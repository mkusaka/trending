<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-01T02:19:05Z</updated>
  <subtitle>Monthly Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>aws-amplify/aws-sdk-ios</title>
    <updated>2023-02-01T02:19:05Z</updated>
    <id>tag:github.com,2023-02-01:/aws-amplify/aws-sdk-ios</id>
    <link href="https://github.com/aws-amplify/aws-sdk-ios" rel="alternate"></link>
    <summary type="html">&lt;p&gt;AWS SDK for iOS. For more information, see our web site:&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;AWS SDK for iOS&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aws-amplify/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/aws/aws-sdk-ios.svg?sanitize=true&#34; alt=&#34;Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/AWSCore&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/AWSCore.svg?sanitize=true&#34; alt=&#34;CocoaPods&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/aws-amplify/aws-sdk-ios&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/aws-amplify/aws-sdk-ios.svg?style=svg&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/jWVbPfC&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/308323056592486420?logo=discord&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The AWS SDK for iOS provides a library and documentation for developers to build connected mobile applications using AWS.&lt;/p&gt; &#xA;&lt;h3&gt;Features / APIs&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aws-amplify.github.io/docs/ios/authentication&#34;&gt;&lt;strong&gt;Authentication&lt;/strong&gt;&lt;/a&gt;: APIs and building blocks for developers who want to create user authentication experiences.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aws-amplify.github.io/docs/ios/analytics&#34;&gt;&lt;strong&gt;Analytics&lt;/strong&gt;&lt;/a&gt;: Easily collect analytics data for your app. Analytics data includes user sessions and other custom events that you want to track in your app.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aws-amplify.github.io/docs/ios/api&#34;&gt;&lt;strong&gt;API&lt;/strong&gt;&lt;/a&gt;: Provides a simple solution when making HTTP requests. It provides an automatic, lightweight signing process which complies with AWS Signature Version 4.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aws-amplify.github.io/docs/ios/storage&#34;&gt;&lt;strong&gt;Storage&lt;/strong&gt;&lt;/a&gt;: Provides a simple mechanism for managing user content for your app in public, protected or private storage buckets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aws-amplify.github.io/docs/ios/push-notifications&#34;&gt;&lt;strong&gt;Push Notifications&lt;/strong&gt;&lt;/a&gt;: Allows you to integrate push notifications in your app with Amazon Pinpoint targeting and campaign management support.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aws-amplify.github.io/docs/ios/pubsub&#34;&gt;&lt;strong&gt;PubSub&lt;/strong&gt;&lt;/a&gt;: Provides connectivity with cloud-based message-oriented middleware.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aws-amplify.github.io/docs/ios/manualsetup&#34;&gt;&lt;strong&gt;Generated AWS Service Interfaces&lt;/strong&gt;&lt;/a&gt;: Provides direct interaction with any AWS service.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Visit our &lt;a href=&#34;https://aws-amplify.github.io&#34;&gt;Web Site&lt;/a&gt; to learn more about Amplify Framework.&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aws-amplify.github.io/docs&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aws-amplify/aws-sdk-ios/main/#setup&#34;&gt;Setup&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/awslabs/aws-sdk-ios-samples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;To get started with the AWS SDK for iOS, check out the &lt;a href=&#34;https://aws-amplify.github.io/docs/ios/start&#34;&gt;Developer Guide for iOS&lt;/a&gt;. You can set up the SDK and start building a new project, or you integrate the SDK in an existing project. You can also run the samples to get a sense of how the SDK works.&lt;/p&gt; &#xA;&lt;p&gt;To use the AWS SDK for iOS, you will need the following installed on your development machine:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Xcode 11.0 or later&lt;/li&gt; &#xA; &lt;li&gt;iOS 9 or later&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Include the SDK for iOS in an Existing Application&lt;/h2&gt; &#xA;&lt;p&gt;We have a couple &lt;a href=&#34;https://github.com/awslabs/aws-sdk-ios-samples&#34;&gt;samples&lt;/a&gt; applications which showcase how to use the AWS SDK for iOS. Please note that the code in these sample applications is not of production quality, and should be considered as exactly what we called them: samples.&lt;/p&gt; &#xA;&lt;p&gt;There are several ways to integrate the AWS Mobile SDK for iOS into your own project:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;Swift Package Manager&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cocoapods.org/&#34;&gt;CocoaPods&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/mobile/sdk/&#34;&gt;Dynamic Frameworks&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You should use ONE and only one of these ways to import the AWS Mobile SDK. Importing the SDK in multiple ways loads duplicate copies of the SDK into the project and causes compiler/linker errors.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: If you are using XCFrameworks (i.e., either Swift Package Manager, Carthage, or Dynamic Frameworks), some modules are named with the &lt;code&gt;XCF&lt;/code&gt; suffix to work around a &lt;a href=&#34;https://bugs.swift.org/browse/SR-11704&#34;&gt;Swift issue&lt;/a&gt;. &lt;code&gt;AWSMobileClient&lt;/code&gt; is named as &lt;code&gt;AWSMobileClientXCF&lt;/code&gt; and &lt;code&gt;AWSLocation&lt;/code&gt; is named as &lt;code&gt;AWSLocationXCF&lt;/code&gt;. To use the &lt;code&gt;AWSMobileClient&lt;/code&gt; or &lt;code&gt;AWSLocation&lt;/code&gt; SDKs, import them as:&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import AWSMobileClientXCF&#xA;import AWSLocationXCF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and use it your app code without the &lt;code&gt;XCF&lt;/code&gt; suffix.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;AWSMobileClient.default().initialize() &#xA;let locationClient = AWSLocation.default()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Swift Package Manager is distributed with Xcode. To start adding the AWS SDK to your iOS project, open your project in Xcode and select &lt;strong&gt;File &amp;gt; Swift Packages &amp;gt; Add Package Dependency&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aws-amplify/aws-sdk-ios/main/readme-images/spm-setup-01-add-package-dependency.png&#34; alt=&#34;Add package dependency&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Enter the URL for the AWS SDK for iOS Swift Package Manager GitHub repo (&lt;code&gt;https://github.com/aws-amplify/aws-sdk-ios-spm&lt;/code&gt;) into the search bar and click &lt;strong&gt;Next&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aws-amplify/aws-sdk-ios/main/readme-images/spm-setup-02-search-amplify-repo.png&#34; alt=&#34;Search for repo&#34;&gt;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; This URL is &lt;em&gt;not&lt;/em&gt; the main URL of the SDK. We maintain the Swift Package Manager manifest (&lt;code&gt;Package.swift&lt;/code&gt;) file for this library in a separate repo so that apps that use the SDK do not have to download the entire source repository in order to consume the binary targets.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You&#39;ll see the repository rules for which version of the SDK you want Swift Package Manager to install. Choose the first rule, &lt;strong&gt;Version&lt;/strong&gt;, and select &lt;strong&gt;Up to Next Minor&lt;/strong&gt; as it will use the latest compatible version of the dependency that can be detected from the &lt;code&gt;main&lt;/code&gt; branch, then click &lt;strong&gt;Next&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aws-amplify/aws-sdk-ios/main/readme-images/spm-setup-03-dependency-version-options.png&#34; alt=&#34;Dependency version options&#34;&gt;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; The AWS Mobile SDK for iOS does &lt;a href=&#34;https://docs.amplify.aws/sdk/configuration/setup-options/q/platform/ios#aws-sdk-version-vs-semantic-versioning&#34;&gt;not use Semantic Versioning&lt;/a&gt;, and may introduce breaking API changes on minor version releases. We recommend setting your &lt;strong&gt;Version&lt;/strong&gt; rule to &lt;strong&gt;Up to Next Minor&lt;/strong&gt; and evaluating minor version releases to ensure they are compatible with your app.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Choose which of the libraries you want added to your project. Always select the &lt;strong&gt;AWSCore&lt;/strong&gt; SDK. The remaining SDKs to install will vary based on which SDK you&#39;re trying to install. Most SDKs rely only on &lt;strong&gt;AWSCore&lt;/strong&gt;, but for a full dependency list, see the &lt;a href=&#34;https://raw.githubusercontent.com/aws-amplify/aws-sdk-ios/main/README-spm-support.md&#34;&gt;README-spm-support file&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Note: AWSLex is not currently supported for the &lt;code&gt;arm64&lt;/code&gt; architecture through Swift Package Manager due to conflicts with a packaged binary dependency.&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aws-amplify/aws-sdk-ios/main/readme-images/spm-setup-04-select-dependencies.png&#34; alt=&#34;Select dependencies&#34;&gt;&lt;/p&gt; &lt;p&gt;Select all that are appropriate, then click &lt;strong&gt;Finish&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;You can always go back and modify which SPM packages are included in your project by opening the Swift Packages tab for your project: Click on the Project file in the Xcode navigator, then click on your project&#39;s icon, then select the &lt;strong&gt;Swift Packages&lt;/strong&gt; tab.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;The AWS Mobile SDK for iOS is available through &lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt;. If you have not installed CocoaPods, install CocoaPods by running the command:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; $ gem install cocoapods&#xA; $ pod setup&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Depending on your system settings, you may have to use &lt;code&gt;sudo&lt;/code&gt; for installing &lt;code&gt;cocoapods&lt;/code&gt; as follows:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; $ sudo gem install cocoapods&#xA; $ pod setup&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In your project directory (the directory where your &lt;code&gt;*.xcodeproj&lt;/code&gt; file is), run the following to create a &lt;code&gt;Podfile&lt;/code&gt; in your project.&lt;/p&gt; &lt;pre&gt;&lt;code&gt; $ pod init&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Edit the podfile to include the pods you want to integrate into your project. For example, if you need auth, you can use AWSMobileClient, and if you need analytics, you add AWSPinpoint. As a result, your podfile might look something like this:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;target &#39;YourTarget&#39; do&#xA;    pod &#39;AWSMobileClient&#39;&#xA;    pod &#39;AWSPinpoint&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a complete list of our pods, check out the .podspec files in the root directory of this project.&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Then run the following command:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; $ pod install --repo-update&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To open your project, open the newly generated &lt;code&gt;*.xcworkspace&lt;/code&gt; file in your project&#39;s directory with XCode. You can do this by issuing the following command in your project folder:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; $ xed .&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Do &lt;strong&gt;NOT&lt;/strong&gt; use &lt;code&gt;*.xcodeproj&lt;/code&gt;. If you open up a project file instead of a workspace, you may receive the following error:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; ld: library not found for -lPods-AWSCore&#xA; clang: error: linker command failed with exit code 1 (use -v to see invocation)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;h4&gt;XCFrameworks (recommended)&lt;/h4&gt; &#xA;&lt;p&gt;Carthage supports XCFrameworks in Xcode 12 or above. Follow the steps below to consume the AWS SDK for iOS using XCFrameworks:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install Carthage 0.37.0 or greater.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add the following to your &lt;code&gt;Cartfile&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; github &#34;aws-amplify/aws-sdk-ios&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Then run the following command:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; $ carthage update --use-xcframeworks --no-use-binaries&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;As of Carthage 0.37.0, prebuilt binaries using XCFrameworks are not supported, as mentioned in the Carthage release notes - &lt;a href=&#34;https://github.com/Carthage/Carthage/releases/tag/0.37.0&#34;&gt;https://github.com/Carthage/Carthage/releases/tag/0.37.0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;On your application targets’ General settings tab, in the Embedded Binaries section, drag and drop each xcframework you want to use from the Carthage/Build folder on disk.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Frameworks with &#34;fat libraries&#34; (not recommended)&lt;/h4&gt; &#xA;&lt;p&gt;To build platform-specific framework bundles with multiple architectures in the binary, (Xcode 11 and below)&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the latest version of &lt;a href=&#34;https://github.com/Carthage/Carthage#installing-carthage&#34;&gt;Carthage&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add the following to your &lt;code&gt;Cartfile&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; github &#34;aws-amplify/aws-sdk-ios&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Then run the following command:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; $ carthage update&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;With your project open in Xcode, select your &lt;strong&gt;Target&lt;/strong&gt;. Under &lt;strong&gt;General&lt;/strong&gt; tab, find &lt;strong&gt;Frameworks, Libraries, and Embedded Content&lt;/strong&gt; and then click the &lt;strong&gt;+&lt;/strong&gt; button.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Click the &lt;strong&gt;Add Other...&lt;/strong&gt; button, then &#34;Add Files...&#34; in the popup menu, then navigate to the &lt;code&gt;AWS&amp;lt;#ServiceName#&amp;gt;.framework&lt;/code&gt; files under &lt;code&gt;Carthage&lt;/code&gt; &amp;gt; &lt;code&gt;Build&lt;/code&gt; &amp;gt; &lt;code&gt;iOS&lt;/code&gt; and select them. Do not check the &lt;strong&gt;Destination: Copy items if needed&lt;/strong&gt; checkbox if prompted. Add the frameworks that you need for you specific use case. For example, if you are using AWSMobileClient and AWSPinpoint, you will want to add the following frameworks:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;AWSAuthCore.framework&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AWSCognitoIdentityProvider.framework&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AWSCognitoIdentityProviderASF.framework&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AWSCore.framework&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AWSMobileClient.framework&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AWSPinpoint.framework&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Under the &lt;strong&gt;Build Phases&lt;/strong&gt; tab in your &lt;strong&gt;Target&lt;/strong&gt;, click the &lt;strong&gt;+&lt;/strong&gt; button on the top left and then select &lt;strong&gt;New Run Script Phase&lt;/strong&gt;. Then setup the build phase as follows. Make sure this phase is below the &lt;code&gt;Embed Frameworks&lt;/code&gt; phase.&lt;/p&gt; &lt;pre&gt;&lt;code&gt; Shell /bin/sh&#xA; &#xA; bash &#34;${BUILT_PRODUCTS_DIR}/${FRAMEWORKS_FOLDER_PATH}/AWSCore.framework/strip-frameworks.sh&#34;&#xA; &#xA; Show environment variables in build log: Checked&#xA; Run script only when installing: Not checked&#xA; &#xA; Input Files: Empty&#xA; Output Files: Empty&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: Currently, the AWS SDK for iOS builds the Carthage binaries using the latest released version of Xcode. To consume the pre-built binaries your Xcode version needs to be the same, else you have to build the frameworks on your machine by passing &lt;code&gt;--no-use-binaries&lt;/code&gt; flag to &lt;code&gt;carthage update&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Frameworks&lt;/h3&gt; &#xA;&lt;h4&gt;XCFramework setup&lt;/h4&gt; &#xA;&lt;p&gt;Starting AWS SDK iOS version 2.22.1, SDK binaries are released as XCFrameworks. Follow the steps below to install XCFramework.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download the &lt;a href=&#34;https://releases.amplify.aws/aws-sdk-ios/latest/aws-ios-sdk.zip&#34;&gt;latest SDK&lt;/a&gt;. Older SDK versions can be downloaded from &lt;code&gt;https://releases.amplify.aws/aws-sdk-ios/aws-ios-sdk-#.#.#.zip&lt;/code&gt;, where &lt;code&gt;#.#.#&lt;/code&gt; represents the version number. So for version 2.23.3, the download link is &lt;a href=&#34;https://releases.amplify.aws/aws-sdk-ios/aws-ios-sdk-2.23.3.zip&#34;&gt;https://releases.amplify.aws/aws-sdk-ios/aws-ios-sdk-2.23.3.zip&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note1: If you are using version &amp;lt; 2.22.1 please refer to the &#34;Legacy framework setup&#34; section below. Note2: To download version &amp;lt; 2.23.3 use this link &lt;code&gt;https://sdk-for-ios.amazonwebservices.com/aws-ios-sdk-#.#.#.zip&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Uncompress the ZIP file&lt;/li&gt; &#xA; &lt;li&gt;On your application targets’ General settings tab, in the Embedded Binaries section, drag and drop each xcframework you want to use from the downloaded folder.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Legacy framework setup&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download the required SDK using &lt;code&gt;https://sdk-for-ios.amazonwebservices.com/aws-ios-sdk-#.#.#.zip&lt;/code&gt;, where &lt;code&gt;#.#.#&lt;/code&gt; represents the version number. So for version 2.10.2, the download link is &lt;a href=&#34;https://sdk-for-ios.amazonwebservices.com/aws-ios-sdk-2.10.2.zip&#34;&gt;https://sdk-for-ios.amazonwebservices.com/aws-ios-sdk-2.10.2.zip&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: If you are using version &amp;gt; 2.22.0 please refer to the &#34;XCFramework setup&#34; section above.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;With your project open in Xcode, select your &lt;strong&gt;Target&lt;/strong&gt;. Under &lt;strong&gt;General&lt;/strong&gt; tab, find &lt;strong&gt;Embedded Binaries&lt;/strong&gt; and then click the &lt;strong&gt;+&lt;/strong&gt; button.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Click the &lt;strong&gt;Add Other...&lt;/strong&gt; button, navigate to the &lt;code&gt;AWS&amp;lt;#ServiceName#&amp;gt;.framework&lt;/code&gt; files and select them. Check the &lt;strong&gt;Destination: Copy items if needed&lt;/strong&gt; checkbox when prompted. Add the frameworks that you need for you specific use case. For example, if you are using AWSMobileClient and AWSPinpoint, you will want to add the following frameworks:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;AWSAuthCore.framework&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AWSCognitoIdentityProvider.framework&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AWSCognitoIdentityProviderASF.framework&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AWSCore.framework&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AWSMobileClient.framework&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AWSPinpoint.framework&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Under the &lt;strong&gt;Build Phases&lt;/strong&gt; tab in your &lt;strong&gt;Target&lt;/strong&gt;, click the &lt;strong&gt;+&lt;/strong&gt; button on the top left and then select &lt;strong&gt;New Run Script Phase&lt;/strong&gt;. Then setup the build phase as follows. Make sure this phase is below the &lt;code&gt;Embed Frameworks&lt;/code&gt; phase.&lt;/p&gt; &lt;pre&gt;&lt;code&gt; Shell /bin/sh&#xA; &#xA; bash &#34;${BUILT_PRODUCTS_DIR}/${FRAMEWORKS_FOLDER_PATH}/AWSCore.framework/strip-frameworks.sh&#34;&#xA; &#xA; Show environment variables in build log: Checked&#xA; Run script only when installing: Not checked&#xA; &#xA; Input Files: Empty&#xA; Output Files: Empty&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Update the SDK to a Newer Version&lt;/h2&gt; &#xA;&lt;p&gt;When we release a new version of the SDK, you can pick up the changes as described below.&lt;/p&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Run the following command in your project directory. CocoaPods automatically picks up the new changes.&lt;/p&gt; &lt;pre&gt;&lt;code&gt; $ pod update&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: If your pod is having an issue, you can delete &lt;code&gt;Podfile.lock&lt;/code&gt; and &lt;code&gt;Pods/&lt;/code&gt; then run &lt;code&gt;pod install&lt;/code&gt; to cleanly install the SDK.&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aws-amplify/aws-sdk-ios/main/readme-images/cocoapods-setup-03.png?raw=true&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Run the following command in your project directory. Carthage automatically picks up the new changes.&lt;/p&gt; &lt;pre&gt;&lt;code&gt; $ carthage update&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Frameworks&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;In Xcode&#39;s &lt;strong&gt;Project Navigator&lt;/strong&gt;, type &#34;AWS&#34; to find the AWS Frameworks or XCFrameworks that you manually added to your project. Select all of the AWS Frameworks and hit &lt;strong&gt;Delete&lt;/strong&gt; on your keyboard. Then select &lt;strong&gt;Move to Trash&lt;/strong&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Follow the installation process above to include the new version of the SDK.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Getting Started with Swift&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Import the AWSCore header in the application delegate.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import AWSCore&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a default service configuration by adding the following code snippet in the &lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt; application delegate method.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let credentialsProvider = AWSCognitoCredentialsProvider(&#xA;    regionType: CognitoRegionType,&#xA;    identityPoolId: CognitoIdentityPoolId)&#xA;let configuration = AWSServiceConfiguration(&#xA;    region: DefaultServiceRegionType,&#xA;    credentialsProvider: credentialsProvider)&#xA;AWSServiceManager.default().defaultServiceConfiguration = configuration&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In Swift file you want to use the SDK, import the appropriate headers for the services you are using. The header file import convention is &lt;code&gt;import AWSServiceName&lt;/code&gt;, as in the following examples:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import AWSS3&#xA;import AWSDynamoDB&#xA;import AWSSQS&#xA;import AWSSNS&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Make a call to the AWS services.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let dynamoDB = AWSDynamoDB.default()&#xA;let listTableInput = AWSDynamoDBListTablesInput()&#xA;dynamoDB.listTables(listTableInput!).continueWith { (task:AWSTask&amp;lt;AWSDynamoDBListTablesOutput&amp;gt;) -&amp;gt; Any? in&#xA;    if let error = task.error as? NSError {&#xA;    print(&#34;Error occurred: \(error)&#34;)&#xA;        return nil&#xA;    }&#xA;&#xA;    let listTablesOutput = task.result&#xA;&#xA;    for tableName in listTablesOutput!.tableNames! {&#xA;        print(&#34;\(tableName)&#34;)&#xA;    }&#xA;&#xA;    return nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Most of the service client classes have a singleton method to get a default client. The naming convention is &lt;code&gt;+ defaultSERVICENAME&lt;/code&gt; (e.g. &lt;code&gt;+ defaultDynamoDB&lt;/code&gt; in the above code snippet). This singleton method creates a service client with &lt;code&gt;defaultServiceConfiguration&lt;/code&gt;, which you set up in step 5, and maintains a strong reference to the client.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started with Objective-C&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Import the AWSCore header in the application delegate.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;@import AWSCore;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a default service configuration by adding the following code snippet in the &lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt; application delegate method.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;AWSCognitoCredentialsProvider *credentialsProvider = [[AWSCognitoCredentialsProvider alloc] initWithRegionType:CognitoRegionType&#xA;                                                                                                identityPoolId:CognitoIdentityPoolId];&#xA;AWSServiceConfiguration *configuration = [[AWSServiceConfiguration alloc] initWithRegion:DefaultServiceRegionType&#xA;                                                                     credentialsProvider:credentialsProvider];&#xA;AWSServiceManager.defaultServiceManager.defaultServiceConfiguration = configuration;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Import the appropriate headers for the services you are using. The header file import convention is &lt;code&gt;@import AWSServiceName;&lt;/code&gt;, as in the following examples:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;@import AWSS3;&#xA;@import AWSDynamoDB;&#xA;@import AWSSQS;&#xA;@import AWSSNS;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Make a call to the AWS services.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;AWSSNS *sns = [AWSSNS defaultSNS];&#xA;AWSSNSListTopicsInput *listTopicsInput = [AWSSNSListTopicsInput new];&#xA;[[sns listTopics:listTopicsInput] continueWithBlock:^id(AWSTask *task) {&#xA;    // Do something with the response&#xA;    return nil;&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Most of the service client classes have a singleton method to get a default client. The naming convention is &lt;code&gt;+ defaultSERVICENAME&lt;/code&gt; (e.g. &lt;code&gt;+ defaultS3SNS&lt;/code&gt; in the above code snippet). This singleton method creates a service client with &lt;code&gt;defaultServiceConfiguration&lt;/code&gt;, which you set up in step 5, and maintains a strong reference to the client.&lt;/p&gt; &#xA;&lt;h2&gt;Working with AWSTask&lt;/h2&gt; &#xA;&lt;p&gt;The SDK returns &lt;code&gt;AWSTask&lt;/code&gt; objects when operating on asynchronous operations to avoid blocking the UI thread.&lt;/p&gt; &#xA;&lt;p&gt;The AWSTask class is a renamed version of BFTask from the Bolts framework. For complete documentation on Bolts, see the &lt;a href=&#34;https://github.com/BoltsFramework/Bolts-ObjC&#34;&gt;Bolts-iOS repo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Logging&lt;/h2&gt; &#xA;&lt;p&gt;As of version 2.5.4 of this SDK, logging utilizes &lt;a href=&#34;https://github.com/CocoaLumberjack/CocoaLumberjack&#34;&gt;CocoaLumberjack&lt;/a&gt;, a flexible, fast, open source logging framework. It supports many capabilities including the ability to set logging level per output target, for instance, concise messages logged to the console and verbose messages to a log file.&lt;/p&gt; &#xA;&lt;p&gt;CocoaLumberjack logging levels are additive such that when the level is set to verbose, all messages from the levels below verbose are logged. It is also possible to set custom logging to meet your needs. For more information, see &lt;a href=&#34;https://github.com/CocoaLumberjack/CocoaLumberjack/raw/master/Documentation/CustomLogLevels.md&#34;&gt;CocoaLumberjack&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Changing Log Levels&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;AWSDDLog.sharedInstance.logLevel = .verbose&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following logging level options are available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;.off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.error&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.warning&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.info&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.debug&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.verbose&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective-C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;[AWSDDLog sharedInstance].logLevel = AWSDDLogLevelVerbose;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following logging level options are available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;AWSDDLogLevelOff&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWSDDLogLevelError&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWSDDLogLevelWarning&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWSDDLogLevelInfo&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWSDDLogLevelDebug&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AWSDDLogLevelVerbose&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We recommend setting the log level to &lt;code&gt;Off&lt;/code&gt; before publishing to the Apple App Store.&lt;/p&gt; &#xA;&lt;h3&gt;Targeting Log Output&lt;/h3&gt; &#xA;&lt;p&gt;CocoaLumberjack can direct logs to file or used as a framework that integrates with the Xcode console.&lt;/p&gt; &#xA;&lt;p&gt;To initialize logging to files, use the following code:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let fileLogger: AWSDDFileLogger = AWSDDFileLogger() // File Logger&#xA;fileLogger.rollingFrequency = TimeInterval(60*60*24)  // 24 hours&#xA;fileLogger.logFileManager.maximumNumberOfLogFiles = 7&#xA;AWSDDLog.add(fileLogger)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective-C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;AWSDDFileLogger *fileLogger = [[AWSDDFileLogger alloc] init]; // File Logger&#xA;fileLogger.rollingFrequency = 60 * 60 * 24; // 24 hour rolling&#xA;fileLogger.logFileManager.maximumNumberOfLogFiles = 7;&#xA;[AWSDDLog addLogger:fileLogger];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To initialize logging to your Xcode console, use the following code:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;AWSDDLog.add(AWSDDTTYLogger.sharedInstance) // TTY = Xcode console&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Objective-C&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;[AWSDDLog addLogger:[AWSDDTTYLogger sharedInstance]]; // TTY = Xcode console&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Open Source Contributions&lt;/h2&gt; &#xA;&lt;p&gt;We welcome any and all contributions from the community! Make sure you read through our contribution guide &lt;a href=&#34;https://raw.githubusercontent.com/aws-amplify/aws-sdk-ios/main/CONTRIBUTING.md&#34;&gt;here&lt;/a&gt; before submitting any PR&#39;s. Thanks! &amp;lt;3&lt;/p&gt; &#xA;&lt;h2&gt;Talk to Us&lt;/h2&gt; &#xA;&lt;p&gt;Visit our GitHub &lt;a href=&#34;https://github.com/aws-amplify/aws-sdk-ios/issues&#34;&gt;Issues&lt;/a&gt; to leave feedback and to connect with other users of the SDK.&lt;/p&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;Amazon Web Services&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;strong&gt;LICENSE&lt;/strong&gt; file for more info.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>SDWebImage/SDWebImageWebPCoder</title>
    <updated>2023-02-01T02:19:05Z</updated>
    <id>tag:github.com,2023-02-01:/SDWebImage/SDWebImageWebPCoder</id>
    <link href="https://github.com/SDWebImage/SDWebImageWebPCoder" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A WebP coder plugin for SDWebImage, use libwebp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SDWebImageWebPCoder&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/SDWebImage/SDWebImageWebPCoder&#34;&gt;&lt;img src=&#34;http://img.shields.io/travis/SDWebImage/SDWebImageWebPCoder.svg?style=flat&#34; alt=&#34;CI Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoapods.org/pods/SDWebImageWebPCoder&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/SDWebImageWebPCoder.svg?style=flat&#34; alt=&#34;Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoapods.org/pods/SDWebImageWebPCoder&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/l/SDWebImageWebPCoder.svg?style=flat&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoapods.org/pods/SDWebImageWebPCoder&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/SDWebImageWebPCoder.svg?style=flat&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/SwiftPM-compatible-brightgreen.svg?style=flat&#34; alt=&#34;SwiftPM compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/SDWebImage/SDWebImageWebPCoder&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/SDWebImage/SDWebImageWebPCoder&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/SDWebImage/SDWebImageWebPCoder/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Starting with the SDWebImage 5.0 version, we moved the WebP support code and &lt;a href=&#34;https://github.com/webmproject/libwebp&#34;&gt;libwebp&lt;/a&gt; from the Core Repo to this stand-alone repo.&lt;/p&gt; &#xA;&lt;p&gt;SDWebImageWebPCoder supports both WebP decoding and encoding, for Static WebP or Animated WebP as well.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iOS 9.0&lt;/li&gt; &#xA; &lt;li&gt;macOS 10.11&lt;/li&gt; &#xA; &lt;li&gt;tvOS 9.0&lt;/li&gt; &#xA; &lt;li&gt;watchOS 2.0&lt;/li&gt; &#xA; &lt;li&gt;Xcode 11.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h4&gt;CocoaPods&lt;/h4&gt; &#xA;&lt;p&gt;SDWebImageWebPCoder is available through &lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt;. To install it, simply add the following line to your Podfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;SDWebImageWebPCoder&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Carthage&lt;/h4&gt; &#xA;&lt;p&gt;SDWebImageWebPCoder is available through &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;SDWebImage/SDWebImageWebPCoder&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Swift Package Manager (Xcode 11+)&lt;/h4&gt; &#xA;&lt;p&gt;SDWebImageWebPCoder is available through &lt;a href=&#34;https://swift.org/package-manager&#34;&gt;Swift Package Manager&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let package = Package(&#xA;    dependencies: [&#xA;        .package(url: &#34;https://github.com/SDWebImage/SDWebImageWebPCoder.git&#34;, from: &#34;0.3.0&#34;)&#xA;    ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Add Coder&lt;/h3&gt; &#xA;&lt;p&gt;Before using SDWebImage to load WebP images, you need to register the WebP Coder to your coders manager. This step is recommended to be done after your App launch (like AppDelegate method).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-C&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// Add coder&#xA;SDImageWebPCoder *webPCoder = [SDImageWebPCoder sharedCoder];&#xA;[[SDImageCodersManager sharedManager] addCoder:webPCoder];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Add coder&#xA;let WebPCoder = SDImageWebPCoder.shared&#xA;SDImageCodersManager.shared.addCoder(WebPCoder)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Modify HTTP Accept Header&lt;/h3&gt; &#xA;&lt;p&gt;Some of image server provider may try to detect the client supported format, by default, SDWebImage use &lt;code&gt;image/*,*/*;q=0.8&lt;/code&gt; for &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept&#34;&gt;Accept&lt;/a&gt;. You can modify it with the &lt;code&gt;image/webp&lt;/code&gt; as well.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-C&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;[[SDWebImageDownloader sharedDownloader] setValue:@&#34;image/webp,image/*,*/*;q=0.8&#34; forHTTPHeaderField:@&#34;Accept&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;SDWebImageDownloader.shared.setValue(&#34;image/webp,image/*,*/*;q=0.8&#34;, forHTTPHeaderField:&#34;Accept&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Loading&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-C&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// WebP online image loading&#xA;NSURL *webpURL;&#xA;UIImageView *imageView;&#xA;[imageView sd_setImageWithURL:webpURL];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// WebP online image loading&#xA;let webpURL: URL&#xA;let imageView: UIImageView&#xA;imageView.sd_setImage(with: webpURL)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Progressive Animation Loading (0.5.0+)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-C&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// WebP progressive loading for animated image&#xA;NSURL *webpURL;&#xA;SDAnimatedImageView *imageView;&#xA;imageView.shouldIncrementalLoad = YES;&#xA;[imageView sd_setImageWithURL:webpURL placeholderImage:nil options:SDWebImageProgressiveLoad];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// WebP progressive loading for animated image&#xA;let webpURL: URL&#xA;let imageView: SDAnimatedImageView&#xA;imageView.shouldIncrementalLoad = true&#xA;imageView.sd_setImage(with: webpURL, placeholderImage: nil, options: [.progressiveLoad])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Decoding&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-C&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// WebP image decoding&#xA;NSData *webpData;&#xA;UIImage *image = [[SDImageWebPCoder sharedCoder] decodedImageWithData:webpData options:nil];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// WebP image decoding&#xA;let webpData: Data&#xA;let image = SDImageWebPCoder.shared.decodedImage(with: data, options: nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Thumbnail Decoding (0.4.0+)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-C&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// WebP thumbnail image decoding&#xA;NSData *webpData;&#xA;CGSize thumbnailSize = CGSizeMake(300, 300);&#xA;UIImage *thumbnailImage = [[SDImageWebPCoder sharedCoder] decodedImageWithData:webpData options:@{SDImageCoderDecodeThumbnailPixelSize : @(thumbnailSize)}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// WebP thumbnail image decoding&#xA;let webpData: Data&#xA;let thumbnailSize = CGSize(width: 300, height: 300)&#xA;let image = SDImageWebPCoder.shared.decodedImage(with: data, options: [.decodeThumbnailPixelSize: thumbnailSize])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Encoding&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-c&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// WebP image encoding&#xA;UIImage *image;&#xA;NSData *webpData = [[SDImageWebPCoder sharedCoder] encodedDataWithImage:image format:SDImageFormatWebP options:nil];&#xA;// Animated encoding&#xA;NSArray&amp;lt;SDImageFrames *&amp;gt; *frames;&#xA;NSData *awebpData = [[SDImageWebPCoder sharedCoder] encodedDataWithFrames:frames loopCount:0 format:SDImageFormatWebP options:nil];&#xA;// Encode Quality&#xA;NSData *lossyWebpData = [[SDImageWebPCoder sharedCoder] encodedDataWithImage:image format:SDImageFormatWebP options:@{SDImageCoderEncodeCompressionQuality : @(0.1)}]; // [0, 1] compression quality&#xA;NSData *limitedWebpData = [[SDImageWebPCoder sharedCoder] encodedDataWithImage:image format:SDImageFormatWebP options:@{SDImageCoderEncodeMaxFileSize : @(1024 * 10)}]; // v0.6.0 feature, limit output file size &amp;lt;= 10KB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// WebP image encoding&#xA;let image: UIImage&#xA;let webpData = SDImageWebPCoder.shared.encodedData(with: image, format: .webP, options: nil)&#xA;// Animated encoding&#xA;let frames: [SDImageFrame]&#xA;let awebpData = SDImageWebPCoder.shared.encodedData(with: frames, loopCount: 0, format: .webP, options: nil)&#xA;// Encode Quality&#xA;let lossyWebpData = SDImageWebPCoder.shared.encodedData(with: image, format: .webP, options: [.encodeCompressionQuality: 0.1]) // [0, 1] compression quality&#xA;let limitedWebpData = SDImageWebPCoder.shared.encodedData(with: image, format: .webP, options: [.encodeMaxFileSize: 1024 * 10]) // v0.6.0 feature, limit output file size &amp;lt;= 10KB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Thumbnail Encoding (0.6.1+)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-C&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// WebP image thumbnail encoding&#xA;UIImage *image;&#xA;NSData *thumbnailWebpData = [[SDImageWebPCoder sharedCoder] encodedDataWithImage:image format:SDImageFormatWebP options:@{SDImageCoderEncodeMaxPixelSize : @(CGSizeMake(200, 200))}]; // v0.6.1 feature, encoding max pixel size&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// WebP image thumbnail encoding&#xA;let image: UIImage&#xA;let thumbnailWebpData = SDImageWebPCoder.shared.encodedData(with: image, format: .webP, options: [.encodeMaxPixelSize: CGSize(width: 200, height: 200)]) // v0.6.1 feature, encoding max pixel size&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See more documentation in &lt;a href=&#34;https://github.com/SDWebImage/SDWebImage/wiki/Advanced-Usage#custom-coder-420&#34;&gt;SDWebImage Wiki - Coders&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Animated WebP Encoding (0.10+)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-c&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// Animated encoding&#xA;NSMutableArray&amp;lt;SDImageFrames *&amp;gt; *frames = [NSMutableArray array];&#xA;for (size_t i = 0; i &amp;lt; images.count; i++) {&#xA;    SDImageFrame *frame = [SDImageFrame frameWithImage:images[i] duration:0.1];&#xA;    [frames appendObject:frame];&#xA;}&#xA;NSData *awebpData = [[SDImageWebPCoder sharedCoder] encodedDataWithFrames:frames loopCount:0 format:SDImageFormatWebP options:nil];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Animated encoding&#xA;var frames: [SDImageFrame] = []&#xA;for i in 0..&amp;lt;images.count {&#xA;    let frame = SDImageFrame(image: images[i], duration: 0.1)&#xA;    frames.append(frame)&#xA;}&#xA;let awebpData = SDImageWebPCoder.shared.encodedData(with: frames, loopCount: 0, format: .webP, options: nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Advanced WebP codec options (0.8+)&lt;/h3&gt; &#xA;&lt;p&gt;The WebP codec &lt;a href=&#34;https://developers.google.com/speed/webp/docs/api&#34;&gt;libwebp&lt;/a&gt; we use, supports some advanced control options for encoding/decoding. You can pass them to libwebp by using the wrapper top level API:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-C&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;UIImage *image;&#xA;SDImageCoderOptions *options = @{SDImageCoderEncodeWebPMethod: @(0), SDImageCoderEncodeWebPAlphaCompression: @(100)};&#xA;NSData *data = [SDImageWebPCoder.sharedCoder encodedDataWithImage:image format:SDImageFormatWebP options:options];&#xA;// Will translate into:&#xA;// config-&amp;gt;method = 0;&#xA;// config-&amp;gt;alpha_quality = 100;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let image: UIImage&#xA;let options = [.encodeWebPMethod: 0, .encodeWebPAlphaCompression: 100]&#xA;let data = SDImageWebPCoder.shared.encodedData(with: image, format: .webP, options: options)&#xA;// Will translate into:&#xA;// config-&amp;gt;method = 0;&#xA;// config-&amp;gt;alpha_quality = 100;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;To run the example project, clone the repo, and run &lt;code&gt;pod install&lt;/code&gt; from the root directory first. Then open &lt;code&gt;SDWebImageWebPCoder.xcworkspace&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is a demo to show how to use &lt;code&gt;WebP&lt;/code&gt; and animated &lt;code&gt;WebP&lt;/code&gt; images via &lt;code&gt;SDWebImageWebPCoderExample&lt;/code&gt; target.&lt;/p&gt; &#xA;&lt;h2&gt;Screenshot&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/SDWebImage/SDWebImageWebPCoder/master/Example/Screenshot/WebPDemo.png&#34; width=&#34;300&#34;&gt; &#xA;&lt;p&gt;These WebP images are from &lt;a href=&#34;https://developers.google.com/speed/webp/gallery1&#34;&gt;WebP Gallery&lt;/a&gt; and &lt;a href=&#34;http://littlesvr.ca/apng/gif_apng_webp.html&#34;&gt;GIF vs APNG vs WebP&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/bpoplauschi&#34;&gt;Bogdan Poplauschi&lt;/a&gt; &lt;a href=&#34;https://github.com/dreampiggy&#34;&gt;DreamPiggy&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;SDWebImageWebPCoder is available under the MIT license. See &lt;a href=&#34;https://github.com/SDWebImage/SDWebImageWebPCoder/raw/master/LICENSE&#34;&gt;the LICENSE file&lt;/a&gt; for more info.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>openid/AppAuth-iOS</title>
    <updated>2023-02-01T02:19:05Z</updated>
    <id>tag:github.com,2023-02-01:/openid/AppAuth-iOS</id>
    <link href="https://github.com/openid/AppAuth-iOS" rel="alternate"></link>
    <summary type="html">&lt;p&gt;iOS and macOS SDK for communicating with OAuth 2.0 and OpenID Connect providers.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://rawgit.com/openid/AppAuth-iOS/master/appauth_lockup.svg?sanitize=true&#34; alt=&#34;AppAuth for iOS and macOS&#34;&gt; &lt;a href=&#34;https://github.com/openid/AppAuth-iOS/actions/workflows/tests.yml&#34;&gt;&lt;img src=&#34;https://github.com/openid/AppAuth-iOS/actions/workflows/tests.yml/badge.svg?event=push&#34; alt=&#34;tests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/openid/AppAuth-iOS&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/openid/AppAuth-iOS/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-brightgreen.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swift.org/package-manager&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/SwiftPM-compatible-brightgreen.svg?style=flat&#34; alt=&#34;SwiftPM compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/AppAuth&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/AppAuth.svg?style=flat&#34; alt=&#34;Pod Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/openid/AppAuth-iOS/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/l/AppAuth.svg?style=flat&#34; alt=&#34;Pod License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/AppAuth&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/AppAuth.svg?style=flat&#34; alt=&#34;Pod Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://developer.apple.com/documentation/xcode/creating_a_mac_version_of_your_ipad_app&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Catalyst-compatible-brightgreen.svg?style=flat&#34; alt=&#34;Catalyst compatible&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;AppAuth for iOS and macOS, and tvOS is a client SDK for communicating with &lt;a href=&#34;https://tools.ietf.org/html/rfc6749&#34;&gt;OAuth 2.0&lt;/a&gt; and &lt;a href=&#34;http://openid.net/specs/openid-connect-core-1_0.html&#34;&gt;OpenID Connect&lt;/a&gt; providers. It strives to directly map the requests and responses of those specifications, while following the idiomatic style of the implementation language. In addition to mapping the raw protocol flows, convenience methods are available to assist with common tasks like performing an action with fresh tokens.&lt;/p&gt; &#xA;&lt;p&gt;It follows the best practices set out in &lt;a href=&#34;https://tools.ietf.org/html/rfc8252&#34;&gt;RFC 8252&amp;nbsp;- OAuth 2.0 for Native Apps&lt;/a&gt; including using &lt;code&gt;SFAuthenticationSession&lt;/code&gt; and &lt;code&gt;SFSafariViewController&lt;/code&gt; on iOS for the auth request. &lt;code&gt;UIWebView&lt;/code&gt; and &lt;code&gt;WKWebView&lt;/code&gt; are explicitly &lt;em&gt;not&lt;/em&gt; supported due to the security and usability reasons explained in &lt;a href=&#34;https://tools.ietf.org/html/rfc8252#section-8.12&#34;&gt;Section 8.12 of RFC 8252&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It also supports the &lt;a href=&#34;https://tools.ietf.org/html/rfc7636&#34;&gt;PKCE&lt;/a&gt; extension to OAuth, which was created to secure authorization codes in public clients when custom URI scheme redirects are used. The library is friendly to other extensions (standard or otherwise), with the ability to handle additional params in all protocol requests and responses.&lt;/p&gt; &#xA;&lt;p&gt;For tvOS, AppAuth implements &lt;a href=&#34;https://tools.ietf.org/html/rfc8628&#34;&gt;OAuth 2.0 Device Authorization Grant &lt;/a&gt; to allow for tvOS sign-ins through a secondary device.&lt;/p&gt; &#xA;&lt;h2&gt;Specification&lt;/h2&gt; &#xA;&lt;h3&gt;iOS&lt;/h3&gt; &#xA;&lt;h4&gt;Supported Versions&lt;/h4&gt; &#xA;&lt;p&gt;AppAuth supports iOS 7 and above.&lt;/p&gt; &#xA;&lt;p&gt;iOS 9+ uses the in-app browser tab pattern (via &lt;code&gt;SFSafariViewController&lt;/code&gt;), and falls back to the system browser (mobile Safari) on earlier versions.&lt;/p&gt; &#xA;&lt;h4&gt;Authorization Server Requirements&lt;/h4&gt; &#xA;&lt;p&gt;Both Custom URI Schemes (all supported versions of iOS) and Universal Links (iOS 9+) can be used with the library.&lt;/p&gt; &#xA;&lt;p&gt;In general, AppAuth can work with any authorization server that supports native apps, as documented in &lt;a href=&#34;https://tools.ietf.org/html/rfc8252&#34;&gt;RFC 8252&lt;/a&gt;, either through custom URI scheme redirects, or universal links. Authorization servers that assume all clients are web-based, or require clients to maintain confidentiality of the client secrets may not work well.&lt;/p&gt; &#xA;&lt;h3&gt;macOS&lt;/h3&gt; &#xA;&lt;h4&gt;Supported Versions&lt;/h4&gt; &#xA;&lt;p&gt;AppAuth supports macOS (OS X) 10.9 and above.&lt;/p&gt; &#xA;&lt;h4&gt;Authorization Server Requirements&lt;/h4&gt; &#xA;&lt;p&gt;AppAuth for macOS supports both custom schemes; a loopback HTTP redirects via a small embedded server.&lt;/p&gt; &#xA;&lt;p&gt;In general, AppAuth can work with any authorization server that supports native apps, as documented in &lt;a href=&#34;https://tools.ietf.org/html/rfc8252&#34;&gt;RFC 8252&lt;/a&gt;; either through custom URI schemes, or loopback HTTP redirects. Authorization servers that assume all clients are web-based, or require clients to maintain confidentiality of the client secrets may not work well.&lt;/p&gt; &#xA;&lt;h3&gt;tvOS&lt;/h3&gt; &#xA;&lt;h4&gt;Supported Versions&lt;/h4&gt; &#xA;&lt;p&gt;AppAuth supports tvOS 9.0 and above. Please note that while it is possible to run the standard AppAuth library on tvOS, the documentation below describes implementing &lt;a href=&#34;https://tools.ietf.org/html/rfc8628&#34;&gt;OAuth 2.0 Device Authorization Grant&lt;/a&gt; (AppAuthTV).&lt;/p&gt; &#xA;&lt;h4&gt;Authorization Server Requirements&lt;/h4&gt; &#xA;&lt;p&gt;AppAuthTV is designed for servers that support the device authorization flow as documented in &lt;a href=&#34;https://tools.ietf.org/html/rfc8628&#34;&gt;RFC 8628&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Try&lt;/h2&gt; &#xA;&lt;p&gt;Want to try out AppAuth? Just run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod try AppAuth&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Follow the instructions in &lt;a href=&#34;https://raw.githubusercontent.com/openid/AppAuth-iOS/master/Examples/README.md&#34;&gt;Examples/README.md&lt;/a&gt; to configure with your own OAuth client (you need to update three configuration points with your client info to try the demo).&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;AppAuth supports four options for dependency management.&lt;/p&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://guides.cocoapods.org/using/getting-started.html&#34;&gt;CocoaPods&lt;/a&gt;, add the following line to your &lt;code&gt;Podfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod &#39;AppAuth&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, run &lt;code&gt;pod install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;tvOS:&lt;/strong&gt; Use the &lt;code&gt;TV&lt;/code&gt; subspec:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod &#39;AppAuth/TV&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://swift.org/package-manager&#34;&gt;Swift Package Manager&lt;/a&gt;, add the following &lt;code&gt;dependency&lt;/code&gt; to your &lt;code&gt;Package.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/openid/AppAuth-iOS.git&#34;, .upToNextMajor(from: &#34;1.3.0&#34;))&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;tvOS:&lt;/strong&gt; Use the &lt;code&gt;AppAuthTV&lt;/code&gt; target.&lt;/p&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;, add the following line to your &lt;code&gt;Cartfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;openid/AppAuth-iOS&#34; &#34;master&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, run &lt;code&gt;carthage bootstrap&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;tvOS:&lt;/strong&gt; Use the &lt;code&gt;AppAuthTV&lt;/code&gt; framework.&lt;/p&gt; &#xA;&lt;h3&gt;Static Library&lt;/h3&gt; &#xA;&lt;p&gt;You can also use AppAuth as a static library. This requires linking the library and your project, and including the headers. Here is a suggested configuration:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create an Xcode Workspace.&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;AppAuth.xcodeproj&lt;/code&gt; to your Workspace.&lt;/li&gt; &#xA; &lt;li&gt;Include libAppAuth as a linked library for your target (in the &#34;General -&amp;gt; Linked Framework and Libraries&#34; section of your target).&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;AppAuth-iOS/Source&lt;/code&gt; to your search paths of your target (&#34;Build Settings -&amp;gt; &#34;Header Search Paths&#34;).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: There is no static library for AppAuthTV.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Auth Flow&lt;/h2&gt; &#xA;&lt;p&gt;AppAuth supports both manual interaction with the authorization server where you need to perform your own token exchanges, as well as convenience methods that perform some of this logic for you. This example uses the convenience method, which returns either an &lt;code&gt;OIDAuthState&lt;/code&gt; object, or an error.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;OIDAuthState&lt;/code&gt; is a class that keeps track of the authorization and token requests and responses, and provides a convenience method to call an API with fresh tokens. This is the only object that you need to serialize to retain the authorization state of the session.&lt;/p&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;You can configure AppAuth by specifying the endpoints directly:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSURL *authorizationEndpoint =&#xA;    [NSURL URLWithString:@&#34;https://accounts.google.com/o/oauth2/v2/auth&#34;];&#xA;NSURL *tokenEndpoint =&#xA;    [NSURL URLWithString:@&#34;https://www.googleapis.com/oauth2/v4/token&#34;];&#xA;&#xA;OIDServiceConfiguration *configuration =&#xA;    [[OIDServiceConfiguration alloc]&#xA;        initWithAuthorizationEndpoint:authorizationEndpoint&#xA;                        tokenEndpoint:tokenEndpoint];&#xA;&#xA;// perform the auth request...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let authorizationEndpoint = URL(string: &#34;https://accounts.google.com/o/oauth2/v2/auth&#34;)!&#xA;let tokenEndpoint = URL(string: &#34;https://www.googleapis.com/oauth2/v4/token&#34;)!&#xA;let configuration = OIDServiceConfiguration(authorizationEndpoint: authorizationEndpoint,&#xA;                                            tokenEndpoint: tokenEndpoint)&#xA;&#xA;// perform the auth request...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;tvOS&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSURL *deviceAuthorizationEndpoint =&#xA;    [NSURL URLWithString:@&#34;https://oauth2.googleapis.com/device/code&#34;];&#xA;NSURL *tokenEndpoint =&#xA;    [NSURL URLWithString:@&#34;https://www.googleapis.com/oauth2/v4/token&#34;];&#xA;&#xA;OIDTVServiceConfiguration *configuration =&#xA;    [[OIDTVServiceConfiguration alloc]&#xA;        initWithDeviceAuthorizationEndpoint:deviceAuthorizationEndpoint&#xA;                              tokenEndpoint:tokenEndpoint];&#xA;&#xA;// perform the auth request...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or through discovery:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSURL *issuer = [NSURL URLWithString:@&#34;https://accounts.google.com&#34;];&#xA;&#xA;[OIDAuthorizationService discoverServiceConfigurationForIssuer:issuer&#xA;    completion:^(OIDServiceConfiguration *_Nullable configuration,&#xA;                 NSError *_Nullable error) {&#xA;&#xA;  if (!configuration) {&#xA;    NSLog(@&#34;Error retrieving discovery document: %@&#34;,&#xA;          [error localizedDescription]);&#xA;    return;&#xA;  }&#xA;&#xA;  // perform the auth request...&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let issuer = URL(string: &#34;https://accounts.google.com&#34;)!&#xA;&#xA;// discovers endpoints&#xA;OIDAuthorizationService.discoverConfiguration(forIssuer: issuer) { configuration, error in&#xA;  guard let config = configuration else {&#xA;    print(&#34;Error retrieving discovery document: \(error?.localizedDescription ?? &#34;Unknown error&#34;)&#34;)&#xA;    return&#xA;  }&#xA;&#xA;  // perform the auth request...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;tvOS&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSURL *issuer = [NSURL URLWithString:@&#34;https://accounts.google.com&#34;];&#xA;&#xA;[OIDTVAuthorizationService discoverServiceConfigurationForIssuer:issuer&#xA;    completion:^(OIDTVServiceConfiguration *_Nullable configuration,&#xA;                 NSError *_Nullable error) {&#xA;&#xA;  if (!configuration) {&#xA;    NSLog(@&#34;Error retrieving discovery document: %@&#34;,&#xA;          [error localizedDescription]);&#xA;    return;&#xA;  }&#xA;&#xA;  // perform the auth request...&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Authorizing –&amp;nbsp;iOS&lt;/h3&gt; &#xA;&lt;p&gt;First, you need to have a property in your &lt;code&gt;UIApplicationDelegate&lt;/code&gt; implementation to hold the session, in order to continue the authorization flow from the redirect. In this example, the implementation of this delegate is a class named &lt;code&gt;AppDelegate&lt;/code&gt;, if your app&#39;s application delegate has a different name, please update the class name in samples below accordingly.&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@interface AppDelegate : UIResponder &amp;lt;UIApplicationDelegate&amp;gt;&#xA;// property of the app&#39;s AppDelegate&#xA;@property(nonatomic, strong, nullable) id&amp;lt;OIDExternalUserAgentSession&amp;gt; currentAuthorizationFlow;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class AppDelegate: UIResponder, UIApplicationDelegate {&#xA;  // property of the app&#39;s AppDelegate&#xA;  var currentAuthorizationFlow: OIDExternalUserAgentSession?&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And your main class, a property to store the auth state:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// property of the containing class&#xA;@property(nonatomic, strong, nullable) OIDAuthState *authState;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// property of the containing class&#xA;private var authState: OIDAuthState?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, initiate the authorization request. By using the &lt;code&gt;authStateByPresentingAuthorizationRequest&lt;/code&gt; convenience method, the token exchange will be performed automatically, and everything will be protected with PKCE (if the server supports it). AppAuth also lets you perform these requests manually. See the &lt;code&gt;authNoCodeExchange&lt;/code&gt; method in the included Example app for a demonstration:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// builds authentication request&#xA;OIDAuthorizationRequest *request =&#xA;    [[OIDAuthorizationRequest alloc] initWithConfiguration:configuration&#xA;                                                  clientId:kClientID&#xA;                                                    scopes:@[OIDScopeOpenID,&#xA;                                                             OIDScopeProfile]&#xA;                                               redirectURL:kRedirectURI&#xA;                                              responseType:OIDResponseTypeCode&#xA;                                      additionalParameters:nil];&#xA;&#xA;// performs authentication request&#xA;AppDelegate *appDelegate =&#xA;    (AppDelegate *)[UIApplication sharedApplication].delegate;&#xA;appDelegate.currentAuthorizationFlow =&#xA;    [OIDAuthState authStateByPresentingAuthorizationRequest:request&#xA;        presentingViewController:self&#xA;                        callback:^(OIDAuthState *_Nullable authState,&#xA;                                   NSError *_Nullable error) {&#xA;  if (authState) {&#xA;    NSLog(@&#34;Got authorization tokens. Access token: %@&#34;,&#xA;          authState.lastTokenResponse.accessToken);&#xA;    [self setAuthState:authState];&#xA;  } else {&#xA;    NSLog(@&#34;Authorization error: %@&#34;, [error localizedDescription]);&#xA;    [self setAuthState:nil];&#xA;  }&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// builds authentication request&#xA;let request = OIDAuthorizationRequest(configuration: configuration,&#xA;                                      clientId: clientID,&#xA;                                      clientSecret: clientSecret,&#xA;                                      scopes: [OIDScopeOpenID, OIDScopeProfile],&#xA;                                      redirectURL: redirectURI,&#xA;                                      responseType: OIDResponseTypeCode,&#xA;                                      additionalParameters: nil)&#xA;&#xA;// performs authentication request&#xA;print(&#34;Initiating authorization request with scope: \(request.scope ?? &#34;nil&#34;)&#34;)&#xA;&#xA;let appDelegate = UIApplication.shared.delegate as! AppDelegate&#xA;&#xA;appDelegate.currentAuthorizationFlow =&#xA;    OIDAuthState.authState(byPresenting: request, presenting: self) { authState, error in&#xA;  if let authState = authState {&#xA;    self.setAuthState(authState)&#xA;    print(&#34;Got authorization tokens. Access token: &#34; +&#xA;          &#34;\(authState.lastTokenResponse?.accessToken ?? &#34;nil&#34;)&#34;)&#xA;  } else {&#xA;    print(&#34;Authorization error: \(error?.localizedDescription ?? &#34;Unknown error&#34;)&#34;)&#xA;    self.setAuthState(nil)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Handling the Redirect&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;The authorization response URL is returned to the app via the iOS openURL app delegate method, so you need to pipe this through to the current authorization session (created in the previous session):&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (BOOL)application:(UIApplication *)app&#xA;            openURL:(NSURL *)url&#xA;            options:(NSDictionary&amp;lt;NSString *, id&amp;gt; *)options {&#xA;  // Sends the URL to the current authorization flow (if any) which will&#xA;  // process it if it relates to an authorization response.&#xA;  if ([_currentAuthorizationFlow resumeExternalUserAgentFlowWithURL:url]) {&#xA;    _currentAuthorizationFlow = nil;&#xA;    return YES;&#xA;  }&#xA;&#xA;  // Your additional URL handling (if any) goes here.&#xA;&#xA;  return NO;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func application(_ app: UIApplication,&#xA;                 open url: URL,&#xA;                 options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -&amp;gt; Bool {&#xA;  // Sends the URL to the current authorization flow (if any) which will&#xA;  // process it if it relates to an authorization response.&#xA;  if let authorizationFlow = self.currentAuthorizationFlow,&#xA;                             authorizationFlow.resumeExternalUserAgentFlow(with: url) {&#xA;    self.currentAuthorizationFlow = nil&#xA;    return true&#xA;  }&#xA;&#xA;  // Your additional URL handling (if any)&#xA;&#xA;  return false&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Authorizing –&amp;nbsp;MacOS&lt;/h3&gt; &#xA;&lt;p&gt;On macOS, the most popular way to get the authorization response redirect is to start a local HTTP server on the loopback interface (limited to incoming requests from the user&#39;s machine only). When the authorization is complete, the user is redirected to that local server, and the authorization response can be processed by the app. AppAuth takes care of managing the local HTTP server lifecycle for you.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;h4&gt;&lt;span&gt;💡&lt;/span&gt; Alternative: Custom URI Schemes&lt;/h4&gt; &#xA; &lt;p&gt;Custom URI schemes are also supported on macOS, but some browsers display an interstitial, which reduces the usability. For an example on using custom URI schemes with macOS, See &lt;code&gt;Example-Mac&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To receive the authorization response using a local HTTP server, first you need to have an instance variable in your main class to retain the HTTP redirect handler:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;OIDRedirectHTTPHandler *_redirectHTTPHandler;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, as the port used by the local HTTP server varies, you need to start it before building the authorization request, in order to get the exact redirect URI to use:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const kSuccessURLString =&#xA;    @&#34;http://openid.github.io/AppAuth-iOS/redirect/&#34;;&#xA;NSURL *successURL = [NSURL URLWithString:kSuccessURLString];&#xA;&#xA;// Starts a loopback HTTP redirect listener to receive the code.  This needs to be started first,&#xA;// as the exact redirect URI (including port) must be passed in the authorization request.&#xA;_redirectHTTPHandler = [[OIDRedirectHTTPHandler alloc] initWithSuccessURL:successURL];&#xA;NSURL *redirectURI = [_redirectHTTPHandler startHTTPListener:nil];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, initiate the authorization request. By using the &lt;code&gt;authStateByPresentingAuthorizationRequest&lt;/code&gt; convenience method, the token exchange will be performed automatically, and everything will be protected with PKCE (if the server supports it). By assigning the return value to the &lt;code&gt;OIDRedirectHTTPHandler&lt;/code&gt;&#39;s &lt;code&gt;currentAuthorizationFlow&lt;/code&gt;, the authorization will continue automatically once the user makes their choice:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// builds authentication request&#xA;OIDAuthorizationRequest *request =&#xA;    [[OIDAuthorizationRequest alloc] initWithConfiguration:configuration&#xA;                                                  clientId:kClientID&#xA;                                              clientSecret:kClientSecret&#xA;                                                    scopes:@[ OIDScopeOpenID ]&#xA;                                               redirectURL:redirectURI&#xA;                                              responseType:OIDResponseTypeCode&#xA;                                      additionalParameters:nil];&#xA;// performs authentication request&#xA;__weak __typeof(self) weakSelf = self;&#xA;_redirectHTTPHandler.currentAuthorizationFlow =&#xA;    [OIDAuthState authStateByPresentingAuthorizationRequest:request&#xA;                        callback:^(OIDAuthState *_Nullable authState,&#xA;                                   NSError *_Nullable error) {&#xA;  // Brings this app to the foreground.&#xA;  [[NSRunningApplication currentApplication]&#xA;      activateWithOptions:(NSApplicationActivateAllWindows |&#xA;                           NSApplicationActivateIgnoringOtherApps)];&#xA;&#xA;  // Processes the authorization response.&#xA;  if (authState) {&#xA;    NSLog(@&#34;Got authorization tokens. Access token: %@&#34;,&#xA;          authState.lastTokenResponse.accessToken);&#xA;  } else {&#xA;    NSLog(@&#34;Authorization error: %@&#34;, error.localizedDescription);&#xA;  }&#xA;  [weakSelf setAuthState:authState];&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Authorizing –&amp;nbsp;tvOS&lt;/h3&gt; &#xA;&lt;p&gt;Ensure that your main class is a delegate of &lt;code&gt;OIDAuthStateChangeDelegate&lt;/code&gt;, &lt;code&gt;OIDAuthStateErrorDelegate&lt;/code&gt;, implement the corresponding methods, and include the following property and instance variable:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// property of the containing class&#xA;@property(nonatomic, strong, nullable) OIDAuthState *authState;&#xA;&#xA;// instance variable of the containing class&#xA;OIDTVAuthorizationCancelBlock _cancelBlock;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, build and perform the authorization request.&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// builds authentication request&#xA;__weak __typeof(self) weakSelf = self;&#xA;&#xA;OIDTVAuthorizationRequest *request =&#xA;    [[OIDTVAuthorizationRequest alloc] initWithConfiguration:configuration&#xA;                                                    clientId:kClientID&#xA;                                                clientSecret:kClientSecret&#xA;                                                      scopes:@[ OIDScopeOpenID, OIDScopeProfile ]&#xA;                                        additionalParameters:nil];&#xA;&#xA;// performs authentication request&#xA;OIDTVAuthorizationInitialization initBlock =&#xA;    ^(OIDTVAuthorizationResponse *_Nullable response, NSError *_Nullable error) {&#xA;      if (response) {&#xA;        // process authorization response&#xA;        NSLog(@&#34;Got authorization response: %@&#34;, response);&#xA;      } else {&#xA;        // handle initialization error&#xA;        NSLog(@&#34;Error: %@&#34;, error);&#xA;      }&#xA;    };&#xA;&#xA;OIDTVAuthorizationCompletion completionBlock =&#xA;    ^(OIDAuthState *_Nullable authState, NSError *_Nullable error) {&#xA;      weakSelf.signInView.hidden = YES;&#xA;      if (authState) {&#xA;        NSLog(@&#34;Token response: %@&#34;, authState.lastTokenResponse);&#xA;        [weakSelf setAuthState:authState];&#xA;      } else {&#xA;        NSLog(@&#34;Error: %@&#34;, error);&#xA;        [weakSelf setAuthState:nil];&#xA;      }&#xA;    };&#xA;&#xA;_cancelBlock = [OIDTVAuthorizationService authorizeTVRequest:request&#xA;                                              initialization:initBlock&#xA;                                                  completion:completionBlock];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Making API Calls&lt;/h3&gt; &#xA;&lt;p&gt;AppAuth gives you the raw token information, if you need it. However, we recommend that users of the &lt;code&gt;OIDAuthState&lt;/code&gt; convenience wrapper use the provided &lt;code&gt;performActionWithFreshTokens:&lt;/code&gt; method to perform their API calls to avoid needing to worry about token freshness:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[_authState performActionWithFreshTokens:^(NSString *_Nonnull accessToken,&#xA;                                           NSString *_Nonnull idToken,&#xA;                                           NSError *_Nullable error) {&#xA;  if (error) {&#xA;    NSLog(@&#34;Error fetching fresh tokens: %@&#34;, [error localizedDescription]);&#xA;    return;&#xA;  }&#xA;&#xA;  // perform your API request using the tokens&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let userinfoEndpoint = URL(string:&#34;https://openidconnect.googleapis.com/v1/userinfo&#34;)!&#xA;self.authState?.performAction() { (accessToken, idToken, error) in&#xA;&#xA;  if error != nil  {&#xA;    print(&#34;Error fetching fresh tokens: \(error?.localizedDescription ?? &#34;Unknown error&#34;)&#34;)&#xA;    return&#xA;  }&#xA;  guard let accessToken = accessToken else {&#xA;    return&#xA;  }&#xA;&#xA;  // Add Bearer token to request&#xA;  var urlRequest = URLRequest(url: userinfoEndpoint)&#xA;  urlRequest.allHTTPHeaderFields = [&#34;Authorization&#34;: &#34;Bearer \(accessToken)&#34;]&#xA;&#xA;  // Perform request...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom User-Agents (iOS and macOS)&lt;/h3&gt; &#xA;&lt;p&gt;Each OAuth flow involves presenting an external user-agent to the user, that allows them to interact with the OAuth authorization server. Typical examples of a user-agent are the user&#39;s browser, or an in-app browser tab incarnation like &lt;code&gt;ASWebAuthenticationSession&lt;/code&gt; on iOS.&lt;/p&gt; &#xA;&lt;p&gt;AppAuth ships with several implementations of an external user-agent out of the box, including defaults for iOS and macOS suitable for most cases. The default user-agents typically share persistent cookies with the system default browser, to improve the chance that the user doesn&#39;t need to sign-in all over again.&lt;/p&gt; &#xA;&lt;p&gt;It is possible to change the user-agent that AppAuth uses, and even write your own - all without needing to fork the library.&lt;/p&gt; &#xA;&lt;p&gt;All implementations of the external user-agent, be they included or created by you need to conform to the &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/protocol_o_i_d_external_user_agent-p.html&#34;&gt;&lt;code&gt;OIDExternalUserAgent&lt;/code&gt;&lt;/a&gt; protocol.&lt;/p&gt; &#xA;&lt;p&gt;Instances of the &lt;code&gt;OIDExternalUserAgent&lt;/code&gt;are passed into &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/interface_o_i_d_auth_state.html#ac762fe2bf95c116f0b437419be211fa1&#34;&gt;&lt;code&gt;OIDAuthState.authStateByPresentingAuthorizationRequest:externalUserAgent:callback&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/interface_o_i_d_authorization_service.html#ae551f8e6887366a46e49b09b37389b8f&#34;&gt;&lt;code&gt;OIDAuthorizationService.presentAuthorizationRequest:externalUserAgent:callback:&lt;/code&gt;&lt;/a&gt; rather than using the platform-specific convenience methods (which use the default user-agents for their respective platforms), like &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/category_o_i_d_auth_state_07_i_o_s_08.html#ae32fd0732cd3192cd5219f2655a4c85c&#34;&gt;&lt;code&gt;OIDAuthState.authStateByPresentingAuthorizationRequest:presentingViewController:callback:&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Popular use-cases for writing your own user-agent implementation include needing to style the user-agent in ways not supported by AppAuth, and implementing a fully custom flow with your own business logic. You can take one of the existing implementations as a starting point to copy, rename, and customize to your needs.&lt;/p&gt; &#xA;&lt;h4&gt;Custom Browser User-Agent&lt;/h4&gt; &#xA;&lt;p&gt;AppAuth for iOS includes a few extra user-agent implementations which you can try, or use as a reference for your own implementation. One of them, &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/interface_o_i_d_external_user_agent_i_o_s_custom_browser.html&#34;&gt;&lt;code&gt;OIDExternalUserAgentIOSCustomBrowser&lt;/code&gt;&lt;/a&gt; enables you to use a different browser for authentication, like Chrome for iOS or Firefox for iOS.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s how to configure AppAuth to use a custom browser using the &lt;code&gt;OIDExternalUserAgentIOSCustomBrowser&lt;/code&gt; user agent:&lt;/p&gt; &#xA;&lt;p&gt;First, add the following array to your &lt;a href=&#34;https://github.com/openid/AppAuth-iOS/raw/135f99d2cb4e9d18d310ac2588b905e612461561/Examples/Example-iOS_ObjC/Source/Info.plist#L34&#34;&gt;Info.plist&lt;/a&gt; (in XCode, right click -&amp;gt; Open As -&amp;gt; Source Code)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    &amp;lt;key&amp;gt;LSApplicationQueriesSchemes&amp;lt;/key&amp;gt;&#xA;    &amp;lt;array&amp;gt;&#xA;        &amp;lt;string&amp;gt;googlechromes&amp;lt;/string&amp;gt;&#xA;        &amp;lt;string&amp;gt;opera-https&amp;lt;/string&amp;gt;&#xA;        &amp;lt;string&amp;gt;firefox&amp;lt;/string&amp;gt;&#xA;    &amp;lt;/array&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is required so that AppAuth can test for the browser and open the app store if it&#39;s not installed (the default behavior of this user-agent). You only need to include the URL scheme of the actual browser you intend to use.&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// performs authentication request&#xA;AppDelegate *appDelegate =&#xA;    (AppDelegate *)[UIApplication sharedApplication].delegate;&#xA;id&amp;lt;OIDExternalUserAgent&amp;gt; userAgent =&#xA;    [OIDExternalUserAgentIOSCustomBrowser CustomBrowserChrome];&#xA;appDelegate.currentAuthorizationFlow =&#xA;    [OIDAuthState authStateByPresentingAuthorizationRequest:request&#xA;        externalUserAgent:userAgent&#xA;                 callback:^(OIDAuthState *_Nullable authState,&#xA;                                   NSError *_Nullable error) {&#xA;  if (authState) {&#xA;    NSLog(@&#34;Got authorization tokens. Access token: %@&#34;,&#xA;          authState.lastTokenResponse.accessToken);&#xA;    [self setAuthState:authState];&#xA;  } else {&#xA;    NSLog(@&#34;Authorization error: %@&#34;, [error localizedDescription]);&#xA;    [self setAuthState:nil];&#xA;  }&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;guard let appDelegate = UIApplication.shared.delegate as? AppDelegate else {&#xA;            self.logMessage(&#34;Error accessing AppDelegate&#34;)&#xA;            return&#xA;        }&#xA;let userAgent = OIDExternalUserAgentIOSCustomBrowser.customBrowserChrome()&#x9;&#x9;&#xA;appDelegate.currentAuthorizationFlow = OIDAuthState.authState(byPresenting: request, externalUserAgent: userAgent) { authState, error in&#xA;    if let authState = authState {&#xA;        self.setAuthState(authState)&#xA;        self.logMessage(&#34;Got authorization tokens. Access token: \(authState.lastTokenResponse?.accessToken ?? &#34;DEFAULT_TOKEN&#34;)&#34;)&#xA;    } else {&#xA;        self.logMessage(&#34;Authorization error: \(error?.localizedDescription ?? &#34;DEFAULT_ERROR&#34;)&#34;)&#xA;        self.setAuthState(nil)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it! With those two changes (which you can try on the included sample), AppAuth will use Chrome iOS for the authorization request (and open Chrome in the App Store if it&#39;s not installed).&lt;/p&gt; &#xA;&lt;p&gt;⚠️&lt;strong&gt;Note: the &lt;code&gt;OIDExternalUserAgentIOSCustomBrowser&lt;/code&gt; user-agent is not intended for consumer apps&lt;/strong&gt;. It is designed for advanced enterprise use-cases where the app developers have greater control over the operating environment and have special requirements that require a custom browser like Chrome.&lt;/p&gt; &#xA;&lt;p&gt;You don&#39;t need to stop with the included external user agents either! Since the &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/protocol_o_i_d_external_user_agent-p.html&#34;&gt;&lt;code&gt;OIDExternalUserAgent&lt;/code&gt;&lt;/a&gt; protocol is part of AppAuth&#39;s public API, you can implement your own versions of it. In the above example, &lt;code&gt;userAgent = [OIDExternalUserAgentIOSCustomBrowser CustomBrowserChrome]&lt;/code&gt; would be replaced with an instantiation of your user-agent implementation.&lt;/p&gt; &#xA;&lt;h2&gt;API Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Browse the &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/annotated.html&#34;&gt;API documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Included Samples&lt;/h2&gt; &#xA;&lt;p&gt;Sample apps that explore core AppAuth features are available for iOS, macOS and tvOS; follow the instructions in &lt;a href=&#34;https://raw.githubusercontent.com/openid/AppAuth-iOS/master/Examples/README.md&#34;&gt;Examples/README.md&lt;/a&gt; to get started.&lt;/p&gt;</summary>
  </entry>
</feed>