<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-15T01:50:20Z</updated>
  <subtitle>Weekly Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zhanghao5683934/Meihu-Beautyface-sdk</title>
    <updated>2023-10-15T01:50:20Z</updated>
    <id>tag:github.com,2023-10-15:/zhanghao5683934/Meihu-Beautyface-sdk</id>
    <link href="https://github.com/zhanghao5683934/Meihu-Beautyface-sdk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;美狐美颜sdk，支持美颜滤镜(Beauty Filter)、面具特效(Mask the special effects)、贴纸(Software/Hardware Encoder) 、滤镜(LUTs)&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt;&#xA; &lt;img src=&#34;https://images.gitee.com/uploads/images/2021/0807/140824_628c2001_9236797.png&#34;&gt;&#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34;&gt;&#xA; &lt;img src=&#34;https://images.gitee.com/uploads/images/2021/0807/140839_fa112ac1_9236797.png&#34;&gt;&#xA;&lt;/div&gt; &#xA;&lt;h3&gt;美狐美颜开源版（如果对你有用，请给个star和fork！)&lt;/h3&gt; &#xA;&lt;h3&gt;Meihu beauty open source version (if it is useful to you, please give a star and fork!)&lt;/h3&gt; &#xA;&lt;h3&gt;演示Demo&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;美颜演示下载地址Beauty demo download address: &lt;a target=&#34;_blank&#34; href=&#34;http://fir.facegl.com/yetc&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://fir.facegl.com/yetc&#34;&gt;http://fir.facegl.com/yetc&lt;/a&gt; 演示demo：&lt;img src=&#34;https://images.gitee.com/uploads/images/2021/0611/133433_ea131003_2073279.png&#34; width=&#34;400&#34;&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;接入说明 Access instructions&lt;/h3&gt; &#xA;&lt;p&gt;下载项目后 用Xcode打开 真机运行即可展示效果 After downloading the project, open it with Xcode and run it on the real machine to show the effect&lt;/p&gt; &#xA;&lt;h3&gt;项目介绍 Project Introduction&lt;/h3&gt; &#xA;&lt;p&gt;美狐美颜sdk，是以人脸识别技术为核心，提供专业级实时美颜、大眼瘦脸、美颜滤镜、动态贴纸等滤镜的移动端sdk，以打造多功能视频美颜软件为目标，充分满足客户在直播美颜、短视频美颜等众多音视频软件业务场景的美化需求。现推出开源版本iOS版，Android开源版本正在研发中敬请期待！ Meihu beauty sdk is a mobile sdk with face recognition technology as the core, providing professional-grade real-time beauty, big eyes and face reduction, beauty filters, dynamic stickers and other filters, to create a multi-functional video beauty software The goal is to fully meet the beautification needs of customers in many audio and video software business scenarios such as live beauty and short video beauty. The open source version is now available for iOS, and the Android open source version is under development, so stay tuned!&lt;/p&gt; &#xA;&lt;h3&gt;功能展示&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/zhanghao5683934/Meihu-FaceBeauty-Live/raw/main/meihumeiyan.png?raw=true&#34; alt=&#34;输入图片说明&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;版本对比&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://gitee.com/MeiHuSDK/meihu-meiyan/raw/master/QQ%E5%9B%BE%E7%89%8720220323170228.png&#34; alt=&#34;输入图片说明&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;开源版使用须知&lt;/h3&gt; &#xA;&lt;h3&gt;Instructions for using the open source version&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;允许用于个人学习、教学案例&lt;/li&gt; &#xA; &lt;li&gt;Allowed for personal study, teaching case&lt;/li&gt; &#xA; &lt;li&gt;开源版不适合商用，商用请购买商业版&lt;/li&gt; &#xA; &lt;li&gt;The open source version is not suitable for commercial use, please purchase the commercial version for commercial use&lt;/li&gt; &#xA; &lt;li&gt;禁止将本项目的代码和资源进行任何形式的出售，产生的一切任何后果责任由侵权者自负&lt;/li&gt; &#xA; &lt;li&gt;It is prohibited to sell the code and resources of this project in any form, and the infringer shall be responsible for all consequences arising therefrom&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;商业合作 Business cooperation&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;美狐sdk非开源版拥有更加完善的功能、性能更高、更稳定，支持目前主流的云服务平台&lt;/li&gt; &#xA; &lt;li&gt;The non-open source version of Meihu SDK has more complete functions, higher performance and more stability, and supports the current mainstream cloud service platforms&lt;/li&gt; &#xA; &lt;li&gt;如果您想使用功能更完善的美颜sdk，请联系QQ客服：1532375297，获取其它版本&lt;/li&gt; &#xA; &lt;li&gt;If you want to use the beauty sdk with more complete functions, please contact QQ customer service: 1532375297 to obtain other versions&lt;/li&gt; &#xA; &lt;li&gt;欢迎了解更多公司信息，请查看:&lt;a href=&#34;http://www.facegl.com/en.html&#34;&gt;http://www.facegl.com/en.html&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Welcome to know more company information, please check:&lt;a href=&#34;http://www.facegl.com/en.html&#34;&gt;http://www.facegl.com/en.html&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;交流互动（加客服经理微信或加入开源群，请备注“github美颜”）&lt;/h3&gt; &#xA;&lt;h3&gt;Communication and interaction (add customer service manager WeChat or join open source group)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://edu-qiniu.sdwanyue.com/admin/20220825/bc6a6a62e404104b23a8fa064305e47e.jpg&#34; alt=&#34;输入图片说明&#34; title=&#34;wxer1.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;点击链接加入群聊【美狐开源学习交流群】Click the link to join the group chat [Meihu Open Source Learning Exchange Group]：&lt;a href=&#34;https://jq.qq.com/?_wv=1027&amp;amp;k=8b8WsWFE&#34;&gt;https://jq.qq.com/?_wv=1027&amp;amp;k=8b8WsWFE&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://images.gitee.com/uploads/images/2021/0916/173830_95d0c197_9236797.png&#34; alt=&#34;输入图片说明&#34; title=&#34;美狐开源学习交流群群聊二维码.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;美颜开源QQ群：101672457 skype：live:1532375297&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>specta/expecta</title>
    <updated>2023-10-15T01:50:20Z</updated>
    <id>tag:github.com,2023-10-15:/specta/expecta</id>
    <link href="https://github.com/specta/expecta" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Matcher Framework for Objective-C/Cocoa&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Expecta &lt;a href=&#34;https://travis-ci.org/specta/expecta&#34;&gt;&lt;img src=&#34;http://img.shields.io/travis/specta/expecta/master.svg?style=flat&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/Expecta/&#34;&gt;&lt;img src=&#34;http://img.shields.io/cocoapods/v/Expecta.svg?style=flat&#34; alt=&#34;Pod Version&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;A matcher framework for Objective-C and Cocoa.&lt;/p&gt; &#xA;&lt;h2&gt;FEATURES&lt;/h2&gt; &#xA;&lt;p&gt;The main advantage of using Expecta over other matcher frameworks is that you do not have to specify the data types. Also, the syntax of Expecta matchers is much more readable and does not suffer from parenthesitis.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;expect(@&#34;foo&#34;).to.equal(@&#34;foo&#34;); // `to` is a syntactic sugar and can be safely omitted.&#xA;expect(foo).notTo.equal(1);&#xA;expect([bar isBar]).to.equal(YES);&#xA;expect(baz).to.equal(3.14159);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Expecta is framework-agnostic: it works well with XCTest and XCTest-compatible test frameworks such as &lt;a href=&#34;http://github.com/petejkim/specta/&#34;&gt;Specta&lt;/a&gt;, or &lt;a href=&#34;https://github.com/kiwi-bdd/Kiwi/&#34;&gt;Kiwi&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;MATCHERS&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.equal(y);&lt;/code&gt; compares objects or primitives x and y and passes if they are identical (==) or equivalent isEqual:).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beIdenticalTo(y);&lt;/code&gt; compares objects x and y and passes if they are identical and have the same memory address.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beNil();&lt;/code&gt; passes if x is nil.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beTruthy();&lt;/code&gt; passes if x evaluates to true (non-zero).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beFalsy();&lt;/code&gt; passes if x evaluates to false (zero).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.contain(y);&lt;/code&gt; passes if an instance of NSArray or NSString x contains y.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beSupersetOf(y);&lt;/code&gt; passes if an instance of NSArray, NSSet, NSDictionary or NSOrderedSet x contains all elements of y.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.haveCountOf(y);&lt;/code&gt; passes if an instance of NSArray, NSSet, NSDictionary or NSString x has a count or length of y.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beEmpty();&lt;/code&gt; passes if an instance of NSArray, NSSet, NSDictionary or NSString x has a count or length of .&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beInstanceOf([Foo class]);&lt;/code&gt; passes if x is an instance of a class Foo.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beKindOf([Foo class]);&lt;/code&gt; passes if x is an instance of a class Foo or if x is an instance of any class that inherits from the class Foo.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect([Foo class]).to.beSubclassOf([Bar class]);&lt;/code&gt; passes if the class Foo is a subclass of the class Bar or if it is identical to the class Bar. Use beKindOf() for class clusters.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beLessThan(y);&lt;/code&gt; passes if &lt;code&gt;x&lt;/code&gt; is less than &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beLessThanOrEqualTo(y);&lt;/code&gt; passes if &lt;code&gt;x&lt;/code&gt; is less than or equal to &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beGreaterThan(y);&lt;/code&gt; passes if &lt;code&gt;x&lt;/code&gt; is greater than &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beGreaterThanOrEqualTo(y);&lt;/code&gt; passes if &lt;code&gt;x&lt;/code&gt; is greater than or equal to &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beInTheRangeOf(y,z);&lt;/code&gt; passes if &lt;code&gt;x&lt;/code&gt; is in the range of &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beCloseTo(y);&lt;/code&gt; passes if &lt;code&gt;x&lt;/code&gt; is close to &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beCloseToWithin(y, z);&lt;/code&gt; passes if &lt;code&gt;x&lt;/code&gt; is close to &lt;code&gt;y&lt;/code&gt; within &lt;code&gt;z&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(^{ /* code */ }).to.raise(@&#34;ExceptionName&#34;);&lt;/code&gt; passes if a given block of code raises an exception named &lt;code&gt;ExceptionName&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(^{ /* code */ }).to.raiseAny();&lt;/code&gt; passes if a given block of code raises any exception.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.conformTo(y);&lt;/code&gt; passes if &lt;code&gt;x&lt;/code&gt; conforms to the protocol &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.respondTo(y);&lt;/code&gt; passes if &lt;code&gt;x&lt;/code&gt; responds to the selector &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(^{ /* code */ }).to.notify(@&#34;NotificationName&#34;);&lt;/code&gt; passes if a given block of code generates an NSNotification named &lt;code&gt;NotificationName&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(^{ /* code */ }).to.notify(notification);&lt;/code&gt; passes if a given block of code generates an NSNotification equal to the passed &lt;code&gt;notification&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.beginWith(y);&lt;/code&gt; passes if an instance of NSString, NSArray, or NSOrderedSet &lt;code&gt;x&lt;/code&gt; begins with &lt;code&gt;y&lt;/code&gt;. Also liased by &lt;code&gt;startWith&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.endWith(y);&lt;/code&gt; passes if an instance of NSString, NSArray, or NSOrderedSet &lt;code&gt;x&lt;/code&gt; ends with &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).to.match(y);&lt;/code&gt; passes if an instance of NSString &lt;code&gt;x&lt;/code&gt; matches regular expression (given as NSString) &lt;code&gt;y&lt;/code&gt; one or more times.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Inverting Matchers&lt;/h3&gt; &#xA;&lt;p&gt;Every matcher&#39;s criteria can be inverted by prepending &lt;code&gt;.notTo&lt;/code&gt; or &lt;code&gt;.toNot&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).notTo.equal(y);&lt;/code&gt; compares objects or primitives x and y and passes if they are &lt;em&gt;not&lt;/em&gt; equivalent.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Asynchronous Testing&lt;/h3&gt; &#xA;&lt;p&gt;Every matcher can be made to perform asynchronous testing by prepending &lt;code&gt;.will&lt;/code&gt;, &lt;code&gt;.willNot&lt;/code&gt; or &lt;code&gt;after(...)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).will.beNil();&lt;/code&gt; passes if x becomes nil before the default timeout.&lt;/p&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).willNot.beNil();&lt;/code&gt; passes if x becomes non-nil before the default timeout.&lt;/p&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).after(3).to.beNil();&lt;/code&gt; passes if x becoms nil after 3.0 seconds.&lt;/p&gt; &#xA; &lt;p&gt;&lt;code&gt;expect(x).after(2.5).notTo.equal(42);&lt;/code&gt; passes if x doesn&#39;t equal 42 after 2.5 seconds.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The default timeout is 1.0 second and is used for all matchers if not otherwise specified. This setting can be changed by calling &lt;code&gt;[Expecta setAsynchronousTestTimeout:x]&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the desired timeout in seconds.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;describe(@&#34;Foo&#34;, ^{&#xA;  beforeAll(^{&#xA;    // All asynchronous matching using `will` and `willNot`&#xA;    // will have a timeout of 2.0 seconds&#xA;    [Expecta setAsynchronousTestTimeout:2];&#xA;  });&#xA;&#xA;  it(@&#34;will not be nil&#34;, ^{&#xA;    // Test case where default timeout is used&#xA;    expect(foo).willNot.beNil();&#xA;  });&#xA;&#xA;  it(@&#34;should equal 42 after 3 seconds&#34;, ^{&#xA;    // Signle case where timeout differs from the default&#xA;    expect(foo).after(3).to.equal(42);&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Forced Failing&lt;/h3&gt; &#xA;&lt;p&gt;You can fail a test by using the &lt;code&gt;failure&lt;/code&gt; attribute. This can be used to test branching.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;failure(@&#34;This should not happen&#34;);&lt;/code&gt; outright fails a test.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;WRITING NEW MATCHERS&lt;/h3&gt; &#xA;&lt;p&gt;Writing a new matcher is easy with special macros provided by Expecta. Take a look at how &lt;code&gt;.beKindOf()&lt;/code&gt; matcher is defined:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;EXPMatchers+beKindOf.h&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;#import &#34;Expecta.h&#34;&#xA;&#xA;EXPMatcherInterface(beKindOf, (Class expected));&#xA;// 1st argument is the name of the matcher function&#xA;// 2nd argument is the list of arguments that may be passed in the function&#xA;// call.&#xA;// Multiple arguments are fine. (e.g. (int foo, float bar))&#xA;&#xA;#define beAKindOf beKindOf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;EXPMatchers+beKindOf.m&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;#import &#34;EXPMatchers+beKindOf.h&#34;&#xA;&#xA;EXPMatcherImplementationBegin(beKindOf, (Class expected)) {&#xA;  BOOL actualIsNil = (actual == nil);&#xA;  BOOL expectedIsNil = (expected == nil);&#xA;&#xA;  prerequisite(^BOOL {&#xA;    return !(actualIsNil || expectedIsNil);&#xA;    // Return `NO` if matcher should fail whether or not the result is inverted&#xA;    // using `.Not`.&#xA;  });&#xA;&#xA;  match(^BOOL {&#xA;    return [actual isKindOfClass:expected];&#xA;    // Return `YES` if the matcher should pass, `NO` if it should not.&#xA;    // The actual value/object is passed as `actual`.&#xA;    // Please note that primitive values will be wrapped in NSNumber/NSValue.&#xA;  });&#xA;&#xA;  failureMessageForTo(^NSString * {&#xA;    if (actualIsNil)&#xA;      return @&#34;the actual value is nil/null&#34;;&#xA;    if (expectedIsNil)&#xA;      return @&#34;the expected value is nil/null&#34;;&#xA;    return [NSString&#xA;        stringWithFormat:@&#34;expected: a kind of %@, &#34;&#xA;                          &#34;got: an instance of %@, which is not a kind of %@&#34;,&#xA;                         [expected class], [actual class], [expected class]];&#xA;    // Return the message to be displayed when the match function returns `YES`.&#xA;  });&#xA;&#xA;  failureMessageForNotTo(^NSString * {&#xA;    if (actualIsNil)&#xA;      return @&#34;the actual value is nil/null&#34;;&#xA;    if (expectedIsNil)&#xA;      return @&#34;the expected value is nil/null&#34;;&#xA;    return [NSString&#xA;        stringWithFormat:@&#34;expected: not a kind of %@, &#34;&#xA;                          &#34;got: an instance of %@, which is a kind of %@&#34;,&#xA;                         [expected class], [actual class], [expected class]];&#xA;    // Return the message to be displayed when the match function returns `NO`.&#xA;  });&#xA;}&#xA;EXPMatcherImplementationEnd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;DYNAMIC PREDICATE MATCHERS&lt;/h2&gt; &#xA;&lt;p&gt;It is possible to add predicate matchers by simply defining the matcher interface, with the matcher implementation being handled at runtime by delegating to the predicate method on your object.&lt;/p&gt; &#xA;&lt;p&gt;For instance, if you have the following class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@interface LightSwitch : NSObject&#xA;@property (nonatomic, assign, getter=isTurnedOn) BOOL turnedOn;&#xA;@end&#xA;&#xA;@implementation LightSwitch&#xA;@synthesize turnedOn;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The normal way to write an assertion that the switch is turned on would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;expect([lightSwitch isTurnedOn]).to.beTruthy();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, if we define a custom predicate matcher:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;EXPMatcherInterface(isTurnedOn, (void));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Note: we haven&#39;t defined the matcher implementation, just it&#39;s interface)&lt;/p&gt; &#xA;&lt;p&gt;You can now write your assertion as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;expect(lightSwitch).isTurnedOn();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;INSTALLATION&lt;/h2&gt; &#xA;&lt;p&gt;You can setup Expecta using &lt;a href=&#34;http://github.com/CocoaPods/CocoaPods&#34;&gt;CocoaPods&lt;/a&gt;, &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/specta/expecta/master/#setting-up-manually&#34;&gt;completely manually&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add Expecta to your project&#39;s &lt;code&gt;Podfile&lt;/code&gt;:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;target :MyApp do&#xA;# your app dependencies&#xA;&#xA;  target :MyAppTests do&#xA;    inherit! search_paths&#xA;&#xA;    pod &#39;Expecta&#39;, &#39;~&amp;gt; 1.0&#39;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Add Expecta to your project&#39;s &lt;code&gt;Cartfile.private&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;github &#34;specta/expecta&#34; &#34;master&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run &lt;code&gt;carthage update&lt;/code&gt; in your project directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Drag the appropriate &lt;strong&gt;Expecta.framework&lt;/strong&gt; for your platform (located in &lt;code&gt;Carthage/Build/&lt;/code&gt;) into your application’s Xcode project, and add it to your test target(s).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run &lt;code&gt;pod update&lt;/code&gt; or &lt;code&gt;pod install&lt;/code&gt; in your project directory.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Setting Up Manually&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone Expecta from Github.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run &lt;code&gt;rake&lt;/code&gt; in your project directory to build the frameworks and libraries.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add a Cocoa or Cocoa Touch Unit Testing Bundle target to your Xcode project if you don&#39;t already have one.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For &lt;strong&gt;OS X projects&lt;/strong&gt;, copy and add &lt;code&gt;Expecta.framework&lt;/code&gt; in the &lt;code&gt;Products/osx&lt;/code&gt; folder to your project&#39;s test target.&lt;/p&gt; &lt;p&gt;For &lt;strong&gt;iOS projects&lt;/strong&gt;, copy and add &lt;code&gt;Expecta.framework&lt;/code&gt; in the &lt;code&gt;Products/ios&lt;/code&gt; folder to your project&#39;s test target.&lt;/p&gt; &lt;p&gt;You can also use &lt;code&gt;libExpecta.a&lt;/code&gt; if you prefer to link Expecta as a static library — iOS 7.x and below require this.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add &lt;code&gt;-ObjC&lt;/code&gt; and &lt;code&gt;-all_load&lt;/code&gt; to the &lt;strong&gt;Other Linker Flags&lt;/strong&gt; build setting for the test target in your Xcode project.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can now use Expecta in your test classes by adding the following import:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;@import Expecta; // If you&#39;re using Expecta.framework&#xA;&#xA;// OR&#xA;&#xA;#import &amp;lt;Expecta/Expecta.h&amp;gt; // If you&#39;re using the static library, or the framework&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;STATUS&lt;/h2&gt; &#xA;&lt;p&gt;Expecta, and Specta are considered done projects, there are no plans for &lt;em&gt;active&lt;/em&gt; development on the project at the moment aside from ensuring future Xcode compatability. Therefore it is a stable dependency, but will not be moving into the Swift world. If you are looking for that, we recommend you consider &lt;a href=&#34;https://github.com/quick/quick&#34;&gt;Quick&lt;/a&gt; and &lt;a href=&#34;https://github.com/quick/nimble&#34;&gt;Nimble&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contribution Guidelines&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Please use only spaces and indent 2 spaces at a time.&lt;/li&gt; &#xA; &lt;li&gt;Please prefix instance variable names with a single underscore (&lt;code&gt;_&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Please prefix custom classes and functions defined in the global scope with &lt;code&gt;EXP&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2012-2016 &lt;a href=&#34;https://github.com/specta?tab=members&#34;&gt;Specta Team&lt;/a&gt;. This software is licensed under the &lt;a href=&#34;http://github.com/specta/specta/raw/master/LICENSE&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>