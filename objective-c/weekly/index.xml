<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-04T01:45:20Z</updated>
  <subtitle>Weekly Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>devxoul/JLHTTPRequest</title>
    <updated>2022-12-04T01:45:20Z</updated>
    <id>tag:github.com,2022-12-04:/devxoul/JLHTTPRequest</id>
    <link href="https://github.com/devxoul/JLHTTPRequest" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This is shit. Do not use it. Use AFNetworking.&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>yourkarma/JWT</title>
    <updated>2022-12-04T01:45:20Z</updated>
    <id>tag:github.com,2022-12-04:/yourkarma/JWT</id>
    <link href="https://github.com/yourkarma/JWT" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A JSON Web Token implementation in Objective-C.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://jwt.io/&#34;&gt;&lt;img src=&#34;http://jwt.io/assets/logo.svg?sanitize=true&#34; alt=&#34;JWT&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/yourkarma/JWT&#34;&gt;&lt;img src=&#34;https://travis-ci.org/yourkarma/JWT.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/JWT&#34;&gt;&lt;img src=&#34;http://img.shields.io/cocoapods/v/JWT.svg?style=flat&#34; alt=&#34;Pod Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/JWT&#34;&gt;&lt;img src=&#34;http://img.shields.io/cocoapods/p/JWT.svg?style=flat&#34; alt=&#34;Pod Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/ObjectiveC-JWT/community?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/ObjectiveC-JWT/community.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;JWT&lt;/h1&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html&#34;&gt;JSON Web Token&lt;/a&gt; implementation in Objective-C.&lt;/p&gt; &#xA;&lt;h1&gt;What&#39;s new in master and bleeding edge.&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Version Three release (?)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yourkarma/JWT/master/Documentation/Prerelease/custom_claims.md&#34;&gt;Custom Claims&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;EC algorithms support.&lt;/li&gt; &#xA; &lt;li&gt;Keys extraction from Pem files has been updated.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Custom Claims.&lt;/h2&gt; &#xA;&lt;h3&gt;Deprecation.&lt;/h3&gt; &#xA;&lt;p&gt;Old ClaimsSet API has been deprecated and will be removed in API version 3.0.&lt;/p&gt; &#xA;&lt;h3&gt;Process.&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Define custom serializer for a claim.&lt;/li&gt; &#xA; &lt;li&gt;Define custom verifier for a claim.&lt;/li&gt; &#xA; &lt;li&gt;Register new claim with serializer and verifier at claims set coordinator.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yourkarma/JWT/master/Documentation/Prerelease/custom_claims.md&#34;&gt;Example&lt;/a&gt;.&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (void)test {&#xA;    /// Setup ClaimsSetCoordinator&#xA;    __auto_type claim = JWTClaimVariations.intersectionOfIntervals;&#xA;    __auto_type claimSerializer = JWTClaimSerializerVariations.interval;&#xA;    __auto_type claimVerifier = JWTClaimVerifierVariations.intersection;&#xA;&#xA;    id&amp;lt;JWTClaimsSetCoordinatorProtocol&amp;gt; claimsSetCoordinator = [JWTClaimsSetCoordinatorBase new];&#xA;    [claimsSetCoordinator registerClaim:claim serializer:claimSerializer verifier:claimVerifier forClaimName:JWTClaimsNames.intersectionOfIntervals];&#xA;&#xA;    __auto_type deserialized = ({&#xA;        claimsSetCoordinator.configureClaimsSet(^JWTClaimsSetDSLBase *(JWTClaimsSetDSLBase *claimsSetDSL) {&#xA;            claimsSetDSL.intersection = @[@(2), @(5)];&#xA;            return claimsSetDSL;&#xA;        });&#xA;        self.claimsSetCoordinator.claimsSetStorage;&#xA;    });&#xA;    &#xA;    __auto_type serialized = ({&#xA;        __auto_type dictionary = [self.claimsSetCoordinator.claimsSetSerializer dictionaryFromClaimsSet:deserialized];&#xA;        dictionary;&#xA;    });&#xA;    &#xA;    __auto_type result = @{&#xA;        JWTClaimsNames.intersectionOfIntervals : @&#34;2,5&#34;&#xA;    };&#xA;    XCTAssertEqual(serialized.count, 1);&#xA;    XCTAssertEqualObjects(serialized, result);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;EC algorithms support.&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites.&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Certificate and P12 for Public and Private keys accordingly.&lt;/li&gt; &#xA; &lt;li&gt;Pem files with keys in &lt;em&gt;ANSI X9.63&lt;/em&gt; format.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Example.&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSString *privateKeyString = @&#34;&amp;lt;ANSI X9.63 formatted key&amp;gt;&#34;;&#xA;NSString *publicKeyString = @&#34;&amp;lt;ANSI X9.63 formatted key&amp;gt;&#34;;&#xA;&#xA;// Note: We should pass type of key. Default type is RSA.&#xA;NSDictionary *parameters = @{JWTCryptoKey.parametersKeyBuilder : JWTCryptoKeyBuilder.new.keyTypeEC};&#xA;&#xA;id &amp;lt;JWTCryptoKeyProtocol&amp;gt; privateKey = [[JWTCryptoKeyPrivate alloc] initWithPemEncoded:privateKeyString parameters:parameters error:nil];&#xA;id &amp;lt;JWTCryptoKeyProtocol&amp;gt; publicKey = [[JWTCryptoKeyPublic alloc] initWithPemEncoded:publicKeyString parameters:parameters error:nil];&#xA;&#xA;// Note: JWTAlgorithmRSFamilyDataHolder will be renamed to something more appropriate. It can holds any asymmetric keys pair (private and public).&#xA;id &amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt; holder = [JWTAlgorithmRSFamilyDataHolder new].signKey(privateKey).verifyKey(publicKey).algorithmName(JWTAlgorithmNameES256);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;What&#39;s new in Version 3.0&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fluent style expanded.&lt;/li&gt; &#xA; &lt;li&gt;Coding result types added.&lt;/li&gt; &#xA; &lt;li&gt;Algorithms and data holders.&lt;/li&gt; &#xA; &lt;li&gt;Algorithms and data holders chain.&lt;/li&gt; &#xA; &lt;li&gt;Keys loaded from Pem files.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction to Algorithms data holders and chain.&lt;/h2&gt; &#xA;&lt;p&gt;You have an algorithm, a secret data and an unknown jwt token. Let&#39;s try to decode it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// create token&#xA;NSString *token = @&#34;...&#34;;&#xA;&#xA;// possible that algorithm could return error.&#xA;// you could try use algorithm and data chain.&#xA;&#xA;NSString *firstSecret = @&#34;first&#34;;&#xA;NSString *firstAlgorithmName = JWTAlgorithmNameHS384;&#xA;&#xA;id &amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt; firstHolder = [JWTAlgorithmHSFamilyDataHolder new].algorithmName(firstAlgorithmName).secret(firstSecret);&#xA;&#xA;id &amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt; errorHolder = [JWTAlgorithmNoneDataHolder new];&#xA;&#xA;// chain together.&#xA;JWTAlgorithmDataHolderChain *chain = [[JWTAlgorithmDataHolderChain alloc] initWithHolders:@[firstHolder, errorHolder]];&#xA;&#xA;// or add them in builder&#xA;[JWTDecodingBuilder decodeMessage:token].addHolder(firstHolder).addHolder(errorHolder);&#xA;&#xA;// or add them as chain&#xA;[JWTDecodingBuilder decodeMessage:token].chain(chain);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Maybe you would like to try different secrets.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// possible that your algorithm has several secrets.&#xA;// you don&#39;t know which secret to use.&#xA;// but you want to decode it.&#xA;NSString *firstSecret = @&#34;first&#34;;&#xA;NSArray *manySecrets = @[@&#34;second&#34;, @&#34;third&#34;, @&#34;forty two&#34;];&#xA;// translate to data&#xA;NSArray *manySecretsData = @[];&#xA;for (NSString *secret in manySecrets) {&#xA;    NSData *secretData = [JWTBase64Coder dataWithBase64UrlEncodedString:secret];&#xA;    if (secret) {&#xA;        manySecretsData = [manySecretsData arrayByAddingObject:secretData];&#xA;    }&#xA;}&#xA;&#xA;NSString *algorithmName = JWTAlgorithmNameHS384;&#xA;&#xA;id &amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt; firstHolder = [JWTAlgorithmHSFamilyDataHolder new].algorithmName(algorithmName).secret(firstSecret);&#xA;&#xA;// lets create chain&#xA;JWTAlgorithmDataHolderChain *chain = [JWTAlgorithmDataHolderChain chainWithHolder:firstHolder];&#xA;&#xA;// and lets populate chain with secrets.&#xA;NSLog(@&#34;chain has: %@&#34;, chain.debugDescription);&#xA;&#xA;JWTAlgorithmDataHolderChain *expandedChain = [chain chainByPopulatingAlgorithm:firstHolder.currentAlgorithm withManySecretData:manySecretsData];&#xA;&#xA;// now we have expanded chain with many secrets and one algorithm.&#xA;NSLog(@&#34;expanded chain has: %@&#34;, expandedChain.debugDescription);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Decode and encode with chain.&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;JWTClaimsSet *claimsSet = [[JWTClaimsSet alloc] init];&#xA;// fill it&#xA;claimsSet.issuer = @&#34;Facebook&#34;;&#xA;claimsSet.subject = @&#34;Token&#34;;&#xA;claimsSet.audience = @&#34;https://jwt.io&#34;;&#xA;&#xA;// encode it&#xA;NSString *secret = @&#34;secret&#34;;&#xA;NSString *algorithmName = @&#34;HS384&#34;;&#xA;NSDictionary *headers = @{@&#34;custom&#34;:@&#34;value&#34;};&#xA;&#xA;id&amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt;holder = [JWTAlgorithmHSFamilyDataHolder new].algorithmName(algorithmName).secret(secret);&#xA;&#xA;JWTCodingResultType *result = [JWTEncodingBuilder encodeClaimsSet:claimsSet].headers(headers).addHolder(holder).result;&#xA;&#xA;NSString *encodedToken = result.successResult.encoded;&#xA;if (result.successResult) {&#xA;    // handle encoded result&#xA;    NSLog(@&#34;encoded result: %@&#34;, result.successResult.encoded);&#xA;}&#xA;else {&#xA;    // handle error&#xA;    NSLog(@&#34;encode failed, error: %@&#34;, result.errorResult.error);&#xA;}&#xA;&#xA;// decode it&#xA;// you can set any property that you want, all properties are optional&#xA;JWTClaimsSet *trustedClaimsSet = [claimsSet copy];&#xA;&#xA;NSNumber *options = @(JWTCodingDecodingOptionsNone);&#xA;NSString *yourJwt = encodedToken; // from previous example&#xA;JWTCodingResultType *decodedResult = [JWTDecodingBuilder decodeMessage:yourJwt].claimsSet(claimsSet).addHolder(holder).options(options).and.result;&#xA;&#xA;if (decodedResult.successResult) {&#xA;    // handle decoded result&#xA;    NSLog(@&#34;decoded result: %@&#34;, decodedResult.successResult.headerAndPayloadDictionary);&#xA;    NSLog(@&#34;headers: %@&#34;, decodedResult.successResult.headers);&#xA;    NSLog(@&#34;payload: %@&#34;, decodedResult.successResult.payload);&#xA;}&#xA;else {&#xA;    // handle error&#xA;    NSLog(@&#34;decode failed, error: %@&#34;, decodedResult.errorResult.error);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Keys loaded from Pem files.&lt;/h2&gt; &#xA;&lt;p&gt;You have a key in pem file. And you want to use it directly for sign/verify. Suppose, that &#34;public_rsa.pem&#34; and &#34;private_rsa.pem&#34; are public and private keys in pem format.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// Load keys&#xA;- (NSString *)pemKeyStringFromFileWithName:(NSString *)string inBundle:(NSBundle *)bundle {&#xA;    NSURL *fileURL = [bundle URLForResource:name withExtension:@&#34;pem&#34;];&#xA;    NSError *error = nil;&#xA;    NSString *fileContent = [NSString stringWithContentsOfURL:fileURL encoding:NSUTF8StringEncoding error:&amp;amp;error];&#xA;    if (error) {&#xA;        NSLog(@&#34;%@ error: %@&#34;, self.debugDescription, error);&#xA;        return nil;&#xA;    }&#xA;}&#xA;&#xA;// Sign and verify&#xA;- (void)signAndVerifyWithPrivateKeyPemString:(NSString *)privateKey publicKeyPemString:(NSString *)publicKey privateKeyPassphrase:(NSString *)passphrase {&#xA;    NSString *algorithmName = @&#34;RS256&#34;;&#xA;&#xA;    id &amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt; signDataHolder = [JWTAlgorithmRSFamilyDataHolder new].keyExtractorType([JWTCryptoKeyExtractor privateKeyWithPEMBase64].type).privateKeyCertificatePassphrase(passphrase).algorithmName(algorithmName).secret(privateKey);&#xA;&#xA;    id &amp;lt;JWTAlgorithmDataHolderProtocol&amp;gt; verifyDataHolder = [JWTAlgorithmRSFamilyDataHolder new].keyExtractorType([JWTCryptoKeyExtractor publicKeyWithPEMBase64].type).algorithmName(algorithmName).secret(publicKey);&#xA;&#xA;    // sign&#xA;    NSDictionary *payloadDictionary = @{@&#34;hello&#34;: @&#34;world&#34;};&#xA;&#xA;    JWTCodingBuilder *signBuilder = [JWTEncodingBuilder encodePayload:payloadDictionary].addHolder(signDataHolder);&#xA;    JWTCodingResultType *signResult = signBuilder.result;&#xA;    NSString *token = nil;&#xA;    if (signResult.successResult) {&#xA;        // success&#xA;        NSLog(@&#34;%@ success: %@&#34;, self.debugDescription, signResult.successResult.encoded);&#xA;        token = signResult.successResult.encoded;&#xA;    }&#xA;    else {&#xA;        // error&#xA;        NSLog(@&#34;%@ error: %@&#34;, self.debugDescription, signResult.errorResult.error);&#xA;    }&#xA;&#xA;    // verify&#xA;    if (token == nil) {&#xA;        NSLog(@&#34;something wrong&#34;);&#xA;    }&#xA;&#xA;    JWTCodingBuilder *verifyBuilder = [JWTDecodingBuilder decodeMessage:token].addHolder(verifyDataHolder);&#xA;    JWTCodingResultType *verifyResult = verifyBuilder.result;&#xA;    if (verifyResult.successResult) {&#xA;        // success&#xA;        NSLog(@&#34;%@ success: %@&#34;, self.debugDescription, verifyResult.successResult.payload);&#xA;        token = verifyResult.successResult.encoded;&#xA;    }&#xA;    else {&#xA;        // error&#xA;        NSLog(@&#34;%@ error: %@&#34;, self.debugDescription, verifyResult.errorResult.error);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Experiments in Version 2.0&lt;/h1&gt; &#xA;&lt;h2&gt;Whitelists possible algorithms.&lt;/h2&gt; &#xA;&lt;p&gt;When you need to decode jwt by several algorithms you could specify their names in whitelist. Later this feature possible will migrate to options. For example, someone returns result or error.&lt;/p&gt; &#xA;&lt;h3&gt;Limitations&lt;/h3&gt; &#xA;&lt;p&gt;Restricted to pair (algorithm or none) due to limitations of unique &lt;code&gt;secret&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSString *jwtResultOrError = /*...*/;&#xA;NSString *secret = @&#34;secret&#34;;&#xA;JWTBuilder *builder = [JWT decodeMessage:jwtResultOrError].secret(@&#34;secret&#34;).whitelist(@[@&#34;HS256&#34;, @&#34;none&#34;]);&#xA;NSDictionary *decoded = builder.decode;&#xA;if (builder.jwtError) {&#xA;    // oh!&#xA;}&#xA;else {&#xA;    NSDictionary *payload = decoded[@&#34;payload&#34;];&#xA;    NSDictionary *header = decoded[@&#34;header&#34;];&#xA;    NSArray *tries = decoded[@&#34;tries&#34;]; // will be evolded into something appropriate later.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;What&#39;s new in Version 2.0&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Old plain style deprecated.&lt;/li&gt; &#xA; &lt;li&gt;Use modern fluent style instead.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSDictionary *payload = @{@&#34;foo&#34; : @&#34;bar&#34;};&#xA;NSString *secret = @&#34;secret&#34;;&#xA;id&amp;lt;JWTAlgorithm&amp;gt; algorithm = [JWTAlgorithmFactory algorithmByName:@&#34;HS256&#34;];&#xA;// Deprecated&#xA;[JWT encodePayload:payload withSecret:secret algorithm:algorithm];&#xA;&#xA;// Modern&#xA;[JWTBuilder encodePayload:payload].secret(secret).algorithm(algorithm).encode;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;Add the following to your &lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt; Podfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod &#34;JWT&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install via Cartfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;yourkarma/JWT&#34; &#34;master&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and &lt;code&gt;import JWT&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;JWTBuilder&lt;/h2&gt; &#xA;&lt;p&gt;To encode &amp;amp; decode JWTs, use fluent style with the &lt;code&gt;JWTBuilder&lt;/code&gt; interface&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;+ (JWTBuilder *)encodePayload:(NSDictionary *)payload;&#xA;+ (JWTBuilder *)encodeClaimsSet:(JWTClaimsSet *)claimsSet;&#xA;+ (JWTBuilder *)decodeMessage:(NSString *)message;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, JWTBuilder has interface from both decoding and encoding.&lt;/p&gt; &#xA;&lt;p&gt;Note: some attributes are encode-only or decode-only.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#pragma mark - Encode only&#xA;*payload;&#xA;*headers;&#xA;*algorithm;&#xA;&#xA;#pragma mark - Decode only&#xA;*message&#xA;*options // as forcedOption from jwt decode functions interface.&#xA;*whitelist  //optional array of algorithm names to whitelist for decoding&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can inspect JWTBuilder by &lt;code&gt;jwt&lt;/code&gt;-prefixed attributes.&lt;/p&gt; &#xA;&lt;p&gt;You can set JWTBuilder attributes by fluent style (block interface).&lt;/p&gt; &#xA;&lt;p&gt;You can encode arbitrary payloads like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSDictionary *payload = @{@&#34;foo&#34; : @&#34;bar&#34;};&#xA;NSString *secret = @&#34;secret&#34;;&#xA;id&amp;lt;JWTAlgorithm&amp;gt; algorithm = [JWTAlgorithmFactory algorithmByName:@&#34;HS256&#34;];&#xA;&#xA;[JWTBuilder encodePayload:payload].secret(@&#34;secret&#34;).algorithm(algorithm).encode;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;re using reserved claim names you can encode your claim set like so (all properties are optional):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;JWTClaimsSet *claimsSet = [[JWTClaimsSet alloc] init];&#xA;claimsSet.issuer = @&#34;Facebook&#34;;&#xA;claimsSet.subject = @&#34;Token&#34;;&#xA;claimsSet.audience = @&#34;http://yourkarma.com&#34;;&#xA;claimsSet.expirationDate = [NSDate distantFuture];&#xA;claimsSet.notBeforeDate = [NSDate distantPast];&#xA;claimsSet.issuedAt = [NSDate date];&#xA;claimsSet.identifier = @&#34;thisisunique&#34;;&#xA;claimsSet.type = @&#34;test&#34;;&#xA;&#xA;NSString *secret = @&#34;secret&#34;;&#xA;id&amp;lt;JWTAlgorithm&amp;gt; algorithm = [JWTAlgorithmFactory algorithmByName:@&#34;HS256&#34;];&#xA;&#xA;[JWTBuilder encodeClaimsSet:claimsSet].secret(secret).algorithm(algorithm).encode;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can decode a JWT like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSString *jwtToken = @&#34;header.payload.signature&#34;;&#xA;NSString *secret = @&#34;secret&#34;;&#xA;NSString *algorithmName = @&#34;HS256&#34;; //Must specify an algorithm to use&#xA;&#xA;NSDictionary *payload = [JWTBuilder decodeMessage:jwtToken].secret(secret).algorithmName(algorithmName).decode;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to check claims while decoding, you could use next sample of code (all properties are optional):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// Trusted Claims Set&#xA;JWTClaimsSet *trustedClaimsSet = [[JWTClaimsSet alloc] init];&#xA;trustedClaimsSet.issuer = @&#34;Facebook&#34;;&#xA;trustedClaimsSet.subject = @&#34;Token&#34;;&#xA;trustedClaimsSet.audience = @&#34;http://yourkarma.com&#34;;&#xA;trustedClaimsSet.expirationDate = [NSDate date];&#xA;trustedClaimsSet.notBeforeDate = [NSDate date];&#xA;trustedClaimsSet.issuedAt = [NSDate date];&#xA;trustedClaimsSet.identifier = @&#34;thisisunique&#34;;&#xA;trustedClaimsSet.type = @&#34;test&#34;;&#xA;&#xA;NSString *message = @&#34;encodedJwt&#34;;&#xA;NSString *secret = @&#34;secret&#34;;&#xA;NSString *algorithmName = @&#34;chosenAlgorithm&#34;&#xA;&#xA;JWTBuilder *builder = [JWTBuilder decodeMessage:jwt].secret(secret).algorithmName(algorithmName).claimsSet(trustedClaimsSet);&#xA;NSDictionary *payload = builder.decode;&#xA;&#xA;if (builder.jwtError == nil) {&#xA;    // do your work here&#xA;}&#xA;else {&#xA;    // handle error&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to enforce a whitelist of valid algorithms:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSArray *whitelist = @[@&#34;HS256&#34;, @&#34;HS512&#34;];&#xA;NSString *jwtToken = @&#34;header.payload.signature&#34;;&#xA;NSString *secret = @&#34;secret&#34;;&#xA;NSString *algorithmName = @&#34;HS256&#34;;&#xA;&#xA;//Returns nil&#xA;NSDictionary *payload = [JWTBuilder decodeMessage:jwtToken].secret(secret).algorithmName(algorithmName).whitelist(@[]).decode;&#xA;&#xA;//Returns the decoded payload&#xA;NSDictionary *payload = [JWTBuilder decodeMessage:jwtToken].secret(secret).algorithmName(algorithmName).whitelist(whitelist).decode;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Encode / Decode Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// suppose, that you create ClaimsSet&#xA;JWTClaimsSet *claimsSet = [[JWTClaimsSet alloc] init];&#xA;// fill it&#xA;claimsSet.issuer = @&#34;Facebook&#34;;&#xA;claimsSet.subject = @&#34;Token&#34;;&#xA;claimsSet.audience = @&#34;http://yourkarma.com&#34;;&#xA;&#xA;// encode it&#xA;NSString *secret = @&#34;secret&#34;;&#xA;NSString *algorithmName = @&#34;HS384&#34;;&#xA;NSDictionary *headers = @{@&#34;custom&#34;:@&#34;value&#34;};&#xA;id&amp;lt;JWTAlgorithm&amp;gt; algorithm = [JWTAlgorithmFactory algorithmByName:algorithmName];&#xA;&#xA;JWTBuilder *encodeBuilder = [JWT encodeClaimsSet:claimsSet];&#xA;NSString *encodedResult = encodeBuilder.secret(secret).algorithm(algorithm).headers(headers).encode;&#xA;&#xA;if (encodeBuilder.jwtError == nil) {&#xA;    // handle encoded result&#xA;    NSLog(@&#34;encoded result: %@&#34;, encodedResult);&#xA;}&#xA;else {&#xA;    // handle error&#xA;    NSLog(@&#34;encode failed, error: %@&#34;, encodeBuilder.jwtError);&#xA;}&#xA;&#xA;// decode it&#xA;// you can set any property that you want, all properties are optional&#xA;JWTClaimsSet *trustedClaimsSet = [claimsSet copy];&#xA;&#xA;// decode forced ? try YES&#xA;BOOL decodeForced = NO;&#xA;NSNumber *options = @(decodeForced);&#xA;NSString *yourJwt = encodedResult; // from previous example&#xA;NSString *yourSecret = secret; // from previous example&#xA;NSString *yourAlgorithm = algorithmName; // from previous example&#xA;JWTBuilder *decodeBuilder = [JWT decodeMessage:yourJwt];&#xA;NSDictionary *decodedResult = decodeBuilder.message(yourJwt).secret(yourSecret).algorithmName(yourAlgorithm).claimsSet(trustedClaimsSet).options(options).decode;&#xA;if (decodeBuilder.jwtError == nil) {&#xA;    // handle decoded result&#xA;    NSLog(@&#34;decoded result: %@&#34;, decodedResult);&#xA;}&#xA;else {&#xA;    // handle error&#xA;    NSLog(@&#34;decode failed, error: %@&#34;, decodeBuilder.jwtError);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;NSData&lt;/h4&gt; &#xA;&lt;p&gt;You can also encode/decode using a secret that is represented as an NSData object&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;//Encode&#xA;NSData *secretData = &#34;&amp;lt;your data&amp;gt;&#34;;&#xA;NSString *algorithmName = @&#34;HS384&#34;;&#xA;NSDictionary *headers = @{@&#34;custom&#34;:@&#34;value&#34;};&#xA;id&amp;lt;JWTAlgorithm&amp;gt; algorithm = [JWTAlgorithmFactory algorithmByName:algorithmName];&#xA;&#xA;JWTBuilder *encodeBuilder = [JWT encodeClaimsSet:claimsSet];&#xA;NSString *encodedResult = encodeBuilder.secretData(secretData).algorithm(algorithm).headers(headers).encode;&#xA;&#xA;//Decode&#xA;NSString *jwtToken = @&#34;header.payload.signature&#34;;&#xA;NSData *secretData = &#34;&amp;lt;your data&amp;gt;&#34;&#xA;NSString *algorithmName = @&#34;HS256&#34;; //Must specify an algorithm to use&#xA;&#xA;NSDictionary *payload = [JWTBuilder decodeMessage:jwtToken].secretData(secretData).algorithmName(algorithmName).decode;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Algorithms&lt;/h1&gt; &#xA;&lt;p&gt;The following algorithms are supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RS256&lt;/li&gt; &#xA; &lt;li&gt;HS512 - HMAC using SHA-512.&lt;/li&gt; &#xA; &lt;li&gt;HS256 / HS384 / HS512&lt;/li&gt; &#xA; &lt;li&gt;None&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;RS256 usage.&lt;/h2&gt; &#xA;&lt;p&gt;For example, you have your file with privateKey: &lt;code&gt;file.p12&lt;/code&gt;. And you have a secret passphrase for that file: &lt;code&gt;secret&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// Encode&#xA;NSDictionary *payload = @{@&#34;payload&#34; : @&#34;hidden_information&#34;};&#xA;NSString *algorithmName = @&#34;RS256&#34;;&#xA;&#xA;NSString *filePath = [[NSBundle mainBundle] pathForResource:@&#34;secret_key&#34; ofType:@&#34;p12&#34;];&#xA;NSData *privateKeySecretData = [NSData dataWithContentsOfFile:filePath];&#xA;&#xA;NSString *passphraseForPrivateKey = @&#34;secret&#34;;&#xA;&#xA;JWTBuilder *builder = [JWTBuilder encodePayload:payload].secretData(privateKeySecretData).privateKeyCertificatePassphrase(passphraseForPrivateKey).algorithmName(algorithmName);&#xA;NSString *token = builder.encode;&#xA;&#xA;// check error&#xA;if (builder.jwtError == nil) {&#xA;    // handle result&#xA;}&#xA;else {&#xA;    // error occurred.&#xA;}&#xA;&#xA;// Decode&#xA;// Suppose, that you get token from previous example. You need a valid public key for a private key in previous example.&#xA;// Private key stored in @&#34;secret_key.p12&#34;. So, you need public key for that private key.&#xA;NSString *publicKey = @&#34;...&#34;; // load public key. Or use it as raw string.&#xA;&#xA;algorithmName = @&#34;RS256&#34;;&#xA;&#xA;JWTBuilder *decodeBuilder = [JWTBuilder decodeMessage:token].secret(publicKey).algorithmName(algorithmName);&#xA;NSDictionary *envelopedPayload = decodeBuilder.decode;&#xA;&#xA;// check error&#xA;if (decodeBuilder.jwtError == nil) {&#xA;    // handle result&#xA;}&#xA;else {&#xA;    // error occurred.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additional algorithms can be added by implementing the &lt;code&gt;JWTAlgorithm&lt;/code&gt; protocol.&lt;/p&gt; &#xA;&lt;h2&gt;Before pull request&lt;/h2&gt; &#xA;&lt;p&gt;Please, read &lt;a href=&#34;https://github.com/yourkarma/JWT/raw/master/.github/CONTRIBUTING.md&#34;&gt;Contribution notes&lt;/a&gt; before make pull request.&lt;/p&gt; &#xA;&lt;h2&gt;Powered by&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.jetbrains.com&#34;&gt;&lt;img src=&#34;https://www.jetbrains.com/apple-touch-icon-180x180.png&#34; alt=&#34;JetBrains&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>yarry/IRZRUH2Monitor</title>
    <updated>2022-12-04T01:45:20Z</updated>
    <id>tag:github.com,2022-12-04:/yarry/IRZRUH2Monitor</id>
    <link href="https://github.com/yarry/IRZRUH2Monitor" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple IRZRUH2 3G Router monitor for MAC OSZ&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;IRZ RUH2 Monitor&lt;/h1&gt; &#xA;&lt;p&gt;Monitors connection state for 3G Router IRZ RUH2&lt;/p&gt;</summary>
  </entry>
</feed>