<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-08-24T01:48:29Z</updated>
  <subtitle>Weekly Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SDWebImage/SDWebImageAVIFCoder</title>
    <updated>2025-08-24T01:48:29Z</updated>
    <id>tag:github.com,2025-08-24:/SDWebImage/SDWebImageAVIFCoder</id>
    <link href="https://github.com/SDWebImage/SDWebImageAVIFCoder" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A SDWebImage coder plugin to support AVIF(AV1 Image File Format) image&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SDWebImageAVIFCoder&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/SDWebImage/SDWebImageAVIFCoder/actions/workflows/check-image-decoding.yml&#34;&gt;&lt;img src=&#34;https://github.com/SDWebImage/SDWebImageAVIFCoder/actions/workflows/check-image-decoding.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34; /&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/SDWebImageAVIFCoder&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/SDWebImageAVIFCoder.svg?style=flat&#34; alt=&#34;Version&#34; /&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/SDWebImageAVIFCoder&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/l/SDWebImageAVIFCoder.svg?style=flat&#34; alt=&#34;License&#34; /&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/SDWebImageAVIFCoder&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/SDWebImageAVIFCoder.svg?style=flat&#34; alt=&#34;Platform&#34; /&gt;&lt;/a&gt; &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/SwiftPM-compatible-brightgreen.svg?style=flat&#34; alt=&#34;SwiftPM compatible&#34; /&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/SDWebImage/SDWebImageAVIFCoder&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34; /&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s for&lt;/h2&gt; &#xA;&lt;p&gt;This is a &lt;a href=&#34;https://github.com/rs/SDWebImage&#34;&gt;SDWebImage&lt;/a&gt; coder plugin to add &lt;a href=&#34;https://aomediacodec.github.io/av1-avif/&#34;&gt;AV1 Image File Format (AVIF)&lt;/a&gt; support. Which is built based on the open-sourced &lt;a href=&#34;https://github.com/AOMediaCodec/libavif&#34;&gt;libavif&lt;/a&gt; codec.&lt;/p&gt; &#xA;&lt;p&gt;This AVIF coder plugin support AVIF still/sequence image. Including alpha channel, as well as 10bit/12bit/16bit HDR images. (The AVIF sequence animation is available from v0.9.0).&lt;/p&gt; &#xA;&lt;p&gt;The AVIF encoding is also supported now. Which always encode as 8-bit depth images.&lt;/p&gt; &#xA;&lt;p&gt;See the demo for the more showcase.&lt;/p&gt; &#xA;&lt;h2&gt;Note&lt;/h2&gt; &#xA;&lt;p&gt;AVIF image spec is still in evolve. And the current upstream AVIF codec is a simple implementation. The encoding time may be long for large images.&lt;/p&gt; &#xA;&lt;p&gt;Since we rely on the external codec libavif. We may periodically update the dependency and bump version. Make sure you&#39;re using the latest version as possible as you can :)&lt;/p&gt; &#xA;&lt;h2&gt;AV1 Codec&lt;/h2&gt; &#xA;&lt;p&gt;libavif is a image codec. But AVIF is based on the AV1 Video standard. So it need a AV1 codec for support. This relationship is just like HEIF(image) and HEVC(video) codec.&lt;/p&gt; &#xA;&lt;p&gt;You can choose the codec and use &lt;code&gt;libavif&lt;/code&gt; CocoaPods subspec to choose the one you&#39;d like.&lt;/p&gt; &#xA;&lt;h3&gt;aom&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For Carthage/SwifftPM&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;libavif is built with &lt;a href=&#34;https://aomedia.googlesource.com/aom/&#34;&gt;aom&lt;/a&gt; codec support. aom is the first AV1 codec during the standard draft implementation. The aom support both decodinng and encoding&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For CocoaPods&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Because of strange design of &lt;strong&gt;subspec dependencies resolution algorithm&lt;/strong&gt;, we can not make aom by default (or all the subspecs will always link aom, which means not optional). So libavif is built with nothing codec (&lt;code&gt;libavif/core&lt;/code&gt;). You need to choose the actual AV1 codec using one or more of below.&lt;/p&gt; &#xA;&lt;p&gt;If you want to use aom, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;libavif/liaom&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or other AV1 codec, like dav1d:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;libavif/libdav1d&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;dav1d (Decoding)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/videolan/dav1d&#34;&gt;dav1d&lt;/a&gt; is the new and next generation AV1 codec, focused on speed and correctness.&lt;/p&gt; &#xA;&lt;p&gt;See more about &lt;a href=&#34;https://github.com/videolan/dav1d#why-do-you-not-improve-libaom-rather-than-starting-a-new-project&#34;&gt;explanation for why starting a new project but not improving aom&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;From v0.3.0, libavif can built with dav1d. For CocoaPods user, you can simply use the subspec for this. Carthage for optional dav1d codec is not supported currently.&lt;/p&gt; &#xA;&lt;h3&gt;libgav1 (Decoding)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://chromium.googlesource.com/codecs/libgav1/&#34;&gt;libgav1&lt;/a&gt; is a Main profile (0) &amp;amp; High profile (1) compliant AV1 decoder. More information on the AV1 video format can be found at aomedia.org.&lt;/p&gt; &#xA;&lt;p&gt;From v0.8.3, libavif can built with libgav1. For For CocoaPods user, you can simply use the subspec for this.&lt;/p&gt; &#xA;&lt;h3&gt;rav1e (Encoding)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/xiph/rav1e&#34;&gt;rav1e&lt;/a&gt; is the fastest and safest AV1 encoder. Which use &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust programming&lt;/a&gt; to provide fast and safe codec compared to aom. Its current form it is most suitable for cases where libaom (the reference encoder) is too slow.&lt;/p&gt; &#xA;&lt;p&gt;See more about &lt;a href=&#34;https://github.com/xiph/rav1e/issues/1248&#34;&gt;performance&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;From v0.4.3, libavif can built with rav1e. For CocoaPods user, you can simply use the subspec for this. Carthage/SPM for optional rav1c codec is not supported currently.&lt;/p&gt; &#xA;&lt;p&gt;Note: The librav1e on CocoaPods use pre-built static-linking binary. Which means, it can not be used for CocoaPods&#39;s dynamic-linking.&lt;/p&gt; &#xA;&lt;p&gt;To use for framework package format (CocoaPods defaults use ar archive format), you should write something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;use_frameworks! :linkage =&amp;gt; :static&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but not this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;use_frameworks!&#xA;# use_frameworks! :linkage =&amp;gt; :dynamic&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: before librav1e v0.6.1, it only support iOS &amp;amp;&amp;amp; macOS. watchOS and tvOS is avaiable from v0.6.2 with the latest Rust toolchain. And for visionOS supports need Rust community upstream support. For latest integration, check or fire issues in &lt;a href=&#34;https://github.com/SDWebImage/librav1e-Xcode&#34;&gt;https://github.com/SDWebImage/librav1e-Xcode&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;SVT-AV1 (Encoding)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitlab.com/AOMediaCodec/SVT-AV1&#34;&gt;SVT-AV1&lt;/a&gt; is the Scalable Video Technology for AV1 (SVT-AV1 Encoder and Decoder) is an AV1-compliant encoder/decoder library core.&lt;/p&gt; &#xA;&lt;p&gt;From v0.8.3, libavif can built with STV-AV1. For For CocoaPods user, you can simply use the subspec for this.&lt;/p&gt; &#xA;&lt;h2&gt;Choose codec at runtime&lt;/h2&gt; &#xA;&lt;p&gt;Although libavif has a automatic detection of installed AVIF codec, but for example, &lt;code&gt;aom&lt;/code&gt; supports both decoding and encoding, but slower than &lt;code&gt;rav1e&lt;/code&gt; on encoding.&lt;/p&gt; &#xA;&lt;p&gt;You can force to use the &lt;code&gt;aom&lt;/code&gt; for decoding and &lt;code&gt;rav1e&lt;/code&gt; for encoding like this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-C&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSDictionary *decodeOptions = [SDImageCoderAVIFDecodeCodecChoice: @(AVIF_CODEC_CHOICE_AOM)];&#xA;NSDictionary *encodeOptions = [SDImageCoderAVIFEncodeCodecChoice: @(AVIF_CODEC_CHOICE_RAV1E)];&#xA;&#xA;// Pass from UI level options&#xA;[imageView sd_setImageWithURL:url placeholderImage:nil options:0 context:@{SDWebImageContextImageDecodeOptions: decodeOptions, SDWebImageContextImageEncodeOptions: encodeOptions} progress:nil completed:nil];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let decodeOptions: [SDImageCoderOption: Any] = [.avifDecodeCodecChoice: AVIF_CODEC_CHOICE_AOM.rawValue]&#xA;let encodeOptions = [SDImageCoderOption: Any] = [.avifEncodeCodecChoice: AVIF_CODEC_CHOICE_RAV1E.rawValue]&#xA;&#xA;// Pass from UI level options&#xA;imageView.sd_setImage(with: url, placeholderImage: nil, options: [], context: [.imageDecodeOptions: decodeOptions, .imageEncodeOptions: encodeOptions], progress: nil, completed: nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iOS 9&lt;/li&gt; &#xA; &lt;li&gt;macOS 10.11&lt;/li&gt; &#xA; &lt;li&gt;tvOS 9.0&lt;/li&gt; &#xA; &lt;li&gt;watchOS 2.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h4&gt;CocoaPods&lt;/h4&gt; &#xA;&lt;p&gt;SDWebImageAVIFCoder is available through &lt;a href=&#34;https://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt;. To install it with default aom AV1 codec, simply add the following line to your Podfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;SDWebImageAVIFCoder&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: From version 0.4.0, if you want to use rav1e or dav1e instead aom for faster AV1 codec, control the subspec of libavif instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;SDWebImageAVIFCoder&#39;&#xA;pod &#39;libavif&#39;, :subspecs =&amp;gt; [&#xA;  &#39;libdav1d&#39;,&#xA;  &#39;librav1e&#39;&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or, for libgav1 &amp;amp;&amp;amp; SVT-AV1, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;SDWebImageAVIFCoder&#39;&#xA;pod &#39;libavif&#39;, :subspecs =&amp;gt; [&#xA;  &#39;libgva1&#39;,&#xA;  &#39;SVT-AV1&#39;&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: From version 0.2.0, the dependency libavif and libaom use the portable C implementation to works on Apple platforms. If you need the pre-built library with SIMD/AVX and assembly optimization, try the 0.1.0 version.&lt;/p&gt; &#xA;&lt;h4&gt;Carthage&lt;/h4&gt; &#xA;&lt;p&gt;SDWebImageAVIFCoder is available through &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;SDWebImage/SDWebImageAVIFCoder&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Carthage does not support like CocoaPods&#39; subspec, it only supports libaom for AVIF decoding &amp;amp;&amp;amp; encoding.&lt;/p&gt; &#xA;&lt;h4&gt;Swift Package Manager (Xcode 11+)&lt;/h4&gt; &#xA;&lt;p&gt;SDWebImageAVIFCoder is available through &lt;a href=&#34;https://swift.org/package-manager&#34;&gt;Swift Package Manager&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The framework through SwiftPM only supports libaom for AVIF decoding &amp;amp;&amp;amp; encoding.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let package = Package(&#xA;    dependencies: [&#xA;        .package(url: &#34;https://github.com/SDWebImage/SDWebImageAVIFCoder.git&#34;, from: &#34;0.5&#34;)&#xA;    ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;To use AVIF coder, you should firstly add the &lt;code&gt;SDImageAVIFCoder.sharedCoder&lt;/code&gt; to the coders manager. Then you can call the View Category method to start load AVIF images.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-C&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;SDImageAVIFCoder *AVIFCoder = SDImageAVIFCoder.sharedCoder;&#xA;[[SDImageCodersManager sharedManager] addCoder:AVIFCoder];&#xA;UIImageView *imageView;&#xA;[imageView sd_setImageWithURL:url];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let AVIFCoder = SDImageAVIFCoder.shared&#xA;SDImageCodersManager.shared.addCoder(AVIFCoder)&#xA;let imageView: UIImageView&#xA;imageView.sd_setImage(with: url)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Decoding&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-C&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// AVIF image decoding&#xA;NSData *avifData;&#xA;UIImage *image = [[SDImageAVIFCoder sharedCoder] decodedImageWithData:avifData options:nil];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// AVIF image decoding&#xA;let avifData: Data&#xA;let image = SDImageAVIFCoder.shared.decodedImage(with: data, options: nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Thumbnail Decoding (0.10.0+)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-C&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// AVIF thumbnail image decoding&#xA;NSData *avifData;&#xA;CGSize thumbnailSize = CGSizeMake(300, 300);&#xA;UIImage *thumbnailImage = [[SDImageAVIFCoder sharedCoder] decodedImageWithData:avifData options:@{SDImageCoderDecodeThumbnailPixelSize : @(thumbnailSize)}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// AVIF thumbnail image decoding&#xA;let avifData: Data&#xA;let thumbnailSize = CGSize(width: 300, height: 300)&#xA;let image = SDImageAVIFCoder.shared.decodedImage(with: data, options: [.decodeThumbnailPixelSize: thumbnailSize])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Encoding (No animtion support)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objective-c&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;// AVIF image encoding&#xA;UIImage *image;&#xA;NSData *avifData = [[SDImageAVIFCoder sharedCoder] encodedDataWithImage:image format:SDImageFormatAVIF options:nil];&#xA;// Encode Quality&#xA;NSData *lossyAVIFData = [[SDImageAVIFCoder sharedCoder] encodedDataWithImage:image format:SDImageFormatAVIF options:@{SDImageCoderEncodeCompressionQuality : @(0.1)}]; // [0, 1] compression quality&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// AVIF image encoding&#xA;let image: UIImage&#xA;let avifData = SDImageAVIFCoder.shared.encodedData(with: image, format: .avif, options: nil)&#xA;// Encode Quality&#xA;let lossyAVIFData = SDImageAVIFCoder.shared.encodedData(with: image, format: .avif, options: [.encodeCompressionQuality: 0.1]) // [0, 1] compression quality&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Screenshot&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/SDWebImage/SDWebImageAVIFCoder/master/Example/Screenshot/AVIFDemo-iOS.png&#34; width=&#34;300&#34; /&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/SDWebImage/SDWebImageAVIFCoder/master/Example/Screenshot/AVIFDemo-macOS.png&#34; width=&#34;600&#34; /&gt; &#xA;&lt;p&gt;The images are from &lt;a href=&#34;https://github.com/AOMediaCodec/av1-avif/tree/master/testFiles&#34;&gt;AV1 Still Image File Format Specification Test Files&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;AVIF Image Viewer&lt;/h2&gt; &#xA;&lt;p&gt;AVIF is a new image format, which lack of related toolchains like Browser or Desktop Viewer support.&lt;/p&gt; &#xA;&lt;p&gt;You can try &lt;a href=&#34;https://github.com/dreampiggy/AVIFQuickLook&#34;&gt;AVIFQuickLook&lt;/a&gt; QuickLook plugin on macOS to view it in Finder.&lt;/p&gt; &#xA;&lt;p&gt;You can also try using &lt;a href=&#34;https://kagami.github.io/avif.js/&#34;&gt;avif.js&lt;/a&gt; to view it online by using Chrome&#39;s AV1 codec.&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;SDWebImageAVIFCoder use &lt;a href=&#34;https://github.com/SDWebImage/SDWebImageAVIFCoder/actions&#34;&gt;GitHub Actions&lt;/a&gt; for testing. Each merge request will run the test cases to ensure the AVIF decoding/encoding function works.&lt;/p&gt; &#xA;&lt;p&gt;Current test cases use macOS command line tools, to compare the AVIF sample decoding result with &lt;a href=&#34;https://www.imagemagick.org/&#34;&gt;ImageMagick&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We have also the XCTest unit test target, you can run it by using Xcode&#39;s Test action.&lt;/p&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;DreamPiggy, &lt;a href=&#34;mailto:lizhuoli1126@126.com&#34;&gt;lizhuoli1126@126.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributor&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ledyba-z&#34;&gt;ledyba-z&lt;/a&gt;, &lt;a href=&#34;mailto:ryo.hirafuji@gmail.com&#34;&gt;ryo.hirafuji@gmail.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;SDWebImageAVIFCoder is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/AOMediaCodec/libavif&#34;&gt;libavif&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aomedia.googlesource.com/aom/&#34;&gt;aom&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/videolan/dav1d&#34;&gt;dav1d&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dreampiggy/AVIFQuickLook&#34;&gt;AVIFQuickLook&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Kagami/avif.js&#34;&gt;avif.js&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>datatheorem/TrustKit</title>
    <updated>2025-08-24T01:48:29Z</updated>
    <id>tag:github.com,2025-08-24:/datatheorem/TrustKit</id>
    <link href="https://github.com/datatheorem/TrustKit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Easy SSL pinning validation and reporting for iOS, macOS, tvOS and watchOS.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;TrustKit&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://app.bitrise.io/app/fe29405fb90f94ea&#34;&gt;&lt;img src=&#34;https://app.bitrise.io/app/fe29405fb90f94ea/status.svg?token=TJ3o4dhSWa--0ZlJT7FV1A&#34; alt=&#34;Build Status&#34; /&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34; /&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/TrustKit&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/TrustKit.svg?style=flat&#34; alt=&#34;Version Status&#34; /&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/TrustKit&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/TrustKit.svg?style=flat&#34; alt=&#34;Platform&#34; /&gt;&lt;/a&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/MIT_License&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/l/TrustKit.svg?style=flat&#34; alt=&#34;License MIT&#34; /&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/TrustKit/Lobby&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/datatheorem/gitter.png&#34; alt=&#34;Gitter chat&#34; /&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;TrustKit&lt;/strong&gt; is an open source framework that makes it easy to deploy SSL public key pinning and reporting in any iOS 12+, macOS 10.13+, tvOS 12+ or watchOS 4+ App; it supports both Swift and Objective-C Apps.&lt;/p&gt; &#xA;&lt;p&gt;If you need SSL pinning/reporting in your Android App. we have also released &lt;strong&gt;TrustKit for Android&lt;/strong&gt; at &lt;a href=&#34;https://github.com/datatheorem/TrustKit-Android&#34;&gt;https://github.com/datatheorem/TrustKit-Android&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;TrustKit&lt;/strong&gt; provides the following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simple API to configure an SSL pinning policy and enforce it within an App. The policy settings are heavily based on the &lt;a href=&#34;https://tools.ietf.org/html/rfc7469&#34;&gt;HTTP Public Key Pinning specification&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Sane implementation by pinning the certificate&#39;s Subject Public Key Info, &lt;a href=&#34;https://www.imperialviolet.org/2011/05/04/pinning.html&#34;&gt;as opposed to the certificate itself or the public key bits&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Reporting mechanism to notify a server about pinning validation failures happening within the App, when an unexpected certificate chain is detected. This is similar to the &lt;em&gt;report-uri&lt;/em&gt; directive described in the HPKP specification. The reporting mechanism can also be customized within the App by leveraging pin validation notifications sent by TrustKit.&lt;/li&gt; &#xA; &lt;li&gt;Auto-pinning functionality by swizzling the App&#39;s &lt;em&gt;NSURLConnection&lt;/em&gt; and &lt;em&gt;NSURLSession&lt;/em&gt; delegates in order to automatically add pinning validation to the App&#39;s HTTPS connections; this allows deploying &lt;strong&gt;TrustKit&lt;/strong&gt; without even modifying the App&#39;s source code.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Read the &lt;a href=&#34;https://github.com/datatheorem/TrustKit/raw/master/docs/getting-started.md&#34;&gt;Getting Started&lt;/a&gt; guide.&lt;/li&gt; &#xA; &lt;li&gt;Check out the &lt;a href=&#34;https://datatheorem.github.io/TrustKit/documentation&#34;&gt;API documentation&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;TrustKit was initially released at &lt;a href=&#34;https://github.com/datatheorem/TrustKit/raw/master/docs/TrustKit-BH2015.pdf&#34;&gt;Black Hat USA 2015&lt;/a&gt; and was also featured on &lt;a href=&#34;https://www.paypal-engineering.com/2015/10/14/key-pinning-in-mobile-applications/&#34;&gt;PayPal&#39;s engineering blog&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Sample Usage&lt;/h2&gt; &#xA;&lt;p&gt;Deploying SSL pinning in the App requires initializing &lt;strong&gt;TrustKit&lt;/strong&gt; with a pinning policy (domains, Subject Public Key Info hashes, and additional settings).&lt;/p&gt; &#xA;&lt;p&gt;The policy can be configured within the App&#39;s &lt;code&gt;Info.plist&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://datatheorem.github.io/TrustKit/images/linking3_dynamic.png&#34; alt=&#34;Info.plist policy&#34; /&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, the pinning policy can be set programmatically:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;    NSDictionary *trustKitConfig =&#xA;  @{&#xA;    kTSKSwizzleNetworkDelegates: @NO,&#xA;    kTSKPinnedDomains : @{&#xA;            @&#34;www.datatheorem.com&#34; : @{&#xA;                    kTSKExpirationDate: @&#34;2017-12-01&#34;,&#xA;                    kTSKPublicKeyHashes : @[&#xA;                            @&#34;HXXQgxueCIU5TTLHob/bPbwcKOKw6DkfsTWYHbxbqTY=&#34;,&#xA;                            @&#34;0SDf3cRToyZJaMsoS17oF72VMavLxj/N7WBNasNuiR8=&#34;&#xA;                            ],&#xA;                    kTSKEnforcePinning : @NO,&#xA;                    },&#xA;            @&#34;yahoo.com&#34; : @{&#xA;                    kTSKPublicKeyHashes : @[&#xA;                            @&#34;TQEtdMbmwFgYUifM4LDF+xgEtd0z69mPGmkp014d6ZY=&#34;,&#xA;                            @&#34;rFjc3wG7lTZe43zeYTvPq8k4xdDEutCmIhI5dn4oCeE=&#34;,&#xA;                            ],&#xA;                    kTSKIncludeSubdomains : @YES&#xA;                    }&#xA;            }};&#xA;    &#xA;    [TrustKit initSharedInstanceWithConfiguration:trustKitConfig];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The policy can also be set programmatically in Swift Apps:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;        let trustKitConfig = [&#xA;            kTSKSwizzleNetworkDelegates: false,&#xA;            kTSKPinnedDomains: [&#xA;                &#34;yahoo.com&#34;: [&#xA;                    kTSKExpirationDate: &#34;2017-12-01&#34;,&#xA;                    kTSKPublicKeyHashes: [&#xA;                        &#34;JbQbUG5JMJUoI6brnx0x3vZF6jilxsapbXGVfjhN8Fg=&#34;,&#xA;                        &#34;WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18=&#34;&#xA;                    ],]]] as [String : Any]&#xA;        &#xA;        TrustKit.initSharedInstance(withConfiguration:trustKitConfig)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After TrustKit has been initialized, a &lt;a href=&#34;https://datatheorem.github.io/TrustKit/documentation/Classes/TSKPinningValidator.html&#34;&gt;&lt;code&gt;TSKPinningValidator&lt;/code&gt; instance&lt;/a&gt; can be retrieved from the TrustKit singleton, and can be used to perform SSL pinning validation in the App&#39;s network delegates. For example in an NSURLSessionDelegate:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)URLSession:(NSURLSession *)session &#xA;              task:(NSURLSessionTask *)task &#xA;didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge &#xA; completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler {&#xA;{&#xA;    TSKPinningValidator *pinningValidator = [[TrustKit sharedInstance] pinningValidator];&#xA;    // Pass the authentication challenge to the validator; if the validation fails, the connection will be blocked&#xA;    if (![pinningValidator handleChallenge:challenge completionHandler:completionHandler])&#xA;    {&#xA;        // TrustKit did not handle this challenge: perhaps it was not for server trust&#xA;        // or the domain was not pinned. Fall back to the default behavior&#xA;        completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information, see the &lt;a href=&#34;https://github.com/datatheorem/TrustKit/raw/master/docs/getting-started.md&#34;&gt;Getting Started&lt;/a&gt; guide.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;TrustKit&lt;/strong&gt; is a joint-effort between the mobile teams at Data Theorem and Yahoo. See &lt;code&gt;AUTHORS&lt;/code&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;TrustKit&lt;/strong&gt; is released under the MIT license. See &lt;code&gt;LICENSE&lt;/code&gt; for details.&lt;/p&gt;</summary>
  </entry>
</feed>