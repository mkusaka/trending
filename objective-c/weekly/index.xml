<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-23T02:00:10Z</updated>
  <subtitle>Weekly Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SocketMobile/swift-package-capturesdk</title>
    <updated>2023-07-23T02:00:10Z</updated>
    <id>tag:github.com,2023-07-23:/SocketMobile/swift-package-capturesdk</id>
    <link href="https://github.com/SocketMobile/swift-package-capturesdk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CaptureSDK is the easiest solution for adding barcode scanning and RFID/NFC reading capability to an iOS application&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CaptureSDK Version 1.7.5 - Swift Package Manager&lt;/h1&gt; &#xA;&lt;p&gt;Socket Mobile is a leading innovator of data capture and delivery solutions for enhanced productivity.&lt;/p&gt; &#xA;&lt;p&gt;CaptureSDK is the easiest solution for adding barcode scanning and RFID/NFC reading capability to an iOS application.&lt;/p&gt; &#xA;&lt;p&gt;The Socket Mobile barcode scanner and contactless reader/writer are an ergonomic, fast and accurate solution to a variety of data entry scenarios.&lt;/p&gt; &#xA;&lt;p&gt;This SDK is very easy to integrate to an application without requirement to follow a specific design architecture.&lt;/p&gt; &#xA;&lt;p&gt;Within 10 minutes the barcode scanning or RFID/NFC reading capability can be integrated into an application.&lt;/p&gt; &#xA;&lt;p&gt;The CaptureSDK offers a built-in barcode scanner called SocketCam, allowing to test and integrate the SDK even before getting a Socket Mobile scanner, using the exact same API, which makes the transition from using SocketCam to a Socket scanner totally frictionless.&lt;/p&gt; &#xA;&lt;p&gt;More documentation can be found &lt;a href=&#34;https://docs.socketmobile.com/capture/ios/en/latest/&#34; title=&#34;CaptureSDK Documentation&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Devices compatibility and CaptureSDK versions&lt;/h1&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Devices&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&amp;lt; 1.4&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;1.4&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;1.5&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;1.6&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;1.7&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;SocketCam C820&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;S720/D720/S820&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;D600, S550, and all other barcode scanners&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;S370&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;M930&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SocketMobile/swift-package-capturesdk/master/#breaking-changes&#34;&gt;Breaking changes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SocketMobile/swift-package-capturesdk/master/#quick-install-notes&#34;&gt;Quick install notes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SocketMobile/swift-package-capturesdk/master/#capture-usage&#34;&gt;CaptureSDK usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SocketMobile/swift-package-capturesdk/master/#sample-code&#34;&gt;Sample code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SocketMobile/swift-package-capturesdk/master/#socketcam-c820&#34;&gt;SocketCam C820&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SocketMobile/swift-package-capturesdk/master/#configure-and-connect-a-socket-mobile-device&#34;&gt;Configure and connect a Socket Mobile device&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SocketMobile/swift-package-capturesdk/master/#device-notifications-battery-level&#34;&gt;Device Notifications (Battery Level)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SocketMobile/swift-package-capturesdk/master/#closing-capture&#34;&gt;Closing Capture&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Breaking changes&lt;/h1&gt; &#xA;&lt;p&gt;We have improved and changed some things in our architecture to prepare the future. The SDK still works as you expect. However we have made some changes that don&#39;t require too much effort from you:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The SDK is now a framework, not a static library anymore&lt;/li&gt; &#xA; &lt;li&gt;The name is now &lt;code&gt;CaptureSDK&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/SocketMobile/cocoapods-capture&#34;&gt;cocoapods-capture&lt;/a&gt; and &lt;a href=&#34;https://github.com/SocketMobile/cocoapods-capture-obj-c&#34;&gt;cocoapods-capture-obj-c&lt;/a&gt; are now deprecated. However, this new framework is more to be used in Swift projects&lt;/li&gt; &#xA; &lt;li&gt;The minimum target is now iOS 11.0&lt;/li&gt; &#xA; &lt;li&gt;SocketCam C820, formerly known as SoftScan has been improved and allows you to scan with your device and not with a scanner&lt;/li&gt; &#xA; &lt;li&gt;Capture Helper is now included into the framework - &lt;a href=&#34;https://docs.socketmobile.com/capture/ios/en/latest/captureHelper.html&#34;&gt;CaptureHelper&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Bitcode has been enabled in the version 1.5.5 but disabled in the version 1.5.7 build with Xcode 14. If you need a version with Bitcode enabled, please use the 1.5.5&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Quick install notes&lt;/h1&gt; &#xA;&lt;p&gt;CaptureSDK is using &lt;a href=&#34;https://www.swift.org/package-manager/&#34;&gt;Swift Package Manager&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;First, you need to install Xcode.&lt;/p&gt; &#xA;&lt;p&gt;To include the SDK in your Xcode project you have to add a &lt;code&gt;Package Dependency&lt;/code&gt; in the project&#39;s settings section and in the tab &#34;Package Dependencies&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Add the url of this repository: &lt;a href=&#34;https://github.com/SocketMobile/swift-package-capturesdk.git&#34;&gt;https://github.com/SocketMobile/swift-package-capturesdk.git&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SocketMobile/swift-package-capturesdk/master/docs/add-to-your-project.png&#34; alt=&#34;Add the Package to the project&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Once you have added the package, you should see &lt;code&gt;CaptureSDK&lt;/code&gt; added to your Package Dependencies in Xcode&#39;s Project Navigator as follow:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SocketMobile/swift-package-capturesdk/master/docs/added-to-your-project.png&#34; alt=&#34;Added Package to the project&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;VERY IMPORTANT&lt;/strong&gt;: Supported external accessory protocols array in the application settings. In order to be able to use the Socket Mobile barcode scanners, the scanners external accessory protocol string needs to be added in the application project info in the &lt;strong&gt;supported external accessory protocols array&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The protocol string is &lt;code&gt;com.socketmobile.chs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If the application does use a Socket Mobile barcode scanner it will need to be MFi whitelisted before submitting the application in the App Store. Socket Mobile will handle the whitelist (MFi) application process for you, when you submit your app for MFi in your Socket Mobile developer account. This has to be done once for the first version supporting the barcode scanner.&lt;/p&gt; &#xA;&lt;p&gt;You also need to add the following key to your &lt;code&gt;Info.plist&lt;/code&gt;: &lt;strong&gt;CFBundleAllowMixedLocalizations&lt;/strong&gt; (&lt;em&gt;Localized resources can be mixed&lt;/em&gt;) to &lt;strong&gt;&lt;code&gt;YES&lt;/code&gt;&lt;/strong&gt;. That allows or SDK to display localized strings.&lt;/p&gt; &#xA;&lt;p&gt;An AppKey is required in order to use CaptureSDK.&lt;/p&gt; &#xA;&lt;p&gt;The AppKey can be generated by logging in Socket Mobile developer portal and registering your application.&lt;/p&gt; &#xA;&lt;p&gt;This registration needs the Socket Mobile developer ID, the application Bundle ID (which is case sensitive).&lt;/p&gt; &#xA;&lt;p&gt;Now you&#39;re ready to add &lt;code&gt;import CaptureSDK&lt;/code&gt; in your main controller, and make it derive from one of the &lt;code&gt;CaptureHelperDelegate&lt;/code&gt; that your application needs.&lt;/p&gt; &#xA;&lt;p&gt;Go to the &lt;code&gt;CaptureHelperDelegate&lt;/code&gt; source and copy paste the delegates you want to override, at minimum the onDecodedData delegate in order to be able to receive the barcode decoded data in your application.&lt;/p&gt; &#xA;&lt;h1&gt;CaptureSDK usage&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;CaptureSDK&lt;/code&gt; is described in greater details in the &lt;a href=&#34;https://docs.socketmobile.com/capture/ios/en/latest/&#34; title=&#34;CaptureSDK Documentation&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The recommended way of using &lt;code&gt;CaptureSDK&lt;/code&gt; is by using &lt;code&gt;CaptureHelper&lt;/code&gt;. &lt;code&gt;CaptureHelper&lt;/code&gt; is now included into the framework and not as a separate file: &lt;a href=&#34;https://docs.socketmobile.com/capture/ios/en/latest/captureHelper.html&#34;&gt;CaptureHelper&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;1. Getting a &lt;code&gt;CaptureHelper&lt;/code&gt; instance&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;CaptureHelper&lt;/code&gt; can be instantiated in one of your application controllers using its &lt;code&gt;CaptureHelper.sharedInstance&lt;/code&gt; static member.&lt;/p&gt; &#xA;&lt;h2&gt;2. &lt;code&gt;CaptureHelper&lt;/code&gt; delegates stack&lt;/h2&gt; &#xA;&lt;p&gt;The chosen controller must implement one of the &lt;code&gt;CaptureHelper[xxxxx]Delegate&lt;/code&gt; protocols in order to receive the various &lt;code&gt;CaptureSDK&lt;/code&gt; asynchronous events.&lt;/p&gt; &#xA;&lt;p&gt;The reference of the controller deriving from at least one of the &lt;code&gt;CaptureHelper[xxxxx]Delegate&lt;/code&gt; can be set by using the &lt;code&gt;CaptureHelper pushDelegate&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CaptureHelper&lt;/code&gt; maintains a delegates stack. The delegate on top of the stack is the one that receives the notification from &lt;code&gt;CaptureSDK&lt;/code&gt;. So if the application has multiple views requiring the scanning feature, it can push a reference of a new view controller to the &lt;code&gt;CaptureHelper&lt;/code&gt; delegates stack, and remove that reference when the view is no longer active.&lt;/p&gt; &#xA;&lt;h2&gt;3. Opening &lt;code&gt;CaptureHelper&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;In order to start &lt;code&gt;CaptureSDK&lt;/code&gt;, the API uses the &lt;code&gt;openWithAppInfo:withCompletionHandler&lt;/code&gt; method with the application information.&lt;/p&gt; &#xA;&lt;p&gt;This open method &lt;strong&gt;can be called only once&lt;/strong&gt;, in the main view controller by example, and the &lt;code&gt;CaptureHelper.sharedInstance&lt;/code&gt; can be used at various place in the application code as singleton reference without the need to pass it through various controllers.&lt;/p&gt; &#xA;&lt;p&gt;The application information is retrieved from the Socket Mobile developer portal, by registering the application with its application ID, the developer ID. The application key is then generated and all three initialize the AppInfo required to open &lt;code&gt;CaptureSDK&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The application ID is composed by the application bundle ID prefixed by the platform on which the application is designed to run.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example of such application ID: &lt;code&gt;&#34;ios:com.socketmobile.SingleEntry&#34;&lt;/code&gt;. The application ID is &lt;strong&gt;case sensitive&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Once &lt;code&gt;CaptureSDK&lt;/code&gt; is open, then the device arrival notification can occurs as soon as a scanner is connected to the iOS device.&lt;/p&gt; &#xA;&lt;p&gt;The decoded data coming from the scanner can be retrieved by overriding the &lt;code&gt;onDecodedData&lt;/code&gt; delegate.&lt;/p&gt; &#xA;&lt;h2&gt;4. Summary for integrating &lt;code&gt;CaptureSDK&lt;/code&gt; in a Xcode project:&lt;/h2&gt; &#xA;&lt;p&gt;Example of ViewController.m for SingleEntry app:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit&#xA;import CaptureSDK&#xA;&#xA;class MasterViewController:&#xA;  UITableViewController,&#xA;  CaptureHelperDevicePresenceDelegate,&#xA;  CaptureHelperDeviceManagerPresenceDelegate,&#xA;  CaptureHelperDeviceDecodedDataDelegate,&#xA;  CaptureHelperErrorDelegate,&#xA;  CaptureHelperDevicePowerDelegate {&#xA;&#xA;&#xA;  // Capture Helper shareInstance allows to share&#xA;  // the same instance of Capture Helper with the&#xA;  // entire application. That static property can&#xA;  // be used in any views but it is recommended&#xA;  // to open only once Capture Helper (in the main&#xA;  // view controller) and pushDelegate, popDelegate&#xA;  // each time a new view requiring scanning capability&#xA;  // is loaded or unloaded respectively.&#xA;  var captureHelper = CaptureHelper.sharedInstance&#xA;&#xA;  override func viewDidLoad() {&#xA;      super.viewDidLoad()&#xA;      // Do any additional setup after loading the view, typically from a nib.&#xA;      // fill out the App Info with the Bundle ID which should start by the&#xA;      // platform on which the application is running and followed with the&#xA;      // case sensitive application Bundle ID,&#xA;      // with the Socket Mobile Portal developer ID&#xA;      // and with the Application Key generated from the Socket Mobile Developer&#xA;      // portal&#xA;      let AppInfo = SKTAppInfo()&#xA;      AppInfo.appKey = &#34;MC0CFQD1tdTpaABkppmG+iP3dB9kolYVtwIUY8c3UmEfaPoTI3AxbPOTpNgw+fo=&#34;&#xA;      AppInfo.appID = &#34;ios:com.socketmobile.SingleEntrySwift&#34;&#xA;      AppInfo.developerID = &#34;bb57d8e1-f911-47ba-b510-693be162686a&#34;&#xA;&#xA;      // there is a stack of delegates the last push is the&#xA;      // delegate active, when a new view requiring notifications from the&#xA;      // scanner, then push its delegate and pop its delegate when the&#xA;      // view is done&#xA;      captureHelper.pushDelegate(self)&#xA;&#xA;      // to make all the delegates able to update the UI without the app&#xA;      // having to dispatch the UI update code, set the dispatchQueue&#xA;      // property to the DispatchQueue.main&#xA;      captureHelper.dispatchQueue = DispatchQueue.main&#xA;&#xA;      // open Capture Helper only once in the application&#xA;      captureHelper.openWithAppInfo(AppInfo, withCompletionHandler: { (_ result: SKTResult) in&#xA;          print(&#34;Result of Capture initialization: \(result.rawValue)&#34;)&#xA;      })&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;CaptureHelper&lt;/code&gt; makes the application aware of a new device connection by invoking the &lt;code&gt;onDeviceArrival&lt;/code&gt; of the protocol and, in the same way when a device disconnects, the &lt;code&gt;onDeviceRemoval&lt;/code&gt; is invoked. A &lt;code&gt;CaptureHelper&lt;/code&gt; device instance representing the device that is connected can be used to retrieve or set a device property.&lt;/p&gt; &#xA;&lt;p&gt;Example of the view controller being aware of the scanner:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func didNotifyArrivalForDevice(_ device: CaptureHelperDevice, withResult result: SKTResult) {&#xA;    print(&#34;Main view device arrival:\(device.deviceInfo.name!)&#34;)&#xA;}&#xA;&#xA;func didNotifyRemovalForDevice(_ device: CaptureHelperDevice, withResult result: SKTResult) {&#xA;    print(&#34;Main view device removal:\(device.deviceInfo.name!)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a combo device like the S370 which has 2 devices, there will be two &lt;code&gt;didNotifyArrivalForDevice&lt;/code&gt; and two &lt;code&gt;didNotifyRemovalForDevice&lt;/code&gt; notifications.&lt;/p&gt; &#xA;&lt;p&gt;The following code shows how you can distinghuish and handle them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func didNotifyArrivalForDevice(_ device: CaptureHelperDevice, withResult result: SKTResult) {&#xA;    print(&#34;didNotifyArrivalForDevice: \(String(describing: device.deviceInfo.name))&#34;)&#xA;    if device.deviceInfo.deviceType == .NFCS370 {&#xA;    // handle the NFC reader of the S370&#xA;    } else if device.deviceInfo.deviceType == .scannerS370 {&#xA;    // handle the Barcode scanner of the S370&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the scanner triggers a scan, the decoded data can be retrieve in the protocol function &lt;code&gt;onDecodedData&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Example of retrieving the decoded data received by a scanner:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func didReceiveDecodedData(_ decodedData: SKTCaptureDecodedData?, fromDevice device: CaptureHelperDevice, withResult result: SKTResult) {&#xA;    if result == SKTCaptureErrors.E_NOERROR {&#xA;        let rawData = decodedData?.decodedData&#xA;        let rawDataSize = rawData?.count&#xA;        print(&#34;Size: \(String(describing: rawDataSize))&#34;)&#xA;        print(&#34;data: \(String(describing: decodedData?.decodedData))&#34;)&#xA;        let string = decodedData?.stringFromDecodedData()!&#xA;        print(&#34;Decoded Data \(String(describing: string))&#34;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The application can retrieve or modify the device properties by calling the various &lt;code&gt;CaptureHelperDevice&lt;/code&gt; get/set methods. By example there is a method to retrieve the device friendly name: &lt;code&gt;getFriendlyNameWithCompletionHandler&lt;/code&gt;. The call is asynchronous and will return immediately. The final result and the friendly name can be retrieved in the completion handler function block.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;IMPORTANT&lt;/strong&gt;: If a property is not accessible through the available &lt;code&gt;CaptureHelper&lt;/code&gt; methods, it is very easy to add new ones, by creating a &lt;code&gt;CaptureHelper&lt;/code&gt; &lt;strong&gt;extension&lt;/strong&gt; class and copy and paste a similar get/set method and change the property settings inside the new method.&lt;/p&gt; &#xA;&lt;p&gt;Creating a &lt;code&gt;CaptureHelper&lt;/code&gt; extension allows to avoid an overwrite of a modified version of &lt;code&gt;CaptureHelper&lt;/code&gt; when updating to a more recent &lt;code&gt;CaptureSDK&lt;/code&gt; CocoaPods.&lt;/p&gt; &#xA;&lt;h1&gt;Sample code&lt;/h1&gt; &#xA;&lt;p&gt;Sample code can be found in &lt;a href=&#34;https://github.com/SocketMobile&#34; title=&#34;Socket Mobile Samples&#34;&gt;GitHub / SocketMobile&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;SocketCam C820&lt;/h1&gt; &#xA;&lt;p&gt;We have included &lt;code&gt;SocketCam C820&lt;/code&gt; into the SDK, formerly known as SoftScan.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;SocketCam&lt;/code&gt; feature refers to the capability of using the phone&#39;s camera in order to scan a barcode. The main purpose of integrating this feature in &lt;code&gt;CaptureSDK&lt;/code&gt; is to provide a consistent interface to barcode readers.&lt;/p&gt; &#xA;&lt;p&gt;Whether it is a Socket Mobile scanner, or simply the phone&#39;s camera, the application relies on the same interface, same API, which makes the transition from using SocketCam to a physical Socket scanner totally frictionless.&lt;/p&gt; &#xA;&lt;p&gt;The application using the &lt;code&gt;SocketCam&lt;/code&gt; feature needs to do 2 things differently, which Socket Mobile scanners don&#39;t require.&lt;/p&gt; &#xA;&lt;p&gt;The first thing is to register the application main UI view to &lt;code&gt;CaptureSDK&lt;/code&gt; so the camera overlay view can be displayed correctly by passing the UI application reference to the overlay property &lt;code&gt;kSktCapturePropIdOverlayViewDevice&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The second thing is to provide a trigger logic that starts the &lt;code&gt;SocketCam&lt;/code&gt; scanning operation. The trigger is a &lt;code&gt;CaptureSDK&lt;/code&gt; property &lt;code&gt;kSktCapturePropIdTriggerDevice&lt;/code&gt; that exists since the first version of &lt;code&gt;CaptureSDK&lt;/code&gt;, whereas the overlay view property has been added to support &lt;code&gt;SocketCam&lt;/code&gt; feature.&lt;/p&gt; &#xA;&lt;p&gt;A third property &lt;code&gt;kSktCapturePropIdSocketCamStatus&lt;/code&gt; allows to enable or disable the &lt;code&gt;SocketCam&lt;/code&gt; feature. This is a &lt;code&gt;CaptureSDK&lt;/code&gt; property that is persistent across the life cycle of the application using it.&lt;/p&gt; &#xA;&lt;p&gt;If the &lt;code&gt;SocketCam&lt;/code&gt; feature is enabled, &lt;code&gt;CaptureSDK&lt;/code&gt; will send a device arrival notification to the application referencing a &lt;code&gt;SocketCam&lt;/code&gt; device the application can control.&lt;/p&gt; &#xA;&lt;p&gt;Once the application triggers a read, the decoded data arrives the same way with the same information than as any other Socket Mobile devices supported by &lt;code&gt;CaptureSDK&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For more information please check the &lt;a href=&#34;https://docs.socketmobile.com/capture/ios/en/latest/&#34; title=&#34;CaptureSDK Documentation&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Configure and connect a Socket Mobile device&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;CaptureSDK&lt;/code&gt; is designed for using all of the Socket Mobile devices on the iOS platforms.&lt;/p&gt; &#xA;&lt;p&gt;As the application developer, &lt;code&gt;CaptureSDK&lt;/code&gt; will give you full programmatic access to a connected Socket Mobile data capture device to customize the data source (barcode symbology or RFID Tag), data support and manage device feedback messages and functions.&lt;/p&gt; &#xA;&lt;p&gt;The API documentation for &lt;code&gt;CaptureSDK&lt;/code&gt; can be found &lt;a href=&#34;https://docs.socketmobile.com/capture/ios/en/latest/&#34; title=&#34;Capture Documentation&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The Socket Mobile devices are shipped by default in &lt;strong&gt;MFi mode&lt;/strong&gt; which is compatible with the &lt;code&gt;CaptureSDK&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The device can be configured to the &lt;strong&gt;Application mode&lt;/strong&gt; by using the &lt;a href=&#34;https://itunes.apple.com/us/app/socket-mobile-companion/id1175638950?mt=8&#34; title=&#34;Socket Mobile Companion&#34;&gt;Socket Mobile Companion app&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also refer to the &lt;a href=&#34;https://docs.socketmobile.com/capture/ios/en/latest/ConfigureInAppMode.html&#34; title=&#34;Configure and connect scanner&#34;&gt;documentation&lt;/a&gt; for instructions without using Companion.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;BLE DEVICES&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;For D600, S550 and S370, the BLE Device manager must have a favorite set to &lt;code&gt;*&lt;/code&gt; and for more information please check the &lt;a href=&#34;https://docs.socketmobile.com/capture/ios/en/latest/&#34; title=&#34;CaptureSDK Documentation&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Themes selection&lt;/h1&gt; &#xA;&lt;p&gt;The Themes Selection allows to choose LEDs sequences that are played on S550 or S370 devices. Please check the &lt;a href=&#34;https://docs.socketmobile.com/capture/ios/en/latest/topicsThemesSelection.html&#34; title=&#34;CaptureSDK Documentation - Themes Selection&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Device Notifications (Battery Level)&lt;/h1&gt; &#xA;&lt;p&gt;The Device Notifications can be configured in order to receive a notification each time one or more of those events occur:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Battery Level change&lt;/li&gt; &#xA; &lt;li&gt;Power State change&lt;/li&gt; &#xA; &lt;li&gt;Buttons State change&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default the device notifications are turned off. The recommended usage is to first check if a particular notification is turned off or on. Depending on this reading, then the application can set a specific notification to be received if it is not already set. That setting stays persistent in the Socket Mobile device across scanner shutdown. It is not recommended to set systematically a notification in the device without checking first if that setting is already correct.&lt;/p&gt; &#xA;&lt;p&gt;For the Battery Level and Power State, it could take a long time before the state changes, so usually the initial value is read using the corresponding &lt;code&gt;CaptureHelper&lt;/code&gt; Get method.&lt;/p&gt; &#xA;&lt;p&gt;Last, some devices don&#39;t support some of the notifications. If that&#39;s the case, an error &lt;code&gt;ESKT_NOTSUPPORTED (-15)&lt;/code&gt; is returned when trying to set a notification that is not supported.&lt;/p&gt; &#xA;&lt;p&gt;For more information please check the &lt;a href=&#34;https://docs.socketmobile.com/capture/ios/en/latest/&#34; title=&#34;CaptureSDK Documentation&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Closing &lt;code&gt;CaptureSDK&lt;/code&gt;&lt;/h1&gt; &#xA;&lt;p&gt;It is not recommended to close &lt;code&gt;CaptureSDK&lt;/code&gt; because the scanner will go through reinitialization the next time &lt;code&gt;CaptureSDK&lt;/code&gt; is open which causes a delay before being able to use the scanner.&lt;/p&gt; &#xA;&lt;p&gt;Closing &lt;code&gt;CaptureSDK&lt;/code&gt; does not affect power consumption, since the scanner stays connected to the iOS host anyway.&lt;/p&gt; &#xA;&lt;p&gt;It is also worth noting that when the Socket Mobile device is connected the power consumption is really minimal, compare to establishing a connection.&lt;/p&gt; &#xA;&lt;p&gt;If the motive of closing &lt;code&gt;CaptureSDK&lt;/code&gt; is to not receive any decoded data from the device then the application delegate can simply be removed and the application will no longer receive any event from the scanner until it sets its delegate back again.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>google/eDistantObject</title>
    <updated>2023-07-23T02:00:10Z</updated>
    <id>tag:github.com,2023-07-23:/google/eDistantObject</id>
    <link href="https://github.com/google/eDistantObject" rel="alternate"></link>
    <summary type="html">&lt;p&gt;eDistantObject (eDO) - Remote invocation library for iOS&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;eDistantObject&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/google/eDistantObject/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-Apache%202-lightgrey.svg?style=flat&#34; alt=&#34;Apache License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/google/eDistantObject&#34;&gt;&lt;img src=&#34;https://travis-ci.org/google/eDistantObject.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;eDistantObject (easyDistantObject or eDO) provides users an easy way to make remote invocations between processes in Objective-C and Swift without explicitly constructing RPC structures.&lt;/p&gt; &#xA;&lt;p&gt;Similar to &lt;a href=&#34;https://developer.apple.com/reference/foundation/nsdistantobject?language=objc&#34;&gt;NSDistantObject&lt;/a&gt;, eDistantObject takes advantage of Objective-C runtime features: it behaves as a proxy, or a puppet, in one process, and when it receives the message, it forwards the message via the communication layer (POSIX socket) to the object in a different process.&lt;/p&gt; &#xA;&lt;p&gt;You can find the guideline to setup eDO and try it with your code in &lt;a href=&#34;https://raw.githubusercontent.com/google/eDistantObject/master/docs/setup.md&#34;&gt;Setup Guide&lt;/a&gt;, and more about how eDO actually works in &lt;a href=&#34;https://raw.githubusercontent.com/google/eDistantObject/master/docs/detail.md&#34;&gt;Details Doc&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;p&gt;Consider a typical use case, where a Client needs to communicate with a Host. The usage steps for eDO are broken into three main steps:&lt;/p&gt; &#xA;&lt;h3&gt;1. &lt;a href=&#34;https://raw.githubusercontent.com/google/eDistantObject/master/docs/terminology.md#hostremote-process&#34;&gt;Host&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;On the host side, an &lt;code&gt;EDOHostService&lt;/code&gt; must be created so that the eDistantObject is set up. Say this is done in a file &lt;code&gt;Host.m&lt;/code&gt;. Adding the following code will setup a simple distant object.&lt;/p&gt; &#xA;&lt;p&gt;The execution queue will hold a strong reference to the EDOHostService, so it needs to be retained to keep the service alive. To stop serving the root object, we can either call the invalidate API or release the queue, which implicitly invalidates the service hosting the root object.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;FooClass&lt;/code&gt; is just a placeholder. Any class can be used in this way.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;- (void)startUp {&#xA;  // Arbitrary port number for starting the service. Ensure that this doesn&#39;t&#xA;  // conflict with any existing ports being used.&#xA;  UInt16 portNumber = 12345;&#xA;&#xA;  // The root object exposed is associated with a dispatch queue, any invocation made&#xA;  // on this object will have its invocations forwarded to the host. The invocations&#xA;  // will be dispatched to the associated queue.&#xA;  FooClass *rootObject = [[FooClass alloc] init];&#xA;  // If the execution queue is released, the EDOHostService running in this&#xA;  // queue will be released as well. Users can choose their own way to&#xA;  // retain the queue.&#xA;  self.executionQueue = dispatch_queue_create(&#34;MyQueue&#34;, DISPATCH_QUEUE_SERIAL);&#xA;  [EDOHostService serviceWithPort:portNumber&#xA;                       rootObject:rootObject&#xA;                            queue:self.executionQueue];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;2. &lt;a href=&#34;https://raw.githubusercontent.com/google/eDistantObject/master/docs/terminology.md#shared-header&#34;&gt;Shared Header&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;So that both the client and the host are aware of the methods available in the &lt;code&gt;FooClass&lt;/code&gt; class, the header &lt;code&gt;FooClass.h&lt;/code&gt; needs to be exposed in both the host as well as the client targets. However, any calls from the client side will be forwarded to the host, hence &lt;code&gt;FooClass.m&lt;/code&gt; will only need to be compiled and linked with the Host process.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;# FooClass.h&#xA;&#xA;@interface FooClass&#xA;- (void)method1;&#xA;@end&#xA;&#xA;# FooClass.m omitted [Present only in the Host Process, containing the implementation of method1]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3. &lt;a href=&#34;https://raw.githubusercontent.com/google/eDistantObject/master/docs/terminology.md#client-process&#34;&gt;Client&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;In the client side, say a file &lt;code&gt;Client.m&lt;/code&gt; makes a call to the distant object, &lt;code&gt;FooClass&lt;/code&gt;. For this purpose, the client will have to fetch the root distant object using &lt;code&gt;EDOClientService&lt;/code&gt;. Once this is set up, the distant object can be used as if it were a local object, with calls proxied to the host.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;&#xA;- (void)someMethod {&#xA;  // The object, fetched remotely from the host is seen by the client to be the same as a local&#xA;  // object.&#xA;  FooClass *rootObject = [EDOClientService rootObjectWithPort:portNumber];&#xA;  [rootObject method1];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information please look at &lt;a href=&#34;https://raw.githubusercontent.com/google/eDistantObject/master/docs/setup.md#where-to-write-code&#34;&gt;Where to write code&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Swift Support&lt;/h2&gt; &#xA;&lt;p&gt;eDO can also work on Swift although it uses features of Objective-C as long as the object defined and used are marked to invoke in the Objective-C manner.&lt;/p&gt; &#xA;&lt;p&gt;For Swift support you will need some extra setup. Please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/google/eDistantObject/master/docs/swift.md&#34;&gt;Swift Guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;For Contributors&lt;/h2&gt; &#xA;&lt;p&gt;Please make sure you’ve followed the guidelines in &lt;a href=&#34;https://github.com/google/eDistantObject/raw/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; before making any contributions.&lt;/p&gt; &#xA;&lt;h3&gt;Setup eDistantObject project&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone eDistantObject repository from GitHub:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/google/eDistantObject.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;After you have cloned the eDistantObject repository, install dependencies:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Open &lt;code&gt;eDistantObject.xcworkspace&lt;/code&gt; and ensure that all the targets build.&lt;/li&gt; &#xA; &lt;li&gt;You can now use &lt;code&gt;eDistantObject.xcworkspace&lt;/code&gt; to make changes to the project.&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>PojavLauncherTeam/PojavLauncher_iOS</title>
    <updated>2023-07-23T02:00:10Z</updated>
    <id>tag:github.com,2023-07-23:/PojavLauncherTeam/PojavLauncher_iOS</id>
    <link href="https://github.com/PojavLauncherTeam/PojavLauncher_iOS" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Minecraft: Java Edition Launcher for Android and iOS based on Boardwalk. This repository contains source code for iOS/iPadOS platform.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PojavLauncher for iOS&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/PojavLauncherTeam/PojavLauncher_iOS/actions/workflows/development.yml&#34;&gt;&lt;img src=&#34;https://github.com/PojavLauncherTeam/PojavLauncher_iOS/actions/workflows/development.yml/badge.svg?branch=main&#34; alt=&#34;Development build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crowdin.com/project/pojavlauncher&#34;&gt;&lt;img src=&#34;https://badges.crowdin.net/pojavlauncher/localized.svg?sanitize=true&#34; alt=&#34;Crowdin&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/pojavlauncher-724163890803638273&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/724163890803638273.svg?label=&amp;amp;logo=discord&amp;amp;logoColor=ffffff&amp;amp;color=7389D8&amp;amp;labelColor=6A7EC2&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;PojavLauncher is a Minecraft: Java Edition launcher for Android, iOS, and iPadOS, based off of zhouwei&#39;s &lt;a href=&#34;https://github.com/zhouwei/Boardwalk&#34;&gt;Boardwalk&lt;/a&gt; project.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports most versions of Minecraft: Java Edition, from the very first beta to the newest snapshots.&lt;/li&gt; &#xA; &lt;li&gt;Supports Forge, Fabric, OptiFine, and Quilt for you to customize the experience with supported mods.&lt;/li&gt; &#xA; &lt;li&gt;Includes customizable on-screen controls, keyboard and mouse support, and game controller support.&lt;/li&gt; &#xA; &lt;li&gt;Optimized for jailbroken and TrollStore devices to enable better capabilities.&lt;/li&gt; &#xA; &lt;li&gt;Microsoft account and demo mode support for logging into Minecraft.&lt;/li&gt; &#xA; &lt;li&gt;...and much more!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This repository contains the code for our iOS and iPadOS port of PojavLauncher. Looking for &lt;a href=&#34;https://github.com/PojavLauncherTeam/PojavLauncher&#34;&gt;Android?&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting started with PojavLauncher&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://pojavlauncherteam.github.io/INSTALL.html#ios&#34;&gt;PojavLauncher Website&lt;/a&gt; has extensive documentation on how to install, set up, and play! For those who wish to install quickly, here&#39;s the basics:&lt;/p&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;p&gt;At the minimum, you&#39;ll need one of the following devices on &lt;strong&gt;iOS 14.0&lt;/strong&gt; and later:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iPhone 6s and later&lt;/li&gt; &#xA; &lt;li&gt;iPad (5th generation) and later&lt;/li&gt; &#xA; &lt;li&gt;iPad Air (2nd generation) and later&lt;/li&gt; &#xA; &lt;li&gt;iPad mini (4th generation) and later&lt;/li&gt; &#xA; &lt;li&gt;iPad Pro (all models)&lt;/li&gt; &#xA; &lt;li&gt;iPod touch (7th generation)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;However, we recommend one of the following devices on &lt;strong&gt;iOS 14.0&lt;/strong&gt; and later:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iPhone XS and later, excluding iPhone XR and iPhone SE (2nd generation)&lt;/li&gt; &#xA; &lt;li&gt;iPad (10th generation) and later&lt;/li&gt; &#xA; &lt;li&gt;iPad Air (4th generation) and later&lt;/li&gt; &#xA; &lt;li&gt;iPad mini (6th generation) and later&lt;/li&gt; &#xA; &lt;li&gt;iPad Pro (all models, except for 9.7-inch)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Recommended devices provide a smoother and more enjoyable gameplay experience compared to other supported devices.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;tvOS support is in development.&lt;/li&gt; &#xA; &lt;li&gt;iOS 17 is not currently supported, as Apple broke every iOS app debugger outside of Xcode.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Setting up to sideload&lt;/h3&gt; &#xA;&lt;p&gt;PojavLauncher can be sideloaded in many ways. Our recommended solution is to install &lt;a href=&#34;https://github.com/opa334/TrollStore&#34;&gt;TrollStore&lt;/a&gt; if your iOS version supports it. Installing with TrollStore allows you to permenantly sign the application, automatically enable JIT, and increase memory limits.&lt;/p&gt; &#xA;&lt;p&gt;If you cannot, &lt;a href=&#34;https://altstore.io&#34;&gt;AltStore&lt;/a&gt; and &lt;a href=&#34;https://sidestore.io&#34;&gt;SideStore&lt;/a&gt; are your next best options.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Signing services that do not use your UDID (and use distribution certificates) are not supported, as PojavLauncher requires capabilities they do not allow.&lt;/li&gt; &#xA; &lt;li&gt;Only install sideloading software and PojavLauncher from trusted sources. We are not responsible for any harm caused by using unofficial software.&lt;/li&gt; &#xA; &lt;li&gt;Jailbreaks also benefit from permenant signing, autoJIT, and increased memory limits, however we do not recommend them for regular use.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Installing PojavLauncher&lt;/h3&gt; &#xA;&lt;h4&gt;Release build (TrollStore)&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download an IPA of PojavLauncher in &lt;a href=&#34;https://github.com/PojavLauncherTeam/PojavLauncher_iOS/releases&#34;&gt;Releases&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Open the package in TrollStore using the share menu.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Release build (AltStore/SideStore trusted source)&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add &lt;code&gt;PojavLauncher Repository&lt;/code&gt; from the Trusted Sources menu.&lt;/li&gt; &#xA; &lt;li&gt;Tap &lt;code&gt;FREE&lt;/code&gt; to begin installing.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Nightly builds&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;These builds can contain game-breaking bugs. Use with caution.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download an IPA build of PojavLauncher in the &lt;a href=&#34;https://github.com/PojavLauncherTeam/PojavLauncher_iOS/actions&#34;&gt;Actions tab&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Open the downloaded IPA in your sideloading app to install.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Enabling JIT&lt;/h3&gt; &#xA;&lt;p&gt;PojavLauncher makes use of &lt;strong&gt;just-in-time compilation&lt;/strong&gt;, or JIT, to provide usable speeds for the end user. JIT is not supported on iOS without the application being debugged, so workarounds are required to enable it. You can use this chart to determine the best solution for you and your setup.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Application&lt;/th&gt; &#xA;   &lt;th&gt;AltStore&lt;/th&gt; &#xA;   &lt;th&gt;SideStore&lt;/th&gt; &#xA;   &lt;th&gt;TrollStore&lt;/th&gt; &#xA;   &lt;th&gt;Jitterbug&lt;/th&gt; &#xA;   &lt;th&gt;Jailbroken&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Requires ext-device&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;If VPN unavailable&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Requires Wi-Fi&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Auto enabled&lt;/td&gt; &#xA;   &lt;td&gt;Yes(*)&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;(*) AltServer running on the local network is required.&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;PojavLauncher is amazing, and surprisingly stable, and it wouldn&#39;t be this way without the commmunity that helped and contribute to the project! Some notable names:&lt;/p&gt; &#xA;&lt;p&gt;@khanhduytran0 - Lead iOS port developer&lt;br&gt; @crystall1nedev - Lead iOS port developer&lt;br&gt; @artdeell&lt;br&gt; @Mathius-Boulay&lt;br&gt; @zhuowei&lt;br&gt; @jkcoxson&lt;br&gt; @Diatrus&lt;/p&gt; &#xA;&lt;h2&gt;Third party components and their licenses&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/PojavLauncherTeam/caciocavallo&#34;&gt;Caciocavallo&lt;/a&gt;: &lt;a href=&#34;https://github.com/PojavLauncherTeam/caciocavallo/raw/master/LICENSE&#34;&gt;GNU GPLv2 License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://code.google.com/p/jsr-305&#34;&gt;jsr305&lt;/a&gt;: &lt;a href=&#34;http://opensource.org/licenses/BSD-3-Clause&#34;&gt;3-Clause BSD License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/zhuowei/Boardwalk&#34;&gt;Boardwalk&lt;/a&gt;: &lt;a href=&#34;https://github.com/zhuowei/Boardwalk/raw/master/LICENSE&#34;&gt;Apache 2.0 License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ptitSeb/gl4es&#34;&gt;GL4ES&lt;/a&gt; by @lunixbochs @ptitSeb: &lt;a href=&#34;https://github.com/ptitSeb/gl4es/raw/master/LICENSE&#34;&gt;MIT License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gitlab.freedesktop.org/mesa/mesa&#34;&gt;Mesa 3D Graphics Library&lt;/a&gt;: &lt;a href=&#34;https://docs.mesa3d.org/license.html&#34;&gt;MIT License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/khanhduytran0/metalangle&#34;&gt;MetalANGLE&lt;/a&gt; by @kakashidinho and ANGLE team: &lt;a href=&#34;https://github.com/kakashidinho/metalangle/raw/master/LICENSE&#34;&gt;BSD 2.0 License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/KhronosGroup/MoltenVK&#34;&gt;MoltenVK&lt;/a&gt;: &lt;a href=&#34;https://github.com/KhronosGroup/MoltenVK/raw/master/LICENSE&#34;&gt;Apache 2.0 License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kcat/openal-soft&#34;&gt;openal-soft&lt;/a&gt;: &lt;a href=&#34;https://github.com/kcat/openal-soft/raw/master/COPYING&#34;&gt;LGPLv2 License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.azul.com/downloads/?package=jdk&#34;&gt;Azul Zulu JDK&lt;/a&gt;: &lt;a href=&#34;https://openjdk.java.net/legal/gplv2+ce.html&#34;&gt;GNU GPLv2 License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/PojavLauncherTeam/lwjgl3&#34;&gt;LWJGL3&lt;/a&gt;: &lt;a href=&#34;https://github.com/LWJGL/lwjgl3/raw/master/LICENSE.md&#34;&gt;BSD-3 License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/PojavLauncherTeam/lwjglx&#34;&gt;LWJGLX&lt;/a&gt; (LWJGL2 API compatibility layer for LWJGL3): unknown license.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/khanhduytran0/DBNumberedSlider&#34;&gt;DBNumberedSlider&lt;/a&gt;: &lt;a href=&#34;https://github.com/immago/DBNumberedSlider/raw/master/LICENSE&#34;&gt;Apache 2.0 License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/khanhduytran0/fishhook&#34;&gt;fishhook&lt;/a&gt;: &lt;a href=&#34;https://github.com/facebook/fishhook/raw/main/LICENSE&#34;&gt;BSD-3 License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/java-native-access/jna&#34;&gt;Java Native Access&lt;/a&gt;: &lt;a href=&#34;https://github.com/java-native-access/jna/raw/master/LICENSE&#34;&gt;Apache 2.0 License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/khanhduytran0/shaderc&#34;&gt;shaderc&lt;/a&gt; (used by Vulkan rendering mods): &lt;a href=&#34;https://github.com/google/shaderc/raw/main/LICENSE&#34;&gt;Apache 2.0 License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mozilla-mobile/firefox-ios/tree/b2f89ac40835c5988a1a3eb642982544e00f0f90/ThirdParty/NRFileManager&#34;&gt;NRFileManager&lt;/a&gt;: &lt;a href=&#34;https://www.mozilla.org/en-US/MPL/2.0&#34;&gt;MPL-2.0 License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rileytestut/AltKit&#34;&gt;AltKit&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/abbeycode/UnzipKit&#34;&gt;UnzipKit&lt;/a&gt;: &lt;a href=&#34;https://github.com/abbeycode/UnzipKit/raw/master/LICENSE&#34;&gt;BSD-2 License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/xpn/DyldDeNeuralyzer&#34;&gt;DyldDeNeuralyzer&lt;/a&gt;: bypasses Library Validation for loading external runtime&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://mc-heads.net&#34;&gt;MCHeads&lt;/a&gt; for providing Minecraft avatars.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Special thanks to MacStadium!&lt;/h2&gt; &#xA;&lt;p&gt;This project is listed under the MacStadium Open Source Program, which allows all of us developers to keep on moving forward even without physical access to a Mac.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/55281754/183129754-c3736bb9-d528-4af7-9351-a12b3be7549e.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- sillysock was here --&gt;</summary>
  </entry>
</feed>