<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-25T01:51:19Z</updated>
  <subtitle>Weekly Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ReactiveCocoa/ReactiveObjC</title>
    <updated>2024-02-25T01:51:19Z</updated>
    <id>tag:github.com,2024-02-25:/ReactiveCocoa/ReactiveObjC</id>
    <link href="https://github.com/ReactiveCocoa/ReactiveObjC" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The 2.x ReactiveCocoa Objective-C API: Streams of values over time&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ReactiveObjC&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE: This is legacy introduction to the Objective-C ReactiveCocoa, which is now known as ReactiveObjC. For the updated version that uses Swift, please see &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa&#34;&gt;ReactiveCocoa&lt;/a&gt; or &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveSwift&#34;&gt;ReactiveSwift&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;ReactiveObjC (formally ReactiveCocoa or RAC) is an Objective-C framework inspired by &lt;a href=&#34;http://en.wikipedia.org/wiki/Functional_reactive_programming&#34;&gt;Functional Reactive Programming&lt;/a&gt;. It provides APIs for &lt;strong&gt;composing and transforming streams of values&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re already familiar with functional reactive programming or know the basic premise of ReactiveObjC, check out the other documentation in this folder for a framework overview and more in-depth information about how it all works in practice.&lt;/p&gt; &#xA;&lt;h2&gt;New to ReactiveObjC?&lt;/h2&gt; &#xA;&lt;p&gt;ReactiveObjC is documented like crazy, and there&#39;s a wealth of introductory material available to explain what RAC is and how you can use it.&lt;/p&gt; &#xA;&lt;p&gt;If you want to learn more, we recommend these resources, roughly in order:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/#when-to-use-reactiveobjc&#34;&gt;When to use ReactiveObjC&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/Documentation/FrameworkOverview.md&#34;&gt;Framework Overview&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/Documentation/BasicOperators.md&#34;&gt;Basic Operators&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/ReactiveObjC/&#34;&gt;Header documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Previously answered &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa/wiki&#34;&gt;Stack Overflow&lt;/a&gt; questions and &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa/issues?labels=question&amp;amp;state=closed&#34;&gt;GitHub issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;The rest of this folder&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://leanpub.com/iosfrp/&#34;&gt;Functional Reactive Programming on iOS&lt;/a&gt; (eBook)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you have any further questions, please feel free to &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveObjC/issues/new&#34;&gt;file an issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;ReactiveObjC is inspired by &lt;a href=&#34;http://blog.maybeapps.com/post/42894317939/input-and-output&#34;&gt;functional reactive programming&lt;/a&gt;. Rather than using mutable variables which are replaced and modified in-place, RAC provides signals (represented by &lt;code&gt;RACSignal&lt;/code&gt;) that capture present and future values.&lt;/p&gt; &#xA;&lt;p&gt;By chaining, combining, and reacting to signals, software can be written declaratively, without the need for code that continually observes and updates values.&lt;/p&gt; &#xA;&lt;p&gt;For example, a text field can be bound to the latest time, even as it changes, instead of using additional code that watches the clock and updates the text field every second. It works much like KVO, but with blocks instead of overriding &lt;code&gt;-observeValueForKeyPath:ofObject:change:context:&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Signals can also represent asynchronous operations, much like &lt;a href=&#34;http://en.wikipedia.org/wiki/Futures_and_promises&#34;&gt;futures and promises&lt;/a&gt;. This greatly simplifies asynchronous software, including networking code.&lt;/p&gt; &#xA;&lt;p&gt;One of the major advantages of RAC is that it provides a single, unified approach to dealing with asynchronous behaviors, including delegate methods, callback blocks, target-action mechanisms, notifications, and KVO.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a simple example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// When self.username changes, logs the new name to the console.&#xA;//&#xA;// RACObserve(self, username) creates a new RACSignal that sends the current&#xA;// value of self.username, then the new value whenever it changes.&#xA;// -subscribeNext: will execute the block whenever the signal sends a value.&#xA;[RACObserve(self, username) subscribeNext:^(NSString *newName) {&#xA;&#x9;NSLog(@&#34;%@&#34;, newName);&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But unlike KVO notifications, signals can be chained together and operated on:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Only logs names that starts with &#34;j&#34;.&#xA;//&#xA;// -filter returns a new RACSignal that only sends a new value when its block&#xA;// returns YES.&#xA;[[RACObserve(self, username)&#xA;&#x9;filter:^(NSString *newName) {&#xA;&#x9;&#x9;return [newName hasPrefix:@&#34;j&#34;];&#xA;&#x9;}]&#xA;&#x9;subscribeNext:^(NSString *newName) {&#xA;&#x9;&#x9;NSLog(@&#34;%@&#34;, newName);&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Signals can also be used to derive state. Instead of observing properties and setting other properties in response to the new values, RAC makes it possible to express properties in terms of signals and operations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Creates a one-way binding so that self.createEnabled will be&#xA;// true whenever self.password and self.passwordConfirmation&#xA;// are equal.&#xA;//&#xA;// RAC() is a macro that makes the binding look nicer.&#xA;//&#xA;// +combineLatest:reduce: takes an array of signals, executes the block with the&#xA;// latest value from each signal whenever any of them changes, and returns a new&#xA;// RACSignal that sends the return value of that block as values.&#xA;RAC(self, createEnabled) = [RACSignal&#xA;&#x9;combineLatest:@[ RACObserve(self, password), RACObserve(self, passwordConfirmation) ]&#xA;&#x9;reduce:^(NSString *password, NSString *passwordConfirm) {&#xA;&#x9;&#x9;return @([passwordConfirm isEqualToString:password]);&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Signals can be built on any stream of values over time, not just KVO. For example, they can also represent button presses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Logs a message whenever the button is pressed.&#xA;//&#xA;// RACCommand creates signals to represent UI actions. Each signal can&#xA;// represent a button press, for example, and have additional work associated&#xA;// with it.&#xA;//&#xA;// -rac_command is an addition to NSButton. The button will send itself on that&#xA;// command whenever it&#39;s pressed.&#xA;self.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^(id _) {&#xA;&#x9;NSLog(@&#34;button was pressed!&#34;);&#xA;&#x9;return [RACSignal empty];&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or asynchronous network operations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Hooks up a &#34;Log in&#34; button to log in over the network.&#xA;//&#xA;// This block will be run whenever the login command is executed, starting&#xA;// the login process.&#xA;self.loginCommand = [[RACCommand alloc] initWithSignalBlock:^(id sender) {&#xA;&#x9;// The hypothetical -logIn method returns a signal that sends a value when&#xA;&#x9;// the network request finishes.&#xA;&#x9;return [client logIn];&#xA;}];&#xA;&#xA;// -executionSignals returns a signal that includes the signals returned from&#xA;// the above block, one for each time the command is executed.&#xA;[self.loginCommand.executionSignals subscribeNext:^(RACSignal *loginSignal) {&#xA;&#x9;// Log a message whenever we log in successfully.&#xA;&#x9;[loginSignal subscribeCompleted:^{&#xA;&#x9;&#x9;NSLog(@&#34;Logged in successfully!&#34;);&#xA;&#x9;}];&#xA;}];&#xA;&#xA;// Executes the login command when the button is pressed.&#xA;self.loginButton.rac_command = self.loginCommand;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Signals can also represent timers, other UI events, or anything else that changes over time.&lt;/p&gt; &#xA;&lt;p&gt;Using signals for asynchronous operations makes it possible to build up more complex behavior by chaining and transforming those signals. Work can easily be triggered after a group of operations completes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Performs 2 network operations and logs a message to the console when they are&#xA;// both completed.&#xA;//&#xA;// +merge: takes an array of signals and returns a new RACSignal that passes&#xA;// through the values of all of the signals and completes when all of the&#xA;// signals complete.&#xA;//&#xA;// -subscribeCompleted: will execute the block when the signal completes.&#xA;[[RACSignal&#xA;&#x9;merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]]&#xA;&#x9;subscribeCompleted:^{&#xA;&#x9;&#x9;NSLog(@&#34;They&#39;re both done!&#34;);&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Signals can be chained to sequentially execute asynchronous operations, instead of nesting callbacks with blocks. This is similar to how &lt;a href=&#34;http://en.wikipedia.org/wiki/Futures_and_promises&#34;&gt;futures and promises&lt;/a&gt; are usually used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Logs in the user, then loads any cached messages, then fetches the remaining&#xA;// messages from the server. After that&#39;s all done, logs a message to the&#xA;// console.&#xA;//&#xA;// The hypothetical -logInUser methods returns a signal that completes after&#xA;// logging in.&#xA;//&#xA;// -flattenMap: will execute its block whenever the signal sends a value, and&#xA;// returns a new RACSignal that merges all of the signals returned from the block&#xA;// into a single signal.&#xA;[[[[client&#xA;&#x9;logInUser]&#xA;&#x9;flattenMap:^(User *user) {&#xA;&#x9;&#x9;// Return a signal that loads cached messages for the user.&#xA;&#x9;&#x9;return [client loadCachedMessagesForUser:user];&#xA;&#x9;}]&#xA;&#x9;flattenMap:^(NSArray *messages) {&#xA;&#x9;&#x9;// Return a signal that fetches any remaining messages.&#xA;&#x9;&#x9;return [client fetchMessagesAfterMessage:messages.lastObject];&#xA;&#x9;}]&#xA;&#x9;subscribeNext:^(NSArray *newMessages) {&#xA;&#x9;&#x9;NSLog(@&#34;New messages: %@&#34;, newMessages);&#xA;&#x9;} completed:^{&#xA;&#x9;&#x9;NSLog(@&#34;Fetched all messages.&#34;);&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;RAC even makes it easy to bind to the result of an asynchronous operation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Creates a one-way binding so that self.imageView.image will be set as the user&#39;s&#xA;// avatar as soon as it&#39;s downloaded.&#xA;//&#xA;// The hypothetical -fetchUserWithUsername: method returns a signal which sends&#xA;// the user.&#xA;//&#xA;// -deliverOn: creates new signals that will do their work on other queues. In&#xA;// this example, it&#39;s used to move work to a background queue and then back to the main thread.&#xA;//&#xA;// -map: calls its block with each user that&#39;s fetched and returns a new&#xA;// RACSignal that sends values returned from the block.&#xA;RAC(self.imageView, image) = [[[[client&#xA;&#x9;fetchUserWithUsername:@&#34;joshaber&#34;]&#xA;&#x9;deliverOn:[RACScheduler scheduler]]&#xA;&#x9;map:^(User *user) {&#xA;&#x9;&#x9;// Download the avatar (this is done on a background queue).&#xA;&#x9;&#x9;return [[NSImage alloc] initWithContentsOfURL:user.avatarURL];&#xA;&#x9;}]&#xA;&#x9;// Now the assignment will be done on the main thread.&#xA;&#x9;deliverOn:RACScheduler.mainThreadScheduler];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That demonstrates some of what RAC can do, but it doesn&#39;t demonstrate why RAC is so powerful. It&#39;s hard to appreciate RAC from README-sized examples, but it makes it possible to write code with less state, less boilerplate, better code locality, and better expression of intent.&lt;/p&gt; &#xA;&lt;p&gt;For more sample code, check out &lt;a href=&#34;https://github.com/AshFurrow/C-41&#34;&gt;C-41&lt;/a&gt; or &lt;a href=&#34;https://github.com/jspahrsummers/GroceryList&#34;&gt;GroceryList&lt;/a&gt;, which are real iOS apps written using ReactiveObjC. Additional information about RAC can be found in this folder.&lt;/p&gt; &#xA;&lt;h2&gt;When to use ReactiveObjC&lt;/h2&gt; &#xA;&lt;p&gt;Upon first glance, ReactiveObjC is very abstract, and it can be difficult to understand how to apply it to concrete problems.&lt;/p&gt; &#xA;&lt;p&gt;Here are some of the use cases that RAC excels at.&lt;/p&gt; &#xA;&lt;h3&gt;Handling asynchronous or event-driven data sources&lt;/h3&gt; &#xA;&lt;p&gt;Much of Cocoa programming is focused on reacting to user events or changes in application state. Code that deals with such events can quickly become very complex and spaghetti-like, with lots of callbacks and state variables to handle ordering issues.&lt;/p&gt; &#xA;&lt;p&gt;Patterns that seem superficially different, like UI callbacks, network responses, and KVO notifications, actually have a lot in common. &lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/ReactiveOjC/RACSignal.h&#34;&gt;RACSignal&lt;/a&gt; unifies all these different APIs so that they can be composed together and manipulated in the same way.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;&#xA;static void *ObservationContext = &amp;amp;ObservationContext;&#xA;&#xA;- (void)viewDidLoad {&#xA;&#x9;[super viewDidLoad];&#xA;&#xA;&#x9;[LoginManager.sharedManager addObserver:self forKeyPath:@&#34;loggingIn&#34; options:NSKeyValueObservingOptionInitial context:&amp;amp;ObservationContext];&#xA;&#x9;[NSNotificationCenter.defaultCenter addObserver:self selector:@selector(loggedOut:) name:UserDidLogOutNotification object:LoginManager.sharedManager];&#xA;&#xA;&#x9;[self.usernameTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];&#xA;&#x9;[self.passwordTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];&#xA;&#x9;[self.logInButton addTarget:self action:@selector(logInPressed:) forControlEvents:UIControlEventTouchUpInside];&#xA;}&#xA;&#xA;- (void)dealloc {&#xA;&#x9;[LoginManager.sharedManager removeObserver:self forKeyPath:@&#34;loggingIn&#34; context:ObservationContext];&#xA;&#x9;[NSNotificationCenter.defaultCenter removeObserver:self];&#xA;}&#xA;&#xA;- (void)updateLogInButton {&#xA;&#x9;BOOL textFieldsNonEmpty = self.usernameTextField.text.length &amp;gt; 0 &amp;amp;&amp;amp; self.passwordTextField.text.length &amp;gt; 0;&#xA;&#x9;BOOL readyToLogIn = !LoginManager.sharedManager.isLoggingIn &amp;amp;&amp;amp; !self.loggedIn;&#xA;&#x9;self.logInButton.enabled = textFieldsNonEmpty &amp;amp;&amp;amp; readyToLogIn;&#xA;}&#xA;&#xA;- (IBAction)logInPressed:(UIButton *)sender {&#xA;&#x9;[[LoginManager sharedManager]&#xA;&#x9;&#x9;logInWithUsername:self.usernameTextField.text&#xA;&#x9;&#x9;password:self.passwordTextField.text&#xA;&#x9;&#x9;success:^{&#xA;&#x9;&#x9;&#x9;self.loggedIn = YES;&#xA;&#x9;&#x9;} failure:^(NSError *error) {&#xA;&#x9;&#x9;&#x9;[self presentError:error];&#xA;&#x9;&#x9;}];&#xA;}&#xA;&#xA;- (void)loggedOut:(NSNotification *)notification {&#xA;&#x9;self.loggedIn = NO;&#xA;}&#xA;&#xA;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {&#xA;&#x9;if (context == ObservationContext) {&#xA;&#x9;&#x9;[self updateLogInButton];&#xA;&#x9;} else {&#xA;&#x9;&#x9;[super observeValueForKeyPath:keyPath ofObject:object change:change context:context];&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;…&amp;nbsp;could be expressed in RAC like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (void)viewDidLoad {&#xA;&#x9;[super viewDidLoad];&#xA;&#xA;&#x9;@weakify(self);&#xA;&#xA;&#x9;RAC(self.logInButton, enabled) = [RACSignal&#xA;&#x9;&#x9;combineLatest:@[&#xA;&#x9;&#x9;&#x9;self.usernameTextField.rac_textSignal,&#xA;&#x9;&#x9;&#x9;self.passwordTextField.rac_textSignal,&#xA;&#x9;&#x9;&#x9;RACObserve(LoginManager.sharedManager, loggingIn),&#xA;&#x9;&#x9;&#x9;RACObserve(self, loggedIn)&#xA;&#x9;&#x9;] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) {&#xA;&#x9;&#x9;&#x9;return @(username.length &amp;gt; 0 &amp;amp;&amp;amp; password.length &amp;gt; 0 &amp;amp;&amp;amp; !loggingIn.boolValue &amp;amp;&amp;amp; !loggedIn.boolValue);&#xA;&#x9;&#x9;}];&#xA;&#xA;&#x9;[[self.logInButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(UIButton *sender) {&#xA;&#x9;&#x9;@strongify(self);&#xA;&#xA;&#x9;&#x9;RACSignal *loginSignal = [LoginManager.sharedManager&#xA;&#x9;&#x9;&#x9;logInWithUsername:self.usernameTextField.text&#xA;&#x9;&#x9;&#x9;password:self.passwordTextField.text];&#xA;&#xA;&#x9;&#x9;&#x9;[loginSignal subscribeError:^(NSError *error) {&#xA;&#x9;&#x9;&#x9;&#x9;@strongify(self);&#xA;&#x9;&#x9;&#x9;&#x9;[self presentError:error];&#xA;&#x9;&#x9;&#x9;} completed:^{&#xA;&#x9;&#x9;&#x9;&#x9;@strongify(self);&#xA;&#x9;&#x9;&#x9;&#x9;self.loggedIn = YES;&#xA;&#x9;&#x9;&#x9;}];&#xA;&#x9;}];&#xA;&#xA;&#x9;RAC(self, loggedIn) = [[NSNotificationCenter.defaultCenter&#xA;&#x9;&#x9;rac_addObserverForName:UserDidLogOutNotification object:nil]&#xA;&#x9;&#x9;mapReplace:@NO];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Chaining dependent operations&lt;/h3&gt; &#xA;&lt;p&gt;Dependencies are most often found in network requests, where a previous request to the server needs to complete before the next one can be constructed, and so on:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[client logInWithSuccess:^{&#xA;&#x9;[client loadCachedMessagesWithSuccess:^(NSArray *messages) {&#xA;&#x9;&#x9;[client fetchMessagesAfterMessage:messages.lastObject success:^(NSArray *nextMessages) {&#xA;&#x9;&#x9;&#x9;NSLog(@&#34;Fetched all messages.&#34;);&#xA;&#x9;&#x9;} failure:^(NSError *error) {&#xA;&#x9;&#x9;&#x9;[self presentError:error];&#xA;&#x9;&#x9;}];&#xA;&#x9;} failure:^(NSError *error) {&#xA;&#x9;&#x9;[self presentError:error];&#xA;&#x9;}];&#xA;} failure:^(NSError *error) {&#xA;&#x9;[self presentError:error];&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ReactiveObjC makes this pattern particularly easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[[[[client logIn]&#xA;&#x9;then:^{&#xA;&#x9;&#x9;return [client loadCachedMessages];&#xA;&#x9;}]&#xA;&#x9;flattenMap:^(NSArray *messages) {&#xA;&#x9;&#x9;return [client fetchMessagesAfterMessage:messages.lastObject];&#xA;&#x9;}]&#xA;&#x9;subscribeError:^(NSError *error) {&#xA;&#x9;&#x9;[self presentError:error];&#xA;&#x9;} completed:^{&#xA;&#x9;&#x9;NSLog(@&#34;Fetched all messages.&#34;);&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parallelizing independent work&lt;/h3&gt; &#xA;&lt;p&gt;Working with independent data sets in parallel and then combining them into a final result is non-trivial in Cocoa, and often involves a lot of synchronization:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;__block NSArray *databaseObjects;&#xA;__block NSArray *fileContents;&#xA;&#xA;NSOperationQueue *backgroundQueue = [[NSOperationQueue alloc] init];&#xA;NSBlockOperation *databaseOperation = [NSBlockOperation blockOperationWithBlock:^{&#xA;&#x9;databaseObjects = [databaseClient fetchObjectsMatchingPredicate:predicate];&#xA;}];&#xA;&#xA;NSBlockOperation *filesOperation = [NSBlockOperation blockOperationWithBlock:^{&#xA;&#x9;NSMutableArray *filesInProgress = [NSMutableArray array];&#xA;&#x9;for (NSString *path in files) {&#xA;&#x9;&#x9;[filesInProgress addObject:[NSData dataWithContentsOfFile:path]];&#xA;&#x9;}&#xA;&#xA;&#x9;fileContents = [filesInProgress copy];&#xA;}];&#xA;&#xA;NSBlockOperation *finishOperation = [NSBlockOperation blockOperationWithBlock:^{&#xA;&#x9;[self finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents];&#xA;&#x9;NSLog(@&#34;Done processing&#34;);&#xA;}];&#xA;&#xA;[finishOperation addDependency:databaseOperation];&#xA;[finishOperation addDependency:filesOperation];&#xA;[backgroundQueue addOperation:databaseOperation];&#xA;[backgroundQueue addOperation:filesOperation];&#xA;[backgroundQueue addOperation:finishOperation];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above code can be cleaned up and optimized by simply composing signals:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;RACSignal *databaseSignal = [[databaseClient&#xA;&#x9;fetchObjectsMatchingPredicate:predicate]&#xA;&#x9;subscribeOn:[RACScheduler scheduler]];&#xA;&#xA;RACSignal *fileSignal = [RACSignal startEagerlyWithScheduler:[RACScheduler scheduler] block:^(id&amp;lt;RACSubscriber&amp;gt; subscriber) {&#xA;&#x9;NSMutableArray *filesInProgress = [NSMutableArray array];&#xA;&#x9;for (NSString *path in files) {&#xA;&#x9;&#x9;[filesInProgress addObject:[NSData dataWithContentsOfFile:path]];&#xA;&#x9;}&#xA;&#xA;&#x9;[subscriber sendNext:[filesInProgress copy]];&#xA;&#x9;[subscriber sendCompleted];&#xA;}];&#xA;&#xA;[[RACSignal&#xA;&#x9;combineLatest:@[ databaseSignal, fileSignal ]&#xA;&#x9;reduce:^ id (NSArray *databaseObjects, NSArray *fileContents) {&#xA;&#x9;&#x9;[self finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents];&#xA;&#x9;&#x9;return nil;&#xA;&#x9;}]&#xA;&#x9;subscribeCompleted:^{&#xA;&#x9;&#x9;NSLog(@&#34;Done processing&#34;);&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Simplifying collection transformations&lt;/h3&gt; &#xA;&lt;p&gt;Higher-order functions like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;/&lt;code&gt;reduce&lt;/code&gt; are sorely missing from Foundation, leading to loop-focused code like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSMutableArray *results = [NSMutableArray array];&#xA;for (NSString *str in strings) {&#xA;&#x9;if (str.length &amp;lt; 2) {&#xA;&#x9;&#x9;continue;&#xA;&#x9;}&#xA;&#xA;&#x9;NSString *newString = [str stringByAppendingString:@&#34;foobar&#34;];&#xA;&#x9;[results addObject:newString];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ReactiveCocoa/ReactiveObjC/master/ReactiveObjC/RACSequence.h&#34;&gt;RACSequence&lt;/a&gt; allows any Cocoa collection to be manipulated in a uniform and declarative way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;RACSequence *results = [[strings.rac_sequence&#xA;&#x9;filter:^ BOOL (NSString *str) {&#xA;&#x9;&#x9;return str.length &amp;gt;= 2;&#xA;&#x9;}]&#xA;&#x9;map:^(NSString *str) {&#xA;&#x9;&#x9;return [str stringByAppendingString:@&#34;foobar&#34;];&#xA;&#x9;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;System Requirements&lt;/h2&gt; &#xA;&lt;p&gt;ReactiveObjC supports OS X 10.8+ and iOS 8.0+.&lt;/p&gt; &#xA;&lt;h2&gt;Importing ReactiveObjC&lt;/h2&gt; &#xA;&lt;p&gt;To add RAC to your application:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add the ReactiveObjC repository as a submodule of your application&#39;s repository.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;git submodule update --init --recursive&lt;/code&gt; from within the ReactiveObjC folder.&lt;/li&gt; &#xA; &lt;li&gt;Drag and drop &lt;code&gt;ReactiveObjC.xcodeproj&lt;/code&gt; into your application&#39;s Xcode project or workspace.&lt;/li&gt; &#xA; &lt;li&gt;On the &#34;Build Phases&#34; tab of your application target, add RAC to the &#34;Link Binary With Libraries&#34; phase.&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;ReactiveObjC.framework&lt;/code&gt;. RAC must also be added to any &#34;Copy Frameworks&#34; build phase. If you don&#39;t already have one, simply add a &#34;Copy Files&#34; build phase and target the &#34;Frameworks&#34; destination.&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;&#34;$(BUILD_ROOT)/../IntermediateBuildFilesPath/UninstalledProducts/include&#34; $(inherited)&lt;/code&gt; to the &#34;Header Search Paths&#34; build setting (this is only necessary for archive builds, but it has no negative effect otherwise).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;For iOS targets&lt;/strong&gt;, add &lt;code&gt;-ObjC&lt;/code&gt; to the &#34;Other Linker Flags&#34; build setting.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;If you added RAC to a project (not a workspace)&lt;/strong&gt;, you will also need to add the appropriate RAC target to the &#34;Target Dependencies&#34; of your application.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;To see a project already set up with RAC, check out &lt;a href=&#34;https://github.com/AshFurrow/C-41&#34;&gt;C-41&lt;/a&gt; or &lt;a href=&#34;https://github.com/jspahrsummers/GroceryList&#34;&gt;GroceryList&lt;/a&gt;, which are real iOS apps written using ReactiveObjC.&lt;/p&gt; &#xA;&lt;h2&gt;More Info&lt;/h2&gt; &#xA;&lt;p&gt;ReactiveObjC is inspired by .NET&#39;s &lt;a href=&#34;http://msdn.microsoft.com/en-us/data/gg577609&#34;&gt;Reactive Extensions&lt;/a&gt; (Rx). Most of the principles of Rx apply to RAC as well. There are some really good Rx resources out there:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh242985.aspx&#34;&gt;Reactive Extensions MSDN entry&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://leecampbell.blogspot.com/2010/08/reactive-extensions-for-net.html&#34;&gt;Reactive Extensions for .NET Introduction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://channel9.msdn.com/tags/Rx/&#34;&gt;Rx - Channel 9 videos&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rxwiki.wikidot.com/&#34;&gt;Reactive Extensions wiki&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rxwiki.wikidot.com/101samples&#34;&gt;101 Rx Samples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Programming-Reactive-Extensions-Jesse-Liberty/dp/1430237473&#34;&gt;Programming Reactive Extensions and LINQ&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;RAC and Rx are both frameworks inspired by functional reactive programming. Here are some resources related to FRP:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://elm-lang.org/learn/What-is-FRP.elm&#34;&gt;What is FRP? - Elm Language&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631&#34;&gt;What is Functional Reactive Programming - Stack Overflow&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525&#34;&gt;Specification for a Functional Reactive Language - Stack Overflow&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.coursera.org/course/reactive&#34;&gt;Principles of Reactive Programming on Coursera&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>AppLovin/AppLovin-MAX-SDK-iOS</title>
    <updated>2024-02-25T01:51:19Z</updated>
    <id>tag:github.com,2024-02-25:/AppLovin/AppLovin-MAX-SDK-iOS</id>
    <link href="https://github.com/AppLovin/AppLovin-MAX-SDK-iOS" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;AppLovin MAX SDK&lt;/h1&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;MAX is AppLovin&#39;s in-app monetization solution.&lt;/p&gt; &#xA;&lt;p&gt;Move beyond the traditional monetization solution and integrate MAX. MAX is a single unbiased auction where advertisers get equal access to all ad inventory and bid simultaneously, which drives more competition and higher CPMs for you. You can read more about it &lt;a href=&#34;https://www.applovin.com/max-header-bidding&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Please check out our &lt;a href=&#34;https://dash.applovin.com/documentation/mediation/ios/getting-started&#34;&gt;documentation&lt;/a&gt; to get started on integrating and enabling mediated networks using our guides.&lt;/p&gt; &#xA;&lt;h2&gt;Demo Apps&lt;/h2&gt; &#xA;&lt;p&gt;To get started with the demo apps, follow the instructions below:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open a Terminal window in the directory of the desired project: &lt;code&gt;DemoApp-ObjC&lt;/code&gt; or &lt;code&gt;DemoApp-Swift&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Install the latest SDK with CocoaPods using &lt;code&gt;pod install --repo-update&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Open the newly generated Xcode workspace file using &lt;code&gt;YOUR_PROJECT_NAME.xcworkspace&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Update the &lt;code&gt;AppLovinSdkKey&lt;/code&gt; value in the &lt;code&gt;Info.plist&lt;/code&gt; file with the Applovin SDK key associated with your account.&lt;/li&gt; &#xA; &lt;li&gt;Update the bundle identifier with your own unique identifier associated with the application you will create (or already created, if it is an existing app) in the MAX dashboard.&lt;/li&gt; &#xA; &lt;li&gt;Update the unique MAX ad unit id value within the view controller code. Each ad format will correspond to a unique MAX ad unit ID you created in the Applovin dashboard for the bundle id used before.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;img src=&#34;https://github.com/AppLovin/AppLovin-MAX-SDK-iOS/assets/144739628/f7317eea-ea0d-47ef-ade3-7ed0a7ca6493&#34; width=&#34;300&#34; height=&#34;700&#34;&gt; &#xA;&lt;h2&gt;Error Codes&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Code&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Indicates an unspecified error with one of the mediated network SDKs.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;204&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Indicates that no ads are currently eligible for your device.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-1001&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Indicates that the ad request timed out (usually due to poor connectivity).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-1009&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Indicates that the device is not connected to the internet (e.g. airplane mode).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-5001&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Indicates that the ad failed to load due to various reasons (such as no networks being able to fill).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-5201&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Indicates an internal state error with the AppLovin MAX SDK.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;We recommend using GitHub to file issues. For feature requests, improvements, questions or any other integration issues using MAX Mediation by AppLovin, contact us via our support page &lt;a href=&#34;https://monetization-support.applovin.com/hc/en-us&#34;&gt;https://monetization-support.applovin.com/hc/en-us&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Squirrel/Squirrel.Mac</title>
    <updated>2024-02-25T01:51:19Z</updated>
    <id>tag:github.com,2024-02-25:/Squirrel/Squirrel.Mac</id>
    <link href="https://github.com/Squirrel/Squirrel.Mac" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Cocoa framework for updating OS X apps&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Squirrel&lt;/h1&gt; &#xA;&lt;p&gt;Squirrel is an OS X framework focused on making application updates &lt;strong&gt;as safe and transparent as updates to a website&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Instead of publishing a feed of versions from which your app must select, Squirrel updates to the version your server tells it to. This allows you to intelligently update your clients based on the request you give to Squirrel. The server can remotely drive behaviors like rolling back or phased rollouts.&lt;/p&gt; &#xA;&lt;p&gt;Your request can include authentication details, custom headers or a request body so that your server has the context it needs in order to supply the most suitable update.&lt;/p&gt; &#xA;&lt;p&gt;The update JSON Squirrel requests should be dynamically generated based on criteria in the request, and whether an update is required. Squirrel relies on server side support for determining whether an update is required, see &lt;a href=&#34;https://raw.githubusercontent.com/Squirrel/Squirrel.Mac/master/#server-support&#34;&gt;Server Support&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Squirrel&#39;s installer is also designed to be fault tolerant, and ensure that any updates installed are valid.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://shipitsquirrel.github.io/images/ship%20it%20squirrel.png&#34; alt=&#34;&lt;img alt=&#39;shipit&#39; src=&#39;https://github.githubassets.com/images/icons/emoji/shipit.png?v8&#39; /&gt;)&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Adopting Squirrel&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install xctool with &lt;code&gt;brew install xctool&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Add the Squirrel repository as a git submodule&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;script/bootstrap&lt;/code&gt; from within the submodule&lt;/li&gt; &#xA; &lt;li&gt;Add references to Squirrel.xcodeproj and its &lt;a href=&#34;https://raw.githubusercontent.com/Squirrel/Squirrel.Mac/master/#dependencies&#34;&gt;dependencies&lt;/a&gt; to your project&lt;/li&gt; &#xA; &lt;li&gt;Add Squirrel.framework as a target dependency&lt;/li&gt; &#xA; &lt;li&gt;Link Squirrel.framework and add it to a Copy Files build phase which copies it into your Frameworks directory&lt;/li&gt; &#xA; &lt;li&gt;Ensure your application includes the &lt;a href=&#34;https://raw.githubusercontent.com/Squirrel/Squirrel.Mac/master/#dependencies&#34;&gt;dependencies&lt;/a&gt;. Squirrel does not embed them itself.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you’re developing Squirrel on its own, then use &lt;code&gt;Squirrel.xcworkspace&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Dependencies&lt;/h1&gt; &#xA;&lt;p&gt;Squirrel depends on &lt;a href=&#34;http://github.com/ReactiveCocoa/ReactiveCocoa&#34;&gt;ReactiveCocoa&lt;/a&gt; and &lt;a href=&#34;https://github.com/Mantle/Mantle&#34;&gt;Mantle&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If your application is already using ReactiveCocoa, ensure it is using the same version as Squirrel.&lt;/p&gt; &#xA;&lt;p&gt;Otherwise, add a target dependency and Copy Files build phase entry for the ReactiveCocoa.framework target included in Squirrel&#39;s repository, in &lt;code&gt;Carthage/Checkouts/ReactiveCocoa&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Similarly, ensure your application includes Mantle, or copies in the Squirrel version.&lt;/p&gt; &#xA;&lt;p&gt;Finally, ensure your application&#39;s Runpath Search Paths (&lt;code&gt;LD_RUNPATH_SEARCH_PATHS&lt;/code&gt;) includes the directory that Squirrel.framework, ReactiveCocoa.framework and Mantle.framework are copied into.&lt;/p&gt; &#xA;&lt;h1&gt;Configuration&lt;/h1&gt; &#xA;&lt;p&gt;Once Squirrel is added to your project, you need to configure and start it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#import &amp;lt;Squirrel/Squirrel.h&amp;gt;&#xA;&#xA;- (void)applicationDidFinishLaunching:(NSNotification *)notification {&#xA;&#x9;NSURLComponents *components = [[NSURLComponents alloc] init];&#xA;&#xA;&#x9;components.scheme = @&#34;https&#34;;&#xA;&#x9;components.host = @&#34;mycompany.com&#34;;&#xA;&#x9;components.path = @&#34;/myapp/latest&#34;;&#xA;&#xA;&#x9;NSString *bundleVersion = NSBundle.mainBundle.sqrl_bundleVersion;&#xA;&#x9;components.query = [[NSString stringWithFormat:@&#34;version=%@&#34;, bundleVersion] stringByAddingPercentEncodingWithAllowedCharacters:NSCharacterSet.URLQueryAllowedCharacterSet]&#xA;&#xA;&#x9;self.updater = [[SQRLUpdater alloc] initWithUpdateRequest:[NSURLRequest requestWithURL:components.URL]];&#xA;&#xA;&#x9;// Check for updates every 4 hours.&#xA;&#x9;[self.updater startAutomaticChecksWithInterval:60 * 60 * 4];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Squirrel will periodically request and automatically download any updates. When your application terminates, any downloaded update will be automatically installed.&lt;/p&gt; &#xA;&lt;h2&gt;Update Requests&lt;/h2&gt; &#xA;&lt;p&gt;Squirrel is indifferent to the request the client application provides for update checking. &lt;code&gt;Accept: application/json&lt;/code&gt; is added to the request headers because Squirrel is responsible for parsing the response.&lt;/p&gt; &#xA;&lt;p&gt;For the requirements imposed on the responses and the body format of an update response see &lt;a href=&#34;https://raw.githubusercontent.com/Squirrel/Squirrel.Mac/master/#server-support&#34;&gt;Server Support&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Your update request must &lt;em&gt;at least&lt;/em&gt; include a version identifier so that the server can determine whether an update for this specific version is required. It may also include other identifying criteria such as operating system version or username, to allow the server to deliver as fine grained an update as you would like.&lt;/p&gt; &#xA;&lt;p&gt;How you include the version identifier or other criteria is specific to the server that you are requesting updates from. A common approach is to use query parameters, &lt;a href=&#34;https://raw.githubusercontent.com/Squirrel/Squirrel.Mac/master/#configuration&#34;&gt;Configuration&lt;/a&gt; shows an example of this.&lt;/p&gt; &#xA;&lt;h2&gt;Update Available Notifications&lt;/h2&gt; &#xA;&lt;p&gt;To know when an update is ready to be installed, you can subscribe to the &lt;code&gt;updates&lt;/code&gt; signal on &lt;code&gt;SQRLUpdater&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[self.updater.updates subscribeNext:^(SQRLDownloadedUpdate *downloadedUpdate) {&#xA;    NSLog(@&#34;An update is ready to install: %@&#34;, downloadedUpdate);&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installing Updates&lt;/h2&gt; &#xA;&lt;p&gt;While downloaded updates are automatically installed when your application terminates, if don&#39;t want to wait you can manually terminate the app to begin the installation process immediately.&lt;/p&gt; &#xA;&lt;p&gt;Once an &lt;a href=&#34;https://raw.githubusercontent.com/Squirrel/Squirrel.Mac/master/#update-available-notifications&#34;&gt;update available notification&lt;/a&gt; has been received, you may want to present an interface informing the user about the update and offering the ability to install and relaunch.&lt;/p&gt; &#xA;&lt;p&gt;To explicitly install a downloaded update and automatically relaunch afterward, subscribe to the &lt;code&gt;relaunchToInstallUpdate&lt;/code&gt; signal on &lt;code&gt;SQRLUpdater&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[[self.updater relaunchToInstallUpdate] subscribeError:^(NSError *error) {&#xA;    NSLog(@&#34;Error preparing update: %@&#34;, error);&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Server Support&lt;/h1&gt; &#xA;&lt;p&gt;Your server should determine whether an update is required based on the &lt;a href=&#34;https://raw.githubusercontent.com/Squirrel/Squirrel.Mac/master/#update-requests&#34;&gt;Update Request&lt;/a&gt; your client issues.&lt;/p&gt; &#xA;&lt;p&gt;If an update is required your server should respond with a status code of &lt;a href=&#34;http://tools.ietf.org/html/rfc2616#section-10.2.1&#34;&gt;200 OK&lt;/a&gt; and include the &lt;a href=&#34;https://raw.githubusercontent.com/Squirrel/Squirrel.Mac/master/#update-server-json-format&#34;&gt;update JSON&lt;/a&gt; in the body. Squirrel &lt;strong&gt;will&lt;/strong&gt; download and install this update, even if the version of the update is the same as the currently running version. To save redundantly downloading the same version multiple times your server must not inform the client to update.&lt;/p&gt; &#xA;&lt;p&gt;If no update is required your server must respond with a status code of &lt;a href=&#34;http://tools.ietf.org/html/rfc2616#section-10.2.5&#34;&gt;204 No Content&lt;/a&gt;. Squirrel will check for an update again at the interval you specify.&lt;/p&gt; &#xA;&lt;h2&gt;Update Server JSON Format&lt;/h2&gt; &#xA;&lt;p&gt;When an update is available, Squirrel expects the following schema in response to the update request provided:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;&#x9;&#34;url&#34;: &#34;https://mycompany.example.com/myapp/releases/myrelease&#34;,&#xA;&#x9;&#34;name&#34;: &#34;My Release Name&#34;,&#xA;&#x9;&#34;notes&#34;: &#34;Theses are some release notes innit&#34;,&#xA;&#x9;&#34;pub_date&#34;: &#34;2013-09-18T12:29:53+01:00&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The only required key is &#34;url&#34;, the others are optional.&lt;/p&gt; &#xA;&lt;p&gt;Squirrel will request &#34;url&#34; with &lt;code&gt;Accept: application/zip&lt;/code&gt; and only supports installing ZIP updates. If future update formats are supported their MIME type will be added to the &lt;code&gt;Accept&lt;/code&gt; header so that your server can return the appropriate format.&lt;/p&gt; &#xA;&lt;p&gt;&#34;pub_date&#34; if present must be formatted according to ISO 8601.&lt;/p&gt; &#xA;&lt;h2&gt;Update File JSON Format&lt;/h2&gt; &#xA;&lt;p&gt;The alternate update technique uses a plain JSON file meaning you can store your update metadata on S3 or another static file store. The format of this file is detailed below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;&#x9;&#34;currentRelease&#34;: &#34;1.2.3&#34;,&#xA;&#x9;&#34;releases&#34;: [&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#34;version&#34;: &#34;1.2.1&#34;,&#xA;&#x9;&#x9;&#x9;&#34;updateTo&#34;: {&#xA;&#x9;&#x9;&#x9;&#x9;&#34;version&#34;: &#34;1.2.1&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;&#34;pub_date&#34;: &#34;2013-09-18T12:29:53+01:00&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;&#34;notes&#34;: &#34;Theses are some release notes innit&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;&#34;name&#34;: &#34;1.2.1&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;&#34;url&#34;: &#34;https://mycompany.example.com/myapp/releases/myrelease&#34;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;},&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#34;version&#34;: &#34;1.2.3&#34;,&#xA;&#x9;&#x9;&#x9;&#34;updateTo&#34;: {&#xA;&#x9;&#x9;&#x9;&#x9;&#34;version&#34;: &#34;1.2.3&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;&#34;pub_date&#34;: &#34;2014-09-18T12:29:53+01:00&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;&#34;notes&#34;: &#34;Theses are some more release notes innit&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;&#34;name&#34;: &#34;1.2.3&#34;,&#xA;&#x9;&#x9;&#x9;&#x9;&#34;url&#34;: &#34;https://mycompany.example.com/myapp/releases/myrelease3&#34;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;User Interface&lt;/h1&gt; &#xA;&lt;p&gt;Squirrel does not provide any GUI components for presenting updates. If you want to indicate updates to the user, make sure to &lt;a href=&#34;https://raw.githubusercontent.com/Squirrel/Squirrel.Mac/master/#update-available-notifications&#34;&gt;listen for downloaded updates&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>