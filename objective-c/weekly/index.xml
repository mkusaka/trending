<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Objective-C Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-07T02:16:27Z</updated>
  <subtitle>Weekly Trending of Objective-C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>AFNetworking/AFNetworking</title>
    <updated>2022-08-07T02:16:27Z</updated>
    <id>tag:github.com,2022-08-07:/AFNetworking/AFNetworking</id>
    <link href="https://github.com/AFNetworking/AFNetworking" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A delightful networking framework for iOS, macOS, watchOS, and tvOS.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.github.com/AFNetworking/AFNetworking/assets/afnetworking-logo.png&#34; alt=&#34;AFNetworking&#34; title=&#34;AFNetworking&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/AFNetworking/AFNetworking/actions&#34;&gt;&lt;img src=&#34;https://github.com/AFNetworking/AFNetworking/workflows/AFNetworking%20CI/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://img.shields.io/cocoapods/v/AFNetworking.svg&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/AFNetworking.svg?sanitize=true&#34; alt=&#34;CocoaPods Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/AFNetworking&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/AFNetworking.svg?style=flat&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://twitter.com/AFNetworking&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/twitter-@AFNetworking-blue.svg?style=flat&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;AFNetworking is a delightful networking library for iOS, macOS, watchOS, and tvOS. It&#39;s built on top of the &lt;a href=&#34;https://developer.apple.com/documentation/foundation/url_loading_system&#34;&gt;Foundation URL Loading System&lt;/a&gt;, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.&lt;/p&gt; &#xA;&lt;p&gt;Perhaps the most important feature of all, however, is the amazing community of developers who use and contribute to AFNetworking every day. AFNetworking powers some of the most popular and critically-acclaimed apps on the iPhone, iPad, and Mac.&lt;/p&gt; &#xA;&lt;h2&gt;How To Get Started&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/AFNetworking/AFNetworking/archive/master.zip&#34;&gt;Download AFNetworking&lt;/a&gt; and try out the included Mac and iPhone example apps&lt;/li&gt; &#xA; &lt;li&gt;Read the &lt;a href=&#34;https://github.com/AFNetworking/AFNetworking/wiki/Getting-Started-with-AFNetworking&#34;&gt;&#34;Getting Started&#34; guide&lt;/a&gt;, &lt;a href=&#34;https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-FAQ&#34;&gt;FAQ&lt;/a&gt;, or &lt;a href=&#34;https://github.com/AFNetworking/AFNetworking/wiki&#34;&gt;other articles on the Wiki&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Communication&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you &lt;strong&gt;need help&lt;/strong&gt;, use &lt;a href=&#34;http://stackoverflow.com/questions/tagged/afnetworking&#34;&gt;Stack Overflow&lt;/a&gt;. (Tag &#39;afnetworking&#39;)&lt;/li&gt; &#xA; &lt;li&gt;If you&#39;d like to &lt;strong&gt;ask a general question&lt;/strong&gt;, use &lt;a href=&#34;http://stackoverflow.com/questions/tagged/afnetworking&#34;&gt;Stack Overflow&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If you &lt;strong&gt;found a bug&lt;/strong&gt;, &lt;em&gt;and can provide steps to reliably reproduce it&lt;/em&gt;, open an issue.&lt;/li&gt; &#xA; &lt;li&gt;If you &lt;strong&gt;have a feature request&lt;/strong&gt;, open an issue.&lt;/li&gt; &#xA; &lt;li&gt;If you &lt;strong&gt;want to contribute&lt;/strong&gt;, submit a pull request.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;AFNetworking supports multiple methods for installing the library in a project.&lt;/p&gt; &#xA;&lt;h2&gt;Installation with CocoaPods&lt;/h2&gt; &#xA;&lt;p&gt;To integrate AFNetworking into your Xcode project using CocoaPods, specify it in your &lt;code&gt;Podfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;AFNetworking&#39;, &#39;~&amp;gt; 4.0&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Installation with Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;Once you have your Swift package set up, adding AFNetworking as a dependency is as easy as adding it to the &lt;code&gt;dependencies&lt;/code&gt; value of your &lt;code&gt;Package.swift&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/AFNetworking/AFNetworking.git&#34;, .upToNextMajor(from: &#34;4.0.0&#34;))&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: AFNetworking&#39;s Swift package does not include it&#39;s UIKit extensions.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Installation with Carthage&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt; is a decentralized dependency manager that builds your dependencies and provides you with binary frameworks. To integrate AFNetworking, add the following to your &lt;code&gt;Cartfile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ogdl&#34;&gt;github &#34;AFNetworking/AFNetworking&#34; ~&amp;gt; 4.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;AFNetworking Version&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Minimum iOS Target&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Minimum macOS Target&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Minimum watchOS Target&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Minimum tvOS Target&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;4.x&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;iOS 9&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;macOS 10.10&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;watchOS 2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;tvOS 9.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Xcode 11+ is required.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;3.x&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;iOS 7&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;OS X 10.9&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;watchOS 2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;tvOS 9.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Xcode 7+ is required. &lt;code&gt;NSURLConnectionOperation&lt;/code&gt; support has been removed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.6 -&amp;gt; 2.6.3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;iOS 7&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;OS X 10.9&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;watchOS 2.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;n/a&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Xcode 7+ is required.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.0 -&amp;gt; 2.5.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;iOS 6&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;OS X 10.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;n/a&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;n/a&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Xcode 5+ is required. &lt;code&gt;NSURLSession&lt;/code&gt; subspec requires iOS 7 or OS X 10.9.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.x&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;iOS 5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Mac OS X 10.7&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;n/a&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;n/a&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.10.x&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;iOS 4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Mac OS X 10.6&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;n/a&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;n/a&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;(macOS projects must support &lt;a href=&#34;https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtVersionsPlatforms.html&#34;&gt;64-bit with modern Cocoa runtime&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Programming in Swift? Try &lt;a href=&#34;https://github.com/Alamofire/Alamofire&#34;&gt;Alamofire&lt;/a&gt; for a more conventional set of APIs.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Architecture&lt;/h2&gt; &#xA;&lt;h3&gt;NSURLSession&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;AFURLSessionManager&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Serialization&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;AFURLRequestSerialization&amp;gt;&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;AFHTTPRequestSerializer&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AFJSONRequestSerializer&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AFPropertyListRequestSerializer&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;AFURLResponseSerialization&amp;gt;&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;AFHTTPResponseSerializer&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AFJSONResponseSerializer&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AFXMLParserResponseSerializer&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AFXMLDocumentResponseSerializer&lt;/code&gt; &lt;em&gt;(macOS)&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AFPropertyListResponseSerializer&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AFImageResponseSerializer&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;AFCompoundResponseSerializer&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Additional Functionality&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;AFSecurityPolicy&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AFNetworkReachabilityManager&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;AFURLSessionManager&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;AFURLSessionManager&lt;/code&gt; creates and manages an &lt;code&gt;NSURLSession&lt;/code&gt; object based on a specified &lt;code&gt;NSURLSessionConfiguration&lt;/code&gt; object, which conforms to &lt;code&gt;&amp;lt;NSURLSessionTaskDelegate&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;NSURLSessionDataDelegate&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;NSURLSessionDownloadDelegate&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;NSURLSessionDelegate&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Creating a Download Task&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];&#xA;AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];&#xA;&#xA;NSURL *URL = [NSURL URLWithString:@&#34;http://example.com/download.zip&#34;];&#xA;NSURLRequest *request = [NSURLRequest requestWithURL:URL];&#xA;&#xA;NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) {&#xA;    NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];&#xA;    return [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];&#xA;} completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) {&#xA;    NSLog(@&#34;File downloaded to: %@&#34;, filePath);&#xA;}];&#xA;[downloadTask resume];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Creating an Upload Task&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];&#xA;AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];&#xA;&#xA;NSURL *URL = [NSURL URLWithString:@&#34;http://example.com/upload&#34;];&#xA;NSURLRequest *request = [NSURLRequest requestWithURL:URL];&#xA;&#xA;NSURL *filePath = [NSURL fileURLWithPath:@&#34;file://path/to/image.png&#34;];&#xA;NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithRequest:request fromFile:filePath progress:nil completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {&#xA;    if (error) {&#xA;        NSLog(@&#34;Error: %@&#34;, error);&#xA;    } else {&#xA;        NSLog(@&#34;Success: %@ %@&#34;, response, responseObject);&#xA;    }&#xA;}];&#xA;[uploadTask resume];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Creating an Upload Task for a Multi-Part Request, with Progress&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@&#34;POST&#34; URLString:@&#34;http://example.com/upload&#34; parameters:nil constructingBodyWithBlock:^(id&amp;lt;AFMultipartFormData&amp;gt; formData) {&#xA;        [formData appendPartWithFileURL:[NSURL fileURLWithPath:@&#34;file://path/to/image.jpg&#34;] name:@&#34;file&#34; fileName:@&#34;filename.jpg&#34; mimeType:@&#34;image/jpeg&#34; error:nil];&#xA;    } error:nil];&#xA;&#xA;AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];&#xA;&#xA;NSURLSessionUploadTask *uploadTask;&#xA;uploadTask = [manager&#xA;              uploadTaskWithStreamedRequest:request&#xA;              progress:^(NSProgress * _Nonnull uploadProgress) {&#xA;                  // This is not called back on the main queue.&#xA;                  // You are responsible for dispatching to the main queue for UI updates&#xA;                  dispatch_async(dispatch_get_main_queue(), ^{&#xA;                      //Update the progress view&#xA;                      [progressView setProgress:uploadProgress.fractionCompleted];&#xA;                  });&#xA;              }&#xA;              completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {&#xA;                  if (error) {&#xA;                      NSLog(@&#34;Error: %@&#34;, error);&#xA;                  } else {&#xA;                      NSLog(@&#34;%@ %@&#34;, response, responseObject);&#xA;                  }&#xA;              }];&#xA;&#xA;[uploadTask resume];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Creating a Data Task&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];&#xA;AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];&#xA;&#xA;NSURL *URL = [NSURL URLWithString:@&#34;http://httpbin.org/get&#34;];&#xA;NSURLRequest *request = [NSURLRequest requestWithURL:URL];&#xA;&#xA;NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {&#xA;    if (error) {&#xA;        NSLog(@&#34;Error: %@&#34;, error);&#xA;    } else {&#xA;        NSLog(@&#34;%@ %@&#34;, response, responseObject);&#xA;    }&#xA;}];&#xA;[dataTask resume];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Request Serialization&lt;/h3&gt; &#xA;&lt;p&gt;Request serializers create requests from URL strings, encoding parameters as either a query string or HTTP body.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;NSString *URLString = @&#34;http://example.com&#34;;&#xA;NSDictionary *parameters = @{@&#34;foo&#34;: @&#34;bar&#34;, @&#34;baz&#34;: @[@1, @2, @3]};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Query String Parameter Encoding&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;[[AFHTTPRequestSerializer serializer] requestWithMethod:@&#34;GET&#34; URLString:URLString parameters:parameters error:nil];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;GET http://example.com?foo=bar&amp;amp;baz[]=1&amp;amp;baz[]=2&amp;amp;baz[]=3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;URL Form Parameter Encoding&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;[[AFHTTPRequestSerializer serializer] requestWithMethod:@&#34;POST&#34; URLString:URLString parameters:parameters error:nil];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;POST http://example.com/&#xA;Content-Type: application/x-www-form-urlencoded&#xA;&#xA;foo=bar&amp;amp;baz[]=1&amp;amp;baz[]=2&amp;amp;baz[]=3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;JSON Parameter Encoding&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;[[AFJSONRequestSerializer serializer] requestWithMethod:@&#34;POST&#34; URLString:URLString parameters:parameters error:nil];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;POST http://example.com/&#xA;Content-Type: application/json&#xA;&#xA;{&#34;foo&#34;: &#34;bar&#34;, &#34;baz&#34;: [1,2,3]}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Network Reachability Manager&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;AFNetworkReachabilityManager&lt;/code&gt; monitors the reachability of domains, and addresses for both WWAN and WiFi network interfaces.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Do not use Reachability to determine if the original request should be sent. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You should try to send it.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;You can use Reachability to determine when a request should be automatically retried. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Although it may still fail, a Reachability notification that the connectivity is available is a good time to retry something.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Network reachability is a useful tool for determining why a request might have failed. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;After a network request has failed, telling the user they&#39;re offline is better than giving them a more technical but accurate error, such as &#34;request timed out.&#34;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See also &lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2012-706/&#34;&gt;WWDC 2012 session 706, &#34;Networking Best Practices.&#34;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Shared Network Reachability&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {&#xA;    NSLog(@&#34;Reachability: %@&#34;, AFStringFromNetworkReachabilityStatus(status));&#xA;}];&#xA;&#xA;[[AFNetworkReachabilityManager sharedManager] startMonitoring];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Security Policy&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;AFSecurityPolicy&lt;/code&gt; evaluates server trust against pinned X.509 certificates and public keys over secure connections.&lt;/p&gt; &#xA;&lt;p&gt;Adding pinned SSL certificates to your app helps prevent man-in-the-middle attacks and other vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged to route all communication over an HTTPS connection with SSL pinning configured and enabled.&lt;/p&gt; &#xA;&lt;h4&gt;Allowing Invalid SSL Certificates&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];&#xA;manager.securityPolicy.allowInvalidCertificates = YES; // not recommended for production&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Unit Tests&lt;/h2&gt; &#xA;&lt;p&gt;AFNetworking includes a suite of unit tests within the Tests subdirectory. These tests can be run simply be executed the test action on the platform framework you would like to test.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;AFNetworking is owned and maintained by the &lt;a href=&#34;http://alamofire.org&#34;&gt;Alamofire Software Foundation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;AFNetworking was originally created by &lt;a href=&#34;https://github.com/sco/&#34;&gt;Scott Raymond&lt;/a&gt; and &lt;a href=&#34;https://github.com/mattt/&#34;&gt;Mattt Thompson&lt;/a&gt; in the development of &lt;a href=&#34;http://en.wikipedia.org/wiki/Gowalla&#34;&gt;Gowalla for iPhone&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;AFNetworking&#39;s logo was designed by &lt;a href=&#34;http://www.alandefibaugh.com/&#34;&gt;Alan Defibaugh&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;And most of all, thanks to AFNetworking&#39;s &lt;a href=&#34;https://github.com/AFNetworking/AFNetworking/contributors&#34;&gt;growing list of contributors&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Security Disclosure&lt;/h3&gt; &#xA;&lt;p&gt;If you believe you have identified a security vulnerability with AFNetworking, you should report it as soon as possible via email to &lt;a href=&#34;mailto:security@alamofire.org&#34;&gt;security@alamofire.org&lt;/a&gt;. Please do not post it to a public issue tracker.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;AFNetworking is released under the MIT license. See &lt;a href=&#34;https://github.com/AFNetworking/AFNetworking/raw/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>sparkle-project/Sparkle</title>
    <updated>2022-08-07T02:16:27Z</updated>
    <id>tag:github.com,2022-08-07:/sparkle-project/Sparkle</id>
    <link href="https://github.com/sparkle-project/Sparkle" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A software update framework for macOS&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Sparkle 2 &lt;img src=&#34;https://github.com/sparkle-project/Sparkle/workflows/Build%20%26%20Tests/badge.svg?branch=2.x&#34; alt=&#34;Build Status&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/SwiftPM-compatible-4BC51D.svg?style=flat&#34; alt=&#34;SwiftPM&#34;&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/Sparkle&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/Sparkle.svg?cacheSeconds=86400&#34; alt=&#34;CocoaPods&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Secure and reliable software update framework for macOS.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/sparkle-project/Sparkle/2.x/Resources/Screenshot.png&#34; width=&#34;732&#34; alt=&#34;Sparkle shows familiar update window with release notes&#34;&gt; &#xA;&lt;p&gt;Sparkle 2 adds support for application sandboxing, custom user interfaces, updating external bundles, and a more modern architecture which includes faster and more reliable installs.&lt;/p&gt; &#xA;&lt;p&gt;Pre-releases when available can be found on the &lt;a href=&#34;https://github.com/sparkle-project/Sparkle/releases&#34;&gt;Sparkle&#39;s Releases&lt;/a&gt; or on your favorite package manager. More nightly builds can be downloaded by selecting a recent &lt;a href=&#34;https://github.com/sparkle-project/Sparkle/actions?query=event%3Apush+is%3Asuccess+branch%3A2.x&#34;&gt;workflow run&lt;/a&gt; and downloading the corresponding Sparkle-distribution artifact.&lt;/p&gt; &#xA;&lt;p&gt;The current status for future versions of Sparkle is tracked by &lt;a href=&#34;https://github.com/sparkle-project/Sparkle/milestones&#34;&gt;its roadmap&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Please visit &lt;a href=&#34;http://sparkle-project.org&#34;&gt;Sparkle&#39;s website&lt;/a&gt; for up to date documentation on using and migrating over to Sparkle 2. Refer to &lt;a href=&#34;https://raw.githubusercontent.com/sparkle-project/Sparkle/2.x/CHANGELOG&#34;&gt;Changelog&lt;/a&gt; for a more detailed list of changes. More internal design documents to the project can be found in the repository under &lt;a href=&#34;https://raw.githubusercontent.com/sparkle-project/Sparkle/2.x/Documentation/&#34;&gt;Documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Seamless. There&#39;s no mention of Sparkle; your icons and app name are used.&lt;/li&gt; &#xA; &lt;li&gt;Secure. Updates are verified using EdDSA signatures and Apple Code Signing. Supports Sandboxed applications in Sparkle 2.&lt;/li&gt; &#xA; &lt;li&gt;Fast. Supports delta updates which only patch files that have changed and atomic-safe installs.&lt;/li&gt; &#xA; &lt;li&gt;Easy to install. Sparkle requires no code in your app, and only needs static files on a web server.&lt;/li&gt; &#xA; &lt;li&gt;Customizable. Sparkle 2 supports plugging in a custom UI for updates.&lt;/li&gt; &#xA; &lt;li&gt;Flexible. Supports applications, package installers, preference panes, and other plug-ins. Sparkle 2 supports updating external bundles.&lt;/li&gt; &#xA; &lt;li&gt;Handles permissions, quarantine, and automatically asks for authentication if needed.&lt;/li&gt; &#xA; &lt;li&gt;Uses RSS-based appcasts for release information. Appcasts are a de-facto standard supported by 3rd party update-tracking programs and websites.&lt;/li&gt; &#xA; &lt;li&gt;Stays hidden until second launch for better first impressions.&lt;/li&gt; &#xA; &lt;li&gt;Truly self-updating — the user can choose to automatically download and install all updates in the background.&lt;/li&gt; &#xA; &lt;li&gt;Ability to use channels for beta updates (in Sparkle 2), add phased rollouts to users, and mark updates as critical or major.&lt;/li&gt; &#xA; &lt;li&gt;Progress and status notifications for the host app.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Runtime: macOS 10.13 or greater for 2.3, macOS 10.11 or greater for 2.2.x&lt;/li&gt; &#xA; &lt;li&gt;Build: Latest major Xcode (stable or beta, whichever is latest) and one major version less.&lt;/li&gt; &#xA; &lt;li&gt;HTTPS server for serving updates (see &lt;a href=&#34;http://sparkle-project.org/documentation/app-transport-security/&#34;&gt;App Transport Security&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://sparkle-project.org/documentation/&#34;&gt;getting started guide&lt;/a&gt;. No code is necessary, but a bit of Xcode configuration is required.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;This repository uses git submodules, and will not build unless you clone recursively. Also, GitHub-provided ZIP/tar archives are broken due to GitHub not supporting git submodules properly.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/sparkle-project/Sparkle&#xA;git submodule update --init --recursive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Troubleshooting&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Please check &lt;strong&gt;Console.app&lt;/strong&gt; for logs under your application. Sparkle prints detailed information there about all problems it encounters. It often also suggests solutions to the problems, so please read Sparkle&#39;s log messages carefully.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Use the &lt;code&gt;generate_appcast&lt;/code&gt; tool which creates appcast files, correct signatures, and delta updates automatically.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Make sure the URL specified in &lt;a href=&#34;https://sparkle-project.org/documentation/customization/&#34;&gt;&lt;code&gt;SUFeedURL&lt;/code&gt;&lt;/a&gt; is valid (typos/404s are a common error!), and that it uses modern TLS (&lt;a href=&#34;https://www.ssllabs.com/ssltest/&#34;&gt;test it&lt;/a&gt;).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;API symbols&lt;/h3&gt; &#xA;&lt;p&gt;Sparkle is built with &lt;code&gt;-fvisibility=hidden -fvisibility-inlines-hidden&lt;/code&gt; which means no symbols are exported by default. If you are adding a symbol to the public API you must decorate the declaration with the &lt;code&gt;SU_EXPORT&lt;/code&gt; macro (grep the source code for examples).&lt;/p&gt; &#xA;&lt;h3&gt;Building the distribution package&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cd&lt;/code&gt; to the root of the Sparkle source tree and run &lt;code&gt;make release&lt;/code&gt;. Sparkle-&lt;em&gt;VERSION&lt;/em&gt;.tar.xz (or .bz2) will be created in a temporary directory and revealed in Finder after the build has completed.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, build the Distribution scheme in the Xcode UI.&lt;/p&gt; &#xA;&lt;h3&gt;Code of Conduct&lt;/h3&gt; &#xA;&lt;p&gt;We pledge to have an open and welcoming environment. See our &lt;a href=&#34;https://raw.githubusercontent.com/sparkle-project/Sparkle/2.x/CODE_OF_CONDUCT.md&#34;&gt;Code of Conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>openid/AppAuth-iOS</title>
    <updated>2022-08-07T02:16:27Z</updated>
    <id>tag:github.com,2022-08-07:/openid/AppAuth-iOS</id>
    <link href="https://github.com/openid/AppAuth-iOS" rel="alternate"></link>
    <summary type="html">&lt;p&gt;iOS and macOS SDK for communicating with OAuth 2.0 and OpenID Connect providers.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://rawgit.com/openid/AppAuth-iOS/master/appauth_lockup.svg?sanitize=true&#34; alt=&#34;AppAuth for iOS and macOS&#34;&gt; &lt;a href=&#34;https://github.com/openid/AppAuth-iOS/actions/workflows/tests.yml&#34;&gt;&lt;img src=&#34;https://github.com/openid/AppAuth-iOS/actions/workflows/tests.yml/badge.svg?event=push&#34; alt=&#34;tests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/openid/AppAuth-iOS&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/openid/AppAuth-iOS/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-brightgreen.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swift.org/package-manager&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/SwiftPM-compatible-brightgreen.svg?style=flat&#34; alt=&#34;SwiftPM compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/AppAuth&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/AppAuth.svg?style=flat&#34; alt=&#34;Pod Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/openid/AppAuth-iOS/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/l/AppAuth.svg?style=flat&#34; alt=&#34;Pod License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/AppAuth&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/AppAuth.svg?style=flat&#34; alt=&#34;Pod Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://developer.apple.com/documentation/xcode/creating_a_mac_version_of_your_ipad_app&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Catalyst-compatible-brightgreen.svg?style=flat&#34; alt=&#34;Catalyst compatible&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;AppAuth for iOS and macOS, and tvOS is a client SDK for communicating with &lt;a href=&#34;https://tools.ietf.org/html/rfc6749&#34;&gt;OAuth 2.0&lt;/a&gt; and &lt;a href=&#34;http://openid.net/specs/openid-connect-core-1_0.html&#34;&gt;OpenID Connect&lt;/a&gt; providers. It strives to directly map the requests and responses of those specifications, while following the idiomatic style of the implementation language. In addition to mapping the raw protocol flows, convenience methods are available to assist with common tasks like performing an action with fresh tokens.&lt;/p&gt; &#xA;&lt;p&gt;It follows the best practices set out in &lt;a href=&#34;https://tools.ietf.org/html/rfc8252&#34;&gt;RFC 8252&amp;nbsp;- OAuth 2.0 for Native Apps&lt;/a&gt; including using &lt;code&gt;SFAuthenticationSession&lt;/code&gt; and &lt;code&gt;SFSafariViewController&lt;/code&gt; on iOS for the auth request. &lt;code&gt;UIWebView&lt;/code&gt; and &lt;code&gt;WKWebView&lt;/code&gt; are explicitly &lt;em&gt;not&lt;/em&gt; supported due to the security and usability reasons explained in &lt;a href=&#34;https://tools.ietf.org/html/rfc8252#section-8.12&#34;&gt;Section 8.12 of RFC 8252&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It also supports the &lt;a href=&#34;https://tools.ietf.org/html/rfc7636&#34;&gt;PKCE&lt;/a&gt; extension to OAuth, which was created to secure authorization codes in public clients when custom URI scheme redirects are used. The library is friendly to other extensions (standard or otherwise), with the ability to handle additional params in all protocol requests and responses.&lt;/p&gt; &#xA;&lt;p&gt;For tvOS, AppAuth implements &lt;a href=&#34;https://tools.ietf.org/html/rfc8628&#34;&gt;OAuth 2.0 Device Authorization Grant &lt;/a&gt; to allow for tvOS sign-ins through a secondary device.&lt;/p&gt; &#xA;&lt;h2&gt;Specification&lt;/h2&gt; &#xA;&lt;h3&gt;iOS&lt;/h3&gt; &#xA;&lt;h4&gt;Supported Versions&lt;/h4&gt; &#xA;&lt;p&gt;AppAuth supports iOS 7 and above.&lt;/p&gt; &#xA;&lt;p&gt;iOS 9+ uses the in-app browser tab pattern (via &lt;code&gt;SFSafariViewController&lt;/code&gt;), and falls back to the system browser (mobile Safari) on earlier versions.&lt;/p&gt; &#xA;&lt;h4&gt;Authorization Server Requirements&lt;/h4&gt; &#xA;&lt;p&gt;Both Custom URI Schemes (all supported versions of iOS) and Universal Links (iOS 9+) can be used with the library.&lt;/p&gt; &#xA;&lt;p&gt;In general, AppAuth can work with any authorization server that supports native apps, as documented in &lt;a href=&#34;https://tools.ietf.org/html/rfc8252&#34;&gt;RFC 8252&lt;/a&gt;, either through custom URI scheme redirects, or universal links. Authorization servers that assume all clients are web-based, or require clients to maintain confidentiality of the client secrets may not work well.&lt;/p&gt; &#xA;&lt;h3&gt;macOS&lt;/h3&gt; &#xA;&lt;h4&gt;Supported Versions&lt;/h4&gt; &#xA;&lt;p&gt;AppAuth supports macOS (OS X) 10.9 and above.&lt;/p&gt; &#xA;&lt;h4&gt;Authorization Server Requirements&lt;/h4&gt; &#xA;&lt;p&gt;AppAuth for macOS supports both custom schemes; a loopback HTTP redirects via a small embedded server.&lt;/p&gt; &#xA;&lt;p&gt;In general, AppAuth can work with any authorization server that supports native apps, as documented in &lt;a href=&#34;https://tools.ietf.org/html/rfc8252&#34;&gt;RFC 8252&lt;/a&gt;; either through custom URI schemes, or loopback HTTP redirects. Authorization servers that assume all clients are web-based, or require clients to maintain confidentiality of the client secrets may not work well.&lt;/p&gt; &#xA;&lt;h3&gt;tvOS&lt;/h3&gt; &#xA;&lt;h4&gt;Supported Versions&lt;/h4&gt; &#xA;&lt;p&gt;AppAuth supports tvOS 9.0 and above. Please note that while it is possible to run the standard AppAuth library on tvOS, the documentation below describes implementing &lt;a href=&#34;https://tools.ietf.org/html/rfc8628&#34;&gt;OAuth 2.0 Device Authorization Grant&lt;/a&gt; (AppAuthTV).&lt;/p&gt; &#xA;&lt;h4&gt;Authorization Server Requirements&lt;/h4&gt; &#xA;&lt;p&gt;AppAuthTV is designed for servers that support the device authorization flow as documented in &lt;a href=&#34;https://tools.ietf.org/html/rfc8628&#34;&gt;RFC 8628&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Try&lt;/h2&gt; &#xA;&lt;p&gt;Want to try out AppAuth? Just run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod try AppAuth&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Follow the instructions in &lt;a href=&#34;https://raw.githubusercontent.com/openid/AppAuth-iOS/master/Examples/README.md&#34;&gt;Examples/README.md&lt;/a&gt; to configure with your own OAuth client (you need to update three configuration points with your client info to try the demo).&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;AppAuth supports four options for dependency management.&lt;/p&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://guides.cocoapods.org/using/getting-started.html&#34;&gt;CocoaPods&lt;/a&gt;, add the following line to your &lt;code&gt;Podfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod &#39;AppAuth&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, run &lt;code&gt;pod install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;tvOS:&lt;/strong&gt; Use the &lt;code&gt;TV&lt;/code&gt; subspec:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod &#39;AppAuth/TV&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://swift.org/package-manager&#34;&gt;Swift Package Manager&lt;/a&gt;, add the following &lt;code&gt;dependency&lt;/code&gt; to your &lt;code&gt;Package.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/openid/AppAuth-iOS.git&#34;, .upToNextMajor(from: &#34;1.3.0&#34;))&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;tvOS:&lt;/strong&gt; Use the &lt;code&gt;AppAuthTV&lt;/code&gt; target.&lt;/p&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;, add the following line to your &lt;code&gt;Cartfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;openid/AppAuth-iOS&#34; &#34;master&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, run &lt;code&gt;carthage bootstrap&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;tvOS:&lt;/strong&gt; Use the &lt;code&gt;AppAuthTV&lt;/code&gt; framework.&lt;/p&gt; &#xA;&lt;h3&gt;Static Library&lt;/h3&gt; &#xA;&lt;p&gt;You can also use AppAuth as a static library. This requires linking the library and your project, and including the headers. Here is a suggested configuration:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create an Xcode Workspace.&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;AppAuth.xcodeproj&lt;/code&gt; to your Workspace.&lt;/li&gt; &#xA; &lt;li&gt;Include libAppAuth as a linked library for your target (in the &#34;General -&amp;gt; Linked Framework and Libraries&#34; section of your target).&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;AppAuth-iOS/Source&lt;/code&gt; to your search paths of your target (&#34;Build Settings -&amp;gt; &#34;Header Search Paths&#34;).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: There is no static library for AppAuthTV.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Auth Flow&lt;/h2&gt; &#xA;&lt;p&gt;AppAuth supports both manual interaction with the authorization server where you need to perform your own token exchanges, as well as convenience methods that perform some of this logic for you. This example uses the convenience method, which returns either an &lt;code&gt;OIDAuthState&lt;/code&gt; object, or an error.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;OIDAuthState&lt;/code&gt; is a class that keeps track of the authorization and token requests and responses, and provides a convenience method to call an API with fresh tokens. This is the only object that you need to serialize to retain the authorization state of the session.&lt;/p&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;You can configure AppAuth by specifying the endpoints directly:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSURL *authorizationEndpoint =&#xA;    [NSURL URLWithString:@&#34;https://accounts.google.com/o/oauth2/v2/auth&#34;];&#xA;NSURL *tokenEndpoint =&#xA;    [NSURL URLWithString:@&#34;https://www.googleapis.com/oauth2/v4/token&#34;];&#xA;&#xA;OIDServiceConfiguration *configuration =&#xA;    [[OIDServiceConfiguration alloc]&#xA;        initWithAuthorizationEndpoint:authorizationEndpoint&#xA;                        tokenEndpoint:tokenEndpoint];&#xA;&#xA;// perform the auth request...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let authorizationEndpoint = URL(string: &#34;https://accounts.google.com/o/oauth2/v2/auth&#34;)!&#xA;let tokenEndpoint = URL(string: &#34;https://www.googleapis.com/oauth2/v4/token&#34;)!&#xA;let configuration = OIDServiceConfiguration(authorizationEndpoint: authorizationEndpoint,&#xA;                                            tokenEndpoint: tokenEndpoint)&#xA;&#xA;// perform the auth request...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;tvOS&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSURL *deviceAuthorizationEndpoint =&#xA;    [NSURL URLWithString:@&#34;https://oauth2.googleapis.com/device/code&#34;];&#xA;NSURL *tokenEndpoint =&#xA;    [NSURL URLWithString:@&#34;https://www.googleapis.com/oauth2/v4/token&#34;];&#xA;&#xA;OIDTVServiceConfiguration *configuration =&#xA;    [[OIDTVServiceConfiguration alloc]&#xA;        initWithDeviceAuthorizationEndpoint:deviceAuthorizationEndpoint&#xA;                              tokenEndpoint:tokenEndpoint];&#xA;&#xA;// perform the auth request...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or through discovery:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSURL *issuer = [NSURL URLWithString:@&#34;https://accounts.google.com&#34;];&#xA;&#xA;[OIDAuthorizationService discoverServiceConfigurationForIssuer:issuer&#xA;    completion:^(OIDServiceConfiguration *_Nullable configuration,&#xA;                 NSError *_Nullable error) {&#xA;&#xA;  if (!configuration) {&#xA;    NSLog(@&#34;Error retrieving discovery document: %@&#34;,&#xA;          [error localizedDescription]);&#xA;    return;&#xA;  }&#xA;&#xA;  // perform the auth request...&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let issuer = URL(string: &#34;https://accounts.google.com&#34;)!&#xA;&#xA;// discovers endpoints&#xA;OIDAuthorizationService.discoverConfiguration(forIssuer: issuer) { configuration, error in&#xA;  guard let config = configuration else {&#xA;    print(&#34;Error retrieving discovery document: \(error?.localizedDescription ?? &#34;Unknown error&#34;)&#34;)&#xA;    return&#xA;  }&#xA;&#xA;  // perform the auth request...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;tvOS&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;NSURL *issuer = [NSURL URLWithString:@&#34;https://accounts.google.com&#34;];&#xA;&#xA;[OIDTVAuthorizationService discoverServiceConfigurationForIssuer:issuer&#xA;    completion:^(OIDTVServiceConfiguration *_Nullable configuration,&#xA;                 NSError *_Nullable error) {&#xA;&#xA;  if (!configuration) {&#xA;    NSLog(@&#34;Error retrieving discovery document: %@&#34;,&#xA;          [error localizedDescription]);&#xA;    return;&#xA;  }&#xA;&#xA;  // perform the auth request...&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Authorizing –&amp;nbsp;iOS&lt;/h3&gt; &#xA;&lt;p&gt;First, you need to have a property in your &lt;code&gt;UIApplicationDelegate&lt;/code&gt; implementation to hold the session, in order to continue the authorization flow from the redirect. In this example, the implementation of this delegate is a class named &lt;code&gt;AppDelegate&lt;/code&gt;, if your app&#39;s application delegate has a different name, please update the class name in samples below accordingly.&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@interface AppDelegate : UIResponder &amp;lt;UIApplicationDelegate&amp;gt;&#xA;// property of the app&#39;s AppDelegate&#xA;@property(nonatomic, strong, nullable) id&amp;lt;OIDExternalUserAgentSession&amp;gt; currentAuthorizationFlow;&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class AppDelegate: UIResponder, UIApplicationDelegate {&#xA;  // property of the app&#39;s AppDelegate&#xA;  var currentAuthorizationFlow: OIDExternalUserAgentSession?&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And your main class, a property to store the auth state:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// property of the containing class&#xA;@property(nonatomic, strong, nullable) OIDAuthState *authState;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// property of the containing class&#xA;private var authState: OIDAuthState?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, initiate the authorization request. By using the &lt;code&gt;authStateByPresentingAuthorizationRequest&lt;/code&gt; convenience method, the token exchange will be performed automatically, and everything will be protected with PKCE (if the server supports it). AppAuth also lets you perform these requests manually. See the &lt;code&gt;authNoCodeExchange&lt;/code&gt; method in the included Example app for a demonstration:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// builds authentication request&#xA;OIDAuthorizationRequest *request =&#xA;    [[OIDAuthorizationRequest alloc] initWithConfiguration:configuration&#xA;                                                  clientId:kClientID&#xA;                                                    scopes:@[OIDScopeOpenID,&#xA;                                                             OIDScopeProfile]&#xA;                                               redirectURL:kRedirectURI&#xA;                                              responseType:OIDResponseTypeCode&#xA;                                      additionalParameters:nil];&#xA;&#xA;// performs authentication request&#xA;AppDelegate *appDelegate =&#xA;    (AppDelegate *)[UIApplication sharedApplication].delegate;&#xA;appDelegate.currentAuthorizationFlow =&#xA;    [OIDAuthState authStateByPresentingAuthorizationRequest:request&#xA;        presentingViewController:self&#xA;                        callback:^(OIDAuthState *_Nullable authState,&#xA;                                   NSError *_Nullable error) {&#xA;  if (authState) {&#xA;    NSLog(@&#34;Got authorization tokens. Access token: %@&#34;,&#xA;          authState.lastTokenResponse.accessToken);&#xA;    [self setAuthState:authState];&#xA;  } else {&#xA;    NSLog(@&#34;Authorization error: %@&#34;, [error localizedDescription]);&#xA;    [self setAuthState:nil];&#xA;  }&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// builds authentication request&#xA;let request = OIDAuthorizationRequest(configuration: configuration,&#xA;                                      clientId: clientID,&#xA;                                      clientSecret: clientSecret,&#xA;                                      scopes: [OIDScopeOpenID, OIDScopeProfile],&#xA;                                      redirectURL: redirectURI,&#xA;                                      responseType: OIDResponseTypeCode,&#xA;                                      additionalParameters: nil)&#xA;&#xA;// performs authentication request&#xA;print(&#34;Initiating authorization request with scope: \(request.scope ?? &#34;nil&#34;)&#34;)&#xA;&#xA;let appDelegate = UIApplication.shared.delegate as! AppDelegate&#xA;&#xA;appDelegate.currentAuthorizationFlow =&#xA;    OIDAuthState.authState(byPresenting: request, presenting: self) { authState, error in&#xA;  if let authState = authState {&#xA;    self.setAuthState(authState)&#xA;    print(&#34;Got authorization tokens. Access token: &#34; +&#xA;          &#34;\(authState.lastTokenResponse?.accessToken ?? &#34;nil&#34;)&#34;)&#xA;  } else {&#xA;    print(&#34;Authorization error: \(error?.localizedDescription ?? &#34;Unknown error&#34;)&#34;)&#xA;    self.setAuthState(nil)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Handling the Redirect&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;The authorization response URL is returned to the app via the iOS openURL app delegate method, so you need to pipe this through to the current authorization session (created in the previous session):&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;- (BOOL)application:(UIApplication *)app&#xA;            openURL:(NSURL *)url&#xA;            options:(NSDictionary&amp;lt;NSString *, id&amp;gt; *)options {&#xA;  // Sends the URL to the current authorization flow (if any) which will&#xA;  // process it if it relates to an authorization response.&#xA;  if ([_currentAuthorizationFlow resumeExternalUserAgentFlowWithURL:url]) {&#xA;    _currentAuthorizationFlow = nil;&#xA;    return YES;&#xA;  }&#xA;&#xA;  // Your additional URL handling (if any) goes here.&#xA;&#xA;  return NO;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func application(_ app: UIApplication,&#xA;                 open url: URL,&#xA;                 options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -&amp;gt; Bool {&#xA;  // Sends the URL to the current authorization flow (if any) which will&#xA;  // process it if it relates to an authorization response.&#xA;  if let authorizationFlow = self.currentAuthorizationFlow,&#xA;                             authorizationFlow.resumeExternalUserAgentFlow(with: url) {&#xA;    self.currentAuthorizationFlow = nil&#xA;    return true&#xA;  }&#xA;&#xA;  // Your additional URL handling (if any)&#xA;&#xA;  return false&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Authorizing –&amp;nbsp;MacOS&lt;/h3&gt; &#xA;&lt;p&gt;On macOS, the most popular way to get the authorization response redirect is to start a local HTTP server on the loopback interface (limited to incoming requests from the user&#39;s machine only). When the authorization is complete, the user is redirected to that local server, and the authorization response can be processed by the app. AppAuth takes care of managing the local HTTP server lifecycle for you.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;h4&gt;&lt;span&gt;💡&lt;/span&gt; Alternative: Custom URI Schemes&lt;/h4&gt; &#xA; &lt;p&gt;Custom URI schemes are also supported on macOS, but some browsers display an interstitial, which reduces the usability. For an example on using custom URI schemes with macOS, See &lt;code&gt;Example-Mac&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To receive the authorization response using a local HTTP server, first you need to have an instance variable in your main class to retain the HTTP redirect handler:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;OIDRedirectHTTPHandler *_redirectHTTPHandler;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, as the port used by the local HTTP server varies, you need to start it before building the authorization request, in order to get the exact redirect URI to use:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;static NSString *const kSuccessURLString =&#xA;    @&#34;http://openid.github.io/AppAuth-iOS/redirect/&#34;;&#xA;NSURL *successURL = [NSURL URLWithString:kSuccessURLString];&#xA;&#xA;// Starts a loopback HTTP redirect listener to receive the code.  This needs to be started first,&#xA;// as the exact redirect URI (including port) must be passed in the authorization request.&#xA;_redirectHTTPHandler = [[OIDRedirectHTTPHandler alloc] initWithSuccessURL:successURL];&#xA;NSURL *redirectURI = [_redirectHTTPHandler startHTTPListener:nil];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, initiate the authorization request. By using the &lt;code&gt;authStateByPresentingAuthorizationRequest&lt;/code&gt; convenience method, the token exchange will be performed automatically, and everything will be protected with PKCE (if the server supports it). By assigning the return value to the &lt;code&gt;OIDRedirectHTTPHandler&lt;/code&gt;&#39;s &lt;code&gt;currentAuthorizationFlow&lt;/code&gt;, the authorization will continue automatically once the user makes their choice:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// builds authentication request&#xA;OIDAuthorizationRequest *request =&#xA;    [[OIDAuthorizationRequest alloc] initWithConfiguration:configuration&#xA;                                                  clientId:kClientID&#xA;                                              clientSecret:kClientSecret&#xA;                                                    scopes:@[ OIDScopeOpenID ]&#xA;                                               redirectURL:redirectURI&#xA;                                              responseType:OIDResponseTypeCode&#xA;                                      additionalParameters:nil];&#xA;// performs authentication request&#xA;__weak __typeof(self) weakSelf = self;&#xA;_redirectHTTPHandler.currentAuthorizationFlow =&#xA;    [OIDAuthState authStateByPresentingAuthorizationRequest:request&#xA;                        callback:^(OIDAuthState *_Nullable authState,&#xA;                                   NSError *_Nullable error) {&#xA;  // Brings this app to the foreground.&#xA;  [[NSRunningApplication currentApplication]&#xA;      activateWithOptions:(NSApplicationActivateAllWindows |&#xA;                           NSApplicationActivateIgnoringOtherApps)];&#xA;&#xA;  // Processes the authorization response.&#xA;  if (authState) {&#xA;    NSLog(@&#34;Got authorization tokens. Access token: %@&#34;,&#xA;          authState.lastTokenResponse.accessToken);&#xA;  } else {&#xA;    NSLog(@&#34;Authorization error: %@&#34;, error.localizedDescription);&#xA;  }&#xA;  [weakSelf setAuthState:authState];&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Authorizing –&amp;nbsp;tvOS&lt;/h3&gt; &#xA;&lt;p&gt;Ensure that your main class is a delegate of &lt;code&gt;OIDAuthStateChangeDelegate&lt;/code&gt;, &lt;code&gt;OIDAuthStateErrorDelegate&lt;/code&gt;, implement the corresponding methods, and include the following property and instance variable:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// property of the containing class&#xA;@property(nonatomic, strong, nullable) OIDAuthState *authState;&#xA;&#xA;// instance variable of the containing class&#xA;OIDTVAuthorizationCancelBlock _cancelBlock;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, build and perform the authorization request.&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// builds authentication request&#xA;__weak __typeof(self) weakSelf = self;&#xA;&#xA;OIDTVAuthorizationRequest *request =&#xA;    [[OIDTVAuthorizationRequest alloc] initWithConfiguration:configuration&#xA;                                                    clientId:kClientID&#xA;                                                clientSecret:kClientSecret&#xA;                                                      scopes:@[ OIDScopeOpenID, OIDScopeProfile ]&#xA;                                        additionalParameters:nil];&#xA;&#xA;// performs authentication request&#xA;OIDTVAuthorizationInitialization initBlock =&#xA;    ^(OIDTVAuthorizationResponse *_Nullable response, NSError *_Nullable error) {&#xA;      if (response) {&#xA;        // process authorization response&#xA;        NSLog(@&#34;Got authorization response: %@&#34;, response);&#xA;      } else {&#xA;        // handle initialization error&#xA;        NSLog(@&#34;Error: %@&#34;, error);&#xA;      }&#xA;    };&#xA;&#xA;OIDTVAuthorizationCompletion completionBlock =&#xA;    ^(OIDAuthState *_Nullable authState, NSError *_Nullable error) {&#xA;      weakSelf.signInView.hidden = YES;&#xA;      if (authState) {&#xA;        NSLog(@&#34;Token response: %@&#34;, authState.lastTokenResponse);&#xA;        [weakSelf setAuthState:authState];&#xA;      } else {&#xA;        NSLog(@&#34;Error: %@&#34;, error);&#xA;        [weakSelf setAuthState:nil];&#xA;      }&#xA;    };&#xA;&#xA;_cancelBlock = [OIDTVAuthorizationService authorizeTVRequest:request&#xA;                                              initialization:initBlock&#xA;                                                  completion:completionBlock];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Making API Calls&lt;/h3&gt; &#xA;&lt;p&gt;AppAuth gives you the raw token information, if you need it. However, we recommend that users of the &lt;code&gt;OIDAuthState&lt;/code&gt; convenience wrapper use the provided &lt;code&gt;performActionWithFreshTokens:&lt;/code&gt; method to perform their API calls to avoid needing to worry about token freshness:&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[_authState performActionWithFreshTokens:^(NSString *_Nonnull accessToken,&#xA;                                           NSString *_Nonnull idToken,&#xA;                                           NSError *_Nullable error) {&#xA;  if (error) {&#xA;    NSLog(@&#34;Error fetching fresh tokens: %@&#34;, [error localizedDescription]);&#xA;    return;&#xA;  }&#xA;&#xA;  // perform your API request using the tokens&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let userinfoEndpoint = URL(string:&#34;https://openidconnect.googleapis.com/v1/userinfo&#34;)!&#xA;self.authState?.performAction() { (accessToken, idToken, error) in&#xA;&#xA;  if error != nil  {&#xA;    print(&#34;Error fetching fresh tokens: \(error?.localizedDescription ?? &#34;Unknown error&#34;)&#34;)&#xA;    return&#xA;  }&#xA;  guard let accessToken = accessToken else {&#xA;    return&#xA;  }&#xA;&#xA;  // Add Bearer token to request&#xA;  var urlRequest = URLRequest(url: userinfoEndpoint)&#xA;  urlRequest.allHTTPHeaderFields = [&#34;Authorization&#34;: &#34;Bearer \(accessToken)&#34;]&#xA;&#xA;  // Perform request...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom User-Agents (iOS and macOS)&lt;/h3&gt; &#xA;&lt;p&gt;Each OAuth flow involves presenting an external user-agent to the user, that allows them to interact with the OAuth authorization server. Typical examples of a user-agent are the user&#39;s browser, or an in-app browser tab incarnation like &lt;code&gt;ASWebAuthenticationSession&lt;/code&gt; on iOS.&lt;/p&gt; &#xA;&lt;p&gt;AppAuth ships with several implementations of an external user-agent out of the box, including defaults for iOS and macOS suitable for most cases. The default user-agents typically share persistent cookies with the system default browser, to improve the chance that the user doesn&#39;t need to sign-in all over again.&lt;/p&gt; &#xA;&lt;p&gt;It is possible to change the user-agent that AppAuth uses, and even write your own - all without needing to fork the library.&lt;/p&gt; &#xA;&lt;p&gt;All implementations of the external user-agent, be they included or created by you need to conform to the &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/protocol_o_i_d_external_user_agent-p.html&#34;&gt;&lt;code&gt;OIDExternalUserAgent&lt;/code&gt;&lt;/a&gt; protocol.&lt;/p&gt; &#xA;&lt;p&gt;Instances of the &lt;code&gt;OIDExternalUserAgent&lt;/code&gt;are passed into &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/interface_o_i_d_auth_state.html#ac762fe2bf95c116f0b437419be211fa1&#34;&gt;&lt;code&gt;OIDAuthState.authStateByPresentingAuthorizationRequest:externalUserAgent:callback&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/interface_o_i_d_authorization_service.html#ae551f8e6887366a46e49b09b37389b8f&#34;&gt;&lt;code&gt;OIDAuthorizationService.presentAuthorizationRequest:externalUserAgent:callback:&lt;/code&gt;&lt;/a&gt; rather than using the platform-specific convenience methods (which use the default user-agents for their respective platforms), like &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/category_o_i_d_auth_state_07_i_o_s_08.html#ae32fd0732cd3192cd5219f2655a4c85c&#34;&gt;&lt;code&gt;OIDAuthState.authStateByPresentingAuthorizationRequest:presentingViewController:callback:&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Popular use-cases for writing your own user-agent implementation include needing to style the user-agent in ways not supported by AppAuth, and implementing a fully custom flow with your own business logic. You can take one of the existing implementations as a starting point to copy, rename, and customize to your needs.&lt;/p&gt; &#xA;&lt;h4&gt;Custom Browser User-Agent&lt;/h4&gt; &#xA;&lt;p&gt;AppAuth for iOS includes a few extra user-agent implementations which you can try, or use as a reference for your own implementation. One of them, &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/interface_o_i_d_external_user_agent_i_o_s_custom_browser.html&#34;&gt;&lt;code&gt;OIDExternalUserAgentIOSCustomBrowser&lt;/code&gt;&lt;/a&gt; enables you to use a different browser for authentication, like Chrome for iOS or Firefox for iOS.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s how to configure AppAuth to use a custom browser using the &lt;code&gt;OIDExternalUserAgentIOSCustomBrowser&lt;/code&gt; user agent:&lt;/p&gt; &#xA;&lt;p&gt;First, add the following array to your &lt;a href=&#34;https://github.com/openid/AppAuth-iOS/raw/135f99d2cb4e9d18d310ac2588b905e612461561/Examples/Example-iOS_ObjC/Source/Info.plist#L34&#34;&gt;Info.plist&lt;/a&gt; (in XCode, right click -&amp;gt; Open As -&amp;gt; Source Code)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    &amp;lt;key&amp;gt;LSApplicationQueriesSchemes&amp;lt;/key&amp;gt;&#xA;    &amp;lt;array&amp;gt;&#xA;        &amp;lt;string&amp;gt;googlechromes&amp;lt;/string&amp;gt;&#xA;        &amp;lt;string&amp;gt;opera-https&amp;lt;/string&amp;gt;&#xA;        &amp;lt;string&amp;gt;firefox&amp;lt;/string&amp;gt;&#xA;    &amp;lt;/array&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is required so that AppAuth can test for the browser and open the app store if it&#39;s not installed (the default behavior of this user-agent). You only need to include the URL scheme of the actual browser you intend to use.&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Objective-C&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// performs authentication request&#xA;AppDelegate *appDelegate =&#xA;    (AppDelegate *)[UIApplication sharedApplication].delegate;&#xA;id&amp;lt;OIDExternalUserAgent&amp;gt; userAgent =&#xA;    [OIDExternalUserAgentIOSCustomBrowser CustomBrowserChrome];&#xA;appDelegate.currentAuthorizationFlow =&#xA;    [OIDAuthState authStateByPresentingAuthorizationRequest:request&#xA;        externalUserAgent:userAgent&#xA;                 callback:^(OIDAuthState *_Nullable authState,&#xA;                                   NSError *_Nullable error) {&#xA;  if (authState) {&#xA;    NSLog(@&#34;Got authorization tokens. Access token: %@&#34;,&#xA;          authState.lastTokenResponse.accessToken);&#xA;    [self setAuthState:authState];&#xA;  } else {&#xA;    NSLog(@&#34;Authorization error: %@&#34;, [error localizedDescription]);&#xA;    [self setAuthState:nil];&#xA;  }&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Swift&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;guard let appDelegate = UIApplication.shared.delegate as? AppDelegate else {&#xA;            self.logMessage(&#34;Error accessing AppDelegate&#34;)&#xA;            return&#xA;        }&#xA;let userAgent = OIDExternalUserAgentIOSCustomBrowser.customBrowserChrome()&#x9;&#x9;&#xA;appDelegate.currentAuthorizationFlow = OIDAuthState.authState(byPresenting: request, externalUserAgent: userAgent) { authState, error in&#xA;    if let authState = authState {&#xA;        self.setAuthState(authState)&#xA;        self.logMessage(&#34;Got authorization tokens. Access token: \(authState.lastTokenResponse?.accessToken ?? &#34;DEFAULT_TOKEN&#34;)&#34;)&#xA;    } else {&#xA;        self.logMessage(&#34;Authorization error: \(error?.localizedDescription ?? &#34;DEFAULT_ERROR&#34;)&#34;)&#xA;        self.setAuthState(nil)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it! With those two changes (which you can try on the included sample), AppAuth will use Chrome iOS for the authorization request (and open Chrome in the App Store if it&#39;s not installed).&lt;/p&gt; &#xA;&lt;p&gt;⚠️&lt;strong&gt;Note: the &lt;code&gt;OIDExternalUserAgentIOSCustomBrowser&lt;/code&gt; user-agent is not intended for consumer apps&lt;/strong&gt;. It is designed for advanced enterprise use-cases where the app developers have greater control over the operating environment and have special requirements that require a custom browser like Chrome.&lt;/p&gt; &#xA;&lt;p&gt;You don&#39;t need to stop with the included external user agents either! Since the &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/protocol_o_i_d_external_user_agent-p.html&#34;&gt;&lt;code&gt;OIDExternalUserAgent&lt;/code&gt;&lt;/a&gt; protocol is part of AppAuth&#39;s public API, you can implement your own versions of it. In the above example, &lt;code&gt;userAgent = [OIDExternalUserAgentIOSCustomBrowser CustomBrowserChrome]&lt;/code&gt; would be replaced with an instantiation of your user-agent implementation.&lt;/p&gt; &#xA;&lt;h2&gt;API Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Browse the &lt;a href=&#34;http://openid.github.io/AppAuth-iOS/docs/latest/annotated.html&#34;&gt;API documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Included Samples&lt;/h2&gt; &#xA;&lt;p&gt;Sample apps that explore core AppAuth features are available for iOS, macOS and tvOS; follow the instructions in &lt;a href=&#34;https://raw.githubusercontent.com/openid/AppAuth-iOS/master/Examples/README.md&#34;&gt;Examples/README.md&lt;/a&gt; to get started.&lt;/p&gt;</summary>
  </entry>
</feed>