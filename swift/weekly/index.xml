<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-05T02:02:56Z</updated>
  <subtitle>Weekly Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SwiftKickMobile/SwiftMessages</title>
    <updated>2023-11-05T02:02:56Z</updated>
    <id>tag:github.com,2023-11-05:/SwiftKickMobile/SwiftMessages</id>
    <link href="https://github.com/SwiftKickMobile/SwiftMessages" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A very flexible message bar for UIKit and SwiftUI.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SwiftMessages&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://twitter.com/TimothyMoose&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/contact-@TimothyMoose-blue.svg?style=flat&#34; alt=&#34;Twitter: @TimothyMoose&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/SwiftMessages&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/SwiftMessages.svg?style=flat&#34; alt=&#34;Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/SwiftMessages&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/l/SwiftMessages.svg?style=flat&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/SwiftMessages&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/SwiftMessages.svg?style=flat&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/Design/swiftmessages.png&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;ðŸ”¥ðŸ”¥ðŸ”¥ &lt;strong&gt;NEW&lt;/strong&gt; SwiftUI support added!&lt;/p&gt; &#xA;&lt;p&gt;SwiftMessages is a very flexible view and view controller presentation library for UIKit and SwiftUI.&lt;/p&gt; &#xA;&lt;p&gt;Message views and view controllers can be displayed at the top, bottom, or center of the screen, or behind navigation bars and tab bars. There are interactive dismiss gestures including a fun, physics-based one. Multiple background dimming modes. And a lot more!&lt;/p&gt; &#xA;&lt;p&gt;In addition to the numerous configuration options, SwiftMessages provides several good-looking layouts and themes. But SwiftMessages is also designer-friendly, which means you can fully and easily customize the view:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Copy one of the included nib files into your project and change it.&lt;/li&gt; &#xA; &lt;li&gt;Subclass &lt;code&gt;MessageView&lt;/code&gt; and add elements, etc.&lt;/li&gt; &#xA; &lt;li&gt;Or just supply an arbitrary instance of &lt;code&gt;View&lt;/code&gt; or &lt;code&gt;UIView&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/Demo/demo.png&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;Go to &lt;code&gt;File | Swift Packages | Add Package Dependency...&lt;/code&gt; in Xcode and search for &#34;SwiftMessages&#34;. If multiple results are found, select the one owned by SwiftKick Mobile.&lt;/p&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;Add the following line to your Podfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;SwiftMessages&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;p&gt;Add the following line to your Cartfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;github &#34;SwiftKickMobile/SwiftMessages&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the Carthage build fails, &lt;a href=&#34;https://github.com/Carthage/Carthage/issues/3019&#34;&gt;try using the script&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Manual&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Put SwiftMessages repo somewhere in your project directory.&lt;/li&gt; &#xA; &lt;li&gt;In Xcode, add &lt;code&gt;SwiftMessages.xcodeproj&lt;/code&gt; to your project.&lt;/li&gt; &#xA; &lt;li&gt;On your app&#39;s target, add the SwiftMessages framework: &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;as an embedded binary on the General tab.&lt;/li&gt; &#xA;   &lt;li&gt;as a target dependency on the Build Phases tab.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Basics&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;SwiftMessages.show(view: myView)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Although you can show any instance of &lt;code&gt;UIView&lt;/code&gt;, SwiftMessages provides a &lt;code&gt;MessageView&lt;/code&gt; class and assortment of nib-based layouts that should handle most cases:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Instantiate a message view from the provided card view layout. SwiftMessages searches for nib&#xA;// files in the main bundle first, so you can easily copy them into your project and make changes.&#xA;let view = MessageView.viewFromNib(layout: .cardView)&#xA;&#xA;// Theme message elements with the warning style.&#xA;view.configureTheme(.warning)&#xA;&#xA;// Add a drop shadow.&#xA;view.configureDropShadow()&#xA;&#xA;// Set message title, body, and icon. Here, we&#39;re overriding the default warning&#xA;// image with an emoji character.&#xA;let iconText = [&#34;ðŸ¤”&#34;, &#34;ðŸ˜³&#34;, &#34;ðŸ™„&#34;, &#34;ðŸ˜¶&#34;].randomElement()!&#xA;view.configureContent(title: &#34;Warning&#34;, body: &#34;Consider yourself warned.&#34;, iconText: iconText)&#xA;&#xA;// Increase the external margin around the card. In general, the effect of this setting&#xA;// depends on how the given layout is constrained to the layout margins.&#xA;view.layoutMarginAdditions = UIEdgeInsets(top: 20, left: 20, bottom: 20, right: 20)&#xA;&#xA;// Reduce the corner radius (applicable to layouts featuring rounded corners).&#xA;(view.backgroundView as? CornerRoundingView)?.cornerRadius = 10&#xA;&#xA;// Show the message.&#xA;SwiftMessages.show(view: view)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may wish to use the view provider variant &lt;code&gt;show(viewProvider:)&lt;/code&gt; to ensure that your UIKit code is executed on the main queue:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;SwiftMessages.show {&#xA;    let view = MessageView.viewFromNib(layout: .cardView)&#xA;    // ... configure the view&#xA;    return view&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;SwiftMessages.Config&lt;/code&gt; struct provides numerous configuration options that can be passed to &lt;code&gt;show()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var config = SwiftMessages.Config()&#xA;&#xA;// Slide up from the bottom.&#xA;config.presentationStyle = .bottom&#xA;&#xA;// Display in a window at the specified window level.&#xA;config.presentationContext = .window(windowLevel: .statusBar)&#xA;&#xA;Note that, as of iOS 13, it is no longer possible to cover the status bar&#xA;regardless of the window level. A workaround is to hide the status bar instead.&#xA;config.prefersStatusBarHidden = true&#xA;&#xA;// Disable the default auto-hiding behavior.&#xA;config.duration = .forever&#xA;&#xA;// Dim the background like a popover view. Hide when the background is tapped.&#xA;config.dimMode = .gray(interactive: true)&#xA;&#xA;// Disable the interactive pan-to-hide gesture.&#xA;config.interactiveHide = false&#xA;&#xA;// Specify a status bar style to if the message is displayed directly under the status bar.&#xA;config.preferredStatusBarStyle = .lightContent&#xA;&#xA;// Specify one or more event listeners to respond to show and hide events.&#xA;config.eventListeners.append() { event in&#xA;    if case .didHide = event {&#xA;        print(&#34;yep id=\(String(describing: event.id)&#34;)&#xA;    }&#xA;}&#xA;&#xA;SwiftMessages.show(config: config, view: view)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Specify default configuration options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;SwiftMessages.defaultConfig.presentationStyle = .bottom&#xA;&#xA;// Show message with default config.&#xA;SwiftMessages.show(view: view)&#xA;&#xA;// Customize config using the default as a base.&#xA;var config = SwiftMessages.defaultConfig&#xA;config.duration = .forever&#xA;SwiftMessages.show(config: config, view: view)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;View Controllers&lt;/h3&gt; &#xA;&lt;p&gt;SwiftMessages can present view controllers using the &lt;code&gt;SwiftMessagesSegue&lt;/code&gt; custom modal segue!&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/Design/SwiftMessagesSegue.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/SwiftMessages/SwiftMessagesSegue.swift&#34;&gt;&lt;code&gt;SwiftMessagesSegue&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;code&gt;UIStoryboardSegue&lt;/code&gt; that integrates directly into Interface Builder as a custom modal segue, enabling view controllers to take advantage of SwiftMessages layouts, animations and more. &lt;code&gt;SwiftMessagesSegue&lt;/code&gt; works with any UIKIt project â€” storyboards are not required. Refer to the View Controllers readme below for more information.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/ViewControllers.md&#34;&gt;View Controllers Readme&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;And check out our blog post &lt;a href=&#34;http://www.swiftkickmobile.com/elegant-custom-uiviewcontroller-transitioning-uiviewcontrollertransitioningdelegate-uiviewcontrolleranimatedtransitioning/&#34;&gt;Elegant Custom UIViewController Transitioning&lt;/a&gt; to learn a great technique you can use to build your own custom segues that utilize &lt;code&gt;UIViewControllerTransitioningDelegate&lt;/code&gt; and &lt;code&gt;UIViewControllerAnimatedTransitioning&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;SwiftUI&lt;/h3&gt; &#xA;&lt;p&gt;Any of the built-in SwiftMessages views can be displayed by calling the SwiftMessages APIs from within observable object, a button action closure, etc. However, SwiftMessages can also display your custom SwiftUI views.&lt;/p&gt; &#xA;&lt;p&gt;The first step is to define a type that conforms to &lt;code&gt;MessageViewConvertible&lt;/code&gt;. This would typically be a struct containing the message data to display:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct DemoMessage: Identifiable {&#xA;    let title: String&#xA;    let body: String&#xA;&#xA;    var id: String { title + body }&#xA;}&#xA;&#xA;extension DemoMessage: MessageViewConvertible {&#xA;    func asMessageView() -&amp;gt; DemoMessageView {&#xA;        DemoMessageView(message: self)&#xA;    }&#xA;}&#xA;&#xA;struct DemoMessageView: View {&#xA;&#xA;    let message: DemoMessage&#xA;&#xA;    var body: some View {&#xA;        VStack(alignment: .leading) {&#xA;            Text(message.title).font(.system(size: 20, weight: .bold))&#xA;            Text(message.body)&#xA;        }&#xA;        .multilineTextAlignment(.leading)&#xA;        .padding(30)&#xA;        // This makes the message width greedy&#xA;        .frame(maxWidth: .infinity)&#xA;        .background(.gray)&#xA;        // This makes a tab-style view where the bottom corners are rounded and&#xA;        // the view&#39;s background extends to the top edge.&#xA;        .mask(&#xA;&#x9;        UnevenRoundedRectangle(bottomLeadingRadius: 15, bottomTrailingRadius: 15)&#xA;            // This causes the background to extend into the safe area to the screen edge.&#xA;            .edgesIgnoringSafeArea(.top)&#xA;        )&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The SwiftUI message view can be displayed just like any other UIKit message by using &lt;code&gt;MessageHostingView&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct DemoView: View {&#xA;    var body: some View {&#xA;        Button(&#34;Show message&#34;) {&#xA;            let message = DemoMessage(title: &#34;Demo&#34;, body: &#34;SwiftUI forever!&#34;)&#xA;            let messageView = MessageHostingView(message: message)&#xA;            SwiftMessages.show(view: messageView)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But you may also use a state-based approach using the &lt;code&gt;swiftMessage()&lt;/code&gt; view modifier:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct DemoView: View {&#xA;&#xA;    @State var message: DemoMessage?&#xA;&#xA;    var body: some View {&#xA;        Button(&#34;Show message&#34;) {&#xA;            message = DemoMessage(title: &#34;Demo&#34;, body: &#34;SwiftUI forever!&#34;)&#xA;        }&#xA;        .swiftMessage(message: $message)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This technique may be more SwiftUI-like, but it doesn&#39;t offer the full capability of SwiftMessages, such as explicitly hiding messages by their ID. It is totally reasonable to use a combination of both approaches.&lt;/p&gt; &#xA;&lt;p&gt;Try it out in the SwiftUI demo app!&lt;/p&gt; &#xA;&lt;h3&gt;Accessibility&lt;/h3&gt; &#xA;&lt;p&gt;SwiftMessages provides excellent VoiceOver support out-of-the-box.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The title and body of the message are combined into a single announcement when the message is shown. The &lt;code&gt;MessageView.accessibilityPrefix&lt;/code&gt; property can be set to prepend additional clarifying text to the announcement.&lt;/p&gt; &lt;p&gt;Sometimes, a message may contain important visual cues that aren&#39;t captured in the title or body. For example, a message may rely on a yellow background to convey a warning rather than having the word &#34;warning&#34; in the title or body. In this case, it might be helpful to set &lt;code&gt;MessageView.accessibilityPrefix = &#34;warning&#34;&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If the message is shown with a dim view using &lt;code&gt;config.dimMode&lt;/code&gt;, elements below the dim view are not focusable until the message is hidden. If &lt;code&gt;config.dimMode.interactive == true&lt;/code&gt;, the dim view itself will be focusable and read out &#34;dismiss&#34; followed by &#34;button&#34;. The former text can be customized by setting the &lt;code&gt;config.dimModeAccessibilityLabel&lt;/code&gt; property.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the &lt;code&gt;AccessibleMessage&lt;/code&gt; protocol for implementing proper accessibility support in custom views.&lt;/p&gt; &#xA;&lt;h3&gt;Keyboard Avoidance&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;KeyboardTrackingView&lt;/code&gt; class can be used to cause the message view to avoid the keyboard by sliding up when the keyboard gets too close.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var config = SwiftMessages.defaultConfig&#xA;config.keyboardTrackingView = KeyboardTrackingView()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can incorporate &lt;code&gt;KeyboardTrackingView&lt;/code&gt; into your app even when you&#39;re not using SwiftMessages. Install into your view hierarchy by pinning &lt;code&gt;KeyboardTrackingView&lt;/code&gt; to the bottom, leading, and trailing edges of the screen. Then pin the bottom of your content that should avoid the keyboard to the top &lt;code&gt;KeyboardTrackingView&lt;/code&gt;. Use an equality constraint to strictly track the keyboard or an inequality constraint to only move when the keyboard gets too close. &lt;code&gt;KeyboardTrackingView&lt;/code&gt; works by observing keyboard notifications and adjusting its height to maintain its top edge above the keyboard, thereby pushing your content up. See the comments in &lt;code&gt;KeyboardTrackingView&lt;/code&gt; for configuration options.&lt;/p&gt; &#xA;&lt;h3&gt;Message Queueing&lt;/h3&gt; &#xA;&lt;p&gt;You can call &lt;code&gt;SwiftMessages.show()&lt;/code&gt; as many times as you like. SwiftMessages maintains a queue and shows messages one at a time. If your view implements the &lt;code&gt;Identifiable&lt;/code&gt; protocol (like &lt;code&gt;MessageView&lt;/code&gt;), duplicate messages will be removed automatically. The pause between messages can be adjusted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;SwiftMessages.pauseBetweenMessages = 1.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a few ways to hide messages programatically:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Hide the current message.&#xA;SwiftMessages.hide()&#xA;&#xA;// Or hide the current message and clear the queue.&#xA;SwiftMessages.hideAll()&#xA;&#xA;// Or for a view that implements `Identifiable`:&#xA;SwiftMessages.hide(id: someId)&#xA;&#xA;// Or hide when the number of calls to show() and hideCounted(id:) for a &#xA;// given message ID are equal. This can be useful for messages that may be&#xA;// shown from  multiple code paths to ensure that all paths are ready to hide.&#xA;SwiftMessages.hideCounted(id: someId)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Multiple instances of &lt;code&gt;SwiftMessages&lt;/code&gt; can be used to show more than one message at a time. Note that the static &lt;code&gt;SwiftMessages.show()&lt;/code&gt; and other static APIs on &lt;code&gt;SwiftMessage&lt;/code&gt; are just convenience wrappers around the shared instance &lt;code&gt;SwiftMessages.sharedInstance&lt;/code&gt;). Instances must be retained, thus it should be a property of something (e.g. your view controller):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class SomeViewController: UIViewController {&#xA;    let otherMessages = SwiftMessages()&#x9;&#xA;&#x9;&#xA;    func someMethod() {&#xA;        SwiftMessages.show(...)&#xA;        otherMessages.show(...)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieving Messages&lt;/h3&gt; &#xA;&lt;p&gt;There are several APIs available for retrieving messages that are currently being shown, hidden, or queued to be shown. These APIs are useful for updating messages when some event happens without needing to keep temporary references around. See also &lt;code&gt;eventListeners&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Get a message view with the given ID if it is currently &#xA;// being shown or hidden.&#xA;if let view = SwiftMessages.current(id: &#34;some id&#34;) { ... }&#xA;&#xA;// Get a message view with the given ID if is it currently &#xA;// queued to be shown. &#xA;if let view = SwiftMessages.queued(id: &#34;some id&#34;) { ... }&#xA;&#xA;// Get a message view with the given ID if it is currently being&#xA;// shown, hidden or in the queue to be shown.&#xA;if let view = SwiftMessages.currentOrQueued(id: &#34;some id&#34;) { ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Customization&lt;/h3&gt; &#xA;&lt;p&gt;SwiftMessages can display any &lt;code&gt;UIView&lt;/code&gt;. However, there are varying degrees of customization that can be done to the bundled views.&lt;/p&gt; &#xA;&lt;h4&gt;Nib Files&lt;/h4&gt; &#xA;&lt;p&gt;All of the message designs bundled with SwiftMessages have associated nib files. You are encouraged to copy any of these nib files into your project and modify them to suit your needs. SwiftMessages will load your copy of the file instead of the original. Nib files may be copied in Xcode using drag-and-drop.&lt;/p&gt; &#xA;&lt;p&gt;To facilitate the use of nib-based layouts, &lt;code&gt;MessageView&lt;/code&gt; provides some type-safe convenience methods for loading the bundled nibs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let view = MessageView.viewFromNib(layout: .cardView)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition, the &lt;code&gt;SwiftMessages&lt;/code&gt; class provides some generic loading methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Instantiate MessageView from a named nib.&#xA;let view: MessageView = try! SwiftMessages.viewFromNib(named: &#34;MyCustomNib&#34;)&#xA;&#xA;// Instantiate MyCustomView from a nib named MyCustomView.nib.&#xA;let view: MyCustomView = try! SwiftMessages.viewFromNib()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;MessageView Class&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/SwiftMessages/MessageView.swift&#34;&gt;&lt;code&gt;MessageView&lt;/code&gt;&lt;/a&gt; is a light-weight view that all of the bundled designs use. It primarily consists of the following optional &lt;code&gt;@IBOutlet&lt;/code&gt; properties:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Element&lt;/th&gt; &#xA;   &lt;th&gt;Declaration&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Title&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;titleLabel: UILabel?&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The message title.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Message body&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bodyLabel: UILabel?&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The body of the message.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Image icon&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iconImageView: UIImageView?&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;An image-based icon.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Text icon&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iconLabel: UILabel?&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A text-based (emoji) alternative to the image icon.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Button&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;button: UIButton?&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;An action button.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The SwiftMessages nib file use &lt;code&gt;MessageView&lt;/code&gt; as the top-level view with content connected to these outlets. The layouts are done using stack views, which means that you can remove an element by simply hiding it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;view.titleLabel.isHidden = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A common mistake is attempting to remove an element by setting the corresponding outlet to &lt;code&gt;nil&lt;/code&gt;. This does not work because it does not remove the element from the view hierarchy.&lt;/p&gt; &#xA;&lt;h4&gt;Configuration&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;MessageView&lt;/code&gt; provides numerous methods that follow the &lt;code&gt;configure*&lt;/code&gt; naming convention:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;view.configureTheme(.warning)&#xA;view.configureContent(title: &#34;Warning&#34;, body: &#34;Consider yourself warned.&#34;, iconText: &#34;ðŸ¤”&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All of these methods are shortcuts for quickly configuring the underlying view properties. SwiftMessages strives to avoid doing any internal magic in these methods, so you do not need to call them. You can configure the view properties directly or combine the two approaches.&lt;/p&gt; &#xA;&lt;h4&gt;Interaction&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;MessageView&lt;/code&gt; provides an optional block-based tap handler for the button and another for the view itself:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Hide when button tapped&#xA;messageView.buttonTapHandler = { _ in SwiftMessages.hide() }&#xA;&#xA;// Hide when message view tapped&#xA;messageView.tapHandler = { _ in SwiftMessages.hide() }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Extending&lt;/h4&gt; &#xA;&lt;p&gt;The suggested method for starting with &lt;code&gt;MessageView&lt;/code&gt; as a base and &lt;strong&gt;adding new elements&lt;/strong&gt;, such as additional buttons, is as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Copy one of the bundled nib files into your project or create a new one from scratch.&lt;/li&gt; &#xA; &lt;li&gt;Add new elements to the nib file.&lt;/li&gt; &#xA; &lt;li&gt;Sublcass &lt;code&gt;MessageView&lt;/code&gt; and create outlets for the new elements.&lt;/li&gt; &#xA; &lt;li&gt;Assign the top-level view in the nib file to the subclass.&lt;/li&gt; &#xA; &lt;li&gt;Connect outlets between the nib file and the subclass.&lt;/li&gt; &#xA; &lt;li&gt;(recommended) override the implementation of &lt;code&gt;Identifiable&lt;/code&gt; as needed to incorporate new elements into the message&#39;s identity.&lt;/li&gt; &#xA; &lt;li&gt;(recommended) override the implementation of &lt;code&gt;AccessibleMessage&lt;/code&gt; as needed to incorporate new elements into Voice Over.&lt;/li&gt; &#xA; &lt;li&gt;Use one of the nib-loading methods above to load the view.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;BaseView Class&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/SwiftMessages/BaseView.swift&#34;&gt;&lt;code&gt;BaseView&lt;/code&gt;&lt;/a&gt; is the superclass of &lt;code&gt;MessageView&lt;/code&gt; and provides numerous options that aren&#39;t specific to the &#34;title + body + icon + button&#34; design of &lt;code&gt;MessageView&lt;/code&gt;. Custom views that are significantly different from &lt;code&gt;MessageView&lt;/code&gt;, such as a progress indicator, should subclass &lt;code&gt;BaseView&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;CornerRoundingView Class&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/SwiftMessages/CornerRoundingView.swift&#34;&gt;&lt;code&gt;CornerRoundingView&lt;/code&gt;&lt;/a&gt; is a custom view that messages can use for rounding all or a subset of corners with squircles (the smoother method of rounding corners that you see on app icons). The nib files that feature rounded corners have &lt;code&gt;backgroundView&lt;/code&gt; assigned to a &lt;code&gt;CornerRoundingView&lt;/code&gt;. It provides a &lt;code&gt;roundsLeadingCorners&lt;/code&gt; option to dynamically round only the leading corners of the view when presented from top or bottom (a feature used for the tab-style layouts).&lt;/p&gt; &#xA;&lt;h4&gt;Animator Protocol&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/SwiftMessages/Animator.swift&#34;&gt;&lt;code&gt;Animator&lt;/code&gt;&lt;/a&gt; is the protocol that SwiftMessages uses for presentation and dismissal animations. Custom animations can be done through the &lt;code&gt;SwiftMessages.PresentationStyle.custom(animator:)&lt;/code&gt;. Some related components:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/SwiftMessages/TopBottomAnimation.swift&#34;&gt;&lt;code&gt;TopBottomAnimation&lt;/code&gt;&lt;/a&gt; is a sliding implementation of &lt;code&gt;Animator&lt;/code&gt; used internally by &lt;code&gt;.top&lt;/code&gt; and &lt;code&gt;.bottom&lt;/code&gt; presentation styles. It provides some customization options.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/SwiftMessages/PhysicsAnimation.swift&#34;&gt;&lt;code&gt;PhysicsAnimation&lt;/code&gt;&lt;/a&gt; is a scaling + opacity implementation of &lt;code&gt;Animator&lt;/code&gt; used internally by the &lt;code&gt;.center&lt;/code&gt; presentation style. It provides a fun physics-based dismissal gesture and provides customization options including &lt;code&gt;.top&lt;/code&gt; and &lt;code&gt;.bottom&lt;/code&gt; placement.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/SwiftMessages/PhysicsPanHandler.swift&#34;&gt;&lt;code&gt;PhysicsPanHandler&lt;/code&gt;&lt;/a&gt; provides the physics-based dismissal gesture for &lt;code&gt;PhysicsAnimation&lt;/code&gt; and can be incorporated into other &lt;code&gt;Animator&lt;/code&gt; implementations.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;High-quality PRs for cool &lt;code&gt;Animator&lt;/code&gt; implementations are welcome!&lt;/p&gt; &#xA;&lt;h4&gt;MarginAdjustable Protocol&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/SwiftMessages/MarginAdjustable.swift&#34;&gt;&lt;code&gt;MarginAdjustable&lt;/code&gt;&lt;/a&gt; is a protocol adopted by &lt;code&gt;BaseView&lt;/code&gt;. If the view being presented adopts &lt;code&gt;MarginAdjustable&lt;/code&gt;, SwiftMessages takes ownership of the view&#39;s layout margins to ensure ideal spacing across the full range of presentation contexts.&lt;/p&gt; &#xA;&lt;h4&gt;BackgroundViewable Protocol&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/SwiftMessages/BackgroundViewable.swift&#34;&gt;&lt;code&gt;BackgroundViewable&lt;/code&gt;&lt;/a&gt; is a protocol adopted by &lt;code&gt;BaseView&lt;/code&gt; and requires that a view provide a single &lt;code&gt;backgroundView&lt;/code&gt; property. &lt;code&gt;BaseView&lt;/code&gt; initializes &lt;code&gt;backgroundView = self&lt;/code&gt;, which you can freely re-assign to any subview.&lt;/p&gt; &#xA;&lt;p&gt;If the view being presented adopts &lt;code&gt;BackgroundViewable&lt;/code&gt;, SwiftMessages will ignore touches outside of &lt;code&gt;backgroundView&lt;/code&gt;. This is important because message views always span the full width of the device. Card and tab-style layouts appear inset from the edges of the device because the message view&#39;s background is transparent and &lt;code&gt;backgroundView&lt;/code&gt; is assigned to a subview constrained to the layout margins. In these layouts, touches in the transparent margins should be ignored.&lt;/p&gt; &#xA;&lt;h4&gt;Identifiable Protocol&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/SwiftMessages/Identifiable.swift&#34;&gt;&lt;code&gt;Identifiable&lt;/code&gt;&lt;/a&gt; is a protocol adopted by &lt;code&gt;MessageView&lt;/code&gt; and requires that a view provide a single &lt;code&gt;id&lt;/code&gt; property, which SwiftMessages uses for message deduplication.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MessageView&lt;/code&gt; computes the &lt;code&gt;id&lt;/code&gt; based on the message content, but &lt;code&gt;id&lt;/code&gt; can also be set explicitly as needed.&lt;/p&gt; &#xA;&lt;h4&gt;AccessibleMessage Protocol&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/SwiftMessages/AccessibleMessage.swift&#34;&gt;&lt;code&gt;AccessibleMessage&lt;/code&gt;&lt;/a&gt; is a protocol adopted by &lt;code&gt;MessageView&lt;/code&gt;. If the view being presented adopts &lt;code&gt;AccessibleMessage&lt;/code&gt;, SwiftMessages provides improved Voice Over.&lt;/p&gt; &#xA;&lt;h2&gt;About SwiftKick Mobile&lt;/h2&gt; &#xA;&lt;p&gt;We build high quality apps! &lt;a href=&#34;http://www.swiftkickmobile.com&#34;&gt;Get in touch&lt;/a&gt; if you need help with a project.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;SwiftMessages is distributed under the MIT license. &lt;a href=&#34;https://raw.githubusercontent.com/SwiftKickMobile/SwiftMessages/master/LICENSE.md&#34;&gt;See LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>sparrowcode/AlertKit</title>
    <updated>2023-11-05T02:02:56Z</updated>
    <id>tag:github.com,2023-11-05:/sparrowcode/AlertKit</id>
    <link href="https://github.com/sparrowcode/AlertKit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Native alert from Apple Music &amp; Feedback. Contains Done, Heart &amp; Message and other presets.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;AlertKit&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Popup from Apple Music &amp;amp; Feedback in AppStore&lt;/strong&gt;. Contains &lt;code&gt;Done&lt;/code&gt;, &lt;code&gt;Heart&lt;/code&gt;, &lt;code&gt;Error&lt;/code&gt; and other. Supports Dark Mode. I tried to recreate Apple&#39;s alerts as much as possible. You can find these alerts in the AppStore after feedback and after you add a song to your library in Apple Music.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.sparrowcode.io/github/alertkit/v5/preview-v1_2.png&#34; alt=&#34;Alert Kit v5&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;For UIKit &amp;amp; SwiftUI call this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;AlertKitAPI.present(&#xA;    title: &#34;Added to Library&#34;,&#xA;    icon: .done,&#xA;    style: .iOS17AppleMusic,&#xA;    haptic: .success&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Available 2 styles:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public enum AlertViewStyle {&#xA;&#xA;    case iOS16AppleMusic&#xA;    case iOS17AppleMusic&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Community&lt;/h3&gt; &#xA;&lt;p float=&#34;left&#34;&gt; &lt;a href=&#34;https://twitter.com/sparrowcode_en&#34;&gt; &lt;img src=&#34;https://cdn.sparrowcode.io/github/badges/twitter-en.png?version=5&#34; height=&#34;52&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://twitter.com/sparrowcode_&#34;&gt; &lt;img src=&#34;https://cdn.sparrowcode.io/github/badges/twitter-ru.png?version=5&#34; height=&#34;52&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://t.me/sparrowcode_en&#34;&gt; &lt;img src=&#34;https://cdn.sparrowcode.io/github/badges/telegram-en.png?version=2&#34; height=&#34;52&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://t.me/sparrowcode&#34;&gt; &lt;img src=&#34;https://cdn.sparrowcode.io/github/badges/telegram-ru.png?version=2&#34; height=&#34;52&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://youtube.com/@sparrowcode&#34;&gt; &lt;img src=&#34;https://cdn.sparrowcode.io/github/badges/youtube-ru.png?version=1&#34; height=&#34;52&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/sparrowcode/AlertKit/v5/#apps-using&#34;&gt; &lt;img src=&#34;https://cdn.sparrowcode.io/github/badges/download-on-the-appstore.png?version=4&#34; height=&#34;52&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Navigate&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sparrowcode/AlertKit/v5/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sparrowcode/AlertKit/v5/#swift-package-manager&#34;&gt;Swift Package Manager&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sparrowcode/AlertKit/v5/#cocoapods&#34;&gt;CocoaPods&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sparrowcode/AlertKit/v5/#swiftui&#34;&gt;SwiftUI&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sparrowcode/AlertKit/v5/#present--dismiss&#34;&gt;Present &amp;amp; Dismiss&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sparrowcode/AlertKit/v5/#customisation&#34;&gt;Customisation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sparrowcode/AlertKit/v5/#apps-using&#34;&gt;Apps Using&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Ready to use on iOS 13+. Supports iOS and visionOS. Working with &lt;code&gt;UIKit&lt;/code&gt; and &lt;code&gt;SwiftUI&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;In Xcode go to Project -&amp;gt; Your Project Name -&amp;gt; &lt;code&gt;Package Dependencies&lt;/code&gt; -&amp;gt; Tap &lt;em&gt;Plus&lt;/em&gt;. Insert url:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;https://github.com/sparrowcode/AlertKit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or adding it to the &lt;code&gt;dependencies&lt;/code&gt; of your &lt;code&gt;Package.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/sparrowcode/AlertKit&#34;, .upToNextMajor(from: &#34;5.1.5&#34;))&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CocoaPods:&lt;/h3&gt; &#xA;&lt;p&gt;This is an outdated way of doing things. I advise you to use &lt;a href=&#34;https://raw.githubusercontent.com/sparrowcode/AlertKit/v5/#swift-package-manager&#34;&gt;SPM&lt;/a&gt;. However, I will continue to support Cocoapods for some time.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Cocoapods Instalation&lt;/summary&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt; is a dependency manager. For usage and installation instructions, visit their website. To integrate using CocoaPods, specify it in your &lt;code&gt;Podfile&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;SPAlert&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Manually&lt;/h3&gt; &#xA;&lt;p&gt;If you prefer not to use any of dependency managers, you can integrate manually. Put &lt;code&gt;Sources/AlertKit&lt;/code&gt; folder in your Xcode project. Make sure to enable &lt;code&gt;Copy items if needed&lt;/code&gt; and &lt;code&gt;Create groups&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;SwiftUI&lt;/h2&gt; &#xA;&lt;p&gt;You can use basic way via AlertKitAPI or call via modifier:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let alertView = AlertAppleMusic17View(title: &#34;Hello&#34;, subtitle: nil, icon: .done)&#xA;&#xA;VStack {}&#xA;    .alert(isPresent: $alertPresented, view: alertView)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Customisation&lt;/h2&gt; &#xA;&lt;p&gt;If you need customisation fonts, icon, colors or any other, make view:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let alertView = AlertAppleMusic17View(title: &#34;Added to Library&#34;, subtitle: nil, icon: .done)&#xA;// Change Font&#xA;alertView.titleLabel.font = UIFont.systemFont(ofSize: 21)&#xA;// Change Color&#xA;alertView.titleLabel.textColor = .white&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Present &amp;amp; Dismiss&lt;/h2&gt; &#xA;&lt;p&gt;You can present and dismiss alerts manually via view.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let alertView = AlertAppleMusic17View(title: &#34;Added to Library&#34;, subtitle: nil, icon: .done)&#xA;alertView.present(on: self)&#xA;&#xA;// and dismiss&#xA;alertView.dismiss()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For dismiss all alerts that was presented:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;AlertKitAPI.dismissAllAlerts()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Apps Using&lt;/h2&gt; &#xA;&lt;p float=&#34;left&#34;&gt; &lt;a href=&#34;https://apps.apple.com/app/id1624477055&#34;&gt;&lt;img src=&#34;https://cdn.sparrowcode.io/github/apps-using/id1624477055.png?version=2&#34; height=&#34;65&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://apps.apple.com/app/id1625641322&#34;&gt;&lt;img src=&#34;https://cdn.sparrowcode.io/github/apps-using/id1625641322.png?version=2&#34; height=&#34;65&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://apps.apple.com/app/id1625641322&#34;&gt;&lt;img src=&#34;https://cdn.sparrowcode.io/github/apps-using/id6449774982.png?version=2&#34; height=&#34;65&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://apps.apple.com/app/id875280793&#34;&gt;&lt;img src=&#34;https://cdn.sparrowcode.io/github/apps-using/id875280793.png?version=2&#34; height=&#34;65&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://apps.apple.com/app/id743843090&#34;&gt;&lt;img src=&#34;https://cdn.sparrowcode.io/github/apps-using/id743843090.png?version=2&#34; height=&#34;65&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://apps.apple.com/app/id537070378&#34;&gt;&lt;img src=&#34;https://cdn.sparrowcode.io/github/apps-using/id537070378.png?version=2&#34; height=&#34;65&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://apps.apple.com/app/id1617055933&#34;&gt;&lt;img src=&#34;https://cdn.sparrowcode.io/github/apps-using/id1617055933.png?version=2&#34; height=&#34;65&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://apps.apple.com/app/id1668579869&#34;&gt;&lt;img src=&#34;https://cdn.sparrowcode.io/github/apps-using/id1668579869.png?version=1&#34; height=&#34;65&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;If you use a &lt;code&gt;AlertKit&lt;/code&gt;, add your app via Pull Request.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Quick/Nimble</title>
    <updated>2023-11-05T02:02:56Z</updated>
    <id>tag:github.com,2023-11-05:/Quick/Nimble</id>
    <link href="https://github.com/Quick/Nimble" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Matcher Framework for Swift and Objective-C&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Nimble&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Quick/Nimble/actions/workflows/ci-xcode.yml&#34;&gt;&lt;img src=&#34;https://github.com/Quick/Nimble/actions/workflows/ci-xcode.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/Nimble&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/Nimble.svg?sanitize=true&#34; alt=&#34;CocoaPods&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/Nimble&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/Nimble.svg?sanitize=true&#34; alt=&#34;Platforms&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Use Nimble to express the expected outcomes of Swift or Objective-C expressions. Inspired by &lt;a href=&#34;https://github.com/pivotal/cedar&#34;&gt;Cedar&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;expect(1 + 1).to(equal(2))&#xA;expect(1.2).to(beCloseTo(1.1, within: 0.1))&#xA;expect(3) &amp;gt; 2&#xA;expect(&#34;seahorse&#34;).to(contain(&#34;sea&#34;))&#xA;expect([&#34;Atlantic&#34;, &#34;Pacific&#34;]).toNot(contain(&#34;Mississippi&#34;))&#xA;expect(ocean.isClean).toEventually(beTruthy())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;How to Use Nimble&lt;/h1&gt; &#xA;&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt; &lt;em&gt;generated with &lt;a href=&#34;https://github.com/thlorenz/doctoc&#34;&gt;DocToc&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#some-background-expressing-outcomes-using-assertions-in-xctest&#34;&gt;Some Background: Expressing Outcomes Using Assertions in XCTest&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#nimble-expectations-using-expectto&#34;&gt;Nimble: Expectations Using &lt;code&gt;expect(...).to&lt;/code&gt;&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#custom-failure-messages&#34;&gt;Custom Failure Messages&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#type-safety&#34;&gt;Type Safety&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#operator-overloads&#34;&gt;Operator Overloads&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#lazily-computed-values&#34;&gt;Lazily Computed Values&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#c-primitives&#34;&gt;C Primitives&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#asyncawait-support&#34;&gt;Async/Await in Expectations&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#polling-expectations&#34;&gt;Polling Expectations&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#objective-c-support&#34;&gt;Objective-C Support&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#disabling-objective-c-shorthand&#34;&gt;Disabling Objective-C Shorthand&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#built-in-matcher-functions&#34;&gt;Built-in Matcher Functions&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#type-checking&#34;&gt;Type Checking&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#equivalence&#34;&gt;Equivalence&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#identity&#34;&gt;Identity&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#comparisons&#34;&gt;Comparisons&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#typesclasses&#34;&gt;Types/Classes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#truthiness&#34;&gt;Truthiness&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#swift-assertions&#34;&gt;Swift Assertions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#swift-error-handling&#34;&gt;Swift Error Handling&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#exceptions&#34;&gt;Exceptions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#collection-membership&#34;&gt;Collection Membership&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#strings&#34;&gt;Strings&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#collection-elements&#34;&gt;Collection Elements&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#collection-count&#34;&gt;Collection Count&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#notifications&#34;&gt;Notifications&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#result&#34;&gt;Result&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#matching-a-value-to-any-of-a-group-of-matchers&#34;&gt;Matching a value to any of a group of matchers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#custom-validation&#34;&gt;Custom Validation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#writing-your-own-matchers&#34;&gt;Writing Your Own Matchers&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#matcherresult&#34;&gt;MatcherResult&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#lazy-evaluation&#34;&gt;Lazy Evaluation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#type-checking-via-swift-generics&#34;&gt;Type Checking via Swift Generics&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#customizing-failure-messages&#34;&gt;Customizing Failure Messages&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#basic-customization&#34;&gt;Basic Customization&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#full-customization&#34;&gt;Full Customization&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#supporting-objective-c&#34;&gt;Supporting Objective-C&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#properly-handling-nil-in-objective-c-matchers&#34;&gt;Properly Handling &lt;code&gt;nil&lt;/code&gt; in Objective-C Matchers&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#migrating-from-the-old-matcher-api&#34;&gt;Migrating from the Old Matcher API&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#installing-nimble&#34;&gt;Installing Nimble&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#installing-nimble-as-a-submodule&#34;&gt;Installing Nimble as a Submodule&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#installing-nimble-via-cocoapods&#34;&gt;Installing Nimble via CocoaPods&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#using-nimble-without-xctest&#34;&gt;Using Nimble without XCTest&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;h1&gt;Some Background: Expressing Outcomes Using Assertions in XCTest&lt;/h1&gt; &#xA;&lt;p&gt;Apple&#39;s Xcode includes the XCTest framework, which provides assertion macros to test whether code behaves properly. For example, to assert that &lt;code&gt;1 + 1 = 2&lt;/code&gt;, XCTest has you write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;XCTAssertEqual(1 + 1, 2, &#34;expected one plus one to equal two&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, in Objective-C:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;XCTAssertEqual(1 + 1, 2, @&#34;expected one plus one to equal two&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;XCTest assertions have a couple of drawbacks:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Not enough macros.&lt;/strong&gt; There&#39;s no easy way to assert that a string contains a particular substring, or that a number is less than or equal to another.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;It&#39;s hard to write asynchronous tests.&lt;/strong&gt; XCTest forces you to write a lot of boilerplate code.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Nimble addresses these concerns.&lt;/p&gt; &#xA;&lt;h1&gt;Nimble: Expectations Using &lt;code&gt;expect(...).to&lt;/code&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Nimble allows you to express expectations using a natural, easily understood language:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;import Nimble&#xA;&#xA;expect(seagull.squawk).to(equal(&#34;Squee!&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;@import Nimble;&#xA;&#xA;expect(seagull.squawk).to(equal(@&#34;Squee!&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;expect&lt;/code&gt; function autocompletes to include &lt;code&gt;file:&lt;/code&gt; and &lt;code&gt;line:&lt;/code&gt;, but these parameters are optional. Use the default values to have Xcode highlight the correct line when an expectation is not met.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To perform the opposite expectation--to assert something is &lt;em&gt;not&lt;/em&gt; equal--use &lt;code&gt;toNot&lt;/code&gt; or &lt;code&gt;notTo&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;import Nimble&#xA;&#xA;expect(seagull.squawk).toNot(equal(&#34;Oh, hello there!&#34;))&#xA;expect(seagull.squawk).notTo(equal(&#34;Oh, hello there!&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;@import Nimble;&#xA;&#xA;expect(seagull.squawk).toNot(equal(@&#34;Oh, hello there!&#34;));&#xA;expect(seagull.squawk).notTo(equal(@&#34;Oh, hello there!&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom Failure Messages&lt;/h2&gt; &#xA;&lt;p&gt;Would you like to add more information to the test&#39;s failure messages? Use the &lt;code&gt;description&lt;/code&gt; optional argument to add your own text:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(1 + 1).to(equal(3))&#xA;// failed - expected to equal &amp;lt;3&amp;gt;, got &amp;lt;2&amp;gt;&#xA;&#xA;expect(1 + 1).to(equal(3), description: &#34;Make sure libKindergartenMath is loaded&#34;)&#xA;// failed - Make sure libKindergartenMath is loaded&#xA;// expected to equal &amp;lt;3&amp;gt;, got &amp;lt;2&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or the *WithDescription version in Objective-C:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;@import Nimble;&#xA;&#xA;expect(@(1+1)).to(equal(@3));&#xA;// failed - expected to equal &amp;lt;3.0000&amp;gt;, got &amp;lt;2.0000&amp;gt;&#xA;&#xA;expect(@(1+1)).toWithDescription(equal(@3), @&#34;Make sure libKindergartenMath is loaded&#34;);&#xA;// failed - Make sure libKindergartenMath is loaded&#xA;// expected to equal &amp;lt;3.0000&amp;gt;, got &amp;lt;2.0000&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Type Safety&lt;/h2&gt; &#xA;&lt;p&gt;Nimble makes sure you don&#39;t compare two types that don&#39;t match:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Does not compile:&#xA;expect(1 + 1).to(equal(&#34;Squee!&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Nimble uses generics--only available in Swift--to ensure type correctness. That means type checking is not available when using Nimble in Objective-C. &lt;span&gt;ðŸ˜­&lt;/span&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Operator Overloads&lt;/h2&gt; &#xA;&lt;p&gt;Tired of so much typing? With Nimble, you can use overloaded operators like &lt;code&gt;==&lt;/code&gt; for equivalence, or &lt;code&gt;&amp;gt;&lt;/code&gt; for comparisons:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if squawk does not equal &#34;Hi!&#34;:&#xA;expect(seagull.squawk) != &#34;Hi!&#34;&#xA;&#xA;// Passes if 10 is greater than 2:&#xA;expect(10) &amp;gt; 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Operator overloads are only available in Swift, so you won&#39;t be able to use this syntax in Objective-C. &lt;span&gt;ðŸ’”&lt;/span&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Lazily Computed Values&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;expect&lt;/code&gt; function doesn&#39;t evaluate the value it&#39;s given until it&#39;s time to match. So Nimble can test whether an expression raises an exception once evaluated:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Note: Swift currently doesn&#39;t have exceptions.&#xA;//       Only Objective-C code can raise exceptions&#xA;//       that Nimble will catch.&#xA;//       (see https://github.com/Quick/Nimble/issues/220#issuecomment-172667064)&#xA;let exception = NSException(&#xA;    name: NSInternalInconsistencyException,&#xA;    reason: &#34;Not enough fish in the sea.&#34;,&#xA;    userInfo: [&#34;something&#34;: &#34;is fishy&#34;])&#xA;expect { exception.raise() }.to(raiseException())&#xA;&#xA;// Also, you can customize raiseException to be more specific&#xA;expect { exception.raise() }.to(raiseException(named: NSInternalInconsistencyException))&#xA;expect { exception.raise() }.to(raiseException(&#xA;    named: NSInternalInconsistencyException,&#xA;    reason: &#34;Not enough fish in the sea&#34;))&#xA;expect { exception.raise() }.to(raiseException(&#xA;    named: NSInternalInconsistencyException,&#xA;    reason: &#34;Not enough fish in the sea&#34;,&#xA;    userInfo: [&#34;something&#34;: &#34;is fishy&#34;]))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Objective-C works the same way, but you must use the &lt;code&gt;expectAction&lt;/code&gt; macro when making an expectation on an expression that has no return value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;NSException *exception = [NSException exceptionWithName:NSInternalInconsistencyException&#xA;                                                 reason:@&#34;Not enough fish in the sea.&#34;&#xA;                                               userInfo:nil];&#xA;expectAction(^{ [exception raise]; }).to(raiseException());&#xA;&#xA;// Use the property-block syntax to be more specific.&#xA;expectAction(^{ [exception raise]; }).to(raiseException().named(NSInternalInconsistencyException));&#xA;expectAction(^{ [exception raise]; }).to(raiseException().&#xA;    named(NSInternalInconsistencyException).&#xA;    reason(&#34;Not enough fish in the sea&#34;));&#xA;expectAction(^{ [exception raise]; }).to(raiseException().&#xA;    named(NSInternalInconsistencyException).&#xA;    reason(&#34;Not enough fish in the sea&#34;).&#xA;    userInfo(@{@&#34;something&#34;: @&#34;is fishy&#34;}));&#xA;&#xA;// You can also pass a block for custom matching of the raised exception&#xA;expectAction(exception.raise()).to(raiseException().satisfyingBlock(^(NSException *exception) {&#xA;    expect(exception.name).to(beginWith(NSInternalInconsistencyException));&#xA;}));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;C Primitives&lt;/h2&gt; &#xA;&lt;p&gt;Some testing frameworks make it hard to test primitive C values. In Nimble, it just works:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;let actual: CInt = 1&#xA;let expectedValue: CInt = 1&#xA;expect(actual).to(equal(expectedValue))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In fact, Nimble uses type inference, so you can write the above without explicitly specifying both types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(1 as CInt).to(equal(1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;In Objective-C, Nimble only supports Objective-C objects. To make expectations on primitive C values, wrap then in an object literal:&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;expect(@(1 + 1)).to(equal(@2));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Async/Await Support&lt;/h2&gt; &#xA;&lt;p&gt;Nimble makes it easy to await for an async function to complete. Simply pass the async function in to &lt;code&gt;expect&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;await expect { await aFunctionReturning1() }.to(equal(1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The async function is awaited on first, before passing it to the matcher. This enables the matcher to run synchronous code like before, without caring about whether the value it&#39;s processing was abtained async or not.&lt;/p&gt; &#xA;&lt;p&gt;Async support is Swift-only, and it requires that you execute the test in an async context. For XCTest, this is as simple as marking your test function with &lt;code&gt;async&lt;/code&gt;. If you use Quick, all tests in Quick 6 are executed in an async context. In Quick 7 and later, only tests that are in an &lt;code&gt;AsyncSpec&lt;/code&gt; subclass will be executed in an async context.&lt;/p&gt; &#xA;&lt;p&gt;To avoid a compiler errors when using synchronous &lt;code&gt;expect&lt;/code&gt; in asynchronous contexts, &lt;code&gt;expect&lt;/code&gt; with async expressions does not support autoclosures. However, the &lt;code&gt;expecta&lt;/code&gt; (expect async) function is provided as an alternative, which does support autoclosures.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;await expecta(await aFunctionReturning1()).to(equal(1)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, if you&#39;re ever in a situation where you want to force the compiler to produce a &lt;code&gt;SyncExpectation&lt;/code&gt;, you can use the &lt;code&gt;expects&lt;/code&gt; (expect sync) function to produce a &lt;code&gt;SyncExpectation&lt;/code&gt;. Like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;expects(someNonAsyncFunction()).to(equal(1)))&#xA;&#xA;expects(await someAsyncFunction()).to(equal(1)) // Compiler error: &#39;async&#39; call in an autoclosure that does not support concurrency&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Async Matchers&lt;/h3&gt; &#xA;&lt;p&gt;In addition to asserting on async functions prior to passing them to a synchronous matcher, you can also write matchers that directly take in an async value. These are called &lt;code&gt;AsyncMatcher&lt;/code&gt;s. This is most obviously useful when directly asserting against an actor. In addition to writing your own async matchers, Nimble currently ships with async versions of the following matchers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;allPass&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;containElementSatisfying&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;satisfyAllOf&lt;/code&gt; and the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator overload accept both &lt;code&gt;AsyncMatcher&lt;/code&gt; and synchronous &lt;code&gt;Matcher&lt;/code&gt;s.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;satisfyAnyOf&lt;/code&gt; and the &lt;code&gt;||&lt;/code&gt; operator overload accept both &lt;code&gt;AsyncMatcher&lt;/code&gt; and synchronous &lt;code&gt;Matcher&lt;/code&gt;s.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note: Async/Await support is different than the &lt;code&gt;toEventually&lt;/code&gt;/&lt;code&gt;toEventuallyNot&lt;/code&gt; feature described below.&lt;/p&gt; &#xA;&lt;h2&gt;Polling Expectations&lt;/h2&gt; &#xA;&lt;p&gt;In Nimble, it&#39;s easy to make expectations on values that are updated asynchronously. Just use &lt;code&gt;toEventually&lt;/code&gt; or &lt;code&gt;toEventuallyNot&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;DispatchQueue.main.async {&#xA;    ocean.add(&#34;dolphins&#34;)&#xA;    ocean.add(&#34;whales&#34;)&#xA;}&#xA;expect(ocean).toEventually(contain(&#34;dolphins&#34;, &#34;whales&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;dispatch_async(dispatch_get_main_queue(), ^{&#xA;    [ocean add:@&#34;dolphins&#34;];&#xA;    [ocean add:@&#34;whales&#34;];&#xA;});&#xA;expect(ocean).toEventually(contain(@&#34;dolphins&#34;, @&#34;whales&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: toEventually triggers its polls on the main thread. Blocking the main thread will cause Nimble to stop the run loop. This can cause test pollution for whatever incomplete code that was running on the main thread. Blocking the main thread can be caused by blocking IO, calls to sleep(), deadlocks, and synchronous IPC.&lt;/p&gt; &#xA;&lt;p&gt;In the above example, &lt;code&gt;ocean&lt;/code&gt; is constantly re-evaluated. If it ever contains dolphins and whales, the expectation passes. If &lt;code&gt;ocean&lt;/code&gt; still doesn&#39;t contain them, even after being continuously re-evaluated for one whole second, the expectation fails.&lt;/p&gt; &#xA;&lt;h3&gt;Using Polling Expectations in Async Tests&lt;/h3&gt; &#xA;&lt;p&gt;You can easily use &lt;code&gt;toEventually&lt;/code&gt; or &lt;code&gt;toEventuallyNot&lt;/code&gt; in async contexts as well. You only need to add an &lt;code&gt;await&lt;/code&gt; statement to the beginning of the line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;DispatchQueue.main.async {&#xA;    ocean.add(&#34;dolphins&#34;)&#xA;    ocean.add(&#34;whales&#34;)&#xA;}&#xA;await expect(ocean).toEventually(contain(&#34;dolphens&#34;, &#34;whiles&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Starting in Nimble 12, &lt;code&gt;toEventually&lt;/code&gt; et. al. now also supports async expectations. For example, the following test is now supported:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;actor MyActor {&#xA;    private var counter = 0&#xA;&#xA;    func access() -&amp;gt; Int {&#xA;        counter += 1&#xA;        return counter&#xA;    }&#xA;}&#xA;&#xA;let subject = MyActor()&#xA;await expect { await subject.access() }.toEventually(equal(2))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Verifying a Matcher will Never or Always Match&lt;/h3&gt; &#xA;&lt;p&gt;You can also test that a value always or never matches throughout the length of the timeout. Use &lt;code&gt;toNever&lt;/code&gt; and &lt;code&gt;toAlways&lt;/code&gt; for this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;ocean.add(&#34;dolphins&#34;)&#xA;expect(ocean).toAlways(contain(&#34;dolphins&#34;))&#xA;expect(ocean).toNever(contain(&#34;hares&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;[ocean add:@&#34;dolphins&#34;]&#xA;expect(ocean).toAlways(contain(@&#34;dolphins&#34;))&#xA;expect(ocean).toNever(contain(@&#34;hares&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Waiting for a Callback to be Called&lt;/h3&gt; &#xA;&lt;p&gt;You can also provide a callback by using the &lt;code&gt;waitUntil&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;waitUntil { done in&#xA;    ocean.goFish { success in&#xA;        expect(success).to(beTrue())&#xA;        done()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;waitUntil(^(void (^done)(void)){&#xA;    [ocean goFishWithHandler:^(BOOL success){&#xA;        expect(success).to(beTrue());&#xA;        done();&#xA;    }];&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;waitUntil&lt;/code&gt; also optionally takes a timeout parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;waitUntil(timeout: .seconds(10)) { done in&#xA;    ocean.goFish { success in&#xA;        expect(success).to(beTrue())&#xA;        done()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;waitUntilTimeout(10, ^(void (^done)(void)){&#xA;    [ocean goFishWithHandler:^(BOOL success){&#xA;        expect(success).to(beTrue());&#xA;        done();&#xA;    }];&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: &lt;code&gt;waitUntil&lt;/code&gt; triggers its timeout code on the main thread. Blocking the main thread will cause Nimble to stop the run loop to continue. This can cause test pollution for whatever incomplete code that was running on the main thread. Blocking the main thread can be caused by blocking IO, calls to sleep(), deadlocks, and synchronous IPC.&lt;/p&gt; &#xA;&lt;h3&gt;Changing the Timeout and Polling Intervals&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes it takes more than a second for a value to update. In those cases, use the &lt;code&gt;timeout&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Waits three seconds for ocean to contain &#34;starfish&#34;:&#xA;expect(ocean).toEventually(contain(&#34;starfish&#34;), timeout: .seconds(3))&#xA;&#xA;// Evaluate someValue every 0.2 seconds repeatedly until it equals 100, or fails if it timeouts after 5.5 seconds.&#xA;expect(someValue).toEventually(equal(100), timeout: .milliseconds(5500), pollInterval: .milliseconds(200))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Waits three seconds for ocean to contain &#34;starfish&#34;:&#xA;expect(ocean).withTimeout(3).toEventually(contain(@&#34;starfish&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Changing default Timeout and Poll Intervals&lt;/h3&gt; &#xA;&lt;p&gt;In some cases (e.g. when running on slower machines) it can be useful to modify the default timeout and poll interval values. This can be done as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Increase the global timeout to 5 seconds:&#xA;Nimble.PollingDefaults.timeout = .seconds(5)&#xA;&#xA;// Slow the polling interval to 0.1 seconds:&#xA;Nimble.PollingDefaults.pollInterval = .milliseconds(100)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can set these globally at test startup in two ways:&lt;/p&gt; &#xA;&lt;h4&gt;Quick&lt;/h4&gt; &#xA;&lt;p&gt;If you use &lt;a href=&#34;https://github.com/Quick/Quick&#34;&gt;Quick&lt;/a&gt;, add a &lt;a href=&#34;https://github.com/Quick/Quick/raw/main/Documentation/en-us/ConfiguringQuick.md&#34;&gt;&lt;code&gt;QuickConfiguration&lt;/code&gt; subclass&lt;/a&gt; which sets your desired &lt;code&gt;PollingDefaults&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Quick&#xA;import Nimble&#xA;&#xA;class PollingConfiguration: QuickConfiguration {&#xA;    override class func configure(_ configuration: QCKConfiguration) {&#xA;        Nimble.PollingDefaults.timeout = .seconds(5)&#xA;        Nimble.PollingDefaults.pollInterval = .milliseconds(100)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;XCTest&lt;/h4&gt; &#xA;&lt;p&gt;If you use &lt;a href=&#34;https://developer.apple.com/documentation/xctest&#34;&gt;XCTest&lt;/a&gt;, add an object that conforms to &lt;a href=&#34;https://developer.apple.com/documentation/xctest/xctestobservation&#34;&gt;&lt;code&gt;XCTestObservation&lt;/code&gt;&lt;/a&gt; and implement &lt;a href=&#34;https://developer.apple.com/documentation/xctest/xctestobservation/1500772-testbundlewillstart&#34;&gt;&lt;code&gt;testBundleWillStart(_:)&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, you will need to register this observer with the &lt;a href=&#34;https://developer.apple.com/documentation/xctest/xctestobservationcenter&#34;&gt;&lt;code&gt;XCTestObservationCenter&lt;/code&gt;&lt;/a&gt; at test startup. To do this, set the &lt;code&gt;NSPrincipalClass&lt;/code&gt; key in your test bundle&#39;s Info.plist and implement a class with that same name.&lt;/p&gt; &#xA;&lt;p&gt;For example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- Info.plist --&amp;gt;&#xA;&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&amp;gt;&#xA;&amp;lt;!DOCTYPE plist PUBLIC &#34;-//Apple//DTD PLIST 1.0//EN&#34; &#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&#34;&amp;gt;&#xA;&amp;lt;plist version=&#34;1.0&#34;&amp;gt;&#xA;&amp;lt;dict&amp;gt;&#xA;    &amp;lt;!-- ... --&amp;gt;&#xA;&#x9;&amp;lt;key&amp;gt;NSPrincipalClass&amp;lt;/key&amp;gt;&#xA;&#x9;&amp;lt;string&amp;gt;MyTests.TestSetup&amp;lt;/string&amp;gt;&#xA;&amp;lt;/dict&amp;gt;&#xA;&amp;lt;/plist&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// TestSetup.swift&#xA;import XCTest&#xA;import Nimble&#xA;&#xA;@objc&#xA;class TestSetup: NSObject {&#xA;&#x9;override init() {&#xA;&#x9;&#x9;XCTestObservationCenter.shared.register(PollingConfigurationTestObserver())&#xA;&#x9;}&#xA;}&#xA;&#xA;class PollingConfigurationTestObserver: NSObject, XCTestObserver {&#xA;    func testBundleWillStart(_ testBundle: Bundle) {&#xA;        Nimble.PollingDefaults.timeout = .seconds(5)&#xA;        Nimble.PollingDefaults.pollInterval = .milliseconds(100)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In Linux, you can implement &lt;code&gt;LinuxMain&lt;/code&gt; to set the PollingDefaults before calling &lt;code&gt;XCTMain&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Objective-C Support&lt;/h2&gt; &#xA;&lt;p&gt;Nimble has full support for Objective-C. However, there are two things to keep in mind when using Nimble in Objective-C:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;All parameters passed to the &lt;code&gt;expect&lt;/code&gt; function, as well as matcher functions like &lt;code&gt;equal&lt;/code&gt;, must be Objective-C objects or can be converted into an &lt;code&gt;NSObject&lt;/code&gt; equivalent:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;@import Nimble;&#xA;&#xA;expect(@(1 + 1)).to(equal(@2));&#xA;expect(@&#34;Hello world&#34;).to(contain(@&#34;world&#34;));&#xA;&#xA;// Boxed as NSNumber *&#xA;expect(2).to(equal(2));&#xA;expect(1.2).to(beLessThan(2.0));&#xA;expect(true).to(beTruthy());&#xA;&#xA;// Boxed as NSString *&#xA;expect(&#34;Hello world&#34;).to(equal(&#34;Hello world&#34;));&#xA;&#xA;// Boxed as NSRange&#xA;expect(NSMakeRange(1, 10)).to(equal(NSMakeRange(1, 10)));&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To make an expectation on an expression that does not return a value, such as &lt;code&gt;-[NSException raise]&lt;/code&gt;, use &lt;code&gt;expectAction&lt;/code&gt; instead of &lt;code&gt;expect&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expectAction(^{ [exception raise]; }).to(raiseException());&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The following types are currently converted to an &lt;code&gt;NSObject&lt;/code&gt; type:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;C Numeric types&lt;/strong&gt; are converted to &lt;code&gt;NSNumber *&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NSRange&lt;/code&gt; is converted to &lt;code&gt;NSValue *&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;char *&lt;/code&gt; is converted to &lt;code&gt;NSString *&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For the following matchers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beGreaterThan&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beGreaterThanOrEqual&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beLessThan&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beLessThanOrEqual&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beCloseTo&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beTrue&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beFalse&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beTruthy&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beFalsy&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;haveCount&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you would like to see more, &lt;a href=&#34;https://github.com/Quick/Nimble/issues&#34;&gt;file an issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Disabling Objective-C Shorthand&lt;/h2&gt; &#xA;&lt;p&gt;Nimble provides a shorthand for expressing expectations using the &lt;code&gt;expect&lt;/code&gt; function. To disable this shorthand in Objective-C, define the &lt;code&gt;NIMBLE_DISABLE_SHORT_SYNTAX&lt;/code&gt; macro somewhere in your code before importing Nimble:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#define NIMBLE_DISABLE_SHORT_SYNTAX 1&#xA;&#xA;@import Nimble;&#xA;&#xA;NMB_expect(^{ return seagull.squawk; }, __FILE__, __LINE__).to(NMB_equal(@&#34;Squee!&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Disabling the shorthand is useful if you&#39;re testing functions with names that conflict with Nimble functions, such as &lt;code&gt;expect&lt;/code&gt; or &lt;code&gt;equal&lt;/code&gt;. If that&#39;s not the case, there&#39;s no point in disabling the shorthand.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Built-in Matcher Functions&lt;/h1&gt; &#xA;&lt;p&gt;Nimble includes a wide variety of matcher functions.&lt;/p&gt; &#xA;&lt;h2&gt;Type Checking&lt;/h2&gt; &#xA;&lt;p&gt;Nimble supports checking the type membership of any kind of object, whether Objective-C conformant or not:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;protocol SomeProtocol{}&#xA;class SomeClassConformingToProtocol: SomeProtocol{}&#xA;struct SomeStructConformingToProtocol: SomeProtocol{}&#xA;&#xA;// The following tests pass&#xA;expect(1).to(beAKindOf(Int.self))&#xA;expect(&#34;turtle&#34;).to(beAKindOf(String.self))&#xA;&#xA;let classObject = SomeClassConformingToProtocol()&#xA;expect(classObject).to(beAKindOf(SomeProtocol.self))&#xA;expect(classObject).to(beAKindOf(SomeClassConformingToProtocol.self))&#xA;expect(classObject).toNot(beAKindOf(SomeStructConformingToProtocol.self))&#xA;&#xA;let structObject = SomeStructConformingToProtocol()&#xA;expect(structObject).to(beAKindOf(SomeProtocol.self))&#xA;expect(structObject).to(beAKindOf(SomeStructConformingToProtocol.self))&#xA;expect(structObject).toNot(beAKindOf(SomeClassConformingToProtocol.self))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// The following tests pass&#xA;NSMutableArray *array = [NSMutableArray array];&#xA;expect(array).to(beAKindOf([NSArray class]));&#xA;expect(@1).toNot(beAKindOf([NSNull class]));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Objects can be tested for their exact types using the &lt;code&gt;beAnInstanceOf&lt;/code&gt; matcher:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;protocol SomeProtocol{}&#xA;class SomeClassConformingToProtocol: SomeProtocol{}&#xA;struct SomeStructConformingToProtocol: SomeProtocol{}&#xA;&#xA;// Unlike the &#39;beKindOf&#39; matcher, the &#39;beAnInstanceOf&#39; matcher only&#xA;// passes if the object is the EXACT type requested. The following&#xA;// tests pass -- note its behavior when working in an inheritance hierarchy.&#xA;expect(1).to(beAnInstanceOf(Int.self))&#xA;expect(&#34;turtle&#34;).to(beAnInstanceOf(String.self))&#xA;&#xA;let classObject = SomeClassConformingToProtocol()&#xA;expect(classObject).toNot(beAnInstanceOf(SomeProtocol.self))&#xA;expect(classObject).to(beAnInstanceOf(SomeClassConformingToProtocol.self))&#xA;expect(classObject).toNot(beAnInstanceOf(SomeStructConformingToProtocol.self))&#xA;&#xA;let structObject = SomeStructConformingToProtocol()&#xA;expect(structObject).toNot(beAnInstanceOf(SomeProtocol.self))&#xA;expect(structObject).to(beAnInstanceOf(SomeStructConformingToProtocol.self))&#xA;expect(structObject).toNot(beAnInstanceOf(SomeClassConformingToProtocol.self))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Equivalence&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;actual&#39; is equivalent to &#39;expected&#39;:&#xA;expect(actual).to(equal(expected))&#xA;expect(actual) == expected&#xA;&#xA;// Passes if &#39;actual&#39; is not equivalent to &#39;expected&#39;:&#xA;expect(actual).toNot(equal(expected))&#xA;expect(actual) != expected&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;actual&#39; is equivalent to &#39;expected&#39;:&#xA;expect(actual).to(equal(expected))&#xA;&#xA;// Passes if &#39;actual&#39; is not equivalent to &#39;expected&#39;:&#xA;expect(actual).toNot(equal(expected))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Values must be &lt;code&gt;Equatable&lt;/code&gt;, &lt;code&gt;Comparable&lt;/code&gt;, or subclasses of &lt;code&gt;NSObject&lt;/code&gt;. &lt;code&gt;equal&lt;/code&gt; will always fail when used to compare one or more &lt;code&gt;nil&lt;/code&gt; values.&lt;/p&gt; &#xA;&lt;h2&gt;Identity&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;actual&#39; has the same pointer address as &#39;expected&#39;:&#xA;expect(actual).to(beIdenticalTo(expected))&#xA;expect(actual) === expected&#xA;&#xA;// Passes if &#39;actual&#39; does not have the same pointer address as &#39;expected&#39;:&#xA;expect(actual).toNot(beIdenticalTo(expected))&#xA;expect(actual) !== expected&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is important to remember that &lt;code&gt;beIdenticalTo&lt;/code&gt; only makes sense when comparing types with reference semantics, which have a notion of identity. In Swift, that means types that are defined as a &lt;code&gt;class&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This matcher will not work when comparing types with value semantics such as those defined as a &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt;. If you need to compare two value types, consider what it means for instances of your type to be identical. This may mean comparing individual properties or, if it makes sense to do so, conforming your type to &lt;code&gt;Equatable&lt;/code&gt; and using Nimble&#39;s equivalence matchers instead.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;actual&#39; has the same pointer address as &#39;expected&#39;:&#xA;expect(actual).to(beIdenticalTo(expected));&#xA;&#xA;// Passes if &#39;actual&#39; does not have the same pointer address as &#39;expected&#39;:&#xA;expect(actual).toNot(beIdenticalTo(expected));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Comparisons&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(actual).to(beLessThan(expected))&#xA;expect(actual) &amp;lt; expected&#xA;&#xA;expect(actual).to(beLessThanOrEqualTo(expected))&#xA;expect(actual) &amp;lt;= expected&#xA;&#xA;expect(actual).to(beGreaterThan(expected))&#xA;expect(actual) &amp;gt; expected&#xA;&#xA;expect(actual).to(beGreaterThanOrEqualTo(expected))&#xA;expect(actual) &amp;gt;= expected&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(actual).to(beLessThan(expected));&#xA;expect(actual).to(beLessThanOrEqualTo(expected));&#xA;expect(actual).to(beGreaterThan(expected));&#xA;expect(actual).to(beGreaterThanOrEqualTo(expected));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Values given to the comparison matchers above must implement &lt;code&gt;Comparable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Because of how computers represent floating point numbers, assertions that two floating point numbers be equal will sometimes fail. To express that two numbers should be close to one another within a certain margin of error, use &lt;code&gt;beCloseTo&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(actual).to(beCloseTo(expected, within: delta))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(actual).to(beCloseTo(expected).within(delta));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example, to assert that &lt;code&gt;10.01&lt;/code&gt; is close to &lt;code&gt;10&lt;/code&gt;, you can write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(10.01).to(beCloseTo(10, within: 0.1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(@(10.01)).to(beCloseTo(@10).within(0.1));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is also an operator shortcut available in Swift:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(actual) â‰ˆ expected&#xA;expect(actual) â‰ˆ (expected, delta)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Type &lt;kbd&gt;option&lt;/kbd&gt;+&lt;kbd&gt;x&lt;/kbd&gt; to get &lt;code&gt;â‰ˆ&lt;/code&gt; on a U.S. keyboard)&lt;/p&gt; &#xA;&lt;p&gt;The former version uses the default delta of 0.0001. Here is yet another way to do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(actual) â‰ˆ expected Â± delta&#xA;expect(actual) == expected Â± delta&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Type &lt;kbd&gt;option&lt;/kbd&gt;+&lt;kbd&gt;shift&lt;/kbd&gt;+&lt;kbd&gt;=&lt;/kbd&gt; to get &lt;code&gt;Â±&lt;/code&gt; on a U.S. keyboard)&lt;/p&gt; &#xA;&lt;p&gt;If you are comparing arrays of floating point numbers, you&#39;ll find the following useful:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect([0.0, 2.0]) â‰ˆ [0.0001, 2.0001]&#xA;expect([0.0, 2.0]).to(beCloseTo([0.1, 2.1], within: 0.1))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Values given to the &lt;code&gt;beCloseTo&lt;/code&gt; matcher must conform to &lt;code&gt;FloatingPoint&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Types/Classes&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;instance&#39; is an instance of &#39;aClass&#39;:&#xA;expect(instance).to(beAnInstanceOf(aClass))&#xA;&#xA;// Passes if &#39;instance&#39; is an instance of &#39;aClass&#39; or any of its subclasses:&#xA;expect(instance).to(beAKindOf(aClass))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;instance&#39; is an instance of &#39;aClass&#39;:&#xA;expect(instance).to(beAnInstanceOf(aClass));&#xA;&#xA;// Passes if &#39;instance&#39; is an instance of &#39;aClass&#39; or any of its subclasses:&#xA;expect(instance).to(beAKindOf(aClass));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Instances must be Objective-C objects: subclasses of &lt;code&gt;NSObject&lt;/code&gt;, or Swift objects bridged to Objective-C with the &lt;code&gt;@objc&lt;/code&gt; prefix.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;For example, to assert that &lt;code&gt;dolphin&lt;/code&gt; is a kind of &lt;code&gt;Mammal&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(dolphin).to(beAKindOf(Mammal))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(dolphin).to(beAKindOf([Mammal class]));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;beAnInstanceOf&lt;/code&gt; uses the &lt;code&gt;-[NSObject isMemberOfClass:]&lt;/code&gt; method to test membership. &lt;code&gt;beAKindOf&lt;/code&gt; uses &lt;code&gt;-[NSObject isKindOfClass:]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Truthiness&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Passes if &#39;actual&#39; is not nil, true, or an object with a boolean value of true:&#xA;expect(actual).to(beTruthy())&#xA;&#xA;// Passes if &#39;actual&#39; is only true (not nil or an object conforming to Boolean true):&#xA;expect(actual).to(beTrue())&#xA;&#xA;// Passes if &#39;actual&#39; is nil, false, or an object with a boolean value of false:&#xA;expect(actual).to(beFalsy())&#xA;&#xA;// Passes if &#39;actual&#39; is only false (not nil or an object conforming to Boolean false):&#xA;expect(actual).to(beFalse())&#xA;&#xA;// Passes if &#39;actual&#39; is nil:&#xA;expect(actual).to(beNil())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;actual&#39; is not nil, true, or an object with a boolean value of true:&#xA;expect(actual).to(beTruthy());&#xA;&#xA;// Passes if &#39;actual&#39; is only true (not nil or an object conforming to Boolean true):&#xA;expect(actual).to(beTrue());&#xA;&#xA;// Passes if &#39;actual&#39; is nil, false, or an object with a boolean value of false:&#xA;expect(actual).to(beFalsy());&#xA;&#xA;// Passes if &#39;actual&#39; is only false (not nil or an object conforming to Boolean false):&#xA;expect(actual).to(beFalse());&#xA;&#xA;// Passes if &#39;actual&#39; is nil:&#xA;expect(actual).to(beNil());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Swift Assertions&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re using Swift, you can use the &lt;code&gt;throwAssertion&lt;/code&gt; matcher to check if an assertion is thrown (e.g. &lt;code&gt;fatalError()&lt;/code&gt;). This is made possible by &lt;a href=&#34;https://github.com/mattgallagher&#34;&gt;@mattgallagher&lt;/a&gt;&#39;s &lt;a href=&#34;https://github.com/mattgallagher/CwlPreconditionTesting&#34;&gt;CwlPreconditionTesting&lt;/a&gt; library.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;somethingThatThrows()&#39; throws an assertion, &#xA;// such as by calling &#39;fatalError()&#39; or if a precondition fails:&#xA;expect { try somethingThatThrows() }.to(throwAssertion())&#xA;expect { () -&amp;gt; Void in fatalError() }.to(throwAssertion())&#xA;expect { precondition(false) }.to(throwAssertion())&#xA;&#xA;// Passes if throwing an NSError is not equal to throwing an assertion:&#xA;expect { throw NSError(domain: &#34;test&#34;, code: 0, userInfo: nil) }.toNot(throwAssertion())&#xA;&#xA;// Passes if the code after the precondition check is not run:&#xA;var reachedPoint1 = false&#xA;var reachedPoint2 = false&#xA;expect {&#xA;    reachedPoint1 = true&#xA;    precondition(false, &#34;condition message&#34;)&#xA;    reachedPoint2 = true&#xA;}.to(throwAssertion())&#xA;&#xA;expect(reachedPoint1) == true&#xA;expect(reachedPoint2) == false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This feature is only available in Swift.&lt;/li&gt; &#xA; &lt;li&gt;The tvOS simulator is supported, but using a different mechanism, requiring you to turn off the &lt;code&gt;Debug executable&lt;/code&gt; scheme setting for your tvOS scheme&#39;s Test configuration.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Swift Error Handling&lt;/h2&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;throwError&lt;/code&gt; matcher to check if an error is thrown.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;somethingThatThrows()&#39; throws an &#39;Error&#39;:&#xA;expect { try somethingThatThrows() }.to(throwError())&#xA;&#xA;// Passes if &#39;somethingThatThrows()&#39; throws an error within a particular domain:&#xA;expect { try somethingThatThrows() }.to(throwError { (error: Error) in&#xA;    expect(error._domain).to(equal(NSCocoaErrorDomain))&#xA;})&#xA;&#xA;// Passes if &#39;somethingThatThrows()&#39; throws a particular error enum case:&#xA;expect { try somethingThatThrows() }.to(throwError(NSCocoaError.PropertyListReadCorruptError))&#xA;&#xA;// Passes if &#39;somethingThatThrows()&#39; throws an error of a particular type:&#xA;expect { try somethingThatThrows() }.to(throwError(errorType: NimbleError.self))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When working directly with &lt;code&gt;Error&lt;/code&gt; values, using the &lt;code&gt;matchError&lt;/code&gt; matcher allows you to perform certain checks on the error itself without having to explicitly cast the error.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;matchError&lt;/code&gt; matcher allows you to check whether or not the error:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;is the same &lt;em&gt;type&lt;/em&gt; of error you are expecting.&lt;/li&gt; &#xA; &lt;li&gt;represents a particular error value that you are expecting.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This can be useful when using &lt;code&gt;Result&lt;/code&gt; or &lt;code&gt;Promise&lt;/code&gt; types, for example.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;let actual: Error = ...&#xA;&#xA;// Passes if &#39;actual&#39; represents any error value from the NimbleErrorEnum type:&#xA;expect(actual).to(matchError(NimbleErrorEnum.self))&#xA;&#xA;// Passes if &#39;actual&#39; represents the case &#39;timeout&#39; from the NimbleErrorEnum type:&#xA;expect(actual).to(matchError(NimbleErrorEnum.timeout))&#xA;&#xA;// Passes if &#39;actual&#39; contains an NSError equal to the one provided:&#xA;expect(actual).to(matchError(NSError(domain: &#34;err&#34;, code: 123, userInfo: nil)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: This feature is only available in Swift.&lt;/p&gt; &#xA;&lt;h2&gt;Exceptions&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;actual&#39;, when evaluated, raises an exception:&#xA;expect(actual).to(raiseException())&#xA;&#xA;// Passes if &#39;actual&#39; raises an exception with the given name:&#xA;expect(actual).to(raiseException(named: name))&#xA;&#xA;// Passes if &#39;actual&#39; raises an exception with the given name and reason:&#xA;expect(actual).to(raiseException(named: name, reason: reason))&#xA;&#xA;// Passes if &#39;actual&#39; raises an exception which passes expectations defined in the given closure:&#xA;// (in this case, if the exception&#39;s name begins with &#34;a r&#34;)&#xA;expect { exception.raise() }.to(raiseException { (exception: NSException) in&#xA;    expect(exception.name).to(beginWith(&#34;a r&#34;))&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;actual&#39;, when evaluated, raises an exception:&#xA;expect(actual).to(raiseException())&#xA;&#xA;// Passes if &#39;actual&#39; raises an exception with the given name&#xA;expect(actual).to(raiseException().named(name))&#xA;&#xA;// Passes if &#39;actual&#39; raises an exception with the given name and reason:&#xA;expect(actual).to(raiseException().named(name).reason(reason))&#xA;&#xA;// Passes if &#39;actual&#39; raises an exception and it passes expectations defined in the given block:&#xA;// (in this case, if name begins with &#34;a r&#34;)&#xA;expect(actual).to(raiseException().satisfyingBlock(^(NSException *exception) {&#xA;    expect(exception.name).to(beginWith(@&#34;a r&#34;));&#xA;}));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: Swift currently doesn&#39;t have exceptions (see &lt;a href=&#34;https://github.com/Quick/Nimble/issues/220#issuecomment-172667064&#34;&gt;#220&lt;/a&gt;). Only Objective-C code can raise exceptions that Nimble will catch.&lt;/p&gt; &#xA;&lt;h2&gt;Collection Membership&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if all of the expected values are members of &#39;actual&#39;:&#xA;expect(actual).to(contain(expected...))&#xA;&#xA;// Passes if &#39;actual&#39; is empty (i.e. it contains no elements):&#xA;expect(actual).to(beEmpty())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if expected is a member of &#39;actual&#39;:&#xA;expect(actual).to(contain(expected));&#xA;&#xA;// Passes if &#39;actual&#39; is empty (i.e. it contains no elements):&#xA;expect(actual).to(beEmpty());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;In Swift &lt;code&gt;contain&lt;/code&gt; takes any number of arguments. The expectation passes if all of them are members of the collection. In Objective-C, &lt;code&gt;contain&lt;/code&gt; only takes one argument &lt;a href=&#34;https://github.com/Quick/Nimble/issues/27&#34;&gt;for now&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;For example, to assert that a list of sea creature names contains &#34;dolphin&#34; and &#34;starfish&#34;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect([&#34;whale&#34;, &#34;dolphin&#34;, &#34;starfish&#34;]).to(contain(&#34;dolphin&#34;, &#34;starfish&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(@[@&#34;whale&#34;, @&#34;dolphin&#34;, @&#34;starfish&#34;]).to(contain(@&#34;dolphin&#34;));&#xA;expect(@[@&#34;whale&#34;, @&#34;dolphin&#34;, @&#34;starfish&#34;]).to(contain(@&#34;starfish&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;contain&lt;/code&gt; and &lt;code&gt;beEmpty&lt;/code&gt; expect collections to be instances of &lt;code&gt;NSArray&lt;/code&gt;, &lt;code&gt;NSSet&lt;/code&gt;, or a Swift collection composed of &lt;code&gt;Equatable&lt;/code&gt; elements.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To test whether a set of elements is present at the beginning or end of an ordered collection, use &lt;code&gt;beginWith&lt;/code&gt; and &lt;code&gt;endWith&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if the elements in expected appear at the beginning of &#39;actual&#39;:&#xA;expect(actual).to(beginWith(expected...))&#xA;&#xA;// Passes if the the elements in expected come at the end of &#39;actual&#39;:&#xA;expect(actual).to(endWith(expected...))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if the elements in expected appear at the beginning of &#39;actual&#39;:&#xA;expect(actual).to(beginWith(expected));&#xA;&#xA;// Passes if the the elements in expected come at the end of &#39;actual&#39;:&#xA;expect(actual).to(endWith(expected));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;beginWith&lt;/code&gt; and &lt;code&gt;endWith&lt;/code&gt; expect collections to be instances of &lt;code&gt;NSArray&lt;/code&gt;, or ordered Swift collections composed of &lt;code&gt;Equatable&lt;/code&gt; elements.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Like &lt;code&gt;contain&lt;/code&gt;, in Objective-C &lt;code&gt;beginWith&lt;/code&gt; and &lt;code&gt;endWith&lt;/code&gt; only support a single argument &lt;a href=&#34;https://github.com/Quick/Nimble/issues/27&#34;&gt;for now&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For code that returns collections of complex objects without a strict ordering, there is the &lt;code&gt;containElementSatisfying&lt;/code&gt; matcher:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;struct Turtle {&#xA;    let color: String&#xA;}&#xA;&#xA;let turtles: [Turtle] = functionThatReturnsSomeTurtlesInAnyOrder()&#xA;&#xA;// This set of matchers passes regardless of whether the array is &#xA;// [{color: &#34;blue&#34;}, {color: &#34;green&#34;}] or [{color: &#34;green&#34;}, {color: &#34;blue&#34;}]:&#xA;&#xA;expect(turtles).to(containElementSatisfying({ turtle in&#xA;    return turtle.color == &#34;green&#34;&#xA;}))&#xA;expect(turtles).to(containElementSatisfying({ turtle in&#xA;    return turtle.color == &#34;blue&#34;&#xA;}, &#34;that is a turtle with color &#39;blue&#39;&#34;))&#xA;&#xA;// The second matcher will incorporate the provided string in the error message&#xA;// should it fail&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: in Swift, &lt;code&gt;containElementSatisfying&lt;/code&gt; also has a variant that takes in an async function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;@interface Turtle : NSObject&#xA;@property (nonatomic, readonly, nonnull) NSString *color;&#xA;@end&#xA;&#xA;@implementation Turtle &#xA;@end&#xA;&#xA;NSArray&amp;lt;Turtle *&amp;gt; * __nonnull turtles = functionThatReturnsSomeTurtlesInAnyOrder();&#xA;&#xA;// This set of matchers passes regardless of whether the array is &#xA;// [{color: &#34;blue&#34;}, {color: &#34;green&#34;}] or [{color: &#34;green&#34;}, {color: &#34;blue&#34;}]:&#xA;&#xA;expect(turtles).to(containElementSatisfying(^BOOL(id __nonnull object) {&#xA;    return [[turtle color] isEqualToString:@&#34;green&#34;];&#xA;}));&#xA;expect(turtles).to(containElementSatisfying(^BOOL(id __nonnull object) {&#xA;    return [[turtle color] isEqualToString:@&#34;blue&#34;];&#xA;}));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For asserting on if the given &lt;code&gt;Comparable&lt;/code&gt; value is inside of a &lt;code&gt;Range&lt;/code&gt;, use the &lt;code&gt;beWithin&lt;/code&gt; matcher.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if 5 is within the range 1 through 10, inclusive&#xA;expect(5).to(beWithin(1...10))&#xA;&#xA;// Passes if 5 is not within the range 2 through 4.&#xA;expect(5).toNot(beWithin(2..&amp;lt;5))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Strings&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;actual&#39; contains &#39;substring&#39;:&#xA;expect(actual).to(contain(substring))&#xA;&#xA;// Passes if &#39;actual&#39; begins with &#39;prefix&#39;:&#xA;expect(actual).to(beginWith(prefix))&#xA;&#xA;// Passes if &#39;actual&#39; ends with &#39;suffix&#39;:&#xA;expect(actual).to(endWith(suffix))&#xA;&#xA;// Passes if &#39;actual&#39; represents the empty string, &#34;&#34;:&#xA;expect(actual).to(beEmpty())&#xA;&#xA;// Passes if &#39;actual&#39; matches the regular expression defined in &#39;expected&#39;:&#xA;expect(actual).to(match(expected))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;actual&#39; contains &#39;substring&#39;:&#xA;expect(actual).to(contain(expected));&#xA;&#xA;// Passes if &#39;actual&#39; begins with &#39;prefix&#39;:&#xA;expect(actual).to(beginWith(prefix));&#xA;&#xA;// Passes if &#39;actual&#39; ends with &#39;suffix&#39;:&#xA;expect(actual).to(endWith(suffix));&#xA;&#xA;// Passes if &#39;actual&#39; represents the empty string, &#34;&#34;:&#xA;expect(actual).to(beEmpty());&#xA;&#xA;// Passes if &#39;actual&#39; matches the regular expression defined in &#39;expected&#39;:&#xA;expect(actual).to(match(expected))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Collection Elements&lt;/h2&gt; &#xA;&lt;p&gt;Nimble provides a means to check that all elements of a collection pass a given expectation.&lt;/p&gt; &#xA;&lt;h3&gt;Swift&lt;/h3&gt; &#xA;&lt;p&gt;In Swift, the collection must be an instance of a type conforming to &lt;code&gt;Sequence&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Providing a custom function:&#xA;expect([1, 2, 3, 4]).to(allPass { $0 &amp;lt; 5 })&#xA;&#xA;// Composing the expectation with another matcher:&#xA;expect([1, 2, 3, 4]).to(allPass(beLessThan(5)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are also variants of &lt;code&gt;allPass&lt;/code&gt; that check against async matchers, and that take in async functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Providing a custom function:&#xA;expect([1, 2, 3, 4]).to(allPass { await asyncFunctionReturningBool($0) })&#xA;&#xA;// Composing the expectation with another matcher:&#xA;expect([1, 2, 3, 4]).to(allPass(someAsyncMatcher()))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Objective-C&lt;/h3&gt; &#xA;&lt;p&gt;In Objective-C, the collection must be an instance of a type which implements the &lt;code&gt;NSFastEnumeration&lt;/code&gt; protocol, and whose elements are instances of a type which subclasses &lt;code&gt;NSObject&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, unlike in Swift, there is no override to specify a custom matcher function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(@[@1, @2, @3, @4]).to(allPass(beLessThan(@5)));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Collection Count&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;actual&#39; contains the &#39;expected&#39; number of elements:&#xA;expect(actual).to(haveCount(expected))&#xA;&#xA;// Passes if &#39;actual&#39; does _not_ contain the &#39;expected&#39; number of elements:&#xA;expect(actual).notTo(haveCount(expected))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;actual&#39; contains the &#39;expected&#39; number of elements:&#xA;expect(actual).to(haveCount(expected))&#xA;&#xA;// Passes if &#39;actual&#39; does _not_ contain the &#39;expected&#39; number of elements:&#xA;expect(actual).notTo(haveCount(expected))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Swift, the actual value must be an instance of a type conforming to &lt;code&gt;Collection&lt;/code&gt;. For example, instances of &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Dictionary&lt;/code&gt;, or &lt;code&gt;Set&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For Objective-C, the actual value must be one of the following classes, or their subclasses:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;NSArray&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NSDictionary&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NSSet&lt;/code&gt;, or&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NSHashTable&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Notifications&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;let testNotification = Notification(name: Notification.Name(&#34;Foo&#34;), object: nil)&#xA;&#xA;// Passes if the closure in expect { ... } posts a notification to the default&#xA;// notification center.&#xA;expect {&#xA;    NotificationCenter.default.post(testNotification)&#xA;}.to(postNotifications(equal([testNotification])))&#xA;&#xA;// Passes if the closure in expect { ... } posts a notification to a given&#xA;// notification center&#xA;let notificationCenter = NotificationCenter()&#xA;expect {&#xA;    notificationCenter.post(testNotification)&#xA;}.to(postNotifications(equal([testNotification]), from: notificationCenter))&#xA;&#xA;// Passes if the closure in expect { ... } posts a notification with the provided names to a given&#xA;// notification center. Make sure to use this when running tests on Catalina, &#xA;// using DistributedNotificationCenter as there is currently no way &#xA;// of observing notifications without providing specific names.&#xA;let distributedNotificationCenter = DistributedNotificationCenter()&#xA;expect {&#xA;    distributedNotificationCenter.post(testNotification)&#xA;}.toEventually(postDistributedNotifications(equal([testNotification]),&#xA;                                  from: distributedNotificationCenter,&#xA;                                  names: [testNotification.name]))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;This matcher is only available in Swift.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Result&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;let aResult: Result&amp;lt;String, Error&amp;gt; = .success(&#34;Hooray&#34;) &#xA;&#xA;// passes if result is .success&#xA;expect(aResult).to(beSuccess()) &#xA;&#xA;// passes if result value is .success and validates Success value&#xA;expect(aResult).to(beSuccess { value in&#xA;    expect(value).to(equal(&#34;Hooray&#34;))&#xA;})&#xA;&#xA;&#xA;enum AnError: Error {&#xA;    case somethingHappened&#xA;}&#xA;let otherResult: Result&amp;lt;String, AnError&amp;gt; = .failure(.somethingHappened) &#xA;&#xA;// passes if result is .failure&#xA;expect(otherResult).to(beFailure()) &#xA;&#xA;// passes if result value is .failure and validates error&#xA;expect(otherResult).to(beFailure { error in&#xA;    expect(error).to(matchError(AnError.somethingHappened))&#xA;}) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;This matcher is only available in Swift.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Matching a value to any of a group of matchers&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// passes if actual is either less than 10 or greater than 20&#xA;expect(actual).to(satisfyAnyOf(beLessThan(10), beGreaterThan(20)))&#xA;&#xA;// can include any number of matchers -- the following will pass&#xA;// **be careful** -- too many matchers can be the sign of an unfocused test&#xA;expect(6).to(satisfyAnyOf(equal(2), equal(3), equal(4), equal(5), equal(6), equal(7)))&#xA;&#xA;// in Swift you also have the option to use the || operator to achieve a similar function&#xA;expect(82).to(beLessThan(50) || beGreaterThan(80))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: In swift, you can mix and match synchronous and asynchronous matchers using by &lt;code&gt;satisfyAnyOf&lt;/code&gt;/&lt;code&gt;||&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// passes if actual is either less than 10 or greater than 20&#xA;expect(actual).to(satisfyAnyOf(beLessThan(@10), beGreaterThan(@20)))&#xA;&#xA;// can include any number of matchers -- the following will pass&#xA;// **be careful** -- too many matchers can be the sign of an unfocused test&#xA;expect(@6).to(satisfyAnyOf(equal(@2), equal(@3), equal(@4), equal(@5), equal(@6), equal(@7)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: This matcher allows you to chain any number of matchers together. This provides flexibility, but if you find yourself chaining many matchers together in one test, consider whether you could instead refactor that single test into multiple, more precisely focused tests for better coverage.&lt;/p&gt; &#xA;&lt;h2&gt;Custom Validation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// passes if .succeeded is returned from the closure&#xA;expect {&#xA;    guard case .enumCaseWithAssociatedValueThatIDontCareAbout = actual else {&#xA;        return .failed(reason: &#34;wrong enum case&#34;)&#xA;    }&#xA;&#xA;    return .succeeded&#xA;}.to(succeed())&#xA;&#xA;// passes if .failed is returned from the closure&#xA;expect {&#xA;    guard case .enumCaseWithAssociatedValueThatIDontCareAbout = actual else {&#xA;        return .failed(reason: &#34;wrong enum case&#34;)&#xA;    }&#xA;&#xA;    return .succeeded&#xA;}.notTo(succeed())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;String&lt;/code&gt; provided with &lt;code&gt;.failed()&lt;/code&gt; is shown when the test fails.&lt;/p&gt; &#xA;&lt;p&gt;When using &lt;code&gt;toEventually()&lt;/code&gt; be careful not to make state changes or run process intensive code since this closure will be ran many times.&lt;/p&gt; &#xA;&lt;h1&gt;Writing Your Own Matchers&lt;/h1&gt; &#xA;&lt;p&gt;In Nimble, matchers are Swift functions that take an expected value and return a &lt;code&gt;Matcher&lt;/code&gt; closure. Take &lt;code&gt;equal&lt;/code&gt;, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;public func equal&amp;lt;T: Equatable&amp;gt;(expectedValue: T?) -&amp;gt; Matcher&amp;lt;T&amp;gt; {&#xA;    // Can be shortened to:&#xA;    //   Matcher { actual in  ... }&#xA;    //&#xA;    // But shown with types here for clarity.&#xA;    return Matcher { (actualExpression: Expression&amp;lt;T&amp;gt;) throws -&amp;gt; MatcherResult in&#xA;        let msg = ExpectationMessage.expectedActualValueTo(&#34;equal &amp;lt;\(expectedValue)&amp;gt;&#34;)&#xA;        if let actualValue = try actualExpression.evaluate() {&#xA;            return MatcherResult(&#xA;                bool: actualValue == expectedValue!,&#xA;                message: msg&#xA;            )&#xA;        } else {&#xA;            return MatcherResult(&#xA;                status: .fail,&#xA;                message: msg.appendedBeNilHint()&#xA;            )&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The return value of a &lt;code&gt;Matcher&lt;/code&gt; closure is a &lt;code&gt;MatcherResult&lt;/code&gt; that indicates whether the actual value matches the expectation and what error message to display on failure.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The actual &lt;code&gt;equal&lt;/code&gt; matcher function does not match when &lt;code&gt;expected&lt;/code&gt; are nil; the example above has been edited for brevity.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Since matchers are just Swift functions, you can define them anywhere: at the top of your test file, in a file shared by all of your tests, or in an Xcode project you distribute to others.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If you write a matcher you think everyone can use, consider adding it to Nimble&#39;s built-in set of matchers by sending a pull request! Or distribute it yourself via GitHub.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;For examples of how to write your own matchers, just check out the &lt;a href=&#34;https://github.com/Quick/Nimble/tree/main/Sources/Nimble/Matchers&#34;&gt;&lt;code&gt;Matchers&lt;/code&gt; directory&lt;/a&gt; to see how Nimble&#39;s built-in set of matchers are implemented. You can also check out the tips below.&lt;/p&gt; &#xA;&lt;h2&gt;MatcherResult&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;MatcherResult&lt;/code&gt; is the return struct that &lt;code&gt;Matcher&lt;/code&gt; return to indicate success and failure. A &lt;code&gt;MatcherResult&lt;/code&gt; is made up of two values: &lt;code&gt;MatcherStatus&lt;/code&gt; and &lt;code&gt;ExpectationMessage&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Instead of a boolean, &lt;code&gt;MatcherStatus&lt;/code&gt; captures a trinary set of values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;public enum MatcherStatus {&#xA;// The matcher &#34;passes&#34; with the given expression&#xA;// eg - expect(1).to(equal(1))&#xA;case matches&#xA;&#xA;// The matcher &#34;fails&#34; with the given expression&#xA;// eg - expect(1).toNot(equal(1))&#xA;case doesNotMatch&#xA;&#xA;// The matcher never &#34;passes&#34; with the given expression, even if negated&#xA;// eg - expect(nil as Int?).toNot(equal(1))&#xA;case fail&#xA;&#xA;// ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Meanwhile, &lt;code&gt;ExpectationMessage&lt;/code&gt; provides messaging semantics for error reporting.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;public indirect enum ExpectationMessage {&#xA;// Emits standard error message:&#xA;// eg - &#34;expected to &amp;lt;string&amp;gt;, got &amp;lt;actual&amp;gt;&#34;&#xA;case expectedActualValueTo(/* message: */ String)&#xA;&#xA;// Allows any free-form message&#xA;// eg - &#34;&amp;lt;string&amp;gt;&#34;&#xA;case fail(/* message: */ String)&#xA;&#xA;// ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Matchers should usually depend on either &lt;code&gt;.expectedActualValueTo(..)&lt;/code&gt; or &lt;code&gt;.fail(..)&lt;/code&gt; when reporting errors. Special cases can be used for the other enum cases.&lt;/p&gt; &#xA;&lt;p&gt;Finally, if your Matcher utilizes other Matchers, you can utilize &lt;code&gt;.appended(details:)&lt;/code&gt; and &lt;code&gt;.appended(message:)&lt;/code&gt; methods to annotate an existing error with more details.&lt;/p&gt; &#xA;&lt;p&gt;A common message to append is failing on nils. For that, &lt;code&gt;.appendedBeNilHint()&lt;/code&gt; can be used.&lt;/p&gt; &#xA;&lt;h2&gt;Lazy Evaluation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;actualExpression&lt;/code&gt; is a lazy, memoized closure around the value provided to the &lt;code&gt;expect&lt;/code&gt; function. The expression can either be a closure or a value directly passed to &lt;code&gt;expect(...)&lt;/code&gt;. In order to determine whether that value matches, custom matchers should call &lt;code&gt;actualExpression.evaluate()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;public func beNil&amp;lt;T&amp;gt;() -&amp;gt; Matcher&amp;lt;T&amp;gt; {&#xA;    // Matcher.simpleNilable(..) automatically generates ExpectationMessage for&#xA;    // us based on the string we provide to it. Also, the &#39;Nilable&#39; postfix indicates&#xA;    // that this Matcher supports matching against nil actualExpressions, instead of&#xA;    // always resulting in a MatcherStatus.fail result -- which is true for&#xA;    // Matcher.simple(..)&#xA;    return Matcher.simpleNilable(&#34;be nil&#34;) { actualExpression in&#xA;        let actualValue = try actualExpression.evaluate()&#xA;        return MatcherStatus(bool: actualValue == nil)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above example, &lt;code&gt;actualExpression&lt;/code&gt; is not &lt;code&gt;nil&lt;/code&gt; -- it is a closure that returns a value. The value it returns, which is accessed via the &lt;code&gt;evaluate()&lt;/code&gt; method, may be &lt;code&gt;nil&lt;/code&gt;. If that value is &lt;code&gt;nil&lt;/code&gt;, the &lt;code&gt;beNil&lt;/code&gt; matcher function returns &lt;code&gt;true&lt;/code&gt;, indicating that the expectation passed.&lt;/p&gt; &#xA;&lt;h2&gt;Type Checking via Swift Generics&lt;/h2&gt; &#xA;&lt;p&gt;Using Swift&#39;s generics, matchers can constrain the type of the actual value passed to the &lt;code&gt;expect&lt;/code&gt; function by modifying the return type.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following matcher, &lt;code&gt;haveDescription&lt;/code&gt;, only accepts actual values that implement the &lt;code&gt;Printable&lt;/code&gt; protocol. It checks their &lt;code&gt;description&lt;/code&gt; against the one provided to the matcher function, and passes if they are the same:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;public func haveDescription(description: String) -&amp;gt; Matcher&amp;lt;Printable?&amp;gt; {&#xA;    return Matcher.simple(&#34;have description&#34;) { actual in&#xA;        return MatcherStatus(bool: actual.evaluate().description == description)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Customizing Failure Messages&lt;/h2&gt; &#xA;&lt;p&gt;When using &lt;code&gt;Matcher.simple(..)&lt;/code&gt; or &lt;code&gt;Matcher.simpleNilable(..)&lt;/code&gt;, Nimble outputs the following failure message when an expectation fails:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// where `message` is the first string argument and&#xA;// `actual` is the actual value received in `expect(..)`&#xA;&#34;expected to \(message), got &amp;lt;\(actual)&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can customize this message by modifying the way you create a &lt;code&gt;Matcher&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Basic Customization&lt;/h3&gt; &#xA;&lt;p&gt;For slightly more complex error messaging, receive the created failure message with &lt;code&gt;Matcher.define(..)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;public func equal&amp;lt;T: Equatable&amp;gt;(_ expectedValue: T?) -&amp;gt; Matcher&amp;lt;T&amp;gt; {&#xA;    return Matcher.define(&#34;equal &amp;lt;\(stringify(expectedValue))&amp;gt;&#34;) { actualExpression, msg in&#xA;        let actualValue = try actualExpression.evaluate()&#xA;        let matches = actualValue == expectedValue &amp;amp;&amp;amp; expectedValue != nil&#xA;        if expectedValue == nil || actualValue == nil {&#xA;            if expectedValue == nil &amp;amp;&amp;amp; actualValue != nil {&#xA;                return MatcherResult(&#xA;                    status: .fail,&#xA;                    message: msg.appendedBeNilHint()&#xA;                )&#xA;            }&#xA;            return MatcherResult(status: .fail, message: msg)&#xA;        }&#xA;        return MatcherResult(bool: matches, message: msg)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the example above, &lt;code&gt;msg&lt;/code&gt; is defined based on the string given to &lt;code&gt;Matcher.define&lt;/code&gt;. The code looks akin to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;let msg = ExpectationMessage.expectedActualValueTo(&#34;equal &amp;lt;\(stringify(expectedValue))&amp;gt;&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Full Customization&lt;/h3&gt; &#xA;&lt;p&gt;To fully customize the behavior of the Matcher, use the overload that expects a &lt;code&gt;MatcherResult&lt;/code&gt; to be returned.&lt;/p&gt; &#xA;&lt;p&gt;Along with &lt;code&gt;MatcherResult&lt;/code&gt;, there are other &lt;code&gt;ExpectationMessage&lt;/code&gt; enum values you can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public indirect enum ExpectationMessage {&#xA;// Emits standard error message:&#xA;// eg - &#34;expected to &amp;lt;message&amp;gt;, got &amp;lt;actual&amp;gt;&#34;&#xA;case expectedActualValueTo(/* message: */ String)&#xA;&#xA;// Allows any free-form message&#xA;// eg - &#34;&amp;lt;message&amp;gt;&#34;&#xA;case fail(/* message: */ String)&#xA;&#xA;// Emits standard error message with a custom actual value instead of the default.&#xA;// eg - &#34;expected to &amp;lt;message&amp;gt;, got &amp;lt;actual&amp;gt;&#34;&#xA;case expectedCustomValueTo(/* message: */ String, /* actual: */ String)&#xA;&#xA;// Emits standard error message without mentioning the actual value&#xA;// eg - &#34;expected to &amp;lt;message&amp;gt;&#34;&#xA;case expectedTo(/* message: */ String)&#xA;&#xA;// ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For matchers that compose other matchers, there are a handful of helper functions to annotate messages.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;appended(message: String)&lt;/code&gt; is used to append to the original failure message:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// produces &#34;expected to be true, got &amp;lt;actual&amp;gt; (use beFalse() for inverse)&#34;&#xA;// appended message do show up inline in Xcode.&#xA;.expectedActualValueTo(&#34;be true&#34;).appended(message: &#34; (use beFalse() for inverse)&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a more comprehensive message that spans multiple lines, use &lt;code&gt;appended(details: String)&lt;/code&gt; instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// produces &#34;expected to be true, got &amp;lt;actual&amp;gt;\n\nuse beFalse() for inverse\nor use beNil()&#34;&#xA;// details do not show inline in Xcode, but do show up in test logs.&#xA;.expectedActualValueTo(&#34;be true&#34;).appended(details: &#34;use beFalse() for inverse\nor use beNil()&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Asynchronous Matchers&lt;/h2&gt; &#xA;&lt;p&gt;To write matchers against async expressions, return an instance of &lt;code&gt;AsyncMatcher&lt;/code&gt;. The closure passed to &lt;code&gt;AsyncMatcher&lt;/code&gt; is async, and the expression you evaluate is also asynchronous and needs to be awaited on.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;actor CallRecorder&amp;lt;Arguments&amp;gt; {&#xA;    private(set) var calls: [Arguments] = []&#xA;    &#xA;    func record(call: Arguments) {&#xA;        calls.append(call)&#xA;    }&#xA;}&#xA;&#xA;func beCalled&amp;lt;Argument: Equatable&amp;gt;(with arguments: Argument) -&amp;gt; AsyncMatcher&amp;lt;CallRecorder&amp;lt;Argument&amp;gt;&amp;gt; {&#xA;    AsyncMatcher { (expression: AsyncExpression&amp;lt;CallRecorder&amp;lt;Argument&amp;gt;&amp;gt;) in&#xA;        let message = ExpectationMessage.expectedActualValueTo(&#34;be called with \(arguments)&#34;)&#xA;        guard let calls = try await expression.evaluate()?.calls else {&#xA;            return MatcherResult(status: .fail, message: message.appendedBeNilHint())&#xA;        }&#xA;        &#xA;        return MatcherResult(bool: calls.contains(args), message: message.appended(details: &#34;called with \(calls)&#34;))&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, we created an actor to act as an object to record calls to an async function. Then, we created the &lt;code&gt;beCalled(with:)&lt;/code&gt; matcher to check if the actor has received a call with the given arguments.&lt;/p&gt; &#xA;&lt;h2&gt;Supporting Objective-C&lt;/h2&gt; &#xA;&lt;p&gt;To use a custom matcher written in Swift from Objective-C, you&#39;ll have to extend the &lt;code&gt;NMBMatcher&lt;/code&gt; class, adding a new class method for your custom matcher. The example below defines the class method &lt;code&gt;+[NMBMatcher beNilMatcher]&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;extension NMBMatcher {&#xA;    @objc public class func beNilMatcher() -&amp;gt; NMBMatcher {&#xA;        return NMBMatcher { actualExpression in&#xA;            return try beNil().satisfies(actualExpression).toObjectiveC()&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above allows you to use the matcher from Objective-C:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(actual).to([NMBMatcher beNilMatcher]());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To make the syntax easier to use, define a C function that calls the class method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;FOUNDATION_EXPORT NMBMatcher *beNil() {&#xA;    return [NMBMatcher beNilMatcher];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Properly Handling &lt;code&gt;nil&lt;/code&gt; in Objective-C Matchers&lt;/h3&gt; &#xA;&lt;p&gt;When supporting Objective-C, make sure you handle &lt;code&gt;nil&lt;/code&gt; appropriately. Like &lt;a href=&#34;https://github.com/pivotal/cedar/issues/100&#34;&gt;Cedar&lt;/a&gt;, &lt;strong&gt;most matchers do not match with nil&lt;/strong&gt;. This is to bring prevent test writers from being surprised by &lt;code&gt;nil&lt;/code&gt; values where they did not expect them.&lt;/p&gt; &#xA;&lt;p&gt;Nimble provides the &lt;code&gt;beNil&lt;/code&gt; matcher function for test writer that want to make expectations on &lt;code&gt;nil&lt;/code&gt; objects:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(nil).to(equal(nil)); // fails&#xA;expect(nil).to(beNil());    // passes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your matcher does not want to match with nil, you use &lt;code&gt;Matcher.define&lt;/code&gt; or &lt;code&gt;Matcher.simple&lt;/code&gt;. Using those factory methods will automatically generate expected value failure messages when they&#39;re nil.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public func beginWith&amp;lt;S: Sequence&amp;gt;(_ startingElement: S.Element) -&amp;gt; Matcher&amp;lt;S&amp;gt; where S.Element: Equatable {&#xA;    return Matcher.simple(&#34;begin with &amp;lt;\(startingElement)&amp;gt;&#34;) { actualExpression in&#xA;        guard let actualValue = try actualExpression.evaluate() else { return .fail }&#xA;&#xA;        var actualGenerator = actualValue.makeIterator()&#xA;        return MatcherStatus(bool: actualGenerator.next() == startingElement)&#xA;    }&#xA;}&#xA;&#xA;extension NMBMatcher {&#xA;    @objc public class func beginWithMatcher(_ expected: Any) -&amp;gt; NMBMatcher {&#xA;        return NMBMatcher { actualExpression in&#xA;            let actual = try actualExpression.evaluate()&#xA;            let expr = actualExpression.cast { $0 as? NMBOrderedCollection }&#xA;            return try beginWith(expected).satisfies(expr).toObjectiveC()&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Installing Nimble&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Nimble can be used on its own, or in conjunction with its sister project, &lt;a href=&#34;https://github.com/Quick/Quick&#34;&gt;Quick&lt;/a&gt;. To install both Quick and Nimble, follow &lt;a href=&#34;https://github.com/Quick/Quick/raw/main/Documentation/en-us/InstallingQuick.md&#34;&gt;the installation instructions in the Quick Documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Nimble can currently be installed in one of two ways: using CocoaPods, or with git submodules.&lt;/p&gt; &#xA;&lt;h2&gt;Installing Nimble as a Submodule&lt;/h2&gt; &#xA;&lt;p&gt;To use Nimble as a submodule to test your macOS, iOS or tvOS applications, follow these 4 easy steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone the Nimble repository&lt;/li&gt; &#xA; &lt;li&gt;Add Nimble.xcodeproj to the Xcode workspace for your project&lt;/li&gt; &#xA; &lt;li&gt;Link Nimble.framework to your test target&lt;/li&gt; &#xA; &lt;li&gt;Start writing expectations!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For more detailed instructions on each of these steps, read &lt;a href=&#34;https://github.com/Quick/Quick#how-to-install-quick&#34;&gt;How to Install Quick&lt;/a&gt;. Ignore the steps involving adding Quick to your project in order to install just Nimble.&lt;/p&gt; &#xA;&lt;h2&gt;Installing Nimble via CocoaPods&lt;/h2&gt; &#xA;&lt;p&gt;To use Nimble in CocoaPods to test your macOS, iOS, tvOS or watchOS applications, add Nimble to your podfile and add the &lt;code&gt;use_frameworks!&lt;/code&gt; line to enable Swift support for CocoaPods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;platform :ios, &#39;8.0&#39;&#xA;&#xA;source &#39;https://github.com/CocoaPods/Specs.git&#39;&#xA;&#xA;# Whatever pods you need for your app go here&#xA;&#xA;target &#39;YOUR_APP_NAME_HERE_Tests&#39;, :exclusive =&amp;gt; true do&#xA;  use_frameworks!&#xA;  pod &#39;Nimble&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally run &lt;code&gt;pod install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installing Nimble via Swift Package Manager&lt;/h2&gt; &#xA;&lt;h3&gt;Xcode&lt;/h3&gt; &#xA;&lt;p&gt;To install Nimble via Xcode&#39;s Swift Package Manager Integration: Select your project configuration, then the project tab, then the Package Dependencies tab. Click on the &#34;plus&#34; button at the bottom of the list, then follow the wizard to add Quick to your project. Specify &lt;code&gt;https://github.com/Quick/Nimble.git&lt;/code&gt; as the url, and be sure to add Nimble as a dependency of your unit test target, not your app target.&lt;/p&gt; &#xA;&lt;h3&gt;Package.Swift&lt;/h3&gt; &#xA;&lt;p&gt;To use Nimble with Swift Package Manager to test your applications, add Nimble to your &lt;code&gt;Package.Swift&lt;/code&gt; and link it with your test target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// swift-tools-version:5.5&#xA;&#xA;import PackageDescription&#xA;&#xA;let package = Package(&#xA;    name: &#34;MyAwesomeLibrary&#34;,&#xA;    products: [&#xA;        // ...&#xA;    ],&#xA;    dependencies: [&#xA;        // ...&#xA;        .package(url:  &#34;https://github.com/Quick/Nimble.git&#34;, from: &#34;12.0.0&#34;),&#xA;    ],&#xA;    targets: [&#xA;        // Targets are the basic building blocks of a package. A target can define a module or a test suite.&#xA;        // Targets can depend on other targets in this package, and on products in packages this package depends on.&#xA;        .target(&#xA;            name: &#34;MyAwesomeLibrary&#34;,&#xA;            dependencies: ...),&#xA;        .testTarget(&#xA;            name: &#34;MyAwesomeLibraryTests&#34;,&#xA;            dependencies: [&#34;MyAwesomeLibrary&#34;, &#34;Nimble&#34;]),&#xA;    ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please note that if you install Nimble using Swift Package Manager, then &lt;code&gt;raiseException&lt;/code&gt; is not available.&lt;/p&gt; &#xA;&lt;h2&gt;Using Nimble without XCTest&lt;/h2&gt; &#xA;&lt;p&gt;Nimble is integrated with XCTest to allow it work well when used in Xcode test bundles, however it can also be used in a standalone app. After installing Nimble using one of the above methods, there are two additional steps required to make this work.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a custom assertion handler and assign an instance of it to the global &lt;code&gt;NimbleAssertionHandler&lt;/code&gt; variable. For example:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class MyAssertionHandler : AssertionHandler {&#xA;    func assert(assertion: Bool, message: FailureMessage, location: SourceLocation) {&#xA;        if (!assertion) {&#xA;            print(&#34;Expectation failed: \(message.stringValue)&#34;)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Somewhere before you use any assertions&#xA;NimbleAssertionHandler = MyAssertionHandler()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Add a post-build action to fix an issue with the Swift XCTest support library being unnecessarily copied into your app&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Edit your scheme in Xcode, and navigate to Build -&amp;gt; Post-actions&lt;/li&gt; &#xA; &lt;li&gt;Click the &#34;+&#34; icon and select &#34;New Run Script Action&#34;&lt;/li&gt; &#xA; &lt;li&gt;Open the &#34;Provide build settings from&#34; dropdown and select your target&lt;/li&gt; &#xA; &lt;li&gt;Enter the following script contents:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;rm &#34;${SWIFT_STDLIB_TOOL_DESTINATION_DIR}/libswiftXCTest.dylib&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now use Nimble assertions in your code and handle failures as you see fit.&lt;/p&gt;</summary>
  </entry>
</feed>