<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-14T02:05:12Z</updated>
  <subtitle>Weekly Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SwiftUIX/SwiftUIX</title>
    <updated>2023-05-14T02:05:12Z</updated>
    <id>tag:github.com,2023-05-14:/SwiftUIX/SwiftUIX</id>
    <link href="https://github.com/SwiftUIX/SwiftUIX" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Extensions and additions to the standard SwiftUI library.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;img align=&#34;top&#34; src=&#34;https://raw.githubusercontent.com/SwiftUIX/SwiftUIX/master/Assets/logo.png&#34; width=&#34;36&#34; height=&#34;36&#34;&gt; SwiftUIX&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/SwiftUIX/SwiftUIX/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;SwiftUIX attempts to fill the gaps of the still nascent SwiftUI framework, providing an extensive suite of components, extensions and utilities to complement the standard library. This project is &lt;strong&gt;by far&lt;/strong&gt; the most complete port of missing UIKit/AppKit functionality, striving to deliver it in the most Apple-like fashion possible.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftUIX/SwiftUIX/master/#why&#34;&gt;Why&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftUIX/SwiftUIX/master/#requirements&#34;&gt;Requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftUIX/SwiftUIX/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftUIX/SwiftUIX/master/#contents&#34;&gt;Contents&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftUIX/SwiftUIX/master/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftUIX/SwiftUIX/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftUIX/SwiftUIX/master/#support&#34;&gt;Support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftUIX/SwiftUIX/master/#credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Why&lt;/h1&gt; &#xA;&lt;p&gt;The goal of this project is to &lt;strong&gt;complement&lt;/strong&gt; the SwiftUI standard library, offering hundreds of extensions and views that empower you, the developer, to build applications with the ease promised by the revolution that is SwiftUI.&lt;/p&gt; &#xA;&lt;h1&gt;Requirements&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Deployment target: iOS 13, macOS 10.15, tvOS 13, or watchOS 6&lt;/li&gt; &#xA; &lt;li&gt;Xcode 14+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;The preferred way of installing SwiftUIX is via the &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;Swift Package Manager&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Xcode 11 integrates with libSwiftPM to provide support for iOS, watchOS, macOS and tvOS platforms.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;In Xcode, open your project and navigate to &lt;strong&gt;File&lt;/strong&gt; → &lt;strong&gt;Swift Packages&lt;/strong&gt; → &lt;strong&gt;Add Package Dependency...&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Paste the repository URL (&lt;code&gt;https://github.com/SwiftUIX/SwiftUIX&lt;/code&gt;) and click &lt;strong&gt;Next&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;For &lt;strong&gt;Rules&lt;/strong&gt;, select &lt;strong&gt;Branch&lt;/strong&gt; (with branch set to &lt;code&gt;master&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Click &lt;strong&gt;Finish&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Open the Project settings, add &lt;strong&gt;SwiftUI.framework&lt;/strong&gt; to the &lt;strong&gt;Linked Frameworks and Libraries&lt;/strong&gt;, set &lt;strong&gt;Status&lt;/strong&gt; to &lt;strong&gt;Optional&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Contents&lt;/h1&gt; &#xA;&lt;p&gt;All documentation is available via the &lt;a href=&#34;https://github.com/SwiftUIX/SwiftUIX/wiki&#34;&gt;repository wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;While the project itself is stable and heavily being used in production, its documentation is &lt;strong&gt;work-in-progress&lt;/strong&gt;. Contributions are encouraged and welcomed.&lt;/p&gt; &#xA;&lt;h3&gt;UIKit → SwiftUI&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;UIKit&lt;/th&gt; &#xA;   &lt;th&gt;SwiftUI&lt;/th&gt; &#xA;   &lt;th&gt;SwiftUIX&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;LPLinkView&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;LinkPresentationView&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UIActivityIndicatorView&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ActivityIndicator&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UIActivityViewController&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;AppActivityView&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UIBlurEffect&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;BlurEffectView&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UICollectionView&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CollectionView&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UIDeviceOrientation&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;DeviceLayoutOrientation&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UIImagePickerController&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ImagePicker&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UIPageViewController&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;PaginationView&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UIScreen&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Screen&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UISearchBar&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;SearchBar&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UIScrollView&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ScrollView&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CocoaScrollView&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UISwipeGestureRecognizer&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;SwipeGestureOverlay&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UITableView&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;List&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CocoaList&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UITextField&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;TextField&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CocoaTextField&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UIModalPresentationStyle&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ModalPresentationStyle&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UIViewControllerTransitioningDelegate&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;UIHostingControllerTransitioningDelegate&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UIVisualEffectView&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;VisualEffectView&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;UIWindow&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;WindowOverlay&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;&lt;strong&gt;Activity&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ActivityIndicator&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code&gt;ActivityIndicator()&#xA;    .animated(true)&#xA;    .style(.large)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;AppActivityView&lt;/code&gt; - a SwiftUI port for &lt;code&gt;UIActivityViewController&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;AppActivityView(activityItems: [...])&#xA;    .excludeActivityTypes([...])&#xA;    .onCancel { }&#xA;    .onComplete { result in&#xA;        foo(result)&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Appearance&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;View/visible(_:)&lt;/code&gt; - Sets a view&#39;s visibility.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Error Handling&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;TryButton&lt;/code&gt; - A button capable of performing throwing functions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Geometry&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;flip3D(_:axis:reverse:)&lt;/code&gt; - Flips this view.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RectangleCorner&lt;/code&gt; - A corner of a Rectangle.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ZeroSizeView&lt;/code&gt; - A zero-size view for when &lt;code&gt;EmptyView&lt;/code&gt; just doesn&#39;t work.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Keyboard&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Keyboard&lt;/code&gt; - An object representing the keyboard.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;View/padding(.keyboard) &lt;/code&gt;- Pads this view with the active system height of the keyboard.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Link Presentation:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;LinkPresentationView&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;LinkPresentationView(url: url)&#xA;    .frame(height: 192)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Navigation&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;View/navigationBarColor(_:)&lt;/code&gt; - Configures the color of the navigation bar for this view.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;View/navigationBarTranslucent(_:)&lt;/code&gt; - Configures the translucency of the navigation bar for this view.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;View/navigationBarTransparent(_:)&lt;/code&gt; - Configures the transparency of the navigation bar for this view.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Pagination&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;PaginationView&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;PaginationView(axis: .horizontal) {&#xA;    ForEach(0..&amp;lt;10, id: \.hashValue) { index in&#xA;        Text(String(index))&#xA;    }&#xA;}&#xA;.currentPageIndex($...)&#xA;.pageIndicatorAlignment(...)&#xA;.pageIndicatorTintColor(...)&#xA;.currentPageIndicatorTintColor(...)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Scrolling&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;View/isScrollEnabled(_:)&lt;/code&gt; - Adds a condition that controls whether users can scroll within this view. Works with:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;CocoaList&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;CocoaScrollView&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;CollectionView&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TextView&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Does not work with SwiftUI&#39;s &lt;code&gt;ScrollView&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Search&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;SearchBar&lt;/code&gt; - A SwiftUI port for &lt;code&gt;UISearchBar&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State var isEditing: Bool = false&#xA;    @State var searchText: String = &#34;&#34;&#xA;    &#xA;    var body: some View {&#xA;        SearchBar(&#34;Search...&#34;, text: $searchText, isEditing: $isEditing)&#xA;            .showsCancelButton(isEditing)&#xA;            .onCancel { print(&#34;Canceled!&#34;) }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;View/navigationSearchBar(_:)&lt;/code&gt; - Sets the navigation search bar for this view.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&#34;Hello, world!&#34;)&#xA;    .navigationSearchBar {&#xA;        SearchBar(&#34;Placeholder&#34;, text: $text)&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;View/navigationSearchBarHiddenWhenScrolling(_:)&lt;/code&gt; - Hides the integrated search bar when scrolling any underlying content.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Screen&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Screen&lt;/code&gt; - A representation of the device&#39;s screen.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;UserInterfaceIdiom&lt;/code&gt; - A SwiftUI port for &lt;code&gt;UIUserInterfaceIdiom&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;UserInterfaceOrientation&lt;/code&gt; - A SwiftUI port for &lt;code&gt;UserInterfaceOrientation&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Scroll&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ScrollIndicatorStyle&lt;/code&gt; - A type that specifies the appearance and interaction of all scroll indicators within a view hierarchy &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;HiddenScrollViewIndicatorStyle&lt;/code&gt; - A scroll indicator style that hides all scroll view indicators within a view hierarchy.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Status Bar&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;View/statusItem(id:image:&lt;/code&gt;) - Adds a status bar item configured to present a popover when clicked&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&#34;Hello, world!&#34;)&#xA;    .statusItem(id: &#34;foo&#34;, image: .system(.exclamationmark)) {&#xA;        Text(&#34;Popover!&#34;)&#xA;            .padding()&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Text&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;TextView&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;TextView(&#34;placeholder text&#34;, text: $text, onEditingChanged: { editing in&#xA;    print(editing)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Visual Effects&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;VisualEffectBlurView&lt;/code&gt; - A blur effect view that expands to fill.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;VisualEffectBlurView(blurStyle: .dark)&#xA;    .edgesIgnoringSafeArea(.all)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Window&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;View/windowOverlay(isKeyAndVisible:content:)&lt;/code&gt; - Makes a window key and visible when a given condition is true.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;SwiftUIX welcomes contributions in the form of GitHub issues and pull-requests. Please refer the &lt;a href=&#34;https://github.com/SwiftUIX/SwiftUIX/projects&#34;&gt;projects&lt;/a&gt; section before raising a bug or feature request, as it may already be under progress.&lt;/p&gt; &#xA;&lt;p&gt;To create an Xcode project for SwiftUIX run &lt;code&gt;bundle install; bundle exec fastlane generate_xcodeproj&lt;/code&gt;. To check the automated builds for SwiftUIX run &lt;code&gt;bundle install; bundle exec fastlane build&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;SwiftUIX is licensed under the &lt;a href=&#34;https://vmanot.mit-license.org&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Support&lt;/h1&gt; &#xA;&lt;p&gt;SwiftUIX is and will always be free and open. Maintaining SwiftUIX, however, is a time-consuming endeavour. If you&#39;re reliant on SwiftUIX for your app/project and would like to see it grow, consider contributing/donating as way to help.&lt;/p&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;p&gt;SwiftUIX is a project of &lt;a href=&#34;https://github.com/vmanot&#34;&gt;@vmanot&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>WenchaoD/FSPagerView</title>
    <updated>2023-05-14T02:05:12Z</updated>
    <id>tag:github.com,2023-05-14:/WenchaoD/FSPagerView</id>
    <link href="https://github.com/WenchaoD/FSPagerView" rel="alternate"></link>
    <summary type="html">&lt;p&gt;FSPagerView is an elegant Screen Slide Library. It is extremely helpful for making Banner View、Product Show、Welcome/Guide Pages、Screen/ViewController Sliders.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/5186464/24086370/45e7e8dc-0d49-11e7-86aa-139354fe00c5.jpg&#34; alt=&#34;fspagerview&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WenchaoD/FSPagerView/master/#&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/language-swift%205.0%20%7C%20objc-FF69B4.svg?style=plastic&#34; alt=&#34;Languages&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/FSPagerView&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/platform-iOS%20%7C%20tvOS-blue.svg?style=plastic&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/FSPagerView&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/FSPagerView.svg?style=plastic&#34; alt=&#34;Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=plastic&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/SPM-compatible-FF9966.svg?style=plastic&#34; alt=&#34;SPM compatible&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;b&gt;SWIFT&lt;/b&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;a href=&#34;https://github.com/WenchaoD/FSPagerView/raw/master/README-OBJECTIVE-C.md&#34;&gt;&lt;b&gt;OBJECTIVE-C&lt;/b&gt;&lt;/a&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;FSPagerView&lt;/strong&gt; is an elegant Screen Slide Library implemented primarily with &lt;em&gt;&lt;strong&gt;UICollectionView&lt;/strong&gt;&lt;/em&gt;. It is extremely helpful for making Banner、Product Show、Welcome/Guide Pages、Screen/ViewController Sliders.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;strong&gt;Infinite&lt;/strong&gt;&lt;/em&gt; scrolling.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;strong&gt;Automatic&lt;/strong&gt;&lt;/em&gt; Sliding.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;strong&gt;Horizontal&lt;/strong&gt;&lt;/em&gt; and &lt;em&gt;&lt;strong&gt;Vertical&lt;/strong&gt;&lt;/em&gt; paging.&lt;/li&gt; &#xA; &lt;li&gt;Fully customizable item, with predefined banner-style item.&lt;/li&gt; &#xA; &lt;li&gt;Fully customizable &lt;em&gt;&lt;strong&gt;page control&lt;/strong&gt;&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Rich build-in 3D transformers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;strong&gt;Simple&lt;/strong&gt;&lt;/em&gt; and &lt;em&gt;&lt;strong&gt;Delightful&lt;/strong&gt;&lt;/em&gt; api usage.&lt;/li&gt; &#xA; &lt;li&gt;Support &lt;strong&gt;SWIFT&lt;/strong&gt; and &lt;strong&gt;OBJECTIVE-C&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Demos&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WenchaoD/FSPagerView/master/#banner&#34;&gt;Demo1 - Banner&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WenchaoD/FSPagerView/master/#transformer&#34;&gt;Demo2 - Transformer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WenchaoD/FSPagerView/master/#page_control&#34;&gt;Demo3 - Page Control&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Demo1 - Banner &lt;a id=&#34;banner&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Banner&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/5186464/22688057/9003d880-ed65-11e6-882e-4587c97c8878.gif&#34; alt=&#34;9&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;automaticSlidingInterval&lt;/h3&gt; &#xA;&lt;p&gt;The time interval of automatic sliding. 0 means disabling automatic sliding. Default is 0.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;e.g.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.automaticSlidingInterval = 3.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;isInfinite&lt;/h3&gt; &#xA;&lt;p&gt;A boolean value indicates whether the pager view has infinite number of items. Default is false.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;e.g.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.isInfinite = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;decelerationDistance&lt;/h3&gt; &#xA;&lt;p&gt;An unsigned integer value that determines the paging distance of the pager view, which indicates the number of passing items during the deceleration. When the value of this property is FSPagerView.automaticDistance, the actual &#39;distance&#39; is automatically calculated according to the scrolling speed of the pager view. Default is 1.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;e.g.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.decelerationDistance = 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;itemSize&lt;/h3&gt; &#xA;&lt;p&gt;The item size of the pager view. When the value of this property is FSPagerView.automaticSize, the items fill the entire visible area of the pager view. Default is FSPagerView.automaticSize.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;e.g.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.itemSize = CGSize(width: 200, height: 180)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;interitemSpacing&lt;/h3&gt; &#xA;&lt;p&gt;The spacing to use between items in the pager view. Default is 0.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;e.g.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.interitemSpacing = 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Demo2 - Transformers&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Cross Fading&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/5186464/22686429/1983b97e-ed5f-11e6-9a32-44c1830df7ac.gif&#34; alt=&#34;1&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.transformer = FSPagerViewTransformer(type: .crossFading)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Zoom Out&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/5186464/22686426/19830862-ed5f-11e6-90be-8fb1319cd125.gif&#34; alt=&#34;2&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.transformer = FSPagerViewTransformer(type: .zoomOut)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Depth&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/5186464/22686430/19856c1a-ed5f-11e6-8187-9e4395b7597c.gif&#34; alt=&#34;3&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.transformer = FSPagerViewTransformer(type: .depth)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Linear&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/5186464/22686428/198368c0-ed5f-11e6-95df-cfcfe9bc3f29.gif&#34; alt=&#34;4&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.transformer = FSPagerViewTransformer(type: .linear)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Overlap&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/5186464/22686431/198905aa-ed5f-11e6-9312-ec371c8c4e44.gif&#34; alt=&#34;5&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.transformer = FSPagerViewTransformer(type: .overlap)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Ferris Wheel&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/5186464/22686427/19831c08-ed5f-11e6-8bdb-30e762a85d4b.gif&#34; alt=&#34;6&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.transformer = FSPagerViewTransformer(type: .ferrisWheel)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Inverted Ferris Wheel&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/5186464/22686433/19b669a0-ed5f-11e6-8bf0-dc23edf8101f.gif&#34; alt=&#34;7&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.transformer = FSPagerViewTransformer(type: .invertedFerrisWheel)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Cover Flow&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/5186464/22686432/19b567f8-ed5f-11e6-885d-bd660c98b507.gif&#34; alt=&#34;8&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.transformer = FSPagerViewTransformer(type: .coverFlow)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Cubic&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/5186464/23461598/8875080c-fec5-11e6-8db6-6d8864acfcc1.gif&#34; alt=&#34;9&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pagerView.transformer = FSPagerViewTransformer(type: .cubic)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Customize your own transformer by subclassing&lt;code&gt;FSPagerViewTransformer.&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Demo3 Page Control&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Page Control&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/5186464/22689720/2baabdb0-ed6d-11e6-8287-ef7a2c0f64bc.gif&#34; alt=&#34;10&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;|&lt;/p&gt; &#xA;&lt;h3&gt;numberOfPages&lt;/h3&gt; &#xA;&lt;p&gt;The number of page indicators of the page control. Default is 0.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;e.g.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pageControl.numberOfPages = 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;currentPage&lt;/h3&gt; &#xA;&lt;p&gt;The current page, highlighted by the page control. Default is 0.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;e.g.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pageControl.currentPage = 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;contentHorizontalAlignment&lt;/h3&gt; &#xA;&lt;p&gt;The horizontal alignment of content within the control’s bounds. Default is center.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;e.g.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pageControl.contentHorizontalAlignment = .right&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;setStrokeColor:forState:&lt;/h3&gt; &#xA;&lt;p&gt;Sets the stroke color for page indicators to use for the specified state. (selected/normal).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;e.g.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pageControl.setStrokeColor(.green, for: .normal)&#xA;pageControl.setStrokeColor(.yellow, for: .selected)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;setFillColor:forState:&lt;/h3&gt; &#xA;&lt;p&gt;Sets the fill color for page indicators to use for the specified state. (selected/normal).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;e.g.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pageControl.setFillColor(.gray, for: .normal)&#xA;pageControl.setFillColor(.white, for: .selected)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;setImage:forState:&lt;/h3&gt; &#xA;&lt;p&gt;Sets the image for page indicators to use for the specified state. (selected/normal).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;e.g.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pageControl.setImage(UIImage(named:&#34;image1&#34;), for: .normal)&#xA;pageControl.setImage(UIImage(named:&#34;image2&#34;), for: .selected)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;setPath:forState:&lt;/h3&gt; &#xA;&lt;p&gt;Sets the path for page indicators to use for the specified state. (selected/normal).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;e.g.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;pageControl.setPath(UIBezierPath(rect: CGRect(x: 0, y: 0, width: 8, height: 8)), for: .normal)&#xA;pageControl.setPath(UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: 8, height: 8)), for: .selected)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Manually&lt;/li&gt; &#xA; &lt;li&gt;Cocoapods&lt;/li&gt; &#xA; &lt;li&gt;Carthage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Manually&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WenchaoD/FSPagerView/master/#&#34;&gt;Download&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt; the source code.&lt;/li&gt; &#xA; &lt;li&gt;Extract the zip file, simply drag folder &lt;em&gt;&lt;strong&gt;Sources&lt;/strong&gt;&lt;/em&gt; into your project.&lt;/li&gt; &#xA; &lt;li&gt;Make sure &lt;em&gt;&lt;strong&gt;Copy items if needed&lt;/strong&gt;&lt;/em&gt; is checked.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Cocoapods&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;use_frameworks!&#xA;target &#39;&amp;lt;Your Target Name&amp;gt;&#39; do&#xA;    pod &#39;FSPagerView&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;github &#34;WenchaoD/FSPagerView&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Tutorial&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WenchaoD/FSPagerView/master/#getting_started&#34;&gt;Getting started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WenchaoD/FSPagerView/master/#implement_fspagerviewdatasource&#34;&gt;Implement FSPagerViewDataSource&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/WenchaoD/FSPagerView/master/#implement_fspagerviewdelegate&#34;&gt;Implement FSPagerViewDelegate&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;1. Getting started &lt;a id=&#34;getting_started&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Getting started with code&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Create a pager view&#xA;let pagerView = FSPagerView(frame: frame1)&#xA;pagerView.dataSource = self&#xA;pagerView.delegate = self&#xA;pagerView.register(FSPagerViewCell.self, forCellWithReuseIdentifier: &#34;cell&#34;)&#xA;self.view.addSubview(pagerView)&#xA;// Create a page control&#xA;let pageControl = FSPageControl(frame: frame2)&#xA;self.view.addSubview(pageControl)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Getting started with Interface Builder &lt;br&gt; 1、Simply drag &lt;strong&gt;UIView&lt;/strong&gt; instance into your View Controller, Change the &lt;code&gt;Custom Class&lt;/code&gt; to &lt;code&gt;FSPagerView&lt;/code&gt;. (Or &lt;code&gt;FSPageControl&lt;/code&gt;) &lt;br&gt; 2、Link the &lt;code&gt;dataSource&lt;/code&gt; and &lt;code&gt;delegate&lt;/code&gt; property of &lt;strong&gt;FSPagerView&lt;/strong&gt; to your View Controller. &lt;br&gt; 3、Register a cell class.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@IBOutlet weak var pagerView: FSPagerView! {&#xA;    didSet {&#xA;        self.pagerView.register(FSPagerViewCell.self, forCellWithReuseIdentifier: &#34;cell&#34;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;2. Implement FSPagerViewDataSource &lt;a id=&#34;implement_fspagerviewdatasource&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public func numberOfItems(in pagerView: FSPagerView) -&amp;gt; Int {&#xA;    return numberOfItems&#xA;}&#xA;    &#xA;public func pagerView(_ pagerView: FSPagerView, cellForItemAt index: Int) -&amp;gt; FSPagerViewCell {&#xA;    let cell = pagerView.dequeueReusableCell(withReuseIdentifier: &#34;cell&#34;, at: index)&#xA;    cell.imageView?.image = ...&#xA;    cell.textLabel?.text = ...&#xA;    return cell&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3. Implement FSPagerViewDelegate &lt;a id=&#34;implement_fspagerviewdelegate&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func pagerView(_ pagerView: FSPagerView, shouldHighlightItemAt index: Int) -&amp;gt; Bool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Asks the delegate if the item should be highlighted during tracking.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func pagerView(_ pagerView: FSPagerView, didHighlightItemAt index: Int)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Tells the delegate that the item at the specified index was highlighted.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func pagerView(_ pagerView: FSPagerView, shouldSelectItemAt index: Int) -&amp;gt; Bool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Asks the delegate if the specified item should be selected.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func pagerView(_ pagerView: FSPagerView, didSelectItemAt index: Int)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Tells the delegate that the item at the specified index was selected.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func pagerView(_ pagerView: FSPagerView, willDisplay cell: FSPagerViewCell, forItemAt index: Int)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Tells the delegate that the specified cell is about to be displayed in the pager view.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func pagerView(_ pagerView: FSPagerView, didEndDisplaying cell: FSPagerViewCell, forItemAt index: Int)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Tells the delegate that the specified cell was removed from the pager view.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func pagerViewWillBeginDragging(_ pagerView: FSPagerView)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Tells the delegate when the pager view is about to start scrolling the content.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func pagerViewWillEndDragging(_ pagerView: FSPagerView, targetIndex: Int)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Tells the delegate when the user finishes scrolling the content.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func pagerViewDidScroll(_ pagerView: FSPagerView)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Tells the delegate when the user scrolls the content view within the receiver.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func pagerViewDidEndScrollAnimation(_ pagerView: FSPagerView)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Tells the delegate when a scrolling animation in the pager view concludes.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func pagerViewDidEndDecelerating(_ pagerView: FSPagerView)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Tells the delegate that the pager view has ended decelerating the scrolling movement.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;support&#34;&gt;&lt;/a&gt;Support this repo&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;strong&gt;Star&lt;/strong&gt;&lt;/em&gt; this repo &lt;a href=&#34;https://raw.githubusercontent.com/WenchaoD/FSPagerView/master/#&#34;&gt;&lt;img style=&#34;margin-bottom:-12px&#34; width=&#34;72&#34; alt=&#34;star&#34; src=&#34;https://cloud.githubusercontent.com/assets/5186464/15383105/fcf9cdf0-1dc2-11e6-88db-bf221042a584.png&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Buy me a Coffee. ☕️&lt;/p&gt; &lt;p&gt;&lt;a href=&#34;https://www.paypal.me/WenchaoD&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://www.paypalobjects.com/webstatic/i/logo/rebrand/ppcom.svg?sanitize=true&#34; width=&#34;100&#34; height=&#34;40&#34; style=&#34;margin-bottom:-15px;&#34;&gt;&lt;/a&gt; &amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp; &lt;a href=&#34;https://user-images.githubusercontent.com/5186464/45949944-46960480-c030-11e8-9e90-30b015698cf6.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://a1.mzstatic.com/us/r30/Purple49/v4/50/16/b3/5016b341-39c1-b47b-2994-d7e23823baed/icon175x175.png&#34; width=&#34;40&#34; height=&#34;40&#34; style=&#34;margin-bottom:-15px;-webkit-border-radius:10px;border:1px solid rgba(30, 154, 236, 1);&#34;&gt;&lt;/a&gt; &amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp; &lt;a href=&#34;https://cloud.githubusercontent.com/assets/5186464/15096872/b06f3a3a-153c-11e6-89f9-2e9c7b88ef42.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://a4.mzstatic.com/us/r30/Purple49/v4/23/31/14/233114f8-2e8d-7b63-8dc5-85d29893061e/icon175x175.jpeg&#34; height=&#34;40&#34; width=&#34;40&#34; style=&#34;margin-bottom:-15px; -webkit-border-radius: 10px;border:1px solid rgba(43, 177, 0, 1)&#34;&gt;&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;strong&gt;微博：&lt;a href=&#34;http://weibo.com/WenchaoD&#34;&gt;@WenchaoD&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;strong&gt;Twitter: &lt;a href=&#34;https://twitter.com/WenchaoD&#34;&gt;@WenchaoD&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Other repos: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/WenchaoD&#34;&gt;&lt;em&gt;&lt;strong&gt;FSCalendar&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;http://cocoadocs.org/docsets/FSPagerView&#34;&gt;Documentation&lt;/a&gt;&lt;/h1&gt;</summary>
  </entry>
  <entry>
    <title>apple/swift-nio</title>
    <updated>2023-05-14T02:05:12Z</updated>
    <id>tag:github.com,2023-05-14:/apple/swift-nio</id>
    <link href="https://github.com/apple/swift-nio" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Event-driven network application framework for high performance protocol servers &amp; clients, non-blocking.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/swift-server/sswg/raw/main/process/incubation.md#graduated-level&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/sswg-graduated-green.svg?sanitize=true&#34; alt=&#34;sswg:graduated|104x20&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;SwiftNIO&lt;/h1&gt; &#xA;&lt;p&gt;SwiftNIO is a cross-platform asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp;amp; clients.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s like &lt;a href=&#34;https://netty.io&#34;&gt;Netty&lt;/a&gt;, but written for Swift.&lt;/p&gt; &#xA;&lt;h3&gt;Repository organization&lt;/h3&gt; &#xA;&lt;p&gt;The SwiftNIO project is split across multiple repositories:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Repository&lt;/th&gt; &#xA;   &lt;th&gt;NIO 2 (Swift 5.6+)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/apple/swift-nio&#34;&gt;https://github.com/apple/swift-nio&lt;/a&gt; &lt;br&gt; SwiftNIO core&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;from: &#34;2.0.0&#34;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/apple/swift-nio-ssl&#34;&gt;https://github.com/apple/swift-nio-ssl&lt;/a&gt; &lt;br&gt; TLS (SSL) support&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;from: &#34;2.0.0&#34;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/apple/swift-nio-http2&#34;&gt;https://github.com/apple/swift-nio-http2&lt;/a&gt;&lt;br&gt; HTTP/2 support&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;from: &#34;1.0.0&#34;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/apple/swift-nio-extras&#34;&gt;https://github.com/apple/swift-nio-extras&lt;/a&gt; &lt;br&gt;useful additions around SwiftNIO&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;from: &#34;1.0.0&#34;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/apple/swift-nio-transport-services&#34;&gt;https://github.com/apple/swift-nio-transport-services&lt;/a&gt; &lt;br&gt; first-class support for macOS, iOS, tvOS, and watchOS&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;from: &#34;1.0.0&#34;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/apple/swift-nio-ssh&#34;&gt;https://github.com/apple/swift-nio-ssh&lt;/a&gt; &lt;br&gt; SSH support&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;.upToNextMinor(from: &#34;0.2.0&#34;)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;NIO 2.29.0 and older support Swift 5.0+, NIO 2.39.0 and older support Swift 5.2+.&lt;/p&gt; &#xA;&lt;p&gt;Within this repository we have a number of products that provide different functionality. This package contains the following products:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;NIO&lt;/code&gt;. This is an umbrella module exporting &lt;code&gt;NIOCore&lt;/code&gt;, &lt;code&gt;NIOEmbedded&lt;/code&gt; and &lt;code&gt;NIOPosix&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NIOCore&lt;/code&gt;. This provides the core abstractions and types for using SwiftNIO (see &lt;a href=&#34;https://raw.githubusercontent.com/apple/swift-nio/main/#conceptual-overview&#34;&gt;&#34;Conceptual Overview&#34;&lt;/a&gt; for more details). Most NIO extension projects that provide things like new &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloop&#34;&gt;&lt;code&gt;EventLoop&lt;/code&gt;s&lt;/a&gt; and &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;s&lt;/a&gt; or new protocol implementations should only need to depend on &lt;code&gt;NIOCore&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NIOPosix&lt;/code&gt;. This provides the primary [&lt;code&gt;EventLoopGroup&lt;/code&gt;], &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloop&#34;&gt;&lt;code&gt;EventLoop&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;s&lt;/a&gt; for use on POSIX-based systems. This is our high performance core I/O layer. In general, this should only be imported by projects that plan to do some actual I/O, such as high-level protocol implementations or applications.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NIOEmbedded&lt;/code&gt;. This provides &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/nioembedded/embeddedchannel&#34;&gt;&lt;code&gt;EmbeddedChannel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/nioembedded/embeddedeventloop&#34;&gt;&lt;code&gt;EmbeddedEventLoop&lt;/code&gt;&lt;/a&gt;, implementations of the &lt;code&gt;NIOCore&lt;/code&gt; abstractions that provide fine-grained control over their execution. These are most often used for testing, but can also be used to drive protocol implementations in a way that is decoupled from networking altogether.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NIOConcurrencyHelpers&lt;/code&gt;. This provides a few low-level concurrency primitives that are used by NIO implementations, such as locks and atomics.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NIOFoundationCompat&lt;/code&gt;. This extends a number of NIO types for better interoperation with Foundation data types. If you are working with Foundation data types such as &lt;code&gt;Data&lt;/code&gt;, you should import this.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NIOTLS&lt;/code&gt;. This provides a few common abstraction types for working with multiple TLS implementations. Note that this doesn&#39;t provide TLS itself: please investigate &lt;a href=&#34;https://github.com/apple/swift-nio-ssl&#34;&gt;swift-nio-ssl&lt;/a&gt; and &lt;a href=&#34;https://github.com/apple/swift-nio-transport-services&#34;&gt;swift-nio-transport-services&lt;/a&gt; for concrete implementations.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NIOHTTP1&lt;/code&gt;. This provides a low-level HTTP/1.1 protocol implementation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NIOWebSocket&lt;/code&gt;. This provides a low-level WebSocket protocol implementation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NIOTestUtils&lt;/code&gt;. This provides a number of helpers for testing projects that use SwiftNIO.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Protocol Implementations&lt;/h3&gt; &#xA;&lt;p&gt;Below you can find a list of a few protocol implementations that are done with SwiftNIO. This is a non-exhaustive list of protocols that are either part of the SwiftNIO project or are accepted into the &lt;a href=&#34;https://swift.org/server&#34;&gt;SSWG&lt;/a&gt;&#39;s incubation process. All of the libraries listed below do all of their I/O in a non-blocking fashion using SwiftNIO.&lt;/p&gt; &#xA;&lt;h4&gt;Low-level protocol implementations&lt;/h4&gt; &#xA;&lt;p&gt;Low-level protocol implementations are often a collection of &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt;s that implement a protocol but still require the user to have a good understanding of SwiftNIO. Often, low-level protocol implementations will then be wrapped in high-level libraries with a nicer, more user-friendly API.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Protocol&lt;/th&gt; &#xA;   &lt;th&gt;Client&lt;/th&gt; &#xA;   &lt;th&gt;Server&lt;/th&gt; &#xA;   &lt;th&gt;Repository&lt;/th&gt; &#xA;   &lt;th&gt;Module&lt;/th&gt; &#xA;   &lt;th&gt;Comment&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;HTTP/1&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/apple/swift-nio&#34;&gt;apple/swift-nio&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niohttp1&#34;&gt;&lt;code&gt;NIOHTTP1&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;official NIO project&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;HTTP/2&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/apple/swift-nio-http2&#34;&gt;apple/swift-nio-http2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio-http2/main/documentation/niohttp2&#34;&gt;&lt;code&gt;NIOHTTP2&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;official NIO project&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;WebSocket&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/apple/swift-nio&#34;&gt;apple/swift-nio&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niowebsocket&#34;&gt;&lt;code&gt;NIOWebSocket&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;official NIO project&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TLS&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/apple/swift-nio-ssl&#34;&gt;apple/swift-nio-ssl&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio-ssl/main/documentation/niossl&#34;&gt;&lt;code&gt;NIOSSL&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;official NIO project&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SSH&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/apple/swift-nio-ssh&#34;&gt;apple/swift-nio-ssh&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio-ssh/main/documentation/niossh&#34;&gt;&lt;code&gt;NIOSSH&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;official NIO project&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;High-level implementations&lt;/h4&gt; &#xA;&lt;p&gt;High-level implementations are usually libraries that come with an API that doesn&#39;t expose SwiftNIO&#39;s &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelpipeline&#34;&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt;&lt;/a&gt; and can therefore be used with very little (or no) SwiftNIO-specific knowledge. The implementations listed below do still do all of their I/O in SwiftNIO and integrate really well with the SwiftNIO ecosystem.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Protocol&lt;/th&gt; &#xA;   &lt;th&gt;Client&lt;/th&gt; &#xA;   &lt;th&gt;Server&lt;/th&gt; &#xA;   &lt;th&gt;Repository&lt;/th&gt; &#xA;   &lt;th&gt;Module&lt;/th&gt; &#xA;   &lt;th&gt;Comment&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;HTTP&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/swift-server/async-http-client&#34;&gt;swift-server/async-http-client&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;AsyncHTTPClient&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;SSWG community project&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;gRPC&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/grpc/grpc-swift&#34;&gt;grpc/grpc-swift&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;GRPC&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;also offers a low-level API; SSWG community project&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;APNS&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/kylebrowning/APNSwift&#34;&gt;kylebrowning/APNSwift&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;APNSwift&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;SSWG community project&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;PostgreSQL&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/vapor/postgres-nio&#34;&gt;vapor/postgres-nio&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;PostgresNIO&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;SSWG community project&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Redis&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://gitlab.com/Mordil/swift-redi-stack&#34;&gt;mordil/swift-redi-stack&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;RediStack&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;SSWG community project&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Supported Versions&lt;/h3&gt; &#xA;&lt;h3&gt;SwiftNIO 2&lt;/h3&gt; &#xA;&lt;p&gt;This is the current version of SwiftNIO and will be supported for the foreseeable future.&lt;/p&gt; &#xA;&lt;p&gt;The most recent versions of SwiftNIO support Swift 5.6 and newer. The minimum Swift version supported by SwiftNIO releases are detailed below:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;SwiftNIO&lt;/th&gt; &#xA;   &lt;th&gt;Minimum Swift Version&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;2.0.0 ..&amp;lt; 2.30.0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;5.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;2.30.0 ..&amp;lt; 2.40.0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;5.2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;2.40.0 ..&amp;lt; 2.43.0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;5.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;2.43.0 ..&amp;lt; 2.51.0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;5.5.2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;2.51.0 ...&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;5.6&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;SwiftNIO 1&lt;/h3&gt; &#xA;&lt;p&gt;SwiftNIO 1 is considered end of life - it is strongly recommended that you move to a newer version. The Core NIO team does not actively work on this version. No new features will be added to this version but PRs which fix bugs or security vulnerabilities will be accepted until the end of May 2022.&lt;/p&gt; &#xA;&lt;p&gt;If you have a SwiftNIO 1 application or library that you would like to migrate to SwiftNIO 2, please check out the &lt;a href=&#34;https://raw.githubusercontent.com/apple/swift-nio/main/docs/migration-guide-NIO1-to-NIO2.md&#34;&gt;migration guide&lt;/a&gt; we prepared for you.&lt;/p&gt; &#xA;&lt;p&gt;The latest released SwiftNIO 1 version&amp;nbsp;supports Swift 4.0, 4.1, 4.2, and 5.0.&lt;/p&gt; &#xA;&lt;h3&gt;Supported Platforms&lt;/h3&gt; &#xA;&lt;p&gt;SwiftNIO aims to support all of the platforms where Swift is supported. Currently, it is developed and tested on macOS and Linux, and is known to support the following operating system versions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ubuntu 18.04+&lt;/li&gt; &#xA; &lt;li&gt;macOS 10.9+, iOS 7+; (macOS 10.14+, iOS 12+, tvOS 12+ or watchOS 6+ with &lt;a href=&#34;https://github.com/apple/swift-nio-transport-services&#34;&gt;swift-nio-transport-services&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Compatibility&lt;/h3&gt; &#xA;&lt;p&gt;SwiftNIO follows &lt;a href=&#34;https://semver.org/#semantic-versioning-200&#34;&gt;SemVer 2.0.0&lt;/a&gt; with a separate document declaring &lt;a href=&#34;https://raw.githubusercontent.com/apple/swift-nio/main/docs/public-api.md&#34;&gt;SwiftNIO&#39;s Public API&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;What this means for you is that you should depend on SwiftNIO with a version range that covers everything from the minimum SwiftNIO version you require up to the next major version. In SwiftPM that can be easily done specifying for example &lt;code&gt;from: &#34;2.0.0&#34;&lt;/code&gt; meaning that you support SwiftNIO in every version starting from 2.0.0 up to (excluding) 3.0.0. SemVer and SwiftNIO&#39;s Public API guarantees should result in a working program without having to worry about testing every single version for compatibility.&lt;/p&gt; &#xA;&lt;h2&gt;Conceptual Overview&lt;/h2&gt; &#xA;&lt;p&gt;SwiftNIO is fundamentally a low-level tool for building high-performance networking applications in Swift. It particularly targets those use-cases where using a &#34;thread-per-connection&#34; model of concurrency is inefficient or untenable. This is a common limitation when building servers that use a large number of relatively low-utilization connections, such as HTTP servers.&lt;/p&gt; &#xA;&lt;p&gt;To achieve its goals SwiftNIO extensively uses &#34;non-blocking I/O&#34;: hence the name! Non-blocking I/O differs from the more common blocking I/O model because the application does not wait for data to be sent to or received from the network: instead, SwiftNIO asks for the kernel to notify it when I/O operations can be performed without waiting.&lt;/p&gt; &#xA;&lt;p&gt;SwiftNIO does not aim to provide high-level solutions like, for example, web frameworks do. Instead, SwiftNIO is focused on providing the low-level building blocks for these higher-level applications. When it comes to building a web application, most users will not want to use SwiftNIO directly: instead, they&#39;ll want to use one of the many great web frameworks available in the Swift ecosystem. Those web frameworks, however, may choose to use SwiftNIO under the covers to provide their networking support.&lt;/p&gt; &#xA;&lt;p&gt;The following sections will describe the low-level tools that SwiftNIO provides, and provide a quick overview of how to work with them. If you feel comfortable with these concepts, then you can skip right ahead to the other sections of this README.&lt;/p&gt; &#xA;&lt;h3&gt;Basic Architecture&lt;/h3&gt; &#xA;&lt;p&gt;The basic building blocks of SwiftNIO are the following 8 types of objects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloopgroup&#34;&gt;&lt;code&gt;EventLoopGroup&lt;/code&gt;&lt;/a&gt;, a protocol, provided by &lt;code&gt;NIOCore&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloop&#34;&gt;&lt;code&gt;EventLoop&lt;/code&gt;&lt;/a&gt;, a protocol, provided by &lt;code&gt;NIOCore&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;, a protocol, provided by &lt;code&gt;NIOCore&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt;, a protocol, provided by &lt;code&gt;NIOCore&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Bootstrap&lt;/code&gt;, several related structures, provided by &lt;code&gt;NIOCore&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/bytebuffer&#34;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt;, a struct, provided by &lt;code&gt;NIOCore&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloopfuture&#34;&gt;&lt;code&gt;EventLoopFuture&lt;/code&gt;&lt;/a&gt;, a generic class, provided by &lt;code&gt;NIOCore&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventlooppromise&#34;&gt;&lt;code&gt;EventLoopPromise&lt;/code&gt;&lt;/a&gt;, a generic struct, provided by &lt;code&gt;NIOCore&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All SwiftNIO applications are ultimately constructed of these various components.&lt;/p&gt; &#xA;&lt;h4&gt;EventLoops and EventLoopGroups&lt;/h4&gt; &#xA;&lt;p&gt;The basic I/O primitive of SwiftNIO is the event loop. The event loop is an object that waits for events (usually I/O related events, such as &#34;data received&#34;) to happen and then fires some kind of callback when they do. In almost all SwiftNIO applications there will be relatively few event loops: usually only one or two per CPU core the application wants to use. Generally speaking event loops run for the entire lifetime of your application, spinning in an endless loop dispatching events.&lt;/p&gt; &#xA;&lt;p&gt;Event loops are gathered together into event loop &lt;em&gt;groups&lt;/em&gt;. These groups provide a mechanism to distribute work around the event loops. For example, when listening for inbound connections the listening socket will be registered on one event loop. However, we don&#39;t want all connections that are accepted on that listening socket to be registered with the same event loop, as that would potentially overload one event loop while leaving the others empty. For that reason, the event loop group provides the ability to spread load across multiple event loops.&lt;/p&gt; &#xA;&lt;p&gt;In SwiftNIO today there is one &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloopgroup&#34;&gt;&lt;code&gt;EventLoopGroup&lt;/code&gt;&lt;/a&gt; implementation, and two &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloop&#34;&gt;&lt;code&gt;EventLoop&lt;/code&gt;&lt;/a&gt; implementations. For production applications there is the &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/nioposix/multithreadedeventloopgroup&#34;&gt;&lt;code&gt;MultiThreadedEventLoopGroup&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloopgroup&#34;&gt;&lt;code&gt;EventLoopGroup&lt;/code&gt;&lt;/a&gt; that creates a number of threads (using the POSIX &lt;a href=&#34;https://en.wikipedia.org/wiki/POSIX_Threads&#34;&gt;&lt;code&gt;pthreads&lt;/code&gt;&lt;/a&gt; library) and places one &lt;code&gt;SelectableEventLoop&lt;/code&gt; on each one. The &lt;code&gt;SelectableEventLoop&lt;/code&gt; is an event loop that uses a selector (either &lt;a href=&#34;https://en.wikipedia.org/wiki/Kqueue&#34;&gt;&lt;code&gt;kqueue&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/Epoll&#34;&gt;&lt;code&gt;epoll&lt;/code&gt;&lt;/a&gt; depending on the target system) to manage I/O events from file descriptors and to dispatch work. These &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloop&#34;&gt;&lt;code&gt;EventLoop&lt;/code&gt;s&lt;/a&gt; and &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloopgroup&#34;&gt;&lt;code&gt;EventLoopGroup&lt;/code&gt;s&lt;/a&gt; are provided by the &lt;code&gt;NIOPosix&lt;/code&gt; module. Additionally, there is the &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/nioembedded/embeddedeventloop&#34;&gt;&lt;code&gt;EmbeddedEventLoop&lt;/code&gt;&lt;/a&gt;, which is a dummy event loop that is used primarily for testing purposes, provided by the &lt;code&gt;NIOEmbedded&lt;/code&gt; module.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloop&#34;&gt;&lt;code&gt;EventLoop&lt;/code&gt;&lt;/a&gt;s have a number of important properties. Most vitally, they are the way all work gets done in SwiftNIO applications. In order to ensure thread-safety, any work that wants to be done on almost any of the other objects in SwiftNIO must be dispatched via an &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloop&#34;&gt;&lt;code&gt;EventLoop&lt;/code&gt;&lt;/a&gt;. &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloop&#34;&gt;&lt;code&gt;EventLoop&lt;/code&gt;&lt;/a&gt; objects own almost all the other objects in a SwiftNIO application, and understanding their execution model is critical for building high-performance SwiftNIO applications.&lt;/p&gt; &#xA;&lt;h4&gt;Channels, Channel Handlers, Channel Pipelines, and Channel Contexts&lt;/h4&gt; &#xA;&lt;p&gt;While &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloop&#34;&gt;&lt;code&gt;EventLoop&lt;/code&gt;&lt;/a&gt;s are critical to the way SwiftNIO works, most users will not interact with them substantially beyond asking them to create &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventlooppromise&#34;&gt;&lt;code&gt;EventLoopPromise&lt;/code&gt;&lt;/a&gt;s and to schedule work. The parts of a SwiftNIO application most users will spend the most time interacting with are &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s and &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt;s.&lt;/p&gt; &#xA;&lt;p&gt;Almost every file descriptor that a user interacts with in a SwiftNIO program is associated with a single &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; owns this file descriptor, and is responsible for managing its lifetime. It is also responsible for processing inbound and outbound events on that file descriptor: whenever the event loop has an event that corresponds to a file descriptor, it will notify the &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; that owns that file descriptor.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s by themselves, however, are not useful. After all, it is a rare application that doesn&#39;t want to do anything with the data it sends or receives on a socket! So the other important part of the &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelpipeline&#34;&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelpipeline&#34;&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt;&lt;/a&gt; is a sequence of objects, called &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt;s, that process events on a &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt;s process these events one after another, in order, mutating and transforming events as they go. This can be thought of as a data processing pipeline; hence the name &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelpipeline&#34;&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;All &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt;s are either Inbound or Outbound handlers, or both. Inbound handlers process &#34;inbound&#34; events: events like reading data from a socket, reading socket close, or other kinds of events initiated by remote peers. Outbound handlers process &#34;outbound&#34; events, such as writes, connection attempts, and local socket closes.&lt;/p&gt; &#xA;&lt;p&gt;Each handler processes the events in order. For example, read events are passed from the front of the pipeline to the back, one handler at a time, while write events are passed from the back of the pipeline to the front. Each handler may, at any time, generate either inbound or outbound events that will be sent to the next handler in whichever direction is appropriate. This allows handlers to split up reads, coalesce writes, delay connection attempts, and generally perform arbitrary transformations of events.&lt;/p&gt; &#xA;&lt;p&gt;In general, &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt;s are designed to be highly re-usable components. This means they tend to be designed to be as small as possible, performing one specific data transformation. This allows handlers to be composed together in novel and flexible ways, which helps with code reuse and encapsulation.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt;s are able to keep track of where they are in a &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelpipeline&#34;&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt;&lt;/a&gt; by using a &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandlercontext&#34;&gt;&lt;code&gt;ChannelHandlerContext&lt;/code&gt;&lt;/a&gt;. These objects contain references to the previous and next channel handler in the pipeline, ensuring that it is always possible for a &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt; to emit events while it remains in a pipeline.&lt;/p&gt; &#xA;&lt;p&gt;SwiftNIO ships with many &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt;s built in that provide useful functionality, such as HTTP parsing. In addition, high-performance applications will want to provide as much of their logic as possible in &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt;s, as it helps avoid problems with context switching.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, SwiftNIO ships with a few &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; implementations. In particular, it ships with &lt;code&gt;ServerSocketChannel&lt;/code&gt;, a &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; for sockets that accept inbound connections; &lt;code&gt;SocketChannel&lt;/code&gt;, a &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; for TCP connections; and &lt;code&gt;DatagramChannel&lt;/code&gt;, a &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; for UDP sockets. All of these are provided by the &lt;code&gt;NIOPosix&lt;/code&gt; module. It also provides&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/nioembedded/embeddedchannel&#34;&gt;&lt;code&gt;EmbeddedChannel&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; primarily used for testing, provided by the &lt;code&gt;NIOEmbedded&lt;/code&gt; module.&lt;/p&gt; &#xA;&lt;h5&gt;A Note on Blocking&lt;/h5&gt; &#xA;&lt;p&gt;One of the important notes about &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelpipeline&#34;&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt;&lt;/a&gt;s is that they are thread-safe. This is very important for writing SwiftNIO applications, as it allows you to write much simpler &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt;s in the knowledge that they will not require synchronization.&lt;/p&gt; &#xA;&lt;p&gt;However, this is achieved by dispatching all code on the &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelpipeline&#34;&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt;&lt;/a&gt; on the same thread as the &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloop&#34;&gt;&lt;code&gt;EventLoop&lt;/code&gt;&lt;/a&gt;. This means that, as a general rule, &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt;s &lt;strong&gt;must not&lt;/strong&gt; call blocking code without dispatching it to a background thread. If a &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelhandler&#34;&gt;&lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/a&gt; blocks for any reason, all &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s attached to the parent &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloop&#34;&gt;&lt;code&gt;EventLoop&lt;/code&gt;&lt;/a&gt; will be unable to progress until the blocking call completes.&lt;/p&gt; &#xA;&lt;p&gt;This is a common concern while writing SwiftNIO applications. If it is useful to write code in a blocking style, it is highly recommended that you dispatch work to a different thread when you&#39;re done with it in your pipeline.&lt;/p&gt; &#xA;&lt;h4&gt;Bootstrap&lt;/h4&gt; &#xA;&lt;p&gt;While it is possible to configure and register &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s with &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloop&#34;&gt;&lt;code&gt;EventLoop&lt;/code&gt;&lt;/a&gt;s directly, it is generally more useful to have a higher-level abstraction to handle this work.&lt;/p&gt; &#xA;&lt;p&gt;For this reason, SwiftNIO ships a number of &lt;code&gt;Bootstrap&lt;/code&gt; objects whose purpose is to streamline the creation of channels. Some &lt;code&gt;Bootstrap&lt;/code&gt; objects also provide other functionality, such as support for Happy Eyeballs for making TCP connection attempts.&lt;/p&gt; &#xA;&lt;p&gt;Currently SwiftNIO ships with three &lt;code&gt;Bootstrap&lt;/code&gt; objects in the &lt;code&gt;NIOPosix&lt;/code&gt; module: &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/nioposix/serverbootstrap&#34;&gt;&lt;code&gt;ServerBootstrap&lt;/code&gt;&lt;/a&gt;, for bootstrapping listening channels; &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/nioposix/clientbootstrap&#34;&gt;&lt;code&gt;ClientBootstrap&lt;/code&gt;&lt;/a&gt;, for bootstrapping client TCP channels; and &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/nioposix/datagrambootstrap&#34;&gt;&lt;code&gt;DatagramBootstrap&lt;/code&gt;&lt;/a&gt; for bootstrapping UDP channels.&lt;/p&gt; &#xA;&lt;h4&gt;ByteBuffer&lt;/h4&gt; &#xA;&lt;p&gt;The majority of the work in a SwiftNIO application involves shuffling buffers of bytes around. At the very least, data is sent and received to and from the network in the form of buffers of bytes. For this reason it&#39;s very important to have a high-performance data structure that is optimized for the kind of work SwiftNIO applications perform.&lt;/p&gt; &#xA;&lt;p&gt;For this reason, SwiftNIO provides &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/bytebuffer&#34;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt;, a fast copy-on-write byte buffer that forms a key building block of most SwiftNIO applications. This type is provided by the &lt;code&gt;NIOCore&lt;/code&gt; module.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/bytebuffer&#34;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt; provides a number of useful features, and in addition provides a number of hooks to use it in an &#34;unsafe&#34; mode. This turns off bounds checking for improved performance, at the cost of potentially opening your application up to memory correctness problems.&lt;/p&gt; &#xA;&lt;p&gt;In general, it is highly recommended that you use the &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/bytebuffer&#34;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt; in its safe mode at all times.&lt;/p&gt; &#xA;&lt;p&gt;For more details on the API of &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/bytebuffer&#34;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt;, please see our API documentation, linked below.&lt;/p&gt; &#xA;&lt;h4&gt;Promises and Futures&lt;/h4&gt; &#xA;&lt;p&gt;One major difference between writing concurrent code and writing synchronous code is that not all actions will complete immediately. For example, when you write data on a channel, it is possible that the event loop will not be able to immediately flush that write out to the network. For this reason, SwiftNIO provides &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventlooppromise&#34;&gt;&lt;code&gt;EventLoopPromise&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloopfuture&#34;&gt;&lt;code&gt;EventLoopFuture&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; to manage operations that complete &lt;em&gt;asynchronously&lt;/em&gt;. These types are provided by the &lt;code&gt;NIOCore&lt;/code&gt; module.&lt;/p&gt; &#xA;&lt;p&gt;An &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloopfuture&#34;&gt;&lt;code&gt;EventLoopFuture&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is essentially a container for the return value of a function that will be populated &lt;em&gt;at some time in the future&lt;/em&gt;. Each &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloopfuture&#34;&gt;&lt;code&gt;EventLoopFuture&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; has a corresponding &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventlooppromise&#34;&gt;&lt;code&gt;EventLoopPromise&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, which is the object that the result will be put into. When the promise is succeeded, the future will be fulfilled.&lt;/p&gt; &#xA;&lt;p&gt;If you had to poll the future to detect when it completed that would be quite inefficient, so &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloopfuture&#34;&gt;&lt;code&gt;EventLoopFuture&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is designed to have managed callbacks. Essentially, you can hang callbacks off the future that will be executed when a result is available. The &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloopfuture&#34;&gt;&lt;code&gt;EventLoopFuture&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; will even carefully arrange the scheduling to ensure that these callbacks always execute on the event loop that initially created the promise, which helps ensure that you don&#39;t need too much synchronization around &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloopfuture&#34;&gt;&lt;code&gt;EventLoopFuture&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; callbacks.&lt;/p&gt; &#xA;&lt;p&gt;Another important topic for consideration is the difference between how the promise passed to &lt;code&gt;close&lt;/code&gt; works as opposed to &lt;code&gt;closeFuture&lt;/code&gt; on a &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;. For example, the promise passed into &lt;code&gt;close&lt;/code&gt; will succeed after the &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is closed down but before the &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelpipeline&#34;&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt;&lt;/a&gt; is completely cleared out. This will allow you to take action on the &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelpipeline&#34;&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt;&lt;/a&gt; before it is completely cleared out, if needed. If it is desired to wait for the &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channel&#34;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; to close down and the &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/channelpipeline&#34;&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt;&lt;/a&gt; to be cleared out without any further action, then the better option would be to wait for the &lt;code&gt;closeFuture&lt;/code&gt; to succeed.&lt;/p&gt; &#xA;&lt;p&gt;There are several functions for applying callbacks to &lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/niocore/eventloopfuture&#34;&gt;&lt;code&gt;EventLoopFuture&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, depending on how and when you want them to execute. Details of these functions is left to the API documentation.&lt;/p&gt; &#xA;&lt;h3&gt;Design Philosophy&lt;/h3&gt; &#xA;&lt;p&gt;SwiftNIO is designed to be a powerful tool for building networked applications and frameworks, but it is not intended to be the perfect solution for all levels of abstraction. SwiftNIO is tightly focused on providing the basic I/O primitives and protocol implementations at low levels of abstraction, leaving more expressive but slower abstractions to the wider community to build. The intention is that SwiftNIO will be a building block for server-side applications, not necessarily the framework those applications will use directly.&lt;/p&gt; &#xA;&lt;p&gt;Applications that need extremely high performance from their networking stack may choose to use SwiftNIO directly in order to reduce the overhead of their abstractions. These applications should be able to maintain extremely high performance with relatively little maintenance cost. SwiftNIO also focuses on providing useful abstractions for this use-case, such that extremely high performance network servers can be built directly.&lt;/p&gt; &#xA;&lt;p&gt;The core SwiftNIO repository will contain a few extremely important protocol implementations, such as HTTP, directly in tree. However, we believe that most protocol implementations should be decoupled from the release cycle of the underlying networking stack, as the release cadence is likely to be very different (either much faster or much slower). For this reason, we actively encourage the community to develop and maintain their protocol implementations out-of-tree. Indeed, some first-party SwiftNIO protocol implementations, including our TLS and HTTP/2 bindings, are developed out-of-tree!&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://swiftpackageindex.com/apple/swift-nio/main/documentation/nio&#34;&gt;API documentation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example Usage&lt;/h2&gt; &#xA;&lt;p&gt;There are currently several example projects that demonstrate how to use SwiftNIO.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;chat client&lt;/strong&gt; &lt;a href=&#34;https://github.com/apple/swift-nio/tree/main/Sources/NIOChatClient&#34;&gt;https://github.com/apple/swift-nio/tree/main/Sources/NIOChatClient&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;chat server&lt;/strong&gt; &lt;a href=&#34;https://github.com/apple/swift-nio/tree/main/Sources/NIOChatServer&#34;&gt;https://github.com/apple/swift-nio/tree/main/Sources/NIOChatServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;echo client&lt;/strong&gt; &lt;a href=&#34;https://github.com/apple/swift-nio/tree/main/Sources/NIOEchoClient&#34;&gt;https://github.com/apple/swift-nio/tree/main/Sources/NIOEchoClient&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;echo server&lt;/strong&gt; &lt;a href=&#34;https://github.com/apple/swift-nio/tree/main/Sources/NIOEchoServer&#34;&gt;https://github.com/apple/swift-nio/tree/main/Sources/NIOEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;UDP echo client&lt;/strong&gt; &lt;a href=&#34;https://github.com/apple/swift-nio/tree/main/Sources/NIOUDPEchoClient&#34;&gt;https://github.com/apple/swift-nio/tree/main/Sources/NIOUDPEchoClient&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;UDP echo server&lt;/strong&gt; &lt;a href=&#34;https://github.com/apple/swift-nio/tree/main/Sources/NIOUDPEchoServer&#34;&gt;https://github.com/apple/swift-nio/tree/main/Sources/NIOUDPEchoServer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;HTTP client&lt;/strong&gt; &lt;a href=&#34;https://github.com/apple/swift-nio/tree/main/Sources/NIOHTTP1Client&#34;&gt;https://github.com/apple/swift-nio/tree/main/Sources/NIOHTTP1Client&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;HTTP server&lt;/strong&gt; &lt;a href=&#34;https://github.com/apple/swift-nio/tree/main/Sources/NIOHTTP1Server&#34;&gt;https://github.com/apple/swift-nio/tree/main/Sources/NIOHTTP1Server&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;WebSocket client&lt;/strong&gt; &lt;a href=&#34;https://github.com/apple/swift-nio/tree/main/Sources/NIOWebSocketClient&#34;&gt;https://github.com/apple/swift-nio/tree/main/Sources/NIOWebSocketClient&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;WebSocket server&lt;/strong&gt; &lt;a href=&#34;https://github.com/apple/swift-nio/tree/main/Sources/NIOWebSocketServer&#34;&gt;https://github.com/apple/swift-nio/tree/main/Sources/NIOWebSocketServer&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To build &amp;amp; run them, run following command, replace TARGET_NAME with the folder name under &lt;code&gt;./Sources&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;swift run TARGET_NAME&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example, to run NIOHTTP1Server, run following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;swift run NIOHTTP1Server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;SwiftNIO primarily uses &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;SwiftPM&lt;/a&gt; as its build tool, so we recommend using that as well. If you want to depend on SwiftNIO in your own project, it&#39;s as simple as adding a &lt;code&gt;dependencies&lt;/code&gt; clause to your &lt;code&gt;Package.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/apple/swift-nio.git&#34;, from: &#34;2.0.0&#34;)&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and then adding the appropriate SwiftNIO module(s) to your target dependencies. The syntax for adding target dependencies differs slightly between Swift versions. For example, if you want to depend on the &lt;code&gt;NIOCore&lt;/code&gt;, &lt;code&gt;NIOPosix&lt;/code&gt; and &lt;code&gt;NIOHTTP1&lt;/code&gt; modules, specify the following dependencies:&lt;/p&gt; &#xA;&lt;h4&gt;Swift 5.4 and newer (&lt;code&gt;swift-tools-version:5.4&lt;/code&gt;)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;dependencies: [.product(name: &#34;NIOCore&#34;, package: &#34;swift-nio&#34;),&#xA;               .product(name: &#34;NIOPosix&#34;, package: &#34;swift-nio&#34;),&#xA;               .product(name: &#34;NIOHTTP1&#34;, package: &#34;swift-nio&#34;)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using Xcode Package support&lt;/h3&gt; &#xA;&lt;p&gt;If your project is set up as an Xcode project and you&#39;re using Xcode 11+, you can add SwiftNIO as a dependency to your Xcode project by clicking File -&amp;gt; Swift Packages -&amp;gt; Add Package Dependency. In the upcoming dialog, please enter &lt;code&gt;https://github.com/apple/swift-nio.git&lt;/code&gt; and click Next twice. Finally, select the targets you are planning to use (for example &lt;code&gt;NIOCore&lt;/code&gt;, &lt;code&gt;NIOHTTP1&lt;/code&gt;, and &lt;code&gt;NIOFoundationCompat&lt;/code&gt;) and click finish. Now will be able to &lt;code&gt;import NIOCore&lt;/code&gt; (as well as all the other targets you have selected) in your project.&lt;/p&gt; &#xA;&lt;p&gt;To work on SwiftNIO itself, or to investigate some of the demonstration applications, you can clone the repository directly and use SwiftPM to help build it. For example, you can run the following commands to compile and run the example echo server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;swift build&#xA;swift test&#xA;swift run NIOEchoServer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To verify that it is working, you can use another shell to attempt to connect to it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#34;Hello SwiftNIO&#34; | nc localhost 9999&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If all goes well, you&#39;ll see the message echoed back to you.&lt;/p&gt; &#xA;&lt;p&gt;To work on SwiftNIO in Xcode, you can just open the &lt;code&gt;Package.swift&lt;/code&gt; file in Xcode and use Xcode&#39;s support for SwiftPM Packages.&lt;/p&gt; &#xA;&lt;h3&gt;An alternative: using &lt;code&gt;docker-compose&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Alternatively, you may want to develop or test with &lt;code&gt;docker-compose&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;First make sure you have &lt;a href=&#34;https://www.docker.com/community-edition&#34;&gt;Docker&lt;/a&gt; installed, next run the following commands:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;docker-compose -f docker/docker-compose.yaml run test&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Will create a base image with Swift runtime and other build and test dependencies, compile SwiftNIO and run the unit and integration tests&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;docker-compose -f docker/docker-compose.yaml up echo&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Will create a base image, compile SwiftNIO, and run a sample &lt;code&gt;NIOEchoServer&lt;/code&gt; on &lt;code&gt;localhost:9999&lt;/code&gt;. Test it by &lt;code&gt;echo Hello SwiftNIO | nc localhost 9999&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;docker-compose -f docker/docker-compose.yaml up http&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Will create a base image, compile SwiftNIO, and run a sample &lt;code&gt;NIOHTTP1Server&lt;/code&gt; on &lt;code&gt;localhost:8888&lt;/code&gt;. Test it by &lt;code&gt;curl http://localhost:8888&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;docker-compose -f docker/docker-compose.yaml -f docker/docker-compose.2204.57.yaml run test&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Will create a base image using Ubuntu 22.04 and Swift 5.7, compile SwiftNIO and run the unit and integration tests. Files exist for other ubuntu and swift versions in the docker directory.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Developing SwiftNIO&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: This section is only relevant if you would like to develop SwiftNIO yourself. You can ignore the information here if you just want to use SwiftNIO as a SwiftPM package.&lt;/p&gt; &#xA;&lt;p&gt;For the most part, SwiftNIO development is as straightforward as any other SwiftPM project. With that said, we do have a few processes that are worth understanding before you contribute. For details, please see &lt;code&gt;CONTRIBUTING.md&lt;/code&gt; in this repository.&lt;/p&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;p&gt;SwiftNIO&#39;s &lt;code&gt;main&lt;/code&gt; branch is the development branch for the next releases of SwiftNIO 2, it&#39;s Swift 5-only.&lt;/p&gt; &#xA;&lt;p&gt;To be able to compile and run SwiftNIO and the integration tests, you need to have a few prerequisites installed on your system.&lt;/p&gt; &#xA;&lt;h4&gt;macOS&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Xcode 11.4 or newer, Xcode 12 recommended.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Linux&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift 5.6 or newer from &lt;a href=&#34;https://swift.org/download/#releases&#34;&gt;swift.org/download&lt;/a&gt;. We always recommend to use the latest released version.&lt;/li&gt; &#xA; &lt;li&gt;netcat (for integration tests only)&lt;/li&gt; &#xA; &lt;li&gt;lsof (for integration tests only)&lt;/li&gt; &#xA; &lt;li&gt;shasum (for integration tests only)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Ubuntu 18.04&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;# install swift tarball from https://swift.org/downloads&#xA;apt-get install -y git curl libatomic1 libxml2 netcat-openbsd lsof perl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fedora 28+&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;dnf install swift-lang /usr/bin/nc /usr/bin/lsof /usr/bin/shasum&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>