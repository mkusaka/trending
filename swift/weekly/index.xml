<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-16T02:06:07Z</updated>
  <subtitle>Weekly Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>leetcode-mafia/cheetah</title>
    <updated>2023-04-16T02:06:07Z</updated>
    <id>tag:github.com,2023-04-16:/leetcode-mafia/cheetah</id>
    <link href="https://github.com/leetcode-mafia/cheetah" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Whisper &amp; GPT-based app for passing remote SWE interviews&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cheetah&lt;/h1&gt; &#xA;&lt;p&gt;Cheetah is an AI-powered macOS app designed to assist users during remote software engineering interviews by providing real-time, discreet coaching and live coding platform integration.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/106342593/229961889-489e2b36-f3e6-453a-9784-f160bc1c4f8d.mp4&#34;&gt;Quick demo video (1:28)&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;https://github.com/leetcode-mafia/cheetah/raw/91cc5b89864fe28476a7e2062ede2c8322c17896/cheetah.jpg&#34; alt=&#34;Screenshot&#34;&gt; &#xA;&lt;p&gt;With Cheetah, you can improve your interview performance and increase your chances of landing that $300k SWE job, without spending your weekends cramming leetcode challenges and memorizing algorithms you&#39;ll never use.&lt;/p&gt; &#xA;&lt;h2&gt;How it works&lt;/h2&gt; &#xA;&lt;p&gt;Cheetah leverages Whisper for real-time audio transcription and GPT-4 for generating hints and solutions. You need to have your own OpenAI API key to use the app. If you don&#39;t have access to GPT-4, gpt-3.5-turbo may be used as an alternative.&lt;/p&gt; &#xA;&lt;p&gt;Whisper runs locally on your system, utilizing Georgi Gerganov&#39;s &lt;a href=&#34;https://github.com/ggerganov/whisper.cpp&#34;&gt;whisper.cpp&lt;/a&gt;. A recent M1 or M2 Mac is required for optimal performance.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;h3&gt;Audio driver setup&lt;/h3&gt; &#xA;&lt;p&gt;For the best results, ensure the audio input captures both sides of the conversation.&lt;/p&gt; &#xA;&lt;p&gt;When using a video chat app like Zoom or Google Meet, you can achieve this with &lt;a href=&#34;https://existential.audio/blackhole/&#34;&gt;BlackHole&lt;/a&gt;, a free audio loopback driver. Follow the instructions for setting up a &lt;a href=&#34;https://github.com/ExistentialAudio/BlackHole/wiki/Multi-Output-Device&#34;&gt;Multi-Output Device&lt;/a&gt;, and remember not to use the loopback device as input for the video chat app.&lt;/p&gt; &#xA;&lt;h3&gt;App overview&lt;/h3&gt; &#xA;&lt;p&gt;Open the app and select an audio input to start live transcription. A snippet of the transcription will be displayed under the audio input selector.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; running the app in debug mode will result in very slow audio transcription performance.&lt;/p&gt; &#xA;&lt;p&gt;The UI features three buttons:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Generates an answer for the interviewer&#39;s question.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Refine:&lt;/strong&gt; Updates the existing answer, useful for when the interviewer provides additional constraints or clarification.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Analyze:&lt;/strong&gt; Analyzes code and logs from the live coding environment in your web browser. Requires the browser extension.&lt;/p&gt; &#xA;&lt;p&gt;You can also select (highlight) a portion of a generated answer and click Refine to get more detail.&lt;/p&gt; &#xA;&lt;h3&gt;Installing the browser extension&lt;/h3&gt; &#xA;&lt;p&gt;Currently, only Firefox is supported. Follow these steps to install the extension:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add the domain of the live coding platform to &lt;code&gt;matches&lt;/code&gt; in ./extension/manifest.json&lt;/li&gt; &#xA; &lt;li&gt;Go to &lt;a href=&#34;https://firefox-source-docs.mozilla.org/devtools-user/about_colon_debugging/index.html&#34;&gt;about:debugging&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Click &#34;This Firefox&#34;&lt;/li&gt; &#xA; &lt;li&gt;Click &#34;Load Temporary Add-on&#34;&lt;/li&gt; &#xA; &lt;li&gt;Select ./extension/manifest.json&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;Cheetah is a satirical art project and is not intended for use in real-world settings. It may generate incorrect or inappropriate solutions. Users should exercise caution and take responsibility for the information provided by the app.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>scinfu/SwiftSoup</title>
    <updated>2023-04-16T02:06:07Z</updated>
    <id>tag:github.com,2023-04-16:/scinfu/SwiftSoup</id>
    <link href="https://github.com/scinfu/SwiftSoup" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SwiftSoup: Pure Swift HTML Parser, with best of DOM, CSS, and jquery (Supports Linux, iOS, Mac, tvOS, watchOS)&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/scinfu/SwiftSoup/master/swiftsoup.png&#34; alt=&#34;SwiftSoup&#34; title=&#34;SwiftSoup&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/platform-Linux%20%7C%20OS%20X%20%7C%20iOS%20%7C%20tvOS%20%7C%20watchOS-orange.svg?sanitize=true&#34; alt=&#34;Platform OS X | iOS | tvOS | watchOS | Linux&#34;&gt; &lt;a href=&#34;https://github.com/apple/swift-package-manager&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/SPM-compatible-4BC51D.svg?style=flat&#34; alt=&#34;SPM compatible&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/badge/%F0%9F%90%A7%20linux-ready-red.svg?sanitize=true&#34; alt=&#34;üêß linux: ready&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt; &lt;a href=&#34;https://travis-ci.org/scinfu/SwiftSoup&#34;&gt;&lt;img src=&#34;https://travis-ci.org/scinfu/SwiftSoup.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoapods.org/pods/SwiftSoup&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/SwiftSoup.svg?style=flat&#34; alt=&#34;Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoapods.org/pods/SwiftSoup&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/l/SwiftSoup.svg?style=flat&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://twitter.com/scinfu&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/twitter-@scinfu-blue.svg?style=flat&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;SwiftSoup&lt;/code&gt; is a pure Swift library, cross-platform (macOS, iOS, tvOS, watchOS and Linux!), for working with real-world HTML. It provides a very convenient API for extracting and manipulating data, using the best of DOM, CSS, and jQuery-like methods. &lt;code&gt;SwiftSoup&lt;/code&gt; implements the WHATWG HTML5 specification, and parses HTML to the same DOM as modern browsers do.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Scrape and parse HTML from a URL, file, or string&lt;/li&gt; &#xA; &lt;li&gt;Find and extract data, using DOM traversal or CSS selectors&lt;/li&gt; &#xA; &lt;li&gt;Manipulate the HTML elements, attributes, and text&lt;/li&gt; &#xA; &lt;li&gt;Clean user-submitted content against a safe white-list, to prevent XSS attacks&lt;/li&gt; &#xA; &lt;li&gt;Output tidy HTML &lt;code&gt;SwiftSoup&lt;/code&gt; is designed to deal with all varieties of HTML found in the wild; from pristine and validating, to invalid tag-soup; &lt;code&gt;SwiftSoup&lt;/code&gt; will create a sensible parse tree.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Swift&lt;/h2&gt; &#xA;&lt;p&gt;Swift 5 &lt;code&gt;&amp;gt;=2.0.0&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Swift 4.2 &lt;code&gt;1.7.4&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Cocoapods&lt;/h3&gt; &#xA;&lt;p&gt;SwiftSoup is available through &lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt;. To install it, simply add the following line to your Podfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;SwiftSoup&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;p&gt;SwiftSoup is also available through &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;. To install it, simply add the following line to your Cartfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;github &#34;scinfu/SwiftSoup&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;SwiftSoup is also available through &lt;a href=&#34;https://github.com/apple/swift-package-manager&#34;&gt;Swift Package Manager&lt;/a&gt;. To install it, simply add the dependency to your Package.Swift file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;...&#xA;dependencies: [&#xA;    .package(url: &#34;https://github.com/scinfu/SwiftSoup.git&#34;, from: &#34;2.5.3&#34;),&#xA;],&#xA;targets: [&#xA;    .target( name: &#34;YourTarget&#34;, dependencies: [&#34;SwiftSoup&#34;]),&#xA;]&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Try&lt;/h2&gt; &#xA;&lt;h3&gt;Try out the simple online CSS selectors site:&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://swiftsoup.herokuapp.com/&#34;&gt;SwiftSoup Test Site&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Try out the example project opening Terminal and type:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pod try SwiftSoup&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/scinfu/SwiftSoup/master/Example/img1.png&#34; alt=&#34;SwiftSoup&#34; title=&#34;SwiftSoup&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/scinfu/SwiftSoup/master/Example/img2.png&#34; alt=&#34;SwiftSoup&#34; title=&#34;SwiftSoup&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;To parse an HTML document:&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;   let html = &#34;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;First parse&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&#34;&#xA;       + &#34;&amp;lt;body&amp;gt;&amp;lt;p&amp;gt;Parsed HTML into a doc.&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#34;&#xA;   let doc: Document = try SwiftSoup.parse(html)&#xA;   return try doc.text()&#xA;} catch Exception.Error(let type, let message) {&#xA;    print(message)&#xA;} catch {&#xA;    print(&#34;error&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Unclosed tags (e.g. &lt;code&gt;&amp;lt;p&amp;gt;Lorem &amp;lt;p&amp;gt;Ipsum&lt;/code&gt; parses to &lt;code&gt;&amp;lt;p&amp;gt;Lorem&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;Ipsum&amp;lt;/p&amp;gt;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Implicit tags (e.g. a naked &lt;code&gt;&amp;lt;td&amp;gt;Table data&amp;lt;/td&amp;gt;&lt;/code&gt; is wrapped into a &lt;code&gt;&amp;lt;table&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;...&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Reliably creating the document structure (&lt;code&gt;html&lt;/code&gt; containing a &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt;, and only appropriate elements within the head)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;The object model of a document&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Documents consist of Elements and TextNodes&lt;/li&gt; &#xA; &lt;li&gt;The inheritance chain is: &lt;code&gt;Document&lt;/code&gt; extends &lt;code&gt;Element&lt;/code&gt; extends &lt;code&gt;Node.TextNode&lt;/code&gt; extends &lt;code&gt;Node&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;An Element contains a list of children Nodes, and has one parent Element. They also have provide a filtered list of child Elements only.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Extract attributes, text, and HTML from elements&lt;/h1&gt; &#xA;&lt;h3&gt;Problem&lt;/h3&gt; &#xA;&lt;p&gt;After parsing a document, and finding some elements, you&#39;ll want to get at the data inside those elements.&lt;/p&gt; &#xA;&lt;h3&gt;Solution&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To get the value of an attribute, use the &lt;code&gt;Node.attr(_ String key)&lt;/code&gt; method&lt;/li&gt; &#xA; &lt;li&gt;For the text on an element (and its combined children), use &lt;code&gt;Element.text()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;For HTML, use &lt;code&gt;Element.html()&lt;/code&gt;, or &lt;code&gt;Node.outerHtml()&lt;/code&gt; as appropriate&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    let html: String = &#34;&amp;lt;p&amp;gt;An &amp;lt;a href=&#39;http://example.com/&#39;&amp;gt;&amp;lt;b&amp;gt;example&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt; link.&amp;lt;/p&amp;gt;&#34;&#xA;    let doc: Document = try SwiftSoup.parse(html)&#xA;    let link: Element = try doc.select(&#34;a&#34;).first()!&#xA;    &#xA;    let text: String = try doc.body()!.text() // &#34;An example link.&#34;&#xA;    let linkHref: String = try link.attr(&#34;href&#34;) // &#34;http://example.com/&#34;&#xA;    let linkText: String = try link.text() // &#34;example&#34;&#xA;    &#xA;    let linkOuterH: String = try link.outerHtml() // &#34;&amp;lt;a href=&#34;http://example.com/&#34;&amp;gt;&amp;lt;b&amp;gt;example&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt;&#34;&#xA;    let linkInnerH: String = try link.html() // &#34;&amp;lt;b&amp;gt;example&amp;lt;/b&amp;gt;&#34;&#xA;} catch Exception.Error(let type, let message) {&#xA;    print(message)&#xA;} catch {&#xA;    print(&#34;error&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Description&lt;/h3&gt; &#xA;&lt;p&gt;The methods above are the core of the element data access methods. There are additional others:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Element.id()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Element.tagName()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Element.className()&lt;/code&gt; and &lt;code&gt;Element.hasClass(_ String className)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All of these accessor methods have corresponding setter methods to change the data.&lt;/p&gt; &#xA;&lt;h1&gt;Parse a document from a String&lt;/h1&gt; &#xA;&lt;h3&gt;Problem&lt;/h3&gt; &#xA;&lt;p&gt;You have HTML in a Swift String, and you want to parse that HTML to get at its contents, or to make sure it&#39;s well formed, or to modify it. The String may have come from user input, a file, or from the web.&lt;/p&gt; &#xA;&lt;h3&gt;Solution&lt;/h3&gt; &#xA;&lt;p&gt;Use the static &lt;code&gt;SwiftSoup.parse(_ html: String)&lt;/code&gt; method, or &lt;code&gt;SwiftSoup.parse(_ html: String, _ baseUri: String)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    let html = &#34;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;First parse&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&#34;&#xA;        + &#34;&amp;lt;body&amp;gt;&amp;lt;p&amp;gt;Parsed HTML into a doc.&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#34;&#xA;    let doc: Document = try SwiftSoup.parse(html)&#xA;    return try doc.text()&#xA;} catch Exception.Error(let type, let message) {&#xA;    print(&#34;&#34;)&#xA;} catch {&#xA;    print(&#34;&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Description&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;parse(_ html: String, _ baseUri: String)&lt;/code&gt; method parses the input HTML into a new &lt;code&gt;Document&lt;/code&gt;. The base URI argument is used to resolve relative URLs into absolute URLs, and should be set to the URL where the document was fetched from. If that&#39;s not applicable, or if you know the HTML has a base element, you can use the &lt;code&gt;parse(_ html: String)&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;As long as you pass in a non-null string, you&#39;re guaranteed to have a successful, sensible parse, with a Document containing (at least) a &lt;code&gt;head&lt;/code&gt; and a &lt;code&gt;body&lt;/code&gt; element.&lt;/p&gt; &#xA;&lt;p&gt;Once you have a &lt;code&gt;Document&lt;/code&gt;, you can get at the data using the appropriate methods in &lt;code&gt;Document&lt;/code&gt; and its supers &lt;code&gt;Element&lt;/code&gt; and &lt;code&gt;Node&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Parsing a body fragment&lt;/h1&gt; &#xA;&lt;h3&gt;Problem&lt;/h3&gt; &#xA;&lt;p&gt;You have a fragment of body HTML (e.g. &lt;code&gt;div&lt;/code&gt; containing a couple of p tags; as opposed to a full HTML document) that you want to parse. Perhaps it was provided by a user submitting a comment, or editing the body of a page in a CMS.&lt;/p&gt; &#xA;&lt;h3&gt;Solution&lt;/h3&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;SwiftSoup.parseBodyFragment(_ html: String)&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    let html: String = &#34;&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;Lorem ipsum.&amp;lt;/p&amp;gt;&#34;&#xA;    let doc: Document = try SwiftSoup.parseBodyFragment(html)&#xA;    let body: Element? = doc.body()&#xA;} catch Exception.Error(let type, let message) {&#xA;    print(message)&#xA;} catch {&#xA;    print(&#34;error&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Description&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;parseBodyFragment&lt;/code&gt; method creates an empty shell document, and inserts the parsed HTML into the &lt;code&gt;body&lt;/code&gt; element. If you used the normal &lt;code&gt;SwiftSoup(_ html: String)&lt;/code&gt; method, you would generally get the same result, but explicitly treating the input as a body fragment ensures that any bozo HTML provided by the user is parsed into the &lt;code&gt;body&lt;/code&gt; element.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Document.body()&lt;/code&gt; method retrieves the element children of the document&#39;s &lt;code&gt;body&lt;/code&gt; element; it is equivalent to &lt;code&gt;doc.getElementsByTag(&#34;body&#34;)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Stay safe&lt;/h3&gt; &#xA;&lt;p&gt;If you are going to accept HTML input from a user, you need to be careful to avoid cross-site scripting attacks. See the documentation for the &lt;code&gt;Whitelist&lt;/code&gt; based cleaner, and clean the input with &lt;code&gt;clean(String bodyHtml, Whitelist whitelist)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Sanitize untrusted HTML (to prevent XSS)&lt;/h1&gt; &#xA;&lt;h3&gt;Problem&lt;/h3&gt; &#xA;&lt;p&gt;You want to allow untrusted users to supply HTML for output on your website (e.g. as comment submission). You need to clean this HTML to avoid &lt;a href=&#34;https://en.wikipedia.org/wiki/Cross-site_scripting&#34;&gt;cross-site scripting&lt;/a&gt; (XSS) attacks.&lt;/p&gt; &#xA;&lt;h3&gt;Solution&lt;/h3&gt; &#xA;&lt;p&gt;Use the SwiftSoup HTML &lt;code&gt;Cleaner&lt;/code&gt; with a configuration specified by a &lt;code&gt;Whitelist&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    let unsafe: String = &#34;&amp;lt;p&amp;gt;&amp;lt;a href=&#39;http://example.com/&#39; onclick=&#39;stealCookies()&#39;&amp;gt;Link&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&#34;&#xA;    let safe: String = try SwiftSoup.clean(unsafe, Whitelist.basic())!&#xA;    // now: &amp;lt;p&amp;gt;&amp;lt;a href=&#34;http://example.com/&#34; rel=&#34;nofollow&#34;&amp;gt;Link&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&#xA;} catch Exception.Error(let type, let message) {&#xA;    print(message)&#xA;} catch {&#xA;    print(&#34;error&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Discussion&lt;/h3&gt; &#xA;&lt;p&gt;A cross-site scripting attack against your site can really ruin your day, not to mention your users&#39;. Many sites avoid XSS attacks by not allowing HTML in user submitted content: they enforce plain text only, or use an alternative markup syntax like wiki-text or Markdown. These are seldom optimal solutions for the user, as they lower expressiveness, and force the user to learn a new syntax.&lt;/p&gt; &#xA;&lt;p&gt;A better solution may be to use a rich text WYSIWYG editor (like &lt;a href=&#34;http://ckeditor.com&#34;&gt;CKEditor&lt;/a&gt; or &lt;a href=&#34;https://www.tinymce.com&#34;&gt;TinyMCE&lt;/a&gt;). These output HTML, and allow the user to work visually. However, their validation is done on the client side: you need to apply a server-side validation to clean up the input and ensure the HTML is safe to place on your site. Otherwise, an attacker can avoid the client-side Javascript validation and inject unsafe HMTL directly into your site&lt;/p&gt; &#xA;&lt;p&gt;The SwiftSoup whitelist sanitizer works by parsing the input HTML (in a safe, sand-boxed environment), and then iterating through the parse tree and only allowing known-safe tags and attributes (and values) through into the cleaned output.&lt;/p&gt; &#xA;&lt;p&gt;It does not use regular expressions, which are inappropriate for this task.&lt;/p&gt; &#xA;&lt;p&gt;SwiftSoup provides a range of &lt;code&gt;Whitelist&lt;/code&gt; configurations to suit most requirements; they can be modified if necessary, but take care.&lt;/p&gt; &#xA;&lt;p&gt;The cleaner is useful not only for avoiding XSS, but also in limiting the range of elements the user can provide: you may be OK with textual &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;strong&lt;/code&gt; elements, but not structural &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;table&lt;/code&gt; elements.&lt;/p&gt; &#xA;&lt;h3&gt;See also&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;See the &lt;a href=&#34;http://ha.ckers.org/xss.html&#34;&gt;XSS cheat sheet&lt;/a&gt; and filter evasion guide, as an example of how regular-expression filters don&#39;t work, and why a safe whitelist parser-based sanitizer is the correct approach.&lt;/li&gt; &#xA; &lt;li&gt;See the &lt;code&gt;Cleaner&lt;/code&gt; reference if you want to get a &lt;code&gt;Document&lt;/code&gt; instead of a String return&lt;/li&gt; &#xA; &lt;li&gt;See the &lt;code&gt;Whitelist&lt;/code&gt; reference for the different canned options, and to create a custom whitelist&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://en.wikipedia.org/wiki/Nofollow&#34;&gt;nofollow&lt;/a&gt; link attribute&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Set attribute values&lt;/h1&gt; &#xA;&lt;h3&gt;Problem&lt;/h3&gt; &#xA;&lt;p&gt;You have a parsed document that you would like to update attribute values on, before saving it out to disk, or sending it on as a HTTP response.&lt;/p&gt; &#xA;&lt;h3&gt;Solution&lt;/h3&gt; &#xA;&lt;p&gt;Use the attribute setter methods &lt;code&gt;Element.attr(_ key: String, _ value: String)&lt;/code&gt;, and &lt;code&gt;Elements.attr(_ key: String, _ value: String)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you need to modify the class attribute of an element, use the &lt;code&gt;Element.addClass(_ className: String)&lt;/code&gt; and &lt;code&gt;Element.removeClass(_ className: String)&lt;/code&gt; methods.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Elements&lt;/code&gt; collection has bulk attribute and class methods. For example, to add a &lt;code&gt;rel=&#34;nofollow&#34;&lt;/code&gt; attribute to every &lt;code&gt;a&lt;/code&gt; element inside a div:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    try doc.select(&#34;div.comments a&#34;).attr(&#34;rel&#34;, &#34;nofollow&#34;)&#xA;} catch Exception.Error(let type, let message) {&#xA;    print(message)&#xA;} catch {&#xA;    print(&#34;error&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Description&lt;/h3&gt; &#xA;&lt;p&gt;Like the other methods in &lt;code&gt;Element&lt;/code&gt;, the attr methods return the current &lt;code&gt;Element&lt;/code&gt; (or &lt;code&gt;Elements&lt;/code&gt; when working on a collection from a select). This allows convenient method chaining:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    try doc.select(&#34;div.masthead&#34;).attr(&#34;title&#34;, &#34;swiftsoup&#34;).addClass(&#34;round-box&#34;)&#xA;} catch Exception.Error(let type, let message) {&#xA;    print(message)&#xA;} catch {&#xA;    print(&#34;error&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Set the HTML of an element&lt;/h1&gt; &#xA;&lt;h3&gt;Problem&lt;/h3&gt; &#xA;&lt;p&gt;You need to modify the HTML of an element.&lt;/p&gt; &#xA;&lt;h3&gt;Solution&lt;/h3&gt; &#xA;&lt;p&gt;Use the HTML setter methods in &lt;code&gt;Element&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    let doc: Document = try SwiftSoup.parse(&#34;&amp;lt;div&amp;gt;One&amp;lt;/div&amp;gt;&amp;lt;span&amp;gt;One&amp;lt;/span&amp;gt;&#34;)&#xA;    let div: Element = try doc.select(&#34;div&#34;).first()! // &amp;lt;div&amp;gt;One&amp;lt;/div&amp;gt;&#xA;    try div.html(&#34;&amp;lt;p&amp;gt;lorem ipsum&amp;lt;/p&amp;gt;&#34;) // &amp;lt;div&amp;gt;&amp;lt;p&amp;gt;lorem ipsum&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&#xA;    try div.prepend(&#34;&amp;lt;p&amp;gt;First&amp;lt;/p&amp;gt;&#34;)&#xA;    try div.append(&#34;&amp;lt;p&amp;gt;Last&amp;lt;/p&amp;gt;&#34;)&#xA;    print(div)&#xA;    // now div is: &amp;lt;div&amp;gt;&amp;lt;p&amp;gt;First&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;lorem ipsum&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;Last&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&#xA;    &#xA;    let span: Element = try doc.select(&#34;span&#34;).first()! // &amp;lt;span&amp;gt;One&amp;lt;/span&amp;gt;&#xA;    try span.wrap(&#34;&amp;lt;li&amp;gt;&amp;lt;a href=&#39;http://example.com/&#39;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#34;)&#xA;    print(doc)&#xA;    // now: &amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;First&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;lorem ipsum&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;Last&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;li&amp;gt;&amp;lt;a href=&#34;http://example.com/&#34;&amp;gt;&amp;lt;span&amp;gt;One&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#xA;} catch Exception.Error(let type, let message) {&#xA;    print(message)&#xA;} catch {&#xA;    print(&#34;error&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Discussion&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Element.html(_ html: String)&lt;/code&gt; clears any existing inner HTML in an element, and replaces it with parsed HTML.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Element.prepend(_ first: String)&lt;/code&gt; and &lt;code&gt;Element.append(_ last: String)&lt;/code&gt; add HTML to the start or end of an element&#39;s inner HTML, respectively&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Element.wrap(_ around: String)&lt;/code&gt; wraps HTML around the outer HTML of an element.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;See also&lt;/h3&gt; &#xA;&lt;p&gt;You can also use the &lt;code&gt;Element.prependElement(_ tag: String)&lt;/code&gt; and &lt;code&gt;Element.appendElement(_ tag: String)&lt;/code&gt; methods to create new elements and insert them into the document flow as a child element.&lt;/p&gt; &#xA;&lt;h1&gt;Setting the text content of elements&lt;/h1&gt; &#xA;&lt;h3&gt;Problem&lt;/h3&gt; &#xA;&lt;p&gt;You need to modify the text content of an HTML document.&lt;/p&gt; &#xA;&lt;h1&gt;Solution&lt;/h1&gt; &#xA;&lt;p&gt;Use the text setter methods of &lt;code&gt;Element&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    let doc: Document = try SwiftSoup.parse(&#34;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&#34;)&#xA;    let div: Element = try doc.select(&#34;div&#34;).first()! // &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&#xA;    try div.text(&#34;five &amp;gt; four&#34;) // &amp;lt;div&amp;gt;five &amp;amp;gt; four&amp;lt;/div&amp;gt;&#xA;    try div.prepend(&#34;First &#34;)&#xA;    try div.append(&#34; Last&#34;)&#xA;    // now: &amp;lt;div&amp;gt;First five &amp;amp;gt; four Last&amp;lt;/div&amp;gt;&#xA;} catch Exception.Error(let type, let message) {&#xA;    print(message)&#xA;} catch {&#xA;    print(&#34;error&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Discussion&lt;/h3&gt; &#xA;&lt;p&gt;The text setter methods mirror the [[HTML setter|Set the HTML of an element]] methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Element.text(_ text: String)&lt;/code&gt; clears any existing inner HTML in an element, and replaces it with the supplied text.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Element.prepend(_ first: String)&lt;/code&gt; and &lt;code&gt;Element.append(_ last: String)&lt;/code&gt; add text nodes to the start or end of an element&#39;s inner HTML, respectively The text should be supplied unencoded: characters like &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; etc will be treated as literals, not HTML.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Use DOM methods to navigate a document&lt;/h1&gt; &#xA;&lt;h3&gt;Problem&lt;/h3&gt; &#xA;&lt;p&gt;You have a HTML document that you want to extract data from. You know generally the structure of the HTML document.&lt;/p&gt; &#xA;&lt;h3&gt;Solution&lt;/h3&gt; &#xA;&lt;p&gt;Use the DOM-like methods available after parsing HTML into a &lt;code&gt;Document&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    let html: String = &#34;&amp;lt;a id=1 href=&#39;?foo=bar&amp;amp;mid&amp;amp;lt=true&#39;&amp;gt;One&amp;lt;/a&amp;gt; &amp;lt;a id=2 href=&#39;?foo=bar&amp;amp;lt;qux&amp;amp;lg=1&#39;&amp;gt;Two&amp;lt;/a&amp;gt;&#34;&#xA;    let els: Elements = try SwiftSoup.parse(html).select(&#34;a&#34;)&#xA;    for link: Element in els.array() {&#xA;        let linkHref: String = try link.attr(&#34;href&#34;)&#xA;        let linkText: String = try link.text()&#xA;    }&#xA;} catch Exception.Error(let type, let message) {&#xA;    print(message)&#xA;} catch {&#xA;    print(&#34;error&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Description&lt;/h3&gt; &#xA;&lt;p&gt;Elements provide a range of DOM-like methods to find elements, and extract and manipulate their data. The DOM getters are contextual: called on a parent Document they find matching elements under the document; called on a child element they find elements under that child. In this way you can window in on the data you want.&lt;/p&gt; &#xA;&lt;h3&gt;Finding elements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;getElementById(_ id: String)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;getElementsByTag(_ tag:String)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;getElementsByClass(_ className: String)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;getElementsByAttribute(_ key: String)&lt;/code&gt; (and related methods)&lt;/li&gt; &#xA; &lt;li&gt;Element siblings: &lt;code&gt;siblingElements()&lt;/code&gt;, &lt;code&gt;firstElementSibling()&lt;/code&gt;, &lt;code&gt;lastElementSibling()&lt;/code&gt;, &lt;code&gt;nextElementSibling()&lt;/code&gt;, &lt;code&gt;previousElementSibling()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Graph: &lt;code&gt;parent()&lt;/code&gt;, &lt;code&gt;children()&lt;/code&gt;, &lt;code&gt;child(_ index: Int)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Element data&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;attr(_ key: Strin)&lt;/code&gt; to get and &lt;code&gt;attr(_ key: String, _ value: String)&lt;/code&gt; to set attributes&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;attributes()&lt;/code&gt; to get all attributes&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;id()&lt;/code&gt;, &lt;code&gt;className()&lt;/code&gt; and &lt;code&gt;classNames()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;text()&lt;/code&gt; to get and &lt;code&gt;text(_ value: String)&lt;/code&gt; to set the text content&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;html()&lt;/code&gt; to get and &lt;code&gt;html(_ value: String)&lt;/code&gt; to set the inner HTML content&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;outerHtml()&lt;/code&gt; to get the outer HTML value&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;data()&lt;/code&gt; to get data content (e.g. of script and style tags)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tag()&lt;/code&gt; and &lt;code&gt;tagName()&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Manipulating HTML and text&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;append(_ html: String)&lt;/code&gt;, &lt;code&gt;prepend(html: String)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;appendText(text: String)&lt;/code&gt;, &lt;code&gt;prependText(text: String)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;appendElement(tagName: String)&lt;/code&gt;, &lt;code&gt;prependElement(tagName: String)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;html(_ value: String)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Use selector syntax to find elements&lt;/h1&gt; &#xA;&lt;h3&gt;Problem&lt;/h3&gt; &#xA;&lt;p&gt;You want to find or manipulate elements using a CSS or jQuery-like selector syntax.&lt;/p&gt; &#xA;&lt;h3&gt;Solution&lt;/h3&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;Element.select(_ selector: String)&lt;/code&gt; and &lt;code&gt;Elements.select(_ selector: String)&lt;/code&gt; methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    let doc: Document = try SwiftSoup.parse(&#34;...&#34;)&#xA;    let links: Elements = try doc.select(&#34;a[href]&#34;) // a with href&#xA;    let pngs: Elements = try doc.select(&#34;img[src$=.png]&#34;)&#xA;    // img with src ending .png&#xA;    let masthead: Element? = try doc.select(&#34;div.masthead&#34;).first()&#xA;    // div with class=masthead&#xA;    let resultLinks: Elements? = try doc.select(&#34;h3.r &amp;gt; a&#34;) // direct a after h3&#xA;} catch Exception.Error(let type, let message) {&#xA;    print(message)&#xA;} catch {&#xA;    print(&#34;error&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Description&lt;/h3&gt; &#xA;&lt;p&gt;SwiftSoup elements support a &lt;a href=&#34;https://www.w3.org/TR/2009/PR-css3-selectors-20091215/&#34;&gt;CSS&lt;/a&gt; (or &lt;a href=&#34;http://jquery.com&#34;&gt;jQuery&lt;/a&gt;) like selector syntax to find matching elements, that allows very powerful and robust queries.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;select&lt;/code&gt; method is available in a &lt;code&gt;Document&lt;/code&gt;, &lt;code&gt;Element&lt;/code&gt;, or in &lt;code&gt;Elements&lt;/code&gt;. It is contextual, so you can filter by selecting from a specific element, or by chaining select calls.&lt;/p&gt; &#xA;&lt;p&gt;Select returns a list of &lt;code&gt;Elements&lt;/code&gt; (as &lt;code&gt;Elements&lt;/code&gt;), which provides a range of methods to extract and manipulate the results.&lt;/p&gt; &#xA;&lt;h3&gt;Selector overview&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;tagname&lt;/code&gt;: find elements by tag, e.g. &lt;code&gt;a&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ns|tag&lt;/code&gt;: find elements by tag in a namespace, e.g. &lt;code&gt;fb|name&lt;/code&gt; finds &lt;code&gt;&amp;lt;fb:name&amp;gt;&lt;/code&gt; elements&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;#id&lt;/code&gt;: find elements by ID, e.g. &lt;code&gt;#logo&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.class&lt;/code&gt;: find elements by class name, e.g. &lt;code&gt;.masthead&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[attribute]&lt;/code&gt;: elements with attribute, e.g. &lt;code&gt;[href]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[^attr]&lt;/code&gt;: elements with an attribute name prefix, e.g. &lt;code&gt;[^data-]&lt;/code&gt; finds elements with HTML5 dataset attributes&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[attr=value]&lt;/code&gt;: elements with attribute value, e.g. &lt;code&gt;[width=500]&lt;/code&gt; (also quotable, like &lt;code&gt;[data-name=&#39;launch sequence&#39;]&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[attr^=value]&lt;/code&gt;, &lt;code&gt;[attr$=value]&lt;/code&gt;, &lt;code&gt;[attr*=value]&lt;/code&gt;: elements with attributes that start with, end with, or contain the value, e.g. &lt;code&gt;[href*=/path/]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[attr~=regex]&lt;/code&gt;: elements with attribute values that match the regular expression; e.g. &lt;code&gt;img[src~=(?i)\.(png|jpe?g)]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;*&lt;/code&gt;: all elements, e.g. &lt;code&gt;*&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Selector combinations&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;el#id&lt;/code&gt;: elements with ID, e.g. &lt;code&gt;div#logo&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;el.class&lt;/code&gt;: elements with class, e.g. &lt;code&gt;div.masthead&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;el[attr]&lt;/code&gt;: elements with attribute, e.g. &lt;code&gt;a[href]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Any combination, e.g. &lt;code&gt;a[href].highlight&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Ancestor &lt;code&gt;child&lt;/code&gt;: child elements that descend from ancestor, e.g. &lt;code&gt;.body p&lt;/code&gt; finds &lt;code&gt;p&lt;/code&gt; elements anywhere under a block with class &#34;body&#34;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;parent &amp;gt; child&lt;/code&gt;: child elements that descend directly from parent, e.g. &lt;code&gt;div.content &amp;gt; p&lt;/code&gt; finds p elements; and &lt;code&gt;body &amp;gt; *&lt;/code&gt; finds the direct children of the body tag&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;siblingA + siblingB&lt;/code&gt;: finds sibling B element immediately preceded by sibling A, e.g. &lt;code&gt;div.head + div&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;siblingA ~ siblingX&lt;/code&gt;: finds sibling X element preceded by sibling A, e.g. &lt;code&gt;h1 ~ p&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;el&lt;/code&gt;, &lt;code&gt;el&lt;/code&gt;, &lt;code&gt;el&lt;/code&gt;: group multiple selectors, find unique elements that match any of the selectors; e.g. &lt;code&gt;div.masthead&lt;/code&gt;, &lt;code&gt;div.logo&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Pseudo selectors&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:lt(n)&lt;/code&gt;: find elements whose sibling index (i.e. its position in the DOM tree relative to its parent) is less than n; e.g. &lt;code&gt;td:lt(3)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:gt(n)&lt;/code&gt;: find elements whose sibling index is greater than n; e.g. &lt;code&gt;div p:gt(2)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:eq(n)&lt;/code&gt;: find elements whose sibling index is equal to n; e.g. &lt;code&gt;form input:eq(1)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:has(seletor)&lt;/code&gt;: find elements that contain elements matching the selector; e.g. &lt;code&gt;div:has(p)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:not(selector)&lt;/code&gt;: find elements that do not match the selector; e.g. &lt;code&gt;div:not(.logo)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:contains(text)&lt;/code&gt;: find elements that contain the given text. The search is case-insensitive; e.g. &lt;code&gt;p:contains(swiftsoup)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:containsOwn(text)&lt;/code&gt;: find elements that directly contain the given text&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:matches(regex)&lt;/code&gt;: find elements whose text matches the specified regular expression; e.g. &lt;code&gt;div:matches((?i)login)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:matchesOwn(regex)&lt;/code&gt;: find elements whose own text matches the specified regular expression&lt;/li&gt; &#xA; &lt;li&gt;Note that the above indexed pseudo-selectors are 0-based, that is, the first element is at index 0, the second at 1, etc&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;h2&gt;To parse an HTML document from String:&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let html = &#34;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;First parse&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;p&amp;gt;Parsed HTML into a doc.&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#34;&#xA;guard let doc: Document = try? SwiftSoup.parse(html) else { return }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Get all text nodes:&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;guard let elements = try? doc.getAllElements() else { return html }&#xA;for element in elements {&#xA;    for textNode in element.textNodes() {&#xA;        [...]&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Set CSS using SwiftSoup:&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try doc.head()?.append(&#34;&amp;lt;style&amp;gt;html {font-size: 2em}&amp;lt;/style&amp;gt;&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Get HTML value&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let html = &#34;&amp;lt;div class=\&#34;container-fluid\&#34;&amp;gt;&#34;&#xA;    + &#34;&amp;lt;div class=\&#34;panel panel-default \&#34;&amp;gt;&#34;&#xA;    + &#34;&amp;lt;div class=\&#34;panel-body\&#34;&amp;gt;&#34;&#xA;    + &#34;&amp;lt;form id=\&#34;coupon_checkout\&#34; action=\&#34;http://uat.all.com.my/checkout/couponcode\&#34; method=\&#34;post\&#34;&amp;gt;&#34;&#xA;    + &#34;&amp;lt;input type=\&#34;hidden\&#34; name=\&#34;transaction_id\&#34; value=\&#34;4245\&#34;&amp;gt;&#34;&#xA;    + &#34;&amp;lt;input type=\&#34;hidden\&#34; name=\&#34;lang\&#34; value=\&#34;EN\&#34;&amp;gt;&#34;&#xA;    + &#34;&amp;lt;input type=\&#34;hidden\&#34; name=\&#34;devicetype\&#34; value=\&#34;\&#34;&amp;gt;&#34;&#xA;    + &#34;&amp;lt;div class=\&#34;input-group\&#34;&amp;gt;&#34;&#xA;    + &#34;&amp;lt;input type=\&#34;text\&#34; class=\&#34;form-control\&#34; id=\&#34;coupon_code\&#34; name=\&#34;coupon\&#34; placeholder=\&#34;Coupon Code\&#34;&amp;gt;&#34;&#xA;    + &#34;&amp;lt;span class=\&#34;input-group-btn\&#34;&amp;gt;&#34;&#xA;    + &#34;&amp;lt;button class=\&#34;btn btn-primary\&#34; type=\&#34;submit\&#34;&amp;gt;Enter Code&amp;lt;/button&amp;gt;&#34;&#xA;    + &#34;&amp;lt;/span&amp;gt;&#34;&#xA;    + &#34;&amp;lt;/div&amp;gt;&#34;&#xA;    + &#34;&amp;lt;/form&amp;gt;&#34;&#xA;    + &#34;&amp;lt;/div&amp;gt;&#34;&#xA;    + &#34;&amp;lt;/div&amp;gt;&#34;&#xA;guard let doc: Document = try? SwiftSoup.parse(html) else { return } // parse html&#xA;let elements = try doc.select(&#34;[name=transaction_id]&#34;) // query&#xA;let transaction_id = try elements.get(0) // select first element&#xA;let value = try transaction_id.val() // get value&#xA;print(value) // 4245&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How to remove all the html from a string&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;guard let doc: Document = try? SwiftSoup.parse(html) else { return } // parse html&#xA;guard let txt = try? doc.text() else { return }&#xA;print(txt)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How to get and update XML values&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let xml = &#34;&amp;lt;?xml version=&#39;1&#39; encoding=&#39;UTF-8&#39; something=&#39;else&#39;?&amp;gt;&amp;lt;val&amp;gt;One&amp;lt;/val&amp;gt;&#34;&#xA;guard let doc = try? SwiftSoup.parse(xml, &#34;&#34;, Parser.xmlParser()) else { return }&#xA;guard let element = try? doc.getElementsByTag(&#34;val&#34;).first() else { return } // Find first element&#xA;try element.text(&#34;NewValue&#34;) // Edit Value&#xA;let valueString = try element.text() // &#34;NewValue&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How to get all &lt;code&gt;&amp;lt;img src&amp;gt;&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    let doc: Document = try SwiftSoup.parse(html)&#xA;    let srcs: Elements = try doc.select(&#34;img[src]&#34;)&#xA;    let srcsStringArray: [String?] = srcs.array().map { try? $0.attr(&#34;src&#34;).description }&#xA;    // do something with srcsStringArray&#xA;} catch Exception.Error(_, let message) {&#xA;    print(message)&#xA;} catch {&#xA;    print(&#34;error&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Get all &lt;code&gt;href&lt;/code&gt; of &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let html = &#34;&amp;lt;a id=1 href=&#39;?foo=bar&amp;amp;mid&amp;amp;lt=true&#39;&amp;gt;One&amp;lt;/a&amp;gt; &amp;lt;a id=2 href=&#39;?foo=bar&amp;amp;lt;qux&amp;amp;lg=1&#39;&amp;gt;Two&amp;lt;/a&amp;gt;&#34;&#xA;guard let els: Elements = try? SwiftSoup.parse(html).select(&#34;a&#34;) else { return }&#xA;for element: Element in els.array() {&#xA;    print(try? element.attr(&#34;href&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;?foo=bar&amp;amp;mid&amp;amp;lt=true&#34;&#xA;&#34;?foo=bar&amp;lt;qux&amp;amp;lg=1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Escape and Unescape&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let text = &#34;Hello &amp;amp;&amp;lt;&amp;gt; √Ö √• œÄ Êñ∞ there ¬æ ¬© ¬ª&#34;&#xA;&#xA;print(Entities.escape(text))&#xA;print(Entities.unescape(text))&#xA;&#xA;&#xA;print(Entities.escape(text, OutputSettings().encoder(String.Encoding.ascii).escapeMode(Entities.EscapeMode.base)))&#xA;print(Entities.escape(text, OutputSettings().charset(String.Encoding.ascii).escapeMode(Entities.EscapeMode.extended)))&#xA;print(Entities.escape(text, OutputSettings().charset(String.Encoding.ascii).escapeMode(Entities.EscapeMode.xhtml)))&#xA;print(Entities.escape(text, OutputSettings().charset(String.Encoding.utf8).escapeMode(Entities.EscapeMode.extended)))&#xA;print(Entities.escape(text, OutputSettings().charset(String.Encoding.utf8).escapeMode(Entities.EscapeMode.xhtml)))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;Hello &amp;amp;amp;&amp;amp;lt;&amp;amp;gt; √Ö √• œÄ Êñ∞ there ¬æ ¬© ¬ª&#34;&#xA;&#34;Hello &amp;amp;&amp;lt;&amp;gt; √Ö √• œÄ Êñ∞ there ¬æ ¬© ¬ª&#34;&#xA;&#xA;&#xA;&#34;Hello &amp;amp;amp;&amp;amp;lt;&amp;amp;gt; &amp;amp;Aring; &amp;amp;aring; &amp;amp;#x3c0; &amp;amp;#x65b0; there &amp;amp;frac34; &amp;amp;copy; &amp;amp;raquo;&#34;&#xA;&#34;Hello &amp;amp;amp;&amp;amp;lt;&amp;amp;gt; &amp;amp;angst; &amp;amp;aring; &amp;amp;pi; &amp;amp;#x65b0; there &amp;amp;frac34; &amp;amp;copy; &amp;amp;raquo;&#34;&#xA;&#34;Hello &amp;amp;amp;&amp;amp;lt;&amp;amp;gt; &amp;amp;#xc5; &amp;amp;#xe5; &amp;amp;#x3c0; &amp;amp;#x65b0; there &amp;amp;#xbe; &amp;amp;#xa9; &amp;amp;#xbb;&#34;&#xA;&#34;Hello &amp;amp;amp;&amp;amp;lt;&amp;amp;gt; √Ö √• œÄ Êñ∞ there ¬æ ¬© ¬ª&#34;&#xA;&#34;Hello &amp;amp;amp;&amp;amp;lt;&amp;amp;gt; √Ö √• œÄ Êñ∞ there ¬æ ¬© ¬ª&#34;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;Nabil Chatbi, &lt;a href=&#34;mailto:scinfu@gmail.com&#34;&gt;scinfu@gmail.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Note&lt;/h2&gt; &#xA;&lt;p&gt;SwiftSoup was ported to Swift from Java &lt;a href=&#34;https://jsoup.org/&#34;&gt;Jsoup&lt;/a&gt; library.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;SwiftSoup is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Ranchero-Software/NetNewsWire</title>
    <updated>2023-04-16T02:06:07Z</updated>
    <id>tag:github.com,2023-04-16:/Ranchero-Software/NetNewsWire</id>
    <link href="https://github.com/Ranchero-Software/NetNewsWire" rel="alternate"></link>
    <summary type="html">&lt;p&gt;RSS reader for macOS and iOS.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Ranchero-Software/NetNewsWire/main/Technotes/Images/icon.png&#34; alt=&#34;Icon&#34;&gt; NetNewsWire&lt;/h1&gt; &#xA;&lt;p&gt;It‚Äôs a free and open-source feed reader for macOS and iOS.&lt;/p&gt; &#xA;&lt;p&gt;It supports &lt;a href=&#34;https://cyber.harvard.edu/rss/rss.html&#34;&gt;RSS&lt;/a&gt;, &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc4287&#34;&gt;Atom&lt;/a&gt;, &lt;a href=&#34;https://jsonfeed.org/&#34;&gt;JSON Feed&lt;/a&gt;, and &lt;a href=&#34;https://github.com/scripting/Scripting-News/raw/master/rss-in-json/README.md&#34;&gt;RSS-in-JSON&lt;/a&gt; formats.&lt;/p&gt; &#xA;&lt;p&gt;More info: &lt;a href=&#34;https://netnewswire.com/&#34;&gt;https://netnewswire.com/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Also see the &lt;a href=&#34;https://raw.githubusercontent.com/Ranchero-Software/NetNewsWire/main/Technotes/&#34;&gt;Technotes&lt;/a&gt; and the &lt;a href=&#34;https://raw.githubusercontent.com/Ranchero-Software/NetNewsWire/main/Technotes/Roadmap.md&#34;&gt;Roadmap&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note: NetNewsWire‚Äôs Help menu has a bunch of these links, so you don‚Äôt have to remember to come back to this page.&lt;/p&gt; &#xA;&lt;p&gt;Here‚Äôs &lt;a href=&#34;https://raw.githubusercontent.com/Ranchero-Software/NetNewsWire/main/Technotes/HowToSupportNetNewsWire.markdown&#34;&gt;How to Support NetNewsWire&lt;/a&gt;. Spoiler: don‚Äôt send money. :)&lt;/p&gt; &#xA;&lt;h4&gt;Community&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://netnewswire.com/slack&#34;&gt;Join the Slack group&lt;/a&gt; to talk with other NetNewsWire users ‚Äî&amp;nbsp;and to help out, if you‚Äôd like to, by testing, coding, writing, providing feedback, or just helping us think things through. Everybody is welcome and encouraged to join.&lt;/p&gt; &#xA;&lt;p&gt;Every community member is expected to abide by the &lt;a href=&#34;https://raw.githubusercontent.com/Ranchero-Software/NetNewsWire/main/CONTRIBUTING.md#code-of-conduct&#34;&gt;code of conduct&lt;/a&gt; which is included in the &lt;a href=&#34;https://raw.githubusercontent.com/Ranchero-Software/NetNewsWire/main/CONTRIBUTING.md&#34;&gt;Contributing&lt;/a&gt; page.&lt;/p&gt; &#xA;&lt;h4&gt;Pull Requests&lt;/h4&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/Ranchero-Software/NetNewsWire/main/CONTRIBUTING.md&#34;&gt;Contributing&lt;/a&gt; page for our process. It‚Äôs pretty straightforward.&lt;/p&gt; &#xA;&lt;h4&gt;Building&lt;/h4&gt; &#xA;&lt;p&gt;You can build and test NetNewsWire without a paid developer account.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/Ranchero-Software/NetNewsWire.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can locally override the Xcode settings for code signing by creating a &lt;code&gt;DeveloperSettings.xcconfig&lt;/code&gt; file locally at the appropriate path. This allows for a pristine project with code signing set up with the appropriate developer ID and certificates, and for developer to be able to have local settings without needing to check in anything into source control.&lt;/p&gt; &#xA;&lt;p&gt;You can do this in one of two ways: using the included &lt;code&gt;setup.sh&lt;/code&gt; script or by creating the folder structure and file manually.&lt;/p&gt; &#xA;&lt;h5&gt;Using &lt;code&gt;setup.sh&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open Terminal and &lt;code&gt;cd&lt;/code&gt; into the NetNewsWire directory.&lt;/li&gt; &#xA; &lt;li&gt;Run this command to ensure you have execution rights for the script: &lt;code&gt;chmod +x setup.sh&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Execute the script with the following command: &lt;code&gt;./setup.sh&lt;/code&gt; and complete the answers.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Manually&lt;/h5&gt; &#xA;&lt;p&gt;Make a directory &lt;code&gt;SharedXcodeSettings&lt;/code&gt; next to where you have this repository.&lt;/p&gt; &#xA;&lt;p&gt;The directory structure is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aDirectory/&#xA;  SharedXcodeSettings/&#xA;    DeveloperSettings.xcconfig&#xA;  NetNewsWire/&#xA;    NetNewsWire.xcworkspace&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;p&gt;If your NetNewsWire Xcode project file is at: &lt;code&gt;/Users/Shared/git/NetNewsWire/NetNewsWire.xcodeproj&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Create your &lt;code&gt;DeveloperSettings.xcconfig&lt;/code&gt; file at &lt;code&gt;/Users/Shared/git/SharedXcodeSettings/DeveloperSettings.xcconfig&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then create a plain text file in it: &lt;code&gt;SharedXcodeSettings/DeveloperSettings.xcconfig&lt;/code&gt; and give it the contents:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;CODE_SIGN_IDENTITY = Mac Developer&#xA;DEVELOPMENT_TEAM = &amp;lt;Your Team ID&amp;gt;&#xA;CODE_SIGN_STYLE = Automatic&#xA;ORGANIZATION_IDENTIFIER = &amp;lt;Your Domain Name Reversed&amp;gt;&#xA;DEVELOPER_ENTITLEMENTS = -dev&#xA;PROVISIONING_PROFILE_SPECIFIER =&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set &lt;code&gt;DEVELOPMENT_TEAM&lt;/code&gt; to your Apple supplied development team. You can use Keychain Access to &lt;a href=&#34;https://raw.githubusercontent.com/Ranchero-Software/NetNewsWire/main/Technotes/FindingYourDevelopmentTeamID.md&#34;&gt;find your development team ID&lt;/a&gt;. Set &lt;code&gt;ORGANIZATION_IDENTIFIER&lt;/code&gt; to a reversed domain name that you control or have made up. Note that &lt;code&gt;PROVISIONING_PROFILE_SPECIFIER&lt;/code&gt; should not have a value associated with it.&lt;/p&gt; &#xA;&lt;p&gt;You can now open the &lt;code&gt;NetNewsWire.xccodeproj&lt;/code&gt; in Xcode.&lt;/p&gt; &#xA;&lt;p&gt;Now you should be able to build without code signing errors and without modifying the NetNewsWire Xcode project. This is a special build of NetNewsWire with some functionality disabled. This is because we have API keys that can&#39;t be stored in the repository or shared between developers. Certain account types, like iCloud and Feedly, aren&#39;t enabled and the Reader View isn&#39;t enabled because of this.&lt;/p&gt; &#xA;&lt;p&gt;If you have any problems, we will help you out in Slack (&lt;a href=&#34;https://raw.githubusercontent.com/Ranchero-Software/NetNewsWire/main/README.md#Community&#34;&gt;see above&lt;/a&gt;).&lt;/p&gt;</summary>
  </entry>
</feed>