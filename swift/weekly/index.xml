<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-07-28T01:45:14Z</updated>
  <subtitle>Weekly Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>XITRIX/iTorrent</title>
    <updated>2024-07-28T01:45:14Z</updated>
    <id>tag:github.com,2024-07-28:/XITRIX/iTorrent</id>
    <link href="https://github.com/XITRIX/iTorrent" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Torrent client for iOS 16+&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Git migration to iTorrent 2.0 in progress&lt;/p&gt; &#xA;&lt;p&gt;iTorrent 2.0 app is it beta preview state, expect to see some bugs and be ready report about them.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://intradeus.github.io/http-protocol-redirector?r=altstore://source?url=https://xitrix.github.io/iTorrent/AltStore.json&#34; title=&#34;Download with AltStore.&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Download-AltStore-green?style=flat&#34; alt=&#34;AltStore Button&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://intradeus.github.io/http-protocol-redirector?r=sidestore://source?url=https://xitrix.github.io/iTorrent/AltStore.json&#34; title=&#34;Download with SideStore.&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Download-SideStore-purple?style=flat&#34; alt=&#34;SideStore Button&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://intradeus.github.io/http-protocol-redirector?r=itms-services://?action=download-manifest&amp;amp;url=https://github.com/XITRIX/iTorrent/releases/latest/download/manifest.plist&#34; title=&#34;Download with Jailbreak.&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Download-Jailbreak-red?style=flat&#34; alt=&#34;Jailbreak Button&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>marcoarment/Blackbird</title>
    <updated>2024-07-28T01:45:14Z</updated>
    <id>tag:github.com,2024-07-28:/marcoarment/Blackbird</id>
    <link href="https://github.com/marcoarment/Blackbird" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Blackbird&lt;/h1&gt; &#xA;&lt;p&gt;A SQLite database wrapper and model layer, using Swift concurrency and &lt;code&gt;Codable&lt;/code&gt;, with no other dependencies.&lt;/p&gt; &#xA;&lt;p&gt;Philosophy:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Prioritize speed of development over all else.&lt;/li&gt; &#xA; &lt;li&gt;No code generation.&lt;/li&gt; &#xA; &lt;li&gt;No schema definitions.&lt;/li&gt; &#xA; &lt;li&gt;Automatic migrations.&lt;/li&gt; &#xA; &lt;li&gt;Async by default.&lt;/li&gt; &#xA; &lt;li&gt;Use Swift’s type system and key-paths instead of strings whenever possible.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Project status&lt;/h2&gt; &#xA;&lt;p&gt;Blackbird is a &lt;strong&gt;beta&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Minor changes may still occur that break backwards compatibility with code or databases.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m using Blackbird in shipping software now, but do so at your own risk.&lt;/p&gt; &#xA;&lt;h2&gt;BlackbirdModel&lt;/h2&gt; &#xA;&lt;p&gt;A protocol to store structs in the &lt;a href=&#34;https://www.sqlite.org/&#34;&gt;SQLite&lt;/a&gt;-powered &lt;a href=&#34;https://raw.githubusercontent.com/marcoarment/Blackbird/main/#blackbirddatabase&#34;&gt;Blackbird.Database&lt;/a&gt;, with compiler-checked key-paths for common operations.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s how you define a table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Blackbird&#xA;&#xA;struct Post: BlackbirdModel {&#xA;    @BlackbirdColumn var id: Int&#xA;    @BlackbirdColumn var title: String&#xA;    @BlackbirdColumn var url: URL?&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it. No &lt;code&gt;CREATE TABLE&lt;/code&gt;, no separate table-definition logic, no additional steps.&lt;/p&gt; &#xA;&lt;p&gt;And &lt;strong&gt;automatic migrations&lt;/strong&gt;. Want to add or remove columns or indexes, or start using more of Blackbird&#39;s features such as custom &lt;code&gt;enum&lt;/code&gt; columns, unique indexes, or custom primary keys? Just change the code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Post: BlackbirdModel {&#xA;    static var primaryKey: [BlackbirdColumnKeyPath] = [ \.$guid, \.$id ]&#xA;&#xA;    static var indexes: [[BlackbirdColumnKeyPath]] = [&#xA;        [ \.$title ],&#xA;        [ \.$publishedDate, \.$format ],&#xA;    ]&#xA;&#xA;    static var uniqueIndexes: [[BlackbirdColumnKeyPath]] = [&#xA;        [ \.$guid ],&#xA;    ]&#xA;    &#xA;    enum Format: Int, BlackbirdIntegerEnum {&#xA;        case markdown&#xA;        case html&#xA;    }&#xA;    &#xA;    @BlackbirdColumn var id: Int&#xA;    @BlackbirdColumn var guid: String&#xA;    @BlackbirdColumn var title: String&#xA;    @BlackbirdColumn var publishedDate: Date?&#xA;    @BlackbirdColumn var format: Format&#xA;    @BlackbirdColumn var url: URL?&#xA;    @BlackbirdColumn var image: Data?&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;…and Blackbird will automatically migrate the table to the new schema at runtime.&lt;/p&gt; &#xA;&lt;h3&gt;Queries&lt;/h3&gt; &#xA;&lt;p&gt;Write instances safely and easily to a &lt;a href=&#34;https://raw.githubusercontent.com/marcoarment/Blackbird/main/#blackbird-database&#34;&gt;Blackbird.Database&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let post = Post(id: 1, title: &#34;What I had for breakfast&#34;)&#xA;try await post.write(to: db)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Perform queries in many different ways, preferring structured queries using key-paths for compile-time checking, type safety, and convenience:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Fetch by primary key&#xA;let post = try await Post.read(from: db, id: 2)&#xA;&#xA;// Or with a WHERE condition, using compiler-checked key-paths:&#xA;let posts = try await Post.read(from: db, matching: \.$title == &#34;Sports&#34;)&#xA;&#xA;// Select custom columns, with row dictionaries typed by key-path:&#xA;for row in try await Post.query(in: db, columns: [\.$id, \.$image], matching: \.$url != nil) {&#xA;    let postID = row[\.$id]       // returns Int&#xA;    let imageData = row[\.$image] // returns Data?&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;SQL is never required, but it&#39;s always available:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try await Post.query(in: db, &#34;UPDATE $T SET format = ? WHERE date &amp;lt; ?&#34;, .html, date)&#xA;&#xA;let posts = try await Post.read(from: db, sqlWhere: &#34;title LIKE ? ORDER BY RANDOM()&#34;, &#34;Sports%&#34;)&#xA;&#xA;for row in try await Post.query(in: db, &#34;SELECT MAX(id) AS max FROM $T WHERE url = ?&#34;, url) {&#xA;    let maxID = row[&#34;max&#34;]?.intValue&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Monitor for row- and column-level changes with Combine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let listener = Post.changePublisher(in: db).sink { change in&#xA;    if change.hasPrimaryKeyChanged(7) {&#xA;        print(&#34;Post 7 has changed&#34;)&#xA;    }&#xA;&#xA;    if change.hasColumnChanged(\.$title) {&#xA;        print(&#34;A title has changed&#34;)&#xA;    }&#xA;}&#xA;&#xA;// Or monitor a single column by key-path:&#xA;let listener = Post.changePublisher(in: db, columns: [\.$title]).sink { _ in&#xA;    print(&#34;A post&#39;s title changed&#34;)&#xA;}&#xA;&#xA;// Or listen for changes for a specific primary key:&#xA;let listener = Post.changePublisher(in: db, primaryKey: 3, columns: [\.$title]).sink { _ in&#xA;    print(&#34;Post 3&#39;s title changed&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SwiftUI&lt;/h3&gt; &#xA;&lt;p&gt;Blackbird is designed for SwiftUI, offering async-loading, automatically-updating result wrappers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct RootView: View {&#xA;    // The database that all child views will automatically use&#xA;    @StateObject var database = try! Blackbird.Database.inMemoryDatabase()&#xA;&#xA;    var body: some View {&#xA;        PostListView()&#xA;        .environment(\.blackbirdDatabase, database)&#xA;    }&#xA;}&#xA;&#xA;struct PostListView: View {&#xA;    // Async-loading, auto-updating array of matching instances&#xA;    @BlackbirdLiveModels({ try await Post.read(from: $0, orderBy: .ascending(\.$id)) }) var posts&#xA;    &#xA;    // Async-loading, auto-updating rows from a custom query&#xA;    @BlackbirdLiveQuery(tableName: &#34;Post&#34;, { try await $0.query(&#34;SELECT MAX(id) AS max FROM Post&#34;) }) var maxID&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if posts.didLoad {&#xA;                List {&#xA;                    ForEach(posts.results) { post in&#xA;                        NavigationLink(destination: PostView(post: post.liveModel)) {&#xA;                            Text(post.title)&#xA;                        }&#xA;                    }&#xA;                }&#xA;            } else {&#xA;                ProgressView()&#xA;            }&#xA;        }&#xA;        .navigationTitle(maxID.didLoad ? &#34;\(maxID.results.first?[&#34;max&#34;]?.intValue ?? 0) posts&#34; : &#34;Loading…&#34;)&#xA;    }&#xA;}&#xA;&#xA;struct PostView: View {&#xA;    // Auto-updating instance&#xA;    @BlackbirdLiveModel var post: Post?&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if let post {&#xA;                Text(post.title)&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Blackbird.Database&lt;/h2&gt; &#xA;&lt;p&gt;A lightweight async wrapper around &lt;a href=&#34;https://www.sqlite.org/&#34;&gt;SQLite&lt;/a&gt; that can be used with or without &lt;a href=&#34;https://raw.githubusercontent.com/marcoarment/Blackbird/main/#BlackbirdModel&#34;&gt;BlackbirdModel&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let db = try Blackbird.Database(path: &#34;/tmp/db.sqlite&#34;)&#xA;&#xA;// SELECT with parameterized queries&#xA;for row in try await db.query(&#34;SELECT id FROM posts WHERE state = ?&#34;, 1) {&#xA;    let id = row[&#34;id&#34;]?.intValue&#xA;    // ...&#xA;}&#xA;&#xA;// Run direct queries&#xA;try await db.execute(&#34;UPDATE posts SET comments = NULL&#34;)&#xA;&#xA;// Transactions with synchronous queries&#xA;try await db.transaction { core in&#xA;    try core.query(&#34;INSERT INTO posts VALUES (?, ?)&#34;, 16, &#34;Sports!&#34;)&#xA;    try core.query(&#34;INSERT INTO posts VALUES (?, ?)&#34;, 17, &#34;Dewey Defeats Truman&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Wishlist for future Swift-language capabilities&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Static type reflection for cleaner schema detection:&lt;/strong&gt; Swift currently has no way to reflect a type&#39;s properties without creating an instance — &lt;a href=&#34;https://developer.apple.com/documentation/swift/mirror&#34;&gt;Mirror&lt;/a&gt; only reflects property names and values of given instances. If the language adds static type reflection in the future, my schema detection wouldn&#39;t need to rely on a hack using a Decoder to generate empty instances.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;KeyPath to/from String, static reflection of a type&#39;s KeyPaths:&lt;/strong&gt; With the abilities to get a type&#39;s available KeyPaths (without some &lt;a href=&#34;https://forums.swift.org/t/getting-keypaths-to-members-automatically-using-mirror/21207&#34;&gt;awful hacks&lt;/a&gt;) and create KeyPaths from strings at runtime, many of my hacks using Codable could be replaced with KeyPaths, which would be cleaner and probably much faster.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Method to get CodingKeys enum names and custom values:&lt;/strong&gt; It&#39;s currently impossible to get the names of &lt;code&gt;CodingKeys&lt;/code&gt; cases without resorting to &lt;a href=&#34;https://forums.swift.org/t/getting-the-name-of-a-swift-enum-value/35654/18&#34;&gt;this awful hack&lt;/a&gt;. Decoders must know these names to perform proper decoding to arbitrary types that may have custom &lt;code&gt;CodingKeys&lt;/code&gt; declared. If this hack ever stops working, BlackbirdModel cannot support custom &lt;code&gt;CodingKeys&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Cleaner protocol name (&lt;code&gt;Blackbird.Model&lt;/code&gt;):&lt;/strong&gt; Protocols can&#39;t contain dots or be nested within another type.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Nested struct definitions inside protocols&lt;/strong&gt; could make a lot of my &#34;BlackbirdModel…&#34; names shorter.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;why is it called blackbird&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Lockheed_SR-71_Blackbird&#34;&gt;The plane&lt;/a&gt;, of course.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s old, awesome, and ridiculously fast. Well, this database library is based on old, awesome tech (SQLite), and it&#39;s ridiculously fast.&lt;/p&gt; &#xA;&lt;p&gt;(If I&#39;m honest, though, it&#39;s mostly because it&#39;s a cool-ass plane. I don&#39;t even really care about planes, generally. Just that one.)&lt;/p&gt; &#xA;&lt;h3&gt;you know there are lots of other things called that&lt;/h3&gt; &#xA;&lt;p&gt;Of course &lt;a href=&#34;https://en.wikipedia.org/wiki/Blackbird&#34;&gt;there are&lt;/a&gt;. Who cares?&lt;/p&gt; &#xA;&lt;p&gt;This is a database engine that&#39;ll be used by, at most, a handful of nerds. It doesn&#39;t matter what it&#39;s called.&lt;/p&gt; &#xA;&lt;p&gt;I like unique names (rather than generic or descriptive names, like &lt;code&gt;Model&lt;/code&gt; or &lt;code&gt;SwiftSQLite&lt;/code&gt;) because they&#39;re easier to search for and harder to confuse with other types. So I wanted something memorable. I suppose I could&#39;ve called it something like &lt;code&gt;ButtDB&lt;/code&gt; — memorable! — but as I use it over the coming years, I wanted to type something cooler after all of my &lt;code&gt;struct&lt;/code&gt; definitions.&lt;/p&gt; &#xA;&lt;h3&gt;why don&#39;t you support [SQLite feature]&lt;/h3&gt; &#xA;&lt;p&gt;Blackbird is designed to make it very fast and easy to write apps that have the most common, straightforward database needs.&lt;/p&gt; &#xA;&lt;p&gt;Custom SQL is supported in many ways, but more advanced SQLite behavior like triggers, views, windows, foreign-key constraints, cascading writes, partial or expression indexes, virtual columns, etc. are not directly supported by Blackbird and may cause undefined behavior if used.&lt;/p&gt; &#xA;&lt;p&gt;By not supporting esoteric or specialized features that apps typically don&#39;t need, Blackbird is able to offer a cleaner API and more useful functionality for common cases.&lt;/p&gt; &#xA;&lt;h3&gt;why didn&#39;t you just use [other SQLite library]&lt;/h3&gt; &#xA;&lt;p&gt;I like to write my own libraries.&lt;/p&gt; &#xA;&lt;p&gt;My libraries can perfectly match my needs and the way I expect them to work. And if my needs or expectations change, I can change the libraries.&lt;/p&gt; &#xA;&lt;p&gt;I also learn a great deal when writing them, exercising and improving my skills to benefit the rest of my work.&lt;/p&gt; &#xA;&lt;p&gt;And when I write the libraries, I understand how everything works as I&#39;m using them, therefore creating fewer bugs and writing more efficient software.&lt;/p&gt; &#xA;&lt;h3&gt;you know [other SQLite library] is faster&lt;/h3&gt; &#xA;&lt;p&gt;I know. Ironic, considering that I named this one after the fastest plane.&lt;/p&gt; &#xA;&lt;p&gt;Blackbird is optimized for speed of &lt;strong&gt;development&lt;/strong&gt;. It&#39;s pretty fast in execution, too, but clarity, ease of use, reduced repetition, and simple tooling are higher priorities.&lt;/p&gt; &#xA;&lt;p&gt;Blackbird also offers automatic caching and fine-grained change reporting. This helps apps avoid many unnecessary queries, reloads, and UI refreshes, which can result in faster overall app performance.&lt;/p&gt; &#xA;&lt;p&gt;Other Swift SQLite libraries can be faster at raw database performance by omitting much of Blackbird&#39;s reflection, abstraction, and key-path usage. Some use code-generation methods, which can execute very efficiently but complicate development more than I&#39;d like. Others take less-abstracted approaches that enable more custom behavior but make usage more complicated.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;ve chosen different trade-offs to better fit my needs. I&#39;ve never written an app that was too slow to read its database, but I&#39;ve frequently struggled with maintenance of large, complex codebases.&lt;/p&gt; &#xA;&lt;p&gt;Blackbird&#39;s goal is to achieve my ideal balance of ease-of-use and bug-avoidance, even though it&#39;s therefore not the fastest SQLite library in execution.&lt;/p&gt; &#xA;&lt;p&gt;Phones keep getting faster, but a bug is a bug forever.&lt;/p&gt;</summary>
  </entry>
</feed>