<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-05-11T01:45:34Z</updated>
  <subtitle>Weekly Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>modelcontextprotocol/swift-sdk</title>
    <updated>2025-05-11T01:45:34Z</updated>
    <id>tag:github.com,2025-05-11:/modelcontextprotocol/swift-sdk</id>
    <link href="https://github.com/modelcontextprotocol/swift-sdk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The official Swift SDK for Model Context Protocol servers and clients. Maintained in collaboration with @loopwork-ai.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MCP Swift SDK&lt;/h1&gt; &#xA;&lt;p&gt;Official Swift SDK for the &lt;a href=&#34;https://modelcontextprotocol.io&#34;&gt;Model Context Protocol&lt;/a&gt; (MCP).&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;The Model Context Protocol (MCP) defines a standardized way for applications to communicate with AI and ML models. This Swift SDK implements both client and server components according to the &lt;a href=&#34;https://modelcontextprotocol.io/specification/2025-03-26&#34;&gt;2025-03-26&lt;/a&gt; (latest) version of the MCP specification.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift 6.0+ (Xcode 16+)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/modelcontextprotocol/swift-sdk/main/#platform-availability&#34;&gt;Platform Availability&lt;/a&gt; section below for platform-specific requirements.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;Add the following to your &lt;code&gt;Package.swift&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/modelcontextprotocol/swift-sdk.git&#34;, from: &#34;0.8.2&#34;)&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then add the dependency to your target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.target(&#xA;    name: &#34;YourTarget&#34;,&#xA;    dependencies: [&#xA;        .product(name: &#34;MCP&#34;, package: &#34;swift-sdk&#34;)&#xA;    ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Client Usage&lt;/h2&gt; &#xA;&lt;p&gt;The client component allows your application to connect to MCP servers.&lt;/p&gt; &#xA;&lt;h3&gt;Basic Client Setup&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import MCP&#xA;&#xA;// Initialize the client&#xA;let client = Client(name: &#34;MyApp&#34;, version: &#34;1.0.0&#34;)&#xA;&#xA;// Create a transport and connect&#xA;let transport = StdioTransport()&#xA;try await client.connect(transport: transport)&#xA;&#xA;// Initialize the connection&#xA;let result = try await client.initialize()&#xA;&#xA;// Check server capabilities&#xA;if result.capabilities.tools != nil {&#xA;    // Server supports tools (implicitly including tool calling if the &#39;tools&#39; capability object is present)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Transport Options for Clients&lt;/h3&gt; &#xA;&lt;h4&gt;Stdio Transport&lt;/h4&gt; &#xA;&lt;p&gt;For local subprocess communication:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Create a stdio transport (simplest option)&#xA;let transport = StdioTransport()&#xA;try await client.connect(transport: transport)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;HTTP Transport&lt;/h4&gt; &#xA;&lt;p&gt;For remote server communication:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Create a streaming HTTP transport&#xA;let transport = HTTPClientTransport(&#xA;    endpoint: URL(string: &#34;http://localhost:8080&#34;)!,&#xA;    streaming: true  // Enable Server-Sent Events for real-time updates&#xA;)&#xA;try await client.connect(transport: transport)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tools&lt;/h3&gt; &#xA;&lt;p&gt;Tools represent functions that can be called by the client:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// List available tools&#xA;let tools = try await client.listTools()&#xA;print(&#34;Available tools: \(tools.map { $0.name }.joined(separator: &#34;, &#34;))&#34;)&#xA;&#xA;// Call a tool with arguments&#xA;let (content, isError) = try await client.callTool(&#xA;    name: &#34;image-generator&#34;,&#xA;    arguments: [&#xA;        &#34;prompt&#34;: &#34;A serene mountain landscape at sunset&#34;,&#xA;        &#34;style&#34;: &#34;photorealistic&#34;,&#xA;        &#34;width&#34;: 1024,&#xA;        &#34;height&#34;: 768&#xA;    ]&#xA;)&#xA;&#xA;// Handle tool content&#xA;for item in content {&#xA;    switch item {&#xA;    case .text(let text):&#xA;        print(&#34;Generated text: \(text)&#34;)&#xA;    case .image(let data, let mimeType, let metadata):&#xA;        if let width = metadata?[&#34;width&#34;] as? Int,&#xA;           let height = metadata?[&#34;height&#34;] as? Int {&#xA;            print(&#34;Generated \(width)x\(height) image of type \(mimeType)&#34;)&#xA;            // Save or display the image data&#xA;        }&#xA;    case .audio(let data, let mimeType):&#xA;        print(&#34;Received audio data of type \(mimeType)&#34;)&#xA;    case .resource(let uri, let mimeType, let text):&#xA;        print(&#34;Received resource from \(uri) of type \(mimeType)&#34;)&#xA;        if let text = text {&#xA;            print(&#34;Resource text: \(text)&#34;)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;Resources represent data that can be accessed and potentially subscribed to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// List available resources&#xA;let (resources, nextCursor) = try await client.listResources()&#xA;print(&#34;Available resources: \(resources.map { $0.uri }.joined(separator: &#34;, &#34;))&#34;)&#xA;&#xA;// Read a resource&#xA;let contents = try await client.readResource(uri: &#34;resource://example&#34;)&#xA;print(&#34;Resource content: \(contents)&#34;)&#xA;&#xA;// Subscribe to resource updates if supported&#xA;if result.capabilities.resources.subscribe {&#xA;    try await client.subscribeToResource(uri: &#34;resource://example&#34;)&#xA;&#xA;    // Register notification handler&#xA;    await client.onNotification(ResourceUpdatedNotification.self) { message in&#xA;        let uri = message.params.uri&#xA;        print(&#34;Resource \(uri) updated with new content&#34;)&#xA;&#xA;        // Fetch the updated resource content&#xA;        let updatedContents = try await client.readResource(uri: uri)&#xA;        print(&#34;Updated resource content received&#34;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Prompts&lt;/h3&gt; &#xA;&lt;p&gt;Prompts represent templated conversation starters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// List available prompts&#xA;let (prompts, nextCursor) = try await client.listPrompts()&#xA;print(&#34;Available prompts: \(prompts.map { $0.name }.joined(separator: &#34;, &#34;))&#34;)&#xA;&#xA;// Get a prompt with arguments&#xA;let (description, messages) = try await client.getPrompt(&#xA;    name: &#34;customer-service&#34;,&#xA;    arguments: [&#xA;        &#34;customerName&#34;: &#34;Alice&#34;,&#xA;        &#34;orderNumber&#34;: &#34;ORD-12345&#34;,&#xA;        &#34;issue&#34;: &#34;delivery delay&#34;&#xA;    ]&#xA;)&#xA;&#xA;// Use the prompt messages in your application&#xA;print(&#34;Prompt description: \(description)&#34;)&#xA;for message in messages {&#xA;    if case .text(text: let text) = message.content {&#xA;        print(&#34;\(message.role): \(text)&#34;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Error Handling&lt;/h3&gt; &#xA;&lt;p&gt;Handle common client errors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    let result = try await client.initialize()&#xA;    // Success&#xA;} catch let error as MCPError {&#xA;    print(&#34;MCP Error: \(error.localizedDescription)&#34;)&#xA;} catch {&#xA;    print(&#34;Unexpected error: \(error)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Advanced Client Features&lt;/h3&gt; &#xA;&lt;h4&gt;Strict vs Non-Strict Configuration&lt;/h4&gt; &#xA;&lt;p&gt;Configure client behavior for capability checking:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Strict configuration - fail fast if a capability is missing&#xA;let strictClient = Client(&#xA;    name: &#34;StrictClient&#34;,&#xA;    version: &#34;1.0.0&#34;,&#xA;    configuration: .strict&#xA;)&#xA;&#xA;// With strict configuration, calling a method for an unsupported capability&#xA;// will throw an error immediately without sending a request&#xA;do {&#xA;    // This will throw an error if resources.list capability is not available&#xA;    let resources = try await strictClient.listResources()&#xA;} catch let error as MCPError {&#xA;    print(&#34;Capability not available: \(error.localizedDescription)&#34;)&#xA;}&#xA;&#xA;// Default (non-strict) configuration - attempt the request anyway&#xA;let client = Client(&#xA;    name: &#34;FlexibleClient&#34;,&#xA;    version: &#34;1.0.0&#34;,&#xA;    configuration: .default&#xA;)&#xA;&#xA;// With default configuration, the client will attempt the request&#xA;// even if the capability wasn&#39;t advertised by the server&#xA;do {&#xA;    let resources = try await client.listResources()&#xA;} catch let error as MCPError {&#xA;    // Still handle the error if the server rejects the request&#xA;    print(&#34;Server rejected request: \(error.localizedDescription)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Request Batching&lt;/h4&gt; &#xA;&lt;p&gt;Improve performance by sending multiple requests in a single batch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Array to hold tool call tasks&#xA;var toolTasks: [Task&amp;lt;CallTool.Result, Error&amp;gt;] = []&#xA;&#xA;// Send a batch of requests&#xA;try await client.withBatch { batch in&#xA;    // Add multiple tool calls to the batch&#xA;    for i in 0..&amp;lt;10 {&#xA;        toolTasks.append(&#xA;            try await batch.addRequest(&#xA;                CallTool.request(.init(name: &#34;square&#34;, arguments: [&#34;n&#34;: i]))&#xA;            )&#xA;        )&#xA;    }&#xA;}&#xA;&#xA;// Process results after the batch is sent&#xA;print(&#34;Processing \(toolTasks.count) tool results...&#34;)&#xA;for (index, task) in toolTasks.enumerated() {&#xA;    do {&#xA;        let result = try await task.value&#xA;        print(&#34;\(index): \(result.content)&#34;)&#xA;    } catch {&#xA;        print(&#34;\(index) failed: \(error)&#34;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also batch different types of requests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Declare task variables&#xA;var pingTask: Task&amp;lt;Ping.Result, Error&amp;gt;?&#xA;var promptTask: Task&amp;lt;GetPrompt.Result, Error&amp;gt;?&#xA;&#xA;// Send a batch with different request types&#xA;try await client.withBatch { batch in&#xA;    pingTask = try await batch.addRequest(Ping.request())&#xA;    promptTask = try await batch.addRequest(&#xA;        GetPrompt.request(.init(name: &#34;greeting&#34;))&#xA;    )&#xA;}&#xA;&#xA;// Process individual results&#xA;do {&#xA;    if let pingTask = pingTask {&#xA;        try await pingTask.value&#xA;        print(&#34;Ping successful&#34;)&#xA;    }&#xA;&#xA;    if let promptTask = promptTask {&#xA;        let promptResult = try await promptTask.value&#xA;        print(&#34;Prompt: \(promptResult.description ?? &#34;None&#34;)&#34;)&#xA;    }&#xA;} catch {&#xA;    print(&#34;Error processing batch results: \(error)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] &lt;code&gt;Server&lt;/code&gt; automatically handles batch requests from MCP clients.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Server Usage&lt;/h2&gt; &#xA;&lt;p&gt;The server component allows your application to host model capabilities and respond to client requests.&lt;/p&gt; &#xA;&lt;h3&gt;Basic Server Setup&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import MCP&#xA;&#xA;// Initialize the server with capabilities&#xA;let server = Server(&#xA;    name: &#34;MyModelServer&#34;,&#xA;    version: &#34;1.0.0&#34;,&#xA;    capabilities: .init(&#xA;        prompts: .init(listChanged: true),&#xA;        resources: .init(subscribe: true, listChanged: true),&#xA;        tools: .init(listChanged: true)&#xA;    )&#xA;)&#xA;&#xA;// Create transport and start server&#xA;let transport = StdioTransport()&#xA;try await server.start(transport: transport)&#xA;&#xA;// Now register handlers for the capabilities you&#39;ve enabled&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tools&lt;/h3&gt; &#xA;&lt;p&gt;Register tool handlers to respond to client tool calls:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Register a tool list handler&#xA;server.withMethodHandler(ListTools.self) { _ in&#xA;    let tools = [&#xA;        Tool(&#xA;            name: &#34;weather&#34;,&#xA;            description: &#34;Get current weather for a location&#34;,&#xA;            inputSchema: .object([&#xA;                &#34;location&#34;: .string(&#34;City name or coordinates&#34;),&#xA;                &#34;units&#34;: .string(&#34;Units of measurement, e.g., metric, imperial&#34;)&#xA;            ])&#xA;        ),&#xA;        Tool(&#xA;            name: &#34;calculator&#34;,&#xA;            description: &#34;Perform calculations&#34;,&#xA;            inputSchema: .object([&#xA;                &#34;expression&#34;: .string(&#34;Mathematical expression to evaluate&#34;)&#xA;            ])&#xA;        )&#xA;    ]&#xA;    return .init(tools: tools)&#xA;}&#xA;&#xA;// Register a tool call handler&#xA;server.withMethodHandler(CallTool.self) { params in&#xA;    switch params.name {&#xA;    case &#34;weather&#34;:&#xA;        let location = params.arguments?[&#34;location&#34;]?.stringValue ?? &#34;Unknown&#34;&#xA;        let units = params.arguments?[&#34;units&#34;]?.stringValue ?? &#34;metric&#34;&#xA;        let weatherData = getWeatherData(location: location, units: units) // Your implementation&#xA;        return .init(&#xA;            content: [.text(&#34;Weather for \(location): \(weatherData.temperature)Â°, \(weatherData.conditions)&#34;)],&#xA;            isError: false&#xA;        )&#xA;&#xA;    case &#34;calculator&#34;:&#xA;        if let expression = params.arguments?[&#34;expression&#34;]?.stringValue {&#xA;            let result = evaluateExpression(expression) // Your implementation&#xA;            return .init(content: [.text(&#34;\(result)&#34;)], isError: false)&#xA;        } else {&#xA;            return .init(content: [.text(&#34;Missing expression parameter&#34;)], isError: true)&#xA;        }&#xA;&#xA;    default:&#xA;        return .init(content: [.text(&#34;Unknown tool&#34;)], isError: true)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;Implement resource handlers for data access:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Register a resource list handler&#xA;server.withMethodHandler(ListResources.self) { params in&#xA;    let resources = [&#xA;        Resource(&#xA;            uri: &#34;resource://knowledge-base/articles&#34;,&#xA;            name: &#34;Knowledge Base Articles&#34;,&#xA;            description: &#34;Collection of support articles and documentation&#34;&#xA;        ),&#xA;        Resource(&#xA;            uri: &#34;resource://system/status&#34;,&#xA;            name: &#34;System Status&#34;,&#xA;            description: &#34;Current system operational status&#34;&#xA;        )&#xA;    ]&#xA;    return .init(resources: resources, nextCursor: nil)&#xA;}&#xA;&#xA;// Register a resource read handler&#xA;server.withMethodHandler(ReadResource.self) { params in&#xA;    switch params.uri {&#xA;    case &#34;resource://knowledge-base/articles&#34;:&#xA;        return .init(contents: [Resource.Content.text(&#34;# Knowledge Base\n\nThis is the content of the knowledge base...&#34;, uri: params.uri)])&#xA;&#xA;    case &#34;resource://system/status&#34;:&#xA;        let status = getCurrentSystemStatus() // Your implementation&#xA;        let statusJson = &#34;&#34;&#34;&#xA;            {&#xA;                &#34;status&#34;: &#34;\(status.overall)&#34;,&#xA;                &#34;components&#34;: {&#xA;                    &#34;database&#34;: &#34;\(status.database)&#34;,&#xA;                    &#34;api&#34;: &#34;\(status.api)&#34;,&#xA;                    &#34;model&#34;: &#34;\(status.model)&#34;&#xA;                },&#xA;                &#34;lastUpdated&#34;: &#34;\(status.timestamp)&#34;&#xA;            }&#xA;            &#34;&#34;&#34;&#xA;        return .init(contents: [Resource.Content.text(statusJson, uri: params.uri, mimeType: &#34;application/json&#34;)])&#xA;&#xA;    default:&#xA;        throw MCPError.invalidParams(&#34;Unknown resource URI: \(params.uri)&#34;)&#xA;    }&#xA;}&#xA;&#xA;// Register a resource subscribe handler&#xA;server.withMethodHandler(SubscribeToResource.self) { params in&#xA;    // Store subscription for later notifications.&#xA;    // Client identity for multi-client scenarios needs to be managed by the server application,&#xA;    // potentially using information from the initialize handshake if the server handles one client post-init.&#xA;    // addSubscription(clientID: /* some_client_identifier */, uri: params.uri)&#xA;    print(&#34;Client subscribed to \(params.uri). Server needs to implement logic to track this subscription.&#34;)&#xA;    return .init()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Prompts&lt;/h3&gt; &#xA;&lt;p&gt;Implement prompt handlers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Register a prompt list handler&#xA;server.withMethodHandler(ListPrompts.self) { params in&#xA;    let prompts = [&#xA;        Prompt(&#xA;            name: &#34;interview&#34;,&#xA;            description: &#34;Job interview conversation starter&#34;,&#xA;            arguments: [&#xA;                .init(name: &#34;position&#34;, description: &#34;Job position&#34;, required: true),&#xA;                .init(name: &#34;company&#34;, description: &#34;Company name&#34;, required: true),&#xA;                .init(name: &#34;interviewee&#34;, description: &#34;Candidate name&#34;)&#xA;            ]&#xA;        ),&#xA;        Prompt(&#xA;            name: &#34;customer-support&#34;,&#xA;            description: &#34;Customer support conversation starter&#34;,&#xA;            arguments: [&#xA;                .init(name: &#34;issue&#34;, description: &#34;Customer issue&#34;, required: true),&#xA;                .init(name: &#34;product&#34;, description: &#34;Product name&#34;, required: true)&#xA;            ]&#xA;        )&#xA;    ]&#xA;    return .init(prompts: prompts, nextCursor: nil)&#xA;}&#xA;&#xA;// Register a prompt get handler&#xA;server.withMethodHandler(GetPrompt.self) { params in&#xA;    switch params.name {&#xA;    case &#34;interview&#34;:&#xA;        let position = params.arguments?[&#34;position&#34;]?.stringValue ?? &#34;Software Engineer&#34;&#xA;        let company = params.arguments?[&#34;company&#34;]?.stringValue ?? &#34;Acme Corp&#34;&#xA;        let interviewee = params.arguments?[&#34;interviewee&#34;]?.stringValue ?? &#34;Candidate&#34;&#xA;&#xA;        let description = &#34;Job interview for \(position) position at \(company)&#34;&#xA;        let messages: [Prompt.Message] = [&#xA;            .init(role: .user, content: .text(text: &#34;You are an interviewer for the \(position) position at \(company).&#34;)),&#xA;            .init(role: .user, content: .text(text: &#34;Hello, I&#39;m \(interviewee) and I&#39;m here for the \(position) interview.&#34;)),&#xA;            .init(role: .assistant, content: .text(text: &#34;Hi \(interviewee), welcome to \(company)! I&#39;d like to start by asking about your background and experience.&#34;))&#xA;        ]&#xA;&#xA;        return .init(description: description, messages: messages)&#xA;&#xA;    case &#34;customer-support&#34;:&#xA;        // Similar implementation for customer support prompt&#xA;&#xA;    default:&#xA;        throw MCPError.invalidParams(&#34;Unknown prompt name: \(params.name)&#34;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Initialize Hook&lt;/h4&gt; &#xA;&lt;p&gt;Control client connections with an initialize hook:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Start the server with an initialize hook&#xA;try await server.start(transport: transport) { clientInfo, clientCapabilities in&#xA;    // Validate client info&#xA;    guard clientInfo.name != &#34;BlockedClient&#34; else {&#xA;        throw MCPError.invalidRequest(&#34;This client is not allowed&#34;)&#xA;    }&#xA;&#xA;    // You can also inspect client capabilities&#xA;    if clientCapabilities.tools == nil {&#xA;        print(&#34;Client does not support tools&#34;)&#xA;    }&#xA;&#xA;    // Perform any server-side setup based on client info&#xA;    print(&#34;Client \(clientInfo.name) v\(clientInfo.version) connected&#34;)&#xA;&#xA;    // If the hook completes without throwing, initialization succeeds&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Graceful Shutdown&lt;/h3&gt; &#xA;&lt;p&gt;We recommend using &lt;a href=&#34;https://github.com/swift-server/swift-service-lifecycle&#34;&gt;Swift Service Lifecycle&lt;/a&gt; for managing startup and shutdown of services.&lt;/p&gt; &#xA;&lt;p&gt;First, add the dependency to your &lt;code&gt;Package.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.package(url: &#34;https://github.com/swift-server/swift-service-lifecycle.git&#34;, from: &#34;2.3.0&#34;),&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then implement the MCP server as a &lt;code&gt;Service&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import MCP&#xA;import ServiceLifecycle&#xA;import Logging&#xA;&#xA;struct MCPService: Service {&#xA;    let server: Server&#xA;    let transport: Transport&#xA;&#xA;    init(server: Server, transport: Transport) {&#xA;        self.server = server&#xA;        self.transport = transport&#xA;    }&#xA;&#xA;    func run() async throws {&#xA;        // Start the server&#xA;        try await server.start(transport: transport)&#xA;&#xA;        // Keep running until external cancellation&#xA;        try await Task.sleep(for: .days(365 * 100))  // Effectively forever&#xA;    }&#xA;&#xA;    func shutdown() async throws {&#xA;        // Gracefully shutdown the server&#xA;        await server.stop()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then use it in your application:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import MCP&#xA;import ServiceLifecycle&#xA;import Logging&#xA;&#xA;let logger = Logger(label: &#34;com.example.mcp-server&#34;)&#xA;&#xA;// Create the MCP server&#xA;let server = Server(&#xA;    name: &#34;MyModelServer&#34;,&#xA;    version: &#34;1.0.0&#34;,&#xA;    capabilities: .init(&#xA;        prompts: .init(listChanged: true),&#xA;        resources: .init(subscribe: true, listChanged: true),&#xA;        tools: .init(listChanged: true)&#xA;    ),&#xA;    logger: logger&#xA;)&#xA;&#xA;// Add handlers directly to the server&#xA;server.withMethodHandler(ListTools.self) { _ in&#xA;    // Your implementation&#xA;    return .init(tools: [&#xA;        Tool(name: &#34;example&#34;, description: &#34;An example tool&#34;)&#xA;    ])&#xA;}&#xA;&#xA;server.withMethodHandler(CallTool.self) { params in&#xA;    // Your implementation&#xA;    return .init(content: [.text(&#34;Tool result&#34;)], isError: false)&#xA;}&#xA;&#xA;// Create MCP service and other services&#xA;let transport = StdioTransport(logger: logger)&#xA;let mcpService = MCPService(server: server, transport: transport)&#xA;let databaseService = DatabaseService() // Your other services&#xA;&#xA;// Create service group with signal handling&#xA;let serviceGroup = ServiceGroup(&#xA;    services: [mcpService, databaseService],&#xA;    configuration: .init(&#xA;        gracefulShutdownSignals: [.sigterm, .sigint]&#xA;    ),&#xA;    logger: logger&#xA;)&#xA;&#xA;// Run the service group - this blocks until shutdown&#xA;try await serviceGroup.run()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This approach has several benefits:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Signal handling&lt;/strong&gt;: Automatically traps SIGINT, SIGTERM and triggers graceful shutdown&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Graceful shutdown&lt;/strong&gt;: Properly shuts down your MCP server and other services&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Timeout-based shutdown&lt;/strong&gt;: Configurable shutdown timeouts to prevent hanging processes&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Advanced service management&lt;/strong&gt;: &lt;a href=&#34;https://swiftpackageindex.com/swift-server/swift-service-lifecycle/documentation/servicelifecycle&#34;&gt;&lt;code&gt;ServiceLifecycle&lt;/code&gt;&lt;/a&gt; also supports service dependencies, conditional services, and other useful features.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Transports&lt;/h2&gt; &#xA;&lt;p&gt;MCP&#39;s transport layer handles communication between clients and servers. The Swift SDK provides multiple built-in transports:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Transport&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Platforms&lt;/th&gt; &#xA;   &lt;th&gt;Best for&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/modelcontextprotocol/swift-sdk/main/Sources/MCP/Base/Transports/StdioTransport.swift&#34;&gt;&lt;code&gt;StdioTransport&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Implements &lt;a href=&#34;https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#stdio&#34;&gt;stdio transport&lt;/a&gt; using standard input/output streams&lt;/td&gt; &#xA;   &lt;td&gt;Apple platforms, Linux with glibc&lt;/td&gt; &#xA;   &lt;td&gt;Local subprocesses, CLI tools&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/modelcontextprotocol/swift-sdk/main/Sources/MCP/Base/Transports/HTTPClientTransport.swift&#34;&gt;&lt;code&gt;HTTPClientTransport&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Implements &lt;a href=&#34;https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#streamable-http&#34;&gt;Streamable HTTP transport&lt;/a&gt; using Foundation&#39;s URL Loading System&lt;/td&gt; &#xA;   &lt;td&gt;All platforms with Foundation&lt;/td&gt; &#xA;   &lt;td&gt;Remote servers, web applications&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/modelcontextprotocol/swift-sdk/main/Sources/MCP/Base/Transports/NetworkTransport.swift&#34;&gt;&lt;code&gt;NetworkTransport&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Custom transport using Apple&#39;s Network framework for TCP/UDP connections&lt;/td&gt; &#xA;   &lt;td&gt;Apple platforms only&lt;/td&gt; &#xA;   &lt;td&gt;Low-level networking, custom protocols&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Custom Transport Implementation&lt;/h3&gt; &#xA;&lt;p&gt;You can implement a custom transport by conforming to the &lt;code&gt;Transport&lt;/code&gt; protocol:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import MCP&#xA;import Foundation&#xA;&#xA;public actor MyCustomTransport: Transport {&#xA;    public nonisolated let logger: Logger&#xA;    private var isConnected = false&#xA;    private let messageStream: AsyncThrowingStream&amp;lt;Data, Error&amp;gt;&#xA;    private let messageContinuation: AsyncThrowingStream&amp;lt;Data, Error&amp;gt;.Continuation&#xA;&#xA;    public init(logger: Logger? = nil) {&#xA;        self.logger = logger ?? Logger(label: &#34;my.custom.transport&#34;)&#xA;&#xA;        var continuation: AsyncThrowingStream&amp;lt;Data, Error&amp;gt;.Continuation!&#xA;        self.messageStream = AsyncThrowingStream { continuation = $0 }&#xA;        self.messageContinuation = continuation&#xA;    }&#xA;&#xA;    public func connect() async throws {&#xA;        // Implement your connection logic&#xA;        isConnected = true&#xA;    }&#xA;&#xA;    public func disconnect() async {&#xA;        // Implement your disconnection logic&#xA;        isConnected = false&#xA;        messageContinuation.finish()&#xA;    }&#xA;&#xA;    public func send(_ data: Data) async throws {&#xA;        // Implement your message sending logic&#xA;    }&#xA;&#xA;    public func receive() -&amp;gt; AsyncThrowingStream&amp;lt;Data, Error&amp;gt; {&#xA;        return messageStream&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Platform Availability&lt;/h2&gt; &#xA;&lt;p&gt;The Swift SDK has the following platform requirements:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Platform&lt;/th&gt; &#xA;   &lt;th&gt;Minimum Version&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;macOS&lt;/td&gt; &#xA;   &lt;td&gt;13.0+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;iOS / Mac Catalyst&lt;/td&gt; &#xA;   &lt;td&gt;16.0+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;watchOS&lt;/td&gt; &#xA;   &lt;td&gt;9.0+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tvOS&lt;/td&gt; &#xA;   &lt;td&gt;16.0+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;visionOS&lt;/td&gt; &#xA;   &lt;td&gt;1.0+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Linux&lt;/td&gt; &#xA;   &lt;td&gt;Distributions with &lt;code&gt;glibc&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;While the core library works on any platform supporting Swift 6 (including Linux and Windows), running a client or server requires a compatible transport.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;re actively working to expand platform support:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/modelcontextprotocol/swift-sdk/pull/64&#34;&gt;Alpine Linux support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/modelcontextprotocol/swift-sdk/pull/64&#34;&gt;Windows support&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Debugging and Logging&lt;/h2&gt; &#xA;&lt;p&gt;Enable logging to help troubleshoot issues:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Logging&#xA;import MCP&#xA;&#xA;// Configure Logger&#xA;LoggingSystem.bootstrap { label in&#xA;    var handler = StreamLogHandler.standardOutput(label: label)&#xA;    handler.logLevel = .debug&#xA;    return handler&#xA;}&#xA;&#xA;// Create logger&#xA;let logger = Logger(label: &#34;com.example.mcp&#34;)&#xA;&#xA;// Pass to client/server&#xA;let client = Client(name: &#34;MyApp&#34;, version: &#34;1.0.0&#34;, logger: logger)&#xA;&#xA;// Pass to transport&#xA;let transport = StdioTransport(logger: logger)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Additional Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://modelcontextprotocol.io/specification/2025-03-26/&#34;&gt;MCP Specification&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://modelcontextprotocol.io&#34;&gt;Protocol Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/modelcontextprotocol/swift-sdk&#34;&gt;GitHub Repository&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;This project follows &lt;a href=&#34;https://semver.org/&#34;&gt;Semantic Versioning&lt;/a&gt;. For pre-1.0 releases, minor version increments (0.X.0) may contain breaking changes.&lt;/p&gt; &#xA;&lt;p&gt;For details about changes in each release, see the &lt;a href=&#34;https://github.com/modelcontextprotocol/swift-sdk/releases&#34;&gt;GitHub Releases page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under the MIT License.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>krzysztofzablocki/Inject</title>
    <updated>2025-05-11T01:45:34Z</updated>
    <id>tag:github.com,2025-05-11:/krzysztofzablocki/Inject</id>
    <link href="https://github.com/krzysztofzablocki/Inject" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Hot Reloading for Swift applications!&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Inject&lt;/h1&gt; &#xA;&lt;p&gt;Hot reloading workflow helper that enables you to save hours of time each week, regardless if you are using &lt;code&gt;UIKit&lt;/code&gt;, &lt;code&gt;AppKit&lt;/code&gt; or &lt;code&gt;SwiftUI&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.swiftystack.com/&#34;&gt;&lt;strong&gt;If you&#39;d like to support my work and improve your engineering workflows, check out my SwiftyStack course&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;TLDR: A single line of code&lt;/strong&gt; change allows you to live code &lt;code&gt;UIKit&lt;/code&gt; screen:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/26660989/161756368-b150bc25-b66f-4822-86ee-2e4aed713932.mp4&#34;&gt;https://user-images.githubusercontent.com/26660989/161756368-b150bc25-b66f-4822-86ee-2e4aed713932.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://merowing.info/2022/04/hot-reloading-in-swift/&#34;&gt;Read detailed article about this&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The heavy lifting is done by the amazing &lt;a href=&#34;https://github.com/johnno1962/InjectionIII&#34;&gt;InjectionIII&lt;/a&gt;. This library is just a thin wrapper to provide the best developer experience possible while requiring minimum effort.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;ve been using it for years.&lt;/p&gt; &#xA;&lt;h2&gt;What is hot reloading?&lt;/h2&gt; &#xA;&lt;p&gt;Hot reloading is a technique allowing you to get rid of compiling your whole application and avoiding deploy/restart cycles as much as possible, all while allowing you to edit your running application code and see changes reflected as close as possible to real-time.&lt;/p&gt; &#xA;&lt;p&gt;This makes you significantly more productive by reducing the time you spend waiting for apps to rebuild, restart, re-navigate to the previous location where you were in the app itself, re-produce the data you need.&lt;/p&gt; &#xA;&lt;p&gt;This can save you literal hours off development time, &lt;strong&gt;each day&lt;/strong&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;Does it add manual overhead to my workflows?&lt;/h2&gt; &#xA;&lt;p&gt;Once you configured your project initially, it&#39;s practically free.&lt;/p&gt; &#xA;&lt;p&gt;You donâ€™t need to add conditional compilation or remove &lt;code&gt;Inject&lt;/code&gt; code from your applications for production, it&#39;s already designed to behave as no-op inlined code that will get stripped by LLVM in non-debug builds.&lt;/p&gt; &#xA;&lt;p&gt;Which means that you can enable it once per view and keep using it for years to come.&lt;/p&gt; &#xA;&lt;h1&gt;Integration&lt;/h1&gt; &#xA;&lt;h3&gt;Initial project setup&lt;/h3&gt; &#xA;&lt;p&gt;To integrate &lt;code&gt;Inject&lt;/code&gt; just add it as SPM dependency:&lt;/p&gt; &#xA;&lt;h3&gt;via Xcode&lt;/h3&gt; &#xA;&lt;p&gt;Open your project, click on File â†’ Swift Packages â†’ Add Package Dependencyâ€¦, enter the repository url (&lt;code&gt;https://github.com/krzysztofzablocki/Inject.git&lt;/code&gt;) and add the package product to your app target.&lt;/p&gt; &#xA;&lt;h3&gt;via SPM package.swift&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(&#xA;      url: &#34;https://github.com/krzysztofzablocki/Inject.git&#34;,&#xA;      from: &#34;1.2.4&#34;&#xA;    )&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;via Cocoapods Podfile&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;InjectHotReload&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Individual Developer setup (once per machine)&lt;/h3&gt; &#xA;&lt;p&gt;If anyone in your project wants to use injection, they only need to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You must add &#34;-Xlinker -interposable&#34; (without the double quotes and on separate lines) to the &#34;Other Linker Flags&#34; of all targets in your project for the &lt;strong&gt;Debug&lt;/strong&gt; configuration (qualified by the simulator SDK to avoid complications with bitcode), refer to &lt;a href=&#34;https://github.com/johnno1962/InjectionIII#limitationsfaq&#34;&gt;InjectionForXcode documentation&lt;/a&gt; if you run into any issues&lt;/li&gt; &#xA; &lt;li&gt;Download newest version of Xcode Injection from it&#39;s &lt;a href=&#34;https://github.com/johnno1962/InjectionIII/releases&#34;&gt;GitHub Page&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Unpack it and place under &lt;code&gt;/Applications&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Make sure that the Xcode version you are using to compile our projects is under the default location: &lt;code&gt;/Applications/Xcode.app&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run the injection application&lt;/li&gt; &#xA; &lt;li&gt;Select open project / open recent from it&#39;s menu and pick the right workspace file you are using&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After choosing the project in Injection app, launch the app&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If everything is configured correctly you should see similar log in the console:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ðŸ’‰ InjectionIII connected /Users/merowing/work/SourceryPro/App.xcworkspace&#xA;ðŸ’‰ Watching files under /Users/merowing/work/SourceryPro&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Workflow integration&lt;/h2&gt; &#xA;&lt;p&gt;You can either add &lt;code&gt;import Inject&lt;/code&gt; in individual files in your project or use &lt;code&gt;@_exported import Inject&lt;/code&gt; in your project target to have it automatically available in all its files.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;strong&gt;SwiftUI&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Just 2 steps to enable injection in your &lt;code&gt;SwiftUI&lt;/code&gt; Views&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;call &lt;code&gt;.enableInjection()&lt;/code&gt; at the end of your body definition&lt;/li&gt; &#xA; &lt;li&gt;add &lt;code&gt;@ObserveInjection var inject&lt;/code&gt; to your view struct&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;Remember you &lt;strong&gt;don&#39;t need&lt;/strong&gt; to remove this code when you are done, it&#39;s NO-OP in production builds.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If you want to see your changes in action, you can enable an optional &lt;code&gt;Animation&lt;/code&gt; variable on &lt;code&gt;InjectConfiguration.animation&lt;/code&gt; that will be used when ever new source code is injected into your application.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;InjectConfiguration.animation = .interactiveSpring()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using &lt;code&gt;Inject&lt;/code&gt; is demoed in this &lt;a href=&#34;https://github.com/MarcoEidinger/InjectSwiftUIExample&#34;&gt;example app&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;strong&gt;UIKit / AppKit&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;For standard imperative UI frameworks we need a way to clean-up state between code injection phases.&lt;/p&gt; &#xA;&lt;p&gt;I create the concept of &lt;strong&gt;Hosts&lt;/strong&gt; that work really well in that context, there are 2:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ViewControllerHost&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ViewHost&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;How do we integrate this? We wrap the class we want to iterate on at the parent level, so we donâ€™t modify the class we want to be injecting but we modify the parent callsite.&lt;/p&gt; &#xA;&lt;p&gt;Eg. If you have a &lt;code&gt;SplitViewController&lt;/code&gt; that creates &lt;code&gt;PaneA&lt;/code&gt; and &lt;code&gt;PaneB &lt;/code&gt;, and you want to iterate on layout/logic code in &lt;code&gt;PaneA&lt;/code&gt;, you modify the callsite in &lt;code&gt;SplitViewController&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;paneA = Inject.ViewHost(&#xA;  PaneAView(whatever: arguments, you: want)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That is all the changes you need to do, your app now allows you to change anything in &lt;code&gt;PaneAView&lt;/code&gt; except for its initialiser API and the changes will be almost immediately reflected in your App.&lt;/p&gt; &#xA;&lt;p&gt;Make sure to call initializer inside &lt;code&gt;Inject.ViewControllerHost(...)&lt;/code&gt; or &lt;code&gt;Inject.ViewHost(...)&lt;/code&gt;. Inject relies on &lt;code&gt;@autoclosure&lt;/code&gt; to reload views when hot-reload happens. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// WRONG&#xA;let viewController = YourViewController()&#xA;rootViewController.pushViewController(Inject.ViewControllerHost(viewController), animated: true)&#xA;&#xA;// CORRECT&#xA;let viewController = Inject.ViewControllerHost(YourViewController())&#xA;rootViewController.pushViewController(viewController, animated: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;Remember you &lt;strong&gt;don&#39;t need&lt;/strong&gt; to remove this code when you are done, it&#39;s NO-OP in production builds.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;&lt;strong&gt;Injection Hook for UIKit&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;depending on the architecture used in your UIKit App, you might want to attach a hook to be executed each time a view controller is reloaded.&lt;/p&gt; &#xA;&lt;p&gt;Eg. you might want to bind the &lt;code&gt;UIViewController&lt;/code&gt; to the presenter each-time there&#39;s a reload, to achieve this you can use &lt;code&gt;onInjectionHook&lt;/code&gt; Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myView.onInjectionHook = { hostedViewController in&#xA;//any thing here will be executed each time the controller is reloaded&#xA;// for example, you might want to re-assign the controller to your presenter&#xA;presenter.ui = hostedViewController&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;(Optional) Automatic Injection Script&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;WARNING:&lt;/strong&gt; This script automatically modifies your Swift source code. It&#39;s provided as a convenience but use it with caution! Review the changes it makes carefully. It might not be suitable for all projects or coding styles. Consider using Xcode code snippets for more manual control.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To automatically add &lt;code&gt;import Inject&lt;/code&gt;, &lt;code&gt;@ObserveInjection var inject&lt;/code&gt;, and &lt;code&gt;.enableInjection()&lt;/code&gt; to your SwiftUI views, you can add the following script as a &#34;Run Script&#34; build phase in your Xcode project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash&#xA;&#xA;# Function to modify a single Swift file&#xA;modify_swift_file() {&#xA;    local filepath=&#34;$1&#34;&#xA;    local filename=$(basename &#34;$filepath&#34;)&#xA;    local tempfile=&#34;$filepath.tmp&#34;&#xA;&#xA;    # Check if the file should be processed&#xA;    if [[ $(grep -c &#34;: View {&#34; &#34;$filepath&#34;) -eq 0 ]]; then&#xA;        echo &#34;Skipping: $filename (No &#39;: View {&#39; found)&#34;&#xA;        return&#xA;    fi&#xA;&#xA;    # Create a temporary file for modifications&#xA;    cp &#34;$filepath&#34; &#34;$tempfile&#34;&#xA;&#xA;    # 1. Add import Inject if needed&#xA;    if ! grep -q &#34;import Inject&#34; &#34;$tempfile&#34;; then&#xA;        sed -i &#39;&#39; -e &#39;/^import SwiftUI/a\&#xA;import Inject&#39; &#34;$tempfile&#34;&#xA;    fi&#xA;&#xA;    # 2. Add @ObserveInjection var inject if needed&#xA;    if ! grep -q &#34;@ObserveInjection var inject&#34; &#34;$tempfile&#34;; then&#xA;        sed -i &#39;&#39; -e &#39;/struct.*: View {/a\&#xA;    @ObserveInjection var inject&#39; &#34;$tempfile&#34;&#xA;    fi&#xA;&#xA;    # 3. Add .enableInjection() just before the closing brace of the body&#xA;    # Find the start of var body: some View {&#xA;    local body_start_line=$(grep -n &#34;var body: some View {&#34; &#34;$tempfile&#34; | cut -d &#39;:&#39; -f 1)&#xA;&#xA;    if [[ -n &#34;$body_start_line&#34; ]]; then&#xA;        # Get the line number of the closing brace of the body&#xA;        local body_end_line=$(awk -v start=&#34;$body_start_line&#34; &#39;&#xA;            NR == start { count = 1 }&#xA;            NR &amp;gt; start {&#xA;                if ($0 ~ /{/) count++&#xA;                if ($0 ~ /}/) {&#xA;                    count--&#xA;                    if (count == 0) {&#xA;                        print NR&#xA;                        exit&#xA;                    }&#xA;                }&#xA;            }&#xA;        &#39; &#34;$tempfile&#34;)&#xA;&#xA;        if [[ -n &#34;$body_end_line&#34; ]]; then&#xA;            # Check if .enableInjection() is already present&#xA;            if ! grep -q &#34;.enableInjection()&#34; &#34;$tempfile&#34;; then&#xA;                # Insert .enableInjection() before the closing brace of the body&#xA;                sed -i &#39;&#39; -e &#34;${body_end_line}i\\&#xA;        .enableInjection()&#34; &#34;$tempfile&#34;&#xA;            fi&#xA;        fi&#xA;    fi&#xA;&#xA;    # Check if modifications were made and overwrite the original file&#xA;    if ! cmp -s &#34;$filepath&#34; &#34;$tempfile&#34;; then&#xA;        mv &#34;$tempfile&#34; &#34;$filepath&#34;&#xA;        echo &#34;Modified: $filename&#34;&#xA;    else&#xA;        echo &#34;No changes for: $filename&#34;&#xA;    fi&#xA;&#xA;    rm -f &#34;$tempfile&#34;&#xA;}&#xA;&#xA;# Main script&#xA;find &#34;$SRCROOT&#34; -name &#34;*.swift&#34; -print0 | while IFS= read -r -d $&#39;\0&#39; filepath; do&#xA;    modify_swift_file &#34;$filepath&#34;&#xA;done&#xA;&#xA;echo &#34;Inject modification script completed.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;iOS 12&lt;/h4&gt; &#xA;&lt;p&gt;You need to add -weak_framework SwiftUI to Other Linker Flags for iOS 12 to work.&lt;/p&gt; &#xA;&lt;h4&gt;The Composable Architecture&lt;/h4&gt; &#xA;&lt;p&gt;Since the introduction of ReducerProtocol you can use Inject with TCA without support code.&lt;/p&gt;</summary>
  </entry>
</feed>