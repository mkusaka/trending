<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-05T02:01:16Z</updated>
  <subtitle>Weekly Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hmlongco/Factory</title>
    <updated>2023-03-05T02:01:16Z</updated>
    <id>tag:github.com,2023-03-05:/hmlongco/Factory</id>
    <link href="https://github.com/hmlongco/Factory" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A new approach to Container-Based Dependency Injection for Swift and SwiftUI.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/hmlongco/Factory/raw/main/Logo.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A new approach to Container-Based Dependency Injection for Swift and SwiftUI.&lt;/p&gt; &#xA;&lt;h2&gt;Factory 2.0&lt;/h2&gt; &#xA;&lt;p&gt;Factory is strongly influenced by SwiftUI, and in my opinion is highly suited for use in that environment. Factory is...&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Adaptable&lt;/strong&gt;: Factory doesn&#39;t tie you down to a single dependency injection strategy or technique.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Powerful&lt;/strong&gt;: Factory supports containers, scopes, passed parameters, decorators, unit tests, SwiftUI Previews, and much, much more.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Performant&lt;/strong&gt;: Little to no setup time is needed for the vast majority of your services, resolutions are extremely fast, and no compile-time scripts or build phases are needed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Safe&lt;/strong&gt;: Factory is compile-time safe; a factory for a given type must exist or the code simply will not compile.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Concise&lt;/strong&gt;: Defining a registration usually takes just a single line of code. Same for resolution.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Flexible&lt;/strong&gt;: Working with UIKIt or SwiftUI? iOS or macOS? Using MVVM? MVP? Clean? VIPER? No problem. Factory works with all of these and more.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Documented&lt;/strong&gt;: Factory 2.0 has extensive DocC documentation and examples covering its classes, methods, and use cases.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Lightweight&lt;/strong&gt;: With all of that Factory is slim and trim, just 421 lines of executable code and half the size of Resolver.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Tested&lt;/strong&gt;: Unit tests with 100% code coverage helps ensure correct operation of registrations, resolutions, and scopes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Free&lt;/strong&gt;: Factory is free and open source under the MIT License.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Sound too good to be true? Let&#39;s take a look.&lt;/p&gt; &#xA;&lt;h2&gt;A Simple Example&lt;/h2&gt; &#xA;&lt;p&gt;Most container-based dependency injection systems require you to define in some way that a given service type is available for injection and many require some sort of factory or mechanism that will provide a new instance of the service when needed.&lt;/p&gt; &#xA;&lt;p&gt;Factory is no exception. Here&#39;s a simple dependency registration that returns a service that conforms to &lt;code&gt;MyServiceType&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    var myService: Factory&amp;lt;MyServiceType&amp;gt; { &#xA;        Factory(self) { MyService() }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unlike Resolver which often requires defining a plethora of nested registration functions, or SwiftUI, where defining a new environment variable requires creating a new EnvironmentKey and adding additional getters and setters, here we simply add a new &lt;code&gt;Factory&lt;/code&gt; computed variable to the default container. When it&#39;s called our Factory is created, its closure is evaluated, and we get an instance of our dependency when we need it.&lt;/p&gt; &#xA;&lt;p&gt;Injecting an instance of our service is equally straightforward. Here&#39;s just one of the many ways Factory can be used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ContentViewModel: ObservableObject {&#xA;    @Injected(\.myService) private var myService&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This particular view model uses one of Factory&#39;s &lt;code&gt;@Injected&lt;/code&gt; property wrappers to request the desired dependency. Similar to &lt;code&gt;@Environment&lt;/code&gt; in SwiftUI, we provide the property wrapper with a keyPath to a factory of the desired type and it resolves that type the moment &lt;code&gt;ContentViewModel&lt;/code&gt; is created.&lt;/p&gt; &#xA;&lt;p&gt;And that&#39;s the core mechanism. In order to use the property wrapper you &lt;em&gt;must&lt;/em&gt; define a factory within the specified container. That factory &lt;em&gt;must&lt;/em&gt; return the desired type when asked. Fail to do either one and the code will simply not compile. As such, Factory is compile-time safe.&lt;/p&gt; &#xA;&lt;p&gt;By the way, if you&#39;re concerned about building Factory&#39;s on the fly, don&#39;t be. Like SwftUI Views, Factory structs and modifiers are lightweight and transitory value types. They&#39;re created inside computed variables &lt;strong&gt;only&lt;/strong&gt; when they&#39;re needed and then immediately discarded once their purpose has been served.&lt;/p&gt; &#xA;&lt;p&gt;For more examples of Factory definitions that define scopes, use constructor injection, and do parameter passing, see the &lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory/registrations&#34;&gt;Registrations&lt;/a&gt; page.&lt;/p&gt; &#xA;&lt;h2&gt;Resolving Factories&lt;/h2&gt; &#xA;&lt;p&gt;Earlier we demonstrated how to use the &lt;code&gt;Injected&lt;/code&gt; property wrapper. But it&#39;s also possible to bypass the property wrapper and talk to the factory yourself.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ContentViewModel: ObservableObject {&#xA;    private let myService = Container.shared.myService()&#xA;    private let eventLogger = Container.shared.eventLogger()&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Just call the desired factory as a function and you&#39;ll get an instance of its managed dependency. It&#39;s that simple.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re into container-based dependency injection, note that you can also pass an instance of a container to a view model and obtain an instance of your service directly from that container.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ContentViewModel: ObservableObject {&#xA;    let service: MyServiceType&#xA;    init(container: Container) {&#xA;        service = container.service()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or if you want to use a Composition Root structure, just use the container to provide the required dependencies to a constructor.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    var myRepository: Factory&amp;lt;MyRepositoryType&amp;gt; {&#xA;        Factory(self) { MyRepository(service: self.networkService()) }&#xA;    }&#xA;    var networkService: Factory&amp;lt;Networking&amp;gt; {&#xA;        Factory(self) { MyNetworkService() }&#xA;    }&#xA;}&#xA;&#xA;@main&#xA;struct FactoryDemoApp: App {&#xA;    let viewModel = MyViewModel(repository: Container.shared.myRepository())&#xA;    var body: some Scene {&#xA;        WindowGroup {&#xA;            NavigationView {&#xA;                ContentView(viewModel: viewModel)&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Factory is flexible, and it doesn&#39;t tie you down to a specific dependency injection pattern or technique.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory/resolutions&#34;&gt;Resolutions&lt;/a&gt; for more examples.&lt;/p&gt; &#xA;&lt;h2&gt;Mocking&lt;/h2&gt; &#xA;&lt;p&gt;If we go back and look at our original view model code one might wonder why we&#39;ve gone to all of this trouble? Why not simply say &lt;code&gt;let myService = MyService()&lt;/code&gt; and be done with it?&lt;/p&gt; &#xA;&lt;p&gt;Or keep the container idea, but write something similar to this…&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    static var myService: MyServiceType { MyService() }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Well, the primary benefit one gains from using a container-based dependency injection system is that we&#39;re able to change the behavior of the system as needed. Consider the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @StateObject var model = ContentViewModel()&#xA;    var body: some View {&#xA;        Text(model.text())&#xA;            .padding()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Our ContentView uses our view model, which is assigned to a StateObject. Great. But now we want to preview our code. How do we change the behavior of &lt;code&gt;ContentViewModel&lt;/code&gt; so that its &lt;code&gt;MyService&lt;/code&gt; dependency isn&#39;t making live API calls during development?&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s easy. Just replace &lt;code&gt;MyService&lt;/code&gt; with a mock that also conforms to &lt;code&gt;MyServiceType&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView_Previews: PreviewProvider {&#xA;    static var previews: some View {&#xA;        let _ = Container.myService.register { MockService2() }&#xA;        ContentView()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note the line in our preview code where we’re gone back to our container and registered a new closure on our factory. This function overrides the default factory closure.&lt;/p&gt; &#xA;&lt;p&gt;Now when our preview is displayed &lt;code&gt;ContentView&lt;/code&gt; creates a &lt;code&gt;ContentViewModel&lt;/code&gt; which in turn has a dependency on &lt;code&gt;myService&lt;/code&gt; using the &lt;code&gt;Injected&lt;/code&gt; property wrapper. And when the wrapper asks the factory for an instance of &lt;code&gt;MyServiceType&lt;/code&gt; it now gets a &lt;code&gt;MockService2&lt;/code&gt; instead of the &lt;code&gt;MyService&lt;/code&gt; type originally defined.&lt;/p&gt; &#xA;&lt;p&gt;This is a powerful concept that lets us reach deep into a chain of dependencies and alter the behavior of a system as needed.&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;The same concept can be used used when writing unit tests. Consider the following.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;final class FactoryCoreTests: XCTestCase {&#xA;&#xA;    override func setUp() {&#xA;        super.setUp()&#xA;        Container.shared = Container()&#xA;    }&#xA;    &#xA;    func testLoaded() throws {&#xA;        Container.shared.accountProvider.register { MockProvider(accounts: .sampleAccounts) }&#xA;        let model = Container.shared.someViewModel()&#xA;        model.load()&#xA;        XCTAssertTrue(model.isLoaded)&#xA;    }&#xA;&#xA;    func testEmpty() throws {&#xA;        Container.shared.accountProvider.register { MockProvider(accounts: []) }&#xA;        let model = Container.shared.someViewModel()&#xA;        model.load()&#xA;        XCTAssertTrue(model.isEmpty)&#xA;    }&#xA;&#xA;    func testErrors() throws {&#xA;        Container.shared.accountProvider.register { MockProvider(error: .notFoundError) }&#xA;        let model = Container.shared.someViewModel()&#xA;        model.load()&#xA;        XCTAssertTrue(model.errorMessage = &#34;Some Error&#34;)&#xA;    }&#xA;    &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Again, Factory makes it easy to reach into a chain of dependencies and make specific changes to the system as needed. This makes testing loading states, empty states, and error conditions simple.&lt;/p&gt; &#xA;&lt;p&gt;But we&#39;re not done yet.&lt;/p&gt; &#xA;&lt;p&gt;Factory has quite a few more tricks up its sleeve...&lt;/p&gt; &#xA;&lt;h2&gt;Scope&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;ve used Resolver or some other dependency injection system before then you&#39;ve probably experienced the benefits and power of scopes.&lt;/p&gt; &#xA;&lt;p&gt;And if not, the concept is easy to understand: Just how long should an instance of an object live?&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ve no doubt stuffed an instance of a class into a variable and created a singleton at some point in your career. This is an example of a scope. A single instance is created and then used and shared by all of the methods and functions in the app.&lt;/p&gt; &#xA;&lt;p&gt;This can be done in Factory just by adding a scope modifer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    var networkService: Factory&amp;lt;NetworkProviding&amp;gt; { &#xA;        self { NetworkProvider() }&#xA;            .singleton&#xA;    }&#xA;    var myService: Factory&amp;lt;MyServiceType&amp;gt; { &#xA;        self { MyService() }&#xA;            .scope(.session)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now whenever someone requests an instance of &lt;code&gt;networkService&lt;/code&gt; they&#39;ll get the same instance of the object as everyone else.&lt;/p&gt; &#xA;&lt;p&gt;Note that the client neither knows nor cares about the scope. Nor should it. The client is simply given what it needs when it needs it.&lt;/p&gt; &#xA;&lt;p&gt;If no scope is specified the default scope is unique. A new instance of the service will be instantiated and returned every time one is requested from the factory.&lt;/p&gt; &#xA;&lt;p&gt;Other common scopes are &lt;code&gt;cached&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt;. Cached items are persisted until the cache is reset, while shared items exist just as long as someone holds a strong reference to them. When the last reference goes away, the weakly held shared reference also goes away.&lt;/p&gt; &#xA;&lt;p&gt;Factory has other scope types, plus the ability to define your own. See &lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory/scopes&#34;&gt;Scopes&lt;/a&gt; for additonal examples.&lt;/p&gt; &#xA;&lt;p&gt;Scopes and scope management are powerful tools to have in your dependency injection arsenal.&lt;/p&gt; &#xA;&lt;h2&gt;Simplified Syntax&lt;/h2&gt; &#xA;&lt;p&gt;You may have noticed in the previous example that Factory also provides a bit of syntactical sugar that lets us make our definitions more concise. We simply ask the enclosing container to make a properly bound Factory for us using &lt;code&gt;self.callAsFunction { ... }&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    var sugared: Factory&amp;lt;MyServiceType&amp;gt; { &#xA;        self { MyService() }&#xA;    }&#xA;    var formal: Factory&amp;lt;MyServiceType&amp;gt; { &#xA;        Factory(self) { MyService() }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both definitions provide the same exact result. The sugared function is even inlined, so there&#39;s not even a performance difference between the two versions.&lt;/p&gt; &#xA;&lt;h2&gt;Debugging&lt;/h2&gt; &#xA;&lt;p&gt;Factory can also help you debug your code.&lt;/p&gt; &#xA;&lt;p&gt;For example, when running in DEBUG mode Factory allows you to trace the injection process and see every object created or returned during a given resolution cycle.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;0: Factory.Container.cycleDemo = CycleDemo N:105553131389696&#xA;1:     Factory.Container.aService = AServiceType N:105553119821680&#xA;2:         Factory.Container.implementsAB = AServiceType &amp;amp; BServiceType N:105553119821680&#xA;3:             Factory.Container.networkService = NetworkService N:105553119770688&#xA;1:     Factory.Container.bService = BServiceType N:105553119821680&#xA;2:         Factory.Container.implementsAB = AServiceType &amp;amp; BServiceType C:105553119821680&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can make it a lot easier to see the entire dependency tree for a given object or service.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory/debugging&#34;&gt;Debugging&lt;/a&gt; for more on this and other features.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;A single README file barely scratches the surface. Fortunately, Factory is throughly documented.&lt;/p&gt; &#xA;&lt;p&gt;Current DocC documentation can be found in the project as well as online on &lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory&#34;&gt;GitHub Pages&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Factory 2.0 Migration&lt;/h2&gt; &#xA;&lt;p&gt;If you started with Factory 1.x a &lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory/migration&#34;&gt;migration document is available here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Factory 2.0 adds true Factory containers for container-based dependency resolution&lt;/li&gt; &#xA; &lt;li&gt;Factory 2.0 adds container-based scopes&lt;/li&gt; &#xA; &lt;li&gt;Factory 2.0 adds decorators to containers and factories&lt;/li&gt; &#xA; &lt;li&gt;Factory 2.0 adds debug trace support&lt;/li&gt; &#xA; &lt;li&gt;Factory 2.0 adds keyPath-based property wrappers&lt;/li&gt; &#xA; &lt;li&gt;Factory 2.0 adds a new InjectedObject property wrapper for SwiftUI Views&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Discussion Forum&lt;/h2&gt; &#xA;&lt;p&gt;Discussion and comments on Factory and Factory 2.0 can be found in &lt;a href=&#34;https://github.com/hmlongco/Factory/discussions&#34;&gt;Discussions&lt;/a&gt;. Go there if you have something to say or if you want to stay up to date.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Factory is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt; &#xA;&lt;h2&gt;Sponsor Factory!&lt;/h2&gt; &#xA;&lt;p&gt;If you want to support my work on Factory and Resolver, consider a &lt;a href=&#34;https://github.com/sponsors/hmlongco&#34;&gt;GitHub Sponsorship&lt;/a&gt;! Many levels exist for increased support and even for mentorship and company training.&lt;/p&gt; &#xA;&lt;p&gt;Or you can just buy me a cup of coffee!&lt;/p&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;Factory is designed, implemented, documented, and maintained by &lt;a href=&#34;https://www.linkedin.com/in/hmlong/&#34;&gt;Michael Long&lt;/a&gt;, a Lead iOS Software Engineer and a Top 1,000 Technology Writer on Medium.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;LinkedIn: &lt;a href=&#34;https://www.linkedin.com/in/hmlong/&#34;&gt;@hmlong&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Medium: &lt;a href=&#34;https://medium.com/@michaellong&#34;&gt;@michaellong&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Twitter: &lt;a href=&#34;https://twitter.com/hmlco&#34;&gt;@hmlco&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Michael was also one of Google&#39;s &lt;a href=&#34;https://opensource.googleblog.com/2021/09/announcing-latest-open-source-peer-bonus-winners.html&#34;&gt;Open Source Peer Reward&lt;/a&gt; winners in 2021 for his work on Resolver.&lt;/p&gt; &#xA;&lt;h2&gt;Additional Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory&#34;&gt;Factory Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://betterprogramming.pub/factory-and-functional-dependency-injection-2d0a38042d05&#34;&gt;Factory and Functional Dependency Injection&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://betterprogramming.pub/factory-multiple-module-registration-f9d19721a31d?sk=a03d78484d8c351762306ff00a8be67c&#34;&gt;Factory: Multiple Module Registration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hmlongco/Resolver&#34;&gt;Resolver: A Swift Dependency Injection System&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Inversion_of_control&#34;&gt;Inversion of Control Design Pattern ~ Wikipedia&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://martinfowler.com/articles/injection.html&#34;&gt;Inversion of Control Containers and the Dependency Injection pattern ~ Martin Fowler&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cocoacasts.com/nuts-and-bolts-of-dependency-injection-in-swift/&#34;&gt;Nuts and Bolts of Dependency Injection in Swift&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cocoacasts.com/dependency-injection-in-swift&#34;&gt;Dependency Injection in Swift&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://medium.com/better-programming/taking-swift-dependency-injection-to-the-next-level-b71114c6a9c6&#34;&gt;Swift 5.1 Takes Dependency Injection to the Next Level&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hmlongco/Builder&#34;&gt;Builder: A Declarative UIKit Library (Uses Factory in Demo)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>aheze/Setting</title>
    <updated>2023-03-05T02:01:16Z</updated>
    <id>tag:github.com,2023-03-05:/aheze/Setting</id>
    <link href="https://github.com/aheze/Setting" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Compose beautiful preference panels.&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aheze/Setting/main/Assets/Top.png&#34; width=&#34;300&#34; alt=&#34;Header image&#34;&gt; &#xA;&lt;p&gt;&lt;strong&gt;Compose beautiful preference panels.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simple but powerful syntax (powered by &lt;a href=&#34;https://www.hackingwithswift.com/swift/5.4/result-builders&#34;&gt;result builders&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Create nested pages and groups.&lt;/li&gt; &#xA; &lt;li&gt;Fully searchable.&lt;/li&gt; &#xA; &lt;li&gt;Native integration with SwiftUI and AppStorage.&lt;/li&gt; &#xA; &lt;li&gt;Comes with pre-made components: Toggle, Button, Slider, etc...&lt;/li&gt; &#xA; &lt;li&gt;Style components with native SwiftUI modifiers.&lt;/li&gt; &#xA; &lt;li&gt;Show and hide components dynamically.&lt;/li&gt; &#xA; &lt;li&gt;Add your own custom SwiftUI views.&lt;/li&gt; &#xA; &lt;li&gt;Works on iOS and macOS.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aheze/Setting/main/Assets/Setting.png&#34; alt=&#34;Screenshots of views created with Setting&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aheze/Setting/main/Assets/Details.png&#34; alt=&#34;Screenshots of a nested page and search results&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Setting is available via the &lt;a href=&#34;https://developer.apple.com/documentation/swift_packages/adding_package_dependencies_to_your_app&#34;&gt;Swift Package Manager&lt;/a&gt;. Requires iOS 15+ or macOS Monterey and up.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;https://github.com/aheze/Setting&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Setting&#xA;import SwiftUI&#xA;&#xA;struct PlaygroundView: View {&#xA;    /// Setting supports `@State`, `@AppStorage`, `@Published`, and more!&#xA;    @AppStorage(&#34;isOn&#34;) var isOn = true&#xA;&#xA;    var body: some View {&#xA;        /// Start things off with `SettingStack`.&#xA;        SettingStack {&#xA;            /// This is the main settings page.&#xA;            SettingPage(title: &#34;Playground&#34;) {&#xA;                /// Use groups to group components together.&#xA;                SettingGroup(header: &#34;Main Group&#34;) {&#xA;                    /// Use any of the pre-made components...&#xA;                    SettingToggle(title: &#34;This value is persisted!&#34;, isOn: $isOn)&#xA;&#xA;                    /// ...or define your own ones!&#xA;                    SettingCustomView {&#xA;                        Image(&#34;Logo&#34;)&#xA;                            .resizable()&#xA;                            .aspectRatio(contentMode: .fit)&#xA;                            .frame(width: 160)&#xA;                            .padding(20)&#xA;                    }&#xA;&#xA;                    /// Nest `SettingPage` inside other `SettingPage`s!&#xA;                    SettingPage(title: &#34;Advanced Settings&#34;) {&#xA;                        SettingText(title: &#34;I show up on the next page!&#34;)&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aheze/Setting/main/Assets/Customizable.png&#34; alt=&#34;The result, a generated settings page. Clicking on &amp;quot;Advanced Settings&amp;quot; presents a new page.&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;p&gt;View more examples in the &lt;a href=&#34;https://github.com/aheze/Setting/tree/main/Example/SettingExample&#34;&gt;example app&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct PlaygroundView: View {&#xA;    var body: some View {&#xA;        SettingStack {&#xA;            SettingPage(title: &#34;Playground&#34;) {&#xA;                SettingGroup {&#xA;                    SettingText(title: &#34;Hello!&#34;)&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aheze/Setting/main/Assets/1.png&#34; alt=&#34;Settings view rendered with &amp;quot;Hello!&amp;quot; label&#34;&gt;&lt;/p&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;SettingStack {&#xA;    SettingPage(title: &#34;Playground&#34;) {&#xA;        SettingGroup {&#xA;            SettingText(title: &#34;Hello!&#34;)&#xA;        }&#xA;&#xA;        SettingGroup {&#xA;            SettingPage(title: &#34;First Page&#34;) {}&#xA;                .previewIcon(&#34;star&#34;)&#xA;&#xA;            SettingPage(title: &#34;Second Page&#34;) {}&#xA;                .previewIcon(&#34;sparkles&#34;)&#xA;&#xA;            SettingPage(title: &#34;Third Page&#34;) {}&#xA;                .previewIcon(&#34;leaf.fill&#34;)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aheze/Setting/main/Assets/2.png&#34; alt=&#34;Settings view rendered with 3 row links&#34;&gt;&lt;/p&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct PlaygroundView: View {&#xA;    @AppStorage(&#34;isOn&#34;) var isOn = true&#xA;    @AppStorage(&#34;value&#34;) var value = Double(5)&#xA;&#xA;    var body: some View {&#xA;        SettingStack {&#xA;            SettingPage(title: &#34;Playground&#34;) {&#xA;                SettingGroup {&#xA;                    SettingToggle(title: &#34;On&#34;, isOn: $isOn)&#xA;                }&#xA;&#xA;                SettingGroup(header: &#34;Slider&#34;) {&#xA;                    SettingSlider(&#xA;                        value: $value,&#xA;                        range: 0 ... 10&#xA;                    )&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aheze/Setting/main/Assets/3.png&#34; alt=&#34;Settings view rendered with toggle and slider&#34;&gt;&lt;/p&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct PlaygroundView: View {&#xA;    @AppStorage(&#34;index&#34;) var index = 0&#xA;&#xA;    var body: some View {&#xA;        SettingStack {&#xA;            SettingPage(title: &#34;Playground&#34;) {&#xA;                SettingGroup {&#xA;                    SettingPicker(&#xA;                        title: &#34;Picker&#34;,&#xA;                        choices: [&#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;],&#xA;                        selectedIndex: $index&#xA;                    )&#xA;                    SettingPicker(&#xA;                        title: &#34;Picker with menu&#34;,&#xA;                        choices: [&#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;],&#xA;                        selectedIndex: $index,&#xA;                        choicesConfiguration: .init(&#xA;                            pickerDisplayMode: .menu&#xA;                        )&#xA;                    )&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aheze/Setting/main/Assets/4.png&#34; alt=&#34;Settings view rendered with picker&#34;&gt;&lt;/p&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;SettingStack {&#xA;    SettingPage(title: &#34;Playground&#34;) {&#xA;        SettingCustomView {&#xA;            Color.blue&#xA;                .opacity(0.1)&#xA;                .cornerRadius(12)&#xA;                .overlay {&#xA;                    Text(&#34;Put anything here!&#34;)&#xA;                        .foregroundColor(.blue)&#xA;                        .font(.title.bold())&#xA;                }&#xA;                .frame(height: 150)&#xA;                .padding(.horizontal, 16)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aheze/Setting/main/Assets/5.png&#34; alt=&#34;Settings view rendered with &amp;quot;Put anything here!&amp;quot; label&#34;&gt;&lt;/p&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Notes&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If multiple components have the same title, use the &lt;code&gt;id&lt;/code&gt; parameter to make sure everything gets rendered correctly.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;SettingText(id: &#34;Announcement 1&#34;, title: &#34;Hello!&#34;)&#xA;SettingText(id: &#34;Announcement 2&#34;, title: &#34;Hello!&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Setting comes with &lt;code&gt;if-else&lt;/code&gt; support!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;SettingToggle(title: &#34;Turn on&#34;, isOn: $isOn)&#xA;&#xA;if isOn {&#xA;    SettingText(&#34;I&#39;m turned on!&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Wrap components in &lt;code&gt;SettingCustomView&lt;/code&gt; to style them.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;SettingCustomView {&#xA;    SettingText(title: &#34;I&#39;m bold!&#34;)&#xA;        .bold()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Need to store custom structs in &lt;code&gt;AppStorage&lt;/code&gt;? Check out @IanKeen&#39;s awesome &lt;a href=&#34;https://gist.github.com/IanKeen/4d29b48519dca125b21675eeb7623d60&#34;&gt;gist&lt;/a&gt;!&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can pass in a custom &lt;code&gt;SettingViewModel&lt;/code&gt; instance for finer control.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct PlaygroundView: View {&#xA;    @StateObject var settingViewModel = SettingViewModel()&#xA;&#xA;    var body: some View {&#xA;        SettingStack(settingViewModel: settingViewModel) {&#xA;            SettingPage(title: &#34;Playground&#34;) {&#xA;                SettingGroup {&#xA;                    SettingText(title: &#34;Welcome to Setting!&#34;)&#xA;                }&#xA;            }&#xA;        } customNoResultsView: {&#xA;            VStack(spacing: 20) {&#xA;                Image(systemName: &#34;xmark&#34;)&#xA;                    .font(.largeTitle)&#xA;&#xA;                Text(&#34;No results for &#39;\(settingViewModel.searchText)&#39;&#34;)&#xA;            }&#xA;            .frame(maxWidth: .infinity, maxHeight: .infinity)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aheze/Setting/main/Assets/NoResults.png&#34; alt=&#34;Settings view rendered with &amp;quot;Put anything here!&amp;quot; label&#34;&gt;&lt;/p&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Community&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Author&lt;/th&gt; &#xA;   &lt;th&gt;Contributing&lt;/th&gt; &#xA;   &lt;th&gt;Need Help?&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Setting is made by &lt;a href=&#34;https://github.com/aheze&#34;&gt;aheze&lt;/a&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;All contributions are welcome. Just &lt;a href=&#34;https://github.com/aheze/Setting/fork&#34;&gt;fork&lt;/a&gt; the repo, then make a pull request.&lt;/td&gt; &#xA;   &lt;td&gt;Open an &lt;a href=&#34;https://github.com/aheze/Setting/issues&#34;&gt;issue&lt;/a&gt; or join the &lt;a href=&#34;https://discord.com/invite/Pmq8fYcus2&#34;&gt;Discord server&lt;/a&gt;. You can also ping me on &lt;a href=&#34;https://twitter.com/aheze0&#34;&gt;Twitter&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;MIT License&#xA;&#xA;Copyright (c) 2023 A. Zheng&#xA;&#xA;Permission is hereby granted, free of charge, to any person obtaining a copy&#xA;of this software and associated documentation files (the &#34;Software&#34;), to deal&#xA;in the Software without restriction, including without limitation the rights&#xA;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#xA;copies of the Software, and to permit persons to whom the Software is&#xA;furnished to do so, subject to the following conditions:&#xA;&#xA;The above copyright notice and this permission notice shall be included in all&#xA;copies or substantial portions of the Software.&#xA;&#xA;THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#xA;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#xA;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#xA;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#xA;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#xA;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#xA;SOFTWARE.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>dylanshine/openai-kit</title>
    <updated>2023-03-05T02:01:16Z</updated>
    <id>tag:github.com,2023-03-05:/dylanshine/openai-kit</id>
    <link href="https://github.com/dylanshine/openai-kit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A community Swift package used to interact with the OpenAI API&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;OpenAIKit&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://img.shields.io/badge/swift-5.7-brightgreen.svg?sanitize=true&#34; alt=&#34;Swift&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;OpenAIKit is a Swift package used to communicate with the &lt;a href=&#34;https://beta.openai.com/docs/api-reference/introduction&#34;&gt;OpenAI API&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;Add the dependency to Package.swift:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    ...&#xA;    .package(url: &#34;https://github.com/dylanshine/openai-kit.git&#34;, from: &#34;1.0.0&#34;)&#xA;],&#xA;targets: [&#xA;    .target(name: &#34;App&#34;, dependencies: [&#xA;        .product(name: &#34;OpenAIKit&#34;, package: &#34;openai-kit&#34;),&#xA;    ]),&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is encouraged to use environment variables to inject the OpenAI API key, instead of hardcoding it in the source code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# .env&#xA;&#xA;OPENAI_API_KEY=&#34;YOUR-API-KEY&#34;&#xA;OPENAI_ORGANIZATION=&#34;YOUR-ORGANIZATION&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;⚠️ OpenAI strongly recommends developers of client-side applications proxy requests through a separate backend service to keep their API key safe. API keys can access and manipulate customer billing, usage, and organizational data, so it&#39;s a significant risk to &lt;a href=&#34;https://nshipster.com/secrets/&#34;&gt;expose&lt;/a&gt; them.&lt;/p&gt; &#xA;&lt;p&gt;Create a &lt;code&gt;OpenAIKit.Client&lt;/code&gt; using a httpClient and configuration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;&#xA;var apiKey: String {&#xA;&#x9;ProcessInfo.processInfo.environment[&#34;OPENAI_API_KEY&#34;]!&#xA;}&#xA;&#xA;var organization: String {&#xA;&#x9;ProcessInfo.processInfo.environment[&#34;OPENAI_ORGANIZATION&#34;]!&#xA;}&#xA;&#xA;...&#xA;&#xA;let httpClient = HTTPClient(eventLoopGroupProvider: .createNew)&#xA;let configuration = Configuration(apiKey: apiKey, organization: organization)&#xA;&#xA;let openAIClient = OpenAIKit.Client(httpClient: httpClient, configuration: configuration)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using the API&lt;/h2&gt; &#xA;&lt;p&gt;The OpenAIKit.Client implements a handful of methods to interact with the OpenAI API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import OpenAIKit&#xA;&#xA;let completion = try await openAIClient.completions.create(&#xA;    model: Model.GPT3.davinci,&#xA;    prompts: [&#34;Write a haiku&#34;]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;What&#39;s Implemented&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://beta.openai.com/docs/api-reference/models&#34;&gt;Models&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://beta.openai.com/docs/api-reference/completions&#34;&gt;Completions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://beta.openai.com/docs/api-reference/edits&#34;&gt;Edits&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://beta.openai.com/docs/api-reference/images&#34;&gt;Images&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://beta.openai.com/docs/api-reference/embeddings&#34;&gt;Embeddings&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://beta.openai.com/docs/api-reference/files&#34;&gt;Files&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://beta.openai.com/docs/api-reference/moderations&#34;&gt;Moderations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;a href=&#34;https://beta.openai.com/docs/api-reference/fine-tunes&#34;&gt;Fine-tunes&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Error handling&lt;/h2&gt; &#xA;&lt;p&gt;If the request to the API failed for any reason an &lt;code&gt;OpenAIKit.APIErrorResponse&lt;/code&gt; is &lt;code&gt;thrown&lt;/code&gt;. Simply ensure you catch errors thrown like any other throwing function&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;   ...&#xA;} catch let error as APIErrorResponse {&#xA;    print(error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>