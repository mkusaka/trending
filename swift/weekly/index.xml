<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-29T02:07:32Z</updated>
  <subtitle>Weekly Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>devicekit/DeviceKit</title>
    <updated>2023-01-29T02:07:32Z</updated>
    <id>tag:github.com,2023-01-29:/devicekit/DeviceKit</id>
    <link href="https://github.com/devicekit/DeviceKit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;DeviceKit is a value-type replacement of UIDevice.&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://raw.githubusercontent.com/devicekit/DeviceKit/master/DeviceKit.svg?sanitize=true&#34; height=&#34;128&#34;&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/devicekit/DeviceKit/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-lightgrey.svg?sanitize=true&#34; alt=&#34;GitHub license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/DeviceKit&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/DeviceKit.svg?sanitize=true&#34; alt=&#34;CocoaPods Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/devicekit/DeviceKit&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/devicekit/DeviceKit/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/DeviceKit&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/dt/DeviceKit.svg?sanitize=true&#34; alt=&#34;CocoaPods&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/devicekit/DeviceKit/maintainability&#34;&gt;&lt;img src=&#34;https://api.codeclimate.com/v1/badges/844e23a17bde71ff6be1/maintainability&#34; alt=&#34;Maintainability&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/DeviceKit&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/DeviceKit.svg?style=flat&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Branch&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Versions&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;strong&gt;master&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;≥ 2.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Swift 4 - 4.2&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;≥ 1.3 &amp;lt; 1.13&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Swift 3&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;≥ 1.0 &amp;lt; 1.3&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Swift 2.3&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&amp;lt; 1.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;code&gt;DeviceKit&lt;/code&gt; is a value-type replacement of &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIDevice_Class/&#34;&gt;&lt;code&gt;UIDevice&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Current version 5.0.0&lt;/h2&gt; &#xA;&lt;p&gt;See our detailed &lt;a href=&#34;https://raw.githubusercontent.com/devicekit/DeviceKit/master/CHANGELOG.md&#34;&gt;changelog&lt;/a&gt; for the latest features, improvements and bug fixes.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Equatable&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Device identification&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Device family detection&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Device group detection&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Simulator detection&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Battery state&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Battery level&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Various device metrics (e.g. screen size, screen ratio, PPI)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Low Power Mode detection&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Guided Access Session detection&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Screen brightness&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Display Zoom detection&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Detect available sensors (Touch ID, Face ID)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Detect available disk space&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Apple Pencil support detection&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iOS 11.0+&lt;/li&gt; &#xA; &lt;li&gt;tvOS 11.0+&lt;/li&gt; &#xA; &lt;li&gt;watchOS 4.0+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;DeviceKit can be installed in various ways.&lt;/p&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;h4&gt;Swift 5&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;DeviceKit&#39;, &#39;~&amp;gt; 4.0&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;iOS 8.0 support&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;DeviceKit&#39;, &#39;3.2&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Swift 4.0 - Swift 4.2&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;DeviceKit&#39;, &#39;~&amp;gt; 1.3&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Swift 3&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;DeviceKit&#39;, &#39;~&amp;gt; 1.2.3&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Swift 2.3 (Unsupported)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;DeviceKit&#39;, :git =&amp;gt; &#39;https://github.com/devicekit/DeviceKit.git&#39;, :branch =&amp;gt; &#39;swift-2.3-unsupported&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;h4&gt;Swift 5&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/devicekit/DeviceKit.git&#34;, from: &#34;4.0.0&#34;),&#xA;    /// ...&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;iOS 8.0 support&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/devicekit/DeviceKit.git&#34;, from: &#34;3.2.0&#34;),&#xA;    /// ...&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;h4&gt;Swift 5&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ogdl&#34;&gt;github &#34;devicekit/DeviceKit&#34; ~&amp;gt; 4.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;iOS 8.0 support&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ogdl&#34;&gt;github &#34;devicekit/DeviceKit&#34; ~&amp;gt; 3.2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Swift 4.0 - Swift 4.2&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ogdl&#34;&gt;github &#34;devicekit/DeviceKit&#34; ~&amp;gt; 1.3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Swift 3&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ogdl&#34;&gt;github &#34;devicekit/DeviceKit&#34; ~&amp;gt; 1.2.3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Swift 2.3 (Unsupported)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ogdl&#34;&gt;github &#34;devicekit/DeviceKit&#34; &#34;swift-2.3-unsupported&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Manually&lt;/h3&gt; &#xA;&lt;p&gt;To install it manually, drag the &lt;code&gt;DeviceKit&lt;/code&gt; project into your app project in Xcode. Or add it as a git submodule by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git submodule add https://github.com/devicekit/DeviceKit.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;First make sure to import the framework:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import DeviceKit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here are some usage examples. All devices are also available as simulators:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.iPhone6 =&amp;gt; .simulator(.iPhone6)&#xA;.iPhone6s =&amp;gt; .simulator(.iPhone6s)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can try these examples in Playground.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;To try DeviceKit in the playground, open the &lt;code&gt;DeviceKit.xcworkspace&lt;/code&gt; and build DeviceKit.framework for any simulator first by selecting &#34;DeviceKit&#34; as your current scheme.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Get the Device You&#39;re Running On&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let device = Device.current&#xA;&#xA;print(device)     // prints, for example, &#34;iPhone 6 Plus&#34;&#xA;&#xA;if device == .iPhone6Plus {&#xA;  // Do something&#xA;} else {&#xA;  // Do something else&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get the Device Family&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let device = Device.current&#xA;if device.isPod {&#xA;  // iPods (real or simulator)&#xA;} else if device.isPhone {&#xA;  // iPhone (real or simulator)&#xA;} else if device.isPad {&#xA;  // iPad (real or simulator)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Check If Running on Simulator&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let device = Device.current&#xA;if device.isSimulator {&#xA;  // Running on one of the simulators(iPod/iPhone/iPad)&#xA;  // Skip doing something irrelevant for Simulator&#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get the Simulator Device&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let device = Device.current&#xA;switch device {&#xA;case .simulator(.iPhone6s): break // You&#39;re running on the iPhone 6s simulator&#xA;case .simulator(.iPadAir2): break // You&#39;re running on the iPad Air 2 simulator&#xA;default: break&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Make Sure the Device Is Contained in a Preconfigured Group&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let groupOfAllowedDevices: [Device] = [.iPhone6, .iPhone6Plus, .iPhone6s, .iPhone6sPlus, .simulator(.iPhone6), .simulator(.iPhone6Plus),.simulator(.iPhone6s),.simulator(.iPhone6sPlus).simulator(.iPhone8),.simulator(.iPhone8Plus),.simulator(.iPhoneX),.simulator(.iPhoneXS),.simulator(.iPhoneXSMax),.simulator(.iPhoneXR)]&#xA;&#xA;let device = Device.current&#xA; &#xA;if device.isOneOf(groupOfAllowedDevices) {&#xA;  // Do your action&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get the Current Battery State&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;To get the current battery state we need to set &lt;code&gt;UIDevice.current.isBatteryMonitoringEnabled&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. To avoid any issues with your code, we read the current setting and reset it to what it was before when we&#39;re done.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if device.batteryState == .full || device.batteryState &amp;gt;= .charging(75) {&#xA;  print(&#34;Your battery is happy! 😊&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get the Current Battery Level&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if device.batteryLevel &amp;gt;= 50 {&#xA;  install_iOS()&#xA;} else {&#xA;  showError()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get Low Power mode status&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if device.batteryState.lowPowerMode {&#xA;  print(&#34;Low Power mode is enabled! 🔋&#34;)&#xA;} else {&#xA;  print(&#34;Low Power mode is disabled! 😊&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Check if a Guided Access session is currently active&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if device.isGuidedAccessSessionActive {&#xA;  print(&#34;Guided Access session is currently active&#34;)&#xA;} else {&#xA;  print(&#34;No Guided Access session is currently active&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get Screen Brightness&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if device.screenBrightness &amp;gt; 50 {&#xA;  print(&#34;Take care of your eyes!&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get Available Disk Space&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if Device.volumeAvailableCapacityForOpportunisticUsage ?? 0 &amp;gt; Int64(1_000_000) {&#xA;  // download that nice-to-have huge file&#xA;}&#xA;&#xA;if Device.volumeAvailableCapacityForImportantUsage ?? 0 &amp;gt; Int64(1_000) {&#xA;  // download that file you really need&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Source of Information&lt;/h2&gt; &#xA;&lt;p&gt;All model identifiers are taken from the following website: &lt;a href=&#34;https://www.theiphonewiki.com/wiki/Models&#34;&gt;https://www.theiphonewiki.com/wiki/Models&lt;/a&gt; or extracted from the simulator app bundled with Xcode.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you have the need for a specific feature that you want implemented or if you experienced a bug, please open an issue. If you extended the functionality of DeviceKit yourself and want others to use it too, please submit a pull request.&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;The complete list of people who contributed to this project is available &lt;a href=&#34;https://github.com/devicekit/DeviceKit/graphs/contributors&#34;&gt;here&lt;/a&gt;. DeviceKit wouldn&#39;t be what it is without you! Thank you very much! 🙏&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>pointfreeco/swift-identified-collections</title>
    <updated>2023-01-29T02:07:32Z</updated>
    <id>tag:github.com,2023-01-29:/pointfreeco/swift-identified-collections</id>
    <link href="https://github.com/pointfreeco/swift-identified-collections" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A library of data structures for working with collections of identifiable elements in an ergonomic, performant way.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Swift Identified Collections&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://actions-badge.atrox.dev/pointfreeco/swift-identified-collections/goto&#34;&gt;&lt;img src=&#34;https://github.com/pointfreeco/swift-identified-collections/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-identified-collections&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-identified-collections%2Fbadge%3Ftype%3Dswift-versions&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-identified-collections&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-identified-collections%2Fbadge%3Ftype%3Dplatforms&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A library of data structures for working with collections of identifiable elements in an ergonomic, performant way.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;When modeling a collection of elements in your application&#39;s state, it is easy to reach for a standard &lt;code&gt;Array&lt;/code&gt;. However, as your application becomes more complex, this approach can break down in many ways, including accidentally making mutations to the wrong elements or even crashing. 😬&lt;/p&gt; &#xA;&lt;p&gt;For example, if you were building a &#34;Todos&#34; application in SwiftUI, you might model an individual todo in an identifiable value type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Todo: Identifiable {&#xA;  var description = &#34;&#34;&#xA;  let id: UUID&#xA;  var isComplete = false&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And you would hold an array of these todos as a published field in your app&#39;s view model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class TodosViewModel: ObservableObject {&#xA;  @Published var todos: [Todo] = []&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A view can render a list of these todos quite simply, and because they are identifiable we can even omit the &lt;code&gt;id&lt;/code&gt; parameter of &lt;code&gt;List&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct TodosView: View {&#xA;  @ObservedObject var viewModel: TodosViewModel&#xA;  &#xA;  var body: some View {&#xA;    List(self.viewModel.todos) { todo in&#xA;      ...&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your deployment target is set to the latest version of SwiftUI, you may be tempted to pass along a binding to the list so that each row is given mutable access to its todo. This will work for simple cases, but as soon as you introduce side effects, like API clients or analytics, or want to write unit tests, you must push this logic into a view model, instead. And that means each row must be able to communicate its actions back to the view model.&lt;/p&gt; &#xA;&lt;p&gt;You could do so by introducing some endpoints on the view model, like when a row&#39;s completed toggle is changed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class TodosViewModel: ObservableObject {&#xA;  ...&#xA;  func todoCheckboxToggled(at id: Todo.ID) {&#xA;    guard let index = self.todos.firstIndex(where: { $0.id == id })&#xA;    else { return }&#xA;    &#xA;    self.todos[index].isComplete.toggle()&#xA;    // TODO: Update todo on backend using an API client&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code is simple enough, but it can require a full traversal of the array to do its job.&lt;/p&gt; &#xA;&lt;p&gt;Perhaps it would be more performant for a row to communicate its index back to the view model instead, and then it could mutate the todo directly via its index subscript. But this makes the view more complicated:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;List(self.viewModel.todos.enumerated(), id: \.element.id) { index, todo in&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This isn&#39;t so bad, but at the moment it doesn&#39;t even compile. An &lt;a href=&#34;https://github.com/apple/swift-evolution/raw/main/proposals/0312-indexed-and-enumerated-zip-collections.md&#34;&gt;evolution proposal&lt;/a&gt; may change that soon, but in the meantime &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;ForEach&lt;/code&gt; must be passed a &lt;code&gt;RandomAccessCollection&lt;/code&gt;, which is perhaps most simply achieved by constructing another array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;List(Array(self.viewModel.todos.enumerated()), id: \.element.id) { index, todo in&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This compiles, but we&#39;ve just moved the performance problem to the view: every time this body is evaluated there&#39;s the possibility a whole new array is being allocated.&lt;/p&gt; &#xA;&lt;p&gt;But even if it were possible to pass an enumerated collection directly to these views, identifying an element of mutable state by an index introduces a number of other problems.&lt;/p&gt; &#xA;&lt;p&gt;While it&#39;s true that we can greatly simplify and improve the performance of any view model methods that mutate an element through its index subscript:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class TodosViewModel: ObservableObject {&#xA;  ...&#xA;  func todoCheckboxToggled(at index: Int) {&#xA;    self.todos[index].isComplete.toggle()&#xA;    // TODO: Update todo on backend using an API client&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any asynchronous work that we add to this endpoint must take great care in &lt;em&gt;not&lt;/em&gt; using this index later on. An index is not a stable identifier: todos can be moved and removed at any time, and an index identifying &#34;Buy lettuce&#34; at one moment may identify &#34;Call Mom&#34; the next, or worse, may be a completely invalid index and crash your application!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class TodosViewModel: ObservableObject {&#xA;  ...&#xA;  func todoCheckboxToggled(at index: Int) async {&#xA;    self.todos[index].isComplete.toggle()&#xA;    &#xA;    do {&#xA;      // ❌ Could update the wrong todo, or crash!&#xA;      self.todos[index] = try await self.apiClient.updateTodo(self.todos[index]) &#xA;    } catch {&#xA;      // Handle error&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Whenever you need to access a particular todo after performing some asynchronous work, you &lt;em&gt;must&lt;/em&gt; do the work of traversing the array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class TodosViewModel: ObservableObject {&#xA;  ...&#xA;  func todoCheckboxToggled(at index: Int) async {&#xA;    self.todos[index].isComplete.toggle()&#xA;    &#xA;    // 1️⃣ Get a reference to the todo&#39;s id before kicking off the async work&#xA;    let id = self.todos[index].id&#xA;  &#xA;    do {&#xA;      // 2️⃣ Update the todo on the backend&#xA;      let updatedTodo = try await self.apiClient.updateTodo(self.todos[index])&#xA;              &#xA;      // 3️⃣ Find the updated index of the todo after the async work is done&#xA;      let updatedIndex = self.todos.firstIndex(where: { $0.id == id })!&#xA;      &#xA;      // 4️⃣ Update the correct todo&#xA;      self.todos[updatedIndex] = updatedTodo&#xA;    } catch {&#xA;      // Handle error&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Introducing: identified collections&lt;/h2&gt; &#xA;&lt;p&gt;Identified collections are designed to solve all of these problems by providing data structures for working with collections of identifiable elements in an ergonomic, performant way.&lt;/p&gt; &#xA;&lt;p&gt;Most of the time, you can simply swap an &lt;code&gt;Array&lt;/code&gt; out for an &lt;code&gt;IdentifiedArray&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import IdentifiedCollections&#xA;&#xA;class TodosViewModel: ObservableObject {&#xA;  @Published var todos: IdentifiedArrayOf&amp;lt;Todo&amp;gt; = []&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then you can mutate an element directly via its id-based subscript, no traversals needed, even after asynchronous work is performed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class TodosViewModel: ObservableObject {&#xA;  ...&#xA;  func todoCheckboxToggled(at id: Todo.ID) async {&#xA;    self.todos[id: id]?.isComplete.toggle()&#xA;    &#xA;    do {&#xA;      // 1️⃣ Update todo on backend and mutate it in the todos identified array.&#xA;      self.todos[id: id] = try await self.apiClient.updateTodo(self.todos[id: id]!)&#xA;    } catch {&#xA;      // Handle error&#xA;    }&#xA;&#xA;    // No step 2️⃣ 😆&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also simply pass the identified array to views like &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;ForEach&lt;/code&gt; without any complications:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;List(self.viewModel.todos) { todo in&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Identified arrays are designed to integrate with SwiftUI applications, as well as applications written in &lt;a href=&#34;https://github.com/pointfreeco/swift-composable-architecture&#34;&gt;the Composable Architecture&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Design&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;IdentifiedArray&lt;/code&gt; is a lightweight wrapper around the &lt;a href=&#34;https://github.com/apple/swift-collections/raw/main/Documentation/OrderedDictionary.md&#34;&gt;&lt;code&gt;OrderedDictionary&lt;/code&gt;&lt;/a&gt; type from Apple&#39;s &lt;a href=&#34;https://github.com/apple/swift-collections&#34;&gt;Swift Collections&lt;/a&gt;. It shares many of the same performance characteristics and design considerations, but is better adapted to solving the problem of holding onto a collection of &lt;em&gt;identifiable&lt;/em&gt; elements in your application&#39;s state.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;IdentifiedArray&lt;/code&gt; does not expose any of the details of &lt;code&gt;OrderedDictionary&lt;/code&gt; that may lead to breaking invariants. For example an &lt;code&gt;OrderedDictionary&amp;lt;ID, Identifiable&amp;gt;&lt;/code&gt; may freely hold a value whose identifier does not match its key or multiple values could have the same id, and &lt;code&gt;IdentifiedArray&lt;/code&gt; does not allow for these situations.&lt;/p&gt; &#xA;&lt;p&gt;And unlike &lt;a href=&#34;https://github.com/apple/swift-collections/raw/main/Documentation/OrderedSet.md&#34;&gt;&lt;code&gt;OrderedSet&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;IdentifiedArray&lt;/code&gt; does not require that its &lt;code&gt;Element&lt;/code&gt; type conforms to the &lt;code&gt;Hashable&lt;/code&gt; protocol, which may be difficult or impossible to do, and introduces questions around the quality of hashing, etc.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;IdentifiedArray&lt;/code&gt; does not even require that its &lt;code&gt;Element&lt;/code&gt; conforms to &lt;code&gt;Identifiable&lt;/code&gt;. Just as SwiftUI&#39;s &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;ForEach&lt;/code&gt; views take an &lt;code&gt;id&lt;/code&gt; key path to an element&#39;s identifier, &lt;code&gt;IdentifiedArray&lt;/code&gt;s can be constructed with a key path:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var numbers = IdentifiedArray(id: \Int.self)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;IdentifiedArray&lt;/code&gt; is designed to match the performance characteristics of &lt;code&gt;OrderedDictionary&lt;/code&gt;. It has been benchmarked with &lt;a href=&#34;https://github.com/apple/swift-collections-benchmark&#34;&gt;Swift Collections Benchmark&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pointfreeco/swift-identified-collections/main/.github/benchmark.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can add Identified Collections to an Xcode project by adding it as a package dependency.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/pointfreeco/swift-identified-collections&#34;&gt;https://github.com/pointfreeco/swift-identified-collections&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If you want to use Identified Collections in a &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;SwiftPM&lt;/a&gt; project, it&#39;s as simple as adding a &lt;code&gt;dependencies&lt;/code&gt; clause to your &lt;code&gt;Package.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;  .package(url: &#34;https://github.com/pointfreeco/swift-identified-collections&#34;, from: &#34;0.6.0&#34;)&#xA;],&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The latest documentation for Identified Collections&#39; APIs is available &lt;a href=&#34;https://pointfreeco.github.io/swift-identified-collections/main/documentation/identifiedcollections/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Interested in learning more?&lt;/h2&gt; &#xA;&lt;p&gt;These concepts (and more) are explored thoroughly in &lt;a href=&#34;https://www.pointfree.co&#34;&gt;Point-Free&lt;/a&gt;, a video series exploring functional programming and Swift hosted by &lt;a href=&#34;https://github.com/mbrandonw&#34;&gt;Brandon Williams&lt;/a&gt; and &lt;a href=&#34;https://github.com/stephencelis&#34;&gt;Stephen Celis&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Usage of &lt;code&gt;IdentifiedArray&lt;/code&gt; in &lt;a href=&#34;https://github.com/pointfreeco/swift-composable-architecture&#34;&gt;the Composable Architecture&lt;/a&gt; was explored in the following &lt;a href=&#34;https://www.pointfree.co&#34;&gt;Point-Free&lt;/a&gt; episode:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.pointfree.co/episodes/ep148-derived-behavior-collections&#34;&gt;Episode 148&lt;/a&gt;: Derived Behavior: Collections&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;a href=&#34;https://www.pointfree.co/episodes/ep148-derived-behavior-collections&#34;&gt; &lt;img alt=&#34;video poster image&#34; src=&#34;https://d3rccdn33rt8ze.cloudfront.net/episodes/0148.jpeg&#34; width=&#34;480&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;All modules are released under the MIT license. See &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-identified-collections/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>SwiftGen/SwiftGen</title>
    <updated>2023-01-29T02:07:32Z</updated>
    <id>tag:github.com,2023-01-29:/SwiftGen/SwiftGen</id>
    <link href="https://github.com/SwiftGen/SwiftGen" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Swift code generator for your assets, storyboards, Localizable.strings, … — Get rid of all String-based APIs!&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SwiftGen&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://img.shields.io/cocoapods/v/SwiftGen.svg&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/SwiftGen.svg?sanitize=true&#34; alt=&#34;CocoaPods Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/SwiftGen&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/SwiftGen.svg?style=flat&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/badge/Swift-4.x-orange&#34; alt=&#34;Swift 4.x&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Swift-5.x-orange&#34; alt=&#34;Swift 5.x&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;SwiftGen is a tool to automatically generate Swift code for resources of your projects (like images, localised strings, etc), to make them type-safe to use.&lt;/p&gt; &#xA;&lt;table border=&#34;0&#34;&gt;&#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;img alt=&#34;SwiftGen Logo&#34; src=&#34;https://github.com/SwiftGen/Eve/raw/master/logo/logo-256.png&#34;&gt; &lt;/td&gt;&#xA;   &lt;td&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/#installation&#34;&gt;Installation&lt;/a&gt; &lt;/li&gt;&#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/#configuration-file&#34;&gt;Configuration File&lt;/a&gt; &lt;/li&gt;&#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/#choosing-your-template&#34;&gt;Choosing your template&lt;/a&gt; &lt;/li&gt;&#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/#additional-documentation&#34;&gt;Additional documentation&lt;/a&gt; &lt;/li&gt;&#xA;    &lt;/ul&gt; Then generate constants for: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/#asset-catalog&#34;&gt;Assets Catalogs&lt;/a&gt; &lt;/li&gt;&#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/#colors&#34;&gt;Colors&lt;/a&gt; &lt;/li&gt;&#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/#core-data&#34;&gt;Core Data&lt;/a&gt; &lt;/li&gt;&#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/#files&#34;&gt;Files&lt;/a&gt; &lt;/li&gt;&#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/#fonts&#34;&gt;Fonts&lt;/a&gt; &lt;/li&gt;&#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/#interface-builder&#34;&gt;Interface Builder files&lt;/a&gt; &lt;/li&gt;&#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/#json-and-yaml&#34;&gt;JSON and YAML files&lt;/a&gt; &lt;/li&gt;&#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/#plists&#34;&gt;Plists&lt;/a&gt; &lt;/li&gt;&#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/#strings&#34;&gt;Localizable strings&lt;/a&gt; &lt;/li&gt;&#xA;    &lt;/ul&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt;&#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;span style=&#34;float:none&#34;&gt;&lt;/span&gt; &#xA;&lt;p&gt;There are multiple benefits in using this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Avoid any risk of typo when using a String&lt;/li&gt; &#xA; &lt;li&gt;Free auto-completion&lt;/li&gt; &#xA; &lt;li&gt;Avoid the risk of using a non-existing asset name&lt;/li&gt; &#xA; &lt;li&gt;All this will be ensured by the compiler and thus avoid the risk of crashing at runtime.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also, it&#39;s fully customizable thanks to Stencil templates, so even if it comes with predefined templates, you can make your own to generate whatever code fits your needs and your guidelines!&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;There are multiple possibilities to install SwiftGen on your machine or in your project, depending on your preferences and needs:&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Download the ZIP&lt;/strong&gt; for the latest release&lt;/summary&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/SwiftGen/SwiftGen/releases/latest&#34;&gt;Go to the GitHub page for the latest release&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;Download the &lt;code&gt;swiftgen-x.y.z.zip&lt;/code&gt; file associated with that release&lt;/li&gt; &#xA;  &lt;li&gt;Extract the content of the zip archive in your project directory&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;We recommend that you &lt;strong&gt;unarchive the ZIP inside your project directory&lt;/strong&gt; and &lt;strong&gt;commit its content&lt;/strong&gt; to git. This way, &lt;strong&gt;all coworkers will use the same version of SwiftGen for this project&lt;/strong&gt;.&lt;/p&gt; &#xA; &lt;p&gt;If you unarchived the ZIP file in a folder e.g. called &lt;code&gt;swiftgen&lt;/code&gt; at the root of your project directory, you can then invoke SwiftGen in your Script Build Phase using:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#34;${PROJECT_DIR}/swiftgen/bin/swiftgen&#34; …&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;hr&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Via &lt;strong&gt;CocoaPods&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;p&gt;If you&#39;re using CocoaPods, simply add &lt;code&gt;pod &#39;SwiftGen&#39;, &#39;~&amp;gt; 6.0&#39;&lt;/code&gt; to your &lt;code&gt;Podfile&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;p&gt;Then execute &lt;code&gt;pod install --repo-update&lt;/code&gt; (or &lt;code&gt;pod update SwiftGen&lt;/code&gt; if you want to update an existing SwiftGen installation) to download and install the &lt;code&gt;SwiftGen&lt;/code&gt; binaries and dependencies in &lt;code&gt;Pods/SwiftGen/bin/swiftgen&lt;/code&gt; next to your project.&lt;/p&gt; &#xA; &lt;p&gt;Given that you can specify an exact version for &lt;code&gt;SwiftGen&lt;/code&gt; in your &lt;code&gt;Podfile&lt;/code&gt;, this allows you to ensure &lt;strong&gt;all coworkers will use the same version of SwiftGen for this project&lt;/strong&gt;.&lt;/p&gt; &#xA; &lt;p&gt;You can then invoke SwiftGen in your Script Build Phase using:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;if [[ -f &#34;${PODS_ROOT}/SwiftGen/bin/swiftgen&#34; ]]; then&#xA;  &#34;${PODS_ROOT}/SwiftGen/bin/swiftgen&#34; …&#xA;else&#xA;  echo &#34;warning: SwiftGen is not installed. Run &#39;pod install --repo-update&#39; to install it.&#34;&#xA;fi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;Similarly, be sure to use &lt;code&gt;Pods/SwiftGen/bin/swiftgen&lt;/code&gt; instead of just &lt;code&gt;swiftgen&lt;/code&gt; where we mention commands with &lt;code&gt;swiftgen&lt;/code&gt; in the rest of the documentation.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;Note: SwiftGen isn&#39;t really a pod, as it&#39;s not a library your code will depend on at runtime; so the installation via CocoaPods is just a trick that installs the SwiftGen binaries in the Pods/ folder, but you won&#39;t see any swift files in the Pods/SwiftGen group in your Xcode&#39;s Pods.xcodeproj. That&#39;s normal; the SwiftGen binary is still present in that folder in the Finder.&lt;/em&gt;&lt;/p&gt; &#xA; &lt;hr&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Via &lt;strong&gt;Homebrew&lt;/strong&gt; &lt;em&gt;(system-wide installation)&lt;/em&gt;&lt;/summary&gt; &#xA; &lt;p&gt;To install SwiftGen via &lt;a href=&#34;http://brew.sh&#34;&gt;Homebrew&lt;/a&gt;, simply use:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ brew update&#xA;$ brew install swiftgen&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;This will install SwiftGen &lt;strong&gt;system-wide&lt;/strong&gt;. The same version of SwiftGen will be used for all projects on that machine, and you should make sure all your coworkers have the same version of SwiftGen installed on their machine too.&lt;/p&gt; &#xA; &lt;p&gt;You can then invoke &lt;code&gt;swiftgen&lt;/code&gt; directly in your Script Build Phase (as it will be in your &lt;code&gt;$PATH&lt;/code&gt; already):&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;swiftgen … &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;hr&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Via &lt;strong&gt;Mint&lt;/strong&gt; &lt;em&gt;(system-wide installation)&lt;/em&gt;&lt;/summary&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;❗️SwiftGen 6.0 or higher only.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;To install SwiftGen via &lt;a href=&#34;https://github.com/yonaskolb/Mint&#34;&gt;Mint&lt;/a&gt;, simply use:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mint install SwiftGen/SwiftGen&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;hr&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Compile from source&lt;/strong&gt; &lt;em&gt;(only recommended if you need features from the `stable` branch or want to test a PR)&lt;/em&gt;&lt;/summary&gt; &#xA; &lt;p&gt;This solution is when you want to build and install the latest version from &lt;code&gt;stable&lt;/code&gt; and have access to features which might not have been released yet.&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;If you have &lt;code&gt;homebrew&lt;/code&gt; installed, you can use the following command to build and install the latest commit:&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install swiftgen --HEAD&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Alternatively, you can clone the repository and use &lt;code&gt;rake cli:install&lt;/code&gt; to build the tool and install it from any branch, which could be useful to test SwiftGen in a fork or a Pull Request branch.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;Some Ruby tools are used in the build process, and the system Ruby works well if you are running a recent macOS. However, if you are using &lt;code&gt;rbenv&lt;/code&gt; you can run &lt;code&gt;rbenv install&lt;/code&gt; to make sure you have a matching version of Ruby installed.&lt;/p&gt; &#xA; &lt;p&gt;Then install the Ruby Gems:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Install bundle if it isn&#39;t installed&#xA;gem install bundle&#xA;# Install the Ruby gems from Gemfile&#xA;bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You can now install to the default locations (no parameter) or to custom locations:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Binary is installed in `./.build/swiftgen/bin`&#xA;$ rake cli:install&#xA;# - OR -&#xA;# Binary will be installed in `~/swiftgen/bin``&#xA;$ rake cli:install[~/swiftgen/bin]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You can then invoke SwiftGen using the path to the binary where you installed it:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;~/swiftgen/bin/swiftgen …&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Or add the path to the &lt;code&gt;bin&lt;/code&gt; folder to your &lt;code&gt;$PATH&lt;/code&gt; and invoke &lt;code&gt;swiftgen&lt;/code&gt; directly.&lt;/p&gt; &#xA; &lt;hr&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Known Installation Issues On macOS Before 10.14.4&lt;/h3&gt; &#xA;&lt;p&gt;Starting with &lt;a href=&#34;https://github.com/SwiftGen/SwiftGen/releases/6.2.1&#34;&gt;SwiftGen 6.2.1&lt;/a&gt;, if you get an error similar to &lt;code&gt;dyld: Symbol not found: _$s11SubSequenceSlTl&lt;/code&gt; when running SwiftGen, you&#39;ll need to install the &lt;a href=&#34;https://support.apple.com/kb/DL1998&#34;&gt;Swift 5 Runtime Support for Command Line Tools&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update to macOS 10.14.4 or later&lt;/li&gt; &#xA; &lt;li&gt;Install Xcode 10.2 or later at &lt;code&gt;/Applications/Xcode.app&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Rebuild SwiftGen from source using Xcode 10.2 or later&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Configuration File&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;❗️ If you&#39;re migrating from older SwiftGen versions, don&#39;t forget to &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/MigrationGuide.md&#34;&gt;read the Migration Guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;SwiftGen is provided as a single command-line tool which uses a configuration file to define the various parsers to run (depending on the type of input files you need to parse) and their parameters.&lt;/p&gt; &#xA;&lt;p&gt;To create a sample configuration file as a starting point to adapt to your needs, run &lt;code&gt;swiftgen config init&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Each parser described in the &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/ConfigFile.md&#34;&gt;configuration file&lt;/a&gt; (&lt;code&gt;strings&lt;/code&gt;, &lt;code&gt;fonts&lt;/code&gt;, &lt;code&gt;ib&lt;/code&gt;, …) typically corresponds to a type of input resources to parse (strings files, IB files, Font files, JSON files, …), allowing you to generate constants for each types of those input files.&lt;/p&gt; &#xA;&lt;p&gt;To use SwiftGen, simply create a &lt;code&gt;swiftgen.yml&lt;/code&gt; YAML file (either manually or using &lt;code&gt;swiftgen config init&lt;/code&gt;) then edit it to adapt to your project. The config file should list all the parsers to invoke, and for each parser, the list of inputs/outputs/templates/parameters to use for it.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;strings:&#xA;  inputs: Resources/Base.lproj&#xA;  outputs:&#xA;    - templateName: structured-swift5&#xA;      output: Generated/Strings.swift&#xA;xcassets:&#xA;  inputs:&#xA;    - Resources/Images.xcassets&#xA;    - Resources/MoreImages.xcassets&#xA;    - Resources/Colors.xcassets&#xA;  outputs:&#xA;    - templateName: swift5&#xA;      output: Generated/Assets.swift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you just have to invoke &lt;code&gt;swiftgen config run&lt;/code&gt;, or even just &lt;code&gt;swiftgen&lt;/code&gt; for short, and it will execute what&#39;s described in the configuration file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/ConfigFile.md&#34;&gt;The dedicated documentation&lt;/a&gt; explains the syntax and possibilities in details – like how to pass custom parameters to your templates, use &lt;code&gt;swiftgen config lint&lt;/code&gt; to validate your config file, how to use alternate config files, and other tips.&lt;/p&gt; &#xA;&lt;p&gt;There are also additional subcommands you can invoke from the command line to manage and configure SwiftGen:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;swiftgen config&lt;/code&gt; subcommand to help you with the configuration file, especially &lt;code&gt;swiftgen config init&lt;/code&gt; to create a starting point for your config and &lt;code&gt;swiftgen config lint&lt;/code&gt; to validate that your Config file is valid and has no errors&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;swiftgen template&lt;/code&gt; subcommands to help you print, duplicate, find and manage templates bundled with SwiftGen&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Lastly, you can use &lt;code&gt;--help&lt;/code&gt; on &lt;code&gt;swiftgen&lt;/code&gt; or one of its subcommand to see the detailed usage.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Directly invoking a parser without a config file&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;p&gt;While we highly recommend the use a configuration file for performance reasons (especially if you have multiple outputs, but also because it&#39;s more flexible), it&#39;s also possible to directly invoke the available parsers individually using &lt;code&gt;swiftgen run&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;swiftgen run colors [OPTIONS] DIRORFILE1 …&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;swiftgen run coredata [OPTIONS] DIRORFILE1 …&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;swiftgen run files [OPTIONS] DIRORFILE1 …&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;swiftgen run fonts [OPTIONS] DIRORFILE1 …&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;swiftgen run ib [OPTIONS] DIRORFILE1 …&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;swiftgen run json [OPTIONS] DIRORFILE1 …&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;swiftgen run plist [OPTIONS] DIRORFILE1 …&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;swiftgen run strings [OPTIONS] DIRORFILE1 …&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;swiftgen run xcassets [OPTIONS] DIRORFILE1 …&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;swiftgen run yaml [OPTIONS] DIRORFILE1 …&lt;/code&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;One rare cases where this might be useful — as opposed to using a config file — is if you are working on a custom template and want to quickly test the specific parser you&#39;re working on at each iteration/version of your custom template, until you&#39;re happy with it.&lt;/p&gt; &#xA; &lt;p&gt;Each parser command generally accepts the same options and syntax, and they mirror the options and parameters from the configuration file:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;--output FILE&lt;/code&gt; or &lt;code&gt;-o FILE&lt;/code&gt;: set the file where to write the generated code. If omitted, the generated code will be printed on &lt;code&gt;stdout&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;--templateName NAME&lt;/code&gt; or &lt;code&gt;-n NAME&lt;/code&gt;: define the Stencil template to use (by name, see &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/templates&#34;&gt;here for more info&lt;/a&gt;) to generate the output.&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;--templatePath PATH&lt;/code&gt; or &lt;code&gt;-p PATH&lt;/code&gt;: define the Stencil template to use, using a full path.&lt;/li&gt; &#xA;  &lt;li&gt;Note: you should specify one and only one template when invoking SwiftGen. You have to use either &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; but should not use both at the same time (it wouldn&#39;t make sense anyway and you&#39;ll get an error if you try)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;--filter REGEX&lt;/code&gt; or &lt;code&gt;-f REGEX&lt;/code&gt;: the filter to apply to each input path. Filters are applied to actual (relative) paths, not just the filename. Each command has a default filter that you can override with this option.&lt;/li&gt; &#xA;  &lt;li&gt;Note: use &lt;code&gt;.+&lt;/code&gt; to match multiple characters (at least one), and don&#39;t forget to escape the dot (&lt;code&gt;\.&lt;/code&gt;) if you want to match a literal dot like for an extension. Add &lt;code&gt;$&lt;/code&gt; at the end to ensure the path ends with the extension you want. Regular expressions will be case sensitive by default, and not anchored to the start/end of a path. For example, use &lt;code&gt;.+\.xib$&lt;/code&gt; to match files with a &lt;code&gt;.xib&lt;/code&gt; extension. Use a tool such as &lt;a href=&#34;https://regexr.com&#34;&gt;RegExr&lt;/a&gt; to ensure you&#39;re using a valid regular expression.&lt;/li&gt; &#xA;  &lt;li&gt;Each command supports multiple input files (or directories where applicable).&lt;/li&gt; &#xA;  &lt;li&gt;You can always use the &lt;code&gt;--help&lt;/code&gt; flag to see what options a command accept, e.g. &lt;code&gt;swiftgen run xcassets --help&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Choosing your template&lt;/h2&gt; &#xA;&lt;p&gt;SwiftGen is based on templates (it uses &lt;a href=&#34;https://github.com/stencilproject/Stencil&#34;&gt;Stencil&lt;/a&gt; as its template engine). This means that &lt;strong&gt;you can choose the template that fits the Swift version you&#39;re using&lt;/strong&gt; — and also the one that best fits your preferences — to &lt;strong&gt;adapt the generated code to your own conventions and Swift version&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Bundled templates vs. Custom ones&lt;/h3&gt; &#xA;&lt;p&gt;SwiftGen comes bundled with some templates for each of the parsers (&lt;code&gt;colors&lt;/code&gt;, &lt;code&gt;coredata&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;fonts&lt;/code&gt;, &lt;code&gt;ib&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, &lt;code&gt;plist&lt;/code&gt;, &lt;code&gt;strings&lt;/code&gt;, &lt;code&gt;xcassets&lt;/code&gt;, &lt;code&gt;yaml&lt;/code&gt;), which will fit most needs; simply use the &lt;code&gt;templateName&lt;/code&gt; output option to specify the name of the template to use. But you can also create your own templates if the bundled ones don&#39;t suit your coding conventions or needs: just store them anywhere (like in your project repository) and use the &lt;code&gt;templatePath&lt;/code&gt; output option instead of &lt;code&gt;templateName&lt;/code&gt;, to specify their path.&lt;/p&gt; &#xA;&lt;p&gt;💡 You can use the &lt;code&gt;swiftgen template list&lt;/code&gt; command to list all the available bundled templates for each parser, and use &lt;code&gt;swiftgen template cat&lt;/code&gt; to show a template&#39;s content and duplicate it to create your own variation.&lt;/p&gt; &#xA;&lt;p&gt;For more information about how to create your own templates, &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/Articles/Creating-custom-templates.md&#34;&gt;see the dedicated documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Templates bundled with SwiftGen:&lt;/h3&gt; &#xA;&lt;p&gt;As explained above, you can use &lt;code&gt;swiftgen template list&lt;/code&gt; to list all templates bundled with SwiftGen. For most SwiftGen parsers, we provide, among others:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A &lt;code&gt;swift4&lt;/code&gt; template, compatible with Swift 4&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;swift5&lt;/code&gt; template, compatible with Swift 5&lt;/li&gt; &#xA; &lt;li&gt;Other variants, like &lt;code&gt;flat-swift4/5&lt;/code&gt; and &lt;code&gt;structured-swift4/5&lt;/code&gt; templates for Strings, etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can &lt;strong&gt;find the documentation for each bundled template &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/templates&#34;&gt;here in the repo&lt;/a&gt;&lt;/strong&gt;, with documentation organized as one folder per SwiftGen parser, then one MarkDown file per template. You can also use &lt;code&gt;swiftgen template doc&lt;/code&gt; to open that documentation page in your browser directly from your terminal.&lt;/p&gt; &#xA;&lt;p&gt;Each MarkDown file documents the Swift Version it&#39;s aimed for, the use case for that template (in which cases you might favor that template over others), the available parameters to customize it on invocation (using the &lt;code&gt;params:&lt;/code&gt; key in your config file), and some code examples.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Don&#39;t hesitate to make PRs to share your improvements suggestions on the bundled templates 😉&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Additional documentation&lt;/h2&gt; &#xA;&lt;h3&gt;Playground&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;SwiftGen.playground&lt;/code&gt; available in this repository will allow you to play with the code that the tool typically generates, and see some examples of how you can take advantage of it.&lt;/p&gt; &#xA;&lt;p&gt;This allows you to have a quick look at how typical code generated by SwiftGen looks like, and how you will then use the generated constants in your code.&lt;/p&gt; &#xA;&lt;h3&gt;Dedicated Documentation in Markdown&lt;/h3&gt; &#xA;&lt;p&gt;There is a lot of documentation in the form of Markdown files in this repository, and in the related &lt;a href=&#34;https://github.com/SwiftGen/StencilSwiftKit&#34;&gt;StencilSwiftKit&lt;/a&gt; repository as well.&lt;/p&gt; &#xA;&lt;p&gt;Be sure to &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/&#34;&gt;check the &#34;Documentation&#34; folder&lt;/a&gt; of each repository.&lt;/p&gt; &#xA;&lt;p&gt;Especially, in addition to the previously mentioned &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/MigrationGuide.md&#34;&gt;Migration Guide&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/ConfigFile.md&#34;&gt;Configuration File&lt;/a&gt; documentation, the &lt;code&gt;Documentation/&lt;/code&gt; folder in the SwiftGen repository also includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/templates/&#34;&gt;&lt;code&gt;templates&lt;/code&gt; subdirectory&lt;/a&gt; that details the documentation for each of the templates bundled with SwiftGen (when to use each template, what the output will look like, and custom parameters to adjust them, …)&lt;/li&gt; &#xA; &lt;li&gt;A &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/SwiftGenKit%20Contexts/&#34;&gt;&lt;code&gt;SwiftGenKit Contexts&lt;/code&gt; subdirectory&lt;/a&gt; that details the structure of the &#34;Stencil Contexts&#34;, i.e. the Dictionary/YAML representation resulting of parsing your input files. This documentation is useful for people wanting to write their own templates, so that they know the structure and various keys available when writing their template, to construct the wanted generated output accordingly.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/Articles/&#34;&gt;Various articles&lt;/a&gt; to provide best practices &amp;amp; tips on how to better take advantage of SwiftGen in your projects: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/Articles/Xcode-Integration.md&#34;&gt;Integrate SwiftGen in your Xcode project&lt;/a&gt; — so it rebuilds the constants every time you build&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/Articles/SwiftLint-Integration.md&#34;&gt;Configure SwiftLint to help your developers use constants generated by SwiftGen&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/Articles/Creating-custom-templates.md&#34;&gt;Create a custom template&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/Articles/Watch-a-folder-for-changes.md&#34;&gt;watch a folder to auto-regenerate an output every time you save the template you&#39;re working on&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;…and more&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Tutorials&lt;/h3&gt; &#xA;&lt;p&gt;You can also find other help &amp;amp; tutorial material on the internet, like &lt;a href=&#34;https://github.com/FrenchKit/Mastering-code-generation-Classroom&#34;&gt;this classroom about Code Generation I gave at FrenchKit in Sept&#39;17&lt;/a&gt; — and its wiki detailing a step-by-step tutorial about installing and using SwiftGen (and Sourcery too)&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Available Parsers&lt;/h1&gt; &#xA;&lt;h2&gt;Asset Catalog&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;xcassets:&#xA;  inputs: /dir/to/search/for/imageset/assets&#xA;  outputs:&#xA;    templateName: swift5&#xA;    output: Assets.swift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will generate an &lt;code&gt;enum Asset&lt;/code&gt; with one &lt;code&gt;static let&lt;/code&gt; per asset (image set, color set, data set, …) in your assets catalog, so that you can use them as constants.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example of code generated by the bundled template&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;internal enum Asset {&#xA;  internal enum Files {&#xA;    internal static let data = DataAsset(value: &#34;Data&#34;)&#xA;    internal static let readme = DataAsset(value: &#34;README&#34;)&#xA;  }&#xA;  internal enum Food {&#xA;    internal enum Exotic {&#xA;      internal static let banana = ImageAsset(value: &#34;Exotic/Banana&#34;)&#xA;      internal static let mango = ImageAsset(value: &#34;Exotic/Mango&#34;)&#xA;    }&#xA;    internal static let `private` = ImageAsset(value: &#34;private&#34;)&#xA;  }&#xA;  internal enum Styles {&#xA;    internal enum Vengo {&#xA;      internal static let primary = ColorAsset(value: &#34;Vengo/Primary&#34;)&#xA;      internal static let tint = ColorAsset(value: &#34;Vengo/Tint&#34;)&#xA;    }&#xA;  }&#xA;  internal enum Symbols {&#xA;    internal static let exclamationMark = SymbolAsset(name: &#34;Exclamation Mark&#34;)&#xA;    internal static let plus = SymbolAsset(name: &#34;Plus&#34;)&#xA;  }&#xA;  internal enum Targets {&#xA;    internal static let bottles = ARResourceGroupAsset(name: &#34;Bottles&#34;)&#xA;    internal static let paintings = ARResourceGroupAsset(name: &#34;Paintings&#34;)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Usage Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// You can create new images by referring to the enum instance and calling `.image` on it:&#xA;let bananaImage = Asset.Exotic.banana.image&#xA;let privateImage = Asset.private.image&#xA;&#xA;// You can create colors by referring to the enum instance and calling `.color` on it:&#xA;let primaryColor = Asset.Styles.Vengo.primary.color&#xA;let tintColor = Asset.Styles.Vengo.tint.color&#xA;&#xA;// You can create data items by referring to the enum instance and calling `.data` on it:&#xA;let data = Asset.data.data&#xA;let readme = Asset.readme.data&#xA;&#xA;// You can load an AR resource group&#39;s items using:&#xA;let bottles = Asset.Targets.bottles.referenceObjects&#xA;let paintings = Asset.Targets.paintings.referenceImages&#xA;&#xA;// You can create new symbol images by referring to the enum instance and calling `.image` on it (with or without configuration)&#xA;let plus = Asset.Symbols.plus.image&#xA;let style = UIImage.SymbolConfiguration(textStyle: .headline)&#xA;let styled = Asset.Symbols.exclamationMark.image(with: style)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Colors&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;❗️ We recommend to define your colors in your Assets Catalogs and use the &lt;code&gt;xcassets&lt;/code&gt; parser (see above) to generate color constants, instead of using this &lt;code&gt;colors&lt;/code&gt; parser described below.&lt;br&gt; The &lt;code&gt;colors&lt;/code&gt; parser below is mainly useful if you support older versions of iOS where colors can&#39;t be defined in Asset Catalogs, or if you want to use Android&#39;s &lt;code&gt;colors.xml&lt;/code&gt; files as input.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;colors:&#xA;  inputs: /path/to/colors-file.txt&#xA;  outputs:&#xA;    templateName: swift5&#xA;    output: Colors.swift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will generate a &lt;code&gt;enum ColorName&lt;/code&gt; with one &lt;code&gt;static let&lt;/code&gt; per color listed in the text file passed as argument.&lt;/p&gt; &#xA;&lt;p&gt;The input file is expected to be either:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Sources/TestUtils/Fixtures/Resources/Colors/extra.txt&#34;&gt;plain text file&lt;/a&gt;, with one line per color to register, each line being composed by the Name to give to the color, followed by &#34;:&#34;, followed by the Hex representation of the color (like &lt;code&gt;rrggbb&lt;/code&gt; or &lt;code&gt;rrggbbaa&lt;/code&gt;, optionally prefixed by &lt;code&gt;#&lt;/code&gt; or &lt;code&gt;0x&lt;/code&gt;) or the name of another color in the file. Whitespaces are ignored.&lt;/li&gt; &#xA; &lt;li&gt;a &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Sources/TestUtils/Fixtures/Resources/Colors/colors.json&#34;&gt;JSON file&lt;/a&gt;, representing a dictionary of names -&amp;gt; values, each value being the hex representation of the color&lt;/li&gt; &#xA; &lt;li&gt;a &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Sources/TestUtils/Fixtures/Resources/Colors/colors.xml&#34;&gt;XML file&lt;/a&gt;, expected to be the same format as the Android colors.xml files, containing tags &lt;code&gt;&amp;lt;color name=&#34;AColorName&#34;&amp;gt;AColorHexRepresentation&amp;lt;/color&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;a &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/DrawColor/Concepts/AboutColorLists.html#//apple_ref/doc/uid/20000757-BAJHJEDI&#34;&gt;&lt;code&gt;*.clr&lt;/code&gt; file&lt;/a&gt; used by Apple&#39;s Color Palettes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example you can use this command to generate colors from one of your system color lists:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;colors:&#xA;  inputs: ~/Library/Colors/MyColors.clr&#xA;  outputs:&#xA;    templateName: swift5&#xA;    output: Colors.swift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Generated code will look the same as if you&#39;d use a text file.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example of code generated by the bundled template&lt;/summary&gt; &#xA; &lt;p&gt;Given the following &lt;code&gt;colors.txt&lt;/code&gt; file:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;Cyan-Color       : 0xff66ccff&#xA;ArticleTitle     : #33fe66&#xA;ArticleBody      : 339666&#xA;ArticleFootnote  : ff66ccff&#xA;Translucent      : ffffffcc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The generated code will look like this:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;internal struct ColorName {&#xA;  internal let rgbaValue: UInt32&#xA;  internal var color: Color { return Color(named: self) }&#xA;&#xA;  /// &amp;lt;span style=&#34;display:block;width:3em;height:2em;border:1px solid black;background:#339666&#34;&amp;gt;&amp;lt;/span&amp;gt;&#xA;  /// Alpha: 100% &amp;lt;br/&amp;gt; (0x339666ff)&#xA;  internal static let articleBody = ColorName(rgbaValue: 0x339666ff)&#xA;  /// &amp;lt;span style=&#34;display:block;width:3em;height:2em;border:1px solid black;background:#ff66cc&#34;&amp;gt;&amp;lt;/span&amp;gt;&#xA;  /// Alpha: 100% &amp;lt;br/&amp;gt; (0xff66ccff)&#xA;  internal static let articleFootnote = ColorName(rgbaValue: 0xff66ccff)&#xA;&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Usage Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// You can create colors with the convenience constructor like this:&#xA;let title = UIColor(named: .articleBody)  // iOS&#xA;let footnote = NSColor(named: .articleFootnote) // macOS&#xA;&#xA;// Or as an alternative, you can refer to enum instance and call .color on it:&#xA;let sameTitle = ColorName.articleBody.color&#xA;let sameFootnote = ColorName.articleFootnote.color&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This way, no need to enter the color red, green, blue, alpha values each time and create ugly constants in the global namespace for them.&lt;/p&gt; &#xA;&lt;h2&gt;Core Data&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;coredata:&#xA;  inputs: /path/to/model.xcdatamodeld&#xA;  outputs:&#xA;    templateName: swift5&#xA;    output: CoreData.swift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will parse the specified core data model(s), generate a class for each entity in your model containing all the attributes, and a few extensions if needed for relationships and predefined fetch requests.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example of code generated by the bundled template&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;internal class MainEntity: NSManagedObject {&#xA;  internal class var entityName: String {&#xA;    return &#34;MainEntity&#34;&#xA;  }&#xA;&#xA;  internal class func entity(in managedObjectContext: NSManagedObjectContext) -&amp;gt; NSEntityDescription? {&#xA;    return NSEntityDescription.entity(forEntityName: entityName, in: managedObjectContext)&#xA;  }&#xA;&#xA;  @nonobjc internal class func makeFetchRequest() -&amp;gt; NSFetchRequest&amp;lt;MainEntity&amp;gt; {&#xA;    return NSFetchRequest&amp;lt;MainEntity&amp;gt;(entityName: entityName)&#xA;  }&#xA;&#xA;  @NSManaged internal var attributedString: NSAttributedString?&#xA;  @NSManaged internal var binaryData: Data?&#xA;  @NSManaged internal var boolean: Bool&#xA;  @NSManaged internal var date: Date?&#xA;  @NSManaged internal var float: Float&#xA;  @NSManaged internal var int64: Int64&#xA;  internal var integerEnum: IntegerEnum {&#xA;    get {&#xA;      let key = &#34;integerEnum&#34;&#xA;      willAccessValue(forKey: key)&#xA;      defer { didAccessValue(forKey: key) }&#xA;&#xA;      guard let value = primitiveValue(forKey: key) as? IntegerEnum.RawValue,&#xA;        let result = IntegerEnum(rawValue: value) else {&#xA;        fatalError(&#34;Could not convert value for key &#39;\(key)&#39; to type &#39;IntegerEnum&#39;&#34;)&#xA;      }&#xA;      return result&#xA;    }&#xA;    set {&#xA;      let key = &#34;integerEnum&#34;&#xA;      willChangeValue(forKey: key)&#xA;      defer { didChangeValue(forKey: key) }&#xA;&#xA;      setPrimitiveValue(newValue.rawValue, forKey: key)&#xA;    }&#xA;  }&#xA;  @NSManaged internal var manyToMany: Set&amp;lt;SecondaryEntity&amp;gt;&#xA;}&#xA;&#xA;// MARK: Relationship ManyToMany&#xA;&#xA;extension MainEntity {&#xA;  @objc(addManyToManyObject:)&#xA;  @NSManaged public func addToManyToMany(_ value: SecondaryEntity)&#xA;&#xA;  @objc(removeManyToManyObject:)&#xA;  @NSManaged public func removeFromManyToMany(_ value: SecondaryEntity)&#xA;&#xA;  @objc(addManyToMany:)&#xA;  @NSManaged public func addToManyToMany(_ values: Set&amp;lt;SecondaryEntity&amp;gt;)&#xA;&#xA;  @objc(removeManyToMany:)&#xA;  @NSManaged public func removeFromManyToMany(_ values: Set&amp;lt;SecondaryEntity&amp;gt;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Usage Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Fetch all the instances of MainEntity&#xA;let request = MainEntity.makeFetchRequest()&#xA;let mainItems = try myContext.execute(request)&#xA;&#xA;// Type-safe relationships: `relatedItem` will be a `SecondaryEntity?` in this case&#xA;let relatedItem = myMainItem.manyToMany.first&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Files&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;files:&#xA;  inputs: path/to/search&#xA;  filter: .+\.mp4$&#xA;  outputs:&#xA;    templateName: structured-swift5&#xA;    output: Files.swift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The files parser is intended to just list the name and mimetype of the files and subdirectories in a given directory. This will recursively search the specified directory using the given filter (default &lt;code&gt;.*&lt;/code&gt;), defining a &lt;code&gt;struct File&lt;/code&gt; for each matching file, and an hierarchical enum representing the directory structure of files.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example of code generated by the bundled template&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;internal enum Files {&#xA;  /// test.txt&#xA;  internal static let testTxt = File(name: &#34;test&#34;, ext: &#34;txt&#34;, path: &#34;&#34;, mimeType: &#34;text/plain&#34;)&#xA;  /// subdir/&#xA;  internal enum Subdir {&#xA;    /// subdir/A Video With Spaces.mp4&#xA;    internal static let aVideoWithSpacesMp4 = File(name: &#34;A Video With Spaces&#34;, ext: &#34;mp4&#34;, path: &#34;subdir&#34;, mimeType: &#34;video/mp4&#34;)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Usage Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Access files using the `url` or `path` fields&#xA;let txt = Files.testTxt.url&#xA;let video = Files.Subdir.aVideoWithSpacesMp4.path&#xA;&#xA;// In addition, there are `url(locale:)` and `path(locale:)` to specify a locale&#xA;let localeTxt = Files.testTxt.url(locale: Locale.current)&#xA;let localeVideo = Files.Subdir.aVideoWithSpacesMp4.path(locale: Locale.current)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Flat Structure Support&lt;/h3&gt; &#xA;&lt;p&gt;SwiftGen also has a template if you&#39;re not interested in keeping the folder structure in the generated code.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example of code generated by the flat bundled template&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;internal enum Files {&#xA;  /// test.txt&#xA;  internal static let testTxt = File(name: &#34;test&#34;, ext: &#34;txt&#34;, path: &#34;&#34;, mimeType: &#34;text/plain&#34;)&#xA;  /// subdir/A Video With Spaces.mp4&#xA;  internal static let aVideoWithSpacesMp4 = File(name: &#34;A Video With Spaces&#34;, ext: &#34;mp4&#34;, path: &#34;subdir&#34;, mimeType: &#34;video/mp4&#34;)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Given the same file and folder structure as above the usage will now be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Access files using the `url` or `path` fields&#xA;let txt = Files.testTxt.url&#xA;let video = Files.aVideoWithSpacesMp4.path&#xA;&#xA;// In addition, there are `url(locale:)` and `path(locale:)` to specify a locale&#xA;let localeTxt = Files.testTxt.url(locale: Locale.current)&#xA;let localeVideo = Files.aVideoWithSpacesMp4.path(locale: Locale.current)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Fonts&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;fonts:&#xA;  inputs: /path/to/font/dir&#xA;  outputs:&#xA;    templateName: swift5&#xA;    output: Fonts.swift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will recursively go through the specified directory, finding any typeface files (TTF, OTF, …), defining a &lt;code&gt;struct FontFamily&lt;/code&gt; for each family, and an enum nested under that family that will represent the font styles.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example of code generated by the bundled template&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;internal enum FontFamily {&#xA;  internal enum SFNSDisplay: String, FontConvertible {&#xA;    internal static let regular = FontConvertible(name: &#34;.SFNSDisplay-Regular&#34;, family: &#34;.SF NS Display&#34;, path: &#34;SFNSDisplay-Regular.otf&#34;)&#xA;  }&#xA;  internal enum ZapfDingbats: String, FontConvertible {&#xA;    internal static let regular = FontConvertible(name: &#34;ZapfDingbatsITC&#34;, family: &#34;Zapf Dingbats&#34;, path: &#34;ZapfDingbats.ttf&#34;)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Usage Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// You can create fonts with the convenience constructor like this:&#xA;let displayRegular = UIFont(font: FontFamily.SFNSDisplay.regular, size: 20.0) // iOS&#xA;let dingbats = NSFont(font: FontFamily.ZapfDingbats.regular, size: 20.0)  // macOS&#xA;&#xA;// Or as an alternative, you can refer to enum instance and call .font on it:&#xA;let sameDisplayRegular = FontFamily.SFNSDisplay.regular.font(size: 20.0)&#xA;let sameDingbats = FontFamily.ZapfDingbats.regular.font(size: 20.0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Interface Builder&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;ib:&#xA;  inputs: /dir/to/search/for/storyboards&#xA;  outputs:&#xA;    - templateName: scenes-swift5&#xA;      output: Storyboard Scenes.swift&#xA;    - templateName: segues-swift5&#xA;      output: Storyboard Segues.swift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will generate an &lt;code&gt;enum&lt;/code&gt; for each of your &lt;code&gt;NSStoryboard&lt;/code&gt;/&lt;code&gt;UIStoryboard&lt;/code&gt;, with respectively one &lt;code&gt;static let&lt;/code&gt; per storyboard scene or segue.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example of code generated by the bundled template&lt;/summary&gt; &#xA; &lt;p&gt;The generated code will look like this:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// output from the scenes template&#xA;&#xA;internal enum StoryboardScene {&#xA;  internal enum Dependency: StoryboardType {&#xA;    internal static let storyboardName = &#34;Dependency&#34;&#xA;&#xA;    internal static let dependent = SceneType&amp;lt;UIViewController&amp;gt;(storyboard: Dependency.self, identifier: &#34;Dependent&#34;)&#xA;  }&#xA;  internal enum Message: StoryboardType {&#xA;    internal static let storyboardName = &#34;Message&#34;&#xA;&#xA;    internal static let messagesList = SceneType&amp;lt;UITableViewController&amp;gt;(storyboard: Message.self, identifier: &#34;MessagesList&#34;)&#xA;  }&#xA;}&#xA;&#xA;// output from the segues template&#xA;&#xA;internal enum StoryboardSegue {&#xA;  internal enum Message: String, SegueType {&#xA;    case customBack = &#34;CustomBack&#34;&#xA;    case embed = &#34;Embed&#34;&#xA;    case nonCustom = &#34;NonCustom&#34;&#xA;    case showNavCtrl = &#34;Show-NavCtrl&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Usage Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// You can instantiate scenes using the `instantiate` method:&#xA;let vc = StoryboardScene.Dependency.dependent.instantiate()&#xA;&#xA;// You can perform segues using:&#xA;vc.perform(segue: StoryboardSegue.Message.embed)&#xA;&#xA;// or match them (in prepareForSegue):&#xA;override func prepare(for segue: UIStoryboardSegue, sender: Any?) {&#xA;  switch StoryboardSegue.Message(segue) {&#xA;  case .embed?:&#xA;    // Prepare for your custom segue transition, passing information to the destination VC&#xA;  case .customBack?:&#xA;    // Prepare for your custom segue transition, passing information to the destination VC&#xA;  default:&#xA;    // Other segues from other scenes, not handled by this VC&#xA;    break&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;JSON and YAML&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;json:&#xA;  inputs: /path/to/json/dir-or-file&#xA;  outputs:&#xA;    templateName: runtime-swift5&#xA;    output: JSON.swift&#xA;yaml:&#xA;  inputs: /path/to/yaml/dir-or-file&#xA;  outputs:&#xA;    templateName: inline-swift5&#xA;    output: YAML.swift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will parse the given file, or when given a directory, recursively search for JSON and YAML files. It will define an &lt;code&gt;enum&lt;/code&gt; for each file (and documents in a file where needed), and type-safe constants for the content of the file.&lt;/p&gt; &#xA;&lt;p&gt;Unlike other parsers, this one is intended to allow you to use more custom inputs (as the formats are quite open to your needs) to generate your code. This means that for these parsers (and the &lt;code&gt;plist&lt;/code&gt; one), you&#39;ll probably be more likely to use custom templates to generate code properly adapted/tuned to your inputs, rather than using the bundled templates. To read more about writing your own custom templates, see &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/Articles/Creating-custom-templates.md&#34;&gt;see the dedicated documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example of code generated by the bundled template&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;internal enum JSONFiles {&#xA;  internal enum Info {&#xA;    private static let _document = JSONDocument(path: &#34;info.json&#34;)&#xA;    internal static let key1: String = _document[&#34;key1&#34;]&#xA;    internal static let key2: String = _document[&#34;key2&#34;]&#xA;    internal static let key3: [String: Any] = _document[&#34;key3&#34;]&#xA;  }&#xA;  internal enum Sequence {&#xA;    internal static let items: [Int] = objectFromJSON(at: &#34;sequence.json&#34;)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Usage Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// This will be a dictionary&#xA;let foo = JSONFiles.Info.key3&#xA;&#xA;// This will be an [Int]&#xA;let bar = JSONFiles.Sequence.items&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Plists&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;plist:&#xA;  inputs: /path/to/plist/dir-or-file&#xA;  outputs:&#xA;    templateName: runtime-swift5&#xA;    output: Plist.swift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will parse the given file, or when given a directory, recursively search for Plist files. It will define an &lt;code&gt;enum&lt;/code&gt; for each file (and documents in a file where needed), and type-safe constants for the content of the file.&lt;/p&gt; &#xA;&lt;p&gt;Unlike other parsers, this one is intended to allow you to use more custom inputs (as the format is quite open to your needs) to generate your code. This means that for this parser (and the &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;yaml&lt;/code&gt; ones), you&#39;ll probably be more likely to use custom templates to generate code properly adapted/tuned to your inputs, rather than using the bundled templates. To read more about writing your own custom templates, see &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/Articles/Creating-custom-templates.md&#34;&gt;see the dedicated documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example of code generated by the bundled template&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;internal enum PlistFiles {&#xA;  internal enum Test {&#xA;    internal static let items: [String] = arrayFromPlist(at: &#34;array.plist&#34;)&#xA;  }&#xA;  internal enum Stuff {&#xA;    private static let _document = PlistDocument(path: &#34;dictionary.plist&#34;)&#xA;    internal static let key1: Int = _document[&#34;key1&#34;]&#xA;    internal static let key2: [String: Any] = _document[&#34;key2&#34;]&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Usage Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// This will be an array&#xA;let foo = PlistFiles.Test.items&#xA;&#xA;// This will be an Int&#xA;let bar = PlistFiles.Stuff.key1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Strings&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;strings:&#xA;  inputs: /path/to/language.lproj&#xA;  outputs:&#xA;    templateName: structured-swift5&#xA;    output: Strings.swift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will generate a Swift &lt;code&gt;enum L10n&lt;/code&gt; that will map all your &lt;code&gt;Localizable.strings&lt;/code&gt; and &lt;code&gt;Localizable.stringsdict&lt;/code&gt; (or other tables) keys to a &lt;code&gt;static let&lt;/code&gt; constant. And if it detects placeholders like &lt;code&gt;%@&lt;/code&gt;,&lt;code&gt;%d&lt;/code&gt;,&lt;code&gt;%f&lt;/code&gt;, it will generate a &lt;code&gt;static func&lt;/code&gt; with the proper argument types instead, to provide type-safe formatting. By default it will add comments to the generated constants and functions using the comments from the strings file if present, or the default translation of the string.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note that all dots within the key names are converted to dots in code (by using nested enums). You can provide a different separator than &lt;code&gt;.&lt;/code&gt; to split key names into substructures by using a parser option – see &lt;a href=&#34;https://raw.githubusercontent.com/SwiftGen/SwiftGen/stable/Documentation/Parsers/strings.md&#34;&gt;the parser documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example of code generated by the structured bundled template&lt;/summary&gt; &#xA; &lt;p&gt;Given the following &lt;code&gt;Localizable.strings&lt;/code&gt; file:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;/* Title for an alert */&#xA;&#34;alert_title&#34; = &#34;Title of the alert&#34;;&#xA;&#34;alert_message&#34; = &#34;Some alert body there&#34;;&#xA;/* A comment with no space above it */&#xA;&#34;bananas.owner&#34; = &#34;Those %d bananas belong to %@.&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;And the following &lt;code&gt;Localizable.stringsdict&lt;/code&gt; file:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&amp;gt;&#xA;&amp;lt;plist version=&#34;1.0&#34;&amp;gt;&#xA;  &amp;lt;dict&amp;gt;&#xA;    &amp;lt;key&amp;gt;apples.count&amp;lt;/key&amp;gt;&#xA;    &amp;lt;dict&amp;gt;&#xA;        &amp;lt;key&amp;gt;NSStringLocalizedFormatKey&amp;lt;/key&amp;gt;&#xA;        &amp;lt;string&amp;gt;%#@apples@&amp;lt;/string&amp;gt;&#xA;        &amp;lt;key&amp;gt;apples&amp;lt;/key&amp;gt;&#xA;        &amp;lt;dict&amp;gt;&#xA;            &amp;lt;key&amp;gt;NSStringFormatSpecTypeKey&amp;lt;/key&amp;gt;&#xA;            &amp;lt;string&amp;gt;NSStringPluralRuleType&amp;lt;/string&amp;gt;&#xA;            &amp;lt;key&amp;gt;NSStringFormatValueTypeKey&amp;lt;/key&amp;gt;&#xA;            &amp;lt;string&amp;gt;d&amp;lt;/string&amp;gt;&#xA;            &amp;lt;key&amp;gt;zero&amp;lt;/key&amp;gt;&#xA;            &amp;lt;string&amp;gt;You have no apples&amp;lt;/string&amp;gt;&#xA;            &amp;lt;key&amp;gt;one&amp;lt;/key&amp;gt;&#xA;            &amp;lt;string&amp;gt;You have one apple&amp;lt;/string&amp;gt;&#xA;            &amp;lt;key&amp;gt;other&amp;lt;/key&amp;gt;&#xA;            &amp;lt;string&amp;gt;You have %d apples. Wow that is a lot!&amp;lt;/string&amp;gt;&#xA;        &amp;lt;/dict&amp;gt;&#xA;    &amp;lt;/dict&amp;gt;&#xA;  &amp;lt;/dict&amp;gt;&#xA;&amp;lt;/plist&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;&lt;em&gt;Reminder: Don&#39;t forget to end each line in your &lt;code&gt;*.strings&lt;/code&gt; files with a semicolon &lt;code&gt;;&lt;/code&gt;! Now that in Swift code we don&#39;t need semi-colons, it&#39;s easy to forget it&#39;s still required by the &lt;code&gt;Localizable.strings&lt;/code&gt; file format 😉&lt;/em&gt;&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;The generated code will contain this:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;internal enum L10n {&#xA;  /// Some alert body there&#xA;  internal static let alertMessage = L10n.tr(&#34;Localizable&#34;, &#34;alert__message&#34;, fallback: #&#34;Some alert body there&#34;#)&#xA;  /// Title for an alert&#xA;  internal static let alertTitle = L10n.tr(&#34;Localizable&#34;, &#34;alert__title&#34;, fallback: #&#34;Title of the alert&#34;#)&#xA;  internal enum Apples {&#xA;    /// You have %d apples&#xA;    internal static func count(_ p1: Int) -&amp;gt; String {&#xA;      return L10n.tr(&#34;Localizable&#34;, &#34;apples.count&#34;, p1, fallback: #&#34;You have %d apples&#34;#)&#xA;    }&#xA;  }&#xA;  internal enum Bananas {&#xA;    /// A comment with no space above it&#xA;    internal static func owner(_ p1: Int, _ p2: Any) -&amp;gt; String {&#xA;      return L10n.tr(&#34;Localizable&#34;, &#34;bananas.owner&#34;, p1, String(describing: p2), fallback: #&#34;Those %d bananas belong to %@.&#34;#)&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Note that if the same key is present in both the &lt;code&gt;.strings&lt;/code&gt; and the &lt;code&gt;.stringsdict&lt;/code&gt; files, SwiftGen will only consider the one in the &lt;code&gt;.stringsdict&lt;/code&gt; file, as that&#39;s also how Foundation behaves at runtime.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Usage Example&lt;/h3&gt; &#xA;&lt;p&gt;Once the code has been generated by the script, you can use it this way in your Swift code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Simple strings&#xA;let message = L10n.alertMessage&#xA;let title = L10n.alertTitle&#xA;&#xA;// with parameters, note that each argument needs to be of the correct type&#xA;let apples = L10n.Apples.count(3)&#xA;let bananas = L10n.Bananas.owner(5, &#34;Olivier&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Flat Strings Support&lt;/h3&gt; &#xA;&lt;p&gt;SwiftGen also has a template to support flat strings files (i.e. without splitting the keys in substructures using &#34;dot syntax&#34;). The advantage is that your keys won&#39;t be mangled in any way; the disadvantage is that auto-completion won&#39;t be as nice.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Example of code generated by the flat bundled template&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;internal enum L10n {&#xA;  /// Some alert body there&#xA;  internal static let alertMessage = L10n.tr(&#34;Localizable&#34;, &#34;alert__message&#34;, fallback: #&#34;Some alert body there&#34;#)&#xA;  /// Title for an alert&#xA;  internal static let alertTitle = L10n.tr(&#34;Localizable&#34;, &#34;alert__title&#34;, fallback: #&#34;Title of the alert&#34;#)&#xA;  /// You have %d apples&#xA;  internal static func applesCount(_ p1: Int) -&amp;gt; String {&#xA;    return L10n.tr(&#34;Localizable&#34;, &#34;apples.count&#34;, p1, fallback: #&#34;You have %d apples&#34;#)&#xA;  }&#xA;  /// A comment with no space above it&#xA;  internal static func bananasOwner(_ p1: Int, _ p2: Any) -&amp;gt; String {&#xA;    return L10n.tr(&#34;Localizable&#34;, &#34;bananas.owner&#34;, p1, String(describing: p2), fallback: #&#34;Those %d bananas belong to %@.&#34;#)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Given the same &lt;code&gt;Localizable.strings&lt;/code&gt; and &lt;code&gt;Localizable.stringsdict&lt;/code&gt; as above the usage will now be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Simple strings&#xA;let message = L10n.alertMessage&#xA;let title = L10n.alertTitle&#xA;&#xA;// with parameters, note that each argument needs to be of the correct type&#xA;let apples = L10n.applesCount(3)&#xA;let bananas = L10n.bananasOwner(5, &#34;Olivier&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Licence&lt;/h1&gt; &#xA;&lt;p&gt;This code and tool is under the MIT Licence. See the &lt;code&gt;LICENCE&lt;/code&gt; file in this repository.&lt;/p&gt; &#xA;&lt;h2&gt;Attributions&lt;/h2&gt; &#xA;&lt;p&gt;This tool is powered by&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/stencilproject/Stencil&#34;&gt;Stencil&lt;/a&gt; and few other libs by &lt;a href=&#34;https://github.com/kylef&#34;&gt;Kyle Fuller&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;SwiftGenKit and &lt;a href=&#34;https://github.com/SwiftGen/StencilSwiftKit&#34;&gt;StencilSwiftKit&lt;/a&gt;, our internal frameworks at SwiftGen&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is currently mainly maintained by &lt;a href=&#34;https://github.com/AliSoftware&#34;&gt;@AliSoftware&lt;/a&gt; and &lt;a href=&#34;https://github.com/djbe&#34;&gt;@djbe&lt;/a&gt;. But I couldn&#39;t thank enough all the other &lt;a href=&#34;https://github.com/SwiftGen/SwiftGen/graphs/contributors&#34;&gt;contributors&lt;/a&gt; to this tool along the different versions which helped make SwiftGen awesome! 🎉&lt;/p&gt; &#xA;&lt;p&gt;If you want to contribute, don&#39;t hesitate to open a Pull Request, or even join the team!&lt;/p&gt; &#xA;&lt;h2&gt;Other Libraries / Tools&lt;/h2&gt; &#xA;&lt;p&gt;If you want to also get rid of String-based APIs not only for your resources, but also for &lt;code&gt;UITableViewCell&lt;/code&gt;, &lt;code&gt;UICollectionViewCell&lt;/code&gt; and XIB-based views, you should take a look at my Mixin &lt;a href=&#34;https://github.com/AliSoftware/Reusable&#34;&gt;Reusable&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to generate Swift code from your own Swift code (so meta!), like generate &lt;code&gt;Equatable&lt;/code&gt; conformance to your types and a lot of other similar things, use &lt;a href=&#34;https://github.com/krzysztofzablocki/Sourcery&#34;&gt;Sourcery&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;SwiftGen and Sourcery are complementary tools. In fact, Sourcery uses &lt;code&gt;Stencil&lt;/code&gt; too, as well as SwiftGen&#39;s &lt;code&gt;StencilSwiftKit&lt;/code&gt; so you can use the exact same syntax for your templates for both!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can also &lt;a href=&#34;http://twitter.com/aligatr&#34;&gt;follow me on twitter&lt;/a&gt; for news/updates about other projects I am creating, or &lt;a href=&#34;https://alisoftware.github.io&#34;&gt;read my blog&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>