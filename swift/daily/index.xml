<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-06T01:34:12Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rundfunk47/stinsen</title>
    <updated>2024-08-06T01:34:12Z</updated>
    <id>tag:github.com,2024-08-06:/rundfunk47/stinsen</id>
    <link href="https://github.com/rundfunk47/stinsen" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Coordinators in SwiftUI. Simple, powerful and elegant.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/rundfunk47/stinsen/master/Images/wordmark.svg?sanitize=true&#34; alt=&#34;Stinsen&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://swift.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1.svg?label=language&amp;amp;message=Swift%205&amp;amp;color=FA7343&amp;amp;logo=swift&amp;amp;style=flat-square&#34; alt=&#34;Language&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://apple.com&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1.svg?label=platforms&amp;amp;message=iOS%20%7C%20tvOS%20%7C%20watchOS%20%7C%20macOS&amp;amp;logo=apple&amp;amp;style=flat-square&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/rundfunk47/stinsen/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/l/Crossroad.svg?style=flat-square&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Simple, powerful and elegant implementation of the Coordinator pattern in SwiftUI. Stinsen is written using 100% SwiftUI which makes it work seamlessly across iOS, tvOS, watchOS and macOS devices.&lt;/p&gt; &#xA;&lt;h1&gt;Why? ü§î&lt;/h1&gt; &#xA;&lt;p&gt;We all know routing in UIKit can be hard to do elegantly when working with applications of a larger size or when attempting to apply an architectural pattern such as MVVM. Unfortunately, SwiftUI out of the box suffers from many of the same problems as UIKit does: concepts such as &lt;code&gt;NavigationLink&lt;/code&gt; live in the view-layer, we still have no clear concept of flows and routes, and so on. &lt;em&gt;Stinsen&lt;/em&gt; was created to alleviate these pains, and is an implementation of the &lt;em&gt;Coordinator Pattern&lt;/em&gt;. Being written in SwiftUI, it is completely cross-platform and uses the native tools such as &lt;code&gt;@EnvironmentObject&lt;/code&gt;. The goal is to make &lt;em&gt;Stinsen&lt;/em&gt; feel like a missing tool in SwiftUI, conforming to its coding style and general principles.&lt;/p&gt; &#xA;&lt;h1&gt;What is a Coordinator? ü§∑üèΩ‚Äç‚ôÇÔ∏è&lt;/h1&gt; &#xA;&lt;p&gt;Normally in SwiftUI, the view has to handle adding other views to the navigation stack using &lt;code&gt;NavigationLink&lt;/code&gt;. What we have here is a tight coupling between the views, since the view must know in advance all the other views that it can navigate between. Also, the view is in violation of the &lt;em&gt;single-responsibility principle&lt;/em&gt; (SRP). Using the Coordinator Pattern, presented to the iOS community by Soroush Khanlou at the NSSpain conference in 2015, we can delegate this responsibility to a higher class: The Coordinator.&lt;/p&gt; &#xA;&lt;h1&gt;How do I use Stinsen? üë©üèº‚Äçüè´&lt;/h1&gt; &#xA;&lt;h2&gt;Defining the coordinator&lt;/h2&gt; &#xA;&lt;p&gt;Example using a Navigation Stack:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;final class UnauthenticatedCoordinator: NavigationCoordinatable {&#xA;    let stack = NavigationStack(initial: \UnauthenticatedCoordinator.start)&#xA;    &#xA;    @Root var start = makeStart&#xA;    @Route(.modal) var forgotPassword = makeForgotPassword&#xA;    @Route(.push) var registration = makeRegistration&#xA;    &#xA;    func makeRegistration() -&amp;gt; RegistrationCoordinator {&#xA;        return RegistrationCoordinator()&#xA;    }&#xA;    &#xA;    @ViewBuilder func makeForgotPassword() -&amp;gt; some View {&#xA;        ForgotPasswordScreen()&#xA;    }&#xA;    &#xA;    @ViewBuilder func makeStart() -&amp;gt; some View {&#xA;        LoginScreen()&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;@Route&lt;/code&gt;s defines all the possible routes that can be performed from the current coordinator and the transition that will be performed. The value on the right hand side is the factory function that will be executed when routing. The function can return either a SwiftUI view or another coordinator. The &lt;code&gt;@Root&lt;/code&gt; another type of route that has no transition, and used for defining the first view of the coordinator&#39;s navigation stack, which is referenced by the &lt;code&gt;NavigationStack&lt;/code&gt;-class.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Stinsen&lt;/em&gt; out of the box has two different kinds of &lt;code&gt;Coordinatable&lt;/code&gt; protocols your coordinators can implement:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;NavigationCoordinatable&lt;/code&gt; - For navigational flows. Make sure to wrap these in a NavigationViewCoordinator if you wish to push on the navigation stack.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TabCoordinatable&lt;/code&gt; - For TabViews.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition, &lt;em&gt;Stinsen&lt;/em&gt; also has two Coordinators you can use, &lt;code&gt;ViewWrapperCoordinator&lt;/code&gt; and &lt;code&gt;NavigationViewCoordinator&lt;/code&gt;. &lt;code&gt;ViewWrapperCoordinator&lt;/code&gt; is a coordinator you can either subclass or use right away to wrap your coordinator in a view, and &lt;code&gt;NavigationViewCoordinator&lt;/code&gt; is a &lt;code&gt;ViewWrapperCoordinator&lt;/code&gt; subclass that wraps your coordinator in a &lt;code&gt;NavigationView&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Showing the coordinator for the user&lt;/h2&gt; &#xA;&lt;p&gt;The view for the coordinator can be created using &lt;code&gt;.view()&lt;/code&gt;, so in order to show a coordinator to the user you would just do something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct StinsenApp: App {&#xA;    var body: some Scene {&#xA;        WindowGroup {&#xA;            MainCoordinator().view()&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Stinsen&lt;/em&gt; can be used to power your whole app, or just parts of your app. You can still use the usual SwiftUI &lt;code&gt;NavigationLink&lt;/code&gt;s and present modal sheets inside views managed by &lt;em&gt;Stinsen&lt;/em&gt;, if you wish to do so.&lt;/p&gt; &#xA;&lt;h2&gt;Navigating from the coordinator&lt;/h2&gt; &#xA;&lt;p&gt;Using a router, which has a reference to both the coordinator and the view, we can perform transitions from a view. Inside the view, the router can be fetched using &lt;code&gt;@EnvironmentObject&lt;/code&gt;. Using the router one can transition to other routes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct TodosScreen: View {&#xA;    @EnvironmentObject var todosRouter: TodosCoordinator.Router&#xA;    &#xA;    var body: some View {&#xA;        List {&#xA;          /* ... */&#xA;        }&#xA;        .navigationBarItems(&#xA;            trailing: Button(&#xA;                action: {&#xA;                    // Transition to the screen to create a todo:&#xA;                    todosRouter.route(to: \.createTodo) &#xA;                },&#xA;                label: { &#xA;                    Image(systemName: &#34;doc.badge.plus&#34;) &#xA;                }&#xA;            )&#xA;        )&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also fetch routers referencing coordinators that appeared earlier in the tree. For instance, you may want to switch the tab from a view that is inside the &lt;code&gt;TabView&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Routing can be performed directly on the coordinator itself, which can be useful if you want your coordinator to have some logic, or if you pass the coordinator around:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;final class MainCoordinator: NavigationCoordinatable {&#xA;    @Root var unauthenticated = makeUnauthenticated&#xA;    @Root var authenticated = makeAuthenticated&#xA;    &#xA;    /* ... */&#xA;    &#xA;    init() {&#xA;        /* ... */&#xA;&#xA;        cancellable = AuthenticationService.shared.status.sink { [weak self] status in&#xA;            switch status {&#xA;            case .authenticated(let user):&#xA;                self?.root(\.authentiated, user)&#xA;            case .unauthenticated:&#xA;                self?.root(\.unauthentiated)&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What actions you can perform from the router/coordinator depends on the kind of coordinator used. For instance, using a &lt;code&gt;NavigationCoordinatable&lt;/code&gt;, some of the functions you can perform are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;popLast&lt;/code&gt; - Removes the last item from the stack. Note that &lt;em&gt;Stinsen&lt;/em&gt; doesn&#39;t care if the view was presented modally or pushed, the same function is used for both.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pop&lt;/code&gt; - Removes the view from the stack. This function can only be performed by a router, since only the router knows about which view you&#39;re trying to pop.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;popToRoot&lt;/code&gt; - Clears the stack.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;root&lt;/code&gt; - Changes the root (i.e. the first view of the stack). If the root is already the active root, will do nothing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;route&lt;/code&gt; - Navigates to another route.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;focusFirst&lt;/code&gt; - Finds the specified route if it exists in the stack, starting from the first item. If found, will remove everything after that.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dismissCoordinator&lt;/code&gt; - Deletes the whole coordinator and it&#39;s associated children from the tree.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Examples üì±&lt;/h1&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/rundfunk47/stinsen/master/Images/stinsenapp-ios.gif&#34; alt=&#34;Stinsen Sample App&#34;&gt; &#xA;&lt;p&gt;Clone the repo and run the &lt;em&gt;StinsenApp&lt;/em&gt; in &lt;em&gt;Examples/App&lt;/em&gt; to get a feel for how &lt;em&gt;Stinsen&lt;/em&gt; can be used. &lt;em&gt;StinsenApp&lt;/em&gt; works on iOS, tvOS, watchOS and macOS. It attempts to showcase many of the features &lt;em&gt;Stinsen&lt;/em&gt; has available for you to use. Most of the code from this readme comes from the sample app. There is also an example showing how &lt;em&gt;Stinsen&lt;/em&gt; can be used to apply a testable MVVM-C architecture in SwiftUI, which is available in &lt;em&gt;Example/MVVM&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Advanced usage üë©üèæ‚Äçüî¨&lt;/h1&gt; &#xA;&lt;h2&gt;ViewModel Support&lt;/h2&gt; &#xA;&lt;p&gt;Since &lt;code&gt;@EnvironmentObject&lt;/code&gt; only can be accessed within a &lt;code&gt;View&lt;/code&gt;, &lt;em&gt;Stinsen&lt;/em&gt; provides a couple of ways of routing from the ViewModel. You can inject the coordinator through the √¨nitializer, or register it at creation and resolve it in the viewmodel through a dependency injection framework. These are the recommended ways of doing this, since you will have maximum control and functionality.&lt;/p&gt; &#xA;&lt;p&gt;Other ways are passing the router using the &lt;code&gt;onAppear&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct TodosScreen: View {&#xA;    @StateObject var viewModel = TodosViewModel() &#xA;    @EnvironmentObject var projects: TodosCoordinator.Router&#xA;    &#xA;    var body: some View {&#xA;        List {&#xA;          /* ... */&#xA;        }&#xA;        .onAppear {&#xA;            viewModel.router = projects&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use what is called the &lt;code&gt;RouterStore&lt;/code&gt; to retreive the router. The &lt;code&gt;RouterStore&lt;/code&gt; saves the instance of the router and you can get it via a custom PropertyWrapper.&lt;/p&gt; &#xA;&lt;p&gt;To retrieve a router:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class LoginScreenViewModel: ObservableObject {&#xA;    &#xA;    // directly via the RouterStore&#xA;    var main: MainCoordinator.Router? = RouterStore.shared.retrieve()&#xA;    &#xA;    // via the RouterObject property wrapper&#xA;    @RouterObject&#xA;    var unauthenticated: Unauthenticated.Router?&#xA;    &#xA;    init() {&#xA;        &#xA;    }&#xA;    &#xA;    func loginButtonPressed() {&#xA;        main?.root(\.authenticated)&#xA;    }&#xA;    &#xA;    func forgotPasswordButtonPressed() {&#xA;        unauthenticated?.route(to: \.forgotPassword)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To see this example in action, please check the MVVM-app in &lt;em&gt;Examples/MVVM&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Customizing&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes you&#39;d want to customize the view generated by your coordinator. NavigationCoordinatable and TabCoordinatable have a &lt;code&gt;customize&lt;/code&gt;-function you can implement in order to do so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;final class AuthenticatedCoordinator: TabCoordinatable {&#xA;    /* ... */&#xA;    @ViewBuilder func customize(_ view: AnyView) -&amp;gt; some View {&#xA;        view&#xA;            .onReceive(Services.shared.$authentication) { authentication in&#xA;                switch authentication {&#xA;                case .authenticated:&#xA;                    self.root(\.authenticated)&#xA;                case .unauthenticated:&#xA;                    self.root(\.unauthenticated)&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is also a &lt;code&gt;ViewWrapperCoordinator&lt;/code&gt; you can use to customize as well.&lt;/p&gt; &#xA;&lt;h2&gt;Chaining&lt;/h2&gt; &#xA;&lt;p&gt;Since most functions on the coordinator/router return a coordinator, you can use the results and chain them together to perform more advanced routing, if needed. For instance, to create a SwiftUI buttons that will change the tab and select a specific todo from anywhere in the app after login:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;VStack {&#xA;    ForEach(todosStore.favorites) { todo in&#xA;        Button(todo.name) {&#xA;            authenticatedRouter&#xA;                .focusFirst(\.todos)&#xA;                .child&#xA;                .popToRoot()&#xA;                .route(to: \.todo, todo.id)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;AuthenticatedCoordinator&lt;/code&gt; referenced by the &lt;code&gt;authenticatedRouter&lt;/code&gt; is a &lt;code&gt;TabCoordinatable&lt;/code&gt;, so the function will:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;focusFirst&lt;/code&gt;: return the first tab represented by the route &lt;code&gt;todos&lt;/code&gt; and make it the active tab, unless it already is the active one.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;child&lt;/code&gt;: will return it&#39;s child, the &lt;code&gt;Todos&lt;/code&gt;-tab is a &lt;code&gt;NavigationViewCoordinator&lt;/code&gt; and the child is the &lt;code&gt;NavigationCoordinatable&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;popToRoot&lt;/code&gt;: will pop away any children that may or may not have been present.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;route&lt;/code&gt;: will route to the route &lt;code&gt;Todo&lt;/code&gt; with the specified id.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since Stinsen uses KeyPaths to represent the routes, the functions are type-safe and invalid chains cannot be created. This means: if you have a route in &lt;em&gt;A&lt;/em&gt; to &lt;em&gt;B&lt;/em&gt; and in &lt;em&gt;B&lt;/em&gt; to &lt;em&gt;C&lt;/em&gt;, the app will not compile if you try to route from &lt;em&gt;A&lt;/em&gt; to &lt;em&gt;C&lt;/em&gt; without routing to &lt;em&gt;B&lt;/em&gt; first. Also, you cannot perform actions such as &lt;code&gt;popToRoot()&lt;/code&gt; on a &lt;code&gt;TabCoordinatable&lt;/code&gt; and so on.&lt;/p&gt; &#xA;&lt;h2&gt;Deep Linking&lt;/h2&gt; &#xA;&lt;p&gt;Using the returned values, you can easily deeplink within the app:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;final class MainCoordinator: NavigationCoordinatable {&#xA;    @ViewBuilder func customize(_ view: AnyView) -&amp;gt; some View {&#xA;        view.onOpenURL { url in&#xA;            if let coordinator = self.hasRoot(\.authenticated) {&#xA;                do {&#xA;                    // Create a DeepLink-enum&#xA;                    let deepLink = try DeepLink(url: url, todosStore: coordinator.todosStore)&#xA;                    &#xA;                    switch deepLink {&#xA;                    case .todo(let id):&#xA;                        coordinator&#xA;                            .focusFirst(\.todos)&#xA;                            .child&#xA;                            .route(to: \.todo, id)&#xA;                    }&#xA;                } catch {&#xA;                    print(error.localizedDescription)&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Creating your own Coordinatable&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Stinsen&lt;/em&gt; comes with a couple of &lt;em&gt;Coordinatables&lt;/em&gt; for standard SwiftUI views. If you for instance want to use it for a Hamburger-menu, you need to create your own. Check the source-code to get some inspiration.&lt;/p&gt; &#xA;&lt;h1&gt;Installation üíæ&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;Stinsen&lt;/em&gt; supports two ways of installation, Cocoapods and SPM.&lt;/p&gt; &#xA;&lt;h2&gt;SPM&lt;/h2&gt; &#xA;&lt;p&gt;Open Xcode and your project, click &lt;code&gt;File / Swift Packages / Add package dependency...&lt;/code&gt; . In the textfield &#34;&lt;em&gt;Enter package repository URL&lt;/em&gt;&#34;, write &lt;code&gt;https://github.com/rundfunk47/stinsen&lt;/code&gt; and press &lt;em&gt;Next&lt;/em&gt; twice&lt;/p&gt; &#xA;&lt;h2&gt;Cocoapods&lt;/h2&gt; &#xA;&lt;p&gt;Create a &lt;code&gt;Podfile&lt;/code&gt; in your app&#39;s root directory. Add&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Podfile&#xA;use_frameworks!&#xA;&#xA;target &#39;YOUR_TARGET_NAME&#39; do&#xA;    pod &#39;Stinsen&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Known issues and bugs üêõ&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Stinsen&lt;/em&gt; does not support &lt;code&gt;DoubleColumnNavigationViewStyle&lt;/code&gt;. The reason for this is that it does not work as expected due to issues with &lt;code&gt;isActive&lt;/code&gt; in SwiftUI. &lt;em&gt;Workaround:&lt;/em&gt; Use UIViewRepresentable or create your own implementation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Stinsen&lt;/em&gt; works pretty bad in various older versions of iOS 13 due to, well, iOS 13 not really being that good at SwiftUI. Rather than trying to set a minimum version that &lt;em&gt;Stinsen&lt;/em&gt; supports, you&#39;re on your own if you&#39;re supporting iOS 13 to figure out whether or not the features you use actually work. Generally, version 13.4 and above seem to work alright.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Who are responsible? üôãüèø‚Äç‚ôÇÔ∏è&lt;/h1&gt; &#xA;&lt;p&gt;At Byva we strive to create a 100% SwiftUI application, so it is natural that we needed to create a coordinator framework that satisfied this and other needs we have. The framework is used in production and manages ~50 flows and ~100 screens. The framework is maintained by &lt;a href=&#34;https://github.com/rundfunk47/&#34;&gt;@rundfunk47&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Why the name &#34;Stinsen&#34;? üöÇ&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;Stins&lt;/em&gt; is short in Swedish for &#34;Station Master&#34;, and &lt;em&gt;Stinsen&lt;/em&gt; is the definite article, &#34;The Station Master&#34;. Colloquially the term was mostly used to refer to the Train Dispatcher, who is responsible for routing the trains. The logo is based on a wooden statue of a &lt;em&gt;stins&lt;/em&gt; that is located near the train station in Link√∂ping, Sweden.&lt;/p&gt; &#xA;&lt;h1&gt;Updating from Stinsen v1 üöÄ&lt;/h1&gt; &#xA;&lt;p&gt;The biggest change in Stinsen v2 is that it is more type-safe than Stinsen v1, which allows for easier chaining and deep-linking, among other things.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The Route-enum has been replaced with property wrappers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AnyCoordinatable&lt;/code&gt; has been replaced with a protocol. It does not perform the same duties as the old &lt;code&gt;AnyCoordinatable&lt;/code&gt; and does not fit in with the more type-safe routing of version 2, so remove it from your project.&lt;/li&gt; &#xA; &lt;li&gt;Enums are not used for routes, now &lt;em&gt;Stinsen&lt;/em&gt; uses keypaths. So instead of &lt;code&gt;route(to: .a)&lt;/code&gt; we use &lt;code&gt;route(to: \.a)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;CoordinatorView has been removed, use &lt;code&gt;.view()&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Routers are specialized using the coordinator instead of the route.&lt;/li&gt; &#xA; &lt;li&gt;Minor changes to functions and variable names.&lt;/li&gt; &#xA; &lt;li&gt;Coordinators need to be marked as final.&lt;/li&gt; &#xA; &lt;li&gt;ViewCoordinatable has been removed and folded into NavigationCoordinatable. Use multiple &lt;code&gt;@Root&lt;/code&gt;s and switch between them using &lt;code&gt;.root()&lt;/code&gt; to get the same functionality.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License üìÉ&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;Stinsen&lt;/em&gt; is released under an MIT license. See LICENCE for more information.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>exyte/SVGView</title>
    <updated>2024-08-06T01:34:12Z</updated>
    <id>tag:github.com,2024-08-06:/exyte/SVGView</id>
    <link href="https://github.com/exyte/SVGView" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SVG parser and renderer written in SwiftUI&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://exyte.com/&#34;&gt;&#xA;  &lt;picture&gt;&#xA;   &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://raw.githubusercontent.com/exyte/media/master/common/header-dark.png&#34;&gt;&#xA;   &lt;img src=&#34;https://raw.githubusercontent.com/exyte/media/master/common/header-light.png&#34;&gt;&#xA;  &lt;/picture&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://exyte.com/&#34;&gt;&#xA;  &lt;picture&gt;&#xA;   &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://raw.githubusercontent.com/exyte/media/master/common/our-site-dark.png&#34; width=&#34;80&#34; height=&#34;16&#34;&gt;&#xA;   &lt;img src=&#34;https://raw.githubusercontent.com/exyte/media/master/common/our-site-light.png&#34; width=&#34;80&#34; height=&#34;16&#34;&gt;&#xA;  &lt;/picture&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#34;https://twitter.com/exyteHQ&#34;&gt;&#xA;  &lt;picture&gt;&#xA;   &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://raw.githubusercontent.com/exyte/media/master/common/twitter-dark.png&#34; width=&#34;74&#34; height=&#34;16&#34;&gt;&#xA;   &lt;img src=&#34;https://raw.githubusercontent.com/exyte/media/master/common/twitter-light.png&#34; width=&#34;74&#34; height=&#34;16&#34;&gt; &#xA;  &lt;/picture&gt;&lt;/a&gt; &lt;a href=&#34;https://exyte.com/contacts&#34;&gt;&#xA;  &lt;picture&gt;&#xA;   &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://raw.githubusercontent.com/exyte/media/master/common/get-in-touch-dark.png&#34; width=&#34;128&#34; height=&#34;24&#34; align=&#34;right&#34;&gt;&#xA;   &lt;img src=&#34;https://raw.githubusercontent.com/exyte/media/master/common/get-in-touch-light.png&#34; width=&#34;128&#34; height=&#34;24&#34; align=&#34;right&#34;&gt;&#xA;  &lt;/picture&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;/p&gt;&#xA;&lt;h1 align=&#34;left&#34;&gt;SVGView&lt;/h1&gt;&#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;/p&gt;&#xA;&lt;h4&gt;SVG parser written in SwiftUI&lt;/h4&gt;&#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://swiftpackageindex.com/exyte/SVGView&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fexyte%2FSVGView%2Fbadge%3Ftype%3Dswift-versions&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/exyte/SVGView&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fexyte%2FSVGView%2Fbadge%3Ftype%3Dplatforms&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/exyte/SVGView&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/SwiftPM-Compatible-brightgreen.svg?sanitize=true&#34; alt=&#34;SPM Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/SVGView&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/cocoapods-Compatible-brightgreen.svg?sanitize=true&#34; alt=&#34;Cocoapods Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-brightgreen.svg?style=flat&#34; alt=&#34;Carthage Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-black.svg?sanitize=true&#34; alt=&#34;License: MIT&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Overview&lt;/h1&gt; &#xA;&lt;p&gt;The goal of this project is to bring the full power of SVG to Apple platforms. Our framework can parse SVG files and represent their content in SwiftUI. It provides you with the ability to not only render SVG files, but also add interactivity to them, handle user input and use SwiftUI to put your art into motion.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;Get started with &lt;code&gt;SVGView&lt;/code&gt; in a few lines of code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct ContentView: View {&#xA;    var body: some View {&#xA;        SVGView(contentsOf: Bundle.main.url(forResource: &#34;example&#34;, withExtension: &#34;svg&#34;)!)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Customization&lt;/h2&gt; &#xA;&lt;p&gt;You can change various parameters for the nodes like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let circle = SVGCircle(cx: 30, cy: 30, r: 30)&#xA;circle.fill = SVGColor.black&#xA;circle.stroke = SVGStroke(fill: SVGColor(hex: &#34;ABCDEF&#34;), width: 2)&#xA;circle.onTapGesture {&#xA;    print(&#34;tap&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Interact with vector elements&lt;/h2&gt; &#xA;&lt;p&gt;You may locate the desired part of your SVG file using standard identifiers to add gestures and change its properties in runtime:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct ContentView: View {&#xA;    var body: some View {&#xA;        let view = SVGView(contentsOf: Bundle.main.url(forResource: &#34;example&#34;, withExtension: &#34;svg&#34;)!)&#xA;        if let part = view.getNode(byId: &#34;part&#34;) {&#xA;            part.onTapGesture {&#xA;                part.opacity = 0.2&#xA;            }&#xA;        }&#xA;        return view&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Animation&lt;/h2&gt; &#xA;&lt;p&gt;You can use standard SwiftUI tools to animate your image:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;if let part = view.getNode(byId: &#34;part&#34;) {&#xA;    part.onTapGesture {&#xA;        withAnimation {&#xA;            part.opacity = 0.2&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Complex effects&lt;/h2&gt; &#xA;&lt;p&gt;SVGView makes it easy to add custom effects to your app. For example, make this &lt;a href=&#34;https://www.iconfinder.com/icons/1337497/&#34;&gt;pikachu&lt;/a&gt; track finger movement:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;var body: some View {&#xA;    let view = SVGView(contentsOf: Bundle.main.url(forResource: &#34;pikachu&#34;, withExtension: &#34;svg&#34;)!)&#xA;    let delta = CGAffineTransform(translationX: getEyeX(), y: 0)&#xA;    view.getNode(byId: &#34;eye1&#34;)?.transform = delta&#xA;    view.getNode(byId: &#34;eye2&#34;)?.transform = delta&#xA;&#xA;    return view.gesture(DragGesture().onChanged { g in&#xA;        self.x = g.location.x&#xA;    })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://i.imgur.com/Ij0Xn4A.gif&#34; width=&#34;300&#34; height=&#34;300&#34;&gt; &#xA;&lt;h1&gt;SVG Tests Coverage&lt;/h1&gt; &#xA;&lt;p&gt;Our mission is to provide 100% support of all SVG standards: 1.1 (Second Edition), Tiny 1.2 and 2.0. However, this project is at its very beginning, so you can follow our progress on &lt;a href=&#34;https://raw.githubusercontent.com/exyte/SVGView/main/w3c-coverage.md&#34;&gt;this page&lt;/a&gt;. You can also check out &lt;a href=&#34;https://github.com/exyte/SVGViewTests&#34;&gt;SVGViewTests project&lt;/a&gt; to see how well this framework handles every single SVG test case.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;h2&gt;Swift Package Manager&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/exyte/SVGView.git&#34;)&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;CocoaPods&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;SVGView&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Carthage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ogdl&#34;&gt;github &#34;Exyte/SVGView&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Requirements&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iOS 14+ / watchOS 7+ / macOS 11+&lt;/li&gt; &#xA; &lt;li&gt;Xcode 12+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Our other open source SwiftUI libraries&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/exyte/PopupView&#34;&gt;PopupView&lt;/a&gt; - Toasts and popups library&lt;br&gt; &lt;a href=&#34;https://github.com/exyte/Grid&#34;&gt;Grid&lt;/a&gt; - The most powerful Grid container&lt;br&gt; &lt;a href=&#34;https://github.com/exyte/ScalingHeaderScrollView&#34;&gt;ScalingHeaderScrollView&lt;/a&gt; - A scroll view with a sticky header which shrinks as you scroll&lt;br&gt; &lt;a href=&#34;https://github.com/exyte/AnimatedTabBar&#34;&gt;AnimatedTabBar&lt;/a&gt; - A tabbar with a number of preset animations&lt;br&gt; &lt;a href=&#34;https://github.com/exyte/mediapicker&#34;&gt;MediaPicker&lt;/a&gt; - Customizable media picker&lt;br&gt; &lt;a href=&#34;https://github.com/exyte/chat&#34;&gt;Chat&lt;/a&gt; - Chat UI framework with fully customizable message cells, input view, and a built-in media picker&lt;br&gt; &lt;a href=&#34;https://github.com/exyte/OpenAI&#34;&gt;OpenAI&lt;/a&gt; Wrapper lib for &lt;a href=&#34;https://platform.openai.com/docs/api-reference/introduction&#34;&gt;OpenAI REST API&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/exyte/AnimatedGradient&#34;&gt;AnimatedGradient&lt;/a&gt; - Animated linear gradient&lt;br&gt; &lt;a href=&#34;https://github.com/exyte/ConcentricOnboarding&#34;&gt;ConcentricOnboarding&lt;/a&gt; - Animated onboarding flow&lt;br&gt; &lt;a href=&#34;https://github.com/exyte/FloatingButton&#34;&gt;FloatingButton&lt;/a&gt; - Floating button menu&lt;br&gt; &lt;a href=&#34;https://github.com/exyte/ActivityIndicatorView&#34;&gt;ActivityIndicatorView&lt;/a&gt; - A number of animated loading indicators&lt;br&gt; &lt;a href=&#34;https://github.com/exyte/ProgressIndicatorView&#34;&gt;ProgressIndicatorView&lt;/a&gt; - A number of animated progress indicators&lt;br&gt; &lt;a href=&#34;https://github.com/exyte/FlagAndCountryCode&#34;&gt;FlagAndCountryCode&lt;/a&gt; - Phone codes and flags for every country&lt;br&gt; &lt;a href=&#34;https://github.com/exyte/LiquidSwipe&#34;&gt;LiquidSwipe&lt;/a&gt; - Liquid navigation animation&lt;/p&gt;</summary>
  </entry>
</feed>