<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-26T01:38:18Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jflinter/Dwifft</title>
    <updated>2023-08-26T01:38:18Z</updated>
    <id>tag:github.com,2023-08-26:/jflinter/Dwifft</id>
    <link href="https://github.com/jflinter/Dwifft" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Swift Diff&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/jflinter/Dwifft&#34;&gt;&lt;img src=&#34;https://img.shields.io/travis/jflinter/Dwifft/master.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/tag/jflinter/dwifft.svg?label=Current%20Version&#34; alt=&#34;Current Version&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Dwifft!&lt;/h1&gt; &#xA;&lt;h2&gt;In 10 seconds&lt;/h2&gt; &#xA;&lt;p&gt;Dwifft is a small Swift library that tells you what the &#34;diff&#34; is between two collections, namely, the series of &#34;edit operations&#34; required to turn one into the other. It also comes with UIKit bindings, to automatically, animatedly keep a UITableView/UICollectionView in sync with a piece of data by making the necessary row/section insertion/deletion calls for you as the data changes.&lt;/p&gt; &#xA;&lt;h2&gt;Longer version&lt;/h2&gt; &#xA;&lt;p&gt;Dwifft is a Swift library that does two things. The first thing sounds interesting but perhaps only abstractly useful, and the other thing is a very concretely useful thing based off the first thing.&lt;/p&gt; &#xA;&lt;p&gt;The first thing (found in &lt;code&gt;Dwifft.swift&lt;/code&gt;) is an algorithm that calculates the diff between two collections using the &lt;a href=&#34;https://en.wikipedia.org/wiki/Longest_common_subsequence_problem&#34;&gt;Longest Common Subsequence method&lt;/a&gt;. If this kind of thing is interesting to you, there&#39;s a pretty great paper on diffing algorithms: &lt;a href=&#34;http://www.xmailserver.org/diff2.pdf&#34;&gt;http://www.xmailserver.org/diff2.pdf&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The second thing (found in &lt;code&gt;Dwifft+UIKit.swift&lt;/code&gt;) is a series of diff calculators for &lt;code&gt;UITableView&lt;/code&gt;s and &lt;code&gt;UICollectionView&lt;/code&gt;s. Let&#39;s say you have a &lt;code&gt;UITableView&lt;/code&gt; that&#39;s backed by a simple array of values (like a list of names, e.g. &lt;code&gt;[&#34;Alice&#34;, &#34;Bob&#34;, &#34;Carol&#34;]&lt;/code&gt;. If that array changes (maybe Bob leaves, and is replaced by Dave, so our list is now &lt;code&gt;[&#34;Alice, &#34;Carol&#34;, &#34;Dave&#34;]&lt;/code&gt;), we&#39;ll want to update the table. The easiest way to do this is by calling &lt;code&gt;reloadData&lt;/code&gt; on it. This has a couple of downsides: the transition isn&#39;t animated, and it&#39;ll cause your user to lose their scroll position if they&#39;ve scrolled the table. The nicer way is to use the &lt;code&gt;insertRowsAtIndexPaths:withRowAnimation&lt;/code&gt; and &lt;code&gt;deleteRowsAtIndexPaths:withRowAnimation&lt;/code&gt; methods on &lt;code&gt;UITableView&lt;/code&gt;, but this requires you to figure out which index paths have changed in your array (in our example, you&#39;d have to figure out that the row at index 1 should be removed, and a new row should be inserted at index 2 should then be added). If only we had a way to diff the previous value of our array with it&#39;s new value. Wait a minute.&lt;/p&gt; &#xA;&lt;p&gt;When you wire up a &lt;code&gt;TableViewDiffCalculator&lt;/code&gt; to your &lt;code&gt;UITableView&lt;/code&gt; (or a &lt;code&gt;CollectionViewDiffCalculator&lt;/code&gt; to your &lt;code&gt;UICollectionView&lt;/code&gt;, it&#39;ll &lt;em&gt;automatically&lt;/em&gt; calculate diffs and trigger the necessary animations on it whenever you change its &lt;code&gt;sectionedValues&lt;/code&gt; property. Neat, right? Notably, as of Dwifft 0.6, Dwifft will also figure out &lt;em&gt;section&lt;/em&gt; insertions and deletions, as well as how to efficiently insert and delete rows across different sections, which is just so massively useful if you have a multi-section table. If you&#39;re currently using a &amp;lt;0.6 version of Dwifft and want to do this, read the &lt;a href=&#34;https://github.com/jflinter/Dwifft/releases/tag/0.6&#34;&gt;0.6 release notes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Even longer version&lt;/h2&gt; &#xA;&lt;p&gt;Learn more about the history of Dwifft, and how it works, in this &lt;a href=&#34;https://vimeo.com/211194798&#34;&gt;exciting video of a talk&lt;/a&gt; recorded at the Brooklyn Swift meetup in March 2017.&lt;/p&gt; &#xA;&lt;h2&gt;Why you should use Dwifft&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Dwifft is &lt;em&gt;useful&lt;/em&gt; - it can help you build a substantially better user experience if you have table/collection views with dynamic content in your app.&lt;/li&gt; &#xA; &lt;li&gt;Dwifft is &lt;em&gt;safe&lt;/em&gt; - there is some non-trivial index math inside of this diff algorithm that is easy to screw up. Dwifft has 100% test coverage on all of its core algorithms. Additionally, all of Dwifft&#39;s core functionality is tested with &lt;a href=&#34;https://github.com/typelift/SwiftCheck&#34;&gt;SwiftCheck&lt;/a&gt;, meaning it has been shown to behave correctly under an exhausting set of inputs and edge cases.&lt;/li&gt; &#xA; &lt;li&gt;Dwifft is &lt;em&gt;fast&lt;/em&gt; - a lot of time has been spent making Dwifft considerably (many orders of magnitude) faster than a na√Øve implementation. It almost certainly won&#39;t be the bottleneck in your UI code.&lt;/li&gt; &#xA; &lt;li&gt;Dwifft is &lt;em&gt;small&lt;/em&gt; - Dwifft believes (to the extent that a software library can &#34;believe&#34; in things) in the unix philosophy of small, easily-composed tools. It&#39;s unopinionated and flexible enough to fit into most apps, and leaves a lot of control in your hands as a developer. As such, you can probably cram it into your app in less than 5 minutes. Also, because it&#39;s small, it can actually achieve nice goals like 100% test and documentation coverage.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to get started&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;First, you should take a look at the example app, to get a feel for how Dwifft is meant to be used.&lt;/li&gt; &#xA; &lt;li&gt;Next, you should just sit down and read the &lt;a href=&#34;https://www.jackflintermann.com/Dwifft&#34;&gt;entire documentation&lt;/a&gt; - it will take you &amp;lt;10 minutes, and you&#39;ll leave knowing everything there is to know about Dwifft.&lt;/li&gt; &#xA; &lt;li&gt;Then, install Dwifft via cocoapods or carthage or whatever people are using these days.&lt;/li&gt; &#xA; &lt;li&gt;Then get to Dwiffing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are welcome, with some caveats - please read the &lt;a href=&#34;https://github.com/jflinter/Dwifft/raw/master/CONTRIBUTING.md&#34;&gt;contributing guidelines&lt;/a&gt; before opening a PR to avoid wasting both our time.&lt;/p&gt; &#xA;&lt;p&gt;Ok, that&#39;s it, there&#39;s nothing more here.&lt;/p&gt;</summary>
  </entry>
</feed>