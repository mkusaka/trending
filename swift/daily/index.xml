<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-13T01:44:13Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>apple/swift-driver</title>
    <updated>2023-03-13T01:44:13Z</updated>
    <id>tag:github.com,2023-03-13:/apple/swift-driver</id>
    <link href="https://github.com/apple/swift-driver" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Swift compiler driver reimplementation in Swift&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Swift Compiler Driver&lt;/h1&gt; &#xA;&lt;p&gt;Swift&#39;s compiler driver is a program that coordinates the compilation of Swift source code into various compiled results: executables, libraries, object files, Swift modules and interfaces, etc. It is the program one invokes from the command line to build Swift code (i.e., &lt;code&gt;swift&lt;/code&gt; or &lt;code&gt;swiftc&lt;/code&gt;) and is often invoked on the developer&#39;s behalf by a build system such as the &lt;a href=&#34;https://github.com/apple/swift-package-manager&#34;&gt;Swift Package Manager (SwiftPM)&lt;/a&gt; or Xcode&#39;s build system.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;swift-driver&lt;/code&gt; project is a new implementation of the Swift compiler driver that is intended to replace the &lt;a href=&#34;https://github.com/apple/swift/tree/main/lib/Driver&#34;&gt;existing driver&lt;/a&gt; with a more extensible, maintainable, and robust code base. The specific goals of this project include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A maintainable, robust, and flexible Swift code base&lt;/li&gt; &#xA; &lt;li&gt;Library-based architecture that allows better integration with build tools&lt;/li&gt; &#xA; &lt;li&gt;Leverage existing Swift build technologies (&lt;a href=&#34;https://github.com/apple/swift-package-manager&#34;&gt;SwiftPM&lt;/a&gt;, &lt;a href=&#34;https://github.com/apple/swift-llbuild&#34;&gt;llbuild&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;A platform for experimenting with more efficient build models for Swift, including compile servers and unifying build graphs across different driver invocations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Currently, swift-driver is only compatible with trunk development snapshots from &lt;a href=&#34;https://swift.org/download/#snapshots&#34;&gt;swift.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The preferred way to build &lt;code&gt;swift-driver&lt;/code&gt; is to use the Swift package manager.&lt;/p&gt; &#xA;&lt;p&gt;On most platforms you can build using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ swift build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, on Windows, some additional work must be done by the developer.&lt;/p&gt; &#xA;&lt;p&gt;Due to the default version of swift-tools-support-core that &lt;code&gt;Package.resolved&lt;/code&gt; references, we must first update the package dependencies.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;swift package update&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, we can build the package using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;swift build -Xcc -I -Xcc &#34;%SystemDrive%\Library\sqlite-3.38.0\usr\include&#34; -Xlinker -L -Xlinker &#34;%SystemDrive%\Library\sqlite-3.38.0\usr\lib&#34; -Xlinker &#34;%SDKROOT%\usr\lib\swift\windows\x86_64\swiftCore.lib&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because SQLite3 is a system library dependency, and there is no singular header and library search path, the developer must specify that. The path to SQLite3 may need to be adjusted if the library is not located at the specified location. Additionally, because Swift Package Manager does not differentiate between C/C++ and Swift targets and uses the Swift driver as the linker driver we must link in the Swift runtime into all targets manually.&lt;/p&gt; &#xA;&lt;p&gt;To use &lt;code&gt;swift-driver&lt;/code&gt; in place of the existing Swift driver, create a symbolic link from &lt;code&gt;swift&lt;/code&gt; and &lt;code&gt;swiftc&lt;/code&gt; to &lt;code&gt;swift-driver&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ln -s /path/to/built/swift-driver $SOME_PATH/swift&#xA;ln -s /path/to/built/swift-driver $SOME_PATH/swiftc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Swift packages can be built with the new Swift driver by overriding &lt;code&gt;SWIFT_EXEC&lt;/code&gt; to refer to the &lt;code&gt;swiftc&lt;/code&gt; symbolic link created above and &lt;code&gt;SWIFT_DRIVER_SWIFT_FRONTEND_EXEC&lt;/code&gt; to refer to the original &lt;code&gt;swift-frontend&lt;/code&gt;, e.g.,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SWIFT_EXEC=$SOME_PATH/swiftc SWIFT_DRIVER_SWIFT_FRONTEND_EXEC=$TOOLCHAIN_PATH/bin/swift-frontend swift build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, one can use the new Swift driver within Xcode by adding a custom build setting (usually at the project level) named &lt;code&gt;SWIFT_EXEC&lt;/code&gt; that refers to &lt;code&gt;$SOME_PATH/swiftc&lt;/code&gt; and adding &lt;code&gt;-driver-use-frontend-path $TOOLCHAIN_DIR/usr/bin/swiftc&lt;/code&gt; to &lt;code&gt;Other Swift Flags&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building with CMake&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;swift-driver&lt;/code&gt; can also be built with CMake, which is suggested for environments where the Swift Package Manager is not yet available. Doing so requires several dependencies to be built first, all with CMake:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;(Non-Apple platforms only) &lt;a href=&#34;https://github.com/apple/swift-corelibs-foundation&#34;&gt;swift-corelibs-foundation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apple/swift-llbuild&#34;&gt;llbuild&lt;/a&gt; configure CMake with &lt;code&gt;-DLLBUILD_SUPPORT_BINDINGS=&#34;Swift&#34;&lt;/code&gt; and &lt;code&gt;-DCMAKE_OSX_ARCHITECTURES=x86_64&lt;/code&gt; (If building on Intel) when building &lt;pre&gt;&lt;code&gt;cmake -B &amp;lt;llbuild-build-dir&amp;gt; -G Ninja &amp;lt;llbuild-source-dir&amp;gt; -DLLBUILD_SUPPORT_BINDINGS=&#34;Swift&#34; -DCMAKE_OSX_ARCHITECTURES=x86_64&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apple/swift-system&#34;&gt;swift-system&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apple/swift-argument-parser&#34;&gt;swift-argument-parser&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jpsim/Yams&#34;&gt;Yams&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Once those dependencies have built, build &lt;code&gt;swift-driver&lt;/code&gt; itself:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -B &amp;lt;swift-driver-build-dir&amp;gt; -G Ninja &amp;lt;swift-driver-source-dir&amp;gt; -DTSC_DIR=&amp;lt;swift-tools-support-core-build-dir&amp;gt;/cmake/modules -DLLBuild_DIR=&amp;lt;llbuild-build-dir&amp;gt;/cmake/modules -DYams_DIR=&amp;lt;yamls-build-dir&amp;gt;/cmake/modules -DArgumentParser_DIR=&amp;lt;swift-argument-parser-build-dir&amp;gt;&#xA;cmake --build &amp;lt;swift-driver-build-dir&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Developing &lt;code&gt;swift-driver&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;The new Swift driver is a work in progress, and there are numerous places for anyone with an interest to contribute! This section covers testing, miscellaneous development tips and tricks, and a rough development plan showing what work still needs to be done.&lt;/p&gt; &#xA;&lt;h3&gt;Driver Documentation&lt;/h3&gt; &#xA;&lt;p&gt;For a conceptual overview of the driver, see &lt;a href=&#34;https://github.com/apple/swift/raw/main/docs/Driver.md&#34;&gt;The Swift Driver, Compilation Model, and Command-Line Experience&lt;/a&gt;. To learn more about the internals, see &lt;a href=&#34;https://github.com/apple/swift/raw/main/docs/DriverInternals.md&#34;&gt;Driver Design &amp;amp; Internals&lt;/a&gt; and &lt;a href=&#34;https://github.com/apple/swift/raw/main/docs/DriverParseableOutput.md&#34;&gt;Parseable Driver Output&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Testing&lt;/h3&gt; &#xA;&lt;p&gt;Test using command-line SwiftPM or Xcode.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ swift test --parallel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Integration tests are costly to run and are disabled by default. Enable them using &lt;code&gt;SWIFT_DRIVER_ENABLE_INTEGRATION_TESTS&lt;/code&gt; environment variable. In Xcode, you can set this variable in the scheme&#39;s test action.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ SWIFT_DRIVER_ENABLE_INTEGRATION_TESTS=1 swift test --parallel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some integration tests run the lit test suites in a Swift working copy. To enable these, clone Swift and its dependencies and build them with build-script, then set both &lt;code&gt;SWIFT_DRIVER_ENABLE_INTEGRATION_TESTS&lt;/code&gt; and &lt;code&gt;SWIFT_DRIVER_LIT_DIR&lt;/code&gt;, either in your Xcode scheme or on the command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ SWIFT_DRIVER_ENABLE_INTEGRATION_TESTS=1 \&#xA;  SWIFT_DRIVER_LIT_DIR=/path/to/build/Ninja-ReleaseAssert/swift-.../test-... \&#xA;  swift test -c release --parallel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Testing against &lt;code&gt;swift&lt;/code&gt; compiler trunk&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;swift-driver&lt;/code&gt; Continuous Integration runs against the most recent Trunk Development snapshot published at &lt;a href=&#34;https://swift.org/download/&#34;&gt;swift.org/download&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When developing patches that have complex interactions with the underlying &lt;code&gt;swift&lt;/code&gt; compiler frontend, it may be prudent to ensure that &lt;code&gt;swift-driver&lt;/code&gt; tests also pass against the current tip-of-trunk &lt;code&gt;swift&lt;/code&gt;. To do so, create an empty pull request against &lt;a href=&#34;https://github.com/apple/swift&#34;&gt;github.com/apple/swift&lt;/a&gt; and perform cross-repository testing against your &lt;code&gt;swift-driver&lt;/code&gt; pull request #, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Using:&#xA;apple/swift-driver#208&#xA;@swift-ci smoke test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;@swift-ci cross-repository testing facilities are described &lt;a href=&#34;https://github.com/apple/swift/raw/main/docs/ContinuousIntegration.md#cross-repository-testing&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Testing in Xcode with custom toolchain&lt;/h3&gt; &#xA;&lt;p&gt;After the toolchain is installed, Xcode needs to be told to use it. This can mean two things, building the driver with the toolchain and telling the driver to use the toolchain when running.&lt;/p&gt; &#xA;&lt;p&gt;Building with the toolchain is easy, set the toolchain in Xcode: Menu Bar &amp;gt; Xcode &amp;gt; Toolchains &amp;gt; select your toolchain&lt;/p&gt; &#xA;&lt;p&gt;Running the driver requires setting the TOOLCHAINS environment variable. This tells xcrun which toolchain to use (on darwin xcrun is used to find tools). This variable is the name of the toolchain and not the path (ex: &lt;code&gt;Swift Development Snapshot&lt;/code&gt;). Important note: xcrun lookup is lower priority than the SWIFT_EXEC_*_EXEC family of environment variables, the tools directory, and any tools in the same directory as the driver (This includes a driver installed in a toolchain). Even though TOOLCHAINS is not highest priority it&#39;s a convenient way to run the xctest suite using a custom toolchain.&lt;/p&gt; &#xA;&lt;h4&gt;Preparing a Linux docker for debug&lt;/h4&gt; &#xA;&lt;p&gt;When developing on macOS without quick access to a Linux machine, using a Linux Docker is often helpful when debugging.&lt;/p&gt; &#xA;&lt;p&gt;To get a docker up and running to the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install Docker for Mac.&lt;/li&gt; &#xA; &lt;li&gt;Get the newest swift docker image &lt;code&gt;docker pull swift&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run the following command to start a docker&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ docker run -v /path/to/swift-driver:/home/swift-driver \&#xA;  --cap-add=SYS_PTRACE --security-opt seccomp=unconfined \&#xA;  --security-opt apparmor=unconfined -it swift:latest bash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install dependencies by running&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ apt-get update&#xA;$ apt-get install libsqlite3-dev&#xA;$ apt-get install libncurses-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can now go to &lt;code&gt;/home/swift-driver&lt;/code&gt; and run &lt;code&gt;swift test --parallel&lt;/code&gt; to run your tests.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Rebuilding &lt;code&gt;Options.swift&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Options.swift&lt;/code&gt;, which contains the complete set of options that can be parsed by the driver, is automatically generated from the &lt;a href=&#34;https://github.com/apple/swift/tree/main/include/swift/Option&#34;&gt;option tables in the Swift compiler&lt;/a&gt;. If you need to regenerate &lt;code&gt;Options.swift&lt;/code&gt;, you will need to &lt;a href=&#34;https://github.com/apple/swift#building-swift&#34;&gt;build the Swift compiler&lt;/a&gt; and then build &lt;code&gt;makeOptions&lt;/code&gt; program with a &lt;code&gt;-I&lt;/code&gt; that allows the generated &lt;code&gt;Options.inc&lt;/code&gt; to be found, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ swift build -Xcc -I/path/to/build/Ninja-ReleaseAssert/swift-.../include --product makeOptions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, run &lt;code&gt;makeOptions&lt;/code&gt; and redirect the output to overwrite &lt;code&gt;Options.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ .build/path/to/makeOptions &amp;gt; Sources/SwiftOptions/Options.swift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Development Plan&lt;/h3&gt; &#xA;&lt;p&gt;The goal of the new Swift driver is to provide a drop-in replacement for the existing driver, which means that there is a fixed initial feature set to implement before the existing Swift driver can be deprecated and removed. The development plan below covers that feature set, as well as describing a number of tasks that can improve the Swift driver---from code cleanups, to improving testing, implementing missing features, and integrating with existing systems.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Code and documentation quality &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Search for &lt;code&gt;FIXME:&lt;/code&gt; or &lt;code&gt;TODO:&lt;/code&gt;: there are lots of little things to improve!&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Improve documentation of how to incorporate the driver into your own builds&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add useful descriptions to any &lt;code&gt;Error&lt;/code&gt; thrown within the library&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Option parsing &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Look for complete &#34;coverage&#34; of the options in &lt;code&gt;Options.swift&lt;/code&gt;. Is every option there checked somewhere in the driver?&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Find a better way to describe aliases for options. Can they be of some other type &lt;code&gt;OptionAlias&lt;/code&gt; so we can&#39;t make the mistake of (e.g.) asking for an alias option when we&#39;re translating options?&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Diagnose unused options on the command line&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Typo correction for misspelled option names&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Find a better way than &lt;code&gt;makeOptions.cpp&lt;/code&gt; to translate the command-line options from &lt;a href=&#34;https://github.com/apple/swift/tree/main/include/swift/Option&#34;&gt;Swift&#39;s repository&lt;/a&gt; into &lt;code&gt;Options.swift&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Platform support &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Teach the &lt;code&gt;DarwinToolchain&lt;/code&gt; to also handle iOS, tvOS, watchOS&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Fill out the &lt;code&gt;GenericUnixToolchain&lt;/code&gt; toolchain to get it working&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Implement a &lt;code&gt;WindowsToolchain&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Implement proper tokenization for response files&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Compilation modes &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Batch mode&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Whole-module-optimization mode&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; REPL mode&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Immediate mode&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Features &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Precompiled bridging headers&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support embedding of bitcode&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Incremental compilation&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Parseable output, as used by SwiftPM&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Response files&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Input and primary input file lists&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Complete &lt;code&gt;OutputFileMap&lt;/code&gt; implementation to handle all file types uniformly&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Testing &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Build stuff with SwiftPM or Xcode or your favorite build system, using &lt;code&gt;swift-driver&lt;/code&gt;. Were the results identical? What changed?&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Shim in &lt;code&gt;swift-driver&lt;/code&gt; so it can run the Swift repository&#39;s &lt;a href=&#34;https://github.com/apple/swift/tree/main/test/Driver&#34;&gt;driver test suite&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Investigate differences in the test results for the Swift repository&#39;s driver test suite (above) between the existing and new driver.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Port interesting tests from the Swift repository&#39;s &lt;a href=&#34;https://github.com/apple/swift/tree/main/test/Driver&#34;&gt;driver test suite&lt;/a&gt; over to XCTest&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Fuzz the command-line options to try to crash the Swift driver itself&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Integration &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Teach the Swift compiler&#39;s &lt;a href=&#34;https://github.com/apple/swift/raw/main/utils/build-script&#34;&gt;&lt;code&gt;build-script&lt;/code&gt;&lt;/a&gt; to build &lt;code&gt;swift-driver&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Building on the above, teach the Swift compiler&#39;s &lt;a href=&#34;https://github.com/apple/swift/raw/main/utils/build-toolchain&#34;&gt;&lt;code&gt;build-toolchain&lt;/code&gt;&lt;/a&gt; to install &lt;code&gt;swift-driver&lt;/code&gt; as the primary driver so we can test full toolchains with the new driver&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Build all Swift interfaces from an SDK&lt;/h3&gt; &#xA;&lt;p&gt;Based on libSwiftDriver, &lt;code&gt;swift-build-sdk-interfaces&lt;/code&gt; is a tool to batch build all Swift textual interfaces (&lt;code&gt;.swiftinterface&lt;/code&gt;) from an SDK into binary modules (&lt;code&gt;.swiftmodule&lt;/code&gt;). As an example, the following command finds all Swift textual interface from the MacOSX SDK, builds all of them into binary modules, and outputs module-specific error logs into the given directory.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt; $SDKROOT=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk SWIFT_EXEC=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc swift-build-sdk-interfaces -o /tmp/outputs -v -log-path /tmp/logs&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;SDKROOT&lt;/em&gt;: an env var to specify the SDK to work on&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;SWIFT_EXEC&lt;/em&gt;: teach &lt;code&gt;swift-build-sdk-interfaces&lt;/code&gt; about where to find the Swift compiler to use&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;-O&lt;/em&gt;: the output directory for all binary modules built from textual interfaces&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;-log-path&lt;/em&gt;: where to dump log files when fatal error happens&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>buresdv/Cork</title>
    <updated>2023-03-13T01:44:13Z</updated>
    <id>tag:github.com,2023-03-13:/buresdv/Cork</id>
    <link href="https://github.com/buresdv/Cork" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fast GUI for Homebrew written in SwiftUI&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cork&lt;/h1&gt; &#xA;&lt;p&gt;A fast GUI for Homebrew written in SwiftUI&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://elk.zone/mstdn.social/@davidbures&#34;&gt;&lt;img src=&#34;https://img.shields.io/mastodon/follow/108939255808776594?domain=https%3A%2F%2Fmstdn.social&amp;amp;label=Follow%20me%20for%20updates&amp;amp;style=flat&#34; alt=&#34;Mastodon Link&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/kUHg8uGHpG&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/1083475351260377119?label=Tak%20to%20me%20on%20Discord&amp;amp;style=flat&#34; alt=&#34;Mastodon Link&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Special Thanks&lt;/h2&gt; &#xA;&lt;p&gt;I&#39;d like to personally thank &lt;a href=&#34;https://github.com/sebj&#34;&gt;Seb Jachec&lt;/a&gt; for implementing a system for getting real-time outputs of Brew commands.&lt;/p&gt; &#xA;&lt;p&gt;Without his contribution, many of the processes that depend on real-time outputs, such as installation, uninstallation and updating of packages, would be impossible.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Cork&lt;/h2&gt; &#xA;&lt;p&gt;Pre-compiled, always up-to-date versions are available from my Homebrew tap, which you get access to by donating 5€/month. You can donate through &lt;a href=&#34;https://ko-fi.com/buresdv&#34;&gt;Ko-Fi&lt;/a&gt; or &lt;a href=&#34;https://github.com/sponsors/buresdv&#34;&gt;GitHub Sponsors&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, as Cork is open source, you can always compile it from source for free. See below for instructions.&lt;/p&gt; &#xA;&lt;h2&gt;Screenshots&lt;/h2&gt; &#xA;&lt;h3&gt;Main Window&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/N8HQtcL.jpg&#34; alt=&#34;Start Page&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Package Info&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/L7LyzmS.jpg&#34; alt=&#34;Package Info&#34;&gt; &lt;img src=&#34;https://i.imgur.com/ZHaEcOA.jpg&#34; alt=&#34;Package Info&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Install Package&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/CtqSCUu.jpg&#34; alt=&#34;Install Package&#34;&gt; &lt;img src=&#34;https://i.imgur.com/Agc7zxX.jpg&#34; alt=&#34;Install Package&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Tap Taps&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Dya1SkM.jpg&#34; alt=&#34;Tap Taps&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Brew Maintenance&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/LGkDErZ.jpg&#34; alt=&#34;Brew Maintenance&#34;&gt; &lt;img src=&#34;https://i.imgur.com/GbTerQX.jpg&#34; alt=&#34;Brew Maintenance Results&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Compiling Cork&lt;/h2&gt; &#xA;&lt;p&gt;Compiling Cork is simple, as it does not have many dependencies.&lt;/p&gt; &#xA;&lt;p&gt;Prerequisites:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;macOS Ventura or newer&lt;/li&gt; &#xA; &lt;li&gt;Xcode 14.2 or newer&lt;/li&gt; &#xA; &lt;li&gt;Git&lt;/li&gt; &#xA; &lt;li&gt;An Apple Developer accout. &lt;strong&gt;You don&#39;t need a paid one! Even a free one works perfectly&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Instructions:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Before you begin&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;Enroll your account in the developer program at &lt;a href=&#34;https://developer.apple.com/&#34;&gt;https://developer.apple.com/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install Xcode&lt;/li&gt; &#xA; &lt;li&gt;Add your Developer account to Xcode. To do so, in the Menu bar, click &lt;code&gt;Xcode → Settings&lt;/code&gt;, and in the window that opens, click &lt;code&gt;Accounts&lt;/code&gt;. You can add your account there&lt;/li&gt; &#xA; &lt;li&gt;After you add your account, it will appear in the list of Apple IDs on the left od the screen. Select your account there&lt;/li&gt; &#xA; &lt;li&gt;At the bottom of the screen, click &lt;code&gt;Manage Certificates...&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;On the bottom left, click the &lt;strong&gt;+&lt;/strong&gt; icon and select &lt;code&gt;Apple Development&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;When a new item appears in the list called &lt;code&gt;Apple Development Certificates&lt;/code&gt;, you can press &lt;code&gt;Done&lt;/code&gt; to close the account manager&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Compiling Cork&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone this repo using &lt;code&gt;git clone https://github.com/buresdv/Cork.git &amp;amp;&amp;amp; cd Cork &amp;amp;&amp;amp; open .&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Double-click &lt;code&gt;Cork.xcodeproj&lt;/code&gt;. Xcode should open the project&lt;/li&gt; &#xA; &lt;li&gt;Wait until all the dependencies are resolved. It should take a couple minutes at most&lt;/li&gt; &#xA; &lt;li&gt;In the Menu Bar, click &lt;code&gt;Product → Archive&lt;/code&gt; and wait for the building to finish&lt;/li&gt; &#xA; &lt;li&gt;A new window will open. From the list of Cork rows, select the topmost one, and click &lt;code&gt;Distribute App&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Click &lt;code&gt;Copy App&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Open the resulting folder. You&#39;ll see an app called Cork. Drag Cork to your &lt;code&gt;/Applications/&lt;/code&gt; folder, and you&#39;re done!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Cork is licensed under &lt;a href=&#34;https://commonsclause.com&#34;&gt;Commons Clause&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This means that Cork open-source and you can do whatever you want with Cork&#39;s source, like modifying it, contributing to it etc., but you can&#39;t sell Cork or modified versions of it.&lt;/p&gt;</summary>
  </entry>
</feed>