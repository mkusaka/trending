<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-16T01:45:46Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pointfreeco/swift-case-paths</title>
    <updated>2023-11-16T01:45:46Z</updated>
    <id>tag:github.com,2023-11-16:/pointfreeco/swift-case-paths</id>
    <link href="https://github.com/pointfreeco/swift-case-paths" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸ§° Case paths extends the key path hierarchy to enum cases.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ðŸ§° CasePaths&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://actions-badge.atrox.dev/pointfreeco/swift-case-paths/goto&#34;&gt;&lt;img src=&#34;https://github.com/pointfreeco/swift-case-paths/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://pointfree.co/slack-invite&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/slack-chat-informational.svg?label=Slack&amp;amp;logo=slack&#34; alt=&#34;Slack&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-case-paths&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-case-paths%2Fbadge%3Ftype%3Dswift-versions&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-case-paths&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-case-paths%2Fbadge%3Ftype%3Dplatforms&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Case paths extends the key path hierarchy to enum cases.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;Swift endows every struct and class property with a &lt;a href=&#34;https://developer.apple.com/documentation/swift/swift_standard_library/key-path_expressions&#34;&gt;key path&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct User {&#xA;  let id: Int&#xA;  var name: String&#xA;}&#xA;&#xA;\User.id    // KeyPath&amp;lt;User, Int&amp;gt;&#xA;\User.name  // WritableKeyPath&amp;lt;User, String&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is compiler-generated code that can be used to abstractly zoom in on part of a structure, inspect and even change it, all while propagating those changes to the structure&#39;s whole. They are the silent partner of many modern Swift APIs powered by &lt;a href=&#34;https://github.com/apple/swift-evolution/raw/master/proposals/0252-keypath-dynamic-member-lookup.md&#34;&gt;dynamic member lookup&lt;/a&gt;, like SwiftUI &lt;a href=&#34;https://developer.apple.com/documentation/swiftui/bindable/subscript(dynamicmember:)&#34;&gt;bindings&lt;/a&gt;, but also make more direct appearances, like in the SwiftUI &lt;a href=&#34;https://developer.apple.com/documentation/swiftui/scene/environment(_:_:)&#34;&gt;environment&lt;/a&gt; and &lt;a href=&#34;https://developer.apple.com/documentation/swift/unsafemutablepointer/pointer(to:)-8veyb&#34;&gt;unsafe mutable pointers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, no such structure exists for enum cases.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum UserAction {&#xA;  case home(HomeAction)&#xA;  case settings(SettingsAction)&#xA;}&#xA;&#xA;\UserAction.home  // ðŸ›‘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;ðŸ›‘ key path cannot refer to static member &#39;home&#39;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;And so it&#39;s not possible to write generic code that can zoom in and modify the data of a particular case in the enum.&lt;/p&gt; &#xA;&lt;h2&gt;Using case paths in libraries&lt;/h2&gt; &#xA;&lt;p&gt;By far the most common use of case paths is as a tool inside a library that is distributed to other developers. Case paths are used in the &lt;a href=&#34;http://github.com/pointfreeco/swift-composable-architecture&#34;&gt;Composable Architecture&lt;/a&gt;, &lt;a href=&#34;http://github.com/pointfreeco/swiftui-navigation&#34;&gt;SwiftUI Navigation&lt;/a&gt;, &lt;a href=&#34;http://github.com/pointfreeco/swift-parsing&#34;&gt;Parsing&lt;/a&gt;, and many other libraries.&lt;/p&gt; &#xA;&lt;p&gt;If you maintain a library where you expect your users to model their domains with enums, then providing case path tools to them can help them break their domains into smaller units. For example, consider the &lt;code&gt;Binding&lt;/code&gt; type provided by SwiftUI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Binding&amp;lt;Value&amp;gt; {&#xA;  let get: () -&amp;gt; Value&#xA;  let set: (Value) -&amp;gt; Void&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Through the power of &lt;a href=&#34;https://github.com/apple/swift-evolution/raw/master/proposals/0252-keypath-dynamic-member-lookup.md&#34;&gt;dynamic member lookup&lt;/a&gt; we are able to support dot-chaining syntax for deriving new bindings to members of values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@dynamicMemberLookup&#xA;struct Binding&amp;lt;Value&amp;gt; {&#xA;  â€¦&#xA;  subscript&amp;lt;Member&amp;gt;(dynamicMember keyPath: WritableKeyPath&amp;lt;Value, Member&amp;gt;) -&amp;gt; Binding&amp;lt;Member&amp;gt; {&#xA;    Binding&amp;lt;Member&amp;gt;(&#xA;      get: { self.get()[keyPath: keyPath] },&#xA;      set: { &#xA;        var value = self.get()&#xA;        value[keyPath: keyPath] = $0&#xA;        self.set(value)&#xA;      }&#xA;    )&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you had a binding of a user, you could simply append &lt;code&gt;.name&lt;/code&gt; to that binding to immediately derive a binding to the user&#39;s name:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let user: Binding&amp;lt;User&amp;gt; = // ...&#xA;let name: Binding&amp;lt;String&amp;gt; = user.name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, there are no such affordances for enums:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum Destination {&#xA;  case home(HomeState)&#xA;  case settings(SettingsState)&#xA;}&#xA;let destination: Binding&amp;lt;Destination&amp;gt; = // ...&#xA;destination.home      // ðŸ›‘&#xA;destination.settings  // ðŸ›‘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is not possible to derive a binding to just the &lt;code&gt;home&lt;/code&gt; case of a destination binding by using simple dot-chaining syntax.&lt;/p&gt; &#xA;&lt;p&gt;However, if SwiftUI used this CasePaths library, then they could provide this tool quite easily. They could provide an additional &lt;code&gt;dynamicMember&lt;/code&gt; subscript that uses a &lt;code&gt;CaseKeyPath&lt;/code&gt;, which is a key path that singles out a case of an enum, and use that to derive a binding to a particular case of an enum:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import CasePaths&#xA;&#xA;extension Binding {&#xA;  public subscript&amp;lt;Case&amp;gt;(dynamicMember keyPath: CaseKeyPath&amp;lt;Value, Case&amp;gt;) -&amp;gt; Binding&amp;lt;Case&amp;gt;?&#xA;  where Value: CasePathable {&#xA;    Binding&amp;lt;Case&amp;gt;(&#xA;      unwrapping: Binding&amp;lt;Case?&amp;gt;(&#xA;        get: { self.wrappedValue[case: keyPath] },&#xA;        set: { newValue, transaction in&#xA;          guard let newValue else { return }&#xA;          self.transaction(transaction).wrappedValue[case: keyPath] = newValue&#xA;        }&#xA;      )&#xA;    )&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With that defined, one can annotate their enum with the &lt;code&gt;@CasePathable&lt;/code&gt; macro and then immediately use dot-chaining to derive a binding of a case from a binding of an enum:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@CasePathable&#xA;enum Destination {&#xA;  case home(HomeState)&#xA;  case settings(SettingsState)&#xA;}&#xA;let destination: Binding&amp;lt;Destination&amp;gt; = // ...&#xA;destination.home      // Binding&amp;lt;HomeState&amp;gt;?&#xA;destination.settings  // Binding&amp;lt;SettingsState&amp;gt;?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is an example of how libraries can provide tools for their users to embrace enums without losing out on the ergonomics of structs.&lt;/p&gt; &#xA;&lt;h2&gt;Basics of case paths&lt;/h2&gt; &#xA;&lt;p&gt;While library tooling is the biggest use case for using this library, there are some ways that you can use case paths in first-party code too. The library bridges the gap between structs and enums by introducing what we call &#34;case paths&#34;: key paths for enum cases.&lt;/p&gt; &#xA;&lt;p&gt;Case paths can be enabled for an enum using the &lt;code&gt;@CasePathable&lt;/code&gt; macro:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@CasePathable&#xA;enum UserAction {&#xA;  case home(HomeAction)&#xA;  case settings(SettingsAction)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And they can be produced from a &#34;case-pathable&#34; enum through its &lt;code&gt;Cases&lt;/code&gt; namespace:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;\UserAction.Cases.home      // CaseKeyPath&amp;lt;UserAction, HomeAction&amp;gt;&#xA;\UserAction.Cases.settings  // CaseKeyPath&amp;lt;UserAction, SettingsAction&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And like any key path, they can be abbreviated when the enum type can be inferred:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;\.home as CaseKeyPath&amp;lt;UserAction, HomeAction&amp;gt;&#xA;\.settings as CaseKeyPath&amp;lt;UserAction, SettingsAction&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Case paths vs. key paths&lt;/h3&gt; &#xA;&lt;h4&gt;Extracting, embedding, modifying, and testing values&lt;/h4&gt; &#xA;&lt;p&gt;As key paths package up the functionality of getting and setting a value on a root structure, case paths package up the functionality of optionally extracting and modifying an associated value of a root enumeration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;user[keyPath: \User.name] = &#34;Blob&#34;&#xA;user[keyPath: \.name]  // &#34;Blob&#34;&#xA;&#xA;userAction[case: \UserAction.Cases.home] = .onAppear&#xA;userAction[case: \.home]  // Optional(HomeAction.onAppear)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the case doesn&#39;t match, the extraction can fail and return &lt;code&gt;nil&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;userAction[case: \.settings]  // nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Case paths have an additional ability, which is to embed an associated value into a brand new root:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let userActionToHome = \UserAction.Cases.home&#xA;userActionToHome(.onAppear)  // UserAction.home(.onAppear)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Cases can be tested using the &lt;code&gt;is&lt;/code&gt; method on case-pathable enums:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;userAction.is(\.home)      // true&#xA;userAction.is(\.settings)  // false&#xA;&#xA;let actions: [UserAction] = [â€¦]&#xA;let homeActionsCount = actions.count(where: { $0.is(\.home) })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And their associated values can be mutated in place using the &lt;code&gt;modify&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var result = Result&amp;lt;String, Error&amp;gt;.success(&#34;Blob&#34;)&#xA;result.modify(\.success) {&#xA;  $0 += &#34;, Jr.&#34;&#xA;}&#xA;result  // Result.success(&#34;Blob, Jr.&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Composing paths&lt;/h4&gt; &#xA;&lt;p&gt;Case paths, like key paths, compose. You can dive deeper into the enumeration of an enumeration&#39;s case using familiar dot-chaining:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;\HighScore.user.name&#xA;// WritableKeyPath&amp;lt;HighScore, String&amp;gt;&#xA;&#xA;\AppAction.Cases.user.home&#xA;// CaseKeyPath&amp;lt;AppAction, HomeAction&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can append them together:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let highScoreToUser = \HighScore.user&#xA;let userToName = \User.name&#xA;let highScoreToUserName = highScoreToUser.append(path: userToName)&#xA;// WritableKeyPath&amp;lt;HighScore, String&amp;gt;&#xA;&#xA;let appActionToUser = \AppAction.Cases.user&#xA;let userActionToHome = \UserAction.Cases.home&#xA;let appActionToHome = appActionToUser.append(path: userActionToHome)&#xA;// CaseKeyPath&amp;lt;AppAction, HomeAction&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Identity paths&lt;/h4&gt; &#xA;&lt;p&gt;Case paths, also like key paths, provide an &lt;a href=&#34;https://github.com/apple/swift-evolution/raw/master/proposals/0227-identity-keypath.md&#34;&gt;identity&lt;/a&gt; path, which is useful for interacting with APIs that use key paths and case paths but you want to work with entire structure.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;\User.self              // WritableKeyPath&amp;lt;User, User&amp;gt;&#xA;\UserAction.Cases.self  // CaseKeyPath&amp;lt;UserAction, UserAction&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Property access&lt;/h4&gt; &#xA;&lt;p&gt;Since Swift 5.2, key path expressions can be passed directly to methods like &lt;code&gt;map&lt;/code&gt;. Case-pathable enums that are annotated with dynamic member lookup enable property access and key path expressions for each case.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@CasePathable&#xA;@dynamicMemberLookup&#xA;enum UserAction {&#xA;  case home(HomeAction)&#xA;  case settings(SettingsAction)&#xA;}&#xA;&#xA;let userAction: UserAction = .home(.onAppear)&#xA;userAction.home      // Optional(HomeAction.onAppear)&#xA;userAction.settings  // nil&#xA;&#xA;let userActions: [UserAction] = [.home(.onAppear), .settings(.purchaseButtonTapped)]&#xA;userActions.compactMap(\.home)  // [HomeAction.onAppear]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Dynamic case lookup&lt;/h4&gt; &#xA;&lt;p&gt;Because case key paths are bona fide key paths under the hood, they can be used in the same applications, like dynamic member lookup. For example, we can extend SwiftUI&#39;s binding type to enum cases by extending it with a subscript:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Binding {&#xA;  subscript&amp;lt;Member&amp;gt;(&#xA;    dynamicMember keyPath: CaseKeyPath&amp;lt;Value, Member&amp;gt;&#xA;  ) -&amp;gt; Binding&amp;lt;Member&amp;gt;? {&#xA;    guard let member = self.wrappedValue[case: keyPath]&#xA;    else { return nil }&#xA;    return Binding&amp;lt;Member&amp;gt;(&#xA;      get: { self.wrappedValue[case: keyPath] ?? member },&#xA;      set: { self.wrappedValue[case: keyPath] = $0 }&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;@CasePathable enum ItemStatus {&#xA;  case inStock(quantity: Int)&#xA;  case outOfStock(isOnBackOrder: Bool)&#xA;}&#xA;&#xA;struct ItemStatusView: View {&#xA;  @Binding var status: ItemStatus&#xA;&#xA;  var body: some View {&#xA;    switch self.status {&#xA;    case .inStock:&#xA;      self.$status.inStock.map { $quantity in&#xA;        Section {&#xA;          Stepper(&#34;Quantity: \(quantity)&#34;, value: $quantity)&#xA;          Button(&#34;Mark as sold out&#34;) {&#xA;            self.item.status = .outOfStock(isOnBackOrder: false)&#xA;          }&#xA;        } header: {&#xA;          Text(&#34;In stock&#34;)&#xA;        }&#xA;      }&#xA;    case .outOfStock:&#xA;      self.$status.outOfStock.map { $isOnBackOrder in&#xA;        Section {&#xA;          Toggle(&#34;Is on back order?&#34;, isOn: $isOnBackOrder)&#xA;          Button(&#34;Is back in stock!&#34;) {&#xA;            self.item.status = .inStock(quantity: 1)&#xA;          }&#xA;        } header: {&#xA;          Text(&#34;Out of stock&#34;)&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; The above is a simplified version of the subscript that ships in our &lt;a href=&#34;https://github.com/pointfreeco/swiftui-navigation&#34;&gt;SwiftUINavigation&lt;/a&gt; library.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Computed paths&lt;/h4&gt; &#xA;&lt;p&gt;Key paths are created for every property, even computed ones, so what is the equivalent for case paths? Well, &#34;computed&#34; case paths can be created by extending the case-pathable enum&#39;s &lt;code&gt;AllCasePaths&lt;/code&gt; type with properties that implement the &lt;code&gt;embed&lt;/code&gt; and &lt;code&gt;extract&lt;/code&gt; functionality of a custom case:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@CasePathable&#xA;enum Authentication {&#xA;  case authenticated(accessToken: String)&#xA;  case unauthenticated&#xA;}&#xA;&#xA;extension Authentication.AllCasePaths {&#xA;  var encrypted: AnyCasePath&amp;lt;Authentication, String&amp;gt; {&#xA;    AnyCasePath(&#xA;      embed: { decryptedToken in&#xA;        .authenticated(token: encrypt(decryptedToken))&#xA;      },&#xA;      extract: { authentication in&#xA;        guard&#xA;          case let .authenticated(encryptedToken) = authentication,&#xA;          let decryptedToken = decrypt(token)&#xA;        else { return nil }&#xA;        return decryptedToken&#xA;      }&#xA;    )&#xA;  }&#xA;}&#xA;&#xA;\Authentication.Cases.encrypted&#xA;// CaseKeyPath&amp;lt;Authentication, String&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Case studies&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/pointfreeco/swiftui-navigation&#34;&gt;&lt;strong&gt;SwiftUINavigation&lt;/strong&gt;&lt;/a&gt; uses case paths to power SwiftUI bindings, including navigation, with enums.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/pointfreeco/swift-composable-architecture&#34;&gt;&lt;strong&gt;The Composable Architecture&lt;/strong&gt;&lt;/a&gt; allows you to break large features down into smaller ones that can be glued together user key paths and case paths.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/pointfreeco/swift-parsing&#34;&gt;&lt;strong&gt;Parsing&lt;/strong&gt;&lt;/a&gt; uses case paths to turn unstructured data into enums and back again.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Do you have a project that uses case paths that you&#39;d like to share? Please &lt;a href=&#34;https://github.com/pointfreeco/swift-case-paths/edit/main/README.md&#34;&gt;open a PR&lt;/a&gt; with a link to it!&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;If you want to discuss this library or have a question about how to use it to solve a particular problem, there are a number of places you can discuss with fellow &lt;a href=&#34;http://www.pointfree.co&#34;&gt;Point-Free&lt;/a&gt; enthusiasts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For long-form discussions, we recommend the &lt;a href=&#34;http://github.com/pointfreeco/swift-case-paths/discussions&#34;&gt;discussions&lt;/a&gt; tab of this repo.&lt;/li&gt; &#xA; &lt;li&gt;For casual chat, we recommend the &lt;a href=&#34;http://pointfree.co/slack-invite&#34;&gt;Point-Free Community Slack&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The latest documentation for CasePaths&#39; APIs is available &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-case-paths/main/documentation/casepaths&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Credit and thanks&lt;/h2&gt; &#xA;&lt;p&gt;Special thanks to &lt;a href=&#34;https://github.com/gringoireDM&#34;&gt;Giuseppe Lanza&lt;/a&gt;, whose &lt;a href=&#34;https://github.com/gringoireDM/EnumKit&#34;&gt;EnumKit&lt;/a&gt; inspired the original, reflection-based solution this library used to power case paths.&lt;/p&gt; &#xA;&lt;h2&gt;Interested in learning more?&lt;/h2&gt; &#xA;&lt;p&gt;These concepts (and more) are explored thoroughly in &lt;a href=&#34;https://www.pointfree.co&#34;&gt;Point-Free&lt;/a&gt;, a video series exploring functional programming and Swift hosted by &lt;a href=&#34;https://github.com/mbrandonw&#34;&gt;Brandon Williams&lt;/a&gt; and &lt;a href=&#34;https://github.com/stephencelis&#34;&gt;Stephen Celis&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The design of this library was explored in the following &lt;a href=&#34;https://www.pointfree.co&#34;&gt;Point-Free&lt;/a&gt; episodes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.pointfree.co/episodes/ep87-the-case-for-case-paths-introduction&#34;&gt;Episode 87&lt;/a&gt;: The Case for Case Paths: Introduction&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.pointfree.co/episodes/ep88-the-case-for-case-paths-properties&#34;&gt;Episode 88&lt;/a&gt;: The Case for Case Paths: Properties&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.pointfree.co/episodes/ep89-case-paths-for-free&#34;&gt;Episode 89&lt;/a&gt;: Case Paths for Free&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;a href=&#34;https://www.pointfree.co/episodes/ep87-the-case-for-case-paths-introduction&#34;&gt; &lt;img alt=&#34;video poster image&#34; src=&#34;https://d3rccdn33rt8ze.cloudfront.net/episodes/0087.jpeg&#34; width=&#34;480&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;All modules are released under the MIT license. See &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-case-paths/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
</feed>