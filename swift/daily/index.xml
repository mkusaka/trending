<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-25T01:44:43Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SimonFairbairn/SwiftyMarkdown</title>
    <updated>2023-04-25T01:44:43Z</updated>
    <id>tag:github.com,2023-04-25:/SimonFairbairn/SwiftyMarkdown</id>
    <link href="https://github.com/SimonFairbairn/SwiftyMarkdown" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Converts Markdown files and strings into NSAttributedStrings with lots of customisation options.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SwiftyMarkdown 1.0&lt;/h1&gt; &#xA;&lt;p&gt;SwiftyMarkdown converts Markdown files and strings into &lt;code&gt;NSAttributedString&lt;/code&gt;s using sensible defaults and a Swift-style syntax. It uses dynamic type to set the font size correctly with whatever font you&#39;d like to use.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SimonFairbairn/SwiftyMarkdown/master/#fully-rebuilt-for-2020&#34;&gt;What&#39;s New&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SimonFairbairn/SwiftyMarkdown/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SimonFairbairn/SwiftyMarkdown/master/#how-to-use-swiftymarkdown&#34;&gt;How to Use&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SimonFairbairn/SwiftyMarkdown/master/#screenshot&#34;&gt;Screenshot&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SimonFairbairn/SwiftyMarkdown/master/#front-matter&#34;&gt;Front Matter&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SimonFairbairn/SwiftyMarkdown/master/#appendix&#34;&gt;Appendix&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Fully Rebuilt For 2020!&lt;/h2&gt; &#xA;&lt;p&gt;SwiftyMarkdown now features a more robust and reliable rules-based line processing and character tokenisation engine. It has added support for images stored in the bundle (&lt;code&gt;![Image](&amp;lt;Name In bundle&amp;gt;)&lt;/code&gt;), codeblocks, blockquotes, and unordered lists!&lt;/p&gt; &#xA;&lt;p&gt;Line-level attributes can now have a paragraph alignment applied to them (e.g. &lt;code&gt;h2.aligment = .center&lt;/code&gt;), and links can be optionally underlined by setting &lt;code&gt;underlineLinks&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It also uses the system color &lt;code&gt;.label&lt;/code&gt; as the default font color on iOS 13 and above for Dark Mode support out of the box.&lt;/p&gt; &#xA;&lt;p&gt;Support for all of Apple&#39;s platforms has been enabled.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;CocoaPods:&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;pod &#39;SwiftyMarkdown&#39;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;SPM:&lt;/h3&gt; &#xA;&lt;p&gt;In Xcode, &lt;code&gt;File -&amp;gt; Swift Packages -&amp;gt; Add Package Dependency&lt;/code&gt; and add the GitHub URL.&lt;/p&gt; &#xA;&lt;h2&gt;How To Use SwiftyMarkdown&lt;/h2&gt; &#xA;&lt;p&gt;Read Markdown from a text string...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let md = SwiftyMarkdown(string: &#34;# Heading\nMy *Markdown* string&#34;)&#xA;md.attributedString()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...or from a URL.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if let url = Bundle.main.url(forResource: &#34;file&#34;, withExtension: &#34;md&#34;), md = SwiftyMarkdown(url: url ) {&#xA;&#x9;md.attributedString()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use a different string once SwiftyMarkdown has been initialised, you can now do so like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let md = SwiftyMarkdown(string: &#34;# Heading\nMy *Markdown* string&#34;)&#xA;md.attributedString(from: &#34;A **SECOND** Markdown string. *Fancy!*&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The attributed string can then be assigned to any label or text control that has support for attributed text.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let md = SwiftyMarkdown(string: &#34;# Heading\nMy *Markdown* string&#34;)&#xA;let label = UILabel()&#xA;label.attributedText = md.attributedString()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Supported Markdown Features&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;*italics* or _italics_&#xA;**bold** or __bold__&#xA;~~Linethrough~~Strikethroughs. &#xA;`code`&#xA;&#xA;# Header 1&#xA;&#xA;or&#xA;&#xA;Header 1&#xA;====&#xA;&#xA;## Header 2&#xA;&#xA;or&#xA;&#xA;Header 2&#xA;---&#xA;&#xA;### Header 3&#xA;#### Header 4&#xA;##### Header 5 #####&#xA;###### Header 6 ######&#xA;&#xA;&#x9;Indented code blocks (spaces or tabs)&#xA;&#xA;[Links](http://voyagetravelapps.com/)&#xA;![Images](&amp;lt;Name of asset in bundle&amp;gt;)&#xA;&#xA;[Referenced Links][1]&#xA;![Referenced Images][2]&#xA;&#xA;[1]: http://voyagetravelapps.com/&#xA;[2]: &amp;lt;Name of asset in bundle&amp;gt;&#xA;&#xA;&amp;gt; Blockquotes&#xA;&#xA;- Bulleted&#xA;- Lists&#xA;&#x9;- Including indented lists&#xA;&#x9;&#x9;- Up to three levels&#xA;- Neat!&#xA;&#xA;1. Ordered&#xA;1. Lists&#xA;&#x9;1. Including indented lists&#xA;&#x9;&#x9;- Up to three levels&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Compound rules also work, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;It recognises **[Bold Links](http://voyagetravelapps.com/)**&#xA;&#xA;Or [**Bold Links**](http://voyagetravelapps.com/)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Images will be inserted into the returned &lt;code&gt;NSAttributedString&lt;/code&gt; as an &lt;code&gt;NSTextAttachment&lt;/code&gt; (sadly, this will not work on watchOS as &lt;code&gt;NSTextAttachment&lt;/code&gt; is not available).&lt;/p&gt; &#xA;&lt;h2&gt;Customisation&lt;/h2&gt; &#xA;&lt;p&gt;Set the attributes of every paragraph and character style type using straightforward dot syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;md.body.fontName = &#34;AvenirNextCondensed-Medium&#34;&#xA;&#xA;md.h1.color = UIColor.redColor()&#xA;md.h1.fontName = &#34;AvenirNextCondensed-Bold&#34;&#xA;md.h1.fontSize = 16&#xA;md.h1.alignmnent = .center&#xA;&#xA;md.italic.color = UIColor.blueColor()&#xA;&#xA;md.underlineLinks = true&#xA;&#xA;md.bullet = &#34;üçè&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On iOS, Specified font sizes will be adjusted relative to the the user&#39;s dynamic type settings.&lt;/p&gt; &#xA;&lt;h2&gt;Screenshot&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cl.ly/779e6964257a/swiftymarkdown-2020.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s an example project included in the repository. Open the &lt;code&gt;Example/SwiftyMarkdown.xcodeproj&lt;/code&gt; file to get started.&lt;/p&gt; &#xA;&lt;h2&gt;Front Matter&lt;/h2&gt; &#xA;&lt;p&gt;SwiftyMarkdown recognises YAML front matter and will populate the &lt;code&gt;frontMatterAttributes&lt;/code&gt; property with the key-value pairs that it fines.&lt;/p&gt; &#xA;&lt;h2&gt;Appendix&lt;/h2&gt; &#xA;&lt;h3&gt;A) All Customisable Properties&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;h1.fontName : String&#xA;h1.fontSize : CGFloat&#xA;h1.color : UI/NSColor&#xA;h1.fontStyle : FontStyle&#xA;h1.alignment : NSTextAlignment&#xA;&#xA;h2.fontName : String&#xA;h2.fontSize : CGFloat&#xA;h2.color : UI/NSColor&#xA;h2.fontStyle : FontStyle&#xA;h2.alignment : NSTextAlignment&#xA;&#xA;h3.fontName : String&#xA;h3.fontSize : CGFloat&#xA;h3.color : UI/NSColor&#xA;h3.fontStyle : FontStyle&#xA;h3.alignment : NSTextAlignment&#xA;&#xA;h4.fontName : String&#xA;h4.fontSize : CGFloat&#xA;h4.color : UI/NSColor&#xA;h4.fontStyle : FontStyle&#xA;h4.alignment : NSTextAlignment&#xA;&#xA;h5.fontName : String&#xA;h5.fontSize : CGFloat&#xA;h5.color : UI/NSColor&#xA;h5.fontStyle : FontStyle&#xA;h5.alignment : NSTextAlignment&#xA;&#xA;h6.fontName : String&#xA;h6.fontSize : CGFloat&#xA;h6.color : UI/NSColor&#xA;h6.fontStyle : FontStyle&#xA;h6.alignment : NSTextAlignment&#xA;&#xA;body.fontName : String&#xA;body.fontSize : CGFloat&#xA;body.color : UI/NSColor&#xA;body.fontStyle : FontStyle&#xA;body.alignment : NSTextAlignment&#xA;&#xA;blockquotes.fontName : String&#xA;blockquotes.fontSize : CGFloat&#xA;blockquotes.color : UI/NSColor&#xA;blockquotes.fontStyle : FontStyle&#xA;blockquotes.alignment : NSTextAlignment&#xA;&#xA;link.fontName : String&#xA;link.fontSize : CGFloat&#xA;link.color : UI/NSColor&#xA;link.fontStyle : FontStyle&#xA;&#xA;bold.fontName : String&#xA;bold.fontSize : CGFloat&#xA;bold.color : UI/NSColor&#xA;bold.fontStyle : FontStyle&#xA;&#xA;italic.fontName : String&#xA;italic.fontSize : CGFloat&#xA;italic.color : UI/NSColor&#xA;italic.fontStyle : FontStyle&#xA;&#xA;code.fontName : String&#xA;code.fontSize : CGFloat&#xA;code.color : UI/NSColor&#xA;code.fontStyle : FontStyle&#xA;&#xA;strikethrough.fontName : String&#xA;strikethrough.fontSize : CGFloat&#xA;strikethrough.color : UI/NSColor&#xA;strikethrough.fontStyle : FontStyle&#xA;&#xA;underlineLinks : Bool&#xA;&#xA;bullet : String&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;FontStyle&lt;/code&gt; is an enum with these cases: &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;bold&lt;/code&gt;, &lt;code&gt;italic&lt;/code&gt;, and &lt;code&gt;bolditalic&lt;/code&gt; to give you more precise control over how lines and character styles should look. For example, perhaps you want blockquotes to default to having the italic style:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;md.blockquotes.fontStyle = .italic&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, if you like a bit of chaos:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;md.bold.fontStyle = .italic&#xA;md.italic.fontStyle = .bold&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;B) Advanced Customisation&lt;/h3&gt; &#xA;&lt;p&gt;SwiftyMarkdown uses a rules-based line processing and customisation engine that is no longer limited to Markdown. Rules are processed in order, from top to bottom. Line processing happens first, then character styles are applied based on the character rules.&lt;/p&gt; &#xA;&lt;p&gt;For example, here&#39;s how a small subset of Markdown line tags are set up within SwiftyMarkdown:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum MarkdownLineStyle : LineStyling {&#xA;&#x9;case h1&#xA;&#x9;case h2&#xA;&#x9;case previousH1&#xA;&#x9;case codeblock&#xA;&#x9;case body&#xA;&#x9;&#xA;&#x9;var shouldTokeniseLine: Bool {&#xA;&#x9;&#x9;switch self {&#xA;&#x9;&#x9;case .codeblock:&#xA;&#x9;&#x9;&#x9;return false&#xA;&#x9;&#x9;default:&#xA;&#x9;&#x9;&#x9;return true&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;func styleIfFoundStyleAffectsPreviousLine() -&amp;gt; LineStyling? {&#xA;&#x9;&#x9;switch self {&#xA;&#x9;&#x9;case .previousH1:&#xA;&#x9;&#x9;&#x9;return MarkdownLineStyle.h1&#xA;&#x9;&#x9;default :&#xA;&#x9;&#x9;&#x9;return nil&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;static public var lineRules = [&#xA;&#x9;LineRule(token: &#34;    &#34;,type : MarkdownLineStyle.codeblock, removeFrom: .leading),&#xA;&#x9;LineRule(token: &#34;=&#34;,type : MarkdownLineStyle.previousH1, removeFrom: .entireLine, changeAppliesTo: .previous),&#xA;&#x9;LineRule(token: &#34;## &#34;,type : MarkdownLineStyle.h2, removeFrom: .both),&#xA;&#x9;LineRule(token: &#34;# &#34;,type : MarkdownLineStyle.h1, removeFrom: .both)&#xA;]&#xA;&#xA;let lineProcessor = SwiftyLineProcessor(rules: SwiftyMarkdown.lineRules, default: MarkdownLineStyle.body)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, the character styles all follow rules:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum CharacterStyle : CharacterStyling {&#xA;&#x9;case link, bold, italic, code&#xA;}&#xA;&#xA;static public var characterRules = [&#xA;    CharacterRule(primaryTag: CharacterRuleTag(tag: &#34;[&#34;, type: .open), otherTags: [&#xA;&#x9;&#x9;&#x9;CharacterRuleTag(tag: &#34;]&#34;, type: .close),&#xA;&#x9;&#x9;&#x9;CharacterRuleTag(tag: &#34;[&#34;, type: .metadataOpen),&#xA;&#x9;&#x9;&#x9;CharacterRuleTag(tag: &#34;]&#34;, type: .metadataClose)&#xA;&#x9;], styles: [1 : CharacterStyle.link], metadataLookup: true, definesBoundary: true),&#xA;&#x9;CharacterRule(primaryTag: CharacterRuleTag(tag: &#34;`&#34;, type: .repeating), otherTags: [], styles: [1 : CharacterStyle.code], shouldCancelRemainingTags: true, balancedTags: true),&#xA;&#x9;CharacterRule(primaryTag: CharacterRuleTag(tag: &#34;*&#34;, type: .repeating), otherTags: [], styles: [1 : CharacterStyle.italic, 2 : CharacterStyle.bold], minTags:1 , maxTags:2),&#xA;&#x9;CharacterRule(primaryTag: CharacterRuleTag(tag: &#34;_&#34;, type: .repeating), otherTags: [], styles: [1 : CharacterStyle.italic, 2 : CharacterStyle.bold], minTags:1 , maxTags:2)&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These Character Rules are defined by SwiftyMarkdown:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;public struct CharacterRule : CustomStringConvertible {&#xA;&#xA;&#x9;public let primaryTag : CharacterRuleTag&#xA;&#x9;public let tags : [CharacterRuleTag]&#xA;&#x9;public let escapeCharacters : [Character]&#xA;&#x9;public let styles : [Int : CharacterStyling]&#xA;&#x9;public let minTags : Int&#xA;&#x9;public let maxTags : Int&#xA;&#x9;public var metadataLookup : Bool = false&#xA;&#x9;public var definesBoundary = false&#xA;&#x9;public var shouldCancelRemainingRules = false&#xA;&#x9;public var balancedTags = false&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;primaryTag&lt;/code&gt;: Each rule must have at least one tag and it can be one of &lt;code&gt;repeating&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;metadataOpen&lt;/code&gt;, or &lt;code&gt;metadataClose&lt;/code&gt;. &lt;code&gt;repeating&lt;/code&gt; tags are tags that have identical open and close characters (and often have more than 1 style depending on how many are in a group). For example, the &lt;code&gt;*&lt;/code&gt; tag used in Markdown.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tags&lt;/code&gt;: An array of other tags that the rule can look for. This is where you would put the &lt;code&gt;close&lt;/code&gt; tag for a custom rule, for example.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;escapeCharacters&lt;/code&gt;: The characters that appear prior to any of the tag characters that tell the scanner to ignore the tag.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;styles&lt;/code&gt;: The styles that should be applied to every character between the opening and closing tags.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;minTags&lt;/code&gt;: The minimum number of repeating characters to be considered a successful match. For example, setting the &lt;code&gt;primaryTag&lt;/code&gt; to &lt;code&gt;*&lt;/code&gt; and the &lt;code&gt;minTag&lt;/code&gt; to 2 would mean that &lt;code&gt;**foo**&lt;/code&gt; would be a successful match wheras &lt;code&gt;*bar*&lt;/code&gt; would not.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;maxTags&lt;/code&gt;: The maximum number of repeating characters to be considered a successful match.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;metadataLookup&lt;/code&gt;: Used for Markdown reference links. Tells the scanner to try to look up the metadata from this dictionary, rather than from the inline result.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;definesBoundary&lt;/code&gt;: In order for open and close tags to be successful, the &lt;code&gt;boundaryCount&lt;/code&gt; for a given location in the string needs to be the same. Setting this property to &lt;code&gt;true&lt;/code&gt; means that this rule will increase the &lt;code&gt;boundaryCount&lt;/code&gt; for every character between its opening and closing tags. For example, the &lt;code&gt;[&lt;/code&gt; rule defines a boundary. After it is applied, the string &lt;code&gt;*foo[bar*]&lt;/code&gt; becomes &lt;code&gt;*foobar*&lt;/code&gt; with a boundaryCount &lt;code&gt;00001111&lt;/code&gt;. Applying the &lt;code&gt;*&lt;/code&gt; rule results in the output &lt;code&gt;*foobar*&lt;/code&gt; because the opening &lt;code&gt;*&lt;/code&gt; tag and the closing &lt;code&gt;*&lt;/code&gt; tag now have different &lt;code&gt;boundaryCount&lt;/code&gt; values. It&#39;s basically a way to fix the &lt;code&gt;**[should not be bold**](url)&lt;/code&gt; problem in Markdown.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;shouldCancelRemainingTags&lt;/code&gt;: A successful match will mark every character between the opening and closing tags as complete, thereby preventing any further rules from being applied to those characters.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;balancedTags&lt;/code&gt;: This flag requires that the opening and closing tags be of exactly equal length. E.g. If this is set to true, &lt;code&gt;**foo*&lt;/code&gt; would result in &lt;code&gt;**foo*&lt;/code&gt;. If it was false, the output would be &lt;code&gt;*foo&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Rule Subsets&lt;/h4&gt; &#xA;&lt;p&gt;If you want to only support a small subset of Markdown, it&#39;s now easy to do.&lt;/p&gt; &#xA;&lt;p&gt;This example would only process strings with &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;_&lt;/code&gt; characters, ignoring links, images, code, and all line-level attributes (headings, blockquotes, etc.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;SwiftyMarkdown.lineRules = []&#xA;&#xA;SwiftyMarkdown.characterRules = [&#xA;&#x9;CharacterRule(primaryTag: CharacterRuleTag(tag: &#34;*&#34;, type: .repeating), otherTags: [], styles: [1 : CharacterStyle.italic, 2 : CharacterStyle.bold], minTags:1 , maxTags:2),&#xA;&#x9;CharacterRule(primaryTag: CharacterRuleTag(tag: &#34;_&#34;, type: .repeating), otherTags: [], styles: [1 : CharacterStyle.italic, 2 : CharacterStyle.bold], minTags:1 , maxTags:2)&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Custom Rules&lt;/h4&gt; &#xA;&lt;p&gt;If you wanted to create a rule that applied a style of &lt;code&gt;Elf&lt;/code&gt; to a range of characters between &#34;The elf will speak now: %Here is my elf speaking%&#34;, you could set things up like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum Characters : CharacterStyling {&#xA;&#x9;case elf&#xA;&#xA;&#x9;func isEqualTo( _ other : CharacterStyling) -&amp;gt; Bool {&#xA;&#x9;&#x9;if let other = other as? Characters else {&#xA;&#x9;&#x9;&#x9;return false&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return other == self&#xA;&#x9;}&#xA;}&#xA;&#xA;let characterRules = [&#xA;&#x9;CharacterRule(primaryTag: CharacterRuleTag(tag: &#34;%&#34;, type: .repeating), otherTags: [], styles: [1 : CharacterStyle.elf])&#xA;]&#xA;&#xA;let processor = SwiftyTokeniser( with : characterRules )&#xA;let string = &#34;The elf will speak now: %Here is my elf speaking%&#34;&#xA;let tokens = processor.process(string)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output is an array of tokens would be equivalent to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;[&#xA;&#x9;Token(type: .string, inputString: &#34;The elf will speak now: &#34;, characterStyles: []),&#xA;&#x9;Token(type: .repeatingTag, inputString: &#34;%&#34;, characterStyles: []),&#xA;&#x9;Token(type: .string, inputString: &#34;Here is my elf speaking&#34;, characterStyles: [.elf]),&#xA;&#x9;Token(type: .repeatingTag, inputString: &#34;%&#34;, characterStyles: [])&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;C) SpriteKit Support&lt;/h3&gt; &#xA;&lt;p&gt;Did you know that &lt;code&gt;SKLabelNode&lt;/code&gt; supports attributed text? I didn&#39;t.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let smd = SwiftyMarkdown(string: &#34;My Character&#39;s **Dialogue**&#34;)&#xA;&#xA;let label = SKLabelNode()&#xA;label.preferredMaxLayoutWidth = 500&#xA;label.numberOfLines = 0&#xA;label.attributedText = smd.attributedString()&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>