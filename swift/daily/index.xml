<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-22T01:47:25Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cezheng/Fuzi</title>
    <updated>2022-08-22T01:47:25Z</updated>
    <id>tag:github.com,2022-08-22:/cezheng/Fuzi</id>
    <link href="https://github.com/cezheng/Fuzi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fast &amp; lightweight XML &amp; HTML parser in Swift with XPath &amp; CSS support&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Fuzi (斧子)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/cezheng/Fuzi&#34;&gt;&lt;img src=&#34;https://api.travis-ci.org/cezheng/Fuzi.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/Fuzi&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/Fuzi.svg?sanitize=true&#34; alt=&#34;CocoaPods Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/l/Fuzi.svg?style=flat&amp;amp;color=gray&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cezheng.github.io/Fuzi/&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/Fuzi.svg?style=flat&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://twitter.com/AdamoCheng&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/twitter-@AdamoCheng-blue.svg?style=flat&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;A fast &amp;amp; lightweight XML/HTML parser in Swift that makes your life easier.&lt;/strong&gt; &lt;a href=&#34;http://cezheng.github.io/Fuzi/&#34;&gt;[Documentation]&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Fuzi is based on a Swift port of Mattt Thompson&#39;s &lt;a href=&#34;https://github.com/mattt/Ono&#34;&gt;Ono&lt;/a&gt;(斧), using most of its low level implementaions with moderate class &amp;amp; interface redesign following standard Swift conventions, along with several bug fixes.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Fuzi(斧子) means &#34;axe&#34;, in homage to &lt;a href=&#34;https://github.com/mattt/Ono&#34;&gt;Ono&lt;/a&gt;(斧), which in turn is inspired by &lt;a href=&#34;http://nokogiri.org&#34;&gt;Nokogiri&lt;/a&gt; (鋸), which means &#34;saw&#34;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cezheng/Fuzi/master/README-zh.md&#34;&gt;简体中文&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/cezheng/Fuzi/master/README-ja.md&#34;&gt;日本語&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;A Quick Look&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let xml = &#34;...&#34;&#xA;// or&#xA;// let xmlData = &amp;lt;some NSData or Data&amp;gt;&#xA;do {&#xA;  let document = try XMLDocument(string: xml)&#xA;  // or&#xA;  // let document = try XMLDocument(data: xmlData)&#xA;  &#xA;  if let root = document.root {&#xA;    // Accessing all child nodes of root element&#xA;    for element in root.children {&#xA;      print(&#34;\(element.tag): \(element.attributes)&#34;)&#xA;    }&#xA;    &#xA;    // Getting child element by tag &amp;amp; accessing attributes&#xA;    if let length = root.firstChild(tag:&#34;Length&#34;, inNamespace: &#34;dc&#34;) {&#xA;      print(length[&#34;unit&#34;])     // `unit` attribute&#xA;      print(length.attributes)  // all attributes&#xA;    }&#xA;  }&#xA;  &#xA;  // XPath &amp;amp; CSS queries&#xA;  for element in document.xpath(&#34;//element&#34;) {&#xA;    print(&#34;\(element.tag): \(element.attributes)&#34;)&#xA;  }&#xA;  &#xA;  if let firstLink = document.firstChild(css: &#34;a, link&#34;) {&#xA;    print(firstLink[&#34;href&#34;])&#xA;  }&#xA;} catch let error {&#xA;  print(error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;h3&gt;Inherited from Ono&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Extremely performant document parsing and traversal, powered by &lt;code&gt;libxml2&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Support for both &lt;a href=&#34;http://en.wikipedia.org/wiki/XPath&#34;&gt;XPath&lt;/a&gt; and &lt;a href=&#34;http://en.wikipedia.org/wiki/Cascading_Style_Sheets&#34;&gt;CSS&lt;/a&gt; queries&lt;/li&gt; &#xA; &lt;li&gt;Automatic conversion of date and number values&lt;/li&gt; &#xA; &lt;li&gt;Correct, common-sense handling of XML namespaces for elements and attributes&lt;/li&gt; &#xA; &lt;li&gt;Ability to load HTML and XML documents from either &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;NSData&lt;/code&gt; or &lt;code&gt;[CChar]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Comprehensive test suite&lt;/li&gt; &#xA; &lt;li&gt;Full documentation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Improved in Fuzi&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simple, modern API following standard Swift conventions, no more return types like &lt;code&gt;AnyObject!&lt;/code&gt; that cause unnecessary type casts&lt;/li&gt; &#xA; &lt;li&gt;Customizable date and number formatters&lt;/li&gt; &#xA; &lt;li&gt;Some bugs fixes&lt;/li&gt; &#xA; &lt;li&gt;More convenience methods for HTML Documents&lt;/li&gt; &#xA; &lt;li&gt;Access XML nodes of all types (Including text, comment, etc.)&lt;/li&gt; &#xA; &lt;li&gt;Support for more CSS selectors (yet to come)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iOS 8.0+ / Mac OS X 10.9+&lt;/li&gt; &#xA; &lt;li&gt;Xcode 8.0+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Use version &lt;a href=&#34;https://raw.githubusercontent.com/cezheng/releases/tag/0.4.0&#34;&gt;0.4.0&lt;/a&gt; for Swift 2.3.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;There are 4 ways you can install Fuzi to your project.&lt;/p&gt; &#xA;&lt;h3&gt;Using &lt;a href=&#34;http://cocoapods.org/&#34;&gt;CocoaPods&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;http://cocoapods.org/&#34;&gt;CocoaPods&lt;/a&gt; to install &lt;code&gt;Fuzi&lt;/code&gt; by adding it to your to your &lt;code&gt;Podfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;platform :ios, &#39;8.0&#39;&#xA;use_frameworks!&#xA;&#xA;target &#39;MyApp&#39; do&#xA;&#x9;pod &#39;Fuzi&#39;, &#39;~&amp;gt; 1.0.0&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pod install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;The Swift Package Manager is now built-in with Xcode 11 (currently in beta). You can easily add Fuzi as a dependency by choosing &lt;code&gt;File &amp;gt; Swift Packages &amp;gt; Add Package Dependency...&lt;/code&gt; or in the Swift Packages tab of your project file and clicking on &lt;code&gt;+&lt;/code&gt;. Simply use &lt;code&gt;https://github.com/cezheng/Fuzi&lt;/code&gt; as repository and Xcode should automatically resolve the current version.&lt;/p&gt; &#xA;&lt;h3&gt;Manually&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add all &lt;code&gt;*.swift&lt;/code&gt; files in &lt;code&gt;Fuzi&lt;/code&gt; directory into your project.&lt;/li&gt; &#xA; &lt;li&gt;In your Xcode project &lt;code&gt;Build Settings&lt;/code&gt;: &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Find &lt;code&gt;Search Paths&lt;/code&gt;, add &lt;code&gt;$(SDKROOT)/usr/include/libxml2&lt;/code&gt; to &lt;code&gt;Header Search Paths&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Find &lt;code&gt;Linking&lt;/code&gt;, add &lt;code&gt;-lxml2&lt;/code&gt; to &lt;code&gt;Other Linker Flags&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Using &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Create a &lt;code&gt;Cartfile&lt;/code&gt; or &lt;code&gt;Cartfile.private&lt;/code&gt; in the root directory of your project, and add the following line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;cezheng/Fuzi&#34; ~&amp;gt; 1.0.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ carthage update&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then do the followings in Xcode:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Drag the &lt;code&gt;Fuzi.framework&lt;/code&gt; built by Carthage into your target&#39;s &lt;code&gt;General&lt;/code&gt; -&amp;gt; &lt;code&gt;Embedded Binaries&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;In &lt;code&gt;Build Settings&lt;/code&gt;, find &lt;code&gt;Search Paths&lt;/code&gt;, add &lt;code&gt;$(SDKROOT)/usr/include/libxml2&lt;/code&gt; to &lt;code&gt;Header Search Paths&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;XML&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Fuzi&#xA;&#xA;let xml = &#34;...&#34;&#xA;do {&#xA;  // if encoding is omitted, it defaults to NSUTF8StringEncoding&#xA;  let document = try XMLDocument(string: html, encoding: String.Encoding.utf8)&#xA;  if let root = document.root {&#xA;    print(root.tag)&#xA;    &#xA;    // define a prefix for a namespace&#xA;    document.definePrefix(&#34;atom&#34;, defaultNamespace: &#34;http://www.w3.org/2005/Atom&#34;)&#xA;    &#xA;    // get first child element with given tag in namespace(optional)&#xA;    print(root.firstChild(tag: &#34;title&#34;, inNamespace: &#34;atom&#34;))&#xA;&#xA;    // iterate through all children&#xA;    for element in root.children {&#xA;      print(&#34;\(index) \(element.tag): \(element.attributes)&#34;)&#xA;    }&#xA;  }&#xA;  // you can also use CSS selector against XMLDocument when you feels it makes sense&#xA;} catch let error as XMLError {&#xA;  switch error {&#xA;  case .noError: print(&#34;wth this should not appear&#34;)&#xA;  case .parserFailure, .invalidData: print(error)&#xA;  case .libXMLError(let code, let message):&#xA;    print(&#34;libxml error code: \(code), message: \(message)&#34;)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;HTML&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;HTMLDocument&lt;/code&gt; is a subclass of &lt;code&gt;XMLDocument&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Fuzi&#xA;&#xA;let html = &#34;&amp;lt;html&amp;gt;...&amp;lt;/html&amp;gt;&#34;&#xA;do {&#xA;  // if encoding is omitted, it defaults to NSUTF8StringEncoding&#xA;  let doc = try HTMLDocument(string: html, encoding: String.Encoding.utf8)&#xA;  &#xA;  // CSS queries&#xA;  if let elementById = doc.firstChild(css: &#34;#id&#34;) {&#xA;    print(elementById.stringValue)&#xA;  }&#xA;  for link in doc.css(&#34;a, link&#34;) {&#xA;      print(link.rawXML)&#xA;      print(link[&#34;href&#34;])&#xA;  }&#xA;  &#xA;  // XPath queries&#xA;  if let firstAnchor = doc.firstChild(xpath: &#34;//body/a&#34;) {&#xA;    print(firstAnchor[&#34;href&#34;])&#xA;  }&#xA;  for script in doc.xpath(&#34;//head/script&#34;) {&#xA;    print(script[&#34;src&#34;])&#xA;  }&#xA;  &#xA;  // Evaluate XPath functions&#xA;  if let result = doc.eval(xpath: &#34;count(/*/a)&#34;) {&#xA;    print(&#34;anchor count : \(result.doubleValue)&#34;)&#xA;  }&#xA;  &#xA;  // Convenient HTML methods&#xA;  print(doc.title) // gets &amp;lt;title&amp;gt;&#39;s innerHTML in &amp;lt;head&amp;gt;&#xA;  print(doc.head)  // gets &amp;lt;head&amp;gt; element&#xA;  print(doc.body)  // gets &amp;lt;body&amp;gt; element&#xA;  &#xA;} catch let error {&#xA;  print(error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;I don&#39;t care about error handling&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Fuzi&#xA;&#xA;let xml = &#34;...&#34;&#xA;&#xA;// Don&#39;t show me the errors, just don&#39;t crash&#xA;if let doc1 = try? XMLDocument(string: xml) {&#xA;  //...&#xA;}&#xA;&#xA;let html = &#34;&amp;lt;html&amp;gt;...&amp;lt;/html&amp;gt;&#34;&#xA;&#xA;// I&#39;m sure this won&#39;t crash&#xA;let doc2 = try! HTMLDocument(string: html)&#xA;//...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;I want to access Text Nodes&lt;/h3&gt; &#xA;&lt;p&gt;Not only text nodes, you can specify what types of nodes you would like to access.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let document = ...&#xA;// Get all child nodes that are Element nodes, Text nodes, or Comment nodes&#xA;document.root?.childNodes(ofTypes: [.Element, .Text, .Comment])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Migrating From Ono?&lt;/h2&gt; &#xA;&lt;p&gt;Looking at example programs is the swiftest way to know the difference. The following 2 examples do exactly the same thing.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mattt/Ono/raw/master/Example/main.m&#34;&gt;Ono Example&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cezheng/Fuzi/master/FuziDemo/FuziDemo/main.swift&#34;&gt;Fuzi Example&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Accessing children&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Ono&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[doc firstChildWithTag:tag inNamespace:namespace];&#xA;[doc firstChildWithXPath:xpath];&#xA;[doc firstChildWithXPath:css];&#xA;for (ONOXMLElement *element in parent.children) {&#xA;  //...&#xA;}&#xA;[doc childrenWithTag:tag inNamespace:namespace];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fuzi&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;doc.firstChild(tag: tag, inNamespace: namespace)&#xA;doc.firstChild(xpath: xpath)&#xA;doc.firstChild(css: css)&#xA;for element in parent.children {&#xA;  //...&#xA;}&#xA;doc.children(tag: tag, inNamespace:namespace)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Iterate through query results&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Ono&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Conforms to &lt;code&gt;NSFastEnumeration&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// simply iterating through the results&#xA;// mark `__unused` to unused params `idx` and `stop`&#xA;[doc enumerateElementsWithXPath:xpath usingBlock:^(ONOXMLElement *element, __unused NSUInteger idx, __unused BOOL *stop) {&#xA;  NSLog(@&#34;%@&#34;, element);&#xA;}];&#xA;&#xA;// stop the iteration at second element&#xA;[doc enumerateElementsWithXPath:XPath usingBlock:^(ONOXMLElement *element, NSUInteger idx, BOOL *stop) {&#xA;  *stop = (idx == 1);&#xA;}];&#xA;&#xA;// getting element by index &#xA;ONOXMLDocument *nthElement = [(NSEnumerator*)[doc CSS:css] allObjects][n];&#xA;&#xA;// total element count&#xA;NSUInteger count = [(NSEnumerator*)[document XPath:xpath] allObjects].count;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fuzi&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Conforms to Swift&#39;s &lt;code&gt;SequenceType&lt;/code&gt; and &lt;code&gt;Indexable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// simply iterating through the results&#xA;// no need to write the unused `idx` or `stop` params&#xA;for element in doc.xpath(xpath) {&#xA;  print(element)&#xA;}&#xA;&#xA;// stop the iteration at second element&#xA;for (index, element) in doc.xpath(xpath).enumerate() {&#xA;  if idx == 1 {&#xA;    break&#xA;  }&#xA;}&#xA;&#xA;// getting element by index &#xA;if let nthElement = doc.css(css)[n] {&#xA;  //...&#xA;}&#xA;&#xA;// total element count&#xA;let count = doc.xpath(xpath).count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Evaluating XPath Functions&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Ono&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;ONOXPathFunctionResult *result = [doc functionResultByEvaluatingXPath:xpath];&#xA;result.boolValue;    //BOOL&#xA;result.numericValue; //double&#xA;result.stringValue;  //NSString&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fuzi&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if let result = doc.eval(xpath: xpath) {&#xA;  result.boolValue   //Bool&#xA;  result.doubleValue //Double&#xA;  result.stringValue //String&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Fuzi&lt;/code&gt; is released under the MIT license. See &lt;a href=&#34;https://raw.githubusercontent.com/cezheng/Fuzi/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>qvacua/vimr</title>
    <updated>2022-08-22T01:47:25Z</updated>
    <id>tag:github.com,2022-08-22:/qvacua/vimr</id>
    <link href="https://github.com/qvacua/vimr" rel="alternate"></link>
    <summary type="html">&lt;p&gt;VimR — Neovim GUI for macOS in Swift&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;VimR — Neovim GUI for macOS&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/qvacua/vimr/releases&#34;&gt;Download&lt;/a&gt; • &lt;a href=&#34;https://github.com/qvacua/vimr/wiki&#34;&gt;Documentation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/qvacua/vimr/develop/resources/screenshot1.png&#34; alt=&#34;Screenshot 1&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/qvacua/vimr/develop/resources/screenshot2.png&#34; alt=&#34;Screenshot 2&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;Project VimR is a Neovim GUI for macOS. The goal is to build an editor that uses Neovim inside with many of the convenience GUI features similar to those present in modern editors. We mainly use Swift, but also use C/Objective-C when where appropriate.&lt;/p&gt; &#xA;&lt;p&gt;There are other Neovim GUIs for macOS, see the &lt;a href=&#34;https://github.com/neovim/neovim/wiki/Related-projects#gui&#34;&gt;list&lt;/a&gt;, so why?&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Play around with &lt;a href=&#34;https://github.com/qvacua/neovim&#34;&gt;Neovim&lt;/a&gt;,&lt;/li&gt; &#xA; &lt;li&gt;play around with Swift (and especially with &lt;a href=&#34;https://github.com/ReactiveX/RxSwift&#34;&gt;RxSwift&lt;/a&gt;), and&lt;/li&gt; &#xA; &lt;li&gt;(most importantly) have fun!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to support VimR financially, use &lt;a href=&#34;https://github.com/sponsors/qvacua&#34;&gt;Github&#39;s Sponsor&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;Pre-built Universal signed and notarized binaries can be found under &lt;a href=&#34;https://github.com/qvacua/vimr/releases&#34;&gt;Releases&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Reusable Components&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/qvacua/vimr/raw/develop/RxPack/RxMessagePort.swift&#34;&gt;RxMessagePort&lt;/a&gt;: RxSwift wrapper for local and remote &lt;code&gt;CFMessagePort&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/qvacua/vimr/raw/develop/RxPack/RxMsgpackRpc.swift&#34;&gt;RxMsgpackRpc&lt;/a&gt;: Implementation of MsgpackRpc using RxSwift.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/qvacua/vimr/raw/develop/RxPack/RxNeovimApi.swift&#34;&gt;RxNeovimApi&lt;/a&gt;: RxSwift wrapper of Neovim API.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/qvacua/vimr/tree/develop/NvimView&#34;&gt;NvimView&lt;/a&gt;: SwiftPM module which bundles everything, e.g. Neovim&#39;s &lt;code&gt;runtime&lt;/code&gt;-files, needed to embed Neovim in a Cocoa App.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Some Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Markdown preview&lt;/li&gt; &#xA; &lt;li&gt;Generic HTML preview (retains the scroll position when reloading)&lt;/li&gt; &#xA; &lt;li&gt;Fuzzy file finder a la Xcode&#39;s &#34;Open Quickly...&#34;&lt;/li&gt; &#xA; &lt;li&gt;Trackpad support: Pinching for zooming and two-finger scrolling.&lt;/li&gt; &#xA; &lt;li&gt;Ligatures: Turned off by default. Turn it on in the Preferences.&lt;/li&gt; &#xA; &lt;li&gt;Command line tool.&lt;/li&gt; &#xA; &lt;li&gt;(Simple) File browser&lt;/li&gt; &#xA; &lt;li&gt;Flexible workspace model a la JetBrain&#39;s IDEs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to Build&lt;/h2&gt; &#xA;&lt;p&gt;Clone this repository. Install &lt;code&gt;homebrew&lt;/code&gt;, then in the project root:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git submodule init&#xA;git submodule update&#xA;&#xA;xcode-select --install # install the Xcode command line tools, if you haven&#39;t already&#xA;brew bundle&#xA;&#xA;clean=true notarize=false use_carthage_cache=false ./bin/build_vimr.sh&#xA;# VimR.app will be placed in ./build/Build/Products/Release/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/qvacua/vimr/master/DEVELOP.md&#34;&gt;DEVELOP.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/qvacua/vimr/raw/master/LICENSE&#34;&gt;MIT&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>hmlongco/Factory</title>
    <updated>2022-08-22T01:47:25Z</updated>
    <id>tag:github.com,2022-08-22:/hmlongco/Factory</id>
    <link href="https://github.com/hmlongco/Factory" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A new approach to Container-Based Dependency Injection for Swift and SwiftUI.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/hmlongco/Factory/raw/main/Logo.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A new approach to Container-Based Dependency Injection for Swift and SwiftUI.&lt;/p&gt; &#xA;&lt;h2&gt;Why Something New?&lt;/h2&gt; &#xA;&lt;p&gt;The first dependency injection system I ever wrote was &lt;a href=&#34;https://github.com/hmlongco/Resolver&#34;&gt;Resolver&lt;/a&gt;. This open source project, while quite powerful and still in use in many applications, suffers from a few drawbacks.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Resolver requires pre-registration of all services up front.&lt;/li&gt; &#xA; &lt;li&gt;Resolver uses type inference to dynamically find and return registered services from a container.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The first drawback is relatively minor. While preregistration could lead to a performance hit on application launch, in practice the process is usually quick and not normally noticable.&lt;/p&gt; &#xA;&lt;p&gt;No, it’s the second one that’s somewhat more problematic.&lt;/p&gt; &#xA;&lt;p&gt;Failure to find a matching type can lead to an application crash if we attempt to resolve a given type and a matching registration is not found. In real life that isn’t really a problem as such a thing tends to be noticed and fixed rather quickly the very first time you run a unit test or the second you run the application to see if your newest feature works.&lt;/p&gt; &#xA;&lt;p&gt;But... could we do better? That question lead me on a quest for compile-time type safety. Several other systems have attempted to solve this, but I didn&#39;t want to have to add a source code scanning and generation step to my build process, nor did I want to give up a lot of the control and flexibility inherent in a run-time-based system.&lt;/p&gt; &#xA;&lt;p&gt;I also wanted something simple, fast, clean, and easy to use.&lt;/p&gt; &#xA;&lt;p&gt;Could I have my cake and eat it too?&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Factory is strongly influenced by SwiftUI, and in my opinion is highly suited for use in that environment. Factory is...&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Safe:&lt;/strong&gt; Factory is compile-time safe; a factory for a given type &lt;em&gt;must&lt;/em&gt; exist or the code simply will not compile.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Flexible:&lt;/strong&gt; It&#39;s easy to override dependencies at runtime and for use in SwiftUI Previews.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Powerful:&lt;/strong&gt; Like Resolver, Factory supports application, cached, shared, and custom scopes, custom containers, arguments, decorators, and more.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Lightweight:&lt;/strong&gt; With all of that Factory is slim and trim, just 400 lines of code and half the size of Resolver.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Performant:&lt;/strong&gt; Little to no setup time is needed for the vast majority of your services, resolutions are extremely fast, and no compile-time scripts or build phases are needed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Concise:&lt;/strong&gt; Defining a registration usually takes just a single line of code. Same for resolution.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Tested:&lt;/strong&gt; Unit tests ensure correct operation of registrations, resolutions, and scopes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Free:&lt;/strong&gt; Factory is free and open source under the MIT License.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Sound too good to be true? Let&#39;s take a look.&lt;/p&gt; &#xA;&lt;h2&gt;A Simple Example&lt;/h2&gt; &#xA;&lt;p&gt;Most container-based dependency injection systems require you to define in some way that a given service type is available for injection and many reqire some sort of factory or mechanism that will provide a new instance of the service when needed.&lt;/p&gt; &#xA;&lt;p&gt;Factory is no exception. Here&#39;s a simple dependency registraion.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    static let myService = Factory { MyService() as MyServiceType }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unlike Resolver which often requires defining a plethora of nested registration functions, or SwiftUI, where defining a new environment variable requires creating a new EnvironmentKey and adding additional getters and setters, here we simply add a new &lt;code&gt;Factory&lt;/code&gt; to the default container. When called, the factory closure is evaluated and returns an instance of our dependency. That&#39;s it.&lt;/p&gt; &#xA;&lt;p&gt;Injecting and using the service where needed is equally straightforward. Here&#39;s one way to do it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ContentViewModel: ObservableObject {&#xA;    @Injected(Container.myService) private var myService&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here our view model uses one of Factory&#39;s &lt;code&gt;@Injected&lt;/code&gt; property wrappers to request the desired dependency. Similar to &lt;code&gt;@EnvironmentObject&lt;/code&gt; in SwiftUI, we provide the property wrapper initializer with a reference to a factory of the desired type and it handles the rest.&lt;/p&gt; &#xA;&lt;p&gt;And that&#39;s the core mechanism. In order to use the property wrapper you &lt;em&gt;must&lt;/em&gt; define a factory. That factory &lt;em&gt;must&lt;/em&gt; return the desired type when asked. Fail to do either one and the code will simply not compile. As such, Factory is compile-time safe.&lt;/p&gt; &#xA;&lt;h2&gt;Factory&lt;/h2&gt; &#xA;&lt;p&gt;Similar to a &lt;code&gt;View&lt;/code&gt; in SwiftUI, a &lt;code&gt;Factory&lt;/code&gt; is a lightweight struct that exists to define and manage a specific dependency. Just provide it with a closure that constructs and returns an instance of your dependency or service, and Factory will handle the rest.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;static let myService = Factory { MyService() as MyServiceType }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The type of a factory is inferred from the return type of the closure. Here&#39;s we&#39;re casting &lt;code&gt;MyService&lt;/code&gt; to the protocol it implements, so any dependency returned by this factory will always conform to &lt;code&gt;MyServiceType&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We can also get the same result by explicitly specializing the generic Factory as shown below. Both the specialization and the cast are equivalent and provide the same result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;static let myService = Factory&amp;lt;MyServiceType&amp;gt; { MyService() }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Do neither one and the factory type will always be the returned type. In this case it&#39;s &lt;code&gt;MyService&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;static let myService = Factory { MyService() }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Due to the lazy nature of static variables, no factory is instantiated until it&#39;s referenced for the first time. Contrast this with Resolver, which forced us to run code to register &lt;em&gt;everything&lt;/em&gt; prior to resolving anything.&lt;/p&gt; &#xA;&lt;p&gt;Finally, note that it&#39;s possible to bypass the property wrapper and talk to the factory yourself in a &lt;em&gt;Service Locator&lt;/em&gt; pattern.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ContentViewModel: ObservableObject {&#xA;    // dependencies&#xA;    private let myService = Container.myService()&#xA;    private let eventLogger = Container.eventLogger()&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Just call the desired specific factory as a function and you&#39;ll get an instance of its managed dpendency. It&#39;s that simple.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;You can access the factory directly or the property wrapper if you prefer, but either way for clarity I&#39;d suggest grouping all of a given object&#39;s dependencies in a single place near the top of the class and marking them as private.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Mocking and Testing&lt;/h2&gt; &#xA;&lt;p&gt;If we go back and look at our view model code one might wonder why we&#39;ve gone to all of this trouble? Why not simply say &lt;code&gt;let myService = MyService()&lt;/code&gt; and be done with it?&lt;/p&gt; &#xA;&lt;p&gt;Or keep the container idea, but write something similar to this…&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    static var myService: MyServiceType { MyService() }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Well, the primary benefit one gains from using a container-based dependency injection system is that we&#39;re able to change the behavior of the system as needed. Consider the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @StateObject var model = ContentViewModel()&#xA;    var body: some View {&#xA;        Text(model.text())&#xA;            .padding()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Our ContentView uses our view model, which is assigned to a StateObject. Great. But now we want to preview our code. How do we change the behavior of &lt;code&gt;ContentViewModel&lt;/code&gt; so that its &lt;code&gt;MyService&lt;/code&gt; dependency isn&#39;t making live API calls during development?&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s easy. Just replace &lt;code&gt;MyService&lt;/code&gt; with a mock that also conforms to &lt;code&gt;MyServiceType&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView_Previews: PreviewProvider {&#xA;    static var previews: some View {&#xA;        let _ = Container.myService.register { MockService2() }&#xA;        ContentView()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note the line in our preview code where we’re gone back to our container and registered a new closure on our factory. This function overrides the default factory closure.&lt;/p&gt; &#xA;&lt;p&gt;Now when our preview is displayed &lt;code&gt;ContentView&lt;/code&gt; creates a &lt;code&gt;ContentViewModel&lt;/code&gt; which in turn has a dependency on &lt;code&gt;myService&lt;/code&gt; using the &lt;code&gt;Injected&lt;/code&gt; property wrapper.&lt;/p&gt; &#xA;&lt;p&gt;And when the wrapper asks the factory for an instance of &lt;code&gt;MyServiceType&lt;/code&gt; it now gets a &lt;code&gt;MockService2&lt;/code&gt; instead of the &lt;code&gt;MyService&lt;/code&gt; type originally defined.&lt;/p&gt; &#xA;&lt;p&gt;This is a powerful concept that lets us reach deep into a chain of dependencies and alter the behavior of a system as needed.&lt;/p&gt; &#xA;&lt;p&gt;But we&#39;re not done yet.&lt;/p&gt; &#xA;&lt;p&gt;Factory has quite a few more tricks up its sleeve...&lt;/p&gt; &#xA;&lt;h2&gt;Scope&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;ve used Resolver or some other dependency injection system before then you&#39;ve probably experienced the benefits and power of scopes.&lt;/p&gt; &#xA;&lt;p&gt;And if not, the concept is easy to understand: Just how long should an instance of an object live?&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ve no doubt stuffed an instance of a class into a variable and created a singleton at some point in your career. This is an example of a scope. A single instance is created and then used and shared by all of the methods and functions in the app.&lt;/p&gt; &#xA;&lt;p&gt;This can be done in Factory just by adding a scope attribute.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    static let myService = Factory(scope: .singleton) { MyService() as MyServiceType }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now whenever someone requests an instance of &lt;code&gt;myService&lt;/code&gt; they&#39;ll get the same instance of the object as everyone else.&lt;/p&gt; &#xA;&lt;p&gt;If not specified the default scope is &lt;code&gt;unique&lt;/code&gt;; every time the factory is asked for an instance of an object it will get a new instance of that object.&lt;/p&gt; &#xA;&lt;p&gt;Other common scopes are &lt;code&gt;cached&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt;. Cached items are persisted until the cache is reset, while shared items exist just as long as someone holds a strong reference to them. When the last reference goes away, the weakly held shared reference also goes away.&lt;/p&gt; &#xA;&lt;p&gt;You can also add your own special purpose caches to the mix. Try this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container.Scope {&#xA;    static var session = Cached()&#xA;}&#xA;&#xA;extension Container {&#xA;    static let authenticatedUser = Factory(scope: .session) { AuthenticatedUser() }&#xA;    static let profileImageCache = Factory(scope: .session) { ProfileImageCache() }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once created, a single instance of &lt;code&gt;AuthenticatedUser&lt;/code&gt; and &lt;code&gt;ProfileImageCache&lt;/code&gt; will be provided to anyone that needs one... up until the point where the session scope is reset, perhaps by a user logging out.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func logout() {&#xA;    Container.Scope.session.reset()&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Scopes are powerful tools to have in your arsenal. Use them.&lt;/p&gt; &#xA;&lt;h2&gt;Constructor Injection&lt;/h2&gt; &#xA;&lt;p&gt;At times we might prefer (or need) to use a technique known as &lt;em&gt;constructor injection&lt;/em&gt; where dependencies are provided to an object upon initialization.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s easy to do in Factory. Here we have a service that needs an instance of &lt;code&gt;MyServiceType&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    static let constructedService = Factory { ConstructedService(service: myService()) }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All of the factories in a container are visible to the other factories in that container. Just call the needed factory as a function and the dependency will be provided.&lt;/p&gt; &#xA;&lt;h2&gt;Passing Parameters&lt;/h2&gt; &#xA;&lt;p&gt;Like it or not, some services require one or more parameters to be passed to them in order to be initialized correctly. In that case use &lt;code&gt;ParameterFactory&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    static var argumentService = ParameterFactory&amp;lt;Int, MyServiceType&amp;gt; { n in&#xA;        ParameterService(value: n)&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One caveat is that you can&#39;t use the &lt;code&gt;@Injected&lt;/code&gt; property wrapper with &lt;code&gt;ParameterFactory&lt;/code&gt; as there&#39;s no way to get the needed parameters to the property wrapper before the wrapper is initialized. That being the case, you&#39;ll probably need to reference the container directly and do something similar to the following.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class MyClass {&#xA;    var myService: MyServiceType&#xA;    init(_ n: Int) {&#xA;         myService = Container.parameterService(n)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to pass more than one parameter just use a tuple, dictionary, or struct.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;static var tupleService = ParameterFactory&amp;lt;(Int, Int), MultipleParameterService&amp;gt; { (a, b) in&#xA;    MultipleParameterService(a: a, b: b)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, if you define a scope keep in mind that the first argument passed will be used to create the dependency and &lt;em&gt;that&lt;/em&gt; dependency will be cached. Since the cached object will be returned from now on any arguments passed in later requests will be ignored until the scope is reset.&lt;/p&gt; &#xA;&lt;h2&gt;Optionals and Dynamic Registration&lt;/h2&gt; &#xA;&lt;p&gt;With Factory registrations can be performed at any time. Consider the following optional factory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    static let userProviding = Factory&amp;lt;UserProviding?&amp;gt; { nil }&#xA;}&#xA;&#xA;func authenticated(with user: User) {&#xA;    ...&#xA;    Container.userProviding.register { UserProvider(user: user) }&#xA;    ...&#xA;}&#xA;&#xA;func logout() {&#xA;    ...&#xA;    Container.userProviding.reset()&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now any view model or service that needs an instance of an authenticated user will receive one (or nothing if no user is authenticated). Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class SomeViewModel: ObservableObject {&#xA;    @Injected(Container.userProviding) private let provider&#xA;    func update(email: String) {&#xA;        provider?.updateEmailAddress(email)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The injected provider is optional by default since the Factory was defined that way. You &lt;em&gt;could&lt;/em&gt; explicitly unwrap the optional...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Injected(Container.userProviding) private let provider: UserProviding!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But doing so violates the core premise on which Factory was built in the first place: &lt;em&gt;Your code is guaranteed to be safe.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;I&#39;d avise against it.&lt;/p&gt; &#xA;&lt;p&gt;A few other things here. First, note that we used &lt;code&gt;@Injected&lt;/code&gt; to supply an optional type. We don&#39;t need a &lt;code&gt;@OptionalInjected&lt;/code&gt; property wrapper to do this as we did in Resolver. Same for &lt;code&gt;@LazyInjected&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Next, note that Factory is &lt;em&gt;thread-safe.&lt;/em&gt; Registrations and resolutions lock and unlock the containers and caches as needed.&lt;/p&gt; &#xA;&lt;p&gt;And finally, note that calling register also &lt;em&gt;removes any cached dependency from its associated scope.&lt;/em&gt; This ensures that any new dependency injection request performed from that point on will always get the most recently defined instance of an object.&lt;/p&gt; &#xA;&lt;h2&gt;Lazy and Weak Injections&lt;/h2&gt; &#xA;&lt;p&gt;Factory also has &lt;code&gt;LazyInjected&lt;/code&gt; and &lt;code&gt;WeakLazyInjected&lt;/code&gt; property wrappers. Use &lt;code&gt;LazyInjected&lt;/code&gt; when you want to defer construction of some class until it&#39;s actually needed. Here the child &lt;code&gt;service&lt;/code&gt; won&#39;t be instantiated until the &lt;code&gt;test&lt;/code&gt; function is called.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ServicesP {&#xA;    @LazyInjected(Container.servicesC) var service&#xA;    let name = &#34;Parent&#34;&#xA;    init() {}&#xA;    func test() -&amp;gt; String? {&#xA;        service.name&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And &lt;code&gt;WeakLazyInjected&lt;/code&gt; is useful when building parent/child relationships and you want to avoid retain cycles back to the parent class. It&#39;s also lazy since otherwise you&#39;d have a cyclic dependency between the parent and the child. (P needs C which needs P which needs C which...)&#39;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ServicesC {&#xA;    @WeakLazyInjected(Container.servicesP) var service: ServicesP?&#xA;    init() {}&#xA;    let name = &#34;Child&#34;&#xA;    func test() -&amp;gt; String? {&#xA;        service?.name&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And the factories. Note the shared scopes so references can be kept and maintained for the parent/child relationships.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    static var servicesP = Factory(scope: .shared) { ServicesP() }&#xA;    static var servicesC = Factory(scope: .shared) { ServicesC() }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that if you use &lt;code&gt;WeakLazyInjected&lt;/code&gt; then that class must have been instantiated previously and a strong reference to the class must be maintained elsewhere. If not then the class will be released as soon as it&#39;s created. Think of it like...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;weak var gone: MyClass? = MyClass()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom Containers&lt;/h2&gt; &#xA;&lt;p&gt;In a large project you might want to segregate factories into additional, smaller containers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class OrderContainer: SharedContainer {&#xA;    static let optionalService = Factory&amp;lt;SimpleService?&amp;gt; { nil }&#xA;    static let constructedService = Factory { MyConstructedService(service: myServiceType()) }&#xA;    static let additionalService = Factory(scope: .session) { SimpleService() }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Just define a new container derived from &lt;code&gt;SharedContainer&lt;/code&gt; and add your factories there. You can have as many as you wish, and even derive other containers from your own.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class PaymentsContainer: OrderContainer {&#xA;    static let paymentsServiceType = Factory&amp;lt;PaymentsServiceType&amp;gt; { PaymentsService(service: myServiceType()) }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While a container &lt;em&gt;tree&lt;/em&gt; makes dependency resolutions easier, don&#39;t forget that if need be you can reach across containers simply by specifying the full container.factory path.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class PaymentsContainer: SharedContainer {&#xA;    static let anotherService = Factory { AnotherService(OrderContainer.optionalService()) }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s important to note that in Factory a custom container is not really a &#34;container&#34; in the traditional sense. It&#39;s a name space, used to group similar or related factories together. All registrations and scopes are still managed by the parent &lt;code&gt;SharedContainer&lt;/code&gt; classs on which all containers are based.&lt;/p&gt; &#xA;&lt;h2&gt;SharedContainer&lt;/h2&gt; &#xA;&lt;p&gt;You can also add your own factories to the root &lt;code&gt;SharedContainer&lt;/code&gt; class. Anything added there will be visible and available to every container in the system.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension SharedContainer {&#xA;    static let api = Factory&amp;lt;APIServiceType&amp;gt; { APIService() }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As mentioned earlier, any registrations defined with your app are managed here.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;If we have several mocks that we use all of the time in our previews or unit tests, we can also add a setup function to a given container to make this easier.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    static func setupMocks() {&#xA;        myService.register { MockServiceN(4) }&#xA;        sharedService.register { MockService2() }&#xA;    }&#xA;}&#xA;&#xA;struct ContentView_Previews: PreviewProvider {&#xA;    static var previews: some View {&#xA;        let _ = Container.setupMocks()&#xA;        ContentView()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Reset&lt;/h2&gt; &#xA;&lt;p&gt;Using register on a factory lets us change the state of the system. But what if we need to revert back to the original behavior?&lt;/p&gt; &#xA;&lt;p&gt;Simple. Just reset it to bring back the original factory closure. Or, if desired, you can reset &lt;em&gt;everything&lt;/em&gt; back to square one with a single command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;Container.myService.reset() // single&#xA;Container.Registrations.reset() // all &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The same applies to scope management. You can reset a single cache, or all of them if desired. This includes any caches you might have added, like the &lt;code&gt;session&lt;/code&gt; scope we added above.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;Container.Scope.cached.reset() // single&#xA;Container.Scope.reset() // all scopes except singletons&#xA;Container.Scope.reset(includingSingletons: true) // all including singletons&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;includingSingletons&lt;/code&gt; option must be explicitly specified in order to reset singletons. You have the power. Use it wisely.&lt;/p&gt; &#xA;&lt;h2&gt;Xcode Unit Tests&lt;/h2&gt; &#xA;&lt;p&gt;Finally, Factory has a few additional provisions added to make unit testing eaiser. In your unit test setUp function you can &lt;em&gt;push&lt;/em&gt; the current state of the registration system and then register and test anything you want.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;final class FactoryCoreTests: XCTestCase {&#xA;&#xA;    override func setUp() {&#xA;        super.setUp()&#xA;        Container.Registrations.push()&#xA;        Container.setupMocks()&#xA;     }&#xA;&#xA;    override func tearDown() {&#xA;        super.tearDown()&#xA;        Container.Registrations.pop()&#xA;    }&#xA;    &#xA;    func testSomething() throws {&#xA;        Container.myServiceType.register(factory: { MockService() })&#xA;        let model = Container.someViewModel()&#xA;        XCTAssertTrue(model.isLoaded)&#xA;        ...&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then in your tearDown function simply &lt;em&gt;pop&lt;/em&gt; your changes to restore everything back to the way it was prior to running that test suite.&lt;/p&gt; &#xA;&lt;h2&gt;Resolver&lt;/h2&gt; &#xA;&lt;p&gt;Factory will probably mark the end of Resolver. I learned a lot from that project, and it even won me an &lt;a href=&#34;https://opensource.googleblog.com/2021/09/announcing-latest-open-source-peer-bonus-winners.html&#34;&gt;Open Source Peer Bonus from Google&lt;/a&gt;. (I always thought it a bit strange for an iOS developer to get an award from Google, but there you have it.)&lt;/p&gt; &#xA;&lt;p&gt;But Factory is smaller, faster, cleaner and all in all a much better solution than Resolver could ever be.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Factory is available as a Swift Package. Just add it to your projects.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s also available via CocoaPods. Just add &lt;code&gt;pod Factory&lt;/code&gt; to your Podfile.&lt;/p&gt; &#xA;&lt;p&gt;Finally, Factory is just a single file. Download the project and then add Factory.swift to your project. It&#39;s that easy.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Factory is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;Factory was designed, implemented, documented, and maintained by &lt;a href=&#34;https://www.linkedin.com/in/hmlong/&#34;&gt;Michael Long&lt;/a&gt;, a Senior Lead iOS engineer at &lt;a href=&#34;https://www.clientresourcesinc.com/solutions/&#34;&gt;CRi Solutions&lt;/a&gt;. CRi is a leader in developing cutting edge iOS, Android, and mobile web applications and solutions for our corporate and financial clients.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Email: &lt;a href=&#34;mailto:mlong@clientresourcesinc.com&#34;&gt;mlong@clientresourcesinc.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Twitter: @hmlco&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;He was also one of Google&#39;s &lt;a href=&#34;https://opensource.googleblog.com/2021/09/announcing-latest-open-source-peer-bonus-winners.html&#34;&gt;Open Source Peer Reward&lt;/a&gt; winners in 2021 for his work on Resolver.&lt;/p&gt; &#xA;&lt;h2&gt;Additional Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hmlongco/Resolver&#34;&gt;Resolver: A Swift Dependency Injection System&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hmlongco/Builder&#34;&gt;Builder: A Declarative UIKit Library (Uses Factory in Demo)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Inversion_of_control&#34;&gt;Inversion of Control Design Pattern ~ Wikipedia&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://martinfowler.com/articles/injection.html&#34;&gt;Inversion of Control Containers and the Dependency Injection pattern ~ Martin Fowler&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cocoacasts.com/nuts-and-bolts-of-dependency-injection-in-swift/&#34;&gt;Nuts and Bolts of Dependency Injection in Swift&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cocoacasts.com/dependency-injection-in-swift&#34;&gt;Dependency Injection in Swift&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://medium.com/better-programming/taking-swift-dependency-injection-to-the-next-level-b71114c6a9c6&#34;&gt;Swift 5.1 Takes Dependency Injection to the Next Level&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>