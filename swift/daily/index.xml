<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-20T01:45:32Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pointfreeco/swift-concurrency-extras</title>
    <updated>2023-07-20T01:45:32Z</updated>
    <id>tag:github.com,2023-07-20:/pointfreeco/swift-concurrency-extras</id>
    <link href="https://github.com/pointfreeco/swift-concurrency-extras" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Useful, testable Swift concurrency.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;swift-concurrency-extras&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pointfreeco/swift-concurrency-extras/actions?query=workflow%3ACI&#34;&gt;&lt;img src=&#34;https://github.com/pointfreeco/swift-concurrency-extras/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.pointfree.co/slack-invite&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/slack-chat-informational.svg?label=Slack&amp;amp;logo=slack&#34; alt=&#34;Slack&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-concurrency-extras&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-concurrency-extras%2Fbadge%3Ftype%3Dswift-versions&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-concurrency-extras&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-concurrency-extras%2Fbadge%3Ftype%3Dplatforms&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Reliably testable Swift concurrency.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#motivation&#34;&gt;Motivation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#actorisolated-and-lockisolated&#34;&gt;&lt;code&gt;ActorIsolated&lt;/code&gt; and &lt;code&gt;LockIsolated&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#streams&#34;&gt;Streams&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#tasks&#34;&gt;Tasks&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#uncheckedsendable&#34;&gt;&lt;code&gt;UncheckedSendable&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#serial-execution&#34;&gt;Serial execution&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#other-libraries&#34;&gt;Other libraries&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#learn-more&#34;&gt;Learn more&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#License&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Learn more&lt;/h2&gt; &#xA;&lt;p&gt;This library was designed to support libraries and episodes produced for &lt;a href=&#34;https://www.pointfree.co&#34;&gt;Point-Free&lt;/a&gt;, a video series exploring the Swift programming language hosted by &lt;a href=&#34;https://github.com/mbrandonw&#34;&gt;Brandon Williams&lt;/a&gt; and &lt;a href=&#34;https://github.com/stephencelis&#34;&gt;Stephen Celis&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can watch all of the episodes &lt;a href=&#34;https://www.pointfree.co/collections/concurrency&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;a href=&#34;https://www.pointfree.co/collections/concurrency/&#34;&gt; &lt;img alt=&#34;video poster image&#34; src=&#34;https://d3rccdn33rt8ze.cloudfront.net/episodes/0238.jpeg&#34; width=&#34;600&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;This library comes with a number of tools that make working with Swift concurrency easier and more testable.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#actorisolated-and-lockisolated&#34;&gt;&lt;code&gt;ActorIsolated&lt;/code&gt; and &lt;code&gt;LockIsolated&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#streams&#34;&gt;Streams&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#tasks&#34;&gt;Tasks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#uncheckedsendable&#34;&gt;&lt;code&gt;UncheckedSendable&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#serial-execution&#34;&gt;Serial execution&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;ActorIsolated&lt;/code&gt; and &lt;code&gt;LockIsolated&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;ActorIsolated&lt;/code&gt; and &lt;code&gt;LockIsolated&lt;/code&gt; types help wrap other values in an isolated context. &lt;code&gt;ActorIsolated&lt;/code&gt; wraps the value in an actor so that the only way to access and mutate the value is through an async/await interface. &lt;code&gt;LockIsolated&lt;/code&gt; wraps the value in a class with a lock, which allows you to read and write the value with a synchronous interface. You should prefer to use &lt;code&gt;ActorIsolated&lt;/code&gt; when you have access to an asynchronous context.&lt;/p&gt; &#xA;&lt;h3&gt;Streams&lt;/h3&gt; &#xA;&lt;p&gt;The library comes with numerous helper APIs spread across the two Swift stream types:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;There are helpers that erase any &lt;code&gt;AsyncSequence&lt;/code&gt; conformance to either concrete stream type. This allows you to treat the stream type as a kind of &#34;type erased&#34; &lt;code&gt;AsyncSequence&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;For example, suppose you have a dependency client like this:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ScreenshotsClient {&#xA;  var screenshots: () -&amp;gt; AsyncStream&amp;lt;Void&amp;gt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Then you can construct a live implementation that &#34;erases&#34; the &lt;code&gt;NotificationCenter.Notifications&lt;/code&gt; async sequence to a stream:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension ScreenshotsClient {&#xA;  static let live = Self(&#xA;    screenshots: {&#xA;      NotificationCenter.default&#xA;        .notifications(named: UIApplication.userDidTakeScreenshotNotification)&#xA;        .map { _ in }&#xA;        .eraseToStream()  // ⬅️&#xA;    }&#xA;  )&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Use &lt;code&gt;eraseToThrowingStream()&lt;/code&gt; to propagate failures from throwing async sequences.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Swift 5.9&#39;s &lt;code&gt;makeStream(of:)&lt;/code&gt; functions have been back-ported. It can handy in tests that need to override a dependency endpoint that returns a stream:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let screenshots = AsyncStream.makeStream(of: Void.self)&#xA;&#xA;let model = FeatureModel(screenshots: { screenshots.stream })&#xA;&#xA;XCTAssertEqual(model.screenshotCount, 0)&#xA;screenshots.continuation.yield()  // Simulate a screenshot being taken.&#xA;XCTAssertEqual(model.screenshotCount, 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Static &lt;code&gt;AsyncStream.never&lt;/code&gt; and &lt;code&gt;AsyncThrowingStream.never&lt;/code&gt; helpers are provided that represent streams that live forever and never emit. They can be handy in tests that need to override a dependency endpoint with a stream that should suspend and never emit for the duration of the test.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let model = FeatureModel(screenshots: { .never })&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Static &lt;code&gt;AsyncStream.finished&lt;/code&gt; and &lt;code&gt;AsyncThrowingStream.finished(throwing:)&lt;/code&gt; helpers are provided that represents streams that complete immediately without emitting. They can be handy in tests that need to override a dependency endpoint with a stream that completes/fails immediately.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Tasks&lt;/h3&gt; &#xA;&lt;p&gt;The library enhances the &lt;code&gt;Task&lt;/code&gt; type with new functionality.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The static function &lt;code&gt;Task.never()&lt;/code&gt; can asynchronously return a value of any type, but does so by suspending forever. This can be useful for satisfying a dependency requirement in a way that does not require you to actually return data from that endpoint.&lt;/p&gt; &lt;p&gt;For example, suppose you have a dependency client like this:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct SettingsClient {&#xA;  var fetchSettings: () async throws -&amp;gt; Settings&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You can override the client&#39;s &lt;code&gt;fetchSettings&lt;/code&gt; endpoint in tests to suspend forever by awaiting &lt;code&gt;Task.never()&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;SettingsClient(&#xA;  fetchSettings: { try await Task.never() }&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Task.cancellableValue&lt;/code&gt; is a property that awaits the unstructured task&#39;s &lt;code&gt;value&lt;/code&gt; property while propagating cancellation from the current async context.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Task.megaYield()&lt;/code&gt; is a blunt tool that can make flakey async tests a little less flakey by suspending the current task a number of times and improve the odds that other async work has enough time to start. Prefer the reliability of &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/#serial-execution&#34;&gt;serial execution&lt;/a&gt; instead where possible.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;UncheckedSendable&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A wrapper type that can make any type &lt;code&gt;Sendable&lt;/code&gt;, but in an unsafe and unchecked way. This type should only be used as an alternative to &lt;code&gt;@preconcurrency import&lt;/code&gt;, which turns off concurrency checks for everything in the library. Whereas &lt;code&gt;UncheckedSendable&lt;/code&gt; allows you to turn off concurrency warnings for just one single usage of a particular type.&lt;/p&gt; &#xA;&lt;p&gt;While &lt;a href=&#34;https://github.com/apple/swift-evolution/raw/main/proposals/0302-concurrent-value-and-concurrent-closures.md&#34;&gt;SE-0302&lt;/a&gt; mentions future work of &lt;a href=&#34;https://github.com/apple/swift-evolution/raw/main/proposals/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases&#34;&gt;&#34;Adaptor Types for Legacy Codebases&#34;&lt;/a&gt;, including an &lt;code&gt;UnsafeTransfer&lt;/code&gt; type that serves the same purpose, it has not landed in Swift.&lt;/p&gt; &#xA;&lt;h3&gt;Serial execution&lt;/h3&gt; &#xA;&lt;p&gt;Some asynchronous code is &lt;a href=&#34;https://forums.swift.org/t/reliably-testing-code-that-adopts-swift-concurrency/57304&#34;&gt;notoriously difficult&lt;/a&gt; to test in Swift due to how suspension points are processed by the runtime. The library comes with a static function, &lt;code&gt;withMainSerialExecutor&lt;/code&gt;, that attempts to run all tasks spawned in an operation serially and deterministically. This function can be used to make asynchronous tests faster and less flakey.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: This API is only intended to be used from tests to make them more reliable. Please do not use it from application code.&lt;/p&gt; &#xA; &lt;p&gt;We say that it &#34;&lt;em&gt;attempts&lt;/em&gt; to run all tasks spawned in an operation serially and deterministically&#34; because under the hood it relies on a global, mutable variable in the Swift runtime to do its job, and there are no scoping &lt;em&gt;guarantees&lt;/em&gt; should this mutable variable change during the operation.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;For example, consider the following seemingly simple model that makes a network request and manages some &lt;code&gt;isLoading&lt;/code&gt; state while the request is inflight:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Observable&#xA;class NumberFactModel {&#xA;  var fact: String?&#xA;  var isLoading = false&#xA;  var number = 0&#xA;&#xA;  // Inject the request dependency explicitly to make it testable, but can also&#xA;  // be provided via a dependency management library.&#xA;  let getFact: (Int) async throws -&amp;gt; String&#xA;&#xA;  func getFactButtonTapped() async {&#xA;    self.isLoading = true&#xA;    defer { self.isLoading = false }&#xA;    do {&#xA;      self.fact = try await self.getFact(self.number)&#xA;    } catch {&#xA;      // TODO: Handle error&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We would love to be able to write a test that allows us to confirm that the &lt;code&gt;isLoading&lt;/code&gt; state flips to &lt;code&gt;true&lt;/code&gt; and then &lt;code&gt;false&lt;/code&gt;. You might hope that it is as easy as this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func testIsLoading() async {&#xA;  let model = NumberFactModel(getFact: { &#34;\($0) is a good number&#34; })&#xA;&#xA;  let task = Task { await model.getFactButtonTapped() }&#xA;  XCTAssertEqual(model.isLoading, true)&#xA;  XCTAssertEqual(model.fact, nil)&#xA;&#xA;  await task.value&#xA;  XCTAssertEqual(model.isLoading, false)&#xA;  XCTAssertEqual(model.fact, &#34;0 is a good number.&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However this fails almost 100% of the time. The problem is that the line immediately after creating the unstructured &lt;code&gt;Task&lt;/code&gt; executes before the line &lt;em&gt;inside&lt;/em&gt; the unstructured task, and so we never detect the moment the &lt;code&gt;isLoading&lt;/code&gt; state flips to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You might hope you can wiggle yourself in between the moment the &lt;code&gt;getFactButtonTapped&lt;/code&gt; method is called and the moment the request finishes by using a &lt;code&gt;Task.yield&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; func testIsLoading() async {&#xA;   let model = NumberFactModel(getFact: { &#34;\($0) is a good number&#34; })&#xA;&#xA;   let task = Task { await model.getFactButtonTapped() }&#xA;+  await Task.yield()&#xA;   XCTAssertEqual(model.isLoading, true)&#xA;   XCTAssertEqual(model.fact, nil)&#xA;&#xA;   await task.value&#xA;   XCTAssertEqual(model.isLoading, false)&#xA;   XCTAssertEqual(model.fact, &#34;0 is a good number.&#34;)&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But that still fails the vast majority of times.&lt;/p&gt; &#xA;&lt;p&gt;These problems, and more, can be fixed by running this entire test on the main serial executor:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; func testIsLoading() async {&#xA;+  await withMainSerialExecutor {&#xA;     let model = NumberFactModel(getFact: { &#34;\($0) is a good number&#34; })&#xA;&#xA;     let task = Task { await model.getFactButtonTapped() }&#xA;     await Task.yield()&#xA;     XCTAssertEqual(model.isLoading, true)&#xA;     XCTAssertEqual(model.fact, nil)&#xA;&#xA;     await task.value&#xA;     XCTAssertEqual(model.isLoading, false)&#xA;     XCTAssertEqual(model.fact, &#34;0 is a good number.&#34;)&#xA;+  }&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That one change makes this test pass deterministically, 100% of the time.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The latest documentation for this library is available &lt;a href=&#34;http://pointfreeco.github.io/swift-concurrency-extras/main/documentation/concurrencyextras&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Credits and thanks&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to Pat Brown and &lt;a href=&#34;https://twitter.com/tgrapperon&#34;&gt;Thomas Grapperon&lt;/a&gt; for providing feedback on the library before its release. Special thanks to &lt;a href=&#34;https://twitter.com/kabiroberai&#34;&gt;Kabir Oberai&lt;/a&gt; who helped us work around an Xcode bug and ship serial execution tools with the library.&lt;/p&gt; &#xA;&lt;h2&gt;Other libraries&lt;/h2&gt; &#xA;&lt;p&gt;Concurrency Extras is just one library that makes it easier to write testable code in Swift.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://github.com/pointfreeco/swift-case-paths&#34;&gt;Case Paths&lt;/a&gt;: Tools for working with and testing enums.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://github.com/pointfreeco/swift-clocks&#34;&gt;Clocks&lt;/a&gt;: A few clocks that make working with Swift concurrency more testable and more versatile.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://github.com/pointfreeco/combine-schedulers&#34;&gt;Combine Schedulers&lt;/a&gt;: A few schedulers that make working with Combine more testable and more versatile.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://github.com/pointfreeco/swift-composable-architecture&#34;&gt;Composable Architecture&lt;/a&gt;: A library for building applications in a consistent and understandable way, with composition, testing, and ergonomics in mind.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://github.com/pointfreeco/swift-custom-dump&#34;&gt;Custom Dump&lt;/a&gt;: A collection of tools for debugging, diffing, and testing your application&#39;s data structures.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://github.com/pointfreeco/swift-dependencies&#34;&gt;Dependencies&lt;/a&gt;: A dependency management library inspired by SwiftUI&#39;s &#34;environment.&#34;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://github.com/pointfreeco/swift-snapshot-testing&#34;&gt;Snapshot Testing&lt;/a&gt;: Assert on your application by recording and and asserting against artifacts.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://github.com/pointfreeco/xctest-dynamic-overlay&#34;&gt;XCTest Dynamic Overlay&lt;/a&gt;: Call &lt;code&gt;XCTFail&lt;/code&gt; and other typically test-only helpers from application code.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is released under the MIT license. See &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-concurrency-extras/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
</feed>