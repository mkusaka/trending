<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-23T01:38:34Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>migueldeicaza/SwiftTerm</title>
    <updated>2025-06-23T01:38:34Z</updated>
    <id>tag:github.com,2025-06-23:/migueldeicaza/SwiftTerm</id>
    <link href="https://github.com/migueldeicaza/SwiftTerm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Xterm/VT100 Terminal emulator in Swift&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/migueldeicaza/SwiftTerm/actions/workflows/swift.yml&#34;&gt;&lt;img src=&#34;https://github.com/migueldeicaza/SwiftTerm/actions/workflows/swift.yml/badge.svg?sanitize=true&#34; alt=&#34;Swift&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;SwiftTerm&lt;/h1&gt; &#xA;&lt;p&gt;SwiftTerm is a VT100/Xterm terminal emulator library for Swift applications that can be embedded into macOS, iOS applications, text-based, headless applications or other custom scenarios. It has been used in several commercially available SSH clients, including &lt;a href=&#34;https://apps.apple.com/us/app/secure-shellfish-ssh-files/id1336634154&#34;&gt;Secure Shellfish&lt;/a&gt;, &lt;a href=&#34;https://apps.apple.com/us/app/la-terminal-ssh-client/id1629902861&#34;&gt;La Terminal&lt;/a&gt; and &lt;a href=&#34;https://github.com/CodeEditApp/CodeEdit&#34;&gt;CodeEdit&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Check the &lt;a href=&#34;https://migueldeicaza.github.io/SwiftTermDocs/documentation/swiftterm/&#34;&gt;API Documentation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This repository contains both a terminal emulator engine that is UI agnostic, as well as front-ends for this engine for iOS using UIKit, and macOS using AppKit. A curses-based terminal emulator (to emulate an xterm inside a console application) is available as part of the &lt;a href=&#34;https://github.com/migueldeicaza/TermKit&#34;&gt;TermKit&lt;/a&gt; library.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Sample Code&lt;/strong&gt; There are a couple of minimal sample apps for Mac and iOS showing how to use the library inside the &lt;code&gt;TerminalApp&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The sample Mac app has much of the functionality of MacOS&#39; Terminal.app, but without the configuration UI.&lt;/li&gt; &#xA; &lt;li&gt;The sample iOS application uses an SSH library to connect to a remote system (as there is no native shell on iOS to run), and the sample happens to be hardcoded to my home machine, you can change that in the source code.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Companion App&lt;/strong&gt; &lt;a href=&#34;https://github.com/migueldeicaza/SwiftTermApp&#34;&gt;SwiftTermApp&lt;/a&gt; builds an actual iOS app that uses this library and is more complete than the testing apps in this module and provides a proper configuration UI.&lt;/p&gt; &#xA;&lt;p&gt;This is a port of my original &lt;a href=&#34;https://github.com/migueldeicaza/XtermSharp&#34;&gt;XtermSharp&lt;/a&gt;, which was itself based on &lt;a href=&#34;https://xtermjs.org&#34;&gt;xterm.js&lt;/a&gt;. At this point, I consider SwiftTerm to be a more advanced terminal emulator than both of those (modulo Selection/Accessibility) as it handles UTF, Unicode and grapheme clusters better than those and has a more complete coverage of terminal emulation. XtermSharp is generally attempting to keep up.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pretty decent terminal emulation, on or better than XtermSharp and xterm.js (and more comprehensive in many ways)&lt;/li&gt; &#xA; &lt;li&gt;Unicode rendering (including Emoji, and combining characters and emoji)&lt;/li&gt; &#xA; &lt;li&gt;Reusable and pluggable engine allows multiple user interfaces to be built on top of it.&lt;/li&gt; &#xA; &lt;li&gt;Selection engine (with macOS support in the view)&lt;/li&gt; &#xA; &lt;li&gt;Supports colors (ANSI, 256, TrueColor)&lt;/li&gt; &#xA; &lt;li&gt;Supports mouse events&lt;/li&gt; &#xA; &lt;li&gt;Supports terminal resizing operations (controlled by remote host, or locally)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda&#34;&gt;Hyperlinks&lt;/a&gt; in terminal output&lt;/li&gt; &#xA; &lt;li&gt;AppKit, UIKit front-ends; ncurses front-end &lt;a href=&#34;https://github.com/migueldeicaza/TermKit&#34;&gt;provided separately&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Local process and SSH connection support (some assembly required for the last one)&lt;/li&gt; &#xA; &lt;li&gt;Proper CoreText rendering can munch through the hardened Unicode test suites.&lt;/li&gt; &#xA; &lt;li&gt;Sixel graphics (Use img2sixel to test)&lt;/li&gt; &#xA; &lt;li&gt;iTerm2-style graphic rendering (Use imgcat to test)&lt;/li&gt; &#xA; &lt;li&gt;Fuzzed and abused&lt;/li&gt; &#xA; &lt;li&gt;Seems pretty fast to me&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;SwiftTerm library&lt;/h1&gt; &#xA;&lt;p&gt;The SwiftTerm library itself contains the source code for both the engine and the front-ends. The front-ends are conditionally compiled based on the target platform.&lt;/p&gt; &#xA;&lt;p&gt;The engine is in this directory, while code for macOS lives under &lt;code&gt;Mac&lt;/code&gt;, and code for iOS, lives under &lt;code&gt;iOS&lt;/code&gt;. Given that those two share a lot of common traits, the shared code is under &lt;code&gt;Apple&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Using SwiftTerm&lt;/h2&gt; &#xA;&lt;p&gt;SwiftTerm uses the Swift Package Manager for its build, and you can add the library to your project by using the url for this project or a fork of it.&lt;/p&gt; &#xA;&lt;h2&gt;MacOS NSView&lt;/h2&gt; &#xA;&lt;p&gt;The macOS AppKit NSView implementation &lt;a href=&#34;https://migueldeicaza.github.io/SwiftTermDocs/documentation/swiftterm/terminalview&#34;&gt;&lt;code&gt;TerminalView&lt;/code&gt;&lt;/a&gt; is a reusable NSView control that can be connected to any source by implementing the &lt;a href=&#34;https://migueldeicaza.github.io/SwiftTermDocs/documentation/swiftterm/terminalviewdelegate&#34;&gt;&lt;code&gt;TerminalViewDelegate&lt;/code&gt;&lt;/a&gt;.&lt;br&gt; I anticipate that a common scenario will be to host a local Unix command, so I have included &lt;a href=&#34;https://migueldeicaza.github.io/SwiftTermDocs/documentation/swiftterm/localprocessterminalview&#34;&gt;&lt;code&gt;LocalProcessTerminalView&lt;/code&gt;&lt;/a&gt; which is an implementation that connects the &lt;code&gt;TerminalView&lt;/code&gt; to a Unix pseudo-terminal and runs a command there.&lt;/p&gt; &#xA;&lt;h2&gt;iOS UIView&lt;/h2&gt; &#xA;&lt;p&gt;There is an equivalent UIKit UIView implementation for &lt;a href=&#34;https://migueldeicaza.github.io/SwiftTermDocs/documentation/swiftterm/terminalview&#34;&gt;&lt;code&gt;TerminalView&lt;/code&gt;&lt;/a&gt; which like its NSView companion is an embeddable and reusable view that can be connected to your application by implementing the same TerminalViewDelegate. Unlike the NSView case running on a Mac, where a common scenario will be to run local commands, given that iOS does not offer access to processes, the most common scenario will be to wire up this terminal to a remote host. And the safest way of connecting to a remote system is with SSH.&lt;/p&gt; &#xA;&lt;h2&gt;Shared Code between MacOS and iOS&lt;/h2&gt; &#xA;&lt;p&gt;The iOS and UIKit code share a lot of the code, that code lives under the Apple directory.&lt;/p&gt; &#xA;&lt;h2&gt;Using SSH&lt;/h2&gt; &#xA;&lt;p&gt;The core library currently does not provide a convenient way to connect to SSH, purely to avoid the additional dependency. But this git module references a module that pulls a precompiled SSH client (&lt;a href=&#34;https://github.com/migueldeicaza/SwiftSH&#34;&gt;Frugghi&#39;s SwiftSH&lt;/a&gt;), along with a &lt;a href=&#34;https://github.com/migueldeicaza/SwiftTerm/raw/main/TerminalApp/iOSTerminal/UIKitSshTerminalView.swift&#34;&gt;&lt;code&gt;UIKitSsshTerminalView&lt;/code&gt;&lt;/a&gt; in the iOS sample that that connects the &lt;code&gt;TerminalView&lt;/code&gt; for iOS to an SSH connection.&lt;/p&gt; &#xA;&lt;h1&gt;Working on SwiftTerm&lt;/h1&gt; &#xA;&lt;p&gt;If you are using Xcode, there are two toplevel projects, one for Mac and one for iOS in the TerminalApp directory, one called &#34;iOSTerminal.xcodeproj&#34; and one called &#34;MacTerminal.xcodeproj&#34;.&lt;/p&gt; &#xA;&lt;p&gt;This is needed because Xcode does not provide code completion for iOS if you have a Mac project in the project. So I had to split them up. Both projects reference the same SwiftTerm package.&lt;/p&gt; &#xA;&lt;p&gt;When working with these projects, if you choose the terminal application it will run this one. To run the test suite, select the &#39;SwiftTerm&#39; target instead, and you can use &#39;SwiftTermFuzz&#39; to run the fuzzer.&lt;/p&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;swift build&lt;/code&gt; to build the package, and &lt;code&gt;swift test&lt;/code&gt; to run the test suite - but be warned that the test suite expects the directory &lt;code&gt;esctest&lt;/code&gt; to be checked out to run. You can see how I run these on GitHub actions in the file &lt;code&gt;.github/workflows/swift.yml&lt;/code&gt; if you want to do this locally.&lt;/p&gt; &#xA;&lt;p&gt;If using Xcode, you can select the &#34;SwiftTerm&#34; project, and then use Command-U to run the test suite.&lt;/p&gt; &#xA;&lt;h1&gt;Pending Work&lt;/h1&gt; &#xA;&lt;p&gt;GitHub issues has a list of desired features and enhancements&lt;/p&gt; &#xA;&lt;h1&gt;Long Term Plans&lt;/h1&gt; &#xA;&lt;p&gt;In the longer term, I want to also add a tvOS UIView, a &lt;a href=&#34;https://github.com/rhx/SwiftGtk&#34;&gt;SwiftGtk&lt;/a&gt; front-end for Linux.&lt;/p&gt; &#xA;&lt;h1&gt;Screenshots&lt;/h1&gt; &#xA;&lt;p&gt;24 Bit Color&lt;/p&gt; &#xA;&lt;img width=&#34;1246&#34; alt=&#34;24 bit color&#34; src=&#34;https://user-images.githubusercontent.com/36863/79060395-82181400-7c52-11ea-8f48-cd02323a8284.png&#34;&gt; &#xA;&lt;p&gt;Midnight Commander&lt;/p&gt; &#xA;&lt;img width=&#34;969&#34; alt=&#34;Screen Shot 2020-04-12 at 12 17 49 AM&#34; src=&#34;https://user-images.githubusercontent.com/36863/79060466-49c50580-7c53-11ea-8514-bb4a31359662.png&#34;&gt; &#xA;&lt;p&gt;Solid UTF-8 support, excellent rendering: &lt;img width=&#34;799&#34; alt=&#34;Screen Shot 2020-04-22 at 11 25 30 PM&#34; src=&#34;https://user-images.githubusercontent.com/36863/80055786-95e43580-84f0-11ea-86dd-8dfb7f062b39.png&#34;&gt;&lt;/p&gt; &#xA;&lt;img width=&#34;799&#34; alt=&#34;Screen Shot 2020-04-22 at 11 25 24 PM&#34; src=&#34;https://user-images.githubusercontent.com/36863/80055792-9977bc80-84f0-11ea-8cac-735d4a516a80.png&#34;&gt; &#xA;&lt;p&gt;Supports hyperlinks emitted by modern apps:&lt;/p&gt; &#xA;&lt;img width=&#34;674&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/36863/80055972-0b500600-84f1-11ea-9c57-41cadce67162.png&#34;&gt; &#xA;&lt;p&gt;iOS support:&lt;/p&gt; &#xA;&lt;img width=&#34;981&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/36863/80056069-54a05580-84f1-11ea-8597-5a227c9c64a7.png&#34;&gt; &#xA;&lt;p&gt;Sixel support:&lt;/p&gt; &#xA;&lt;img width=&#34;770&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/36863/115647346-97a62c00-a2f1-11eb-929a-f9d942cc0c09.png&#34;&gt; &#xA;&lt;img width=&#34;568&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/36863/115647706-4e0a1100-a2f2-11eb-9bba-2a82503bca33.png&#34;&gt; &#xA;&lt;h1&gt;Resources&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://geoffg.net/Downloads/Terminal/VT100_User_Guide.pdf&#34;&gt;Digital&#39;s VT100 User Guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://terminalguide.namepad.de&#34;&gt;Terminal Guide&lt;/a&gt; - very nice and visual, but not normative&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Mouse-Tracking&#34;&gt;Xterm Control Sequences&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://vt100.net/docs/vt510-rm/contents.html%5D&#34;&gt;VT510 Video Terminal Programmer Information&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Additional and useful documents:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://vt100.net/docs/vt3xx-gp/contents.html&#34;&gt;VT330/VT340 Programmer Reference Manual Volume 2: Graphics Programming&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://vt100.net/emu/dec_ansi_parser&#34;&gt;A parser for DEC’s ANSI-compatible video terminals&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://vt100.net/emu/&#34;&gt;Codes and Standards&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man4/console_codes.4.html&#34;&gt;Linux Console Docs&lt;/a&gt; they are a subset of vt100, but often simple to follow.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/saitoha/libsixel&#34;&gt;Sixel Graphics&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Test suites:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://invisible-island.net/vttest/&#34;&gt;VTTest&lt;/a&gt; - old, but still good&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gitlab.freedesktop.org/terminal-wg/esctest&#34;&gt;EscTest&lt;/a&gt; - fantastic: George Nachman, the author of iTerm, created this test suite, and it became a FreeDesktop standard. Since then, Thomas E. Dickey, the xterm maintainer and maintainer of many text apps has contributed to this effort.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Authors&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Thanks go to the &lt;a href=&#34;https://xtermjs.org/&#34;&gt;xterm.js&lt;/a&gt; developers that originally wrote a terminal emulator that was licensed under a license that allowed for maximum reuse.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://krzyzanowskim.com&#34;&gt;Marcin Krzyzanowski&lt;/a&gt; who masterfully improved and curated the rendering engine on AppKit/CoreText to be the glorious renderer that it is today - and for his contributions to the rendering engine&lt;/li&gt; &#xA; &lt;li&gt;Greg Munn that did a lot of work in XtermSharp to support the needs of Visual Studio for Mac&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/palmin&#34;&gt;Anders Borum&lt;/a&gt; has contributed reliability fixes, the sixel parser and changes required to put SwiftTerm to use in production.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://tirania.org/&#34;&gt;Miguel de Icaza&lt;/a&gt; -me- who have been looking for an excuse to write some Swift code.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>