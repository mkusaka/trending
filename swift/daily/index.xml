<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-31T01:43:32Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>weichsel/ZIPFoundation</title>
    <updated>2023-08-31T01:43:32Z</updated>
    <id>tag:github.com,2023-08-31:/weichsel/ZIPFoundation</id>
    <link href="https://github.com/weichsel/ZIPFoundation" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Effortless ZIP Handling in Swift&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1577319/27564151-1d99e3a0-5ad6-11e7-8ab6-417c5b5a3ff2.png&#34; width=&#34;489&#34;&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/apple/swift-package-manager&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/SPM-compatible-brightgreen.svg?sanitize=true&#34; alt=&#34;Swift Package Manager compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/ZIPFoundation&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/ZIPFoundation.svg?sanitize=true&#34; alt=&#34;CocoaPods Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/weichsel/ZIPFoundation&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Platforms-macOS%20%7C%20iOS%20%7C%20tvOS%20%7C%20watchOS%20%7C%20visionOS%20%7C%20Linux-lightgrey.svg?sanitize=true&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://twitter.com/weichsel&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/twitter-@weichsel-blue.svg?style=flat&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;ZIP Foundation is a library to create, read and modify ZIP archive files.&lt;br&gt; It is written in Swift and based on &lt;a href=&#34;https://developer.apple.com/documentation/compression&#34;&gt;Apple&#39;s libcompression&lt;/a&gt; for high performance and energy efficiency.&lt;br&gt; To learn more about the performance characteristics of the framework, you can read &lt;a href=&#34;https://thomas.zoechling.me/journal/2017/07/ZIPFoundation.html&#34;&gt;this blog post&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#requirements&#34;&gt;Requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#zipping-files-and-directories&#34;&gt;Zipping Files and Directories&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#unzipping-archives&#34;&gt;Unzipping Archives&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#advanced-usage&#34;&gt;Advanced Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#accessing-individual-entries&#34;&gt;Accessing individual Entries&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#creating-archives&#34;&gt;Creating Archives&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#adding-and-removing-entries&#34;&gt;Adding and Removing Entries&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#closure-based-reading-and-writing&#34;&gt;Closure based Reading and Writing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#in-memory-archives&#34;&gt;In-Memory Archives&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#progress-tracking-and-cancellation&#34;&gt;Progress Tracking and Cancellation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/weichsel/ZIPFoundation/development/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Modern Swift API&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; High Performance Compression and Decompression&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Large File Support&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; In-Memory Archives&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Deterministic Memory Consumption&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Linux compatibility&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; No 3rd party dependencies (on Apple platforms, zlib on Linux)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Comprehensive Unit and Performance Test Coverage&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Complete Documentation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iOS 12.0+ / macOS 10.11+ / tvOS 12.0+ / watchOS 2.0+ / visionOS 1.0+&lt;/li&gt; &#xA; &lt;li&gt;Or Linux with zlib development package&lt;/li&gt; &#xA; &lt;li&gt;Xcode 11.0&lt;/li&gt; &#xA; &lt;li&gt;Swift 4.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;The Swift Package Manager is a dependency manager integrated with the Swift build system. To learn how to use the Swift Package Manager for your project, please read the &lt;a href=&#34;https://github.com/apple/swift-package-manager/raw/master/Documentation/Usage.md&#34;&gt;official documentation&lt;/a&gt;.&lt;br&gt; To add ZIP Foundation as a dependency, you have to add it to the &lt;code&gt;dependencies&lt;/code&gt; of your &lt;code&gt;Package.swift&lt;/code&gt; file and refer to that dependency in your &lt;code&gt;target&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// swift-tools-version:5.0&#xA;import PackageDescription&#xA;let package = Package(&#xA;    name: &#34;&amp;lt;Your Product Name&amp;gt;&#34;,&#xA;    dependencies: [&#xA;&#x9;&#x9;.package(url: &#34;https://github.com/weichsel/ZIPFoundation.git&#34;, .upToNextMajor(from: &#34;0.9.0&#34;))&#xA;    ],&#xA;    targets: [&#xA;        .target(&#xA;&#x9;&#x9;name: &#34;&amp;lt;Your Target Name&amp;gt;&#34;,&#xA;&#x9;&#x9;dependencies: [&#34;ZIPFoundation&#34;]),&#xA;    ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After adding the dependency, you can fetch the library with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ swift package resolve&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt; is a decentralized dependency manager.&lt;br&gt; Installation instructions can be found in the project&#39;s &lt;a href=&#34;https://github.com/Carthage/Carthage#installing-carthage&#34;&gt;README file&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To integrate ZIPFoundation into your Xcode project using Carthage, you have to add it to your &lt;code&gt;Cartfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ogdl&#34;&gt;github &#34;weichsel/ZIPFoundation&#34; ~&amp;gt; 0.9&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After adding ZIPFoundation to the &lt;code&gt;Cartfile&lt;/code&gt;, you have to fetch the sources by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;carthage update --no-build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The fetched project has to be integrated into your workspace by dragging &lt;code&gt;ZIPFoundation.xcodeproj&lt;/code&gt; to Xcode&#39;s Project Navigator. (See &lt;a href=&#34;https://github.com/Carthage/Carthage#adding-frameworks-to-an-application&#34;&gt;official Carhage docs&lt;/a&gt;.)&lt;/p&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;CocoaPods is a dependency manager for Objective-C and Swift.&lt;br&gt; To learn more about setting up your project for CocoaPods, please refer to the &lt;a href=&#34;https://cocoapods.org/#install&#34;&gt;official documentation&lt;/a&gt;.&lt;br&gt; To integrate ZIP Foundation into your Xcode project using CocoaPods, you have to add it to your project&#39;s &lt;code&gt;Podfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;source &#39;https://github.com/CocoaPods/Specs.git&#39;&#xA;platform :ios, &#39;10.0&#39;&#xA;use_frameworks!&#xA;target &#39;&amp;lt;Your Target Name&amp;gt;&#39; do&#xA;    pod &#39;ZIPFoundation&#39;, &#39;~&amp;gt; 0.9&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Afterwards, run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pod install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;ZIP Foundation provides two high level methods to zip and unzip items. Both are implemented as extension of &lt;code&gt;FileManager&lt;/code&gt;.&lt;br&gt; The functionality of those methods is modeled after the behavior of the Archive Utility in macOS.&lt;/p&gt; &#xA;&lt;h3&gt;Zipping Files and Directories&lt;/h3&gt; &#xA;&lt;p&gt;To zip a single file you simply pass a file URL representing the item you want to zip and a destination URL to &lt;code&gt;FileManager.zipItem(at sourceURL: URL, to destinationURL: URL)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let fileManager = FileManager()&#xA;let currentWorkingPath = fileManager.currentDirectoryPath&#xA;var sourceURL = URL(fileURLWithPath: currentWorkingPath)&#xA;sourceURL.appendPathComponent(&#34;file.txt&#34;)&#xA;var destinationURL = URL(fileURLWithPath: currentWorkingPath)&#xA;destinationURL.appendPathComponent(&#34;archive.zip&#34;)&#xA;do {&#xA;    try fileManager.zipItem(at: sourceURL, to: destinationURL)&#xA;} catch {&#xA;    print(&#34;Creation of ZIP archive failed with error:\(error)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, archives are created without any compression. To create compressed ZIP archives, the optional &lt;code&gt;compressionMethod&lt;/code&gt; parameter has to be set to &lt;code&gt;.deflate&lt;/code&gt;.&lt;br&gt; The same method also accepts URLs that represent directory items. In that case, &lt;code&gt;zipItem&lt;/code&gt; adds the directory content of &lt;code&gt;sourceURL&lt;/code&gt; to the archive.&lt;br&gt; By default, a root directory entry named after the &lt;code&gt;lastPathComponent&lt;/code&gt; of the &lt;code&gt;sourceURL&lt;/code&gt; is added to the destination archive. If you don&#39;t want to preserve the parent directory of the source in your archive, you can pass &lt;code&gt;shouldKeepParent: false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Unzipping Archives&lt;/h3&gt; &#xA;&lt;p&gt;To unzip existing archives, you can use &lt;code&gt;FileManager.unzipItem(at sourceURL: URL, to destinationURL: URL)&lt;/code&gt;.&lt;br&gt; This recursively extracts all entries within the archive to the destination URL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let fileManager = FileManager()&#xA;let currentWorkingPath = fileManager.currentDirectoryPath&#xA;var sourceURL = URL(fileURLWithPath: currentWorkingPath)&#xA;sourceURL.appendPathComponent(&#34;archive.zip&#34;)&#xA;var destinationURL = URL(fileURLWithPath: currentWorkingPath)&#xA;destinationURL.appendPathComponent(&#34;directory&#34;)&#xA;do {&#xA;    try fileManager.createDirectory(at: destinationURL, withIntermediateDirectories: true, attributes: nil)&#xA;    try fileManager.unzipItem(at: sourceURL, to: destinationURL)&#xA;} catch {&#xA;    print(&#34;Extraction of ZIP archive failed with error:\(error)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Advanced Usage&lt;/h2&gt; &#xA;&lt;p&gt;ZIP Foundation also allows you to individually access specific entries without the need to extract the whole archive. Additionally it comes with the ability to incrementally update archive contents.&lt;/p&gt; &#xA;&lt;h3&gt;Accessing individual Entries&lt;/h3&gt; &#xA;&lt;p&gt;To gain access to specific ZIP entries, you have to initialize an &lt;code&gt;Archive&lt;/code&gt; object with a file URL that represents an existing archive. After doing that, entries can be retrieved via their relative path. &lt;code&gt;Archive&lt;/code&gt; conforms to &lt;code&gt;Sequence&lt;/code&gt; and therefore supports subscripting:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let fileManager = FileManager()&#xA;let currentWorkingPath = fileManager.currentDirectoryPath&#xA;var archiveURL = URL(fileURLWithPath: currentWorkingPath)&#xA;archiveURL.appendPathComponent(&#34;archive.zip&#34;)&#xA;guard let archive = Archive(url: archiveURL, accessMode: .read) else  {&#xA;    return&#xA;}&#xA;guard let entry = archive[&#34;file.txt&#34;] else {&#xA;    return&#xA;}&#xA;var destinationURL = URL(fileURLWithPath: currentWorkingPath)&#xA;destinationURL.appendPathComponent(&#34;out.txt&#34;)&#xA;do {&#xA;    try archive.extract(entry, to: destinationURL)&#xA;} catch {&#xA;    print(&#34;Extracting entry from archive failed with error:\(error)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;extract&lt;/code&gt; method accepts optional parameters that allow you to control compression and memory consumption.&lt;br&gt; You can find detailed information about that parameters in the method&#39;s documentation.&lt;/p&gt; &#xA;&lt;h3&gt;Creating Archives&lt;/h3&gt; &#xA;&lt;p&gt;To create a new &lt;code&gt;Archive&lt;/code&gt;, pass in a non-existing file URL and &lt;code&gt;AccessMode.create&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let currentWorkingPath = fileManager.currentDirectoryPath&#xA;var archiveURL = URL(fileURLWithPath: currentWorkingPath)&#xA;archiveURL.appendPathComponent(&#34;newArchive.zip&#34;)&#xA;guard let archive = Archive(url: archiveURL, accessMode: .create) else  {&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Adding and Removing Entries&lt;/h3&gt; &#xA;&lt;p&gt;You can add or remove entries to/from archives that have been opened with &lt;code&gt;.create&lt;/code&gt; or &lt;code&gt;.update&lt;/code&gt; &lt;code&gt;AccessMode&lt;/code&gt;. To add an entry from an existing file, you can pass a relative path and a base URL to &lt;code&gt;addEntry&lt;/code&gt;. The relative path identifies the entry within the ZIP archive. The relative path and the base URL must form an absolute file URL that points to the file you want to add to the archive:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let fileManager = FileManager()&#xA;let currentWorkingPath = fileManager.currentDirectoryPath&#xA;var archiveURL = URL(fileURLWithPath: currentWorkingPath)&#xA;archiveURL.appendPathComponent(&#34;archive.zip&#34;)&#xA;guard let archive = Archive(url: archiveURL, accessMode: .update) else  {&#xA;    return&#xA;}&#xA;var fileURL = URL(fileURLWithPath: currentWorkingPath)&#xA;fileURL.appendPathComponent(&#34;file.txt&#34;)&#xA;do {&#xA;    try archive.addEntry(with: fileURL.lastPathComponent, relativeTo: fileURL.deletingLastPathComponent())&#xA;} catch {&#xA;    print(&#34;Adding entry to ZIP archive failed with error:\(error)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, the &lt;code&gt;addEntry(with path: String, fileURL: URL)&lt;/code&gt; method can be used to add files that are &lt;em&gt;not&lt;/em&gt; sharing a common base directory. The &lt;code&gt;fileURL&lt;/code&gt; parameter must contain an absolute file URL that points to a file, symlink or directory on an arbitrary file system location.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;addEntry&lt;/code&gt; method accepts several optional parameters that allow you to control compression, memory consumption and file attributes.&lt;br&gt; You can find detailed information about that parameters in the method&#39;s documentation.&lt;/p&gt; &#xA;&lt;p&gt;To remove an entry, you need a reference to an entry within an archive that you can pass to &lt;code&gt;removeEntry&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;guard let entry = archive[&#34;file.txt&#34;] else {&#xA;    return&#xA;}&#xA;do {&#xA;    try archive.remove(entry)&#xA;} catch {&#xA;    print(&#34;Removing entry from ZIP archive failed with error:\(error)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Closure based Reading and Writing&lt;/h3&gt; &#xA;&lt;p&gt;ZIP Foundation also allows you to consume ZIP entry contents without writing them to the file system. The &lt;code&gt;extract&lt;/code&gt; method accepts a closure of type &lt;code&gt;Consumer&lt;/code&gt;. This closure is called during extraction until the contents of an entry are exhausted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try archive.extract(entry, consumer: { (data) in&#xA;    print(data.count)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;data&lt;/code&gt; passed into the closure contains chunks of the current entry. You can control the chunk size of the entry by providing the optional &lt;code&gt;bufferSize&lt;/code&gt; parameter.&lt;/p&gt; &#xA;&lt;p&gt;You can also add entries from an in-memory data source. To do this you have to provide a closure of type &lt;code&gt;Provider&lt;/code&gt; to the &lt;code&gt;addEntry&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let string = &#34;abcdefghijkl&#34;&#xA;guard let data = string.data(using: .utf8) else { return }&#xA;try? archive.addEntry(with: &#34;fromMemory.txt&#34;, type: .file, uncompressedSize: UInt64(data.count), bufferSize: 4, provider: { (position, size) -&amp;gt; Data in&#xA;    // This will be called until `data` is exhausted (3x in this case).&#xA;    return data.subdata(in: position..&amp;lt;position+size)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The closure is called until enough data has been provided to create an entry of &lt;code&gt;uncompressedSize&lt;/code&gt;. The closure receives &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; arguments so that you can manage the state of your data source.&lt;/p&gt; &#xA;&lt;h3&gt;In-Memory Archives&lt;/h3&gt; &#xA;&lt;p&gt;Besides closure based reading and writing of file based archives, ZIP Foundation also provides capabilities to process in-memory archives. This allows creation or extraction of archives that only reside in RAM. One use case for this functionality is dynamic creation of ZIP archives that are later sent to a client - without performing any disk IO.&lt;/p&gt; &#xA;&lt;p&gt;To work with in-memory archives the &lt;code&gt;init(data: Data, accessMode: AccessMode)&lt;/code&gt; initializer must be used.&lt;br&gt; To &lt;em&gt;read&lt;/em&gt; or &lt;em&gt;update&lt;/em&gt; an in-memory archive, the passed-in &lt;code&gt;data&lt;/code&gt; must contain a representation of a valid ZIP archive.&lt;br&gt; To &lt;em&gt;create&lt;/em&gt; an in-memory archive, the &lt;code&gt;data&lt;/code&gt; parameter can be omitted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let string = &#34;Some string!&#34;&#xA;guard let archive = Archive(accessMode: .create),&#xA;        let data = string.data(using: .utf8) else { return }&#xA;    try? archive.addEntry(with: &#34;inMemory.txt&#34;, type: .file, uncompressedSize: UInt64(data.count), bufferSize: 4, provider: { (position, size) -&amp;gt; Data in&#xA;        return data.subdata(in: position..&amp;lt;position+size)&#xA;    })&#xA;let archiveData = archive.data&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Progress Tracking and Cancellation&lt;/h3&gt; &#xA;&lt;p&gt;All &lt;code&gt;Archive&lt;/code&gt; operations take an optional &lt;code&gt;progress&lt;/code&gt; parameter. By passing in an instance of &lt;a href=&#34;https://developer.apple.com/documentation/foundation/progress&#34;&gt;Progress&lt;/a&gt;, you indicate that you want to track the progress of the current ZIP operation. ZIP Foundation automatically configures the &lt;code&gt;totalUnitCount&lt;/code&gt; of the &lt;code&gt;progress&lt;/code&gt; object and continuously updates its &lt;code&gt;completedUnitCount&lt;/code&gt;.&lt;br&gt; To get notifications about the completed work of the current operation, you can attach a Key-Value Observer to the &lt;code&gt;fractionCompleted&lt;/code&gt; property of your &lt;code&gt;progress&lt;/code&gt; object.&lt;br&gt; The ZIP Foundation &lt;code&gt;FileManager&lt;/code&gt; extension methods also accept optional &lt;code&gt;progress&lt;/code&gt; parameters. &lt;code&gt;zipItem&lt;/code&gt; and &lt;code&gt;unzipItem&lt;/code&gt; both automatically create a hierarchy of progress objects that reflect the progress of all items contained in a directory or an archive that contains multiple items.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://developer.apple.com/documentation/foundation/progress/1413832-cancel&#34;&gt;cancel()&lt;/a&gt; method of &lt;code&gt;Progress&lt;/code&gt; can be used to terminate an unfinished ZIP operation. In case of cancelation, the current operation throws an &lt;code&gt;ArchiveError.cancelledOperation&lt;/code&gt; exception.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;ZIP Foundation is written and maintained by &lt;a href=&#34;http://thomas.zoechling.me&#34;&gt;Thomas Zoechling&lt;/a&gt;.&lt;br&gt; Twitter: &lt;a href=&#34;https://twitter.com/weichsel&#34;&gt;@weichsel&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;ZIP Foundation is released under the MIT License.&lt;br&gt; See &lt;a href=&#34;https://github.com/weichsel/ZIPFoundation/raw/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
</feed>