<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-11-30T01:36:07Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>apple/swift-metrics</title>
    <updated>2024-11-30T01:36:07Z</updated>
    <id>tag:github.com,2024-11-30:/apple/swift-metrics</id>
    <link href="https://github.com/apple/swift-metrics" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Metrics API for Swift&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SwiftMetrics&lt;/h1&gt; &#xA;&lt;p&gt;A Metrics API package for Swift.&lt;/p&gt; &#xA;&lt;p&gt;Almost all production server software needs to emit metrics information for observability. Because it&#39;s unlikely that all parties can agree on one specific metrics backend implementation, this API is designed to establish a standard that can be implemented by various metrics libraries which then post the metrics data to backends like &lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt;, &lt;a href=&#34;https://graphiteapp.org&#34;&gt;Graphite&lt;/a&gt;, publish over &lt;a href=&#34;https://github.com/statsd/statsd&#34;&gt;statsd&lt;/a&gt;, write to disk, etc.&lt;/p&gt; &#xA;&lt;p&gt;This is the beginning of a community-driven open-source project actively seeking contributions, be it code, documentation, or ideas. Apart from contributing to SwiftMetrics itself, we need metrics compatible libraries which send the metrics over to backend such as the ones mentioned above. What SwiftMetrics provides today is covered in the &lt;a href=&#34;https://apple.github.io/swift-metrics/&#34;&gt;API docs&lt;/a&gt;, but it will continue to evolve with community input.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;If you have a server-side Swift application, or maybe a cross-platform (e.g. Linux, macOS) application or library, and you would like to emit metrics, targeting this metrics API package is a great idea. Below you&#39;ll find all you need to know to get started.&lt;/p&gt; &#xA;&lt;h3&gt;Adding the dependency&lt;/h3&gt; &#xA;&lt;p&gt;To add a dependency on the metrics API package, you need to declare it in your &lt;code&gt;Package.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// swift-metrics 1.x and 2.x are almost API compatible, so most clients should use&#xA;.package(url: &#34;https://github.com/apple/swift-metrics.git&#34;, &#34;1.0.0&#34; ..&amp;lt; &#34;3.0.0&#34;),&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and to your application/library target, add &#34;Metrics&#34; to your dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.target(&#xA;    name: &#34;BestExampleApp&#34;,&#xA;    dependencies: [&#xA;        // ... &#xA;        .product(name: &#34;Metrics&#34;, package: &#34;swift-metrics&#34;),&#xA;    ]&#xA;),&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Emitting metrics information&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 1) let&#39;s import the metrics API package&#xA;import Metrics&#xA;&#xA;// 2) we need to create a concrete metric object, the label works similarly to a `DispatchQueue` label&#xA;let counter = Counter(label: &#34;com.example.BestExampleApp.numberOfRequests&#34;)&#xA;&#xA;// 3) we&#39;re now ready to use it&#xA;counter.increment()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Selecting a metrics backend implementation (applications only)&lt;/h3&gt; &#xA;&lt;p&gt;Note: If you are building a library, you don&#39;t need to concern yourself with this section. It is the end users of your library (the applications) who will decide which metrics backend to use. Libraries should never change the metrics implementation as that is something owned by the application.&lt;/p&gt; &#xA;&lt;p&gt;SwiftMetrics only provides the metrics system API. As an application owner, you need to select a metrics backend (such as the ones mentioned above) to make the metrics information useful.&lt;/p&gt; &#xA;&lt;p&gt;Selecting a backend is done by adding a dependency on the desired backend client implementation and invoking the &lt;code&gt;MetricsSystem.bootstrap&lt;/code&gt; function at the beginning of the program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;MetricsSystem.bootstrap(SelectedMetricsImplementation())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This instructs the &lt;code&gt;MetricsSystem&lt;/code&gt; to install &lt;code&gt;SelectedMetricsImplementation&lt;/code&gt; (actual name will differ) as the metrics backend to use.&lt;/p&gt; &#xA;&lt;p&gt;As the API has just launched, not many implementations exist yet. If you are interested in implementing one see the &#34;Implementing a metrics backend&#34; section below explaining how to do so. List of existing SwiftMetrics API compatible libraries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/MrLotU/SwiftPrometheus&#34;&gt;SwiftPrometheus&lt;/a&gt;, support for &lt;a href=&#34;https://prometheus.io&#34;&gt;Prometheus&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apple/swift-statsd-client&#34;&gt;StatsD Client&lt;/a&gt;, support for StatsD&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-swift&#34;&gt;OpenTelemetry Swift&lt;/a&gt;, support for &lt;a href=&#34;https://opentelemetry.io/&#34;&gt;OpenTelemetry&lt;/a&gt; which also implements other metrics and tracing backends&lt;/li&gt; &#xA; &lt;li&gt;Your library? &lt;a href=&#34;https://forums.swift.org/c/server&#34;&gt;Get in touch!&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Swift Metrics Extras&lt;/h3&gt; &#xA;&lt;p&gt;You may also be interested in some &#34;extra&#34; modules which are collected in the &lt;a href=&#34;https://github.com/apple/swift-metrics-extras&#34;&gt;Swift Metrics Extras&lt;/a&gt; repository.&lt;/p&gt; &#xA;&lt;h2&gt;Detailed design&lt;/h2&gt; &#xA;&lt;h3&gt;Architecture&lt;/h3&gt; &#xA;&lt;p&gt;We believe that for the Swift on Server ecosystem, it&#39;s crucial to have a metrics API that can be adopted by anybody so a multitude of libraries from different parties can all provide metrics information. More concretely this means that we believe all the metrics events from all libraries should end up in the same place, be one of the backends mentioned above or wherever else the application owner may choose.&lt;/p&gt; &#xA;&lt;p&gt;In the real world, there are so many opinions over how exactly a metrics system should behave, how metrics should be aggregated and calculated, and where/how to persist them. We think it&#39;s not feasible to wait for one metrics package to support everything that a specific deployment needs while still being simple enough to use and remain performant. That&#39;s why we decided to split the problem into two:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;a metrics API&lt;/li&gt; &#xA; &lt;li&gt;a metrics backend implementation&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This package only provides the metrics API itself, and therefore, SwiftMetrics is a &#34;metrics API package.&#34; SwiftMetrics can be configured (using &lt;code&gt;MetricsSystem.bootstrap&lt;/code&gt;) to choose any compatible metrics backend implementation. This way, packages can adopt the API, and the application can choose any compatible metrics backend implementation without requiring any changes from any of the libraries.&lt;/p&gt; &#xA;&lt;p&gt;This API was designed with the contributors to the Swift on Server community and approved by the SSWG (Swift Server Work Group) to the &#34;sandbox level&#34; of the SSWG&#39;s incubation process.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://forums.swift.org/t/metrics/19353&#34;&gt;pitch&lt;/a&gt; | &lt;a href=&#34;https://forums.swift.org/t/discussion-server-metrics-api/&#34;&gt;discussion&lt;/a&gt; | &lt;a href=&#34;https://forums.swift.org/t/feedback-server-metrics-api/&#34;&gt;feedback&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Metric types&lt;/h3&gt; &#xA;&lt;p&gt;The API supports four metric types:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Counter&lt;/code&gt;: A counter is a cumulative metric that represents a single monotonically increasing counter whose value can only increase or be reset to zero on restart. For example, you can use a counter to represent the number of requests served, tasks completed, or errors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;counter.increment(by: 100)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Gauge&lt;/code&gt;: A Gauge is a metric that represents a single numerical value that can arbitrarily go up and down. Gauges are typically used for measured values like temperatures or current memory usage, but also &#34;counts&#34; that can go up and down, like the number of active threads. Gauges are modeled as a &lt;code&gt;Recorder&lt;/code&gt; with a sample size of 1 that does not perform any aggregation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;gauge.record(100)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Meter&lt;/code&gt;: A Meter is similar to &lt;code&gt;Gauge&lt;/code&gt; - a metric that represents a single numerical value that can arbitrarily go up and down. Meters are typically used for measured values like temperatures or current memory usage, but also &#34;counts&#34; that can go up and down, like the number of active threads. Unlike &lt;code&gt;Gauge&lt;/code&gt;, &lt;code&gt;Meter&lt;/code&gt; also supports atomic incerements and decerements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;meter.record(100)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Recorder&lt;/code&gt;: A recorder collects observations within a time window (usually things like response sizes) and &lt;em&gt;can&lt;/em&gt; provide aggregated information about the data sample, for example count, sum, min, max and various quantiles.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;recorder.record(100)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Timer&lt;/code&gt;: A timer collects observations within a time window (usually things like request duration) and provides aggregated information about the data sample, for example min, max and various quantiles. It is similar to a &lt;code&gt;Recorder&lt;/code&gt; but specialized for values that represent durations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;timer.recordMilliseconds(100)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Implementing a metrics backend (e.g. Prometheus client library)&lt;/h3&gt; &#xA;&lt;p&gt;Note: Unless you need to implement a custom metrics backend, everything in this section is likely not relevant, so please feel free to skip.&lt;/p&gt; &#xA;&lt;p&gt;As seen above, each constructor for &lt;code&gt;Counter&lt;/code&gt;, &lt;code&gt;Gauge&lt;/code&gt;, &lt;code&gt;Meter&lt;/code&gt;, &lt;code&gt;Recorder&lt;/code&gt; and &lt;code&gt;Timer&lt;/code&gt; provides a metric object. This uncertainty obscures the selected metrics backend calling these constructors by design. &lt;em&gt;Each application&lt;/em&gt; can select and configure its desired backend. The application sets up the metrics backend it wishes to use. Configuring the metrics backend is straightforward:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let metricsImplementation = MyFavoriteMetricsImplementation()&#xA;MetricsSystem.bootstrap(metricsImplementation)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This instructs the &lt;code&gt;MetricsSystem&lt;/code&gt; to install &lt;code&gt;MyFavoriteMetricsImplementation&lt;/code&gt; as the metrics backend (&lt;code&gt;MetricsFactory&lt;/code&gt;) to use. This should only be done once at the beginning of the program.&lt;/p&gt; &#xA;&lt;p&gt;Given the above, an implementation of a metric backend needs to conform to &lt;code&gt;protocol MetricsFactory&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol MetricsFactory {&#xA;    func makeCounter(label: String, dimensions: [(String, String)]) -&amp;gt; CounterHandler&#xA;    func makeMeter(label: String, dimensions: [(String, String)]) -&amp;gt; MeterHandler&#xA;    func makeRecorder(label: String, dimensions: [(String, String)], aggregate: Bool) -&amp;gt; RecorderHandler    &#xA;    func makeTimer(label: String, dimensions: [(String, String)]) -&amp;gt; TimerHandler&#xA;&#xA;    func destroyCounter(_ handler: CounterHandler)&#xA;    func destroyMeter(_ handler: MeterHandler)&#xA;    func destroyRecorder(_ handler: RecorderHandler)&#xA;    func destroyTimer(_ handler: TimerHandler)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;MetricsFactory&lt;/code&gt; is responsible for instantiating the concrete metrics classes that capture the metrics and perform aggregation and calculation of various quantiles as needed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Counter&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol CounterHandler: AnyObject {&#xA;    func increment(by: Int64)&#xA;    func reset()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Meter&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol MeterHandler: AnyObject {&#xA;    func set(_ value: Int64)&#xA;    func set(_ value: Double)&#xA;    func increment(by: Double)&#xA;    func decrement(by: Double)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Recorder&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol RecorderHandler: AnyObject {&#xA;    func record(_ value: Int64)&#xA;    func record(_ value: Double)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Timer&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol TimerHandler: AnyObject {&#xA;    func recordNanoseconds(_ duration: Int64)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Dealing with Overflows&lt;/h4&gt; &#xA;&lt;p&gt;Implementation of metric objects that deal with integers, like &lt;code&gt;Counter&lt;/code&gt; and &lt;code&gt;Timer&lt;/code&gt; should be careful with overflow. The expected behavior is to cap at &lt;code&gt;.max&lt;/code&gt;, and never crash the program due to overflow . For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ExampleCounter: CounterHandler {&#xA;    var value: Int64 = 0&#xA;    func increment(by amount: Int64) {&#xA;        let result = self.value.addingReportingOverflow(amount)&#xA;        if result.overflow {&#xA;            self.value = Int64.max&#xA;        } else {&#xA;            self.value = result.partialValue&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Full example&lt;/h4&gt; &#xA;&lt;p&gt;Here is a full, but contrived, example of an in-memory implementation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class SimpleMetricsLibrary: MetricsFactory {&#xA;    init() {}&#xA;&#xA;    func makeCounter(label: String, dimensions: [(String, String)]) -&amp;gt; CounterHandler {&#xA;        return ExampleCounter(label, dimensions)&#xA;    }&#xA;&#xA;    func makeMeter(label: String, dimensions: [(String, String)]) -&amp;gt; MeterHandler {&#xA;        return ExampleMeter(label, dimensions)&#xA;    }&#xA;&#xA;    func makeRecorder(label: String, dimensions: [(String, String)], aggregate: Bool) -&amp;gt; RecorderHandler {&#xA;        return ExampleRecorder(label, dimensions, aggregate)&#xA;    }&#xA;&#xA;    func makeTimer(label: String, dimensions: [(String, String)]) -&amp;gt; TimerHandler {&#xA;        return ExampleTimer(label, dimensions)&#xA;    }&#xA;&#xA;    // implementation is stateless, so nothing to do on destroy calls&#xA;    func destroyCounter(_ handler: CounterHandler) {}&#xA;    func destroyMeter(_ handler: TimerHandler) {}&#xA;    func destroyRecorder(_ handler: RecorderHandler) {}    &#xA;    func destroyTimer(_ handler: TimerHandler) {}&#xA;&#xA;    private class ExampleCounter: CounterHandler {&#xA;        init(_: String, _: [(String, String)]) {}&#xA;&#xA;        let lock = NSLock()&#xA;        var value: Int64 = 0&#xA;        func increment(by amount: Int64) {&#xA;            self.lock.withLock {&#xA;                self.value += amount&#xA;            }&#xA;        }&#xA;&#xA;        func reset() {&#xA;            self.lock.withLock {&#xA;                self.value = 0&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    private class ExampleMeter: MeterHandler {&#xA;        init(_: String, _: [(String, String)]) {}&#xA;&#xA;        let lock = NSLock()&#xA;        var _value: Double = 0&#xA;&#xA;        func set(_ value: Int64) {&#xA;            self.set(Double(value))&#xA;        }&#xA;&#xA;        func set(_ value: Double) {&#xA;            self.lock.withLock { _value = value }&#xA;        }&#xA;&#xA;        func increment(by value: Double) {&#xA;            self.lock.withLock { self._value += value }&#xA;        }&#xA;&#xA;        func decrement(by value: Double) {&#xA;            self.lock.withLock { self._value -= value }&#xA;        }&#xA;    }&#xA;&#xA;    private class ExampleRecorder: RecorderHandler {&#xA;        init(_: String, _: [(String, String)], _: Bool) {}&#xA;&#xA;        private let lock = NSLock()&#xA;        var values = [(Int64, Double)]()&#xA;        func record(_ value: Int64) {&#xA;            self.record(Double(value))&#xA;        }&#xA;&#xA;        func record(_ value: Double) {&#xA;            // TODO: sliding window&#xA;            lock.withLock {&#xA;                values.append((Date().nanoSince1970, value))&#xA;                self._count += 1&#xA;                self._sum += value&#xA;                self._min = Swift.min(self._min, value)&#xA;                self._max = Swift.max(self._max, value)&#xA;            }&#xA;        }&#xA;&#xA;        var _sum: Double = 0&#xA;        var sum: Double {&#xA;            return self.lock.withLock { _sum }&#xA;        }&#xA;&#xA;        private var _count: Int = 0&#xA;        var count: Int {&#xA;            return self.lock.withLock { _count }&#xA;        }&#xA;&#xA;        private var _min: Double = 0&#xA;        var min: Double {&#xA;            return self.lock.withLock { _min }&#xA;        }&#xA;&#xA;        private var _max: Double = 0&#xA;        var max: Double {&#xA;            return self.lock.withLock { _max }&#xA;        }&#xA;    }&#xA;&#xA;    private class ExampleTimer: TimerHandler {&#xA;        init(_: String, _: [(String, String)]) {}&#xA;&#xA;        let lock = NSLock()&#xA;        var _value: Int64 = 0&#xA;&#xA;        func recordNanoseconds(_ duration: Int64) {&#xA;            self.lock.withLock { _value = duration }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/apple/swift-metrics/main/SECURITY.md&#34;&gt;SECURITY.md&lt;/a&gt; for details on the security process.&lt;/p&gt; &#xA;&lt;h2&gt;Getting involved&lt;/h2&gt; &#xA;&lt;p&gt;Do not hesitate to get in touch as well, over on &lt;a href=&#34;https://forums.swift.org/c/server&#34;&gt;https://forums.swift.org/c/server&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>