<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-16T01:46:03Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pointfreeco/swift-parsing</title>
    <updated>2023-01-16T01:46:03Z</updated>
    <id>tag:github.com,2023-01-16:/pointfreeco/swift-parsing</id>
    <link href="https://github.com/pointfreeco/swift-parsing" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A library for turning nebulous data into well-structured data, with a focus on composition, performance, generality, and ergonomics.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;swift-parsing&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/pointfreeco/swift-parsing/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-parsing&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-parsing%2Fbadge%3Ftype%3Dswift-versions&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-parsing&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-parsing%2Fbadge%3Ftype%3Dplatforms&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A library for turning unstructured data into structured data, with a focus on composition, performance, generality, and invertibility:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Composition&lt;/strong&gt;: Ability to break large, complex parsing problems down into smaller, simpler ones. And the ability to take small, simple parsers and easily combine them into larger, more complex ones.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Performance&lt;/strong&gt;: Parsers that have been composed of many smaller parts should perform as well as highly-tuned, hand-written parsers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Generality&lt;/strong&gt;: Ability to parse &lt;em&gt;any&lt;/em&gt; kind of input into &lt;em&gt;any&lt;/em&gt; kind of output. This allows you to choose which abstraction levels you want to work on based on how much performance you need or how much correctness you want guaranteed. For example, you can write a highly tuned parser on collections of UTF-8 code units, and it will automatically plug into parsers of strings, arrays, unsafe buffer pointers and more.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Invertibility&lt;/strong&gt;: Ability to invert your parsers so that they are printers. This allows you to transform your well-structured data back into unstructured data, which is useful for serialization, sending data over the network, &lt;a href=&#34;https://github.com/pointfreeco/swift-url-routing&#34;&gt;URL routing&lt;/a&gt;, and more.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/#motivation&#34;&gt;Motivation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/#getting-started&#34;&gt;Getting started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/#benchmarks&#34;&gt;Benchmarks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/#documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/#other-libraries&#34;&gt;Other libraries&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Learn More&lt;/h2&gt; &#xA;&lt;p&gt;This library was designed over the course of many &lt;a href=&#34;https://www.pointfree.co/collections/parsing&#34;&gt;episodes&lt;/a&gt; on &lt;a href=&#34;https://www.pointfree.co&#34;&gt;Point-Free&lt;/a&gt;, a video series exploring functional programming and the Swift language, hosted by &lt;a href=&#34;https://twitter.com/mbrandonw&#34;&gt;Brandon Williams&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/stephencelis&#34;&gt;Stephen Celis&lt;/a&gt;. You can watch all of the episodes &lt;a href=&#34;https://www.pointfree.co/collections/parsing&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;a href=&#34;https://www.pointfree.co/collections/parsing&#34;&gt; &lt;img alt=&#34;video poster image&#34; src=&#34;https://d3rccdn33rt8ze.cloudfront.net/episodes/0126.jpeg&#34; width=&#34;600&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;Parsing is a surprisingly ubiquitous problem in programming. We can define parsing as trying to transform unstructured data into structured data. The Swift standard library comes with a number of parsers that we reach for every day. For example, there are initializers on &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, and even &lt;code&gt;Bool&lt;/code&gt;, that attempt to parse numbers and booleans from strings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Int(&#34;42&#34;)          // 42&#xA;Int(&#34;Hello&#34;)       // nil&#xA;&#xA;Double(&#34;123.45&#34;)   // 123.45&#xA;Double(&#34;Goodbye&#34;)  // nil&#xA;&#xA;Bool(&#34;true&#34;)       // true&#xA;Bool(&#34;0&#34;)          // nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And there are types like &lt;code&gt;JSONDecoder&lt;/code&gt; and &lt;code&gt;PropertyListDecoder&lt;/code&gt; that attempt to parse &lt;code&gt;Decodable&lt;/code&gt;-conforming types from data:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try JSONDecoder().decode(User.self, from: data)&#xA;try PropertyListDecoder().decode(Settings.self, from: data)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While parsers are everywhere in Swift, Swift has no holistic story &lt;em&gt;for&lt;/em&gt; parsing. Instead, we typically parse data in an ad hoc fashion using a number of unrelated initializers, methods, and other means. And this typically leads to less maintainable, less reusable code.&lt;/p&gt; &#xA;&lt;p&gt;This library aims to write such a story for parsing in Swift. It introduces a single unit of parsing that can be combined in interesting ways to form large, complex parsers that can tackle the programming problems you need to solve in a maintainable way.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;This is an abridged version of the &lt;a href=&#34;https://pointfreeco.github.io/swift-parsing/main/documentation/parsing/gettingstarted&#34;&gt;&#34;Getting Started&#34;&lt;/a&gt; article in the library&#39;s &lt;a href=&#34;https://pointfreeco.github.io/swift-parsing&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Suppose you have a string that holds some user data that you want to parse into an array of &lt;code&gt;User&lt;/code&gt;s:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var input = &#34;&#34;&#34;&#xA;1,Blob,true&#xA;2,Blob Jr.,false&#xA;3,Blob Sr.,true&#xA;&#34;&#34;&#34;&#xA;&#xA;struct User {&#xA;  var id: Int&#xA;  var name: String&#xA;  var isAdmin: Bool&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A naive approach to this would be a nested use of &lt;code&gt;.split(separator:)&lt;/code&gt;, and then a little bit of extra work to convert strings into integers and booleans:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let users = input&#xA;  .split(separator: &#34;\n&#34;)&#xA;  .compactMap { row -&amp;gt; User? in&#xA;    let fields = row.split(separator: &#34;,&#34;)&#xA;    guard&#xA;      fields.count == 3,&#xA;      let id = Int(fields[0]),&#xA;      let isAdmin = Bool(String(fields[2]))&#xA;    else { return nil }&#xA;&#xA;    return User(id: id, name: String(fields[1]), isAdmin: isAdmin)&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Not only is this code a little messy, but it is also inefficient since we are allocating arrays for the &lt;code&gt;.split&lt;/code&gt; and then just immediately throwing away those values.&lt;/p&gt; &#xA;&lt;p&gt;It would be more straightforward and efficient to instead describe how to consume bits from the beginning of the input and convert that into users. This is what this parser library excels at ðŸ˜„.&lt;/p&gt; &#xA;&lt;p&gt;We can start by describing what it means to parse a single row, first by parsing an integer off the front of the string, and then parsing a comma. We can do this by using the &lt;code&gt;Parse&lt;/code&gt; type, which acts as an entry point into describing a list of parsers that you want to run one after the other to consume from an input:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let user = Parse {&#xA;  Int.parser()&#xA;  &#34;,&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Already this can consume the beginning of the input:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try user.parse(&#34;1,&#34;) // 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next we want to take everything up until the next comma for the user&#39;s name, and then consume the comma:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let user = Parse {&#xA;  Int.parser()&#xA;  &#34;,&#34;&#xA;  Prefix { $0 != &#34;,&#34; }&#xA;  &#34;,&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then we want to take the boolean at the end of the row for the user&#39;s admin status:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let user = Parse {&#xA;  Int.parser()&#xA;  &#34;,&#34;&#xA;  Prefix { $0 != &#34;,&#34; }&#xA;  &#34;,&#34;&#xA;  Bool.parser()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Currently this will parse a tuple &lt;code&gt;(Int, Substring, Bool)&lt;/code&gt; from the input, and we can &lt;code&gt;.map&lt;/code&gt; on that to turn it into a &lt;code&gt;User&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let user = Parse {&#xA;  Int.parser()&#xA;  &#34;,&#34;&#xA;  Prefix { $0 != &#34;,&#34; }&#xA;  &#34;,&#34;&#xA;  Bool.parser()&#xA;}&#xA;.map { User(id: $0, name: String($1), isAdmin: $2) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To make the data we are parsing to more prominent, we can instead pass the transform closure as the first argument to &lt;code&gt;Parse&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let user = Parse {&#xA;  User(id: $0, name: String($1), isAdmin: $2)&#xA;} with: {&#xA;  Int.parser()&#xA;  &#34;,&#34;&#xA;  Prefix { $0 != &#34;,&#34; }&#xA;  &#34;,&#34;&#xA;  Bool.parser()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or we can pass the &lt;code&gt;User&lt;/code&gt; initializer to &lt;code&gt;Parse&lt;/code&gt; in a point-free style by transforming the &lt;code&gt;Prefix&lt;/code&gt; parser&#39;s output from a &lt;code&gt;Substring&lt;/code&gt; to &lt;code&gt; String&lt;/code&gt; first:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let user = Parse(User.init(id:name:isAdmin:)) {&#xA;  Int.parser()&#xA;  &#34;,&#34;&#xA;  Prefix { $0 != &#34;,&#34; }.map(String.init)&#xA;  &#34;,&#34;&#xA;  Bool.parser()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That is enough to parse a single user from the input string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try user.parse(&#34;1,Blob,true&#34;)&#xA;// User(id: 1, name: &#34;Blob&#34;, isAdmin: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To parse multiple users from the input we can use the &lt;code&gt;Many&lt;/code&gt; parser to run the user parser many times:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let users = Many {&#xA;  user&#xA;} separator: {&#xA;  &#34;\n&#34;&#xA;}&#xA;&#xA;try users.parse(input)&#xA;// [User(id: 1, name: &#34;Blob&#34;, isAdmin: true), ...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now this parser can process an entire document of users, and the code is simpler and more straightforward than the version that uses &lt;code&gt;.split&lt;/code&gt; and &lt;code&gt;.compactMap&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Even better, it&#39;s more performant. We&#39;ve written &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/Sources/swift-parsing-benchmark/ReadmeExample.swift&#34;&gt;benchmarks&lt;/a&gt; for these two styles of parsing, and the &lt;code&gt;.split&lt;/code&gt;-style of parsing is more than twice as slow:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;name                             time        std        iterations&#xA;------------------------------------------------------------------&#xA;README Example.Parser: Substring 3426.000 ns Â±  63.40 %     385395&#xA;README Example.Ad hoc            7631.000 ns Â±  47.01 %     169332&#xA;Program ended with exit code: 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Further, if you are willing write your parsers against &lt;code&gt;UTF8View&lt;/code&gt; instead of &lt;code&gt;Substring&lt;/code&gt;, you can eke out even more performance, more than doubling the speed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;name                             time        std        iterations&#xA;------------------------------------------------------------------&#xA;README Example.Parser: Substring 3693.000 ns Â±  81.76 %     349763&#xA;README Example.Parser: UTF8      1272.000 ns Â± 128.16 %     999150&#xA;README Example.Ad hoc            8504.000 ns Â±  59.59 %     151417&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also compare these times to a tool that Apple&#39;s Foundation gives us: &lt;code&gt;Scanner&lt;/code&gt;. It&#39;s a type that allows you to consume from the beginning of strings in order to produce values, and provides a nicer API than using &lt;code&gt;.split&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var users: [User] = []&#xA;while scanner.currentIndex != input.endIndex {&#xA;  guard&#xA;    let id = scanner.scanInt(),&#xA;    let _ = scanner.scanString(&#34;,&#34;),&#xA;    let name = scanner.scanUpToString(&#34;,&#34;),&#xA;    let _ = scanner.scanString(&#34;,&#34;),&#xA;    let isAdmin = scanner.scanBool()&#xA;  else { break }&#xA;&#xA;  users.append(User(id: id, name: name, isAdmin: isAdmin))&#xA;  _ = scanner.scanString(&#34;\n&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, the &lt;code&gt;Scanner&lt;/code&gt; style of parsing is more than 5 times as slow as the substring parser written above, and more than 15 times slower than the UTF-8 parser:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;name                             time         std        iterations&#xA;-------------------------------------------------------------------&#xA;README Example.Parser: Substring  3481.000 ns Â±  65.04 %     376525&#xA;README Example.Parser: UTF8       1207.000 ns Â± 110.96 %    1000000&#xA;README Example.Ad hoc             8029.000 ns Â±  44.44 %     163719&#xA;README Example.Scanner           19786.000 ns Â±  35.26 %      62125&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can take things even further. With one small change we can turn the parser into a &lt;em&gt;printer&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-let user = Parse(User.init(id:name:isAdmin:)) {&#xA;+let user = ParsePrint(.memberwise(User.init(id:name:isAdmin:))) {&#xA;   Int.parser()&#xA;   &#34;,&#34;&#xA;   Prefix { $0 != &#34;,&#34; }.map(String.init)&#xA;   &#34;,&#34;&#xA;   Bool.parser()&#xA; }&#xA;&#xA; let users = Many {&#xA;   user&#xA; } separator: {&#xA;   &#34;\n&#34;&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With this one change we can now print an array of users back into a string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;users.print([&#xA;  User(id: 1, name: &#34;Blob&#34;, isAdmin: true),&#xA;  User(id: 2, name: &#34;Blob Jr.&#34;, isAdmin: false),&#xA;  User(id: 3, name: &#34;Blob Sr.&#34;, isAdmin: true),&#xA;])&#xA;// 1,Blob,true&#xA;// 2,Blob Jr.,false&#xA;// 3,Blob Sr.,true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s the basics of parsing and printing a simple string format, but there&#39;s a lot more operators and tricks to learn in order to performantly parse larger inputs. Read the &lt;a href=&#34;https://pointfreeco.github.io/swift-parsing&#34;&gt;documentation&lt;/a&gt; to dive more deeply into the concepts of parser-printers, and view the &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/Sources/swift-parsing-benchmark&#34;&gt;benchmarks&lt;/a&gt; for more examples of real life parsing scenarios.&lt;/p&gt; &#xA;&lt;h2&gt;Benchmarks&lt;/h2&gt; &#xA;&lt;p&gt;This library comes with a benchmark executable that not only demonstrates the performance of the library, but also provides a wide variety of parsing examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/Sources/swift-parsing-benchmark/Color.swift&#34;&gt;Hex color&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/Sources/swift-parsing-benchmark/CSV.swift&#34;&gt;Simplified CSV&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/Sources/swift-parsing-benchmark/JSON.swift&#34;&gt;Simplified JSON&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/Sources/swift-parsing-benchmark/Date.swift&#34;&gt;ISO8601 date&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/Sources/swift-parsing-benchmark/HTTP.swift&#34;&gt;HTTP request&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/Sources/swift-parsing-benchmark/BinaryData.swift&#34;&gt;DNS header&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/Sources/swift-parsing-benchmark/Arithmetic.swift&#34;&gt;Arithmetic grammar&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/Sources/swift-parsing-benchmark/XCTestLogs.swift&#34;&gt;Xcode test logs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;and more&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These are the times we currently get when running the benchmarks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;MacBook Pro (16-inch, 2021)&#xA;Apple M1 Pro (10 cores, 8 performance and 2 efficiency)&#xA;32 GB (LPDDR5)&#xA;&#xA;name                                         time            std        iterations&#xA;----------------------------------------------------------------------------------&#xA;Arithmetic.Parser                                8042.000 ns Â±   5.91 %     174657&#xA;BinaryData.Parser                                  42.000 ns Â±  56.81 %    1000000&#xA;Bool.Bool.init                                     41.000 ns Â±  60.69 %    1000000&#xA;Bool.Bool.parser                                   42.000 ns Â±  57.28 %    1000000&#xA;Bool.Scanner.scanBool                            1041.000 ns Â±  25.98 %    1000000&#xA;Color.Parser                                      209.000 ns Â±  13.68 %    1000000&#xA;CSV.Parser                                    4047750.000 ns Â±   1.18 %        349&#xA;CSV.Ad hoc mutating methods                    898604.000 ns Â±   1.49 %       1596&#xA;Date.Parser                                      6416.000 ns Â±   2.56 %     219218&#xA;Date.DateFormatter                              25625.000 ns Â±   2.19 %      54110&#xA;Date.ISO8601DateFormatter                       35125.000 ns Â±   1.71 %      39758&#xA;HTTP.HTTP                                        9709.000 ns Â±   3.81 %     138868&#xA;JSON.Parser                                     32292.000 ns Â±   3.18 %      41890&#xA;JSON.JSONSerialization                           1833.000 ns Â±   8.58 %     764057&#xA;Numerics.Int.init                                  41.000 ns Â±  84.54 %    1000000&#xA;Numerics.Int.parser                                42.000 ns Â±  72.17 %    1000000&#xA;Numerics.Scanner.scanInt                          125.000 ns Â±  20.26 %    1000000&#xA;Numerics.Comma separated: Int.parser          8096459.000 ns Â±   0.44 %        173&#xA;Numerics.Comma separated: Scanner.scanInt    49178770.500 ns Â±   0.24 %         28&#xA;Numerics.Comma separated: String.split       14922583.500 ns Â±   0.67 %         94&#xA;Numerics.Double.init                               42.000 ns Â±  72.61 %    1000000&#xA;Numerics.Double.parser                            125.000 ns Â±  58.57 %    1000000&#xA;Numerics.Scanner.scanDouble                       167.000 ns Â±  18.84 %    1000000&#xA;Numerics.Comma separated: Double.parser      11313395.500 ns Â±   0.96 %        124&#xA;Numerics.Comma separated: Scanner.scanDouble 50431521.000 ns Â±   0.19 %         28&#xA;Numerics.Comma separated: String.split       18744125.000 ns Â±   0.46 %         75&#xA;PrefixUpTo.Parser: Substring                   249958.000 ns Â±   0.88 %       5595&#xA;PrefixUpTo.Parser: UTF8                         13250.000 ns Â±   2.96 %     105812&#xA;PrefixUpTo.String.range(of:)                    43084.000 ns Â±   1.57 %      32439&#xA;PrefixUpTo.Scanner.scanUpToString               47500.000 ns Â±   1.27 %      29444&#xA;Race.Parser                                     34417.000 ns Â±   2.73 %      40502&#xA;README Example.Parser: Substring                 4000.000 ns Â±   3.79 %     347868&#xA;README Example.Parser: UTF8                      1125.000 ns Â±   7.92 %    1000000&#xA;README Example.Ad hoc                            3542.000 ns Â±   4.13 %     394248&#xA;README Example.Scanner                          14292.000 ns Â±   2.82 %      97922&#xA;String Abstractions.Substring                  934167.000 ns Â±   0.60 %       1505&#xA;String Abstractions.UTF8                       158750.000 ns Â±   1.36 %       8816&#xA;UUID.UUID.init                                    209.000 ns Â±  15.02 %    1000000&#xA;UUID.UUID.parser                                  208.000 ns Â±  24.17 %    1000000&#xA;Xcode Logs.Parser                             3768437.500 ns Â±   0.56 %        372&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The documentation for releases and main are available here:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pointfreeco.github.io/swift-parsing&#34;&gt;main&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pointfreeco.github.io/swift-parsing/0.10.0/documentation/parsing&#34;&gt;0.10.0&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Other versions &lt;/summary&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://pointfreeco.github.io/swift-parsing/0.9.0/documentation/parsing&#34;&gt;0.9.0&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://pointfreeco.github.io/swift-parsing/0.8.0/documentation/parsing&#34;&gt;0.8.0&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://pointfreeco.github.io/swift-parsing/0.7.1/documentation/parsing&#34;&gt;0.7.1&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://pointfreeco.github.io/swift-parsing/0.7.0/documentation/parsing&#34;&gt;0.7&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://pointfreeco.github.io/swift-parsing/0.6.0/documentation/parsing&#34;&gt;0.6&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://pointfreeco.github.io/swift-parsing/0.5.0/documentation/parsing&#34;&gt;0.5&lt;/a&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Other libraries&lt;/h2&gt; &#xA;&lt;p&gt;There are a few other parsing libraries in the Swift community that you might also be interested in:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nicklockwood/Consumer&#34;&gt;Consumer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/johnpatrickmorgan/Sparse&#34;&gt;Sparse&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/davedufresne/SwiftParsec&#34;&gt;SwiftParsec&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The printing functionality in this library is inspired by the paper &lt;a href=&#34;https://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf&#34;&gt;&#34;Invertible syntax descriptions: Unifying parsing and pretty printing&#34;&lt;/a&gt;, by Tillmann Rendel and Klaus Ostermann.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is released under the MIT license. See &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-parsing/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
</feed>