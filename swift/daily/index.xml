<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-29T01:40:47Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>powenn/ModMyIPA</title>
    <updated>2022-10-29T01:40:47Z</updated>
    <id>tag:github.com,2022-10-29:/powenn/ModMyIPA</id>
    <link href="https://github.com/powenn/ModMyIPA" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An app to modify ipa files so you can multiple install the same app&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ModMyIPA&lt;/h1&gt; &#xA;&lt;h2&gt;An app to modify ipa files so you can multiple install the same app&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/powenn/ModMyIPA/raw/main/Screenshots/01.png&#34; alt=&#34;screenshot&#34;&gt; &lt;img src=&#34;https://github.com/powenn/ModMyIPA/raw/main/Screenshots/02.png&#34; alt=&#34;screenshot&#34;&gt; &lt;img src=&#34;https://github.com/powenn/ModMyIPA/raw/main/Screenshots/03.png&#34; alt=&#34;screenshot&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>pointfreeco/swift-clocks</title>
    <updated>2022-10-29T01:40:47Z</updated>
    <id>tag:github.com,2022-10-29:/pointfreeco/swift-clocks</id>
    <link href="https://github.com/pointfreeco/swift-clocks" rel="alternate"></link>
    <summary type="html">&lt;p&gt;⏰ A few clocks that make working with Swift concurrency more testable and more versatile.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;swift-clocks&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pointfreeco/swift-clocks/actions?query=workflow%3ACI&#34;&gt;&lt;img src=&#34;https://github.com/pointfreeco/swift-clocks/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-clocks&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-clocks%2Fbadge%3Ftype%3Dswift-versions&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-clocks&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-clocks%2Fbadge%3Ftype%3Dplatforms&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;⏰ A few clocks that make working with Swift concurrency more testable and more versatile.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/#motivation&#34;&gt;Motivation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/#learn-more&#34;&gt;Learn more&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/#testclock&#34;&gt;&lt;code&gt;TestClock&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/#immediateclock&#34;&gt;&lt;code&gt;ImmediateClock&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/#unimplementedclock&#34;&gt;&lt;code&gt;UnimplementedClock&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/#timers&#34;&gt;Timers&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/#documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/#License&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Learn More&lt;/h2&gt; &#xA;&lt;p&gt;This library was designed in episodes on &lt;a href=&#34;https://www.pointfree.co&#34;&gt;Point-Free&lt;/a&gt;, a video series exploring the Swift programming language hosted by &lt;a href=&#34;https://github.com/mbrandonw&#34;&gt;Brandon Williams&lt;/a&gt; and &lt;a href=&#34;https://github.com/stephencelis&#34;&gt;Stephen Celis&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can watch all of the episodes &lt;a href=&#34;https://www.pointfree.co/collections/concurrency/clocks&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;a href=&#34;https://www.pointfree.co/collections/concurrency/clocks&#34;&gt; &lt;img alt=&#34;video poster image&#34; src=&#34;https://i.vimeocdn.com/video/1524033919-5201b27e94ead2d18805eae70faf0282028d27c926bfaa5423d9d28fa1f72301-d&#34; width=&#34;480&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;Clock&lt;/code&gt; protocol in Swift provides a powerful abstraction for time-based asynchrony in Swift&#39;s structured concurrency. With just a single &lt;code&gt;sleep&lt;/code&gt; method you can express many powerful async operators, such as timers, &lt;code&gt;debounce&lt;/code&gt;, &lt;code&gt;throttle&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt; and more (see &lt;a href=&#34;http://github.com/apple/swift-async-algorithms&#34;&gt;swift-async-algorithms&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;However, the moment you use a concrete clock in your asynchronous code, or use &lt;code&gt;Task.sleep&lt;/code&gt; directly, you instantly lose the ability to easily test and preview your features, forcing you to wait for real world time to pass to see how your feature works.&lt;/p&gt; &#xA;&lt;p&gt;This library provides new &lt;code&gt;Clock&lt;/code&gt; conformances that allow you to turn any time-based asynchronous code into something that is easier to test and debug:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/#TestClock&#34;&gt;TestClock&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/#ImmediateClock&#34;&gt;ImmediateClock&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/#UnimplementedClock&#34;&gt;UnimplementedClock&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/#Timers&#34;&gt;Timers&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;TestClock&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A clock whose time can be controlled in a deterministic manner.&lt;/p&gt; &#xA;&lt;p&gt;This clock is useful for testing how the flow of time affects asynchronous and concurrent code. This includes any code that makes use of &lt;code&gt;sleep&lt;/code&gt; or any time-based async operators, such as &lt;code&gt;debounce&lt;/code&gt;, &lt;code&gt;throttle&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt;, and more.&lt;/p&gt; &#xA;&lt;p&gt;For example, suppose you have a model that encapsulates the behavior of a timer that be started and stopped, and with each tick of the timer a count value was incremented:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@MainActor&#xA;class FeatureModel: ObservableObject {&#xA;  @Published var count = 0&#xA;  let clock: any Clock&amp;lt;Duration&amp;gt;&#xA;  var timerTask: Task&amp;lt;Void, Error&amp;gt;?&#xA;&#xA;  init(clock: any Clock&amp;lt;Duration&amp;gt;) {&#xA;    self.clock = clock&#xA;  }&#xA;  func startTimerButtonTapped() {&#xA;    self.timerTask = Task {&#xA;      while true {&#xA;        try await self.clock.sleep(for: .seconds(1))&#xA;        self.count += 1&#xA;      }&#xA;    }&#xA;  }&#xA;  func stopTimerButtonTapped() {&#xA;    self.timerTask?.cancel()&#xA;    self.timerTask = nil&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we have explicitly forced a clock to be provided in order to construct the &lt;code&gt;FeatureModel&lt;/code&gt;. This makes it possible to use a real life clock, such as &lt;code&gt;ContinuousClock&lt;/code&gt;, when running on a device or simulator, and use a more controllable clock in tests, such as the &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/todo&#34;&gt;&lt;code&gt;TestClock&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To write a test for this feature we can construct a &lt;code&gt;FeatureModel&lt;/code&gt; with a &lt;code&gt;TestClock&lt;/code&gt;, then advance the clock forward and assert on how the model changes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func testTimer() async {&#xA;  let clock = TestClock()&#xA;  let model = FeatureModel(clock: clock)&#xA;&#xA;  XCTAssertEqual(model.count, 0)&#xA;  model.startTimerButtonTapped()&#xA;&#xA;  // Advance the clock 1 second and prove that the model&#39;s&#xA;  // count incremented by one.&#xA;  await clock.advance(by: .seconds(1))&#xA;  XCTAssertEqual(model.count, 1)&#xA;&#xA;  // Advance the clock 4 seconds and prove that the model&#39;s&#xA;  // count incremented by 4.&#xA;  await clock.advance(by: .seconds(4))&#xA;  XCTAssertEqual(model.count, 5)&#xA;&#xA;  // Stop the timer, run the clock until there is no more&#xA;  // suspensions, and prove that the count did not increment.&#xA;  model.stopTimerButtonTapped()&#xA;  await clock.run()&#xA;  XCTAssertEqual(model.count, 5)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This test is easy to write, passes deterministically, and takes a fraction of a second to run. If you were to use a concrete clock in your feature, such a test would be difficult to write. You would have to wait for real time to pass, slowing down your test suite, and you would have to take extra care to allow for the inherent imprecision in time-based asynchrony so that you do not have flakey tests.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;ImmediateClock&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A clock that does not suspend when sleeping.&lt;/p&gt; &#xA;&lt;p&gt;This clock is useful for squashing all of time down to a single instant, forcing any &lt;code&gt;sleep&lt;/code&gt;s to execute immediately. For example, suppose you have a feature that needs to wait 5 seconds before performing some action, like showing a welcome message:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Feature: View {&#xA;  @State var message: String?&#xA;&#xA;  var body: some View {&#xA;    VStack {&#xA;      if let message = self.message {&#xA;        Text(self.message)&#xA;      }&#xA;    }&#xA;    .task {&#xA;      do {&#xA;        try await Task.sleep(for: .seconds(5))&#xA;        self.message = &#34;Welcome!&#34;&#xA;      } catch {}&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is currently using a real life clock by calling out to &lt;code&gt;Task.sleep&lt;/code&gt;, which means every change you make to the styling and behavior of this feature you must wait for 5 real life seconds to pass before you see the effect. This will severely hurt you ability to quickly iterate on the feature in an Xcode preview.&lt;/p&gt; &#xA;&lt;p&gt;The fix is to have your view hold onto a clock so that it can be controlled from the outside:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Feature: View {&#xA;  @State var message: String?&#xA;  let clock: any Clock&amp;lt;Duration&amp;gt;&#xA;&#xA;  var body: some View {&#xA;    VStack {&#xA;      if let message = self.message {&#xA;        Text(self.message)&#xA;      }&#xA;    }&#xA;    .task {&#xA;      do {&#xA;        try await self.clock.sleep(for: .seconds(5))&#xA;        self.message = &#34;Welcome!&#34;&#xA;      } catch {}&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can construct this view with a &lt;code&gt;ContinuousClock&lt;/code&gt; when running on a device or simulator, and use an &lt;code&gt;ImmediateClock&lt;/code&gt; when running in an Xcode preview:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Feature_Previews: PreviewProvider {&#xA;  static var previews: some View {&#xA;    Feature(clock: ImmediateClock())&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now the welcome message will be displayed immediately with every change made to the view. No need to wait for 5 real world seconds to pass.&lt;/p&gt; &#xA;&lt;p&gt;You can also propagate a clock to a SwiftUI view via the &lt;code&gt;continuousClock&lt;/code&gt; and &lt;code&gt;suspendingClock&lt;/code&gt; environment values that ship with the library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Feature: View {&#xA;  @State var message: String?&#xA;  @Environment(\.continuousClock) var clock&#xA;&#xA;  var body: some View {&#xA;    VStack {&#xA;      if let message = self.message {&#xA;        Text(self.message)&#xA;      }&#xA;    }&#xA;    .task {&#xA;      do {&#xA;        try await self.clock.sleep(for: .seconds(5))&#xA;        self.message = &#34;Welcome!&#34;&#xA;      } catch {}&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;struct Feature_Previews: PreviewProvider {&#xA;  static var previews: some View {&#xA;    Feature()&#xA;      .environment(\.continuousClock, ImmediateClock())&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;UnimplementedClock&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A clock that causes an XCTest failure when any of its endpoints are invoked.&lt;/p&gt; &#xA;&lt;p&gt;This clock is useful when a clock dependency must be provided to test a feature, but you don&#39;t actually expect the clock to be used in the particular execution flow you are exercising.&lt;/p&gt; &#xA;&lt;p&gt;For example, consider the following model that encapsulates the behavior of being able to increment and decrement a count, as well as starting and stopping a timer that increments the counter every second:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@MainActor&#xA;class FeatureModel: ObservableObject {&#xA;  @Published var count = 0&#xA;  let clock: any Clock&amp;lt;Duration&amp;gt;&#xA;  var timerTask: Task&amp;lt;Void, Error&amp;gt;?&#xA;&#xA;  init(clock: any Clock&amp;lt;Duration&amp;gt;) {&#xA;    self.clock = clock&#xA;  }&#xA;  func incrementButtonTapped() {&#xA;    self.count += 1&#xA;  }&#xA;  func decrementButtonTapped() {&#xA;    self.count -= 1&#xA;  }&#xA;  func startTimerButtonTapped() {&#xA;    self.timerTask = Task {&#xA;      for await _ in self.clock.timer(interval: .seconds(1)) {&#xA;        self.count += 1&#xA;      }&#xA;    }&#xA;  }&#xA;  func stopTimerButtonTapped() {&#xA;    self.timerTask?.cancel()&#xA;    self.timerTask = nil&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we test the flow of the user incrementing and decrementing the count, there is no need for the clock. We don&#39;t expect any time-based asynchrony to occur. To make this clear, we can use an &lt;code&gt;UnimplementedClock&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func testIncrementDecrement() {&#xA;  let model = FeatureModel(clock: UnimplementedClock())&#xA;&#xA;  XCTAssertEqual(model.count, 0)&#xA;  self.model.incrementButtonTapped()&#xA;  XCTAssertEqual(model.count, 1)&#xA;  self.model.decrementButtonTapped()&#xA;  XCTAssertEqual(model.count, 0)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If this test passes it definitively proves that the clock is not used at all in the user flow being tested, making this test stronger. If in the future the increment and decrement endpoints start making use of time-based asynchrony using the clock, we will be instantly notified by test failures. This will help us find the tests that should be updated to assert on the new behavior in the feature.&lt;/p&gt; &#xA;&lt;h3&gt;Timers&lt;/h3&gt; &#xA;&lt;p&gt;All clocks now come with a method that allows you to create an &lt;code&gt;AsyncSequence&lt;/code&gt;-based timer on an interval specified by a duration. This allows you to handle timers with simple &lt;code&gt;for await&lt;/code&gt; syntax, such as this observable object that exposes the ability to start and stop a timer for incrementing a value every second:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@MainActor&#xA;class FeatureModel: ObservableObject {&#xA;  @Published var count = 0&#xA;  let clock: any Clock&amp;lt;Duration&amp;gt;&#xA;  var timerTask: Task&amp;lt;Void, Error&amp;gt;?&#xA;&#xA;  init(clock: any Clock&amp;lt;Duration&amp;gt;) {&#xA;    self.clock = clock&#xA;  }&#xA;  func startTimerButtonTapped() {&#xA;    self.timerTask = Task {&#xA;      for await _ in self.clock.timer(interval: .seconds(1)) {&#xA;        self.count += 1&#xA;      }&#xA;    }&#xA;  }&#xA;  func stopTimerButtonTapped() {&#xA;    self.timerTask?.cancel()&#xA;    self.timerTask = nil&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This feature can also be easily tested by making use of the &lt;code&gt;TestClock&lt;/code&gt; discussed above:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func testTimer() async {&#xA;  let clock = TestClock()&#xA;  let model = FeatureModel(clock: clock)&#xA;&#xA;  XCTAssertEqual(model.count, 0)&#xA;  model.startTimerButtonTapped()&#xA;&#xA;  await clock.advance(by: .seconds(1))&#xA;  XCTAssertEqual(model.count, 1)&#xA;&#xA;  await clock.advance(by: .seconds(4))&#xA;  XCTAssertEqual(model.count, 5)&#xA;&#xA;  model.stopTimerButtonTapped()&#xA;  await clock.run()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The latest documentation for this library is available &lt;a href=&#34;http://pointfreeco.github.io/swift-clocks/main/documentation/clocks&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is released under the MIT license. See &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-clocks/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
</feed>