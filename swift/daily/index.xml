<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-17T01:46:51Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rechsteiner/Parchment</title>
    <updated>2023-11-17T01:46:51Z</updated>
    <id>tag:github.com,2023-11-17:/rechsteiner/Parchment</id>
    <link href="https://github.com/rechsteiner/Parchment" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A paging view with a highly customizable menu ✨&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/.images/title-light-mode.png#gh-light-mode-only&#34; width=&#34;240&#34; height=&#34;70&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/.images/title-dark-mode.png#gh-dark-mode-only&#34; width=&#34;240&#34; height=&#34;70&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#getting-started&#34;&gt;Getting Started&lt;/a&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#customization&#34;&gt;Customization&lt;/a&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/strong&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/rechsteiner/Parchment/actions/workflows/parchment.yml&#34;&gt;&lt;img src=&#34;https://github.com/rechsteiner/Parchment/actions/workflows/parchment.yml/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; ✨ &lt;strong&gt;New beta is out!&lt;/strong&gt; Features a new and improved API for SwiftUI &lt;a href=&#34;https://github.com/rechsteiner/Parchment/releases/tag/v4.0.0-beta&#34;&gt;Try it now.&lt;/a&gt; &lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/.images/example-cities.gif&#34; alt=&#34;Cities Example&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/.images/example-unsplash.gif&#34; alt=&#34;Unsplash Example&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/.images/example-calendar.gif&#34; alt=&#34;Calendar Example&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Parchment lets you page between view controllers while showing any type of generic indicator that scrolls along with the content. Here are some benefits of using Parchment:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Highly customizable&lt;/strong&gt; &lt;br&gt; The menu items are built using &lt;code&gt;UICollectionView&lt;/code&gt;, which means you can display pretty much whatever you want. You can even subclass the layout to create completely custom behaviours.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Memory-efficient&lt;/strong&gt;: &lt;br&gt; Parchment only allocates view controllers when they’re needed, meaning if you have a lot of view controllers you don’t have to initialize them all up-front.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Infinite scrolling&lt;/strong&gt;: &lt;br&gt; Because view controllers are only allocated as you are scrolling, you can create data sources that are infinitely large. This is perfect for things like &lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/Documentation/infinite-data-source.md&#34;&gt;calendars&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#getting-started&#34;&gt;Getting started&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#basic-usage&#34;&gt;Basic usage&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#data-source&#34;&gt;Data source&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#infinite-data-source&#34;&gt;Infinite data source&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#selecting-items&#34;&gt;Selecting items&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#reloading-data&#34;&gt;Reloading data&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#delegate&#34;&gt;Delegate&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#size-delegate&#34;&gt;Size delegate&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#selecting-items&#34;&gt;Selecting items&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#customization&#34;&gt;Customization&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#changelog&#34;&gt;Changelog&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#licence&#34;&gt;Licence&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;h3&gt;Basic usage&lt;/h3&gt; &#xA;&lt;p&gt;Parchment is built around the &lt;code&gt;PagingViewController&lt;/code&gt; class. You can initialize it with an array of view controllers and it will display menu items for each view controller using their &lt;code&gt;title&lt;/code&gt; property.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let firstViewController = UIViewController()&#xA;let secondViewController = UIViewController()&#xA;&#xA;let pagingViewController = PagingViewController(viewControllers: [&#xA;  firstViewController,&#xA;  secondViewController&#xA;])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See more: &lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/Documentation/basic-usage.md&#34;&gt;Basic usage&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Data source&lt;/h3&gt; &#xA;&lt;p&gt;Initializing &lt;code&gt;PagingViewController&lt;/code&gt; with an array of view controllers is fine in most cases, but if you have more than a few view controllers you probably don&#39;t want to allocate them all up-front. If you&#39;re going to display a fixed number of view controllers, you can setup your own data source by implementing &lt;code&gt;PagingViewControllerDataSource&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;extension ViewController: PagingViewControllerDataSource {&#xA;    func numberOfViewControllers(in pagingViewController: PagingViewController) -&amp;gt; Int {&#xA;        return 10&#xA;    }&#xA;&#xA;    func pagingViewController(_ pagingViewController: PagingViewController, viewControllerAt index: Int) -&amp;gt; UIViewController {&#xA;        return ChildViewController(index: index)&#xA;    }&#xA;&#xA;    func pagingViewController(_: PagingViewController, pagingItemAt index: Int) -&amp;gt; PagingItem {&#xA;        return PagingIndexItem(title: &#34;View \(index)&#34;, index: index)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you need to set the &lt;code&gt;dataSource&lt;/code&gt; property and select the initial item:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let pagingViewController = PagingViewController()&#xA;pagingViewController.dataSource = self&#xA;pagingViewController.select(index: 0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using the data source means Parchment will only allocate view controllers for the currently selected item and any of its siblings. This is a lot more memory efficient than using &lt;code&gt;PagingViewController(viewControllers:)&lt;/code&gt; if you have many view controllers.&lt;/p&gt; &#xA;&lt;p&gt;Read more: &lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/Documentation/data-source.md&#34;&gt;Using the data source&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Infinite data source&lt;/h3&gt; &#xA;&lt;p&gt;Using &lt;code&gt;PagingViewControllerDataSource&lt;/code&gt; means you need to know how many view controllers to display. If you’re creating something like a calendar, the number of view controllers can be infinitely large. In that case you can use the &lt;code&gt;PagingViewControllerInfiniteDataSource&lt;/code&gt; protocol:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;extension ViewController: PagingViewControllerInfiniteDataSource {&#xA;    func pagingViewController(_: PagingViewController, viewControllerFor pagingItem: PagingItem) -&amp;gt; UIViewController {&#xA;        return ItemViewController(item: pagingItem)&#xA;    }&#xA;&#xA;    func pagingViewController(_: PagingViewController, itemBefore pagingItem: PagingItem) -&amp;gt; PagingItem? {&#xA;        guard let item = pagingItem as? Item else { return nil }&#xA;        return Item(index: item.index - 1)&#xA;    }&#xA;&#xA;    func pagingViewController(_ : PagingViewController, itemAfter pagingItem: PagingItem) -&amp;gt; PagingItem? {&#xA;        guard let item = pagingItem as? Item else { return nil }&#xA;        return Item(index: item.index + 1)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then set the &lt;code&gt;infiniteDataSource&lt;/code&gt; property and select the initial item:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let pagingViewController = PagingViewController()&#xA;pagingViewController.infiniteDataSource = self&#xA;pagingViewController.select(pagingItem: Item(index: 0))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This pattern is very similar to the &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIPageViewControllerClassReferenceClassRef/&#34;&gt;UIPageViewControllerDataSource&lt;/a&gt; protocol. The main difference is that instead of returning view controllers directly, you have to return an instance conforming to the &lt;code&gt;PagingItem&lt;/code&gt; protocol. Parchment will recursively call these methods for the selected &lt;code&gt;PagingItem&lt;/code&gt; until the available space is filled up.&lt;/p&gt; &#xA;&lt;p&gt;Read more: &lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/Documentation/infinite-data-source.md&#34;&gt;Using the infinite data source&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Selecting items&lt;/h3&gt; &#xA;&lt;p&gt;You can select items programatically using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func select(pagingItem: PagingItem, animated: Bool = false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let’s say you want to select the first item:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;override func viewDidLoad() {&#xA;  super.viewDidLoad()&#xA;  if let first = pagingViewController.children.first as? PagingItem {&#xA;    pagingViewController.select(pagingItem: first)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or if you have set the &lt;code&gt;dateSource&lt;/code&gt; property, you can select items based on their index:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func select(index: Int, animated: Bool = false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reloading data&lt;/h3&gt; &#xA;&lt;p&gt;You can reload data using this method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func reloadData()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will keep the previously selected item if it&#39;s still part of the updated data. If not, it will select the first item in the list. It will also reload the view controllers displayed in the page view controller. If you only want to reload the menu items, you can use this method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func reloadMenu()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Calling &lt;code&gt;reloadData()&lt;/code&gt; will not work when using &lt;code&gt;PagingViewControllerInfiniteDataSource&lt;/code&gt;, as we then need to know what the initial item should be. In that case you should use this method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func reloadData(around: PagingItem)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will mark the given paging item as selected and generate new items around it.&lt;/p&gt; &#xA;&lt;h3&gt;Delegate&lt;/h3&gt; &#xA;&lt;p&gt;Parchment provides delegate methods for every step of the transition process through the &lt;code&gt;PagingViewControllerDelegate&lt;/code&gt; protocol.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;protocol PagingViewControllerDelegate: class {&#xA;&#xA;    func pagingViewController(&#xA;        _: PagingViewController,&#xA;        isScrollingFromItem currentPagingItem: PagingItem,&#xA;        toItem upcomingPagingItem: PagingItem?,&#xA;        startingViewController: UIViewController,&#xA;        destinationViewController: UIViewController?,&#xA;        progress: CGFloat)&#xA;&#xA;    func pagingViewController(&#xA;        _: PagingViewController,&#xA;        willScrollToItem pagingItem: PagingItem,&#xA;        startingViewController: UIViewController,&#xA;        destinationViewController: UIViewController)&#xA;&#xA;    func pagingViewController(&#xA;        _ pagingViewController: PagingViewController,&#xA;        didScrollToItem pagingItem: PagingItem,&#xA;        startingViewController: UIViewController?,&#xA;        destinationViewController: UIViewController,&#xA;        transitionSuccessful: Bool)&#xA;&#xA;    func pagingViewController(&#xA;        _ pagingViewController: PagingViewController,&#xA;        didSelectItem pagingItem: PagingItem)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Size delegate&lt;/h3&gt; &#xA;&lt;p&gt;By default, the size of the menu items is controlled by the &lt;code&gt;menuItemSize&lt;/code&gt; property. If you need to control width of each menu item individually you can use the &lt;code&gt;PagingControllerSizeDelegate&lt;/code&gt; protocol:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;protocol PagingViewControllerSizeDelegate: class {&#xA;    func pagingViewController(&#xA;        _: PagingViewController,&#xA;        widthForPagingItem pagingItem: PagingItem,&#xA;        isSelected: Bool) -&amp;gt; CGFloat&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then set the &lt;code&gt;sizeDelegate&lt;/code&gt; on the &lt;code&gt;PagingViewController&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let pagingViewController = PagingViewController()&#xA;pagingViewController.sizeDelegate = self&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Customization&lt;/h2&gt; &#xA;&lt;p&gt;Parchment is built to be very flexible. The menu items are displayed using UICollectionView, so they can display pretty much whatever you want. If you need any further customization you can even subclass the collection view layout. All customization is handled by the properties listed below.&lt;/p&gt; &#xA;&lt;h3&gt;Custom cells&lt;/h3&gt; &#xA;&lt;p&gt;To use custom cells you need to subclass &lt;code&gt;PagingCell&lt;/code&gt; and register the cell type for a given &lt;code&gt;PagingItem&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let pagingViewController = PagingViewController()&#xA;pagingViewController.register(CalendarPagingCell.self, for: CalendarItem.self)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Parchment will then dequeue your custom cell when you return the given &lt;code&gt;PagingItem&lt;/code&gt; in your data source. You can register multiple cell types for different &lt;code&gt;PagingItem&lt;/code&gt;s.&lt;/p&gt; &#xA;&lt;h3&gt;Properties&lt;/h3&gt; &#xA;&lt;p&gt;All customization properties are set on &lt;code&gt;PagingViewController&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let pagingViewController = PagingViewController()&#xA;pagingViewController.menuItemSize = .fixed(width: 40, height: 40)&#xA;pagingViewController.menuItemSpacing = 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;menuItemSize&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The size of the menu items. When using &lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/#size-delegate&#34;&gt;&lt;code&gt;sizeDelegate&lt;/code&gt;&lt;/a&gt; the width will be ignored.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;enum PagingMenuItemSize {&#xA;  case fixed(width: CGFloat, height: CGFloat)&#xA;&#xA;  // Automatically calculate the size of the menu items based on the&#xA;  // cells intrinsic content size. Try to come up with an estimated&#xA;  // width that&#39;s similar to the expected width of the cells.&#xA;  case selfSizing(estimatedWidth: CGFloat, height: CGFloat)&#xA;&#xA;  // Tries to fit all menu items inside the bounds of the screen.&#xA;  // If the items can&#39;t fit, the items will scroll as normal and&#xA;  // set the menu items width to `minWidth`.&#xA;  case sizeToFit(minWidth: CGFloat, height: CGFloat)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;.sizeToFit(minWidth: 150, height: 40)&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;menuItemSpacing&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The spacing between the menu items.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;0&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;menuItemLabelSpacing&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The horizontal constraints of menu item label.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;20&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;menuInsets&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The insets around all of the menu items.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;UIEdgeInsets()&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;menuHorizontalAlignment&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;enum PagingMenuHorizontalAlignment {&#xA;  case `default`&#xA;&#xA;  // Allows all paging items to be centered within the paging menu&#xA;  // when PagingMenuItemSize is .fixed and the sum of the widths&#xA;  // of all the paging items are less than the paging menu&#xA;  case center&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;.default&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;menuTransition&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Determine the transition behaviour of menu items while scrolling the content.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;enum PagingMenuTransition {&#xA;  // Update scroll offset based on how much the content has&#xA;  // scrolled. Makes the menu items transition smoothly as you scroll.&#xA;  case scrollAlongside&#xA;&#xA;  // Animate the menu item position after a transition has completed.&#xA;  case animateAfter&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;.scrollAlongside&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;menuInteraction&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Determine how users can interact with the menu items.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;enum PagingMenuInteraction {&#xA;  case scrolling&#xA;  case swipe&#xA;  case none&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;.scrolling&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;menuLayoutClass&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The class type for collection view layout. Override this if you want to use your own subclass of the layout. Setting this property will initialize the new layout type and update the collection view.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;PagingCollectionViewLayout.Type&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;selectedScrollPosition&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Determine how the selected menu item should be aligned when it is selected. Effectively the same as the &lt;code&gt;UICollectionViewScrollPosition&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;enum PagingSelectedScrollPosition {&#xA;  case left&#xA;  case right&#xA;&#xA;  // Centers the selected menu item where possible. If the item is&#xA;  // to the far left or right, it will not update the scroll position.&#xA;  // Effectivly the same as .centeredHorizontally on UIScrollView.&#xA;  case preferCentered&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;.preferCentered&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;indicatorOptions&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Add an indicator view to the selected menu item. The indicator width will be equal to the selected menu items width. Insets only apply horizontally.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;enum PagingIndicatorOptions {&#xA;  case hidden&#xA;  case visible(&#xA;    height: CGFloat,&#xA;    zIndex: Int,&#xA;    spacing: UIEdgeInsets,&#xA;    insets: UIEdgeInsets)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Default:&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;.visible(&#xA;  height: 4,&#xA;  zIndex: Int.max,&#xA;  spacing: UIEdgeInsets.zero,&#xA;  insets: UIEdgeInsets(top: 0, left: 8, bottom: 0, right: 8))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;indicatorClass&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The class type for the indicator view. Override this if you want your use your own subclass of &lt;code&gt;PagingIndicatorView&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;PagingIndicatorView.self&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;indicatorColor&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The background color for the indicator view.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;UIColor(red: 3/255, green: 125/255, blue: 233/255, alpha: 1)&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;borderOptions&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Add a border at the bottom of the menu items. The border will be as wide as all the menu items. Insets only apply horizontally.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;enum PagingBorderOptions {&#xA;  case hidden&#xA;  case visible(&#xA;    height: CGFloat,&#xA;    zIndex: Int,&#xA;    insets: UIEdgeInsets)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Default:&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;.visible(&#xA;  height: 1,&#xA;  zIndex: Int.max - 1,&#xA;  insets: UIEdgeInsets(top: 0, left: 8, bottom: 0, right: 8))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;borderClass&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The class type for the border view. Override this if you want your use your own subclass of &lt;code&gt;PagingBorderView&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;PagingBorderView.self&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;borderColor&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The background color for the border view.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;UIColor(white: 0.9, alpha: 1)&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;includeSafeAreaInsets&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Updates the content inset for the menu items based on the &lt;code&gt;.safeAreaInsets&lt;/code&gt; property.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;true&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;font&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The font used for title label on the menu items.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;UIFont.systemFont(ofSize: 15, weight: UIFont.Weight.medium)&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;selectedFont&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The font used for title label on the currently selected menu item.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;UIFont.systemFont(ofSize: 15, weight: UIFont.Weight.medium)&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;textColor&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The color of the title label on the menu items.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;UIColor.black&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;selectedTextColor&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The text color for the currently selected menu item.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;UIColor(red: 3/255, green: 125/255, blue: 233/255, alpha: 1)&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;backgroundColor&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The background color for the menu items.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;UIColor.white&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;selectedBackgroundColor&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The background color for the selected menu item.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;UIColor.clear&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;menuBackgroundColor&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The background color for the view behind the menu items.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Default: &lt;code&gt;UIColor.white&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Parchment will be compatible with the lastest public release of Swift.&lt;/p&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iOS 11.0+&lt;/li&gt; &#xA; &lt;li&gt;Xcode 14.0+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;Parchment is available through &lt;a href=&#34;https://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt;. To install it, add the following to your &lt;code&gt;Podfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod &#39;Parchment&#39;, &#39;~&amp;gt; 3.2&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;Parchment is available through &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;Swift Package Manager&lt;/a&gt;. Add Parchment as a dependency to your &lt;code&gt;Package.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;.package(url: &#34;https://github.com/rechsteiner/Parchment&#34;, from: &#34;3.2.0&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;p&gt;Parchment also supports &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;. To install it, add the following to your &lt;code&gt;Cartfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;rechsteiner/Parchment&#34; ~&amp;gt; 3.2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/Carthage/Carthage#adding-frameworks-to-an-application&#34;&gt;this guide&lt;/a&gt; for more details on using Carthage.&lt;/p&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;This can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;h2&gt;Licence&lt;/h2&gt; &#xA;&lt;p&gt;Parchment is released under the MIT license. See &lt;a href=&#34;https://raw.githubusercontent.com/rechsteiner/Parchment/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
</feed>