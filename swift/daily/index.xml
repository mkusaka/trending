<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-21T01:59:04Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>securing/IOSSecuritySuite</title>
    <updated>2022-07-21T01:59:04Z</updated>
    <id>tag:github.com,2022-07-21:/securing/IOSSecuritySuite</id>
    <link href="https://github.com/securing/IOSSecuritySuite" rel="alternate"></link>
    <summary type="html">&lt;p&gt;iOS platform security &amp; anti-tampering Swift library&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/securing/IOSSecuritySuite/master/logo.png&#34; alt=&#34;ISS logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;by &lt;a href=&#34;https://twitter.com/_r3ggi&#34;&gt;@_r3ggi&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h2&gt;ISS Description&lt;/h2&gt; &#xA;&lt;p&gt;üåè iOS Security Suite is an advanced and easy-to-use platform security &amp;amp; anti-tampering library written in pure Swift! If you are developing for iOS and you want to protect your app according to the OWASP &lt;a href=&#34;https://github.com/OWASP/owasp-masvs&#34;&gt;MASVS&lt;/a&gt; standard, chapter v8, then this library could save you a lot of time. üöÄ&lt;/p&gt; &#xA;&lt;p&gt;What ISS detects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Jailbreak (even the iOS 11+ with brand new indicators! üî•)&lt;/li&gt; &#xA; &lt;li&gt;Attached debugger üë®üèª‚ÄçüöÄ&lt;/li&gt; &#xA; &lt;li&gt;If an app was run in an emulator üëΩ&lt;/li&gt; &#xA; &lt;li&gt;Common reverse engineering tools running on the device üî≠&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;There are 4 ways you can start using IOSSecuritySuite&lt;/p&gt; &#xA;&lt;h3&gt;1. Add source&lt;/h3&gt; &#xA;&lt;p&gt;Add &lt;code&gt;IOSSecuritySuite/*.swift&lt;/code&gt; files to your project&lt;/p&gt; &#xA;&lt;h3&gt;2. Setup with CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;pod &#39;IOSSecuritySuite&#39;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;3. Setup with Carthage&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;github &#34;securing/IOSSecuritySuite&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;4. Setup with Swift Package Manager&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.package(url: &#34;https://github.com/securing/IOSSecuritySuite.git&#34;, from: &#34;1.5.0&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Update Info.plist&lt;/h3&gt; &#xA;&lt;p&gt;After adding ISS to your project, you will also need to update your main Info.plist. There is a check in jailbreak detection module that uses &lt;code&gt;canOpenURL(_:)&lt;/code&gt; method and &lt;a href=&#34;https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl&#34;&gt;requires&lt;/a&gt; specifying URLs that will be queried.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;key&amp;gt;LSApplicationQueriesSchemes&amp;lt;/key&amp;gt;&#xA;&amp;lt;array&amp;gt;&#xA;    &amp;lt;string&amp;gt;undecimus&amp;lt;/string&amp;gt;&#xA;    &amp;lt;string&amp;gt;sileo&amp;lt;/string&amp;gt;&#xA;    &amp;lt;string&amp;gt;zbra&amp;lt;/string&amp;gt;&#xA;    &amp;lt;string&amp;gt;filza&amp;lt;/string&amp;gt;&#xA;    &amp;lt;string&amp;gt;activator&amp;lt;/string&amp;gt;&#xA;&amp;lt;/array&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;h3&gt;Jailbreak detector module&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;The simplest method&lt;/strong&gt; returns True/False if you just want to know if the device is jailbroken or jailed&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;if IOSSecuritySuite.amIJailbroken() {&#xA;&#x9;print(&#34;This device is jailbroken&#34;)&#xA;} else {&#xA;&#x9;print(&#34;This device is not jailbroken&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Verbose&lt;/strong&gt;, if you also want to know what indicators were identified&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let jailbreakStatus = IOSSecuritySuite.amIJailbrokenWithFailMessage()&#xA;if jailbreakStatus.jailbroken {&#xA;&#x9;print(&#34;This device is jailbroken&#34;)&#xA;&#x9;print(&#34;Because: \(jailbreakStatus.failMessage)&#34;)&#xA;} else {&#xA;&#x9;print(&#34;This device is not jailbroken&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The failMessage is a String containing comma-separated indicators as shown on the example below: &lt;code&gt;sileo:// URL scheme detected, Suspicious file exists: /Library/MobileSubstrate/MobileSubstrate.dylib, Fork was able to create a new process&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Verbose &amp;amp; filterable&lt;/strong&gt;, if you also want to for example identify devices that were jailbroken in the past, but now are jailed&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let jailbreakStatus = IOSSecuritySuite.amIJailbrokenWithFailedChecks()&#xA;if jailbreakStatus.jailbroken {&#xA;   if (jailbreakStatus.failedChecks.contains { $0.check == .existenceOfSuspiciousFiles }) &amp;amp;&amp;amp; (jailbreakStatus.failedChecks.contains { $0.check == .suspiciousFilesCanBeOpened }) {&#xA;         print(&#34;This is real jailbroken device&#34;)&#xA;   }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Debugger detector module&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let amIDebugged: Bool = IOSSecuritySuite.amIDebugged()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deny debugger at all&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;IOSSecuritySuite.denyDebugger()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Emulator detector module&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let runInEmulator: Bool = IOSSecuritySuite.amIRunInEmulator()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reverse engineering tools detector module&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let amIReverseEngineered: Bool = IOSSecuritySuite.amIReverseEngineered()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;System proxy detector module&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let amIProxied: Bool = IOSSecuritySuite.amIProxied()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Experimental features&lt;/h2&gt; &#xA;&lt;h3&gt;Runtime hook detector module&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let amIRuntimeHooked: Bool = amIRuntimeHook(dyldWhiteList: dylds, detectionClass: SomeClass.self, selector: #selector(SomeClass.someFunction), isClassMethod: false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Symbol hook deny module&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;// If we want to deny symbol hook of Swift function, we have to pass mangled name of that function&#xA;denySymbolHook(&#34;$s10Foundation5NSLogyySS_s7CVarArg_pdtF&#34;)   // denying hooking for the NSLog function&#xA;NSLog(&#34;Hello Symbol Hook&#34;)&#xA;     &#xA;denySymbolHook(&#34;abort&#34;) &#xA;abort()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MSHook detector module&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;// Function declaration&#xA;func someFunction(takes: Int) -&amp;gt; Bool {&#xA;&#x9;return false&#xA;} &#xA;&#xA;// Defining FunctionType : @convention(thin) indicates a ‚Äúthin‚Äù function reference, which uses the Swift calling convention with no special ‚Äúself‚Äù or ‚Äúcontext‚Äù parameters.&#xA;typealias FunctionType = @convention(thin) (Int) -&amp;gt; (Bool)&#xA;&#xA;// Getting pointer address of function we want to verify&#xA;func getSwiftFunctionAddr(_ function: @escaping FunctionType) -&amp;gt; UnsafeMutableRawPointer {&#xA;&#x9;return unsafeBitCast(function, to: UnsafeMutableRawPointer.self)&#xA;}&#xA;&#xA;let funcAddr = getSwiftFunctionAddr(someFunction)&#xA;let amIMSHooked = IOSSecuritySuite.amIMSHooked(funcAddr)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MSHook deny module&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;// Function declaration&#xA;func denyDebugger(value: Int) {&#xA;}&#xA;&#xA;// Defining FunctionType : @convention(thin) indicates a ‚Äúthin‚Äù function reference, which uses the Swift calling convention with no special ‚Äúself‚Äù or ‚Äúcontext‚Äù parameters.&#xA;typealias FunctionType = @convention(thin) (Int)-&amp;gt;()&#xA;&#xA;// Getting original function address&#xA;let funcDenyDebugger: FunctionType = denyDebugger &#xA;let funcAddr = unsafeBitCast(funcDenyDebugger, to: UnsafeMutableRawPointer.self)&#xA;&#xA;&#xA;if let originalDenyDebugger = denyMSHook(funcAddr) {&#xA;// Call the original function with 1337 as Int argument&#xA;     unsafeBitCast(originalDenyDebugger, to: FunctionType.self)(1337)&#xA; } else {&#xA;     denyDebugger()&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;File integrity verifier module&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;// Determine if application has been tampered with &#xA;if IOSSecuritySuite.amITampered([.bundleID(&#34;biz.securing.FrameworkClientApp&#34;),&#xA;    .mobileProvision(&#34;2976c70b56e9ae1e2c8e8b231bf6b0cff12bbbd0a593f21846d9a004dd181be3&#34;),&#xA;    .machO(&#34;IOSSecuritySuite&#34;, &#34;6d8d460b9a4ee6c0f378e30f137cebaf2ce12bf31a2eef3729c36889158aa7fc&#34;)]).result {&#xA;    print(&#34;I have been Tampered.&#34;)&#xA;}&#xA;else {&#xA;    print(&#34;I have not been Tampered.&#34;)&#xA;}&#xA;&#xA;// Manually verify SHA256 hash value of a loaded dylib&#xA;if let hashValue = IOSSecuritySuite.getMachOFileHashValue(.custom(&#34;IOSSecuritySuite&#34;)), hashValue == &#34;6d8d460b9a4ee6c0f378e30f137cebaf2ce12bf31a2eef3729c36889158aa7fc&#34; {&#xA;    print(&#34;I have not been Tampered.&#34;)&#xA;}&#xA;else {&#xA;    print(&#34;I have been Tampered.&#34;)&#xA;}&#xA; &#xA;// Check SHA256 hash value of the main executable&#xA;// Tip: Your application may retrieve this value from the server&#xA;if let hashValue = IOSSecuritySuite.getMachOFileHashValue(.default), hashValue == &#34;your-application-executable-hash-value&#34; {&#xA;    print(&#34;I have not been Tampered.&#34;)&#xA;}&#xA;else {&#xA;    print(&#34;I have been Tampered.&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Breakpoint detection module&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func denyDebugger() {&#xA;    // Set breakpoint here&#xA;}&#xA;     &#xA;typealias FunctionType = @convention(thin) ()-&amp;gt;()&#xA;let func_denyDebugger: FunctionType = denyDebugger   // `: FunctionType` is a must&#xA;let func_addr = unsafeBitCast(func_denyDebugger, to: UnsafeMutableRawPointer.self)&#xA;let hasBreakpoint = IOSSecuritySuite.hasBreakpointAt(func_addr, functionSize: nil)&#xA;&#xA;if hasBreakpoint {&#xA;    print(&#34;Breakpoint found in the specified function&#34;)&#xA;} else {&#xA;    print(&#34;Breakpoint not found in the specified function&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Watchpoint detection module&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;// Set a breakpoint at the testWatchpoint function&#xA;func testWatchpoint() -&amp;gt; Bool{&#xA;&#x9;&#x9;// lldb: watchpoint set expression ptr&#xA;    var ptr = malloc(9)&#xA;    // lldb: watchpoint set variable count&#xA;    var count = 3&#xA;    return IOSSecuritySuite.hasWatchpoint()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Security considerations&lt;/h2&gt; &#xA;&lt;p&gt;Before using this and other platform security checkers, you have to understand that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Including this tool in your project is not the only thing you should do in order to improve your app security! You can read a general mobile security whitepaper &lt;a href=&#34;https://www.securing.biz/en/mobile-application-security-best-practices/index.html&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Detecting if a device is jailbroken is done locally on the device. It means that every jailbreak detector may be bypassed (even this)!&lt;/li&gt; &#xA; &lt;li&gt;Swift code is considered to be harder to manipulate dynamically than Objective-C. Since this library was written in pure Swift, the IOSSecuritySuite methods shouldn&#39;t be exposed to Objective-C runtime (which makes it more difficult to bypass ‚úÖ). You have to know that attacker is still able to MSHookFunction/MSFindSymbol Swift symbols and dynamically change Swift code execution flow.&lt;/li&gt; &#xA; &lt;li&gt;It&#39;s also a good idea to obfuscate the whole project code, including this library. See &lt;a href=&#34;https://github.com/rockbruno/swiftshield&#34;&gt;Swiftshield&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contribution ‚ù§Ô∏è&lt;/h2&gt; &#xA;&lt;p&gt;Yes, please! If you have a better idea or you just want to improve this project, please text me on &lt;a href=&#34;https://twitter.com/_r3ggi&#34;&gt;Twitter&lt;/a&gt; or &lt;a href=&#34;https://www.linkedin.com/in/wojciech-regula/&#34;&gt;Linkedin&lt;/a&gt;. Pull requests are more than welcome!&lt;/p&gt; &#xA;&lt;h3&gt;Special thanks: üëèüèª&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kubajakowski&#34;&gt;kubajakowski&lt;/a&gt; for pointing out the problem with &lt;code&gt;canOpenURL(_:)&lt;/code&gt; method&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/olbartek&#34;&gt;olbartek&lt;/a&gt; for code review and pull request&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/benbahrenburg&#34;&gt;benbahrenburg&lt;/a&gt; for various ISS improvements&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fotiDim&#34;&gt;fotiDim&lt;/a&gt; for adding new file paths to check&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/gcharita&#34;&gt;gcharita&lt;/a&gt; for adding the Swift Package Manager support&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rynaardb&#34;&gt;rynaardb&lt;/a&gt; for creating the &lt;code&gt;amIJailbrokenWithFailedChecks()&lt;/code&gt; method&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/undeaDD&#34;&gt;undeaDD&lt;/a&gt; for various ISS improvements&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fnxpt&#34;&gt;fnxpt&lt;/a&gt; for adding multiple JB detections&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/TannerJin&#34;&gt;TannerJin&lt;/a&gt; for MSHook, RuntimeHook, SymbolHook and Watchpoint Detection modules&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/NikoXu&#34;&gt;NikoXu&lt;/a&gt; for adding file integrity module&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hellpf&#34;&gt;hellpf&lt;/a&gt; for fixing a dangling socket problem&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Research Installer5 and Zebra Package Manager detection ( Cydia Alternatives )&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;See the LICENSE file.&lt;/p&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;p&gt;While creating this tool I used:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üîó &lt;a href=&#34;https://github.com/TheSwiftyCoder/JailBreak-Detection&#34;&gt;https://github.com/TheSwiftyCoder/JailBreak-Detection&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;üîó &lt;a href=&#34;https://github.com/abhinashjain/jailbreakdetection&#34;&gt;https://github.com/abhinashjain/jailbreakdetection&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;üîó &lt;a href=&#34;https://gist.github.com/ddrccw/8412847&#34;&gt;https://gist.github.com/ddrccw/8412847&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;üîó &lt;a href=&#34;https://gist.github.com/bugaevc/4307eaf045e4b4264d8e395b5878a63b&#34;&gt;https://gist.github.com/bugaevc/4307eaf045e4b4264d8e395b5878a63b&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;üìö &#34;iOS Application Security&#34; by David Thiel&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>