<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-17T01:46:20Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>grishka/NearDrop</title>
    <updated>2023-04-17T01:46:20Z</updated>
    <id>tag:github.com,2023-04-17:/grishka/NearDrop</id>
    <link href="https://github.com/grishka/NearDrop" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An unofficial Google Nearby Share app for macOS&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;NearDrop&lt;/strong&gt; is a partial implementation of &lt;a href=&#34;https://blog.google/products/android/nearby-share/&#34;&gt;Google&#39;s Nearby Share&lt;/a&gt; for macOS.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/grishka/NearDrop/master/PROTOCOL.md&#34;&gt;Protocol documentation&lt;/a&gt; is available separately.&lt;/p&gt; &#xA;&lt;p&gt;The app lives in your menu bar and saves files to your downloads folder. It&#39;s that simple, really.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Receive only&lt;/strong&gt;. For now. I haven&#39;t yet figured out how to make Android turn on the MDNS service and/or show the &#34;a device nearby is sharing&#34; notification.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Wi-Fi LAN only&lt;/strong&gt;. Your Android device and your Mac need to be on the same network for this app to work. Google&#39;s implementation supports multiple mediums, including Wi-Fi Direct, Wi-Fi hotspot, Bluetooth, some kind of 5G peer-to-peer connection, and even a WebRTC-based protocol that goes over the internet through Google servers. Wi-Fi direct isn&#39;t supported on macOS (Apple has their own, incompatible, AWDL thing, used in AirDrop). Bluetooth needs further reverse engineering.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Visible to everyone on your network at all times&lt;/strong&gt; while the app is running. Limited visibility (contacts etc) requires talking to Google servers, and becoming temporarily visible requires listening for whatever triggers the &#34;device nearby is sharing&#34; notification.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Download the latest build from the releases section, unzip, move to your applications folder. When running for the first time, right-click the app and select &#34;Open&#34;, then confirm running an app from unidentified developer.&lt;/p&gt; &#xA;&lt;p&gt;If you want the app to start on boot, add it manually to login objects in System Preferences.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Pull requests that change the readme will not be accepted.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h4&gt;Why is the app not notarized?&lt;/h4&gt; &#xA;&lt;p&gt;Because I don&#39;t want to pay Apple $99 a year for the privilege of developing macOS apps and oppose their idea of security.&lt;/p&gt; &#xA;&lt;h4&gt;Why is this not on the app store?&lt;/h4&gt; &#xA;&lt;p&gt;Because I don&#39;t want to pay Apple $99 a year for the privilege of developing macOS apps. I also don&#39;t want to have to go through the review process.&lt;/p&gt; &#xA;&lt;h4&gt;Why not the other way around, i.e. AirDrop on Android?&lt;/h4&gt; &#xA;&lt;p&gt;While I am an Android developer, and I have looked into this, this is nigh-impossible. AirDrop uses &lt;a href=&#34;https://stackoverflow.com/questions/19587701/what-is-awdl-apple-wireless-direct-link-and-how-does-it-work&#34;&gt;AWDL&lt;/a&gt;, Apple&#39;s own proprietary take on peer-to-peer Wi-Fi. This works on top of 802.11 itself, the low-level Wi-Fi protocol, and thus can not be implemented without messing around with the Wi-Fi adapter drivers and raw packets and all that. It might be possible on Android, but it would at the very least require root and possibly a custom kernel. There is &lt;a href=&#34;https://owlink.org/code/&#34;&gt;an open-source implementation of AWDL and AirDrop for Linux&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mergesort/Boutique</title>
    <updated>2023-04-17T01:46:20Z</updated>
    <id>tag:github.com,2023-04-17:/mergesort/Boutique</id>
    <link href="https://github.com/mergesort/Boutique" rel="alternate"></link>
    <summary type="html">&lt;p&gt;✨ A magical persistence library (and so much more) for state-driven iOS and Mac apps ✨&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mergesort/Boutique/main/Images/logo.jpg&#34; alt=&#34;Boutique Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;A simple but surprisingly fancy data store and so much more&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;&#34;I ripped out Core Data, this is the way it should work&#34;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;— &lt;a href=&#34;https://github.com/joshdholtz&#34;&gt;Josh Holtz&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;&#34;Boutique is ridiculously easy to implement and makes persistence a breeze. It&#39;s become my first addition to every project I start.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;— &lt;a href=&#34;https://github.com/thillsman&#34;&gt;Tyler Hillsman&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;&#34;Boutique has become invaluable, I use it in every side project now. Not having to care about persistence is great and the cost of getting started is practically zero.&#34;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;— &lt;a href=&#34;https://github.com/palleas&#34;&gt;Romain Pouclet&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you find Boutique valuable I would really appreciate it if you would consider helping &lt;a href=&#34;https://github.com/sponsors/mergesort&#34;&gt;sponsor my open source work&lt;/a&gt;, so I can continue to work on projects like Boutique to help developers like yourself.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Boutique is a simple but powerful persistence library, a small set of property wrappers and types that enable building incredibly simple state-driven apps for SwiftUI, UIKit, and AppKit. With its dual-layered memory + disk caching architecture Boutique provides a way to build apps that update in real time with full offline storage in only a few lines of code using an incredibly simple API. Boutique is built atop &lt;a href=&#34;https://github.com/mergesort/Bodega&#34;&gt;Bodega&lt;/a&gt;, and you can find a demo app built atop the Model View Controller Store architecture in this &lt;a href=&#34;https://github.com/mergesort/Boutique/tree/main/Demo&#34;&gt;repo&lt;/a&gt; which shows you how to make an offline-ready SwiftUI app in only a few lines of code. You can read more about the thinking behind the architecture in this blog post exploring the &lt;a href=&#34;https://build.ms/2022/06/22/model-view-controller-store&#34;&gt;MVCS architecture&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mergesort/Boutique/main/#getting-started&#34;&gt;Getting Started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mergesort/Boutique/main/#store&#34;&gt;Store&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mergesort/Boutique/main/#the-magic-of-stored&#34;&gt;The Magic Of @Stored&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mergesort/Boutique/main/#storedvalue--asyncstoredvalue&#34;&gt;@StoredValue &amp;amp; @AsyncStoredValue&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mergesort/Boutique/main/#documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mergesort/Boutique/main/#further-exploration&#34;&gt;Further Exploration&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Getting Started&lt;/h3&gt; &#xA;&lt;p&gt;Boutique only has one concept you need to understand. When you save data to the &lt;code&gt;Store&lt;/code&gt; your data will be persisted automatically for you and exposed as a regular Swift array. The @&lt;code&gt;StoredValue&lt;/code&gt; and @&lt;code&gt;AsyncStoredValue&lt;/code&gt; property wrappers work the same way, but instead of an array they work with singular Swift values. You&#39;ll never have to think about databases, everything in your app is a regular Swift array or value using your app&#39;s models, with straightforward code that looks like any other app.&lt;/p&gt; &#xA;&lt;p&gt;You may be familiar with the &lt;code&gt;Store&lt;/code&gt; from &lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt; or &lt;a href=&#34;https://github.com/pointfreeco/swift-composable-architecture&#34;&gt;The Composable Architecture&lt;/a&gt;, but unlike those frameworks you won&#39;t need to worry about adding Actions or Reducers. With this &lt;code&gt;Store&lt;/code&gt; implementation all your data is persisted for you automatically, no additional code required. This allows you to build realtime updating apps with full offline support in an incredibly simple and straightforward manner.&lt;/p&gt; &#xA;&lt;p&gt;You can read a high level overview of Boutique below, but Boutique is also fully documented &lt;a href=&#34;https://mergesort.github.io/Boutique/documentation/boutique&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Store&lt;/h3&gt; &#xA;&lt;p&gt;We&#39;ll go through a high level overview of the &lt;code&gt;Store&lt;/code&gt; below, but the &lt;code&gt;Store&lt;/code&gt; is fully documented with context, use cases, and examples &lt;a href=&#34;https://mergesort.github.io/Boutique/documentation/boutique/using-stores/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The entire surface area of the API for achieving full offline support and realtime model updates across your entire app is three methods, &lt;code&gt;.insert()&lt;/code&gt;, &lt;code&gt;.remove()&lt;/code&gt;, and &lt;code&gt;.removeAll()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Create a Store ¹&#xA;let store = Store&amp;lt;Animal&amp;gt;(&#xA;    storage: SQLiteStorageEngine.default(appendingPath: &#34;Animals&#34;),&#xA;    cacheIdentifier: \.id&#xA;)&#xA;&#xA;// Insert an item into the Store ²&#xA;let redPanda = Animal(id: &#34;red_panda&#34;)&#xA;try await store.insert(redPanda)&#xA;&#xA;// Remove an animal from the Store&#xA;try await store.remove(redPanda)&#xA;&#xA;// Insert two more animals to the Store&#xA;let dog = Item(name: &#34;dog&#34;)&#xA;let cat = Item(name: &#34;cat&#34;)&#xA;try await store.insert([dog, cat])&#xA;&#xA;// You can read items directly&#xA;print(store.items) // Prints [dog, cat]&#xA;&#xA;// You also don&#39;t have to worry about maintaining uniqueness, the Store handles uniqueness for you&#xA;let secondDog = Item(name: &#34;dog&#34;)&#xA;try await store.insert(secondDog)&#xA;print(store.items) // Prints [dog, cat]&#xA;&#xA;// Clear your store by removing all the items at once.&#xA;store.removeAll()&#xA;&#xA;print(store.items) // Prints []&#xA;&#xA;// You can even chain commands together&#xA;try await store&#xA;    .insert(dog)&#xA;    .insert(cat)&#xA;    .run()&#xA;    &#xA;print(store.items) // Prints [dog, cat]&#xA;&#xA;// This is a good way to clear stale cached data&#xA;try await store&#xA;    .removeAll()&#xA;    .insert(redPanda)&#xA;    .run()&#xA;&#xA;print(store.items) // Prints [redPanda]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And if you&#39;re building a SwiftUI app you don&#39;t have to change a thing, Boutique was made for and with SwiftUI in mind. (But works well in UIKit and AppKit of course. 😉)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Since items is a @Published property &#xA;// you can subscribe to any changes in realtime.&#xA;store.$items.sink({ items in&#xA;    print(&#34;Items was updated&#34;, items)&#xA;})&#xA;&#xA;// Works great with SwiftUI out the box for more complex pipelines.&#xA;.onReceive(store.$items, perform: {&#xA;    self.allItems = $0.filter({ $0.id &amp;gt; 100 })&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;¹ You can have as many or as few Stores as you&#39;d like. It may be a good strategy to have one Store for all of the images you download in your app, but you may also want to have one Store per model-type you&#39;d like to cache. You can even create separate stores for tests, Boutique isn&#39;t prescriptive and the choice for how you&#39;d like to model your data is yours. You&#39;ll also notice, that&#39;s a concept from Bodega which you can read about in Bodega&#39;s &lt;a href=&#34;https://mergesort.github.io/Bodega/documentation/bodega/using-storageengines&#34;&gt;StorageEngine documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;² Under the hood the Store is doing the work of saving all changes to disk when you add or remove items.&lt;/p&gt; &#xA;&lt;p&gt;³ In SwiftUI you can even power your &lt;code&gt;View&lt;/code&gt;s with &lt;code&gt;$items&lt;/code&gt; and use &lt;code&gt;.onReceive()&lt;/code&gt; to update and manipulate data published by the Store&#39;s &lt;code&gt;$items&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt; Storing images or other binary data in Boutique is technically supported but not recommended. The reason is that storing images in Boutique&#39;s can balloon up the in-memory store, and your app&#39;s memory as a result. For similar reasons as it&#39;s not recommended to store images or binary blobs in a database, it&#39;s not recommended to store images or binary blobs in Boutique.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;The Magic of @Stored&lt;/h3&gt; &#xA;&lt;p&gt;We&#39;ll go through a high level overview of the &lt;code&gt;@Stored&lt;/code&gt; property wrapper below, but &lt;code&gt;@Stored&lt;/code&gt; is fully documented with context, use cases, and examples &lt;a href=&#34;https://mergesort.github.io/Boutique/documentation/boutique/the-@stored-family-of-property-wrappers/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;That was easy, but I want to show you something that makes Boutique feel downright magical. The &lt;code&gt;Store&lt;/code&gt; is a simple way to gain the benefits of offline storage and realtime updates, but by using the &lt;code&gt;@Stored&lt;/code&gt; property wrapper we can cache any property in-memory and on disk with just one line of code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Store where Item == RemoteImage {&#xA;&#xA;    // Initialize a Store to save our images into&#xA;    static let imagesStore = Store&amp;lt;RemoteImage&amp;gt;(&#xA;        storage: SQLiteStorageEngine.default(appendingPath: &#34;Images&#34;)&#xA;    )&#xA;&#xA;}&#xA;&#xA;final class ImagesController: ObservableObject {&#xA;&#xA;    /// Creates a @Stored property to handle an in-memory and on-disk cache of images. ⁴&#xA;    @Stored(in: .imagesStore) var images&#xA;&#xA;    /// Fetches `RemoteImage` from the API, providing the user with a red panda if the request succeeds.&#xA;    func fetchImage() async throws -&amp;gt; RemoteImage {&#xA;        // Hit the API that provides you a random image&#39;s metadata&#xA;        let imageURL = URL(string: &#34;https://image.redpanda.club/random/json&#34;)!&#xA;        let randomImageRequest = URLRequest(url: imageURL)&#xA;        let (imageResponse, _) = try await URLSession.shared.data(for: randomImageRequest)&#xA;&#xA;        return RemoteImage(createdAt: .now, url: imageResponse.url, width: imageResponse.width, height: imageResponse.height, imageData: imageResponse.imageData)&#xA;    }&#xA;  &#xA;    /// Saves an image to the `Store` in memory and on disk.&#xA;    func saveImage(image: RemoteImage) async throws {&#xA;        try await self.$images.insert(image)&#xA;    }&#xA;  &#xA;    /// Removes one image from the `Store` in memory and on disk.&#xA;    func removeImage(image: RemoteImage) async throws {&#xA;        try await self.$images.remove(image)&#xA;    }&#xA;  &#xA;    /// Removes all of the images from the `Store` in memory and on disk.&#xA;    func clearAllImages() async throws {&#xA;        try await self.$images.removeAll()&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it, that&#39;s really it. This technique scales very well, and sharing this data across many views is exactly how Boutique scales from simple to complex apps without adding API complexity. It&#39;s hard to believe that now your app can update its state in real time with full offline storage thanks to only one line of code. &lt;code&gt;@Stored(in: .imagesStore) var images&lt;/code&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;⁴ (If you&#39;d prefer to decouple the store from your view model, controller, or manager object, you can inject stores into the object like this.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;final class ImagesController: ObservableObject {&#xA;&#xA;    @Stored var images: [RemoteImage]&#xA;&#xA;    init(store: Store&amp;lt;RemoteImage&amp;gt;) {&#xA;        self._images = Stored(in: store)&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;StoredValue &amp;amp; AsyncStoredValue&lt;/h3&gt; &#xA;&lt;p&gt;We&#39;ll go through a high level overview of the &lt;code&gt;@StoredValue&lt;/code&gt; and &lt;code&gt;@AsyncStoredValue&lt;/code&gt; property wrappers below, but they&#39;re fully documented with context, use cases, and examples &lt;a href=&#34;https://mergesort.github.io/Boutique/documentation/boutique/the-@stored-family-of-property-wrappers/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Store&lt;/code&gt; and &lt;code&gt;@Stored&lt;/code&gt; were created to store an array of data because most data apps render comes in the form of an array. But occasionally we need to store an individual value, that&#39;s where @&lt;code&gt;StoredValue&lt;/code&gt; and @&lt;code&gt;AsyncStoredValue&lt;/code&gt; come in handy.&lt;/p&gt; &#xA;&lt;p&gt;Whether you need to save an important piece of information for the next time your app is launched or if want to change how an app looks based on a user&#39;s settings, those app configurations are individual values that you&#39;ll want to persist.&lt;/p&gt; &#xA;&lt;p&gt;Often times people will choose to store individual items like that in &lt;code&gt;UserDefaults&lt;/code&gt;. If you&#39;ve used &lt;code&gt;@AppStorage&lt;/code&gt; then @&lt;code&gt;StoredValue&lt;/code&gt; will feel right at home, it has a very similar API with some additional features. A @&lt;code&gt;StoredValue&lt;/code&gt; will end up being stored in &lt;code&gt;UserDefaults&lt;/code&gt;, but it also exposes a &lt;code&gt;publisher&lt;/code&gt; so you can easily subscribe to changes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Setup a `@StoredValue, @AsyncStoredValue has the same API.&#xA;@StoredValue(key: &#34;hasHapticsEnabled&#34;)&#xA;var hasHapticsEnabled = false&#xA;&#xA;// You can also store nil values&#xA;@StoredValue(key: &#34;lastOpenedDate&#34;)&#xA;var lastOpenedDate: Date? = nil&#xA;&#xA;// Enums work as well, as long as it conforms to `Codable` and `Equatable`.&#xA;@StoredValue(key: &#34;currentTheme&#34;)&#xA;var currentlySelectedTheme = .light&#xA;&#xA;// Complex objects work as well&#xA;struct UserPreferences: Codable, Equatable {&#xA;    var hasHapticsEnabled: Bool&#xA;    var prefersDarkMode: Bool&#xA;    var prefersWideScreen: Bool&#xA;    var spatialAudioEnabled: Bool&#xA;}&#xA;&#xA;@StoredValue(key: &#34;userPreferences&#34;)&#xA;var preferences = UserPreferences()&#xA;&#xA;// Set the lastOpenedDate to now&#xA;$lastOpenedDate.set(.now)&#xA;&#xA;// currentlySelected is now .dark&#xA;$currentlySelectedTheme.set(.dark)&#xA;&#xA;// StoredValues that are backed by a boolean also have a toggle() function&#xA;$hasHapticsEnabled.toggle()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An @&lt;code&gt;AsyncStoredValue&lt;/code&gt; is very similar to @&lt;code&gt;StoredValue&lt;/code&gt;, the main difference is that rather than storing individual values in &lt;code&gt;UserDefaults&lt;/code&gt; an @&lt;code&gt;AsyncStoredValue&lt;/code&gt; is stored in a &lt;code&gt;StorageEngine&lt;/code&gt;, much like a &lt;code&gt;Store&lt;/code&gt;. This allows you to build your own custom persistence layer for storing values, such as building a &lt;code&gt;KeychainStorageEngine&lt;/code&gt; to store individual values in the keychain much the same way we can choose our own persistence layer for @&lt;code&gt;Stored&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Documentation&lt;/h3&gt; &#xA;&lt;p&gt;If you have any questions I would ask that you please look at the documentation first, both Boutique and Bodega are very heavily documented. On top of that Boutique comes with not one but two demo apps, each serving a different purpose but demonstrating how you can build a Boutique-backed app.&lt;/p&gt; &#xA;&lt;p&gt;As I was building v1 I noticed that people who got Boutique loved it, and people who thought it might be good but had questions grew to love it once they understood how to use it. Because of that I sought out to write a lot of documentation explaining the concepts and common use cases you&#39;ll encounter when building an iOS or macOS app. If you still have questions or suggestions I&#39;m very open to feedback, how to contribute is discussed in the aptly named &lt;a href=&#34;https://raw.githubusercontent.com/mergesort/Boutique/main/#feedback&#34;&gt;Feedback&lt;/a&gt; section of this readme.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://build.ms/boutique/docs&#34;&gt;Boutique Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://build.ms/bodega/docs&#34;&gt;Bodega Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mergesort/Boutique/tree/main/Demo&#34;&gt;Boutique Demo App&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mergesort/Boutique/tree/main/Performance%20Profiler&#34;&gt;Performance Profiler App&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Further Exploration&lt;/h3&gt; &#xA;&lt;p&gt;Boutique is very useful on its own for building realtime offline-ready apps with just a few lines of code, but it&#39;s even more powerful when you use the Model View Controller Store architecture I&#39;ve developed, demonstrated in the &lt;code&gt;ImagesController&lt;/code&gt; above. MVCS brings together the familiarity and simplicity of the &lt;a href=&#34;https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html&#34;&gt;MVC architecture&lt;/a&gt; you know and love with the power of a &lt;code&gt;Store&lt;/code&gt;, to give your app a simple but well-defined state management and data architecture.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;d like to learn more about how it works you can read about the philosophy in a &lt;a href=&#34;https://build.ms/2022/06/22/model-view-controller-store&#34;&gt;blog post&lt;/a&gt; where I explore MVCS for SwiftUI, and you can find a reference implementation of an offline-ready realtime MVCS app powered by Boutique in this &lt;a href=&#34;https://github.com/mergesort/MVCS&#34;&gt;repo&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ve only scratched the surface of what Boutique can do here. Leveraging Bodega&#39;s &lt;code&gt;StorageEngine&lt;/code&gt; you can build complex data pipelines that do everything from caching data to interfacing with your API server. Boutique and Bodega are more than libraries, they&#39;re a set of primitives for any data-driven application, so I suggest giving them a shot, playing with the &lt;a href=&#34;https://github.com/mergesort/Boutique/tree/main/Demo&#34;&gt;demo app&lt;/a&gt;, and even building an app of your own!&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Feedback&lt;/h3&gt; &#xA;&lt;p&gt;This project provides multiple forms of delivering feedback to maintainers.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;If you have a question about Boutique, we ask that you first consult the &lt;a href=&#34;https://build.ms/boutique/docs&#34;&gt;documentation&lt;/a&gt; to see if your question has been answered there.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;This project is heavily documented but also includes multiple sample projects.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The first app is a &lt;a href=&#34;https://github.com/mergesort/Boutique/tree/main/Demo&#34;&gt;Demo app&lt;/a&gt; which shows you how to build a canonical Boutique app using the Model View Controller Store pattern. The app is heavily documented with inline explanations to help you build an intuition for how a Boutique app works and save you time by teaching you best practices along the way.&lt;/li&gt; &#xA;   &lt;li&gt;The second app is a &lt;a href=&#34;https://github.com/mergesort/Boutique/tree/main/Performance%20Profiler&#34;&gt;Performance Profiler&lt;/a&gt; also using Boutique&#39;s preferred architecture. If you&#39;re working on a custom &lt;code&gt;StorageEngine&lt;/code&gt; this project will serve you well as a way to test the performance of the operations you need to build.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you still have a question, enhancement, or a way to improve Boutique, this project leverages GitHub&#39;s &lt;a href=&#34;https://github.com/mergesort/Boutique/discussions&#34;&gt;Discussions&lt;/a&gt; feature.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you find a bug and wish to report an &lt;a href=&#34;https://github.com/mergesort/Boutique/issues&#34;&gt;issue&lt;/a&gt; would be appreciated.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iOS 13.0+&lt;/li&gt; &#xA; &lt;li&gt;macOS 11.0+&lt;/li&gt; &#xA; &lt;li&gt;Xcode 13.2+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;h4&gt;Swift Package Manager&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://www.swift.org/package-manager&#34;&gt;Swift Package Manager&lt;/a&gt; is a tool for automating the distribution of Swift code and is integrated into the Swift build system.&lt;/p&gt; &#xA;&lt;p&gt;Once you have your Swift package set up, adding Boutique as a dependency is as easy as adding it to the dependencies value of your &lt;code&gt;Package.swift&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/mergesort/Boutique.git&#34;, .upToNextMajor(from: &#34;1.0.0&#34;))&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Manually&lt;/h4&gt; &#xA;&lt;p&gt;If you prefer not to use SPM, you can integrate Boutique into your project manually by copying the files in.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;About me&lt;/h3&gt; &#xA;&lt;p&gt;Hi, I&#39;m &lt;a href=&#34;http://fabisevi.ch&#34;&gt;Joe&lt;/a&gt; everywhere on the web, but especially on &lt;a href=&#34;https://macaw.social/@mergesort&#34;&gt;Mastodon&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/mergesort/Boutique/main/LICENSE&#34;&gt;license&lt;/a&gt; for more information about how you can use Boutique.&lt;/p&gt; &#xA;&lt;h3&gt;Sponsorship&lt;/h3&gt; &#xA;&lt;p&gt;Boutique is a labor of love to help developers build better apps, making it easier for you to unlock your creativity and make something amazing for your yourself and your users. If you find Boutique valuable I would really appreciate it if you&#39;d consider helping &lt;a href=&#34;https://github.com/sponsors/mergesort&#34;&gt;sponsor my open source work&lt;/a&gt;, so I can continue to work on projects like Boutique to help developers like yourself.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;Now that you know what&#39;s &lt;em&gt;in store&lt;/em&gt; for you, it&#39;s time to get started&lt;/strong&gt; 🏪&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>arror/Mango</title>
    <updated>2023-04-17T01:46:20Z</updated>
    <id>tag:github.com,2023-04-17:/arror/Mango</id>
    <link href="https://github.com/arror/Mango" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Xray for iOS&lt;/p&gt;&lt;hr&gt;&lt;p&gt;系统要求：iOS16.0+&lt;/p&gt; &#xA;&lt;p&gt;开发语言：Swift、Golang、C、Assembly&lt;/p&gt; &#xA;&lt;p&gt;界面框架：SwiftUI、UIKit&lt;/p&gt; &#xA;&lt;p&gt;内核： xray: &lt;a href=&#34;https://github.com/XTLS/Xray-core(1.8.0)&#34;&gt;https://github.com/XTLS/Xray-core(1.8.0)&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Tun2Socks &lt;a href=&#34;https://github.com/heiher/hev-socks5-tunnel&#34;&gt;https://github.com/heiher/hev-socks5-tunnel&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;编译： 1.下载工程 2.更新依赖 3.修改Config.xcconfig中DEVELOPMENT_TEAM &amp;amp; APP_ID&lt;/p&gt; &#xA;&lt;p&gt;关联项目： XrayKit：&lt;a href=&#34;https://github.com/daemooon/XrayKit&#34;&gt;https://github.com/daemooon/XrayKit&lt;/a&gt; Tun2SocksKit：&lt;a href=&#34;https://github.com/daemooon/Tun2SocksKit&#34;&gt;https://github.com/daemooon/Tun2SocksKit&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>