<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-20T01:54:12Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mecid/swift-unidirectional-flow</title>
    <updated>2022-07-20T01:54:12Z</updated>
    <id>tag:github.com,2022-07-20:/mecid/swift-unidirectional-flow</id>
    <link href="https://github.com/mecid/swift-unidirectional-flow" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Unidirectional flow implemented using the latest Swift Generics and Swift Concurrency features.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;swift-unidirectional-flow&lt;/h1&gt; &#xA;&lt;p&gt;Unidirectional flow implemented using the latest Swift Generics and Swift Concurrency features.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct SearchState: Equatable {&#xA;    var repos: [Repo] = []&#xA;    var isLoading = false&#xA;}&#xA;&#xA;enum SearchAction: Equatable {&#xA;    case search(query: String)&#xA;    case setResults(repos: [Repo])&#xA;}&#xA;&#xA;struct SearchReducer: Reducer {&#xA;    func reduce(oldState: SearchState, with action: SearchAction) -&amp;gt; SearchState {&#xA;        var state = oldState&#xA;        &#xA;        switch action {&#xA;        case .search:&#xA;            state.isLoading = true&#xA;        case let .setResults(repos):&#xA;            state.repos = repos&#xA;            state.isLoading = false&#xA;        }&#xA;        &#xA;        return state&#xA;    }&#xA;}&#xA;&#xA;struct SearchDependencies {&#xA;    var search: (String) async throws -&amp;gt; SearchResponse&#xA;}&#xA;&#xA;struct SearchMiddleware: Middleware {&#xA;    func process(&#xA;        state: SearchState,&#xA;        with action: SearchAction,&#xA;        using dependencies: SearchDependencies&#xA;    ) async -&amp;gt; SearchAction? {&#xA;        switch action {&#xA;        case let .search(query):&#xA;            let results = try? await dependencies.search(query)&#xA;            return .setResults(repos: results?.items ?? [])&#xA;        default:&#xA;            return nil&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;typealias SearchStore = Store&amp;lt;SearchState, SearchAction, SearchDependencies&amp;gt;&#xA;&#xA;struct SearchContainerView: View {&#xA;    @StateObject private var store = SearchStore(&#xA;        initialState: .init(),&#xA;        reducer: SearchReducer(),&#xA;        dependencies: .production,&#xA;        middlewares: [SearchMiddleware()]&#xA;    )&#xA;    @State private var query = &#34;&#34;&#xA;    &#xA;    var body: some View {&#xA;        List(store.state.repos) { repo in&#xA;            VStack(alignment: .leading) {&#xA;                Text(repo.name)&#xA;                    .font(.headline)&#xA;                &#xA;                if let description = repo.description {&#xA;                    Text(description)&#xA;                }&#xA;            }&#xA;        }&#xA;        .redacted(reason: store.state.isLoading ? .placeholder : [])&#xA;        .searchable(text: $query)&#xA;        .task(id: query) {&#xA;            await store.send(.search(query: query))&#xA;        }&#xA;        .navigationTitle(&#34;Github Search&#34;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To learn more about Unidirectional Flow in Swift, take a look at my dedicated &lt;a href=&#34;https://swiftwithmajid.com/2022/03/16/functional-core-imperative-shell-in-swift-unidirectional-flow/&#34;&gt;post&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>sindresorhus/Defaults</title>
    <updated>2022-07-20T01:54:12Z</updated>
    <id>tag:github.com,2022-07-20:/sindresorhus/Defaults</id>
    <link href="https://github.com/sindresorhus/Defaults" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üíæ Swifty and modern UserDefaults&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Defaults&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Swifty and modern &lt;a href=&#34;https://developer.apple.com/documentation/foundation/userdefaults&#34;&gt;UserDefaults&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Store key-value pairs persistently across launches of your app.&lt;/p&gt; &#xA;&lt;p&gt;It uses &lt;code&gt;NSUserDefaults&lt;/code&gt; underneath but exposes a type-safe facade with lots of nice conveniences.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s used in production by apps like &lt;a href=&#34;https://github.com/sindresorhus/Gifski&#34;&gt;Gifski&lt;/a&gt;, &lt;a href=&#34;https://sindresorhus.com/dato&#34;&gt;Dato&lt;/a&gt;, &lt;a href=&#34;https://sindresorhus.com/lungo&#34;&gt;Lungo&lt;/a&gt;, &lt;a href=&#34;https://sindresorhus.com/battery-indicator&#34;&gt;Battery Indicator&lt;/a&gt;, and &lt;a href=&#34;https://sindresorhus.com/heic-converter&#34;&gt;HEIC Converter&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For a real-world example, see the &lt;a href=&#34;https://github.com/sindresorhus/Plash/raw/533dbc888d8ba3bd9581e60320af282a22c53f85/Plash/Constants.swift#L9-L18&#34;&gt;Plash app&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Highlights&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Strongly typed:&lt;/strong&gt; You declare the type and default value upfront.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Codable support:&lt;/strong&gt; You can store any &lt;a href=&#34;https://developer.apple.com/documentation/swift/codable&#34;&gt;Codable&lt;/a&gt; value, like an enum.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;NSSecureCoding support:&lt;/strong&gt; You can store any &lt;a href=&#34;https://developer.apple.com/documentation/foundation/nssecurecoding&#34;&gt;NSSecureCoding&lt;/a&gt; value.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;SwiftUI:&lt;/strong&gt; Property wrapper that updates the view when the &lt;code&gt;UserDefaults&lt;/code&gt; value changes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Publishers:&lt;/strong&gt; Combine publishers built-in.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Observation:&lt;/strong&gt; Observe changes to keys.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Debuggable:&lt;/strong&gt; The data is stored as JSON-serialized values.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Customizable:&lt;/strong&gt; You can serialize and deserialize your own type in your own way.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Benefits over &lt;code&gt;@AppStorage&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You define strongly-typed identifiers in a single place and can use them everywhere.&lt;/li&gt; &#xA; &lt;li&gt;You also define the default values in a single place instead of having to remember what default value you used in other places.&lt;/li&gt; &#xA; &lt;li&gt;You can use it outside of SwiftUI.&lt;/li&gt; &#xA; &lt;li&gt;Comes with Combine publisher.&lt;/li&gt; &#xA; &lt;li&gt;Supports many more types, even &lt;code&gt;Codable&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Easy to add support for your own custom types.&lt;/li&gt; &#xA; &lt;li&gt;Comes with a convenience SwiftUI &lt;code&gt;Toggle&lt;/code&gt; component.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;macOS 10.13+&lt;/li&gt; &#xA; &lt;li&gt;iOS 12+&lt;/li&gt; &#xA; &lt;li&gt;tvOS 12+&lt;/li&gt; &#xA; &lt;li&gt;watchOS 5+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;hr&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt; &lt;/p&gt;&#xA; &lt;p&gt; &lt;sup&gt; &lt;a href=&#34;https://github.com/sponsors/sindresorhus&#34;&gt;Sindre&#39;s open source work is supported by the community&lt;/a&gt; &lt;/sup&gt; &lt;/p&gt; &#xA; &lt;sup&gt;Special thanks to:&lt;/sup&gt; &#xA; &lt;br&gt; &#xA; &lt;br&gt; &#xA; &lt;a href=&#34;https://keygen.sh&#34;&gt; &#xA;  &lt;div&gt; &#xA;   &lt;img src=&#34;https://sindresorhus.com/assets/thanks/keygen-logo.svg?sanitize=true&#34; width=&#34;210&#34; alt=&#34;Keygen&#34;&gt; &#xA;  &lt;/div&gt; &lt;b&gt;A dead-simple software licensing and distribution API built for developers&lt;/b&gt; &lt;/a&gt; &#xA; &lt;br&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;hr&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Migration Guides&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sindresorhus/Defaults/main/migration.md&#34;&gt;From v4 to v5&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;Add &lt;code&gt;https://github.com/sindresorhus/Defaults&lt;/code&gt; in the &lt;a href=&#34;https://developer.apple.com/documentation/xcode/adding_package_dependencies_to_your_app&#34;&gt;‚ÄúSwift Package Manager‚Äù tab in Xcode&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;There are some issues running Defaults with Xcode 13.3 because of a Swift bug. &lt;a href=&#34;https://raw.githubusercontent.com/sindresorhus/Defaults/main/workaround.md&#34;&gt;See the workaround&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Support types&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Int(8/16/32/64)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;UInt(8/16/32/64)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CGFloat&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Float&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;String&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Data&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;UUID&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NSColor&lt;/code&gt; (macOS)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;UIColor&lt;/code&gt; (iOS)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Color&lt;/code&gt; (SwiftUI)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Codable&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NSSecureCoding&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Range&lt;/code&gt;, &lt;code&gt;ClosedRange&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Defaults also support the above types wrapped in &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Dictionary&lt;/code&gt;, &lt;code&gt;Range&lt;/code&gt;, &lt;code&gt;ClosedRange&lt;/code&gt;, and even wrapped in nested types. For example, &lt;code&gt;[[String: Set&amp;lt;[String: Int]&amp;gt;]]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For more types, see the &lt;a href=&#34;https://raw.githubusercontent.com/sindresorhus/Defaults/main/#enum-example&#34;&gt;enum example&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/sindresorhus/Defaults/main/#codable-example&#34;&gt;&lt;code&gt;Codable&lt;/code&gt; example&lt;/a&gt;, or &lt;a href=&#34;https://raw.githubusercontent.com/sindresorhus/Defaults/main/#advanced-usage&#34;&gt;advanced Usage&lt;/a&gt;. For more examples, see &lt;a href=&#34;https://raw.githubusercontent.com/sindresorhus/Defaults/main/Tests/DefaultsTests&#34;&gt;Tests/DefaultsTests&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can easily add support for any custom type.&lt;/p&gt; &#xA;&lt;p&gt;If a type conforms to both &lt;code&gt;NSSecureCoding&lt;/code&gt; and &lt;code&gt;Codable&lt;/code&gt;, then &lt;code&gt;Codable&lt;/code&gt; will be used for the serialization.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;You declare the defaults keys upfront with type and default value.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Do not use a dot in the key name, because of &lt;a href=&#34;https://github.com/sindresorhus/Defaults/issues/59&#34;&gt;this bug&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Cocoa&#xA;import Defaults&#xA;&#xA;extension Defaults.Keys {&#xA;&#x9;static let quality = Key&amp;lt;Double&amp;gt;(&#34;quality&#34;, default: 0.8)&#xA;&#x9;//            ^            ^         ^                ^&#xA;&#x9;//           Key          Type   UserDefaults name   Default value&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then access it as a subscript on the &lt;code&gt;Defaults&lt;/code&gt; global:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Defaults[.quality]&#xA;//=&amp;gt; 0.8&#xA;&#xA;Defaults[.quality] = 0.5&#xA;//=&amp;gt; 0.5&#xA;&#xA;Defaults[.quality] += 0.1&#xA;//=&amp;gt; 0.6&#xA;&#xA;Defaults[.quality] = &#34;ü¶Ñ&#34;&#xA;//=&amp;gt; [Cannot assign value of type &#39;String&#39; to type &#39;Double&#39;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also declare optional keys for when you don&#39;t want to declare a default value upfront:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Defaults.Keys {&#xA;&#x9;static let name = Key&amp;lt;Double?&amp;gt;(&#34;name&#34;)&#xA;}&#xA;&#xA;if let name = Defaults[.name] {&#xA;&#x9;print(name)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default value is then &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Enum example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum DurationKeys: String, Defaults.Serializable {&#xA;&#x9;case tenMinutes = &#34;10 Minutes&#34;&#xA;&#x9;case halfHour = &#34;30 Minutes&#34;&#xA;&#x9;case oneHour = &#34;1 Hour&#34;&#xA;}&#xA;&#xA;extension Defaults.Keys {&#xA;&#x9;static let defaultDuration = Key&amp;lt;DurationKeys&amp;gt;(&#34;defaultDuration&#34;, default: .oneHour)&#xA;}&#xA;&#xA;Defaults[.defaultDuration].rawValue&#xA;//=&amp;gt; &#34;1 Hour&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;(This works as long as the raw value of the enum is any of the supported types)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Codable example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct User: Codable, Defaults.Serializable {&#xA;&#x9;let name: String&#xA;&#x9;let age: String&#xA;}&#xA;&#xA;extension Defaults.Keys {&#xA;&#x9;static let user = Key&amp;lt;User&amp;gt;(&#34;user&#34;, default: .init(name: &#34;Hello&#34;, age: &#34;24&#34;))&#xA;}&#xA;&#xA;Defaults[.user].name&#xA;//=&amp;gt; &#34;Hello&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Use keys directly&lt;/h3&gt; &#xA;&lt;p&gt;You are not required to attach keys to &lt;code&gt;Defaults.Keys&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let isUnicorn = Defaults.Key&amp;lt;Bool&amp;gt;(&#34;isUnicorn&#34;, default: true)&#xA;&#xA;Defaults[isUnicorn]&#xA;//=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SwiftUI support&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;code&gt;@Default&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;@Default&lt;/code&gt; property wrapper to get/set a &lt;code&gt;Defaults&lt;/code&gt; item and also have the view be updated when the value changes. This is similar to &lt;code&gt;@State&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Defaults.Keys {&#xA;&#x9;static let hasUnicorn = Key&amp;lt;Bool&amp;gt;(&#34;hasUnicorn&#34;, default: false)&#xA;}&#xA;&#xA;struct ContentView: View {&#xA;&#x9;@Default(.hasUnicorn) var hasUnicorn&#xA;&#xA;&#x9;var body: some View {&#xA;&#x9;&#x9;Text(&#34;Has Unicorn: \(hasUnicorn)&#34;)&#xA;&#x9;&#x9;Toggle(&#34;Toggle&#34;, isOn: $hasUnicorn)&#xA;&#x9;&#x9;Button(&#34;Reset&#34;) {&#xA;&#x9;&#x9;&#x9;_hasUnicorn.reset()&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that it&#39;s &lt;code&gt;@Default&lt;/code&gt;, not &lt;code&gt;@Defaults&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You cannot use &lt;code&gt;@Default&lt;/code&gt; in an &lt;code&gt;ObservableObject&lt;/code&gt;. It&#39;s meant to be used in a &lt;code&gt;View&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Toggle&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;There&#39;s also a &lt;code&gt;SwiftUI.Toggle&lt;/code&gt; wrapper that makes it easier to create a toggle based on a &lt;code&gt;Defaults&lt;/code&gt; key with a &lt;code&gt;Bool&lt;/code&gt; value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Defaults.Keys {&#xA;&#x9;static let showAllDayEvents = Key&amp;lt;Bool&amp;gt;(&#34;showAllDayEvents&#34;, default: false)&#xA;}&#xA;&#xA;struct ShowAllDayEventsSetting: View {&#xA;&#x9;var body: some View {&#xA;&#x9;&#x9;Defaults.Toggle(&#34;Show All-Day Events&#34;, key: .showAllDayEvents)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also listen to changes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ShowAllDayEventsSetting: View {&#xA;&#x9;var body: some View {&#xA;&#x9;&#x9;Defaults.Toggle(&#34;Show All-Day Events&#34;, key: .showAllDayEvents)&#xA;&#x9;&#x9;&#x9;// Note that this has to be directly attached to `Defaults.Toggle`. It&#39;s not `View#onChange()`.&#xA;&#x9;&#x9;&#x9;.onChange {&#xA;&#x9;&#x9;&#x9;&#x9;print(&#34;Value&#34;, $0)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Requires at least macOS 11, iOS 14, tvOS 14, watchOS 7.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Observe changes to a key&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Defaults.Keys {&#xA;&#x9;static let isUnicornMode = Key&amp;lt;Bool&amp;gt;(&#34;isUnicornMode&#34;, default: false)&#xA;}&#xA;&#xA;let observer = Defaults.observe(.isUnicornMode) { change in&#xA;&#x9;// Initial event&#xA;&#x9;print(change.oldValue)&#xA;&#x9;//=&amp;gt; false&#xA;&#x9;print(change.newValue)&#xA;&#x9;//=&amp;gt; false&#xA;&#xA;&#x9;// First actual event&#xA;&#x9;print(change.oldValue)&#xA;&#x9;//=&amp;gt; false&#xA;&#x9;print(change.newValue)&#xA;&#x9;//=&amp;gt; true&#xA;}&#xA;&#xA;Defaults[.isUnicornMode] = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In contrast to the native &lt;code&gt;UserDefaults&lt;/code&gt; key observation, here you receive a strongly-typed change object.&lt;/p&gt; &#xA;&lt;p&gt;There is also an observation API using the &lt;a href=&#34;https://developer.apple.com/documentation/combine&#34;&gt;Combine&lt;/a&gt; framework, exposing a &lt;a href=&#34;https://developer.apple.com/documentation/combine/publisher&#34;&gt;Publisher&lt;/a&gt; for key changes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let publisher = Defaults.publisher(.isUnicornMode)&#xA;&#xA;let cancellable = publisher.sink { change in&#xA;&#x9;// Initial event&#xA;&#x9;print(change.oldValue)&#xA;&#x9;//=&amp;gt; false&#xA;&#x9;print(change.newValue)&#xA;&#x9;//=&amp;gt; false&#xA;&#xA;&#x9;// First actual event&#xA;&#x9;print(change.oldValue)&#xA;&#x9;//=&amp;gt; false&#xA;&#x9;print(change.newValue)&#xA;&#x9;//=&amp;gt; true&#xA;}&#xA;&#xA;Defaults[.isUnicornMode] = true&#xA;&#xA;// To invalidate the observation.&#xA;cancellable.cancel()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Invalidate observations automatically&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Defaults.Keys {&#xA;&#x9;static let isUnicornMode = Key&amp;lt;Bool&amp;gt;(&#34;isUnicornMode&#34;, default: false)&#xA;}&#xA;&#xA;final class Foo {&#xA;&#x9;init() {&#xA;&#x9;&#x9;Defaults.observe(.isUnicornMode) { change in&#xA;&#x9;&#x9;&#x9;print(change.oldValue)&#xA;&#x9;&#x9;&#x9;print(change.newValue)&#xA;&#x9;&#x9;}.tieToLifetime(of: self)&#xA;&#x9;}&#xA;}&#xA;&#xA;Defaults[.isUnicornMode] = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The observation will be valid until &lt;code&gt;self&lt;/code&gt; is deinitialized.&lt;/p&gt; &#xA;&lt;h3&gt;Reset keys to their default values&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Defaults.Keys {&#xA;&#x9;static let isUnicornMode = Key&amp;lt;Bool&amp;gt;(&#34;isUnicornMode&#34;, default: false)&#xA;}&#xA;&#xA;Defaults[.isUnicornMode] = true&#xA;//=&amp;gt; true&#xA;&#xA;Defaults.reset(.isUnicornMode)&#xA;&#xA;Defaults[.isUnicornMode]&#xA;//=&amp;gt; false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This works for a &lt;code&gt;Key&lt;/code&gt; with an optional too, which will be reset back to &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Control propagation of change events&lt;/h3&gt; &#xA;&lt;p&gt;Changes made within the &lt;code&gt;Defaults.withoutPropagation&lt;/code&gt; closure will not be propagated to observation callbacks (&lt;code&gt;Defaults.observe()&lt;/code&gt; or &lt;code&gt;Defaults.publisher()&lt;/code&gt;), and therefore could prevent infinite recursion.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let observer = Defaults.observe(keys: .key1, .key2) {&#xA;&#x9;&#x9;// ‚Ä¶&#xA;&#xA;&#x9;&#x9;Defaults.withoutPropagation {&#xA;&#x9;&#x9;&#x9;// Update `.key1` without propagating the change to listeners.&#xA;&#x9;&#x9;&#x9;Defaults[.key1] = 11&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// This will be propagated.&#xA;&#x9;&#x9;Defaults[.someKey] = true&#xA;&#x9;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;It&#39;s just &lt;code&gt;UserDefaults&lt;/code&gt; with sugar&lt;/h3&gt; &#xA;&lt;p&gt;This works too:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Defaults.Keys {&#xA;&#x9;static let isUnicorn = Key&amp;lt;Bool&amp;gt;(&#34;isUnicorn&#34;, default: true)&#xA;}&#xA;&#xA;UserDefaults.standard[.isUnicorn]&#xA;//=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Shared &lt;code&gt;UserDefaults&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let extensionDefaults = UserDefaults(suiteName: &#34;com.unicorn.app&#34;)!&#xA;&#xA;extension Defaults.Keys {&#xA;&#x9;static let isUnicorn = Key&amp;lt;Bool&amp;gt;(&#34;isUnicorn&#34;, default: true, suite: extensionDefaults)&#xA;}&#xA;&#xA;Defaults[.isUnicorn]&#xA;//=&amp;gt; true&#xA;&#xA;// Or&#xA;&#xA;extensionDefaults[.isUnicorn]&#xA;//=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Default values are registered with &lt;code&gt;UserDefaults&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;When you create a &lt;code&gt;Defaults.Key&lt;/code&gt;, it automatically registers the &lt;code&gt;default&lt;/code&gt; value with normal &lt;code&gt;UserDefaults&lt;/code&gt;. This means you can make use of the default value in, for example, bindings in Interface Builder.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Defaults.Keys {&#xA;&#x9;static let isUnicornMode = Key&amp;lt;Bool&amp;gt;(&#34;isUnicornMode&#34;, default: true)&#xA;}&#xA;&#xA;print(UserDefaults.standard.bool(forKey: Defaults.Keys.isUnicornMode.name))&#xA;//=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;Defaults&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.Keys&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;class&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Stores the keys.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.Key&lt;/code&gt; &lt;em&gt;(alias &lt;code&gt;Defaults.Keys.Key&lt;/code&gt;)&lt;/em&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Defaults.Key&amp;lt;T&amp;gt;(_ key: String, default: T, suite: UserDefaults = .standard)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;class&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Create a key with a default value.&lt;/p&gt; &#xA;&lt;p&gt;The default value is written to the actual &lt;code&gt;UserDefaults&lt;/code&gt; and can be used elsewhere. For example, with a Interface Builder binding.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.Serializable&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol DefaultsSerializable {&#xA;&#x9;typealias Value = Bridge.Value&#xA;&#x9;typealias Serializable = Bridge.Serializable&#xA;&#x9;associatedtype Bridge: Defaults.Bridge&#xA;&#xA;&#x9;static var bridge: Bridge { get }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;protocol&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Types that conform to this protocol can be used with &lt;code&gt;Defaults&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The type should have a static variable &lt;code&gt;bridge&lt;/code&gt; which should reference an instance of a type that conforms to &lt;code&gt;Defaults.Bridge&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.Bridge&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol DefaultsBridge {&#xA;&#x9;associatedtype Value&#xA;&#x9;associatedtype Serializable&#xA;&#xA;&#x9;func serialize(_ value: Value?) -&amp;gt; Serializable?&#xA;&#x9;func deserialize(_ object: Serializable?) -&amp;gt; Value?&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;protocol&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;A &lt;code&gt;Bridge&lt;/code&gt; is responsible for serialization and deserialization.&lt;/p&gt; &#xA;&lt;p&gt;It has two associated types &lt;code&gt;Value&lt;/code&gt; and &lt;code&gt;Serializable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Value&lt;/code&gt;: The type you want to use.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Serializable&lt;/code&gt;: The type stored in &lt;code&gt;UserDefaults&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;serialize&lt;/code&gt;: Executed before storing to the &lt;code&gt;UserDefaults&lt;/code&gt; .&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;deserialize&lt;/code&gt;: Executed after retrieving its value from the &lt;code&gt;UserDefaults&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.AnySerializable&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Defaults.AnySerializable&amp;lt;Value: Defaults.Serializable&amp;gt;(_ value: Value)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;class&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Type-erased wrapper for &lt;code&gt;Defaults.Serializable&lt;/code&gt; values.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;get&amp;lt;Value: Defaults.Serializable&amp;gt;() -&amp;gt; Value?&lt;/code&gt;: Retrieve the value which type is &lt;code&gt;Value&lt;/code&gt; from UserDefaults.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;get&amp;lt;Value: Defaults.Serializable&amp;gt;(_: Value.Type) -&amp;gt; Value?&lt;/code&gt;: Specify the &lt;code&gt;Value&lt;/code&gt; you want to retrieve. This can be useful in some ambiguous cases.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;set&amp;lt;Value: Defaults.Serializable&amp;gt;(_ newValue: Value)&lt;/code&gt;: Set a new value for &lt;code&gt;Defaults.AnySerializable&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.reset(keys‚Ä¶)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;func&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Reset the given keys back to their default values.&lt;/p&gt; &#xA;&lt;p&gt;You can also specify string keys, which can be useful if you need to store some keys in a collection, as it&#39;s not possible to store &lt;code&gt;Defaults.Key&lt;/code&gt; in a collection because it&#39;s generic.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.observe&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Defaults.observe&amp;lt;T: Codable&amp;gt;(&#xA;&#x9;_ key: Defaults.Key&amp;lt;T&amp;gt;,&#xA;&#x9;options: ObservationOptions = [.initial],&#xA;&#x9;handler: @escaping (KeyChange&amp;lt;T&amp;gt;) -&amp;gt; Void&#xA;) -&amp;gt; Defaults.Observation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;func&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Observe changes to a key or an optional key.&lt;/p&gt; &#xA;&lt;p&gt;By default, it will also trigger an initial event on creation. This can be useful for setting default values on controls. You can override this behavior with the &lt;code&gt;options&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.observe(keys: keys..., options:)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;func&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Observe multiple keys of any type, but without any information about the changes.&lt;/p&gt; &#xA;&lt;p&gt;Options are the same as in &lt;code&gt;.observe(‚Ä¶)&lt;/code&gt; for a single key.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.publisher(_ key:, options:)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Defaults.publisher&amp;lt;T: Codable&amp;gt;(&#xA;&#x9;_ key: Defaults.Key&amp;lt;T&amp;gt;,&#xA;&#x9;options: ObservationOptions = [.initial]&#xA;) -&amp;gt; AnyPublisher&amp;lt;KeyChange&amp;lt;T&amp;gt;, Never&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;func&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Observation API using &lt;a href=&#34;https://developer.apple.com/documentation/combine/publisher&#34;&gt;Publisher&lt;/a&gt; from the &lt;a href=&#34;https://developer.apple.com/documentation/combine&#34;&gt;Combine&lt;/a&gt; framework.&lt;/p&gt; &#xA;&lt;p&gt;Available on macOS 10.15+, iOS 13.0+, tvOS 13.0+, and watchOS 6.0+.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.publisher(keys: keys‚Ä¶, options:)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;func&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/documentation/combine&#34;&gt;Combine&lt;/a&gt; observation API for multiple key observation, but without specific information about changes.&lt;/p&gt; &#xA;&lt;p&gt;Available on macOS 10.15+, iOS 13.0+, tvOS 13.0+, and watchOS 6.0+.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.removeAll&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Defaults.removeAll(suite: UserDefaults = .standard)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;func&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Remove all entries from the given &lt;code&gt;UserDefaults&lt;/code&gt; suite.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;Defaults.Observation&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;protocol&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Represents an observation of a defaults key.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.Observation#invalidate&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Defaults.Observation#invalidate()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;func&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Invalidate the observation.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.Observation#tieToLifetime&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@discardableResult&#xA;Defaults.Observation#tieToLifetime(of weaklyHeldObject: AnyObject) -&amp;gt; Self&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;func&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Keep the observation alive for as long as, and no longer than, another object exists.&lt;/p&gt; &#xA;&lt;p&gt;When &lt;code&gt;weaklyHeldObject&lt;/code&gt; is deinitialized, the observation is invalidated automatically.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.Observation.removeLifetimeTie&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Defaults.Observation#removeLifetimeTie()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;func&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Break the lifetime tie created by &lt;code&gt;tieToLifetime(of:)&lt;/code&gt;, if one exists.&lt;/p&gt; &#xA;&lt;p&gt;The effects of any call to &lt;code&gt;tieToLifetime(of:)&lt;/code&gt; are reversed. Note however that if the tied-to object has already died, then the observation is already invalid and this method has no logical effect.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.withoutPropagation(_ closure:)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Execute the closure without triggering change events.&lt;/p&gt; &#xA;&lt;p&gt;Any &lt;code&gt;Defaults&lt;/code&gt; key changes made within the closure will not propagate to &lt;code&gt;Defaults&lt;/code&gt; event listeners (&lt;code&gt;Defaults.observe()&lt;/code&gt; and &lt;code&gt;Defaults.publisher()&lt;/code&gt;). This can be useful to prevent infinite recursion when you want to change a key in the callback listening to changes for the same key.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.migrate(keys..., to: Version)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Defaults.migrate&amp;lt;T: Defaults.Serializable &amp;amp; Codable&amp;gt;(keys..., to: Version)&#xA;Defaults.migrate&amp;lt;T: Defaults.NativeType&amp;gt;(keys..., to: Version)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;func&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Migrate the given keys to the specific version.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;@Default(_ key:)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Get/set a &lt;code&gt;Defaults&lt;/code&gt; item and also have the SwiftUI view be updated when the value changes.&lt;/p&gt; &#xA;&lt;h3&gt;Advanced&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.CollectionSerializable&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol DefaultsCollectionSerializable: Collection, Defaults.Serializable {&#xA;&#x9;init(_ elements: [Element])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;protocol&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;A &lt;code&gt;Collection&lt;/code&gt; which can store into the native &lt;code&gt;UserDefaults&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It should have an initializer &lt;code&gt;init(_ elements: [Element])&lt;/code&gt; to let &lt;code&gt;Defaults&lt;/code&gt; do the de-serialization.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Defaults.SetAlgebraSerializable&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol DefaultsSetAlgebraSerializable: SetAlgebra, Defaults.Serializable {&#xA;&#x9;func toArray() -&amp;gt; [Element]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type: &lt;code&gt;protocol&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;A &lt;code&gt;SetAlgebra&lt;/code&gt; which can store into the native &lt;code&gt;UserDefaults&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It should have a function &lt;code&gt;func toArray() -&amp;gt; [Element]&lt;/code&gt; to let &lt;code&gt;Defaults&lt;/code&gt; do the serialization.&lt;/p&gt; &#xA;&lt;h2&gt;Advanced usage&lt;/h2&gt; &#xA;&lt;h3&gt;Custom types&lt;/h3&gt; &#xA;&lt;p&gt;Although &lt;code&gt;Defaults&lt;/code&gt; already has built-in support for many types, you might need to be able to use your own custom type. The below guide will show you how to make your own custom type work with &lt;code&gt;Defaults&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create your own custom type.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct User {&#xA;&#x9;let name: String&#xA;&#x9;let age: String&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Create a bridge that conforms to &lt;code&gt;Defaults.Bridge&lt;/code&gt;, which is responsible for handling serialization and deserialization.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct UserBridge: Defaults.Bridge {&#xA;&#x9;typealias Value = User&#xA;&#x9;typealias Serializable = [String: String]&#xA;&#xA;&#x9;public func serialize(_ value: Value?) -&amp;gt; Serializable? {&#xA;&#x9;&#x9;guard let value = value else {&#xA;&#x9;&#x9;&#x9;return nil&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;return [&#xA;&#x9;&#x9;&#x9;&#34;name&#34;: value.name,&#xA;&#x9;&#x9;&#x9;&#34;age&#34;: value.age&#xA;&#x9;&#x9;]&#xA;&#x9;}&#xA;&#xA;&#x9;public func deserialize(_ object: Serializable?) -&amp;gt; Value? {&#xA;&#x9;&#x9;guard&#xA;&#x9;&#x9;&#x9;let object = object,&#xA;&#x9;&#x9;&#x9;let name = object[&#34;name&#34;],&#xA;&#x9;&#x9;&#x9;let age = object[&#34;age&#34;]&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;return nil&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;return User(&#xA;&#x9;&#x9;&#x9;name: name,&#xA;&#x9;&#x9;&#x9;age: age&#xA;&#x9;&#x9;)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Create an extension of &lt;code&gt;User&lt;/code&gt; that conforms to &lt;code&gt;Defaults.Serializable&lt;/code&gt;. Its static bridge should be the bridge we created above.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct User {&#xA;&#x9;let name: String&#xA;&#x9;let age: String&#xA;}&#xA;&#xA;extension User: Defaults.Serializable {&#xA;&#x9;static let bridge = UserBridge()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Create some keys and enjoy it.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Defaults.Keys {&#xA;&#x9;static let user = Defaults.Key&amp;lt;User&amp;gt;(&#34;user&#34;, default: User(name: &#34;Hello&#34;, age: &#34;24&#34;))&#xA;&#x9;static let arrayUser = Defaults.Key&amp;lt;[User]&amp;gt;(&#34;arrayUser&#34;, default: [User(name: &#34;Hello&#34;, age: &#34;24&#34;)])&#xA;&#x9;static let setUser = Defaults.Key&amp;lt;Set&amp;lt;User&amp;gt;&amp;gt;(&#34;user&#34;, default: Set([User(name: &#34;Hello&#34;, age: &#34;24&#34;)]))&#xA;&#x9;static let dictionaryUser = Defaults.Key&amp;lt;[String: User]&amp;gt;(&#34;dictionaryUser&#34;, default: [&#34;user&#34;: User(name: &#34;Hello&#34;, age: &#34;24&#34;)])&#xA;}&#xA;&#xA;Defaults[.user].name //=&amp;gt; &#34;Hello&#34;&#xA;Defaults[.arrayUser][0].name //=&amp;gt; &#34;Hello&#34;&#xA;Defaults[.setUser].first?.name //=&amp;gt; &#34;Hello&#34;&#xA;Defaults[.dictionaryUser][&#34;user&#34;]?.name //=&amp;gt; &#34;Hello&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dynamic value&lt;/h3&gt; &#xA;&lt;p&gt;There might be situations where you want to use &lt;code&gt;[String: Any]&lt;/code&gt; directly, but &lt;code&gt;Defaults&lt;/code&gt; need its values to conform to &lt;code&gt;Defaults.Serializable&lt;/code&gt;. The type-eraser &lt;code&gt;Defaults.AnySerializable&lt;/code&gt; helps overcome this limitation.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Defaults.AnySerializable&lt;/code&gt; is only available for values that conform to &lt;code&gt;Defaults.Serializable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Warning: The type-eraser should only be used when there&#39;s no other way to handle it because it has much worse performance. It should only be used in wrapped types. For example, wrapped in &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; or &lt;code&gt;Dictionary&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Primitive type&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Defaults.AnySerializable&lt;/code&gt; conforms to &lt;code&gt;ExpressibleByStringLiteral&lt;/code&gt;, &lt;code&gt;ExpressibleByIntegerLiteral&lt;/code&gt;, &lt;code&gt;ExpressibleByFloatLiteral&lt;/code&gt;, &lt;code&gt;ExpressibleByBooleanLiteral&lt;/code&gt;, &lt;code&gt;ExpressibleByNilLiteral&lt;/code&gt;, &lt;code&gt;ExpressibleByArrayLiteral&lt;/code&gt;, and &lt;code&gt;ExpressibleByDictionaryLiteral&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Which means you can assign these primitive types directly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let any = Defaults.Key&amp;lt;Defaults.AnySerializable&amp;gt;(&#34;anyKey&#34;, default: 1)&#xA;Defaults[any] = &#34;ü¶Ñ&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Other types&lt;/h4&gt; &#xA;&lt;h5&gt;Using &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;p&gt;For other types, you will have to assign it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum mime: String, Defaults.Serializable {&#xA;&#x9;case JSON = &#34;application/json&#34;&#xA;&#x9;case STREAM = &#34;application/octet-stream&#34;&#xA;}&#xA;&#xA;let any = Defaults.Key&amp;lt;Defaults.AnySerializable&amp;gt;(&#34;anyKey&#34;, default: [Defaults.AnySerializable(mime.JSON)])&#xA;&#xA;if let mimeType: mime = Defaults[any].get() {&#xA;&#x9;print(mimeType.rawValue)&#xA;&#x9;//=&amp;gt; &#34;application/json&#34;&#xA;}&#xA;&#xA;Defaults[any].set(mime.STREAM)&#xA;&#xA;if let mimeType: mime = Defaults[any].get() {&#xA;&#x9;print(mimeType.rawValue)&#xA;&#x9;//=&amp;gt; &#34;application/octet-stream&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Wrapped in &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, or &lt;code&gt;Dictionary&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Defaults.AnySerializable&lt;/code&gt; also support the above types wrapped in &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Dictionary&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here is the example for &lt;code&gt;[String: Defaults.AnySerializable]&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Defaults.Keys {&#xA;&#x9;static let magic = Key&amp;lt;[String: Defaults.AnySerializable]&amp;gt;(&#34;magic&#34;, default: [:])&#xA;}&#xA;&#xA;enum mime: String, Defaults.Serializable {&#xA;&#x9;case JSON = &#34;application/json&#34;&#xA;}&#xA;&#xA;// ‚Ä¶&#xA;Defaults[.magic][&#34;unicorn&#34;] = &#34;ü¶Ñ&#34;&#xA;&#xA;if let value: String = Defaults[.magic][&#34;unicorn&#34;]?.get() {&#xA;&#x9;print(value)&#xA;&#x9;//=&amp;gt; &#34;ü¶Ñ&#34;&#xA;}&#xA;&#xA;Defaults[.magic][&#34;number&#34;] = 3&#xA;Defaults[.magic][&#34;boolean&#34;] = true&#xA;Defaults[.magic][&#34;enum&#34;] = Defaults.AnySerializable(mime.JSON)&#xA;&#xA;if let mimeType: mime = Defaults[.magic][&#34;enum&#34;]?.get() {&#xA;&#x9;print(mimeType.rawValue)&#xA;&#x9;//=&amp;gt; &#34;application/json&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more examples, see &lt;a href=&#34;https://raw.githubusercontent.com/sindresorhus/Defaults/main/Tests/DefaultsTests/DefaultsAnySeriliazableTests.swift&#34;&gt;Tests/DefaultsAnySerializableTests&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Serialization for ambiguous &lt;code&gt;Codable&lt;/code&gt; type&lt;/h3&gt; &#xA;&lt;p&gt;You may have a type that conforms to &lt;code&gt;Codable &amp;amp; NSSecureCoding&lt;/code&gt; or a &lt;code&gt;Codable &amp;amp; RawRepresentable&lt;/code&gt; enum. By default, &lt;code&gt;Defaults&lt;/code&gt; will prefer the &lt;code&gt;Codable&lt;/code&gt; conformance and use the &lt;code&gt;CodableBridge&lt;/code&gt; to serialize it into a JSON string. If you want to serialize it as a &lt;code&gt;NSSecureCoding&lt;/code&gt; data or use the raw value of the &lt;code&gt;RawRepresentable&lt;/code&gt; enum, you can conform to &lt;code&gt;Defaults.PreferNSSecureCoding&lt;/code&gt; or &lt;code&gt;Defaults.PreferRawRepresentable&lt;/code&gt; to override the default bridge:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum mime: String, Codable, Defaults.Serializable, Defaults.PreferRawRepresentable {&#xA;&#x9;case JSON = &#34;application/json&#34;&#xA;}&#xA;&#xA;extension Defaults.Keys {&#xA;&#x9;static let magic = Key&amp;lt;[String: Defaults.AnySerializable]&amp;gt;(&#34;magic&#34;, default: [:])&#xA;}&#xA;&#xA;print(UserDefaults.standard.string(forKey: &#34;magic&#34;))&#xA;//=&amp;gt; application/json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Had we not added &lt;code&gt;Defaults.PreferRawRepresentable&lt;/code&gt;, the stored representation would have been &lt;code&gt;&#34;application/json&#34;&lt;/code&gt; instead of &lt;code&gt;application/json&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This can also be useful if you conform a type you don&#39;t control to &lt;code&gt;Defaults.Serializable&lt;/code&gt; as the type could receive &lt;code&gt;Codable&lt;/code&gt; conformance at any time and then the stored representation would change, which could make the value unreadable. By explicitly defining which bridge to use, you ensure the stored representation will always stay the same.&lt;/p&gt; &#xA;&lt;h3&gt;Custom &lt;code&gt;Collection&lt;/code&gt; type&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create your &lt;code&gt;Collection&lt;/code&gt; and make its elements conform to &lt;code&gt;Defaults.Serializable&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Bag&amp;lt;Element: Defaults.Serializable&amp;gt;: Collection {&#xA;&#x9;var items: [Element]&#xA;&#xA;&#x9;var startIndex: Int { items.startIndex }&#xA;&#x9;var endIndex: Int { items.endIndex }&#xA;&#xA;&#x9;mutating func insert(element: Element, at: Int) {&#xA;&#x9;&#x9;items.insert(element, at: at)&#xA;&#x9;}&#xA;&#xA;&#x9;func index(after index: Int) -&amp;gt; Int {&#xA;&#x9;&#x9;items.index(after: index)&#xA;&#x9;}&#xA;&#xA;&#x9;subscript(position: Int) -&amp;gt; Element {&#xA;&#x9;&#x9;items[position]&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Create an extension of &lt;code&gt;Bag&lt;/code&gt; that conforms to &lt;code&gt;Defaults.CollectionSerializable&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Bag: Defaults.CollectionSerializable {&#xA;&#x9;init(_ elements: [Element]) {&#xA;&#x9;&#x9;self.items = elements&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Create some keys and enjoy it.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Defaults.Keys {&#xA;&#x9;static let stringBag = Key&amp;lt;Bag&amp;lt;String&amp;gt;&amp;gt;(&#34;stringBag&#34;, default: Bag([&#34;Hello&#34;, &#34;World!&#34;]))&#xA;}&#xA;&#xA;Defaults[.stringBag][0] //=&amp;gt; &#34;Hello&#34;&#xA;Defaults[.stringBag][1] //=&amp;gt; &#34;World!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom &lt;code&gt;SetAlgebra&lt;/code&gt; type&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create your &lt;code&gt;SetAlgebra&lt;/code&gt; and make its elements conform to &lt;code&gt;Defaults.Serializable &amp;amp; Hashable&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct SetBag&amp;lt;Element: Defaults.Serializable &amp;amp; Hashable&amp;gt;: SetAlgebra {&#xA;&#x9;var store = Set&amp;lt;Element&amp;gt;()&#xA;&#xA;&#x9;init() {}&#xA;&#xA;&#x9;init(_ store: Set&amp;lt;Element&amp;gt;) {&#xA;&#x9;&#x9;self.store = store&#xA;&#x9;}&#xA;&#xA;&#x9;func contains(_ member: Element) -&amp;gt; Bool {&#xA;&#x9;&#x9;store.contains(member)&#xA;&#x9;}&#xA;&#xA;&#x9;func union(_ other: SetBag) -&amp;gt; SetBag {&#xA;&#x9;&#x9;SetBag(store.union(other.store))&#xA;&#x9;}&#xA;&#xA;&#x9;func intersection(_ other: SetBag) -&amp;gt; SetBag {&#xA;&#x9;&#x9;var setBag = SetBag()&#xA;&#x9;&#x9;setBag.store = store.intersection(other.store)&#xA;&#x9;&#x9;return setBag&#xA;&#x9;}&#xA;&#xA;&#x9;func symmetricDifference(_ other: SetBag) -&amp;gt; SetBag {&#xA;&#x9;&#x9;var setBag = SetBag()&#xA;&#x9;&#x9;setBag.store = store.symmetricDifference(other.store)&#xA;&#x9;&#x9;return setBag&#xA;&#x9;}&#xA;&#xA;&#x9;@discardableResult&#xA;&#x9;mutating func insert(_ newMember: Element) -&amp;gt; (inserted: Bool, memberAfterInsert: Element) {&#xA;&#x9;&#x9;store.insert(newMember)&#xA;&#x9;}&#xA;&#xA;&#x9;mutating func remove(_ member: Element) -&amp;gt; Element? {&#xA;&#x9;&#x9;store.remove(member)&#xA;&#x9;}&#xA;&#xA;&#x9;mutating func update(with newMember: Element) -&amp;gt; Element? {&#xA;&#x9;&#x9;store.update(with: newMember)&#xA;&#x9;}&#xA;&#xA;&#x9;mutating func formUnion(_ other: SetBag) {&#xA;&#x9;&#x9;store.formUnion(other.store)&#xA;&#x9;}&#xA;&#xA;&#x9;mutating func formSymmetricDifference(_ other: SetBag) {&#xA;&#x9;&#x9;store.formSymmetricDifference(other.store)&#xA;&#x9;}&#xA;&#xA;&#x9;mutating func formIntersection(_ other: SetBag) {&#xA;&#x9;&#x9;store.formIntersection(other.store)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Create an extension of &lt;code&gt;SetBag&lt;/code&gt; that conforms to &lt;code&gt;Defaults.SetAlgebraSerializable&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension SetBag: Defaults.SetAlgebraSerializable {&#xA;&#x9;func toArray() -&amp;gt; [Element] {&#xA;&#x9;&#x9;Array(store)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Create some keys and enjoy it.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Defaults.Keys {&#xA;&#x9;static let stringSet = Key&amp;lt;SetBag&amp;lt;String&amp;gt;&amp;gt;(&#34;stringSet&#34;, default: SetBag([&#34;Hello&#34;, &#34;World!&#34;]))&#xA;}&#xA;&#xA;Defaults[.stringSet].contains(&#34;Hello&#34;) //=&amp;gt; true&#xA;Defaults[.stringSet].contains(&#34;World!&#34;) //=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;How can I store a dictionary of arbitrary values?&lt;/h3&gt; &#xA;&lt;p&gt;After &lt;code&gt;Defaults&lt;/code&gt; v5, you don&#39;t need to use &lt;code&gt;Codable&lt;/code&gt; to store dictionary, &lt;code&gt;Defaults&lt;/code&gt; supports storing dictionary natively. For &lt;code&gt;Defaults&lt;/code&gt; support types, see &lt;a href=&#34;https://raw.githubusercontent.com/sindresorhus/Defaults/main/#support-types&#34;&gt;Support types&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How is this different from &lt;a href=&#34;https://github.com/radex/SwiftyUserDefaults&#34;&gt;&lt;code&gt;SwiftyUserDefaults&lt;/code&gt;&lt;/a&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;It&#39;s inspired by that package and other solutions. The main difference is that this module doesn&#39;t hardcode the default values and comes with Codable support.&lt;/p&gt; &#xA;&lt;h2&gt;Maintainers&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sindresorhus&#34;&gt;Sindre Sorhus&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fredyshox&#34;&gt;Kacper RƒÖczy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hank121314&#34;&gt;@hank121314&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Related&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sindresorhus/Preferences&#34;&gt;Preferences&lt;/a&gt; - Add a preferences window to your macOS app&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sindresorhus/KeyboardShortcuts&#34;&gt;KeyboardShortcuts&lt;/a&gt; - Add user-customizable global keyboard shortcuts to your macOS app&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sindresorhus/LaunchAtLogin&#34;&gt;LaunchAtLogin&lt;/a&gt; - Add &#34;Launch at Login&#34; functionality to your macOS app&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sindresorhus/Regex&#34;&gt;Regex&lt;/a&gt; - Swifty regular expressions&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sindresorhus/DockProgress&#34;&gt;DockProgress&lt;/a&gt; - Show progress in your app&#39;s Dock icon&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sindresorhus/Gifski&#34;&gt;Gifski&lt;/a&gt; - Convert videos to high-quality GIFs on your Mac&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/search?q=user%3Asindresorhus+language%3Aswift&#34;&gt;More‚Ä¶&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>