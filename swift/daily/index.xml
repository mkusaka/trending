<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-07-01T01:35:40Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>vapor/leaf</title>
    <updated>2024-07-01T01:35:40Z</updated>
    <id>tag:github.com,2024-07-01:/vapor/leaf</id>
    <link href="https://github.com/vapor/leaf" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üçÉ An expressive, performant, and extensible templating language built for Swift.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;picture&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://user-images.githubusercontent.com/1130717/259964919-5afdacc0-310d-408b-9d83-9018b92d96e0.png&#34;&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: light)&#34; srcset=&#34;https://user-images.githubusercontent.com/1130717/259964940-b450247b-8110-4757-870f-eda1a34b2e81.png&#34;&gt; &#xA;  &lt;img src=&#34;https://user-images.githubusercontent.com/1130717/259964940-b450247b-8110-4757-870f-eda1a34b2e81.png&#34; height=&#34;96&#34; alt=&#34;Leaf&#34;&gt; &#xA; &lt;/picture&gt; &lt;br&gt; &lt;br&gt; &lt;a href=&#34;https://docs.vapor.codes/4.0/&#34;&gt;&lt;img src=&#34;https://design.vapor.codes/images/readthedocs.svg?sanitize=true&#34; alt=&#34;Documentation&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/vapor&#34;&gt;&lt;img src=&#34;https://design.vapor.codes/images/discordchat.svg?sanitize=true&#34; alt=&#34;Team Chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/vapor/leaf/main/LICENSE&#34;&gt;&lt;img src=&#34;https://design.vapor.codes/images/mitlicense.svg?sanitize=true&#34; alt=&#34;MIT License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/vapor/leaf/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/vapor/leaf/test.yml?event=push&amp;amp;style=plastic&amp;amp;logo=github&amp;amp;label=tests&amp;amp;logoColor=%23ccc&#34; alt=&#34;Continuous Integration&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/github/vapor/leaf&#34;&gt;&lt;img src=&#34;https://img.shields.io/codecov/c/github/vapor/leaf?style=plastic&amp;amp;logo=codecov&amp;amp;label=codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swift.org&#34;&gt;&lt;img src=&#34;https://design.vapor.codes/images/swift57up.svg?sanitize=true&#34; alt=&#34;Swift 5.7+&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;br&gt;</summary>
  </entry>
  <entry>
    <title>vapor/sql-kit</title>
    <updated>2024-07-01T01:35:40Z</updated>
    <id>tag:github.com,2024-07-01:/vapor/sql-kit</id>
    <link href="https://github.com/vapor/sql-kit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;*Ô∏è‚É£ Build SQL queries in Swift. Extensible, protocol-based design that supports DQL, DML, and DDL.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;picture&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://github.com/vapor/sql-kit/assets/1130717/b5828634-c1a1-4d91-b25d-20e033b77269&#34;&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: light)&#34; srcset=&#34;https://github.com/vapor/sql-kit/assets/1130717/f45e4b01-0579-4011-8b06-0f159e0d386f&#34;&gt; &#xA;  &lt;img src=&#34;https://github.com/vapor/sql-kit/assets/1130717/f45e4b01-0579-4011-8b06-0f159e0d386f&#34; height=&#34;96&#34; alt=&#34;SQLKit&#34;&gt; &#xA; &lt;/picture&gt; &lt;br&gt; &lt;br&gt; &lt;a href=&#34;https://docs.vapor.codes/4.0/&#34;&gt;&lt;img src=&#34;https://design.vapor.codes/images/readthedocs.svg?sanitize=true&#34; alt=&#34;Documentation&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/vapor&#34;&gt;&lt;img src=&#34;https://design.vapor.codes/images/discordchat.svg?sanitize=true&#34; alt=&#34;Team Chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/vapor/sql-kit/main/LICENSE&#34;&gt;&lt;img src=&#34;https://design.vapor.codes/images/mitlicense.svg?sanitize=true&#34; alt=&#34;MIT License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/vapor/sql-kit/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/vapor/sql-kit/test.yml?event=push&amp;amp;style=plastic&amp;amp;logo=github&amp;amp;label=tests&amp;amp;logoColor=%23ccc&#34; alt=&#34;Continuous Integration&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/github/vapor/sql-kit&#34;&gt;&lt;img src=&#34;https://img.shields.io/codecov/c/github/vapor/sql-kit?style=plastic&amp;amp;logo=codecov&amp;amp;label=codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swift.org&#34;&gt;&lt;img src=&#34;https://design.vapor.codes/images/swift58up.svg?sanitize=true&#34; alt=&#34;Swift 5.8+&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;Build SQL queries in Swift. Extensible, protocol-based design that supports DQL, DML, and DDL.&lt;/p&gt; &#xA;&lt;h2&gt;Using SQLKit&lt;/h2&gt; &#xA;&lt;p&gt;Use standard SwiftPM syntax to include SQLKit as a dependency in your &lt;code&gt;Package.swift&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.package(url: &#34;https://github.com/vapor/sql-kit.git&#34;, from: &#34;3.0.0&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;SQLKit 3.x requires &lt;a href=&#34;https://github.com/apple/swift-nio&#34;&gt;SwiftNIO&lt;/a&gt; 2.x or later. Previous major versions are no longer supported.&lt;/p&gt; &#xA;&lt;h3&gt;Supported Platforms&lt;/h3&gt; &#xA;&lt;p&gt;SQLKit supports the following platforms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ubuntu 20.04+&lt;/li&gt; &#xA; &lt;li&gt;macOS 10.15+&lt;/li&gt; &#xA; &lt;li&gt;iOS 13+&lt;/li&gt; &#xA; &lt;li&gt;tvOS 13+ and watchOS 7+ (experimental)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;SQLKit is an API for building and serializing SQL queries in Swift. SQLKit attempts to abstract away SQL dialect inconsistencies where possible allowing you to write queries that can run on multiple database flavors. Where abstraction is not possible, SQLKit provides powerful APIs for custom or dynamic behavior.&lt;/p&gt; &#xA;&lt;h3&gt;Supported Databases&lt;/h3&gt; &#xA;&lt;p&gt;These database packages are drivers for SQLKit:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vapor/postgres-kit&#34;&gt;vapor/postgres-kit&lt;/a&gt;: PostgreSQL&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vapor/mysql-kit&#34;&gt;vapor/mysql-kit&lt;/a&gt;: MySQL and MariaDB&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vapor/sqlite-kit&#34;&gt;vapor/sqlite-kit&lt;/a&gt;: SQLite&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;SQLKit does not deal with creating or managing database connections itself. This package is focused entirely around building and serializing SQL queries. To connect to your SQL database, refer to your specific database package&#39;s documentation. Once you are connected to your database and have an instance of &lt;code&gt;SQLDatabase&lt;/code&gt;, you are ready to continue.&lt;/p&gt; &#xA;&lt;h3&gt;Database&lt;/h3&gt; &#xA;&lt;p&gt;Instances of &lt;code&gt;SQLDatabase&lt;/code&gt; are capable of serializing and executing &lt;code&gt;SQLExpression&lt;/code&gt;s.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let db: any SQLDatabase = ...&#xA;db.execute(sql: any SQLExpression, onRow: (any SQLRow) -&amp;gt; ())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;SQLExpression&lt;/code&gt; is a protocol that represents a SQL query string and optional bind values. It can represent an entire SQL query or just a fragment.&lt;/p&gt; &#xA;&lt;p&gt;SQLKit provides &lt;code&gt;SQLExpression&lt;/code&gt;s for common queries like &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;CREATE TABLE&lt;/code&gt;, and many more.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var select = SQLSelect()&#xA;select.columns = [...]&#xA;select.tables = [...]&#xA;select.predicate = ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;SQLDatabase&lt;/code&gt; can be used to create fluent query builders for most of these query types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Planet: Codable { var id: Int, name: String }&#xA;&#xA;let db: some SQLDatabase = ...&#xA;try await db.create(table: &#34;planets&#34;)&#xA;    .column(&#34;id&#34;, type: .int, .primaryKey(autoIncrement: true), .notNull)&#xA;    .column(&#34;name&#34;, type: .string, .notNull)&#xA;    .run()&#xA;try await db.insert(into: &#34;planets&#34;)&#xA;    .columns(&#34;id&#34;, &#34;name&#34;)&#xA;    .values(SQLLiteral.default, SQLBind(&#34;Earth&#34;))&#xA;    .values(SQLLiteral.default, SQLBind(&#34;Mars&#34;))&#xA;    .run()&#xA;let planets = try await db.select()&#xA;    .columns(&#34;id&#34;, &#34;name&#34;)&#xA;    .from(&#34;planets&#34;)&#xA;    .all(decoding: Planet.self)&#xA;print(planets) // [Planet(id: 1, name: &#34;Earth&#34;), Planet(id: 2, name: &#34;Mars&#34;)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can execute a query builder by calling &lt;code&gt;run()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Rows&lt;/h3&gt; &#xA;&lt;p&gt;For query builders that support returning results (e.g. any builder conforming to the &lt;code&gt;SQLQueryFetcher&lt;/code&gt; protocol), there are additional methods for handling the database output:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;all()&lt;/code&gt;: Returns an array of rows.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;first()&lt;/code&gt;: Returns an optional row.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;run(_:)&lt;/code&gt;: Accepts a closure that handles rows as they are returned.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Each of these methods returns &lt;code&gt;SQLRow&lt;/code&gt;, which has methods for access column values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let row: any SQLRow&#xA;let name = try row.decode(column: &#34;name&#34;, as: String.self)&#xA;print(name) // String&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Codable&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;SQLRow&lt;/code&gt; also supports decoding &lt;code&gt;Codable&lt;/code&gt; models directly from a row.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Planet: Codable {&#xA;    var name: String&#xA;}&#xA;&#xA;let planet = try row.decode(model: Planet.self)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Query builders that support returning results have convenience methods for automatically decoding models.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let planets: [Planet] = try await db.select()&#xA;    ...&#xA;    .all(decoding: Planet.self)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Select&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;SQLDatabase.select()&lt;/code&gt; method creates a &lt;code&gt;SELECT&lt;/code&gt; query builder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let planets: [any SQLRow] = try await db.select()&#xA;    .columns(&#34;id&#34;, &#34;name&#34;)&#xA;    .from(&#34;planets&#34;)&#xA;    .where(&#34;name&#34;, .equal, &#34;Earth&#34;)&#xA;    .all()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code generates the following SQL when used with the PostgresKit driver:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-PLpgsql&#34;&gt;SELECT &#34;id&#34;, &#34;name&#34; FROM &#34;planets&#34; WHERE &#34;name&#34; = $1 -- bindings: [&#34;Earth&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that &lt;code&gt;Encodable&lt;/code&gt; values are automatically bound as parameters instead of being serialized directly to the query.&lt;/p&gt; &#xA;&lt;p&gt;The select builder includes the following methods (typically with several variations):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;columns()&lt;/code&gt; (specify a list of columns and/or expressions to return)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;from()&lt;/code&gt; (specify a table to select from)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;join()&lt;/code&gt; (specify additional tables and how to relate them to others)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;where()&lt;/code&gt; and &lt;code&gt;orWhere()&lt;/code&gt; (specify conditions that narrow down the possible results)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;limit()&lt;/code&gt; and &lt;code&gt;offset()&lt;/code&gt; (specify a limited and/or offsetted range of results to return)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;orderBy()&lt;/code&gt; (specify how to sort results before returning them)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;groupBy()&lt;/code&gt; (specify columns and/or expressions for aggregating results)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;having()&lt;/code&gt; and &lt;code&gt;orHaving()&lt;/code&gt; (specify secondary conditions to apply to the results after aggregation)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;distinct()&lt;/code&gt; (specify coalescing of duplicate results)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;for()&lt;/code&gt; and &lt;code&gt;lockingClause()&lt;/code&gt; (specify locking behavior for rows that appear in results)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Conditional expressions provided to &lt;code&gt;where()&lt;/code&gt; or &lt;code&gt;having()&lt;/code&gt; are joined with &lt;code&gt;AND&lt;/code&gt;. Corresponding &lt;code&gt;orWhere()&lt;/code&gt; and &lt;code&gt;orHaving()&lt;/code&gt; methods join conditions with &lt;code&gt;OR&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;builder.where(&#34;name&#34;, .equal, &#34;Earth&#34;).orWhere(&#34;name&#34;, .equal, &#34;Mars&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code generates the following SQL when used with the MySQL driver:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;WHERE `name` = ? OR `name` = ? -- bindings: [&#34;Earth&#34;, &#34;Mars&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;where()&lt;/code&gt;, &lt;code&gt;orWhere()&lt;/code&gt;, &lt;code&gt;having()&lt;/code&gt;, and &lt;code&gt;orHaving()&lt;/code&gt; also support creating grouped clauses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;builder.where(&#34;name&#34;, .notEqual, SQLLiteral.null).where {&#xA;    $0.where(&#34;name&#34;, .equal, SQLBind(&#34;Milky Way&#34;))&#xA;      .orWhere(&#34;name&#34;, .equal, SQLBind(&#34;Andromeda&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code generates the following SQL when used with the SQLite driver:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;WHERE &#34;name&#34; &amp;lt;&amp;gt; NULL AND (&#34;name&#34; = ?1 OR &#34;name&#34; = ?2) -- bindings: [&#34;Milky Way&#34;, &#34;Andromeda&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Insert&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;insert(into:)&lt;/code&gt; method creates an &lt;code&gt;INSERT&lt;/code&gt; query builder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try await db.insert(into: &#34;galaxies&#34;)&#xA;    .columns(&#34;id&#34;, &#34;name&#34;)&#xA;    .values(SQLLiteral.default, SQLBind(&#34;Milky Way&#34;))&#xA;    .values(SQLLiteral.default, SQLBind(&#34;Andromeda&#34;))&#xA;    .run()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code generates the following SQL when used with the PostgreSQL driver:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-PLpgsql&#34;&gt;INSERT INTO &#34;galaxies&#34; (&#34;id&#34;, &#34;name&#34;) VALUES (DEFAULT, $1), (DEFAULT, $2) -- bindings: [&#34;Milky Way&#34;, &#34;Andromeda&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The insert builder also has a method for encoding a &lt;code&gt;Codable&lt;/code&gt; type as a set of values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Galaxy: Codable {&#xA;    var name: String&#xA;}&#xA;&#xA;try builder.model(Galaxy(name: &#34;Milky Way&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code generates the same SQL as would &lt;code&gt;builder.columns(&#34;name&#34;).values(&#34;Milky Way&#34;)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Update&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;update(_:)&lt;/code&gt; method creates an &lt;code&gt;UPDATE&lt;/code&gt; query builder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try await db.update(&#34;planets&#34;)&#xA;    .set(&#34;name&#34;, to: &#34;Jupiter&#34;)&#xA;    .where(&#34;name&#34;, .equal, &#34;Jupiter&#34;)&#xA;    .run()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code generates the following SQL when used with the MySQL driver:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;UPDATE `planets` SET `name` = ? WHERE `name` = ? -- bindings: [&#34;Jupiter&#34;, &#34;Jupiter&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The update builder supports the same &lt;code&gt;where()&lt;/code&gt; and &lt;code&gt;orWhere()&lt;/code&gt; methods as the select builder, via the &lt;code&gt;SQLPredicateBuilder&lt;/code&gt; protocol.&lt;/p&gt; &#xA;&lt;h2&gt;Delete&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;delete(from:)&lt;/code&gt; method creates a &lt;code&gt;DELETE&lt;/code&gt; query builder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;try await db.delete(from: &#34;planets&#34;)&#xA;    .where(&#34;name&#34;, .equal, &#34;Jupiter&#34;)&#xA;    .run()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code generates the following SQL when used with the SQLite driver:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DELETE FROM &#34;planets&#34; WHERE &#34;name&#34; = ?1 -- bindings: [&#34;Jupiter&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The delete builder is also an &lt;code&gt;SQLPredicateBuilder&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Raw&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;raw(_:)&lt;/code&gt; method allows passing custom SQL query strings, with support for parameterized bindings and correctly-quoted identifiers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let planets = try await db.raw(&#34;SELECT \(SQLLiteral.all) FROM \(ident: table) WHERE \(ident: name) = \(bind: &#34;planet&#34;)&#34;)&#xA;    .all()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code generates the following SQL when used with the PostgreSQL driver:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-PLpgsql&#34;&gt;SELECT * FROM &#34;planets&#34; WHERE &#34;name&#34; = $1 -- bindings: [&#34;planet&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;\(bind:)&lt;/code&gt; interpolation should be used for any user input to avoid SQL injection. The &lt;code&gt;\(ident:)&lt;/code&gt; interpolation is used to safely specify identifiers such as table and column names.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] Always prefer a structured query (i.e. one for which a builder or expression type exists) over raw queries. Consider writing your own &lt;code&gt;SQLExpression&lt;/code&gt;s, and even your own &lt;code&gt;SQLQueryBuilder&lt;/code&gt;s, rather than using raw queries, and don&#39;t hesitate to &lt;a href=&#34;https://github.com/vapor/sql-kit/issues/new&#34;&gt;open an issue&lt;/a&gt; to ask for additional feature support.&lt;/p&gt; &#xA;&lt;/blockquote&gt;</summary>
  </entry>
</feed>