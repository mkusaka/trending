<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-07-31T01:39:55Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>NordicSemiconductor/IOS-nRF-Connect-Device-Manager</title>
    <updated>2025-07-31T01:39:55Z</updated>
    <id>tag:github.com,2025-07-31:/NordicSemiconductor/IOS-nRF-Connect-Device-Manager</id>
    <link href="https://github.com/NordicSemiconductor/IOS-nRF-Connect-Device-Manager" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A mobile management library for devices supporting nRF Connect Device Manager.&lt;/p&gt;&lt;hr&gt;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE]&lt;br&gt; This repository is a fork of the &lt;a href=&#34;https://github.com/JuulLabs-OSS/mcumgr-ios&#34;&gt;McuManager iOS Library&lt;/a&gt;, which is no longer being supported by its original maintainer. As of 2021, we have taken ownership of the library, so all new features and bug fixes will be added here. Please, migrate your projects to point to this Git repsository in order to get future updates. See &lt;a href=&#34;https://github.com/NordicSemiconductor/Android-nRF-Connect-Device-Manager#migration-from-the-original-repo&#34;&gt;migration guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;nRF Connect Device Manager&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/Swift-5.10-f05237.svg?sanitize=true&#34; alt=&#34;Swift&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Platforms-iOS%20%7C%20iPadOS%20%7C%20macOS-333333.svg?sanitize=true&#34; alt=&#34;Platforms&#34;&gt; &lt;a href=&#34;https://github.com/NordicSemiconductor/IOS-nRF-Connect-Device-Manager/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/NordicSemiconductor/IOS-nRF-Connect-Device-Manager&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/NordicSemiconductor/IOS-nRF-Connect-Device-Manager/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/NordicSemiconductor/IOS-nRF-Connect-Device-Manager.svg?sanitize=true&#34; alt=&#34;Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/SwiftPM-Compatible-brightgreen&#34; alt=&#34;Swift Package Manager&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/CocoaPods-Compatible-brightgreen&#34; alt=&#34;CocoaPods&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;nRF Connect Device Manager library is compatible with &lt;a href=&#34;https://docs.zephyrproject.org/3.2.0/services/device_mgmt/mcumgr.html#overview&#34;&gt;McuManager (or McuMgr for short)&lt;/a&gt; and &lt;a href=&#34;&#34;&gt;SUIT (shorthand for Software Update for the Internet of Things)&lt;/a&gt;. McuManager is a management subsystem supported by &lt;a href=&#34;https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/index.html&#34;&gt;nRF Connect SDK&lt;/a&gt;, &lt;a href=&#34;https://docs.zephyrproject.org/3.2.0/introduction/index.html&#34;&gt;Zephyr&lt;/a&gt; and Apache Mynewt. McuManager relies on its own &lt;a href=&#34;https://docs.mcuboot.com/&#34;&gt;MCUboot&lt;/a&gt; bootloader for secure bootstrapping after a firmware update and, uses the &lt;a href=&#34;https://docs.zephyrproject.org/3.2.0/services/device_mgmt/smp_protocol.html&#34;&gt;Simple Management Protocol, or SMP&lt;/a&gt;, for communication over Bluetooth LE. The SMP Transport definition for Bluetooth Low Energy, which this library implements, &lt;a href=&#34;https://docs.zephyrproject.org/latest/services/device_mgmt/smp_transport.html&#34;&gt;can be found here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;SUIT and McuManager are related, but not interchangeable. SUIT relies on its own bootloader, but communicates over the SMP Service. Additionally, SUIT supports some functionalities from McuManager, but is not guaranteed to do so. It&#39;s best to always check if a McuManager feature is supported by sending the request, rather than assuming it is.&lt;/p&gt; &#xA;&lt;p&gt;The library provides a transport agnostic implementation of the McuManager protocol. It contains a default implementation for BLE transport.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Minimum required iOS version is 12.0, originally released in Fall of 2018.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!Warning]&lt;br&gt; This library, the default &amp;amp; main API for Device Firmware Update by Nordic Semiconductor, &lt;strong&gt;should not be confused with the previous protocol, NordicDFU&lt;/strong&gt;, serviced by the &lt;a href=&#34;https://github.com/NordicSemiconductor/IOS-DFU-Library&#34;&gt;Old DFU Library&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Compatible Devices&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;nRF52 Series&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;nRF53 Series&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;nRF54 Series&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;nRF91 Series&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NordicSemiconductor/IOS-nRF-Connect-Device-Manager/main/nRF52-Series-small.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NordicSemiconductor/IOS-nRF-Connect-Device-Manager/main/nRF53-Series-small.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NordicSemiconductor/IOS-nRF-Connect-Device-Manager/main/nRF54-Series-small.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NordicSemiconductor/IOS-nRF-Connect-Device-Manager/main/nRF91-Series-small.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;This library is designed to work with the SMP Transport over BLE. It is implemented and maintained by Nordic Semiconductor, but it should work any devices communicating via SMP Protocol. &lt;strong&gt;If you encounter an issue communicating with a device using any chip, not just Nordic, please file an Issue&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Library Adoption into an Existing Project (Install)&lt;/h2&gt; &#xA;&lt;h3&gt;SPM or Swift Package Manager (Recommended)&lt;/h3&gt; &#xA;&lt;p&gt;In Xcode, open your root Project file. Then, switch to the &lt;em&gt;Package Dependencies&lt;/em&gt; Tab, and hit the &lt;em&gt;+&lt;/em&gt; button underneath your list of added Packages. A new modal window will pop-up. On the upper-right corner of this new window, there&#39;s a search box. Paste the URL for this GitHub project &lt;code&gt;https://github.com/NordicSemiconductor/IOS-nRF-Connect-Device-Manager&lt;/code&gt; and the &lt;em&gt;Add Package&lt;/em&gt; button should enable.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NordicSemiconductor/IOS-nRF-Connect-Device-Manager/main/xcode-add-package.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;After Xcode fetches your new project dependency, you should now be able to add &lt;code&gt;import iOSMcuManagerLibrary&lt;/code&gt; to the Swift files from where you&#39;d like to call upon this library. And you&#39;re good to go.&lt;/p&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod &#39;iOSMcuManagerLibrary&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building the Example Project (Requires Xcode &amp;amp; CocoaPods)&lt;/h2&gt; &#xA;&lt;h3&gt;&#34;Cocoapods?&#34;&lt;/h3&gt; &#xA;&lt;p&gt;Not to worry, we have you covered. Just &lt;a href=&#34;https://guides.cocoapods.org/using/getting-started.html&#34;&gt;follow the instructions here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Instructions&lt;/h3&gt; &#xA;&lt;p&gt;First, clone the project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/NordicSemiconductor/IOS-nRF-Connect-Device-Manager.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, open the project&#39;s directory, navigate to the &lt;em&gt;Example&lt;/em&gt; folder, and run &lt;code&gt;pod install&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd IOS-nRF-Connect-Device-Manager/&#xA;cd Example/&#xA;pod install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output should look similar to this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Analyzing dependencies&#xA;Downloading dependencies&#xA;Installing SwiftCBOR (0.4.4)&#xA;Installing ZIPFoundation (0.9.11)&#xA;Installing iOSMcuManagerLibrary (1.3.1)&#xA;Generating Pods project&#xA;Integrating client project&#xA;Pod installation complete! There are 2 dependencies from the Podfile and 3 total pods installed.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should now be able to open, build &amp;amp; run the Example project by opening the &lt;em&gt;nRF Connect Device Manager.xcworkspace&lt;/em&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;open nRF\ Connect\ Device\ Manager.xcworkspace&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Introduction&lt;/h1&gt; &#xA;&lt;p&gt;McuManager is an application layer protocol used to manage and monitor microcontrollers running Apache Mynewt and Zephyr. More specifically, McuManager implements over-the-air (OTA) firmware upgrades, logs, stats, file-system and configuration management. Devices running SUIT as their bootloader might respond to McuManager commands, but it is not guaranteed.&lt;/p&gt; &#xA;&lt;h2&gt;Command Groups&lt;/h2&gt; &#xA;&lt;p&gt;McuManager is organized by functionality into command groups. In &lt;em&gt;mcumgr-ios&lt;/em&gt;, command groups are called managers and extend the &lt;code&gt;McuManager&lt;/code&gt; class. The managers (groups) implemented in &lt;em&gt;mcumgr-ios&lt;/em&gt; are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;DefaultManager&lt;/code&gt;&lt;/strong&gt;: Contains commands relevant to the OS. This includes task and memory pool statistics, device time read &amp;amp; write, and device reset.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;ImageManager&lt;/code&gt;&lt;/strong&gt;: Manage image state on the device and perform image uploads.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;StatsManager&lt;/code&gt;&lt;/strong&gt;: Read stats from the device.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;SettingsManager&lt;/code&gt;&lt;/strong&gt;: Read/Write config values on the device.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;LogManager&lt;/code&gt;&lt;/strong&gt;: Collect logs from the device.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;CrashManager&lt;/code&gt;&lt;/strong&gt;: Run crash tests on the device.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;RunTestManager&lt;/code&gt;&lt;/strong&gt;: Runs tests on the device.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;FileSystemManager&lt;/code&gt;&lt;/strong&gt;: Download/upload files from the device file system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;BasicManager&lt;/code&gt;&lt;/strong&gt;: Send &#39;Erase App Settings&#39; command to the device.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;ShellManager&lt;/code&gt;&lt;/strong&gt;: Send McuMgr Shell commands to the device.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;SuitManager&lt;/code&gt;&lt;/strong&gt;: Send SUIT (Software Update for Internet of Things)-specific commands to the device. This applies to devices running SUIT as their bootloader.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Firmware Upgrade&lt;/h1&gt; &#xA;&lt;p&gt;Firmware upgrade is generally a four step process performed using commands from the &lt;code&gt;image&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt; commands groups: &lt;code&gt;upload&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, and &lt;code&gt;confirm&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This library provides &lt;code&gt;FirmwareUpgradeManager&lt;/code&gt; as a convenience for upgrading the image running on a device. &lt;code&gt;FirmwareUpgradeManager&lt;/code&gt; will forward McuMgr/McuBoot-specific commands to &lt;code&gt;ImageManager&lt;/code&gt;, or redirect them to &lt;code&gt;SuitManager&lt;/code&gt; if a SUIT upgrade procedure (such as the upload being a SUIT Envelope) is detected.&lt;/p&gt; &#xA;&lt;h2&gt;FirmwareUpgradeManager&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;FirmwareUpgradeManager&lt;/code&gt; provides an easy way to perform firmware upgrades on a device. A &lt;code&gt;FirmwareUpgradeManager&lt;/code&gt; must be initialized with an &lt;code&gt;McuMgrTransport&lt;/code&gt; which defines the transport scheme and device. Once initialized, &lt;code&gt;FirmwareUpgradeManager&lt;/code&gt; can perform one firmware upgrade at a time. Firmware upgrades are started using the &lt;code&gt;start(package: McuMgrPackage)&lt;/code&gt; function and can be paused, resumed, and canceled using &lt;code&gt;pause()&lt;/code&gt;, &lt;code&gt;resume()&lt;/code&gt;, and &lt;code&gt;cancel()&lt;/code&gt; respectively.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!CAUTION] &lt;strong&gt;Always&lt;/strong&gt; make your start/pause/cancel DFU API calls from the Main Thread.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;McuMgrPackage API&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import iOSMcuManagerLibrary&#xA;&#xA;do {&#xA;    // Initialize the BLE transport using a scanned peripheral&#xA;    let bleTransport = McuMgrBleTransport(cbPeripheral)&#xA;&#xA;    // Initialize the FirmwareUpgradeManager using the transport and a delegate&#xA;    let dfuManager = FirmwareUpgradeManager(bleTransport, delegate)&#xA;&#xA;    let packageURL = /* Obtain URL to the file user wants to Upload */&#xA;    let package = try McuMgrPackage(from: packageURL)&#xA;&#xA;    // Start the firmware upgrade with the given package&#xA;    dfuManager.start(package: package)&#xA;} catch {&#xA;    // Package initialisation errors here.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is our new, improved, all-conquering API. You create a &lt;code&gt;McuMgrPackage&lt;/code&gt;, and you give it to the &lt;code&gt;FirmwareUpgradeManager&lt;/code&gt;. &lt;a href=&#34;https://www.youtube.com/watch?v=A0QK0JfHzhg&amp;amp;pp&#34;&gt;There&#39;s no Step Three&lt;/a&gt;. This API supports:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; .bin file(s) (Single-Core nRF52xxx) MCUboot Application Update&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; .suit file(s) (&lt;del&gt;Canonical nRF54xx)&lt;/del&gt; SUIT Update&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; .zip file(s) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; DirectXIP (nRF52840) MCUboot Upgrade&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Multi-Image (Application Core, Network Core nRF5340) MCUboot Update&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Multi-Image (Polling - Resources Required nRF54xx) SUIT Update&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Custom Uploads&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is the API you should be using 99% of the time, unless you want to do something specific. For example, you want to unpack your own package, and upload only certain images / resources for specific cores, which is very rare.&lt;/p&gt; &#xA;&lt;p&gt;Have a look at &lt;code&gt;FirmwareUpgradeViewController.swift&lt;/code&gt; from the Example project for a more detailed usage sample.&lt;/p&gt; &#xA;&lt;h3&gt;Custom Multi-Image Upload Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public class ImageManager: McuManager {&#xA;    &#xA;    public struct Image {&#xA;        public let name: String?&#xA;        public let image: Int&#xA;        public let slot: Int&#xA;        public let content: McuMgrManifest.File.ContentType&#xA;        public let hash: Data&#xA;        public let data: Data&#xA;&#xA;        /* ... */&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above is the input type for Image-based API call, where a value of &lt;code&gt;0&lt;/code&gt; for the &lt;code&gt;image&lt;/code&gt; parameter means &lt;strong&gt;App Core&lt;/strong&gt;, and an input of &lt;code&gt;1&lt;/code&gt; means &lt;strong&gt;Net Core&lt;/strong&gt;. These representations were originally intended for McuMgr/MCUboot based products, and not SUIT. In SUIT, there&#39;s no concept of &#39;image&#39; or &#39;slot&#39;, so they&#39;re ignored. But to keep the same API reusable for McuMgr/MCUboot and SUIT devices, but we keep them for backwards compatibility.&lt;/p&gt; &#xA;&lt;p&gt;For McuMgr/MCUboot, you will typically want to set it the &lt;code&gt;slot&lt;/code&gt; parameter to &lt;code&gt;1&lt;/code&gt;, which is the alternate slot that is currently not in use for that specific core. Then, after upload, the firmware device will reset to swap over its slots, making the contents previously uploaded to slot &lt;code&gt;1&lt;/code&gt; (now in slot &lt;code&gt;0&lt;/code&gt; after the swap) as active, and vice-versa.&lt;/p&gt; &#xA;&lt;p&gt;With the Image struct at hand, it&#39;s straightforward to make a call to start DFU for either or both cores:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import iOSMcuManagerLibrary&#xA;&#xA;try {&#xA;    // Initialize the BLE transport using a scanned peripheral&#xA;    let bleTransport = McuMgrBleTransport(cbPeripheral)&#xA;&#xA;    // Initialize the FirmwareUpgradeManager using the transport and a delegate&#xA;    let dfuManager = FirmwareUpgradeManager(bleTransport, delegate)&#xA;&#xA;    // Build Multi-Image DFU parameters&#xA;    let appCoreData = try Data(contentsOf: appCoreFileURL)&#xA;    let appCoreDataHash = try McuMgrImage(data: appCoreData).hash&#xA;    let netCoreData = try Data(contentsOf: netCoreFileURL)&#xA;    let netCoreDataHash = try McuMgrImage(data: netCoreData).hash&#xA;    &#xA;    let images: [ImageManager.Image] = [&#xA;        (image: 0, slot: 1, hash: appCoreDataHash, data: appCoreData),&#xA;        (image: 1, slot: 1, hash: netCoreDataHash, data: netCoreData)&#xA;    ]&#xA;&#xA;    // Start Multi-Image DFU firmware upgrade&#xA;    dfuManager.start(images: images)&#xA;} catch {&#xA;    // Errors here.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;DirectXIP Provision&lt;/h3&gt; &#xA;&lt;p&gt;Whereas non-DirectXIP packages target the secondary / non-active slot, also known as slot &lt;code&gt;1&lt;/code&gt; for each &lt;code&gt;ImageManager.Image&lt;/code&gt;, special attention must be given to DirectXIP packages. Since they provide multiple hashes for the same &lt;code&gt;ImageManager.Image&lt;/code&gt;, one for each available slot. This is because firmware supporting DirectXIP can boot from either slot, not requiring a swap. So, for DirectXIP the &lt;code&gt;[ImageManager.Image]&lt;/code&gt; array might look closer to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import iOSMcuManagerLibrary&#xA;&#xA;try {&#xA;    /*&#xA;    Initialise transport &amp;amp; manager as above.&#xA;    */&#xA;&#xA;    // Build DirectXIP parameters&#xA;    let appCoreSlotZeroData = try Data(contentsOf: appCoreSlotZeroURL)&#xA;    let appCoreSlotZeroHash = try McuMgrImage(data: appCoreSlotZeroData).hash&#xA;    let appCoreSlotOneData = try Data(contentsOf: appCoreSlotOneURL)&#xA;    let appCoreSlotOneHash = try McuMgrImage(data: appCoreSlotOneData).hash&#xA;    &#xA;    let directXIP: [ImageManager.Image] = [&#xA;        (image: 0, slot: 0, hash: appCoreSlotZeroHash, data: appCoreSlotZeroData),&#xA;        (image: 0, slot: 1, hash: appCoreSlotOneHash, data: appCoreSlotOneData)&#xA;    ]&#xA;    &#xA;    // Start DirectXIP Firmware Upgrade&#xA;    dfuManager.start(images: directXIP)&#xA;} catch {&#xA;    // Errors here.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multi-Image DFU Format&lt;/h3&gt; &#xA;&lt;p&gt;Usually, when performing Multi-Image DFU, and even SUIT updates, the delivery format of the attached images for each core will be in a &lt;code&gt;.zip&lt;/code&gt; file. This is because the &lt;code&gt;.zip&lt;/code&gt; file allows us to bundle the necessary information, including the images for each core and which image should be uploaded to each core. This association between the image files, usually in &lt;code&gt;.bin&lt;/code&gt; format, and which core they should be uploaded to, is written in a mandatory JSON format called the Manifest. This &lt;code&gt;manifest.json&lt;/code&gt; is generated by our nRF Connect SDK as part of our Zephyr build system, &lt;a href=&#34;https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/app_dev/build_and_config_system/index.html&#34;&gt;as documented here&lt;/a&gt;. You can look at the &lt;code&gt;McuMgrManifest&lt;/code&gt; struct definition within the library for an insight into the information contained within the manifest.&lt;/p&gt; &#xA;&lt;p&gt;To bridge the gap between the Custom Image Upload API and the output from our Zephyr build system, we wrote &lt;code&gt;McuMgrPackage&lt;/code&gt;, which takes a &lt;code&gt;URL&lt;/code&gt; in its &lt;code&gt;init()&lt;/code&gt; function. Because of the JSON Manifest Parsing nature of the &lt;code&gt;McuMgrPackage&lt;/code&gt; method, you might encounter corner cases / crashes. If you find these, please report them back to us. But regardless, the McuMgrPackage shortcut is a wrapper that initialises the aforementioned &lt;code&gt;[ImageManager.Image]&lt;/code&gt; array API. So you can always fallback to that.&lt;/p&gt; &#xA;&lt;h3&gt;Tell me about SUIT&lt;/h3&gt; &#xA;&lt;p&gt;SUIT, unlike McuManager, places a lot of the logic (read: blame) for firmware update onto the target device rather than the sender (aka &#39;you&#39;, the API user). This simplifies the internal process, but also makes parsing the raw Data and its contents much more complicated. For example, we can&#39;t ascertain the proper Hash signature of every component (file) sent to the firmware because rather than a fixed binary for each Slot or Core, SUIT is designed to represent a sequence of instructions for the bootloader to execute. This means the hashes for the final binaries to be flashed change on-the-fly during the firmware update on the target device&#39;s end.&lt;/p&gt; &#xA;&lt;p&gt;From the sender&#39;s perspective, we only need to send &#34;the Data&#34; in full, and allow the target to figure things out. This pack of bytes represents what we call the SUIT Envelope, which is the sequence of instructions for the firmware to run, akin to the code we write before feeding it into a compiler. These instructions might require other files outside the Envelope itself, known as resources, which will be requested via API Callback. These resources are usually part of a &lt;code&gt;.zip&lt;/code&gt; package that includes the SUIT Envelope and a Manifest file derivative from McuManager&#39;s.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE]&lt;br&gt; &lt;strong&gt;Resources don&#39;t need to have a valid Hash attached to them&lt;/strong&gt; since, as explained above, only the target device knows the proper Hash. &lt;strong&gt;But the Envelope&#39;s Hash is required&lt;/strong&gt;, and it supports different Modes, also known as Types or Algorithms. The list of SUIT Algorithms includes SHA256, SHAKE128, SHA384, SHA512 and SHAKE256. Of these, the &lt;strong&gt;only currently supported mode is SHA256&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Here&#39;s sample code in case you&#39;d like to set up a SUIT upgrade using the &lt;code&gt;ImageManager.Image&lt;/code&gt; API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import iOSMcuManagerLibrary&#xA;&#xA;do {&#xA;    // Initialize the BLE transport using a scanned peripheral&#xA;    let bleTransport = McuMgrBleTransport(cbPeripheral)&#xA;&#xA;    // Initialize the FirmwareUpgradeManager using the transport and a delegate&#xA;    let dfuManager = FirmwareUpgradeManager(bleTransport, delegate)&#xA;&#xA;    // Parse McuMgrSuitEnvelope from File URL&#xA;    let envelope = try McuMgrSuitEnvelope(from: dfuSuitEnvelopeUrl)&#xA;&#xA;    // Look for valid Algorithm Hash &#xA;    guard let sha256Hash = envelope.digest.hash(for: .sha256) else {&#xA;        throw McuMgrSuitParseError.supportedAlgorithmNotFound&#xA;    }&#xA;&#xA;    let suitImage = ImageManager.Image(image: 0, hash: sha256Hash, data: envelope.data)&#xA;    try dfuManager.start(images: [suitImage])&#xA;} catch {&#xA;    // Handle errors from McuMgrSuitEnvelope init, start() API call, etc.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SuitFirmwareUpgradeDelegate&lt;/h4&gt; &#xA;&lt;p&gt;The delegate type you usually give &lt;code&gt;FirmwareUpgradeManager&lt;/code&gt; is &lt;code&gt;FirmwareUpgradeDelegate&lt;/code&gt;. This will cover any needs for McuMgr/McuBoot upgrades, as well as the &#39;Canonical&#39; variant of SUIT, meaning only the Envelope needs to be sent. However, when the upgrade file is a &lt;code&gt;.zip&lt;/code&gt; file, there might be additional resources, such as files, that the target firmware might request. When this happens, a &lt;code&gt;SuitFirmwareUpgradeDelegate&lt;/code&gt;, an extension of &lt;code&gt;FirmwareUpgradeDelegate&lt;/code&gt;, is required. &lt;code&gt;SuitFirmwareUpgradeDelegate&lt;/code&gt; adds a new function to inform you of when a resource is needed. Most of the time, the requested resource will be part of the &lt;code&gt;.zip&lt;/code&gt; package, so it&#39;ll be a very simple implementation. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;&#xA;func uploadRequestsResource(_ resource: FirmwareUpgradeResource) {&#xA;    let image: ImageManager.Image! = package?.image(forResource: resource)&#xA;    firmwareUpgradeManager.uploadResource(resource, data: image.data)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Firmware Upgrade Mode&lt;/h3&gt; &#xA;&lt;p&gt;McuManager firmware upgrades can be performed following slightly different procedures. These different upgrade modes determine the commands sent after the &lt;code&gt;upload&lt;/code&gt; step. &lt;code&gt;FirmwareUpgradeManager&lt;/code&gt; can be configured to perform these upgrade variations by setting the &lt;code&gt;upgradeMode&lt;/code&gt; in &lt;code&gt;FirmwareUpgradeManager&lt;/code&gt;&#39;s &lt;code&gt;configuration&lt;/code&gt; property, explained below. (NOTE: this was previously set with &lt;code&gt;mode&lt;/code&gt; property of &lt;code&gt;FirmwareUpgradeManager&lt;/code&gt;, now removed) The different firmware upgrade modes are as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;.confirmOnly&lt;/code&gt;&lt;/strong&gt;: This mode is &lt;strong&gt;the default mode&lt;/strong&gt;, due to its support for almost any type of DFU variant (Single Image, Multi-Image, Direct XIP, SUIT, etc.). It is in fact, the only supported mode for any form of Multi-Image DFU. However, there is one big caveat to keep in mind: this mode does not support any form of automatic error recovery. So, &lt;strong&gt;if the device fails to boot into the new image, it will not be able to recover and will need to be re-flashed&lt;/strong&gt;. The process for this mode is &lt;code&gt;upload&lt;/code&gt;, &lt;code&gt;confirm&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;.testAndConfirm&lt;/code&gt;&lt;/strong&gt;: This mode is the &lt;strong&gt;recommended, but not default mode&lt;/strong&gt; for performing upgrades due to it&#39;s ability to recover from a bad firmware upgrade. &lt;strong&gt;It is no longer set as the default, due to it only being fully supported in Single Image DFU Mode&lt;/strong&gt;. The process for this mode is &lt;code&gt;upload&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;confirm&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;.testOnly&lt;/code&gt;&lt;/strong&gt;: This mode is useful if you want to run tests on the new image running before confirming it manually as the primary boot image. The process for this mode is &lt;code&gt;upload&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;.uploadOnly&lt;/code&gt;&lt;/strong&gt;: This is a very particular mode. It does not listen or acknowledge Bootloader Info, and plows through the upgrade process with just &lt;code&gt;upload&lt;/code&gt; followed by &lt;code&gt;reset&lt;/code&gt;. That&#39;s it. &lt;strong&gt;It is up to the user, since this is not a default, to decide this is the right mode to use&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Firmware Upgrade State&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;FirmwareUpgradeManager&lt;/code&gt; acts as a simple, mostly linear state machine which is determined by the &lt;code&gt;mode&lt;/code&gt;. As the manager moves through the firmware upgrade process, state changes are provided through the &lt;code&gt;FirmwareUpgradeDelegate&lt;/code&gt;&#39;s &lt;code&gt;upgradeStateDidChange&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;FirmwareUpgradeManager&lt;/code&gt; contains an additional state, &lt;code&gt;validate&lt;/code&gt;, which precedes the upload. The &lt;code&gt;validate&lt;/code&gt; state checks the current image state of the device in an attempt to bypass certain states of the firmware upgrade. For example, if the image to upgrade to already exists in slot 1 on the device, &lt;code&gt;FirmwareUpgradeManager&lt;/code&gt; will skip &lt;code&gt;upload&lt;/code&gt; and move directly to &lt;code&gt;test&lt;/code&gt; (or &lt;code&gt;confirm&lt;/code&gt; if &lt;code&gt;.confirmOnly&lt;/code&gt; mode has been set) from &lt;code&gt;validate&lt;/code&gt;. If the uploaded image is already active, and confirmed in slot 0, the upgrade will succeed immediately. In short, the &lt;code&gt;validate&lt;/code&gt; state makes it easy to reattempt an upgrade without needing to re-upload the image or manually determine where to start.&lt;/p&gt; &#xA;&lt;h3&gt;Firmware Upgrade Configuration&lt;/h3&gt; &#xA;&lt;p&gt;In version 1.2, new features were introduced to speed-up the Upload speeds, mirroring the work first done on the Android side, and they&#39;re all available through the new &lt;code&gt;FirmwareUpgradeConfiguration&lt;/code&gt; struct.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;pipelineDepth&lt;/code&gt;&lt;/strong&gt;: (Represented as &#39;Number of Buffers&#39; in the Example App UI.) For values larger than 1, this enables the &lt;strong&gt;SMP Pipelining&lt;/strong&gt; feature. It means multiple write packets are sent concurrently, thereby providing a large speed increase the higher the number of buffers the receiving device is configured with. Set to &lt;code&gt;1&lt;/code&gt; (Number of Buffers = Disabled) by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;byteAlignment&lt;/code&gt;&lt;/strong&gt;: This is required when used in conjunction with SMP Pipelining. By fixing the size of each chunk of Data sent for the Firmware Upgrade, we can predict the receiving device&#39;s offset jumps and therefore smoothly send multiple Data packets at the same time. When SMP Pipelining is not being used (&lt;code&gt;pipelineDepth&lt;/code&gt; set to &lt;code&gt;1&lt;/code&gt;), the library still performs Byte Alignment if set, but it is not required for updates to work. Set to &lt;code&gt;ImageUploadAlignment.disabled&lt;/code&gt; by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;reassemblyBufferSize&lt;/strong&gt;: SMP Reassembly is another speed-improving feature. It works on devices running NCS 2.0 firmware or later, and is self-adjusting. Before the Upload starts, a request is sent via &lt;code&gt;DefaultManager&lt;/code&gt; asking for MCU Manager Paremeters. If received, it means the firmware can accept data in chunks larger than the MTU Size, therefore also increasing speed. This property will reflect the size of the buffer on the receiving device, and the &lt;code&gt;McuMgrBleTransport&lt;/code&gt; will be set to chunk the data down within the same Sequence Number, keeping each packet transmission within the MTU boundaries. &lt;strong&gt;There is no work required for SMP Reassembly to work&lt;/strong&gt; - on devices not supporting it, the MCU Manager Paremeters request will fail, and the Upload will proceed assuming no reassembly capabilities. &lt;strong&gt;Must not be larger than UInt16.max (65535)&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;eraseAppSettings&lt;/code&gt;&lt;/strong&gt;: This is not a speed-related feature. Instead, setting this to &lt;code&gt;true&lt;/code&gt; means all app data on the device, including Bond Information, Number of Steps, Login or anything else are all erased. If there are any major data changes to the new firmware after the update, like a complete change of functionality or a new update with different save structures, this is recommended. Set to &lt;code&gt;false&lt;/code&gt; by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;upgradeMode&lt;/code&gt;&lt;/strong&gt;: Firmware Upgrade Mode. See Section above for an in-depth explanation of all possible Upgrade Modes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;bootloaderMode&lt;/code&gt;&lt;/strong&gt;: The Bootloader Mode is not necessarily intended to be a setting. It behaves as a setting if the target firmware does not offer a valid response to Bootloader Info request, for example, if it&#39;s not supported. What it does is inform iOSMcuMgrLibrary of the supported operations by the Bootloader. For example, if &lt;code&gt;upgradeMode&lt;/code&gt; is set to &lt;code&gt;confirmOnly&lt;/code&gt; but the Bootloader is in DirectXIP with no Revert mode, sending a Confirm command will be returned with an error. Which means, no Confirm command will be sent, despite the &lt;code&gt;upgradeMode&lt;/code&gt; being set so. So yes, it&#39;s yet another layer of complexity from SMP / McuManager we have to deal with.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Configuration Example&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=uelA7KRLINA&#34;&gt;This is the way&lt;/a&gt; to start DFU with your own custom &lt;code&gt;FirmwareUpgradeConfiguration&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import iOSMcuManagerLibrary&#xA;&#xA;// Setup&#xA;let bleTransport = McuMgrBleTransport(cbPeripheral)&#xA;let dfuManager = FirmwareUpgradeManager(bleTransport, delegate)&#xA;&#xA;// Non-Pipelined Example&#xA;let nonPipelinedConfiguration = FirmwareUpgradeConfiguration(&#xA;    estimatedSwapTime: 10.0, eraseAppSettings: false, pipelineDepth: 2,&#xA;)&#xA;dfuManager.start(package: package, using: nonPipelinedConfiguration)&#xA;&#xA;// Pipelined Example&#xA;let pipelinedConfiguration = FirmwareUpgradeConfiguration(&#xA;    estimatedSwapTime: 10.0, eraseAppSettings: true, pipelineDepth: 4,&#xA;    byteAlignment: .fourByte&#xA;)&#xA;dfuManager.start(package: package, using: pipelinedConfiguration)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Logging&lt;/h1&gt; &#xA;&lt;p&gt;Setting &lt;code&gt;logDelegate&lt;/code&gt; property in a manager gives access to low level logs, that can help debugging both the app and your device. Messages are logged on 6 log levels, from &lt;code&gt;.debug&lt;/code&gt; to &lt;code&gt;.error&lt;/code&gt;, and additionally contain a &lt;code&gt;McuMgrLogCategory&lt;/code&gt;, which identifies the originating component. Additionally, the &lt;code&gt;logDelegate&lt;/code&gt; property of &lt;code&gt;McuMgrBleTransport&lt;/code&gt; provides access to the BLE Transport logs.&lt;/p&gt; &#xA;&lt;h3&gt;Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import iOSMcuManagerLibrary&#xA;&#xA;// Initialize the BLE transport using a scanned peripheral&#xA;let bleTransport = McuMgrBleTransport(cbPeripheral)&#xA;bleTransport.logDelegate = UIApplication.shared.delegate as? McuMgrLogDelegate&#xA;&#xA;// Initialize the DeviceManager using the transport and a delegate&#xA;let deviceManager = DeviceManager(bleTransport, delegate)&#xA;deviceManager.logDelegate = UIApplication.shared.delegate as? McuMgrLogDelegate&#xA;&#xA;// Send echo&#xA;deviceManger.echo(&#34;Hello World!&#34;, callback)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;OSLog integration&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;McuMgrLogDelegate&lt;/code&gt; can be easily integrated with the &lt;a href=&#34;https://developer.apple.com/documentation/os/logging&#34;&gt;Unified Logging System&lt;/a&gt;. An example is provided in the example app in the &lt;code&gt;AppDelegate.swift&lt;/code&gt;. A &lt;code&gt;McuMgrLogLevel&lt;/code&gt; extension that can be found in that file translates the log level to one of &lt;code&gt;OSLogType&lt;/code&gt; levels. Similarly, &lt;code&gt;McuMgrLogCategory&lt;/code&gt; extension converts the category to &lt;code&gt;OSLog&lt;/code&gt; type.&lt;/p&gt; &#xA;&lt;h1&gt;Related Projects&lt;/h1&gt; &#xA;&lt;p&gt;We&#39;ve heard demand from developers for a single McuMgr DFU library to target multiple platforms. So we&#39;ve made available &lt;a href=&#34;https://pub.dev/packages/mcumgr_flutter&#34;&gt;a Flutter library&lt;/a&gt; that acts as a wrapper for both Android and iOS.&lt;/p&gt;</summary>
  </entry>
</feed>