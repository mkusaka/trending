<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-06T01:56:26Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>CombineCommunity/CombineExt</title>
    <updated>2022-08-06T01:56:26Z</updated>
    <id>tag:github.com,2022-08-06:/CombineCommunity/CombineExt</id>
    <link href="https://github.com/CombineCommunity/CombineExt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CombineExt provides a collection of operators, publishers and utilities for Combine, that are not provided by Apple themselves, but are common in other Reactive Frameworks and standards.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CombineExt&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/CombineCommunity/CombineExt/raw/main/Resources/logo.png&#34; width=&#34;45%&#34;&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&#34;https://actions-badge.atrox.dev/CombineCommunity/CombineExt/goto&#34; target=&#34;_blank&#34; alt=&#34;Build Status&#34; title=&#34;Build Status&#34;&gt;&lt;img src=&#34;https://github.com/CombineCommunity/CombineExt/workflows/CombineExt/badge.svg?branch=main&#34; alt=&#34;Build Status&#34; title=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/CombineCommunity/CombineExt&#34; target=&#34;_blank&#34; alt=&#34;Code Coverage for CombineExt on codecov&#34; title=&#34;Code Coverage for CombineExt on codecov&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/CombineCommunity/CombineExt/branch/main/graph/badge.svg?sanitize=true&#34; alt=&#34;Code Coverage for CombineExt on codecov&#34; title=&#34;Code Coverage for CombineExt on codecov&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;img src=&#34;https://img.shields.io/badge/platforms-iOS%2013%20%7C%20macOS 10.15%20%7C%20tvOS%2013%20%7C%20watchOS%206-333333.svg&#34;&gt; &lt;br&gt; &lt;a href=&#34;https://cocoapods.org/pods/CombineExt&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/CombineExt.svg?1&#34; alt=&#34;CombineExt supports CocoaPods&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/apple/swift-package-manager&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Swift%20Package%20Manager-compatible-brightgreen.svg?sanitize=true&#34; alt=&#34;CombineExt supports Swift Package Manager (SPM)&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;CombineExt supports Carthage&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;CombineExt provides a collection of operators, publishers and utilities for Combine, that are not provided by Apple themselves, but are common in other Reactive Frameworks and standards.&lt;/p&gt; &#xA;&lt;p&gt;The original inspiration for many of these additions came from my journey investigating Combine after years of RxSwift and ReactiveX usage.&lt;/p&gt; &#xA;&lt;p&gt;All operators, utilities and helpers respect Combine&#39;s publisher contract, including backpressure.&lt;/p&gt; &#xA;&lt;h3&gt;Operators&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#withLatestFrom&#34;&gt;withLatestFrom&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#flatMapLatest&#34;&gt;flatMapLatest&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#assign&#34;&gt;assign&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#amb&#34;&gt;amb and Collection.amb&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#materialize&#34;&gt;materialize&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#values&#34;&gt;values&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#failures&#34;&gt;failures&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#dematerialize&#34;&gt;dematerialize&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#partition&#34;&gt;partition&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#ZipMany&#34;&gt;zip(with:) and Collection.zip&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#MergeMany&#34;&gt;Collection.merge()&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#CombineLatestMany&#34;&gt;combineLatest(with:) and Collection.combineLatest&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#MapMany&#34;&gt;mapMany(_:)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#FilterMany&#34;&gt;filterMany(_:)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#setOutputType&#34;&gt;setOutputType(to:)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#removeAllDuplicates&#34;&gt;removeAllDuplicates and removeAllDuplicates(by:) &lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#sharereplay&#34;&gt;share(replay:)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#prefixduration&#34;&gt;prefix(duration:tolerance:​on:options:)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#prefixwhilebehavior&#34;&gt;prefix(while:behavior:​)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#toggle&#34;&gt;toggle()&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#nwise&#34;&gt;nwise(_:) and pairwise()&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#ignoreOutputsetOutputType&#34;&gt;ignoreOutput(setOutputType:)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#ignoreFailure&#34;&gt;ignoreFailure&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#mapToResult&#34;&gt;mapToResult&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#flatMapBatchesof&#34;&gt;flatMapBatches(of:)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Publishers&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#AnypublisherCreate&#34;&gt;AnyPublisher.create&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#CurrentValueRelay&#34;&gt;CurrentValueRelay&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#PassthroughRelay&#34;&gt;PassthroughRelay&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Subjects&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/#ReplaySubject&#34;&gt;ReplaySubject&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: This is still a relatively early version of CombineExt, with much more to be desired. I gladly accept PRs, ideas, opinions, or improvements. Thank you! :)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;Add the following line to your &lt;strong&gt;Podfile&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;pod &#39;CombineExt&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;Add the following dependency to your &lt;strong&gt;Package.swift&lt;/strong&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.package(url: &#34;https://github.com/CombineCommunity/CombineExt.git&#34;, from: &#34;1.0.0&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;p&gt;Carthage support is offered as a prebuilt binary.&lt;/p&gt; &#xA;&lt;p&gt;Add the following to your &lt;strong&gt;Cartfile&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;CombineCommunity/CombineExt&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Operators&lt;/h2&gt; &#xA;&lt;p&gt;This section outlines some of the custom operators CombineExt provides.&lt;/p&gt; &#xA;&lt;h3&gt;withLatestFrom&lt;/h3&gt; &#xA;&lt;p&gt;Merges up to four publishers into a single publisher by combining each value from &lt;code&gt;self&lt;/code&gt; with the &lt;em&gt;latest&lt;/em&gt; value from the other publishers, if any.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let taps = PassthroughSubject&amp;lt;Void, Never&amp;gt;()&#xA;let values = CurrentValueSubject&amp;lt;String, Never&amp;gt;(&#34;Hello&#34;)&#xA;&#xA;taps&#xA;  .withLatestFrom(values)&#xA;  .sink(receiveValue: { print(&#34;withLatestFrom: \($0)&#34;) })&#xA;&#xA;taps.send()&#xA;taps.send()&#xA;values.send(&#34;World!&#34;)&#xA;taps.send()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;withLatestFrom: Hello&#xA;withLatestFrom: Hello&#xA;withLatestFrom: World!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;flatMapLatest&lt;/h3&gt; &#xA;&lt;p&gt;Transforms an output value into a new publisher, and flattens the stream of events from these multiple upstream publishers to appear as if they were coming from a single stream of events.&lt;/p&gt; &#xA;&lt;p&gt;Mapping to a new publisher will cancel the subscription to the previous one, keeping only a single subscription active along with its event emissions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;flatMapLatest&lt;/code&gt; is a combination of &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;switchToLatest&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let trigger = PassthroughSubject&amp;lt;Void, Never&amp;gt;()&#xA;trigger&#xA;    .flatMapLatest { performNetworkRequest() }&#xA;&#xA;trigger.send()&#xA;trigger.send() // cancels previous request&#xA;trigger.send() // cancels previous request&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;assign&lt;/h3&gt; &#xA;&lt;p&gt;CombineExt provides custom overloads of &lt;code&gt;assign(to&lt;span&gt;🔛&lt;/span&gt;)&lt;/code&gt; that let you bind a publisher to multiple keypath targets simultaneously.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var label1: UILabel&#xA;var label2: UILabel&#xA;var text: UITextField&#xA;&#xA;[&#34;hey&#34;, &#34;there&#34;, &#34;friend&#34;]&#xA;    .publisher&#xA;    .assign(to: \.text, on: label1,&#xA;            and: \.text, on: label2,&#xA;            and: \.text, on: text)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;CombineExt provides an additional overload — &lt;code&gt;assign(to:on​:ownership)&lt;/code&gt; — which lets you specify the kind of ownersip you want for your assign operation: &lt;code&gt;strong&lt;/code&gt;, &lt;code&gt;weak&lt;/code&gt; or &lt;code&gt;unowned&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Retain `self` strongly&#xA;subscription = subject.assign(to: \.value, on: self)&#xA;subscription = subject.assign(to: \.value, on: self, ownership: .strong)&#xA;&#xA;// Use a `weak` reference to `self`&#xA;subscription = subject.assign(to: \.value, on: self, ownership: .weak)&#xA;&#xA;// Use an `unowned` reference to `self`&#xA;subscription = subject.assign(to: \.value, on: self, ownership: .unowned)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;amb&lt;/h3&gt; &#xA;&lt;p&gt;Amb takes multiple publishers and mirrors the first one to emit an event. You can think of it as a race of publishers, where the first one to emit passes its events, while the others are ignored (there’s also a &lt;code&gt;Collection.amb&lt;/code&gt; method to ease working with multiple publishers).&lt;/p&gt; &#xA;&lt;p&gt;The name &lt;code&gt;amb&lt;/code&gt; comes from the &lt;a href=&#34;http://reactivex.io/documentation/operators/amb.html&#34;&gt;Reactive Extensions operator&lt;/a&gt;, also known in RxJS as &lt;code&gt;race&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let subject1 = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;let subject2 = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;&#xA;subject1&#xA;  .amb(subject2)&#xA;  .sink(receiveCompletion: { print(&#34;amb: completed with \($0)&#34;) },&#xA;        receiveValue: { print(&#34;amb: \($0)&#34;) })&#xA;&#xA;subject2.send(3) // Since this subject emit first, it becomes the active publisher&#xA;subject1.send(1)&#xA;subject2.send(6)&#xA;subject1.send(8)&#xA;subject1.send(7)&#xA;&#xA;subject1.send(completion: .finished)&#xA;// Only when subject2 finishes, amb itself finishes as well, since it&#39;s the active publisher&#xA;subject2.send(completion: .finished)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;amb: 3&#xA;amb: 6&#xA;amb: completed with .finished&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;materialize&lt;/h3&gt; &#xA;&lt;p&gt;Convert any publisher to a publisher of its events. Given a &lt;code&gt;Publisher&amp;lt;Output, MyError&amp;gt;&lt;/code&gt;, this operator will return a &lt;code&gt;Publisher&amp;lt;Event&amp;lt;Output, MyError&amp;gt;, Never&amp;gt;&lt;/code&gt;, which means your failure will actually be a regular value, which makes error handling much simpler in many use cases.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let values = PassthroughSubject&amp;lt;String, MyError&amp;gt;()&#xA;enum MyError: Swift.Error {&#xA;  case ohNo&#xA;}&#xA;&#xA;values&#xA;  .materialize()&#xA;  .sink(receiveCompletion: { print(&#34;materialized: completed with \($0)&#34;) },&#xA;        receiveValue: { print(&#34;materialized: \($0)&#34;) })&#xA;&#xA;values.send(&#34;Hello&#34;)&#xA;values.send(&#34;World&#34;)&#xA;values.send(&#34;What&#39;s up?&#34;)&#xA;values.send(completion: .failure(.ohNo))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;materialize: .value(&#34;Hello&#34;)&#xA;materialize: .value(&#34;World&#34;)&#xA;materialize: .value(&#34;What&#39;s up?&#34;)&#xA;materialize: .failure(.ohNo)&#xA;materialize: completed with .finished&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;values&lt;/h3&gt; &#xA;&lt;p&gt;Given a materialized publisher, publish only the emitted upstream values, omitting failures. Given a &lt;code&gt;Publisher&amp;lt;Event&amp;lt;String, MyError&amp;gt;, Never&amp;gt;&lt;/code&gt;, this operator will return a &lt;code&gt;Publisher&amp;lt;String, Never&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: This operator only works on publishers that were materialized with the &lt;code&gt;materialize()&lt;/code&gt; operator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let values = PassthroughSubject&amp;lt;String, MyError&amp;gt;()&#xA;enum MyError: Swift.Error {&#xA;  case ohNo&#xA;}&#xA;&#xA;values&#xA;  .materialize()&#xA;  .values()&#xA;  .sink(receiveValue: { print(&#34;values: \($0)&#34;) })&#xA;&#xA;values.send(&#34;Hello&#34;)&#xA;values.send(&#34;World&#34;)&#xA;values.send(&#34;What&#39;s up?&#34;)&#xA;values.send(completion: .failure(.ohNo))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;values: &#34;Hello&#34;&#xA;values: &#34;World&#34;&#xA;values: &#34;What&#39;s up?&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;failures&lt;/h3&gt; &#xA;&lt;p&gt;Given a materialized publisher, publish only the emitted upstream failure, omitting values. Given a &lt;code&gt;Publisher&amp;lt;Event&amp;lt;String, MyError&amp;gt;, Never&amp;gt;&lt;/code&gt;, this operator will return a &lt;code&gt;Publisher&amp;lt;MyError, Never&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: This operator only works on publishers that were materialized with the &lt;code&gt;materialize()&lt;/code&gt; operator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let values = PassthroughSubject&amp;lt;String, MyError&amp;gt;()&#xA;enum MyError: Swift.Error {&#xA;  case ohNo&#xA;}&#xA;&#xA;values&#xA;  .materialize()&#xA;  .failures()&#xA;  .sink(receiveValue: { print(&#34;failures: \($0)&#34;) })&#xA;&#xA;values.send(&#34;Hello&#34;)&#xA;values.send(&#34;World&#34;)&#xA;values.send(&#34;What&#39;s up?&#34;)&#xA;values.send(completion: .failure(.ohNo))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;failure: MyError.ohNo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;dematerialize&lt;/h3&gt; &#xA;&lt;p&gt;Converts a previously-materialized publisher into its original form. Given a &lt;code&gt;Publisher&amp;lt;Event&amp;lt;String, MyError&amp;gt;, Never&amp;gt;&lt;/code&gt;, this operator will return a &lt;code&gt;Publisher&amp;lt;String, MyError&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: This operator only works on publishers that were materialized with the &lt;code&gt;materialize()&lt;/code&gt; operator.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;partition&lt;/h3&gt; &#xA;&lt;p&gt;Partition a publisher&#39;s values into two separate publishers of values that match, and don&#39;t match, the provided predicate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let source = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;&#xA;let (even, odd) = source.partition { $0 % 2 == 0 }&#xA;&#xA;even.sink(receiveValue: { print(&#34;even: \($0)&#34;) })&#xA;odd.sink(receiveValue: { print(&#34;odd: \($0)&#34;) })&#xA;&#xA;source.send(1)&#xA;source.send(2)&#xA;source.send(3)&#xA;source.send(4)&#xA;source.send(5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;odd: 1&#xA;even: 2&#xA;odd: 3&#xA;even: 4&#xA;odd: 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;ZipMany&lt;/h3&gt; &#xA;&lt;p&gt;This repo includes two overloads on Combine’s &lt;code&gt;Publisher.zip&lt;/code&gt; methods (which, at the time of writing only go up to arity three).&lt;/p&gt; &#xA;&lt;p&gt;This lets you arbitrarily zip many publishers and receive an array of inner publisher outputs back.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let first = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;let second = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;let third = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;let fourth = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;&#xA;subscription = first&#xA;  .zip(with: second, third, fourth)&#xA;  .map { $0.reduce(0, +) }&#xA;  .sink(receiveValue: { print(&#34;zipped: \($0)&#34;) })&#xA;&#xA;first.send(1)&#xA;second.send(2)&#xA;third.send(3)&#xA;fourth.send(4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may also use &lt;code&gt;.zip()&lt;/code&gt; directly on a collection of publishers with the same output and failure types, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;[first, second, third, fourth]&#xA;  .zip()&#xA;  .map { $0.reduce(0, +) }&#xA;  .sink(receiveValue: { print(&#34;zipped: \($0)&#34;) })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;zipped: 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;MergeMany&lt;/h3&gt; &#xA;&lt;p&gt;This repo includes an extension for Collection that allows you to call &lt;code&gt;.merge()&lt;/code&gt; directly on a collection of publishers with the same output and failure types.&lt;/p&gt; &#xA;&lt;p&gt;This lets you arbitrarily merge many publishers and receive inner publisher outputs back from a single publisher.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let first = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;let second = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;let third = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;let fourth = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;&#xA;subscription = [first, second, third, fourth]&#xA;  .merge()&#xA;  .sink(receiveValue: { print(&#34;output: \($0)&#34;) })&#xA;&#xA;first.send(1)&#xA;second.send(2)&#xA;third.send(3)&#xA;fourth.send(4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;output: 1&#xA;output: 2&#xA;output: 3&#xA;output: 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;CombineLatestMany&lt;/h3&gt; &#xA;&lt;p&gt;This repo includes two overloads on Combine’s &lt;code&gt;Publisher.combineLatest&lt;/code&gt; methods (which, at the time of writing only go up to arity three) and an &lt;code&gt;Collection.combineLatest&lt;/code&gt; constrained extension.&lt;/p&gt; &#xA;&lt;p&gt;This lets you arbitrarily combine many publishers and receive an array of inner publisher outputs back.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let first = PassthroughSubject&amp;lt;Bool, Never&amp;gt;()&#xA;let second = PassthroughSubject&amp;lt;Bool, Never&amp;gt;()&#xA;let third = PassthroughSubject&amp;lt;Bool, Never&amp;gt;()&#xA;let fourth = PassthroughSubject&amp;lt;Bool, Never&amp;gt;()&#xA;&#xA;subscription = [first, second, third, fourth]&#xA;  .combineLatest()&#xA;  .sink(receiveValue: { print(&#34;combineLatest: \($0)&#34;) })&#xA;&#xA;first.send(true)&#xA;second.send(true)&#xA;third.send(true)&#xA;fourth.send(true)&#xA;&#xA;first.send(false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;combineLatest: [true, true, true, true]&#xA;combineLatest: [false, true, true, true]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;FilterMany&lt;/h3&gt; &#xA;&lt;p&gt;Filters element of a publisher collection into a new publisher collection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let intArrayPublisher = PassthroughSubject&amp;lt;[Int], Never&amp;gt;()&#xA;&#xA;intArrayPublisher&#xA;  .filterMany { $0.isMultiple(of: 2) }&#xA;  .sink(receiveValue: { print($0) })&#xA;&#xA;intArrayPublisher.send([10, 2, 4, 3, 8])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;none&#xA;[10, 2, 4, 8]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;MapMany&lt;/h3&gt; &#xA;&lt;p&gt;Projects each element of a publisher collection into a new publisher collection form.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let intArrayPublisher = PassthroughSubject&amp;lt;[Int], Never&amp;gt;()&#xA;    &#xA;intArrayPublisher&#xA;  .mapMany(String.init)&#xA;  .sink(receiveValue: { print($0) })&#xA;    &#xA;intArrayPublisher.send([10, 2, 2, 4, 3, 8])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;[&#34;10&#34;, &#34;2&#34;, &#34;2&#34;, &#34;4&#34;, &#34;3&#34;, &#34;8&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;setOutputType&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Publisher.setOutputType(to:)&lt;/code&gt; is an analog to &lt;a href=&#34;https://developer.apple.com/documentation/combine/publisher/3204753-setfailuretype&#34;&gt;&lt;code&gt;.setFailureType(to:)&lt;/code&gt;&lt;/a&gt; for when &lt;code&gt;Output&lt;/code&gt; is constrained to &lt;code&gt;Never&lt;/code&gt;. This is especially helpful when chaining operators after an &lt;a href=&#34;https://developer.apple.com/documentation/combine/publisher/3204714-ignoreoutput&#34;&gt;&lt;code&gt;.ignoreOutput()&lt;/code&gt;&lt;/a&gt; call.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;removeAllDuplicates&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Publisher.removeAllDuplicates&lt;/code&gt; and &lt;code&gt;.removeAllDuplicates(by:)&lt;/code&gt; are stricter forms of Apple’s &lt;a href=&#34;https://developer.apple.com/documentation/combine/publisher/3204745-removeduplicates&#34;&gt;&lt;code&gt;Publisher.removeDuplicates&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://developer.apple.com/documentation/combine/publisher/3204746-removeduplicates&#34;&gt;&lt;code&gt;.removeDuplicates(by:)&lt;/code&gt;&lt;/a&gt;—the operators de-duplicate across &lt;em&gt;all&lt;/em&gt; previous value events, instead of pairwise.&lt;/p&gt; &#xA;&lt;p&gt;If your &lt;code&gt;Output&lt;/code&gt; doesn‘t conform to &lt;code&gt;Hashable&lt;/code&gt; or &lt;code&gt;Equatable&lt;/code&gt;, you may instead use the comparator-based version of this operator to decide whether two elements are equal.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;subscription = [1, 1, 2, 1, 3, 3, 4].publisher&#xA;  .removeAllDuplicates()&#xA;  .sink(receiveValue: { print(&#34;removeAllDuplicates: \($0)&#34;) })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;removeAllDuplicates: 1&#xA;removeAllDuplicates: 2&#xA;removeAllDuplicates: 3&#xA;removeAllDuplicates: 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;share(replay:)&lt;/h3&gt; &#xA;&lt;p&gt;Similar to &lt;a href=&#34;https://developer.apple.com/documentation/combine/publisher/3204754-share&#34;&gt;&lt;code&gt;Publisher.share&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;.share(replay:)&lt;/code&gt; can be used to create a publisher instance with reference semantics which replays a pre-defined amount of value events to further subscribers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let subject = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;&#xA;let replayedPublisher = subject&#xA;  .share(replay: 3)&#xA;&#xA;subscription1 = replayedPublisher&#xA;  .sink(receiveValue: { print(&#34;first subscriber: \($0)&#34;) })&#xA;  &#xA;subject.send(1)&#xA;subject.send(2)&#xA;subject.send(3)&#xA;subject.send(4)&#xA;&#xA;subscription2 = replayedPublisher&#xA;  .sink(receiveValue: { print(&#34;second subscriber: \($0)&#34;) })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;first subscriber: 1&#xA;first subscriber: 2&#xA;first subscriber: 3&#xA;first subscriber: 4&#xA;second subscriber: 2&#xA;second subscriber: 3&#xA;second subscriber: 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;prefix(duration:)&lt;/h3&gt; &#xA;&lt;p&gt;An overload on &lt;code&gt;Publisher.prefix&lt;/code&gt; that republishes values for a provided &lt;code&gt;duration&lt;/code&gt; (in seconds), and then completes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let subject = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;&#xA;subscription = subject&#xA;  .prefix(duration: 0.5, on: DispatchQueue.main)&#xA;  .sink(receiveValue: { print($0) })&#xA;  &#xA;subject.send(1)&#xA;subject.send(2)&#xA;subject.send(3)&#xA;&#xA;DispatchQueue.main.asyncAfter(deadline: .now() + 1) {&#xA;  subject.send(4)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;1&#xA;2&#xA;3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;prefix(while:behavior:)&lt;/h3&gt; &#xA;&lt;p&gt;An overload on &lt;code&gt;Publisher.prefix(while:)&lt;/code&gt; that allows for inclusion of the first element that doesn’t pass the &lt;code&gt;while&lt;/code&gt; predicate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let subject = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;&#xA;subscription = subject&#xA;  .prefix(&#xA;    while: { $0 % 2 == 0 },&#xA;    behavior: .inclusive&#xA;  )&#xA;  .sink(&#xA;    receivecompletion: { print($0) },&#xA;    receiveValue: { print($0) }&#xA;  )&#xA;  &#xA;subject.send(0)&#xA;subject.send(2)&#xA;subject.send(4)&#xA;subject.send(5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;0&#xA;2&#xA;4&#xA;5&#xA;finished&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;toggle()&lt;/h3&gt; &#xA;&lt;p&gt;Toggle each boolean element of a publisher collection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let subject = PassthroughSubject&amp;lt;Bool, Never&amp;gt;()&#xA;&#xA;subscription = subject&#xA;  .toggle()&#xA;  .sink(receiveValue: { print($0) })&#xA;  &#xA;subject.send(true)&#xA;subject.send(false)&#xA;subject.send(true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;false&#xA;true&#xA;false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;nwise&lt;/h3&gt; &#xA;&lt;p&gt;Groups the elements of the source publisher into arrays of N consecutive elements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let subject = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;&#xA;subscription = subject&#xA;  .nwise(3)&#xA;  .sink(receiveValue: { print($0) })&#xA;  &#xA;subject.send(1)&#xA;subject.send(2)&#xA;subject.send(3)&#xA;subject.send(4)&#xA;subject.send(5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;[1, 2, 3]&#xA;[2, 3, 4]&#xA;[3, 4, 5]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;pairwise&lt;/h3&gt; &#xA;&lt;p&gt;Groups the elements of the source publisher into tuples of the previous and current elements&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let subject = PassthroughSubject&amp;lt;Int, Never&amp;gt;()&#xA;&#xA;subscription = subject&#xA;  .pairwise()&#xA;  .sink(receiveValue: { print(&#34;\($0.0) -&amp;gt; \($0.1)&#34;) })&#xA;&#xA;subject.send(1)&#xA;subject.send(2)&#xA;subject.send(3)&#xA;subject.send(4)&#xA;subject.send(5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;1 -&amp;gt; 2&#xA;2 -&amp;gt; 3&#xA;3 -&amp;gt; 4&#xA;4 -&amp;gt; 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ignoreOutput(setOutputType:)&lt;/h3&gt; &#xA;&lt;p&gt;Shorthand for both ignoring a publisher’s value events and re-writing its &lt;code&gt;Output&lt;/code&gt; generic.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let onlyAFour = [&#34;1&#34;, &#34;2&#34;, &#34;3&#34;].publisher&#xA;  .ignoreOutput(setOutputType: Int.self)&#xA;  .append(4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ignoreFailure&lt;/h3&gt; &#xA;&lt;p&gt;CombineExt provides a couple of overloads to ignore errors and optionally specify a new error type and whether to trigger completions in such cases.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ignoreFailure(completeImmediately:)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignoreFailure(setFailureType:completeImmediately:)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum AnError {&#xA;  case someError &#xA;}&#xA;&#xA;let subject = PassthroughSubject&amp;lt;Int, AnError&amp;gt;()&#xA;&#xA;subscription = subject&#xA;  .ignoreFailure() // The `completeImmediately` parameter defaults to `true`.&#xA;  .sink(receiveValue: { print($0) }, receiveCompletion: { print($0) })&#xA;&#xA;subject.send(1)&#xA;subject.send(2)&#xA;subject.send(3)&#xA;subject.send(completion: .failure(.someError))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;1&#xA;2&#xA;3&#xA;.finished&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;mapToResult&lt;/h3&gt; &#xA;&lt;p&gt;Transforms a publisher of type &lt;code&gt;AnyPublisher&amp;lt;Output, Failure&amp;gt;&lt;/code&gt; to &lt;code&gt;AnyPublisher&amp;lt;Result&amp;lt;Output, Failure&amp;gt;, Never&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum AnError: Error {&#xA;    case someError&#xA;}&#xA;&#xA;let subject = PassthroughSubject&amp;lt;Int, AnError&amp;gt;()&#xA;&#xA;let subscription = subject&#xA;    .mapToResult()&#xA;    .sink(receiveCompletion: { print(&#34;completion: \($0)&#34;) },&#xA;          receiveValue: { print(&#34;value: \($0)&#34;) })&#xA;&#xA;subject.send(1)&#xA;subject.send(2)&#xA;subject.send(3)&#xA;subject.send(completion: .failure(.someError))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;value: success(1)&#xA;value: success(2)&#xA;value: success(3)&#xA;value: failure(AnError.someError)&#xA;completion: finished&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;flatMapBatches(of:)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Collection.flatMapBatches(of:)&lt;/code&gt; subscribes to the receiver’s contained publishers in batches and returns their outputs in batches, too (while maintaining order). Subsequent batches of publishers are only subscribed to when prior batches successfully complete —&amp;nbsp;any one failure is forwarded downstream.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let ints = (1...6).map(Just.init)&#xA;&#xA;subscription = ints&#xA;  .flatMapBatches(of: 2)&#xA;  .sink(receiveCompletion: { print($0) }, receiveValue: { print($0) })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;[1, 2]&#xA;[3, 4]&#xA;[5, 6]&#xA;.finished&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Publishers&lt;/h2&gt; &#xA;&lt;p&gt;This section outlines some of the custom Combine publishers CombineExt provides&lt;/p&gt; &#xA;&lt;h3&gt;AnyPublisher.create&lt;/h3&gt; &#xA;&lt;p&gt;A publisher which accepts a closure with a subscriber argument, to which you can dynamically send value or completion events.&lt;/p&gt; &#xA;&lt;p&gt;This lets you easily create custom publishers to wrap any non-publisher asynchronous work, while still respecting the downstream consumer&#39;s backpressure demand.&lt;/p&gt; &#xA;&lt;p&gt;You should return a &lt;code&gt;Cancellable&lt;/code&gt;-conforming object from the closure in which you can define any cleanup actions to execute when the pubilsher completes or the subscription to the publisher is canceled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;AnyPublisher&amp;lt;String, MyError&amp;gt;.create { subscriber in&#xA;  // Values&#xA;  subscriber.send(&#34;Hello&#34;)&#xA;  subscriber.send(&#34;World!&#34;)&#xA;  &#xA;  // Complete with error&#xA;  subscriber.send(completion: .failure(MyError.someError))&#xA;  &#xA;  // Or, complete successfully&#xA;  subscriber.send(completion: .finished)&#xA;&#xA;  return AnyCancellable { &#xA;    // Perform cleanup&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use an &lt;code&gt;AnyPublisher&lt;/code&gt; initializer with the same signature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;AnyPublisher&amp;lt;String, MyError&amp;gt; { subscriber in &#xA;    /// ...&#xA;    return AnyCancellable { }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;CurrentValueRelay&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;CurrentValueRelay&lt;/code&gt; is identical to a &lt;code&gt;CurrentValueSubject&lt;/code&gt; with two main differences:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It only accepts values, but not completion events, which means it cannot fail.&lt;/li&gt; &#xA; &lt;li&gt;It only publishes a &lt;code&gt;.finished&lt;/code&gt; event upon deallocation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let relay = CurrentValueRelay&amp;lt;String&amp;gt;(&#34;well...&#34;)&#xA;&#xA;relay.sink(receiveValue: { print($0) }) // replays current value, e.g. &#34;well...&#34;&#xA;&#xA;relay.accept(&#34;values&#34;)&#xA;relay.accept(&#34;only&#34;)&#xA;relay.accept(&#34;provide&#34;)&#xA;relay.accept(&#34;great&#34;)&#xA;relay.accept(&#34;guarantees&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;well...&#xA;values&#xA;only&#xA;provide&#xA;great&#xA;guarantees&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;PassthroughRelay&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;PassthroughRelay&lt;/code&gt; is identical to a &lt;code&gt;PassthroughSubject&lt;/code&gt; with two main differences:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It only accepts values, but not completion events, which means it cannot fail.&lt;/li&gt; &#xA; &lt;li&gt;It only publishes a &lt;code&gt;.finished&lt;/code&gt; event upon deallocation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let relay = PassthroughRelay&amp;lt;String&amp;gt;()&#xA;relay.accept(&#34;well...&#34;)&#xA;&#xA;relay.sink(receiveValue: { print($0) }) // does not replay past value(s)&#xA;&#xA;relay.accept(&#34;values&#34;)&#xA;relay.accept(&#34;only&#34;)&#xA;relay.accept(&#34;provide&#34;)&#xA;relay.accept(&#34;great&#34;)&#xA;relay.accept(&#34;guarantees&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;values&#xA;only&#xA;provide&#xA;great&#xA;guarantees&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Subjects&lt;/h2&gt; &#xA;&lt;h3&gt;ReplaySubject&lt;/h3&gt; &#xA;&lt;p&gt;A Combine analog to Rx’s &lt;a href=&#34;http://reactivex.io/documentation/subject.html&#34;&gt;&lt;code&gt;ReplaySubject&lt;/code&gt; type&lt;/a&gt;. It’s similar to a &lt;a href=&#34;https://developer.apple.com/documentation/combine/currentvaluesubject&#34;&gt;&lt;code&gt;CurrentValueSubject&lt;/code&gt;&lt;/a&gt; in that it buffers values, but, it takes it a step further in allowing consumers to specify the number of values to buffer and replay to future subscribers. Also, it will handle forwarding any completion events after the buffer is cleared upon subscription.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let subject = ReplaySubject&amp;lt;Int, Never&amp;gt;(bufferSize: 3)&#xA;&#xA;subject.send(1)&#xA;subject.send(2)&#xA;subject.send(3)&#xA;subject.send(4)&#xA;&#xA;subject&#xA;  .sink(receiveValue: { print($0) })&#xA;&#xA;subject.send(5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;2&#xA;3&#xA;4&#xA;5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT, of course ;-) See the &lt;a href=&#34;https://raw.githubusercontent.com/CombineCommunity/CombineExt/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;The Apple logo and the Combine framework are property of Apple Inc.&lt;/p&gt;</summary>
  </entry>
</feed>