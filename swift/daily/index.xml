<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-08T01:57:19Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Alamofire/AlamofireImage</title>
    <updated>2022-07-08T01:57:19Z</updated>
    <id>tag:github.com,2022-07-08:/Alamofire/AlamofireImage</id>
    <link href="https://github.com/Alamofire/AlamofireImage" rel="alternate"></link>
    <summary type="html">&lt;p&gt;AlamofireImage is an image component library for Alamofire&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;AlamofireImage&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/Alamofire/AlamofireImage&#34;&gt;&lt;img src=&#34;https://travis-ci.org/Alamofire/AlamofireImage.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://img.shields.io/cocoapods/v/AlamofireImage.svg&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/AlamofireImage.svg?sanitize=true&#34; alt=&#34;CocoaPods Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/AlamofireImage&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/AlamofireImage.svg?style=flat&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://twitter.com/AlamofireSF&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/twitter-@AlamofireSF-blue.svg?style=flat&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/Alamofire/Alamofire?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Alamofire/Alamofire.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;AlamofireImage is an image component library for Alamofire.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Image Response Serializers&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; UIImage Extensions for Inflation / Scaling / Rounding / CoreImage&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Single and Multi-Pass Image Filters&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Auto-Purging In-Memory Image Cache&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Prioritized Queue Order Image Downloading&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Authentication with URLCredential&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; UIImageView Async Remote Downloads with Placeholders&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; UIImageView Filters and Transitions&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Comprehensive Test Coverage&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://alamofire.github.io/AlamofireImage/&#34;&gt;Complete Documentation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iOS 10.0+ / macOS 10.12+ / tvOS 10.0+ / watchOS 3.0+&lt;/li&gt; &#xA; &lt;li&gt;Xcode 11+&lt;/li&gt; &#xA; &lt;li&gt;Swift 5.1+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Migration Guides&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Alamofire/AlamofireImage/raw/master/Documentation/AlamofireImage%202.0%20Migration%20Guide.md&#34;&gt;AlamofireImage 2.0 Migration Guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Alamofire/AlamofireImage/raw/master/Documentation/AlamofireImage%203.0%20Migration%20Guide.md&#34;&gt;AlamofireImage 3.0 Migration Guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Alamofire/AlamofireImage/raw/master/Documentation/AlamofireImage%204.0%20Migration%20Guide.md&#34;&gt;AlamofireImage 4.0 Migration Guide&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Alamofire/Alamofire&#34;&gt;Alamofire 5.1+&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Communication&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you need to &lt;strong&gt;find or understand an API&lt;/strong&gt;, check &lt;a href=&#34;https://alamofire.github.io/AlamofireImage/&#34;&gt;our documentation&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If you need &lt;strong&gt;help with an AlamofireImage feature&lt;/strong&gt;, use &lt;a href=&#34;https://forums.swift.org/c/related-projects/alamofire&#34;&gt;our forum on swift.org&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If you&#39;d like to &lt;strong&gt;discuss AlamofireImage best practices&lt;/strong&gt;, use &lt;a href=&#34;https://forums.swift.org/c/related-projects/alamofire&#34;&gt;our forum on swift.org&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If you&#39;d like to &lt;strong&gt;discuss a feature request&lt;/strong&gt;, use &lt;a href=&#34;https://forums.swift.org/c/related-projects/alamofire&#34;&gt;our forum on swift.org&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If you &lt;strong&gt;found a bug&lt;/strong&gt;, open an issue and follow the guide. The more detail the better!&lt;/li&gt; &#xA; &lt;li&gt;If you &lt;strong&gt;want to contribute&lt;/strong&gt;, submit a pull request.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt; is a dependency manager for Cocoa projects. For usage and installation instructions, visit their website. To integrate AlamofireImage into your Xcode project using CocoaPods, specify it in your &lt;code&gt;Podfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;AlamofireImage&#39;, &#39;~&amp;gt; 4.1&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt; is a decentralized dependency manager that builds your dependencies and provides you with binary frameworks. To integrate AlamofireImage into your Xcode project using Carthage, specify it in your &lt;code&gt;Cartfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ogdl&#34;&gt;github &#34;Alamofire/AlamofireImage&#34; ~&amp;gt; 4.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;Swift Package Manager&lt;/a&gt; is a tool for automating the distribution of Swift code and is integrated into the &lt;code&gt;swift&lt;/code&gt; compiler. It is in early development, but AlamofireImage does support its use on supported platforms.&lt;/p&gt; &#xA;&lt;p&gt;Once you have your Swift package set up, adding AlamofireImage as a dependency is as easy as adding it to the &lt;code&gt;dependencies&lt;/code&gt; value of your &lt;code&gt;Package.swift&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/Alamofire/AlamofireImage.git&#34;, .upToNextMajor(from: &#34;4.2.0&#34;))&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Manually&lt;/h3&gt; &#xA;&lt;p&gt;If you prefer not to use either of the aforementioned dependency managers, you can integrate AlamofireImage into your project manually.&lt;/p&gt; &#xA;&lt;h4&gt;Embedded Framework&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open up Terminal, &lt;code&gt;cd&lt;/code&gt; into your top-level project directory, and run the following command &#34;if&#34; your project is not initialized as a git repository:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git init&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add AlamofireImage as a git &lt;a href=&#34;http://git-scm.com/docs/git-submodule&#34;&gt;submodule&lt;/a&gt; by running the following command:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git submodule add https://github.com/Alamofire/AlamofireImage.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Open the new &lt;code&gt;AlamofireImage&lt;/code&gt; folder, and drag the &lt;code&gt;AlamofireImage.xcodeproj&lt;/code&gt; into the Project Navigator of your application&#39;s Xcode project.&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;It should appear nested underneath your application&#39;s blue project icon. Whether it is above or below all the other Xcode groups does not matter.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Select the &lt;code&gt;AlamofireImage.xcodeproj&lt;/code&gt; in the Project Navigator and verify the deployment target matches that of your application target.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Next, select your application project in the Project Navigator (blue project icon) to navigate to the target configuration window and select the application target under the &#34;Targets&#34; heading in the sidebar.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In the tab bar at the top of that window, open the &#34;General&#34; panel.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Click on the &lt;code&gt;+&lt;/code&gt; button under the &#34;Embedded Binaries&#34; section.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You will see two different &lt;code&gt;AlamofireImage.xcodeproj&lt;/code&gt; folders each with two different versions of the &lt;code&gt;AlamofireImage.framework&lt;/code&gt; nested inside a &lt;code&gt;Products&lt;/code&gt; folder.&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;It does not matter which &lt;code&gt;Products&lt;/code&gt; folder you choose from, but it does matter whether you choose the top or bottom &lt;code&gt;AlamofireImage.framework&lt;/code&gt;.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Select the top &lt;code&gt;AlamofireImage.framework&lt;/code&gt; for iOS and the bottom one for OS X.&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;You can verify which one you selected by inspecting the build log for your project. The build target for &lt;code&gt;AlamofireImage&lt;/code&gt; will be listed as either &lt;code&gt;AlamofireImage iOS&lt;/code&gt;, &lt;code&gt;AlamofireImage macOS&lt;/code&gt;, &lt;code&gt;AlamofireImage tvOS&lt;/code&gt; or &lt;code&gt;AlamofireImage watchOS&lt;/code&gt;.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;And that&#39;s it!&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;The &lt;code&gt;AlamofireImage.framework&lt;/code&gt; is automagically added as a target dependency, linked framework and embedded framework in a copy files build phase which is all you need to build on the simulator and a device.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Image Response Serializers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Alamofire&#xA;import AlamofireImage&#xA;&#xA;AF.request(&#34;https://httpbin.org/image/png&#34;).responseImage { response in&#xA;&#x9;debugPrint(response)&#xA;&#xA;&#x9;print(response.request)&#xA;&#x9;print(response.response)&#xA;&#x9;debugPrint(response.result)&#xA;&#xA;    if case .success(let image) = response.result {&#xA;&#x9;&#x9;print(&#34;image downloaded: \(image)&#34;)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The AlamofireImage response image serializers support a wide range of image types including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;image/png&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;image/jpeg&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;image/tiff&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;image/gif&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;image/ico&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;image/x-icon&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;image/bmp&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;image/x-bmp&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;image/x-xbitmap&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;image/x-ms-bmp&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;image/x-win-bitmap&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;image/heic&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;application/octet-stream&lt;/code&gt; (added for iOS 13 support)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If the image you are attempting to download is an invalid MIME type not in the list, you can add custom acceptable content types using the &lt;code&gt;addAcceptableImageContentTypes&lt;/code&gt; extension on the &lt;code&gt;DataRequest&lt;/code&gt; type.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;UIImage Extensions&lt;/h3&gt; &#xA;&lt;p&gt;There are several &lt;code&gt;UIImage&lt;/code&gt; extensions designed to make the common image manipulation operations as simple as possible.&lt;/p&gt; &#xA;&lt;h4&gt;Inflation&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let url = Bundle.main.url(forResource: &#34;unicorn&#34;, withExtension: &#34;png&#34;)!&#xA;let data = try! Data(contentsOf: url)&#xA;let image = UIImage(data: data, scale: UIScreen.main.scale)!&#xA;&#xA;image.af.inflate()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Inflating compressed image formats (such as PNG or JPEG) in a background queue can significantly improve drawing performance on the main thread.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Scaling&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let image = UIImage(named: &#34;unicorn&#34;)!&#xA;let size = CGSize(width: 100.0, height: 100.0)&#xA;&#xA;// Scale image to size disregarding aspect ratio&#xA;let scaledImage = image.af.imageScaled(to: size)&#xA;&#xA;// Scale image to fit within specified size while maintaining aspect ratio&#xA;let aspectScaledToFitImage = image.af.imageAspectScaled(toFit: size)&#xA;&#xA;// Scale image to fill specified size while maintaining aspect ratio&#xA;let aspectScaledToFillImage = image.af.imageAspectScaled(toFill: size)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Rounded Corners&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let image = UIImage(named: &#34;unicorn&#34;)!&#xA;let radius: CGFloat = 20.0&#xA;&#xA;let roundedImage = image.af.imageRounded(withCornerRadius: radius)&#xA;let circularImage = image.af.imageRoundedIntoCircle()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Core Image Filters&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let image = UIImage(named: &#34;unicorn&#34;)!&#xA;&#xA;let sepiaImage = image.af.imageFiltered(withCoreImageFilter: &#34;CISepiaTone&#34;)&#xA;&#xA;let blurredImage = image.af.imageFiltered(&#xA;    withCoreImageFilter: &#34;CIGaussianBlur&#34;,&#xA;    parameters: [&#34;inputRadius&#34;: 25]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Image Filters&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;ImageFilter&lt;/code&gt; protocol was designed to make it easy to apply a filter operation and cache the result after an image finished downloading. It defines two properties to facilitate this functionality.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol ImageFilter {&#xA;    var filter: Image -&amp;gt; Image { get }&#xA;    var identifier: String { get }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;filter&lt;/code&gt; closure contains the operation used to create a modified version of the specified image. The &lt;code&gt;identifier&lt;/code&gt; property is a string used to uniquely identify the filter operation. This is useful when adding filtered versions of an image to a cache. All identifier properties inside AlamofireImage are implemented using protocol extensions.&lt;/p&gt; &#xA;&lt;h4&gt;Single Pass&lt;/h4&gt; &#xA;&lt;p&gt;The single pass image filters only perform a single operation on the specified image.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let image = UIImage(named: &#34;unicorn&#34;)!&#xA;let imageFilter = RoundedCornersFilter(radius: 10.0)&#xA;&#xA;let roundedImage = imageFilter.filter(image)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The current list of single pass image filters includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ScaledToSizeFilter&lt;/code&gt; - Scales an image to a specified size.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AspectScaledToFitSizeFilter&lt;/code&gt; - Scales an image from the center while maintaining the aspect ratio to fit within a specified size.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AspectScaledToFillSizeFilter&lt;/code&gt; - Scales an image from the center while maintaining the aspect ratio to fill a specified size. Any pixels that fall outside the specified size are clipped.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RoundedCornersFilter&lt;/code&gt; - Rounds the corners of an image to the specified radius.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CircleFilter&lt;/code&gt; - Rounds the corners of an image into a circle.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;BlurFilter&lt;/code&gt; - Blurs an image using a &lt;code&gt;CIGaussianBlur&lt;/code&gt; filter with the specified blur radius.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Each image filter is built ontop of the &lt;code&gt;UIImage&lt;/code&gt; extensions.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Multi-Pass&lt;/h4&gt; &#xA;&lt;p&gt;The multi-pass image filters perform multiple operations on the specified image.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let image = UIImage(named: &#34;avatar&#34;)!&#xA;let size = CGSize(width: 100.0, height: 100.0)&#xA;let imageFilter = AspectScaledToFillSizeCircleFilter(size: size)&#xA;&#xA;let avatarImage = imageFilter.filter(image)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The current list of multi-pass image filters includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ScaledToSizeWithRoundedCornersFilter&lt;/code&gt; - Scales an image to a specified size, then rounds the corners to the specified radius.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AspectScaledToFillSizeWithRoundedCornersFilter&lt;/code&gt; - Scales an image from the center while maintaining the aspect ratio to fit within a specified size, then rounds the corners to the specified radius.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ScaledToSizeCircleFilter&lt;/code&gt; - Scales an image to a specified size, then rounds the corners into a circle.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AspectScaledToFillSizeCircleFilter&lt;/code&gt; - Scales an image from the center while maintaining the aspect ratio to fit within a specified size, then rounds the corners into a circle.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Image Cache&lt;/h3&gt; &#xA;&lt;p&gt;Image caching can become complicated when it comes to network images. &lt;code&gt;URLCache&lt;/code&gt; is quite powerful and does a great job reasoning through the various cache policies and &lt;code&gt;Cache-Control&lt;/code&gt; headers. However, it is not equipped to handle caching multiple modified versions of those images.&lt;/p&gt; &#xA;&lt;p&gt;For example, let&#39;s say you need to download an album of images. Your app needs to display both the thumbnail version as well as the full size version at various times. Due to performance issues, you want to scale down the thumbnails to a reasonable size before rendering them on-screen. You also need to apply a global CoreImage filter to the full size images when displayed. While &lt;code&gt;URLCache&lt;/code&gt; can easily handle storing the original downloaded image, it cannot store these different variants. What you really need is another caching layer designed to handle these different variants.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageCache = AutoPurgingImageCache(&#xA;    memoryCapacity: 100_000_000,&#xA;    preferredMemoryUsageAfterPurge: 60_000_000&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;AutoPurgingImageCache&lt;/code&gt; in AlamofireImage fills the role of that additional caching layer. It is an in-memory image cache used to store images up to a given memory capacity. When the memory capacity is reached, the image cache is sorted by last access date, then the oldest image is continuously purged until the preferred memory usage after purge is met. Each time an image is accessed through the cache, the internal access date of the image is updated.&lt;/p&gt; &#xA;&lt;h4&gt;Add / Remove / Fetch Images&lt;/h4&gt; &#xA;&lt;p&gt;Interacting with the &lt;code&gt;ImageCache&lt;/code&gt; protocol APIs is very straightforward.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageCache = AutoPurgingImageCache()&#xA;let avatarImage = UIImage(data: data)!&#xA;&#xA;// Add&#xA;imageCache.add(avatarImage, withIdentifier: &#34;avatar&#34;)&#xA;&#xA;// Fetch&#xA;let cachedAvatar = imageCache.image(withIdentifier: &#34;avatar&#34;)&#xA;&#xA;// Remove&#xA;imageCache.removeImage(withIdentifier: &#34;avatar&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;URL Requests&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;ImageRequestCache&lt;/code&gt; protocol extends the &lt;code&gt;ImageCache&lt;/code&gt; protocol by adding support for &lt;code&gt;URLRequest&lt;/code&gt; caching. This allows a &lt;code&gt;URLRequest&lt;/code&gt; and an additional identifier to generate the unique identifier for the image in the cache.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageCache = AutoPurgingImageCache()&#xA;&#xA;let urlRequest = URLRequest(url: URL(string: &#34;https://httpbin.org/image/png&#34;)!)&#xA;let avatarImage = UIImage(named: &#34;avatar&#34;)!.af.imageRoundedIntoCircle()&#xA;&#xA;// Add&#xA;imageCache.add(avatarImage, for: urlRequest, withIdentifier: &#34;circle&#34;)&#xA;&#xA;// Fetch&#xA;let cachedAvatarImage = imageCache.image(for: urlRequest, withIdentifier: &#34;circle&#34;)&#xA;&#xA;// Remove&#xA;imageCache.removeImage(for: urlRequest, withIdentifier: &#34;circle&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Auto-Purging&lt;/h4&gt; &#xA;&lt;p&gt;Each time an image is fetched from the cache, the cache internally updates the last access date for that image.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let avatar = imageCache.image(withIdentifier: &#34;avatar&#34;)&#xA;let circularAvatar = imageCache.image(for: urlRequest, withIdentifier: &#34;circle&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By updating the last access date for each image, the image cache can make more informed decisions about which images to purge when the memory capacity is reached. The &lt;code&gt;AutoPurgingImageCache&lt;/code&gt; automatically evicts images from the cache in order from oldest last access date to newest until the memory capacity drops below the &lt;code&gt;preferredMemoryCapacityAfterPurge&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;It is important to set reasonable default values for the &lt;code&gt;memoryCapacity&lt;/code&gt; and &lt;code&gt;preferredMemoryCapacityAfterPurge&lt;/code&gt; when you are initializing your image cache. By default, the &lt;code&gt;memoryCapacity&lt;/code&gt; equals 100 MB and the &lt;code&gt;preferredMemoryCapacityAfterPurge&lt;/code&gt; equals 60 MB.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Memory Warnings&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;AutoPurgingImageCache&lt;/code&gt; also listens for memory warnings from your application and will purge all images from the cache if a memory warning is observed.&lt;/p&gt; &#xA;&lt;h3&gt;Image Downloader&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;ImageDownloader&lt;/code&gt; class is responsible for downloading images in parallel on a prioritized queue. It uses an internal Alamofire &lt;code&gt;SessionManager&lt;/code&gt; instance to handle all the downloading and response image serialization. By default, the initialization of an &lt;code&gt;ImageDownloader&lt;/code&gt; uses a default &lt;code&gt;URLSessionConfiguration&lt;/code&gt; with the most common parameter values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageDownloader = ImageDownloader(&#xA;    configuration: ImageDownloader.defaultURLSessionConfiguration(),&#xA;    downloadPrioritization: .fifo,&#xA;    maximumActiveDownloads: 4,&#xA;    imageCache: AutoPurgingImageCache()&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If you need to customize the &lt;code&gt;URLSessionConfiguration&lt;/code&gt; type or parameters, then simply provide your own rather than using the default.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Downloading an Image&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let downloader = ImageDownloader()&#xA;let urlRequest = URLRequest(url: URL(string: &#34;https://httpbin.org/image/jpeg&#34;)!)&#xA;&#xA;downloader.download(urlRequest) { response in&#xA;    print(response.request)&#xA;    print(response.response)&#xA;    debugPrint(response.result)&#xA;&#xA;    if case .success(let image) = response.result {&#xA;        print(image)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Make sure to keep a strong reference to the &lt;code&gt;ImageDownloader&lt;/code&gt; instance, otherwise the &lt;code&gt;completion&lt;/code&gt; closure will not be called because the &lt;code&gt;downloader&lt;/code&gt; reference will go out of scope before the &lt;code&gt;completion&lt;/code&gt; closure can be called.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Applying an ImageFilter&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let downloader = ImageDownloader()&#xA;let urlRequest = URLRequest(url: URL(string: &#34;https://httpbin.org/image/jpeg&#34;)!)&#xA;let filter = AspectScaledToFillSizeCircleFilter(size: CGSize(width: 100.0, height: 100.0))&#xA;&#xA;downloader.download(urlRequest, filter: filter) { response in&#xA;    print(response.request)&#xA;    print(response.response)&#xA;    debugPrint(response.result)&#xA;&#xA;    if case .success(let image) = response.result {&#xA;        print(image)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Authentication&lt;/h4&gt; &#xA;&lt;p&gt;If your images are behind HTTP Basic Auth, you can append the &lt;code&gt;user:password:&lt;/code&gt; or the &lt;code&gt;credential&lt;/code&gt; to the &lt;code&gt;ImageDownloader&lt;/code&gt; instance. The credentials will be applied to all future download requests.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let downloader = ImageDownloader()&#xA;downloader.addAuthentication(user: &#34;username&#34;, password: &#34;password&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Download Prioritization&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;ImageDownloader&lt;/code&gt; maintains an internal queue of pending download requests. Depending on your situation, you may want incoming downloads to be inserted at the front or the back of the queue. The &lt;code&gt;DownloadPrioritization&lt;/code&gt; enumeration allows you to specify which behavior you would prefer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public enum DownloadPrioritization {&#xA;    case fifo, lifo&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;ImageDownloader&lt;/code&gt; is initialized with a &lt;code&gt;.fifo&lt;/code&gt; queue by default.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Image Caching&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;ImageDownloader&lt;/code&gt; uses a combination of an &lt;code&gt;URLCache&lt;/code&gt; and &lt;code&gt;AutoPurgingImageCache&lt;/code&gt; to create a very robust, high performance image caching system.&lt;/p&gt; &#xA;&lt;h5&gt;URLCache&lt;/h5&gt; &#xA;&lt;p&gt;The &lt;code&gt;URLCache&lt;/code&gt; is used to cache all the original image content downloaded from the server. By default, it is initialized with a memory capacity of 20 MB and a disk capacity of 150 MB. This allows up to 150 MB of original image data to be stored on disk at any given time. While these defaults have been carefully set, it is very important to consider your application&#39;s needs and performance requirements and whether these values are right for you.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If you wish to disable this caching layer, create a custom &lt;code&gt;URLSessionConfiguration&lt;/code&gt; with the &lt;code&gt;urlCache&lt;/code&gt; property set to &lt;code&gt;nil&lt;/code&gt; and use that configuration when initializing the &lt;code&gt;ImageDownloader&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h5&gt;Image Cache&lt;/h5&gt; &#xA;&lt;p&gt;The &lt;code&gt;ImageCache&lt;/code&gt; is used to cache all the potentially filtered image content after it has been downloaded from the server. This allows multiple variants of the same image to also be cached, rather than having to re-apply the image filters to the original image each time it is required. By default, an &lt;code&gt;AutoPurgingImageCache&lt;/code&gt; is initialized with a memory capacity of 100 MB and a preferred memory usage after purge limit of 60 MB. This allows up to 100 MB of most recently accessed filtered image content to be stored in-memory at a given time.&lt;/p&gt; &#xA;&lt;h5&gt;Setting Ideal Capacity Limits&lt;/h5&gt; &#xA;&lt;p&gt;Determining the ideal the in-memory and on-disk capacity limits of the &lt;code&gt;URLCache&lt;/code&gt; and &lt;code&gt;AutoPurgingImageCache&lt;/code&gt; requires a bit of forethought. You must carefully consider your application&#39;s needs, and tailor the limits accordingly. By default, the combination of caches offers the following storage capacities:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;150 MB of on-disk storage (original image only)&lt;/li&gt; &#xA; &lt;li&gt;20 MB of in-memory original image data storage (original image only)&lt;/li&gt; &#xA; &lt;li&gt;100 MB of in-memory storage of filtered image content (filtered image if using filters, otherwise original image)&lt;/li&gt; &#xA; &lt;li&gt;60 MB preferred memory capacity after purge of filtered image content&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If you do not use image filters, it is advised to set the memory capacity of the &lt;code&gt;URLCache&lt;/code&gt; to zero. Otherwise, you will be storing the original image data in both the URLCache&#39;s in-memory store as well as the AlamofireImage in-memory store.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Duplicate Downloads&lt;/h4&gt; &#xA;&lt;p&gt;Sometimes application logic can end up attempting to download an image more than once before the initial download request is complete. Most often, this results in the image being downloaded more than once. AlamofireImage handles this case elegantly by merging the duplicate downloads. The image will only be downloaded once, yet both completion handlers will be called.&lt;/p&gt; &#xA;&lt;h5&gt;Image Filter Reuse&lt;/h5&gt; &#xA;&lt;p&gt;In addition to merging duplicate downloads, AlamofireImage can also merge duplicate image filters. If two image filters with the same identifier are attached to the same download, the image filter is only executed once and both completion handlers are called with the same resulting image. This can save large amounts of time and resources for computationally expensive filters such as ones leveraging CoreImage.&lt;/p&gt; &#xA;&lt;h5&gt;Request Receipts&lt;/h5&gt; &#xA;&lt;p&gt;Sometimes it is necessary to cancel an image download for various reasons. AlamofireImage can intelligently handle cancellation logic in the &lt;code&gt;ImageDownloader&lt;/code&gt; by leveraging the &lt;code&gt;RequestReceipt&lt;/code&gt; type along with the &lt;code&gt;cancelRequestForRequestReceipt&lt;/code&gt; method. Each download request vends a &lt;code&gt;RequestReceipt&lt;/code&gt; which can be later used to cancel the request.&lt;/p&gt; &#xA;&lt;p&gt;By cancelling the request through the &lt;code&gt;ImageDownloader&lt;/code&gt; using the &lt;code&gt;RequestReceipt&lt;/code&gt;, AlamofireImage is able to determine how to best handle the cancellation. The cancelled download will always receive a cancellation error, while duplicate downloads are allowed to complete. If the download is already active, it is allowed to complete even though the completion handler will be called with a cancellation error. This greatly improves performance of table and collection views displaying large amounts of images.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;It is NOT recommended to directly call &lt;code&gt;cancel&lt;/code&gt; on the &lt;code&gt;request&lt;/code&gt; in the &lt;code&gt;RequestReceipt&lt;/code&gt;. Doing so can lead to issues such as duplicate downloads never being allowed to complete.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;UIImageView Extension&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/Alamofire/AlamofireImage/master/#uiimage-extensions&#34;&gt;UIImage Extensions&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/Alamofire/AlamofireImage/master/#image-filters&#34;&gt;Image Filters&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/Alamofire/AlamofireImage/master/#image-cache&#34;&gt;Image Cache&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/Alamofire/AlamofireImage/master/#image-downloader&#34;&gt;Image Downloader&lt;/a&gt; were all designed to be flexible and standalone, yet also to provide the foundation of the &lt;code&gt;UIImageView&lt;/code&gt; extension. Due to the powerful support of these classes, protocols and extensions, the &lt;code&gt;UIImageView&lt;/code&gt; APIs are concise, easy to use and contain a large amount of functionality.&lt;/p&gt; &#xA;&lt;h4&gt;Setting Image with URL&lt;/h4&gt; &#xA;&lt;p&gt;Setting the image with a URL will asynchronously download the image and set it once the request is finished.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageView = UIImageView(frame: frame)&#xA;let url = URL(string: &#34;https://httpbin.org/image/png&#34;)!&#xA;&#xA;imageView.af.setImage(withURL: url)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If the image is cached locally, the image is set immediately.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Placeholder Images&lt;/h4&gt; &#xA;&lt;p&gt;By specifying a placeholder image, the image view uses the placeholder image until the remote image is downloaded.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageView = UIImageView(frame: frame)&#xA;let url = URL(string: &#34;https://httpbin.org/image/png&#34;)!&#xA;let placeholderImage = UIImage(named: &#34;placeholder&#34;)!&#xA;&#xA;imageView.af.setImage(withURL: url, placeholderImage: placeholderImage)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If the remote image is cached locally, the placeholder image is never set.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Image Filters&lt;/h4&gt; &#xA;&lt;p&gt;If an image filter is specified, it is applied asynchronously after the remote image is downloaded. Once the filter execution is complete, the resulting image is set on the image view.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageView = UIImageView(frame: frame)&#xA;&#xA;let url = URL(string: &#34;https://httpbin.org/image/png&#34;)!&#xA;let placeholderImage = UIImage(named: &#34;placeholder&#34;)!&#xA;&#xA;let filter = AspectScaledToFillSizeWithRoundedCornersFilter(&#xA;    size: imageView.frame.size,&#xA;    radius: 20.0&#xA;)&#xA;&#xA;imageView.af.setImage(&#xA;    withURL: url,&#xA;    placeholderImage: placeholderImage,&#xA;    filter: filter&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If the remote image with the applied filter is cached locally, the image is set immediately.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Image Transitions&lt;/h4&gt; &#xA;&lt;p&gt;By default, there is no image transition animation when setting the image on the image view. If you wish to add a cross dissolve or flip-from-bottom animation, then specify an &lt;code&gt;ImageTransition&lt;/code&gt; with the preferred duration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageView = UIImageView(frame: frame)&#xA;&#xA;let url = URL(string: &#34;https://httpbin.org/image/png&#34;)!&#xA;let placeholderImage = UIImage(named: &#34;placeholder&#34;)!&#xA;&#xA;let filter = AspectScaledToFillSizeWithRoundedCornersFilter(&#xA;    size: imageView.frame.size,&#xA;    radius: 20.0&#xA;)&#xA;&#xA;imageView.af.setImage(&#xA;    withURL: url,&#xA;    placeholderImage: placeholderImage,&#xA;    filter: filter,&#xA;    imageTransition: .crossDissolve(0.2)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If the remote image is cached locally, the image transition is ignored.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Image Downloader&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;UIImageView&lt;/code&gt; extension is powered by the default &lt;code&gt;ImageDownloader&lt;/code&gt; instance. To customize cache capacities, download priorities, request cache policies, timeout durations, etc., please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/Alamofire/AlamofireImage/master/#image-downloader&#34;&gt;Image Downloader&lt;/a&gt; documentation.&lt;/p&gt; &#xA;&lt;h5&gt;Authentication&lt;/h5&gt; &#xA;&lt;p&gt;If an image requires and authentication credential from the &lt;code&gt;UIImageView&lt;/code&gt; extension, it can be provided as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;ImageDownloader.default.addAuthentication(user: &#34;user&#34;, password: &#34;password&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;Alamofire is owned and maintained by the &lt;a href=&#34;http://alamofire.org&#34;&gt;Alamofire Software Foundation&lt;/a&gt;. You can follow them on Twitter at &lt;a href=&#34;https://twitter.com/AlamofireSF&#34;&gt;@AlamofireSF&lt;/a&gt; for project updates and releases.&lt;/p&gt; &#xA;&lt;h3&gt;Security Disclosure&lt;/h3&gt; &#xA;&lt;p&gt;If you believe you have identified a security vulnerability with AlamofireImage, you should report it as soon as possible via email to &lt;a href=&#34;mailto:security@alamofire.org&#34;&gt;security@alamofire.org&lt;/a&gt;. Please do not post it to a public issue tracker.&lt;/p&gt; &#xA;&lt;h2&gt;Donations&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/Alamofire/Foundation#members&#34;&gt;ASF&lt;/a&gt; is looking to raise money to officially stay registered as a federal non-profit organization. Registering will allow us members to gain some legal protections and also allow us to put donations to use, tax free. Donating to the ASF will enable us to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pay our yearly legal fees to keep the non-profit in good status&lt;/li&gt; &#xA; &lt;li&gt;Pay for our mail servers to help us stay on top of all questions and security issues&lt;/li&gt; &#xA; &lt;li&gt;Potentially fund test servers to make it easier for us to test the edge cases&lt;/li&gt; &#xA; &lt;li&gt;Potentially fund developers to work on one of our projects full-time&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The community adoption of the ASF libraries has been amazing. We are greatly humbled by your enthusiasm around the projects, and want to continue to do everything we can to move the needle forward. With your continued support, the ASF will be able to improve its reach and also provide better legal safety for the core members. If you use any of our libraries for work, see if your employers would be interested in donating. Any amount you can donate today to help us reach our goal would be greatly appreciated.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;amp;hosted_button_id=W34WPEE74APJQ&#34;&gt;&lt;img src=&#34;https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif&#34; alt=&#34;paypal&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;AlamofireImage is released under the MIT license. &lt;a href=&#34;https://github.com/Alamofire/AlamofireImage/raw/master/LICENSE&#34;&gt;See LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>CRED-CLUB/neopop-ios</title>
    <updated>2022-07-08T01:57:19Z</updated>
    <id>tag:github.com,2022-07-08:/CRED-CLUB/neopop-ios</id>
    <link href="https://github.com/CRED-CLUB/neopop-ios" rel="alternate"></link>
    <summary type="html">&lt;p&gt;NeoPop is CRED&#39;s inbuilt library for using NeoPop components in your app&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;NeoPOP&lt;/h1&gt; &#xA;&lt;p&gt;NeoPOP is CRED&#39;s inbuilt library for using NeoPOP components in your app.&lt;/p&gt; &#xA;&lt;h3&gt;What really is NeoPOP?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cred.club/neopop&#34;&gt;NeoPOP&lt;/a&gt; was created with one simple goal; to create the next generation of a beautiful, affirmative design system. NeoPOP stays true to everything that design at CRED stands for.&lt;/p&gt; &#xA;&lt;p&gt;NeoPOP is built for &lt;a href=&#34;https://github.com/CRED-CLUB/neopop-android&#34;&gt;Android&lt;/a&gt;, iOS, &lt;a href=&#34;https://github.com/CRED-CLUB/neopop-flutter&#34;&gt;Flutter&lt;/a&gt; and &lt;a href=&#34;https://github.com/CRED-CLUB/neopop-web&#34;&gt;Web&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/1gN3wzy.jpg&#34; alt=&#34;Banner&#34; title=&#34;Banner&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;NeoPOP is available through CocoaPods. To install it, add the following line to your Podfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;NeoPop&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;Follow &lt;a href=&#34;https://developer.apple.com/documentation/swift_packages/adding_package_dependencies_to_your_app&#34;&gt;this doc&lt;/a&gt; to add a new dependency to your project. If your &lt;code&gt;Package.swift&lt;/code&gt; is already setup, add this line to project dependencies.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/CRED-CLUB/neopop-ios&#34;, from: &#34;1.0.0&#34;)&#xA;],&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iOS 11.0+&lt;/li&gt; &#xA; &lt;li&gt;Swift 5.5+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;PopView&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;PopView&lt;/code&gt; is a subclass of UIView, which can exhibit the NeoPOP effect.&lt;/p&gt; &#xA;&lt;p&gt;The design of a &lt;code&gt;PopView&lt;/code&gt; can be primarily classified with respect to the direction of viewing the &lt;code&gt;PopView&lt;/code&gt;. those are called the &lt;code&gt;EdgeDirection&lt;/code&gt; of the PopView, which are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;topLeft&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;topRight&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;bottomLeft&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;bottomRight&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;top&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;bottom&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;left&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;right&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;PopView.Model&lt;/code&gt; holds the properties of a &lt;code&gt;PopView&lt;/code&gt;, which helps you to customise the view with respect to your requirements.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;PopView.Model&lt;/code&gt; can be initialised as follows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let model = PopView.Model(&#xA;    popEdgeDirection: .bottomRight, &#xA;    backgroundColor: UIColor.gray&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s see some of the examples of drawing a &lt;code&gt;PopView&lt;/code&gt; with different &lt;code&gt;EdgeDirections&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;topLeft&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/72977449/175024211-4a36867f-d9c5-43d5-b52d-3c44c7b9a71b.png&#34; alt=&#34;enter image description here&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;PopView.Model(&#xA;&#x9;popEdgeDirection: .topLeft, &#xA;&#x9;backgroundColor: UIColor.black, &#xA;&#x9;verticalEdgeColor: PopHelper.verticalEdgeColor(for: UIColor.green), &#xA;&#x9;horizontalEdgeColor: PopHelper.horizontalEdgeColor(for: UIColor.green)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;topRight&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/72977449/175024585-e60e63b7-8642-4827-b98f-35cfb6d4dc85.png&#34; alt=&#34;enter image description here&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;PopView.Model(&#xA;    popEdgeDirection: .topRight, &#xA;&#x9;backgroundColor: UIColor.black, &#xA;&#x9;verticalEdgeColor: PopHelper.verticalEdgeColor(for: UIColor.green), &#xA;&#x9;horizontalEdgeColor: PopHelper.horizontalEdgeColor(for: UIColor.green)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;bottomLeft&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/72977449/175024721-5ccb8763-0170-480c-92bf-567dd11f5654.png&#34; alt=&#34;enter image description here&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;PopView.Model(&#xA;&#x9;popEdgeDirection: .bottomLeft, &#xA;&#x9;backgroundColor: UIColor.black, &#xA;&#x9;verticalEdgeColor: PopHelper.verticalEdgeColor(for: UIColor.green), &#xA;&#x9;horizontalEdgeColor: PopHelper.horizontalEdgeColor(for: UIColor.green)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;bottomRight&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/72977449/175024804-d7f7d8d3-106c-4014-a884-11c0771a6026.png&#34; alt=&#34;enter image description here&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;PopView.Model(&#xA;&#x9;popEdgeDirection: .bottomRight, &#xA;&#x9;backgroundColor: UIColor.black, &#xA;&#x9;verticalEdgeColor: PopHelper.verticalEdgeColor(for: UIColor.green), &#xA;&#x9;horizontalEdgeColor: PopHelper.horizontalEdgeColor(for: UIColor.green)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;similarly you can use other directions too.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;/h2&gt; &#xA;&lt;p&gt;for more customisations you may use the properties of &lt;code&gt;PopView.Model&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;PopView.Model&lt;/code&gt; initialiser arguments&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;attribute&lt;/th&gt; &#xA;   &lt;th&gt;description&lt;/th&gt; &#xA;   &lt;th&gt;value&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;neoPopEdgeDirection&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Direction of edge of the pop view.&lt;/td&gt; &#xA;   &lt;td&gt;EdgeDirection&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;customEdgeVisibility&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Change the visibility of the available edges..&lt;/td&gt; &#xA;   &lt;td&gt;EdgeVisibilityModel&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;customBorderVisibility&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Change the visibility of the border.&lt;/td&gt; &#xA;   &lt;td&gt;EdgeVisibilityModel&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;edgeOffSet&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;depth of the edge.&lt;/td&gt; &#xA;   &lt;td&gt;CGFloat&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;backgroundColor&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Background color of the view.&lt;/td&gt; &#xA;   &lt;td&gt;UIColor&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;verticalEdgeColor&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Color of the vertical edge in the view. (either of left/right). Optional input as it will be derived from background color.&lt;/td&gt; &#xA;   &lt;td&gt;UIColor&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;horizontalEdgeColor&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Color of the horizontal edge in the view. (either of top/bottom). Optional input as it will be derived from background color.&lt;/td&gt; &#xA;   &lt;td&gt;UIColor&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;verticalBorderColors&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Color of the vertical edge borders. (customisable for each side of the edge).&lt;/td&gt; &#xA;   &lt;td&gt;EdgeColors&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;horizontalBorderColors&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Color of the horizontal edge borders. (customisable for each side of the edge).&lt;/td&gt; &#xA;   &lt;td&gt;EdgeColors&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;clipsToOffSetWidth&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Whether clipping needs to be done to the horizontal edge (clipping position options are available here).&lt;/td&gt; &#xA;   &lt;td&gt;EdgeDirection&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;clipsToOffSetHeight&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Whether clipping needs to be done to the vertical edge (clipping position options are available here).&lt;/td&gt; &#xA;   &lt;td&gt;EdgeDirection&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;delegate&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Delegate to handle the callbacks. customisations in the drawing path can be achieved through this delegate.&lt;/td&gt; &#xA;   &lt;td&gt;PopViewDrawable&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;modelIdentifier&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Identifier for model/view for reference&lt;/td&gt; &#xA;   &lt;td&gt;String?&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;borderWidth&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;width for the border.&lt;/td&gt; &#xA;   &lt;td&gt;CGFloat&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Initialising a &lt;code&gt;PopView&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can create a &lt;code&gt;PopView&lt;/code&gt; through code using the below approach.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let model = PopView.Model(&#xA;    popEdgeDirection: .bottomRight, &#xA;    backgroundColor: UIColor.black&#xA;)&#xA;&#xA;let popView = PopView(&#xA;&#x9;frame: CGRect(x: 0, y: 0, width: 100, height: 100), &#xA;&#x9;model: model&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;apply NeoPOP effect on a &lt;code&gt;PopView&lt;/code&gt; as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@IBOutlet private weak var popView: PopView!&#xA;...&#xA;let model = PopView.Model(&#xA;    popEdgeDirection: .bottomRight, &#xA;    backgroundColor: UIColor.black&#xA;)&#xA;popView.configurePopView(withModel: model)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is also an extension created on &lt;code&gt;UIView&lt;/code&gt;, which enables to apply NeoPOP Style in any existing &lt;code&gt;UIView&lt;/code&gt; element,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var view: UIView!&#xA;let model = PopView.Model(&#xA;    popEdgeDirection: .bottomRight, &#xA;    backgroundColor: UIColor.black&#xA;)&#xA;view.applyNeoPopStyle(model: model)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Buttons&lt;/h1&gt; &#xA;&lt;h2&gt;PopButton&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/9965653/173539706-fa521743-b214-4372-87dd-799d9b8b6c70.png&#34; alt=&#34;Configs&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The structure and the behaviour of a PopButton mainly depends on two parameters which are &lt;code&gt;EdgeDirection&lt;/code&gt; &amp;amp; &lt;code&gt;PopButton.Position&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;EdgeDirection&lt;/code&gt; is the possible directions of viewing a 3-dimensional &lt;code&gt;PopButton&lt;/code&gt;, which are :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;topLeft&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;topRight&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;bottomLeft&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;bottomRight&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;top&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;bottom&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;left&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;right&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All the below examples are derives with &lt;code&gt;EdgeDirection&lt;/code&gt; as &lt;code&gt;bottomRight&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;PopButton.Position&lt;/code&gt; is the possible positions of a &lt;code&gt;PopButton&lt;/code&gt; when you place it in a 3-dimensional &lt;code&gt;PopView&lt;/code&gt;, like mentioned in this image:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/72977449/175024978-ae5a6a24-6e3a-4973-9209-84fbcbc45077.png&#34; alt=&#34;Group 11479-2&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;here 1-9 are the buttons placed at different possible positions of a popView. which are :&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;em&gt;topLeft&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;topEdge&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;topRight&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;leftEdge&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;center&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;rightEdge&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;bottomLeft&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;bottomEdge&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;bottomRight&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;code&gt;PopButton.Model&lt;/code&gt; is an entity which holds the behavioural properties of a PopButton, which can help you to customise the PopButton w.r.t your requirements.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Initialising a &lt;code&gt;PopButton.Model&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let model = PopButton.Model(&#xA;    position: .bottomRight, &#xA;    backgroundColor: UIColor.gray&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above case of buttons appearing on the different edges of a &lt;code&gt;PopView&lt;/code&gt; is achieved only by changing the &lt;code&gt;PopButton.Position&lt;/code&gt; in the &lt;code&gt;PopButton.Model&lt;/code&gt;. (Please &lt;a href=&#34;https://github.com/CRED-CLUB/neopop-ios/raw/80c7c906c129d99e7bb5eadc568913d7ea351f9d/NeoPopExamples/NeoPopExamples/Example%20Controllers/AdvancedButtonsViewController.swift#L83:L133&#34;&gt;refer the sample app&lt;/a&gt; for this usage)&lt;/p&gt; &#xA;&lt;h2&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Popular Styles of &lt;code&gt;PopButton&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;ELEVATED BUTTON&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/9965653/172596228-1bcb92d0-d293-4290-ac38-b9a693a2fab2.png&#34; alt=&#34;Elevated&#34; title=&#34;Elevated Button&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/9965653/175874614-ab316981-29d1-4ed5-a90b-6fe840ac9700.gif&#34; alt=&#34;elevated&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let elevatedButton = PopButton()&#xA;let model = PopButton.Model(&#xA;    position: .bottomRight, &#xA;    backgroundColor: UIColor.white&#xA;)&#xA;elevatedButton.configurePopButton(withModel: model)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;FLAT BUTTON&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/9965653/172597180-63b4c386-9b7c-4211-a64c-a79892232481.png&#34; alt=&#34;Flat&#34; title=&#34;Flat Button&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/9965653/175874619-b5edb3e8-6c18-4f15-8e60-ef44cb004c94.gif&#34; alt=&#34;flatButton&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let flatButton = PopButton()&#xA;let model = PopButton.Model(&#xA;    position: .bottomRight, &#xA;    backgroundColor: .white, &#xA;    superViewColor: .black&#xA;)&#xA;flatButton.configurePopButton(withModel: model)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;ELEVATED STROKE BUTTON&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/9965653/172597473-630c86b9-574d-4f65-afeb-171c5ec147cc.png&#34; alt=&#34;Elevated Strokes&#34; title=&#34;Elevated Strokes&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/9965653/175874610-3e92e9e9-cbed-4906-a90b-423c615e465d.gif&#34; alt=&#34;elevatedStroked&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let elevatedStrokeButton = PopButton()&#xA;let model = PopButton.Model(&#xA;    position: .bottomRight, &#xA;    backgroundColor: .black, &#xA;    buttonFaceBorderColor: EdgeColors(color: UIColor.white), &#xA;    borderWidth: 0.31, &#xA;    edgeLength: 1.87, &#xA;    customEdgeColor: EdgeColors(&#xA;        left: nil, &#xA;        right: PopHelper.horizontalEdgeColor(for: UIColor.white), &#xA;        top: nil, &#xA;        bottom: PopHelper.verticalEdgeColor(for: UIColor.white)&#xA;    )&#xA;)&#xA;elevatedStrokeButton.configurePopButton(withModel: model)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;FLAT STROKE BUTTON&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/9965653/172597728-5830cc72-1d2a-4d52-8089-55fb61449996.png&#34; alt=&#34;Flat Strokes&#34; title=&#34;Flat Strokes&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/9965653/175874617-a90ef305-d460-4887-927c-0ddecfe45975.gif&#34; alt=&#34;flatStroked&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let flatStrokeButton = PopButton()&#xA;let model = PopButton.Model(&#xA;    position: .bottomRight, &#xA;    backgroundColor: UIColor.black, &#xA;    superViewColor: UIColor.black,&#xA;    buttonFaceBorderColor: EdgeColors(color: UIColor.white),  &#xA;    borderWidth: 0.31, &#xA;    edgeLength: 1.87, &#xA;    customEdgeColor: EdgeColors(&#xA;        left: nil, &#xA;        right: PopHelper.horizontalEdgeColor(for: UIColor.white), &#xA;        top: nil, &#xA;        bottom: PopHelper.verticalEdgeColor(for: UIColor.white)&#xA;    )&#xA;)&#xA;flatStrokeButton.configurePopButton(withModel: model)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;/h2&gt; &#xA;&lt;p&gt;For more customisations make use of the properties of &lt;code&gt;PopButton.Model&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;PopButton.Model&lt;/code&gt; initialiser arguments&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;attribute&lt;/th&gt; &#xA;   &lt;th&gt;description&lt;/th&gt; &#xA;   &lt;th&gt;value&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;direction&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Direction of the edges of the button.&lt;/td&gt; &#xA;   &lt;td&gt;EdgeDirection&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;position&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Position of the button w.r.t the super &lt;code&gt;PopView&lt;/code&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;PopButton.Position&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;backgroundColor&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;color of the button&lt;/td&gt; &#xA;   &lt;td&gt;UIColor&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;superViewColor&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;color of the neopop container color (background color of the &lt;code&gt;PopView&lt;/code&gt; which is the super view of the button)&lt;/td&gt; &#xA;   &lt;td&gt;UIColor?&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;parentContainerBGColor&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;background color of the container(background color of container view which is the super view of the &lt;code&gt;PopView&lt;/code&gt; which is holding the &lt;code&gt;PopButton&lt;/code&gt;). This will be necessary to draw the edges of the button in some positions.&lt;/td&gt; &#xA;   &lt;td&gt;UIColor?&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;buttonFaceBorderColor&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;border colors of button&#39;s content face.&lt;/td&gt; &#xA;   &lt;td&gt;EdgeColors?&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;borderColors&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;border colors of the edges of the button.&lt;/td&gt; &#xA;   &lt;td&gt;PopButton.BorderModel?&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;borderWidth&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;width of the border&lt;/td&gt; &#xA;   &lt;td&gt;CGFloat&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;adjacentButtonAvailability&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;presence of the other button close the edges the current button.&lt;/td&gt; &#xA;   &lt;td&gt;AdjacentButtonAvailability&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;customEdgeColor&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;customise the color of the edges.&lt;/td&gt; &#xA;   &lt;td&gt;EdgeColors?&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;edgeLength&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;depth of the edges.&lt;/td&gt; &#xA;   &lt;td&gt;CGFloat&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;showStaticBaseEdges&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;decides whether to draw borders at the bottom edges of the button.&lt;/td&gt; &#xA;   &lt;td&gt;Bool&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;shimmerStyle&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;shimmer configurations.&lt;/td&gt; &#xA;   &lt;td&gt;ShimmerStyle?&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;How to setup the Button content ?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The content of a &lt;code&gt;PopButton&lt;/code&gt; has a&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;an imageView on left&lt;/li&gt; &#xA; &lt;li&gt;a label&lt;/li&gt; &#xA; &lt;li&gt;an image view on right of the label&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And you can set up a &lt;code&gt;PopButton&lt;/code&gt; content through.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let contentModel = PopButtonContainerView.Model(&#xA;    attributedTitle: nil, &#xA;    leftImage: UIImage(named: &#34;arrow&#34;), &#xA;    leftImageScale: 3&#xA;)&#xA;popButton.configureButtonContent(withModel: contentModel)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;more customisations on these contents are available, for which please refer the &lt;code&gt;PopButtonContainerView&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;/h2&gt; &#xA;&lt;p&gt;We know, the content to show on a button surface differs varies with your use cases and design requirements. So, all buttons in NeoPOP framework is designed to accept a UIView confirming to the protocol &lt;code&gt;PopButtonCustomContainerDrawable&lt;/code&gt; as its contentView. That means, you can create any number of custom views w.r.t your requirements and use it on any buttons in NeoPOP framework.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;PopButtonCustomContainerDrawable&lt;/code&gt; protocol will be listening to state changes of the owner button, such that you can also update the button content view (confirming &lt;code&gt;PopButtonCustomContainerDrawable&lt;/code&gt;) w.r.t state changes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class  ContainerNew: UIView, PopButtonCustomContainerDrawable {&#xA;    public let  titleLabel: UILabel = {&#xA;        let view = UILabel()&#xA;        view.numberOfLines = 1&#xA;        view.translatesAutoresizingMaskIntoConstraints = false&#xA;        return view&#xA;    }()&#xA;&#xA;    func updateOnStateChange(state: PopButton.State) {&#xA;        //Use this space to listen to button state changes&#xA;    }&#xA;}&#xA;&#xA;let newContainer = ContainerNew()&#xA;newContainer.titleLabel.text = &#34;Continue&#34;&#xA;popButon.setCustomContainerView(container)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Non Floating&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/9965653/172599904-75d12903-f490-47d6-b8df-39adc9ef058e.png&#34; alt=&#34;Non Floating&#34; title=&#34;Non Floating&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/9965653/175874607-e8e10326-1d6d-4b7d-be8f-50cc8f37ee14.gif&#34; alt=&#34;tiltNonFloating&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let elevatedButton = PopButton()&#xA;let model = PopButton.Model(&#xA;    position: .bottom, &#xA;    backgroundColor: UIColor.white&#xA;)&#xA;elevatedButton.configurePopButton(withModel: model)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;PopFloatingButton&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;PopFloatingButton&lt;/code&gt; is a pop button with shadow, exhibiting a floating effect.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/72977449/175023303-5344bcb4-b40c-481d-862b-77a63854ba96.gif&#34; alt=&#34;floating_button_press_animation&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/sDQFjqpy/Frame-11183.png&#34; alt=&#34;enter image description here&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;use &lt;code&gt;PopFloatingButton.Model&lt;/code&gt; to configure the button parameters.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;//Create button config model.&#xA;let model = PopFloatingButton.Model(&#xA;    backgroundColor: UIColor.yellow, &#xA;    edgeWidth: 9, &#xA;    shimmerModel: PopShimmerModel(&#xA;        spacing: 10, &#xA;        lineColor1: UIColor.white, &#xA;        lineColor2: UIColor.white, &#xA;        lineWidth1: 16, &#xA;        lineWidth2: 35, &#xA;        duration: 2, &#xA;        delay: 5&#xA;    )&#xA;)&#xA;&#xA;//configure the button.&#xA;button.configureFloatingButton(withModel: model)&#xA;&#xA;//Setup custom container model&#xA;let contentModel = PopButtonContainerView.Model(attributedTitle: nil, rightImage: UIImage(named: &#34;play_now_text&#34;), rightImageScale: 4.81)&#xA;button.configureButtonContent(withModel: contentModel)&#xA;&#x9;&#xA;//Starting shimmer animation.&#xA;button.startShimmerAnimation() &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;post adding shimmer effect : &lt;img src=&#34;https://user-images.githubusercontent.com/9965653/175874574-99f209f2-2d14-458b-9f92-959e6aabf112.gif&#34; alt=&#34;shimmer&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Pull requests are welcome! We&#39;d love help improving this library. Feel free to browse through open issues to look for things that need work. If you have a feature request or bug, please open a new issue so we can track it.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright 2022 Dreamplug Technologies Private Limited&#xA;&#xA;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);&#xA;you may not use this file except in compliance with the License.&#xA;You may obtain a copy of the License at&#xA;&#xA;http://www.apache.org/licenses/LICENSE-2.0&#xA;Unless required by applicable law or agreed to in writing, software&#xA;distributed under the License is distributed on an &#34;AS IS&#34; BASIS,&#xA;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA;See the License for the specific language governing permissions and&#xA;limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>