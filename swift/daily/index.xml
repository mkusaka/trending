<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-26T01:54:41Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Clipy/Clipy</title>
    <updated>2022-07-26T01:54:41Z</updated>
    <id>tag:github.com,2022-07-26:/Clipy/Clipy</id>
    <link href="https://github.com/Clipy/Clipy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Clipboard extension app for macOS.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/Clipy/Clipy/develop/Resources/clipy_logo.png&#34; width=&#34;400&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/Clipy/Clipy/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt; &lt;a href=&#34;https://github.com/Clipy/Clipy/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/Clipy/Clipy.svg?sanitize=true&#34; alt=&#34;Release version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Clipy/Clipy/develop/#backers&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backers/badge.svg?sanitize=true&#34; alt=&#34;OpenCollective&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Clipy/Clipy/develop/#sponsors&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsors/badge.svg?sanitize=true&#34; alt=&#34;OpenCollective&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Clipy is a Clipboard extension app for macOS.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;Requirement&lt;/strong&gt;: macOS 10.10 Yosemite or higher&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Distribution Site&lt;/strong&gt; : &lt;a href=&#34;https://clipy-app.com&#34;&gt;https://clipy-app.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;http://clipy-app.com/img/screenshot1.png&#34; width=&#34;400&#34;&gt; &#xA;&lt;h3&gt;Development Environment&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;macOS 10.15 Catalina&lt;/li&gt; &#xA; &lt;li&gt;Xcode 12.2&lt;/li&gt; &#xA; &lt;li&gt;Swift 5.3&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;How to Build&lt;/h3&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;Move to the project root directory&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bundle install --path=vendor/bundle &amp;amp;&amp;amp; bundle exec pod install&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Open &lt;code&gt;Clipy.xcworkspace&lt;/code&gt; on Xcode.&lt;/li&gt; &#xA; &lt;li&gt;build.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Contributing&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork it ( &lt;a href=&#34;https://github.com/Clipy/Clipy/fork&#34;&gt;https://github.com/Clipy/Clipy/fork&lt;/a&gt; )&lt;/li&gt; &#xA; &lt;li&gt;Create your feature branch (&lt;code&gt;git checkout -b my-new-feature&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Commit your changes (&lt;code&gt;git commit -am &#39;Add some feature&#39;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Push to the branch (&lt;code&gt;git push origin my-new-feature&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Create a new Pull Request&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Localization Contributors&lt;/h3&gt; &#xA;&lt;p&gt;Clipy is looking for localization contributors.&lt;br&gt; If you can contribute, please see &lt;a href=&#34;https://github.com/Clipy/Clipy/raw/master/.github/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Distribution&lt;/h3&gt; &#xA;&lt;p&gt;If you distribute derived work, especially in the Mac App Store, I ask you to follow two rules:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Don&#39;t use &lt;code&gt;Clipy&lt;/code&gt; and &lt;code&gt;ClipMenu&lt;/code&gt; as your product name.&lt;/li&gt; &#xA; &lt;li&gt;Follow the MIT license terms.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Thank you for your cooperation.&lt;/p&gt; &#xA;&lt;h3&gt;Backers&lt;/h3&gt; &#xA;&lt;p&gt;Support us with a monthly donation and help us continue our activities. [&lt;a href=&#34;https://opencollective.com/clipy#backer&#34;&gt;Become a backer&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://opencollective.com/clipy/backer/0/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/0/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/1/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/1/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/2/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/2/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/3/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/3/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/4/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/4/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/5/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/5/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/6/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/6/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/7/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/7/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/8/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/8/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/9/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/9/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/10/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/10/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/11/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/11/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/12/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/12/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/13/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/13/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/14/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/14/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/15/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/15/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/16/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/16/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/17/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/17/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/18/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/18/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/19/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/19/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/20/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/20/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/21/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/21/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/22/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/22/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/23/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/23/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/24/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/24/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/25/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/25/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/26/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/26/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/27/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/27/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/28/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/28/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/backer/29/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/backer/29/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Sponsors&lt;/h3&gt; &#xA;&lt;p&gt;Become a sponsor and get your logo on our README on Github with a link to your site. [&lt;a href=&#34;https://opencollective.com/clipy#sponsor&#34;&gt;Become a sponsor&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://opencollective.com/clipy/sponsor/0/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/0/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/1/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/1/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/2/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/2/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/3/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/3/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/4/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/4/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/5/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/5/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/6/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/6/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/7/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/7/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/8/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/8/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/9/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/9/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/10/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/10/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/11/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/11/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/12/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/12/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/13/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/13/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/14/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/14/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/15/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/15/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/16/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/16/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/17/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/17/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/18/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/18/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/19/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/19/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/20/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/20/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/21/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/21/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/22/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/22/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/23/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/23/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/24/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/24/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/25/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/25/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/26/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/26/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/27/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/27/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/28/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/28/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/clipy/sponsor/29/website&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://opencollective.com/clipy/sponsor/29/avatar.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Licence&lt;/h3&gt; &#xA;&lt;p&gt;Clipy is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt; &#xA;&lt;p&gt;Icons are copyrighted by their respective authors.&lt;/p&gt; &#xA;&lt;h3&gt;Special Thanks&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Thank you for &lt;a href=&#34;https://github.com/naotaka&#34;&gt;@naotaka&lt;/a&gt; who have published &lt;a href=&#34;https://github.com/naotaka/ClipMenu&#34;&gt;ClipMenu&lt;/a&gt; as OSS.&lt;/strong&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>pointfreeco/combine-schedulers</title>
    <updated>2022-07-26T01:54:41Z</updated>
    <id>tag:github.com,2022-07-26:/pointfreeco/combine-schedulers</id>
    <link href="https://github.com/pointfreeco/combine-schedulers" rel="alternate"></link>
    <summary type="html">&lt;p&gt;⏰ A few schedulers that make working with Combine more testable and more versatile.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;⏰ Combine Schedulers&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pointfreeco/combine-schedulers/actions?query=workflow%3ACI&#34;&gt;&lt;img src=&#34;https://github.com/pointfreeco/combine-schedulers/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/combine-schedulers&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fcombine-schedulers%2Fbadge%3Ftype%3Dswift-versions&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/combine-schedulers&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fcombine-schedulers%2Fbadge%3Ftype%3Dplatforms&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A few schedulers that make working with Combine more testable and more versatile.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/#motivation&#34;&gt;Motivation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/#learn-more&#34;&gt;Learn more&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/#anyscheduler&#34;&gt;&lt;code&gt;AnyScheduler&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/#testscheduler&#34;&gt;&lt;code&gt;TestScheduler&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/#immediatescheduler&#34;&gt;&lt;code&gt;ImmediateScheduler&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/#animated-schedulers&#34;&gt;Animated schedulers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/#unimplementedscheduler&#34;&gt;&lt;code&gt;UnimplementedScheduler&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/#uischeduler&#34;&gt;&lt;code&gt;UIScheduler&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/#publisherstimer&#34;&gt;&lt;code&gt;Publishers.Timer&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/#documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/#other-libraries&#34;&gt;Other libraries&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;The Combine framework provides the &lt;code&gt;Scheduler&lt;/code&gt; protocol, which is a powerful abstraction for describing how and when units of work are executed. It unifies many disparate ways of executing work, such as &lt;code&gt;DispatchQueue&lt;/code&gt;, &lt;code&gt;RunLoop&lt;/code&gt; and &lt;code&gt;OperationQueue&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, the moment you use any of these schedulers in your reactive code you instantly make the publisher asynchronous and therefore much harder to test, forcing you to use expectations and waits for time to pass as your publisher executes.&lt;/p&gt; &#xA;&lt;p&gt;This library provides new schedulers that allow you to turn any asynchronous publisher into a synchronous one for ease of testing and debugging.&lt;/p&gt; &#xA;&lt;h2&gt;Learn More&lt;/h2&gt; &#xA;&lt;p&gt;This library was designed over the course of many episodes on &lt;a href=&#34;https://www.pointfree.co&#34;&gt;Point-Free&lt;/a&gt;, a video series exploring functional programming and Swift hosted by &lt;a href=&#34;https://github.com/mbrandonw&#34;&gt;Brandon Williams&lt;/a&gt; and &lt;a href=&#34;https://github.com/stephencelis&#34;&gt;Stephen Celis&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can watch all of the episodes &lt;a href=&#34;https://www.pointfree.co/collections/combine/schedulers&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;a href=&#34;https://www.pointfree.co/collections/combine/schedulers&#34;&gt; &lt;img alt=&#34;video poster image&#34; src=&#34;https://d3rccdn33rt8ze.cloudfront.net/episodes/0106.jpeg&#34; width=&#34;480&#34;&gt; &lt;/a&gt; &#xA;&lt;h3&gt;&lt;code&gt;AnyScheduler&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;AnyScheduler&lt;/code&gt; provides a type-erasing wrapper for the &lt;code&gt;Scheduler&lt;/code&gt; protocol, which can be useful for being generic over many types of schedulers without needing to actually introduce a generic to your code. The Combine framework ships with many type-erasing wrappers, such as &lt;code&gt;AnySubscriber&lt;/code&gt;, &lt;code&gt;AnyPublisher&lt;/code&gt; and &lt;code&gt;AnyCancellable&lt;/code&gt;, yet for some reason does not ship with &lt;code&gt;AnyScheduler&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This type is useful for times that you want to be able to customize the scheduler used in some code from the outside, but you don&#39;t want to introduce a generic to make it customizable. For example, suppose you have an &lt;code&gt;ObservableObject&lt;/code&gt; view model that performs an API request when a method is called:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class EpisodeViewModel: ObservableObject {&#xA;  @Published var episode: Episode?&#xA;&#xA;  let apiClient: ApiClient&#xA;&#xA;  init(apiClient: ApiClient) {&#xA;    self.apiClient = apiClient&#xA;  }&#xA;&#xA;  func reloadButtonTapped() {&#xA;    self.apiClient.fetchEpisode()&#xA;      .receive(on: DispatchQueue.main)&#xA;      .assign(to: &amp;amp;self.$episode)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that we are using &lt;code&gt;DispatchQueue.main&lt;/code&gt; in the &lt;code&gt;reloadButtonTapped&lt;/code&gt; method because the &lt;code&gt;fetchEpisode&lt;/code&gt; endpoint most likely delivers its output on a background thread (as is the case with &lt;code&gt;URLSession&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;This code seems innocent enough, but the presence of &lt;code&gt;.receive(on: DispatchQueue.main)&lt;/code&gt; makes this code harder to test since you have to use &lt;code&gt;XCTest&lt;/code&gt; expectations to explicitly wait a small amount of time for the queue to execute. This can lead to flakiness in tests and make test suites take longer to execute than necessary.&lt;/p&gt; &#xA;&lt;p&gt;One way to fix this testing problem is to use an &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/#immediatescheduler&#34;&gt;&#34;immediate&#34; scheduler&lt;/a&gt; instead of &lt;code&gt;DispatchQueue.main&lt;/code&gt;, which will cause &lt;code&gt;fetchEpisode&lt;/code&gt; to deliver its output as soon as possible with no thread hops. In order to allow for this we would need to inject a scheduler into our view model so that we can control it from the outside:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class EpisodeViewModel&amp;lt;S: Scheduler&amp;gt;: ObservableObject {&#xA;  @Published var episode: Episode?&#xA;&#xA;  let apiClient: ApiClient&#xA;  let scheduler: S&#xA;&#xA;  init(apiClient: ApiClient, scheduler: S) {&#xA;    self.apiClient = apiClient&#xA;    self.scheduler = scheduler&#xA;  }&#xA;&#xA;  func reloadButtonTapped() {&#xA;    self.apiClient.fetchEpisode()&#xA;      .receive(on: self.scheduler)&#xA;      .assign(to: &amp;amp;self.$episode)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we can initialize this view model in production by using &lt;code&gt;DispatchQueue.main&lt;/code&gt; and we can initialize it in tests using &lt;code&gt;DispatchQueue.immediate&lt;/code&gt;. Sounds like a win!&lt;/p&gt; &#xA;&lt;p&gt;However, introducing this generic to our view model is quite heavyweight as it is loudly announcing to the outside world that this type uses a scheduler, and worse it will end up infecting any code that touches this view model that also wants to be testable. For example, any view that uses this view model will need to introduce a generic if it wants to also be able to control the scheduler, which would be useful if we wanted to write &lt;a href=&#34;https://github.com/pointfreeco/swift-snapshot-testing&#34;&gt;snapshot tests&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Instead of introducing a generic to allow for substituting in different schedulers we can use &lt;code&gt;AnyScheduler&lt;/code&gt;. It allows us to be somewhat generic in the scheduler, but without actually introducing a generic.&lt;/p&gt; &#xA;&lt;p&gt;Instead of holding a generic scheduler in our view model we can say that we only want a scheduler whose associated types match that of &lt;code&gt;DispatchQueue&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class EpisodeViewModel: ObservableObject {&#xA;  @Published var episode: Episode?&#xA;&#xA;  let apiClient: ApiClient&#xA;  let scheduler: AnySchedulerOf&amp;lt;DispatchQueue&amp;gt;&#xA;&#xA;  init(apiClient: ApiClient, scheduler: AnySchedulerOf&amp;lt;DispatchQueue&amp;gt;) {&#xA;    self.apiClient = apiClient&#xA;    self.scheduler = scheduler&#xA;  }&#xA;&#xA;  func reloadButtonTapped() {&#xA;    self.apiClient.fetchEpisode()&#xA;      .receive(on: self.scheduler)&#xA;      .assign(to: &amp;amp;self.$episode)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, in production we can create a view model that uses a live &lt;code&gt;DispatchQueue&lt;/code&gt;, but we just have to first erase its type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let viewModel = EpisodeViewModel(&#xA;  apiClient: ...,&#xA;  scheduler: DispatchQueue.main.eraseToAnyScheduler()&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For common schedulers, like &lt;code&gt;DispatchQueue&lt;/code&gt;, &lt;code&gt;OperationQueue&lt;/code&gt;, and &lt;code&gt;RunLoop&lt;/code&gt;, there is even a static helper on &lt;code&gt;AnyScheduler&lt;/code&gt; that further simplifys this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let viewModel = EpisodeViewModel(&#xA;  apiClient: ...,&#xA;  scheduler: .main&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then in tests we can use an immediate scheduler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let viewModel = EpisodeViewModel(&#xA;  apiClient: ...,&#xA;  scheduler: .immediate&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So, in general, &lt;code&gt;AnyScheduler&lt;/code&gt; is great for allowing one to control what scheduler is used in classes, functions, etc. without needing to introduce a generic, which can help simplify the code and reduce implementation details from leaking out.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;TestScheduler&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A scheduler whose current time and execution can be controlled in a deterministic manner. This scheduler is useful for testing how the flow of time effects publishers that use asynchronous operators, such as &lt;code&gt;debounce&lt;/code&gt;, &lt;code&gt;throttle&lt;/code&gt;, &lt;code&gt;delay&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt;, &lt;code&gt;receive(on:)&lt;/code&gt;, &lt;code&gt;subscribe(on:)&lt;/code&gt; and more.&lt;/p&gt; &#xA;&lt;p&gt;For example, consider the following &lt;code&gt;race&lt;/code&gt; operator that runs two futures in parallel, but only emits the first one that completes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func race&amp;lt;Output, Failure: Error&amp;gt;(&#xA;  _ first: Future&amp;lt;Output, Failure&amp;gt;,&#xA;  _ second: Future&amp;lt;Output, Failure&amp;gt;&#xA;) -&amp;gt; AnyPublisher&amp;lt;Output, Failure&amp;gt; {&#xA;  first&#xA;    .merge(with: second)&#xA;    .prefix(1)&#xA;    .eraseToAnyPublisher()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Although this publisher is quite simple we may still want to write some tests for it.&lt;/p&gt; &#xA;&lt;p&gt;To do this we can create a test scheduler and create two futures, one that emits after a second and one that emits after two seconds:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let scheduler = DispatchQueue.test&#xA;&#xA;let first = Future&amp;lt;Int, Never&amp;gt; { callback in&#xA;  scheduler.schedule(after: scheduler.now.advanced(by: 1)) { callback(.success(1)) }&#xA;}&#xA;let second = Future&amp;lt;Int, Never&amp;gt; { callback in&#xA;  scheduler.schedule(after: scheduler.now.advanced(by: 2)) { callback(.success(2)) }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then we can race these futures and collect their emissions into an array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var output: [Int] = []&#xA;let cancellable = race(first, second).sink { output.append($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then we can deterministically move time forward in the scheduler to see how the publisher emits. We can start by moving time forward by one second:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;scheduler.advance(by: 1)&#xA;XCTAssertEqual(output, [1])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This proves that we get the first emission from the publisher since one second of time has passed. If we further advance by one more second we can prove that we do not get anymore emissions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;scheduler.advance(by: 1)&#xA;XCTAssertEqual(output, [1])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is a very simple example of how to control the flow of time with the test scheduler, but this technique can be used to test any publisher that involves Combine&#39;s asynchronous operations.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;ImmediateScheduler&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The Combine framework comes with an &lt;code&gt;ImmediateScheduler&lt;/code&gt; type of its own, but it defines all new types for the associated types of &lt;code&gt;SchedulerTimeType&lt;/code&gt; and &lt;code&gt;SchedulerOptions&lt;/code&gt;. This means you cannot easily swap between a live &lt;code&gt;DispatchQueue&lt;/code&gt; and an &#34;immediate&#34; &lt;code&gt;DispatchQueue&lt;/code&gt; that executes work synchronously. The only way to do that would be to introduce generics to any code making use of that scheduler, which can become unwieldy.&lt;/p&gt; &#xA;&lt;p&gt;So, instead, this library&#39;s &lt;code&gt;ImmediateScheduler&lt;/code&gt; uses the same associated types as an existing scheduler, which means you can use &lt;code&gt;DispatchQueue.immediate&lt;/code&gt; to have a scheduler that looks like a dispatch queue but executes its work immediately. Similarly you can construct &lt;code&gt;RunLoop.immediate&lt;/code&gt; and &lt;code&gt;OperationQueue.immediate&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This scheduler is useful for writing tests against publishers that use asynchrony operators, such as &lt;code&gt;receive(on:)&lt;/code&gt;, &lt;code&gt;subscribe(on:)&lt;/code&gt; and others, because it forces the publisher to emit immediately rather than needing to wait for thread hops or delays using &lt;code&gt;XCTestExpectation&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This scheduler is different from &lt;code&gt;TestScheduler&lt;/code&gt; in that you cannot explicitly control how time flows through your publisher, but rather you are instantly collapsing time into a single point.&lt;/p&gt; &#xA;&lt;p&gt;As a basic example, suppose you have a view model that loads some data after waiting for 10 seconds from when a button is tapped:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class HomeViewModel: ObservableObject {&#xA;  @Published var episodes: [Episode]?&#xA;&#xA;  let apiClient: ApiClient&#xA;&#xA;  init(apiClient: ApiClient) {&#xA;    self.apiClient = apiClient&#xA;  }&#xA;&#xA;  func reloadButtonTapped() {&#xA;    Just(())&#xA;      .delay(for: .seconds(10), scheduler: DispatchQueue.main)&#xA;      .flatMap { apiClient.fetchEpisodes() }&#xA;      .assign(to: &amp;amp;self.$episodes)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to test this code you would literally need to wait 10 seconds for the publisher to emit:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func testViewModel() {&#xA;  let viewModel = HomeViewModel(apiClient: .mock)&#xA;&#xA;  viewModel.reloadButtonTapped()&#xA;&#xA;  _ = XCTWaiter.wait(for: [XCTestExpectation()], timeout: 10)&#xA;&#xA;  XCTAssert(viewModel.episodes, [Episode(id: 42)])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, we can explicitly pass a scheduler into the view model initializer so that it can be controller from the outside:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class HomeViewModel: ObservableObject {&#xA;  @Published var episodes: [Episode]?&#xA;&#xA;  let apiClient: ApiClient&#xA;  let scheduler: AnySchedulerOf&amp;lt;DispatchQueue&amp;gt;&#xA;&#xA;  init(apiClient: ApiClient, scheduler: AnySchedulerOf&amp;lt;DispatchQueue&amp;gt;) {&#xA;    self.apiClient = apiClient&#xA;    self.scheduler = scheduler&#xA;  }&#xA;&#xA;  func reloadButtonTapped() {&#xA;    Just(())&#xA;      .delay(for: .seconds(10), scheduler: self.scheduler)&#xA;      .flatMap { self.apiClient.fetchEpisodes() }&#xA;      .assign(to: &amp;amp;self.$episodes)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then in tests use an immediate scheduler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func testViewModel() {&#xA;  let viewModel = HomeViewModel(&#xA;    apiClient: .mock,&#xA;    scheduler: .immediate&#xA;  )&#xA;&#xA;  viewModel.reloadButtonTapped()&#xA;&#xA;  // No more waiting...&#xA;&#xA;  XCTAssert(viewModel.episodes, [Episode(id: 42)])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Animated schedulers&lt;/h3&gt; &#xA;&lt;p&gt;CombineSchedulers comes with helpers that aid in asynchronous animations in both SwiftUI and UIKit.&lt;/p&gt; &#xA;&lt;p&gt;If a SwiftUI state mutation should be animated, you can invoke the &lt;code&gt;animation&lt;/code&gt; and &lt;code&gt;transaction&lt;/code&gt; methods to transform an existing scheduler into one that schedules its actions with an animation or in a transaction. These APIs mirror SwiftUI&#39;s &lt;code&gt;withAnimation&lt;/code&gt; and &lt;code&gt;withTransaction&lt;/code&gt; functions, which are invoked by the animated scheduler.&lt;/p&gt; &#xA;&lt;p&gt;For example, to animate an API response in your view model, you can specify that the scheduler that receives this state should be animated:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;self.apiClient.fetchEpisode()&#xA;  .receive(on: self.scheduler.animation())&#xA;  .assign(to: &amp;amp;self.$episode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are powering a UIKit feature with Combine, you can use the &lt;code&gt;.animate&lt;/code&gt; method, which mirrors &lt;code&gt;UIView.animate&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;self.apiClient.fetchEpisode()&#xA;  .receive(on: self.scheduler.animate(withDuration: 0.3))&#xA;  .assign(to: &amp;amp;self.$episode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;UnimplementedScheduler&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A scheduler that causes a test to fail if it is used.&lt;/p&gt; &#xA;&lt;p&gt;This scheduler can provide an additional layer of certainty that a tested code path does not require the use of a scheduler.&lt;/p&gt; &#xA;&lt;p&gt;As a view model becomes more complex, only some of its logic may require a scheduler. When writing unit tests for any logic that does &lt;em&gt;not&lt;/em&gt; require a scheduler, one should provide an unimplemented scheduler, instead. This documents, directly in the test, that the feature does not use a scheduler. If it did, or ever does in the future, the test will fail.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following view model has a couple responsibilities:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class EpisodeViewModel: ObservableObject {&#xA;  @Published var episode: Episode?&#xA;&#xA;  let apiClient: ApiClient&#xA;  let mainQueue: AnySchedulerOf&amp;lt;DispatchQueue&amp;gt;&#xA;&#xA;  init(apiClient: ApiClient, mainQueue: AnySchedulerOf&amp;lt;DispatchQueue&amp;gt;) {&#xA;    self.apiClient = apiClient&#xA;    self.mainQueue = mainQueue&#xA;  }&#xA;&#xA;  func reloadButtonTapped() {&#xA;    self.apiClient.fetchEpisode()&#xA;      .receive(on: self.mainQueue)&#xA;      .assign(to: &amp;amp;self.$episode)&#xA;  }&#xA;&#xA;  func favoriteButtonTapped() {&#xA;    self.episode?.isFavorite.toggle()&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It lets the user tap a button to refresh some episode data&lt;/li&gt; &#xA; &lt;li&gt;It lets the user toggle if the episode is one of their favorites&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The API client delivers the episode on a background queue, so the view model must receive it on its main queue before mutating its state.&lt;/p&gt; &#xA;&lt;p&gt;Tapping the favorite button, however, involves no scheduling. This means that a test can be written with an unimplemented scheduler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func testFavoriteButton() {&#xA;  let viewModel = EpisodeViewModel(&#xA;    apiClient: .mock,&#xA;    mainQueue: .unimplemented&#xA;  )&#xA;  viewModel.episode = .mock&#xA;&#xA;  viewModel.favoriteButtonTapped()&#xA;  XCTAssert(viewModel.episode?.isFavorite == true)&#xA;&#xA;  viewModel.favoriteButtonTapped()&#xA;  XCTAssert(viewModel.episode?.isFavorite == false)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With &lt;code&gt;.unimplemented&lt;/code&gt;, this test strongly declares that favoriting an episode does not need a scheduler to do the job, which means it is reasonable to assume that the feature is simple and does not involve any asynchrony.&lt;/p&gt; &#xA;&lt;p&gt;In the future, should favoriting an episode fire off an API request that involves a scheduler, this test will begin to fail, which is a good thing! This will force us to address the complexity that was introduced. Had we used any other scheduler, it would quietly receive this additional work and the test would continue to pass.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;UIScheduler&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A scheduler that executes its work on the main queue as soon as possible. This scheduler is inspired by the &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveSwift/raw/58d92aa01081301549c48a4049e215210f650d07/Sources/Scheduler.swift#L92&#34;&gt;equivalent&lt;/a&gt; scheduler in the &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveSwift&#34;&gt;ReactiveSwift&lt;/a&gt; project.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;UIScheduler.shared.schedule&lt;/code&gt; is invoked from the main thread then the unit of work will be performed immediately. This is in contrast to &lt;code&gt;DispatchQueue.main.schedule&lt;/code&gt;, which will incur a thread hop before executing since it uses &lt;code&gt;DispatchQueue.main.async&lt;/code&gt; under the hood.&lt;/p&gt; &#xA;&lt;p&gt;This scheduler can be useful for situations where you need work executed as quickly as possible on the main thread, and for which a thread hop would be problematic, such as when performing animations.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;Publishers.Timer&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A publisher that emits a scheduler&#39;s current time on a repeating interval.&lt;/p&gt; &#xA;&lt;p&gt;This publisher is an alternative to Foundation&#39;s &lt;code&gt;Timer.publisher&lt;/code&gt;, with its primary difference being that it allows you to use any scheduler for the timer, not just &lt;code&gt;RunLoop&lt;/code&gt;. This is useful because the &lt;code&gt;RunLoop&lt;/code&gt; scheduler is not testable in the sense that if you want to write tests against a publisher that makes use of &lt;code&gt;Timer.publisher&lt;/code&gt; you must explicitly wait for time to pass in order to get emissions. This is likely to lead to fragile tests and greatly bloat the time your tests take to execute.&lt;/p&gt; &#xA;&lt;p&gt;It can be used much like Foundation&#39;s timer, except you specify a scheduler rather than a run loop:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Publishers.Timer(every: .seconds(1), scheduler: DispatchQueue.main)&#xA;  .autoconnect()&#xA;  .sink { print(&#34;Timer&#34;, $0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively you can call the &lt;code&gt;timerPublisher&lt;/code&gt; method on a scheduler in order to derive a repeating timer on that scheduler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;DispatchQueue.main.timerPublisher(every: .seconds(1))&#xA;  .autoconnect()&#xA;  .sink { print(&#34;Timer&#34;, $0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But the best part of this timer is that you can use it with &lt;code&gt;TestScheduler&lt;/code&gt; so that any Combine code you write involving timers becomes more testable. This shows how we can easily simulate the idea of moving time forward 1,000 seconds in a timer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let scheduler = DispatchQueue.test&#xA;var output: [Int] = []&#xA;&#xA;Publishers.Timer(every: 1, scheduler: scheduler)&#xA;  .autoconnect()&#xA;  .sink { _ in output.append(output.count) }&#xA;  .store(in: &amp;amp;self.cancellables)&#xA;&#xA;XCTAssertEqual(output, [])&#xA;&#xA;scheduler.advance(by: 1)&#xA;XCTAssertEqual(output, [0])&#xA;&#xA;scheduler.advance(by: 1)&#xA;XCTAssertEqual(output, [0, 1])&#xA;&#xA;scheduler.advance(by: 1_000)&#xA;XCTAssertEqual(output, Array(0...1_001))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;This library is compatible with iOS 13.2 and higher. Please note that there are bugs in the Combine framework and iOS 13.1 and lower that will cause crashes when trying to compare &lt;code&gt;DispatchQueue.SchedulerTimeType&lt;/code&gt; values, which is an operation that the &lt;code&gt;TestScheduler&lt;/code&gt; depends on.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can add CombineSchedulers to an Xcode project by adding it as a package dependency.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;From the &lt;strong&gt;File&lt;/strong&gt; menu, select &lt;strong&gt;Swift Packages › Add Package Dependency…&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Enter &#34;&lt;a href=&#34;https://github.com/pointfreeco/combine-schedulers&#34;&gt;https://github.com/pointfreeco/combine-schedulers&lt;/a&gt;&#34; into the package repository URL text field&lt;/li&gt; &#xA; &lt;li&gt;Depending on how your project is structured: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If you have a single application target that needs access to the library, then add &lt;strong&gt;CombineSchedulers&lt;/strong&gt; directly to your application.&lt;/li&gt; &#xA;   &lt;li&gt;If you want to use this library from multiple targets you must create a shared framework that depends on &lt;strong&gt;CombineSchedulers&lt;/strong&gt;, and then depend on that framework from your other targets.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The latest documentation for Combine Schedulers&#39; APIs is available &lt;a href=&#34;https://pointfreeco.github.io/combine-schedulers/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Other Libraries&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tcldr/Entwine&#34;&gt;Entwine&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is released under the MIT license. See &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/combine-schedulers/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
</feed>