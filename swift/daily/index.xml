<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-22T01:55:40Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>icanzilb/DoNilDisturbPlugin</title>
    <updated>2022-06-22T01:55:40Z</updated>
    <id>tag:github.com,2022-06-22:/icanzilb/DoNilDisturbPlugin</id>
    <link href="https://github.com/icanzilb/DoNilDisturbPlugin" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A plugin for your Xcode project that stops you from working outside work hours&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DoNilDisturb Swift Plugin&lt;/h1&gt; &#xA;&lt;p&gt;Use Xcode 14+ to make use of this amazing and novel Swift plugin in your package.&lt;/p&gt; &#xA;&lt;p&gt;The plugin stops you from working on your 9-5 project outside of 9-5 hours:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/icanzilb/DoNilDisturbPlugin/main/etc/dnd.png&#34; alt=&#34;Project failing to compile with a message that do not disturb is on&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Add this to your dependencies in your Package.swift:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.package(url: &#34;https://github.com/icanzilb/DoNilDisturbPlugin.git&#34;, from: &#34;0.0.2&#34;),&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;And then&lt;/strong&gt;, add the plugin in your target definition(still in Package.swift:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.target(&#xA;  name: &#34;MyTarget&#34;,&#xA;  plugins: [&#xA;    .plugin(name: &#34;DoNilDisturbPlugin&#34;, package: &#34;DoNilDisturbPlugin&#34;)&#xA;  ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s all. Your target will fail to build outside of working hours.&lt;/p&gt; &#xA;&lt;p&gt;Enjoy your time off work.&lt;/p&gt; &#xA;&lt;h2&gt;Public Holidays support&lt;/h2&gt; &#xA;&lt;p&gt;Grab an &lt;strong&gt;.ics&lt;/strong&gt; file containing the public holidays for your locality. For example, grab this one for Spanish holidays: &lt;a href=&#34;https://www.officeholidays.com/ics-clean/spain&#34;&gt;https://www.officeholidays.com/ics-clean/spain&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Save the calendar file under your project&#39;s root directory in a sub-directory called &lt;code&gt;.config/DoNilDisturb&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The plugin will now respect your holidays:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/icanzilb/DoNilDisturbPlugin/main/etc/holidays.png&#34; alt=&#34;Error message in Xcode failing to build because it&#39;s a public holiday&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT, of course.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Itaybre/CameraController</title>
    <updated>2022-06-22T01:55:40Z</updated>
    <id>tag:github.com,2022-06-22:/Itaybre/CameraController</id>
    <link href="https://github.com/Itaybre/CameraController" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸ“· Control USB Cameras from an app&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt; CameraController &lt;/h1&gt; &#xA;&lt;!-- subtext --&gt; &#xA;&lt;div align=&#34;center&#34;&gt;&#xA;  Control your cameras settings without using the software provided (or not) by the company. &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;!-- shields --&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;!-- downloads --&gt; &#xA; &lt;a href=&#34;https://github.com/itaybre/CameraController/releases&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/downloads/itaybre/CameraController/total&#34; alt=&#34;downloads&#34;&gt; &lt;/a&gt; &#xA; &lt;!-- version --&gt; &#xA; &lt;a href=&#34;https://github.com/itaybre/CameraController/releases/latest&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/release/itaybre/CameraController.svg?sanitize=true&#34; alt=&#34;latest version&#34;&gt; &lt;/a&gt; &#xA; &lt;!-- license --&gt; &#xA; &lt;a href=&#34;https://github.com/itaybre/CameraController/raw/master/License.txt&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/license/itaybre/CameraController.svg?sanitize=true&#34; alt=&#34;license&#34;&gt; &lt;/a&gt; &#xA; &lt;!-- platform --&gt; &#xA; &lt;a href=&#34;https://github.com/itaybre/CameraController&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/platform-macOS-lightgrey.svg?sanitize=true&#34; alt=&#34;platform&#34;&gt; &lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/Itaybre/CameraController/master/.github/Basic.png&#34; width=&#34;299&#34; alt=&#34;basic screenshot&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/Itaybre/CameraController/master/.github/Advanced.png&#34; width=&#34;299&#34; alt=&#34;advanced screenshot&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/Itaybre/CameraController/master/.github/Preferences.png&#34; width=&#34;299&#34; alt=&#34;preferences screenshot&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Manually&lt;/h3&gt; &#xA;&lt;p&gt;Download the latest &lt;code&gt;.zip&lt;/code&gt; from &lt;a href=&#34;https://github.com/itaybre/CameraController/releases/latest&#34;&gt;Releases&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Homebrew&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;brew tap homebrew/cask-drivers&#xA;brew install --cask cameracontroller&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;ToDo&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add MenuBar for easily configure camera&lt;/li&gt; &#xA; &lt;li&gt;Apply latest settings on startup&lt;/li&gt; &#xA; &lt;li&gt;Add more Unit Tests&lt;/li&gt; &#xA; &lt;li&gt;Support for some vendor specific capabilities (like Logitech LED control)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to help&lt;/h2&gt; &#xA;&lt;p&gt;Open &lt;a href=&#34;https://github.com/itaybre/CameraController/issues&#34;&gt;issues&lt;/a&gt; if you have a question, an enhancement to suggest or a bug you&#39;ve found. If you want you can fork the code yourself and submit a pull request to improve the app.&lt;/p&gt; &#xA;&lt;h2&gt;How to build&lt;/h2&gt; &#xA;&lt;h3&gt;Required&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Xcode&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/realm/SwiftLint&#34;&gt;Swiftlint&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Clone the project&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git clone https://github.com/itaybre/CameraController.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;re all set ! Now open the &lt;code&gt;CameraController.xcodeproj&lt;/code&gt; with Xcode&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Does it work with Apple&#39;s Facetime Camera?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In old machines it will work, but new machines (wth T1 and T2 chip) require a special entitlement only available to Apple.&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;macOS Catalina (&lt;code&gt;10.15&lt;/code&gt;) and up.&lt;/li&gt; &#xA; &lt;li&gt;Works with cameras controllable via &lt;a href=&#34;https://www.usb.org/document-library/video-class-v15-document-set&#34;&gt;UVC&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/itaybre&#34;&gt;@itaybre&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Icons by &lt;a href=&#34;https://github.com/herrerajeff&#34;&gt;@herrerajeff&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>Quick/Nimble</title>
    <updated>2022-06-22T01:55:40Z</updated>
    <id>tag:github.com,2022-06-22:/Quick/Nimble</id>
    <link href="https://github.com/Quick/Nimble" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Matcher Framework for Swift and Objective-C&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Nimble&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Quick/Nimble/actions/workflows/ci-xcode.yml&#34;&gt;&lt;img src=&#34;https://github.com/Quick/Nimble/actions/workflows/ci-xcode.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/Nimble&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/Nimble.svg?sanitize=true&#34; alt=&#34;CocoaPods&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/Nimble&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/Nimble.svg?sanitize=true&#34; alt=&#34;Platforms&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Use Nimble to express the expected outcomes of Swift or Objective-C expressions. Inspired by &lt;a href=&#34;https://github.com/pivotal/cedar&#34;&gt;Cedar&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;expect(1 + 1).to(equal(2))&#xA;expect(1.2).to(beCloseTo(1.1, within: 0.1))&#xA;expect(3) &amp;gt; 2&#xA;expect(&#34;seahorse&#34;).to(contain(&#34;sea&#34;))&#xA;expect([&#34;Atlantic&#34;, &#34;Pacific&#34;]).toNot(contain(&#34;Mississippi&#34;))&#xA;expect(ocean.isClean).toEventually(beTruthy())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;How to Use Nimble&lt;/h1&gt; &#xA;&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt; &lt;em&gt;generated with &lt;a href=&#34;https://github.com/thlorenz/doctoc&#34;&gt;DocToc&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#some-background-expressing-outcomes-using-assertions-in-xctest&#34;&gt;Some Background: Expressing Outcomes Using Assertions in XCTest&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#nimble-expectations-using-expectto&#34;&gt;Nimble: Expectations Using &lt;code&gt;expect(...).to&lt;/code&gt;&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#custom-failure-messages&#34;&gt;Custom Failure Messages&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#type-safety&#34;&gt;Type Safety&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#operator-overloads&#34;&gt;Operator Overloads&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#lazily-computed-values&#34;&gt;Lazily Computed Values&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#c-primitives&#34;&gt;C Primitives&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#asynchronous-expectations&#34;&gt;Asynchronous Expectations&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#objective-c-support&#34;&gt;Objective-C Support&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#disabling-objective-c-shorthand&#34;&gt;Disabling Objective-C Shorthand&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#built-in-matcher-functions&#34;&gt;Built-in Matcher Functions&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#type-checking&#34;&gt;Type Checking&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#equivalence&#34;&gt;Equivalence&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#identity&#34;&gt;Identity&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#comparisons&#34;&gt;Comparisons&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#typesclasses&#34;&gt;Types/Classes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#truthiness&#34;&gt;Truthiness&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#swift-assertions&#34;&gt;Swift Assertions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#swift-error-handling&#34;&gt;Swift Error Handling&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#exceptions&#34;&gt;Exceptions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#collection-membership&#34;&gt;Collection Membership&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#strings&#34;&gt;Strings&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#collection-elements&#34;&gt;Collection Elements&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#collection-count&#34;&gt;Collection Count&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#notifications&#34;&gt;Notifications&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#result&#34;&gt;Result&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#matching-a-value-to-any-of-a-group-of-matchers&#34;&gt;Matching a value to any of a group of matchers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#custom-validation&#34;&gt;Custom Validation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#writing-your-own-matchers&#34;&gt;Writing Your Own Matchers&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#predicateresult&#34;&gt;PredicateResult&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#lazy-evaluation&#34;&gt;Lazy Evaluation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#type-checking-via-swift-generics&#34;&gt;Type Checking via Swift Generics&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#customizing-failure-messages&#34;&gt;Customizing Failure Messages&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#basic-customization&#34;&gt;Basic Customization&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#full-customization&#34;&gt;Full Customization&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#supporting-objective-c&#34;&gt;Supporting Objective-C&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#properly-handling-nil-in-objective-c-matchers&#34;&gt;Properly Handling &lt;code&gt;nil&lt;/code&gt; in Objective-C Matchers&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#migrating-from-the-old-matcher-api&#34;&gt;Migrating from the Old Matcher API&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#installing-nimble&#34;&gt;Installing Nimble&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#installing-nimble-as-a-submodule&#34;&gt;Installing Nimble as a Submodule&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#installing-nimble-via-cocoapods&#34;&gt;Installing Nimble via CocoaPods&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Quick/Nimble/main/#using-nimble-without-xctest&#34;&gt;Using Nimble without XCTest&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;h1&gt;Some Background: Expressing Outcomes Using Assertions in XCTest&lt;/h1&gt; &#xA;&lt;p&gt;Apple&#39;s Xcode includes the XCTest framework, which provides assertion macros to test whether code behaves properly. For example, to assert that &lt;code&gt;1 + 1 = 2&lt;/code&gt;, XCTest has you write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;XCTAssertEqual(1 + 1, 2, &#34;expected one plus one to equal two&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, in Objective-C:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;XCTAssertEqual(1 + 1, 2, @&#34;expected one plus one to equal two&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;XCTest assertions have a couple of drawbacks:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Not enough macros.&lt;/strong&gt; There&#39;s no easy way to assert that a string contains a particular substring, or that a number is less than or equal to another.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;It&#39;s hard to write asynchronous tests.&lt;/strong&gt; XCTest forces you to write a lot of boilerplate code.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Nimble addresses these concerns.&lt;/p&gt; &#xA;&lt;h1&gt;Nimble: Expectations Using &lt;code&gt;expect(...).to&lt;/code&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Nimble allows you to express expectations using a natural, easily understood language:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;import Nimble&#xA;&#xA;expect(seagull.squawk).to(equal(&#34;Squee!&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;@import Nimble;&#xA;&#xA;expect(seagull.squawk).to(equal(@&#34;Squee!&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;expect&lt;/code&gt; function autocompletes to include &lt;code&gt;file:&lt;/code&gt; and &lt;code&gt;line:&lt;/code&gt;, but these parameters are optional. Use the default values to have Xcode highlight the correct line when an expectation is not met.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To perform the opposite expectation--to assert something is &lt;em&gt;not&lt;/em&gt; equal--use &lt;code&gt;toNot&lt;/code&gt; or &lt;code&gt;notTo&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;import Nimble&#xA;&#xA;expect(seagull.squawk).toNot(equal(&#34;Oh, hello there!&#34;))&#xA;expect(seagull.squawk).notTo(equal(&#34;Oh, hello there!&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;@import Nimble;&#xA;&#xA;expect(seagull.squawk).toNot(equal(@&#34;Oh, hello there!&#34;));&#xA;expect(seagull.squawk).notTo(equal(@&#34;Oh, hello there!&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom Failure Messages&lt;/h2&gt; &#xA;&lt;p&gt;Would you like to add more information to the test&#39;s failure messages? Use the &lt;code&gt;description&lt;/code&gt; optional argument to add your own text:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(1 + 1).to(equal(3))&#xA;// failed - expected to equal &amp;lt;3&amp;gt;, got &amp;lt;2&amp;gt;&#xA;&#xA;expect(1 + 1).to(equal(3), description: &#34;Make sure libKindergartenMath is loaded&#34;)&#xA;// failed - Make sure libKindergartenMath is loaded&#xA;// expected to equal &amp;lt;3&amp;gt;, got &amp;lt;2&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or the *WithDescription version in Objective-C:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;@import Nimble;&#xA;&#xA;expect(@(1+1)).to(equal(@3));&#xA;// failed - expected to equal &amp;lt;3.0000&amp;gt;, got &amp;lt;2.0000&amp;gt;&#xA;&#xA;expect(@(1+1)).toWithDescription(equal(@3), @&#34;Make sure libKindergartenMath is loaded&#34;);&#xA;// failed - Make sure libKindergartenMath is loaded&#xA;// expected to equal &amp;lt;3.0000&amp;gt;, got &amp;lt;2.0000&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Type Safety&lt;/h2&gt; &#xA;&lt;p&gt;Nimble makes sure you don&#39;t compare two types that don&#39;t match:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Does not compile:&#xA;expect(1 + 1).to(equal(&#34;Squee!&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Nimble uses generics--only available in Swift--to ensure type correctness. That means type checking is not available when using Nimble in Objective-C. &lt;span&gt;ðŸ˜­&lt;/span&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Operator Overloads&lt;/h2&gt; &#xA;&lt;p&gt;Tired of so much typing? With Nimble, you can use overloaded operators like &lt;code&gt;==&lt;/code&gt; for equivalence, or &lt;code&gt;&amp;gt;&lt;/code&gt; for comparisons:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if squawk does not equal &#34;Hi!&#34;:&#xA;expect(seagull.squawk) != &#34;Hi!&#34;&#xA;&#xA;// Passes if 10 is greater than 2:&#xA;expect(10) &amp;gt; 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Operator overloads are only available in Swift, so you won&#39;t be able to use this syntax in Objective-C. &lt;span&gt;ðŸ’”&lt;/span&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Lazily Computed Values&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;expect&lt;/code&gt; function doesn&#39;t evaluate the value it&#39;s given until it&#39;s time to match. So Nimble can test whether an expression raises an exception once evaluated:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Note: Swift currently doesn&#39;t have exceptions.&#xA;//       Only Objective-C code can raise exceptions&#xA;//       that Nimble will catch.&#xA;//       (see https://github.com/Quick/Nimble/issues/220#issuecomment-172667064)&#xA;let exception = NSException(&#xA;    name: NSInternalInconsistencyException,&#xA;    reason: &#34;Not enough fish in the sea.&#34;,&#xA;    userInfo: [&#34;something&#34;: &#34;is fishy&#34;])&#xA;expect { exception.raise() }.to(raiseException())&#xA;&#xA;// Also, you can customize raiseException to be more specific&#xA;expect { exception.raise() }.to(raiseException(named: NSInternalInconsistencyException))&#xA;expect { exception.raise() }.to(raiseException(&#xA;    named: NSInternalInconsistencyException,&#xA;    reason: &#34;Not enough fish in the sea&#34;))&#xA;expect { exception.raise() }.to(raiseException(&#xA;    named: NSInternalInconsistencyException,&#xA;    reason: &#34;Not enough fish in the sea&#34;,&#xA;    userInfo: [&#34;something&#34;: &#34;is fishy&#34;]))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Objective-C works the same way, but you must use the &lt;code&gt;expectAction&lt;/code&gt; macro when making an expectation on an expression that has no return value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;NSException *exception = [NSException exceptionWithName:NSInternalInconsistencyException&#xA;                                                 reason:@&#34;Not enough fish in the sea.&#34;&#xA;                                               userInfo:nil];&#xA;expectAction(^{ [exception raise]; }).to(raiseException());&#xA;&#xA;// Use the property-block syntax to be more specific.&#xA;expectAction(^{ [exception raise]; }).to(raiseException().named(NSInternalInconsistencyException));&#xA;expectAction(^{ [exception raise]; }).to(raiseException().&#xA;    named(NSInternalInconsistencyException).&#xA;    reason(&#34;Not enough fish in the sea&#34;));&#xA;expectAction(^{ [exception raise]; }).to(raiseException().&#xA;    named(NSInternalInconsistencyException).&#xA;    reason(&#34;Not enough fish in the sea&#34;).&#xA;    userInfo(@{@&#34;something&#34;: @&#34;is fishy&#34;}));&#xA;&#xA;// You can also pass a block for custom matching of the raised exception&#xA;expectAction(exception.raise()).to(raiseException().satisfyingBlock(^(NSException *exception) {&#xA;    expect(exception.name).to(beginWith(NSInternalInconsistencyException));&#xA;}));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;C Primitives&lt;/h2&gt; &#xA;&lt;p&gt;Some testing frameworks make it hard to test primitive C values. In Nimble, it just works:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;let actual: CInt = 1&#xA;let expectedValue: CInt = 1&#xA;expect(actual).to(equal(expectedValue))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In fact, Nimble uses type inference, so you can write the above without explicitly specifying both types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(1 as CInt).to(equal(1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;In Objective-C, Nimble only supports Objective-C objects. To make expectations on primitive C values, wrap then in an object literal:&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;expect(@(1 + 1)).to(equal(@2));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Asynchronous Expectations&lt;/h2&gt; &#xA;&lt;p&gt;In Nimble, it&#39;s easy to make expectations on values that are updated asynchronously. Just use &lt;code&gt;toEventually&lt;/code&gt; or &lt;code&gt;toEventuallyNot&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;DispatchQueue.main.async {&#xA;    ocean.add(&#34;dolphins&#34;)&#xA;    ocean.add(&#34;whales&#34;)&#xA;}&#xA;expect(ocean).toEventually(contain(&#34;dolphins&#34;, &#34;whales&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;dispatch_async(dispatch_get_main_queue(), ^{&#xA;    [ocean add:@&#34;dolphins&#34;];&#xA;    [ocean add:@&#34;whales&#34;];&#xA;});&#xA;expect(ocean).toEventually(contain(@&#34;dolphins&#34;, @&#34;whales&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: toEventually triggers its polls on the main thread. Blocking the main thread will cause Nimble to stop the run loop. This can cause test pollution for whatever incomplete code that was running on the main thread. Blocking the main thread can be caused by blocking IO, calls to sleep(), deadlocks, and synchronous IPC.&lt;/p&gt; &#xA;&lt;p&gt;In the above example, &lt;code&gt;ocean&lt;/code&gt; is constantly re-evaluated. If it ever contains dolphins and whales, the expectation passes. If &lt;code&gt;ocean&lt;/code&gt; still doesn&#39;t contain them, even after being continuously re-evaluated for one whole second, the expectation fails.&lt;/p&gt; &#xA;&lt;p&gt;You can also test that a value always or never matches throughout the length of the timeout. Use &lt;code&gt;toNever&lt;/code&gt; and &lt;code&gt;toAlways&lt;/code&gt; for this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;ocean.add(&#34;dolphins&#34;)&#xA;expect(ocean).toAlways(contain(&#34;dolphins&#34;))&#xA;expect(ocean).toNever(contain(&#34;hares&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;[ocean add:@&#34;dolphins&#34;]&#xA;expect(ocean).toAlways(contain(@&#34;dolphins&#34;))&#xA;expect(ocean).toNever(contain(@&#34;hares&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sometimes it takes more than a second for a value to update. In those cases, use the &lt;code&gt;timeout&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Waits three seconds for ocean to contain &#34;starfish&#34;:&#xA;expect(ocean).toEventually(contain(&#34;starfish&#34;), timeout: .seconds(3))&#xA;&#xA;// Evaluate someValue every 0.2 seconds repeatedly until it equals 100, or fails if it timeouts after 5.5 seconds.&#xA;expect(someValue).toEventually(equal(100), timeout: .milliseconds(5500), pollInterval: .milliseconds(200))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Waits three seconds for ocean to contain &#34;starfish&#34;:&#xA;expect(ocean).withTimeout(3).toEventually(contain(@&#34;starfish&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also provide a callback by using the &lt;code&gt;waitUntil&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;waitUntil { done in&#xA;    ocean.goFish { success in&#xA;        expect(success).to(beTrue())&#xA;        done()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;waitUntil(^(void (^done)(void)){&#xA;    [ocean goFishWithHandler:^(BOOL success){&#xA;        expect(success).to(beTrue());&#xA;        done();&#xA;    }];&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;waitUntil&lt;/code&gt; also optionally takes a timeout parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;waitUntil(timeout: .seconds(10)) { done in&#xA;    ocean.goFish { success in&#xA;        expect(success).to(beTrue())&#xA;        done()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;waitUntilTimeout(10, ^(void (^done)(void)){&#xA;    [ocean goFishWithHandler:^(BOOL success){&#xA;        expect(success).to(beTrue());&#xA;        done();&#xA;    }];&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: &lt;code&gt;waitUntil&lt;/code&gt; triggers its timeout code on the main thread. Blocking the main thread will cause Nimble to stop the run loop to continue. This can cause test pollution for whatever incomplete code that was running on the main thread. Blocking the main thread can be caused by blocking IO, calls to sleep(), deadlocks, and synchronous IPC.&lt;/p&gt; &#xA;&lt;p&gt;In some cases (e.g. when running on slower machines) it can be useful to modify the default timeout and poll interval values. This can be done as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Increase the global timeout to 5 seconds:&#xA;Nimble.AsyncDefaults.timeout = .seconds(5)&#xA;&#xA;// Slow the polling interval to 0.1 seconds:&#xA;Nimble.AsyncDefaults.pollInterval = .milliseconds(100)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Objective-C Support&lt;/h2&gt; &#xA;&lt;p&gt;Nimble has full support for Objective-C. However, there are two things to keep in mind when using Nimble in Objective-C:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;All parameters passed to the &lt;code&gt;expect&lt;/code&gt; function, as well as matcher functions like &lt;code&gt;equal&lt;/code&gt;, must be Objective-C objects or can be converted into an &lt;code&gt;NSObject&lt;/code&gt; equivalent:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;@import Nimble;&#xA;&#xA;expect(@(1 + 1)).to(equal(@2));&#xA;expect(@&#34;Hello world&#34;).to(contain(@&#34;world&#34;));&#xA;&#xA;// Boxed as NSNumber *&#xA;expect(2).to(equal(2));&#xA;expect(1.2).to(beLessThan(2.0));&#xA;expect(true).to(beTruthy());&#xA;&#xA;// Boxed as NSString *&#xA;expect(&#34;Hello world&#34;).to(equal(&#34;Hello world&#34;));&#xA;&#xA;// Boxed as NSRange&#xA;expect(NSMakeRange(1, 10)).to(equal(NSMakeRange(1, 10)));&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To make an expectation on an expression that does not return a value, such as &lt;code&gt;-[NSException raise]&lt;/code&gt;, use &lt;code&gt;expectAction&lt;/code&gt; instead of &lt;code&gt;expect&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expectAction(^{ [exception raise]; }).to(raiseException());&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The following types are currently converted to an &lt;code&gt;NSObject&lt;/code&gt; type:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;C Numeric types&lt;/strong&gt; are converted to &lt;code&gt;NSNumber *&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NSRange&lt;/code&gt; is converted to &lt;code&gt;NSValue *&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;char *&lt;/code&gt; is converted to &lt;code&gt;NSString *&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For the following matchers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beGreaterThan&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beGreaterThanOrEqual&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beLessThan&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beLessThanOrEqual&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beCloseTo&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beTrue&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beFalse&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beTruthy&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;beFalsy&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;haveCount&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you would like to see more, &lt;a href=&#34;https://github.com/Quick/Nimble/issues&#34;&gt;file an issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Disabling Objective-C Shorthand&lt;/h2&gt; &#xA;&lt;p&gt;Nimble provides a shorthand for expressing expectations using the &lt;code&gt;expect&lt;/code&gt; function. To disable this shorthand in Objective-C, define the &lt;code&gt;NIMBLE_DISABLE_SHORT_SYNTAX&lt;/code&gt; macro somewhere in your code before importing Nimble:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#define NIMBLE_DISABLE_SHORT_SYNTAX 1&#xA;&#xA;@import Nimble;&#xA;&#xA;NMB_expect(^{ return seagull.squawk; }, __FILE__, __LINE__).to(NMB_equal(@&#34;Squee!&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Disabling the shorthand is useful if you&#39;re testing functions with names that conflict with Nimble functions, such as &lt;code&gt;expect&lt;/code&gt; or &lt;code&gt;equal&lt;/code&gt;. If that&#39;s not the case, there&#39;s no point in disabling the shorthand.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Built-in Matcher Functions&lt;/h1&gt; &#xA;&lt;p&gt;Nimble includes a wide variety of matcher functions.&lt;/p&gt; &#xA;&lt;h2&gt;Type Checking&lt;/h2&gt; &#xA;&lt;p&gt;Nimble supports checking the type membership of any kind of object, whether Objective-C conformant or not:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;protocol SomeProtocol{}&#xA;class SomeClassConformingToProtocol: SomeProtocol{}&#xA;struct SomeStructConformingToProtocol: SomeProtocol{}&#xA;&#xA;// The following tests pass&#xA;expect(1).to(beAKindOf(Int.self))&#xA;expect(&#34;turtle&#34;).to(beAKindOf(String.self))&#xA;&#xA;let classObject = SomeClassConformingToProtocol()&#xA;expect(classObject).to(beAKindOf(SomeProtocol.self))&#xA;expect(classObject).to(beAKindOf(SomeClassConformingToProtocol.self))&#xA;expect(classObject).toNot(beAKindOf(SomeStructConformingToProtocol.self))&#xA;&#xA;let structObject = SomeStructConformingToProtocol()&#xA;expect(structObject).to(beAKindOf(SomeProtocol.self))&#xA;expect(structObject).to(beAKindOf(SomeStructConformingToProtocol.self))&#xA;expect(structObject).toNot(beAKindOf(SomeClassConformingToProtocol.self))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// The following tests pass&#xA;NSMutableArray *array = [NSMutableArray array];&#xA;expect(array).to(beAKindOf([NSArray class]));&#xA;expect(@1).toNot(beAKindOf([NSNull class]));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Objects can be tested for their exact types using the &lt;code&gt;beAnInstanceOf&lt;/code&gt; matcher:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;protocol SomeProtocol{}&#xA;class SomeClassConformingToProtocol: SomeProtocol{}&#xA;struct SomeStructConformingToProtocol: SomeProtocol{}&#xA;&#xA;// Unlike the &#39;beKindOf&#39; matcher, the &#39;beAnInstanceOf&#39; matcher only&#xA;// passes if the object is the EXACT type requested. The following&#xA;// tests pass -- note its behavior when working in an inheritance hierarchy.&#xA;expect(1).to(beAnInstanceOf(Int.self))&#xA;expect(&#34;turtle&#34;).to(beAnInstanceOf(String.self))&#xA;&#xA;let classObject = SomeClassConformingToProtocol()&#xA;expect(classObject).toNot(beAnInstanceOf(SomeProtocol.self))&#xA;expect(classObject).to(beAnInstanceOf(SomeClassConformingToProtocol.self))&#xA;expect(classObject).toNot(beAnInstanceOf(SomeStructConformingToProtocol.self))&#xA;&#xA;let structObject = SomeStructConformingToProtocol()&#xA;expect(structObject).toNot(beAnInstanceOf(SomeProtocol.self))&#xA;expect(structObject).to(beAnInstanceOf(SomeStructConformingToProtocol.self))&#xA;expect(structObject).toNot(beAnInstanceOf(SomeClassConformingToProtocol.self))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Equivalence&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;actual&#39; is equivalent to &#39;expected&#39;:&#xA;expect(actual).to(equal(expected))&#xA;expect(actual) == expected&#xA;&#xA;// Passes if &#39;actual&#39; is not equivalent to &#39;expected&#39;:&#xA;expect(actual).toNot(equal(expected))&#xA;expect(actual) != expected&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;actual&#39; is equivalent to &#39;expected&#39;:&#xA;expect(actual).to(equal(expected))&#xA;&#xA;// Passes if &#39;actual&#39; is not equivalent to &#39;expected&#39;:&#xA;expect(actual).toNot(equal(expected))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Values must be &lt;code&gt;Equatable&lt;/code&gt;, &lt;code&gt;Comparable&lt;/code&gt;, or subclasses of &lt;code&gt;NSObject&lt;/code&gt;. &lt;code&gt;equal&lt;/code&gt; will always fail when used to compare one or more &lt;code&gt;nil&lt;/code&gt; values.&lt;/p&gt; &#xA;&lt;h2&gt;Identity&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;actual&#39; has the same pointer address as &#39;expected&#39;:&#xA;expect(actual).to(beIdenticalTo(expected))&#xA;expect(actual) === expected&#xA;&#xA;// Passes if &#39;actual&#39; does not have the same pointer address as &#39;expected&#39;:&#xA;expect(actual).toNot(beIdenticalTo(expected))&#xA;expect(actual) !== expected&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is important to remember that &lt;code&gt;beIdenticalTo&lt;/code&gt; only makes sense when comparing types with reference semantics, which have a notion of identity. In Swift, that means types that are defined as a &lt;code&gt;class&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This matcher will not work when comparing types with value semantics such as those defined as a &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt;. If you need to compare two value types, consider what it means for instances of your type to be identical. This may mean comparing individual properties or, if it makes sense to do so, conforming your type to &lt;code&gt;Equatable&lt;/code&gt; and using Nimble&#39;s equivalence matchers instead.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;actual&#39; has the same pointer address as &#39;expected&#39;:&#xA;expect(actual).to(beIdenticalTo(expected));&#xA;&#xA;// Passes if &#39;actual&#39; does not have the same pointer address as &#39;expected&#39;:&#xA;expect(actual).toNot(beIdenticalTo(expected));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Comparisons&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(actual).to(beLessThan(expected))&#xA;expect(actual) &amp;lt; expected&#xA;&#xA;expect(actual).to(beLessThanOrEqualTo(expected))&#xA;expect(actual) &amp;lt;= expected&#xA;&#xA;expect(actual).to(beGreaterThan(expected))&#xA;expect(actual) &amp;gt; expected&#xA;&#xA;expect(actual).to(beGreaterThanOrEqualTo(expected))&#xA;expect(actual) &amp;gt;= expected&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(actual).to(beLessThan(expected));&#xA;expect(actual).to(beLessThanOrEqualTo(expected));&#xA;expect(actual).to(beGreaterThan(expected));&#xA;expect(actual).to(beGreaterThanOrEqualTo(expected));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Values given to the comparison matchers above must implement &lt;code&gt;Comparable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Because of how computers represent floating point numbers, assertions that two floating point numbers be equal will sometimes fail. To express that two numbers should be close to one another within a certain margin of error, use &lt;code&gt;beCloseTo&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(actual).to(beCloseTo(expected, within: delta))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(actual).to(beCloseTo(expected).within(delta));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example, to assert that &lt;code&gt;10.01&lt;/code&gt; is close to &lt;code&gt;10&lt;/code&gt;, you can write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(10.01).to(beCloseTo(10, within: 0.1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(@(10.01)).to(beCloseTo(@10).within(0.1));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is also an operator shortcut available in Swift:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(actual) â‰ˆ expected&#xA;expect(actual) â‰ˆ (expected, delta)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Type &lt;kbd&gt;option&lt;/kbd&gt;+&lt;kbd&gt;x&lt;/kbd&gt; to get &lt;code&gt;â‰ˆ&lt;/code&gt; on a U.S. keyboard)&lt;/p&gt; &#xA;&lt;p&gt;The former version uses the default delta of 0.0001. Here is yet another way to do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(actual) â‰ˆ expected Â± delta&#xA;expect(actual) == expected Â± delta&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Type &lt;kbd&gt;option&lt;/kbd&gt;+&lt;kbd&gt;shift&lt;/kbd&gt;+&lt;kbd&gt;=&lt;/kbd&gt; to get &lt;code&gt;Â±&lt;/code&gt; on a U.S. keyboard)&lt;/p&gt; &#xA;&lt;p&gt;If you are comparing arrays of floating point numbers, you&#39;ll find the following useful:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect([0.0, 2.0]) â‰ˆ [0.0001, 2.0001]&#xA;expect([0.0, 2.0]).to(beCloseTo([0.1, 2.1], within: 0.1))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Values given to the &lt;code&gt;beCloseTo&lt;/code&gt; matcher must conform to &lt;code&gt;FloatingPoint&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Types/Classes&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;instance&#39; is an instance of &#39;aClass&#39;:&#xA;expect(instance).to(beAnInstanceOf(aClass))&#xA;&#xA;// Passes if &#39;instance&#39; is an instance of &#39;aClass&#39; or any of its subclasses:&#xA;expect(instance).to(beAKindOf(aClass))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;instance&#39; is an instance of &#39;aClass&#39;:&#xA;expect(instance).to(beAnInstanceOf(aClass));&#xA;&#xA;// Passes if &#39;instance&#39; is an instance of &#39;aClass&#39; or any of its subclasses:&#xA;expect(instance).to(beAKindOf(aClass));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Instances must be Objective-C objects: subclasses of &lt;code&gt;NSObject&lt;/code&gt;, or Swift objects bridged to Objective-C with the &lt;code&gt;@objc&lt;/code&gt; prefix.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;For example, to assert that &lt;code&gt;dolphin&lt;/code&gt; is a kind of &lt;code&gt;Mammal&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect(dolphin).to(beAKindOf(Mammal))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(dolphin).to(beAKindOf([Mammal class]));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;beAnInstanceOf&lt;/code&gt; uses the &lt;code&gt;-[NSObject isMemberOfClass:]&lt;/code&gt; method to test membership. &lt;code&gt;beAKindOf&lt;/code&gt; uses &lt;code&gt;-[NSObject isKindOfClass:]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Truthiness&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Passes if &#39;actual&#39; is not nil, true, or an object with a boolean value of true:&#xA;expect(actual).to(beTruthy())&#xA;&#xA;// Passes if &#39;actual&#39; is only true (not nil or an object conforming to Boolean true):&#xA;expect(actual).to(beTrue())&#xA;&#xA;// Passes if &#39;actual&#39; is nil, false, or an object with a boolean value of false:&#xA;expect(actual).to(beFalsy())&#xA;&#xA;// Passes if &#39;actual&#39; is only false (not nil or an object conforming to Boolean false):&#xA;expect(actual).to(beFalse())&#xA;&#xA;// Passes if &#39;actual&#39; is nil:&#xA;expect(actual).to(beNil())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;actual&#39; is not nil, true, or an object with a boolean value of true:&#xA;expect(actual).to(beTruthy());&#xA;&#xA;// Passes if &#39;actual&#39; is only true (not nil or an object conforming to Boolean true):&#xA;expect(actual).to(beTrue());&#xA;&#xA;// Passes if &#39;actual&#39; is nil, false, or an object with a boolean value of false:&#xA;expect(actual).to(beFalsy());&#xA;&#xA;// Passes if &#39;actual&#39; is only false (not nil or an object conforming to Boolean false):&#xA;expect(actual).to(beFalse());&#xA;&#xA;// Passes if &#39;actual&#39; is nil:&#xA;expect(actual).to(beNil());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Swift Assertions&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re using Swift, you can use the &lt;code&gt;throwAssertion&lt;/code&gt; matcher to check if an assertion is thrown (e.g. &lt;code&gt;fatalError()&lt;/code&gt;). This is made possible by &lt;a href=&#34;https://github.com/mattgallagher&#34;&gt;@mattgallagher&lt;/a&gt;&#39;s &lt;a href=&#34;https://github.com/mattgallagher/CwlPreconditionTesting&#34;&gt;CwlPreconditionTesting&lt;/a&gt; library.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;somethingThatThrows()&#39; throws an assertion, &#xA;// such as by calling &#39;fatalError()&#39; or if a precondition fails:&#xA;expect { try somethingThatThrows() }.to(throwAssertion())&#xA;expect { () -&amp;gt; Void in fatalError() }.to(throwAssertion())&#xA;expect { precondition(false) }.to(throwAssertion())&#xA;&#xA;// Passes if throwing an NSError is not equal to throwing an assertion:&#xA;expect { throw NSError(domain: &#34;test&#34;, code: 0, userInfo: nil) }.toNot(throwAssertion())&#xA;&#xA;// Passes if the code after the precondition check is not run:&#xA;var reachedPoint1 = false&#xA;var reachedPoint2 = false&#xA;expect {&#xA;    reachedPoint1 = true&#xA;    precondition(false, &#34;condition message&#34;)&#xA;    reachedPoint2 = true&#xA;}.to(throwAssertion())&#xA;&#xA;expect(reachedPoint1) == true&#xA;expect(reachedPoint2) == false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This feature is only available in Swift.&lt;/li&gt; &#xA; &lt;li&gt;The tvOS simulator is supported, but using a different mechanism, requiring you to turn off the &lt;code&gt;Debug executable&lt;/code&gt; scheme setting for your tvOS scheme&#39;s Test configuration.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Swift Error Handling&lt;/h2&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;throwError&lt;/code&gt; matcher to check if an error is thrown.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;somethingThatThrows()&#39; throws an &#39;Error&#39;:&#xA;expect { try somethingThatThrows() }.to(throwError())&#xA;&#xA;// Passes if &#39;somethingThatThrows()&#39; throws an error within a particular domain:&#xA;expect { try somethingThatThrows() }.to(throwError { (error: Error) in&#xA;    expect(error._domain).to(equal(NSCocoaErrorDomain))&#xA;})&#xA;&#xA;// Passes if &#39;somethingThatThrows()&#39; throws a particular error enum case:&#xA;expect { try somethingThatThrows() }.to(throwError(NSCocoaError.PropertyListReadCorruptError))&#xA;&#xA;// Passes if &#39;somethingThatThrows()&#39; throws an error of a particular type:&#xA;expect { try somethingThatThrows() }.to(throwError(errorType: NimbleError.self))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When working directly with &lt;code&gt;Error&lt;/code&gt; values, using the &lt;code&gt;matchError&lt;/code&gt; matcher allows you to perform certain checks on the error itself without having to explicitly cast the error.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;matchError&lt;/code&gt; matcher allows you to check whether or not the error:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;is the same &lt;em&gt;type&lt;/em&gt; of error you are expecting.&lt;/li&gt; &#xA; &lt;li&gt;represents a particular error value that you are expecting.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This can be useful when using &lt;code&gt;Result&lt;/code&gt; or &lt;code&gt;Promise&lt;/code&gt; types, for example.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;let actual: Error = ...&#xA;&#xA;// Passes if &#39;actual&#39; represents any error value from the NimbleErrorEnum type:&#xA;expect(actual).to(matchError(NimbleErrorEnum.self))&#xA;&#xA;// Passes if &#39;actual&#39; represents the case &#39;timeout&#39; from the NimbleErrorEnum type:&#xA;expect(actual).to(matchError(NimbleErrorEnum.timeout))&#xA;&#xA;// Passes if &#39;actual&#39; contains an NSError equal to the one provided:&#xA;expect(actual).to(matchError(NSError(domain: &#34;err&#34;, code: 123, userInfo: nil)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: This feature is only available in Swift.&lt;/p&gt; &#xA;&lt;h2&gt;Exceptions&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;actual&#39;, when evaluated, raises an exception:&#xA;expect(actual).to(raiseException())&#xA;&#xA;// Passes if &#39;actual&#39; raises an exception with the given name:&#xA;expect(actual).to(raiseException(named: name))&#xA;&#xA;// Passes if &#39;actual&#39; raises an exception with the given name and reason:&#xA;expect(actual).to(raiseException(named: name, reason: reason))&#xA;&#xA;// Passes if &#39;actual&#39; raises an exception which passes expectations defined in the given closure:&#xA;// (in this case, if the exception&#39;s name begins with &#34;a r&#34;)&#xA;expect { exception.raise() }.to(raiseException { (exception: NSException) in&#xA;    expect(exception.name).to(beginWith(&#34;a r&#34;))&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;actual&#39;, when evaluated, raises an exception:&#xA;expect(actual).to(raiseException())&#xA;&#xA;// Passes if &#39;actual&#39; raises an exception with the given name&#xA;expect(actual).to(raiseException().named(name))&#xA;&#xA;// Passes if &#39;actual&#39; raises an exception with the given name and reason:&#xA;expect(actual).to(raiseException().named(name).reason(reason))&#xA;&#xA;// Passes if &#39;actual&#39; raises an exception and it passes expectations defined in the given block:&#xA;// (in this case, if name begins with &#34;a r&#34;)&#xA;expect(actual).to(raiseException().satisfyingBlock(^(NSException *exception) {&#xA;    expect(exception.name).to(beginWith(@&#34;a r&#34;));&#xA;}));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: Swift currently doesn&#39;t have exceptions (see &lt;a href=&#34;https://github.com/Quick/Nimble/issues/220#issuecomment-172667064&#34;&gt;#220&lt;/a&gt;). Only Objective-C code can raise exceptions that Nimble will catch.&lt;/p&gt; &#xA;&lt;h2&gt;Collection Membership&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if all of the expected values are members of &#39;actual&#39;:&#xA;expect(actual).to(contain(expected...))&#xA;&#xA;// Passes if &#39;actual&#39; is empty (i.e. it contains no elements):&#xA;expect(actual).to(beEmpty())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if expected is a member of &#39;actual&#39;:&#xA;expect(actual).to(contain(expected));&#xA;&#xA;// Passes if &#39;actual&#39; is empty (i.e. it contains no elements):&#xA;expect(actual).to(beEmpty());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;In Swift &lt;code&gt;contain&lt;/code&gt; takes any number of arguments. The expectation passes if all of them are members of the collection. In Objective-C, &lt;code&gt;contain&lt;/code&gt; only takes one argument &lt;a href=&#34;https://github.com/Quick/Nimble/issues/27&#34;&gt;for now&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;For example, to assert that a list of sea creature names contains &#34;dolphin&#34; and &#34;starfish&#34;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;expect([&#34;whale&#34;, &#34;dolphin&#34;, &#34;starfish&#34;]).to(contain(&#34;dolphin&#34;, &#34;starfish&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(@[@&#34;whale&#34;, @&#34;dolphin&#34;, @&#34;starfish&#34;]).to(contain(@&#34;dolphin&#34;));&#xA;expect(@[@&#34;whale&#34;, @&#34;dolphin&#34;, @&#34;starfish&#34;]).to(contain(@&#34;starfish&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;contain&lt;/code&gt; and &lt;code&gt;beEmpty&lt;/code&gt; expect collections to be instances of &lt;code&gt;NSArray&lt;/code&gt;, &lt;code&gt;NSSet&lt;/code&gt;, or a Swift collection composed of &lt;code&gt;Equatable&lt;/code&gt; elements.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To test whether a set of elements is present at the beginning or end of an ordered collection, use &lt;code&gt;beginWith&lt;/code&gt; and &lt;code&gt;endWith&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if the elements in expected appear at the beginning of &#39;actual&#39;:&#xA;expect(actual).to(beginWith(expected...))&#xA;&#xA;// Passes if the the elements in expected come at the end of &#39;actual&#39;:&#xA;expect(actual).to(endWith(expected...))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if the elements in expected appear at the beginning of &#39;actual&#39;:&#xA;expect(actual).to(beginWith(expected));&#xA;&#xA;// Passes if the the elements in expected come at the end of &#39;actual&#39;:&#xA;expect(actual).to(endWith(expected));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;beginWith&lt;/code&gt; and &lt;code&gt;endWith&lt;/code&gt; expect collections to be instances of &lt;code&gt;NSArray&lt;/code&gt;, or ordered Swift collections composed of &lt;code&gt;Equatable&lt;/code&gt; elements.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Like &lt;code&gt;contain&lt;/code&gt;, in Objective-C &lt;code&gt;beginWith&lt;/code&gt; and &lt;code&gt;endWith&lt;/code&gt; only support a single argument &lt;a href=&#34;https://github.com/Quick/Nimble/issues/27&#34;&gt;for now&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For code that returns collections of complex objects without a strict ordering, there is the &lt;code&gt;containElementSatisfying&lt;/code&gt; matcher:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;struct Turtle {&#xA;    let color: String&#xA;}&#xA;&#xA;let turtles: [Turtle] = functionThatReturnsSomeTurtlesInAnyOrder()&#xA;&#xA;// This set of matchers passes regardless of whether the array is &#xA;// [{color: &#34;blue&#34;}, {color: &#34;green&#34;}] or [{color: &#34;green&#34;}, {color: &#34;blue&#34;}]:&#xA;&#xA;expect(turtles).to(containElementSatisfying({ turtle in&#xA;    return turtle.color == &#34;green&#34;&#xA;}))&#xA;expect(turtles).to(containElementSatisfying({ turtle in&#xA;    return turtle.color == &#34;blue&#34;&#xA;}, &#34;that is a turtle with color &#39;blue&#39;&#34;))&#xA;&#xA;// The second matcher will incorporate the provided string in the error message&#xA;// should it fail&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;@interface Turtle : NSObject&#xA;@property (nonatomic, readonly, nonnull) NSString *color;&#xA;@end&#xA;&#xA;@implementation Turtle &#xA;@end&#xA;&#xA;NSArray&amp;lt;Turtle *&amp;gt; * __nonnull turtles = functionThatReturnsSomeTurtlesInAnyOrder();&#xA;&#xA;// This set of matchers passes regardless of whether the array is &#xA;// [{color: &#34;blue&#34;}, {color: &#34;green&#34;}] or [{color: &#34;green&#34;}, {color: &#34;blue&#34;}]:&#xA;&#xA;expect(turtles).to(containElementSatisfying(^BOOL(id __nonnull object) {&#xA;    return [[turtle color] isEqualToString:@&#34;green&#34;];&#xA;}));&#xA;expect(turtles).to(containElementSatisfying(^BOOL(id __nonnull object) {&#xA;    return [[turtle color] isEqualToString:@&#34;blue&#34;];&#xA;}));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For asserting on if the given &lt;code&gt;Comparable&lt;/code&gt; value is inside of a &lt;code&gt;Range&lt;/code&gt;, use the &lt;code&gt;beWithin&lt;/code&gt; matcher.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if 5 is within the range 1 through 10, inclusive&#xA;expect(5).to(beWithin(1...10))&#xA;&#xA;// Passes if 5 is not within the range 2 through 4.&#xA;expect(5).toNot(beWithin(2..&amp;lt;5))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Strings&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;actual&#39; contains &#39;substring&#39;:&#xA;expect(actual).to(contain(substring))&#xA;&#xA;// Passes if &#39;actual&#39; begins with &#39;prefix&#39;:&#xA;expect(actual).to(beginWith(prefix))&#xA;&#xA;// Passes if &#39;actual&#39; ends with &#39;suffix&#39;:&#xA;expect(actual).to(endWith(suffix))&#xA;&#xA;// Passes if &#39;actual&#39; represents the empty string, &#34;&#34;:&#xA;expect(actual).to(beEmpty())&#xA;&#xA;// Passes if &#39;actual&#39; matches the regular expression defined in &#39;expected&#39;:&#xA;expect(actual).to(match(expected))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;actual&#39; contains &#39;substring&#39;:&#xA;expect(actual).to(contain(expected));&#xA;&#xA;// Passes if &#39;actual&#39; begins with &#39;prefix&#39;:&#xA;expect(actual).to(beginWith(prefix));&#xA;&#xA;// Passes if &#39;actual&#39; ends with &#39;suffix&#39;:&#xA;expect(actual).to(endWith(suffix));&#xA;&#xA;// Passes if &#39;actual&#39; represents the empty string, &#34;&#34;:&#xA;expect(actual).to(beEmpty());&#xA;&#xA;// Passes if &#39;actual&#39; matches the regular expression defined in &#39;expected&#39;:&#xA;expect(actual).to(match(expected))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Collection Elements&lt;/h2&gt; &#xA;&lt;p&gt;Nimble provides a means to check that all elements of a collection pass a given expectation.&lt;/p&gt; &#xA;&lt;h3&gt;Swift&lt;/h3&gt; &#xA;&lt;p&gt;In Swift, the collection must be an instance of a type conforming to &lt;code&gt;Sequence&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Providing a custom function:&#xA;expect([1, 2, 3, 4]).to(allPass { $0 &amp;lt; 5 })&#xA;&#xA;// Composing the expectation with another matcher:&#xA;expect([1, 2, 3, 4]).to(allPass(beLessThan(5)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Objective-C&lt;/h3&gt; &#xA;&lt;p&gt;In Objective-C, the collection must be an instance of a type which implements the &lt;code&gt;NSFastEnumeration&lt;/code&gt; protocol, and whose elements are instances of a type which subclasses &lt;code&gt;NSObject&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, unlike in Swift, there is no override to specify a custom matcher function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(@[@1, @2, @3, @4]).to(allPass(beLessThan(@5)));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Collection Count&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// Passes if &#39;actual&#39; contains the &#39;expected&#39; number of elements:&#xA;expect(actual).to(haveCount(expected))&#xA;&#xA;// Passes if &#39;actual&#39; does _not_ contain the &#39;expected&#39; number of elements:&#xA;expect(actual).notTo(haveCount(expected))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// Passes if &#39;actual&#39; contains the &#39;expected&#39; number of elements:&#xA;expect(actual).to(haveCount(expected))&#xA;&#xA;// Passes if &#39;actual&#39; does _not_ contain the &#39;expected&#39; number of elements:&#xA;expect(actual).notTo(haveCount(expected))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Swift, the actual value must be an instance of a type conforming to &lt;code&gt;Collection&lt;/code&gt;. For example, instances of &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Dictionary&lt;/code&gt;, or &lt;code&gt;Set&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For Objective-C, the actual value must be one of the following classes, or their subclasses:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;NSArray&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NSDictionary&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NSSet&lt;/code&gt;, or&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NSHashTable&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Notifications&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;let testNotification = Notification(name: Notification.Name(&#34;Foo&#34;), object: nil)&#xA;&#xA;// Passes if the closure in expect { ... } posts a notification to the default&#xA;// notification center.&#xA;expect {&#xA;    NotificationCenter.default.post(testNotification)&#xA;}.to(postNotifications(equal([testNotification])))&#xA;&#xA;// Passes if the closure in expect { ... } posts a notification to a given&#xA;// notification center&#xA;let notificationCenter = NotificationCenter()&#xA;expect {&#xA;    notificationCenter.post(testNotification)&#xA;}.to(postNotifications(equal([testNotification]), from: notificationCenter))&#xA;&#xA;// Passes if the closure in expect { ... } posts a notification with the provided names to a given&#xA;// notification center. Make sure to use this when running tests on Catalina, &#xA;// using DistributedNotificationCenter as there is currently no way &#xA;// of observing notifications without providing specific names.&#xA;let distributedNotificationCenter = DistributedNotificationCenter()&#xA;expect {&#xA;    distributedNotificationCenter.post(testNotification)&#xA;}.toEventually(postDistributedNotifications(equal([testNotification]),&#xA;                                  from: distributedNotificationCenter,&#xA;                                  names: [testNotification.name]))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;This matcher is only available in Swift.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Result&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;let aResult: Result&amp;lt;String, Error&amp;gt; = .success(&#34;Hooray&#34;) &#xA;&#xA;// passes if result is .success&#xA;expect(aResult).to(beSuccess()) &#xA;&#xA;// passes if result value is .success and validates Success value&#xA;expect(aResult).to(beSuccess { value in&#xA;    expect(value).to(equal(&#34;Hooray&#34;))&#xA;})&#xA;&#xA;&#xA;enum AnError: Error {&#xA;    case somethingHappened&#xA;}&#xA;let otherResult: Result&amp;lt;String, AnError&amp;gt; = .failure(.somethingHappened) &#xA;&#xA;// passes if result is .failure&#xA;expect(otherResult).to(beFailure()) &#xA;&#xA;// passes if result value is .failure and validates error&#xA;expect(otherResult).to(beFailure { error in&#xA;    expect(error).to(matchError(AnError.somethingHappened))&#xA;}) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;This matcher is only available in Swift.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Matching a value to any of a group of matchers&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// passes if actual is either less than 10 or greater than 20&#xA;expect(actual).to(satisfyAnyOf(beLessThan(10), beGreaterThan(20)))&#xA;&#xA;// can include any number of matchers -- the following will pass&#xA;// **be careful** -- too many matchers can be the sign of an unfocused test&#xA;expect(6).to(satisfyAnyOf(equal(2), equal(3), equal(4), equal(5), equal(6), equal(7)))&#xA;&#xA;// in Swift you also have the option to use the || operator to achieve a similar function&#xA;expect(82).to(beLessThan(50) || beGreaterThan(80))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;// passes if actual is either less than 10 or greater than 20&#xA;expect(actual).to(satisfyAnyOf(beLessThan(@10), beGreaterThan(@20)))&#xA;&#xA;// can include any number of matchers -- the following will pass&#xA;// **be careful** -- too many matchers can be the sign of an unfocused test&#xA;expect(@6).to(satisfyAnyOf(equal(@2), equal(@3), equal(@4), equal(@5), equal(@6), equal(@7)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: This matcher allows you to chain any number of matchers together. This provides flexibility, but if you find yourself chaining many matchers together in one test, consider whether you could instead refactor that single test into multiple, more precisely focused tests for better coverage.&lt;/p&gt; &#xA;&lt;h2&gt;Custom Validation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;// passes if .succeeded is returned from the closure&#xA;expect {&#xA;    guard case .enumCaseWithAssociatedValueThatIDontCareAbout = actual else {&#xA;        return .failed(reason: &#34;wrong enum case&#34;)&#xA;    }&#xA;&#xA;    return .succeeded&#xA;}.to(succeed())&#xA;&#xA;// passes if .failed is returned from the closure&#xA;expect {&#xA;    guard case .enumCaseWithAssociatedValueThatIDontCareAbout = actual else {&#xA;        return .failed(reason: &#34;wrong enum case&#34;)&#xA;    }&#xA;&#xA;    return .succeeded&#xA;}.notTo(succeed())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;String&lt;/code&gt; provided with &lt;code&gt;.failed()&lt;/code&gt; is shown when the test fails.&lt;/p&gt; &#xA;&lt;p&gt;When using &lt;code&gt;toEventually()&lt;/code&gt; be careful not to make state changes or run process intensive code since this closure will be ran many times.&lt;/p&gt; &#xA;&lt;h1&gt;Writing Your Own Matchers&lt;/h1&gt; &#xA;&lt;p&gt;In Nimble, matchers are Swift functions that take an expected value and return a &lt;code&gt;Predicate&lt;/code&gt; closure. Take &lt;code&gt;equal&lt;/code&gt;, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;public func equal&amp;lt;T: Equatable&amp;gt;(expectedValue: T?) -&amp;gt; Predicate&amp;lt;T&amp;gt; {&#xA;    // Can be shortened to:&#xA;    //   Predicate { actual in  ... }&#xA;    //&#xA;    // But shown with types here for clarity.&#xA;    return Predicate { (actualExpression: Expression&amp;lt;T&amp;gt;) throws -&amp;gt; PredicateResult in&#xA;        let msg = ExpectationMessage.expectedActualValueTo(&#34;equal &amp;lt;\(expectedValue)&amp;gt;&#34;)&#xA;        if let actualValue = try actualExpression.evaluate() {&#xA;            return PredicateResult(&#xA;                bool: actualValue == expectedValue!,&#xA;                message: msg&#xA;            )&#xA;        } else {&#xA;            return PredicateResult(&#xA;                status: .fail,&#xA;                message: msg.appendedBeNilHint()&#xA;            )&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The return value of a &lt;code&gt;Predicate&lt;/code&gt; closure is a &lt;code&gt;PredicateResult&lt;/code&gt; that indicates whether the actual value matches the expectation and what error message to display on failure.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The actual &lt;code&gt;equal&lt;/code&gt; matcher function does not match when &lt;code&gt;expected&lt;/code&gt; are nil; the example above has been edited for brevity.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Since matchers are just Swift functions, you can define them anywhere: at the top of your test file, in a file shared by all of your tests, or in an Xcode project you distribute to others.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If you write a matcher you think everyone can use, consider adding it to Nimble&#39;s built-in set of matchers by sending a pull request! Or distribute it yourself via GitHub.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;For examples of how to write your own matchers, just check out the &lt;a href=&#34;https://github.com/Quick/Nimble/tree/main/Sources/Nimble/Matchers&#34;&gt;&lt;code&gt;Matchers&lt;/code&gt; directory&lt;/a&gt; to see how Nimble&#39;s built-in set of matchers are implemented. You can also check out the tips below.&lt;/p&gt; &#xA;&lt;h2&gt;PredicateResult&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;PredicateResult&lt;/code&gt; is the return struct that &lt;code&gt;Predicate&lt;/code&gt; return to indicate success and failure. A &lt;code&gt;PredicateResult&lt;/code&gt; is made up of two values: &lt;code&gt;PredicateStatus&lt;/code&gt; and &lt;code&gt;ExpectationMessage&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Instead of a boolean, &lt;code&gt;PredicateStatus&lt;/code&gt; captures a trinary set of values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;public enum PredicateStatus {&#xA;// The predicate &#34;passes&#34; with the given expression&#xA;// eg - expect(1).to(equal(1))&#xA;case matches&#xA;&#xA;// The predicate &#34;fails&#34; with the given expression&#xA;// eg - expect(1).toNot(equal(1))&#xA;case doesNotMatch&#xA;&#xA;// The predicate never &#34;passes&#34; with the given expression, even if negated&#xA;// eg - expect(nil as Int?).toNot(equal(1))&#xA;case fail&#xA;&#xA;// ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Meanwhile, &lt;code&gt;ExpectationMessage&lt;/code&gt; provides messaging semantics for error reporting.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;public indirect enum ExpectationMessage {&#xA;// Emits standard error message:&#xA;// eg - &#34;expected to &amp;lt;string&amp;gt;, got &amp;lt;actual&amp;gt;&#34;&#xA;case expectedActualValueTo(/* message: */ String)&#xA;&#xA;// Allows any free-form message&#xA;// eg - &#34;&amp;lt;string&amp;gt;&#34;&#xA;case fail(/* message: */ String)&#xA;&#xA;// ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Predicates should usually depend on either &lt;code&gt;.expectedActualValueTo(..)&lt;/code&gt; or &lt;code&gt;.fail(..)&lt;/code&gt; when reporting errors. Special cases can be used for the other enum cases.&lt;/p&gt; &#xA;&lt;p&gt;Finally, if your Predicate utilizes other Predicates, you can utilize &lt;code&gt;.appended(details:)&lt;/code&gt; and &lt;code&gt;.appended(message:)&lt;/code&gt; methods to annotate an existing error with more details.&lt;/p&gt; &#xA;&lt;p&gt;A common message to append is failing on nils. For that, &lt;code&gt;.appendedBeNilHint()&lt;/code&gt; can be used.&lt;/p&gt; &#xA;&lt;h2&gt;Lazy Evaluation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;actualExpression&lt;/code&gt; is a lazy, memoized closure around the value provided to the &lt;code&gt;expect&lt;/code&gt; function. The expression can either be a closure or a value directly passed to &lt;code&gt;expect(...)&lt;/code&gt;. In order to determine whether that value matches, custom matchers should call &lt;code&gt;actualExpression.evaluate()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;public func beNil&amp;lt;T&amp;gt;() -&amp;gt; Predicate&amp;lt;T&amp;gt; {&#xA;    // Predicate.simpleNilable(..) automatically generates ExpectationMessage for&#xA;    // us based on the string we provide to it. Also, the &#39;Nilable&#39; postfix indicates&#xA;    // that this Predicate supports matching against nil actualExpressions, instead of&#xA;    // always resulting in a PredicateStatus.fail result -- which is true for&#xA;    // Predicate.simple(..)&#xA;    return Predicate.simpleNilable(&#34;be nil&#34;) { actualExpression in&#xA;        let actualValue = try actualExpression.evaluate()&#xA;        return PredicateStatus(bool: actualValue == nil)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above example, &lt;code&gt;actualExpression&lt;/code&gt; is not &lt;code&gt;nil&lt;/code&gt; -- it is a closure that returns a value. The value it returns, which is accessed via the &lt;code&gt;evaluate()&lt;/code&gt; method, may be &lt;code&gt;nil&lt;/code&gt;. If that value is &lt;code&gt;nil&lt;/code&gt;, the &lt;code&gt;beNil&lt;/code&gt; matcher function returns &lt;code&gt;true&lt;/code&gt;, indicating that the expectation passed.&lt;/p&gt; &#xA;&lt;h2&gt;Type Checking via Swift Generics&lt;/h2&gt; &#xA;&lt;p&gt;Using Swift&#39;s generics, matchers can constrain the type of the actual value passed to the &lt;code&gt;expect&lt;/code&gt; function by modifying the return type.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following matcher, &lt;code&gt;haveDescription&lt;/code&gt;, only accepts actual values that implement the &lt;code&gt;Printable&lt;/code&gt; protocol. It checks their &lt;code&gt;description&lt;/code&gt; against the one provided to the matcher function, and passes if they are the same:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;public func haveDescription(description: String) -&amp;gt; Predicate&amp;lt;Printable?&amp;gt; {&#xA;    return Predicate.simple(&#34;have description&#34;) { actual in&#xA;        return PredicateStatus(bool: actual.evaluate().description == description)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Customizing Failure Messages&lt;/h2&gt; &#xA;&lt;p&gt;When using &lt;code&gt;Predicate.simple(..)&lt;/code&gt; or &lt;code&gt;Predicate.simpleNilable(..)&lt;/code&gt;, Nimble outputs the following failure message when an expectation fails:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// where `message` is the first string argument and&#xA;// `actual` is the actual value received in `expect(..)`&#xA;&#34;expected to \(message), got &amp;lt;\(actual)&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can customize this message by modifying the way you create a &lt;code&gt;Predicate&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Basic Customization&lt;/h3&gt; &#xA;&lt;p&gt;For slightly more complex error messaging, receive the created failure message with &lt;code&gt;Predicate.define(..)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;public func equal&amp;lt;T: Equatable&amp;gt;(_ expectedValue: T?) -&amp;gt; Predicate&amp;lt;T&amp;gt; {&#xA;    return Predicate.define(&#34;equal &amp;lt;\(stringify(expectedValue))&amp;gt;&#34;) { actualExpression, msg in&#xA;        let actualValue = try actualExpression.evaluate()&#xA;        let matches = actualValue == expectedValue &amp;amp;&amp;amp; expectedValue != nil&#xA;        if expectedValue == nil || actualValue == nil {&#xA;            if expectedValue == nil &amp;amp;&amp;amp; actualValue != nil {&#xA;                return PredicateResult(&#xA;                    status: .fail,&#xA;                    message: msg.appendedBeNilHint()&#xA;                )&#xA;            }&#xA;            return PredicateResult(status: .fail, message: msg)&#xA;        }&#xA;        return PredicateResult(bool: matches, message: msg)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the example above, &lt;code&gt;msg&lt;/code&gt; is defined based on the string given to &lt;code&gt;Predicate.define&lt;/code&gt;. The code looks akin to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;let msg = ExpectationMessage.expectedActualValueTo(&#34;equal &amp;lt;\(stringify(expectedValue))&amp;gt;&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Full Customization&lt;/h3&gt; &#xA;&lt;p&gt;To fully customize the behavior of the Predicate, use the overload that expects a &lt;code&gt;PredicateResult&lt;/code&gt; to be returned.&lt;/p&gt; &#xA;&lt;p&gt;Along with &lt;code&gt;PredicateResult&lt;/code&gt;, there are other &lt;code&gt;ExpectationMessage&lt;/code&gt; enum values you can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public indirect enum ExpectationMessage {&#xA;// Emits standard error message:&#xA;// eg - &#34;expected to &amp;lt;message&amp;gt;, got &amp;lt;actual&amp;gt;&#34;&#xA;case expectedActualValueTo(/* message: */ String)&#xA;&#xA;// Allows any free-form message&#xA;// eg - &#34;&amp;lt;message&amp;gt;&#34;&#xA;case fail(/* message: */ String)&#xA;&#xA;// Emits standard error message with a custom actual value instead of the default.&#xA;// eg - &#34;expected to &amp;lt;message&amp;gt;, got &amp;lt;actual&amp;gt;&#34;&#xA;case expectedCustomValueTo(/* message: */ String, /* actual: */ String)&#xA;&#xA;// Emits standard error message without mentioning the actual value&#xA;// eg - &#34;expected to &amp;lt;message&amp;gt;&#34;&#xA;case expectedTo(/* message: */ String)&#xA;&#xA;// ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For matchers that compose other matchers, there are a handful of helper functions to annotate messages.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;appended(message: String)&lt;/code&gt; is used to append to the original failure message:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// produces &#34;expected to be true, got &amp;lt;actual&amp;gt; (use beFalse() for inverse)&#34;&#xA;// appended message do show up inline in Xcode.&#xA;.expectedActualValueTo(&#34;be true&#34;).appended(message: &#34; (use beFalse() for inverse)&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a more comprehensive message that spans multiple lines, use &lt;code&gt;appended(details: String)&lt;/code&gt; instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// produces &#34;expected to be true, got &amp;lt;actual&amp;gt;\n\nuse beFalse() for inverse\nor use beNil()&#34;&#xA;// details do not show inline in Xcode, but do show up in test logs.&#xA;.expectedActualValueTo(&#34;be true&#34;).appended(details: &#34;use beFalse() for inverse\nor use beNil()&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Supporting Objective-C&lt;/h2&gt; &#xA;&lt;p&gt;To use a custom matcher written in Swift from Objective-C, you&#39;ll have to extend the &lt;code&gt;NMBPredicate&lt;/code&gt; class, adding a new class method for your custom matcher. The example below defines the class method &lt;code&gt;+[NMBPredicate beNilMatcher]&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Swift&#xA;&#xA;extension NMBPredicate {&#xA;    @objc public class func beNilMatcher() -&amp;gt; NMBPredicate {&#xA;        return NMBPredicate { actualExpression in&#xA;            return try beNil().satisfies(actualExpression).toObjectiveC()&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above allows you to use the matcher from Objective-C:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(actual).to([NMBPredicate beNilMatcher]());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To make the syntax easier to use, define a C function that calls the class method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;FOUNDATION_EXPORT NMBPredicate *beNil() {&#xA;    return [NMBPredicate beNilMatcher];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Properly Handling &lt;code&gt;nil&lt;/code&gt; in Objective-C Matchers&lt;/h3&gt; &#xA;&lt;p&gt;When supporting Objective-C, make sure you handle &lt;code&gt;nil&lt;/code&gt; appropriately. Like &lt;a href=&#34;https://github.com/pivotal/cedar/issues/100&#34;&gt;Cedar&lt;/a&gt;, &lt;strong&gt;most matchers do not match with nil&lt;/strong&gt;. This is to bring prevent test writers from being surprised by &lt;code&gt;nil&lt;/code&gt; values where they did not expect them.&lt;/p&gt; &#xA;&lt;p&gt;Nimble provides the &lt;code&gt;beNil&lt;/code&gt; matcher function for test writer that want to make expectations on &lt;code&gt;nil&lt;/code&gt; objects:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;// Objective-C&#xA;&#xA;expect(nil).to(equal(nil)); // fails&#xA;expect(nil).to(beNil());    // passes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your matcher does not want to match with nil, you use &lt;code&gt;Predicate.define&lt;/code&gt; or &lt;code&gt;Predicate.simple&lt;/code&gt;. Using those factory methods will automatically generate expected value failure messages when they&#39;re nil.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public func beginWith&amp;lt;S: Sequence&amp;gt;(_ startingElement: S.Element) -&amp;gt; Predicate&amp;lt;S&amp;gt; where S.Element: Equatable {&#xA;    return Predicate.simple(&#34;begin with &amp;lt;\(startingElement)&amp;gt;&#34;) { actualExpression in&#xA;        guard let actualValue = try actualExpression.evaluate() else { return .fail }&#xA;&#xA;        var actualGenerator = actualValue.makeIterator()&#xA;        return PredicateStatus(bool: actualGenerator.next() == startingElement)&#xA;    }&#xA;}&#xA;&#xA;extension NMBPredicate {&#xA;    @objc public class func beginWithMatcher(_ expected: Any) -&amp;gt; NMBPredicate {&#xA;        return NMBPredicate { actualExpression in&#xA;            let actual = try actualExpression.evaluate()&#xA;            let expr = actualExpression.cast { $0 as? NMBOrderedCollection }&#xA;            return try beginWith(expected).satisfies(expr).toObjectiveC()&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Migrating from the Old Matcher API&lt;/h2&gt; &#xA;&lt;p&gt;Previously (&lt;code&gt;&amp;lt;7.0.0&lt;/code&gt;), Nimble supported matchers via the following types:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Matcher&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NonNilMatcherFunc&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MatcherFunc&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All of those types have been replaced by &lt;code&gt;Predicate&lt;/code&gt;. The old API has been removed completely in Nimble v10.&lt;/p&gt; &#xA;&lt;h1&gt;Installing Nimble&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Nimble can be used on its own, or in conjunction with its sister project, &lt;a href=&#34;https://github.com/Quick/Quick&#34;&gt;Quick&lt;/a&gt;. To install both Quick and Nimble, follow &lt;a href=&#34;https://github.com/Quick/Quick/raw/main/Documentation/en-us/InstallingQuick.md&#34;&gt;the installation instructions in the Quick Documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Nimble can currently be installed in one of two ways: using CocoaPods, or with git submodules.&lt;/p&gt; &#xA;&lt;h2&gt;Installing Nimble as a Submodule&lt;/h2&gt; &#xA;&lt;p&gt;To use Nimble as a submodule to test your macOS, iOS or tvOS applications, follow these 4 easy steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone the Nimble repository&lt;/li&gt; &#xA; &lt;li&gt;Add Nimble.xcodeproj to the Xcode workspace for your project&lt;/li&gt; &#xA; &lt;li&gt;Link Nimble.framework to your test target&lt;/li&gt; &#xA; &lt;li&gt;Start writing expectations!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For more detailed instructions on each of these steps, read &lt;a href=&#34;https://github.com/Quick/Quick#how-to-install-quick&#34;&gt;How to Install Quick&lt;/a&gt;. Ignore the steps involving adding Quick to your project in order to install just Nimble.&lt;/p&gt; &#xA;&lt;h2&gt;Installing Nimble via CocoaPods&lt;/h2&gt; &#xA;&lt;p&gt;To use Nimble in CocoaPods to test your macOS, iOS or tvOS applications, add Nimble to your podfile and add the &lt;code&gt;use_frameworks!&lt;/code&gt; line to enable Swift support for CocoaPods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;platform :ios, &#39;8.0&#39;&#xA;&#xA;source &#39;https://github.com/CocoaPods/Specs.git&#39;&#xA;&#xA;# Whatever pods you need for your app go here&#xA;&#xA;target &#39;YOUR_APP_NAME_HERE_Tests&#39;, :exclusive =&amp;gt; true do&#xA;  use_frameworks!&#xA;  pod &#39;Nimble&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally run &lt;code&gt;pod install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Using Nimble without XCTest&lt;/h2&gt; &#xA;&lt;p&gt;Nimble is integrated with XCTest to allow it work well when used in Xcode test bundles, however it can also be used in a standalone app. After installing Nimble using one of the above methods, there are two additional steps required to make this work.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a custom assertion handler and assign an instance of it to the global &lt;code&gt;NimbleAssertionHandler&lt;/code&gt; variable. For example:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class MyAssertionHandler : AssertionHandler {&#xA;    func assert(assertion: Bool, message: FailureMessage, location: SourceLocation) {&#xA;        if (!assertion) {&#xA;            print(&#34;Expectation failed: \(message.stringValue)&#34;)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Somewhere before you use any assertions&#xA;NimbleAssertionHandler = MyAssertionHandler()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Add a post-build action to fix an issue with the Swift XCTest support library being unnecessarily copied into your app&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Edit your scheme in Xcode, and navigate to Build -&amp;gt; Post-actions&lt;/li&gt; &#xA; &lt;li&gt;Click the &#34;+&#34; icon and select &#34;New Run Script Action&#34;&lt;/li&gt; &#xA; &lt;li&gt;Open the &#34;Provide build settings from&#34; dropdown and select your target&lt;/li&gt; &#xA; &lt;li&gt;Enter the following script contents:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;rm &#34;${SWIFT_STDLIB_TOOL_DESTINATION_DIR}/libswiftXCTest.dylib&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now use Nimble assertions in your code and handle failures as you see fit.&lt;/p&gt;</summary>
  </entry>
</feed>