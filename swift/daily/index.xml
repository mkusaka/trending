<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-12T01:46:28Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pointfreeco/swift-identified-collections</title>
    <updated>2023-01-12T01:46:28Z</updated>
    <id>tag:github.com,2023-01-12:/pointfreeco/swift-identified-collections</id>
    <link href="https://github.com/pointfreeco/swift-identified-collections" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A library of data structures for working with collections of identifiable elements in an ergonomic, performant way.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Swift Identified Collections&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://actions-badge.atrox.dev/pointfreeco/swift-identified-collections/goto&#34;&gt;&lt;img src=&#34;https://github.com/pointfreeco/swift-identified-collections/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-identified-collections&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-identified-collections%2Fbadge%3Ftype%3Dswift-versions&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-identified-collections&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-identified-collections%2Fbadge%3Ftype%3Dplatforms&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A library of data structures for working with collections of identifiable elements in an ergonomic, performant way.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;When modeling a collection of elements in your application&#39;s state, it is easy to reach for a standard &lt;code&gt;Array&lt;/code&gt;. However, as your application becomes more complex, this approach can break down in many ways, including accidentally making mutations to the wrong elements or even crashing. üò¨&lt;/p&gt; &#xA;&lt;p&gt;For example, if you were building a &#34;Todos&#34; application in SwiftUI, you might model an individual todo in an identifiable value type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Todo: Identifiable {&#xA;  var description = &#34;&#34;&#xA;  let id: UUID&#xA;  var isComplete = false&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And you would hold an array of these todos as a published field in your app&#39;s view model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class TodosViewModel: ObservableObject {&#xA;  @Published var todos: [Todo] = []&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A view can render a list of these todos quite simply, and because they are identifiable we can even omit the &lt;code&gt;id&lt;/code&gt; parameter of &lt;code&gt;List&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct TodosView: View {&#xA;  @ObservedObject var viewModel: TodosViewModel&#xA;  &#xA;  var body: some View {&#xA;    List(self.viewModel.todos) { todo in&#xA;      ...&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your deployment target is set to the latest version of SwiftUI, you may be tempted to pass along a binding to the list so that each row is given mutable access to its todo. This will work for simple cases, but as soon as you introduce side effects, like API clients or analytics, or want to write unit tests, you must push this logic into a view model, instead. And that means each row must be able to communicate its actions back to the view model.&lt;/p&gt; &#xA;&lt;p&gt;You could do so by introducing some endpoints on the view model, like when a row&#39;s completed toggle is changed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class TodosViewModel: ObservableObject {&#xA;  ...&#xA;  func todoCheckboxToggled(at id: Todo.ID) {&#xA;    guard let index = self.todos.firstIndex(where: { $0.id == id })&#xA;    else { return }&#xA;    &#xA;    self.todos[index].isComplete.toggle()&#xA;    // TODO: Update todo on backend using an API client&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code is simple enough, but it can require a full traversal of the array to do its job.&lt;/p&gt; &#xA;&lt;p&gt;Perhaps it would be more performant for a row to communicate its index back to the view model instead, and then it could mutate the todo directly via its index subscript. But this makes the view more complicated:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;List(self.viewModel.todos.enumerated(), id: \.element.id) { index, todo in&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This isn&#39;t so bad, but at the moment it doesn&#39;t even compile. An &lt;a href=&#34;https://github.com/apple/swift-evolution/raw/main/proposals/0312-indexed-and-enumerated-zip-collections.md&#34;&gt;evolution proposal&lt;/a&gt; may change that soon, but in the meantime &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;ForEach&lt;/code&gt; must be passed a &lt;code&gt;RandomAccessCollection&lt;/code&gt;, which is perhaps most simply achieved by constructing another array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;List(Array(self.viewModel.todos.enumerated()), id: \.element.id) { index, todo in&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This compiles, but we&#39;ve just moved the performance problem to the view: every time this body is evaluated there&#39;s the possibility a whole new array is being allocated.&lt;/p&gt; &#xA;&lt;p&gt;But even if it were possible to pass an enumerated collection directly to these views, identifying an element of mutable state by an index introduces a number of other problems.&lt;/p&gt; &#xA;&lt;p&gt;While it&#39;s true that we can greatly simplify and improve the performance of any view model methods that mutate an element through its index subscript:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class TodosViewModel: ObservableObject {&#xA;  ...&#xA;  func todoCheckboxToggled(at index: Int) {&#xA;    self.todos[index].isComplete.toggle()&#xA;    // TODO: Update todo on backend using an API client&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any asynchronous work that we add to this endpoint must take great care in &lt;em&gt;not&lt;/em&gt; using this index later on. An index is not a stable identifier: todos can be moved and removed at any time, and an index identifying &#34;Buy lettuce&#34; at one moment may identify &#34;Call Mom&#34; the next, or worse, may be a completely invalid index and crash your application!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class TodosViewModel: ObservableObject {&#xA;  ...&#xA;  func todoCheckboxToggled(at index: Int) async {&#xA;    self.todos[index].isComplete.toggle()&#xA;    &#xA;    do {&#xA;      // ‚ùå Could update the wrong todo, or crash!&#xA;      self.todos[index] = try await self.apiClient.updateTodo(self.todos[index]) &#xA;    } catch {&#xA;      // Handle error&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Whenever you need to access a particular todo after performing some asynchronous work, you &lt;em&gt;must&lt;/em&gt; do the work of traversing the array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class TodosViewModel: ObservableObject {&#xA;  ...&#xA;  func todoCheckboxToggled(at index: Int) async {&#xA;    self.todos[index].isComplete.toggle()&#xA;    &#xA;    // 1Ô∏è‚É£ Get a reference to the todo&#39;s id before kicking off the async work&#xA;    let id = self.todos[index].id&#xA;  &#xA;    do {&#xA;      // 2Ô∏è‚É£ Update the todo on the backend&#xA;      let updatedTodo = try await self.apiClient.updateTodo(self.todos[index])&#xA;              &#xA;      // 3Ô∏è‚É£ Find the updated index of the todo after the async work is done&#xA;      let updatedIndex = self.todos.firstIndex(where: { $0.id == id })!&#xA;      &#xA;      // 4Ô∏è‚É£ Update the correct todo&#xA;      self.todos[updatedIndex] = updatedTodo&#xA;    } catch {&#xA;      // Handle error&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Introducing: identified collections&lt;/h2&gt; &#xA;&lt;p&gt;Identified collections are designed to solve all of these problems by providing data structures for working with collections of identifiable elements in an ergonomic, performant way.&lt;/p&gt; &#xA;&lt;p&gt;Most of the time, you can simply swap an &lt;code&gt;Array&lt;/code&gt; out for an &lt;code&gt;IdentifiedArray&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import IdentifiedCollections&#xA;&#xA;class TodosViewModel: ObservableObject {&#xA;  @Published var todos: IdentifiedArrayOf&amp;lt;Todo&amp;gt; = []&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then you can mutate an element directly via its id-based subscript, no traversals needed, even after asynchronous work is performed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class TodosViewModel: ObservableObject {&#xA;  ...&#xA;  func todoCheckboxToggled(at id: Todo.ID) async {&#xA;    self.todos[id: id]?.isComplete.toggle()&#xA;    &#xA;    do {&#xA;      // 1Ô∏è‚É£ Update todo on backend and mutate it in the todos identified array.&#xA;      self.todos[id: id] = try await self.apiClient.updateTodo(self.todos[id: id]!)&#xA;    } catch {&#xA;      // Handle error&#xA;    }&#xA;&#xA;    // No step 2Ô∏è‚É£ üòÜ&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also simply pass the identified array to views like &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;ForEach&lt;/code&gt; without any complications:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;List(self.viewModel.todos) { todo in&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Identified arrays are designed to integrate with SwiftUI applications, as well as applications written in &lt;a href=&#34;https://github.com/pointfreeco/swift-composable-architecture&#34;&gt;the Composable Architecture&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Design&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;IdentifiedArray&lt;/code&gt; is a lightweight wrapper around the &lt;a href=&#34;https://github.com/apple/swift-collections/raw/main/Documentation/OrderedDictionary.md&#34;&gt;&lt;code&gt;OrderedDictionary&lt;/code&gt;&lt;/a&gt; type from Apple&#39;s &lt;a href=&#34;https://github.com/apple/swift-collections&#34;&gt;Swift Collections&lt;/a&gt;. It shares many of the same performance characteristics and design considerations, but is better adapted to solving the problem of holding onto a collection of &lt;em&gt;identifiable&lt;/em&gt; elements in your application&#39;s state.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;IdentifiedArray&lt;/code&gt; does not expose any of the details of &lt;code&gt;OrderedDictionary&lt;/code&gt; that may lead to breaking invariants. For example an &lt;code&gt;OrderedDictionary&amp;lt;ID, Identifiable&amp;gt;&lt;/code&gt; may freely hold a value whose identifier does not match its key or multiple values could have the same id, and &lt;code&gt;IdentifiedArray&lt;/code&gt; does not allow for these situations.&lt;/p&gt; &#xA;&lt;p&gt;And unlike &lt;a href=&#34;https://github.com/apple/swift-collections/raw/main/Documentation/OrderedSet.md&#34;&gt;&lt;code&gt;OrderedSet&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;IdentifiedArray&lt;/code&gt; does not require that its &lt;code&gt;Element&lt;/code&gt; type conforms to the &lt;code&gt;Hashable&lt;/code&gt; protocol, which may be difficult or impossible to do, and introduces questions around the quality of hashing, etc.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;IdentifiedArray&lt;/code&gt; does not even require that its &lt;code&gt;Element&lt;/code&gt; conforms to &lt;code&gt;Identifiable&lt;/code&gt;. Just as SwiftUI&#39;s &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;ForEach&lt;/code&gt; views take an &lt;code&gt;id&lt;/code&gt; key path to an element&#39;s identifier, &lt;code&gt;IdentifiedArray&lt;/code&gt;s can be constructed with a key path:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var numbers = IdentifiedArray(id: \Int.self)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;IdentifiedArray&lt;/code&gt; is designed to match the performance characteristics of &lt;code&gt;OrderedDictionary&lt;/code&gt;. It has been benchmarked with &lt;a href=&#34;https://github.com/apple/swift-collections-benchmark&#34;&gt;Swift Collections Benchmark&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pointfreeco/swift-identified-collections/main/.github/benchmark.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can add Identified Collections to an Xcode project by adding it as a package dependency.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/pointfreeco/swift-identified-collections&#34;&gt;https://github.com/pointfreeco/swift-identified-collections&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If you want to use Identified Collections in a &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;SwiftPM&lt;/a&gt; project, it&#39;s as simple as adding a &lt;code&gt;dependencies&lt;/code&gt; clause to your &lt;code&gt;Package.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;  .package(url: &#34;https://github.com/pointfreeco/swift-identified-collections&#34;, from: &#34;0.6.0&#34;)&#xA;],&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The latest documentation for Identified Collections&#39; APIs is available &lt;a href=&#34;https://pointfreeco.github.io/swift-identified-collections/main/documentation/identifiedcollections/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Interested in learning more?&lt;/h2&gt; &#xA;&lt;p&gt;These concepts (and more) are explored thoroughly in &lt;a href=&#34;https://www.pointfree.co&#34;&gt;Point-Free&lt;/a&gt;, a video series exploring functional programming and Swift hosted by &lt;a href=&#34;https://github.com/mbrandonw&#34;&gt;Brandon Williams&lt;/a&gt; and &lt;a href=&#34;https://github.com/stephencelis&#34;&gt;Stephen Celis&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Usage of &lt;code&gt;IdentifiedArray&lt;/code&gt; in &lt;a href=&#34;https://github.com/pointfreeco/swift-composable-architecture&#34;&gt;the Composable Architecture&lt;/a&gt; was explored in the following &lt;a href=&#34;https://www.pointfree.co&#34;&gt;Point-Free&lt;/a&gt; episode:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.pointfree.co/episodes/ep148-derived-behavior-collections&#34;&gt;Episode 148&lt;/a&gt;: Derived Behavior: Collections&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;a href=&#34;https://www.pointfree.co/episodes/ep148-derived-behavior-collections&#34;&gt; &lt;img alt=&#34;video poster image&#34; src=&#34;https://d3rccdn33rt8ze.cloudfront.net/episodes/0148.jpeg&#34; width=&#34;480&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;All modules are released under the MIT license. See &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-identified-collections/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
</feed>