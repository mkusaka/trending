<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-18T01:38:07Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>RxSwiftCommunity/RxSwiftExt</title>
    <updated>2023-08-18T01:38:07Z</updated>
    <id>tag:github.com,2023-08-18:/RxSwiftCommunity/RxSwiftExt</id>
    <link href="https://github.com/RxSwiftCommunity/RxSwiftExt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A collection of Rx operators &amp; tools not found in the core RxSwift distribution&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://circleci.com/gh/RxSwiftCommunity/RxSwiftExt/tree/main&#34;&gt;&lt;img src=&#34;https://img.shields.io/circleci/project/github/RxSwiftCommunity/RxSwiftExt/main.svg?sanitize=true&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/cocoapods/v/RxSwiftExt.svg?sanitize=true&#34; alt=&#34;pod&#34;&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;RxSwiftExt&lt;/h1&gt; &#xA;&lt;p&gt;If you&#39;re using &lt;a href=&#34;https://github.com/ReactiveX/RxSwift&#34;&gt;RxSwift&lt;/a&gt;, you may have encountered situations where the built-in operators do not bring the exact functionality you want. The RxSwift core is being intentionally kept as compact as possible to avoid bloat. This repository&#39;s purpose is to provide additional convenience operators and Reactive Extensions.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;This branch of RxSwiftExt targets Swift 5.x and RxSwift 5.0.0 or later.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you&#39;re looking for the Swift 4 version of RxSwiftExt, please use version &lt;code&gt;3.4.0&lt;/code&gt; of the framework.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;CocoaPods&lt;/h4&gt; &#xA;&lt;p&gt;Add to your &lt;code&gt;Podfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;RxSwiftExt&#39;, &#39;~&amp;gt; 5&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will install both the &lt;code&gt;RxSwift&lt;/code&gt; and &lt;code&gt;RxCocoa&lt;/code&gt; extensions. If you&#39;re interested in only installing the &lt;code&gt;RxSwift&lt;/code&gt; extensions, without the &lt;code&gt;RxCocoa&lt;/code&gt; extensions, simply use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;RxSwiftExt/Core&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using Swift 4:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;RxSwiftExt&#39;, &#39;~&amp;gt; 3&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Carthage&lt;/h4&gt; &#xA;&lt;p&gt;Add this to your &lt;code&gt;Cartfile&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;RxSwiftCommunity/RxSwiftExt&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Operators&lt;/h1&gt; &#xA;&lt;p&gt;RxSwiftExt is all about adding operators and Reactive Extensions to &lt;a href=&#34;https://github.com/ReactiveX/RxSwift&#34;&gt;RxSwift&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;Operators&lt;/h2&gt; &#xA;&lt;p&gt;These operators are much like the RxSwift &amp;amp; RxCocoa core operators, but provide additional useful abilities to your Rx arsenal.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#unwrap&#34;&gt;unwrap&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#ignore&#34;&gt;ignore&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#ignorewhen&#34;&gt;ignoreWhen&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#once&#34;&gt;Observable.once&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#distinct&#34;&gt;distinct&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#map&#34;&gt;map&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#not&#34;&gt;not&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#and&#34;&gt;and&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#cascade&#34;&gt;Observable.cascade&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#pairwise&#34;&gt;pairwise&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#nwise&#34;&gt;nwise&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#retry&#34;&gt;retry&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#repeatwithbehavior&#34;&gt;repeatWithBehavior&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#catcherrorjustcomplete&#34;&gt;catchErrorJustComplete&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#pausable&#34;&gt;pausable&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#pausablebuffered&#34;&gt;pausableBuffered&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#apply&#34;&gt;apply&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#filtermap&#34;&gt;filterMap&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#fromasync&#34;&gt;Observable.fromAsync&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#zipwith&#34;&gt;Observable.zip(with:)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#mergewith&#34;&gt;Observable.merge(with:)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#count&#34;&gt;count&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#partition&#34;&gt;partition&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#bufferWithTrigger&#34;&gt;bufferWithTrigger&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There are two more available operators for &lt;code&gt;materialize()&lt;/code&gt;&#39;d sequences:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#errors-elements&#34;&gt;errors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#errors-elements&#34;&gt;elements&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Read below for details about each operator.&lt;/p&gt; &#xA;&lt;h2&gt;Reactive Extensions&lt;/h2&gt; &#xA;&lt;p&gt;RxSwift/RxCocoa Reactive Extensions are provided to enhance existing objects and classes from the Apple-ecosystem with Reactive abilities.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#uiviewpropertyanimatoranimate&#34;&gt;UIViewPropertyAnimator.animate&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#uiscrollviewreachedbottom&#34;&gt;UIScrollView.reachedBottom&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Operator details&lt;/h1&gt; &#xA;&lt;h4&gt;unwrap&lt;/h4&gt; &#xA;&lt;p&gt;Unwrap optionals and filter out nil values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  Observable.of(1,2,nil,Int?(4))&#xA;    .unwrap()&#xA;    .subscribe { print($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next(1)&#xA;next(2)&#xA;next(4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ignore&lt;/h4&gt; &#xA;&lt;p&gt;Ignore specific elements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  Observable.from([&#34;One&#34;,&#34;Two&#34;,&#34;Three&#34;])&#xA;    .ignore(&#34;Two&#34;)&#xA;    .subscribe { print($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next(One)&#xA;next(Three)&#xA;completed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ignoreWhen&lt;/h4&gt; &#xA;&lt;p&gt;Ignore elements according to closure.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  Observable&amp;lt;Int&amp;gt;&#xA;    .of(1,2,3,4,5,6)&#xA;    .ignoreWhen { $0 &amp;gt; 2 &amp;amp;&amp;amp; $0 &amp;lt; 6 }&#xA;    .subscribe { print($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next(1)&#xA;next(2)&#xA;next(6)&#xA;completed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;once&lt;/h4&gt; &#xA;&lt;p&gt;Send a next element exactly once to the first subscriber that takes it. Further subscribers get an empty sequence.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  let obs = Observable.once(&#34;Hello world&#34;)&#xA;  print(&#34;First&#34;)&#xA;  obs.subscribe { print($0) }&#xA;  print(&#34;Second&#34;)&#xA;  obs.subscribe { print($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;First&#xA;next(Hello world)&#xA;completed&#xA;Second&#xA;completed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;distinct&lt;/h4&gt; &#xA;&lt;p&gt;Pass elements through only if they were never seen before in the sequence.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Observable.of(&#34;a&#34;,&#34;b&#34;,&#34;a&#34;,&#34;c&#34;,&#34;b&#34;,&#34;a&#34;,&#34;d&#34;)&#xA;    .distinct()&#xA;    .subscribe { print($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next(a)&#xA;next(b)&#xA;next(c)&#xA;next(d)&#xA;completed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;mapTo&lt;/h4&gt; &#xA;&lt;p&gt;Replace every element with the provided value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Observable.of(1,2,3)&#xA;    .mapTo(&#34;Nope.&#34;)&#xA;    .subscribe { print($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next(Nope.)&#xA;next(Nope.)&#xA;next(Nope.)&#xA;completed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;mapAt&lt;/h4&gt; &#xA;&lt;p&gt;Transform every element to the value at the provided key path.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Person {&#xA;    let name: String&#xA;}&#xA;&#xA;Observable&#xA;    .of(&#xA;        Person(name: &#34;Bart&#34;),&#xA;        Person(name: &#34;Lisa&#34;),&#xA;        Person(name: &#34;Maggie&#34;)&#xA;    )&#xA;    .mapAt(\.name)&#xA;    .subscribe { print($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next(Bart)&#xA;next(Lisa)&#xA;next(Maggie)&#xA;completed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;not&lt;/h4&gt; &#xA;&lt;p&gt;Negate booleans.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Observable.just(false)&#xA;    .not()&#xA;    .subscribe { print($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next(true)&#xA;completed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;and&lt;/h4&gt; &#xA;&lt;p&gt;Verifies that every value emitted is &lt;code&gt;true&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Observable.of(true, true)&#xA;&#x9;.and()&#xA;&#x9;.subscribe { print($0) }&#xA;&#xA;Observable.of(true, false)&#xA;&#x9;.and()&#xA;&#x9;.subscribe { print($0) }&#xA;&#xA;Observable&amp;lt;Bool&amp;gt;.empty()&#xA;&#x9;.and()&#xA;&#x9;.subscribe { print($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Returns a &lt;code&gt;Maybe&amp;lt;Bool&amp;gt;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;success(true)&#xA;success(false)&#xA;completed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;cascade&lt;/h4&gt; &#xA;&lt;p&gt;Sequentially cascade through a list of observables, dropping previous subscriptions as soon as an observable further down the list starts emitting elements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let a = PublishSubject&amp;lt;String&amp;gt;()&#xA;let b = PublishSubject&amp;lt;String&amp;gt;()&#xA;let c = PublishSubject&amp;lt;String&amp;gt;()&#xA;Observable.cascade([a,b,c])&#xA;    .subscribe { print($0) }&#xA;a.onNext(&#34;a:1&#34;)&#xA;a.onNext(&#34;a:2&#34;)&#xA;b.onNext(&#34;b:1&#34;)&#xA;a.onNext(&#34;a:3&#34;)&#xA;c.onNext(&#34;c:1&#34;)&#xA;a.onNext(&#34;a:4&#34;)&#xA;b.onNext(&#34;b:4&#34;)&#xA;c.onNext(&#34;c:2&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next(a:1)&#xA;next(a:2)&#xA;next(b:1)&#xA;next(c:1)&#xA;next(c:2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;pairwise&lt;/h4&gt; &#xA;&lt;p&gt;Groups elements emitted by an Observable into arrays, where each array consists of the last 2 consecutive items; similar to a sliding window.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Observable.from([1, 2, 3, 4, 5, 6])&#xA;    .pairwise()&#xA;    .subscribe { print($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next((1, 2))&#xA;next((2, 3))&#xA;next((3, 4))&#xA;next((4, 5))&#xA;next((5, 6))&#xA;completed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;nwise&lt;/h4&gt; &#xA;&lt;p&gt;Groups elements emitted by an Observable into arrays, where each array consists of the last N consecutive items; similar to a sliding window.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Observable.from([1, 2, 3, 4, 5, 6])&#xA;    .nwise(3)&#xA;    .subscribe { print($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next([1, 2, 3])&#xA;next([2, 3, 4])&#xA;next([3, 4, 5])&#xA;next([4, 5, 6])&#xA;completed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;retry&lt;/h4&gt; &#xA;&lt;p&gt;Repeats the source observable sequence using given behavior in case of an error or until it successfully terminated. There are four behaviors with various predicate and delay options: &lt;code&gt;immediate&lt;/code&gt;, &lt;code&gt;delayed&lt;/code&gt;, &lt;code&gt;exponentialDelayed&lt;/code&gt; and &lt;code&gt;customTimerDelayed&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// in case of an error initial delay will be 1 second,&#xA;// every next delay will be doubled&#xA;// delay formula is: initial * pow(1 + multiplier, Double(currentAttempt - 1)), so multiplier 1.0 means, delay will doubled&#xA;_ = sampleObservable.retry(.exponentialDelayed(maxCount: 3, initial: 1.0, multiplier: 1.0), scheduler: delayScheduler)&#xA;    .subscribe(onNext: { event in&#xA;        print(&#34;Receive event: \(event)&#34;)&#xA;    }, onError: { error in&#xA;        print(&#34;Receive error: \(error)&#34;)&#xA;    })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;Receive event: First&#xA;Receive event: Second&#xA;Receive event: First&#xA;Receive event: Second&#xA;Receive event: First&#xA;Receive event: Second&#xA;Receive error: fatalError&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;repeatWithBehavior&lt;/h4&gt; &#xA;&lt;p&gt;Repeats the source observable sequence using given behavior when it completes. This operator takes the same parameters as the &lt;a href=&#34;https://raw.githubusercontent.com/RxSwiftCommunity/RxSwiftExt/main/#retry&#34;&gt;retry&lt;/a&gt; operator. There are four behaviors with various predicate and delay options: &lt;code&gt;immediate&lt;/code&gt;, &lt;code&gt;delayed&lt;/code&gt;, &lt;code&gt;exponentialDelayed&lt;/code&gt; and &lt;code&gt;customTimerDelayed&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// when the sequence completes initial delay will be 1 second,&#xA;// every next delay will be doubled&#xA;// delay formula is: initial * pow(1 + multiplier, Double(currentAttempt - 1)), so multiplier 1.0 means, delay will doubled&#xA;_ = completingObservable.repeatWithBehavior(.exponentialDelayed(maxCount: 3, initial: 1.0, multiplier: 1.2), scheduler: delayScheduler)&#xA;    .subscribe(onNext: { event in&#xA;        print(&#34;Receive event: \(event)&#34;)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;Receive event: First&#xA;Receive event: Second&#xA;Receive event: First&#xA;Receive event: Second&#xA;Receive event: First&#xA;Receive event: Second&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;catchErrorJustComplete&lt;/h4&gt; &#xA;&lt;p&gt;Completes a sequence when an error occurs, dismissing the error condition&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let _ = sampleObservable&#xA;    .do(onError: { print(&#34;Source observable emitted error \($0), ignoring it&#34;) })&#xA;    .catchErrorJustComplete()&#xA;    .subscribe {&#xA;        print (&#34;\($0)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next(First)&#xA;next(Second)&#xA;Source observable emitted error fatalError, ignoring it&#xA;completed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;pausable&lt;/h4&gt; &#xA;&lt;p&gt;Pauses the elements of the source observable sequence unless the latest element from the second observable sequence is &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let observable = Observable&amp;lt;Int&amp;gt;.interval(1, scheduler: MainScheduler.instance)&#xA;&#xA;let trueAtThreeSeconds = Observable&amp;lt;Int&amp;gt;.timer(3, scheduler: MainScheduler.instance).map { _ in true }&#xA;let falseAtFiveSeconds = Observable&amp;lt;Int&amp;gt;.timer(5, scheduler: MainScheduler.instance).map { _ in false }&#xA;let pauser = Observable.of(trueAtThreeSeconds, falseAtFiveSeconds).merge()&#xA;&#xA;let pausedObservable = observable.pausable(pauser)&#xA;&#xA;let _ = pausedObservable&#xA;    .subscribe { print($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next(2)&#xA;next(3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More examples are available in the project&#39;s Playground.&lt;/p&gt; &#xA;&lt;h4&gt;pausableBuffered&lt;/h4&gt; &#xA;&lt;p&gt;Pauses the elements of the source observable sequence unless the latest element from the second observable sequence is &lt;code&gt;true&lt;/code&gt;. Elements emitted by the source observable are buffered (with a configurable limit) and &#34;flushed&#34; (re-emitted) when the observable resumes.&lt;/p&gt; &#xA;&lt;p&gt;Examples are available in the project&#39;s Playground.&lt;/p&gt; &#xA;&lt;h4&gt;apply&lt;/h4&gt; &#xA;&lt;p&gt;Apply provides a unified mechanism for applying transformations on Observable sequences, without having to extend ObservableType or repeating your transformations. For additional rationale for this see &lt;a href=&#34;https://github.com/RxSwiftCommunity/RxSwiftExt/issues/73&#34;&gt;discussion on github&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// An ordinary function that applies some operators to its argument, and returns the resulting Observable&#xA;func requestPolicy(_ request: Observable&amp;lt;Void&amp;gt;) -&amp;gt; Observable&amp;lt;Response&amp;gt; {&#xA;    return request.retry(maxAttempts)&#xA;        .do(onNext: sideEffect)&#xA;        .map { Response.success }&#xA;        .catchError { error in Observable.just(parseRequestError(error: error)) }&#xA;&#xA;// We can apply the function in the apply operator, which preserves the chaining style of invoking Rx operators&#xA;let resilientRequest = request.apply(requestPolicy)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;filterMap&lt;/h4&gt; &#xA;&lt;p&gt;A common pattern in Rx is to filter out some values, then map the remaining ones to something else. &lt;code&gt;filterMap&lt;/code&gt; allows you to do this in one step:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// keep only even numbers and double them&#xA;Observable.of(1,2,3,4,5,6)&#xA;&#x9;.filterMap { number in&#xA;&#x9;&#x9;(number % 2 == 0) ? .ignore : .map(number * 2)&#xA;&#x9;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The sequence above keeps even numbers 2, 4, 6 and produces the sequence 4, 8, 12.&lt;/p&gt; &#xA;&lt;h4&gt;errors, elements&lt;/h4&gt; &#xA;&lt;p&gt;These operators only apply to observable sequences that have been materialized with the &lt;code&gt;materialize()&lt;/code&gt; operator (from RxSwift core). &lt;code&gt;errors&lt;/code&gt; returns a sequence of filtered error events, ommitting elements. &lt;code&gt;elements&lt;/code&gt; returns a sequence of filtered element events, ommitting errors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageResult = _chooseImageButtonPressed.asObservable()&#xA;    .flatMap { imageReceiver.image.materialize() }&#xA;    .share()&#xA;&#xA;let image = imageResult&#xA;    .elements()&#xA;    .asDriver(onErrorDriveWith: .never())&#xA;&#xA;let errorMessage = imageResult&#xA;    .errors()&#xA;    .map(mapErrorMessages)&#xA;    .unwrap()&#xA;    .asDriver(onErrorDriveWith: .never())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;fromAsync&lt;/h4&gt; &#xA;&lt;p&gt;Turns simple asynchronous completion handlers into observable sequences. Suitable for use with existing asynchronous services which call a completion handler with only one parameter. Emits the result produced by the completion handler then completes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func someAsynchronousService(arg1: String, arg2: Int, completionHandler:(String) -&amp;gt; Void) {&#xA;    // a service that asynchronously calls&#xA;&#x9;// the given completionHandler&#xA;}&#xA;&#xA;let observableService = Observable&#xA;    .fromAsync(someAsynchronousService)&#xA;&#xA;observableService(&#34;Foo&#34;, 0)&#xA;    .subscribe(onNext: { (result) in&#xA;        print(result)&#xA;    })&#xA;    .disposed(by: disposeBag)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;zip(with:)&lt;/h4&gt; &#xA;&lt;p&gt;Convenience version of &lt;code&gt;Observable.zip(_:)&lt;/code&gt;. Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let first = Observable.from(numbers)&#xA;let second = Observable.from(strings)&#xA;&#xA;first.zip(with: second) { i, s in&#xA;        s + String(i)&#xA;    }.subscribe(onNext: { (result) in&#xA;        print(result)&#xA;    })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next(&#34;a1&#34;)&#xA;next(&#34;b2&#34;)&#xA;next(&#34;c3&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;merge(with:)&lt;/h4&gt; &#xA;&lt;p&gt;Convenience version of &lt;code&gt;Observable.merge(_:)&lt;/code&gt;. Merges elements from the observable sequence with those of a different observable sequences into a single observable sequence.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let oddStream = Observable.of(1, 3, 5)&#xA;let evenStream = Observable.of(2, 4, 6)&#xA;let otherStream = Observable.of(1, 5, 6)&#xA;&#xA;oddStream.merge(with: evenStream, otherStream)&#xA;    .subscribe(onNext: { result in&#xA;        print(result)&#xA;    })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;1 2 1 3 4 5 5 6 6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ofType&lt;/h4&gt; &#xA;&lt;p&gt;The ofType operator filters the elements of an observable sequence, if that is an instance of the supplied type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Observable.of(NSNumber(value: 1),&#xA;                  NSDecimalNumber(string: &#34;2&#34;),&#xA;                  NSNumber(value: 3),&#xA;                  NSNumber(value: 4),&#xA;                  NSDecimalNumber(string: &#34;5&#34;),&#xA;                  NSNumber(value: 6))&#xA;        .ofType(NSDecimalNumber.self)&#xA;        .subscribe { print($0) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next(2)&#xA;next(5)&#xA;completed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This example emits 2, 5 (&lt;code&gt;NSDecimalNumber&lt;/code&gt; Type).&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;http://reactivex.io/documentation/operators/count.html&#34;&gt;count&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Emits the number of items emitted by an Observable once it terminates with no errors. If a predicate is given, only elements matching the predicate will be counted.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Observable.from([1, 2, 3, 4, 5, 6])&#xA;    .count { $0 % 2 == 0 }&#xA;    .subscribe()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;next(3)&#xA;completed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;partition&lt;/h4&gt; &#xA;&lt;p&gt;Partition a stream into two separate streams of elements that match, and don&#39;t match, the provided predicate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let numbers = Observable&#xA;        .of(1, 2, 3, 4, 5, 6)&#xA;&#xA;    let (evens, odds) = numbers.partition { $0 % 2 == 0 }&#xA;&#xA;    _ = evens.debug(&#34;even&#34;).subscribe() // emits 2, 4, 6&#xA;    _ = odds.debug(&#34;odds&#34;).subscribe() // emits 1, 3, 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;bufferWithTrigger&lt;/h4&gt; &#xA;&lt;p&gt;Collects the elements of the source observable, and emits them as an array when the trigger emits.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let observable = Observable&amp;lt;Int&amp;gt;.interval(1, scheduler: MainScheduler.instance)&#xA;let signalAtThreeSeconds = Observable&amp;lt;Int&amp;gt;.timer(3, scheduler: MainScheduler.instance).map { _ in () }&#xA;let signalAtFiveSeconds = Observable&amp;lt;Int&amp;gt;.timer(5, scheduler: MainScheduler.instance).map { _ in () }&#xA;let trigger = Observable.of(signalAtThreeSeconds, signalAtFiveSeconds).merge()&#xA;let buffered = observable.bufferWithTrigger(trigger)&#xA;buffered.subscribe { print($0) }&#xA;// prints next([0, 1, 2]) @ 3, next([3, 4]) @ 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A live demonstration is available in the Playground.&lt;/p&gt; &#xA;&lt;h1&gt;Reactive Extensions details&lt;/h1&gt; &#xA;&lt;h4&gt;UIViewPropertyAnimator.animate&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;animate(afterDelay:)&lt;/code&gt; operator provides a Completable that triggers the animation upon subscription and completes when the animation ends.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;button.rx.tap&#xA;    .flatMap {&#xA;        animator1.rx.animate()&#xA;            .andThen(animator2.rx.animate(afterDelay: 0.15))&#xA;            .andThen(animator3.rx.animate(afterDelay: 0.1))&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;UIViewPropertyAnimator.fractionComplete&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;fractionComplete&lt;/code&gt; binder provides a reactive way to bind to &lt;code&gt;UIViewPropertyAnimator.fractionComplete&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;slider.rx.value.map(CGFloat.init)&#xA;    .bind(to: animator.rx.fractionComplete)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;UIScrollView.reachedBottom&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;reachedBottom&lt;/code&gt; provides a sequence that emits every time the &lt;code&gt;UIScrollView&lt;/code&gt; is scrolled to the bottom, with an optional offset.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;tableView.rx.reachedBottom(offset: 40)&#xA;            .subscribe { print(&#34;Reached bottom&#34;) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library belongs to &lt;em&gt;RxSwift Community&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;RxSwiftExt is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;</summary>
  </entry>
</feed>