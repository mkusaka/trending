<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-18T01:34:28Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>swiftlang/swift-format</title>
    <updated>2024-08-18T01:34:28Z</updated>
    <id>tag:github.com,2024-08-18:/swiftlang/swift-format</id>
    <link href="https://github.com/swiftlang/swift-format" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Formatting technology for Swift source code&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;swift-format&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;swift-format&lt;/code&gt; provides the formatting technology for &lt;a href=&#34;https://github.com/swiftlang/sourcekit-lsp&#34;&gt;SourceKit-LSP&lt;/a&gt; and the building blocks for doing code formatting transformations.&lt;/p&gt; &#xA;&lt;p&gt;This package can be used as a &lt;a href=&#34;https://raw.githubusercontent.com/swiftlang/swift-format/main/#command-line-usage&#34;&gt;command line tool&lt;/a&gt; or linked into other applications as a Swift Package Manager dependency and invoked via an &lt;a href=&#34;https://raw.githubusercontent.com/swiftlang/swift-format/main/#api-usage&#34;&gt;API&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;NOTE: No default Swift code style guidelines have yet been proposed. The style that is currently applied by &lt;code&gt;swift-format&lt;/code&gt; is just one possibility, and the code is provided so that it can be tested on real-world code and experiments can be made by modifying it.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Matching swift-format to Your Swift Version&lt;/h2&gt; &#xA;&lt;h3&gt;Swift 5.8 and later&lt;/h3&gt; &#xA;&lt;p&gt;As of Swift 5.8, swift-format depends on the version of &lt;a href=&#34;https://github.com/swiftlang/swift-syntax&#34;&gt;SwiftSyntax&lt;/a&gt; whose parser has been rewritten in Swift and no longer has dependencies on libraries in the Swift toolchain.&lt;/p&gt; &#xA;&lt;p&gt;This change allows &lt;code&gt;swift-format&lt;/code&gt; to be built, developed, and run using any version of Swift that can compile it, decoupling it from the version that supported a particular syntax. However, earlier versions of swift-format will still not be able to recognize new syntax added in later versions of the language and parser.&lt;/p&gt; &#xA;&lt;p&gt;Note also that the version numbering scheme has changed to match SwiftSyntax; the 5.8 release of swift-format is &lt;code&gt;508.0.0&lt;/code&gt;, not &lt;code&gt;0.50800.0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Swift 5.7 and earlier&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;swift-format&lt;/code&gt; versions 0.50700.0 and earlier depend on versions of &lt;a href=&#34;https://github.com/swiftlang/swift-syntax&#34;&gt;SwiftSyntax&lt;/a&gt; that used a standalone parsing library distributed as part of the Swift toolchain. When using these versions, you should check out and build &lt;code&gt;swift-format&lt;/code&gt; from the release tag or branch that is compatible with the version of Swift you are using.&lt;/p&gt; &#xA;&lt;p&gt;The major and minor version components of &lt;code&gt;swift-format&lt;/code&gt; and SwiftSyntax must be the same—this is expressed in the &lt;code&gt;SwiftSyntax&lt;/code&gt; dependency in &lt;a href=&#34;https://raw.githubusercontent.com/swiftlang/swift-format/main/Package.swift&#34;&gt;Package.swift&lt;/a&gt;—and those version components must match the Swift toolchain that is installed and used to build and run the formatter:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Xcode Release&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Swift Version&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;&lt;code&gt;swift-format&lt;/code&gt; Branch / Tags&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;–&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Swift at &lt;code&gt;main&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;main&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Xcode 14.0&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Swift 5.7&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;release/5.7&lt;/code&gt; / &lt;code&gt;0.50700.x&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Xcode 13.3&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Swift 5.6&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;release/5.6&lt;/code&gt; / &lt;code&gt;0.50600.x&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Xcode 13.0–13.2&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Swift 5.5&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;swift-5.5-branch&lt;/code&gt; / &lt;code&gt;0.50500.x&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Xcode 12.5&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Swift 5.4&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;swift-5.4-branch&lt;/code&gt; / &lt;code&gt;0.50400.x&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Xcode 12.0–12.4&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Swift 5.3&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;swift-5.3-branch&lt;/code&gt; / &lt;code&gt;0.50300.x&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Xcode 11.4–11.7&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Swift 5.2&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;swift-5.2-branch&lt;/code&gt; / &lt;code&gt;0.50200.x&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Xcode 11.0–11.3&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Swift 5.1&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;swift-5.1-branch&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For example, if you are using Xcode 13.3 (Swift 5.6), you will need &lt;code&gt;swift-format&lt;/code&gt; 0.50600.0.&lt;/p&gt; &#xA;&lt;h2&gt;Getting swift-format&lt;/h2&gt; &#xA;&lt;p&gt;If you are mainly interested in using swift-format (rather than developing it), then you can get it in three different ways:&lt;/p&gt; &#xA;&lt;h3&gt;Included in Xcode&lt;/h3&gt; &#xA;&lt;p&gt;Xcode 16 and above include swift-format in the toolchain. You can run &lt;code&gt;swift-format&lt;/code&gt; from anywhere on the system using &lt;code&gt;swift format&lt;/code&gt; (notice the space instead of dash). To find the path at which &lt;code&gt;swift-format&lt;/code&gt; is installed, run &lt;code&gt;xcrun --find swift-format&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Installing via Homebrew&lt;/h3&gt; &#xA;&lt;p&gt;Run &lt;code&gt;brew install swift-format&lt;/code&gt; to install the latest version.&lt;/p&gt; &#xA;&lt;h3&gt;Building from source&lt;/h3&gt; &#xA;&lt;p&gt;Install &lt;code&gt;swift-format&lt;/code&gt; using the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;VERSION=510.1.0  # replace this with the version you need&#xA;git clone https://github.com/swiftlang/swift-format.git&#xA;cd swift-format&#xA;git checkout &#34;tags/$VERSION&#34;&#xA;swift build -c release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the &lt;code&gt;git checkout&lt;/code&gt; command above will leave the repository in a &#34;detached HEAD&#34; state. This is fine if building and running the tool is all you want to do.&lt;/p&gt; &#xA;&lt;p&gt;Once the build has finished, the &lt;code&gt;swift-format&lt;/code&gt; executable will be located at &lt;code&gt;.build/release/swift-format&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To test that the formatter was built successfully and is compatible with your Swift toolchain, you can also run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;swift test --parallel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We recommend using the &lt;code&gt;--parallel&lt;/code&gt; flag to speed up the test run since there are a large number of tests.&lt;/p&gt; &#xA;&lt;h2&gt;Command Line Usage&lt;/h2&gt; &#xA;&lt;p&gt;The general invocation syntax for &lt;code&gt;swift-format&lt;/code&gt; is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;swift-format [SUBCOMMAND] [OPTIONS...] [FILES...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The tool supports a number of subcommands, each of which has its own options and are described below. Descriptions of the subcommands that are available can also be obtained by running &lt;code&gt;swift-format --help&lt;/code&gt;, and the description of a specific subcommand can be obtained by using the &lt;code&gt;--help&lt;/code&gt; flag after the subcommand name; for example, &lt;code&gt;swift-format lint --help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Formatting&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;swift-format [format] [OPTIONS...] [FILES...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;format&lt;/code&gt; subcommand formats one or more Swift source files (or source code from standard input if no file paths are given on the command line). Writing out the &lt;code&gt;format&lt;/code&gt; subcommand is optional; it is the default behavior if no other subcommand is given.&lt;/p&gt; &#xA;&lt;p&gt;This subcommand supports all of the &lt;a href=&#34;https://raw.githubusercontent.com/swiftlang/swift-format/main/#options-supported-by-formatting-and-linting&#34;&gt;common lint and format options&lt;/a&gt;, as well as the formatting-only options below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-i/--in-place&lt;/code&gt;: Overwrites the input files when formatting instead of printing the results to standard output. &lt;em&gt;No backup of the original file is made before it is overwritten.&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Linting&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;swift-format lint [OPTIONS...] [FILES...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;lint&lt;/code&gt; subcommand checks one or more Swift source files (or source code from standard input if no file paths are given on the command line) for style violations and prints diagnostics to standard error for any violations that are detected.&lt;/p&gt; &#xA;&lt;p&gt;This subcommand supports all of the &lt;a href=&#34;https://raw.githubusercontent.com/swiftlang/swift-format/main/#options-supported-by-formatting-and-linting&#34;&gt;common lint and format options&lt;/a&gt;, as well as the linting-only options below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-s/--strict&lt;/code&gt;: If this option is specified, lint warnings will cause the tool to exit with a non-zero exit code (failure). By default, lint warnings do not prevent a successful exit; only fatal errors (for example, trying to lint a file that does not exist) cause the tool to exit unsuccessfully.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Options Supported by Formatting and Linting&lt;/h3&gt; &#xA;&lt;p&gt;The following options are supported by both the &lt;code&gt;format&lt;/code&gt; and &lt;code&gt;lint&lt;/code&gt; subcommands:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--assume-filename &amp;lt;path&amp;gt;&lt;/code&gt;: The file path that should be used in diagnostics when linting or formatting from standard input. If this option is not provided, then &lt;code&gt;&amp;lt;stdin&amp;gt;&lt;/code&gt; will be used as the filename printed in diagnostics.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--color-diagnostics/--no-color-diagnostics&lt;/code&gt;: By default, &lt;code&gt;swift-format&lt;/code&gt; will print diagnostics in color if standard error is connected to a terminal and without color otherwise (for example, if standard error is being redirected to a file). These flags can be used to force colors on or off respectively, regardless of whether the output is going to a terminal.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--configuration &amp;lt;file&amp;gt;&lt;/code&gt;: The path to a JSON file that contains &lt;a href=&#34;https://raw.githubusercontent.com/swiftlang/swift-format/main/#configuring-the-command-line-tool&#34;&gt;configurable settings&lt;/a&gt; for &lt;code&gt;swift-format&lt;/code&gt;. If omitted, a default configuration is use (which can be seen by running &lt;code&gt;swift-format dump-configuration&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--ignore-unparsable-files&lt;/code&gt;: If this option is specified and a source file contains syntax errors or can otherwise not be parsed successfully by the Swift syntax parser, it will be ignored (no diagnostics will be emitted and it will not be formatted). Without this option, an error will be emitted for any unparsable files.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-p/--parallel&lt;/code&gt;: Process files in parallel, simultaneously across multiple cores.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-r/--recursive&lt;/code&gt;: If specified, then the tool will process &lt;code&gt;.swift&lt;/code&gt; source files in any directories listed on the command line and their descendants. Without this flag, it is an error to list a directory on the command line.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Viewing the Default Configuration&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;swift-format dump-configuration&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;dump-configuration&lt;/code&gt; subcommand dumps the default configuration in JSON format to standard output. This can be used to simplify generating a custom configuration, by redirecting it to a file and editing it.&lt;/p&gt; &#xA;&lt;h3&gt;Configuring the Command Line Tool&lt;/h3&gt; &#xA;&lt;p&gt;For any source file being checked or formatted, &lt;code&gt;swift-format&lt;/code&gt; looks for a JSON-formatted file named &lt;code&gt;.swift-format&lt;/code&gt; in the same directory. If one is found, then that file is loaded to determine the tool&#39;s configuration. If the file is not found, then it looks in the parent directory, and so on.&lt;/p&gt; &#xA;&lt;p&gt;If no configuration file is found, a default configuration is used. The settings in the default configuration can be viewed by running &lt;code&gt;swift-format dump-configuration&lt;/code&gt;, which will dump it to standard output.&lt;/p&gt; &#xA;&lt;p&gt;If the &lt;code&gt;--configuration &amp;lt;file&amp;gt;&lt;/code&gt; option is passed to &lt;code&gt;swift-format&lt;/code&gt;, then that configuration will be used unconditionally and the file system will not be searched.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/swiftlang/swift-format/main/Documentation/Configuration.md&#34;&gt;Documentation/Configuration.md&lt;/a&gt; for a description of the configuration file format and the settings that are available.&lt;/p&gt; &#xA;&lt;h3&gt;Miscellaneous&lt;/h3&gt; &#xA;&lt;p&gt;Running &lt;code&gt;swift-format -v&lt;/code&gt; or &lt;code&gt;swift-format --version&lt;/code&gt; will print version information about &lt;code&gt;swift-format&lt;/code&gt; version and then exit.&lt;/p&gt; &#xA;&lt;h2&gt;API Usage&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;swift-format&lt;/code&gt; can be easily integrated into other tools written in Swift. Instead of invoking the formatter by spawning a subprocess, users can depend on &lt;code&gt;swift-format&lt;/code&gt; as a Swift Package Manager dependency and import the &lt;code&gt;SwiftFormat&lt;/code&gt; module, which contains the entry points into the formatter&#39;s diagnostic and correction behavior.&lt;/p&gt; &#xA;&lt;p&gt;Formatting behavior is provided by the &lt;code&gt;SwiftFormatter&lt;/code&gt; class and linting behavior is provided by the &lt;code&gt;SwiftLinter&lt;/code&gt; class. These APIs can be passed either a Swift source file &lt;code&gt;URL&lt;/code&gt; or a &lt;code&gt;Syntax&lt;/code&gt; node representing a SwiftSyntax syntax tree. The latter capability is particularly useful for writing code generators, since it significantly reduces the amount of trivia that the generator needs to be concerned about adding to the syntax nodes it creates. Instead, it can pass the in-memory syntax tree to the &lt;code&gt;SwiftFormat&lt;/code&gt; API and receive perfectly formatted code as output.&lt;/p&gt; &#xA;&lt;p&gt;Please see the documentation in the &lt;a href=&#34;https://raw.githubusercontent.com/swiftlang/swift-format/main/Sources/SwiftFormat/API/SwiftFormatter.swift&#34;&gt;&lt;code&gt;SwiftFormatter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/swiftlang/swift-format/main/Sources/SwiftFormat/API/SwiftLinter.swift&#34;&gt;&lt;code&gt;SwiftLinter&lt;/code&gt;&lt;/a&gt; classes for more information about their usage.&lt;/p&gt; &#xA;&lt;h3&gt;Checking Out the Source Code for Development&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;main&lt;/code&gt; branch is used for development. Pull requests should be created to merge into the &lt;code&gt;main&lt;/code&gt; branch; changes that are low-risk and compatible with the latest release branch may be cherry-picked into that branch after they have been merged into &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you are interested in developing &lt;code&gt;swift-format&lt;/code&gt;, there is additional documentation about that &lt;a href=&#34;https://raw.githubusercontent.com/swiftlang/swift-format/main/Documentation/Development.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions to Swift are welcomed and encouraged! Please see the &lt;a href=&#34;https://swift.org/contributing/&#34;&gt;Contributing to Swift guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Before submitting the pull request, please make sure you have &lt;a href=&#34;https://github.com/apple/swift/raw/main/docs/ContinuousIntegration.md&#34;&gt;tested your changes&lt;/a&gt; and that they follow the Swift project &lt;a href=&#34;https://swift.org/contributing/#contributing-code&#34;&gt;guidelines for contributing code&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To be a truly great community, &lt;a href=&#34;https://swift.org/&#34;&gt;Swift.org&lt;/a&gt; needs to welcome developers from all walks of life, with different backgrounds, and with a wide range of experience. A diverse and friendly community will have more great ideas, more unique perspectives, and produce more great code. We will work diligently to make the Swift community welcoming to everyone.&lt;/p&gt; &#xA;&lt;p&gt;To give clarity of what is expected of our members, Swift has adopted the code of conduct defined by the Contributor Covenant. This document is used across many open source communities, and we think it articulates our values well. For more, see the &lt;a href=&#34;https://swift.org/code-of-conduct/&#34;&gt;Code of Conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>swift-server/swift-aws-lambda-runtime</title>
    <updated>2024-08-18T01:34:28Z</updated>
    <id>tag:github.com,2024-08-18:/swift-server/swift-aws-lambda-runtime</id>
    <link href="https://github.com/swift-server/swift-aws-lambda-runtime" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Swift implementation of AWS Lambda Runtime&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Swift AWS Lambda Runtime&lt;/h1&gt; &#xA;&lt;p&gt;Many modern systems have client components like iOS, macOS or watchOS applications as well as server components that those clients interact with. Serverless functions are often the easiest and most efficient way for client application developers to extend their applications into the cloud.&lt;/p&gt; &#xA;&lt;p&gt;Serverless functions are increasingly becoming a popular choice for running event-driven or otherwise ad-hoc compute tasks in the cloud. They power mission critical microservices and data intensive workloads. In many cases, serverless functions allow developers to more easily scale and control compute costs given their on-demand nature.&lt;/p&gt; &#xA;&lt;p&gt;When using serverless functions, attention must be given to resource utilization as it directly impacts the costs of the system. This is where Swift shines! With its low memory footprint, deterministic performance, and quick start time, Swift is a fantastic match for the serverless functions architecture.&lt;/p&gt; &#xA;&lt;p&gt;Combine this with Swift&#39;s developer friendliness, expressiveness, and emphasis on safety, and we have a solution that is great for developers at all skill levels, scalable, and cost effective.&lt;/p&gt; &#xA;&lt;p&gt;Swift AWS Lambda Runtime was designed to make building Lambda functions in Swift simple and safe. The library is an implementation of the &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html&#34;&gt;AWS Lambda Runtime API&lt;/a&gt; and uses an embedded asynchronous HTTP Client based on &lt;a href=&#34;http://github.com/apple/swift-nio&#34;&gt;SwiftNIO&lt;/a&gt; that is fine-tuned for performance in the AWS Runtime context. The library provides a multi-tier API that allows building a range of Lambda functions: From quick and simple closures to complex, performance-sensitive event handlers.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;If you have never used AWS Lambda or Docker before, check out this &lt;a href=&#34;https://fabianfett.dev/getting-started-with-swift-aws-lambda-runtime&#34;&gt;getting started guide&lt;/a&gt; which helps you with every step from zero to a running Lambda.&lt;/p&gt; &#xA;&lt;p&gt;First, create a SwiftPM project and pull Swift AWS Lambda Runtime as dependency into your project&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// swift-tools-version:5.7&#xA;&#xA;import PackageDescription&#xA;&#xA;let package = Package(&#xA;    name: &#34;MyLambda&#34;,&#xA;    products: [&#xA;        .executable(name: &#34;MyLambda&#34;, targets: [&#34;MyLambda&#34;]),&#xA;    ],&#xA;    dependencies: [&#xA;        .package(url: &#34;https://github.com/swift-server/swift-aws-lambda-runtime.git&#34;, from: &#34;1.0.0-alpha&#34;),&#xA;    ],&#xA;    targets: [&#xA;        .executableTarget(name: &#34;MyLambda&#34;, dependencies: [&#xA;          .product(name: &#34;AWSLambdaRuntime&#34;, package: &#34;swift-aws-lambda-runtime&#34;),&#xA;        ]),&#xA;    ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, create a &lt;code&gt;MyLambda.swift&lt;/code&gt; and implement your Lambda. Note that the file can not be named &lt;code&gt;main.swift&lt;/code&gt; or you will encounter the following error: &lt;code&gt;&#39;main&#39; attribute cannot be used in a module that contains top-level code&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Using async function&lt;/h3&gt; &#xA;&lt;p&gt;The simplest way to use &lt;code&gt;AWSLambdaRuntime&lt;/code&gt; is to use the &lt;code&gt;SimpleLambdaHandler&lt;/code&gt; protocol and pass in an async function, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Import the module&#xA;import AWSLambdaRuntime&#xA;&#xA;@main&#xA;struct MyLambda: SimpleLambdaHandler {&#xA;    // in this example we are receiving and responding with strings&#xA;    func handle(_ name: String, context: LambdaContext) async throws -&amp;gt; String {&#xA;        &#34;Hello, \(name)&#34;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More commonly, the event would be a JSON, which is modeled using &lt;code&gt;Codable&lt;/code&gt;, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Import the module&#xA;import AWSLambdaRuntime&#xA;&#xA;// Request, uses Codable for transparent JSON encoding&#xA;struct Request: Codable {&#xA;  let name: String&#xA;}&#xA;&#xA;// Response, uses Codable for transparent JSON encoding&#xA;struct Response: Codable {&#xA;  let message: String&#xA;}&#xA;&#xA;@main&#xA;struct MyLambda: SimpleLambdaHandler {&#xA;    // In this example we are receiving and responding with `Codable`.&#xA;    func handle(_ request: Request, context: LambdaContext) async throws -&amp;gt; Response {&#xA;        Response(message: &#34;Hello, \(request.name)&#34;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since most Lambda functions are triggered by events originating in the AWS platform like &lt;code&gt;SNS&lt;/code&gt;, &lt;code&gt;SQS&lt;/code&gt; or &lt;code&gt;APIGateway&lt;/code&gt;, the &lt;a href=&#34;http://github.com/swift-server/swift-aws-lambda-events&#34;&gt;Swift AWS Lambda Events&lt;/a&gt; package includes an &lt;code&gt;AWSLambdaEvents&lt;/code&gt; module that provides implementations for most common AWS event types further simplifying writing Lambda functions. For example, handling a &lt;code&gt;SQS&lt;/code&gt; message:&lt;/p&gt; &#xA;&lt;p&gt;First, add a dependency on the event packages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// swift-tools-version:5.7&#xA;&#xA;import PackageDescription&#xA;&#xA;let package = Package(&#xA;    name: &#34;MyLambda&#34;,&#xA;    products: [&#xA;        .executable(name: &#34;MyLambda&#34;, targets: [&#34;MyLambda&#34;]),&#xA;    ],&#xA;    dependencies: [&#xA;        .package(url: &#34;https://github.com/swift-server/swift-aws-lambda-runtime.git&#34;, from: &#34;1.0.0-alpha&#34;),&#xA;        .package(url: &#34;https://github.com/swift-server/swift-aws-lambda-events.git&#34;, branch: &#34;main&#34;),&#xA;    ],&#xA;    targets: [&#xA;        .executableTarget(name: &#34;MyLambda&#34;, dependencies: [&#xA;          .product(name: &#34;AWSLambdaRuntime&#34;, package: &#34;swift-aws-lambda-runtime&#34;),&#xA;          .product(name: &#34;AWSLambdaEvents&#34;, package: &#34;swift-aws-lambda-events&#34;),&#xA;        ]),&#xA;    ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then in your Lambda:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Import the modules&#xA;import AWSLambdaRuntime&#xA;import AWSLambdaEvents&#xA;&#xA;@main&#xA;struct MyLambda: SimpleLambdaHandler {&#xA;    // In this example we are receiving a SQS Event, with no response (Void).&#xA;    func handle(_ event: SQSEvent, context: LambdaContext) async throws {&#xA;        ...&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In some cases, the Lambda needs to do work on initialization. In such cases, use the &lt;code&gt;LambdaHandler&lt;/code&gt; instead of the &lt;code&gt;SimpleLambdaHandler&lt;/code&gt; which has an additional initialization method. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import AWSLambdaRuntime&#xA;&#xA;@main&#xA;struct MyLambda: LambdaHandler {&#xA;    init(context: LambdaInitializationContext) async throws {&#xA;        ...&#xA;    }   &#xA;&#xA;    func handle(_ event: String, context: LambdaContext) async throws -&amp;gt; Void {&#xA;        ...&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Modeling Lambda functions as async functions is both simple and safe. Swift AWS Lambda Runtime will ensure that the user-provided code is offloaded from the network processing thread such that even if the code becomes slow to respond or gets hang, the underlying process can continue to function. This safety comes at a small performance penalty from context switching between threads. In many cases, the simplicity and safety of using the Closure based API is often preferred over the complexity of the performance-oriented API.&lt;/p&gt; &#xA;&lt;h3&gt;Using EventLoopLambdaHandler&lt;/h3&gt; &#xA;&lt;p&gt;Performance sensitive Lambda functions may choose to use a more complex API which allows user code to run on the same thread as the networking handlers. Swift AWS Lambda Runtime uses &lt;a href=&#34;https://github.com/apple/swift-nio&#34;&gt;SwiftNIO&lt;/a&gt; as its underlying networking engine which means the APIs are based on &lt;a href=&#34;https://github.com/apple/swift-nio&#34;&gt;SwiftNIO&lt;/a&gt; concurrency primitives like the &lt;code&gt;EventLoop&lt;/code&gt; and &lt;code&gt;EventLoopFuture&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Import the modules&#xA;import AWSLambdaRuntime&#xA;import AWSLambdaEvents&#xA;import NIOCore&#xA;&#xA;@main&#xA;struct Handler: EventLoopLambdaHandler {&#xA;    typealias Event = SNSEvent.Message // Event / Request type&#xA;    typealias Output = Void // Output / Response type&#xA;&#xA;    static func makeHandler(context: LambdaInitializationContext) -&amp;gt; EventLoopFuture&amp;lt;Self&amp;gt; {&#xA;        context.eventLoop.makeSucceededFuture(Self())&#xA;    }&#xA;&#xA;    // `EventLoopLambdaHandler` does not offload the Lambda processing to a separate thread&#xA;    // while the closure-based handlers do.&#xA;    func handle(_ event: Event, context: LambdaContext) -&amp;gt; EventLoopFuture&amp;lt;Output&amp;gt; {&#xA;        ...&#xA;        context.eventLoop.makeSucceededFuture(Void())&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Beyond the small cognitive complexity of using the &lt;code&gt;EventLoopFuture&lt;/code&gt; based APIs, note these APIs should be used with extra care. An &lt;code&gt;EventLoopLambdaHandler&lt;/code&gt; will execute the user code on the same &lt;code&gt;EventLoop&lt;/code&gt; (thread) as the library, making processing faster but requiring the user code to never call blocking APIs as it might prevent the underlying process from functioning.&lt;/p&gt; &#xA;&lt;h2&gt;Testing Locally&lt;/h2&gt; &#xA;&lt;p&gt;Before deploying your code to AWS Lambda, you can test it locally by setting the &lt;code&gt;LOCAL_LAMBDA_SERVER_ENABLED&lt;/code&gt; environment variable to true. It will look like this on CLI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;LOCAL_LAMBDA_SERVER_ENABLED=true swift run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This starts a local HTTP server listening on port 7000. You can invoke your local Lambda function by sending an HTTP POST request to &lt;code&gt;http://127.0.0.1:7000/invoke&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The request must include the JSON payload expected as an &lt;code&gt;Event&lt;/code&gt; by your function. You can create a text file with the JSON payload documented by AWS or captured from a trace. In this example, we used &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/services-apigateway.html#apigateway-example-event&#34;&gt;the APIGatewayv2 JSON payload from the documentation&lt;/a&gt;, saved as &lt;code&gt;events/create-session.json&lt;/code&gt; text file.&lt;/p&gt; &#xA;&lt;p&gt;Then we use curl to invoke the local endpoint with the test JSON payload.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl -v --header &#34;Content-Type:\ application/json&#34; --data @events/create-session.json http://127.0.0.1:7000/invoke&#xA;*   Trying 127.0.0.1:7000...&#xA;* Connected to 127.0.0.1 (127.0.0.1) port 7000&#xA;&amp;gt; POST /invoke HTTP/1.1&#xA;&amp;gt; Host: 127.0.0.1:7000&#xA;&amp;gt; User-Agent: curl/8.4.0&#xA;&amp;gt; Accept: */*&#xA;&amp;gt; Content-Type:\ application/json&#xA;&amp;gt; Content-Length: 1160&#xA;&amp;gt; &#xA;&amp;lt; HTTP/1.1 200 OK&#xA;&amp;lt; content-length: 247&#xA;&amp;lt; &#xA;* Connection #0 to host 127.0.0.1 left intact&#xA;{&#34;statusCode&#34;:200,&#34;isBase64Encoded&#34;:false,&#34;body&#34;:&#34;...&#34;,&#34;headers&#34;:{&#34;Access-Control-Allow-Origin&#34;:&#34;*&#34;,&#34;Content-Type&#34;:&#34;application\/json; charset=utf-8&#34;,&#34;Access-Control-Allow-Headers&#34;:&#34;*&#34;}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Modifying the local endpoint&lt;/h3&gt; &#xA;&lt;p&gt;By default, when using the local Lambda server, it listens on the &lt;code&gt;/invoke&lt;/code&gt; endpoint.&lt;/p&gt; &#xA;&lt;p&gt;Some testing tools, such as the &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/images-test.html&#34;&gt;AWS Lambda runtime interface emulator&lt;/a&gt;, require a different endpoint. In that case, you can use the &lt;code&gt;LOCAL_LAMBDA_SERVER_INVOCATION_ENDPOINT&lt;/code&gt; environment variable to force the runtime to listen on a different endpoint.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;LOCAL_LAMBDA_SERVER_ENABLED=true LOCAL_LAMBDA_SERVER_INVOCATION_ENDPOINT=/2015-03-31/functions/function/invocations swift run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Increase logging verbosity&lt;/h2&gt; &#xA;&lt;p&gt;You can increase the verbosity of the runtime using the &lt;code&gt;LOG_LEVEL&lt;/code&gt; environment variable.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;LOG_LEVEL=debug&lt;/code&gt; displays information about the Swift AWS Lambda Runtime activity and lifecycle&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;LOG_LEVEL=trace&lt;/code&gt; displays a string representation of the input event as received from the AWS Lambda service (before invoking your handler).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can modify the verbosity of a Lambda function by passing the LOG_LEVEL environment variable both during your local testing (LOG_LEVEL=trace LOCAL_LAMBDA_SERVER_ENABLED=true swift run) or when you deploy your code on AWS Lambda. You can &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html&#34;&gt;define environment variables for your Lambda functions&lt;/a&gt; in the AWS console or programmatically.&lt;/p&gt; &#xA;&lt;p&gt;This repository follows &lt;a href=&#34;https://www.swift.org/server/guides/libraries/log-levels.html&#34;&gt;Swift&#39;s Log Level Guidelines&lt;/a&gt;. At &lt;code&gt;LOG_LEVEL=trace&lt;/code&gt;, the AWS Lambda runtime will display a string representation of the input event as received from the AWS Lambda service before invoking your handler, for maximum debuggability.&lt;/p&gt; &#xA;&lt;h2&gt;Deploying to AWS Lambda&lt;/h2&gt; &#xA;&lt;p&gt;To deploy Lambda functions to AWS Lambda, you need to compile the code for Amazon Linux which is the OS used on AWS Lambda microVMs, package it as a Zip file, and upload to AWS.&lt;/p&gt; &#xA;&lt;p&gt;Swift AWS Lambda Runtime includes a SwiftPM plugin designed to help with the creation of the zip archive. To build and package your Lambda, run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;swift package archive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;archive&lt;/code&gt; command can be customized using the following parameters&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--output-path&lt;/code&gt; A valid file system path where a folder with the archive operation result will be placed. This folder will contain the following elements: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A file link named &lt;code&gt;bootstrap&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;An executable file&lt;/li&gt; &#xA;   &lt;li&gt;A &lt;strong&gt;Zip&lt;/strong&gt; file ready to be uploaded to AWS&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--verbose&lt;/code&gt; A number that sets the command output detail level between the following values: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;0&lt;/code&gt; (Silent)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;1&lt;/code&gt; (Output)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;2&lt;/code&gt; (Debug)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--swift-version&lt;/code&gt; Swift language version used to define the Amazon Linux 2 Docker image. For example &#34;5.7.3&#34;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--base-docker-image&lt;/code&gt; An Amazon Linux 2 docker image name available in your system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--disable-docker-image-update&lt;/code&gt; If flag is set, docker image will not be updated and local image will be used.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Both &lt;code&gt;--swift-version&lt;/code&gt; and &lt;code&gt;--base-docker-image&lt;/code&gt; are mutually exclusive&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;swift package archive --output-path /Users/JohnAppleseed/Desktop --verbose 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This command execution will generate a folder at &lt;code&gt;/Users/JohnAppleseed/Desktop&lt;/code&gt; with the lambda zipped and ready to upload it and set the command detail output level to &lt;code&gt;2&lt;/code&gt; (debug)&lt;/p&gt; &#xA;&lt;p&gt;on macOS, the archiving plugin uses docker to build the Lambda for Amazon Linux 2, and as such requires to communicate with Docker over the localhost network. At the moment, SwiftPM does not allow plugin communication over network, and as such the invocation requires breaking from the SwiftPM plugin sandbox. This limitation would be removed in the future.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; swift package --disable-sandbox archive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;AWS offers several tools to interact and deploy Lambda functions to AWS Lambda including &lt;a href=&#34;https://aws.amazon.com/serverless/sam/&#34;&gt;SAM&lt;/a&gt; and the &lt;a href=&#34;https://aws.amazon.com/cli/&#34;&gt;AWS CLI&lt;/a&gt;. The &lt;a href=&#34;https://raw.githubusercontent.com/swift-server/swift-aws-lambda-runtime/main/Examples&#34;&gt;Examples Directory&lt;/a&gt; includes complete sample build and deployment scripts that utilize these tools.&lt;/p&gt; &#xA;&lt;p&gt;Note the examples mentioned above use dynamic linking, therefore bundle the required Swift libraries in the Zip package along side the executable. You may choose to link the Lambda function statically (using &lt;code&gt;-static-stdlib&lt;/code&gt;) which could improve performance but requires additional linker flags.&lt;/p&gt; &#xA;&lt;p&gt;To build the Lambda function for Amazon Linux 2, use the Docker image published by Swift.org on &lt;a href=&#34;https://swift.org/download/&#34;&gt;Swift toolchains and Docker images for Amazon Linux 2&lt;/a&gt;, as demonstrated in the examples.&lt;/p&gt; &#xA;&lt;h2&gt;Architecture&lt;/h2&gt; &#xA;&lt;p&gt;The library defines four protocols for the implementation of a Lambda Handler. From low-level to more convenient:&lt;/p&gt; &#xA;&lt;h3&gt;ByteBufferLambdaHandler&lt;/h3&gt; &#xA;&lt;p&gt;An &lt;code&gt;EventLoopFuture&lt;/code&gt; based processing protocol for a Lambda that takes a &lt;code&gt;ByteBuffer&lt;/code&gt; and returns a &lt;code&gt;ByteBuffer?&lt;/code&gt; asynchronously.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ByteBufferLambdaHandler&lt;/code&gt; is the lowest level protocol designed to power the higher level &lt;code&gt;EventLoopLambdaHandler&lt;/code&gt; and &lt;code&gt;LambdaHandler&lt;/code&gt; based APIs. Users are not expected to use this protocol, though some performance sensitive applications that operate at the &lt;code&gt;ByteBuffer&lt;/code&gt; level or have special serialization needs may choose to do so.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol ByteBufferLambdaHandler {&#xA;    /// Create a Lambda handler for the runtime.&#xA;    ///&#xA;    /// Use this to initialize all your resources that you want to cache between invocations. This could be database&#xA;    /// connections and HTTP clients for example. It is encouraged to use the given `EventLoop`&#39;s conformance&#xA;    /// to `EventLoopGroup` when initializing NIO dependencies. This will improve overall performance, as it&#xA;    /// minimizes thread hopping.&#xA;    static func makeHandler(context: LambdaInitializationContext) -&amp;gt; EventLoopFuture&amp;lt;Self&amp;gt;&#xA;&#xA;    /// The Lambda handling method.&#xA;    /// Concrete Lambda handlers implement this method to provide the Lambda functionality.&#xA;    ///&#xA;    /// - parameters:&#xA;    ///     - context: Runtime ``LambdaContext``.&#xA;    ///     - event: The event or input payload encoded as `ByteBuffer`.&#xA;    ///&#xA;    /// - Returns: An `EventLoopFuture` to report the result of the Lambda back to the runtime engine.&#xA;    ///            The `EventLoopFuture` should be completed with either a response encoded as `ByteBuffer` or an `Error`.&#xA;    func handle(_ buffer: ByteBuffer, context: LambdaContext) -&amp;gt; EventLoopFuture&amp;lt;ByteBuffer?&amp;gt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;EventLoopLambdaHandler&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;EventLoopLambdaHandler&lt;/code&gt; is a strongly typed, &lt;code&gt;EventLoopFuture&lt;/code&gt; based asynchronous processing protocol for a Lambda that takes a user defined &lt;code&gt;Event&lt;/code&gt; and returns a user defined &lt;code&gt;Output&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;EventLoopLambdaHandler&lt;/code&gt; provides &lt;code&gt;ByteBuffer&lt;/code&gt; -&amp;gt; &lt;code&gt;Event&lt;/code&gt; decoding and &lt;code&gt;Output&lt;/code&gt; -&amp;gt; &lt;code&gt;ByteBuffer?&lt;/code&gt; encoding for &lt;code&gt;Codable&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;EventLoopLambdaHandler&lt;/code&gt; executes the user provided Lambda on the same &lt;code&gt;EventLoop&lt;/code&gt; as the core runtime engine, making the processing fast but requires more care from the implementation to never block the &lt;code&gt;EventLoop&lt;/code&gt;. It it designed for performance sensitive applications that use &lt;code&gt;Codable&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; based Lambda functions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol EventLoopLambdaHandler {&#xA;    /// The lambda functions input. In most cases this should be `Codable`. If your event originates from an&#xA;    /// AWS service, have a look at [AWSLambdaEvents](https://github.com/swift-server/swift-aws-lambda-events),&#xA;    /// which provides a number of commonly used AWS Event implementations.&#xA;    associatedtype Event&#xA;    /// The lambda functions output. Can be `Void`.&#xA;    associatedtype Output&#xA;&#xA;    /// Create a Lambda handler for the runtime.&#xA;    ///&#xA;    /// Use this to initialize all your resources that you want to cache between invocations. This could be database&#xA;    /// connections and HTTP clients for example. It is encouraged to use the given `EventLoop`&#39;s conformance&#xA;    /// to `EventLoopGroup` when initializing NIO dependencies. This will improve overall performance, as it&#xA;    /// minimizes thread hopping.&#xA;    static func makeHandler(context: LambdaInitializationContext) -&amp;gt; EventLoopFuture&amp;lt;Self&amp;gt;&#xA;&#xA;    /// The Lambda handling method.&#xA;    /// Concrete Lambda handlers implement this method to provide the Lambda functionality.&#xA;    ///&#xA;    /// - parameters:&#xA;    ///     - context: Runtime ``LambdaContext``.&#xA;    ///     - event: Event of type `Event` representing the event or request.&#xA;    ///&#xA;    /// - Returns: An `EventLoopFuture` to report the result of the Lambda back to the runtime engine.&#xA;    ///            The `EventLoopFuture` should be completed with either a response of type ``Output`` or an `Error`.&#xA;    func handle(_ event: Event, context: LambdaContext) -&amp;gt; EventLoopFuture&amp;lt;Output&amp;gt;&#xA;&#xA;    /// Encode a response of type ``Output`` to `ByteBuffer`.&#xA;    /// Concrete Lambda handlers implement this method to provide coding functionality.&#xA;    /// - parameters:&#xA;    ///     - value: Response of type ``Output``.&#xA;    ///     - buffer: A `ByteBuffer` to encode into, will be overwritten.&#xA;    ///&#xA;    /// - Returns: A `ByteBuffer` with the encoded version of the `value`.&#xA;    func encode(value: Output, into buffer: inout ByteBuffer) throws&#xA;&#xA;    /// Decode a `ByteBuffer` to a request or event of type ``Event``.&#xA;    /// Concrete Lambda handlers implement this method to provide coding functionality.&#xA;    ///&#xA;    /// - parameters:&#xA;    ///     - buffer: The `ByteBuffer` to decode.&#xA;    ///&#xA;    /// - Returns: A request or event of type ``Event``.&#xA;    func decode(buffer: ByteBuffer) throws -&amp;gt; Event&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;LambdaHandler&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;LambdaHandler&lt;/code&gt; is a strongly typed, completion handler based asynchronous processing protocol for a Lambda that takes a user defined &lt;code&gt;Event&lt;/code&gt; and returns a user defined &lt;code&gt;Output&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;LambdaHandler&lt;/code&gt; provides &lt;code&gt;ByteBuffer&lt;/code&gt; -&amp;gt; &lt;code&gt;Event&lt;/code&gt; decoding and &lt;code&gt;Output&lt;/code&gt; -&amp;gt; &lt;code&gt;ByteBuffer&lt;/code&gt; encoding for &lt;code&gt;Codable&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;LambdaHandler&lt;/code&gt; offloads the user provided Lambda execution to an async task making processing safer but slightly slower.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol LambdaHandler {&#xA;    /// The lambda function&#39;s input. In most cases this should be `Codable`. If your event originates from an&#xA;    /// AWS service, have a look at [AWSLambdaEvents](https://github.com/swift-server/swift-aws-lambda-events),&#xA;    /// which provides a number of commonly used AWS Event implementations.&#xA;    associatedtype Event&#xA;    /// The lambda function&#39;s output. Can be `Void`.&#xA;    associatedtype Output&#xA;&#xA;    /// The Lambda initialization method.&#xA;    /// Use this method to initialize resources that will be used in every request.&#xA;    ///&#xA;    /// Examples for this can be HTTP or database clients.&#xA;    /// - parameters:&#xA;    ///     - context: Runtime ``LambdaInitializationContext``.&#xA;    init(context: LambdaInitializationContext) async throws&#xA;&#xA;    /// The Lambda handling method.&#xA;    /// Concrete Lambda handlers implement this method to provide the Lambda functionality.&#xA;    ///&#xA;    /// - parameters:&#xA;    ///     - event: Event of type `Event` representing the event or request.&#xA;    ///     - context: Runtime ``LambdaContext``.&#xA;    ///&#xA;    /// - Returns: A Lambda result ot type `Output`.&#xA;    func handle(_ event: Event, context: LambdaContext) async throws -&amp;gt; Output&#xA;&#xA;    /// Encode a response of type ``Output`` to `ByteBuffer`.&#xA;    /// Concrete Lambda handlers implement this method to provide coding functionality.&#xA;    /// - parameters:&#xA;    ///     - value: Response of type ``Output``.&#xA;    ///     - buffer: A `ByteBuffer` to encode into, will be overwritten.&#xA;    ///&#xA;    /// - Returns: A `ByteBuffer` with the encoded version of the `value`.&#xA;    func encode(value: Output, into buffer: inout ByteBuffer) throws&#xA;&#xA;    /// Decode a `ByteBuffer` to a request or event of type ``Event``.&#xA;    /// Concrete Lambda handlers implement this method to provide coding functionality.&#xA;    ///&#xA;    /// - parameters:&#xA;    ///     - buffer: The `ByteBuffer` to decode.&#xA;    ///&#xA;    /// - Returns: A request or event of type ``Event``.&#xA;    func decode(buffer: ByteBuffer) throws -&amp;gt; Event&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SimpleLambdaHandler&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;SimpleLambdaHandler&lt;/code&gt; is a strongly typed, completion handler based asynchronous processing protocol for a Lambda that takes a user defined &lt;code&gt;Event&lt;/code&gt; and returns a user defined &lt;code&gt;Output&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;SimpleLambdaHandler&lt;/code&gt; provides &lt;code&gt;ByteBuffer&lt;/code&gt; -&amp;gt; &lt;code&gt;Event&lt;/code&gt; decoding and &lt;code&gt;Output&lt;/code&gt; -&amp;gt; &lt;code&gt;ByteBuffer&lt;/code&gt; encoding for &lt;code&gt;Codable&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;SimpleLambdaHandler&lt;/code&gt; is the same as &lt;code&gt;LambdaHandler&lt;/code&gt;, but does not require explicit initialization .&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol SimpleLambdaHandler {&#xA;    /// The lambda function&#39;s input. In most cases this should be `Codable`. If your event originates from an&#xA;    /// AWS service, have a look at [AWSLambdaEvents](https://github.com/swift-server/swift-aws-lambda-events),&#xA;    /// which provides a number of commonly used AWS Event implementations.&#xA;    associatedtype Event&#xA;    /// The lambda function&#39;s output. Can be `Void`.&#xA;    associatedtype Output&#xA;&#xA;    init()&#xA;&#xA;    /// The Lambda handling method.&#xA;    /// Concrete Lambda handlers implement this method to provide the Lambda functionality.&#xA;    ///&#xA;    /// - parameters:&#xA;    ///     - event: Event of type `Event` representing the event or request.&#xA;    ///     - context: Runtime ``LambdaContext``.&#xA;    ///&#xA;    /// - Returns: A Lambda result ot type `Output`.&#xA;    func handle(_ event: Event, context: LambdaContext) async throws -&amp;gt; Output&#xA;&#xA;    /// Encode a response of type ``Output`` to `ByteBuffer`.&#xA;    /// Concrete Lambda handlers implement this method to provide coding functionality.&#xA;    /// - parameters:&#xA;    ///     - value: Response of type ``Output``.&#xA;    ///     - buffer: A `ByteBuffer` to encode into, will be overwritten.&#xA;    ///&#xA;    /// - Returns: A `ByteBuffer` with the encoded version of the `value`.&#xA;    func encode(value: Output, into buffer: inout ByteBuffer) throws&#xA;&#xA;    /// Decode a `ByteBuffer` to a request or event of type ``Event``.&#xA;    /// Concrete Lambda handlers implement this method to provide coding functionality.&#xA;    ///&#xA;    /// - parameters:&#xA;    ///     - buffer: The `ByteBuffer` to decode.&#xA;    ///&#xA;    /// - Returns: A request or event of type ``Event``.&#xA;    func decode(buffer: ByteBuffer) throws -&amp;gt; Event&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Context&lt;/h3&gt; &#xA;&lt;p&gt;When calling the user provided Lambda function, the library provides a &lt;code&gt;LambdaContext&lt;/code&gt; class that provides metadata about the execution context, as well as utilities for logging and allocating buffers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public struct LambdaContext: CustomDebugStringConvertible, Sendable {&#xA;  /// The request ID, which identifies the request that triggered the function invocation.&#xA;  public var requestID: String {&#xA;      self.storage.requestID&#xA;  }&#xA;&#xA;  /// The AWS X-Ray tracing header.&#xA;  public var traceID: String {&#xA;      self.storage.traceID&#xA;  }&#xA;&#xA;  /// The ARN of the Lambda function, version, or alias that&#39;s specified in the invocation.&#xA;  public var invokedFunctionARN: String {&#xA;      self.storage.invokedFunctionARN&#xA;  }&#xA;&#xA;  /// The timestamp that the function times out.&#xA;  public var deadline: DispatchWallTime {&#xA;      self.storage.deadline&#xA;  }&#xA;&#xA;  /// For invocations from the AWS Mobile SDK, data about the Amazon Cognito identity provider.&#xA;  public var cognitoIdentity: String? {&#xA;      self.storage.cognitoIdentity&#xA;  }&#xA;&#xA;  /// For invocations from the AWS Mobile SDK, data about the client application and device.&#xA;  public var clientContext: String? {&#xA;      self.storage.clientContext&#xA;  }&#xA;&#xA;  /// `Logger` to log with.&#xA;  ///&#xA;  /// - note: The `LogLevel` can be configured using the `LOG_LEVEL` environment variable.&#xA;  public var logger: Logger {&#xA;      self.storage.logger&#xA;  }&#xA;&#xA;  /// The `EventLoop` the Lambda is executed on. Use this to schedule work with.&#xA;  /// This is useful when implementing the ``EventLoopLambdaHandler`` protocol.&#xA;  ///&#xA;  /// - note: The `EventLoop` is shared with the Lambda runtime engine and should be handled with extra care.&#xA;  ///         Most importantly the `EventLoop` must never be blocked.&#xA;  public var eventLoop: EventLoop {&#xA;      self.storage.eventLoop&#xA;  }&#xA;&#xA;  /// `ByteBufferAllocator` to allocate `ByteBuffer`.&#xA;  /// This is useful when implementing ``EventLoopLambdaHandler``.&#xA;  public var allocator: ByteBufferAllocator {&#xA;      self.storage.allocator&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarally, the library provides a context if and when initializing the Lambda.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public struct LambdaInitializationContext: Sendable {&#xA;    /// `Logger` to log with.&#xA;    ///&#xA;    /// - note: The `LogLevel` can be configured using the `LOG_LEVEL` environment variable.&#xA;    public let logger: Logger&#xA;&#xA;    /// The `EventLoop` the Lambda is executed on. Use this to schedule work with.&#xA;    ///&#xA;    /// - note: The `EventLoop` is shared with the Lambda runtime engine and should be handled with extra care.&#xA;    ///         Most importantly the `EventLoop` must never be blocked.&#xA;    public let eventLoop: EventLoop&#xA;&#xA;    /// `ByteBufferAllocator` to allocate `ByteBuffer`.&#xA;    public let allocator: ByteBufferAllocator&#xA;&#xA;    /// ``LambdaTerminator`` to register shutdown operations.&#xA;    public let terminator: LambdaTerminator&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;The library’s behavior can be fine tuned using environment variables based configuration. The library supported the following environment variables:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;LOG_LEVEL&lt;/code&gt;: Define the logging level as defined by &lt;a href=&#34;https://github.com/apple/swift-log&#34;&gt;SwiftLog&lt;/a&gt;. Set to INFO by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MAX_REQUESTS&lt;/code&gt;: Max cycles the library should handle before exiting. Set to none by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;STOP_SIGNAL&lt;/code&gt;: Signal to capture for termination. Set to &lt;code&gt;TERM&lt;/code&gt; by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;REQUEST_TIMEOUT&lt;/code&gt;: Max time to wait for responses to come back from the AWS Runtime engine. Set to none by default.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;AWS Lambda Runtime Engine Integration&lt;/h3&gt; &#xA;&lt;p&gt;The library is designed to integrate with AWS Lambda Runtime Engine via the &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html&#34;&gt;AWS Lambda Runtime API&lt;/a&gt; which was introduced as part of &lt;a href=&#34;https://aws.amazon.com/about-aws/whats-new/2018/11/aws-lambda-now-supports-custom-runtimes-and-layers/&#34;&gt;AWS Lambda Custom Runtimes&lt;/a&gt; in 2018. The latter is an HTTP server that exposes three main RESTful endpoint:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;/runtime/invocation/next&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/runtime/invocation/response&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/runtime/invocation/error&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A single Lambda execution workflow is made of the following steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The library calls AWS Lambda Runtime Engine &lt;code&gt;/next&lt;/code&gt; endpoint to retrieve the next invocation request.&lt;/li&gt; &#xA; &lt;li&gt;The library parses the response HTTP headers and populate the &lt;code&gt;Context&lt;/code&gt; object.&lt;/li&gt; &#xA; &lt;li&gt;The library reads the &lt;code&gt;/next&lt;/code&gt; response body and attempt to decode it. Typically it decodes to user provided &lt;code&gt;Event&lt;/code&gt; type which extends &lt;code&gt;Decodable&lt;/code&gt;, but users may choose to write Lambda functions that receive the input as &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;ByteBuffer&lt;/code&gt; which require less, or no decoding.&lt;/li&gt; &#xA; &lt;li&gt;The library hands off the &lt;code&gt;Context&lt;/code&gt; and &lt;code&gt;Event&lt;/code&gt; event to the user provided handler. In the case of &lt;code&gt;LambdaHandler&lt;/code&gt; based handler this is done on a dedicated &lt;code&gt;DispatchQueue&lt;/code&gt;, providing isolation between user&#39;s and the library&#39;s code.&lt;/li&gt; &#xA; &lt;li&gt;User provided handler processes the request asynchronously, invoking a callback or returning a future upon completion, which returns a &lt;code&gt;Result&lt;/code&gt; type with the &lt;code&gt;Output&lt;/code&gt; or &lt;code&gt;Error&lt;/code&gt; populated.&lt;/li&gt; &#xA; &lt;li&gt;In case of error, the library posts to AWS Lambda Runtime Engine &lt;code&gt;/error&lt;/code&gt; endpoint to provide the error details, which will show up on AWS Lambda logs.&lt;/li&gt; &#xA; &lt;li&gt;In case of success, the library will attempt to encode the response. Typically it encodes from user provided &lt;code&gt;Output&lt;/code&gt; type which extends &lt;code&gt;Encodable&lt;/code&gt;, but users may choose to write Lambda functions that return a &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;ByteBuffer&lt;/code&gt;, which require less, or no encoding. The library then posts the response to AWS Lambda Runtime Engine &lt;code&gt;/response&lt;/code&gt; endpoint to provide the response to the callee.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The library encapsulates the workflow via the internal &lt;code&gt;LambdaRuntimeClient&lt;/code&gt; and &lt;code&gt;LambdaRunner&lt;/code&gt; structs respectively.&lt;/p&gt; &#xA;&lt;h3&gt;Lifecycle Management&lt;/h3&gt; &#xA;&lt;p&gt;AWS Lambda Runtime Engine controls the Application lifecycle and in the happy case never terminates the application, only suspends its execution when no work is available.&lt;/p&gt; &#xA;&lt;p&gt;As such, the library&#39;s main entry point is designed to run forever in a blocking fashion, performing the workflow described above in an endless loop.&lt;/p&gt; &#xA;&lt;p&gt;That loop is broken if/when an internal error occurs, such as a failure to communicate with AWS Lambda Runtime Engine API, or under other unexpected conditions.&lt;/p&gt; &#xA;&lt;p&gt;By default, the library also registers a Signal handler that traps &lt;code&gt;INT&lt;/code&gt; and &lt;code&gt;TERM&lt;/code&gt;, which are typical Signals used in modern deployment platforms to communicate shutdown request.&lt;/p&gt; &#xA;&lt;h3&gt;Integration with AWS Platform Events&lt;/h3&gt; &#xA;&lt;p&gt;AWS Lambda functions can be invoked directly from the AWS Lambda console UI, AWS Lambda API, AWS SDKs, AWS CLI, and AWS toolkits. More commonly, they are invoked as a reaction to an events coming from the AWS platform. To make it easier to integrate with AWS platform events, &lt;a href=&#34;http://github.com/swift-server/swift-aws-lambda-events&#34;&gt;Swift AWS Lambda Runtime Events&lt;/a&gt; library is available, designed to work together with this runtime library. &lt;a href=&#34;http://github.com/swift-server/swift-aws-lambda-events&#34;&gt;Swift AWS Lambda Runtime Events&lt;/a&gt; includes an &lt;code&gt;AWSLambdaEvents&lt;/code&gt; target which provides abstractions for many commonly used events.&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;Lambda functions performance is usually measured across two axes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Cold start times&lt;/strong&gt;: The time it takes for a Lambda function to startup, ask for an invocation and process the first invocation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Warm invocation times&lt;/strong&gt;: The time it takes for a Lambda function to process an invocation after the Lambda has been invoked at least once.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Larger packages size (Zip file uploaded to AWS Lambda) negatively impact the cold start time, since AWS needs to download and unpack the package before starting the process.&lt;/p&gt; &#xA;&lt;p&gt;Swift provides great Unicode support via &lt;a href=&#34;http://site.icu-project.org/home&#34;&gt;ICU&lt;/a&gt;. Therefore, Swift-based Lambda functions include the ICU libraries which tend to be large. This impacts the download time mentioned above and an area for further optimization. Some of the alternatives worth exploring are using the system ICU that comes with Amazon Linux (albeit older than the one Swift ships with) or working to remove the ICU dependency altogether. We welcome ideas and contributions to this end.&lt;/p&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/swift-server/swift-aws-lambda-runtime/main/SECURITY.md&#34;&gt;SECURITY.md&lt;/a&gt; for details on the security process.&lt;/p&gt; &#xA;&lt;h2&gt;Project status&lt;/h2&gt; &#xA;&lt;p&gt;This is a community-driven open-source project actively seeking contributions. There are several areas which need additional attention, including but not limited to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Further performance tuning&lt;/li&gt; &#xA; &lt;li&gt;Additional documentation and best practices&lt;/li&gt; &#xA; &lt;li&gt;Additional examples&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Version 0.x (previous version) documentation&lt;/h1&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;If you have never used AWS Lambda or Docker before, check out this &lt;a href=&#34;https://fabianfett.de/getting-started-with-swift-aws-lambda-runtime&#34;&gt;getting started guide&lt;/a&gt; which helps you with every step from zero to a running Lambda.&lt;/p&gt; &#xA;&lt;p&gt;First, create a SwiftPM project and pull Swift AWS Lambda Runtime as dependency into your project&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// swift-tools-version:5.6&#xA;&#xA;import PackageDescription&#xA;&#xA;let package = Package(&#xA;    name: &#34;my-lambda&#34;,&#xA;    products: [&#xA;        .executable(name: &#34;MyLambda&#34;, targets: [&#34;MyLambda&#34;]),&#xA;    ],&#xA;    dependencies: [&#xA;        .package(url: &#34;https://github.com/swift-server/swift-aws-lambda-runtime.git&#34;, from: &#34;0.1.0&#34;),&#xA;    ],&#xA;    targets: [&#xA;        .executableTarget(name: &#34;MyLambda&#34;, dependencies: [&#xA;          .product(name: &#34;AWSLambdaRuntime&#34;, package: &#34;swift-aws-lambda-runtime&#34;),&#xA;        ]),&#xA;    ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, create a &lt;code&gt;main.swift&lt;/code&gt; and implement your Lambda.&lt;/p&gt; &#xA;&lt;h3&gt;Using Closures&lt;/h3&gt; &#xA;&lt;p&gt;The simplest way to use &lt;code&gt;AWSLambdaRuntime&lt;/code&gt; is to pass in a closure, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Import the module&#xA;import AWSLambdaRuntime&#xA;&#xA;// in this example we are receiving and responding with strings&#xA;Lambda.run { (context, name: String, callback: @escaping (Result&amp;lt;String, Error&amp;gt;) -&amp;gt; Void) in&#xA;  callback(.success(&#34;Hello, \(name)&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More commonly, the event would be a JSON, which is modeled using &lt;code&gt;Codable&lt;/code&gt;, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Import the module&#xA;import AWSLambdaRuntime&#xA;&#xA;// Request, uses Codable for transparent JSON encoding&#xA;private struct Request: Codable {&#xA;  let name: String&#xA;}&#xA;&#xA;// Response, uses Codable for transparent JSON encoding&#xA;private struct Response: Codable {&#xA;  let message: String&#xA;}&#xA;&#xA;// In this example we are receiving and responding with `Codable`.&#xA;Lambda.run { (context, request: Request, callback: @escaping (Result&amp;lt;Response, Error&amp;gt;) -&amp;gt; Void) in&#xA;  callback(.success(Response(message: &#34;Hello, \(request.name)&#34;)))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since most Lambda functions are triggered by events originating in the AWS platform like &lt;code&gt;SNS&lt;/code&gt;, &lt;code&gt;SQS&lt;/code&gt; or &lt;code&gt;APIGateway&lt;/code&gt;, the &lt;a href=&#34;http://github.com/swift-server/swift-aws-lambda-events&#34;&gt;Swift AWS Lambda Events&lt;/a&gt; package includes an &lt;code&gt;AWSLambdaEvents&lt;/code&gt; module that provides implementations for most common AWS event types further simplifying writing Lambda functions. For example, handling an &lt;code&gt;SQS&lt;/code&gt; message:&lt;/p&gt; &#xA;&lt;p&gt;First, add a dependency on the event packages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// swift-tools-version:5.6&#xA;&#xA;import PackageDescription&#xA;&#xA;let package = Package(&#xA;    name: &#34;my-lambda&#34;,&#xA;    products: [&#xA;        .executable(name: &#34;MyLambda&#34;, targets: [&#34;MyLambda&#34;]),&#xA;    ],&#xA;    dependencies: [&#xA;        .package(url: &#34;https://github.com/swift-server/swift-aws-lambda-runtime.git&#34;, from: &#34;0.1.0&#34;),&#xA;    ],&#xA;    targets: [&#xA;        .executableTarget(name: &#34;MyLambda&#34;, dependencies: [&#xA;          .product(name: &#34;AWSLambdaRuntime&#34;, package: &#34;swift-aws-lambda-runtime&#34;),&#xA;          .product(name: &#34;AWSLambdaEvents&#34;, package: &#34;swift-aws-lambda-runtime&#34;),&#xA;        ]),&#xA;    ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Import the modules&#xA;import AWSLambdaRuntime&#xA;import AWSLambdaEvents&#xA;&#xA;// In this example we are receiving an SQS Event, with no response (Void).&#xA;Lambda.run { (context, message: SQS.Event, callback: @escaping (Result&amp;lt;Void, Error&amp;gt;) -&amp;gt; Void) in&#xA;  ...&#xA;  callback(.success(Void()))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Modeling Lambda functions as Closures is both simple and safe. Swift AWS Lambda Runtime will ensure that the user-provided code is offloaded from the network processing thread such that even if the code becomes slow to respond or gets hang, the underlying process can continue to function. This safety comes at a small performance penalty from context switching between threads. In many cases, the simplicity and safety of using the Closure based API is often preferred over the complexity of the performance-oriented API.&lt;/p&gt; &#xA;&lt;h3&gt;Using EventLoopLambdaHandler&lt;/h3&gt; &#xA;&lt;p&gt;Performance sensitive Lambda functions may choose to use a more complex API which allows user code to run on the same thread as the networking handlers. Swift AWS Lambda Runtime uses &lt;a href=&#34;https://github.com/apple/swift-nio&#34;&gt;SwiftNIO&lt;/a&gt; as its underlying networking engine which means the APIs are based on &lt;a href=&#34;https://github.com/apple/swift-nio&#34;&gt;SwiftNIO&lt;/a&gt; concurrency primitives like the &lt;code&gt;EventLoop&lt;/code&gt; and &lt;code&gt;EventLoopFuture&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Import the modules&#xA;import AWSLambdaRuntime&#xA;import AWSLambdaEvents&#xA;import NIO&#xA;&#xA;// Our Lambda handler, conforms to EventLoopLambdaHandler&#xA;struct Handler: EventLoopLambdaHandler {&#xA;    typealias In = SNS.Message // Request type&#xA;    typealias Out = Void // Response type&#xA;&#xA;    // In this example we are receiving an SNS Message, with no response (Void).&#xA;    func handle(context: Lambda.Context, event: In) -&amp;gt; EventLoopFuture&amp;lt;Out&amp;gt; {&#xA;        ...&#xA;        context.eventLoop.makeSucceededFuture(Void())&#xA;    }&#xA;}&#xA;&#xA;Lambda.run(Handler())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Beyond the small cognitive complexity of using the &lt;code&gt;EventLoopFuture&lt;/code&gt; based APIs, note these APIs should be used with extra care. An &lt;code&gt;EventLoopLambdaHandler&lt;/code&gt; will execute the user code on the same &lt;code&gt;EventLoop&lt;/code&gt; (thread) as the library, making processing faster but requiring the user code to never call blocking APIs as it might prevent the underlying process from functioning.&lt;/p&gt; &#xA;&lt;h2&gt;Deploying to AWS Lambda&lt;/h2&gt; &#xA;&lt;p&gt;To deploy Lambda functions to AWS Lambda, you need to compile the code for Amazon Linux which is the OS used on AWS Lambda microVMs, package it as a Zip file, and upload to AWS.&lt;/p&gt; &#xA;&lt;p&gt;AWS offers several tools to interact and deploy Lambda functions to AWS Lambda including &lt;a href=&#34;https://aws.amazon.com/serverless/sam/&#34;&gt;SAM&lt;/a&gt; and the &lt;a href=&#34;https://aws.amazon.com/cli/&#34;&gt;AWS CLI&lt;/a&gt;. The &lt;a href=&#34;https://raw.githubusercontent.com/swift-server/swift-aws-lambda-runtime/main/Examples&#34;&gt;Examples Directory&lt;/a&gt; includes complete sample build and deployment scripts that utilize these tools.&lt;/p&gt; &#xA;&lt;p&gt;Note the examples mentioned above use dynamic linking, therefore bundle the required Swift libraries in the Zip package along side the executable. You may choose to link the Lambda function statically (using &lt;code&gt;-static-stdlib&lt;/code&gt;) which could improve performance but requires additional linker flags.&lt;/p&gt; &#xA;&lt;p&gt;To build the Lambda function for Amazon Linux, use the Docker image published by Swift.org on &lt;a href=&#34;https://swift.org/download/&#34;&gt;Swift toolchains and Docker images for Amazon Linux 2&lt;/a&gt;, as demonstrated in the examples.&lt;/p&gt; &#xA;&lt;h2&gt;Architecture&lt;/h2&gt; &#xA;&lt;p&gt;The library defines three protocols for the implementation of a Lambda Handler. From low-level to more convenient:&lt;/p&gt; &#xA;&lt;h3&gt;ByteBufferLambdaHandler&lt;/h3&gt; &#xA;&lt;p&gt;An &lt;code&gt;EventLoopFuture&lt;/code&gt; based processing protocol for a Lambda that takes a &lt;code&gt;ByteBuffer&lt;/code&gt; and returns a &lt;code&gt;ByteBuffer?&lt;/code&gt; asynchronously.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ByteBufferLambdaHandler&lt;/code&gt; is the lowest level protocol designed to power the higher level &lt;code&gt;EventLoopLambdaHandler&lt;/code&gt; and &lt;code&gt;LambdaHandler&lt;/code&gt; based APIs. Users are not expected to use this protocol, though some performance sensitive applications that operate at the &lt;code&gt;ByteBuffer&lt;/code&gt; level or have special serialization needs may choose to do so.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol ByteBufferLambdaHandler {&#xA;    /// The Lambda handling method&#xA;    /// Concrete Lambda handlers implement this method to provide the Lambda functionality.&#xA;    ///&#xA;    /// - parameters:&#xA;    ///  - context: Runtime `Context`.&#xA;    ///  - event: The event or request payload encoded as `ByteBuffer`.&#xA;    ///&#xA;    /// - Returns: An `EventLoopFuture` to report the result of the Lambda back to the runtime engine.&#xA;    /// The `EventLoopFuture` should be completed with either a response encoded as `ByteBuffer` or an `Error`&#xA;    func handle(context: Lambda.Context, event: ByteBuffer) -&amp;gt; EventLoopFuture&amp;lt;ByteBuffer?&amp;gt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;EventLoopLambdaHandler&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;EventLoopLambdaHandler&lt;/code&gt; is a strongly typed, &lt;code&gt;EventLoopFuture&lt;/code&gt; based asynchronous processing protocol for a Lambda that takes a user defined &lt;code&gt;In&lt;/code&gt; and returns a user defined &lt;code&gt;Out&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;EventLoopLambdaHandler&lt;/code&gt; extends &lt;code&gt;ByteBufferLambdaHandler&lt;/code&gt;, providing &lt;code&gt;ByteBuffer&lt;/code&gt; -&amp;gt; &lt;code&gt;In&lt;/code&gt; decoding and &lt;code&gt;Out&lt;/code&gt; -&amp;gt; &lt;code&gt;ByteBuffer?&lt;/code&gt; encoding for &lt;code&gt;Codable&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;EventLoopLambdaHandler&lt;/code&gt; executes the user provided Lambda on the same &lt;code&gt;EventLoop&lt;/code&gt; as the core runtime engine, making the processing fast but requires more care from the implementation to never block the &lt;code&gt;EventLoop&lt;/code&gt;. It it designed for performance sensitive applications that use &lt;code&gt;Codable&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; based Lambda functions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol EventLoopLambdaHandler: ByteBufferLambdaHandler {&#xA;    associatedtype In&#xA;    associatedtype Out&#xA;&#xA;    /// The Lambda handling method&#xA;    /// Concrete Lambda handlers implement this method to provide the Lambda functionality.&#xA;    ///&#xA;    /// - parameters:&#xA;    ///  - context: Runtime `Context`.&#xA;    ///  - event: Event of type `In` representing the event or request.&#xA;    ///&#xA;    /// - Returns: An `EventLoopFuture` to report the result of the Lambda back to the runtime engine.&#xA;    /// The `EventLoopFuture` should be completed with either a response of type `Out` or an `Error`&#xA;    func handle(context: Lambda.Context, event: In) -&amp;gt; EventLoopFuture&amp;lt;Out&amp;gt;&#xA;&#xA;    /// Encode a response of type `Out` to `ByteBuffer`&#xA;    /// Concrete Lambda handlers implement this method to provide coding functionality.&#xA;    /// - parameters:&#xA;    ///  - allocator: A `ByteBufferAllocator` to help allocate the `ByteBuffer`.&#xA;    ///  - value: Response of type `Out`.&#xA;    ///&#xA;    /// - Returns: A `ByteBuffer` with the encoded version of the `value`.&#xA;    func encode(allocator: ByteBufferAllocator, value: Out) throws -&amp;gt; ByteBuffer?&#xA;&#xA;    /// Decode a`ByteBuffer` to a request or event of type `In`&#xA;    /// Concrete Lambda handlers implement this method to provide coding functionality.&#xA;    ///&#xA;    /// - parameters:&#xA;    ///  - buffer: The `ByteBuffer` to decode.&#xA;    ///&#xA;    /// - Returns: A request or event of type `In`.&#xA;    func decode(buffer: ByteBuffer) throws -&amp;gt; In&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;LambdaHandler&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;LambdaHandler&lt;/code&gt; is a strongly typed, completion handler based asynchronous processing protocol for a Lambda that takes a user defined &lt;code&gt;In&lt;/code&gt; and returns a user defined &lt;code&gt;Out&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;LambdaHandler&lt;/code&gt; extends &lt;code&gt;ByteBufferLambdaHandler&lt;/code&gt;, performing &lt;code&gt;ByteBuffer&lt;/code&gt; -&amp;gt; &lt;code&gt;In&lt;/code&gt; decoding and &lt;code&gt;Out&lt;/code&gt; -&amp;gt; &lt;code&gt;ByteBuffer&lt;/code&gt; encoding for &lt;code&gt;Codable&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;LambdaHandler&lt;/code&gt; offloads the user provided Lambda execution to a &lt;code&gt;DispatchQueue&lt;/code&gt; making processing safer but slower.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol LambdaHandler: EventLoopLambdaHandler {&#xA;    /// Defines to which `DispatchQueue` the Lambda execution is offloaded to.&#xA;    var offloadQueue: DispatchQueue { get }&#xA;&#xA;    /// The Lambda handling method&#xA;    /// Concrete Lambda handlers implement this method to provide the Lambda functionality.&#xA;    ///&#xA;    /// - parameters:&#xA;    ///  - context: Runtime `Context`.&#xA;    ///  - event: Event of type `In` representing the event or request.&#xA;    ///  - callback: Completion handler to report the result of the Lambda back to the runtime engine.&#xA;    ///  The completion handler expects a `Result` with either a response of type `Out` or an `Error`&#xA;    func handle(context: Lambda.Context, event: In, callback: @escaping (Result&amp;lt;Out, Error&amp;gt;) -&amp;gt; Void)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Closures&lt;/h3&gt; &#xA;&lt;p&gt;In addition to protocol-based Lambda, the library provides support for Closure-based ones, as demonstrated in the overview section above. Closure-based Lambdas are based on the &lt;code&gt;LambdaHandler&lt;/code&gt; protocol which mean they are safer. For most use cases, Closure-based Lambda is a great fit and users are encouraged to use them.&lt;/p&gt; &#xA;&lt;p&gt;The library includes implementations for &lt;code&gt;Codable&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; based Lambda. Since AWS Lambda is primarily JSON based, this covers the most common use cases.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public typealias CodableClosure&amp;lt;In: Decodable, Out: Encodable&amp;gt; = (Lambda.Context, In, @escaping (Result&amp;lt;Out, Error&amp;gt;) -&amp;gt; Void) -&amp;gt; Void&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public typealias StringClosure = (Lambda.Context, String, @escaping (Result&amp;lt;String, Error&amp;gt;) -&amp;gt; Void) -&amp;gt; Void&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This design allows for additional event types as well, and such Lambda implementation can extend one of the above protocols and provided their own &lt;code&gt;ByteBuffer&lt;/code&gt; -&amp;gt; &lt;code&gt;In&lt;/code&gt; decoding and &lt;code&gt;Out&lt;/code&gt; -&amp;gt; &lt;code&gt;ByteBuffer&lt;/code&gt; encoding.&lt;/p&gt; &#xA;&lt;h3&gt;Context&lt;/h3&gt; &#xA;&lt;p&gt;When calling the user provided Lambda function, the library provides a &lt;code&gt;Context&lt;/code&gt; class that provides metadata about the execution context, as well as utilities for logging and allocating buffers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public final class Context {&#xA;    /// The request ID, which identifies the request that triggered the function invocation.&#xA;    public let requestID: String&#xA;&#xA;    /// The AWS X-Ray tracing header.&#xA;    public let traceID: String&#xA;&#xA;    /// The ARN of the Lambda function, version, or alias that&#39;s specified in the invocation.&#xA;    public let invokedFunctionARN: String&#xA;&#xA;    /// The timestamp that the function times out&#xA;    public let deadline: DispatchWallTime&#xA;&#xA;    /// For invocations from the AWS Mobile SDK, data about the Amazon Cognito identity provider.&#xA;    public let cognitoIdentity: String?&#xA;&#xA;    /// For invocations from the AWS Mobile SDK, data about the client application and device.&#xA;    public let clientContext: String?&#xA;&#xA;    /// `Logger` to log with&#xA;    ///&#xA;    /// - note: The `LogLevel` can be configured using the `LOG_LEVEL` environment variable.&#xA;    public let logger: Logger&#xA;&#xA;    /// The `EventLoop` the Lambda is executed on. Use this to schedule work with.&#xA;    /// This is useful when implementing the `EventLoopLambdaHandler` protocol.&#xA;    ///&#xA;    /// - note: The `EventLoop` is shared with the Lambda runtime engine and should be handled with extra care.&#xA;    ///  Most importantly the `EventLoop` must never be blocked.&#xA;    public let eventLoop: EventLoop&#xA;&#xA;    /// `ByteBufferAllocator` to allocate `ByteBuffer`&#xA;    /// This is useful when implementing `EventLoopLambdaHandler`&#xA;    public let allocator: ByteBufferAllocator&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>