<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-05-09T01:36:02Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>modelcontextprotocol/swift-sdk</title>
    <updated>2025-05-09T01:36:02Z</updated>
    <id>tag:github.com,2025-05-09:/modelcontextprotocol/swift-sdk</id>
    <link href="https://github.com/modelcontextprotocol/swift-sdk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The official Swift SDK for Model Context Protocol servers and clients. Maintained in collaboration with @loopwork-ai.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MCP Swift SDK&lt;/h1&gt; &#xA;&lt;p&gt;Official Swift SDK for the &lt;a href=&#34;https://modelcontextprotocol.io&#34;&gt;Model Context Protocol&lt;/a&gt; (MCP).&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;The Model Context Protocol (MCP) defines a standardized way for applications to communicate with AI and ML models. This Swift SDK implements both client and server components according to the &lt;a href=&#34;https://modelcontextprotocol.io/specification/2025-03-26&#34;&gt;2025-03-26&lt;/a&gt; (latest) version of the MCP specification.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift 6.0+ (Xcode 16+)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/modelcontextprotocol/swift-sdk/main/#platform-availability&#34;&gt;Platform Availability&lt;/a&gt; section below for platform-specific requirements.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;Add the following to your &lt;code&gt;Package.swift&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/modelcontextprotocol/swift-sdk.git&#34;, from: &#34;0.8.2&#34;)&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then add the dependency to your target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.target(&#xA;    name: &#34;YourTarget&#34;,&#xA;    dependencies: [&#xA;        .product(name: &#34;MCP&#34;, package: &#34;swift-sdk&#34;)&#xA;    ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Client Usage&lt;/h2&gt; &#xA;&lt;p&gt;The client component allows your application to connect to MCP servers.&lt;/p&gt; &#xA;&lt;h3&gt;Basic Client Setup&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import MCP&#xA;&#xA;// Initialize the client&#xA;let client = Client(name: &#34;MyApp&#34;, version: &#34;1.0.0&#34;)&#xA;&#xA;// Create a transport and connect&#xA;let transport = StdioTransport()&#xA;try await client.connect(transport: transport)&#xA;&#xA;// Initialize the connection&#xA;let result = try await client.initialize()&#xA;&#xA;// Check server capabilities&#xA;if result.capabilities.tools != nil {&#xA;    // Server supports tools (implicitly including tool calling if the &#39;tools&#39; capability object is present)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Transport Options for Clients&lt;/h3&gt; &#xA;&lt;h4&gt;Stdio Transport&lt;/h4&gt; &#xA;&lt;p&gt;For local subprocess communication:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Create a stdio transport (simplest option)&#xA;let transport = StdioTransport()&#xA;try await client.connect(transport: transport)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;HTTP Transport&lt;/h4&gt; &#xA;&lt;p&gt;For remote server communication:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Create a streaming HTTP transport&#xA;let transport = HTTPClientTransport(&#xA;    endpoint: URL(string: &#34;http://localhost:8080&#34;)!,&#xA;    streaming: true  // Enable Server-Sent Events for real-time updates&#xA;)&#xA;try await client.connect(transport: transport)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tools&lt;/h3&gt; &#xA;&lt;p&gt;Tools represent functions that can be called by the client:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// List available tools&#xA;let tools = try await client.listTools()&#xA;print(&#34;Available tools: \(tools.map { $0.name }.joined(separator: &#34;, &#34;))&#34;)&#xA;&#xA;// Call a tool with arguments&#xA;let (content, isError) = try await client.callTool(&#xA;    name: &#34;image-generator&#34;,&#xA;    arguments: [&#xA;        &#34;prompt&#34;: &#34;A serene mountain landscape at sunset&#34;,&#xA;        &#34;style&#34;: &#34;photorealistic&#34;,&#xA;        &#34;width&#34;: 1024,&#xA;        &#34;height&#34;: 768&#xA;    ]&#xA;)&#xA;&#xA;// Handle tool content&#xA;for item in content {&#xA;    switch item {&#xA;    case .text(let text):&#xA;        print(&#34;Generated text: \(text)&#34;)&#xA;    case .image(let data, let mimeType, let metadata):&#xA;        if let width = metadata?[&#34;width&#34;] as? Int,&#xA;           let height = metadata?[&#34;height&#34;] as? Int {&#xA;            print(&#34;Generated \(width)x\(height) image of type \(mimeType)&#34;)&#xA;            // Save or display the image data&#xA;        }&#xA;    case .audio(let data, let mimeType):&#xA;        print(&#34;Received audio data of type \(mimeType)&#34;)&#xA;    case .resource(let uri, let mimeType, let text):&#xA;        print(&#34;Received resource from \(uri) of type \(mimeType)&#34;)&#xA;        if let text = text {&#xA;            print(&#34;Resource text: \(text)&#34;)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;Resources represent data that can be accessed and potentially subscribed to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// List available resources&#xA;let (resources, nextCursor) = try await client.listResources()&#xA;print(&#34;Available resources: \(resources.map { $0.uri }.joined(separator: &#34;, &#34;))&#34;)&#xA;&#xA;// Read a resource&#xA;let contents = try await client.readResource(uri: &#34;resource://example&#34;)&#xA;print(&#34;Resource content: \(contents)&#34;)&#xA;&#xA;// Subscribe to resource updates if supported&#xA;if result.capabilities.resources.subscribe {&#xA;    try await client.subscribeToResource(uri: &#34;resource://example&#34;)&#xA;&#xA;    // Register notification handler&#xA;    await client.onNotification(ResourceUpdatedNotification.self) { message in&#xA;        let uri = message.params.uri&#xA;        print(&#34;Resource \(uri) updated with new content&#34;)&#xA;&#xA;        // Fetch the updated resource content&#xA;        let updatedContents = try await client.readResource(uri: uri)&#xA;        print(&#34;Updated resource content received&#34;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Prompts&lt;/h3&gt; &#xA;&lt;p&gt;Prompts represent templated conversation starters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// List available prompts&#xA;let (prompts, nextCursor) = try await client.listPrompts()&#xA;print(&#34;Available prompts: \(prompts.map { $0.name }.joined(separator: &#34;, &#34;))&#34;)&#xA;&#xA;// Get a prompt with arguments&#xA;let (description, messages) = try await client.getPrompt(&#xA;    name: &#34;customer-service&#34;,&#xA;    arguments: [&#xA;        &#34;customerName&#34;: &#34;Alice&#34;,&#xA;        &#34;orderNumber&#34;: &#34;ORD-12345&#34;,&#xA;        &#34;issue&#34;: &#34;delivery delay&#34;&#xA;    ]&#xA;)&#xA;&#xA;// Use the prompt messages in your application&#xA;print(&#34;Prompt description: \(description)&#34;)&#xA;for message in messages {&#xA;    if case .text(text: let text) = message.content {&#xA;        print(&#34;\(message.role): \(text)&#34;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Error Handling&lt;/h3&gt; &#xA;&lt;p&gt;Handle common client errors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    let result = try await client.initialize()&#xA;    // Success&#xA;} catch let error as MCPError {&#xA;    print(&#34;MCP Error: \(error.localizedDescription)&#34;)&#xA;} catch {&#xA;    print(&#34;Unexpected error: \(error)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Advanced Client Features&lt;/h3&gt; &#xA;&lt;h4&gt;Strict vs Non-Strict Configuration&lt;/h4&gt; &#xA;&lt;p&gt;Configure client behavior for capability checking:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Strict configuration - fail fast if a capability is missing&#xA;let strictClient = Client(&#xA;    name: &#34;StrictClient&#34;,&#xA;    version: &#34;1.0.0&#34;,&#xA;    configuration: .strict&#xA;)&#xA;&#xA;// With strict configuration, calling a method for an unsupported capability&#xA;// will throw an error immediately without sending a request&#xA;do {&#xA;    // This will throw an error if resources.list capability is not available&#xA;    let resources = try await strictClient.listResources()&#xA;} catch let error as MCPError {&#xA;    print(&#34;Capability not available: \(error.localizedDescription)&#34;)&#xA;}&#xA;&#xA;// Default (non-strict) configuration - attempt the request anyway&#xA;let client = Client(&#xA;    name: &#34;FlexibleClient&#34;,&#xA;    version: &#34;1.0.0&#34;,&#xA;    configuration: .default&#xA;)&#xA;&#xA;// With default configuration, the client will attempt the request&#xA;// even if the capability wasn&#39;t advertised by the server&#xA;do {&#xA;    let resources = try await client.listResources()&#xA;} catch let error as MCPError {&#xA;    // Still handle the error if the server rejects the request&#xA;    print(&#34;Server rejected request: \(error.localizedDescription)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Request Batching&lt;/h4&gt; &#xA;&lt;p&gt;Improve performance by sending multiple requests in a single batch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Array to hold tool call tasks&#xA;var toolTasks: [Task&amp;lt;CallTool.Result, Error&amp;gt;] = []&#xA;&#xA;// Send a batch of requests&#xA;try await client.withBatch { batch in&#xA;    // Add multiple tool calls to the batch&#xA;    for i in 0..&amp;lt;10 {&#xA;        toolTasks.append(&#xA;            try await batch.addRequest(&#xA;                CallTool.request(.init(name: &#34;square&#34;, arguments: [&#34;n&#34;: i]))&#xA;            )&#xA;        )&#xA;    }&#xA;}&#xA;&#xA;// Process results after the batch is sent&#xA;print(&#34;Processing \(toolTasks.count) tool results...&#34;)&#xA;for (index, task) in toolTasks.enumerated() {&#xA;    do {&#xA;        let result = try await task.value&#xA;        print(&#34;\(index): \(result.content)&#34;)&#xA;    } catch {&#xA;        print(&#34;\(index) failed: \(error)&#34;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also batch different types of requests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Declare task variables&#xA;var pingTask: Task&amp;lt;Ping.Result, Error&amp;gt;?&#xA;var promptTask: Task&amp;lt;GetPrompt.Result, Error&amp;gt;?&#xA;&#xA;// Send a batch with different request types&#xA;try await client.withBatch { batch in&#xA;    pingTask = try await batch.addRequest(Ping.request())&#xA;    promptTask = try await batch.addRequest(&#xA;        GetPrompt.request(.init(name: &#34;greeting&#34;))&#xA;    )&#xA;}&#xA;&#xA;// Process individual results&#xA;do {&#xA;    if let pingTask = pingTask {&#xA;        try await pingTask.value&#xA;        print(&#34;Ping successful&#34;)&#xA;    }&#xA;&#xA;    if let promptTask = promptTask {&#xA;        let promptResult = try await promptTask.value&#xA;        print(&#34;Prompt: \(promptResult.description ?? &#34;None&#34;)&#34;)&#xA;    }&#xA;} catch {&#xA;    print(&#34;Error processing batch results: \(error)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] &lt;code&gt;Server&lt;/code&gt; automatically handles batch requests from MCP clients.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Server Usage&lt;/h2&gt; &#xA;&lt;p&gt;The server component allows your application to host model capabilities and respond to client requests.&lt;/p&gt; &#xA;&lt;h3&gt;Basic Server Setup&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import MCP&#xA;&#xA;// Initialize the server with capabilities&#xA;let server = Server(&#xA;    name: &#34;MyModelServer&#34;,&#xA;    version: &#34;1.0.0&#34;,&#xA;    capabilities: .init(&#xA;        prompts: .init(listChanged: true),&#xA;        resources: .init(subscribe: true, listChanged: true),&#xA;        tools: .init(listChanged: true)&#xA;    )&#xA;)&#xA;&#xA;// Create transport and start server&#xA;let transport = StdioTransport()&#xA;try await server.start(transport: transport)&#xA;&#xA;// Now register handlers for the capabilities you&#39;ve enabled&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tools&lt;/h3&gt; &#xA;&lt;p&gt;Register tool handlers to respond to client tool calls:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Register a tool list handler&#xA;server.withMethodHandler(ListTools.self) { _ in&#xA;    let tools = [&#xA;        Tool(&#xA;            name: &#34;weather&#34;,&#xA;            description: &#34;Get current weather for a location&#34;,&#xA;            inputSchema: .object([&#xA;                &#34;location&#34;: .string(&#34;City name or coordinates&#34;),&#xA;                &#34;units&#34;: .string(&#34;Units of measurement, e.g., metric, imperial&#34;)&#xA;            ])&#xA;        ),&#xA;        Tool(&#xA;            name: &#34;calculator&#34;,&#xA;            description: &#34;Perform calculations&#34;,&#xA;            inputSchema: .object([&#xA;                &#34;expression&#34;: .string(&#34;Mathematical expression to evaluate&#34;)&#xA;            ])&#xA;        )&#xA;    ]&#xA;    return .init(tools: tools)&#xA;}&#xA;&#xA;// Register a tool call handler&#xA;server.withMethodHandler(CallTool.self) { params in&#xA;    switch params.name {&#xA;    case &#34;weather&#34;:&#xA;        let location = params.arguments?[&#34;location&#34;]?.stringValue ?? &#34;Unknown&#34;&#xA;        let units = params.arguments?[&#34;units&#34;]?.stringValue ?? &#34;metric&#34;&#xA;        let weatherData = getWeatherData(location: location, units: units) // Your implementation&#xA;        return .init(&#xA;            content: [.text(&#34;Weather for \(location): \(weatherData.temperature)Â°, \(weatherData.conditions)&#34;)],&#xA;            isError: false&#xA;        )&#xA;&#xA;    case &#34;calculator&#34;:&#xA;        if let expression = params.arguments?[&#34;expression&#34;]?.stringValue {&#xA;            let result = evaluateExpression(expression) // Your implementation&#xA;            return .init(content: [.text(&#34;\(result)&#34;)], isError: false)&#xA;        } else {&#xA;            return .init(content: [.text(&#34;Missing expression parameter&#34;)], isError: true)&#xA;        }&#xA;&#xA;    default:&#xA;        return .init(content: [.text(&#34;Unknown tool&#34;)], isError: true)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;Implement resource handlers for data access:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Register a resource list handler&#xA;server.withMethodHandler(ListResources.self) { params in&#xA;    let resources = [&#xA;        Resource(&#xA;            uri: &#34;resource://knowledge-base/articles&#34;,&#xA;            name: &#34;Knowledge Base Articles&#34;,&#xA;            description: &#34;Collection of support articles and documentation&#34;&#xA;        ),&#xA;        Resource(&#xA;            uri: &#34;resource://system/status&#34;,&#xA;            name: &#34;System Status&#34;,&#xA;            description: &#34;Current system operational status&#34;&#xA;        )&#xA;    ]&#xA;    return .init(resources: resources, nextCursor: nil)&#xA;}&#xA;&#xA;// Register a resource read handler&#xA;server.withMethodHandler(ReadResource.self) { params in&#xA;    switch params.uri {&#xA;    case &#34;resource://knowledge-base/articles&#34;:&#xA;        return .init(contents: [Resource.Content.text(&#34;# Knowledge Base\n\nThis is the content of the knowledge base...&#34;, uri: params.uri)])&#xA;&#xA;    case &#34;resource://system/status&#34;:&#xA;        let status = getCurrentSystemStatus() // Your implementation&#xA;        let statusJson = &#34;&#34;&#34;&#xA;            {&#xA;                &#34;status&#34;: &#34;\(status.overall)&#34;,&#xA;                &#34;components&#34;: {&#xA;                    &#34;database&#34;: &#34;\(status.database)&#34;,&#xA;                    &#34;api&#34;: &#34;\(status.api)&#34;,&#xA;                    &#34;model&#34;: &#34;\(status.model)&#34;&#xA;                },&#xA;                &#34;lastUpdated&#34;: &#34;\(status.timestamp)&#34;&#xA;            }&#xA;            &#34;&#34;&#34;&#xA;        return .init(contents: [Resource.Content.text(statusJson, uri: params.uri, mimeType: &#34;application/json&#34;)])&#xA;&#xA;    default:&#xA;        throw MCPError.invalidParams(&#34;Unknown resource URI: \(params.uri)&#34;)&#xA;    }&#xA;}&#xA;&#xA;// Register a resource subscribe handler&#xA;server.withMethodHandler(SubscribeToResource.self) { params in&#xA;    // Store subscription for later notifications.&#xA;    // Client identity for multi-client scenarios needs to be managed by the server application,&#xA;    // potentially using information from the initialize handshake if the server handles one client post-init.&#xA;    // addSubscription(clientID: /* some_client_identifier */, uri: params.uri)&#xA;    print(&#34;Client subscribed to \(params.uri). Server needs to implement logic to track this subscription.&#34;)&#xA;    return .init()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Prompts&lt;/h3&gt; &#xA;&lt;p&gt;Implement prompt handlers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Register a prompt list handler&#xA;server.withMethodHandler(ListPrompts.self) { params in&#xA;    let prompts = [&#xA;        Prompt(&#xA;            name: &#34;interview&#34;,&#xA;            description: &#34;Job interview conversation starter&#34;,&#xA;            arguments: [&#xA;                .init(name: &#34;position&#34;, description: &#34;Job position&#34;, required: true),&#xA;                .init(name: &#34;company&#34;, description: &#34;Company name&#34;, required: true),&#xA;                .init(name: &#34;interviewee&#34;, description: &#34;Candidate name&#34;)&#xA;            ]&#xA;        ),&#xA;        Prompt(&#xA;            name: &#34;customer-support&#34;,&#xA;            description: &#34;Customer support conversation starter&#34;,&#xA;            arguments: [&#xA;                .init(name: &#34;issue&#34;, description: &#34;Customer issue&#34;, required: true),&#xA;                .init(name: &#34;product&#34;, description: &#34;Product name&#34;, required: true)&#xA;            ]&#xA;        )&#xA;    ]&#xA;    return .init(prompts: prompts, nextCursor: nil)&#xA;}&#xA;&#xA;// Register a prompt get handler&#xA;server.withMethodHandler(GetPrompt.self) { params in&#xA;    switch params.name {&#xA;    case &#34;interview&#34;:&#xA;        let position = params.arguments?[&#34;position&#34;]?.stringValue ?? &#34;Software Engineer&#34;&#xA;        let company = params.arguments?[&#34;company&#34;]?.stringValue ?? &#34;Acme Corp&#34;&#xA;        let interviewee = params.arguments?[&#34;interviewee&#34;]?.stringValue ?? &#34;Candidate&#34;&#xA;&#xA;        let description = &#34;Job interview for \(position) position at \(company)&#34;&#xA;        let messages: [Prompt.Message] = [&#xA;            .init(role: .user, content: .text(text: &#34;You are an interviewer for the \(position) position at \(company).&#34;)),&#xA;            .init(role: .user, content: .text(text: &#34;Hello, I&#39;m \(interviewee) and I&#39;m here for the \(position) interview.&#34;)),&#xA;            .init(role: .assistant, content: .text(text: &#34;Hi \(interviewee), welcome to \(company)! I&#39;d like to start by asking about your background and experience.&#34;))&#xA;        ]&#xA;&#xA;        return .init(description: description, messages: messages)&#xA;&#xA;    case &#34;customer-support&#34;:&#xA;        // Similar implementation for customer support prompt&#xA;&#xA;    default:&#xA;        throw MCPError.invalidParams(&#34;Unknown prompt name: \(params.name)&#34;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Initialize Hook&lt;/h4&gt; &#xA;&lt;p&gt;Control client connections with an initialize hook:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Start the server with an initialize hook&#xA;try await server.start(transport: transport) { clientInfo, clientCapabilities in&#xA;    // Validate client info&#xA;    guard clientInfo.name != &#34;BlockedClient&#34; else {&#xA;        throw MCPError.invalidRequest(&#34;This client is not allowed&#34;)&#xA;    }&#xA;&#xA;    // You can also inspect client capabilities&#xA;    if clientCapabilities.tools == nil {&#xA;        print(&#34;Client does not support tools&#34;)&#xA;    }&#xA;&#xA;    // Perform any server-side setup based on client info&#xA;    print(&#34;Client \(clientInfo.name) v\(clientInfo.version) connected&#34;)&#xA;&#xA;    // If the hook completes without throwing, initialization succeeds&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Graceful Shutdown&lt;/h3&gt; &#xA;&lt;p&gt;We recommend using &lt;a href=&#34;https://github.com/swift-server/swift-service-lifecycle&#34;&gt;Swift Service Lifecycle&lt;/a&gt; for managing startup and shutdown of services.&lt;/p&gt; &#xA;&lt;p&gt;First, add the dependency to your &lt;code&gt;Package.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.package(url: &#34;https://github.com/swift-server/swift-service-lifecycle.git&#34;, from: &#34;2.3.0&#34;),&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then implement the MCP server as a &lt;code&gt;Service&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import MCP&#xA;import ServiceLifecycle&#xA;import Logging&#xA;&#xA;struct MCPService: Service {&#xA;    let server: Server&#xA;    let transport: Transport&#xA;&#xA;    init(server: Server, transport: Transport) {&#xA;        self.server = server&#xA;        self.transport = transport&#xA;    }&#xA;&#xA;    func run() async throws {&#xA;        // Start the server&#xA;        try await server.start(transport: transport)&#xA;&#xA;        // Keep running until external cancellation&#xA;        try await Task.sleep(for: .days(365 * 100))  // Effectively forever&#xA;    }&#xA;&#xA;    func shutdown() async throws {&#xA;        // Gracefully shutdown the server&#xA;        await server.stop()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then use it in your application:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import MCP&#xA;import ServiceLifecycle&#xA;import Logging&#xA;&#xA;let logger = Logger(label: &#34;com.example.mcp-server&#34;)&#xA;&#xA;// Create the MCP server&#xA;let server = Server(&#xA;    name: &#34;MyModelServer&#34;,&#xA;    version: &#34;1.0.0&#34;,&#xA;    capabilities: .init(&#xA;        prompts: .init(listChanged: true),&#xA;        resources: .init(subscribe: true, listChanged: true),&#xA;        tools: .init(listChanged: true)&#xA;    ),&#xA;    logger: logger&#xA;)&#xA;&#xA;// Add handlers directly to the server&#xA;server.withMethodHandler(ListTools.self) { _ in&#xA;    // Your implementation&#xA;    return .init(tools: [&#xA;        Tool(name: &#34;example&#34;, description: &#34;An example tool&#34;)&#xA;    ])&#xA;}&#xA;&#xA;server.withMethodHandler(CallTool.self) { params in&#xA;    // Your implementation&#xA;    return .init(content: [.text(&#34;Tool result&#34;)], isError: false)&#xA;}&#xA;&#xA;// Create MCP service and other services&#xA;let transport = StdioTransport(logger: logger)&#xA;let mcpService = MCPService(server: server, transport: transport)&#xA;let databaseService = DatabaseService() // Your other services&#xA;&#xA;// Create service group with signal handling&#xA;let serviceGroup = ServiceGroup(&#xA;    services: [mcpService, databaseService],&#xA;    configuration: .init(&#xA;        gracefulShutdownSignals: [.sigterm, .sigint]&#xA;    ),&#xA;    logger: logger&#xA;)&#xA;&#xA;// Run the service group - this blocks until shutdown&#xA;try await serviceGroup.run()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This approach has several benefits:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Signal handling&lt;/strong&gt;: Automatically traps SIGINT, SIGTERM and triggers graceful shutdown&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Graceful shutdown&lt;/strong&gt;: Properly shuts down your MCP server and other services&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Timeout-based shutdown&lt;/strong&gt;: Configurable shutdown timeouts to prevent hanging processes&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Advanced service management&lt;/strong&gt;: &lt;a href=&#34;https://swiftpackageindex.com/swift-server/swift-service-lifecycle/documentation/servicelifecycle&#34;&gt;&lt;code&gt;ServiceLifecycle&lt;/code&gt;&lt;/a&gt; also supports service dependencies, conditional services, and other useful features.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Transports&lt;/h2&gt; &#xA;&lt;p&gt;MCP&#39;s transport layer handles communication between clients and servers. The Swift SDK provides multiple built-in transports:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Transport&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Platforms&lt;/th&gt; &#xA;   &lt;th&gt;Best for&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/modelcontextprotocol/swift-sdk/main/Sources/MCP/Base/Transports/StdioTransport.swift&#34;&gt;&lt;code&gt;StdioTransport&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Implements &lt;a href=&#34;https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#stdio&#34;&gt;stdio transport&lt;/a&gt; using standard input/output streams&lt;/td&gt; &#xA;   &lt;td&gt;Apple platforms, Linux with glibc&lt;/td&gt; &#xA;   &lt;td&gt;Local subprocesses, CLI tools&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/modelcontextprotocol/swift-sdk/main/Sources/MCP/Base/Transports/HTTPClientTransport.swift&#34;&gt;&lt;code&gt;HTTPClientTransport&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Implements &lt;a href=&#34;https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#streamable-http&#34;&gt;Streamable HTTP transport&lt;/a&gt; using Foundation&#39;s URL Loading System&lt;/td&gt; &#xA;   &lt;td&gt;All platforms with Foundation&lt;/td&gt; &#xA;   &lt;td&gt;Remote servers, web applications&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/modelcontextprotocol/swift-sdk/main/Sources/MCP/Base/Transports/NetworkTransport.swift&#34;&gt;&lt;code&gt;NetworkTransport&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Custom transport using Apple&#39;s Network framework for TCP/UDP connections&lt;/td&gt; &#xA;   &lt;td&gt;Apple platforms only&lt;/td&gt; &#xA;   &lt;td&gt;Low-level networking, custom protocols&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Custom Transport Implementation&lt;/h3&gt; &#xA;&lt;p&gt;You can implement a custom transport by conforming to the &lt;code&gt;Transport&lt;/code&gt; protocol:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import MCP&#xA;import Foundation&#xA;&#xA;public actor MyCustomTransport: Transport {&#xA;    public nonisolated let logger: Logger&#xA;    private var isConnected = false&#xA;    private let messageStream: AsyncThrowingStream&amp;lt;Data, Error&amp;gt;&#xA;    private let messageContinuation: AsyncThrowingStream&amp;lt;Data, Error&amp;gt;.Continuation&#xA;&#xA;    public init(logger: Logger? = nil) {&#xA;        self.logger = logger ?? Logger(label: &#34;my.custom.transport&#34;)&#xA;&#xA;        var continuation: AsyncThrowingStream&amp;lt;Data, Error&amp;gt;.Continuation!&#xA;        self.messageStream = AsyncThrowingStream { continuation = $0 }&#xA;        self.messageContinuation = continuation&#xA;    }&#xA;&#xA;    public func connect() async throws {&#xA;        // Implement your connection logic&#xA;        isConnected = true&#xA;    }&#xA;&#xA;    public func disconnect() async {&#xA;        // Implement your disconnection logic&#xA;        isConnected = false&#xA;        messageContinuation.finish()&#xA;    }&#xA;&#xA;    public func send(_ data: Data) async throws {&#xA;        // Implement your message sending logic&#xA;    }&#xA;&#xA;    public func receive() -&amp;gt; AsyncThrowingStream&amp;lt;Data, Error&amp;gt; {&#xA;        return messageStream&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Platform Availability&lt;/h2&gt; &#xA;&lt;p&gt;The Swift SDK has the following platform requirements:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Platform&lt;/th&gt; &#xA;   &lt;th&gt;Minimum Version&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;macOS&lt;/td&gt; &#xA;   &lt;td&gt;13.0+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;iOS / Mac Catalyst&lt;/td&gt; &#xA;   &lt;td&gt;16.0+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;watchOS&lt;/td&gt; &#xA;   &lt;td&gt;9.0+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tvOS&lt;/td&gt; &#xA;   &lt;td&gt;16.0+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;visionOS&lt;/td&gt; &#xA;   &lt;td&gt;1.0+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Linux&lt;/td&gt; &#xA;   &lt;td&gt;Distributions with &lt;code&gt;glibc&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;While the core library works on any platform supporting Swift 6 (including Linux and Windows), running a client or server requires a compatible transport.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;re actively working to expand platform support:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/modelcontextprotocol/swift-sdk/pull/64&#34;&gt;Alpine Linux support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/modelcontextprotocol/swift-sdk/pull/64&#34;&gt;Windows support&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Debugging and Logging&lt;/h2&gt; &#xA;&lt;p&gt;Enable logging to help troubleshoot issues:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Logging&#xA;import MCP&#xA;&#xA;// Configure Logger&#xA;LoggingSystem.bootstrap { label in&#xA;    var handler = StreamLogHandler.standardOutput(label: label)&#xA;    handler.logLevel = .debug&#xA;    return handler&#xA;}&#xA;&#xA;// Create logger&#xA;let logger = Logger(label: &#34;com.example.mcp&#34;)&#xA;&#xA;// Pass to client/server&#xA;let client = Client(name: &#34;MyApp&#34;, version: &#34;1.0.0&#34;, logger: logger)&#xA;&#xA;// Pass to transport&#xA;let transport = StdioTransport(logger: logger)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Additional Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://modelcontextprotocol.io/specification/2025-03-26/&#34;&gt;MCP Specification&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://modelcontextprotocol.io&#34;&gt;Protocol Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/modelcontextprotocol/swift-sdk&#34;&gt;GitHub Repository&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;This project follows &lt;a href=&#34;https://semver.org/&#34;&gt;Semantic Versioning&lt;/a&gt;. For pre-1.0 releases, minor version increments (0.X.0) may contain breaking changes.&lt;/p&gt; &#xA;&lt;p&gt;For details about changes in each release, see the &lt;a href=&#34;https://github.com/modelcontextprotocol/swift-sdk/releases&#34;&gt;GitHub Releases page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under the MIT License.&lt;/p&gt;</summary>
  </entry>
</feed>