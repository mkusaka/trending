<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-03-18T01:36:05Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SwiftfulThinking/SwiftfulRouting</title>
    <updated>2025-03-18T01:36:05Z</updated>
    <id>tag:github.com,2025-03-18:/SwiftfulThinking/SwiftfulRouting</id>
    <link href="https://github.com/SwiftfulThinking/SwiftfulRouting" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Programmatic navigation for SwiftUI applications.&lt;/p&gt;&lt;hr&gt;&lt;h3&gt;üöÄ Learn how to build and use this package: &lt;a href=&#34;https://www.swiftful-thinking.com/offers/REyNLwwH&#34;&gt;https://www.swiftful-thinking.com/offers/REyNLwwH&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h1&gt;SwiftfulRouting ü§ô&lt;/h1&gt; &#xA;&lt;p&gt;SwiftfulRouting is a native, declarative framework that enables programmatic navigation in SwiftUI applications.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sample project: &lt;a href=&#34;https://github.com/SwiftfulThinking/SwiftfulRoutingExample&#34;&gt;https://github.com/SwiftfulThinking/SwiftfulRoutingExample&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;YouTube Tutorial: &lt;a href=&#34;https://www.youtube.com/watch?v=zKfhv-Yds4g&amp;amp;list=PLwvDm4VfkdphPRGbtiY-X3IZsUXFi6595&amp;amp;index=6&#34;&gt;https://www.youtube.com/watch?v=zKfhv-Yds4g&amp;amp;list=PLwvDm4VfkdphPRGbtiY-X3IZsUXFi6595&amp;amp;index=6&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How It Works&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Details (Click to expand) &lt;/summary&gt; &#xA; &lt;br&gt; Routers based on programatic code do not declare the view heirarchy in advance, but rather at the time of execution. However, SwiftUI is declarative, and so we must declare the view heirarchy in advance. The solution herein is to convert SwiftUI&#39;s declarative code to behave as programmatic code by connecting view modifiers to support the routing in advance. &#xA; &lt;br&gt; &#xA; &lt;br&gt; As you segue to a new screen, the framework adds a set view modifiers to the root of the destination View that will support all potential navigation routes. The modifiers are based on generic and/or type-erased destinations, which maintains a declarative view heirarchy while allowing the developer to still determine the destination at the time of execution. &#xA; &lt;br&gt; &#xA; &lt;br&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;The ViewModifiers are in &lt;code&gt;RouterView.swift -&amp;gt; body&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;li&gt;Accessible routing methods are in &lt;code&gt;AnyRouter.swift&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;li&gt;Refer to the sample project for example implementations, UI Tests and sample MVC, MVVM and VIPER design patterns.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;Sample project: &lt;a href=&#34;https://github.com/SwiftfulThinking/SwiftfulRoutingExample&#34;&gt;https://github.com/SwiftfulThinking/SwiftfulRoutingExample&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Details (Click to expand) &lt;/summary&gt; &#xA; &lt;br&gt; Add the package to your Xcode project. &#xA; &lt;pre&gt;&lt;code&gt;https://github.com/SwiftfulThinking/SwiftfulRouting.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Import the package&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import SwiftfulRouting&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Add a &lt;code&gt;RouterView&lt;/code&gt; at the top of your view heirarchy. A &lt;code&gt;RouterView&lt;/code&gt; will embed your view into a Navigation heirarchy and add modifiers to support all potential segues.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    var body: some View {&#xA;        RouterView { _ in&#xA;            MyView()&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;All child views have access to a &lt;code&gt;Router&lt;/code&gt; in the &lt;code&gt;Environment&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Environment(\.router) var router&#xA;    &#xA;var body: some View {&#xA;     Text(&#34;Hello, world!&#34;)&#xA;          .onTapGesture {&#xA;               router.showScreen(.push) { _ in&#xA;                    Text(&#34;Another screen!&#34;)&#xA;               }&#xA;          }&#xA;     }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Instead of relying on the &lt;code&gt;Environment&lt;/code&gt;, you may also pass the &lt;code&gt;Router&lt;/code&gt; directly into the child views. This allows the &lt;code&gt;Router&lt;/code&gt; to be fully decoupled from the View (for more complex app architectures).&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;RouterView { router in&#xA;     ContentView(router: router)&#xA;          .onTapGesture {&#xA;               router.showScreen(.push) { router2 in&#xA;                    Text(&#34;View2&#34;)&#xA;                         .onTapGesture {&#xA;                              router2.showScreen(.push) { router3 in&#xA;                                   Text(&#34;View3&#34;)&#xA;                              }&#xA;                         }&#xA;               }&#xA;          }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;A new Router is created and added to the view heirarchy after each Segue. Refer to &lt;code&gt;AnyRouter.swift&lt;/code&gt; to see all accessible methods.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Setup (existing projects)&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Details (Click to expand) &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;In order to enter the framework&#39;s view heirarchy, you must wrap your content in a RouterView. By default, your view will be wrapped in with navigation stack (iOS 16+ uses a NavigationStack, iOS 15 and below uses NavigationView).&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;If your view is already within a navigation heirarchy, set &lt;code&gt;addNavigationView&lt;/code&gt; to &lt;code&gt;FALSE&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;li&gt;If your view is already within a NavigationStack, use &lt;code&gt;screens&lt;/code&gt; to bind to the existing stack path.&lt;/li&gt; &#xA;  &lt;li&gt;The framework uses the native SwiftUI navigation bar, so all related modifiers will still work.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;RouterView(addNavigationView: false, screens: $existingStack) { router in&#xA;   MyView(router: router)&#xA;        .navigationBarHidden(true)&#xA;        .toolbar {&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Show Screens&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Details (Click to expand) &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;Router supports all native SwiftUI segues.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// NavigationLink&#xA;router.showScreen(.push) { _ in&#xA;     Text(&#34;View2&#34;)&#xA;}&#xA;&#xA;// Sheet&#xA;router.showScreen(.sheet) { _ in&#xA;     Text(&#34;View2&#34;)&#xA;}&#xA;&#xA;// FullScreenCover&#xA;router.showScreen(.fullScreenCover) { _ in&#xA;     Text(&#34;View2&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Segue methods also accept &lt;code&gt;AnyRoute&lt;/code&gt; as a convenience, which make it easy to pass the &lt;code&gt;Route&lt;/code&gt; around your code.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let route = AnyRoute(.push, destination: { router in&#xA;     Text(&#34;Hello, world!&#34;)&#xA;})&#xA;                        &#xA;router.showScreen(route)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;All segues have an onDismiss method.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;&#xA;router.showScreen(.push, onDismiss: {&#xA;     // dismiss action&#xA;}, destination: { _ in&#xA;     Text(&#34;Hello, world!&#34;)&#xA;})&#xA;                &#xA;let route = AnyRoute(.push, onDismiss: {&#xA;     // dismiss action&#xA;}, destination: { _ in&#xA;     Text(&#34;Hello, world!&#34;)&#xA;})&#xA;                &#xA;router.showScreen(route)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;iOS 16+ uses NavigationStack, which supports pushing multiple screens at once.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let route1 = PushRoute(destination: { router in&#xA;     Text(&#34;View1&#34;)&#xA;})&#xA;let route2 = PushRoute(destination: { router in&#xA;     Text(&#34;View2&#34;)&#xA;})&#xA;let route3 = PushRoute(destination: { router in&#xA;     Text(&#34;View3&#34;)&#xA;})&#xA;                        &#xA;router.pushScreenStack(destinations: [route1, route2, route3])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;iOS 16+ also supports resizable sheets.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;router.showResizableSheet(sheetDetents: [.medium, .large], selection: nil, showDragIndicator: true) { _ in&#xA;     Text(&#34;Hello, world!)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Additional convenience methods:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;router.showSafari {&#xA;     URL(string: &#34;https://www.apple.com&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Enter Screen Flows&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Details (Click to expand) &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;Screen &#34;flows&#34; are new way to support dynamic routing in your application. When you enter a &#34;screen flow&#34;, you add an array of &lt;code&gt;Routes&lt;/code&gt; to the heirarchy. The application will immediately segue to the first screen, and then set the remaining screens into a queue.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;router.enterScreenFlow([&#xA;     AnyRoute(.fullScreenCover, destination: screen1),&#xA;     AnyRoute(.push, destination: screen2),&#xA;     AnyRoute(.push, destination: screen3),&#xA;     AnyRoute(.push, destination: screen4),&#xA;])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;This allows the developer to set multiple future segues at once, without requiring screen-specific code in each child view. Each child view&#39;s routing logic is simple as &#34;try to go to next screen&#34;.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;     try router.showNextScreen()&#xA;} catch {&#xA;     // There is no next screen set in the flow&#xA;     // Dismiss the flow (see below dismiss methods) or do something else&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Benefits of using a &#34;flow&#34;:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt; &lt;p&gt;&lt;strong&gt;Simiplified Logic:&lt;/strong&gt; In most applications, the routing logic is tightly coupled to the View (ie. when you create a screen, you declare in code exactly what the next screen must be). Now, you can build a screen without having to worry about routing at all. Simply support &#34;go to next screen&#34; or &#34;dismiss flow&#34; (see dismissal code below).&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;&lt;strong&gt;AB Tests:&lt;/strong&gt; Each user can see a unique flow of screens in your app, and you don&#39;t have to write &#39;if-else&#39; logic within every child view.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;&lt;strong&gt;High-Level Control&lt;/strong&gt;: You can control the entire flow from one method, which will be closer to the business logic of your app, rather than within the View itself.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;&lt;strong&gt;Flows on Flows&lt;/strong&gt;: Flows are fully dynamic, meaning you can enter flows from within flows and can dismiss screens within flows (back-forward-back) without corrupting the flow.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Dismiss Screens&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Details (Click to expand) &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;Dismiss one screen. You can also dismiss a screen using native SwiftUI code, including swipe-back gestures or &lt;code&gt;presentationMode&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;router.dismissScreen()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Dismiss all screens pushed onto the stack. This dismisses every &#34;push&#34; (NavigationLink) on the screen&#39;s Navigation Stack. This does not dismiss &lt;code&gt;sheet&lt;/code&gt; or &lt;code&gt;fullScreenCover&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;router.dismissScreenStack()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Dismiss screen environment. This dismisses the screen&#39;s root environment (if there is one to dismiss), which is the closest &#39;sheet&#39; or &lt;code&gt;fullScreenCover&lt;/code&gt; below the call-site.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;router.dismissEnvironment()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;For example, if you entered the following screen flow and you called &lt;code&gt;dismissEnvironment&lt;/code&gt; from any of the child views, it would dismiss the &lt;code&gt;fullScreenCover&lt;/code&gt;, which in-turn dismisses every view displayed on that Environment.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;router.enterScreenFlow([&#xA;     AnyRoute(.fullScreenCover, destination: screen1),&#xA;     AnyRoute(.push, destination: screen2),&#xA;     AnyRoute(.push, destination: screen3),&#xA;     AnyRoute(.push, destination: screen4),&#xA;])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Logic for dismissing a &#34;Flow&#34; can generally look like:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;     try router.showNextScreen()&#xA;} catch {&#xA;     router.dismissEnvironment()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Or convenience method:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;router.showNextScreenOrDismissEnvironment()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Copy and paste this code into your project to enable swipe back gestures. This is not included in the SwiftUI framework by default and therefore is not automatically included herein.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension UINavigationController: UIGestureRecognizerDelegate {&#xA;    override open func viewDidLoad() {&#xA;        super.viewDidLoad()&#xA;        interactivePopGestureRecognizer?.delegate = self&#xA;    }&#xA;    &#xA;    public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -&amp;gt; Bool {&#xA;        return viewControllers.count &amp;gt; 1&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Alerts&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Details (Click to expand) &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;Router supports native SwiftUI alerts.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Alert&#xA;router.showAlert(.alert, title: &#34;Title goes here&#34;, subtitle: &#34;Subtitle goes here!&#34;) {&#xA;     Button(&#34;OK&#34;) {&#xA;&#xA;     }&#xA;     Button(&#34;Cancel&#34;) {&#xA;                        &#xA;     }&#xA;}&#xA;&#xA;// Confirmation Dialog&#xA;router.showAlert(.confirmationDialog, title: &#34;Title goes here&#34;, subtitle: &#34;Subtitle goes here!&#34;) {&#xA;     Button(&#34;A&#34;) {&#xA;                        &#xA;     }&#xA;     Button(&#34;B&#34;) {&#xA;                        &#xA;     }&#xA;     Button(&#34;C&#34;) {&#xA;                        &#xA;     }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Dismiss an alert.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;router.dismissAlert()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Additional convenience methods:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;router.showBasicAlert(text: &#34;Error&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Modals&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Details (Click to expand) &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;Router also supports any modal transition, which displays above the current content. Customize transition, animation, background color/blur, etc. See sample project for example implementations.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;router.showModal(transition: .move(edge: .top), animation: .easeInOut, alignment: .top, backgroundColor: nil, useDeviceBounds: true) {&#xA;     Text(&#34;Sample&#34;)&#xA;          .onTapGesture {&#xA;               router.dismissModal()&#xA;          }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You can display multiple modals simultaneously. Modals have an optional ID field, which can later be used to dismiss the modal.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;router.showModal(id: &#34;top1&#34;) {&#xA;     Text(&#34;Sample&#34;)&#xA;}&#xA;&#xA;// Dismiss top-most modal&#xA;router.dismissModal()&#xA;&#xA;// Dismiss modal by ID&#xA;router.dismissModal(id: &#34;top1&#34;)&#xA;&#xA;// Dismiss all modals&#xA;router.dismissAllModals()&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Additional convenience methods:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;router.showBasicModal {&#xA;     Text(&#34;Sample&#34;)&#xA;          .onTapGesture {&#xA;               router.dismissModal()&#xA;          }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Contribute ü§ì&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Details (Click to expand) &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;Community contributions are encouraged! Please ensure that your code adheres to the project&#39;s existing coding style and structure. Most new features are likely to be derivatives of existing features, so many of the existing ViewModifiers and Bindings should be reused.&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/SwiftfulThinking/SwiftfulRouting/issues&#34;&gt;Open an issue&lt;/a&gt; for issues with the existing codebase.&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/SwiftfulThinking/SwiftfulRouting/discussions&#34;&gt;Open a discussion&lt;/a&gt; for new feature requests.&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/SwiftfulThinking/SwiftfulRouting/pulls&#34;&gt;Submit a pull request&lt;/a&gt; when the feature is ready.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;Upcoming features:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support multiple Modals per screen&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add &lt;code&gt;showModule&lt;/code&gt; support, for navigating between parent-level RouterView&#39;s&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Support VisionOS&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt;</summary>
  </entry>
  <entry>
    <title>mhaeuser/Battery-Toolkit</title>
    <updated>2025-03-18T01:36:05Z</updated>
    <id>tag:github.com,2025-03-18:/mhaeuser/Battery-Toolkit</id>
    <link href="https://github.com/mhaeuser/Battery-Toolkit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Control the platform power state of your Apple Silicon Mac.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img alt=&#34;Battery Toolkit logo&#34; src=&#34;https://raw.githubusercontent.com/mhaeuser/Battery-Toolkit/main/Resources/LogoCaption.png&#34; width=&#34;500&#34; align=&#34;center&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;Control the platform power state of your Apple Silicon Mac.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhaeuser/Battery-Toolkit/main/#features&#34;&gt;Features&lt;/a&gt; ‚Ä¢ &lt;a href=&#34;https://raw.githubusercontent.com/mhaeuser/Battery-Toolkit/main/#install&#34;&gt;Install&lt;/a&gt; ‚Ä¢ &lt;a href=&#34;https://raw.githubusercontent.com/mhaeuser/Battery-Toolkit/main/#usage&#34;&gt;Usage&lt;/a&gt; ‚Ä¢ &lt;a href=&#34;https://raw.githubusercontent.com/mhaeuser/Battery-Toolkit/main/#uninstall&#34;&gt; Uninstall &lt;/a&gt; ‚Ä¢&lt;a href=&#34;https://raw.githubusercontent.com/mhaeuser/Battery-Toolkit/main/#limitations&#34;&gt; Limitations &lt;/a&gt; ‚Ä¢ &lt;a href=&#34;https://raw.githubusercontent.com/mhaeuser/Battery-Toolkit/main/#technical-details&#34;&gt; Technical Details &lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;h2&gt;Limits battery charge to an upper limit&lt;/h2&gt; &#xA;&lt;p&gt;Modern batteries deteriorate more when always kept at full charge. For this reason, Apple introduced the ‚ÄúOptimized Charging‚Äú feature for all their portable devices, including Macs. However, its limit cannot be changed, and you cannot force charging to be put on hold. Battery Toolkit allows specifying a hard limit past which battery charging will be turned off. For safety reasons, this limit cannot be lower than 50&amp;nbsp;%.&lt;/p&gt; &#xA;&lt;h2&gt;Allows battery charge to drain to a lower limit&lt;/h2&gt; &#xA;&lt;p&gt;Even when connected to power, your Mac&#39;s battery may slowly lose battery charge for various reasons. Short battery charging bursts can further deteriorate batteries. For this reason, Battery Toolkit allows specifying a limit only below which battery charging will be turned on. For safety reasons, this limit cannot be lower than 20&amp;nbsp;%.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This setting is not honoured for cold boots or reboots, because Apple Silicon Macs reset their platform state in these cases. As battery charging will already be ongoing when Battery Toolkit starts, it lets charging proceed to the upper limit to not cause further short bursts across reboots.&lt;/p&gt; &#xA;&lt;h2&gt;Allows you to disable the power adapter&lt;/h2&gt; &#xA;&lt;p&gt;If you want to discharge the battery of your Mac, e.g., to recalibrate it, you can turn off the power adapter without actually unplugging it. You can also have Battery Toolkit disable sleeping when the power adapter is disabled.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Your Mac may go to sleep immediately after enabling the power adapter again. This is a software bug in macOS and cannot easily be worked around.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;img alt=&#34;Power Settings&#34; src=&#34;https://raw.githubusercontent.com/mhaeuser/Battery-Toolkit/main/Resources/PowerSettings.png&#34; width=&#34;607&#34;&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Fig. 1&lt;/strong&gt;. &lt;em&gt;Power Settings&lt;/em&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Grants you manual control&lt;/h2&gt; &#xA;&lt;p&gt;The Battery Toolkit &#34;Commands&#34; menu and its menu bar extra allow you to issue various commands related to the power state of your Mac. These include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Enabling and disabling the power adapter&lt;/li&gt; &#xA; &lt;li&gt;Requesting a full charge&lt;/li&gt; &#xA; &lt;li&gt;Requesting a charge to the specified upper limit&lt;/li&gt; &#xA; &lt;li&gt;Stopping charging immediately&lt;/li&gt; &#xA; &lt;li&gt;Pausing all background activity&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;&lt;img alt=&#34;Menu Bar Extra&#34; src=&#34;https://raw.githubusercontent.com/mhaeuser/Battery-Toolkit/main/Resources/MenuBarExtra.png&#34; width=&#34;283&#34;&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Fig. 2&lt;/strong&gt;. &lt;em&gt;Menu Bar Extra&lt;/em&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Install&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] Battery Toolkit currently only supports Apple Silicon Macs &lt;a href=&#34;https://github.com/mhaeuser/Battery-Toolkit/issues/15&#34;&gt;#15&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Manual Install&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Go to the GitHub &lt;a href=&#34;https://github.com/mhaeuser/Battery-Toolkit/releases/latest&#34;&gt;releases&lt;/a&gt; page&lt;/li&gt; &#xA; &lt;li&gt;Download the latest non-dSYM build (e.g., &lt;code&gt;Battery-Toolkit-1.6.zip&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Unzip the archive&lt;/li&gt; &#xA; &lt;li&gt;Drag &lt;code&gt;Battery Toolkit.app&lt;/code&gt; into your Applications folder&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Install via Homebrew &lt;span&gt;üç∫&lt;/span&gt;&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://brew.sh&#34;&gt;Homebrew&lt;/a&gt; if you haven&#39;t already&lt;/li&gt; &#xA; &lt;li&gt;Open Terminal and run &lt;code&gt;brew tap mhaeuser/mhaeuser&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;brew install battery-toolkit&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;You may want to add the &lt;code&gt;--no-quarantine&lt;/code&gt; flag onto the end of the install command to bypass Gatekeeper more conveniently, but beware the potential security risks of doing so.&lt;/p&gt; &#xA;&lt;p&gt;Otherwise, follow the steps mentioned below.&lt;/p&gt; &#xA;&lt;h3&gt;Opening the App&lt;/h3&gt; &#xA;&lt;p&gt;Because Battery Toolkit is not notarized, you will have to manually allow it to open.&lt;/p&gt; &#xA;&lt;p&gt;On macOS 14 Sonoma or below:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Right click &lt;code&gt;Battery Toolkit.app&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Click &#34;Open&#34;&lt;/li&gt; &#xA; &lt;li&gt;Click &#34;Open&#34; in the dialog box&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;On macOS 15 Sequoia or above:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Try to open the app, it will tell you it&#39;s blocked&lt;/li&gt; &#xA; &lt;li&gt;Go to &lt;code&gt;System Settings &amp;gt; Privacy &amp;amp; Security&lt;/code&gt; and scroll to the bottom&lt;/li&gt; &#xA; &lt;li&gt;Click &#34;Open Anyway&#34; to allow Battery Toolkit to open&lt;/li&gt; &#xA; &lt;li&gt;Click &#34;Open Anyway&#34; on the next dialog box and authenticate&lt;/li&gt; &#xA; &lt;li&gt;Open Battery Toolkit again from Applications folder&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!CAUTION] To ensure there is no chance of interference, please turn ‚ÄúOptimized Charging‚Äù &lt;strong&gt;off&lt;/strong&gt; when Battery Toolkit is in use. &lt;br&gt; Go to macOS System Settings &amp;gt; Battery &amp;gt; the (i) next to Battery Health &amp;gt; Optimized Battery Charging &amp;gt; toggle off&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open Battery Toolkit from your Applications folder&lt;/li&gt; &#xA; &lt;li&gt;The menu bar will change to show the app menus, and a menu bar extra will should be visible&lt;/li&gt; &#xA; &lt;li&gt;Configure the settings through either method (see &lt;strong&gt;Fig. 2, 3, 4&lt;/strong&gt;)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;&lt;img alt=&#34;Menu Bar Main&#34; src=&#34;https://raw.githubusercontent.com/mhaeuser/Battery-Toolkit/main/Resources/MenuBarMain.png&#34; width=&#34;316&#34;&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;&lt;img alt=&#34;Menu Bar Extra&#34; src=&#34;https://raw.githubusercontent.com/mhaeuser/Battery-Toolkit/main/Resources/MenuBarCommands.png&#34; width=&#34;248&#34;&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Fig. 3&lt;/strong&gt;. &lt;em&gt;Main Menu&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Fig. 4&lt;/strong&gt;. &lt;em&gt;Menu Bar Commands&lt;/em&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;If you prefer, you can quit the GUI to hide the menu bar extra and Battery Toolkit will keep running in the background. If you want to change any settings, simply re-open the app.&lt;/p&gt; &#xA;&lt;h1&gt;Uninstall&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Focus Battery Toolkit&lt;/li&gt; &#xA; &lt;li&gt;Open the main Battery Toolkit menu in the menu bar (see &lt;strong&gt;Fig. 3&lt;/strong&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Choose &#34;Disable Background Activity&#34;&lt;/li&gt; &#xA; &lt;li&gt;Move the app to the Trash and empty it&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Limitations&lt;/h1&gt; &#xA;&lt;p&gt;Battery Toolkit disables sleep while it is charging, because it has to actively disable charging once reaching the maximum. Sleep is re-enabled once charging is stopped for any reason, e.g., reaching the maximum charge level, manual cancellation, or unplugging the MacBook.&lt;/p&gt; &#xA;&lt;p&gt;Apps, including Battery Toolkit, cannot control the charge state when the machine is shut down. If the charger remains plugged in while the Mac is off, the battery will charge to 100&amp;nbsp;%.&lt;/p&gt; &#xA;&lt;p&gt;Note that sleep should usually be disabled when the power adapter is disabled, as this will exit Clamshell mode and the machine will sleep immediately if the lid is closed. Refer to the toggle in the Settings dialog (see &lt;strong&gt;Fig. 1&lt;/strong&gt;).&lt;/p&gt; &#xA;&lt;h1&gt;Technical Details&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Based on IOPowerManagement events to minimize resource usage, especially when not connected to power&lt;/li&gt; &#xA; &lt;li&gt;Support for macOS Ventura daemons and login items for a more reliable experience&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Privileged operations are authenticated by the daemon&lt;/li&gt; &#xA; &lt;li&gt;Privileged daemon exposes only a minimal protocol via XPC&lt;/li&gt; &#xA; &lt;li&gt;XPC communication uses the latest macOS codesign features&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Icon based on &lt;a href=&#34;https://seekicon.com/free-icon/rechargable-battery_1&#34;&gt;reference icon by Streamline&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;README overhauled by &lt;a href=&#34;https://github.com/realrogue&#34;&gt;rogue&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>