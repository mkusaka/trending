<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-26T01:50:23Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ProxymanApp/atlantis</title>
    <updated>2023-01-26T01:50:23Z</updated>
    <id>tag:github.com,2023-01-26:/ProxymanApp/atlantis</id>
    <link href="https://github.com/ProxymanApp/atlantis" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A lightweight and powerful iOS framework for intercepting HTTP/HTTPS Traffic.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ProxymanApp/atlantis/main/images/cover.png&#34; alt=&#34;Atlantis: Debug iOS with ease&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A lightweight and powerful iOS framework for intercepting HTTP/HTTPS Traffic from your app. No more messing around with proxy, certificate config.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cocoapods.org/pods/atlantis-proxyman&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/atlantis-proxyman.svg?style=flat&#34; alt=&#34;Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/atlantis-proxyman&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/atlantis-proxyman.svg?style=flat&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/proxyman_app&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/url?label=%40proxyman_app&amp;amp;style=social&amp;amp;url=https%3A%2F%2Ftwitter.com%2Fproxyman_app&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/Proxyman-app/community?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Proxyman-app/community.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/Proxyman-app/community&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/atlantis-proxyman&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/l/atlantis-proxyman.svg?style=flat&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;strong&gt;Automatically&lt;/strong&gt; intercept all HTTP/HTTPS Traffic with ease&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Capture WS/WSS Traffic from URLSessionWebSocketTask&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Capture gRPC traffic&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; ✅ &lt;strong&gt;No need to config HTTP Proxy, Install or Trust any Certificate&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support iOS Physical Devices and Simulators&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Review traffic log from macOS &lt;a href=&#34;https://proxyman.io&#34;&gt;Proxyman&lt;/a&gt; app (&lt;a href=&#34;https://github.com/ProxymanApp/Proxyman&#34;&gt;Github&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Categorize the log by project and devices.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Only for Traffic Inspector, not for Debugging Tools&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Ready for Production&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ProxymanApp/atlantis/main/images/proxyman_atlantis_3.png&#34; alt=&#34;Atlantis: Capture HTTP/HTTPS traffic from iOS app without Proxy and Certificate with Proxyman&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install Atlantis by CocoaPod or SPM, then starting Atlantis&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;By default, Bonjour service will try to connect all Proxyman app in the same network:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you have only &lt;strong&gt;ONE&lt;/strong&gt; MacOS machine that has Proxyman. Let use the simple version:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;#if DEBUG&#xA;    import Atlantis&#xA;#endif&#xA;&#xA;// Add to the end of `application(_:didFinishLaunchingWithOptions:)` in AppDelegate.swift or SceneDelegate.swift&#xA;#if DEBUG&#xA;    Atlantis.start()&#xA;#endif&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If there are many Proxyman apps from colleague&#39;s Mac Machines, and you would Atlantis connects to your macOS machine. Let use &lt;code&gt;Atlantis.start(hostName:)&lt;/code&gt; version&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;#if DEBUG&#xA;    import Atlantis&#xA;#endif&#xA;&#xA;// Add to the end of `application(_:didFinishLaunchingWithOptions:)` in AppDelegate.swift or SceneDelegate.swift&#xA;#if DEBUG&#xA;    Atlantis.start(hostName: &#34;_your_host_name&#34;)&#xA;#endif&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can get the &lt;code&gt;hostName&lt;/code&gt; from Proxyman -&amp;gt; Certificate menu -&amp;gt; Install for iOS -&amp;gt; Atlantis -&amp;gt; How to Start Atlantis -&amp;gt; and copy the &lt;code&gt;HostName&lt;/code&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/ProxymanApp/atlantis/main/images/atlantis_hostname.png&#34; alt=&#34;Proxyman screenshot&#34; width=&#34;70%&#34; height=&#34;auto&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If your project uses Objective-C, please use &lt;strong&gt;CocoaPod&lt;/strong&gt; to install Atlantis (Install via SPM might not work).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;#import &#34;Atlantis-Swift.h&#34;&#xA;&#xA;// Or import Atlantis as a module, you can use:&#xA;@import Atlantis;&#xA;&#xA;// Add to the end of `application(_:didFinishLaunchingWithOptions:)` in AppDelegate&#xA;[Atlantis startWithHostName:nil];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Make sure your iOS devices/simulator and macOS Proxyman are in the &lt;strong&gt;same Wifi Network&lt;/strong&gt; or connect your iOS Devices to Mac by a &lt;strong&gt;USB cable&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Open macOS &lt;a href=&#34;https://proxyman.io&#34;&gt;Proxyman&lt;/a&gt; (or &lt;a href=&#34;https://proxyman.io/release/osx/Proxyman_latest.dmg&#34;&gt;download the lasted here&lt;/a&gt;) (&lt;a href=&#34;https://github.com/ProxymanApp/Proxyman&#34;&gt;Github&lt;/a&gt;)(2.11.0+)&lt;/li&gt; &#xA; &lt;li&gt;Open your iOS app and Inspect traffic logs from Proxyman app&lt;/li&gt; &#xA; &lt;li&gt;Enjoy debugging ❤️&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Requirement&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;macOS Proxyman app 2.11.0+&lt;/li&gt; &#xA; &lt;li&gt;iOS 13.0+ / macOS 10.15+ / Mac Catalyst 13.0+&lt;/li&gt; &#xA; &lt;li&gt;Xcode 11+&lt;/li&gt; &#xA; &lt;li&gt;Swift 5.0+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Required Configuration for iOS 14+&lt;/h3&gt; &#xA;&lt;p&gt;From iOS 14, it&#39;s required to add &lt;code&gt;NSLocalNetworkUsageDescription&lt;/code&gt; and &lt;code&gt;NSBonjourServices&lt;/code&gt; to your info.plist&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open Info.plist file and adding the following keys and values:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;key&amp;gt;NSLocalNetworkUsageDescription&amp;lt;/key&amp;gt;&#xA;&amp;lt;string&amp;gt;Atlantis would use Bonjour Service to discover Proxyman app from your local network.&amp;lt;/string&amp;gt;&#xA;&amp;lt;key&amp;gt;NSBonjourServices&amp;lt;/key&amp;gt;&#xA;&amp;lt;array&amp;gt;&#xA;    &amp;lt;string&amp;gt;_Proxyman._tcp&amp;lt;/string&amp;gt;&#xA;&amp;lt;/array&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;h3&gt;CocoaPod&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add the following line to your Podfile&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pod &#39;atlantis-proxyman&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift Packages Manager&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add &lt;code&gt;https://github.com/ProxymanApp/atlantis&lt;/code&gt; to your project by: Open Xcode -&amp;gt; File Menu -&amp;gt; Swift Packages -&amp;gt; Add Package Dependency...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add to your Cartfile&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;ProxymanApp/atlantis&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Run &lt;code&gt;carthage update --use-xcframeworks&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Drag Atlantis.framework from your project&lt;/li&gt; &#xA; &lt;li&gt;Create a Carthage Script as the &lt;a href=&#34;https://github.com/Carthage/Carthage#quick-start&#34;&gt;Carthage guideline&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For Carthage with Xcode 12, please check out the workaround: &lt;a href=&#34;https://github.com/Carthage/Carthage/raw/master/Documentation/Xcode12Workaround.md&#34;&gt;https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;WS/WSS Traffic&lt;/h2&gt; &#xA;&lt;p&gt;From Atlantis 1.9.0+, Atlantis is capable of capturing all &lt;a href=&#34;https://github.com/ProxymanApp/atlantis/releases/tag/1.9.0&#34;&gt;WS/WSS Traffic&lt;/a&gt;, which is made by URLSessionWebSocketTask, and send to Proxyman app. You don&#39;t need to config anything, it works out of the box.&lt;/p&gt; &#xA;&lt;h2&gt;Run Example App&lt;/h2&gt; &#xA;&lt;p&gt;Atlantis provides a simple example that it can demonstrate how to integrate and use Atlantis and Proxyman. Please follow the following steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open Proxyman for macOS&lt;/li&gt; &#xA; &lt;li&gt;Open iOS Project at &lt;code&gt;Example/Atlantis-Example-App.xcodeproj&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Start the project with any iPhone/iPad Simulator&lt;/li&gt; &#xA; &lt;li&gt;Click on buttons on the main screen&lt;/li&gt; &#xA; &lt;li&gt;Back to Proxyman app and inspect your HTTPS Request/Response.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ProxymanApp/atlantis/main/images/iOS_Example_App.png&#34; alt=&#34;Atlantis: Capture HTTP/HTTPS traffic from iOS app without Proxy and Certificate with Proxyman&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Advanced Usage&lt;/h2&gt; &#xA;&lt;p&gt;By default, if your iOS app uses Apple&#39;s Networking classes (e.g URLSession) or using popular Networking libraries (e.g Alamofire and AFNetworking) to make an HTTP Request, Atlantis will work &lt;strong&gt;OUT OF THE BOX&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, if your app doesn&#39;t use any one of them, Atlantis is not able to automatically capture the network traffic.&lt;/p&gt; &#xA;&lt;p&gt;To resolve it, Atlantis offers certain functions to help you &lt;strong&gt;manually&lt;/strong&gt;* add your Request and Response that will present on the Proxyman app as usual.&lt;/p&gt; &#xA;&lt;h4&gt;1. My app uses C++ Network library and doesn&#39;t use URLSession, NSURLSession or any iOS Networking library&lt;/h4&gt; &#xA;&lt;p&gt;You can construct the Request and Response for Atlantis from the following func&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;    /// Handy func to manually add Atlantis&#39; Request &amp;amp; Response, then sending to Proxyman for inspecting&#xA;    /// It&#39;s useful if your Request &amp;amp; Response are not URLRequest and URLResponse&#xA;    /// - Parameters:&#xA;    ///   - request: Atlantis&#39; request model&#xA;    ///   - response: Atlantis&#39; response model&#xA;    ///   - responseBody: The body data of the response&#xA;    public class func add(request: Request,&#xA;                          response: Response,&#xA;                          responseBody: Data?) {&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Example:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@IBAction func getManualBtnOnClick(_ sender: Any) {&#xA;    // Init Request and Response&#xA;    let header = Header(key: &#34;X-Data&#34;, value: &#34;Atlantis&#34;)&#xA;    let jsonType = Header(key: &#34;Content-Type&#34;, value: &#34;application/json&#34;)&#xA;    let jsonObj: [String: Any] = [&#34;country&#34;: &#34;Singapore&#34;]&#xA;    let data = try! JSONSerialization.data(withJSONObject: jsonObj, options: [])&#xA;    let request = Request(url: &#34;https://proxyman.io/get/data&#34;, method: &#34;GET&#34;, headers: [header, jsonType], body: data)&#xA;    let response = Response(statusCode: 200, headers: [Header(key: &#34;X-Response&#34;, value: &#34;Internal Error server&#34;), jsonType])&#xA;    let responseObj: [String: Any] = [&#34;error_response&#34;: &#34;Not FOund&#34;]&#xA;    let responseData = try! JSONSerialization.data(withJSONObject: responseObj, options: [])&#xA;    &#xA;    // Add to Atlantis and show it on Proxyman app&#xA;    Atlantis.add(request: request, response: response, responseBody: responseData)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;2. My app use GRPC&lt;/h4&gt; &#xA;&lt;p&gt;You can construct the unary Request and Response from GRPC models via the interceptor pattern that is provided by grpc-swift and leverage this to get a complete log of your calls.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Here is an example for an AtlantisInterceptor&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;        import Atlantis&#xA;        import Foundation&#xA;        import GRPC&#xA;        import NIO&#xA;        import NIOHPACK&#xA;        import SwiftProtobuf&#xA;&#xA;        extension HPACKHeaders {&#xA;            var atlantisHeaders: [Header] { map { Header(key: $0.name, value: $0.value) } }&#xA;        }&#xA;&#xA;        public class AtlantisInterceptor&amp;lt;Request: Message, Response: Message&amp;gt;: ClientInterceptor&amp;lt;Request, Response&amp;gt; {&#xA;            private struct LogEntry {&#xA;                let id = UUID()&#xA;                var path: String = &#34;&#34;&#xA;                var started: Date?&#xA;                var request: LogRequest = .init()&#xA;                var response: LogResponse = .init()&#xA;            }&#xA;&#xA;            private struct LogRequest {&#xA;                var metadata: [Header] = []&#xA;                var messages: [String] = []&#xA;                var ended = false&#xA;            }&#xA;&#xA;            private struct LogResponse {&#xA;                var metadata: [Header] = []&#xA;                var messages: [String] = []&#xA;                var end: (status: GRPCStatus, metadata: String)?&#xA;            }&#xA;&#xA;            private var logEntry = LogEntry()&#xA;&#xA;            override public func send(_ part: GRPCClientRequestPart&amp;lt;Request&amp;gt;,&#xA;                                      promise: EventLoopPromise&amp;lt;Void&amp;gt;?,&#xA;                                      context: ClientInterceptorContext&amp;lt;Request, Response&amp;gt;)&#xA;            {&#xA;                logEntry.path = context.path&#xA;                if logEntry.started == nil {&#xA;                    logEntry.started = Date()&#xA;                }&#xA;                switch context.type {&#xA;                case .clientStreaming, .serverStreaming, .bidirectionalStreaming:&#xA;                    streamingSend(part, type: context.type)&#xA;                case .unary:&#xA;                    unarySend(part)&#xA;                }&#xA;                super.send(part, promise: promise, context: context)&#xA;            }&#xA;&#xA;            private func streamingSend(_ part: GRPCClientRequestPart&amp;lt;Request&amp;gt;, type: GRPCCallType) {&#xA;                switch part {&#xA;                case .metadata(let metadata):&#xA;                    logEntry.request.metadata = metadata.atlantisHeaders&#xA;                case .message(let messageRequest, _):&#xA;                    Atlantis.addGRPCStreaming(id: logEntry.id,&#xA;                                              path: logEntry.path,&#xA;                                              message: .data((try? messageRequest.jsonUTF8Data()) ?? Data()),&#xA;                                              success: true,&#xA;                                              statusCode: 0,&#xA;                                              statusMessage: nil,&#xA;                                              streamingType: type.streamingType,&#xA;                                              type: .send,&#xA;                                              startedAt: logEntry.started,&#xA;                                              endedAt: Date(),&#xA;                                              HPACKHeadersRequest: logEntry.request.metadata,&#xA;                                              HPACKHeadersResponse: logEntry.response.metadata)&#xA;                case .end:&#xA;                    logEntry.request.ended = true&#xA;                    switch type {&#xA;                    case .unary, .serverStreaming, .bidirectionalStreaming:&#xA;                        break&#xA;                    case .clientStreaming:&#xA;                        Atlantis.addGRPCStreaming(id: logEntry.id,&#xA;                                                  path: logEntry.path,&#xA;                                                  message: .string(&#34;end&#34;),&#xA;                                                  success: true,&#xA;                                                  statusCode: 0,&#xA;                                                  statusMessage: nil,&#xA;                                                  streamingType: type.streamingType,&#xA;                                                  type: .send,&#xA;                                                  startedAt: logEntry.started,&#xA;                                                  endedAt: Date(),&#xA;                                                  HPACKHeadersRequest: logEntry.request.metadata,&#xA;                                                  HPACKHeadersResponse: logEntry.response.metadata)&#xA;                    }&#xA;                }&#xA;            }&#xA;&#xA;            private func unarySend(_ part: GRPCClientRequestPart&amp;lt;Request&amp;gt;) {&#xA;                switch part {&#xA;                case .metadata(let metadata):&#xA;                    logEntry.request.metadata = metadata.atlantisHeaders&#xA;                case .message(let messageRequest, _):&#xA;                    logEntry.request.messages.append((try? messageRequest.jsonUTF8Data())?.prettyJson ?? &#34;&#34;)&#xA;                case .end:&#xA;                    logEntry.request.ended = true&#xA;                }&#xA;            }&#xA;&#xA;            override public func receive(_ part: GRPCClientResponsePart&amp;lt;Response&amp;gt;, context: ClientInterceptorContext&amp;lt;Request, Response&amp;gt;) {&#xA;                logEntry.path = context.path&#xA;                switch context.type {&#xA;                case .unary:&#xA;                    unaryReceive(part)&#xA;                case .bidirectionalStreaming, .serverStreaming, .clientStreaming:&#xA;                    streamingReceive(part, type: context.type)&#xA;                }&#xA;                super.receive(part, context: context)&#xA;            }&#xA;&#xA;            private func streamingReceive(_ part: GRPCClientResponsePart&amp;lt;Response&amp;gt;, type: GRPCCallType) {&#xA;                switch part {&#xA;                case .metadata(let metadata):&#xA;                    logEntry.response.metadata = metadata.atlantisHeaders&#xA;                case .message(let messageResponse):&#xA;                    Atlantis.addGRPCStreaming(id: logEntry.id,&#xA;                                              path: logEntry.path,&#xA;                                              message: .data((try? messageResponse.jsonUTF8Data()) ?? Data()),&#xA;                                              success: true,&#xA;                                              statusCode: 0,&#xA;                                              statusMessage: nil,&#xA;                                              streamingType: type.streamingType,&#xA;                                              type: .receive,&#xA;                                              startedAt: logEntry.started,&#xA;                                              endedAt: Date(),&#xA;                                              HPACKHeadersRequest: logEntry.request.metadata,&#xA;                                              HPACKHeadersResponse: logEntry.response.metadata)&#xA;                case .end(let status, _):&#xA;                    Atlantis.addGRPCStreaming(id: logEntry.id,&#xA;                                              path: logEntry.path,&#xA;                                              message: .string(&#34;end&#34;),&#xA;                                              success: status.isOk,&#xA;                                              statusCode: status.code.rawValue,&#xA;                                              statusMessage: status.message,&#xA;                                              streamingType: type.streamingType,&#xA;                                              type: .receive,&#xA;                                              startedAt: logEntry.started,&#xA;                                              endedAt: Date(),&#xA;                                              HPACKHeadersRequest: logEntry.request.metadata,&#xA;                                              HPACKHeadersResponse: logEntry.response.metadata)&#xA;                }&#xA;            }&#xA;&#xA;            private func unaryReceive(_ part: GRPCClientResponsePart&amp;lt;Response&amp;gt;) {&#xA;                switch part {&#xA;                case .metadata(let metadata):&#xA;                    logEntry.response.metadata = metadata.atlantisHeaders&#xA;                case .message(let messageResponse):&#xA;                    logEntry.response.messages.append((try? messageResponse.jsonUTF8Data())?.prettyJson ?? &#34;&#34;)&#xA;                case .end(let status, _):&#xA;                    Atlantis.addGRPCUnary(path: logEntry.path,&#xA;                                          requestObject: logEntry.request.messages.joined(separator: &#34;\n&#34;).data(using: .utf8),&#xA;                                          responseObject: logEntry.response.messages.joined(separator: &#34;\n&#34;).data(using: .utf8),&#xA;                                          success: status.isOk,&#xA;                                          statusCode: status.code.rawValue,&#xA;                                          statusMessage: status.message,&#xA;                                          startedAt: logEntry.started,&#xA;                                          endedAt: Date(),&#xA;                                          HPACKHeadersRequest: logEntry.request.metadata,&#xA;                                          HPACKHeadersResponse: logEntry.response.metadata)&#xA;                }&#xA;            }&#xA;&#xA;            override public func errorCaught(_ error: Error, context: ClientInterceptorContext&amp;lt;Request, Response&amp;gt;) {&#xA;                logEntry.path = context.path&#xA;                switch context.type {&#xA;                case .unary, .bidirectionalStreaming, .serverStreaming, .clientStreaming:&#xA;                    Atlantis.addGRPCUnary(path: logEntry.path,&#xA;                                          requestObject: logEntry.request.messages.joined(separator: &#34;\n&#34;).data(using: .utf8),&#xA;                                          responseObject: logEntry.response.messages.joined(separator: &#34;\n&#34;).data(using: .utf8),&#xA;                                          success: false,&#xA;                                          statusCode: GRPCStatus(code: .unknown, message: &#34;&#34;).code.rawValue,&#xA;                                          statusMessage: error.localizedDescription,&#xA;                                          startedAt: logEntry.started,&#xA;                                          endedAt: Date(),&#xA;                                          HPACKHeadersRequest: logEntry.request.metadata,&#xA;                                          HPACKHeadersResponse: logEntry.response.metadata)&#xA;                }&#xA;&#xA;                super.errorCaught(error, context: context)&#xA;            }&#xA;&#xA;            override public func cancel(promise: EventLoopPromise&amp;lt;Void&amp;gt;?, context: ClientInterceptorContext&amp;lt;Request, Response&amp;gt;) {&#xA;                logEntry.path = context.path&#xA;                switch context.type {&#xA;                case .unary, .bidirectionalStreaming, .serverStreaming, .clientStreaming:&#xA;                    Atlantis.addGRPCUnary(path: logEntry.path,&#xA;                                          requestObject: logEntry.request.messages.joined(separator: &#34;\n&#34;).data(using: .utf8),&#xA;                                          responseObject: logEntry.response.messages.joined(separator: &#34;\n&#34;).data(using: .utf8),&#xA;                                          success: false,&#xA;                                          statusCode: GRPCStatus(code: .cancelled, message: nil).code.rawValue,&#xA;                                          statusMessage: &#34;canceled&#34;,&#xA;                                          startedAt: logEntry.started,&#xA;                                          endedAt: Date(),&#xA;                                          HPACKHeadersRequest: logEntry.request.metadata,&#xA;                                          HPACKHeadersResponse: logEntry.response.metadata)&#xA;                }&#xA;                super.cancel(promise: promise, context: context)&#xA;            }&#xA;        }&#xA;&#xA;        extension GRPCCallType {&#xA;            var streamingType: Atlantis.GRPCStreamingType {&#xA;                switch self {&#xA;                case .clientStreaming:&#xA;                    return .client&#xA;                case .serverStreaming:&#xA;                    return .server&#xA;                case .bidirectionalStreaming:&#xA;                    return .server&#xA;                case .unary:&#xA;                    fatalError(&#34;Unary is not a streaming type&#34;)&#xA;                }&#xA;            }&#xA;        }&#xA;&#xA;        private extension Data {&#xA;            var prettyJson: String? {&#xA;                guard let object = try? JSONSerialization.jsonObject(with: self),&#xA;                      let data = try? JSONSerialization.data(withJSONObject: object, options: [.prettyPrinted]),&#xA;                      let prettyPrintedString = String(data: data, encoding: .utf8) else {&#xA;                          return nil&#xA;                      }&#xA;                return prettyPrintedString&#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Example:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;    public class YourInterceptorFactory: YourClientInterceptorFactoryProtocol {&#xA;        func makeGetYourCallInterceptors() -&amp;gt; [ClientInterceptor&amp;lt;YourRequest, YourResponse&amp;gt;] {&#xA;            [AtlantisInterceptor()]&#xA;        }&#xA;    }&#xA;&#xA;    // Your GRPC services that is generated from SwiftGRPC&#xA;    private let client = NoteServiceServiceClient.init(channel: connectionChannel, interceptors: YourInterceptorFactory())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;3. Use Atlantis on Swift Playground&lt;/h4&gt; &#xA;&lt;p&gt;Atlantis is capable of capturing the HTTP/HTTPS and WS/WSS traffic from your Swift Playground.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;https://github.com/finestructure/Arena&#34;&gt;Arena&lt;/a&gt; to generate a new Swift Playground with Atlantis. If you would like to add Atlantis to your existing Swift Playground, please follow &lt;a href=&#34;https://wwdcbysundell.com/2020/importing-swift-packages-into-a-playground-in-xcode12/&#34;&gt;this tutorial&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Enable Swift Playground Mode&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Atlantis.setIsRunningOniOSPlayground(true)&#xA;Atlantis.start()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Trust Proxyman self-signed certificate&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;for macOS: You don&#39;t need to do anything if you&#39;ve already installed &amp;amp; trusted Proxyman Certificate in Certificate Menu -&amp;gt; Install on this Mac.&lt;/li&gt; &#xA; &lt;li&gt;for iOS: Since iOS Playground doesn&#39;t start any iOS Simulator, it&#39;s impossible to inject the Proxyman Certificate. Therefore, we have to manually trust the certificate. Please use &lt;a href=&#34;https://gist.github.com/NghiaTranUIT/275c8da5068d506869a21bd16da27094&#34;&gt;NetworkSSLProxying&lt;/a&gt; class to do it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Make an HTTP/HTTPS or WS/WSS and inspect it on the Proxyman app.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sample Code: &lt;a href=&#34;https://github.com/ProxymanApp/Atlantis-Swift-Playground-Sample-App&#34;&gt;https://github.com/ProxymanApp/Atlantis-Swift-Playground-Sample-App&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h4&gt;1. How does Atlantis work?&lt;/h4&gt; &#xA;&lt;p&gt;Atlantis uses &lt;a href=&#34;https://nshipster.com/method-swizzling/&#34;&gt;Method Swizzling&lt;/a&gt; technique to swizzle certain functions of NSURLSession that enables Atlantis captures HTTP/HTTPS traffic on the fly.&lt;/p&gt; &#xA;&lt;p&gt;Then it sends to &lt;a href=&#34;https://proxyman.io&#34;&gt;Proxyman app&lt;/a&gt; for inspecting later.&lt;/p&gt; &#xA;&lt;h4&gt;2. How can Atlantis stream the data to the Proxyman app?&lt;/h4&gt; &#xA;&lt;p&gt;As soon as your iOS app (Atlantis is enabled) and the Proxyman macOS app are the same &lt;strong&gt;local network&lt;/strong&gt;, Atlantis could discover the Proxyman app by using &lt;a href=&#34;https://developer.apple.com/bonjour/&#34;&gt;Bonjour Service&lt;/a&gt;. After the connection is established, Atlantis will send the data via Socket.&lt;/p&gt; &#xA;&lt;h4&gt;3. Is it safe to send my network traffic logs to the Proxyman app?&lt;/h4&gt; &#xA;&lt;p&gt;It&#39;s completely &lt;strong&gt;safe&lt;/strong&gt; since your data is locally transferred between your iOS app and the Proxyman app, no Internet is required. All traffic logs are captures and send to the Proxyman app for inspecting on the fly.&lt;/p&gt; &#xA;&lt;p&gt;Atlantis and Proxyman app do not store any of your data on any server.&lt;/p&gt; &#xA;&lt;h4&gt;4. What kind of data that Atlantis capture?&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All HTTP/HTTPS traffic from your iOS apps, that integrate the Atlantis framework&lt;/li&gt; &#xA; &lt;li&gt;Your iOS app name, bundle identifier, and small size of the logo&lt;/li&gt; &#xA; &lt;li&gt;iOS devices/simulators name and device models.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;All the above data are not stored anywhere (except in the memory)&lt;/strong&gt;. It will be wiped out as soon as you close the app.&lt;/p&gt; &#xA;&lt;p&gt;They are required to categorize the traffic on the Proxyman app by project and device name. Therefore, it&#39;s easier to know where the request/response comes from.&lt;/p&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;h3&gt;1. I could not see any request from Atlantis on Proxyman app?&lt;/h3&gt; &#xA;&lt;p&gt;For some reason, Bonjour service might not be able to find Proxyman app.&lt;/p&gt; &#xA;&lt;p&gt;=&amp;gt; Make sure your iOS devices and the Mac are in the &lt;strong&gt;same Wifi Network&lt;/strong&gt; or connect to your Mac with &lt;strong&gt;USB Cable&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;=&amp;gt; Please use &lt;code&gt;Atlantis.start(hostName: &#34;_your_host_name&#34;)&lt;/code&gt; version to explicitly tell Atlantis connect to your Mac.&lt;/p&gt; &#xA;&lt;h3&gt;2. I could not use Debugging Tools on Atlantis&#39;s requests?&lt;/h3&gt; &#xA;&lt;p&gt;Atlantis is built for inspecting the Network, not debugging purpose. If you would like to use Debugging Tools, please consider using normal HTTP Proxy&lt;/p&gt; &#xA;&lt;h2&gt;Credit&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;FLEX and maintainer team: &lt;a href=&#34;https://github.com/FLEXTool/FLEX&#34;&gt;https://github.com/FLEXTool/FLEX&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;@yagiz from Bagel project: &lt;a href=&#34;https://github.com/yagiz/Bagel&#34;&gt;https://github.com/yagiz/Bagel&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Atlantis is released under the Apache-2.0 License. See LICENSE for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ninjaprox/NVActivityIndicatorView</title>
    <updated>2023-01-26T01:50:23Z</updated>
    <id>tag:github.com,2023-01-26:/ninjaprox/NVActivityIndicatorView</id>
    <link href="https://github.com/ninjaprox/NVActivityIndicatorView" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A collection of awesome loading animations&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;NVActivityIndicatorView&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ninjaprox/NVActivityIndicatorView/actions/workflows/ios.yml&#34;&gt;&lt;img src=&#34;https://github.com/ninjaprox/NVActivityIndicatorView/actions/workflows/ios.yml/badge.svg?event=push&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://img.shields.io/cocoapods/v/NVActivityIndicatorView.svg&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/NVActivityIndicatorView.svg?sanitize=true&#34; alt=&#34;Cocoapods Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage Compatible&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;⚠️ Check out &lt;a href=&#34;https://github.com/ninjaprox/LoaderUI&#34;&gt;LoaderUI&lt;/a&gt; (ready to use with Swift Package Mananger supported) for SwiftUI implementation of this. 🎉&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;NVActivityIndicatorView&lt;/code&gt; is a collection of awesome loading animations.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ninjaprox/NVActivityIndicatorView/master/Demo.gif&#34; alt=&#34;Demo&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Animation types&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1. ballPulse&lt;/td&gt; &#xA;   &lt;td&gt;2. ballGridPulse&lt;/td&gt; &#xA;   &lt;td&gt;3. ballClipRotate&lt;/td&gt; &#xA;   &lt;td&gt;4. squareSpin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5. ballClipRotatePulse&lt;/td&gt; &#xA;   &lt;td&gt;6. ballClipRotateMultiple&lt;/td&gt; &#xA;   &lt;td&gt;7. ballPulseRise&lt;/td&gt; &#xA;   &lt;td&gt;8. ballRotate&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;9. cubeTransition&lt;/td&gt; &#xA;   &lt;td&gt;10. ballZigZag&lt;/td&gt; &#xA;   &lt;td&gt;11. ballZigZagDeflect&lt;/td&gt; &#xA;   &lt;td&gt;12. ballTrianglePath&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;13. ballScale&lt;/td&gt; &#xA;   &lt;td&gt;14. lineScale&lt;/td&gt; &#xA;   &lt;td&gt;15. lineScaleParty&lt;/td&gt; &#xA;   &lt;td&gt;16. ballScaleMultiple&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;17. ballPulseSync&lt;/td&gt; &#xA;   &lt;td&gt;18. ballBeat&lt;/td&gt; &#xA;   &lt;td&gt;19. lineScalePulseOut&lt;/td&gt; &#xA;   &lt;td&gt;20. lineScalePulseOutRapid&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;21. ballScaleRipple&lt;/td&gt; &#xA;   &lt;td&gt;22. ballScaleRippleMultiple&lt;/td&gt; &#xA;   &lt;td&gt;23. ballSpinFadeLoader&lt;/td&gt; &#xA;   &lt;td&gt;24. lineSpinFadeLoader&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;25. triangleSkewSpin&lt;/td&gt; &#xA;   &lt;td&gt;26. pacman&lt;/td&gt; &#xA;   &lt;td&gt;27. ballGridBeat&lt;/td&gt; &#xA;   &lt;td&gt;28. semiCircleSpin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;29. ballRotateChase&lt;/td&gt; &#xA;   &lt;td&gt;30. orbit&lt;/td&gt; &#xA;   &lt;td&gt;31. audioEqualizer&lt;/td&gt; &#xA;   &lt;td&gt;32. circleStrokeSpin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Cocoapods&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cocoapods.org/#install&#34;&gt;Cocoapods&lt;/a&gt; is a dependency manager for Swift and Objective-C Cocoa projects. To use NVActivityIndicatorView with CocoaPods, add it in your &lt;code&gt;Podfile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;NVActivityIndicatorView&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Carthage/Carthage#installing-carthage&#34;&gt;Carthage&lt;/a&gt; is intended to be the simplest way to add frameworks to your Cocoa application. To use NVActivityIndicatorView with Carthage, add it in your &lt;code&gt;Cartfile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;github &#34;ninjaprox/NVActivityIndicatorView&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;Swift Package Manager&lt;/a&gt; is a tool for managing the distribution of Swift code. To use NVActivityIndicatorView with Swift Package Manger, add it to &lt;code&gt;dependencies&lt;/code&gt; in your &lt;code&gt;Package.swift&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/ninjaprox/NVActivityIndicatorView.git&#34;)&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Migration&lt;/h2&gt; &#xA;&lt;p&gt;Version &lt;a href=&#34;https://github.com/ninjaprox/NVActivityIndicatorView/releases/tag/5.0.0&#34;&gt;5.0.0&lt;/a&gt; comes with breaking changes. Please refer to the release note for details.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Firstly, import &lt;code&gt;NVActivityIndicatorView&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import NVActivityIndicatorView&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Initialization&lt;/h3&gt; &#xA;&lt;p&gt;Then, there are two ways you can create &lt;code&gt;NVActivityIndicatorView&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;By storyboard, changing class of any &lt;code&gt;UIView&lt;/code&gt; to &lt;code&gt;NVActivityIndicatorView&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt; Set &lt;code&gt;Module&lt;/code&gt; to &lt;code&gt;NVActivityIndicatorView&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;By code, using initializer. All parameters other than &lt;code&gt;frame&lt;/code&gt; are optional and &lt;a href=&#34;https://nvactivityindicatorview.vinhis.me/Classes/NVActivityIndicatorView.html&#34;&gt;&lt;code&gt;NVActivityIndicatorView.DEFAULT_*&lt;/code&gt;&lt;/a&gt; are used as default values.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;NVActivityIndicatorView(frame: frame, type: type, color: color, padding: padding)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Control&lt;/h3&gt; &#xA;&lt;p&gt;Start animating.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;activityIndicatorView.startAnimating()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Stop animating.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;activityIndicatorView.stopAnimating()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Determine if it is animating.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;animating = activityIndicatorView.isAnimating&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Change properties&lt;/h3&gt; &#xA;&lt;p&gt;In storyboard, you can change all properties in Attributes inspector tab of Utilities panel.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt; Use one of values (case-insensitive) in &lt;a href=&#34;https://raw.githubusercontent.com/ninjaprox/NVActivityIndicatorView/master/#animation-types&#34;&gt;Animation types&lt;/a&gt; for &lt;code&gt;Type Name&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;All properties are public so you can change them after initializing.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt; All changes must be made before calling &lt;code&gt;startAnimating()&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://nvactivityindicatorview.vinhis.me/&#34;&gt;https://nvactivityindicatorview.vinhis.me/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgment&lt;/h2&gt; &#xA;&lt;p&gt;Thanks &lt;a href=&#34;https://github.com/ConnorAtherton&#34;&gt;Connor Atherton&lt;/a&gt; for inspired &lt;a href=&#34;https://github.com/ConnorAtherton/loaders.css&#34;&gt;Loaders.css&lt;/a&gt; and &lt;a href=&#34;https://github.com/gontovnik&#34;&gt;Danil Gontovnik&lt;/a&gt; for &lt;a href=&#34;https://github.com/gontovnik/DGActivityIndicatorView&#34;&gt;DGActivityIndicatorView&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The MIT License (MIT)&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2016 Vinh Nguyen &lt;a href=&#34;http://twitter.com/ninjaprox&#34;&gt;@ninjaprox&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>rive-app/rive-ios</title>
    <updated>2023-01-26T01:50:23Z</updated>
    <id>tag:github.com,2023-01-26:/rive-app/rive-ios</id>
    <link href="https://github.com/rive-app/rive-ios" rel="alternate"></link>
    <summary type="html">&lt;p&gt;iOS runtime for Rive&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/rive-app/rive-ios/actions/workflows/build_frameworks.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt; &lt;img src=&#34;https://img.shields.io/discord/532365473602600965&#34; alt=&#34;Discord badge&#34;&gt; &lt;img src=&#34;https://img.shields.io/twitter/follow/rive_app.svg?style=social&amp;amp;label=Follow&#34; alt=&#34;Twitter handle&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Rive iOS&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://rive-app.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fff44ed5f-1eea-4154-81ef-84547e61c3fd%2Frive_notion.png?table=block&amp;amp;id=f198cab2-c0bc-4ce8-970c-42220379bcf3&amp;amp;spaceId=9c949665-9ad9-445f-b9c4-5ee204f8b60c&amp;amp;width=2000&amp;amp;userId=&amp;amp;cache=v2&#34; alt=&#34;Rive hero image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;An iOS runtime library for &lt;a href=&#34;https://rive.app&#34;&gt;Rive&lt;/a&gt; that supports both UIKit and SwiftUI.&lt;/p&gt; &#xA;&lt;p&gt;The library is distributed both through Swift Package Manager and Cocoapods.&lt;/p&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;span&gt;⭐&lt;/span&gt; &lt;a href=&#34;https://raw.githubusercontent.com/rive-app/rive-ios/main/#rive-overview&#34;&gt;Rive Overview&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;🚀 &lt;a href=&#34;https://raw.githubusercontent.com/rive-app/rive-ios/main/#getting-started&#34;&gt;Getting Started &amp;amp; API docs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;span&gt;🔍&lt;/span&gt; &lt;a href=&#34;https://raw.githubusercontent.com/rive-app/rive-ios/main/#supported-devices&#34;&gt;Supported Devices&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;span&gt;📚&lt;/span&gt; &lt;a href=&#34;https://raw.githubusercontent.com/rive-app/rive-ios/main/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;span&gt;🏃&lt;/span&gt; &lt;a href=&#34;https://raw.githubusercontent.com/rive-app/rive-ios/main/#migration-guides&#34;&gt;Migration Guides&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;👨‍💻 &lt;a href=&#34;https://raw.githubusercontent.com/rive-app/rive-ios/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;span&gt;❓&lt;/span&gt; &lt;a href=&#34;https://raw.githubusercontent.com/rive-app/rive-ios/main/#issues&#34;&gt;Issues&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Rive Overview&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://rive.app&#34;&gt;Rive&lt;/a&gt; is a real-time interactive design and animation tool that helps teams create and run interactive animations anywhere. Designers and developers use our collaborative editor to create motion graphics that respond to different states and user inputs. Our lightweight open-source runtime libraries allow them to load their animations into apps, games, and websites.&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;🏡&lt;/span&gt; &lt;a href=&#34;https://rive.app/&#34;&gt;Homepage&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;📘&lt;/span&gt; &lt;a href=&#34;https://help.rive.app/&#34;&gt;General help docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;🛠 &lt;a href=&#34;https://rive.app/learn-rive/&#34;&gt;Learning Rive&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Follow along with the link below for a quick start in getting Rive iOS integrated into your multi-platform applications.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://help.rive.app/runtimes/overview/ios&#34;&gt;Getting Started with Rive in iOS&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Supported Devices&lt;/h2&gt; &#xA;&lt;p&gt;Currently, this runtime library supports a minimum iOS version of &lt;strong&gt;14.0+&lt;/strong&gt;. Devices supported include iPhone, iPad, and Mac catalyst.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Check out the &lt;code&gt;Demo-App/&lt;/code&gt; folder and &lt;code&gt;Example-iOS/&lt;/code&gt; folder for example applications using the Rive iOS runtime. It showcases a number of ways to use the high-level &lt;code&gt;RiveViewModel&lt;/code&gt; API through UIKit and SwiftUI examples, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Setting a Rive file via a URL or asset in the bundle&lt;/li&gt; &#xA; &lt;li&gt;Setting layout and loop mode options&lt;/li&gt; &#xA; &lt;li&gt;Displaying single or multiple animations / artboards on one component&lt;/li&gt; &#xA; &lt;li&gt;Setting up and maniuplating a state machine via inputs&lt;/li&gt; &#xA; &lt;li&gt;...and more!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Migration Guides&lt;/h2&gt; &#xA;&lt;p&gt;Using an older version of the runtime and need to learn how to upgrade to the latest version? Check out the migration guides below in our help center that help guide you through version bumps; breaking changes and all!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://help.rive.app/runtimes/overview/ios/migrating-from-2.x.x-to-3.x.x&#34;&gt;Migration guides&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We love contributions! Check out our &lt;a href=&#34;https://raw.githubusercontent.com/rive-app/rive-ios/main/CONTRIBUTING.md&#34;&gt;contributing docs&lt;/a&gt; to get more details into how to run this project, the examples, and more all locally.&lt;/p&gt; &#xA;&lt;h2&gt;Issues&lt;/h2&gt; &#xA;&lt;p&gt;Have an issue with using the runtime, or want to suggest a feature/API to help make your development life better? Log an issue in our &lt;a href=&#34;https://github.com/rive-app/rive-ios/issues&#34;&gt;issues&lt;/a&gt; tab! You can also browse older issues and discussion threads there to see solutions that may have worked for common problems.&lt;/p&gt;</summary>
  </entry>
</feed>