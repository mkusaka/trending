<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-10T01:44:19Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>marksands/BetterCodable</title>
    <updated>2023-05-10T01:44:19Z</updated>
    <id>tag:github.com,2023-05-10:/marksands/BetterCodable</id>
    <link href="https://github.com/marksands/BetterCodable" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Better Codable through Property Wrappers&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Better Codable through Property Wrappers&lt;/h1&gt; &#xA;&lt;p&gt;Level up your &lt;code&gt;Codable&lt;/code&gt; structs through property wrappers. The goal of these property wrappers is to avoid implementing a custom &lt;code&gt;init(from decoder: Decoder) throws&lt;/code&gt; and suffer through boilerplate.&lt;/p&gt; &#xA;&lt;h2&gt;@LossyArray&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;@LossyArray&lt;/code&gt; decodes Arrays and filters invalid values if the Decoder is unable to decode the value. This is useful when the Array contains non-optional types and your API serves elements that are either null or fail to decode within the container.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;Easily filter nulls from primitive containers&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct Response: Codable {&#xA;    @LossyArray var values: [Int]&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;values&#34;: [1, 2, null, 4, 5, null] }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Response.self, from: json)&#xA;&#xA;print(result) // [1, 2, 4, 5]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or silently exclude failable entities&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct Failable: Codable {&#xA;    let value: String&#xA;}&#xA;&#xA;struct Response: Codable {&#xA;    @LossyArray var values: [Failable]&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;values&#34;: [{&#34;value&#34;: 4}, {&#34;value&#34;: &#34;fish&#34;}] }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Response.self, from: json)&#xA;&#xA;print(result) // [Failable(value: &#34;fish&#34;)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;@LossyDictionary&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;@LossyDictionary&lt;/code&gt; decodes Dictionaries and filters invalid key-value pairs if the Decoder is unable to decode the value. This is useful if the Dictionary is intended to contain non-optional values and your API serves values that are either null or fail to decode within the container.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;Easily filter nulls from primitive containers&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct Response: Codable {&#xA;    @LossyDictionary var values: [String: String]&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;values&#34;: {&#34;a&#34;: &#34;A&#34;, &#34;b&#34;: &#34;B&#34;, &#34;c&#34;: null } }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Response.self, from: json)&#xA;&#xA;print(result) // [&#34;a&#34;: &#34;A&#34;, &#34;b&#34;: &#34;B&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or silently exclude failable entities&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct Failable: Codable {&#xA;    let value: String&#xA;}&#xA;&#xA;struct Response: Codable {&#xA;    @LossyDictionary var values: [String: Failable]&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;values&#34;: {&#34;a&#34;: {&#34;value&#34;: &#34;A&#34;}, &#34;b&#34;: {&#34;value&#34;: 2}} }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Response.self, from: json)&#xA;&#xA;print(result) // [&#34;a&#34;: &#34;A&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;@DefaultCodable&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;@DefaultCodable&lt;/code&gt; provides a generic property wrapper that allows for default values using a custom &lt;code&gt;DefaultCodableStrategy&lt;/code&gt;. This allows one to implement their own default behavior for missing data and get the property wrapper behavior for free. Below are a few common default strategies, but they also serve as a template to implement a custom property wrapper to suit your specific use case.&lt;/p&gt; &#xA;&lt;p&gt;While not provided in the source code, it&#39;s a sinch to create your own default strategy for your custom data flow.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct RefreshDaily: DefaultCodableStrategy {&#xA;    static var defaultValue: CacheInterval { return CacheInterval.daily }&#xA;}&#xA;&#xA;struct Cache: Codable {&#xA;    @DefaultCodable&amp;lt;RefreshDaily&amp;gt; var refreshInterval: CacheInterval&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;refreshInterval&#34;: null }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Cache.self, from: json)&#xA;&#xA;print(result) // Cache(refreshInterval: .daily)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;@DefaultFalse&lt;/h2&gt; &#xA;&lt;p&gt;Optional Bools are weird. A type that once meant true or false, now has three possible states: &lt;code&gt;.some(true)&lt;/code&gt;, &lt;code&gt;.some(false)&lt;/code&gt;, or &lt;code&gt;.none&lt;/code&gt;. And the &lt;code&gt;.none&lt;/code&gt; condition &lt;em&gt;could&lt;/em&gt; indicate truthiness if BadDecisionsâ„¢ were made.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;@DefaultFalse&lt;/code&gt; mitigates the confusion by defaulting decoded Bools to false if the Decoder is unable to decode the value, either when null is encountered or some unexpected type.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct UserPrivilege: Codable {&#xA;    @DefaultFalse var isAdmin: Bool&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;isAdmin&#34;: null }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Response.self, from: json)&#xA;&#xA;print(result) // UserPrivilege(isAdmin: false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;@DefaultEmptyArray&lt;/h2&gt; &#xA;&lt;p&gt;The weirdness of Optional Booleans extends to other types, such as Arrays. Soroush has a &lt;a href=&#34;http://khanlou.com/2016/10/emptiness/&#34;&gt;great blog post&lt;/a&gt; explaining why you may want to avoid Optional Arrays. Unfortunately, this idea doesn&#39;t come for free in Swift out of the box. Being forced to implement a custom initializer in order to nil coalesce nil arrays to empty arrays is no fun.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;@DefaultEmptyArray&lt;/code&gt; decodes Arrays and returns an empty array instead of nil if the Decoder is unable to decode the container.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct Response: Codable {&#xA;    @DefaultEmptyArray var favorites: [Favorite]&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;favorites&#34;: null }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Response.self, from: json)&#xA;&#xA;print(result) // Response(favorites: [])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;@DefaultEmptyDictionary&lt;/h2&gt; &#xA;&lt;p&gt;As mentioned previously, Optional Dictionaries are yet another container where nil and emptiness collide.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;@DefaultEmptyDictionary&lt;/code&gt; decodes Dictionaries and returns an empty dictionary instead of nil if the Decoder is unable to decode the container.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct Response: Codable {&#xA;    @DefaultEmptyDictionary var scores: [String: Int]&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;scores&#34;: null }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Response.self, from: json)&#xA;&#xA;print(result) // Response(values: [:])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;@LosslessValue&lt;/h2&gt; &#xA;&lt;p&gt;All credit for this goes to &lt;a href=&#34;https://twitter.com/iankay&#34;&gt;Ian Keen&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Somtimes APIs can be unpredictable. They may treat some form of Identifiers or SKUs as &lt;code&gt;Int&lt;/code&gt;s for one response and &lt;code&gt;String&lt;/code&gt;s for another. Or you might find yourself encountering &lt;code&gt;&#34;true&#34;&lt;/code&gt; when you expect a boolean. This is where &lt;code&gt;@LosslessValue&lt;/code&gt; comes into play.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;@LosslessValue&lt;/code&gt; will attempt to decode a value into the type that you expect, preserving the data that would otherwise throw an exception or be lost altogether.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct Response: Codable {&#xA;    @LosslessValue var sku: String&#xA;    @LosslessValue var isAvailable: Bool&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;sku&#34;: 12345, &#34;isAvailable&#34;: &#34;true&#34; }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Response.self, from: json)&#xA;&#xA;print(result) // Response(sku: &#34;12355&#34;, isAvailable: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Date Wrappers&lt;/h2&gt; &#xA;&lt;p&gt;One common frustration with &lt;code&gt;Codable&lt;/code&gt; is decoding entities that have mixed date formats. &lt;code&gt;JSONDecoder&lt;/code&gt; comes built in with a handy &lt;code&gt;dateDecodingStrategy&lt;/code&gt; property, but that uses the same date format for all dates that it will decode. And often, &lt;code&gt;JSONDecoder&lt;/code&gt; lives elsewhere from the entity forcing tight coupling with the entities if you choose to use its date decoding strategy.&lt;/p&gt; &#xA;&lt;p&gt;Property wrappers are a nice solution to the aforementioned issues. It allows tight binding of the date formatting strategy directly with the property of the entity, and allows the &lt;code&gt;JSONDecoder&lt;/code&gt; to remain decoupled from the entities it decodes. The &lt;code&gt;@DateValue&lt;/code&gt; wrapper is generic across a custom &lt;code&gt;DateValueCodableStrategy&lt;/code&gt;. This allows anyone to implement their own date decoding strategy and get the property wrapper behavior for free. Below are a few common Date strategies, but they also serve as a template to implement a custom property wrapper to suit your specific date format needs.&lt;/p&gt; &#xA;&lt;p&gt;The following property wrappers are heavily inspired by &lt;a href=&#34;https://twitter.com/iankay&#34;&gt;Ian Keen&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;ISO8601Strategy&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;ISO8601Strategy&lt;/code&gt; relies on an &lt;code&gt;ISO8601DateFormatter&lt;/code&gt; in order to decode &lt;code&gt;String&lt;/code&gt; values into &lt;code&gt;Date&lt;/code&gt;s. Encoding the date will encode the value into the original string value.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct Response: Codable {&#xA;    @DateValue&amp;lt;ISO8601Strategy&amp;gt; var date: Date&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;date&#34;: &#34;1996-12-19T16:39:57-08:00&#34; }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Response.self, from: json)&#xA;&#xA;// This produces a valid `Date` representing 39 minutes and 57 seconds after the 16th hour of December 19th, 1996 with an offset of -08:00 from UTC (Pacific Standard Time).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;RFC3339Strategy&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;RFC3339Strategy&lt;/code&gt; decodes RFC 3339 date strings into &lt;code&gt;Date&lt;/code&gt;s. Encoding the date will encode the value back into the original string value.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct Response: Codable {&#xA;    @DateValue&amp;lt;RFC3339Strategy&amp;gt; var date: Date&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;date&#34;: &#34;1996-12-19T16:39:57-08:00&#34; }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Response.self, from: json)&#xA;&#xA;// This produces a valid `Date` representing 39 minutes and 57 seconds after the 16th hour of December 19th, 1996 with an offset of -08:00 from UTC (Pacific Standard Time).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;TimestampStrategy&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;TimestampStrategy&lt;/code&gt; decodes &lt;code&gt;Double&lt;/code&gt;s of a unix epoch into &lt;code&gt;Date&lt;/code&gt;s. Encoding the date will encode the value into the original &lt;code&gt;TimeInterval&lt;/code&gt; value.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct Response: Codable {&#xA;    @DateValue&amp;lt;TimestampStrategy&amp;gt; var date: Date&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;date&#34;: 978307200.0 }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Response.self, from: json)&#xA;&#xA;// This produces a valid `Date` representing January 1st, 2001.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;YearMonthDayStrategy&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;@DateValue&amp;lt;YearMonthDayStrategy&amp;gt;&lt;/code&gt; decodes string values into &lt;code&gt;Date&lt;/code&gt;s using the date format &lt;code&gt;y-MM-dd&lt;/code&gt;. Encoding the date will encode the value back into the original string format.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct Response: Codable {&#xA;    @DateValue&amp;lt;YearMonthDayStrategy&amp;gt; var date: Date&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;date&#34;: &#34;2001-01-01&#34; }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Response.self, from: json)&#xA;&#xA;// This produces a valid `Date` representing January 1st, 2001.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or lastly, you can mix and match date wrappers as needed where the benefits truly shine&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;struct Response: Codable {&#xA;    @DateValue&amp;lt;ISO8601Strategy&amp;gt; var updatedAt: Date&#xA;    @DateValue&amp;lt;YearMonthDayStrategy&amp;gt; var birthday: Date&#xA;}&#xA;&#xA;let json = #&#34;{ &#34;updatedAt&#34;: &#34;2019-10-19T16:14:32-05:00&#34;, &#34;birthday&#34;: &#34;1984-01-22&#34; }&#34;#.data(using: .utf8)!&#xA;let result = try JSONDecoder().decode(Response.self, from: json)&#xA;&#xA;// This produces two valid `Date` values, `updatedAt` representing October 19, 2019 and `birthday` January 22nd, 1984.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;BetterCodable&#39;, &#39;~&amp;gt; 0.1.0&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;h2&gt;Attribution&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under MIT. If you find these useful, please tell your boss where you found them.&lt;/p&gt;</summary>
  </entry>
</feed>