<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-19T01:37:41Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tsalvo/nes-emu-ios</title>
    <updated>2024-04-19T01:37:41Z</updated>
    <id>tag:github.com,2024-04-19:/tsalvo/nes-emu-ios</id>
    <link href="https://github.com/tsalvo/nes-emu-ios" rel="alternate"></link>
    <summary type="html">&lt;p&gt;NES Emulator for iOS / iPadOS / macOS / tvOS, written in Swift&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;nes-emu-ios&lt;/h1&gt; &#xA;&lt;p&gt;An NES emulator written in Swift for iOS / iPadOS / macOS / tvOS. The NES emulation code is heavily based off of fogleman&#39;s NES emulator in Go: &lt;a href=&#34;https://github.com/fogleman/nes&#34;&gt;https://github.com/fogleman/nes&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Screenshots&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tsalvo/nes-emu-ios/master/screenshots/screenshot01.png?raw=true&#34; alt=&#34;NesRomViewController&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/tsalvo/nes-emu-ios/master/screenshots/screenshot02.png?raw=true&#34; alt=&#34;UIDocumentBrowserViewController&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/tsalvo/nes-emu-ios/master/screenshots/screenshot03.png?raw=true&#34; alt=&#34;ConsoleStateViewController&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/tsalvo/nes-emu-ios/master/screenshots/screenshot04.png?raw=true&#34; alt=&#34;SettingsViewController&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This app uses the &lt;code&gt;UIDocumentBrowserViewController&lt;/code&gt; for easy NES ROM (&lt;code&gt;.nes&lt;/code&gt;) file browsing using the native Files app interface. During emulation, PPU output frames are converted to a &lt;code&gt;CIImage&lt;/code&gt; and rendered to a Metal Texture (&lt;code&gt;MTLTexture&lt;/code&gt;) within a MetalKit View (&lt;code&gt;MTKView&lt;/code&gt;). The app uses &lt;code&gt;AVAudioEngine&lt;/code&gt; for sound, with buffers scheduled periodically from the APU output. Save states are persisted using &lt;code&gt;CoreData&lt;/code&gt;. Everything is done using native iOS frameworks, and no third-party libraries.&lt;/p&gt; &#xA;&lt;h2&gt;Current Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;6502 CPU emulation&lt;/li&gt; &#xA; &lt;li&gt;PPU emulation (picture processing unit)&lt;/li&gt; &#xA; &lt;li&gt;APU emulation (audio processing unit)&lt;/li&gt; &#xA; &lt;li&gt;Mapper emulation for several common mappers&lt;/li&gt; &#xA; &lt;li&gt;Touchscreen controls&lt;/li&gt; &#xA; &lt;li&gt;Save states with autosave on exit, and automatic loading of most recent save on game start. Automatic saving and loading can be enabled or disabled in the settings. &lt;strong&gt;The data structure of states may change slightly for future builds, so if you build from an updated source, you may need to erase existing save states or uninstall the previous version.&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Gamepad controls using built-in &lt;code&gt;GameController&lt;/code&gt; framework and &lt;code&gt;extendedGamepad&lt;/code&gt; profile. MFi controllers, Sony DualSense / DualShock 4, or Xbox Wireless controllers should all work. Touchscreen controls auto-hide when a controller is paired for player 1, and auto-show when the player 1 controller disconnects. Whenever a second controller is paired, it should be mapped automatically for player 2.&lt;/li&gt; &#xA; &lt;li&gt;Builds successfully for iOS 14.7+, iPadOS 14.7+, tvOS 14.7+, or Mac Catalyst (macOS 12.0 Monterey or newer). The Mac Catalyst version of the app still needs some Mac-specific tweaks. The tvOS version does not include the &lt;code&gt;UIDocumentBrowserViewController&lt;/code&gt; for ROM browsing, because it is unavailable on the tvOS platform. For now, ROMs must be included directly in the tvOS app bundle before building and installing onto a device (copied to &lt;code&gt;/nes-emu-tvos/Resources/&lt;/code&gt;, and added to the &lt;code&gt;nes-emu-tvos&lt;/code&gt; build target).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Game Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;The following mappers have been implemented:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;000 NROM&lt;/li&gt; &#xA; &lt;li&gt;001 MMC1&lt;/li&gt; &#xA; &lt;li&gt;002 UNROM&lt;/li&gt; &#xA; &lt;li&gt;003 CNROM&lt;/li&gt; &#xA; &lt;li&gt;004 MMC3&lt;/li&gt; &#xA; &lt;li&gt;005 MMC5 (missing some features)&lt;/li&gt; &#xA; &lt;li&gt;007 AxROM&lt;/li&gt; &#xA; &lt;li&gt;009 MMC2&lt;/li&gt; &#xA; &lt;li&gt;010 MMC4&lt;/li&gt; &#xA; &lt;li&gt;011 ColorDreams&lt;/li&gt; &#xA; &lt;li&gt;023 VRC2b / VRC4e / VRC4f&lt;/li&gt; &#xA; &lt;li&gt;025 VRC2c / VRC4b / VRC4d&lt;/li&gt; &#xA; &lt;li&gt;040 NTDEC2722&lt;/li&gt; &#xA; &lt;li&gt;066 GxROM&lt;/li&gt; &#xA; &lt;li&gt;078 Mapper 78&lt;/li&gt; &#xA; &lt;li&gt;085 VRC7 (missing expansion audio)&lt;/li&gt; &#xA; &lt;li&gt;087 Mapper 87&lt;/li&gt; &#xA; &lt;li&gt;118 TxSROM&lt;/li&gt; &#xA; &lt;li&gt;119 TQROM&lt;/li&gt; &#xA; &lt;li&gt;206 Namcot 118 / Tengen Mimic 1&lt;/li&gt; &#xA; &lt;li&gt;232 Camerica Quattro&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The majority of games should work with the above list of supported mappers, with more supported mappers coming soon.&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;For best performance, build the app for &lt;strong&gt;release&lt;/strong&gt; mode instead of debug. Or, if you want better performance for debug builds, change these debug build settings under Swift Compiler - Code Generation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Disable Safety Checks = YES&lt;/li&gt; &#xA; &lt;li&gt;Exclusive Access to Memory = Compile Time Enforcement Only&lt;/li&gt; &#xA; &lt;li&gt;Optimization level = Optimize for Speed [-O]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Near Future Plans&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support more mappers&lt;/li&gt; &#xA; &lt;li&gt;Performance improvements (look for low hanging fruit in areas of the app that are taking the longest).&lt;/li&gt; &#xA; &lt;li&gt;On-screen control improvements (bigger tap areas, better layout).&lt;/li&gt; &#xA; &lt;li&gt;Improvements to tvOS app target (full-screen layout, mechanism to load new ROMs after installation)&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>stelabouras/privacy-manifest</title>
    <updated>2024-04-19T01:37:41Z</updated>
    <id>tag:github.com,2024-04-19:/stelabouras/privacy-manifest</id>
    <link href="https://github.com/stelabouras/privacy-manifest" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A simple tool that parses your Xcode project/workspace or Swift Package, detects required reason APIs and generates a Privacy Manifest if needed.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Privacy Manifest&lt;/h1&gt; &#xA;&lt;p align=&#34;left&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/macOS_v13%2B-_?style=flat&amp;amp;logo=apple&amp;amp;label=platform&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Privacy Manifest CLI tool parses an Xcode project/workspace or a Swift Package and attempts to locate calls to Apple&#39;s required reason APIs &lt;a href=&#34;https://developer.apple.com/documentation/bundleresources/privacy_manifest_files/describing_use_of_required_reason_api&#34;&gt;^1&lt;/a&gt; and detect privacy collected data frameworks [^2].&lt;/p&gt; &#xA;&lt;p&gt;The tool detects and parses the source files of the project as well as the frameworks added in the Xcode project&#39;s Build Phase or in the Swift Package dependencies. It also detects any frameworks / static libraries and checks if they are included in the third-party SDK list that Apple has provided [^3].&lt;/p&gt; &#xA;&lt;p&gt;The tool does not perform any sort of analysis beyond the simple line-by-line check for the existence of the method calls or symbols that Apple has already published.&lt;/p&gt; &#xA;&lt;p&gt;The tool uses a concurrent queue to speed up the parsing process.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can either use the tool by typing: &lt;code&gt;swift run privacy-manifest&lt;/code&gt; in the root directory of the project, or you can install the executable to &lt;code&gt;/usr/local/bin&lt;/code&gt; directory so that you can call it from any folder.&lt;/p&gt; &#xA;&lt;p&gt;Check out the project and run the following command in the project root to install the binary to &lt;code&gt;/usr/local/bin&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;After installing the tool to the &lt;code&gt;/usr/local/bin&lt;/code&gt; directory, you can invoke it from any directory using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;privacy-manifest analyze --project path/to/project --reveal-occurrences --output path&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;path/to/project&lt;/code&gt; can be a relative or an absolute path to the &lt;code&gt;.xcodeproj&lt;/code&gt; or &lt;code&gt;Package.swift&lt;/code&gt; file of your project.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;--reveal-occurrences&lt;/code&gt; is an optional flag that displays extended information regarding the occurrences of the required reason APIs / privacy collected data frameworks in your codebase, highlighting the file and the line where a call has been detected.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;--output&lt;/code&gt; flag is optional and if specified, a &lt;code&gt;PrivacyInfo.xcprivacy&lt;/code&gt; property list file will be generated to that directory based on the detected required reason APIs and from the responses of the user.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;Below is the console output from the &lt;a href=&#34;https://github.com/videolan/vlc-ios&#34;&gt;VLC iOS OSS&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/stelabouras/privacy-manifest/main/.github/privacymanifest-vlc.gif&#34; alt=&#34;Privacy Manifest analyze running for VLC iOS project&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Future implementations&lt;/h2&gt; &#xA;&lt;p&gt;The tool can output the occurrences report to HTML for better readability.&lt;/p&gt; &#xA;&lt;p&gt;On top of that, the list of third-party crash frameworks can be updated so that it can inform the user when such framework is detected (there is a related TODO in the code).&lt;/p&gt; &#xA;&lt;h2&gt;Disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;Do not use this tool alone to create your privacy manifest file for your app or SDK. You must always double-check the occurrences that the tool displays as the tool does not know whether a certain occurrence is included in a comment or on an unused piece of code. Furthermore, there might also be cases where something has not been included in the parsing process.&lt;/p&gt; &#xA;&lt;p&gt;This tool gives you a high-level overview of the different required reason APIs and privacy collected data frameworks your project, workspace or package uses, so always do your own research after using this tool, to confirm the findings.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under Apache License 2.0, see &lt;a href=&#34;https://raw.githubusercontent.com/stelabouras/privacy-manifest/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;[^2]: &lt;a href=&#34;https://developer.apple.com/documentation/bundleresources/privacy_manifest_files/describing_data_use_in_privacy_manifests&#34;&gt;https://developer.apple.com/documentation/bundleresources/privacy_manifest_files/describing_data_use_in_privacy_manifests&lt;/a&gt;). [^3]: &lt;a href=&#34;https://developer.apple.com/support/third-party-SDK-requirements/&#34;&gt;https://developer.apple.com/support/third-party-SDK-requirements/&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jrendel/SwiftKeychainWrapper</title>
    <updated>2024-04-19T01:37:41Z</updated>
    <id>tag:github.com,2024-04-19:/jrendel/SwiftKeychainWrapper</id>
    <link href="https://github.com/jrendel/SwiftKeychainWrapper" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A simple wrapper for the iOS Keychain to allow you to use it in a similar fashion to User Defaults. Written in Swift.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;span&gt;â›”&lt;/span&gt; [DEPRECATED] This library is not being kept up to date. This was created when Swift was first released as a simple way to work with the Keychain. But the approach was restricted and not suited to more advanced keychain usage.&lt;/p&gt; &#xA;&lt;h1&gt;SwiftKeychainWrapper&lt;/h1&gt; &#xA;&lt;p&gt;A simple wrapper for the iOS / tvOS Keychain to allow you to use it in a similar fashion to User Defaults. Written in Swift.&lt;/p&gt; &#xA;&lt;p&gt;Provides singleton instance that is setup to work for most needs. Use &lt;code&gt;KeychainWrapper.standard&lt;/code&gt; to access the singleton instance.&lt;/p&gt; &#xA;&lt;p&gt;If you need to customize the keychain access to use a custom identifier or access group, you can create your own instance instead of using the singleton instance.&lt;/p&gt; &#xA;&lt;p&gt;By default, the Keychain Wrapper saves data as a Generic Password type in the iOS Keychain. It saves items such that they can only be accessed when the app is unlocked and open. If you are not familiar with the iOS Keychain usage, this provides a safe default for using the keychain.&lt;/p&gt; &#xA;&lt;p&gt;Users that want to deviate from this default implementation, now can do so in version 2.0 and up. Each request to save/read a key value now allows you to specify the keychain accessibility for that key.&lt;/p&gt; &#xA;&lt;h2&gt;General Usage&lt;/h2&gt; &#xA;&lt;p&gt;Add a string value to keychain:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let saveSuccessful: Bool = KeychainWrapper.standard.set(&#34;Some String&#34;, forKey: &#34;myKey&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Retrieve a string value from keychain:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let retrievedString: String? = KeychainWrapper.standard.string(forKey: &#34;myKey&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Remove a string value from keychain:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let removeSuccessful: Bool = KeychainWrapper.standard.removeObject(forKey: &#34;myKey&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom Instance&lt;/h2&gt; &#xA;&lt;p&gt;When the Keychain Wrapper is used, all keys are linked to a common identifier for your app, called the service name. By default this uses your main bundle identifier. However, you may also change it, or store multiple items to the keychain under different identifiers.&lt;/p&gt; &#xA;&lt;p&gt;To share keychain items between your applications, you may specify an access group and use that same access group in each application.&lt;/p&gt; &#xA;&lt;p&gt;To set a custom service name identifier or access group, you may now create your own instance of the keychain wrapper as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let uniqueServiceName = &#34;customServiceName&#34;&#xA;let uniqueAccessGroup = &#34;sharedAccessGroupName&#34;&#xA;let customKeychainWrapperInstance = KeychainWrapper(serviceName: uniqueServiceName, accessGroup: uniqueAccessGroup)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The custom instance can then be used in place of the shared instance or static accessors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let saveSuccessful: Bool = customKeychainWrapperInstance.set(&#34;Some String&#34;, forKey: &#34;myKey&#34;)&#xA;&#xA;let retrievedString: String? = customKeychainWrapperInstance.string(forKey: &#34;myKey&#34;)&#xA;&#xA;let removeSuccessful: Bool = customKeychainWrapperInstance.removeObject(forKey: &#34;myKey&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Subscript usage&lt;/h2&gt; &#xA;&lt;p&gt;Keychain can also be accessed with subscript as it is in dictionary. Keys can be predefined and listed in one place for convenience.&lt;/p&gt; &#xA;&lt;p&gt;Firstly, let&#39;s define the key to use later.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension KeychainWrapper.Key {&#xA;    static let myKey: KeychainWrapper.Key = &#34;myKey&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And now we can use this key as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;KeychainWrapper.standard[.myKey] = &#34;some string&#34;&#xA;&#xA;let myValue: String? = KeychainWrapper.standard[.myKey]&#xA;&#xA;KeychainWrapper.standard.remove(forKey: .myKey)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Accessibility Options&lt;/h2&gt; &#xA;&lt;p&gt;By default, all items saved to keychain can only be accessed when the device is unlocked. To change this accessibility, an optional &lt;code&gt;withAccessibility&lt;/code&gt; param can be set on all requests. The enum &lt;code&gt;KeychainItemAccessibilty&lt;/code&gt; provides an easy way to select the accessibility level desired:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;KeychainWrapper.standard.set(&#34;Some String&#34;, forKey: &#34;myKey&#34;, withAccessibility: .AfterFirstUnlock)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Synchronizable Option&lt;/h2&gt; &#xA;&lt;p&gt;By default, all items saved to keychain are not synchronizable, so they are not synced with the iCloud. To change this, an &lt;code&gt;isSynchronizable&lt;/code&gt; bool param can be set on all requests. You need the item to be synchronized with the iCloud if you want to have it on all of your devices:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;KeychainWrapper.standard.set(&#34;Some String&#34;, forKey: &#34;myKey&#34;, isSynchronizable: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important:&lt;/strong&gt; You can&#39;t modify value for key if it was previously set with different accessibility option. Remove the value for key and set it with new accessibility option. (Otherwise the value will not change).&lt;br&gt; For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;KeychainWrapper.standard.set(&#34;String one&#34;, forKey: &#34;myKey&#34;, withAccessibility: .AfterFirstUnlock)&#xA;KeychainWrapper.standard.removeObject(forKey: &#34;myKey&#34;)&#xA;KeychainWrapper.standard.set(&#34;String two&#34;, forKey: &#34;myKey&#34;, withAccessibility: .Always)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h4&gt;CocoaPods&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;http://cocoapods.org/&#34;&gt;CocoaPods&lt;/a&gt; to install SwiftKeychainWrapper by adding it to your &lt;code&gt;Podfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;use_frameworks!&#xA;platform :ios, &#39;8.0&#39;&#xA;&#xA;target &#39;target_name&#39; do&#xA;   pod &#39;SwiftKeychainWrapper&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To use the keychain wrapper in your app, import SwiftKeychainWrapper into the file(s) where you want to use it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import SwiftKeychainWrapper&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Carthage&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt; to install SwiftKeychainWrapper by adding it to your &lt;code&gt;Cartfile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Swift 3.0:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;jrendel/SwiftKeychainWrapper&#34; ~&amp;gt; 3.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Swift 2.3:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;jrendel/SwiftKeychainWrapper&#34; == 2.1.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Swift Package Manager&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;Swift Package Manager&lt;/a&gt; to install SwiftKeychainWrapper using Xcode:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Open your project in Xcode&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Click &#34;File&#34; -&amp;gt; &#34;Swift Packages&#34; -&amp;gt; &#34;Add Package Dependency...&#34;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Paste the following URL: &lt;a href=&#34;https://github.com/jrendel/SwiftKeychainWrapper&#34;&gt;https://github.com/jrendel/SwiftKeychainWrapper&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Click &#34;Next&#34; -&amp;gt; &#34;Next&#34; -&amp;gt; &#34;Finish&#34;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Manually&lt;/h4&gt; &#xA;&lt;p&gt;Download and drop &lt;code&gt;KeychainWrapper.swift&lt;/code&gt; and &lt;code&gt;KeychainItemAcessibility.swift&lt;/code&gt; into your project.&lt;/p&gt; &#xA;&lt;h2&gt;Release History&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;4.1 Added conditional logic for CGFloat accessories for when package is used where CGFloat is not available&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;4.0 Updated with SPM support and other community PRs. Minimum iOS version is now 9.0.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;3.4&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Changed how Swift version is defined for CocoaPods&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;3.3&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Updates for Swift 5.0 and Xcode 10.2&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;3.2&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Updates for Swift 4.2 and Xcode 10&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;3.1&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Updates for Swift 3.1&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;3.0.1&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Added a host app for the unit tests to get around the issue with keychain access not working the same on iOS 10 simulators&lt;/li&gt; &#xA;   &lt;li&gt;Minor update to readme instructions&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;3.0&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Swift 3.0 update. Contains breaking API changes. 2.2.0 and 2.2.1 are now rolled into 3.0&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;2.2.1 (Removed from Cocoapods)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Syntax updates to be more Swift 3 like&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;2.2 (Removed from Cocoapods)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Updated to support Swift 3.0&lt;/li&gt; &#xA;   &lt;li&gt;Remove deprecated functions (static access)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;2.1&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Updated to support Swift 2.3&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;2.0&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Further changes to more closely align the API with how &lt;code&gt;NSUserDefaults&lt;/code&gt; works. Access to the default implementation is now done through a singleton instance. Static accessors have been included that wrap this shared instance to maintain backwards compatibility. These will be removed in the next update&lt;/li&gt; &#xA;   &lt;li&gt;Ability to change keychain service name identifier and access group on the shared instance has been deprecated. Users now have the ability to create their own instance of the keychain if they want to customize these.&lt;/li&gt; &#xA;   &lt;li&gt;Addtional options have been provided to alter the keychain accessibility for each key value saved.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;1.0.11&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Update for Swift 2.0&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;1.0.10&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Update License info. Merged Pull Request with Carthage support.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;1.0.8&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Update for Swift 1.2&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;1.0.7&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Determined that once provisioned correctly for access groups, using KeychainWrapper on the simulator with access groups works. So I removed the simulator related check and unit tests previously added.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;1.0.6&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;Support for Access Groups&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;SwiftKeychainWrapperExample has been updated to show usage with an Access Group: &lt;a href=&#34;https://github.com/jrendel/SwiftKeychainWrapperExample&#34;&gt;https://github.com/jrendel/SwiftKeychainWrapperExample&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Access Groups do not work on the simulator. Apps that are built for the simulator aren&#39;t signed, so there&#39;s no keychain access group for the simulator to check. This means that all apps can see all keychain items when run on the simulator. Attempting to set an access group will result in a failure when attempting to Add or Update keychain items. Because of this, the Keychain Wrapper detects if it is being using on a simulator and will not set an access group property if one is set. This allows the Keychain Wrapper to still be used on the simulator for development of your app. To properly test Keychain Access Groups, you will need to test on a device.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;1.0.5&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;This version converts the project to a proper Swift Framework and adds a podspec file to be compatible with the latest CocoaPods pre-release, which now supports Swift.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;To see an example of usage with CocoaPods, I&#39;ve created the repo SwiftKeychainWrapperExample: &lt;a href=&#34;https://github.com/jrendel/SwiftKeychainWrapperExample&#34;&gt;https://github.com/jrendel/SwiftKeychainWrapperExample&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;1.0.2&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Updated for Xcode 6.1&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;I&#39;ve been using an Objective-C based wrapper in my own projects for the past couple years. The original library I wrote for myself was based on the following tutorial:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.raywenderlich.com/6475/basic-security-in-ios-5-tutorial-part-1&#34;&gt;http://www.raywenderlich.com/6475/basic-security-in-ios-5-tutorial-part-1&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is a rewrite of that code in Swift.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>