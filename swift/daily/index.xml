<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-02T01:38:55Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kaishin/Gifu</title>
    <updated>2024-04-02T01:38:55Z</updated>
    <id>tag:github.com,2024-04-02:/kaishin/Gifu</id>
    <link href="https://github.com/kaishin/Gifu" rel="alternate"></link>
    <summary type="html">&lt;p&gt;High-performance animated GIF support for iOS in Swift&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;img src=&#34;https://github.com/kaishin/Gifu/raw/master/header.gif&#34; alt=&#34;Logo&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/kaishin/Gifu/workflows/Test/badge.svg?sanitize=true&#34; alt=&#34;Test&#34;&gt; &lt;a href=&#34;https://github.com/kaishin/Gifu/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/kaishin/Gifu.svg?sanitize=true&#34; alt=&#34;GitHub release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/badge/Swift-5.0-orange.svg?sanitize=true&#34; alt=&#34;Swift 5.0&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/platforms-iOS%20%7C%20tvOS-lightgrey.svg?sanitize=true&#34; alt=&#34;platforms&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Gifu adds protocol-based, performance-aware animated GIF support to UIKit. (It&#39;s also a &lt;a href=&#34;https://goo.gl/maps/CCeAc&#34;&gt;prefecture in Japan&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;h4&gt;Swift Package Manager&lt;/h4&gt; &#xA;&lt;p&gt;Add the following to your &lt;code&gt;Package.swift&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let package = Package(&#xA;    dependencies: [&#xA;    .package(url: &#34;https://github.com/kaishin/Gifu.git&#34;, from: &#34;3.2.2&#34;)&#xA;    ],&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add the following to your Cartfile: &lt;code&gt;github &#34;kaishin/Gifu&#34;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Then run &lt;code&gt;carthage update&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Follow the current instructions in &lt;a href=&#34;https://github.com/Carthage/Carthage#adding-frameworks-to-an-application&#34;&gt;Carthage&#39;s README&lt;/a&gt; for up to date installation instructions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add the following to your &lt;a href=&#34;http://guides.cocoapods.org/using/the-podfile.html&#34;&gt;Podfile&lt;/a&gt;: &lt;code&gt;pod &#39;Gifu&#39;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;You will also need to make sure you&#39;re opting into using frameworks: &lt;code&gt;use_frameworks!&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Then run &lt;code&gt;pod install&lt;/code&gt; with CocoaPods 0.36 or newer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How It Works&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Gifu&lt;/code&gt; does not require using the built-in &lt;code&gt;GIFImageView&lt;/code&gt; subclass. The &lt;code&gt;Animator&lt;/code&gt; class does the heavy-lifting, while the &lt;code&gt;GIFAnimatable&lt;/code&gt; protocol exposes the functionality to the view classes that conform to it, using protocol extensions.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Animator&lt;/code&gt; has a &lt;code&gt;FrameStore&lt;/code&gt; that only keeps a limited number of frames in-memory, effectively creating a buffer for the animation without consuming all the available memory. This approach makes loading large GIFs a lot more resource-friendly.&lt;/p&gt; &#xA;&lt;p&gt;The figure below summarizes how this works in practice. Given an image containing 10 frames, Gifu will load the current frame (red), buffer the next two frames in this example (orange), and empty up all the other frames to free up memory (gray):&lt;/p&gt; &#xA;&lt;img src=&#34;https://github.com/kaishin/Gifu/raw/master/gifu-figure.gif&#34; width=&#34;300&#34;&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;There are two options that should cover any situation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use the built-in &lt;code&gt;GIFImageView&lt;/code&gt; subclass if you don&#39;t need to combine GIF support with another image library.&lt;/li&gt; &#xA; &lt;li&gt;If you need more flexibility and composability, make your class conform to &lt;code&gt;GIFAnimatable&lt;/code&gt;. In practice, any &lt;code&gt;UIView&lt;/code&gt; subclass would do, since you get most of the required properties for free. For best results, make your &lt;code&gt;UIImageView&lt;/code&gt; subclass conform to &lt;code&gt;GIFAnimatable&lt;/code&gt; to get access to other features such as intrinsic content size.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;GIFAnimatable&lt;/h3&gt; &#xA;&lt;p&gt;The bread and butter of Gifu. Through protocol extensions, &lt;code&gt;GIFAnimatable&lt;/code&gt; exposes all the APIs of the library, and with very little boilerplate, any class can conform to it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class MyImageView: UIImageView, GIFAnimatable {&#xA;  public lazy var animator: Animator? = {&#xA;    return Animator(withDelegate: self)&#xA;  }()&#xA;&#xA;  override public func display(_ layer: CALayer) {&#xA;    updateImageIfNeeded()&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it. Now &lt;code&gt;MyImageView&lt;/code&gt; has access to all these methods and properties:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;prepareForAnimation(withGIFNamed:)&lt;/code&gt; and &lt;code&gt;prepareForAnimation(withGIFData:)&lt;/code&gt; to prepare the animator property for animation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;startAnimatingGIF()&lt;/code&gt; and &lt;code&gt;stopAnimatingGIF()&lt;/code&gt; to control the animation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;animate(withGIFNamed:)&lt;/code&gt; and &lt;code&gt;animate(withGIFData:)&lt;/code&gt; to prepare for animation and start animating immediately.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;frameCount&lt;/code&gt;, &lt;code&gt;isAnimatingGIF&lt;/code&gt;, and &lt;code&gt;activeFrame&lt;/code&gt; to inspect the GIF view.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;prepareForReuse()&lt;/code&gt; to free up resources.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;updateImageIfNeeded()&lt;/code&gt; to update the image property if necessary.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Furthermore, you can make any class GIF-animatable, starting with &lt;code&gt;UIView&lt;/code&gt; subclasses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class CustomAnimatedView: UIView, GIFAnimatable {&#xA;  public lazy var animator: Animator? = {&#xA;    return Animator(withDelegate: self)&#xA;  }()&#xA;&#xA;  override public func display(_ layer: CALayer) {&#xA;    updateImageIfNeeded()&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also make &lt;code&gt;UIKit&lt;/code&gt; classes conform using associated objects may you wish:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit&#xA;import Gifu&#xA;&#xA;extension UIImageView: GIFAnimatable {&#xA;  private struct AssociatedKeys {&#xA;    static var AnimatorKey = &#34;gifu.animator.key&#34;&#xA;  }&#xA;&#xA;  override open func display(_ layer: CALayer) {&#xA;    updateImageIfNeeded()&#xA;  }&#xA;&#xA;  public var animator: Animator? {&#xA;    get {&#xA;      guard let animator = objc_getAssociatedObject(self, &amp;amp;AssociatedKeys.AnimatorKey) as? Animator else {&#xA;        let animator = Animator(withDelegate: self)&#xA;        self.animator = animator&#xA;        return animator&#xA;      }&#xA;&#xA;      return animator&#xA;    }&#xA;&#xA;    set {&#xA;      objc_setAssociatedObject(self, &amp;amp;AssociatedKeys.AnimatorKey, newValue as Animator?, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;p&gt;The simplest way to get started is initializing a &lt;code&gt;GIFAnimatable&lt;/code&gt; class in code or in a storyboard, then calling &lt;code&gt;animate(:)&lt;/code&gt; on it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imageView = GIFImageView(frame: CGRect(x: 0, y: 0, width: 200, height: 100))&#xA;imageView.animate(withGIFNamed: &#34;mugen&#34;) {&#xA;  print(&#34;It&#39;s animating!&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also prepare for the animation when the view loads and only start animating after a user interaction.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// In your view controller..&#xA;&#xA;override func viewDidLoad() {&#xA;  super.viewDidLoad()&#xA;  imageView.prepareForAnimation(withGIFNamed: &#34;mugen&#34;) {&#xA;    print(&#34;Ready to animate!&#34;)&#xA;  }&#xA;}&#xA;&#xA;@IBAction func toggleAnimation(_ sender: AnyObject) {&#xA;  if imageView.isAnimatingGIF {&#xA;    imageView.stopAnimatingGIF()&#xA;  } else {&#xA;    imageView.startAnimatingGIF()&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are using a &lt;code&gt;GIFAnimatable&lt;/code&gt; class in a table or collection view, you can call the &lt;code&gt;prepareForReuse()&lt;/code&gt; method in your cell subclass:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func prepareForReuse() {&#xA;  super.prepareForReuse()&#xA;  imageView.prepareForReuse()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Demo App&lt;/h3&gt; &#xA;&lt;p&gt;Clone or download the repository and open &lt;code&gt;Demo/Demo.xcworkspace&lt;/code&gt; to check out the demo app.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;http://kaishin.github.io/Gifu/&#34;&gt;full API documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iOS 9.0+&lt;/li&gt; &#xA; &lt;li&gt;Swift 4.0&lt;/li&gt; &#xA; &lt;li&gt;Xcode 9.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;See LICENSE.&lt;/p&gt;</summary>
  </entry>
</feed>