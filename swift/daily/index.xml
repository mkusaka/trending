<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-21T01:34:22Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pointfreeco/swift-navigation</title>
    <updated>2024-08-21T01:34:22Z</updated>
    <id>tag:github.com,2024-08-21:/pointfreeco/swift-navigation</id>
    <link href="https://github.com/pointfreeco/swift-navigation" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Bringing simple and powerful navigation tools to all Swift platforms, inspired by SwiftUI.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Swift Navigation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pointfreeco/swift-navigation/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/pointfreeco/swift-navigation/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://pointfree.co/slack-invite&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/slack-chat-informational.svg?label=Slack&amp;amp;logo=slack&#34; alt=&#34;Slack&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-navigation&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-navigation%2Fbadge%3Ftype%3Dswift-versions&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-navigation&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fpointfreeco%2Fswift-navigation%2Fbadge%3Ftype%3Dplatforms&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Bringing simple and powerful navigation tools to all Swift platforms, inspired by SwiftUI.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;This library contains a suite of tools that form the foundation for building powerful state management and navigation APIs for Apple platforms, such as SwiftUI, UIKit, and AppKit, as well as for non-Apple platforms, such as Windows, Linux, Wasm, and more.&lt;/p&gt; &#xA;&lt;p&gt;The SwiftNavigation library forms the foundation that more advanced tools can be built upon, such as the UIKitNavigation and SwiftUINavigation libraries. There are two primary tools provided:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;observe&lt;/code&gt;: Minimally observe changes in a model.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;UIBinding&lt;/code&gt;: Two-way binding for connecting navigation and UI components to an observable model.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition to these tools there are some supplementary concepts that allow you to build more powerful tools, such as &lt;code&gt;UITransaction&lt;/code&gt;, which associates animations and other data with state changes, and &lt;code&gt;UINavigationPath&lt;/code&gt;, which is a type-erased stack of data that helps in describing stack-based navigation.&lt;/p&gt; &#xA;&lt;p&gt;All of these tools form the foundation for how one can build more powerful and robust tools for SwiftUI, UIKit, AppKit, and even non-Apple platforms.&lt;/p&gt; &#xA;&lt;h4&gt;SwiftUI&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] To get access to the tools described below you must depend on the SwiftNavigation package and import the SwiftUINavigation library.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;SwiftUI already comes with incredibly powerful navigation APIs, but there are a few areas lacking that can be filled. In particular, driving navigation from enum state so that you can have compile-time guarantees that only one destination can be active at a time.&lt;/p&gt; &#xA;&lt;p&gt;For example, suppose you have a feature that can present a sheet for creating an item, drill-down to a view for editing an item, and can present an alert for confirming to delete an item. One can technically model this with 3 separate optionals:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Observable&#xA;class FeatureModel {&#xA;  var addItem: AddItemModel?&#xA;  var deleteItemAlertIsPresented: Bool&#xA;  var editItem: EditItemModel?&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then in the view one can use the &lt;code&gt;sheet&lt;/code&gt;, &lt;code&gt;navigationDestination&lt;/code&gt; and &lt;code&gt;alert&lt;/code&gt; view modifiers to describe the type of navigation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.sheet(item: $model.addItem) { addItemModel in&#xA;  AddItemView(model: addItemModel)&#xA;}&#xA;.alert(&#34;Delete?&#34;, isPresented: $model.deleteItemAlertIsPresented) {&#xA;  Button(&#34;Yes&#34;, role: .destructive) { /* ... */ }&#xA;  Button(&#34;No&#34;, role: .cancel) {}&#xA;}&#xA;.navigationDestination(item: $model.editItem) { editItemModel in&#xA;  EditItemModel(model: editItemModel)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This works great at first, but also introduces a lot of unnecessary complexity into your feature. These 3 optionals means that there are technically 8 different states: All can be &lt;code&gt;nil&lt;/code&gt;, one can be non-&lt;code&gt;nil&lt;/code&gt;, two could be non-&lt;code&gt;nil&lt;/code&gt;, or all three could be non-&lt;code&gt;nil&lt;/code&gt;. But only 4 of those states are valid: either all are &lt;code&gt;nil&lt;/code&gt; or exactly one is non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By allowing these 4 other invalid states we can accidentally tell SwiftUI to both present a sheet and alert at the same time, but that is not a valid thing to do in SwiftUI, and SwiftUI will even print a message to the console letting you know that in the future it may actually crash your app.&lt;/p&gt; &#xA;&lt;p&gt;Luckily Swift comes with the perfect tool for dealing with this kind of situation: enums! They allow you to concisely define a type that can be one of many cases. So, we can refactor our 3 optionals as an enum with 3 cases, and then hold onto a single piece of optional state:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Observable&#xA;class FeatureModel {&#xA;  var destination: Destination?&#xA;&#xA;  enum Destination {&#xA;    case addItem(AddItemModel)&#xA;    case deleteItemAlert&#xA;    case editItem(EditItemModel)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is more concise, and we get compile-time verification that at most one destination can be active at a time. However, SwiftUI does not come with the tools to drive navigation from this model. This is where the SwiftUINavigation tools becomes useful.&lt;/p&gt; &#xA;&lt;p&gt;We start by annotating the &lt;code&gt;Destination&lt;/code&gt; enum with the &lt;code&gt;@CasePathable&lt;/code&gt; macro, which allows one to refer to the cases of an enum with dot-syntax just like one does with structs and properties:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;+@CasePathable&#xA; enum Destination {&#xA;   // ...&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And now one can use simple dot-chaining syntax to derive a binding from a particular case of the &lt;code&gt;destination&lt;/code&gt; property:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.sheet(item: $model.destination.addItem) { addItemModel in&#xA;  AddItemView(model: addItemModel)&#xA;}&#xA;.alert(&#34;Delete?&#34;, isPresented: Binding($model.destination.deleteItemAlert)) {&#xA;  Button(&#34;Yes&#34;, role: .destructive) { /* ... */ }&#xA;  Button(&#34;No&#34;, role: .cancel) {}&#xA;}&#xA;.navigationDestination(item: $model.destination.editItem) { editItemModel in&#xA;  EditItemView(model: editItemModel)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] For the alert we are using the special &lt;code&gt;Binding&lt;/code&gt; initializer that turns a &lt;code&gt;Binding&amp;lt;Void?&amp;gt;&lt;/code&gt; into a &lt;code&gt;Binding&amp;lt;Bool&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We now have a concise way of describing all of the destinations a feature can navigate to, and we can still use SwiftUI&#39;s navigation APIs.&lt;/p&gt; &#xA;&lt;h4&gt;UIKit&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] To get access to the tools described below you must depend on the SwiftNavigation package and import the UIKitNavigation library.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Unlike SwiftUI, UIKit does not come with state-driven navigation tools. Its navigation tools are &#34;fire-and-forget&#34;, meaning you simply invoke a method to trigger a navigation, but there is no representation of that in your feature&#39;s state.&lt;/p&gt; &#xA;&lt;p&gt;For example, to present a sheet from a button press one can simply do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let button = UIButton(type: .system, primaryAction: UIAction { [weak self] _ in&#xA;  present(SettingsViewController(), animated: true)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This makes it easy to get started with navigation, but as SwiftUI has taught us, it is incredibly powerful to be able to drive navigation from state. It allows you to encapsulate more of your feature&#39;s logic in an isolated and testable domain, and it unlocks deep linking for free since one just needs to construct a piece of state that represents where you want to navigate to, hand it to SwiftUI, and let SwiftUI handle the rest.&lt;/p&gt; &#xA;&lt;p&gt;The UIKitNavigation library brings a powerful suite of navigation tools to UIKit that are heavily inspired by SwiftUI. For example, if you have a feature model like the one discussed above in the &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-navigation/main/#swiftui&#34;&gt;SwiftUI&lt;/a&gt; section:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Observable&#xA;class FeatureModel {&#xA;  var destination: Destination?&#xA;&#xA;  enum Destination {&#xA;    case addItem(AddItemModel)&#xA;    case deleteItemAlert&#xA;    case editItem(EditItemModel)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;â€¦then one can drive navigation in a &lt;em&gt;view controller&lt;/em&gt; using tools in the library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class FeatureViewController: UIViewController {&#xA;  @UIBindable var model: FeatureModel&#xA;&#xA;  func viewDidLoad() {&#xA;    super.viewDidLoad()&#xA;&#xA;    // Set up view hierarchy&#xA;&#xA;    present(item: $model.destination.addItem) { addItemModel in&#xA;      AddItemViewController(model: addItemModel)&#xA;    }&#xA;    present(isPresented: Binding($model.destination.deleteItemAlert)) {&#xA;      let alert = UIAlertController(title: &#34;Delete?&#34;, message: message, preferredStyle: .alert)&#xA;      alert.addAction(UIAlertAction(title: &#34;Yes&#34;, style: .destructive))&#xA;      alert.addAction(UIAlertAction(title: &#34;No&#34;, style: .cancel))&#xA;      return alert&#xA;    }&#xA;    navigationDestination(item: $model.destination.editItem) { editItemModel in&#xA;      EditItemViewController(model: editItemModel)&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By using the libraries navigation tools we can be guaranteed that the model will be kept in sync with the view. When the state becomes non-&lt;code&gt;nil&lt;/code&gt; the corresponding form of navigation will be triggered, and when the presented view is dismissed, the state will be &lt;code&gt;nil&lt;/code&gt;&#39;d out.&lt;/p&gt; &#xA;&lt;p&gt;Another powerful aspect of SwiftUI is its ability to update its UI whenever state in an observable model changes. And thanks to Swift&#39;s observation tools this can be done done implicitly and minimally: whichever fields are accessed in the &lt;code&gt;body&lt;/code&gt; of the view are automatically tracked so that when they change the view updates.&lt;/p&gt; &#xA;&lt;p&gt;Our UIKitNavigation library comes with a tool that brings this power to UIKit, and it&#39;s called &lt;code&gt;observe&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;observe { [weak self] in&#xA;  guard let self else { return }&#xA;  &#xA;  countLabel.text = &#34;Count: \(model.count)&#34;&#xA;  factLabel.isHidden = model.fact == nil &#xA;  if let fact = model.fact {&#xA;    factLabel.text = fact&#xA;  }&#xA;  activityIndicator.isHidden = !model.isLoadingFact&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Whichever fields are accessed inside &lt;code&gt;observe&lt;/code&gt; (such as &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;fact&lt;/code&gt; and &lt;code&gt;isLoadingFact&lt;/code&gt; above) are automatically tracked, so that whenever they are mutated the trailing closure of &lt;code&gt;observe&lt;/code&gt; will be invoked again, allowing us to update the UI with the freshest data.&lt;/p&gt; &#xA;&lt;p&gt;All of these tools are built on top of Swift&#39;s powerful Observation framework. However, that framework only works on newer versions of Apple&#39;s platforms: iOS 17+, macOS 14+, tvOS 17+ and watchOS 10+. However, thanks to our back-port of Swift&#39;s observation tools (see &lt;a href=&#34;http://github.com/pointfreeco/swift-perception&#34;&gt;Perception&lt;/a&gt;), you can make use of our tools right away, going all the way back to the iOS 13 era of platforms.&lt;/p&gt; &#xA;&lt;h4&gt;Non-Apple platforms&lt;/h4&gt; &#xA;&lt;p&gt;The tools provided by this library can also form the foundation of building navigation tools for non-Apple platforms, such as Windows, Linux, Wasm and more. We do not currently provide any such tools at this moment, but it is possible for them to be built externally.&lt;/p&gt; &#xA;&lt;p&gt;For example, in Wasm it is possible to use the &lt;code&gt;observe(isolation:_:)-93yzu&lt;/code&gt; function to observe changes to a model and update the DOM:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import JavaScriptKit&#xA;&#xA;var countLabel = document.createElement(&#34;span&#34;)&#xA;_ = document.body.appendChild(countLabel)&#xA;&#xA;let token = observe {&#xA;  countLabel.innerText = .string(&#34;Count: \(model.count)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And it&#39;s possible to drive navigation from state, such as an alert:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;alert(isPresented: $model.isShowingErrorAlert) {&#xA;  &#34;Something went wrong&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And you can build more advanced tools for presenting and dismissing &lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt;&#39;s in the browser.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;This repo comes with lots of examples to demonstrate how to solve common and complex navigation problems with the library. Check out &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-navigation/main/Examples&#34;&gt;this&lt;/a&gt; directory to see them all, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-navigation/main/Examples/CaseStudies&#34;&gt;Case Studies&lt;/a&gt;: A collection of SwiftUI and UIKit case studies demonstrating this library&#39;s APIs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-navigation/main/Examples/Inventory&#34;&gt;Inventory&lt;/a&gt;: A multi-screen application with lists, sheets, popovers and alerts, all driven by state and deep-linkable.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Learn More&lt;/h2&gt; &#xA;&lt;p&gt;Swift Navigation&#39;s tools were motivated and designed over the course of many episodes on &lt;a href=&#34;https://www.pointfree.co&#34;&gt;Point-Free&lt;/a&gt;, a video series exploring functional programming and the Swift language, hosted by &lt;a href=&#34;https://twitter.com/mbrandonw&#34;&gt;Brandon Williams&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/stephencelis&#34;&gt;Stephen Celis&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can watch all of the episodes &lt;a href=&#34;https://www.pointfree.co/collections/swiftui/navigation&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;a href=&#34;https://www.pointfree.co/collections/swiftui/navigation&#34;&gt; &lt;img alt=&#34;video poster image&#34; src=&#34;https://d3rccdn33rt8ze.cloudfront.net/email-assets/pf-email-header.png&#34; width=&#34;600&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;If you want to discuss this library or have a question about how to use it to solve a particular problem, there are a number of places you can discuss with fellow &lt;a href=&#34;http://www.pointfree.co&#34;&gt;Point-Free&lt;/a&gt; enthusiasts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For long-form discussions, we recommend the &lt;a href=&#34;http://github.com/pointfreeco/swift-navigation/discussions&#34;&gt;discussions&lt;/a&gt; tab of this repo.&lt;/li&gt; &#xA; &lt;li&gt;For casual chat, we recommend the &lt;a href=&#34;http://pointfree.co/slack-invite&#34;&gt;Point-Free Community slack&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can add Swift Navigation to an Xcode project by adding it as a package dependency.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/pointfreeco/swift-navigation&#34;&gt;https://github.com/pointfreeco/swift-navigation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If you want to use Swift Navigation in a &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;SwiftPM&lt;/a&gt; project, it&#39;s as simple as adding it to a &lt;code&gt;dependencies&lt;/code&gt; clause in your &lt;code&gt;Package.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;  .package(url: &#34;https://github.com/pointfreeco/swift-navigation&#34;, from: &#34;2.0.0&#34;)&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The latest documentation for the Swift Navigation APIs is available &lt;a href=&#34;https://swiftpackageindex.com/pointfreeco/swift-navigation/main/documentation/swiftnavigation&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is released under the MIT license. See &lt;a href=&#34;https://raw.githubusercontent.com/pointfreeco/swift-navigation/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
</feed>