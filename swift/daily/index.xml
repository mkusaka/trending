<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-07T01:37:00Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>evgenyneu/keychain-swift</title>
    <updated>2022-12-07T01:37:00Z</updated>
    <id>tag:github.com,2022-12-07:/evgenyneu/keychain-swift</id>
    <link href="https://github.com/evgenyneu/keychain-swift" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Helper functions for saving text in Keychain securely for iOS, OS X, tvOS and watchOS.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Helper functions for storing text in Keychain for iOS, macOS, tvOS and WatchOS&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/KeychainSwift&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/KeychainSwift.svg?style=flat&#34; alt=&#34;CocoaPods Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/apple/swift-package-manager&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Swift%20Package%20Manager-compatible-brightgreen.svg?sanitize=true&#34; alt=&#34;Swift Package Manager compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/KeychainSwift&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/l/KeychainSwift.svg?style=flat&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://cocoadocs.org/docsets/KeychainSwift&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/p/KeychainSwift.svg?style=flat&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is a collection of helper functions for saving text and data in the Keychain. As you probably noticed Apple&#39;s keychain API is a bit verbose. This library was designed to provide shorter syntax for accomplishing a simple task: reading/writing text values for specified keys:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let keychain = KeychainSwift()&#xA;keychain.set(&#34;hello world&#34;, forKey: &#34;my key&#34;)&#xA;keychain.get(&#34;my key&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Keychain library includes the following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/evgenyneu/keychain-swift/master/#usage&#34;&gt;Get, set and delete string, boolean and Data Keychain items&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/evgenyneu/keychain-swift/master/#keychain_item_access&#34;&gt;Specify item access security level&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/evgenyneu/keychain-swift/master/#keychain_synchronization&#34;&gt;Synchronize items through iCloud&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/evgenyneu/keychain-swift/master/#keychain_access_groups&#34;&gt;Share Keychain items with other apps&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What&#39;s Keychain?&lt;/h2&gt; &#xA;&lt;p&gt;Keychain is a secure storage. You can store all kind of sensitive data in it: user passwords, credit card numbers, secret tokens etc. Once stored in Keychain this information is only available to your app, other apps can&#39;t see it. Besides that, operating system makes sure this information is kept and processed securely. For example, text stored in Keychain can not be extracted from iPhone backup or from its file system. Apple recommends storing only small amount of data in the Keychain. If you need to secure something big you can encrypt it manually, save to a file and store the key in the Keychain.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;There are four ways you can add KeychainSwift to your project.&lt;/p&gt; &#xA;&lt;h4&gt;Add source (iOS 7+)&lt;/h4&gt; &#xA;&lt;p&gt;Simply add &lt;a href=&#34;https://github.com/evgenyneu/keychain-swift/raw/master/Distrib/KeychainSwiftDistrib.swift&#34;&gt;KeychainSwiftDistrib.swift&lt;/a&gt; file into your Xcode project.&lt;/p&gt; &#xA;&lt;h4&gt;Setup with Carthage (iOS 8+)&lt;/h4&gt; &#xA;&lt;p&gt;Alternatively, add &lt;code&gt;github &#34;evgenyneu/keychain-swift&#34; ~&amp;gt; 20.0&lt;/code&gt; to your Cartfile and run &lt;code&gt;carthage update&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Setup with CocoaPods (iOS 8+)&lt;/h4&gt; &#xA;&lt;p&gt;If you are using CocoaPods add this text to your Podfile and run &lt;code&gt;pod install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;use_frameworks!&#xA;target &#39;Your target name&#39;&#xA;pod &#39;KeychainSwift&#39;, &#39;~&amp;gt; 20.0&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Setup with Swift Package Manager&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;In Xcode select &lt;em&gt;File &amp;gt; Add Packages&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Enter this project&#39;s URL: &lt;a href=&#34;https://github.com/evgenyneu/keychain-swift.git&#34;&gt;https://github.com/evgenyneu/keychain-swift.git&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Legacy Swift versions&lt;/h2&gt; &#xA;&lt;p&gt;Setup a &lt;a href=&#34;https://github.com/evgenyneu/keychain-swift/wiki/Legacy-Swift-versions&#34;&gt;previous version&lt;/a&gt; of the library if you use an older version of Swift.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Add &lt;code&gt;import KeychainSwift&lt;/code&gt; to your source code unless you used the file setup method.&lt;/p&gt; &#xA;&lt;h4&gt;String values&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let keychain = KeychainSwift()&#xA;keychain.set(&#34;hello world&#34;, forKey: &#34;my key&#34;)&#xA;keychain.get(&#34;my key&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Boolean values&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let keychain = KeychainSwift()&#xA;keychain.set(true, forKey: &#34;my key&#34;)&#xA;keychain.getBool(&#34;my key&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Data values&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let keychain = KeychainSwift()&#xA;keychain.set(dataObject, forKey: &#34;my key&#34;)&#xA;keychain.getData(&#34;my key&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Removing keys from Keychain&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;keychain.delete(&#34;my key&#34;) // Remove single key&#xA;keychain.clear() // Delete everything from app&#39;s Keychain. Does not work on macOS.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Return all keys&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let keychain = KeychainSwift()&#xA;keychain.allKeys // Returns the names of all keys&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Advanced options&lt;/h2&gt; &#xA;&lt;h3 id=&#34;keychain_item_access&#34;&gt;Keychain item access&lt;/h3&gt; &#xA;&lt;p&gt;Use &lt;code&gt;withAccess&lt;/code&gt; parameter to specify the security level of the keychain storage. By default the &lt;code&gt;.accessibleWhenUnlocked&lt;/code&gt; option is used. It is one of the most restrictive options and provides good data protection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;let keychain = KeychainSwift()&#xA;keychain.set(&#34;Hello world&#34;, forKey: &#34;key 1&#34;, withAccess: .accessibleWhenUnlocked)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;.accessibleAfterFirstUnlock&lt;/code&gt; if you need your app to access the keychain item while in the background. Note that it is less secure than the &lt;code&gt;.accessibleWhenUnlocked&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;p&gt;See the list of all available &lt;a href=&#34;https://github.com/evgenyneu/keychain-swift/raw/master/Sources/KeychainSwiftAccessOptions.swift&#34;&gt;access options&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3 id=&#34;keychain_synchronization&#34;&gt;Synchronizing keychain items with other devices&lt;/h3&gt; &#xA;&lt;p&gt;Set &lt;code&gt;synchronizable&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt; to enable keychain items synchronization across user&#39;s multiple devices. The synchronization will work for users who have the &#34;Keychain&#34; enabled in the iCloud settings on their devices.&lt;/p&gt; &#xA;&lt;p&gt;Setting &lt;code&gt;synchronizable&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt; will add the item to other devices with the &lt;code&gt;set&lt;/code&gt; method and obtain synchronizable items with the &lt;code&gt;get&lt;/code&gt; command. Deleting a synchronizable item will remove it from all devices.&lt;/p&gt; &#xA;&lt;p&gt;Note that you do NOT need to enable iCloud or Keychain Sharing capabilities in your app&#39;s target for this feature to work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;// First device&#xA;let keychain = KeychainSwift()&#xA;keychain.synchronizable = true&#xA;keychain.set(&#34;hello world&#34;, forKey: &#34;my key&#34;)&#xA;&#xA;// Second device&#xA;let keychain = KeychainSwift()&#xA;keychain.synchronizable = true&#xA;keychain.get(&#34;my key&#34;) // Returns &#34;hello world&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We could not get the Keychain synchronization work on macOS.&lt;/p&gt; &#xA;&lt;h3 id=&#34;keychain_access_groups&#34;&gt;Sharing keychain items with other apps&lt;/h3&gt; &#xA;&lt;p&gt;In order to share keychain items between apps on the same device they need to have common &lt;em&gt;Keychain Groups&lt;/em&gt; registered in &lt;em&gt;Capabilities &amp;gt; Keychain Sharing&lt;/em&gt; settings. &lt;a href=&#34;http://evgenii.com/blog/sharing-keychain-in-ios/&#34;&gt;This tutorial&lt;/a&gt; shows how to set it up.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;accessGroup&lt;/code&gt; property to access shared keychain items. In the following example we specify an access group &#34;CS671JRA62.com.myapp.KeychainGroup&#34; that will be used to set, get and delete an item &#34;my key&#34;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let keychain = KeychainSwift()&#xA;keychain.accessGroup = &#34;CS671JRA62.com.myapp.KeychainGroup&#34; // Use your own access goup&#xA;&#xA;keychain.set(&#34;hello world&#34;, forKey: &#34;my key&#34;)&#xA;keychain.get(&#34;my key&#34;)&#xA;keychain.delete(&#34;my key&#34;)&#xA;keychain.clear()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: there is no way of sharing a keychain item between the watchOS 2.0 and its paired device: &lt;a href=&#34;https://forums.developer.apple.com/thread/5938&#34;&gt;https://forums.developer.apple.com/thread/5938&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Setting key prefix&lt;/h3&gt; &#xA;&lt;p&gt;One can pass a &lt;code&gt;keyPrefix&lt;/code&gt; argument when initializing a &lt;code&gt;KeychainSwift&lt;/code&gt; object. The string passed in &lt;code&gt;keyPrefix&lt;/code&gt; argument will be used as a prefix to &lt;strong&gt;all the keys&lt;/strong&gt; used in &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;getData&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; methods. Adding a prefix to the keychain keys can be useful in unit tests. This prevents the tests from changing the Keychain keys that are used when the app is launched manually.&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;clear&lt;/code&gt; method still clears everything from the Keychain regardless of the prefix used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let keychain = KeychainSwift(keyPrefix: &#34;myTestKey_&#34;)&#xA;keychain.set(&#34;hello world&#34;, forKey: &#34;hello&#34;)&#xA;// Value will be stored under &#34;myTestKey_hello&#34; key&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Check if operation was successful&lt;/h3&gt; &#xA;&lt;p&gt;One can verify if &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;clear&lt;/code&gt; methods finished successfully by checking their return values. Those methods return &lt;code&gt;true&lt;/code&gt; on success and &lt;code&gt;false&lt;/code&gt; on error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;if keychain.set(&#34;hello world&#34;, forKey: &#34;my key&#34;) {&#xA;  // Keychain item is saved successfully&#xA;} else {&#xA;  // Report error&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To get a specific failure reason use the &lt;code&gt;lastResultCode&lt;/code&gt; property containing result code for the last operation. See &lt;a href=&#34;https://developer.apple.com/documentation/security/1542001-security_framework_result_codes&#34;&gt;Keychain Result Codes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;keychain.set(&#34;hello world&#34;, forKey: &#34;my key&#34;)&#xA;if keychain.lastResultCode != noErr { /* Report error */ }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Returning data as reference&lt;/h3&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;asReference: true&lt;/code&gt; parameter to return the data as reference, which is needed for &lt;a href=&#34;https://developer.apple.com/documentation/networkextension/nevpnprotocol&#34;&gt;NEVPNProtocol&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let keychain = KeychainSwift()&#xA;keychain.set(dataObject, forKey: &#34;my key&#34;)&#xA;keychain.getData(&#34;my key&#34;, asReference: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using KeychainSwift from Objective-C&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/evgenyneu/keychain-swift/wiki/Using-KeychainSwift-in-Objective-C-project&#34;&gt;This manual&lt;/a&gt; describes how to use KeychainSwift in Objective-C apps.&lt;/p&gt; &#xA;&lt;h2&gt;‚ùóÔ∏èKnown critical issue - call to action‚ùóÔ∏è&lt;/h2&gt; &#xA;&lt;p&gt;It &lt;a href=&#34;https://github.com/evgenyneu/keychain-swift/issues/15&#34;&gt;has been reported&lt;/a&gt; that the library sometimes returns &lt;code&gt;nil&lt;/code&gt; instead of the stored Keychain value. It may be connected with &lt;a href=&#34;https://forums.developer.apple.com/thread/4743&#34;&gt;the Keychain issue&lt;/a&gt; reported on Apple developer forums. The issue is random and hard to reproduce. If you experienced this problem feel free to create an issue and share your story, so we can find solutions.&lt;/p&gt; &#xA;&lt;h2&gt;Video tutorial&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to Alex Nagy from &lt;a href=&#34;https://rebeloper.com/&#34;&gt;rebeloper.com&lt;/a&gt; for creating this two-part &lt;a href=&#34;https://www.youtube.com/watch?v=1R-VIzjD4yo&amp;amp;list=PL_csAAO9PQ8bLfPF7JsnF-t4q63WKZ9O9&#34;&gt;video tutorial&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=1R-VIzjD4yo&amp;amp;list=PL_csAAO9PQ8bLfPF7JsnF-t4q63WKZ9O9&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/evgenyneu/keychain-swift/master/graphics/keychain_swift_video_tutorial.jpg&#34; width=&#34;800&#34; alt=&#34;Keychain Swift video tutorial&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Demo app&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/evgenyneu/keychain-swift/master/graphics/keychain-swift-demo-3.png&#34; alt=&#34;Keychain Swift demo app&#34; width=&#34;320&#34;&gt; &#xA;&lt;h2&gt;Alternative solutions&lt;/h2&gt; &#xA;&lt;p&gt;Here are some other Keychain libraries.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/DanielTomlinson/Latch&#34;&gt;DanielTomlinson/Latch&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jrendel/SwiftKeychainWrapper&#34;&gt;jrendel/SwiftKeychainWrapper&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kishikawakatsumi/KeychainAccess&#34;&gt;kishikawakatsumi/KeychainAccess&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/matthewpalmer/Locksmith&#34;&gt;matthewpalmer/Locksmith&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/s-aska/KeyClip&#34;&gt;s-aska/KeyClip&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/yankodimitrov/SwiftKeychain&#34;&gt;yankodimitrov/SwiftKeychain&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Thanks üëç&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The code is based on this example: &lt;a href=&#34;https://gist.github.com/s-aska/e7ad24175fb7b04f78e7&#34;&gt;https://gist.github.com/s-aska/e7ad24175fb7b04f78e7&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/diogoguimaraes&#34;&gt;diogoguimaraes&lt;/a&gt; for adding Swift Package Manager setup option.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/glyuck&#34;&gt;glyuck&lt;/a&gt; for taming booleans.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/pepibumur&#34;&gt;pepibumur&lt;/a&gt; for adding macOS, watchOS and tvOS support.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/ezura&#34;&gt;ezura&lt;/a&gt; for iOS 7 support.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/mikaoj&#34;&gt;mikaoj&lt;/a&gt; for adding keychain synchronization.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/tcirwin&#34;&gt;tcirwin&lt;/a&gt; for adding Swift 3.0 support.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/Tulleb&#34;&gt;Tulleb&lt;/a&gt; for adding Xcode 8 beta 6 support.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/CraigSiemens&#34;&gt;CraigSiemens&lt;/a&gt; for adding Swift 3.1 support.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/maxkramerbcgdv&#34;&gt;maxkramerbcgdv&lt;/a&gt; for fixing Package Manager setup in Xcode 8.2.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/elikohen&#34;&gt;elikohen&lt;/a&gt; for fixing concurrency issues.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/beny&#34;&gt;beny&lt;/a&gt; for adding Swift 4.2 support.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/xuaninbox&#34;&gt;xuaninbox&lt;/a&gt; for fixing watchOS deployment target for Xcode 10.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/schayes04&#34;&gt;schayes04&lt;/a&gt; for adding Swift 5.0 support.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/mediym41&#34;&gt;mediym41&lt;/a&gt; for adding ability to return data as reference.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/AnthonyOliveri&#34;&gt;AnthonyOliveri&lt;/a&gt; for adding ability to run unit tests from Swift Package Manager.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/philippec&#34;&gt;philippec&lt;/a&gt; for removing deprecated access options.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to &lt;a href=&#34;https://github.com/lucasmpaim&#34;&gt;lucasmpaim&lt;/a&gt; for adding ability to return the names of all keys.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Feedback is welcome&lt;/h2&gt; &#xA;&lt;p&gt;If you notice any issue, got stuck or just want to chat feel free to create an issue. We will be happy to help you.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Keychain Swift is released under the &lt;a href=&#34;https://raw.githubusercontent.com/evgenyneu/keychain-swift/master/LICENSE&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>evelyneee/ellekit</title>
    <updated>2022-12-07T01:37:00Z</updated>
    <id>tag:github.com,2022-12-07:/evelyneee/ellekit</id>
    <link href="https://github.com/evelyneee/ellekit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;yet another tweak injector / tweak hooking library for darwin systems&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;ElleKit: Elegant Low Level Elements&lt;/h2&gt; &#xA;&lt;h3&gt;What this is&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A C function hooker that patches memory pages directly&lt;/li&gt; &#xA; &lt;li&gt;An Objective-C function hooker&lt;/li&gt; &#xA; &lt;li&gt;An arm64 assembler&lt;/li&gt; &#xA; &lt;li&gt;A JIT inline assembly implementation for Swift&lt;/li&gt; &#xA; &lt;li&gt;A Substrate and libhooker API reimplementation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A arm64 device running the XNU kernel&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Tested configurations&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;macOS Ventura (arm64)&lt;/li&gt; &#xA; &lt;li&gt;macOS Ventura (arm64e)&lt;/li&gt; &#xA; &lt;li&gt;iOS 16.1 (arm64)&lt;/li&gt; &#xA; &lt;li&gt;iOS 16.1 (arm64e)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;Use the Substrate API &lt;a href=&#34;https://github.com/theos/headers/raw/master/substrate.h&#34;&gt;header&lt;/a&gt; or the &lt;a href=&#34;https://libhooker.com&#34;&gt;libhooker&lt;/a&gt; API. You can also use the Swift functions directly&lt;/p&gt; &#xA;&lt;h3&gt;Building&lt;/h3&gt; &#xA;&lt;p&gt;To build a dynamic library, use Xcode 14. To build the library, run &lt;code&gt;xcodebuild -target ellekit-mac&lt;/code&gt; for a Mac library or &lt;code&gt;xcodebuild -target ellekit&lt;/code&gt; for an iOS library. You can also use this as a Swift package.&lt;/p&gt; &#xA;&lt;h3&gt;Status&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Can hook most C functions on arm64 and arm64e &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Works on functions with 1 instruction beyond 128mb of address space&lt;/li&gt; &#xA;   &lt;li&gt;Allows making faster hooks for functions within 128mb of address space&lt;/li&gt; &#xA;   &lt;li&gt;Can hook functions without symbols if you provide a pointer to the function&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Can hook Objective-C messages with the original implementation being kept&lt;/li&gt; &#xA; &lt;li&gt;Can hook Objective-C class pairs (MSHookClassPair)&lt;/li&gt; &#xA; &lt;li&gt;Assembles these instructions: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;add&lt;/code&gt;, &lt;code&gt;sub&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;b&lt;/code&gt;, &lt;code&gt;bl&lt;/code&gt;, &lt;code&gt;br&lt;/code&gt;, &lt;code&gt;blr&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;movz&lt;/code&gt;, &lt;code&gt;movk&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;svc&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;csel&lt;/code&gt; with all parameters&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;ldr&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;ret&lt;/code&gt;, &lt;code&gt;nop&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Implements the Substrate API&lt;/li&gt; &#xA; &lt;li&gt;Implements the libhooker API&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;The C hooking technique&lt;/h3&gt; &#xA;&lt;p&gt;ElleKit will only ever patch the functions you give it. If you hook a function within 128mb of address space, it will make a simple branch instruction and patch the function with it.&lt;/p&gt; &#xA;&lt;p&gt;If you hook beyond 128mb of address space, it&#39;ll set up an exception port to catch all breakpoint exceptions and handle them. Then, it&#39;ll patch the target with a &lt;code&gt;brk #1&lt;/code&gt; instruction. ElleKit saves the hooks&#39; target and replacement function and when the exception handler is called, it changes the thread state to redirect execution to the target, then resume execution. This might sound extremely inefficient but it&#39;s not too bad.&lt;/p&gt; &#xA;&lt;h3&gt;The original function&lt;/h3&gt; &#xA;&lt;p&gt;ElleKit writes the original function implementation to a new memory page and then provides a pointer to it. If you use &lt;code&gt;LHHookFunctions&lt;/code&gt;, it will use one page for the orig functions, which will be faster than allocating a new one for each hook. Orig functions are assembled like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-arm64&#34;&gt;// Insert address to target function&#xA;movk x16, target_addr % 65536)&#xA;movk x16, (target_addr / 65536) % 65536 lsl: 16&#xA;movk x16, ((target_addr / 65536) / 65536) % 65536, lsl: 32&#xA;movk x16, ((target_addr / 65536) / 65536) / 65536, lsl: 48&#xA;&#xA;// Jump first instruction (the branch to the replacement, aka what we patched)&#xA;add x16, x16, 4 &#xA;&#xA;// Execute the skipped instruction&#xA;[4 first unpatched bytes of the target function]&#xA;&#xA;// Call the target function&#xA;br x16&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>