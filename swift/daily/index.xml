<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-21T01:40:01Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>swift-server/async-http-client</title>
    <updated>2023-12-21T01:40:01Z</updated>
    <id>tag:github.com,2023-12-21:/swift-server/async-http-client</id>
    <link href="https://github.com/swift-server/async-http-client" rel="alternate"></link>
    <summary type="html">&lt;p&gt;HTTP client library built on SwiftNIO&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;AsyncHTTPClient&lt;/h1&gt; &#xA;&lt;p&gt;This package provides an HTTP Client library built on top of SwiftNIO.&lt;/p&gt; &#xA;&lt;p&gt;This library provides the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;First class support for Swift Concurrency&lt;/li&gt; &#xA; &lt;li&gt;Asynchronous and non-blocking request methods&lt;/li&gt; &#xA; &lt;li&gt;Simple follow-redirects (cookie headers are dropped)&lt;/li&gt; &#xA; &lt;li&gt;Streaming body download&lt;/li&gt; &#xA; &lt;li&gt;TLS support&lt;/li&gt; &#xA; &lt;li&gt;Automatic HTTP/2 over HTTPS&lt;/li&gt; &#xA; &lt;li&gt;Cookie parsing (but not storage)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h4&gt;Adding the dependency&lt;/h4&gt; &#xA;&lt;p&gt;Add the following entry in your &lt;code&gt;Package.swift&lt;/code&gt; to start using &lt;code&gt;HTTPClient&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.package(url: &#34;https://github.com/swift-server/async-http-client.git&#34;, from: &#34;1.9.0&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and &lt;code&gt;AsyncHTTPClient&lt;/code&gt; dependency to your target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.target(name: &#34;MyApp&#34;, dependencies: [.product(name: &#34;AsyncHTTPClient&#34;, package: &#34;async-http-client&#34;)]),&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Request-Response API&lt;/h4&gt; &#xA;&lt;p&gt;The code snippet below illustrates how to make a simple GET request to a remote server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import AsyncHTTPClient&#xA;&#xA;let httpClient = HTTPClient(eventLoopGroupProvider: .singleton)&#xA;&#xA;/// MARK: - Using Swift Concurrency&#xA;let request = HTTPClientRequest(url: &#34;https://apple.com/&#34;)&#xA;let response = try await httpClient.execute(request, timeout: .seconds(30))&#xA;print(&#34;HTTP head&#34;, response)&#xA;if response.status == .ok {&#xA;    let body = try await response.body.collect(upTo: 1024 * 1024) // 1 MB&#xA;    // handle body&#xA;} else {&#xA;    // handle remote error&#xA;}&#xA;&#xA;&#xA;/// MARK: - Using SwiftNIO EventLoopFuture&#xA;httpClient.get(url: &#34;https://apple.com/&#34;).whenComplete { result in&#xA;    switch result {&#xA;    case .failure(let error):&#xA;        // process error&#xA;    case .success(let response):&#xA;        if response.status == .ok {&#xA;            // handle response&#xA;        } else {&#xA;            // handle remote error&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should always shut down &lt;code&gt;HTTPClient&lt;/code&gt; instances you created using &lt;code&gt;try httpClient.shutdown()&lt;/code&gt;. Please note that you must not call &lt;code&gt;httpClient.shutdown&lt;/code&gt; before all requests of the HTTP client have finished, or else the in-flight requests will likely fail because their network connections are interrupted.&lt;/p&gt; &#xA;&lt;h3&gt;async/await examples&lt;/h3&gt; &#xA;&lt;p&gt;Examples for the async/await API can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/swift-server/async-http-client/main/Examples&#34;&gt;&lt;code&gt;Examples&lt;/code&gt; folder&lt;/a&gt; in this Repository.&lt;/p&gt; &#xA;&lt;h2&gt;Usage guide&lt;/h2&gt; &#xA;&lt;p&gt;The default HTTP Method is &lt;code&gt;GET&lt;/code&gt;. In case you need to have more control over the method, or you want to add headers or body, use the &lt;code&gt;HTTPClientRequest&lt;/code&gt; struct:&lt;/p&gt; &#xA;&lt;h4&gt;Using Swift Concurrency&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import AsyncHTTPClient&#xA;&#xA;let httpClient = HTTPClient(eventLoopGroupProvider: .singleton)&#xA;do {&#xA;    var request = HTTPClientRequest(url: &#34;https://apple.com/&#34;)&#xA;    request.method = .POST&#xA;    request.headers.add(name: &#34;User-Agent&#34;, value: &#34;Swift HTTPClient&#34;)&#xA;    request.body = .bytes(ByteBuffer(string: &#34;some data&#34;))&#xA;&#xA;    let response = try await httpClient.execute(request, timeout: .seconds(30))&#xA;    if response.status == .ok {&#xA;        // handle response&#xA;    } else {&#xA;        // handle remote error&#xA;    }&#xA;} catch {&#xA;    // handle error&#xA;}&#xA;// it&#39;s important to shutdown the httpClient after all requests are done, even if one failed&#xA;try await httpClient.shutdown()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Using SwiftNIO EventLoopFuture&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import AsyncHTTPClient&#xA;&#xA;let httpClient = HTTPClient(eventLoopGroupProvider: .singleton)&#xA;defer {&#xA;    // Shutdown is guaranteed to work if it&#39;s done precisely once (which is the case here).&#xA;    try! httpClient.syncShutdown()&#xA;}&#xA;&#xA;var request = try HTTPClient.Request(url: &#34;https://apple.com/&#34;, method: .POST)&#xA;request.headers.add(name: &#34;User-Agent&#34;, value: &#34;Swift HTTPClient&#34;)&#xA;request.body = .string(&#34;some-body&#34;)&#xA;&#xA;httpClient.execute(request: request).whenComplete { result in&#xA;    switch result {&#xA;    case .failure(let error):&#xA;        // process error&#xA;    case .success(let response):&#xA;        if response.status == .ok {&#xA;            // handle response&#xA;        } else {&#xA;            // handle remote error&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Redirects following&lt;/h3&gt; &#xA;&lt;p&gt;Enable follow-redirects behavior using the client configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let httpClient = HTTPClient(eventLoopGroupProvider: .singleton,&#xA;                            configuration: HTTPClient.Configuration(followRedirects: true))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Timeouts&lt;/h3&gt; &#xA;&lt;p&gt;Timeouts (connect and read) can also be set using the client configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let timeout = HTTPClient.Configuration.Timeout(connect: .seconds(1), read: .seconds(1))&#xA;let httpClient = HTTPClient(eventLoopGroupProvider: .singleton,&#xA;                            configuration: HTTPClient.Configuration(timeout: timeout))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or on a per-request basis:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;httpClient.execute(request: request, deadline: .now() + .milliseconds(1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Streaming&lt;/h3&gt; &#xA;&lt;p&gt;When dealing with larger amount of data, it&#39;s critical to stream the response body instead of aggregating in-memory. The following example demonstrates how to count the number of bytes in a streaming response body:&lt;/p&gt; &#xA;&lt;h4&gt;Using Swift Concurrency&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let httpClient = HTTPClient(eventLoopGroupProvider: .singleton)&#xA;do {&#xA;    let request = HTTPClientRequest(url: &#34;https://apple.com/&#34;)&#xA;    let response = try await httpClient.execute(request, timeout: .seconds(30))&#xA;    print(&#34;HTTP head&#34;, response)&#xA;&#xA;    // if defined, the content-length headers announces the size of the body&#xA;    let expectedBytes = response.headers.first(name: &#34;content-length&#34;).flatMap(Int.init)&#xA;&#xA;    var receivedBytes = 0&#xA;    // asynchronously iterates over all body fragments&#xA;    // this loop will automatically propagate backpressure correctly&#xA;    for try await buffer in response.body {&#xA;        // for this example, we are just interested in the size of the fragment&#xA;        receivedBytes += buffer.readableBytes&#xA;&#xA;        if let expectedBytes = expectedBytes {&#xA;            // if the body size is known, we calculate a progress indicator&#xA;            let progress = Double(receivedBytes) / Double(expectedBytes)&#xA;            print(&#34;progress: \(Int(progress * 100))%&#34;)&#xA;        }&#xA;    }&#xA;    print(&#34;did receive \(receivedBytes) bytes&#34;)&#xA;} catch {&#xA;    print(&#34;request failed:&#34;, error)&#xA;}&#xA;// it is important to shutdown the httpClient after all requests are done, even if one failed&#xA;try await httpClient.shutdown()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Using HTTPClientResponseDelegate and SwiftNIO EventLoopFuture&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import NIOCore&#xA;import NIOHTTP1&#xA;&#xA;class CountingDelegate: HTTPClientResponseDelegate {&#xA;    typealias Response = Int&#xA;&#xA;    var count = 0&#xA;&#xA;    func didSendRequestHead(task: HTTPClient.Task&amp;lt;Response&amp;gt;, _ head: HTTPRequestHead) {&#xA;        // this is executed right after request head was sent, called once&#xA;    }&#xA;&#xA;    func didSendRequestPart(task: HTTPClient.Task&amp;lt;Response&amp;gt;, _ part: IOData) {&#xA;        // this is executed when request body part is sent, could be called zero or more times&#xA;    }&#xA;&#xA;    func didSendRequest(task: HTTPClient.Task&amp;lt;Response&amp;gt;) {&#xA;        // this is executed when request is fully sent, called once&#xA;    }&#xA;&#xA;    func didReceiveHead(&#xA;        task: HTTPClient.Task&amp;lt;Response&amp;gt;,&#xA;        _ head: HTTPResponseHead&#xA;    ) -&amp;gt; EventLoopFuture&amp;lt;Void&amp;gt; {&#xA;        // this is executed when we receive HTTP response head part of the request&#xA;        // (it contains response code and headers), called once in case backpressure&#xA;        // is needed, all reads will be paused until returned future is resolved&#xA;        return task.eventLoop.makeSucceededFuture(())&#xA;    }&#xA;&#xA;    func didReceiveBodyPart(&#xA;        task: HTTPClient.Task&amp;lt;Response&amp;gt;,&#xA;        _ buffer: ByteBuffer&#xA;    ) -&amp;gt; EventLoopFuture&amp;lt;Void&amp;gt; {&#xA;        // this is executed when we receive parts of the response body, could be called zero or more times&#xA;        count += buffer.readableBytes&#xA;        // in case backpressure is needed, all reads will be paused until returned future is resolved&#xA;        return task.eventLoop.makeSucceededFuture(())&#xA;    }&#xA;&#xA;    func didFinishRequest(task: HTTPClient.Task&amp;lt;Response&amp;gt;) throws -&amp;gt; Int {&#xA;        // this is called when the request is fully read, called once&#xA;        // this is where you return a result or throw any errors you require to propagate to the client&#xA;        return count&#xA;    }&#xA;&#xA;    func didReceiveError(task: HTTPClient.Task&amp;lt;Response&amp;gt;, _ error: Error) {&#xA;        // this is called when we receive any network-related error, called once&#xA;    }&#xA;}&#xA;&#xA;let request = try HTTPClient.Request(url: &#34;https://apple.com/&#34;)&#xA;let delegate = CountingDelegate()&#xA;&#xA;httpClient.execute(request: request, delegate: delegate).futureResult.whenSuccess { count in&#xA;    print(count)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;File downloads&lt;/h3&gt; &#xA;&lt;p&gt;Based on the &lt;code&gt;HTTPClientResponseDelegate&lt;/code&gt; example above you can build more complex delegates, the built-in &lt;code&gt;FileDownloadDelegate&lt;/code&gt; is one of them. It allows streaming the downloaded data asynchronously, while reporting the download progress at the same time, like in the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let client = HTTPClient(eventLoopGroupProvider: .singleton)&#xA;let request = try HTTPClient.Request(&#xA;    url: &#34;https://swift.org/builds/development/ubuntu1804/latest-build.yml&#34;&#xA;)&#xA;&#xA;let delegate = try FileDownloadDelegate(path: &#34;/tmp/latest-build.yml&#34;, reportProgress: {&#xA;    if let totalBytes = $0.totalBytes {&#xA;        print(&#34;Total bytes count: \(totalBytes)&#34;)&#xA;    }&#xA;    print(&#34;Downloaded \($0.receivedBytes) bytes so far&#34;)&#xA;})&#xA;&#xA;client.execute(request: request, delegate: delegate).futureResult&#xA;    .whenSuccess { progress in&#xA;        if let totalBytes = progress.totalBytes {&#xA;            print(&#34;Final total bytes count: \(totalBytes)&#34;)&#xA;        }&#xA;        print(&#34;Downloaded finished with \(progress.receivedBytes) bytes downloaded&#34;)&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unix Domain Socket Paths&lt;/h3&gt; &#xA;&lt;p&gt;Connecting to servers bound to socket paths is easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let httpClient = HTTPClient(eventLoopGroupProvider: .singleton)&#xA;httpClient.execute(&#xA;    .GET,&#xA;    socketPath: &#34;/tmp/myServer.socket&#34;,&#xA;    urlPath: &#34;/path/to/resource&#34;&#xA;).whenComplete (...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Connecting over TLS to a unix domain socket path is possible as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let httpClient = HTTPClient(eventLoopGroupProvider: .singleton)&#xA;httpClient.execute(&#xA;    .POST,&#xA;    secureSocketPath: &#34;/tmp/myServer.socket&#34;,&#xA;    urlPath: &#34;/path/to/resource&#34;,&#xA;    body: .string(&#34;hello&#34;)&#xA;).whenComplete (...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Direct URLs can easily be constructed to be executed in other scenarios:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let socketPathBasedURL = URL(&#xA;    httpURLWithSocketPath: &#34;/tmp/myServer.socket&#34;,&#xA;    uri: &#34;/path/to/resource&#34;&#xA;)&#xA;let secureSocketPathBasedURL = URL(&#xA;    httpsURLWithSocketPath: &#34;/tmp/myServer.socket&#34;,&#xA;    uri: &#34;/path/to/resource&#34;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Disabling HTTP/2&lt;/h3&gt; &#xA;&lt;p&gt;The exclusive use of HTTP/1 is possible by setting &lt;code&gt;httpVersion&lt;/code&gt; to &lt;code&gt;.http1Only&lt;/code&gt; on &lt;code&gt;HTTPClient.Configuration&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var configuration = HTTPClient.Configuration()&#xA;configuration.httpVersion = .http1Only&#xA;let client = HTTPClient(&#xA;    eventLoopGroupProvider: .singleton,&#xA;    configuration: configuration&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;Please have a look at &lt;a href=&#34;https://raw.githubusercontent.com/swift-server/async-http-client/main/SECURITY.md&#34;&gt;SECURITY.md&lt;/a&gt; for AsyncHTTPClient&#39;s security process.&lt;/p&gt; &#xA;&lt;h2&gt;Supported Versions&lt;/h2&gt; &#xA;&lt;p&gt;The most recent versions of AsyncHTTPClient support Swift 5.6 and newer. The minimum Swift version supported by AsyncHTTPClient releases are detailed below:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;AsyncHTTPClient&lt;/th&gt; &#xA;   &lt;th&gt;Minimum Swift Version&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;1.0.0 ..&amp;lt; 1.5.0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;5.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;1.5.0 ..&amp;lt; 1.10.0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;5.2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;1.10.0 ..&amp;lt; 1.13.0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;5.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;1.13.0 ..&amp;lt; 1.18.0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;5.5.2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;1.18.0 ..&amp;lt; 1.20.0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;5.6&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;1.20.0 ...&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;5.7&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
  <entry>
    <title>psharanda/Atributika</title>
    <updated>2023-12-21T01:40:01Z</updated>
    <id>tag:github.com,2023-12-21:/psharanda/Atributika</id>
    <link href="https://github.com/psharanda/Atributika" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Convert text with HTML tags, links, hashtags, mentions into NSAttributedString. Make them clickable with UILabel drop-in replacement.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/psharanda/Atributika/master/README/logo@2x.png&#34; alt=&#34;&#34; width=&#34;392&#34;&gt; &lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;🚨V5 is now released!🚨&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Atributika&lt;/code&gt; is a Swift library that provides a simple way to build NSAttributedString from HTML-like text, by identifying and styling tags, links, phone numbers, hashtags etc.&lt;/p&gt; &#xA;&lt;p&gt;A standalone &lt;code&gt;AtributikaViews&lt;/code&gt; library offers UILabel/UITextView drop-in replacements capable of displaying highlightable and clickable links, with rich customization, and proper accessibility support.&lt;/p&gt; &#xA;&lt;h2&gt;Intro&lt;/h2&gt; &#xA;&lt;p&gt;While NSAttributedString is undoubtedly powerful, it&#39;s also a low-level API that needs a considerable amount of setup work. If your string is a template and the actual content is only known at runtime, this becomes complicated. When dealing with localizations, constructing NSAttributedString isn&#39;t straightforward either.&lt;/p&gt; &#xA;&lt;p&gt;But wait, &lt;code&gt;Atributika&lt;/code&gt; comes to your rescue!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let b = Attrs().font(.boldSystemFont(ofSize: 20)).foregroundColor(.red)&#xA;        &#xA;label.attributedText = &#34;Hello &amp;lt;b&amp;gt;World&amp;lt;/b&amp;gt;!!!&#34;.style(tags: [&#34;b&#34;: b]).attributedString&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/psharanda/Atributika/master/README/main.png&#34; alt=&#34;&#34; width=&#34;139&#34;&gt; &#xA;&lt;p&gt;Indeed, that&#39;s much simpler. &lt;code&gt;Atributika&lt;/code&gt; is easy-to-use, declarative, flexible, and handles the rough edges for you.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Atributika&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;NSAttributedString builder.&lt;/li&gt; &#xA; &lt;li&gt;Detects and styles HTML-like &lt;strong&gt;tags&lt;/strong&gt; using a custom high-speed parser.&lt;/li&gt; &#xA; &lt;li&gt;Detects and styles &lt;strong&gt;hashtags&lt;/strong&gt; and &lt;strong&gt;mentions&lt;/strong&gt; (i.e., #something and @someone).&lt;/li&gt; &#xA; &lt;li&gt;Identifies and styles &lt;strong&gt;links&lt;/strong&gt; and &lt;strong&gt;phone numbers&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Detects and styles regexes and NSDataDetector patterns.&lt;/li&gt; &#xA; &lt;li&gt;Styles the entire string or just specified ranges.&lt;/li&gt; &#xA; &lt;li&gt;Allows all the above to be chained together to parse complex strings!&lt;/li&gt; &#xA; &lt;li&gt;Provides a clean and expressive API to construct styles.&lt;/li&gt; &#xA; &lt;li&gt;Offers a separate set of detection utilities for standalone use.&lt;/li&gt; &#xA; &lt;li&gt;Compatible with iOS, tvOS, watchOS, and macOS.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;AtributikaViews&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Custom views with &lt;strong&gt;highlightable and clickable&lt;/strong&gt; links.&lt;/li&gt; &#xA; &lt;li&gt;Custom text styles for &lt;code&gt;normal/highlighted/disabled&lt;/code&gt; states.&lt;/li&gt; &#xA; &lt;li&gt;Supports custom highlighting.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;V5&lt;/h2&gt; &#xA;&lt;p&gt;V5 is a major rewrite of the project, executed in early 2023. It&#39;s not fully compatible with the previous version and requires some manual migration. The introduction of breaking changes was necessary for the project&#39;s further evolution.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s what&#39;s new:&lt;/p&gt; &#xA;&lt;p&gt;NSAttributedString Building&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Completely rewritten HTML parser, which fixed a multitude of bugs and improved handling of edge cases.&lt;/li&gt; &#xA; &lt;li&gt;More generic and robust text transforming and attribute fine-tuning APIs.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;AttributedLabel / AttributedTextView&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Moved to a standalone library, independent of Atributika.&lt;/li&gt; &#xA; &lt;li&gt;Offers proper accessibility support.&lt;/li&gt; &#xA; &lt;li&gt;Improved performance and touch handling.&lt;/li&gt; &#xA; &lt;li&gt;AttributedLabel is based on UILabel (lightweight, with vertically-centered text).&lt;/li&gt; &#xA; &lt;li&gt;AttributedTextView is based on UITextView (supports scrolling and text selection, with text aligned to the top of the frame).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;New examples have been added to the Demo application, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Basic web browser powered by AttributedTextView&lt;/li&gt; &#xA; &lt;li&gt;SwiftUI integration&lt;/li&gt; &#xA; &lt;li&gt;Highlightable links for Markdown documents&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Detect and style tags, provide base style for the rest of string, don&#39;t forget about special html symbols&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let redColor = UIColor(red:(0xD0 / 255.0), green: (0x02 / 255.0), blue:(0x1B / 255.0), alpha:1.0)&#xA;let a = Attrs().foregroundColor(redColor)&#xA;&#xA;let font = UIFont(name: &#34;AvenirNext-Regular&#34;, size: 24)!&#xA;let grayColor = UIColor(white: 0x66 / 255.0, alpha: 1)&#xA;let base = Attrs().font(font).foregroundColor(grayColor)&#xA;&#xA;let str = &#34;&amp;lt;a&amp;gt;&amp;amp;lt;a&amp;amp;gt;&amp;lt;/a&amp;gt;tributik&amp;lt;a&amp;gt;&amp;amp;lt;/a&amp;amp;gt;&amp;lt;/a&amp;gt;&#34;&#xA;    .style(tags: [&#34;a&#34;: a])&#xA;    .styleBase(base)&#xA;    .attributedString&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/psharanda/Atributika/master/README/test_atributika_logo.png&#34; alt=&#34;&#34; width=&#34;188&#34;&gt; &#xA;&lt;h3&gt;Detect and style hashtags and mentions&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let str = &#34;#Hello @World!!!&#34;&#xA;    .styleHashtags(Attrs().font(.boldSystemFont(ofSize: 45)))&#xA;    .styleMentions(Attrs().foregroundColor(.red))&#xA;    .attributedString&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/psharanda/Atributika/master/README/test_hashtags_mentions.png&#34; alt=&#34;&#34; width=&#34;232&#34;&gt; &#xA;&lt;h3&gt;Detect and style links&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let str = &#34;Check this website http://google.com&#34;&#xA;    .styleLinks(Attrs().foregroundColor(.blue))&#xA;    .attributedString&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/psharanda/Atributika/master/README/test_links.png&#34; alt=&#34;&#34; width=&#34;237&#34;&gt; &#xA;&lt;h3&gt;Detect and style phone numbers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let str = &#34;Call me (888)555-5512&#34;&#xA;    .stylePhoneNumbers(Attrs().foregroundColor(.red))&#xA;    .attributedString&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/psharanda/Atributika/master/README/test_phone_numbers.png&#34; alt=&#34;&#34; width=&#34;195&#34;&gt; &#xA;&lt;h3&gt;Uber String&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let links = Attrs().foregroundColor(.blue)&#xA;let phoneNumbers = Attrs().backgroundColor(.yellow)&#xA;let mentions = Attrs().font(.italicSystemFont(ofSize: 12)).foregroundColor(.black)&#xA;let b = Attrs().font(.boldSystemFont(ofSize: 12))&#xA;let u = Attrs().underlineStyle(.single)&#xA;&#xA;let base = Attrs().font(.systemFont(ofSize: 12)).foregroundColor(.gray)&#xA;&#xA;let str = &#34;@all I found &amp;lt;u&amp;gt;really&amp;lt;/u&amp;gt; nice framework to manage attributed strings. It is called &amp;lt;b&amp;gt;Atributika&amp;lt;/b&amp;gt;. Call me if you want to know more (123)456-7890 #swift #nsattributedstring https://github.com/psharanda/Atributika&#34;&#xA;    .style(tags: [&#34;u&#34;: u, &#34;b&#34;: b])&#xA;    .styleMentions(mentions)&#xA;    .styleHashtags(links)&#xA;    .styleLinks(links)&#xA;    .stylePhoneNumbers(phoneNumbers)&#xA;    .styleBase(base)&#xA;    .attributedString&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/psharanda/Atributika/master/README/test_uber.png&#34; alt=&#34;&#34; width=&#34;342&#34;&gt; &#xA;&lt;h2&gt;AttributedLabel&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;&#xA;let tweetLabel = AttributedLabel()&#xA;&#xA;tweetLabel.numberOfLines = 0&#xA;tweetLabel.highlightedLinkAttributes = Attrs().foregroundColor(.red).attributes&#xA;&#xA;let baseLinkAttrs = Attrs().foregroundColor(.blue)&#xA;&#xA;let a = TagTuner {&#xA;    Attrs(baseLinkAttrs).akaLink($0.tag.attributes[&#34;href&#34;] ?? &#34;&#34;)&#xA;}&#xA;&#xA;let hashtag = DetectionTuner {&#xA;    Attrs(baseLinkAttrs).akaLink(&#34;https://twitter.com/hashtag/\($0.text.replacingOccurrences(of: &#34;#&#34;, with: &#34;&#34;))&#34;)&#xA;}&#xA;&#xA;let mention = DetectionTuner {&#xA;    Attrs(baseLinkAttrs).akaLink(&#34;https://twitter.com/\($0.text.replacingOccurrences(of: &#34;@&#34;, with: &#34;&#34;))&#34;)&#xA;}&#xA;&#xA;let link = DetectionTuner {&#xA;    Attrs(baseLinkAttrs).akaLink($0.text)&#xA;}&#xA;&#xA;let tweet = &#34;@all I found &amp;lt;u&amp;gt;really&amp;lt;/u&amp;gt; nice framework to manage attributed strings. It is called &amp;lt;b&amp;gt;Atributika&amp;lt;/b&amp;gt;. Call me if you want to know more (123)456-7890 #swift #nsattributedstring https://github.com/psharanda/Atributika&#34;&#xA;&#xA;tweetLabel.attributedText = tweet&#xA;    .style(tags: [&#34;a&#34;: a])&#xA;    .styleHashtags(hashtag)&#xA;    .styleMentions(mention)&#xA;    .styleLinks(link)&#xA;    .attributedString&#xA;&#xA;tweetLabel.onLinkTouchUpInside = { _, val in&#xA;    if let linkStr = val as? String {&#xA;        if let url = URL(string: linkStr) {&#xA;            UIApplication.shared.openURL(url)&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;view.addSubview(tweetLabel)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/psharanda/Atributika/master/README/test_attributedlabel.png&#34; alt=&#34;&#34; width=&#34;361&#34;&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;Current version is compatible with:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift 5.0+&lt;/li&gt; &#xA; &lt;li&gt;iOS 11.0 or later&lt;/li&gt; &#xA; &lt;li&gt;tvOS 11.0 or later&lt;/li&gt; &#xA; &lt;li&gt;watchOS 4.0 or later&lt;/li&gt; &#xA; &lt;li&gt;macOS 10.13 or later&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note: &lt;code&gt;AttributedLabel&lt;/code&gt; / &lt;code&gt;AttributedTextView&lt;/code&gt; are available only on iOS&lt;/p&gt; &#xA;&lt;h2&gt;Why does Atributika have one &#39;t&#39; in its name?&lt;/h2&gt; &#xA;&lt;p&gt;Because in Belarusian/Russian we have one letter &#39;t&#39; (атрыбутыка/атрибутика). So basically it is transcription, not a real word.&lt;/p&gt; &#xA;&lt;h2&gt;Integration&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/apple/swift-package-manager&#34;&gt;Swift Package Manager&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Add dependency to &lt;code&gt;Package.swift&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  dependencies: [&#xA;    .package(url: &#34;https://github.com/psharanda/Atributika.git&#34;, .upToNextMajor(from: &#34;5.0.0&#34;))&#xA;  ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;p&gt;Add &lt;code&gt;github &#34;psharanda/Atributika&#34;&lt;/code&gt; to your &lt;code&gt;Cartfile&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;Atributika is available through &lt;a href=&#34;http://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt;. To install it, simply add the following line to your Podfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#34;Atributika&#34;&#xA;pod &#34;AtributikaViews&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Manual&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add Atributika to you project as a submodule using &lt;code&gt;git submodule add https://github.com/psharanda/Atributika.git&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Open the &lt;code&gt;Atributika&lt;/code&gt; folder &amp;amp; drag &lt;code&gt;Atributika.xcodeproj&lt;/code&gt; into your project tree&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;Atributika.framework&lt;/code&gt; to your target&#39;s &lt;code&gt;Link Binary with Libraries&lt;/code&gt; Build Phase&lt;/li&gt; &#xA; &lt;li&gt;Import Atributika with &lt;code&gt;import Atributika&lt;/code&gt; and you&#39;re ready to go&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Atributika is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt;</summary>
  </entry>
</feed>