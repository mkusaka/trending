<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-07-31T01:27:58Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tgrapperon/swift-dependencies-additions</title>
    <updated>2024-07-31T01:27:58Z</updated>
    <id>tag:github.com,2024-07-31:/tgrapperon/swift-dependencies-additions</id>
    <link href="https://github.com/tgrapperon/swift-dependencies-additions" rel="alternate"></link>
    <summary type="html">&lt;p&gt;More dependencies for `swift-dependencies`&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Dependencies Additions&lt;/h1&gt; &#xA;&lt;p&gt;A companion library to Point-Free&#39;s &lt;a href=&#34;https://github.com/pointfreeco/swift-dependencies&#34;&gt;&lt;code&gt;swift-dependencies&lt;/code&gt;&lt;/a&gt; that provides higher-level dependencies.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tgrapperon/swift-dependencies-additions/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/tgrapperon/swift-dependencies-additions/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/tgrapperon/swift-dependencies-additions&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Ftgrapperon%2Fswift-dependencies-additions%2Fbadge%3Ftype%3Dswift-versions&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/tgrapperon/swift-dependencies-additions&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Ftgrapperon%2Fswift-dependencies-additions%2Fbadge%3Ftype%3Dplatforms&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;On the menu&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pointfreeco/swift-dependencies&#34;&gt;Dependencies&lt;/a&gt; is a fantastic library that helps you to manage your dependencies in a similar fashion SwiftUI handles its &lt;code&gt;Environment&lt;/code&gt;. &lt;code&gt;Dependencies&lt;/code&gt; already ships with many built-in fundamental dependencies, like &lt;code&gt;clock&lt;/code&gt;, &lt;code&gt;uuid&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;p&gt;&#34;Dependencies Additions&#34; intends to extend these core dependencies, and provide coherent and testable implementations to many additional dependencies that are commonly needed when developing on Apple&#39;s platforms.&lt;/p&gt; &#xA;&lt;p&gt;The library currently proposes a few low-level dependencies to interface with:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Accessibility&lt;/code&gt;, an abstraction over &lt;code&gt;UIAccessibility&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Application&lt;/code&gt;, an abstraction over &lt;code&gt;UIApplication.shared&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;&lt;code&gt;AssertionDependency&lt;/code&gt;, to abstract &lt;code&gt;assert(…)&lt;/code&gt; calls and promote them to failures when testing;&lt;/del&gt; (directly available in &lt;code&gt;Dependencies&lt;/code&gt; starting from v1.3.0)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;BundleInfo&lt;/code&gt;, an abstraction over the app&#39;s &lt;code&gt;info.plist&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Codable&lt;/code&gt;, to encode/decode &lt;code&gt;Codable&lt;/code&gt; types to &lt;code&gt;Data&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Compression&lt;/code&gt;, to compress/decompress &lt;code&gt;Data&lt;/code&gt; using the `Compression framework;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DataReader/Writer&lt;/code&gt;, to read/write &lt;code&gt;Data&lt;/code&gt; from &lt;code&gt;URL&lt;/code&gt;&#39;s (an idea from &lt;a href=&#34;https://github.com/davdroman&#34;&gt;David Roman&lt;/a&gt;);&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Logger&lt;/code&gt;, that exposes a privacy-aware &lt;code&gt;Logger&lt;/code&gt; instance;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NotificationCenter&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PersistentContainer&lt;/code&gt;, that abstracts a CoreData &lt;code&gt;NSPersistentContainer&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;UserDefaults&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;UserNotificationCenter&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Path&lt;/code&gt;, a generalized collection of &lt;code&gt;AnyHashable&lt;/code&gt;, to which you can push and pop identifiers to contextualize your models;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ProcessInfo&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Device&lt;/code&gt; (&lt;code&gt;UIDevice&lt;/code&gt;, &lt;code&gt;WKInterfaceDevice&lt;/code&gt;, &lt;code&gt;DCDevice&lt;/code&gt;,…).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It also ships with more experimental and higher-level abstractions for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;AppStorage&lt;/code&gt;, which proposes a &lt;code&gt;@Dependency.AppStorage&lt;/code&gt; property wrapper that mimics &lt;code&gt;SwiftUI&lt;/code&gt;s &lt;code&gt;@AppStorage&lt;/code&gt;, but usable from your model and or any concurrent context.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CoreData&lt;/code&gt;, which attempts to expose a safe and convenient interface to your &lt;code&gt;CoreData&lt;/code&gt; graph (WIP).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Notification&lt;/code&gt;, that exposes &lt;code&gt;NotificationCenter&lt;/code&gt;&#39;s notifications under the form of typed and controllable &lt;code&gt;AsyncSequence&lt;/code&gt;s.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SwiftUI&lt;/code&gt;&#39;s &lt;code&gt;Environment&lt;/code&gt;, which republishes &lt;code&gt;SwiftUI&lt;/code&gt;&#39;s &lt;code&gt;Environment&lt;/code&gt; values in your model.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These higher-level dependencies are currently all experimental, and their targets are named with underscores. They could eventually evolve out of &lt;code&gt;Dependencies Additions&lt;/code&gt; into dedicated repositories if their size/behavior justifies it.&lt;/p&gt; &#xA;&lt;p&gt;This library also proposes a few direct extensions to &#34;core&#34; dependencies like some new date and random numbers generators, as well as some tools to help mixing &lt;code&gt;AsyncSequence&lt;/code&gt;s with Combine for example.&lt;/p&gt; &#xA;&lt;p&gt;This list is preliminary, and many new dependencies will be added to this library in the upcoming weeks. If you need one specific dependency, feel free to open a discussion, so we can find the better way it can integrate with the other ones.&lt;/p&gt; &#xA;&lt;h2&gt;How to use &lt;code&gt;Dependencies Additions&lt;/code&gt;?&lt;/h2&gt; &#xA;&lt;p&gt;This library proposes many heterogeneous dependencies. Having all of them bundled under the same repository has many benefits:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All the dependencies API&#39;s are designed coherently, with predictable behaviors.&lt;/li&gt; &#xA; &lt;li&gt;Some dependencies are too small to justify a fully-fledged repository. Having all of them at hand helps with discovery.&lt;/li&gt; &#xA; &lt;li&gt;Some dependencies depend on other dependencies, and it would be much more complex to manage if each project is in a dedicated repository.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can simply import &lt;code&gt;DependenciesAdditions&lt;/code&gt; umbrella product to get access to all the dependencies at once If you prefer more control, and because each dependency of them is self-contained in its own module, you can import only the ones that you need &#34;à la carte&#34;, on a file-by-file basis.&lt;/p&gt; &#xA;&lt;h3&gt;Using Xcode packages dependencies:&lt;/h3&gt; &#xA;&lt;p&gt;Add the &lt;code&gt;swift-dependencies-additions&lt;/code&gt; package, and only select &#34;DependenciesAdditions&#34; product&lt;/p&gt; &#xA;&lt;h3&gt;Using SwiftPM:&lt;/h3&gt; &#xA;&lt;p&gt;In the &lt;code&gt;dependencies&lt;/code&gt; section, add:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.package(url: &#34;https://github.com/tgrapperon/swift-dependencies-additions&#34;, from: &#34;0.1.0&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In each module you need access to these dependencies, add:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.target(&#xA;  name: &#34;MyModule&#34;,&#xA;  dependencies: [&#xA;    .product(name: &#34;DependenciesAdditions&#34;, package: &#34;swift-dependencies-additions&#34;)&#xA;  ]&#xA;),&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This gives access to all non-underscored dependencies. Experimental dependencies need to be imported individually. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.product(name: &#34;_AppStorage&#34;, package: &#34;swift-dependencies-additions&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;A quick tour of the dependencies&lt;/h2&gt; &#xA;&lt;p&gt;We present here a few of the dependencies currently shipping with the library. If you&#39;re more interested in experimental abstractions like &lt;code&gt;AppStorage&lt;/code&gt; or typed &lt;code&gt;Notification&lt;/code&gt;, you can directly jump to the &lt;a href=&#34;https://raw.githubusercontent.com/tgrapperon/swift-dependencies-additions/main/#higher-level-dependencies&#34;&gt;Higher-level dependencies&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h3&gt;Application&lt;/h3&gt; &#xA;&lt;p&gt;An abstraction over &lt;code&gt;UIApplication&lt;/code&gt; that you can use to communicate with your app&#39;s instance.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Model {&#xA;  @Dependency(\.application) var application&#xA;&#xA;  func setAlternateIcon(name: String) async throws {&#xA;    try await self.application.setAlternateIconName(name)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then, when testing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@MainActor &#xA;func testAlternateIconIsSet() async throws -&amp;gt; Void {&#xA;  var alternateIconName = LockIsolated(&#34;&#34;)&#xA;  let model = withDependencies {&#xA;    $0.application.$setAlternateIcon = { name in&#xA;      alternateIconName.withValue { $0 = name }&#xA;    }&#xA;  } operation: { Model() }&#xA;  try await model.setAlternateIcon(name: &#34;blueprint&#34;)&#xA;  XCTAssertEqual(alternateIconName.value, &#34;blueprint&#34;)&#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Accessibility&lt;/h3&gt; &#xA;&lt;p&gt;An abstraction over &lt;code&gt;UIAccessibility&lt;/code&gt; that you can use to monitor the accessibility state of your app&#39;s instance.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Model {&#xA;  @Dependency(\.accessibility.isClosedCaptioningEnabled) var isClosedCaptioningEnabled&#xA;&#xA;  func play() -&amp;gt; Void {&#xA;    if self.isClosedCaptioningEnabled {&#xA;      self.updateClosedCaptions()&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;BundleInfo&lt;/h3&gt; &#xA;&lt;p&gt;This simple dependency exposes a &lt;code&gt;BundleInfo&lt;/code&gt; type that allows to simply retrieve a few &lt;code&gt;info.plist&lt;/code&gt;-related fields, like the &lt;code&gt;bundleIdentifier&lt;/code&gt; or the app&#39;s &lt;code&gt;version&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Dependency(\.bundleInfo.bundleIdentifier) var bundleIdentifier&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As this value is often used to prefix identifiers, having this value exposed as a dependency allows you to control it at a distance when testing for example.&lt;/p&gt; &#xA;&lt;h3&gt;Codable&lt;/h3&gt; &#xA;&lt;p&gt;The library exposes two dependencies to help with coding or decoding your &lt;code&gt;Codable&lt;/code&gt; types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Dependency(\.encode) var encode&#xA;@Dependency(\.decode) var decode&#xA;&#xA;struct Point: Codable {&#xA;  var x: Double&#xA;  var y: Double&#xA;}&#xA;&#xA;let point = Point(x: 12, y: 35)&#xA;let encoded = try encode(point) // A `Data` value&#xA;let decoded = try decode(Point.self, from: encoded) // A `Point` value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, the API is very similar to JSON or PropertyList encoder and decoder.&lt;/p&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; are producing/consuming &lt;code&gt;JSON&lt;/code&gt; data.&lt;/p&gt; &#xA;&lt;h3&gt;Compression&lt;/h3&gt; &#xA;&lt;p&gt;In the same fashion as &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt;, the library exposes two dependencies to compress and decompress &lt;code&gt;Data&lt;/code&gt;, using Apple&#39;s Compression framework:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Dependency(\.compress) var compress&#xA;@Dependency(\.decompress) var decompress&#xA;&#xA;let uncompressed = &#34;Lorem ipsum dolor sit amet&#34;.data(using: .utf8)!&#xA;let compressed = try compress(uncompressed, using: .lzfse)&#xA;let decompressed = try decompress(compressed, using: .lzfse)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;They can also be called from async contexts, where a more efficient variant is used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let compressed = try await compress(uncompressed)&#xA;let decompressed = try await decompress(compressed)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;decompress&lt;/code&gt; are using the &lt;code&gt;.zlib&lt;/code&gt; algorithm.&lt;/p&gt; &#xA;&lt;h3&gt;Logger&lt;/h3&gt; &#xA;&lt;p&gt;This dependency exposes a privacy-aware &lt;code&gt;Logger&lt;/code&gt; instance. @Dependency(.logger) var logger&lt;/p&gt; &#xA;&lt;p&gt;You can simply use it as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;logger.log(level: .info, &#34;User with id: \(userID, privacy: .private) did purchase a smoothie&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can simply create a subsystem using the provided subscript:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Dependency(\.logger[&#34;Transactions&#34;]) var transactionsLogger&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;PersistentContainer&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;NSPersistentContainer&lt;/code&gt; that exposes Core Data &lt;code&gt;NSManagedObjectContext&lt;/code&gt;s. You can use it as a basis for more elaborate abstractions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Dependency(\.persistentContainer) var persistentContainer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the preview version is an &lt;code&gt;in-memory&lt;/code&gt; variant, and you can easily setup mocks for your SwiftUI previews:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var previews: some View {&#xA;  let model = withDependencies {&#xA;    $0.persistentContainer = .default(inMemory: true).with { context in&#xA;      let smoothie = Smoothie(context: context)&#xA;      smoothie.flavor = &#34;Banana&#34;&#xA;    }&#xA;  }&#xA;  SmoothieView(model: model)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ProcessInfo&lt;/h3&gt; &#xA;&lt;p&gt;A simple abstraction over &lt;code&gt;ProcessInfo&lt;/code&gt; that allows to retrieve low-level information on the system.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Dependency(\.processInfo.thermalState) var thermalState&#xA;&#xA;if thermalState == .critical {&#xA;  self.disableFancyAnimations()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because it&#39;s a dependency, you can test it very easily without having to modify your model.&lt;/p&gt; &#xA;&lt;h3&gt;UserDefaults&lt;/h3&gt; &#xA;&lt;p&gt;An abstraction over &lt;code&gt;UserDefaults&lt;/code&gt;, where you can read and save from the user preferences. The library exposes the same types as SwiftUI&#39;s AppStorage, so you can simply store and retrieve your data.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Dependency(\.userDefaults) var userDefaults&#xA;&#xA;userDefaults.set(true, forKey: &#34;hasUserPassedOnboarding&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With one line of code, you can make your whole app write to your app group user defaults, an in-memory version for testing, or even to &lt;code&gt;NSUbiquitousKeyValueStore&lt;/code&gt; that syncs user preferences over iCloud.&lt;/p&gt; &#xA;&lt;p&gt;You can also give a spin to the more powerful &lt;a href=&#34;https://raw.githubusercontent.com/tgrapperon/swift-dependencies-additions/main/#appstorage&#34;&gt;&lt;code&gt;_AppStorage&lt;/code&gt;&lt;/a&gt; dependency that is built on top of &lt;code&gt;\.userDefaults&lt;/code&gt;, and which allows to seamlessly observe and assign user preferences with an API similar to SwiftUI&#39;s &lt;code&gt;AppStorage&lt;/code&gt; (with which it can interoperate).&lt;/p&gt; &#xA;&lt;h3&gt;Other dependencies&lt;/h3&gt; &#xA;&lt;p&gt;Many other dependencies are available, like &lt;code&gt;UserNotifications&lt;/code&gt; to display notifications, &lt;code&gt;Device&lt;/code&gt; to interact with &lt;code&gt;UIDevice&lt;/code&gt; or &lt;code&gt;WKInterfaceDevice&lt;/code&gt;, &lt;code&gt;Path&lt;/code&gt; to contextualize your model&#39;s tree, a clicking &lt;code&gt;DateGenerator&lt;/code&gt; that is controlled by a &lt;code&gt;Clock&lt;/code&gt; (that you can control itself), etc.&lt;/p&gt; &#xA;&lt;p&gt;Of course, this is only the beginning and many other dependencies will be added in the upcoming weeks. We strongly feel that the larger the dependencies spectrum is, the more you will use them, and the more your code will be testable and structured.&lt;/p&gt; &#xA;&lt;h2&gt;Higher-level dependencies&lt;/h2&gt; &#xA;&lt;p&gt;The library proposes a few experimental higher-level dependencies. They are currently &#34;underscored&#34;, meaning that their APIs are not finalized. They may be extracted into their own library in the future.&lt;/p&gt; &#xA;&lt;h3&gt;AppStorage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Dependency.AppStorage(&#34;username&#34;) var username: String = &#34;Anonymous&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The API follows SwiftUI&#39;s &lt;code&gt;AppStorage&lt;/code&gt;, but is backed by &lt;code&gt;@Dependency(\.userDefaults)&lt;/code&gt;. It can operate within your model and be accessed from async contexts. If the same &lt;code&gt;key&lt;/code&gt;s are used, it can inter-operate with &lt;code&gt;SwiftUI&lt;/code&gt;&#39;s own &lt;code&gt;AppStorage&lt;/code&gt;. The projected value is an &lt;code&gt;AsyncStream&amp;lt;Value&amp;gt;&lt;/code&gt; of this user preference&#39;s values. They can be observed from any async context:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Dependency.AppStorage(&#34;isSoundEnabled&#34;) var isSoundEnabled: Bool = false&#xA;&#xA;for await isSoundEnabled in $isSoundEnabled {&#xA;  await isSoundEnabled ? audioEngine.start() : audioEngine.stop()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Notifications&lt;/h3&gt; &#xA;&lt;p&gt;This dependency allows exposing &lt;code&gt;Notification&lt;/code&gt;s as typed &lt;code&gt;AsyncSequence&lt;/code&gt;s.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Notifications {&#xA;  /// A typed `Notification` that publishes the current device&#39;s battery level.&#xA;  @MainActor&#xA;  public var batterLevelDidChange: SystemNotificationOf&amp;lt;Float&amp;gt; {&#xA;    .init(UIDevice.batteryLevelDidChangeNotification) { notification in&#xA;      @Dependency(\.device.batteryLevel) var level;&#xA;      return level&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then expose this notification with a dedicated property wrapper:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Dependency.Notification(\.batteryLevelDidChange) var batteryLevel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The exposed value is an async sequence of &lt;code&gt;Float&lt;/code&gt; representing the &lt;code&gt;batteryLevel&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;for await level in batteryLevel {&#xA;  if level &amp;lt; 0.2 {&#xA;    self.isLowPowerModeEnabled = true&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SwiftUI Environment&lt;/h3&gt; &#xA;&lt;p&gt;This dependency brings SwiftUI&#39;s &lt;code&gt;Environment&lt;/code&gt; into your model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Dependency.Environment(\.colorScheme) var colorScheme&#xA;@Dependency.Environment(\.dismiss) var dismiss&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, in any &lt;code&gt;View&lt;/code&gt;, you use the &lt;code&gt;.observeEnvironmentAsDependency(\.colorScheme)&lt;/code&gt; modifier to bubble up this value into the model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;HStack { … }&#xA;  .observeEnvironmentAsDependency(\.colorScheme)&#xA;  .observeEnvironmentAsDependency(\.dismiss)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the example above, &lt;code&gt;self.colorScheme&lt;/code&gt; is a &lt;code&gt;ColorScheme?&lt;/code&gt;, and &lt;code&gt;self.dismissAction&lt;/code&gt; is a &lt;code&gt;DismissAction?&lt;/code&gt;. Both are optional because they&#39;re conditioned by the existence of the &lt;code&gt;View&lt;/code&gt;, and they can become &lt;code&gt;nil&lt;/code&gt; again if this view goes away. You can observe their value through the projected value which is an &lt;code&gt;AsyncSequence&lt;/code&gt; of the wrapped value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;for await colorScheme in self.$colorScheme.compactMap{ $0 }.dropFirst() {&#xA;  self.logger.info(&#34;ColorScheme did change: \(colorScheme)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Core Data (WIP)&lt;/h3&gt; &#xA;&lt;p&gt;This dependency is still WIP because we would like to harden the API to avoid common pitfalls with CoreData. But you can get an excerpt of it in the CoreData CaseStudy!&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s next?&lt;/h2&gt; &#xA;&lt;p&gt;This is only the beginning! There are many other dependencies to implement: &lt;code&gt;Speech&lt;/code&gt;, &lt;code&gt;Vision&lt;/code&gt;, &lt;code&gt;KeyChain&lt;/code&gt;, etc… The only rule, for now, is that it shouldn&#39;t require a third-party dependency itself, and should work on &lt;code&gt;Apple&lt;/code&gt; or &lt;code&gt;Linux&lt;/code&gt; platforms out of the box. If you want to contribute a dependency, feel free to open a thread in the discussions!&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can add DependenciesAdditions to an Xcode project by adding it to your project as a package.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;https://github.com/tgrapperon/swift-dependencies-additions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use DependenciesAdditions in a SwiftPM project, it&#39;s as simple as adding it to your Package.swift:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;  .package(url: &#34;https://github.com/tgrapperon/swift-dependencies-additions&#34;, from: &#34;1.0.0&#34;)&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is released under the MIT license. See LICENSE for details.&lt;/p&gt;</summary>
  </entry>
</feed>