<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-18T01:42:30Z</updated>
  <subtitle>Daily Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>krzysztofzablocki/LifetimeTracker</title>
    <updated>2023-11-18T01:42:30Z</updated>
    <id>tag:github.com,2023-11-18:/krzysztofzablocki/LifetimeTracker</id>
    <link href="https://github.com/krzysztofzablocki/LifetimeTracker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Find retain cycles / memory leaks sooner.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LifetimeTracker&lt;/h1&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/krzysztofzablocki/LifetimeTracker/master/Resources/demo-bar.gif&#34; alt=&#34;Demo (bar)&#34;&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/krzysztofzablocki/LifetimeTracker/master/Resources/demo-circular.gif&#34; alt=&#34;Demo (circular)&#34;&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Bar style&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Circular style&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;LifetimeTracker can surface retain cycle / memory issues right as you develop your application, and it will surface them to you immediately, so you can find them with more ease.&lt;/p&gt; &#xA;&lt;p&gt;Instruments and Memory Graph Debugger are great, but too many times, developers forget to check for issues as they close the feature implementation.&lt;/p&gt; &#xA;&lt;p&gt;If you use those tools sporadically many of the issues they surface will require you to investigate the cause and cost you a lot of time in the process.&lt;/p&gt; &#xA;&lt;p&gt;Other tools like &lt;a href=&#34;https://github.com/facebook/FBRetainCycleDetector&#34;&gt;FBRetainCycleDetector&lt;/a&gt; rely on objc runtime magic to find the problems, but that means they can&#39;t really be used for pure Swift classes. This small tool simply focuses on tracking lifetime of objects which means that it can be used in both Objective-C and Swift codebases, and it doesn&#39;t rely on any complex or automatic magic behaviour.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;CocoaPods&lt;/h3&gt; &#xA;&lt;p&gt;Add &lt;code&gt;pod &#39;LifetimeTracker&#39;&lt;/code&gt; to your Podfile.&lt;/p&gt; &#xA;&lt;h3&gt;Carthage&lt;/h3&gt; &#xA;&lt;p&gt;Add &lt;code&gt;github &#34;krzysztofzablocki/LifetimeTracker&#34;&lt;/code&gt; to your Cartfile.&lt;/p&gt; &#xA;&lt;h3&gt;Swift Package Manager&lt;/h3&gt; &#xA;&lt;p&gt;Add &lt;code&gt;LifetimeTracker&#34;&lt;/code&gt; to the dependencies value of your Package.swift.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dependencies: [&#xA;    .package(url: &#34;https://github.com/krzysztofzablocki/LifetimeTracker.git&#34;, .upToNextMajor(from: &#34;1.8.0&#34;))&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Integration&lt;/h2&gt; &#xA;&lt;p&gt;To Integrate visual notifications simply add following line at the start of &lt;code&gt;AppDelegate(didFinishLaunchingWithOptions:)&lt;/code&gt; or if you are using iOS 13+ SceneDelegates in &lt;code&gt;scene(willConnectTo:options:)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Swift:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;#if DEBUG&#xA;&#x9;LifetimeTracker.setup(&#xA;        onUpdate: LifetimeTrackerDashboardIntegration(&#xA;            visibility: .alwaysVisible,&#xA;            style: .bar,&#xA;            textColorForNoIssues: .systemGreen,&#xA;            textColorForLeakDetected: .systemRed&#xA;        ).refreshUI&#xA;    )&#xA;#endif&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Objective-C:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;LifetimeTrackerDashboardIntegration *dashboardIntegration = [LifetimeTrackerDashboardIntegration new];&#xA;[dashboardIntegration setVisibleWhenIssueDetected];&#xA;[dashboardIntegration useBarStyle];&#xA;[LifetimeTracker setupOnUpdate:^(NSDictionary&amp;lt;NSString *,EntriesGroup *&amp;gt; * groups) {&#xA;    [dashboardIntegration refreshUIWithTrackedGroups: groups];&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can control when the dashboard is visible: &lt;code&gt;alwaysVisible&lt;/code&gt;, &lt;code&gt;alwaysHidden&lt;/code&gt;, or &lt;code&gt;visibleWithIssuesDetected&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There are two styles available. A overlay bar view which shows the detailed list of issues directly on the screen or a circular view which displays only the amount of issues and opens the detailed list as modal view controller.&lt;/p&gt; &#xA;&lt;h2&gt;Tracking key actors&lt;/h2&gt; &#xA;&lt;p&gt;Usually, you want to use LifetimeTracker to track only key actors in your app, like ViewModels / Controllers etc. When you have more than &lt;code&gt;maxCount&lt;/code&gt; items alive, the tracker will let you know.&lt;/p&gt; &#xA;&lt;h3&gt;Swift&lt;/h3&gt; &#xA;&lt;p&gt;You conform to &lt;code&gt;LifetimeTrackable&lt;/code&gt; and call &lt;code&gt;trackLifetime()&lt;/code&gt; at the end of your init functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class SectionFrontViewController: UIViewController, LifetimeTrackable {&#xA;    class var lifetimeConfiguration: LifetimeConfiguration {&#xA;        return LifetimeConfiguration(maxCount: 1, groupName: &#34;VC&#34;)&#xA;    }&#xA;    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {&#xA;        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)&#xA;        /// ...&#xA;        trackLifetime()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Objective-C&lt;/h3&gt; &#xA;&lt;p&gt;You conform to &lt;code&gt;LifetimeTrackable&lt;/code&gt; and call &lt;code&gt;[self trackLifetime]&lt;/code&gt; at the end of your init functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;@import LifetimeTracker;&#xA;&#xA;@interface SectionFrontViewController() &amp;lt;LifetimeTrackable&amp;gt;&#xA;&#xA;@implementation SectionFrontViewController&#xA;&#xA;+(LifetimeConfiguration *)lifetimeConfiguration&#xA;{&#xA;    return [[LifetimeConfiguration alloc] initWithMaxCount:1 groupName:@&#34;VC&#34;];&#xA;}&#xA;&#xA;- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil&#xA;{&#xA;    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];&#xA;    if (self) {&#xA;    &#x9;/// â€¦&#xA;        [self trackLifetime];&#xA;    }&#xA;    return self;&#xA;}&#xA;@end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Integrating with &lt;a href=&#34;https://danger.systems&#34;&gt;Danger&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;If you are using Danger, you can use it to add both checkboxes to each PR to ensure people have verified no retain cycles were created but also to inform you when someone forgets to call &lt;code&gt;trackLifetime()&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#&#xA;# ** FILE CHECKS **&#xA;# Checks for certain rules and warns if needed.&#xA;# Some rules can be disabled by using // danger:disable rule_name&#xA;#&#xA;# Rules:&#xA;# - Check if the modified file is a View and doesn&#39;t implement LifetimeTrackable (lifetime_tracking)&#xA;&#xA;# Sometimes an added file is also counted as modified. We want the files to be checked only once.&#xA;files_to_check = (git.modified_files + git.added_files).uniq&#xA;(files_to_check - %w(Dangerfile)).each do |file|&#xA;&#x9;next unless File.file?(file)&#xA;&#x9;# Only check inside swift files&#xA;  next unless File.extname(file).include?(&#34;.swift&#34;)&#xA;&#xA;  # Will be used to check if we&#39;re inside a comment block.&#xA;&#x9;is_comment_block = false&#xA;&#xA;&#x9;# Collects all disabled rules for this file.&#xA;&#x9;disabled_rules = []&#xA;&#xA;&#x9;filelines = File.readlines(file)&#xA;&#x9;filelines.each_with_index do |line, index|&#xA;&#x9;&#x9;if is_comment_block&#xA;&#x9;&#x9;&#x9;if line.include?(&#34;*/&#34;)&#xA;&#x9;&#x9;&#x9;&#x9;is_comment_block = false&#xA;&#x9;&#x9;&#x9;end&#xA;&#x9;&#x9;elsif line.include?(&#34;/*&#34;)&#xA;&#x9;&#x9;&#x9;is_comment_block = true&#xA;&#x9;&#x9;elsif line.include?(&#34;danger:disable&#34;)&#xA;&#x9;&#x9;&#x9;rule_to_disable = line.split.last&#xA;&#x9;&#x9;&#x9;disabled_rules.push(rule_to_disable)&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;# Start our custom line checks&#xA;&#x9;&#x9;&#x9;# e.g. you could do something like check for methods that only call the super class&#39; method&#xA;&#x9;&#x9;&#x9;#if line.include?(&#34;override&#34;) and line.include?(&#34;func&#34;) and filelines[index+1].include?(&#34;super&#34;) and filelines[index+2].include?(&#34;}&#34;)&#xA;&#x9;&#x9;&#x9;#&#x9;warn(&#34;Override methods which only call super can be removed&#34;, file: file, line: index+3)&#xA;&#x9;&#x9;&#x9;#end&#xA;    end&#xA;&#x9;end&#xA;&#xA;&#x9;# Only continue checks for Lifetime Trackable types&#xA;&#x9;next unless (File.basename(file).include?(&#34;ViewModel&#34;) or File.basename(file).include?(&#34;ViewController&#34;) or File.basename(file).include?(&#34;View.swift&#34;)) and !File.basename(file).include?(&#34;Node&#34;) and !File.basename(file).include?(&#34;Tests&#34;) and !File.basename(file).include?(&#34;FlowCoordinator&#34;)&#xA;&#xA;&#x9;if disabled_rules.include?(&#34;lifetime_tracking&#34;) == false&#xA;&#x9;&#x9;if File.readlines(file).grep(/LifetimeTrackable/).any?&#xA;&#x9;&#x9;&#x9;fail(&#34;You forgot to call trackLifetime() from your initializers in &#34; + File.basename(file, &#34;.*&#34;) + &#34; (lifetime_tracking)&#34;) unless File.readlines(file).grep(/trackLifetime()/).any?&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;warn(&#34;Please add support for LifetimeTrackable to &#34; + File.basename(file, &#34;.*&#34;) + &#34; . (lifetime_tracking)&#34;)&#xA;&#x9;&#x9;end&#xA;&#x9;&#x9;markdown(&#34;- [ ] I&#39;ve verified that showing and hiding &#34; + File.basename(file, &#34;.*&#34;) + &#34; doesn&#39;t surface any [LifetimeTracker](https://github.com/krzysztofzablocki/LifetimeTracker) issues&#34;)&#xA;&#x9;end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Surface last notification from the stack&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes it is useful to get information about last retain cycle in order to log it to external sources such as analytics/trackers. In order to do that we can update initial configuration with &lt;code&gt;onLeakDetected&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;[LifetimeTracker setupOnLeakDetected:^(Entry * entry, EntriesGroup * group) {&#xA;    NSLog(@&#34;POSSIBLE LEAK ALERT: %@ - current count %li, max count %li&#34;, entry.name, (long)entry.count, (long)entry.maxCount);&#xA;} onUpdate:^(NSDictionary&amp;lt;NSString *,EntriesGroup *&amp;gt; * groups) {&#xA;    [dashboardIntegration refreshUIWithTrackedGroups: groups];&#xA;}];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;LifetimeTracker.setup(onLeakDetected: { entity, _ in&#xA;&#x9;log.warning(&#34;POSSIBLE LEAK ALERT: \(entity.name) - current count: \(entity.count), max count: \(entity.maxCount)&#34;)&#xA;}, onUpdate: LifetimeTrackerDashboardIntegration(visibility: .alwaysVisible, style: .bar).refreshUI)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Group tracked objects&lt;/h2&gt; &#xA;&lt;p&gt;You can group tracked objects together. &lt;code&gt;maxCount&lt;/code&gt; of a group will be calculated by &lt;code&gt;maxCount&lt;/code&gt; of all members per default. However, you can override it and provide a separate value to the group with &lt;code&gt;groupMaxCount&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You may want to do this when you have a set of subclasses which can appear x times each, but in total only less than the sum of all subclasses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// DetailPage: UIViewController&#xA;&#xA;// VideoDetailPage: DetailItem&#xA;LifetimeConfiguration(maxCount: 3, groupName: &#34;Detail Page&#34;)&#xA;&#xA;// ImageDetailPage: DetailItem&#xA;LifetimeConfiguration(maxCount: 3, groupName: &#34;Detail Page&#34;)&#xA;&#xA;=&amp;gt; Group warning if 7 DetailPage objects are alive&#xA;&#xA;// VideoDetailPage: DetailItem&#xA;LifetimeConfiguration(maxCount: 3, groupName: &#34;Detail Page&#34;, groupMaxCount: 3)&#xA;&#xA;// ImageDetailPage: DetailItem&#xA;LifetimeConfiguration(maxCount: 3, groupName: &#34;Detail Page&#34;, groupMaxCount: 3)&#xA;&#xA;=&amp;gt; Group warning if 4 DetailPage object are alive&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Writing integration tests for memory leaks&lt;/h2&gt; &#xA;&lt;p&gt;You can access the summary label using accessibility identifier &lt;code&gt;LifetimeTracker.summaryLabel&lt;/code&gt;, which allows you to write integration tests that end up with looking up whether any issues were found.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;LifetimeTracker is available under the MIT license. See &lt;a href=&#34;https://raw.githubusercontent.com/krzysztofzablocki/LifetimeTracker/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Attributions&lt;/h2&gt; &#xA;&lt;p&gt;I&#39;ve used &lt;a href=&#34;https://github.com/JohnSundell/SwiftPlate&#34;&gt;SwiftPlate&lt;/a&gt; to generate xcodeproj compatible with CocoaPods and Carthage.&lt;/p&gt;</summary>
  </entry>
</feed>