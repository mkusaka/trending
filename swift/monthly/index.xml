<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-04-01T02:08:41Z</updated>
  <subtitle>Monthly Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>krzyzanowskim/CryptoSwift</title>
    <updated>2025-04-01T02:08:41Z</updated>
    <id>tag:github.com,2025-04-01:/krzyzanowskim/CryptoSwift</id>
    <link href="https://github.com/krzyzanowskim/CryptoSwift" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CryptoSwift is a growing collection of standard and secure cryptographic algorithms implemented in Swift&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#installation&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Platforms-iOS%20%7C%20Android%20%7C%20macOS%20%7C%20watchOS%20%7C%20tvOS%20%7C%20Linux-4E4E4E.svg?colorA=28a745&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#swift-versions-support&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Swift-3.1%20%7C%203.2%20%7C%204.0%20%7C%204.1%20%7C%204.2%20%7C%205.0-lightgrey.svg?colorA=28a745&amp;amp;colorB=4E4E4E&#34; alt=&#34;Swift support&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/swiftlang/swift-package-manager&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/SPM-compatible-brightgreen.svg?style=flat&amp;amp;colorA=28a745&amp;amp;&amp;amp;colorB=4E4E4E&#34; alt=&#34;Swift Package Manager compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cocoapods.org/pods/CryptoSwift&#34;&gt;&lt;img src=&#34;https://img.shields.io/cocoapods/v/CryptoSwift.svg?style=flat&amp;amp;label=CocoaPods&amp;amp;colorA=28a745&amp;amp;&amp;amp;colorB=4E4E4E&#34; alt=&#34;CocoaPods Compatible&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-brightgreen.svg?style=flat&amp;amp;colorA=28a745&amp;amp;&amp;amp;colorB=4E4E4E&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;CryptoSwift&lt;/h1&gt; &#xA;&lt;p&gt;Crypto related functions and helpers for &lt;a href=&#34;https://swift.org&#34;&gt;Swift&lt;/a&gt; implemented in Swift. (&lt;a href=&#34;https://twitter.com/hashtag/pureswift&#34;&gt;#PureSwift&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;main&lt;/code&gt; branch follows the latest currently released &lt;strong&gt;version of Swift&lt;/strong&gt;. If you need an earlier version for an older version of Swift, specify its version in your &lt;code&gt;Podfile&lt;/code&gt; or use the code on the branch for that version. Older branches are unsupported. Check &lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#swift-versions-support&#34;&gt;versions&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#requirements&#34;&gt;Requirements&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#features&#34;&gt;Features&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#contribution&#34;&gt;Contribution&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#installation&#34;&gt;Installation&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#swift-versions-support&#34;&gt;Swift versions&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#how-to&#34;&gt;How-to&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#author&#34;&gt;Author&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#license&#34;&gt;License&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#changelog&#34;&gt;Changelog&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Support &amp;amp; Sponsors&lt;/h3&gt; &#xA;&lt;p&gt;The financial sustainability of the project is possible thanks to the ongoing contributions from our &lt;a href=&#34;https://github.com/sponsors/krzyzanowskim&#34;&gt;GitHub Sponsors&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Premium Sponsors&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.emergetools.com/&#34;&gt;Emerge Tools&lt;/a&gt; is a suite of revolutionary products designed to supercharge mobile apps and the teams that build them.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.emergetools.com&#34;&gt;&lt;img alt=&#34;www.emergetools.com/&#34; width=&#34;200&#34; src=&#34;https://github-production-user-asset-6210df.s3.amazonaws.com/758033/256565082-a21f5ac1-ef39-4b56-a8d2-575adeb7fe55.png&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;Good mood&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Easy to use&lt;/li&gt; &#xA; &lt;li&gt;Convenient extensions for String and Data&lt;/li&gt; &#xA; &lt;li&gt;Support for incremental updates (stream, ...)&lt;/li&gt; &#xA; &lt;li&gt;iOS, Android, macOS, AppleTV, watchOS, Linux support&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Hash (Digest)&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc1321&#34;&gt;MD5&lt;/a&gt; | &lt;a href=&#34;https://tools.ietf.org/html/rfc3174&#34;&gt;SHA1&lt;/a&gt; | &lt;a href=&#34;https://tools.ietf.org/html/rfc6234&#34;&gt;SHA2-224&lt;/a&gt; | &lt;a href=&#34;https://tools.ietf.org/html/rfc6234&#34;&gt;SHA2-256&lt;/a&gt; | &lt;a href=&#34;https://tools.ietf.org/html/rfc6234&#34;&gt;SHA2-384&lt;/a&gt; | &lt;a href=&#34;https://tools.ietf.org/html/rfc6234&#34;&gt;SHA2-512&lt;/a&gt; | &lt;a href=&#34;https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf&#34;&gt;SHA3&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Cyclic Redundancy Check (CRC)&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&#34;&gt;CRC32&lt;/a&gt; | &lt;a href=&#34;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&#34;&gt;CRC32C&lt;/a&gt; | &lt;a href=&#34;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&#34;&gt;CRC16&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Cipher&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf&#34;&gt;AES-128, AES-192, AES-256&lt;/a&gt; | &lt;a href=&#34;http://cr.yp.to/chacha/chacha-20080128.pdf&#34;&gt;ChaCha20&lt;/a&gt; | &lt;a href=&#34;https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha&#34;&gt;XChaCha20&lt;/a&gt; | &lt;a href=&#34;https://tools.ietf.org/html/rfc4503&#34;&gt;Rabbit&lt;/a&gt; | &lt;a href=&#34;https://www.schneier.com/academic/blowfish/&#34;&gt;Blowfish&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;RSA (public-key encryption algorithm)&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift#rsa&#34;&gt;Encryption, Signature&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Message authenticators&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cr.yp.to/mac/poly1305-20050329.pdf&#34;&gt;Poly1305&lt;/a&gt; | &lt;a href=&#34;https://www.ietf.org/rfc/rfc2104.txt&#34;&gt;HMAC (MD5, SHA1, SHA256)&lt;/a&gt; | &lt;a href=&#34;https://tools.ietf.org/html/rfc4493&#34;&gt;CMAC&lt;/a&gt; | &lt;a href=&#34;https://en.wikipedia.org/wiki/CBC-MAC&#34;&gt;CBC-MAC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Cipher mode of operation&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Electronic codebook (&lt;a href=&#34;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_.28ECB.29&#34;&gt;ECB&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Cipher-block chaining (&lt;a href=&#34;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher-block_chaining_.28CBC.29&#34;&gt;CBC&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Propagating Cipher Block Chaining (&lt;a href=&#34;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Propagating_Cipher_Block_Chaining_.28PCBC.29&#34;&gt;PCBC&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Cipher feedback (&lt;a href=&#34;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_feedback_.28CFB.29&#34;&gt;CFB&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Output Feedback (&lt;a href=&#34;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Output_Feedback_.28OFB.29&#34;&gt;OFB&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Counter Mode (&lt;a href=&#34;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_.28CTR.29&#34;&gt;CTR&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Galois/Counter Mode (&lt;a href=&#34;https://csrc.nist.gov/publications/detail/sp/800-38d/final&#34;&gt;GCM&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Counter with Cipher Block Chaining-Message Authentication Code (&lt;a href=&#34;https://csrc.nist.gov/publications/detail/sp/800-38c/final&#34;&gt;CCM&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;OCB Authenticated-Encryption Algorithm (&lt;a href=&#34;https://tools.ietf.org/html/rfc7253&#34;&gt;OCB&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Password-Based Key Derivation Function&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc2898#section-5.1&#34;&gt;PBKDF1&lt;/a&gt; (Password-Based Key Derivation Function 1)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc2898#section-5.2&#34;&gt;PBKDF2&lt;/a&gt; (Password-Based Key Derivation Function 2)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc5869&#34;&gt;HKDF&lt;/a&gt; (HMAC-based Extract-and-Expand Key Derivation Function)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc7914&#34;&gt;Scrypt&lt;/a&gt; (The scrypt Password-Based Key Derivation Function)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Data padding&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc2898.html&#34;&gt;PKCS#5&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc3447#section-9.2&#34;&gt;EMSA-PKCS1-v1_5 (Encoding Method for Signature)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc3447&#34;&gt;EME-PCKS1-v1_5 (Encoding Method for Encryption)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc5652#section-6.3&#34;&gt;PKCS#7&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Padding_(cryptography)#Zero_padding&#34;&gt;Zero padding&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.embedx.com/pdfs/ISO_STD_7816/info_isoiec7816-4%7Bed21.0%7Den.pdf&#34;&gt;ISO78164&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Padding_(cryptography)#ISO_10126&#34;&gt;ISO10126&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;No padding&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Authenticated Encryption with Associated Data (AEAD)&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc7539#section-2.8&#34;&gt;AEAD_CHACHA20_POLY1305&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#section-2&#34;&gt;AEAD_XCHACHA20_POLY1305&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Why&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/discussions/982&#34;&gt;Why?&lt;/a&gt; &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/discussions/982#discussioncomment-3669415&#34;&gt;Because I can&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How do I get involved?&lt;/h2&gt; &#xA;&lt;p&gt;You want to help, great! Go ahead and fork our repo, make your changes and send us a pull request.&lt;/p&gt; &#xA;&lt;h2&gt;Contribution&lt;/h2&gt; &#xA;&lt;p&gt;Check out &lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for more information on how to help with CryptoSwift.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you found a bug, &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/discussions&#34;&gt;open a discussion&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If you have a feature request, &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/discussions&#34;&gt;open a discussion&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Hardened Runtime (macOS) and Xcode&lt;/h3&gt; &#xA;&lt;p&gt;Binary CryptoSwift.xcframework (Used by Swift Package Manager package integration) won&#39;t load properly in your app if the app uses &lt;strong&gt;Sign to Run Locally&lt;/strong&gt; Signing Certificate with Hardened Runtime enabled. It is possible to setup Xcode like this. To solve the problem you have two options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use proper Signing Certificate, eg. &lt;em&gt;Development&lt;/em&gt; &amp;lt;- this is the proper action&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;code&gt;Disable Library Validation&lt;/code&gt; aka &lt;code&gt;com.apple.security.cs.disable-library-validation&lt;/code&gt; entitlement&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Xcode Project&lt;/h4&gt; &#xA;&lt;p&gt;To install CryptoSwift, add it as a submodule to your project (on the top level project directory):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git submodule add https://github.com/krzyzanowskim/CryptoSwift.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is recommended to enable &lt;a href=&#34;https://swift.org/blog/whole-module-optimizations/&#34;&gt;Whole-Module Optimization&lt;/a&gt; to gain better performance. Non-optimized build results in significantly worse performance.&lt;/p&gt; &#xA;&lt;h4&gt;Swift Package Manager&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;https://swift.org/package-manager/&#34;&gt;Swift Package Manager&lt;/a&gt; and specify dependency in &lt;code&gt;Package.swift&lt;/code&gt; by adding this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.package(url: &#34;https://github.com/krzyzanowskim/CryptoSwift.git&#34;, from: &#34;1.8.3&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See: &lt;a href=&#34;https://blog.krzyzanowskim.com/2016/08/09/package-swift-manual/&#34;&gt;Package.swift - manual&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Notice: Swift Package Manager uses debug configuration for debug Xcode build, that may result in significant (up to x10000) worse performance. Performance characteristic is different in Release build. To overcome this problem, consider embed &lt;code&gt;CryptoSwift.xcframework&lt;/code&gt; described below.&lt;/p&gt; &#xA;&lt;h4&gt;CocoaPods&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;https://cocoapods.org/pods/CryptoSwift&#34;&gt;CocoaPods&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pod &#39;CryptoSwift&#39;, &#39;~&amp;gt; 1.8.3&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Bear in mind that CocoaPods will build CryptoSwift without &lt;a href=&#34;https://swift.org/blog/whole-module-optimizations/&#34;&gt;Whole-Module Optimization&lt;/a&gt; that may impact performance. You can change it manually after installation, or use &lt;a href=&#34;https://github.com/jedlewison/cocoapods-wholemodule&#34;&gt;cocoapods-wholemodule&lt;/a&gt; plugin.&lt;/p&gt; &#xA;&lt;h4&gt;Carthage&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;. Specify in Cartfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;github &#34;krzyzanowskim/CryptoSwift&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run &lt;code&gt;carthage&lt;/code&gt; to build the framework and drag the built CryptoSwift.framework into your Xcode project. Follow &lt;a href=&#34;https://github.com/Carthage/Carthage#getting-started&#34;&gt;build instructions&lt;/a&gt;. &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/discussions/983#discussioncomment-3669433&#34;&gt;Common issues&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;XCFramework&lt;/h4&gt; &#xA;&lt;p&gt;XCFrameworks require Xcode 11 or later and they can be integrated similarly to how we’re used to integrating the &lt;code&gt;.framework&lt;/code&gt; format. Please use script &lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/scripts/build-framework.sh&#34;&gt;scripts/build-framework.sh&lt;/a&gt; to generate binary &lt;code&gt;CryptoSwift.xcframework&lt;/code&gt; archive that you can use as a dependency in Xcode.&lt;/p&gt; &#xA;&lt;p&gt;CryptoSwift.xcframework is a Release (Optimized) binary that offer best available Swift code performance.&lt;/p&gt; &#xA;&lt;img width=&#34;320&#34; alt=&#34;Screen Shot 2020-10-27 at 00 06 32&#34; src=&#34;https://user-images.githubusercontent.com/758033/97240586-f0878280-17ee-11eb-9119-e5a960417d04.png&#34;&gt; &#xA;&lt;h4&gt;Embedded Framework&lt;/h4&gt; &#xA;&lt;p&gt;Embedded frameworks require a minimum deployment target of iOS 11.0 or macOS Sierra (10.13). Drag the &lt;code&gt;CryptoSwift.xcodeproj&lt;/code&gt; file into your Xcode project, and add appropriate framework as a dependency to your target. Now select your App and choose the General tab for the app target. Find &lt;em&gt;Embedded Binaries&lt;/em&gt; and press &#34;+&#34;, then select &lt;code&gt;CryptoSwift.framework&lt;/code&gt; (iOS, macOS, watchOS or tvOS)&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/758033/10834511/25a26852-7e9a-11e5-8c01-6cc8f1838459.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Sometimes &#34;embedded framework&#34; option is not available. In that case, you have to add new build phase for the target.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/758033/18415615/d5edabb0-77f8-11e6-8c94-f41d9fc2b8cb.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h5&gt;iOS, macOS, watchOS, tvOS&lt;/h5&gt; &#xA;&lt;p&gt;In the project, you&#39;ll find &lt;a href=&#34;https://mxcl.dev/PromiseKit/news/2016/08/Multiplatform-Single-Scheme-Xcode-Projects/&#34;&gt;single scheme&lt;/a&gt; for all platforms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CryptoSwift&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Swift versions support&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Swift 1.2: branch &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/tree/swift12&#34;&gt;swift12&lt;/a&gt; version &amp;lt;= 0.0.13&lt;/li&gt; &#xA; &lt;li&gt;Swift 2.1: branch &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/tree/swift21&#34;&gt;swift21&lt;/a&gt; version &amp;lt;= 0.2.3&lt;/li&gt; &#xA; &lt;li&gt;Swift 2.2, 2.3: branch &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/tree/swift2&#34;&gt;swift2&lt;/a&gt; version &amp;lt;= 0.5.2&lt;/li&gt; &#xA; &lt;li&gt;Swift 3.1, branch &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/tree/swift3&#34;&gt;swift3&lt;/a&gt; version &amp;lt;= 0.6.9&lt;/li&gt; &#xA; &lt;li&gt;Swift 3.2, branch &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/tree/swift32&#34;&gt;swift32&lt;/a&gt; version = 0.7.0&lt;/li&gt; &#xA; &lt;li&gt;Swift 4.0, branch &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/tree/swift4&#34;&gt;swift4&lt;/a&gt; version &amp;lt;= 0.12.0&lt;/li&gt; &#xA; &lt;li&gt;Swift 4.2, branch &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/tree/swift42&#34;&gt;swift42&lt;/a&gt; version &amp;lt;= 0.15.0&lt;/li&gt; &#xA; &lt;li&gt;Swift 5.0, branch &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/tree/swift5&#34;&gt;swift5&lt;/a&gt; version &amp;lt;= 1.2.0&lt;/li&gt; &#xA; &lt;li&gt;Swift 5.1, branch &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/tree/swift51&#34;&gt;swift5&lt;/a&gt; version &amp;lt;= 1.3.3&lt;/li&gt; &#xA; &lt;li&gt;Swift 5.3 and newer, branch &lt;a href=&#34;https://github.com/krzyzanowskim/CryptoSwift/tree/main&#34;&gt;main&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How-to&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#basics&#34;&gt;Basics (data types, conversion, ...)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#calculate-digest&#34;&gt;Digest (MD5, SHA...)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#message-authenticators-1&#34;&gt;Message authenticators (HMAC, CMAC...)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#password-based-key-derivation-functions&#34;&gt;Password-Based Key Derivation Function (PBKDF2, ...)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#hmac-based-key-derivation-function&#34;&gt;HMAC-based Key Derivation Function (HKDF)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#data-padding&#34;&gt;Data Padding&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#chacha20&#34;&gt;ChaCha20&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#rabbit&#34;&gt;Rabbit&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#blowfish&#34;&gt;Blowfish&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#aes&#34;&gt;AES - Advanced Encryption Standard&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#aes-gcm&#34;&gt;AES-GCM&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/#aead&#34;&gt;Authenticated Encryption with Associated Data (AEAD)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Basics&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import CryptoSwift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;CryptoSwift uses array of bytes aka &lt;code&gt;Array&amp;lt;UInt8&amp;gt;&lt;/code&gt; as a base type for all operations. Every data may be converted to a stream of bytes. You will find convenience functions that accept &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt;, and it will be internally converted to the array of bytes.&lt;/p&gt; &#xA;&lt;h5&gt;Data types conversion&lt;/h5&gt; &#xA;&lt;p&gt;For your convenience, &lt;strong&gt;CryptoSwift&lt;/strong&gt; provides two functions to easily convert an array of bytes to &lt;code&gt;Data&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt; to an array of bytes:&lt;/p&gt; &#xA;&lt;p&gt;Data from bytes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let data = Data([0x01, 0x02, 0x03])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Data&lt;/code&gt; to &lt;code&gt;Array&amp;lt;UInt8&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let bytes = data.bytes                     // [1,2,3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Hexadecimal&#34;&gt;Hexadecimal&lt;/a&gt; encoding:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let bytes = Array&amp;lt;UInt8&amp;gt;(hex: &#34;0x010203&#34;)  // [1,2,3]&#xA;let hex   = bytes.toHexString()            // &#34;010203&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Build bytes out of &lt;code&gt;String&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let bytes: Array&amp;lt;UInt8&amp;gt; = &#34;cipherkey&#34;.bytes  // Array(&#34;cipherkey&#34;.utf8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also... check out helpers that work with &lt;strong&gt;Base64&lt;/strong&gt; encoded data:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;&#34;aPf/i9th9iX+vf49eR7PYk2q7S5xmm3jkRLejgzHNJs=&#34;.decryptBase64ToString(cipher)&#xA;&#34;aPf/i9th9iX+vf49eR7PYk2q7S5xmm3jkRLejgzHNJs=&#34;.decryptBase64(cipher)&#xA;bytes.toBase64()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Calculate Digest&lt;/h5&gt; &#xA;&lt;p&gt;Hashing a data or array of bytes (aka &lt;code&gt;Array&amp;lt;UInt8&amp;gt;&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;/* Hash struct usage */&#xA;let bytes: Array&amp;lt;UInt8&amp;gt; = [0x01, 0x02, 0x03]&#xA;let digest = input.md5()&#xA;let digest = Digest.md5(bytes)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let data = Data([0x01, 0x02, 0x03])&#xA;&#xA;let hash = data.md5()&#xA;let hash = data.sha1()&#xA;let hash = data.sha224()&#xA;let hash = data.sha256()&#xA;let hash = data.sha384()&#xA;let hash = data.sha512()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    var digest = MD5()&#xA;    let partial1 = try digest.update(withBytes: [0x31, 0x32])&#xA;    let partial2 = try digest.update(withBytes: [0x33])&#xA;    let result = try digest.finish()&#xA;} catch { }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hashing a String and printing result&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let hash = &#34;123&#34;.md5() // &#34;123&#34;.bytes.md5()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Calculate CRC&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;bytes.crc16()&#xA;data.crc16()&#xA;&#xA;bytes.crc32()&#xA;data.crc32()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Message authenticators&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Calculate Message Authentication Code (MAC) for message&#xA;let key: Array&amp;lt;UInt8&amp;gt; = [1,2,3,4,5,6,7,8,9,10,...]&#xA;&#xA;try Poly1305(key: key).authenticate(bytes)&#xA;try HMAC(key: key, variant: .sha256).authenticate(bytes)&#xA;try CMAC(key: key).authenticate(bytes)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Password-Based Key Derivation Functions&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let password: Array&amp;lt;UInt8&amp;gt; = Array(&#34;s33krit&#34;.utf8)&#xA;let salt: Array&amp;lt;UInt8&amp;gt; = Array(&#34;nacllcan&#34;.utf8)&#xA;&#xA;let key = try PKCS5.PBKDF2(password: password, salt: salt, iterations: 4096, keyLength: 32, variant: .sha2(.sha256)).calculate()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let password: Array&amp;lt;UInt8&amp;gt; = Array(&#34;s33krit&#34;.utf8)&#xA;let salt: Array&amp;lt;UInt8&amp;gt; = Array(&#34;nacllcan&#34;.utf8)&#xA;// Scrypt implementation does not implement work parallelization, so `p` parameter will&#xA;// increase the work time even in multicore systems&#xA;let key = try Scrypt(password: password, salt: salt, dkLen: 64, N: 16384, r: 8, p: 1).calculate()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;HMAC-based Key Derivation Function&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let password: Array&amp;lt;UInt8&amp;gt; = Array(&#34;s33krit&#34;.utf8)&#xA;let salt: Array&amp;lt;UInt8&amp;gt; = Array(&#34;nacllcan&#34;.utf8)&#xA;&#xA;let key = try HKDF(password: password, salt: salt, variant: .sha256).calculate()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Data Padding&lt;/h5&gt; &#xA;&lt;p&gt;Some content-encryption algorithms assume the input length is a multiple of &lt;code&gt;k&lt;/code&gt; octets, where &lt;code&gt;k&lt;/code&gt; is greater than one. For such algorithms, the input shall be padded.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Padding.pkcs7.add(to: bytes, blockSize: AES.blockSize)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Working with Ciphers&lt;/h4&gt; &#xA;&lt;h5&gt;ChaCha20&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let encrypted = try ChaCha20(key: key, iv: iv).encrypt(message)&#xA;let decrypted = try ChaCha20(key: key, iv: iv).decrypt(encrypted)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Rabbit&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let encrypted = try Rabbit(key: key, iv: iv).encrypt(message)&#xA;let decrypted = try Rabbit(key: key, iv: iv).decrypt(encrypted)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Blowfish&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let encrypted = try Blowfish(key: key, blockMode: CBC(iv: iv), padding: .pkcs7).encrypt(message)&#xA;let decrypted = try Blowfish(key: key, blockMode: CBC(iv: iv), padding: .pkcs7).decrypt(encrypted)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;AES&lt;/h5&gt; &#xA;&lt;p&gt;Notice regarding padding: &lt;em&gt;Manual padding of data is optional, and CryptoSwift is using PKCS7 padding by default. If you need to manually disable/enable padding, you can do this by setting parameter for &lt;strong&gt;AES&lt;/strong&gt; class&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Variant of AES encryption (AES-128, AES-192, AES-256) depends on given key length:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;AES-128 = 16 bytes&lt;/li&gt; &#xA; &lt;li&gt;AES-192 = 24 bytes&lt;/li&gt; &#xA; &lt;li&gt;AES-256 = 32 bytes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;AES-256 example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let encryptedBytes = try AES(key: [1,2,3,...,32], blockMode: CBC(iv: [1,2,3,...,16]), padding: .pkcs7)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Full example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let password: [UInt8] = Array(&#34;s33krit&#34;.utf8)&#xA;let salt: [UInt8] = Array(&#34;nacllcan&#34;.utf8)&#xA;&#xA;/* Generate a key from a `password`. Optional if you already have a key */&#xA;let key = try PKCS5.PBKDF2(&#xA;    password: password,&#xA;    salt: salt,&#xA;    iterations: 4096,&#xA;    keyLength: 32, /* AES-256 */&#xA;    variant: .sha256&#xA;).calculate()&#xA;&#xA;/* Generate random IV value. IV is public value. Either need to generate, or get it from elsewhere */&#xA;let iv = AES.randomIV(AES.blockSize)&#xA;&#xA;/* AES cryptor instance */&#xA;let aes = try AES(key: key, blockMode: CBC(iv: iv), padding: .pkcs7)&#xA;&#xA;/* Encrypt Data */&#xA;let inputData = Data()&#xA;let encryptedBytes = try aes.encrypt(inputData.bytes)&#xA;let encryptedData = Data(encryptedBytes)&#xA;&#xA;/* Decrypt Data */&#xA;let decryptedBytes = try aes.decrypt(encryptedData.bytes)&#xA;let decryptedData = Data(decryptedBytes)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;All at once&lt;/h6&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    let aes = try AES(key: &#34;keykeykeykeykeyk&#34;, iv: &#34;drowssapdrowssap&#34;) // aes128&#xA;    let ciphertext = try aes.encrypt(Array(&#34;Nullam quis risus eget urna mollis ornare vel eu leo.&#34;.utf8))&#xA;} catch { }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;Incremental updates&lt;/h6&gt; &#xA;&lt;p&gt;Incremental operations use instance of Cryptor and encrypt/decrypt one part at a time, this way you can save on memory for large files.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    var encryptor = try AES(key: &#34;keykeykeykeykeyk&#34;, iv: &#34;drowssapdrowssap&#34;).makeEncryptor()&#xA;&#xA;    var ciphertext = Array&amp;lt;UInt8&amp;gt;()&#xA;    // aggregate partial results&#xA;    ciphertext += try encryptor.update(withBytes: Array(&#34;Nullam quis risus &#34;.utf8))&#xA;    ciphertext += try encryptor.update(withBytes: Array(&#34;eget urna mollis &#34;.utf8))&#xA;    ciphertext += try encryptor.update(withBytes: Array(&#34;ornare vel eu leo.&#34;.utf8))&#xA;    // finish at the end&#xA;    ciphertext += try encryptor.finish()&#xA;&#xA;    print(ciphertext.toHexString())&#xA;} catch {&#xA;    print(error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;AES Advanced usage&lt;/h6&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let input: Array&amp;lt;UInt8&amp;gt; = [0,1,2,3,4,5,6,7,8,9]&#xA;&#xA;let key: Array&amp;lt;UInt8&amp;gt; = [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00]&#xA;let iv: Array&amp;lt;UInt8&amp;gt; = // Random bytes of `AES.blockSize` length&#xA;&#xA;do {&#xA;    let encrypted = try AES(key: key, blockMode: CBC(iv: iv), padding: .pkcs7).encrypt(input)&#xA;    let decrypted = try AES(key: key, blockMode: CBC(iv: iv), padding: .pkcs7).decrypt(encrypted)&#xA;} catch {&#xA;    print(error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;AES without data padding&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let input: Array&amp;lt;UInt8&amp;gt; = [0,1,2,3,4,5,6,7,8,9]&#xA;let encrypted: Array&amp;lt;UInt8&amp;gt; = try! AES(key: Array(&#34;secret0key000000&#34;.utf8), blockMode: CBC(iv: Array(&#34;0123456789012345&#34;.utf8)), padding: .noPadding).encrypt(input)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using convenience extensions&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let plain = Data([0x01, 0x02, 0x03])&#xA;let encrypted = try! plain.encrypt(ChaCha20(key: key, iv: iv))&#xA;let decrypted = try! encrypted.decrypt(ChaCha20(key: key, iv: iv))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;AES-GCM&lt;/h5&gt; &#xA;&lt;p&gt;The result of Galois/Counter Mode (GCM) encryption is ciphertext and &lt;strong&gt;authentication tag&lt;/strong&gt;, that is later used to decryption.&lt;/p&gt; &#xA;&lt;p&gt;encryption&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    // In combined mode, the authentication tag is directly appended to the encrypted message. This is usually what you want.&#xA;    let gcm = GCM(iv: iv, mode: .combined)&#xA;    let aes = try AES(key: key, blockMode: gcm, padding: .noPadding)&#xA;    let encrypted = try aes.encrypt(plaintext)&#xA;    let tag = gcm.authenticationTag&#xA;} catch {&#xA;    // failed&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;decryption&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    // In combined mode, the authentication tag is appended to the encrypted message. This is usually what you want.&#xA;    let gcm = GCM(iv: iv, mode: .combined)&#xA;    let aes = try AES(key: key, blockMode: gcm, padding: .noPadding)&#xA;    return try aes.decrypt(encrypted)&#xA;} catch {&#xA;    // failed&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: GCM instance is not intended to be reused. So you can&#39;t use the same &lt;code&gt;GCM&lt;/code&gt; instance from encoding to also perform decoding.&lt;/p&gt; &#xA;&lt;h5&gt;AES-CCM&lt;/h5&gt; &#xA;&lt;p&gt;The result of Counter with Cipher Block Chaining-Message Authentication Code encryption is ciphertext and &lt;strong&gt;authentication tag&lt;/strong&gt;, that is later used to decryption.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {&#xA;    // The authentication tag is appended to the encrypted message.&#xA;&#x9;let tagLength = 8&#xA;&#x9;let ccm = CCM(iv: iv, tagLength: tagLength, messageLength: ciphertext.count - tagLength, additionalAuthenticatedData: data)&#xA;    let aes = try AES(key: key, blockMode: ccm, padding: .noPadding)&#xA;    return try aes.decrypt(encrypted)&#xA;} catch {&#xA;    // failed&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check documentation or CCM specification for valid parameters for CCM.&lt;/p&gt; &#xA;&lt;h5&gt;AEAD&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let encrypt = try AEADChaCha20Poly1305.encrypt(plaintext, key: key, iv: nonce, authenticationHeader: header)&#xA;let decrypt = try AEADChaCha20Poly1305.decrypt(ciphertext, key: key, iv: nonce, authenticationHeader: header, authenticationTag: tagArr: tag)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;RSA&lt;/h5&gt; &#xA;&lt;p&gt;RSA initialization from parameters&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let input: Array&amp;lt;UInt8&amp;gt; = [0,1,2,3,4,5,6,7,8,9]&#xA;&#xA;let n: Array&amp;lt;UInt8&amp;gt; = // RSA modulus&#xA;let e: Array&amp;lt;UInt8&amp;gt; = // RSA public exponent&#xA;let d: Array&amp;lt;UInt8&amp;gt; = // RSA private exponent&#xA;&#xA;let rsa = RSA(n: n, e: e, d: d)&#xA;&#xA;do {&#xA;    let encrypted = try rsa.encrypt(input)&#xA;    let decrypted = try rsa.decrypt(encrypted)&#xA;} catch {&#xA;    print(error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;RSA key generation&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let rsa = try RSA(keySize: 2048) // This generates a modulus, public exponent and private exponent with the given size&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;RSA Encryption &amp;amp; Decryption Example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Alice Generates a Private Key&#xA;let alicesPrivateKey = try RSA(keySize: 1024)&#xA;    &#xA;// Alice shares her **public** key with Bob&#xA;let alicesPublicKeyData = try alicesPrivateKey.publicKeyExternalRepresentation()&#xA;    &#xA;// Bob receives the raw external representation of Alices public key and imports it&#xA;let bobsImportOfAlicesPublicKey = try RSA(rawRepresentation: alicesPublicKeyData)&#xA;    &#xA;// Bob can now encrypt a message for Alice using her public key&#xA;let message = &#34;Hi Alice! This is Bob!&#34;&#xA;let privateMessage = try bobsImportOfAlicesPublicKey.encrypt(message.bytes)&#xA;    &#xA;// This results in some encrypted output like this&#xA;// URcRwG6LfH63zOQf2w+HIllPri9Rb6hFlXbi/bh03zPl2MIIiSTjbAPqbVFmoF3RmDzFjIarIS7ZpT57a1F+OFOJjx50WYlng7dioKFS/rsuGHYnMn4csjCRF6TAqvRQcRnBueeINRRA8SLaLHX6sZuQkjIE5AoHJwgavmiv8PY=&#xA;      &#xA;// Bob can now send this encrypted message to Alice without worrying about people being able to read the original contents&#xA;    &#xA;// Alice receives the encrypted message and uses her private key to decrypt the data and recover the original message&#xA;let originalDecryptedMessage = try alicesPrivateKey.decrypt(privateMessage)&#xA;    &#xA;print(String(data: Data(originalDecryptedMessage), encoding: .utf8))&#xA;// &#34;Hi Alice! This is Bob!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;RSA Signature &amp;amp; Verification Example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Alice Generates a Private Key&#xA;let alicesPrivateKey = try RSA(keySize: 1024)&#xA;    &#xA;// Alice wants to sign a message that she agrees with&#xA;let messageAliceSupports = &#34;Hi my name is Alice!&#34;&#xA;let alicesSignature = try alicesPrivateKey.sign(messageAliceSupports.bytes)&#xA;    &#xA;// Alice shares her Public key and the signature with Bob&#xA;let alicesPublicKeyData = try alicesPrivateKey.publicKeyExternalRepresentation()&#xA;    &#xA;// Bob receives the raw external representation of Alices Public key and imports it!&#xA;let bobsImportOfAlicesPublicKey = try RSA(rawRepresentation: alicesPublicKeyData)&#xA;        &#xA;// Bob can now verify that Alice signed the message using the Private key associated with her shared Public key.&#xA;let verifiedSignature = try bobsImportOfAlicesPublicKey.verify(signature: alicesSignature, for: &#34;Hi my name is Alice!&#34;.bytes)&#xA;    &#xA;if verifiedSignature == true {&#xA;  // Bob knows that the signature Alice provided is valid for the message and was signed using the Private key associated with Alices shared Public key.&#xA;} else {&#xA;  // The signature was invalid, so either&#xA;  // - the message Alice signed was different then what we expected.&#xA;  // - or Alice used a Private key that isn&#39;t associated with the shared Public key that Bob has.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;CryptoSwift RSA Key -&amp;gt; Apple&#39;s Security Framework SecKey Example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;/// Starting with a CryptoSwift RSA Key&#xA;let rsaKey = try RSA(keySize: 1024)&#xA;&#xA;/// Define your Keys attributes&#xA;let attributes: [String:Any] = [&#xA;  kSecAttrKeyType as String: kSecAttrKeyTypeRSA,&#xA;  kSecAttrKeyClass as String: kSecAttrKeyClassPrivate, // or kSecAttrKeyClassPublic&#xA;  kSecAttrKeySizeInBits as String: 1024, // The appropriate bits&#xA;  kSecAttrIsPermanent as String: false&#xA;]&#xA;var error:Unmanaged&amp;lt;CFError&amp;gt;? = nil&#xA;guard let rsaSecKey = try SecKeyCreateWithData(rsaKey.externalRepresentation() as CFData, attributes as CFDictionary, &amp;amp;error) else {&#xA;  /// Error constructing SecKey from raw key data&#xA;  return&#xA;}&#xA;&#xA;/// You now have an RSA SecKey for use with Apple&#39;s Security framework&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Apple&#39;s Security Framework SecKey -&amp;gt; CryptoSwift RSA Key Example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;/// Starting with a SecKey RSA Key&#xA;let rsaSecKey:SecKey&#xA;&#xA;/// Copy External Representation&#xA;var externalRepError:Unmanaged&amp;lt;CFError&amp;gt;?&#xA;guard let cfdata = SecKeyCopyExternalRepresentation(rsaSecKey, &amp;amp;externalRepError) else {&#xA;  /// Failed to copy external representation for RSA SecKey&#xA;  return&#xA;}&#xA;&#xA;/// Instantiate the RSA Key from the raw external representation&#xA;let rsaKey = try RSA(rawRepresentation: cfdata as Data)&#xA;&#xA;/// You now have a CryptoSwift RSA Key&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;CryptoSwift is owned and maintained by &lt;a href=&#34;https://www.krzyzanowskim.com&#34;&gt;Marcin Krzyżanowski&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can follow me on Twitter at &lt;a href=&#34;https://x.com/krzyzanowskim&#34;&gt;@krzyzanowskim&lt;/a&gt; for project updates and releases.&lt;/p&gt; &#xA;&lt;h1&gt;Cryptography Notice&lt;/h1&gt; &#xA;&lt;p&gt;This distribution includes cryptographic software. The country in which you currently reside may have restrictions on the import, possession, use, and/or re-export to another country, of encryption software. BEFORE using any encryption software, please check your country&#39;s laws, regulations and policies concerning the import, possession, or use, and re-export of encryption software, to see if this is permitted. See &lt;a href=&#34;https://www.wassenaar.org/&#34;&gt;https://www.wassenaar.org/&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (C) 2014-2025 Marcin Krzyżanowski &lt;a href=&#34;mailto:marcin@krzyzanowskim.com&#34;&gt;marcin@krzyzanowskim.com&lt;/a&gt; This software is provided &#39;as-is&#39;, without any express or implied warranty.&lt;/p&gt; &#xA;&lt;p&gt;In no event will the authors be held liable for any damages arising from the use of this software.&lt;/p&gt; &#xA;&lt;p&gt;Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, &lt;strong&gt;an acknowledgment in the product documentation is required&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.&lt;/li&gt; &#xA; &lt;li&gt;This notice may not be removed or altered from any source or binary distribution.&lt;/li&gt; &#xA; &lt;li&gt;Redistributions of any form whatsoever must retain the following acknowledgment: &#39;This product includes software developed by the &#34;Marcin Krzyzanowski&#34; (&lt;a href=&#34;https://krzyzanowskim.com/&#34;&gt;https://krzyzanowskim.com/&lt;/a&gt;).&#39;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/krzyzanowskim/CryptoSwift/main/CHANGELOG&#34;&gt;CHANGELOG&lt;/a&gt; file.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>swiftlang/swift-testing</title>
    <updated>2025-04-01T02:08:41Z</updated>
    <id>tag:github.com,2025-04-01:/swiftlang/swift-testing</id>
    <link href="https://github.com/swiftlang/swift-testing" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A modern, expressive testing package for Swift&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Swift Testing&lt;/h1&gt; &#xA;&lt;!--&#xA;This source file is part of the Swift.org open source project&#xA;&#xA;Copyright (c) 2024 Apple Inc. and the Swift project authors&#xA;Licensed under Apache License v2.0 with Runtime Library Exception&#xA;&#xA;See https://swift.org/LICENSE.txt for license information&#xA;See https://swift.org/CONTRIBUTORS.txt for Swift project authors&#xA;--&gt; &#xA;&lt;p&gt;Swift Testing is a package with expressive and intuitive APIs that make testing your Swift code a breeze.&lt;/p&gt; &#xA;&lt;h2&gt;Feature overview&lt;/h2&gt; &#xA;&lt;h3&gt;Clear, expressive API&lt;/h3&gt; &#xA;&lt;p&gt;Swift Testing has a clear and expressive API built using macros, so you can declare complex behaviors with a small amount of code. The &lt;code&gt;#expect&lt;/code&gt; API uses Swift expressions and operators, and captures the evaluated values so you can quickly understand what went wrong when a test fails.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Test func helloWorld() {&#xA;  let greeting = &#34;Hello, world!&#34;&#xA;  #expect(greeting == &#34;Hello&#34;) // Expectation failed: (greeting → &#34;Hello, world!&#34;) == &#34;Hello&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom test behaviors&lt;/h3&gt; &#xA;&lt;p&gt;You can customize the behavior of tests or test suites using traits specified in your code. Traits can describe the runtime conditions for a test, like which device a test should run on, or limit a test to certain operating system versions. Traits can also help you use continuous integration effectively by specifying execution time limits for your tests.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Test(.enabled(if: AppFeatures.isCommentingEnabled))&#xA;func videoCommenting() async throws {&#xA;    let video = try #require(await videoLibrary.video(named: &#34;A Beach&#34;))&#xA;    #expect(video.comments.contains(&#34;So picturesque!&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Easy and flexible organization&lt;/h3&gt; &#xA;&lt;p&gt;Swift Testing provides many ways to keep your tests organized. Structure related tests using a hierarchy of groups and subgroups. Apply tags to flexibly manage, edit, and run tests with common characteristics across your test suite, like tests that target a specific device or use a specific module. You can also give tests a descriptive name so you know what they’re doing at a glance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Test(&#34;Check video metadata&#34;,&#xA;      .tags(.metadata))&#xA;func videoMetadata() {&#xA;    let video = Video(fileName: &#34;By the Lake.mov&#34;)&#xA;    let expectedMetadata = Metadata(duration: .seconds(90))&#xA;    #expect(video.metadata == expectedMetadata)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Scalable coverage and execution&lt;/h3&gt; &#xA;&lt;p&gt;Parameterized tests help you run the same test over a sequence of values so you can write less code. And all tests integrate seamlessly with Swift Concurrency and run in parallel by default.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@Test(&#34;Continents mentioned in videos&#34;, arguments: [&#xA;    &#34;A Beach&#34;,&#xA;    &#34;By the Lake&#34;,&#xA;    &#34;Camping in the Woods&#34;&#xA;])&#xA;func mentionedContinents(videoName: String) async throws {&#xA;    let videoLibrary = try await VideoLibrary()&#xA;    let video = try #require(await videoLibrary.video(named: videoName))&#xA;    #expect(video.mentionedContinents.count &amp;lt;= 3)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Cross-platform support&lt;/h3&gt; &#xA;&lt;p&gt;Swift Testing works on all major platforms supported by Swift, including Apple platforms, Linux, and Windows, so your tests can behave more consistently when moving between platforms. It’s developed as open source and discussed on the &lt;a href=&#34;https://forums.swift.org/c/development/swift-testing/103&#34;&gt;Swift Forums&lt;/a&gt; so the very best ideas, from anywhere, can help shape the future of testing in Swift.&lt;/p&gt; &#xA;&lt;p&gt;The table below describes the current level of support that Swift Testing has for various platforms:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Platform&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;strong&gt;CI Status (6.0)&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;strong&gt;CI Status (main)&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Support Status&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;macOS&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://ci.swift.org/job/swift-testing-main-swift-6.0-macos/&#34;&gt;&lt;img src=&#34;https://ci.swift.org/buildStatus/icon?job=swift-testing-main-swift-6.0-macos&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://ci.swift.org/view/Swift%20Packages/job/swift-testing-main-swift-main-macos/&#34;&gt;&lt;img src=&#34;https://ci.swift.org/buildStatus/icon?job=swift-testing-main-swift-main-macos&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Supported&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;iOS&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Supported&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;watchOS&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Supported&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;tvOS&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Supported&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;visionOS&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Supported&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Ubuntu 22.04&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://ci.swift.org/job/swift-testing-main-swift-6.0-linux/&#34;&gt;&lt;img src=&#34;https://ci.swift.org/buildStatus/icon?job=swift-testing-main-swift-6.0-linux&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://ci.swift.org/view/Swift%20Packages/job/swift-testing-main-swift-main-linux/&#34;&gt;&lt;img src=&#34;https://ci.swift.org/buildStatus/icon?job=swift-testing-main-swift-main-linux&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Supported&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://ci-external.swift.org/job/swift-testing-main-swift-main-windows/&#34;&gt;&lt;img src=&#34;https://ci-external.swift.org/buildStatus/icon?job=swift-testing-main-swift-main-windows&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Supported&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Wasm&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Experimental&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Works with XCTest&lt;/h3&gt; &#xA;&lt;p&gt;If you already have tests written using XCTest, you can run them side-by-side with newer tests written using Swift Testing. This helps you migrate tests incrementally, at your own pace.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Detailed documentation for Swift Testing can be found on the &lt;a href=&#34;https://swiftpackageindex.com/swiftlang/swift-testing/main/documentation/testing&#34;&gt;Swift Package Index&lt;/a&gt;. There, you can delve into comprehensive guides, tutorials, and API references to make the most out of this package. Swift Testing is included with the Swift 6 toolchain and Xcode 16. You do not need to add it as a package dependency to your Swift package or Xcode project.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] Swift Testing depends on upcoming language and compiler features. If you are building Swift Testing from source, be aware that the main branch of this repository requires a recent &lt;strong&gt;main-branch development snapshot&lt;/strong&gt; toolchain.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Other documentation resources for this project can be found in the &lt;a href=&#34;https://github.com/swiftlang/swift-testing/raw/main/Documentation/README.md&#34;&gt;README&lt;/a&gt; of the &lt;code&gt;Documentation/&lt;/code&gt; subdirectory.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>hmlongco/Factory</title>
    <updated>2025-04-01T02:08:41Z</updated>
    <id>tag:github.com,2025-04-01:/hmlongco/Factory</id>
    <link href="https://github.com/hmlongco/Factory" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A new approach to Container-Based Dependency Injection for Swift and SwiftUI.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://swiftpackageindex.com/hmlongco/Factory&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fhmlongco%2FFactory%2Fbadge%3Ftype%3Dswift-versions&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/hmlongco/Factory&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fhmlongco%2FFactory%2Fbadge%3Ftype%3Dplatforms&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/hmlongco/Factory/raw/main/Logo.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A new approach to Container-Based Dependency Injection for Swift and SwiftUI.&lt;/p&gt; &#xA;&lt;h2&gt;Factory 2.4.4&lt;/h2&gt; &#xA;&lt;p&gt;Factory is strongly influenced by SwiftUI, and in my opinion is highly suited for use in that environment. Factory is...&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Adaptable&lt;/strong&gt;: Factory doesn&#39;t tie you down to a single dependency injection strategy or technique.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Powerful&lt;/strong&gt;: Factory supports containers, scopes, passed parameters, contexts, decorators, unit tests, SwiftUI Previews, and much, much more.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Performant&lt;/strong&gt;: Little to no setup time is needed for the vast majority of your services, resolutions are extremely fast, and no compile-time scripts or build phases are needed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Safe&lt;/strong&gt;: Factory is compile-time safe; a factory for a given type must exist or the code simply will not compile.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Concise&lt;/strong&gt;: Defining a registration usually takes just a single line of code. Same for resolution.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Flexible&lt;/strong&gt;: Working with UIKIt or SwiftUI? iOS or macOS? Using MVVM? MVP? Clean? VIPER? No problem. Factory works with all of these and more.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Documented&lt;/strong&gt;: Factory has extensive DocC documentation and examples covering its classes, methods, and use cases.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Lightweight&lt;/strong&gt;: With all of that Factory is slim and trim, under 1,000 lines of executable code.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Tested&lt;/strong&gt;: Unit tests with 100% code coverage helps ensure correct operation of registrations, resolutions, and scopes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Free&lt;/strong&gt;: Factory is free and open source under the MIT License.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Sound too good to be true? Let&#39;s take a look.&lt;/p&gt; &#xA;&lt;h2&gt;A Simple Example&lt;/h2&gt; &#xA;&lt;p&gt;Most container-based dependency injection systems require you to define in some way that a given service type is available for injection and many require some sort of factory or mechanism that will provide a new instance of the service when needed.&lt;/p&gt; &#xA;&lt;p&gt;Factory is no exception. Here&#39;s a simple dependency registration that returns a service that conforms to &lt;code&gt;MyServiceType&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    var myService: Factory&amp;lt;MyServiceType&amp;gt; { &#xA;        Factory(self) { MyService() }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unlike Resolver which often requires defining a plethora of nested registration functions, or SwiftUI, where defining a new environment variable requires creating a new EnvironmentKey and adding additional getters and setters, here we simply add a new &lt;code&gt;Factory&lt;/code&gt; computed variable to the default container. When it&#39;s called our Factory is created, its closure is evaluated, and we get an instance of our dependency when we need it.&lt;/p&gt; &#xA;&lt;p&gt;Injecting an instance of our service is equally straightforward. Here&#39;s just one of the many ways Factory can be used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Pre iOS 17 with ObservableObject&#xA;class ContentViewModel: ObservableObject {&#xA;    @Injected(\.myService) private var myService&#xA;    ...&#xA;}&#xA;&#xA;// Post iOS 17 with Observation&#xA;@Observable class ContentViewModel {&#xA;    @ObservationIgnored&#xA;    @Injected(\.myService) private var myService&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This particular view model uses one of Factory&#39;s &lt;code&gt;@Injected&lt;/code&gt; property wrappers to request the desired dependency. Similar to &lt;code&gt;@Environment&lt;/code&gt; in SwiftUI, we provide the property wrapper with a keyPath to a factory of the desired type and it resolves that type the moment &lt;code&gt;ContentViewModel&lt;/code&gt; is created.&lt;/p&gt; &#xA;&lt;p&gt;And that&#39;s the core mechanism. In order to use the property wrapper you &lt;em&gt;must&lt;/em&gt; define a factory within the specified container. That factory &lt;em&gt;must&lt;/em&gt; return the desired type when asked. Fail to do either one and the code will simply not compile. As such, Factory is compile-time safe.&lt;/p&gt; &#xA;&lt;p&gt;By the way, if you&#39;re concerned about building Factory&#39;s on the fly, don&#39;t be. Like SwiftUI Views, Factory structs and modifiers are lightweight and transitory value types. They&#39;re created inside computed variables &lt;strong&gt;only&lt;/strong&gt; when they&#39;re needed and then immediately discarded once their purpose has been served.&lt;/p&gt; &#xA;&lt;p&gt;For more examples of Factory definitions that define scopes, use constructor injection, and do parameter passing, see the &lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory/registrations&#34;&gt;Registrations&lt;/a&gt; page.&lt;/p&gt; &#xA;&lt;h2&gt;Resolving Factories&lt;/h2&gt; &#xA;&lt;p&gt;Earlier we demonstrated how to use the &lt;code&gt;Injected&lt;/code&gt; property wrapper. But it&#39;s also possible to bypass the property wrapper and talk to the factory yourself.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ContentViewModel: ObservableObject {&#xA;    private let myService = Container.shared.myService()&#xA;    private let eventLogger = Container.shared.eventLogger()&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Just call the desired factory as a function and you&#39;ll get an instance of its managed dependency. It&#39;s that simple.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re into container-based dependency injection, note that you can also pass an instance of a container to a view model and obtain an instance of your service directly from that container.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ContentViewModel: ObservableObject {&#xA;    let service: MyServiceType&#xA;    init(container: Container) {&#xA;        service = container.service()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or if you want to use a Composition Root structure, just use the container to provide the required dependencies to a constructor.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    var myRepository: Factory&amp;lt;MyRepositoryType&amp;gt; {&#xA;        Factory(self) { MyRepository(service: self.networkService()) }&#xA;    }&#xA;    var networkService: Factory&amp;lt;Networking&amp;gt; {&#xA;        Factory(self) { MyNetworkService() }&#xA;    }&#xA;}&#xA;&#xA;@main&#xA;struct FactoryDemoApp: App {&#xA;    let viewModel = MyViewModel(repository: Container.shared.myRepository())&#xA;    var body: some Scene {&#xA;        WindowGroup {&#xA;            NavigationView {&#xA;                ContentView(viewModel: viewModel)&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Factory is flexible, and it doesn&#39;t tie you down to a specific dependency injection pattern or technique.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory/resolutions&#34;&gt;Resolutions&lt;/a&gt; for more examples.&lt;/p&gt; &#xA;&lt;h2&gt;Mocking&lt;/h2&gt; &#xA;&lt;p&gt;If we go back and look at our original view model code one might wonder why we&#39;ve gone to all of this trouble? Why not simply say &lt;code&gt;let myService = MyService()&lt;/code&gt; and be done with it?&lt;/p&gt; &#xA;&lt;p&gt;Or keep the container idea, but write something similar to this…&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    static var myService: MyServiceType { MyService() }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Well, the primary benefit one gains from using a container-based dependency injection system is that we&#39;re able to change the behavior of the system as needed. Consider the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @StateObject var model = ContentViewModel()&#xA;    var body: some View {&#xA;        Text(model.text())&#xA;            .padding()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Our ContentView uses our view model, which is assigned to a StateObject. Great. But now we want to preview our code. How do we change the behavior of &lt;code&gt;ContentViewModel&lt;/code&gt; so that its &lt;code&gt;MyService&lt;/code&gt; dependency isn&#39;t making live API calls during development?&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s easy. Just replace &lt;code&gt;MyService&lt;/code&gt; with a mock that also conforms to &lt;code&gt;MyServiceType&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView_Previews: PreviewProvider {&#xA;    static var previews: some View {&#xA;        let _ = Container.shared.myService.register { MockService2() }&#xA;        ContentView()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note the line in our preview code where we’re gone back to our container and registered a new closure on our factory. This function overrides the default factory closure.&lt;/p&gt; &#xA;&lt;p&gt;Now when our preview is displayed &lt;code&gt;ContentView&lt;/code&gt; creates a &lt;code&gt;ContentViewModel&lt;/code&gt; which in turn has a dependency on &lt;code&gt;myService&lt;/code&gt; using the &lt;code&gt;Injected&lt;/code&gt; property wrapper. And when the wrapper asks the factory for an instance of &lt;code&gt;MyServiceType&lt;/code&gt; it now gets a &lt;code&gt;MockService2&lt;/code&gt; instead of the &lt;code&gt;MyService&lt;/code&gt; type originally defined.&lt;/p&gt; &#xA;&lt;p&gt;This is a powerful concept that lets us reach deep into a chain of dependencies and alter the behavior of a system as needed.&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;The same concept can be used when writing unit tests. Consider the following.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;final class FactoryCoreTests: XCTestCase {&#xA;&#xA;    override func setUp() {&#xA;        super.setUp()&#xA;        Container.shared.reset()&#xA;    }&#xA;    &#xA;    func testLoaded() throws {&#xA;        Container.shared.accountProvider.register { MockProvider(accounts: .sampleAccounts) }&#xA;        let model = Container.shared.someViewModel()&#xA;        model.load()&#xA;        XCTAssertTrue(model.isLoaded)&#xA;    }&#xA;&#xA;    func testEmpty() throws {&#xA;        Container.shared.accountProvider.register { MockProvider(accounts: []) }&#xA;        let model = Container.shared.someViewModel()&#xA;        model.load()&#xA;        XCTAssertTrue(model.isEmpty)&#xA;    }&#xA;&#xA;    func testErrors() throws {&#xA;        Container.shared.accountProvider.register { MockProvider(error: .notFoundError) }&#xA;        let model = Container.shared.someViewModel()&#xA;        model.load()&#xA;        XCTAssertTrue(model.errorMessage = &#34;Some Error&#34;)&#xA;    }&#xA;    &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Again, Factory makes it easy to reach into a chain of dependencies and make specific changes to the system as needed. This makes testing loading states, empty states, and error conditions simple.&lt;/p&gt; &#xA;&lt;p&gt;Factory also works with Xcode 16&#39;s new Swift Testing framework.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Testing&#xA;&#xA;@Suite(.serialized) struct AppTests {&#xA;  @Test(arguments: Parameters.allCases) func testA(parameter: Parameters) {&#xA;    // This function will be invoked serially, once per parameter, because the&#xA;    // containing suite has the .serialized trait.&#xA;    Container.shared.someService.register { MockService(parameter: parameter) }&#xA;    let service = Container.shared.someService()&#xA;    #expect(service.parameter == parameter)&#xA;  }&#xA;&#xA;&#xA;  @Test func testB() async throws {&#xA;    // This function will not run while testA(parameter:) is running. One test&#xA;    // must end before the other will start.&#xA;    Container.shared.someService.register { ErrorService() }&#xA;    let service = Container.shared.someService()&#xA;    #expect(service.error == &#34;Oops&#34;)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But we&#39;re not done yet.&lt;/p&gt; &#xA;&lt;p&gt;Factory has quite a few more tricks up its sleeve...&lt;/p&gt; &#xA;&lt;h2&gt;Scope&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;ve used Resolver or some other dependency injection system before then you&#39;ve probably experienced the benefits and power of scopes.&lt;/p&gt; &#xA;&lt;p&gt;And if not, the concept is easy to understand: Just how long should an instance of an object live?&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ve no doubt stuffed an instance of a class into a variable and created a singleton at some point in your career. This is an example of a scope. A single instance is created and then used and shared by all of the methods and functions in the app.&lt;/p&gt; &#xA;&lt;p&gt;This can be done in Factory just by adding a scope modifier.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    var networkService: Factory&amp;lt;NetworkProviding&amp;gt; { &#xA;        self { NetworkProvider() }&#xA;            .singleton&#xA;    }&#xA;    var myService: Factory&amp;lt;MyServiceType&amp;gt; { &#xA;        self { MyService() }&#xA;            .scope(.session)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now whenever someone requests an instance of &lt;code&gt;networkService&lt;/code&gt; they&#39;ll get the same instance of the object as everyone else.&lt;/p&gt; &#xA;&lt;p&gt;Note that the client neither knows nor cares about the scope. Nor should it. The client is simply given what it needs when it needs it.&lt;/p&gt; &#xA;&lt;p&gt;If no scope is specified the default scope is unique. A new instance of the service will be instantiated and returned every time one is requested from the factory.&lt;/p&gt; &#xA;&lt;p&gt;Other common scopes are &lt;code&gt;cached&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt;. Cached items are persisted until the cache is reset, while shared items exist just as long as someone holds a strong reference to them. When the last reference goes away, the weakly held shared reference also goes away.&lt;/p&gt; &#xA;&lt;p&gt;Factory has other scope types, plus the ability to add more of your own. See &lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory/scopes&#34;&gt;Scopes&lt;/a&gt; for additional examples.&lt;/p&gt; &#xA;&lt;p&gt;Scopes and scope management are powerful tools to have in your dependency injection arsenal.&lt;/p&gt; &#xA;&lt;h2&gt;Simplified Syntax&lt;/h2&gt; &#xA;&lt;p&gt;You may have noticed in the previous example that Factory also provides a bit of syntactical sugar that lets us make our definitions more concise. We simply ask the enclosing container to make a properly bound Factory for us using &lt;code&gt;self.callAsFunction { ... }&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Container {&#xA;    var sugared: Factory&amp;lt;MyServiceType&amp;gt; { &#xA;        self { MyService() }&#xA;    }&#xA;    var formal: Factory&amp;lt;MyServiceType&amp;gt; { &#xA;        Factory(self) { MyService() }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both definitions provide the same exact result. The sugared function is even inlined, so there&#39;s not even a performance difference between the two versions.&lt;/p&gt; &#xA;&lt;h2&gt;Contexts&lt;/h2&gt; &#xA;&lt;p&gt;One powerful new feature in Factory 2.1 is contexts. Let&#39;s say that for logistical reasons whenever your application runs in debug mode you &lt;em&gt;never&lt;/em&gt; want it to make calls to your application&#39;s analytics engine.&lt;/p&gt; &#xA;&lt;p&gt;Easy. Just register an override for that particular context.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;container.analytics.onDebug { &#xA;    StubAnalyticsEngine()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are other contexts for unit testing, for SwiftUI previews, and even when running UITests both in the simulator or when running an app on services like BrowserStack. See the documentation for more.&lt;/p&gt; &#xA;&lt;h2&gt;Debugging&lt;/h2&gt; &#xA;&lt;p&gt;Factory can also help you debug your code. When running in DEBUG mode Factory allows you to trace the injection process and see every object instantiated or returned from a cache during a given resolution cycle.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;0: Factory.Container.cycleDemo&amp;lt;CycleDemo&amp;gt; = N:105553131389696&#xA;1:     Factory.Container.aService&amp;lt;AServiceType&amp;gt; = N:105553119821680&#xA;2:         Factory.Container.implementsAB&amp;lt;AServiceType &amp;amp; BServiceType&amp;gt; = N:105553119821680&#xA;3:             Factory.Container.networkService&amp;lt;NetworkService&amp;gt; = N:105553119770688&#xA;1:     Factory.Container.bService&amp;lt;BServiceType&amp;gt; = N:105553119821680&#xA;2:         Factory.Container.implementsAB&amp;lt;AServiceType &amp;amp; BServiceType&amp;gt; = C:105553119821680&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can make it a lot easier to see the entire dependency tree for a given object or service.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory/debugging&#34;&gt;Debugging&lt;/a&gt; for more on this and other features.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;A single README file barely scratches the surface. Fortunately, Factory is throughly documented.&lt;/p&gt; &#xA;&lt;p&gt;Current DocC documentation can be found in the project as well as online on &lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory&#34;&gt;GitHub Pages&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Factory supports CocoaPods and the Swift Package Manager.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pod &#34;Factory&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or download the source files and add the Factory folder to your project.&lt;/p&gt; &#xA;&lt;p&gt;Note that the current version of Factory (2.4.3) require Swift 5.10 minimum and that the minimum version of iOS currently supported with this release is iOS 13.&lt;/p&gt; &#xA;&lt;h2&gt;Factory 2.0 Migration&lt;/h2&gt; &#xA;&lt;p&gt;If you started with Factory 1.x a &lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory/migration&#34;&gt;migration document is available here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Factory 2.0 adds true Factory containers for container-based dependency resolution&lt;/li&gt; &#xA; &lt;li&gt;Factory 2.0 adds container-based scopes&lt;/li&gt; &#xA; &lt;li&gt;Factory 2.0 adds decorators to containers and factories&lt;/li&gt; &#xA; &lt;li&gt;Factory 2.0 adds debug trace support&lt;/li&gt; &#xA; &lt;li&gt;Factory 2.0 adds keyPath-based property wrappers&lt;/li&gt; &#xA; &lt;li&gt;Factory 2.0 adds a new InjectedObject property wrapper for SwiftUI Views&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Factory 2.4 Migration&lt;/h2&gt; &#xA;&lt;p&gt;Factory 2.4 works with Xcode 16 under Strict Concurrency guidelines.&lt;/p&gt; &#xA;&lt;h2&gt;Discussion Forum&lt;/h2&gt; &#xA;&lt;p&gt;Discussion and comments on Factory and Factory 2.0 can be found in &lt;a href=&#34;https://github.com/hmlongco/Factory/discussions&#34;&gt;Discussions&lt;/a&gt;. Go there if you have something to say or if you want to stay up to date.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Factory is available under the MIT license. See the LICENSE file for more info.&lt;/p&gt; &#xA;&lt;h2&gt;Sponsor Factory!&lt;/h2&gt; &#xA;&lt;p&gt;If you want to support my work on Factory and Resolver, consider a &lt;a href=&#34;https://github.com/sponsors/hmlongco&#34;&gt;GitHub Sponsorship&lt;/a&gt;! Many levels exist for increased support and even for mentorship and company training.&lt;/p&gt; &#xA;&lt;p&gt;Or you can just buy me a cup of coffee!&lt;/p&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;Factory is designed, implemented, documented, and maintained by &lt;a href=&#34;https://www.linkedin.com/in/hmlong/&#34;&gt;Michael Long&lt;/a&gt;, a Lead iOS Software Engineer and a Top 1,000 Technology Writer on Medium.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;LinkedIn: &lt;a href=&#34;https://www.linkedin.com/in/hmlong/&#34;&gt;@hmlong&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Medium: &lt;a href=&#34;https://medium.com/@michaellong&#34;&gt;@michaellong&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;BlueSky: &lt;a href=&#34;https://bsky.app/profile/hmlongco.bsky.social&#34;&gt;@hmlongco&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Michael was also one of Google&#39;s &lt;a href=&#34;https://opensource.googleblog.com/2021/09/announcing-latest-open-source-peer-bonus-winners.html&#34;&gt;Open Source Peer Reward&lt;/a&gt; winners in 2021 for his work on Resolver.&lt;/p&gt; &#xA;&lt;h2&gt;Additional Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hmlongco.github.io/Factory/documentation/factory&#34;&gt;Factory Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://betterprogramming.pub/factory-and-functional-dependency-injection-2d0a38042d05&#34;&gt;Factory 1.0 and Functional Dependency Injection&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://betterprogramming.pub/factory-multiple-module-registration-f9d19721a31d?sk=a03d78484d8c351762306ff00a8be67c&#34;&gt;Factory 1.0: Multiple Module Registration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hmlongco/Resolver&#34;&gt;Resolver: A Swift Dependency Injection System&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Inversion_of_control&#34;&gt;Inversion of Control Design Pattern ~ Wikipedia&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://martinfowler.com/articles/injection.html&#34;&gt;Inversion of Control Containers and the Dependency Injection pattern ~ Martin Fowler&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cocoacasts.com/nuts-and-bolts-of-dependency-injection-in-swift/&#34;&gt;Nuts and Bolts of Dependency Injection in Swift&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cocoacasts.com/dependency-injection-in-swift&#34;&gt;Dependency Injection in Swift&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://medium.com/better-programming/taking-swift-dependency-injection-to-the-next-level-b71114c6a9c6&#34;&gt;Swift 5.1 Takes Dependency Injection to the Next Level&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hmlongco/Builder&#34;&gt;Builder: A Declarative UIKit Library (Uses Factory in Demo)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>