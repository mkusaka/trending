<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Swift Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-12-01T01:58:36Z</updated>
  <subtitle>Monthly Trending of Swift in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SwiftyJSON/SwiftyJSON</title>
    <updated>2024-12-01T01:58:36Z</updated>
    <id>tag:github.com,2024-12-01:/SwiftyJSON/SwiftyJSON</id>
    <link href="https://github.com/SwiftyJSON/SwiftyJSON" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The better way to deal with JSON data in Swift.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SwiftyJSON&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat&#34; alt=&#34;Carthage compatible&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/cocoapods/v/SwiftyJSON.svg?sanitize=true&#34; alt=&#34;CocoaPods&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/platforms-iOS%208.0%20%7C%20macOS%2010.10%20%7C%20tvOS%209.0%20%7C%20watchOS%203.0-F28D00.svg?sanitize=true&#34; alt=&#34;Platform&#34;&gt; &lt;a href=&#34;https://houndci.com&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Reviewed_by-Hound-8E64B0.svg?sanitize=true&#34; alt=&#34;Reviewed by Hound&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;SwiftyJSON makes it easy to deal with JSON data in Swift.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Platform&lt;/th&gt; &#xA;   &lt;th&gt;Build Status&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;*OS&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://travis-ci.org/SwiftyJSON/SwiftyJSON&#34;&gt;&lt;img src=&#34;https://travis-ci.org/SwiftyJSON/SwiftyJSON.svg?branch=master&#34; alt=&#34;Travis CI&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/IBM-Swift/SwiftyJSON&#34;&gt;Linux&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://travis-ci.org/IBM-Swift/SwiftyJSON&#34;&gt;&lt;img src=&#34;https://travis-ci.org/IBM-Swift/SwiftyJSON.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#why-is-the-typical-json-handling-in-swift-not-good&#34;&gt;Why is the typical JSON handling in Swift NOT good&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#requirements&#34;&gt;Requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#integration&#34;&gt;Integration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#initialization&#34;&gt;Initialization&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#subscript&#34;&gt;Subscript&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#loop&#34;&gt;Loop&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#error&#34;&gt;Error&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#optional-getter&#34;&gt;Optional getter&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#non-optional-getter&#34;&gt;Non-optional getter&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#setter&#34;&gt;Setter&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#raw-object&#34;&gt;Raw object&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#literal-convertibles&#34;&gt;Literal convertibles&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#merging&#34;&gt;Merging&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#removing-elements&#34;&gt;Removing elements&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#work-with-alamofire&#34;&gt;Work with Alamofire&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#work-with-moya&#34;&gt;Work with Moya&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SwiftyJSON/SwiftyJSON/master/#swiftyjson-model-generator&#34;&gt;SwiftyJSON Model Generator&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Why is the typical JSON handling in Swift NOT good?&lt;/h2&gt; &#xA;&lt;p&gt;Swift is very strict about types. But although explicit typing is good for saving us from mistakes, it becomes painful when dealing with JSON and other areas that are, by nature, implicit about types.&lt;/p&gt; &#xA;&lt;p&gt;Take the Twitter API for example. Say we want to retrieve a user&#39;s &#34;name&#34; value of some tweet in Swift (according to &lt;a href=&#34;https://developer.twitter.com/en/docs/tweets/timelines/api-reference/get-statuses-home_timeline&#34;&gt;Twitter&#39;s API&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The code would look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if let statusesArray = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [[String: Any]],&#xA;    let user = statusesArray[0][&#34;user&#34;] as? [String: Any],&#xA;    let username = user[&#34;name&#34;] as? String {&#xA;    // Finally we got the username&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s not good.&lt;/p&gt; &#xA;&lt;p&gt;Even if we use optional chaining, it would be messy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if let JSONObject = try JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [[String: Any]],&#xA;    let username = (JSONObject[0][&#34;user&#34;] as? [String: Any])?[&#34;name&#34;] as? String {&#xA;        // There&#39;s our username&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An unreadable mess--for something that should really be simple!&lt;/p&gt; &#xA;&lt;p&gt;With SwiftyJSON all you have to do is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let json = try? JSON(data: dataFromNetworking)&#xA;if let userName = json[0][&#34;user&#34;][&#34;name&#34;].string {&#xA;  //Now you got your value&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And don&#39;t worry about the Optional Wrapping thing. It&#39;s done for you automatically.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let json = try? JSON(data: dataFromNetworking)&#xA;let result = json[999999][&#34;wrong_key&#34;][&#34;wrong_name&#34;]&#xA;if let userName = result.string {&#xA;    //Calm down, take it easy, the &#34;.string&#34; property still produces the correct Optional String type with safety&#xA;} else {&#xA;    //Print the error&#xA;    print(result.error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;iOS 8.0+ | macOS 10.10+ | tvOS 9.0+ | watchOS 2.0+&lt;/li&gt; &#xA; &lt;li&gt;Xcode 8&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Integration&lt;/h2&gt; &#xA;&lt;h4&gt;CocoaPods (iOS 8+, OS X 10.9+)&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;http://cocoapods.org/&#34;&gt;CocoaPods&lt;/a&gt; to install &lt;code&gt;SwiftyJSON&lt;/code&gt; by adding it to your &lt;code&gt;Podfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;platform :ios, &#39;8.0&#39;&#xA;use_frameworks!&#xA;&#xA;target &#39;MyApp&#39; do&#xA;    pod &#39;SwiftyJSON&#39;, &#39;~&amp;gt; 4.0&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Carthage (iOS 8+, OS X 10.9+)&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt; to install &lt;code&gt;SwiftyJSON&lt;/code&gt; by adding it to your &lt;code&gt;Cartfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;github &#34;SwiftyJSON/SwiftyJSON&#34; ~&amp;gt; 4.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you use Carthage to build your dependencies, make sure you have added &lt;code&gt;SwiftyJSON.framework&lt;/code&gt; to the &#34;Linked Frameworks and Libraries&#34; section of your target, and have included them in your Carthage framework copying build phase.&lt;/p&gt; &#xA;&lt;h4&gt;Swift Package Manager&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;https://swift.org/package-manager&#34;&gt;The Swift Package Manager&lt;/a&gt; to install &lt;code&gt;SwiftyJSON&lt;/code&gt; by adding the proper description to your &lt;code&gt;Package.swift&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// swift-tools-version:4.0&#xA;import PackageDescription&#xA;&#xA;let package = Package(&#xA;    name: &#34;YOUR_PROJECT_NAME&#34;,&#xA;    dependencies: [&#xA;        .package(url: &#34;https://github.com/SwiftyJSON/SwiftyJSON.git&#34;, from: &#34;4.0.0&#34;),&#xA;    ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run &lt;code&gt;swift build&lt;/code&gt; whenever you get prepared.&lt;/p&gt; &#xA;&lt;h4&gt;Manually (iOS 7+, OS X 10.9+)&lt;/h4&gt; &#xA;&lt;p&gt;To use this library in your project manually you may:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;for Projects, just drag SwiftyJSON.swift to the project tree&lt;/li&gt; &#xA; &lt;li&gt;for Workspaces, include the whole SwiftyJSON.xcodeproj&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h4&gt;Initialization&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import SwiftyJSON&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let json = try? JSON(data: dataFromNetworking)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let json = JSON(jsonObject)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if let dataFromString = jsonString.data(using: .utf8, allowLossyConversion: false) {&#xA;    let json = JSON(data: dataFromString)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Subscript&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Getting a double from a JSON Array&#xA;let name = json[0].double&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Getting an array of string from a JSON Array&#xA;let arrayNames =  json[&#34;users&#34;].arrayValue.map {$0[&#34;name&#34;].stringValue}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Getting a string from a JSON Dictionary&#xA;let name = json[&#34;name&#34;].stringValue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Getting a string using a path to the element&#xA;let path: [JSONSubscriptType] = [1,&#34;list&#34;,2,&#34;name&#34;]&#xA;let name = json[path].string&#xA;// Just the same&#xA;let name = json[1][&#34;list&#34;][2][&#34;name&#34;].string&#xA;// Alternatively&#xA;let name = json[1,&#34;list&#34;,2,&#34;name&#34;].string&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// With a hard way&#xA;let name = json[].string&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// With a custom way&#xA;let keys:[JSONSubscriptType] = [1,&#34;list&#34;,2,&#34;name&#34;]&#xA;let name = json[keys].string&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Loop&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// If json is .Dictionary&#xA;for (key,subJson):(String, JSON) in json {&#xA;   // Do something you want&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;The first element is always a String, even if the JSON is an Array&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// If json is .Array&#xA;// The `index` is 0..&amp;lt;json.count&#39;s string value&#xA;for (index,subJson):(String, JSON) in json {&#xA;    // Do something you want&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Error&lt;/h4&gt; &#xA;&lt;h5&gt;SwiftyJSON 4.x&lt;/h5&gt; &#xA;&lt;p&gt;SwiftyJSON 4.x introduces an enum type called &lt;code&gt;SwiftyJSONError&lt;/code&gt;, which includes &lt;code&gt;unsupportedType&lt;/code&gt;, &lt;code&gt;indexOutOfBounds&lt;/code&gt;, &lt;code&gt;elementTooDeep&lt;/code&gt;, &lt;code&gt;wrongType&lt;/code&gt;, &lt;code&gt;notExist&lt;/code&gt; and &lt;code&gt;invalidJSON&lt;/code&gt;, at the same time, &lt;code&gt;ErrorDomain&lt;/code&gt; are being replaced by &lt;code&gt;SwiftyJSONError.errorDomain&lt;/code&gt;. Note: Those old error types are deprecated in SwiftyJSON 4.x and will be removed in the future release.&lt;/p&gt; &#xA;&lt;h5&gt;SwiftyJSON 3.x&lt;/h5&gt; &#xA;&lt;p&gt;Use a subscript to get/set a value in an Array or Dictionary&lt;/p&gt; &#xA;&lt;p&gt;If the JSON is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;an array, the app may crash with &#34;index out-of-bounds.&#34;&lt;/li&gt; &#xA; &lt;li&gt;a dictionary, it will be assigned to &lt;code&gt;nil&lt;/code&gt; without a reason.&lt;/li&gt; &#xA; &lt;li&gt;not an array or a dictionary, the app may crash with an &#34;unrecognised selector&#34; exception.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This will never happen in SwiftyJSON.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let json = JSON([&#34;name&#34;, &#34;age&#34;])&#xA;if let name = json[999].string {&#xA;    // Do something you want&#xA;} else {&#xA;    print(json[999].error!) // &#34;Array[999] is out of bounds&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let json = JSON([&#34;name&#34;:&#34;Jack&#34;, &#34;age&#34;: 25])&#xA;if let name = json[&#34;address&#34;].string {&#xA;    // Do something you want&#xA;} else {&#xA;    print(json[&#34;address&#34;].error!) // &#34;Dictionary[&#34;address&#34;] does not exist&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let json = JSON(12345)&#xA;if let age = json[0].string {&#xA;    // Do something you want&#xA;} else {&#xA;    print(json[0])       // &#34;Array[0] failure, It is not an array&#34;&#xA;    print(json[0].error!) // &#34;Array[0] failure, It is not an array&#34;&#xA;}&#xA;&#xA;if let name = json[&#34;name&#34;].string {&#xA;    // Do something you want&#xA;} else {&#xA;    print(json[&#34;name&#34;])       // &#34;Dictionary[\&#34;name&#34;] failure, It is not an dictionary&#34;&#xA;    print(json[&#34;name&#34;].error!) // &#34;Dictionary[\&#34;name&#34;] failure, It is not an dictionary&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Optional getter&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// NSNumber&#xA;if let id = json[&#34;user&#34;][&#34;favourites_count&#34;].number {&#xA;   // Do something you want&#xA;} else {&#xA;   // Print the error&#xA;   print(json[&#34;user&#34;][&#34;favourites_count&#34;].error!)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// String&#xA;if let id = json[&#34;user&#34;][&#34;name&#34;].string {&#xA;   // Do something you want&#xA;} else {&#xA;   // Print the error&#xA;   print(json[&#34;user&#34;][&#34;name&#34;].error!)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Bool&#xA;if let id = json[&#34;user&#34;][&#34;is_translator&#34;].bool {&#xA;   // Do something you want&#xA;} else {&#xA;   // Print the error&#xA;   print(json[&#34;user&#34;][&#34;is_translator&#34;].error!)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Int&#xA;if let id = json[&#34;user&#34;][&#34;id&#34;].int {&#xA;   // Do something you want&#xA;} else {&#xA;   // Print the error&#xA;   print(json[&#34;user&#34;][&#34;id&#34;].error!)&#xA;}&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Non-optional getter&lt;/h4&gt; &#xA;&lt;p&gt;Non-optional getter is named &lt;code&gt;xxxValue&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// If not a Number or nil, return 0&#xA;let id: Int = json[&#34;id&#34;].intValue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// If not a String or nil, return &#34;&#34;&#xA;let name: String = json[&#34;name&#34;].stringValue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// If not an Array or nil, return []&#xA;let list: Array&amp;lt;JSON&amp;gt; = json[&#34;list&#34;].arrayValue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// If not a Dictionary or nil, return [:]&#xA;let user: Dictionary&amp;lt;String, JSON&amp;gt; = json[&#34;user&#34;].dictionaryValue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Setter&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;json[&#34;name&#34;] = JSON(&#34;new-name&#34;)&#xA;json[0] = JSON(1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;json[&#34;id&#34;].int =  1234567890&#xA;json[&#34;coordinate&#34;].double =  8766.766&#xA;json[&#34;name&#34;].string =  &#34;Jack&#34;&#xA;json.arrayObject = [1,2,3,4]&#xA;json.dictionaryObject = [&#34;name&#34;:&#34;Jack&#34;, &#34;age&#34;:25]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Raw object&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let rawObject: Any = json.object&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let rawValue: Any = json.rawValue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;//convert the JSON to raw NSData&#xA;do {&#xA;&#x9;let rawData = try json.rawData()&#xA;  //Do something you want&#xA;} catch {&#xA;&#x9;print(&#34;Error \(error)&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;//convert the JSON to a raw String&#xA;if let rawString = json.rawString() {&#xA;  //Do something you want&#xA;} else {&#xA;&#x9;print(&#34;json.rawString is nil&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Existence&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// shows you whether value specified in JSON or not&#xA;if json[&#34;name&#34;].exists()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Literal convertibles&lt;/h4&gt; &#xA;&lt;p&gt;For more info about literal convertibles: &lt;a href=&#34;http://nshipster.com/swift-literal-convertible/&#34;&gt;Swift Literal Convertibles&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// StringLiteralConvertible&#xA;let json: JSON = &#34;I&#39;m a json&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// IntegerLiteralConvertible&#xA;let json: JSON =  12345&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// BooleanLiteralConvertible&#xA;let json: JSON =  true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// FloatLiteralConvertible&#xA;let json: JSON =  2.8765&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// DictionaryLiteralConvertible&#xA;let json: JSON =  [&#34;I&#34;:&#34;am&#34;, &#34;a&#34;:&#34;json&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// ArrayLiteralConvertible&#xA;let json: JSON =  [&#34;I&#34;, &#34;am&#34;, &#34;a&#34;, &#34;json&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// With subscript in array&#xA;var json: JSON =  [1,2,3]&#xA;json[0] = 100&#xA;json[1] = 200&#xA;json[2] = 300&#xA;json[999] = 300 // Don&#39;t worry, nothing will happen&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// With subscript in dictionary&#xA;var json: JSON =  [&#34;name&#34;: &#34;Jack&#34;, &#34;age&#34;: 25]&#xA;json[&#34;name&#34;] = &#34;Mike&#34;&#xA;json[&#34;age&#34;] = &#34;25&#34; // It&#39;s OK to set String&#xA;json[&#34;address&#34;] = &#34;L.A.&#34; // Add the &#34;address&#34;: &#34;L.A.&#34; in json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Array &amp;amp; Dictionary&#xA;var json: JSON =  [&#34;name&#34;: &#34;Jack&#34;, &#34;age&#34;: 25, &#34;list&#34;: [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, [&#34;what&#34;: &#34;this&#34;]]]&#xA;json[&#34;list&#34;][3][&#34;what&#34;] = &#34;that&#34;&#xA;json[&#34;list&#34;,3,&#34;what&#34;] = &#34;that&#34;&#xA;let path: [JSONSubscriptType] = [&#34;list&#34;,3,&#34;what&#34;]&#xA;json[path] = &#34;that&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// With other JSON objects&#xA;let user: JSON = [&#34;username&#34; : &#34;Steve&#34;, &#34;password&#34;: &#34;supersecurepassword&#34;]&#xA;let auth: JSON = [&#xA;  &#34;user&#34;: user.object, // use user.object instead of just user&#xA;  &#34;apikey&#34;: &#34;supersecretapitoken&#34;&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Merging&lt;/h4&gt; &#xA;&lt;p&gt;It is possible to merge one JSON into another JSON. Merging a JSON into another JSON adds all non existing values to the original JSON which are only present in the &lt;code&gt;other&lt;/code&gt; JSON.&lt;/p&gt; &#xA;&lt;p&gt;If both JSONs contain a value for the same key, &lt;em&gt;mostly&lt;/em&gt; this value gets overwritten in the original JSON, but there are two cases where it provides some special treatment:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;In case of both values being a &lt;code&gt;JSON.Type.array&lt;/code&gt; the values form the array found in the &lt;code&gt;other&lt;/code&gt; JSON getting appended to the original JSON&#39;s array value.&lt;/li&gt; &#xA; &lt;li&gt;In case of both values being a &lt;code&gt;JSON.Type.dictionary&lt;/code&gt; both JSON-values are getting merged the same way the encapsulating JSON is merged.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In a case where two fields in a JSON have different types, the value will get always overwritten.&lt;/p&gt; &#xA;&lt;p&gt;There are two different fashions for merging: &lt;code&gt;merge&lt;/code&gt; modifies the original JSON, whereas &lt;code&gt;merged&lt;/code&gt; works non-destructively on a copy.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let original: JSON = [&#xA;    &#34;first_name&#34;: &#34;John&#34;,&#xA;    &#34;age&#34;: 20,&#xA;    &#34;skills&#34;: [&#34;Coding&#34;, &#34;Reading&#34;],&#xA;    &#34;address&#34;: [&#xA;        &#34;street&#34;: &#34;Front St&#34;,&#xA;        &#34;zip&#34;: &#34;12345&#34;,&#xA;    ]&#xA;]&#xA;&#xA;let update: JSON = [&#xA;    &#34;last_name&#34;: &#34;Doe&#34;,&#xA;    &#34;age&#34;: 21,&#xA;    &#34;skills&#34;: [&#34;Writing&#34;],&#xA;    &#34;address&#34;: [&#xA;        &#34;zip&#34;: &#34;12342&#34;,&#xA;        &#34;city&#34;: &#34;New York City&#34;&#xA;    ]&#xA;]&#xA;&#xA;let updated = original.merge(with: update)&#xA;// [&#xA;//     &#34;first_name&#34;: &#34;John&#34;,&#xA;//     &#34;last_name&#34;: &#34;Doe&#34;,&#xA;//     &#34;age&#34;: 21,&#xA;//     &#34;skills&#34;: [&#34;Coding&#34;, &#34;Reading&#34;, &#34;Writing&#34;],&#xA;//     &#34;address&#34;: [&#xA;//         &#34;street&#34;: &#34;Front St&#34;,&#xA;//         &#34;zip&#34;: &#34;12342&#34;,&#xA;//         &#34;city&#34;: &#34;New York City&#34;&#xA;//     ]&#xA;// ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Removing elements&lt;/h4&gt; &#xA;&lt;p&gt;If you are storing dictionaries, you can remove elements using &lt;code&gt;dictionaryObject.removeValue(forKey:)&lt;/code&gt;. This mutates the JSON object in place.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var object = JSON([&#xA;    &#34;one&#34;: [&#34;color&#34;: &#34;blue&#34;],&#xA;    &#34;two&#34;: [&#34;city&#34;: &#34;tokyo&#34;,&#xA;            &#34;country&#34;: &#34;japan&#34;,&#xA;            &#34;foods&#34;: [&#xA;                &#34;breakfast&#34;: &#34;tea&#34;,&#xA;                &#34;lunch&#34;: &#34;sushi&#34;&#xA;                ]&#xA;            ]&#xA;])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lets remove the &lt;code&gt;country&lt;/code&gt; key:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;object[&#34;two&#34;].dictionaryObject?.removeValue(forKey: &#34;country&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you &lt;code&gt;print(object)&lt;/code&gt;, you&#39;ll see that the &lt;code&gt;country&lt;/code&gt; key no longer exists.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;one&#34; : {&#xA;    &#34;color&#34; : &#34;blue&#34;&#xA;  },&#xA;  &#34;two&#34; : {&#xA;    &#34;city&#34; : &#34;tokyo&#34;,&#xA;    &#34;foods&#34; : {&#xA;      &#34;breakfast&#34; : &#34;tea&#34;,&#xA;      &#34;lunch&#34; : &#34;sushi&#34;&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This also works for nested dictionaries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;object[&#34;two&#34;][&#34;foods&#34;].dictionaryObject?.removeValue(forKey: &#34;breakfast&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;one&#34; : {&#xA;    &#34;color&#34; : &#34;blue&#34;&#xA;  },&#xA;  &#34;two&#34; : {&#xA;    &#34;city&#34; : &#34;tokyo&#34;,&#xA;    &#34;foods&#34; : {&#xA;      &#34;lunch&#34; : &#34;sushi&#34;&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;String representation&lt;/h2&gt; &#xA;&lt;p&gt;There are two options available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;use the default Swift one&lt;/li&gt; &#xA; &lt;li&gt;use a custom one that will handle optionals well and represent &lt;code&gt;nil&lt;/code&gt; as &lt;code&gt;&#34;null&#34;&lt;/code&gt;:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let dict = [&#34;1&#34;:2, &#34;2&#34;:&#34;two&#34;, &#34;3&#34;: nil] as [String: Any?]&#xA;let json = JSON(dict)&#xA;let representation = json.rawString(options: [.castNilToNSNull: true])&#xA;// representation is &#34;{\&#34;1\&#34;:2,\&#34;2\&#34;:\&#34;two\&#34;,\&#34;3\&#34;:null}&#34;, which represents {&#34;1&#34;:2,&#34;2&#34;:&#34;two&#34;,&#34;3&#34;:null}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Work with &lt;a href=&#34;https://github.com/Alamofire/Alamofire&#34;&gt;Alamofire&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;SwiftyJSON nicely wraps the result of the Alamofire JSON response handler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Alamofire.request(url, method: .get).validate().responseJSON { response in&#xA;    switch response.result {&#xA;    case .success(let value):&#xA;        let json = JSON(value)&#xA;        print(&#34;JSON: \(json)&#34;)&#xA;    case .failure(let error):&#xA;        print(error)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We also provide an extension of Alamofire for serializing NSData to SwiftyJSON&#39;s JSON.&lt;/p&gt; &#xA;&lt;p&gt;See: &lt;a href=&#34;https://github.com/SwiftyJSON/Alamofire-SwiftyJSON&#34;&gt;Alamofire-SwiftyJSON&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Work with &lt;a href=&#34;https://github.com/Moya/Moya&#34;&gt;Moya&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;SwiftyJSON parse data to JSON:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let provider = MoyaProvider&amp;lt;Backend&amp;gt;()&#xA;provider.request(.showProducts) { result in&#xA;    switch result {&#xA;    case let .success(moyaResponse):&#xA;        let data = moyaResponse.data&#xA;        let json = JSON(data: data) // convert network data to json&#xA;        print(json)&#xA;    case let .failure(error):&#xA;        print(&#34;error: \(error)&#34;)&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;SwiftyJSON Model Generator&lt;/h2&gt; &#xA;&lt;p&gt;Tools to generate SwiftyJSON Models&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Ahmed-Ali/JSONExport&#34;&gt;JSON Export&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>apple/swift-log</title>
    <updated>2024-12-01T01:58:36Z</updated>
    <id>tag:github.com,2024-12-01:/apple/swift-log</id>
    <link href="https://github.com/apple/swift-log" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Logging API for Swift&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SwiftLog&lt;/h1&gt; &#xA;&lt;p&gt;First things first: This is the beginning of a community-driven open-source project actively seeking contributions, be it code, documentation, or ideas. Apart from contributing to &lt;code&gt;SwiftLog&lt;/code&gt; itself, there&#39;s another huge gap at the moment: &lt;code&gt;SwiftLog&lt;/code&gt; is an &lt;em&gt;API package&lt;/em&gt; which tries to establish a common API the ecosystem can use. To make logging really work for real-world workloads, we need &lt;code&gt;SwiftLog&lt;/code&gt;-compatible &lt;em&gt;logging backends&lt;/em&gt; which then either persist the log messages in files, render them in nicer colors on the terminal, or send them over to Splunk or ELK.&lt;/p&gt; &#xA;&lt;p&gt;What &lt;code&gt;SwiftLog&lt;/code&gt; provides today can be found in the &lt;a href=&#34;https://apple.github.io/swift-log/docs/current/Logging/Structs/Logger.html&#34;&gt;API docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;If you have a server-side Swift application, or maybe a cross-platform (for example Linux &amp;amp; macOS) app/library, and you would like to log, we think targeting this logging API package is a great idea. Below you&#39;ll find all you need to know to get started.&lt;/p&gt; &#xA;&lt;h4&gt;Adding the dependency&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;SwiftLog&lt;/code&gt; is designed for Swift 5.8 and later. To depend on the logging API package, you need to declare your dependency in your &lt;code&gt;Package.swift&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.package(url: &#34;https://github.com/apple/swift-log.git&#34;, from: &#34;1.0.0&#34;),&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and to your application/library target, add &lt;code&gt;&#34;Logging&#34;&lt;/code&gt; to your &lt;code&gt;dependencies&lt;/code&gt;, e.g. like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.target(name: &#34;BestExampleApp&#34;, dependencies: [&#xA;    .product(name: &#34;Logging&#34;, package: &#34;swift-log&#34;)&#xA;],&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Let&#39;s log&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 1) let&#39;s import the logging API package&#xA;import Logging&#xA;&#xA;// 2) we need to create a logger, the label works similarly to a DispatchQueue label&#xA;let logger = Logger(label: &#34;com.example.BestExampleApp.main&#34;)&#xA;&#xA;// 3) we&#39;re now ready to use it&#xA;logger.info(&#34;Hello World!&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;2019-03-13T15:46:38+0000 info: Hello World!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Default &lt;code&gt;Logger&lt;/code&gt; behavior&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;SwiftLog&lt;/code&gt; provides for very basic console logging out-of-the-box by way of &lt;code&gt;StreamLogHandler&lt;/code&gt;. It is possible to switch the default output to &lt;code&gt;stderr&lt;/code&gt; like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;LoggingSystem.bootstrap(StreamLogHandler.standardError)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;StreamLogHandler&lt;/code&gt; is primarily a convenience only and does not provide any substantial customization. Library maintainers who aim to build their own logging backends for integration and consumption should implement the &lt;code&gt;LogHandler&lt;/code&gt; protocol directly as laid out in &lt;a href=&#34;https://raw.githubusercontent.com/apple/swift-log/main/#on-the-implementation-of-a-logging-backend-a-loghandler&#34;&gt;the &#34;On the implementation of a logging backend&#34; section&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For further information, please check the &lt;a href=&#34;https://apple.github.io/swift-log/docs/current/Logging/Structs/Logger.html&#34;&gt;API documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;backends&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Available Logging Backends For Applications&lt;/h2&gt; &#xA;&lt;p&gt;You can choose from one of the following backends to consume your logs. If you are interested in implementing one see the &#34;Implementation considerations&#34; section below explaining how to do so. List of existing SwiftLog API compatible libraries:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Repository&lt;/th&gt; &#xA;   &lt;th&gt;Handler Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Kitura/HeliumLogger&#34;&gt;Kitura/HeliumLogger&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend widely used in the Kitura ecosystem&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ianpartridge/swift-log-syslog&#34;&gt;ianpartridge/swift-log-&lt;strong&gt;syslog&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a &lt;a href=&#34;https://en.wikipedia.org/wiki/Syslog&#34;&gt;syslog&lt;/a&gt; backend&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Adorkable/swift-log-format-and-pipe&#34;&gt;Adorkable/swift-log-&lt;strong&gt;format-and-pipe&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a backend that allows customization of the output format and the resulting destination&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/chrisaljoudi/swift-log-oslog&#34;&gt;chrisaljoudi/swift-log-&lt;strong&gt;oslog&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;an OSLog &lt;a href=&#34;https://developer.apple.com/documentation/os/logging&#34;&gt;Unified Logging&lt;/a&gt; backend for use on Apple platforms. &lt;strong&gt;Important Note:&lt;/strong&gt; we recommend using os_log directly as described &lt;a href=&#34;https://developer.apple.com/documentation/os/logging&#34;&gt;here&lt;/a&gt;. Using os_log through swift-log using this backend will be less efficient and will also prevent specifying the privacy of the message. The backend always uses &lt;code&gt;%{public}@&lt;/code&gt; as the format string and eagerly converts all string interpolations to strings. This has two drawbacks: 1. the static components of the string interpolation would be eagerly copied by the unified logging system, which will result in loss of performance. 2. It makes all messages public, which changes the default privacy policy of os_log, and doesn&#39;t allow specifying fine-grained privacy of sections of the message. In a separate on-going work, Swift APIs for os_log are being improved and made to align closely with swift-log APIs. References: &lt;a href=&#34;https://forums.swift.org/t/custom-string-interpolation-and-compile-time-interpretation-applied-to-logging/18799&#34;&gt;Unifying Logging Levels&lt;/a&gt;, &lt;a href=&#34;https://forums.swift.org/t/logging-levels-for-swifts-server-side-logging-apis-and-new-os-log-apis/20365&#34;&gt;Making os_log accept string interpolations using compile-time interpretation&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Brainfinance/StackdriverLogging&#34;&gt;Brainfinance/StackdriverLogging&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a structured JSON logging backend for use on Google Cloud Platform with the &lt;a href=&#34;https://cloud.google.com/logging/docs/agent&#34;&gt;Stackdriver logging agent&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/DnV1eX/GoogleCloudLogging&#34;&gt;DnV1eX/GoogleCloudLogging&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a client-side library for logging application events in &lt;a href=&#34;https://console.cloud.google.com/logs&#34;&gt;Google Cloud&lt;/a&gt; via REST API v2.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/vapor/console-kit/&#34;&gt;vapor/console-kit&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logger to the current terminal or stdout with stylized (&lt;a href=&#34;https://en.wikipedia.org/wiki/ANSI_escape_code&#34;&gt;ANSI&lt;/a&gt;) output. The default logger for all Vapor applications&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/neallester/swift-log-testing&#34;&gt;neallester/swift-log-testing&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;provides access to log messages for use in assertions (within test targets)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/wlisac/swift-log-slack&#34;&gt;wlisac/swift-log-slack&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend that sends critical log messages to Slack&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/NSHipster/swift-log-github-actions&#34;&gt;NSHipster/swift-log-github-actions&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend that translates logging messages into &lt;a href=&#34;https://help.github.com/en/actions/reference/workflow-commands-for-github-actions&#34;&gt;workflow commands for GitHub Actions&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/stevapple/swift-log-telegram&#34;&gt;stevapple/swift-log-telegram&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend that sends log messages to any Telegram chat (Inspired by and forked from &lt;a href=&#34;https://github.com/wlisac/swift-log-slack&#34;&gt;wlisac/swift-log-slack&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/jagreenwood/swift-log-datadog&#34;&gt;jagreenwood/swift-log-datadog&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend which sends log messages to the &lt;a href=&#34;https://www.datadoghq.com/log-management/&#34;&gt;Datadog&lt;/a&gt; log management service&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/google/swiftlogfirecloud&#34;&gt;google/SwiftLogFireCloud&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend for time series logging which pushes logs as flat files to Firebase Cloud Storage.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/crspybits/swift-log-file&#34;&gt;crspybits/swift-log-file&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a simple local file logger (using &lt;code&gt;Foundation&lt;/code&gt; &lt;code&gt;FileManager&lt;/code&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/sushichop/Puppy&#34;&gt;sushichop/Puppy&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend that supports multiple transports(console, file, syslog, etc.) and has the feature with formatting and file log rotation&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ShivaHuang/swift-log-SwiftyBeaver&#34;&gt;ShivaHuang/swift-log-SwiftyBeaver&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend for printing colored logging to Xcode console / file, or sending encrypted logging to &lt;a href=&#34;https://swiftybeaver.com&#34;&gt;SwiftyBeaver&lt;/a&gt; platform.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Apodini/swift-log-elk&#34;&gt;Apodini/swift-log-elk&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend that formats, caches and sends log data to &lt;a href=&#34;https://github.com/elastic/logstash&#34;&gt;elastic/logstash&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/binaryscraping/swift-log-supabase&#34;&gt;binaryscraping/swift-log-supabase&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend that sends log entries to &lt;a href=&#34;https://github.com/supabase/supabase&#34;&gt;Supabase&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://swiftpackageindex.com/kiliankoe/swift-log-matrix&#34;&gt;kiliankoe/swift-log-matrix&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend for sending logs directly to a &lt;a href=&#34;https://matrix.org&#34;&gt;Matrix&lt;/a&gt; room&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/DiscordBM/DiscordLogger&#34;&gt;DiscordBM/DiscordLogger&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a Discord logging implementation to send your logs over to a Discord channel in a good-looking manner and with a lot of configuration options including the ability to send only a few important log-levels such as &lt;code&gt;warning&lt;/code&gt;/&lt;code&gt;error&lt;/code&gt;/&lt;code&gt;critical&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/CocoaLumberjack/CocoaLumberjack&#34;&gt;CocoaLumberjack&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a fast &amp;amp; simple, yet powerful &amp;amp; flexible logging framework for macOS, iOS, tvOS and watchOS, which includes a logging backend for swift-log.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/rwbutler/swift-log-ecs&#34;&gt;rwbutler/swift-log-ecs&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend for logging in &lt;a href=&#34;https://www.elastic.co/guide/en/ecs-logging/overview/current/intro.html&#34;&gt;ECS Log format&lt;/a&gt;. Compatible with &lt;a href=&#34;https://github.com/vapor/vapor&#34;&gt;Vapor&lt;/a&gt; and allows chaining of multiple LogHandlers.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ShipBook/swift-log-shipbook&#34;&gt;ShipBook/swift-log-&lt;strong&gt;shipbook&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend that sends log entries to &lt;a href=&#34;https://www.shipbook.io&#34;&gt;Shipbook&lt;/a&gt; - Shipbook gives you the power to remotely gather, search and analyze your user logs and exceptions in the cloud, on a per-user &amp;amp; session basis.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/kasianov-mikhail/scout&#34;&gt;kasianov-mikhail/scout&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;CloudKit as a log storage&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/PADL/AndroidLogging&#34;&gt;PADL/AndroidLogging&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;a logging backend for the Android in-kernel log buffer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Your library?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://forums.swift.org/c/server&#34;&gt;Get in touch!&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;What is an API package?&lt;/h2&gt; &#xA;&lt;p&gt;Glad you asked. We believe that for the Swift on Server ecosystem, it&#39;s crucial to have a logging API that can be adopted by anybody so a multitude of libraries from different parties can all log to a shared destination. More concretely this means that we believe all the log messages from all libraries end up in the same file, database, Elastic Stack/Splunk instance, or whatever you may choose.&lt;/p&gt; &#xA;&lt;p&gt;In the real-world however, there are so many opinions over how exactly a logging system should behave, what a log message should be formatted like, and where/how it should be persisted. We think it&#39;s not feasible to wait for one logging package to support everything that a specific deployment needs whilst still being easy enough to use and remain performant. That&#39;s why we decided to cut the problem in half:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;a logging API&lt;/li&gt; &#xA; &lt;li&gt;a logging backend implementation&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This package only provides the logging API itself and therefore &lt;code&gt;SwiftLog&lt;/code&gt; is a &#39;logging API package&#39;. &lt;code&gt;SwiftLog&lt;/code&gt; (using &lt;code&gt;LoggingSystem.bootstrap&lt;/code&gt;) can be configured to choose any compatible logging backend implementation. This way packages can adopt the API and the &lt;em&gt;application&lt;/em&gt; can choose any compatible logging backend implementation without requiring any changes from any of the libraries.&lt;/p&gt; &#xA;&lt;p&gt;Just for completeness sake: This API package does actually include an overly simplistic and non-configurable logging backend implementation which simply writes all log messages to &lt;code&gt;stdout&lt;/code&gt;. The reason to include this overly simplistic logging backend implementation is to improve the first-time usage experience. Let&#39;s assume you start a project and try out &lt;code&gt;SwiftLog&lt;/code&gt; for the first time, it&#39;s just a whole lot better to see something you logged appear on &lt;code&gt;stdout&lt;/code&gt; in a simplistic format rather than nothing happening at all. For any real-world application, we advise configuring another logging backend implementation that logs in the style you like.&lt;/p&gt; &#xA;&lt;h2&gt;The core concepts&lt;/h2&gt; &#xA;&lt;h3&gt;Loggers&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Logger&lt;/code&gt;s are used to emit log messages and therefore the most important type in &lt;code&gt;SwiftLog&lt;/code&gt;, so their use should be as simple as possible. Most commonly, they are used to emit log messages in a certain log level. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// logging an informational message&#xA;logger.info(&#34;Hello World!&#34;)&#xA;&#xA;// ouch, something went wrong&#xA;logger.error(&#34;Houston, we have a problem: \(problem)&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Log levels&lt;/h3&gt; &#xA;&lt;p&gt;The following log levels are supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;debug&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;info&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;notice&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;warning&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;error&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;critical&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The log level of a given logger can be changed, but the change will only affect the specific logger you changed it on. You could say the &lt;code&gt;Logger&lt;/code&gt; is a &lt;em&gt;value type&lt;/em&gt; regarding the log level.&lt;/p&gt; &#xA;&lt;h3&gt;Logging metadata&lt;/h3&gt; &#xA;&lt;p&gt;Logging metadata is metadata that can be attached to loggers to add information that is crucial when debugging a problem. In servers, the usual example is attaching a request UUID to a logger that will then be present on all log messages logged with that logger. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var logger = logger&#xA;logger[metadataKey: &#34;request-uuid&#34;] = &#34;\(UUID())&#34;&#xA;logger.info(&#34;hello world&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will print&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;2019-03-13T18:30:02+0000 info: request-uuid=F8633013-3DD8-481C-9256-B296E43443ED hello world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;with the default logging backend implementation that ships with &lt;code&gt;SwiftLog&lt;/code&gt;. Needless to say, the format is fully defined by the logging backend you choose.&lt;/p&gt; &#xA;&lt;h2&gt;On the implementation of a logging backend (a &lt;code&gt;LogHandler&lt;/code&gt;)&lt;/h2&gt; &#xA;&lt;p&gt;Note: If you don&#39;t want to implement a custom logging backend, everything in this section is probably not very relevant, so please feel free to skip.&lt;/p&gt; &#xA;&lt;p&gt;To become a compatible logging backend that all &lt;code&gt;SwiftLog&lt;/code&gt; consumers can use, you need to do two things: 1) Implement a type (usually a &lt;code&gt;struct&lt;/code&gt;) that implements &lt;code&gt;LogHandler&lt;/code&gt;, a protocol provided by &lt;code&gt;SwiftLog&lt;/code&gt; and 2) instruct &lt;code&gt;SwiftLog&lt;/code&gt; to use your logging backend implementation.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;code&gt;LogHandler&lt;/code&gt; or logging backend implementation is anything that conforms to the following protocol&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol LogHandler {&#xA;    func log(level: Logger.Level, message: Logger.Message, metadata: Logger.Metadata?, source: String, file: String, function: String, line: UInt)&#xA;&#xA;    subscript(metadataKey _: String) -&amp;gt; Logger.Metadata.Value? { get set }&#xA;&#xA;    var metadata: Logger.Metadata { get set }&#xA;&#xA;    var logLevel: Logger.Level { get set }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instructing &lt;code&gt;SwiftLog&lt;/code&gt; to use your logging backend as the one the whole application (including all libraries) should use is very simple:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;LoggingSystem.bootstrap(MyLogHandler.init)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Implementation considerations&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;LogHandler&lt;/code&gt;s control most parts of the logging system:&lt;/p&gt; &#xA;&lt;h4&gt;Under control of a &lt;code&gt;LogHandler&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;h5&gt;Configuration&lt;/h5&gt; &#xA;&lt;p&gt;&lt;code&gt;LogHandler&lt;/code&gt;s control the two crucial pieces of &lt;code&gt;Logger&lt;/code&gt; configuration, namely:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;log level (&lt;code&gt;logger.logLevel&lt;/code&gt; property)&lt;/li&gt; &#xA; &lt;li&gt;logging metadata (&lt;code&gt;logger[metadataKey:]&lt;/code&gt; and &lt;code&gt;logger.metadata&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For the system to work, however, it is important that &lt;code&gt;LogHandler&lt;/code&gt; treat the configuration as &lt;em&gt;value types&lt;/em&gt;. This means that &lt;code&gt;LogHandler&lt;/code&gt;s should be &lt;code&gt;struct&lt;/code&gt;s and a change in log level or logging metadata should only affect the very &lt;code&gt;LogHandler&lt;/code&gt; it was changed on.&lt;/p&gt; &#xA;&lt;p&gt;However, in special cases, it is acceptable that a &lt;code&gt;LogHandler&lt;/code&gt; provides some global log level override that may affect all &lt;code&gt;LogHandler&lt;/code&gt;s created.&lt;/p&gt; &#xA;&lt;h5&gt;Emitting&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;emitting the log message itself&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Not under control of &lt;code&gt;LogHandler&lt;/code&gt;s&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;LogHandler&lt;/code&gt;s do not control if a message should be logged or not. &lt;code&gt;Logger&lt;/code&gt; will only invoke the &lt;code&gt;log&lt;/code&gt; function of a &lt;code&gt;LogHandler&lt;/code&gt; if &lt;code&gt;Logger&lt;/code&gt; determines that a log message should be emitted given the configured log level.&lt;/p&gt; &#xA;&lt;h2&gt;Source vs Label&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;code&gt;Logger&lt;/code&gt; carries an (immutable) &lt;code&gt;label&lt;/code&gt; and each log message carries a &lt;code&gt;source&lt;/code&gt; parameter (since SwiftLog 1.3.0). The &lt;code&gt;Logger&lt;/code&gt;&#39;s label identifies the creator of the &lt;code&gt;Logger&lt;/code&gt;. If you are using structured logging by preserving metadata across multiple modules, the &lt;code&gt;Logger&lt;/code&gt;&#39;s &lt;code&gt;label&lt;/code&gt; is not a good way to identify where a log message originated from as it identifies the creator of a &lt;code&gt;Logger&lt;/code&gt; which is often passed around between libraries to preserve metadata and the like.&lt;/p&gt; &#xA;&lt;p&gt;If you want to filter all log messages originating from a certain subsystem, filter by &lt;code&gt;source&lt;/code&gt; which defaults to the module that is emitting the log message.&lt;/p&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/apple/swift-log/main/SECURITY.md&#34;&gt;SECURITY.md&lt;/a&gt; for SwiftLog&#39;s security process.&lt;/p&gt; &#xA;&lt;h2&gt;Design&lt;/h2&gt; &#xA;&lt;p&gt;This logging API was designed with the contributors to the Swift on Server community and approved by the &lt;a href=&#34;https://swift.org/server/&#34;&gt;SSWG (Swift Server Work Group)&lt;/a&gt; to the &#39;sandbox level&#39; of the SSWG&#39;s &lt;a href=&#34;https://www.swift.org/sswg/incubation-process.html&#34;&gt;incubation process&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://forums.swift.org/t/logging/16027&#34;&gt;pitch&lt;/a&gt;, &lt;a href=&#34;https://forums.swift.org/t/discussion-server-logging-api/18834&#34;&gt;discussion&lt;/a&gt;, &lt;a href=&#34;https://forums.swift.org/t/feedback-server-logging-api-with-revisions/19375&#34;&gt;feedback&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://forums.swift.org/t/logging-levels-for-swifts-server-side-logging-apis-and-new-os-log-apis/20365&#34;&gt;log levels&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>gonzalezreal/swift-markdown-ui</title>
    <updated>2024-12-01T01:58:36Z</updated>
    <id>tag:github.com,2024-12-01:/gonzalezreal/swift-markdown-ui</id>
    <link href="https://github.com/gonzalezreal/swift-markdown-ui" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Display and customize Markdown text in SwiftUI&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MarkdownUI&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/gonzalezreal/MarkdownUI/actions?query=workflow%3ACI&#34;&gt;&lt;img src=&#34;https://github.com/gonzalezreal/MarkdownUI/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/gonzalezreal/swift-markdown-ui&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fgonzalezreal%2Fswift-markdown-ui%2Fbadge%3Ftype%3Dswift-versions&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://swiftpackageindex.com/gonzalezreal/swift-markdown-ui&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fswiftpackageindex.com%2Fapi%2Fpackages%2Fgonzalezreal%2Fswift-markdown-ui%2Fbadge%3Ftype%3Dplatforms&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Display and customize Markdown text in SwiftUI.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/#minimum-requirements&#34;&gt;Minimum requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/#getting-started&#34;&gt;Getting started&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/#creating-a-markdown-view&#34;&gt;Creating a Markdown view&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/#styling-markdown&#34;&gt;Styling Markdown&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/#documentation&#34;&gt;Documentation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/#related-content&#34;&gt;Related content&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/#demo&#34;&gt;Demo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;MarkdownUI is a powerful library for displaying and customizing Markdown text in SwiftUI. It is compatible with the &lt;a href=&#34;https://github.github.com/gfm/&#34;&gt;GitHub Flavored Markdown Spec&lt;/a&gt; and can display images, headings, lists (including task lists), blockquotes, code blocks, tables, and thematic breaks, besides styled text and links.&lt;/p&gt; &#xA;&lt;p&gt;MarkdownUI offers comprehensible theming features to customize how it displays Markdown text. You can use the built-in themes, create your own or override specific text and block styles.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/MarkdownUI@2x.png#gh-light-mode-only&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/MarkdownUI~dark@2x.png#gh-dark-mode-only&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Minimum requirements&lt;/h2&gt; &#xA;&lt;p&gt;You can use MarkdownUI on the following platforms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;macOS 12.0+&lt;/li&gt; &#xA; &lt;li&gt;iOS 15.0+&lt;/li&gt; &#xA; &lt;li&gt;tvOS 15.0+&lt;/li&gt; &#xA; &lt;li&gt;watchOS 8.0+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some features, like displaying tables or multi-image paragraphs, require macOS 13.0+, iOS 16.0+, tvOS 16.0+, and watchOS 9.0+.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;h3&gt;Creating a Markdown view&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;Markdown&lt;/code&gt; view displays rich structured text using the Markdown syntax. It can display images, headings, lists (including task lists), blockquotes, code blocks, tables, and thematic breaks, besides styled text and links.&lt;/p&gt; &#xA;&lt;p&gt;The simplest way of creating a &lt;code&gt;Markdown&lt;/code&gt; view is to pass a Markdown string to the &lt;code&gt;init(_:baseURL:imageBaseURL:)&lt;/code&gt; initializer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let markdownString = &#34;&#34;&#34;&#xA;  ## Try MarkdownUI&#xA;&#xA;  **MarkdownUI** is a native Markdown renderer for SwiftUI&#xA;  compatible with the&#xA;  [GitHub Flavored Markdown Spec](https://github.github.com/gfm/).&#xA;  &#34;&#34;&#34;&#xA;&#xA;var body: some View {&#xA;  Markdown(markdownString)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/MarkdownString@2x.png#gh-light-mode-only&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/MarkdownString~dark@2x.png#gh-dark-mode-only&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A more convenient way to create a &lt;code&gt;Markdown&lt;/code&gt; view is by using the &lt;code&gt;init(baseURL:imageBaseURL:content:)&lt;/code&gt; initializer, which takes a Markdown content builder in which you can compose the view content, either by providing Markdown strings or by using an expressive domain-specific language.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var body: some View {&#xA;  Markdown {&#xA;    &#34;&#34;&#34;&#xA;    ## Using a Markdown Content Builder&#xA;    Use Markdown strings or an expressive domain-specific language&#xA;    to build the content.&#xA;    &#34;&#34;&#34;&#xA;    Heading(.level2) {&#xA;      &#34;Try MarkdownUI&#34;&#xA;    }&#xA;    Paragraph {&#xA;      Strong(&#34;MarkdownUI&#34;)&#xA;      &#34; is a native Markdown renderer for SwiftUI&#34;&#xA;      &#34; compatible with the &#34;&#xA;      InlineLink(&#xA;        &#34;GitHub Flavored Markdown Spec&#34;,&#xA;        destination: URL(string: &#34;https://github.github.com/gfm/&#34;)!&#xA;      )&#xA;      &#34;.&#34;&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/MarkdownContentBuilder@2x.png#gh-light-mode-only&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/MarkdownContentBuilder~dark@2x.png#gh-dark-mode-only&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can also create a &lt;code&gt;MarkdownContent&lt;/code&gt; value in your model layer and later create a &lt;code&gt;Markdown&lt;/code&gt; view by passing the content value to the &lt;code&gt;init(_:baseURL:imageBaseURL:)&lt;/code&gt; initializer. The &lt;code&gt;MarkdownContent&lt;/code&gt; value pre-parses the Markdown string preventing the view from doing this step.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Somewhere in the model layer&#xA;let content = MarkdownContent(&#34;You can try **CommonMark** [here](https://spec.commonmark.org/dingus/).&#34;)&#xA;&#xA;// Later in the view layer&#xA;var body: some View {&#xA;  Markdown(self.model.content)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Styling Markdown&lt;/h3&gt; &#xA;&lt;p&gt;Markdown views use a basic default theme to display the contents. For more information, read about the &lt;code&gt;basic&lt;/code&gt; theme.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Markdown {&#xA;  &#34;&#34;&#34;&#xA;  You can quote text with a `&amp;gt;`.&#xA;&#xA;  &amp;gt; Outside of a dog, a book is man&#39;s best friend. Inside of a&#xA;  &amp;gt; dog it&#39;s too dark to read.&#xA;&#xA;   Groucho Marx&#xA;  &#34;&#34;&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/BlockquoteContent@2x.png#gh-light-mode-only&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/BlockquoteContent~dark@2x.png#gh-dark-mode-only&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can customize the appearance of Markdown content by applying different themes using the &lt;code&gt;markdownTheme(_:)&lt;/code&gt; modifier. For example, you can apply one of the built-in themes, like &lt;code&gt;gitHub&lt;/code&gt;, to either a Markdown view or a view hierarchy that contains Markdown views.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Markdown {&#xA;  &#34;&#34;&#34;&#xA;  You can quote text with a `&amp;gt;`.&#xA;&#xA;  &amp;gt; Outside of a dog, a book is man&#39;s best friend. Inside of a&#xA;  &amp;gt; dog it&#39;s too dark to read.&#xA;&#xA;   Groucho Marx&#xA;  &#34;&#34;&#34;&#xA;}&#xA;.markdownTheme(.gitHub)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/GitHubBlockquote@2x.png#gh-light-mode-only&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/GitHubBlockquote~dark@2x.png#gh-dark-mode-only&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;To override a specific text style from the current theme, use the &lt;code&gt;markdownTextStyle(_:textStyle:)&lt;/code&gt; modifier. The following example shows how to override the &lt;code&gt;code&lt;/code&gt; text style.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Markdown {&#xA;  &#34;&#34;&#34;&#xA;  Use `git status` to list all new or modified files&#xA;  that haven&#39;t yet been committed.&#xA;  &#34;&#34;&#34;&#xA;}&#xA;.markdownTextStyle(\.code) {&#xA;  FontFamilyVariant(.monospaced)&#xA;  FontSize(.em(0.85))&#xA;  ForegroundColor(.purple)&#xA;  BackgroundColor(.purple.opacity(0.25))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/CustomInlineCode@2x.png#gh-light-mode-only&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/CustomInlineCode~dark@2x.png#gh-dark-mode-only&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can also use the &lt;code&gt;markdownBlockStyle(_:body:)&lt;/code&gt; modifier to override a specific block style. For example, you can override only the &lt;code&gt;blockquote&lt;/code&gt; block style, leaving other block styles untouched.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Markdown {&#xA;  &#34;&#34;&#34;&#xA;  You can quote text with a `&amp;gt;`.&#xA;&#xA;  &amp;gt; Outside of a dog, a book is man&#39;s best friend. Inside of a&#xA;  &amp;gt; dog it&#39;s too dark to read.&#xA;&#xA;   Groucho Marx&#xA;  &#34;&#34;&#34;&#xA;}&#xA;.markdownBlockStyle(\.blockquote) { configuration in&#xA;  configuration.label&#xA;    .padding()&#xA;    .markdownTextStyle {&#xA;      FontCapsVariant(.lowercaseSmallCaps)&#xA;      FontWeight(.semibold)&#xA;      BackgroundColor(nil)&#xA;    }&#xA;    .overlay(alignment: .leading) {&#xA;      Rectangle()&#xA;        .fill(Color.teal)&#xA;        .frame(width: 4)&#xA;    }&#xA;    .background(Color.teal.opacity(0.5))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/CustomBlockquote@2x.png#gh-light-mode-only&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Sources/MarkdownUI/Documentation.docc/Resources/CustomBlockquote~dark@2x.png#gh-dark-mode-only&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Another way to customize the appearance of Markdown content is to create your own theme. To create a theme, start by instantiating an empty &lt;code&gt;Theme&lt;/code&gt; and chain together the different text and block styles in a single expression.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Theme {&#xA;  static let fancy = Theme()&#xA;    .code {&#xA;      FontFamilyVariant(.monospaced)&#xA;      FontSize(.em(0.85))&#xA;    }&#xA;    .link {&#xA;      ForegroundColor(.purple)&#xA;    }&#xA;    // More text styles...&#xA;    .paragraph { configuration in&#xA;      configuration.label&#xA;        .relativeLineSpacing(.em(0.25))&#xA;        .markdownMargin(top: 0, bottom: 16)&#xA;    }&#xA;    .listItem { configuration in&#xA;      configuration.label&#xA;        .markdownMargin(top: .em(0.25))&#xA;    }&#xA;    // More block styles...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://swiftpackageindex.com&#34;&gt;Swift Package Index&lt;/a&gt; kindly hosts the online documentation for all versions, available here:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://swiftpackageindex.com/gonzalezreal/swift-markdown-ui/main/documentation/markdownui&#34;&gt;main&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://swiftpackageindex.com/gonzalezreal/swift-markdown-ui/2.1.0/documentation/markdownui&#34;&gt;2.1.0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://swiftpackageindex.com/gonzalezreal/swift-markdown-ui/2.0.2/documentation/markdownui&#34;&gt;2.0.2&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Related content&lt;/h3&gt; &#xA;&lt;p&gt;You can learn more about MarkdownUI by referring to the following articles and third-party resources:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gonzalezreal.github.io/2023/02/18/better-markdown-rendering-in-swiftui.html&#34;&gt;Better Markdown Rendering in SwiftUI&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/gVy06iJQFWQ&#34;&gt;Unlock the Power of Markdown in SwiftUI with THIS Hack!&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/Rebeloper&#34;&gt;@Rebeloper&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Demo&lt;/h2&gt; &#xA;&lt;p&gt;MarkdownUI comes with a few more tricks on the sleeve. You can explore the &lt;a href=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Examples/Demo/&#34;&gt;companion demo project&lt;/a&gt; and discover its complete set of capabilities.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Examples/Demo/Screenshot.png#gh-light-mode-only&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/gonzalezreal/swift-markdown-ui/main/Examples/Demo/Screenshot~dark.png#gh-dark-mode-only&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Adding MarkdownUI to a Swift package&lt;/h3&gt; &#xA;&lt;p&gt;To use MarkdownUI in a Swift Package Manager project, add the following line to the dependencies in your &lt;code&gt;Package.swift&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.package(url: &#34;https://github.com/gonzalezreal/swift-markdown-ui&#34;, from: &#34;2.0.2&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Include &lt;code&gt;&#34;MarkdownUI&#34;&lt;/code&gt; as a dependency for your executable target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;.target(name: &#34;&amp;lt;target&amp;gt;&#34;, dependencies: [&#xA;  .product(name: &#34;MarkdownUI&#34;, package: &#34;swift-markdown-ui&#34;)&#xA;]),&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, add &lt;code&gt;import MarkdownUI&lt;/code&gt; to your source code.&lt;/p&gt; &#xA;&lt;h3&gt;Adding MarkdownUI to an Xcode project&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;From the &lt;strong&gt;File&lt;/strong&gt; menu, select &lt;strong&gt;Add Packages&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Enter &lt;code&gt;https://github.com/gonzalezreal/swift-markdown-ui&lt;/code&gt; into the &lt;em&gt;Search or Enter Package URL&lt;/em&gt; search field&lt;/li&gt; &#xA; &lt;li&gt;Link &lt;strong&gt;MarkdownUI&lt;/strong&gt; to your application target&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>