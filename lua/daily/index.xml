<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-06-01T01:32:30Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>yioneko/nvim-vtsls</title>
    <updated>2024-06-01T01:32:30Z</updated>
    <id>tag:github.com,2024-06-01:/yioneko/nvim-vtsls</id>
    <link href="https://github.com/yioneko/nvim-vtsls" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;nvim-vtsls&lt;/h1&gt; &#xA;&lt;p&gt;Plugin to help utilize capabilities of &lt;a href=&#34;https://github.com/yioneko/vtsls&#34;&gt;vtsls&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: This plugin is &lt;strong&gt;not needed&lt;/strong&gt; to work with &lt;code&gt;vtsls&lt;/code&gt;. It simply offers some extra helper commands and optional improvements. Any server related issue should go up to the upstream.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Setup server&lt;/h3&gt; &#xA;&lt;p&gt;Through &lt;a href=&#34;https://github.com/neovim/nvim-lspconfig&#34;&gt;nvim-lspconfig&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;lspconfig.configs&#34;).vtsls = require(&#34;vtsls&#34;).lspconfig -- set default server config, optional but recommended&#xA;&#xA;-- If the lsp setup is taken over by other plugin, it is the same to call the counterpart setup function&#xA;require(&#34;lspconfig&#34;).vtsls.setup({ --[[ your custom server config here ]] })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Execute commands&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;:VtsExec {command}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rename file/folder and update import paths&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;:VtsRename {from} {to}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Config&lt;/h2&gt; &#xA;&lt;p&gt;This is OPTIONAL. All the fields are also optional.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;vtsls&#39;).config({&#xA;  -- customize handlers for commands&#xA;  handlers = {&#xA;    source_definition = function(err, locations) end,&#xA;    file_references = function(err, locations) end,&#xA;    code_action = function(err, actions) end,&#xA;  },&#xA;  -- automatically trigger renaming of extracted symbol&#xA;  refactor_auto_rename = true,&#xA;  refactor_move_to_file = {&#xA;    -- If dressing.nvim is installed, telescope will be used for selection prompt. Use this to customize&#xA;    -- the opts for telescope picker.&#xA;    telescope_opts = function(items, default) end,&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Commands&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;restart_tsserver&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;This not restart vtsls itself, but restart the underlying tsserver.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;open_tsserver_log&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;It will open prompt if logging has not been enabled.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;reload_projects&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;select_ts_version&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Select version of ts either from workspace or global.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;goto_project_config&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Open &lt;code&gt;tsconfig.json&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;goto_source_definition&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Go to the source definition instead of typings.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;file_references&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Show references of the current file.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;rename_file&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Rename the current file and update all the related paths in the project.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;organize_imports&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;sort_imports&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;remove_unused_imports&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;fix_all&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;remove_unused&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;add_missing_imports&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;source_actions&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Pick applicable source actions (same as above)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;vtsls&#39;).commands[any_command_name](bufnr, on_resolve, on_reject)&#xA;require(&#39;vtsls&#39;).commands.goto_source_definition(winnr, on_resolve, on_reject) -- goto_source_definition requires winnr&#xA;require(&#39;vtsls&#39;).rename(old_name, new_name, on_resolve, on_reject) -- rename file or folder&#xA;&#xA;-- These callbacks are useful if you want to promisify the command functions to write async code.&#xA;function on_resolve() end -- after handler called&#xA;function on_reject(msg_or_err) end -- in case any error happens&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Other useful snippets&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Common settings to enable inlay hints&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  settings = {&#xA;    typescript = {&#xA;      inlayHints = {&#xA;        parameterNames = { enabled = &#34;literals&#34; },&#xA;        parameterTypes = { enabled = true },&#xA;        variableTypes = { enabled = true },&#xA;        propertyDeclarationTypes = { enabled = true },&#xA;        functionLikeReturnTypes = { enabled = true },&#xA;        enumMemberValues = { enabled = true },&#xA;      }&#xA;    },&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Handler for codelens command&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.lsp.commands[&#34;editor.action.showReferences&#34;] = function(command, ctx)&#xA;  local locations = command.arguments[3]&#xA;  local client = vim.lsp.get_client_by_id(ctx.client_id)&#xA;  if locations and #locations &amp;gt; 0 then&#xA;    local items = vim.lsp.util.locations_to_items(locations, client.offset_encoding)&#xA;    vim.fn.setloclist(0, {}, &#34; &#34;, { title = &#34;References&#34;, items = items, context = ctx })&#xA;    vim.api.nvim_command(&#34;lopen&#34;)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Then executing &lt;code&gt;vim.lsp.codelens.run()&lt;/code&gt; will open up a quickfix window for references shown by the lens.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Integration to &lt;a href=&#34;https://github.com/nvim-tree/nvim-tree.lua&#34;&gt;nvim-tree.lua&lt;/a&gt; for automatic renamed paths update&lt;/summary&gt; &#xA; &lt;p&gt;Excellent replacement for manually calling &lt;code&gt;:VtsExec rename_file&lt;/code&gt; or &lt;code&gt;:VtsRename&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;p&gt;You have two ways. You can use &lt;a href=&#34;https://github.com/antosha417/nvim-lsp-file-operations&#34;&gt;nvim-lsp-file-operations&lt;/a&gt;. It has integration with nvim and neo tree. Or you can use the following snippet. It also works for any server supporting &lt;code&gt;workspace/didRenameFiles&lt;/code&gt; notification.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local path_sep = package.config:sub(1, 1)&#xA;&#xA;local function trim_sep(path)&#xA;  return path:gsub(path_sep .. &#34;$&#34;, &#34;&#34;)&#xA;end&#xA;&#xA;local function uri_from_path(path)&#xA;  return vim.uri_from_fname(trim_sep(path))&#xA;end&#xA;&#xA;local function is_sub_path(path, folder)&#xA;  path = trim_sep(path)&#xA;  folder = trim_sep(folder)&#xA;  if path == folder then&#xA;    return true&#xA;  else&#xA;    return path:sub(1, #folder + 1) == folder .. path_sep&#xA;  end&#xA;end&#xA;&#xA;local function check_folders_contains(folders, path)&#xA;  for _, folder in pairs(folders) do&#xA;    if is_sub_path(path, folder.name) then&#xA;      return true&#xA;    end&#xA;  end&#xA;  return false&#xA;end&#xA;&#xA;local function match_file_operation_filter(filter, name, type)&#xA;  if filter.scheme and filter.scheme ~= &#34;file&#34; then&#xA;    -- we do not support uri scheme other than file&#xA;    return false&#xA;  end&#xA;  local pattern = filter.pattern&#xA;  local matches = pattern.matches&#xA;&#xA;  if type ~= matches then&#xA;    return false&#xA;  end&#xA;&#xA;  local regex_str = vim.fn.glob2regpat(pattern.glob)&#xA;  if vim.tbl_get(pattern, &#34;options&#34;, &#34;ignoreCase&#34;) then&#xA;    regex_str = &#34;\\c&#34; .. regex_str&#xA;  end&#xA;  return vim.regex(regex_str):match_str(name) ~= nil&#xA;end&#xA;&#xA;local api = require(&#34;nvim-tree.api&#34;)&#xA;api.events.subscribe(api.events.Event.NodeRenamed, function(data)&#xA;  local stat = vim.loop.fs_stat(data.new_name)&#xA;  if not stat then&#xA;    return&#xA;  end&#xA;  local type = ({ file = &#34;file&#34;, directory = &#34;folder&#34; })[stat.type]&#xA;  local clients = vim.lsp.get_clients({})&#xA;  for _, client in ipairs(clients) do&#xA;    if check_folders_contains(client.workspace_folders, data.old_name) then&#xA;      local filters = vim.tbl_get(client.server_capabilities, &#34;workspace&#34;, &#34;fileOperations&#34;, &#34;didRename&#34;, &#34;filters&#34;)&#xA;        or {}&#xA;      for _, filter in pairs(filters) do&#xA;        if&#xA;          match_file_operation_filter(filter, data.old_name, type)&#xA;          and match_file_operation_filter(filter, data.new_name, type)&#xA;        then&#xA;          client.notify(&#xA;            &#34;workspace/didRenameFiles&#34;,&#xA;            { files = { { oldUri = uri_from_path(data.old_name), newUri = uri_from_path(data.new_name) } } }&#xA;          )&#xA;        end&#xA;      end&#xA;    end&#xA;  end&#xA;end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jose-elias-alvarez/typescript.nvim&#34;&gt;typescript.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pmizio/typescript-tools.nvim&#34;&gt;typescript-tools.nvim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>folke/ts-comments.nvim</title>
    <updated>2024-06-01T01:32:30Z</updated>
    <id>tag:github.com,2024-06-01:/folke/ts-comments.nvim</id>
    <link href="https://github.com/folke/ts-comments.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Tiny plugin to enhance Neovim&#39;s native comments&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;🚀 &lt;code&gt;ts-comments.nvim&lt;/code&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Tiny plugin to enhance Neovim&#39;s native comments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Easily override the comment string for a given &lt;strong&gt;treesitter&lt;/strong&gt; language&lt;/li&gt; &#xA; &lt;li&gt;Supports different comment strings for different &lt;strong&gt;treesitter&lt;/strong&gt; node types&lt;/li&gt; &#xA; &lt;li&gt;Relaxed rules for uncommenting&lt;/li&gt; &#xA; &lt;li&gt;Add proper whitespace when needed&lt;/li&gt; &#xA; &lt;li&gt;Supports multiple commentstrings for the same language. The first one is used for adding comments. All are used for uncommenting.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;⚡️ Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Neovim &amp;gt;= 0.10.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;📦 Installation&lt;/h2&gt; &#xA;&lt;p&gt;Using &lt;a href=&#34;https://github.com/folke/lazy.nvim&#34;&gt;lazy.nvim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  &#34;folke/ts-comments.nvim&#34;,&#xA;  opts = {},&#xA;  event = &#34;VeryLazy&#34;,&#xA;  enabled = vim.fn.has(&#34;nvim-0.10.0&#34;) == 1,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;⚙️ Configuration&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;ts-comments.nvim&lt;/strong&gt; uses the default Neovim &lt;code&gt;commentstring&lt;/code&gt; as a fallback, so there&#39;s no need to configure every language.&lt;/p&gt; &#xA;&lt;p&gt;Default configuration:&lt;/p&gt; &#xA;&lt;!-- config:start --&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  lang = {&#xA;    astro = &#34;&amp;lt;!-- %s --&amp;gt;&#34;,&#xA;    axaml = &#34;&amp;lt;!-- %s --&amp;gt;&#34;,&#xA;    blueprint = &#34;// %s&#34;,&#xA;    c = &#34;// %s&#34;,&#xA;    c_sharp = &#34;// %s&#34;,&#xA;    clojure = { &#34;;; %s&#34;, &#34;; %s&#34; },&#xA;    cpp = &#34;// %s&#34;,&#xA;    cs_project = &#34;&amp;lt;!-- %s --&amp;gt;&#34;,&#xA;    cue = &#34;// %s&#34;,&#xA;    fsharp = &#34;// %s&#34;,&#xA;    fsharp_project = &#34;&amp;lt;!-- %s --&amp;gt;&#34;,&#xA;    gleam = &#34;// %s&#34;,&#xA;    glimmer = &#34;{{! %s }}&#34;,&#xA;    graphql = &#34;# %s&#34;,&#xA;    handlebars = &#34;{{! %s }}&#34;,&#xA;    hcl = &#34;# %s&#34;,&#xA;    html = &#34;&amp;lt;!-- %s --&amp;gt;&#34;,&#xA;    hyprlang = &#34;# %s&#34;,&#xA;    ini = &#34;; %s&#34;,&#xA;    javascript = {&#xA;      &#34;// %s&#34;, -- default commentstring when no treesitter node matches&#xA;      &#34;/* %s */&#34;,&#xA;      call_expression = &#34;// %s&#34;, -- specific commentstring for call_expression&#xA;      jsx_attribute = &#34;// %s&#34;,&#xA;      jsx_element = &#34;{/* %s */}&#34;,&#xA;      jsx_fragment = &#34;{/* %s */}&#34;,&#xA;      spread_element = &#34;// %s&#34;,&#xA;      statement_block = &#34;// %s&#34;,&#xA;    },&#xA;    php = &#34;// %s&#34;,&#xA;    rego = &#34;# %s&#34;,&#xA;    rescript = &#34;// %s&#34;,&#xA;    rust = { &#34;// %s&#34;, &#34;/* %s */&#34; },&#xA;    sql = &#34;-- %s&#34;,&#xA;    svelte = &#34;&amp;lt;!-- %s --&amp;gt;&#34;,&#xA;    terraform = &#34;# %s&#34;,&#xA;    tsx = {&#xA;      &#34;// %s&#34;, -- default commentstring when no treesitter node matches&#xA;      &#34;/* %s */&#34;,&#xA;      call_expression = &#34;// %s&#34;, -- specific commentstring for call_expression&#xA;      jsx_attribute = &#34;// %s&#34;,&#xA;      jsx_element = &#34;{/* %s */}&#34;,&#xA;      jsx_fragment = &#34;{/* %s */}&#34;,&#xA;      spread_element = &#34;// %s&#34;,&#xA;      statement_block = &#34;// %s&#34;,&#xA;    },&#xA;    twig = &#34;{# %s #}&#34;,&#xA;    typescript = { &#34;// %s&#34;, &#34;/* %s */&#34; }, -- langs can have multiple commentstrings&#xA;    vue = &#34;&amp;lt;!-- %s --&amp;gt;&#34;,&#xA;    xaml = &#34;&amp;lt;!-- %s --&amp;gt;&#34;,&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;!-- config:end --&gt; &#xA;&lt;h2&gt;🔗 Related&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/JoosepAlviste/nvim-ts-context-commentstring&#34;&gt;nvim-ts-context-commentstring&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>typecraft-dev/dotfiles</title>
    <updated>2024-06-01T01:32:30Z</updated>
    <id>tag:github.com,2024-06-01:/typecraft-dev/dotfiles</id>
    <link href="https://github.com/typecraft-dev/dotfiles" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>