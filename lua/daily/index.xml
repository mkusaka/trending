<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-29T01:40:31Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>edubart/nelua-lang</title>
    <updated>2023-01-29T01:40:31Z</updated>
    <id>tag:github.com,2023-01-29:/edubart/nelua-lang</id>
    <link href="https://github.com/edubart/nelua-lang" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Minimal, efficient, statically-typed and meta-programmable systems programming language heavily inspired by Lua, which compiles to C and native code.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://nelua.io/assets/img/nelua-logo-64px.png&#34; alt=&#34;Nelua Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://nelua.io/&#34;&gt;nelua.io&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/edubart/nelua-lang/actions&#34;&gt;&lt;img src=&#34;https://github.com/edubart/nelua-lang/workflows/test/badge.svg?sanitize=true&#34; alt=&#34;Test Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/7aaGeG7&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/680417078959800322.svg?sanitize=true&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Nelua (stands for &lt;strong&gt;N&lt;/strong&gt;ative &lt;strong&gt;E&lt;/strong&gt;xtensible &lt;strong&gt;Lua&lt;/strong&gt;) is a minimal, efficient, statically-typed and meta-programmable systems programming language heavily inspired by Lua, which compiles to C and native code.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The language is in alpha state and still evolving.&lt;/p&gt; &#xA;&lt;h2&gt;Quick start&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For basic information check the &lt;a href=&#34;https://nelua.io/&#34;&gt;Website&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;For first steps and how to use Nelua, start at the &lt;a href=&#34;https://nelua.io/tutorial/&#34;&gt;Tutorial&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;For a tour of the language&#39;s syntax, features and usage read the &lt;a href=&#34;https://nelua.io/overview/&#34;&gt;Overview&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;For small examples written in Nelua look the &lt;a href=&#34;https://raw.githubusercontent.com/edubart/nelua-lang/master/examples&#34;&gt;Examples&lt;/a&gt; folder .&lt;/li&gt; &#xA; &lt;li&gt;For questions and discussions go to the &lt;a href=&#34;https://github.com/edubart/nelua-lang/discussions&#34;&gt;Discussions&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;For a chat with the community join the &lt;a href=&#34;https://discord.gg/7aaGeG7&#34;&gt;Discord server&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;For cool stuff made with Nelua check &lt;a href=&#34;https://github.com/AKDev21/awesome-nelua&#34;&gt;Awesome Nelua&lt;/a&gt; repository and &lt;code&gt;#showcase&lt;/code&gt; channel in the Discord server.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After installing, you might want to check out the featured example, a Snake game leveraging the famous &lt;a href=&#34;https://www.libsdl.org&#34;&gt;SDL2&lt;/a&gt; library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nelua examples/snakesdl.nelua&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;Nelua is a &lt;a href=&#34;https://en.wikipedia.org/wiki/System_programming_language&#34;&gt;systems programming language&lt;/a&gt; for performance-sensitive applications where &lt;a href=&#34;https://en.wikipedia.org/wiki/Lua_(programming_language)&#34;&gt;Lua&lt;/a&gt; would not be efficient, such as operating systems, real-time applications and game engines. While it has syntax and semantics similar to Lua, it primarily focuses on generating efficient C code and provide support for highly-optimizable low-level programming. Using Nelua idioms such as records, arrays, manual memory management and pointers should result in performance as efficient as pure C; on the other hand, when using Lua idioms such as tables, metatables and untyped variables, the compiler will bake a runtime library for this sort of dynamic functionality into the program, which could incur some runtime overhead.&lt;/p&gt; &#xA;&lt;p&gt;Nelua can do &lt;a href=&#34;https://en.wikipedia.org/wiki/Metaprogramming&#34;&gt;meta programming&lt;/a&gt; at compile time through preprocessor constructs written in Lua; since the compiler itself is also written in Lua, it means that user-provided preprocessor code can interact at any point with the compiler&#39;s internals and the source code&#39;s &lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;AST&lt;/a&gt;. Such system allows for ad-hoc implementation of high level constructs such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Class_(computer_programming)&#34;&gt;classes&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Generic_programming&#34;&gt;generics&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Polymorphism_(computer_science)&#34;&gt;polymorphism&lt;/a&gt;, all without having to add them into the core specification, thus keeping the language simple, extensible and compact. The same way that Lua&#39;s object-oriented patterns are not built into the language, but can be nonetheless achieved through &lt;a href=&#34;https://webserver2.tecgraf.puc-rio.br/lua/local/pil/13.html&#34;&gt;metatables&lt;/a&gt;, in Nelua you could yourself implement a similar functionality which is fully decided at compile time or dynamically dispatched at runtime.&lt;/p&gt; &#xA;&lt;p&gt;Nelua can do &lt;a href=&#34;https://en.wikipedia.org/wiki/Extensible_programming&#34;&gt;extensible programming&lt;/a&gt; as the programmer may add extensions to the language such as new grammars, &lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;AST&lt;/a&gt; definitions, semantics, type checkers, code generation and behaviors to the compiler at compile time via the preprocessor.&lt;/p&gt; &#xA;&lt;p&gt;Nelua provides support for both &lt;a href=&#34;https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&#34;&gt;garbage-collected&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Manual_memory_management&#34;&gt;manual&lt;/a&gt; memory management in a way that the developer can easily choose between using garbage collection, or completely disabling garbage collection, or mixing both.&lt;/p&gt; &#xA;&lt;p&gt;Nelua first compiles to &lt;a href=&#34;https://en.wikipedia.org/wiki/C_(programming_language)&#34;&gt;C&lt;/a&gt;, then it executes a C compiler to produce &lt;a href=&#34;https://en.wikipedia.org/wiki/Machine_code&#34;&gt;native code&lt;/a&gt;. This way existing C code and libraries can be leveraged and new C libraries can be created. Another benefit is that Nelua can reach the same target platforms as C99 compilers, such &lt;a href=&#34;https://en.wikipedia.org/wiki/GNU_Compiler_Collection&#34;&gt;GCC&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/Clang&#34;&gt;Clang&lt;/a&gt;, while also enjoying state-of-the-art compiler optimizations provided by them.&lt;/p&gt; &#xA;&lt;p&gt;The initial motivation for its creation was to replace C/C++ parts of projects which currently uses Lua with a language that has syntax and semantics similar to Lua, but allows for fine-grained performance optimizations and does not lose the ability to go low level, therefore unifying the syntax and semantics across both compiled and dynamic languages.&lt;/p&gt; &#xA;&lt;h2&gt;Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Be minimal with a small syntax, manual and API, but powerful&lt;/li&gt; &#xA; &lt;li&gt;Be efficient by compiling to optimized C code then native code&lt;/li&gt; &#xA; &lt;li&gt;Have syntax, semantics and features similar to Lua&lt;/li&gt; &#xA; &lt;li&gt;Optionally statically typed with type checking&lt;/li&gt; &#xA; &lt;li&gt;Achieve classes, generics, polymorphism and other higher constructs by meta programming&lt;/li&gt; &#xA; &lt;li&gt;Have an optional garbage collector&lt;/li&gt; &#xA; &lt;li&gt;Make possible to create clean DSLs by extending the language grammar&lt;/li&gt; &#xA; &lt;li&gt;Make programming safe for non experts by doing run/compile-time checks and avoiding undefined behavior&lt;/li&gt; &#xA; &lt;li&gt;Possibility to emit low level code (C, assembly)&lt;/li&gt; &#xA; &lt;li&gt;Be modular and make users capable of creating compiler plugins to extended&lt;/li&gt; &#xA; &lt;li&gt;Generate readable, simple and efficient C code&lt;/li&gt; &#xA; &lt;li&gt;Possibility to output freestanding code (dependency free, for kernel dev or minimal runtime)&lt;/li&gt; &#xA; &lt;li&gt;No single memory management model, choose for your use case GC or manual&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Why?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We love to script in Lua.&lt;/li&gt; &#xA; &lt;li&gt;We love C performance.&lt;/li&gt; &#xA; &lt;li&gt;We want best of both worlds in a single language and with a unified syntax.&lt;/li&gt; &#xA; &lt;li&gt;We want to reuse or mix existing C/C++/Lua code.&lt;/li&gt; &#xA; &lt;li&gt;We want type safety and optimizations.&lt;/li&gt; &#xA; &lt;li&gt;We want to have efficient code while maintaining readability and safety.&lt;/li&gt; &#xA; &lt;li&gt;We want the language features and manual to be minimal and fit our brain.&lt;/li&gt; &#xA; &lt;li&gt;We want to deploy anywhere C runs.&lt;/li&gt; &#xA; &lt;li&gt;We want to extended the language features by meta programming or modding the compiler.&lt;/li&gt; &#xA; &lt;li&gt;We want to code with or without garbage collection depending on our use case.&lt;/li&gt; &#xA; &lt;li&gt;We want to abuse of static dispatch instead of dynamic dispatch to gain performance and correctness.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;You can support or contribute to Nelua in many ways, giving the project a star on github, testing out its features, reporting bugs, discussing ideas, helping other users, spreading it to the world, sharing projects made with it on github, creating tutorials or blog posts, improving its documentation or through a &lt;a href=&#34;https://patreon.com/edubart&#34;&gt;donation or sponsorship&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Nelua is open source, but not very open to contributions in the form of pull requests, if you would like something fixed or implemented in the core language try first submitting a bug report or opening a discussion instead of doing a PR. The authors prefer it this way, so that the ideal solution is always provided, without unwanted consequences on the project, thus keeping the quality of the software.&lt;/p&gt; &#xA;&lt;p&gt;Read more about contributing in the &lt;a href=&#34;https://github.com/edubart/nelua-lang/raw/master/CONTRIBUTING.md&#34;&gt;contributing page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.patreon.com/edubart&#34;&gt;&lt;img src=&#34;https://c5.patreon.com/external/logo/become_a_patron_button.png&#34; alt=&#34;Become a Patron&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT License&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>boltlessengineer/bufterm.nvim</title>
    <updated>2023-01-29T01:40:31Z</updated>
    <id>tag:github.com,2023-01-29:/boltlessengineer/bufterm.nvim</id>
    <link href="https://github.com/boltlessengineer/bufterm.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A neovim plugin to manage terminal buffers&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;bufterm.nvim&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Treat terminals as buffers, not windows.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;A neovim plugin to manage terminal buffers&lt;/p&gt; &#xA;&lt;h2&gt;Thoughts&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;No need to open terminal buffer in new specific window every time.&lt;/li&gt; &#xA; &lt;li&gt;User should able to &lt;em&gt;enter&lt;/em&gt; terminal buffers in &lt;em&gt;any window&lt;/em&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Other terminal plugins are great but it is hard to manually set terminal buffer to window layout user wants.&lt;/p&gt; &#xA;&lt;p&gt;BufTerm NEVER create terminal window on it&#39;s own. It only gives you &lt;code&gt;enter()&lt;/code&gt; function to enter terminal buffer. User can always manually close buffer with &lt;code&gt;:bdelete!&lt;/code&gt; and window with &lt;code&gt;:close&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/60088301/214899478-956b4223-c25a-47d7-99db-376d4fa94fd1.mov&#34;&gt;https://user-images.githubusercontent.com/60088301/214899478-956b4223-c25a-47d7-99db-376d4fa94fd1.mov&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Enter &amp;amp; Switch Terminal buffers&lt;/h3&gt; &#xA;&lt;p&gt;You can enter terminal buffer in &lt;em&gt;any&lt;/em&gt; windows. Just enter the window you want, and run &lt;code&gt;:BufTermEnter&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can also cycle through terminal buffers with &lt;code&gt;:BufTermNext&lt;/code&gt; and &lt;code&gt;:BufTermPrev&lt;/code&gt; commads.&lt;/p&gt; &#xA;&lt;h3&gt;Vim8-like Window navigation&lt;/h3&gt; &#xA;&lt;p&gt;Automatically restore the last mode when leaving the terminal buffer.&lt;/p&gt; &#xA;&lt;p&gt;Window navigation using &lt;code&gt;&amp;lt;C-w&amp;gt;&lt;/code&gt; key directly in terminal mode just like vim8.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt; Don&#39;t use keymap &lt;code&gt;&amp;lt;C-\&amp;gt;&amp;lt;C-n&amp;gt;&amp;lt;C-w&amp;gt;...&lt;/code&gt; or &lt;code&gt;&amp;lt;C-\&amp;gt;&amp;lt;C-o&amp;gt;&amp;lt;C-w&amp;gt;...&lt;/code&gt; for window navigation. This will break &lt;code&gt;remember_mode&lt;/code&gt; feature. Instead, use &lt;code&gt;:wincmd&lt;/code&gt; or &lt;code&gt;enable_ctrl_w&lt;/code&gt; option below.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Compatible with native commands&lt;/h3&gt; &#xA;&lt;p&gt;Although BufTerm provides various useful commands, you can still use Neovim&#39;s native commands like &lt;code&gt;:terminal&lt;/code&gt;, &lt;code&gt;:buffer&lt;/code&gt;, &lt;code&gt;:bprev&lt;/code&gt;, &lt;code&gt;:wincmd&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Using packer.nvim&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use {&#xA;  &#39;boltlessengineer/bufterm.nvim&#39;,&#xA;  config = function()&#xA;    require(&#39;bufterm&#39;).setup()&#xA;  end,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;Below is default configuration&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;bufterm&#39;).setup({&#xA;  save_native_terms = true, -- integrate native terminals from `:terminal` command&#xA;  start_in_insert   = true, -- start terminal in insert mode&#xA;  remember_mode     = true, -- remember vi_mode of terminal buffer&#xA;  enable_ctrl_w     = true, -- use &amp;lt;C-w&amp;gt; for window navigating in terminal mode (like vim8)&#xA;  terminal = {              -- default terminal settings&#xA;    buflisted         = false, -- whether to set &#39;buflisted&#39; option&#xA;    fallback_on_exit  = true,  -- prevent auto-closing window on terminal exit&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;fallback_on_exit&lt;/code&gt; option won&#39;t work with &lt;code&gt;:bdelete!&lt;/code&gt; command&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Enter terminal buffers in current window with &lt;code&gt;:BufTermEnter&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Open new terminal buffer with &lt;code&gt;:terminal&lt;/code&gt; or &lt;code&gt;:BufTermEnter&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Switch between terminal buffers with &lt;code&gt;:BufTermNext&lt;/code&gt; and &lt;code&gt;:BufTermPrev&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;:BufTermEnter&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Enter terminal buffer in current window. Create new terminal buffer if there is no terminal buffer running&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;:BufTermPrev&lt;/code&gt;, &lt;code&gt;:BufTermNext&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Cycle through list of terminal buffers&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;Terminal:new(term)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Create new &lt;code&gt;Terminal&lt;/code&gt; object. See the &lt;a href=&#34;https://raw.githubusercontent.com/boltlessengineer/bufterm.nvim/main/#Examples&#34;&gt;examples&lt;/a&gt; below.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;Terminal:spawn()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Spawn the terminal buffer. This will spawn new terminal job and create the buffer for it. But not showing the actual buffer in window yet.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;Terminal:enter(window)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Open terminal buffer in specific window.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Open Lazygit in floating window&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- this will add Terminal to the list (not starting job yet)&#xA;local Terminal = require(&#39;bufterm.terminal&#39;).Terminal&#xA;local ui       = require(&#39;bufterm.ui&#39;)&#xA;&#xA;local lazygit = Terminal:new({&#xA;  cmd = &#39;lazygit&#39;,&#xA;  buflisted = false,&#xA;  termlisted = false, -- set this option to false if you treat this terminal as single independent terminal&#xA;})&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;leader&amp;gt;g&#39;, function()&#xA;  -- spawn terminal (terminal won&#39;t be spawned if self.jobid is valid)&#xA;  lazygit:spawn()&#xA;  -- open floating window&#xA;  ui.toggle_float(lazygit.bufnr)&#xA;end, {&#xA;  desc = &#39;Open lazygit in floating window&#39;,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Toggle Floating terminal&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local term = require(&#39;bufterm.terminal&#39;)&#xA;local ui   = require(&#39;bufterm.ui&#39;)&#xA;&#xA;vim.keymap.set({ &#39;n&#39;, &#39;t&#39; }, &#39;&amp;lt;C-t&amp;gt;&#39;, function()&#xA;  local recent_term = term.get_recent_term()&#xA;  ui.toggle_float(recent_term.bufnr)&#xA;end, {&#xA;  desc = &#39;Toggle floating window with terminal buffers&#39;,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Inspirations&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/akinsho/toggleterm.nvim&#34;&gt;toggleterm.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/anuvyklack/hydra.nvim&#34;&gt;hydra.nvim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>NvChad/example_config</title>
    <updated>2023-01-29T01:40:31Z</updated>
    <id>tag:github.com,2023-01-29:/NvChad/example_config</id>
    <link href="https://github.com/NvChad/example_config" rel="alternate"></link>
    <summary type="html">&lt;p&gt;example custom config&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>