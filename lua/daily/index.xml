<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-10T01:36:27Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>willothy/nvim-cokeline</title>
    <updated>2024-01-10T01:36:27Z</updated>
    <id>tag:github.com,2024-01-10:/willothy/nvim-cokeline</id>
    <link href="https://github.com/willothy/nvim-cokeline" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üëÉ A Neovim bufferline for people with addictive personalities&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt; üëÉ nvim-cokeline &lt;/h1&gt; &#xA;&lt;!-- panvimdoc-include-comment &lt;br&gt; --&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;i&gt;A Neovim bufferline for people with addictive personalities&lt;/i&gt; &lt;/p&gt; &#xA;&lt;!-- panvimdoc-include-comment &lt;br&gt; --&gt; &#xA;&lt;p&gt;The goal of this plugin is not to be an opinionated bufferline with (more or less) limited customization options. Rather, it tries to provide a general framework allowing you to build &lt;strong&gt;&lt;em&gt;your&lt;/em&gt;&lt;/strong&gt; ideal bufferline, whatever that might look like.&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-start --&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/38540736/226447816-c696153f-ccee-4e4a-8b6a-55e53ee737f8.png&#34; alt=&#34;preview&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;üìñ&lt;/span&gt; Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willothy/nvim-cokeline/main/#sparkles-features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willothy/nvim-cokeline/main/#electric_plug-requirements&#34;&gt;Requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willothy/nvim-cokeline/main/#package-installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willothy/nvim-cokeline/main/#wrench-configuration&#34;&gt;Configuration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willothy/nvim-cokeline/main/#musical_keyboard-mappings&#34;&gt;Mappings&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- panvimdoc-ignore-end --&gt; &#xA;&lt;h2&gt;&lt;span&gt;‚ú®&lt;/span&gt; Features&lt;/h2&gt; &#xA;&lt;h3&gt;Endlessly customizable&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;nvim-cokeline&lt;/code&gt; aims to be the most customizable bufferline plugin around. If you have an idea in mind of what your bufferline should look like, you should be able to make it look that way. If you can&#39;t, open an issue and we&#39;ll try to make it happen!&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-start --&gt; &#xA;&lt;p&gt;Here&#39;s a (very limited) showcase of what it can be configured to look like (check out the wiki for more examples):&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to see configuration&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local get_hex = require(&#39;cokeline.hlgroups&#39;).get_hl_attr&#xA;&#xA;require(&#39;cokeline&#39;).setup({&#xA;  default_hl = {&#xA;    fg = function(buffer)&#xA;      return&#xA;        buffer.is_focused&#xA;        and get_hex(&#39;ColorColumn&#39;, &#39;bg&#39;)&#xA;         or get_hex(&#39;Normal&#39;, &#39;fg&#39;)&#xA;    end,&#xA;    bg = function(buffer)&#xA;      return&#xA;        buffer.is_focused&#xA;        and get_hex(&#39;Normal&#39;, &#39;fg&#39;)&#xA;         or get_hex(&#39;ColorColumn&#39;, &#39;bg&#39;)&#xA;    end,&#xA;  },&#xA;&#xA;  components = {&#xA;    {&#xA;      text = function(buffer) return &#39; &#39; .. buffer.devicon.icon end,&#xA;      fg = function(buffer) return buffer.devicon.color end,&#xA;    },&#xA;    {&#xA;      text = function(buffer) return buffer.unique_prefix end,&#xA;      fg = get_hex(&#39;Comment&#39;, &#39;fg&#39;),&#xA;      italic = true&#xA;    },&#xA;    {&#xA;      text = function(buffer) return buffer.filename .. &#39; &#39; end,&#xA;      underline = function(buffer)&#xA;        return buffer.is_hovered and not buffer.is_focused&#xA;      end&#xA;    },&#xA;    {&#xA;      text = &#39;Ôôï&#39;,&#xA;      on_click = function(_, _, _, _, buffer)&#xA;        buffer:delete()&#xA;      end&#xA;    },&#xA;    {&#xA;      text = &#39; &#39;,&#xA;    }&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/38540736/226447806-0d4be251-788e-495c-abf7-ae5041dcc702.png&#34; alt=&#34;cokeline-default&#34;&gt;&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to see configuration&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local get_hex = require(&#39;cokeline.hlgroups&#39;).get_hl_attr&#xA;&#xA;local green = vim.g.terminal_color_2&#xA;local yellow = vim.g.terminal_color_3&#xA;&#xA;require(&#39;cokeline&#39;).setup({&#xA;  default_hl = {&#xA;    fg = function(buffer)&#xA;      return&#xA;        buffer.is_focused&#xA;        and get_hex(&#39;Normal&#39;, &#39;fg&#39;)&#xA;         or get_hex(&#39;Comment&#39;, &#39;fg&#39;)&#xA;    end,&#xA;    bg = get_hex(&#39;ColorColumn&#39;, &#39;bg&#39;),&#xA;  },&#xA;&#xA;  components = {&#xA;    {&#xA;      text = &#39;ÔΩú&#39;,&#xA;      fg = function(buffer)&#xA;        return&#xA;          buffer.is_modified and yellow or green&#xA;      end&#xA;    },&#xA;    {&#xA;      text = function(buffer) return buffer.devicon.icon .. &#39; &#39; end,&#xA;      fg = function(buffer) return buffer.devicon.color end,&#xA;    },&#xA;    {&#xA;      text = function(buffer) return buffer.index .. &#39;: &#39; end,&#xA;    },&#xA;    {&#xA;      text = function(buffer) return buffer.unique_prefix end,&#xA;      fg = get_hex(&#39;Comment&#39;, &#39;fg&#39;),&#xA;      italic = true,&#xA;    },&#xA;    {&#xA;      text = function(buffer) return buffer.filename .. &#39; &#39; end,&#xA;      bold = function(buffer) return buffer.is_focused end,&#xA;    },&#xA;    {&#xA;      text = &#39; &#39;,&#xA;    },&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/38540736/226447808-fc834732-efd1-4fd1-a0de-65ebea213d3f.png&#34; alt=&#34;cokeline-noib3&#34;&gt;&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to see configuration&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local get_hex = require(&#39;cokeline.hlgroups&#39;).get_hl_attr&#xA;&#xA;require(&#39;cokeline&#39;).setup({&#xA;  default_hl = {&#xA;    fg = function(buffer)&#xA;      return&#xA;        buffer.is_focused&#xA;        and get_hex(&#39;Normal&#39;, &#39;fg&#39;)&#xA;         or get_hex(&#39;Comment&#39;, &#39;fg&#39;)&#xA;    end,&#xA;    bg = &#39;NONE&#39;,&#xA;  },&#xA;  components = {&#xA;    {&#xA;      text = function(buffer) return (buffer.index ~= 1) and &#39;‚ñè&#39; or &#39;&#39; end,&#xA;      fg = function() return get_hex(&#39;Normal&#39;, &#39;fg&#39;) end&#xA;    },&#xA;    {&#xA;      text = function(buffer) return &#39;    &#39; .. buffer.devicon.icon end,&#xA;      fg = function(buffer) return buffer.devicon.color end,&#xA;    },&#xA;    {&#xA;      text = function(buffer) return buffer.filename .. &#39;    &#39; end,&#xA;      bold = function(buffer) return buffer.is_focused end&#xA;    },&#xA;    {&#xA;      text = &#39;Û∞ñ≠&#39;,&#xA;      on_click = function(_, _, _, _, buffer)&#xA;        buffer:delete()&#xA;      end&#xA;    },&#xA;    {&#xA;      text = &#39;  &#39;,&#xA;    },&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/38540736/226447803-13f3d3ee-454f-42be-81b4-9254f95503e4.png&#34; alt=&#34;cokeline-bufferline-lua&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-end --&gt; &#xA;&lt;h3&gt;Dynamic rendering&lt;/h3&gt; &#xA;&lt;!-- ### Dynamic rendering (with sliders) --&gt; &#xA;&lt;p&gt;Even when you have a lot of buffers open, &lt;code&gt;nvim-cokeline&lt;/code&gt; is rendered to always keep the focused buffer visible and in the middle of the bufferline. Also, if a buffer doesn&#39;t fit entirely we still try to include as much of it as possible before cutting off the rest.&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-start --&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/38540736/226447817-4f3679c8-a10a-48ad-8329-b21c3ee54968.gif&#34; alt=&#34;rendering&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-end --&gt; &#xA;&lt;h3&gt;LSP support&lt;/h3&gt; &#xA;&lt;p&gt;If a buffer has an LSP client attached to it, you can configure the style of a component to change based on how many errors, warnings, infos and hints are reported by the LSP.&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-start --&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/38540736/226447813-4ec42530-9e86-43f5-98ed-fd7b4012120b.gif&#34; alt=&#34;lsp-styling&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-end --&gt; &#xA;&lt;h3&gt;Buffer pick&lt;/h3&gt; &#xA;&lt;p&gt;You can focus and close any buffer by typing its &lt;code&gt;pick_letter&lt;/code&gt;. Letters are assigned by filename by default (e.g. &lt;code&gt;foo.txt&lt;/code&gt; gets the letter &lt;code&gt;f&lt;/code&gt;), and by keyboard reachability if the letter is already assigned to another buffer.&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-start --&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to see configuration&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local is_picking_focus = require(&#39;cokeline.mappings&#39;).is_picking_focus&#xA;local is_picking_close = require(&#39;cokeline.mappings&#39;).is_picking_close&#xA;local get_hex = require(&#39;cokeline.hlgroups&#39;).get_hl_attr&#xA;&#xA;local red = vim.g.terminal_color_1&#xA;local yellow = vim.g.terminal_color_3&#xA;&#xA;require(&#39;cokeline&#39;).setup({&#xA;  default_hl = {&#xA;    fg = function(buffer)&#xA;      return&#xA;        buffer.is_focused&#xA;        and get_hex(&#39;Normal&#39;, &#39;fg&#39;)&#xA;         or get_hex(&#39;Comment&#39;, &#39;fg&#39;)&#xA;    end,&#xA;    bg = function() return get_hex(&#39;ColorColumn&#39;, &#39;bg&#39;) end,&#xA;  },&#xA;&#xA;  components = {&#xA;    {&#xA;      text = function(buffer) return (buffer.index ~= 1) and &#39;‚ñè&#39; or &#39;&#39; end,&#xA;    },&#xA;    {&#xA;      text = &#39;  &#39;,&#xA;    },&#xA;    {&#xA;      text = function(buffer)&#xA;        return&#xA;          (is_picking_focus() or is_picking_close())&#xA;          and buffer.pick_letter .. &#39; &#39;&#xA;           or buffer.devicon.icon&#xA;      end,&#xA;      fg = function(buffer)&#xA;        return&#xA;          (is_picking_focus() and yellow)&#xA;          or (is_picking_close() and red)&#xA;          or buffer.devicon.color&#xA;      end,&#xA;      italic = function()&#xA;        return&#xA;          (is_picking_focus() or is_picking_close())&#xA;      end,&#xA;      bold = function()&#xA;        return&#xA;          (is_picking_focus() or is_picking_close())&#xA;      end&#xA;    },&#xA;    {&#xA;      text = &#39; &#39;,&#xA;    },&#xA;    {&#xA;      text = function(buffer) return buffer.filename .. &#39;  &#39; end,&#xA;      bold = function(buffer) return buffer.is_focused end,&#xA;    },&#xA;    {&#xA;      text = &#39;Ôôï&#39;,&#xA;      on_click = function(_, _, _, _, buffer)&#xA;        buffer:delete()&#xA;      end,&#xA;    },&#xA;    {&#xA;      text = &#39;  &#39;,&#xA;    },&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/38540736/226447793-8e2341b3-e454-49dc-af84-72d3b56f40d3.gif&#34; alt=&#34;buffer-pick&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-end --&gt; &#xA;&lt;h3&gt;Sidebars&lt;/h3&gt; &#xA;&lt;p&gt;You can add a left sidebar to integrate nicely with file explorer plugins like &lt;a href=&#34;https://github.com/nvim-tree/nvim-tree.lua&#34;&gt;nvim-tree.lua&lt;/a&gt;, &lt;a href=&#34;https://github.com/ms-jpq/chadtree&#34;&gt;CHADTree&lt;/a&gt; or &lt;a href=&#34;https://github.com/preservim/nerdtree&#34;&gt;NERDTree&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-start --&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to see configuration&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local get_hex = require(&#39;cokeline.hlgroups&#39;).get_hl_attr&#xA;&#xA;local yellow = vim.g.terminal_color_3&#xA;&#xA;require(&#39;cokeline&#39;).setup({&#xA;  default_hl = {&#xA;    fg = function(buffer)&#xA;      return&#xA;        buffer.is_focused&#xA;        and get_hex(&#39;Normal&#39;, &#39;fg&#39;)&#xA;         or get_hex(&#39;Comment&#39;, &#39;fg&#39;)&#xA;    end,&#xA;    bg = function() return get_hex(&#39;ColorColumn&#39;, &#39;bg&#39;) end,&#xA;  },&#xA;&#xA;  sidebar = {&#xA;    filetype = {&#39;NvimTree&#39;, &#39;neo-tree&#39;},&#xA;    components = {&#xA;      {&#xA;        text = function(buf)&#xA;          return buf.filetype&#xA;        end,&#xA;        fg = yellow,&#xA;        bg = function() return get_hex(&#39;NvimTreeNormal&#39;, &#39;bg&#39;) end,&#xA;        bold = true,&#xA;      },&#xA;    }&#xA;  },&#xA;&#xA;  components = {&#xA;    {&#xA;      text = function(buffer) return (buffer.index ~= 1) and &#39;‚ñè&#39; or &#39;&#39; end,&#xA;    },&#xA;    {&#xA;      text = &#39;  &#39;,&#xA;    },&#xA;    {&#xA;      text = function(buffer)&#xA;        return buffer.devicon.icon&#xA;      end,&#xA;      fg = function(buffer)&#xA;        return buffer.devicon.color&#xA;      end,&#xA;    },&#xA;    {&#xA;      text = &#39; &#39;,&#xA;    },&#xA;    {&#xA;      text = function(buffer) return buffer.filename .. &#39;  &#39; end,&#xA;      bold = function(buffer)&#xA;        return buffer.is_focused&#xA;      end,&#xA;    },&#xA;    {&#xA;      text = &#39;Ôôï&#39;,&#xA;      on_click = function(_, _, _, _, buffer)&#xA;        buffer:delete()&#xA;      end,&#xA;    },&#xA;    {&#xA;      text = &#39;  &#39;,&#xA;    },&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/38540736/226447821-de543b87-909c-445f-ac6e-82f5f6bbf9aa.png&#34; alt=&#34;sidebars&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-end --&gt; &#xA;&lt;h3&gt;Unique buffer names&lt;/h3&gt; &#xA;&lt;p&gt;When files with the same filename belonging to different directories are opened simultaneously, you can include a unique filetree prefix to distinguish between them:&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-start --&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/38540736/226447822-3315ad2f-35c9-4fc3-a777-c01cd8f2fe46.gif&#34; alt=&#34;unique-prefix&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-end --&gt; &#xA;&lt;h3&gt;Clickable buffers&lt;/h3&gt; &#xA;&lt;p&gt;Left click on a buffer to focus it, and right click to delete it. Alternatively, define custom click handlers for each component that override the default behavior.&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-start --&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/38540736/226447799-e845d266-0658-44e3-bd89-f706577844bf.gif&#34; alt=&#34;clickable-buffers&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-end --&gt; &#xA;&lt;h3&gt;Hover events&lt;/h3&gt; &#xA;&lt;p&gt;Each component has access to an is_hovered property, and can be given custom &lt;code&gt;on_mouse_enter&lt;/code&gt; and &lt;code&gt;on_mouse_leave&lt;/code&gt; handlers, allowing for implementations of close buttons, diagnostic previews, and more complex funcionality.&lt;/p&gt; &#xA;&lt;p&gt;Note: requires &lt;code&gt;:h &#39;mousemoveevent&#39;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-start --&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/willothy/nvim-cokeline/assets/38540736/fb92475f-d775-44fe-9c95-a76c1cbaf560&#34; alt=&#34;hover-events&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/willothy/nvim-cokeline/assets/38540736/3b319c79-0bff-41dd-9a08-36fd627b3d08&#34; alt=&#34;hover-events-2&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-end --&gt; &#xA;&lt;h3&gt;Buffer re-ordering (including mouse-drag reordering)&lt;/h3&gt; &#xA;&lt;!-- panvimdoc-ignore-start --&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/38540736/226447818-bdf63d70-e153-4353-992d-d317a5764c09.gif&#34; alt=&#34;reordering&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-end --&gt; &#xA;&lt;h3&gt;Close icons&lt;/h3&gt; &#xA;&lt;!-- panvimdoc-ignore-start --&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/38540736/226447802-29b2919e-dd20-4789-8d6a-250d6d453c64.gif&#34; alt=&#34;close-icons&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-end --&gt; &#xA;&lt;h3&gt;Buffer history tracking&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;cokeline.history&#34;):last():focus()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are a user of &lt;a href=&#34;https://github.com/stevearc/resession.nvim&#34;&gt;&lt;code&gt;resession.nvim&lt;/code&gt;&lt;/a&gt;, cokeline&#39;s history will be restored along with the rest of your sessions.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;üîå&lt;/span&gt; Requirements&lt;/h2&gt; &#xA;&lt;p&gt;The two main requirements are Neovim 0.5+ and the &lt;code&gt;termguicolors&lt;/code&gt; option to be set. If you want to display devicons in your bufferline you&#39;ll also need the &lt;a href=&#34;https://github.com/nvim-tree/nvim-web-devicons&#34;&gt;nvim-tree/nvim-web-devicons&lt;/a&gt; plugin and a patched font (see &lt;a href=&#34;https://www.nerdfonts.com/&#34;&gt;Nerd Fonts&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;As of v0.4.0, &lt;a href=&#34;https://github.com/nvim-lua/plenary.nvim&#34;&gt;nvim-lua/plenary.nvim&lt;/a&gt; is required as well.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;üì¶&lt;/span&gt; Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Lua&lt;/h3&gt; &#xA;&lt;h4&gt;With lazy.nvim&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;lazy&#34;).setup({&#xA;  {&#xA;  &#34;willothy/nvim-cokeline&#34;,&#xA;  dependencies = {&#xA;    &#34;nvim-lua/plenary.nvim&#34;,        -- Required for v0.4.0+&#xA;    &#34;nvim-tree/nvim-web-devicons&#34;, -- If you want devicons&#xA;    &#34;stevearc/resession.nvim&#34;       -- Optional, for persistent history&#xA;  },&#xA;  config = true&#xA;}&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Vimscript&lt;/h3&gt; &#xA;&lt;p&gt;If your config is still written in Vimscript and you use &lt;a href=&#34;https://github.com/junegunn/vim-plug&#34;&gt;vim-plug&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;call plug#begin(&#39;~/.config/nvim/plugged&#39;)&#xA;  &#34; ...&#xA;  Plug &#39;nvim-lua/plenary.nvim&#39;        &#34; Required for v0.4.0+&#xA;  Plug &#39;nvim-tree/nvim-web-devicons&#39; &#34; If you want devicons&#xA;  Plug &#39;willothy/nvim-cokeline&#39;&#xA;  &#34; ...&#xA;call plug#end()&#xA;&#xA;set termguicolors&#xA;lua &amp;lt;&amp;lt; EOF&#xA;  require(&#39;cokeline&#39;).setup()&#xA;EOF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;span&gt;üîß&lt;/span&gt; Configuration&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;br&gt; Check out the &lt;a href=&#34;https://github.com/willothy/nvim-cokeline/wiki&#34;&gt;wiki&lt;/a&gt; for more details and API documentation.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;All the configuration is done by changing the contents of the Lua table passed to the &lt;code&gt;setup&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;The valid keys are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;cokeline&#39;).setup({&#xA;  -- Only show the bufferline when there are at least this many visible buffers.&#xA;  -- default: `1`.&#xA;  ---@type integer&#xA;  show_if_buffers_are_at_least = 1,&#xA;&#xA;  buffers = {&#xA;    -- A function to filter out unwanted buffers. Takes a buffer table as a&#xA;    -- parameter (see the following section for more infos) and has to return&#xA;    -- either `true` or `false`.&#xA;    -- default: `false`.&#xA;    ---@type false | fun(buf: Buffer):boolean&#xA;    filter_valid = false,&#xA;&#xA;    -- A looser version of `filter_valid`, use this function if you still&#xA;    -- want the `cokeline-{switch,focus}-{prev,next}` mappings to work for&#xA;    -- these buffers without displaying them in your bufferline.&#xA;    -- default: `false`.&#xA;    ---@type false | fun(buf: Buffer):boolean&#xA;    filter_visible = false,&#xA;&#xA;    -- Which buffer to focus when a buffer is deleted, `prev` focuses the&#xA;    -- buffer to the left of the deleted one while `next` focuses the one the&#xA;    -- right.&#xA;    -- default: &#39;next&#39;.&#xA;    focus_on_delete = &#39;prev&#39; | &#39;next&#39;,&#xA;&#xA;    -- If set to `last` new buffers are added to the end of the bufferline,&#xA;    -- if `next` they are added next to the current buffer.&#xA;    -- if set to `directory` buffers are sorted by their full path.&#xA;    -- if set to `number` buffers are sorted by bufnr, as in default Neovim&#xA;    -- default: &#39;last&#39;.&#xA;    ---@type &#39;last&#39; | &#39;next&#39; | &#39;directory&#39; | &#39;number&#39; | fun(a: Buffer, b: Buffer):boolean&#xA;    new_buffers_position = &#39;last&#39;,&#xA;&#xA;    -- If true, right clicking a buffer will close it&#xA;    -- The close button will still work normally&#xA;    -- Default: true&#xA;    ---@type boolean&#xA;    delete_on_right_click = true,&#xA;  },&#xA;&#xA;  mappings = {&#xA;    -- Controls what happens when the first (last) buffer is focused and you&#xA;    -- try to focus/switch the previous (next) buffer. If `true` the last&#xA;    -- (first) buffers gets focused/switched, if `false` nothing happens.&#xA;    -- default: `true`.&#xA;    ---@type boolean&#xA;    cycle_prev_next = true,&#xA;&#xA;    -- Disables mouse mappings&#xA;    -- default: `false`.&#xA;    ---@type boolean&#xA;    disable_mouse = false,&#xA;  },&#xA;&#xA;  -- Maintains a history of focused buffers using a ringbuffer&#xA;  history = {&#xA;    ---@type boolean&#xA;    enabled = true,&#xA;    ---The number of buffers to save in the history&#xA;    ---@type integer&#xA;    size = 2&#xA;  },&#xA;&#xA;  rendering = {&#xA;    -- The maximum number of characters a rendered buffer is allowed to take&#xA;    -- up. The buffer will be truncated if its width is bigger than this&#xA;    -- value.&#xA;    -- default: `999`.&#xA;    ---@type integer&#xA;    max_buffer_width = 999,&#xA;  },&#xA;&#xA;  pick = {&#xA;    -- Whether to use the filename&#39;s first letter first before&#xA;    -- picking a letter from the valid letters list in order.&#xA;    -- default: `true`&#xA;    ---@type boolean&#xA;    use_filename = true,&#xA;&#xA;    -- The list of letters that are valid as pick letters. Sorted by&#xA;    -- keyboard reachability by default, but may require tweaking for&#xA;    -- non-QWERTY keyboard layouts.&#xA;    -- default: `&#39;asdfjkl;ghnmxcvbziowerutyqpASDFJKLGHNMXCVBZIOWERTYQP&#39;`&#xA;    ---@type string&#xA;    letters = &#39;asdfjkl;ghnmxcvbziowerutyqpASDFJKLGHNMXCVBZIOWERTYQP&#39;,&#xA;  },&#xA;&#xA;  -- The default highlight group values.&#xA;  -- The `fg`, `bg`, and `sp` keys are either colors in hexadecimal format or&#xA;  -- functions taking a `buffer` parameter and returning a color in&#xA;  -- hexadecimal format. Style attributes work the same way, but functions&#xA;  -- should return boolean values.&#xA;  default_hl = {&#xA;    -- default: `ColorColumn`&#39;s background color for focused buffers,&#xA;    -- `Normal`&#39;s foreground color for unfocused ones.&#xA;    ---@type nil | string | fun(buffer: Buffer): string&#xA;    fg = function(buffer)&#xA;      local hlgroups = require(&#34;cokeline.hlgroups&#34;)&#xA;      return buffer.is_focused and hlgroups.get_hl_attr(&#34;ColorColumn&#34;, &#34;bg&#34;)&#xA;        or hlgroups.get_hl_attr(&#34;Normal&#34;, &#34;fg&#34;)&#xA;    end,&#xA;&#xA;    -- default: `Normal`&#39;s foreground color for focused buffers,&#xA;    -- `ColorColumn`&#39;s background color for unfocused ones.&#xA;    -- default: `Normal`&#39;s foreground color.&#xA;    ---@type nil | string | function(buffer: Buffer): string,&#xA;    bg = function(buffer)&#xA;      local hlgroups = require(&#34;cokeline.hlgroups&#34;)&#xA;      return buffer.is_focused and hlgroups.get_hl_attr(&#34;Normal&#34;, &#34;fg&#34;)&#xA;        or hlgroups.get_hl_attr(&#34;ColorColumn&#34;, &#34;bg&#34;)&#xA;    end,&#xA;&#xA;    -- default: unset.&#xA;    ---@type nil | string | function(buffer): string,&#xA;    sp = nil,&#xA;&#xA;    ---@type nil | boolean | fun(buf: Buffer):boolean&#xA;    bold = nil,&#xA;    ---@type nil | boolean | fun(buf: Buffer):boolean&#xA;    italic = nil,&#xA;    ---@type nil | boolean | fun(buf: Buffer):boolean&#xA;    underline = nil,&#xA;    ---@type nil | boolean | fun(buf: Buffer):boolean&#xA;    undercurl = nil,&#xA;    ---@type nil | boolean | fun(buf: Buffer):boolean&#xA;    strikethrough = nil,&#xA;  },&#xA;&#xA;  -- The highlight group used to fill the tabline space&#xA;  fill_hl = &#39;TabLineFill&#39;,&#xA;&#xA;  -- A list of components to be rendered for each buffer. Check out the section&#xA;  -- below explaining what this value can be set to.&#xA;  -- default: see `/lua/cokeline/defaults.lua`&#xA;  ---@type Component[]&#xA;  components = {},&#xA;&#xA;  -- Custom areas can be displayed on the right hand side of the bufferline.&#xA;  -- They act identically to buffer components, except their methods don&#39;t take a Buffer object.&#xA;  -- If you want a rhs component to be stateful, you can wrap it in a closure containing state.&#xA;  ---@type Component[] | false&#xA;  rhs = {},&#xA;&#xA;  -- Tabpages can be displayed on either the left or right of the bufferline.&#xA;  -- They act the same as other components, except they are passed TabPage objects instead of&#xA;  -- buffer objects.&#xA;  ---@type table | false&#xA;  tabs = {&#xA;    placement = &#34;left&#34; | &#34;right&#34;,&#xA;    ---@type Component[]&#xA;    components = {}&#xA;  },&#xA;&#xA;  -- Left sidebar to integrate nicely with file explorer plugins.&#xA;  -- This is a table containing a `filetype` key and a list of `components` to&#xA;  -- be rendered in the sidebar.&#xA;  -- The last component will be automatically space padded if necessary&#xA;  -- to ensure the sidebar and the window below it have the same width.&#xA;  ---@type table | false&#xA;  sidebar = {&#xA;    ---@type string | string[]&#xA;    filetype = { &#34;NvimTree&#34;, &#34;neo-tree&#34;, &#34;SidebarNvim&#34; },&#xA;    ---@type Component[]&#xA;    components = {},&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;So what&#39;s &lt;code&gt;function(buffer)&lt;/code&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;Some of the configuration options can be functions that take a &lt;a href=&#34;https://github.com/willothy/nvim-cokeline/wiki/Buffer&#34;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt; as a single parameter. This is useful as it allows users to set the values of components dynamically based on the buffer that component is being rendered for.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Buffer&lt;/code&gt; type is just a Lua table with the following keys:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;Buffer = {&#xA;  -- The buffer&#39;s order in the bufferline (1 for the first buffer, 2 for the&#xA;  -- second one, etc.).&#xA;  index = int,&#xA;&#xA;  -- The buffer&#39;s internal number as reported by `:ls`.&#xA;  number = int,&#xA;&#xA;  ---@type boolean&#xA;  is_focused = false,&#xA;&#xA;  ---@type boolean&#xA;  is_modified = false,&#xA;&#xA;  ---@type boolean&#xA;  is_readonly = false,&#xA;&#xA;  -- The buffer is the first visible buffer in the tab bar&#xA;  ---@type boolean&#xA;  is_first    = false,&#xA;&#xA;  -- The buffer is the last visible buffer in the tab bar&#xA;  ---@type boolean&#xA;  is_last     = false,&#xA;&#xA;  -- The mouse is hovering over the current component in the buffer&#xA;  -- This is a special variable in that it will only be true for the hovered *component*&#xA;  -- on render. This is to allow components to respond to hover events individually without managing&#xA;  -- component state.&#xA;  ---@type boolean&#xA;  is_hovered  = false,&#xA;&#xA;  -- The mouse is hovering over the buffer (true for all components)&#xA;  ---@type boolean&#xA;  buf_hovered = false,&#xA;&#xA;  -- The buffer&#39;s type as reported by `:echo &amp;amp;buftype`.&#xA;  ---@type string&#xA;  ---@type string&#xA;  type = &#39;&#39;,&#xA;&#xA;  -- The buffer&#39;s filetype as reported by `:echo &amp;amp;filetype`.&#xA;  ---@type string&#xA;  filetype = &#39;&#39;,&#xA;&#xA;  -- The buffer&#39;s full path.&#xA;  ---@type string&#xA;  path = &#39;&#39;,&#xA;&#xA;  -- The buffer&#39;s filename.&#xA;  ---@type string&#xA;  filename = &#39;string&#39;,&#xA;&#xA;  -- A unique prefix used to distinguish buffers with the same filename&#xA;  -- stored in different directories. For example, if we have two files&#xA;  -- `bar/foo.md` and `baz/foo.md`, then the first will have `bar/` as its&#xA;  -- unique prefix and the second one will have `baz/`.&#xA;  ---@type string&#xA;  unique_prefix = &#39;&#39;,&#xA;&#xA;  -- The letter that is displayed when picking a buffer to either focus or&#xA;  -- close it.&#xA;  ---@type string&#xA;  pick_letter = &#39;char&#39;,&#xA;&#xA;  -- This needs the `nvim-tree/nvim-web-devicons` plugin to be installed.&#xA;  devicon = {&#xA;    -- An icon representing the buffer&#39;s filetype.&#xA;    ---@type string&#xA;    icon = &#39;string&#39;,&#xA;&#xA;    -- The colors of the devicon in hexadecimal format (useful to be passed&#xA;    -- to a component&#39;s `fg` field (see the `Components` section).&#xA;    color = &#39;#rrggbb&#39;,&#xA;  },&#xA;&#xA;  -- The values in this table are the ones reported by Neovim&#39;s built in&#xA;  -- LSP interface.&#xA;  diagnostics = {&#xA;    ---@type integer&#xA;    errors = 0,&#xA;    ---@type integer&#xA;    warnings = 0,&#xA;    ---@type integer&#xA;    infos = 0,&#xA;    ---@type integer&#xA;    hints = 0,&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It also has methods that can be used in component event handlers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;---@param self Buffer&#xA;---Deletes the buffer&#xA;function Buffer:delete() end&#xA;&#xA;---@param self Buffer&#xA;---Focuses the buffer&#xA;function Buffer:focus() end&#xA;&#xA;---@param self Buffer&#xA;---@return number&#xA;---Returns the number of lines in the buffer&#xA;function Buffer:lines() end&#xA;&#xA;---@param self Buffer&#xA;---@return string[]&#xA;---Returns the buffer&#39;s lines&#xA;function Buffer:text() end&#xA;&#xA;---@param buf Buffer&#xA;---@return boolean&#xA;---Returns true if the buffer is valid&#xA;function Buffer:is_valid() end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;What about &lt;a href=&#34;https://github.com/willothy/nvim-cokeline/wiki/TabPage&#34;&gt;&lt;code&gt;TabPage&lt;/code&gt;&lt;/a&gt;s?&lt;/h3&gt; &#xA;&lt;p&gt;Each method on a tab component is passed a &lt;code&gt;TabPage&lt;/code&gt; object as an argument.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;TabPage&lt;/code&gt;, like &lt;code&gt;Buffer&lt;/code&gt;, is simply a Lua table with some relevant data attached.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;TabPage = {&#xA;  -- The tabpage number, as reported by `nvim_list_tabpages`&#xA;  ---@type integer&#xA;  number = 0,&#xA;  -- A list of Window objects contained in the TabPage (see wiki for more info)&#xA;  ---@type Window[]&#xA;  windows = {},&#xA;  -- The currently focused window in the TabPage&#xA;  ---@type Window&#xA;  focused = nil,&#xA;  -- True if the TabPage is the current TabPage&#xA;  ---@type boolean&#xA;  is_active = true,&#xA;  -- True if the TabPage is first in the list&#xA;  ---@type boolean&#xA;  is_first = false,&#xA;  -- True if the TabPage is last in the list&#xA;  ---@type boolean&#xA;  is_last = false&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;And &lt;a href=&#34;https://github.com/willothy/nvim-cokeline/wiki/Component&#34;&gt;&lt;code&gt;components&lt;/code&gt;&lt;/a&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;You can configure what each buffer in your bufferline will be composed of by passing a list of components to the &lt;code&gt;setup&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;For example, let&#39;s imagine we want to construct a very minimal bufferline where the only things we&#39;re displaying for each buffer are its index, its filename and a close button.&lt;/p&gt; &#xA;&lt;p&gt;Then in our &lt;code&gt;setup&lt;/code&gt; function we&#39;d have:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;cokeline&#39;).setup({&#xA;  -- ...&#xA;  components = {&#xA;    {&#xA;      text = function(buffer) return &#39; &#39; .. buffer.index end,&#xA;    },&#xA;    {&#xA;      text = function(buffer) return &#39; &#39; .. buffer.filename .. &#39; &#39; end,&#xA;    },&#xA;    {&#xA;      text = &#39;Û∞Öñ&#39;,&#xA;      on_click = function(_, _, _, _, buffer)&#xA;        buffer:delete()&#xA;      end&#xA;    },&#xA;    {&#xA;      text = &#39; &#39;,&#xA;    }&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in this case every buffer would be composed of four components: the first displaying a space followed by the buffer index, the second one the filename padded by a space on each side, then a close button that allows us to &lt;code&gt;:bdelete&lt;/code&gt; the buffer by left-clicking on it, and finally an extra space.&lt;/p&gt; &#xA;&lt;p&gt;This way of dividing each buffer into distinct components, combined with the ability to define every component&#39;s text and color depending on some property of the buffer we&#39;re rendering, allows for great customizability.&lt;/p&gt; &#xA;&lt;p&gt;Every component passed to the &lt;code&gt;components&lt;/code&gt; list has to be a table of the form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;&#xA;  ---@type string | fun(buffer: Buffer): string&#xA;  text = &#34;&#34;,&#xA;&#xA;  -- The foreground, backgrond and style of the component&#xA;  ---@type nil | string | fun(buffer: Buffer): string&#xA;  fg = &#39;#rrggbb&#39;,&#xA;  ---@type nil | string | fun(buffer: Buffer): string&#xA;  bg = &#39;#rrggbb&#39;,&#xA;  ---@type nil | string | fun(buffer: Buffer): string&#xA;  sp = &#39;#rrggbb&#39;,&#xA;  ---@type nil | boolean | fun(buffer: Buffer): boolean&#xA;  bold = false,&#xA;  ---@type nil | boolean | fun(buffer: Buffer): boolean&#xA;  italic = false,&#xA;  ---@type nil | boolean | fun(buffer: Buffer): boolean&#xA;  underline = false,&#xA;  ---@type nil | boolean | fun(buffer: Buffer): boolean&#xA;  undercurl = false,&#xA;  ---@type nil | boolean | fun(buffer: Buffer): boolean&#xA;  strikethrough = false,&#xA;&#xA;  -- Or, alternatively, the name of the highlight group&#xA;  ---@type nil | string | fun(buffer: Buffer): string&#xA;  highlight = nil,&#xA;&#xA;  -- If `true` the buffer will be deleted when this component is&#xA;  -- left-clicked (usually used to implement close buttons, overrides `on_click`).&#xA;  -- deprecated, it is recommended to use the Buffer:delete() method in an on_click event&#xA;  -- to implement close buttons instead.&#xA;  ---@type boolean&#xA;  delete_buffer_on_left_click = false,&#xA;&#xA;  -- Handles click event for a component&#xA;  -- If not set, component will have the default click behavior&#xA;  -- buffer is a Buffer object, not a bufnr&#xA;  ---@type nil | fun(idx: integer, clicks: integer, button: string, mods: string, buffer: Buffer)&#xA;  on_click = nil,&#xA;&#xA;  -- Called on a component when hovered&#xA;  ---@type nil | function(buffer: Buffer, mouse_col: integer)&#xA;  on_mouse_enter = nil,&#xA;&#xA;  -- Called on a component when unhovered&#xA;  ---@type nil | function(buffer: Buffer, mouse_col: integer)&#xA;  on_mouse_leave = nil,&#xA;&#xA;  truncation = {&#xA;    -- default: index of the component in the `components` table (1 for the&#xA;    -- first component, 2 for the second, etc.).&#xA;    ---@type integer&#xA;    priority = 1,&#xA;&#xA;    -- default: `right`.&#xA;    ---@type &#39;left&#39; | &#39;middle&#39; | &#39;right&#39;&#xA;    direction = &#39;left&#39; | &#39;middle&#39; | &#39;right&#39;,&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;the &lt;code&gt;text&lt;/code&gt; key is the only one that has to be set, all the others are optional and can be omitted.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;truncation&lt;/code&gt; table controls what happens when a buffer is too long to be displayed in its entirety.&lt;/p&gt; &#xA;&lt;p&gt;More specifically, if a buffer&#39;s width (given by the sum of the widths of all its components) is bigger than the &lt;code&gt;rendering.max_buffer_width&lt;/code&gt; config option, the buffer will be truncated.&lt;/p&gt; &#xA;&lt;p&gt;The default behaviour is truncate the buffer by dropping components from right to left, with the text of the last component that&#39;s included also being shortened from right to left. This can be modified by changing the values of the &lt;code&gt;truncation.priority&lt;/code&gt; and &lt;code&gt;truncation.direction&lt;/code&gt; keys.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;truncation.priority&lt;/code&gt; controls the order in which components are dropped: the first component to be dropped will be the one with the lowest priority. If that&#39;s still not enough to bring the width of the buffer within the &lt;code&gt;rendering.max_buffer_width&lt;/code&gt; limit, the component with the second lowest priority will be dropped, and so on. Note that a higher priority means a smaller integer value: a component with a priority of 5 will be dropped &lt;em&gt;after&lt;/em&gt; a component with a priority of 6, even though 6 &amp;gt; 5.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;truncation.direction&lt;/code&gt; key simply controls from which direction a component is shortened. For example, you might want to set the &lt;code&gt;truncation.direction&lt;/code&gt; of a component displaying a filename to &lt;code&gt;&#39;middle&#39;&lt;/code&gt; or &lt;code&gt;&#39;left&#39;&lt;/code&gt;, so that if the filename has to be shortened you&#39;ll still be able to see its extension, like in the following example (where it&#39;s set to &lt;code&gt;&#39;left&#39;&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-start --&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/38540736/226447798-6aee2e0f-f957-42ab-96dd-3618e78ba4ba.png&#34; alt=&#34;buffer-truncation&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- panvimdoc-ignore-end --&gt; &#xA;&lt;h4&gt;What about &lt;a href=&#34;https://github.com/willothy/nvim-cokeline/wiki/History&#34;&gt;&lt;code&gt;history&lt;/code&gt;&lt;/a&gt;?&lt;/h4&gt; &#xA;&lt;p&gt;The History keeps track of the buffers you access using a ringbuffer, and provides an API for accessing Buffer objects from the history.&lt;/p&gt; &#xA;&lt;p&gt;You can access the history using &lt;code&gt;require(&#34;cokeline.history&#34;)&lt;/code&gt;, or through the global &lt;code&gt;_G.cokeline.history&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;History&lt;/code&gt; object provides these methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;History = {}&#xA;&#xA;---Adds a Buffer object to the history&#xA;---@type bufnr integer&#xA;function History:push(bufnr)&#xA;end&#xA;&#xA;---Removes and returns the oldest Buffer object in the history&#xA;---@return Buffer?&#xA;function History:pop()&#xA;end&#xA;&#xA;---Returns a list of Buffer objects in the history,&#xA;---ordered from oldest to newest&#xA;---@return Buffer[]&#xA;function History:list()&#xA;end&#xA;&#xA;---Returns an iterator of Buffer objects in the history,&#xA;---ordered from oldest to newest&#xA;---@return fun(): Buffer?&#xA;function History:iter()&#xA;end&#xA;&#xA;---Get a Buffer object by history index&#xA;---@param idx integer&#xA;---@return Buffer?&#xA;function History:get(idx)&#xA;end&#xA;&#xA;---Get a Buffer object representing the last-accessed buffer (before the current one)&#xA;---@return Buffer?&#xA;function History:last()&#xA;end&#xA;&#xA;---Returns true if the history is empty&#xA;---@return boolean&#xA;function History:is_empty()&#xA;end&#xA;&#xA;---Returns the maximum number of buffers that can be stored in the history&#xA;---@return integer&#xA;function History:capacity()&#xA;end&#xA;&#xA;---Returns true if the history contains the given buffer&#xA;---@param bufnr integer&#xA;---@return boolean&#xA;function History:contains(bufnr)&#xA;end&#xA;&#xA;---Returns the number of buffers in the history&#xA;---@return integer&#xA;function History:len()&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;span&gt;üéπ&lt;/span&gt; Mappings&lt;/h2&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;mappings&lt;/code&gt; module to create mappings from Lua:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.keymap.set(&#34;n&#34;, &#34;&amp;lt;leader&amp;gt;bp&#34;, function()&#xA;    require(&#39;cokeline.mappings&#39;).pick(&#34;focus&#34;)&#xA;end, { desc = &#34;Pick a buffer to focus&#34; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, we expose the following &lt;code&gt;&amp;lt;Plug&amp;gt;&lt;/code&gt; mappings which can be used as the right hand side of other mappings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-- Focus the previous/next buffer&#xA;&amp;lt;Plug&amp;gt;(cokeline-focus-prev)&#xA;&amp;lt;Plug&amp;gt;(cokeline-focus-next)&#xA;&#xA;-- Switch the position of the current buffer with the previous/next buffer.&#xA;&amp;lt;Plug&amp;gt;(cokeline-switch-prev)&#xA;&amp;lt;Plug&amp;gt;(cokeline-switch-next)&#xA;&#xA;-- Focuses the buffer with index `i`.&#xA;&amp;lt;Plug&amp;gt;(cokeline-focus-i)&#xA;&#xA;-- Switches the position of the current buffer with the buffer of index `i`.&#xA;&amp;lt;Plug&amp;gt;(cokeline-switch-i)&#xA;&#xA;-- Focus a buffer by its `pick_letter`.&#xA;&amp;lt;Plug&amp;gt;(cokeline-pick-focus)&#xA;&#xA;-- Close a buffer by its `pick_letter`.&#xA;&amp;lt;Plug&amp;gt;(cokeline-pick-close)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A possible configuration could be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local map = vim.api.nvim_set_keymap&#xA;&#xA;map(&#34;n&#34;, &#34;&amp;lt;S-Tab&amp;gt;&#34;, &#34;&amp;lt;Plug&amp;gt;(cokeline-focus-prev)&#34;, { silent = true })&#xA;map(&#34;n&#34;, &#34;&amp;lt;Tab&amp;gt;&#34;, &#34;&amp;lt;Plug&amp;gt;(cokeline-focus-next)&#34;, { silent = true })&#xA;map(&#34;n&#34;, &#34;&amp;lt;Leader&amp;gt;p&#34;, &#34;&amp;lt;Plug&amp;gt;(cokeline-switch-prev)&#34;, { silent = true })&#xA;map(&#34;n&#34;, &#34;&amp;lt;Leader&amp;gt;n&#34;, &#34;&amp;lt;Plug&amp;gt;(cokeline-switch-next)&#34;, { silent = true })&#xA;&#xA;for i = 1, 9 do&#xA;  map(&#xA;    &#34;n&#34;,&#xA;    (&#34;&amp;lt;F%s&amp;gt;&#34;):format(i),&#xA;    (&#34;&amp;lt;Plug&amp;gt;(cokeline-focus-%s)&#34;):format(i),&#xA;    { silent = true }&#xA;  )&#xA;  map(&#xA;    &#34;n&#34;,&#xA;    (&#34;&amp;lt;Leader&amp;gt;%s&#34;):format(i),&#xA;    (&#34;&amp;lt;Plug&amp;gt;(cokeline-switch-%s)&#34;):format(i),&#xA;    { silent = true }&#xA;  )&#xA;end&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>AgusDOLARD/backout.nvim</title>
    <updated>2024-01-10T01:36:27Z</updated>
    <id>tag:github.com,2024-01-10:/AgusDOLARD/backout.nvim</id>
    <link href="https://github.com/AgusDOLARD/backout.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Jump back and forth while being in insert mode&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;backout.nvim&lt;/h1&gt; &#xA;&lt;h2&gt;üìñ Overview&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;backout.nvim&lt;/code&gt; is a minimal neovim plugin designed to move inline while remaining in insert mode. This plugin is inspired by functionality from &lt;a href=&#34;https://github.com/jiangmiao/auto-pairs&#34;&gt;auto-pairs&lt;/a&gt; that I couldn&#39;t find in other auto-pair plugins.&lt;/p&gt; &#xA;&lt;h3&gt;Example&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://vhs.charm.sh/vhs-5zjoLQoKJKK1DQBld3RQRp.gif&#34; alt=&#34;Example&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üöÄ Installation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/folke/lazy.nvim&#34;&gt;lazy.nvim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;return {&#xA;&#x9;&#34;AgusDOLARD/backout.nvim&#34;,&#xA;&#x9;opts = {},&#xA;&#x9;keys = {&#xA;        -- Define your keybinds&#xA;&#x9;&#x9;{ &#34;&amp;lt;M-b&amp;gt;&#34;, &#34;&amp;lt;cmd&amp;gt;lua require(&#39;backout&#39;).back()&amp;lt;cr&amp;gt;&#34;, mode = { &#34;i&#34; } },&#xA;&#x9;&#x9;{ &#34;&amp;lt;M-n&amp;gt;&#34;, &#34;&amp;lt;cmd&amp;gt;lua require(&#39;backout&#39;).out()&amp;lt;cr&amp;gt;&#34;, mode = { &#34;i&#34; } },&#xA;&#x9;},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;‚öôÔ∏è Options&lt;/h2&gt; &#xA;&lt;h3&gt;chars&lt;/h3&gt; &#xA;&lt;p&gt;A string containing characters or sequences to jump between&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    chars = &#34;(){}[]`&#39;\&#34;&amp;lt;&amp;gt;&#34; -- default chars&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;ü§ù Contributions&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are welcome! Feel free to open issues, submit pull requests, or provide feedback to help improve backout.nvim.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Achimobil/FS22_InfoDisplayExtension</title>
    <updated>2024-01-10T01:36:27Z</updated>
    <id>tag:github.com,2024-01-10:/Achimobil/FS22_InfoDisplayExtension</id>
    <link href="https://github.com/Achimobil/FS22_InfoDisplayExtension" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;FS22_InfoDisplayExtension&lt;/h1&gt; &#xA;&lt;h1&gt;ModHub&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.farming-simulator.com/mod.php?mod_id=239604&amp;amp;title=fs2022&#34;&gt;https://www.farming-simulator.com/mod.php?mod_id=239604&amp;amp;title=fs2022&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;General&lt;/h1&gt; &#xA;&lt;h2&gt;DE&lt;/h2&gt; &#xA;&lt;p&gt;Alles in meinen Mods darf weder komplett noch in Teilen in eigene Mods kopiert oder in irgendeiner anderen Form weiterver√∂ffentlicht werden, es sei denn es wird ausdr√ºcklich erlaubt. Dies ist internationales Recht und wird durch das Urheberrecht abgedeckt. Wer trotzdem ohne Erlaubnis Teile von meinen Mods in seine Mods einbaut und ver√∂ffentlicht, gibt automatisch seine Mods zur uneingeschr√§nkten Verwendung und Wiederver√∂ffentlichung f√ºr mich frei. Ich behalte mir vor, von diesem Recht gebrauch zu machen. Das Einstellen meiner Mods auf anderen Downloadportalen ist nur mit dem jeweils auf das GitHub verweisenden Link erlaubt. Jegliche Form des Selbsthostings ist untersagt.&lt;/p&gt; &#xA;&lt;h2&gt;EN&lt;/h2&gt; &#xA;&lt;p&gt;Everything in my mods may not be copied in whole or in part into your own mods or republished in any other form, unless it is expressly permitted. This is international law and is covered by copyright law. Anyone who nevertheless incorporates parts of my mods into their mods and publishes them without permission automatically releases their mods for unrestricted use and republication for me. I reserve the right to make use of this right. Posting my mods on other download portals is only allowed with the link pointing to the GitHub. Any form of self-hosting is prohibited&lt;/p&gt;</summary>
  </entry>
</feed>