<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-21T01:30:41Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nvim-neotest/nvim-nio</title>
    <updated>2024-03-21T01:30:41Z</updated>
    <id>tag:github.com,2024-03-21:/nvim-neotest/nvim-nio</id>
    <link href="https://github.com/nvim-neotest/nvim-nio" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A library for asynchronous IO in Neovim&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;nvim-nio&lt;/h1&gt; &#xA;&lt;p&gt;A library for asynchronous IO in Neovim, inspired by the asyncio library in Python. The library focuses on providing both common asynchronous primitives and asynchronous APIs for Neovim&#39;s core.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neotest/nvim-nio/master/#motivation&#34;&gt;Motivation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neotest/nvim-nio/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neotest/nvim-nio/master/#configuration&#34;&gt;Configuration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neotest/nvim-nio/master/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neotest/nvim-nio/master/#niocontrol&#34;&gt;&lt;code&gt;nio.control&lt;/code&gt;&lt;/a&gt;: Primitives for flow control in async functions&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neotest/nvim-nio/master/#niolsp&#34;&gt;&lt;code&gt;nio.lsp&lt;/code&gt;&lt;/a&gt;: A fully typed and documented async LSP client library, generated from the LSP specification.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neotest/nvim-nio/master/#niofile&#34;&gt;&lt;code&gt;nio.file&lt;/code&gt;&lt;/a&gt;: Open and operate on files asynchronously&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neotest/nvim-nio/master/#nioprocess&#34;&gt;&lt;code&gt;nio.process&lt;/code&gt;&lt;/a&gt;: Run and control subprocesses asynchronously&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neotest/nvim-nio/master/#niouv&#34;&gt;&lt;code&gt;nio.uv&lt;/code&gt;&lt;/a&gt;: Async versions of &lt;code&gt;vim.loop&lt;/code&gt; functions&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neotest/nvim-nio/master/#nioui&#34;&gt;&lt;code&gt;nio.ui&lt;/code&gt;&lt;/a&gt;: Async versions of vim.ui functions&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neotest/nvim-nio/master/#niotests&#34;&gt;&lt;code&gt;nio.tests&lt;/code&gt;&lt;/a&gt;: Async versions of plenary.nvim&#39;s test functions&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neotest/nvim-nio/master/#third-party-integration&#34;&gt;Third Party Integration&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neotest/nvim-nio/master/#used-by&#34;&gt;Used By&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;Work has been ongoing around async libraries in Neovim for years, with a lot of discussion around a &lt;a href=&#34;https://github.com/neovim/neovim/issues/19624&#34;&gt;Neovim core implementation&lt;/a&gt;. Much of the motivation behind this library can be seen in that discussion.&lt;/p&gt; &#xA;&lt;p&gt;nvim-nio aims to provide a simple interface to Lua coroutines that doesn&#39;t feel like it gets in the way of your actual logic. You won&#39;t even know you&#39;re using them. An example of this is error handling. With other libraries, a custom &lt;code&gt;pcall&lt;/code&gt; or some other custom handling must be used to catch errors. With nvim-nio, Lua&#39;s built-in &lt;code&gt;pcall&lt;/code&gt; works exactly as you&#39;d expect.&lt;/p&gt; &#xA;&lt;p&gt;nvim-nio is focused on providing a great developer experience. The API is well documented with examples and full type annotations, which can all be used by the Lua LSP. It&#39;s recommended to use &lt;a href=&#34;https://github.com/folke/neodev.nvim&#34;&gt;neodev.nvim&lt;/a&gt; to get LSP support.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/nvim-lua/plenary.nvim/assets/24252670/0dda462c-0b5c-4300-8e65-b7218e3d2c1e&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Credit to the async library in &lt;a href=&#34;https://github.com/nvim-lua/plenary.nvim&#34;&gt;plenary.nvim&lt;/a&gt; and &lt;a href=&#34;https://github.com/lewis6991/async.nvim&#34;&gt;async.nvim&lt;/a&gt; for inspiring nvim-nio and its implementation. If Neovim core integrates an async library, nvim-nio will aim to maintain compatibility with it if possible.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install with your favourite package manager&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/folke/lazy.nvim&#34;&gt;lazy.nvim&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{ &#34;nvim-neotest/nvim-nio&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Shougo/dein.vim&#34;&gt;dein&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;call dein#add(&#34;nvim-neotest/nvim-nio&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/junegunn/vim-plug&#34;&gt;vim-plug&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Plug &#39;nvim-neotest/nvim-nio&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;packer.nvim&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use { &#34;nvim-neotest/nvim-nio&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;There are no configuration options currently available.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;nvim-nio is based on the concept of tasks. These tasks represent a series of asynchronous actions that run in a single context. Under the hood, each task is running on a separate lua coroutine.&lt;/p&gt; &#xA;&lt;p&gt;Tasks are created by providing an async function to &lt;code&gt;nio.run&lt;/code&gt;. All async functions must be called from a task.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local nio = require(&#34;nio&#34;)&#xA;&#xA;local task = nio.run(function()&#xA;  nio.sleep(10)&#xA;  print(&#34;Hello world&#34;)&#xA;end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For simple use cases tasks won&#39;t be too important but they support features such as cancelling and retrieving stack traces.&lt;/p&gt; &#xA;&lt;p&gt;nvim-nio comes with built-in modules to help with writing async code. See &lt;code&gt;:help nvim-nio&lt;/code&gt; for extensive documentation.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;nio.control&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Primitives for flow control in async functions&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local event = nio.control.event()&#xA;&#xA;local worker = nio.run(function()&#xA;  nio.sleep(1000)&#xA;  event.set()&#xA;end)&#xA;&#xA;local listeners = {&#xA;  nio.run(function()&#xA;    event.wait()&#xA;    print(&#34;First listener notified&#34;)&#xA;  end),&#xA;  nio.run(function()&#xA;    event.wait()&#xA;    print(&#34;Second listener notified&#34;)&#xA;  end),&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;nio.lsp&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A fully typed and documented async LSP client library, generated from the LSP specification.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local client = nio.lsp.get_clients({ name = &#34;lua_ls&#34; })[1]&#xA;&#xA;local err, response = client.request.textDocument_semanticTokens_full({&#xA;  textDocument = { uri = vim.uri_from_bufnr(0) },&#xA;})&#xA;&#xA;assert(not err, err)&#xA;&#xA;for _, token in pairs(response.data) do&#xA;  print(token)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;nio.file&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Open and operate on files asynchronously&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local file = nio.file.open(&#34;test.txt&#34;, &#34;w+&#34;)&#xA;&#xA;file.write(&#34;Hello, World!\n&#34;)&#xA;&#xA;local content = file.read(nil, 0)&#xA;print(content)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;nio.process&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Run and control subprocesses asynchronously&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local first = nio.process.run({&#xA;  cmd = &#34;printf&#34;, args = { &#34;hello&#34; }&#xA;})&#xA;&#xA;local second = nio.process.run({&#xA;  cmd = &#34;cat&#34;, stdin = first.stdout&#xA;})&#xA;&#xA;local output = second.stdout.read()&#xA;print(output)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;nio.uv&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Async versions of &lt;code&gt;vim.loop&lt;/code&gt; functions&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local file_path = &#34;README.md&#34;&#xA;&#xA;local open_err, file_fd = nio.uv.fs_open(file_path, &#34;r&#34;, 438)&#xA;assert(not open_err, open_err)&#xA;&#xA;local stat_err, stat = nio.uv.fs_fstat(file_fd)&#xA;assert(not stat_err, stat_err)&#xA;&#xA;local read_err, data = nio.uv.fs_read(file_fd, stat.size, 0)&#xA;assert(not read_err, read_err)&#xA;&#xA;local close_err = nio.uv.fs_close(file_fd)&#xA;assert(not close_err, close_err)&#xA;&#xA;print(data)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;nio.ui&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Async versions of vim.ui functions&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local value = nio.ui.input({ prompt = &#34;Enter something: &#34; })&#xA;print((&#34;You entered: %s&#34;):format(value))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;nio.tests&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Async versions of plenary.nvim&#39;s test functions&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;nio.tests.it(&#34;notifies listeners&#34;, function()&#xA;  local event = nio.control.event()&#xA;  local notified = 0&#xA;  for _ = 1, 10 do&#xA;    nio.run(function()&#xA;      event.wait()&#xA;      notified = notified + 1&#xA;    end)&#xA;  end&#xA;&#xA;  event.set()&#xA;  nio.sleep(10)&#xA;  assert.equals(10, notified)&#xA;end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Third Party Integration&lt;/h3&gt; &#xA;&lt;p&gt;It is also easy to wrap callback style functions to make them asynchronous using &lt;code&gt;nio.wrap&lt;/code&gt;, which allows easily integrating third-party APIs with nvim-nio.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local nio = require(&#34;nio&#34;)&#xA;&#xA;local sleep = nio.wrap(function(ms, cb)&#xA;  vim.defer_fn(cb, ms)&#xA;end, 2)&#xA;&#xA;nio.run(function()&#xA;  sleep(10)&#xA;  print(&#34;Slept for 10ms&#34;)&#xA;end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Used By&lt;/h2&gt; &#xA;&lt;p&gt;Here are some of the plugins using nvim-nio:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-neotest/neotest&#34;&gt;neotest&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rcarriga/nvim-dap-ui&#34;&gt;nvim-dap-ui&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rest-nvim/rest.nvim&#34;&gt;rest.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-neorocks/rocks.nvim&#34;&gt;rocks.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pysan3/pathlib.nvim&#34;&gt;pathlib.nvim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please open an issue to add any missing entries!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>nvim-neorocks/rocks.nvim</title>
    <updated>2024-03-21T01:30:41Z</updated>
    <id>tag:github.com,2024-03-21:/nvim-neorocks/rocks.nvim</id>
    <link href="https://github.com/nvim-neorocks/rocks.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Neovim plugin management inspired by Cargo, powered by luarocks&lt;/p&gt;&lt;hr&gt;&lt;br&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://github.com/nvim-neorocks/rocks.nvim&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/nvim-neorocks/rocks.nvim/master/rocks-header.svg?sanitize=true&#34; alt=&#34;rocks.nvim&#34;&gt; &lt;/a&gt; &#xA; &lt;p align=&#34;center&#34;&gt; &lt;br&gt; &lt;a href=&#34;https://raw.githubusercontent.com/nvim-neorocks/rocks.nvim/master/doc/rocks.txt&#34;&gt;&lt;strong&gt;Explore the docs »&lt;/strong&gt;&lt;/a&gt; &lt;br&gt; &lt;br&gt; &lt;a href=&#34;https://github.com/nvim-neorocks/rocks.nvim/issues/new?assignees=&amp;amp;labels=bug&#34;&gt;Report Bug&lt;/a&gt; · &lt;a href=&#34;https://github.com/nvim-neorocks/rocks.nvim/issues/new?assignees=&amp;amp;labels=enhancement&#34;&gt;Request Feature&lt;/a&gt; · &lt;a href=&#34;https://github.com/nvim-neorocks/rocks.nvim/discussions/new?category=q-a&#34;&gt;Ask Question&lt;/a&gt; &lt;/p&gt; &#xA; &lt;p&gt; &lt;strong&gt; A modern approach to &lt;a href=&#34;https://neovim.io/&#34;&gt;Neovim&lt;/a&gt; plugin management! &lt;/strong&gt; &lt;/p&gt; &#xA; &lt;p&gt;🌒&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;!-- markdownlint-restore --&gt; &#xA;&lt;h2&gt;&lt;span&gt;🌟&lt;/span&gt; Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Cargo&lt;/code&gt;-like &lt;code&gt;rocks.toml&lt;/code&gt; file for declaring all your plugins.&lt;/li&gt; &#xA; &lt;li&gt;Name-based installation (&lt;code&gt;&#34;nvim-neorg/neorg&#34;&lt;/code&gt; becomes &lt;code&gt;:Rocks install neorg&lt;/code&gt; instead).&lt;/li&gt; &#xA; &lt;li&gt;Automatic dependency and build script management.&lt;/li&gt; &#xA; &lt;li&gt;True semver versioning!&lt;/li&gt; &#xA; &lt;li&gt;Minimal, non-intrusive UI.&lt;/li&gt; &#xA; &lt;li&gt;Async execution.&lt;/li&gt; &#xA; &lt;li&gt;Extensible, with a Lua API. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-neorocks/rocks-git.nvim&#34;&gt;&lt;code&gt;rocks-git.nvim&lt;/code&gt;&lt;/a&gt; for installing from git repositories.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-neorocks/rocks-config.nvim&#34;&gt;&lt;code&gt;rocks-config.nvim&lt;/code&gt;&lt;/a&gt; for plugin configuration.&lt;/li&gt; &#xA;   &lt;li&gt;And more...&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Command completions for plugins and versions on luarocks.org.&lt;/li&gt; &#xA; &lt;li&gt;Binary rocks pulled from &lt;a href=&#34;https://nvim-neorocks.github.io/rocks-binaries/&#34;&gt;rocks-binaries&lt;/a&gt; so you don&#39;t have to compile them.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/nvim-neorocks/rocks.nvim/assets/12857160/955c3ae7-c916-4a70-8fbd-4e28b7f0d77e&#34; alt=&#34;demo&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;🌔&lt;/span&gt; Introduction&lt;/h2&gt; &#xA;&lt;p&gt;rocks.nvim revolutionizes Neovim plugin management by streamlining the way users and developers handle plugins and dependencies. Integrating directly with &lt;a href=&#34;https://luarocks.org&#34;&gt;&lt;code&gt;luarocks&lt;/code&gt;&lt;/a&gt;, this plugin offers an automated approach that shifts the responsibility of specifying dependencies and build steps from users to plugin authors.&lt;/p&gt; &#xA;&lt;h3&gt;Why rocks.nvim?&lt;/h3&gt; &#xA;&lt;p&gt;The traditional approach to Neovim plugin management often places an unjust burden on users.&lt;/p&gt; &#xA;&lt;p&gt;Consider the following example using lazy.nvim:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  &#39;foo/bar.nvim&#39;,&#xA;  dependencies = {&#xA;    &#39;nvim-lua/plenary.nvim&#39;,&#xA;    &#39;MunifTanjim/nui.nvim&#39;,&#xA;    {&#xA;      &#39;4O4/reactivex&#39;, -- LuaRocks dependency&#xA;      build = function(plugin)&#xA;        -- post-install build step required to link the luarocks dependency&#xA;        vim.uv.fs_symlink(plugin.dir, plugin.dir .. &#34;/lua&#34;, { dir = true })&#xA;      end,&#xA;    },&#xA;  },&#xA;  build = &#34;make install&#34; -- Post-install build step of the main plugin&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This setup illustrates several pain points in the status quo:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Manual dependency management: Users are often required to manually specify and manage dependencies.&lt;/li&gt; &#xA; &lt;li&gt;Breaking changes: Updates to a plugin&#39;s dependencies can lead to breaking changes for users.&lt;/li&gt; &#xA; &lt;li&gt;Platform-specific instructions: Build instructions and dependencies may vary by platform, adding complexity.&lt;/li&gt; &#xA; &lt;li&gt;Because of this horrible UX, plugin authors have been reluctant to add dependencies, preferring to copy/paste code instead.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;rocks.nvim simplifies the above example to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:Rocks install bar.nvim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Welcome to a new era of Neovim plugin management - where simplicity meets efficiency!&lt;/p&gt; &#xA;&lt;h3&gt;Philosophy&lt;/h3&gt; &#xA;&lt;p&gt;rocks.nvim itself is designed based on the UNIX philosophy: Do one thing well.&lt;/p&gt; &#xA;&lt;p&gt;It doesn&#39;t dictate how you as a user should configure your plugins. But there&#39;s an optional module for those seeking additional configuration capabilities: &lt;a href=&#34;https://github.com/nvim-neorocks/rocks-config.nvim&#34;&gt;&lt;code&gt;rocks-config.nvim&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We have packaged &lt;a href=&#34;https://luarocks.org/modules/neorocks&#34;&gt;many Neovim plugins and tree-sitter parsers&lt;/a&gt; for luarocks, and an increasing number of plugin authors &lt;a href=&#34;https://luarocks.org/labels/neovim?non_root=on&#34;&gt;have been publishing themselves&lt;/a&gt;. Additionally, &lt;a href=&#34;https://github.com/nvim-neorocks/rocks-git.nvim&#34;&gt;&lt;code&gt;rocks-git.nvim&lt;/code&gt;&lt;/a&gt; ensures you&#39;re covered even when a plugin isn&#39;t directly available on LuaRocks.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;📝&lt;/span&gt; Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;An up-to-date &lt;code&gt;Neovim&lt;/code&gt; nightly (&amp;gt;= 0.10) installation.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;git&lt;/code&gt; command line utility.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;wget&lt;/code&gt; or &lt;code&gt;curl&lt;/code&gt; (if running on a UNIX system) - required for the remote &lt;code&gt;:source&lt;/code&gt; command to work.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;netrw&lt;/code&gt; enabled in your Neovim configuration - enabled by default but some configurations manually disable the plugin.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT]&lt;/p&gt; &#xA; &lt;p&gt;If you are running on an esoteric architecture, &lt;code&gt;rocks.nvim&lt;/code&gt; will attempt to compile its dependencies instead of pulling a prebuilt binary. For the process to succeed you must have a &lt;strong&gt;C++17 parser&lt;/strong&gt; and &lt;strong&gt;Rust toolchain&lt;/strong&gt; installed on your system.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;&lt;span&gt;📥&lt;/span&gt; Installation&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;span&gt;⚡&lt;/span&gt; Installation script (recommended)&lt;/h3&gt; &#xA;&lt;p&gt;The days of bootstrapping and editing your configuration are over. &lt;code&gt;rocks.nvim&lt;/code&gt; can be installed directly through an interactive installer within Neovim.&lt;/p&gt; &#xA;&lt;p&gt;We suggest starting nvim without loading RC files, such that already installed plugins do not interfere with the installer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nvim -u NORC -c &#34;source https://raw.githubusercontent.com/nvim-neorocks/rocks.nvim/master/installer.lua&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT]&lt;/p&gt; &#xA; &lt;p&gt;For security reasons, we recommend that you read &lt;code&gt;:help :source&lt;/code&gt; and the installer code before running it so you know exactly what it does.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!TIP]&lt;/p&gt; &#xA; &lt;p&gt;To configure the luarocks installation to use a specific lua install, use environment variables &lt;code&gt;LUA_BINDIR=&amp;lt;Directory of lua binary&amp;gt;&lt;/code&gt; and &lt;code&gt;LUA_BINDIR_SET=yes&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;p&gt;For example:&lt;/p&gt; &#xA; &lt;p&gt;&lt;code&gt;LUA_BINDIR=&#34;${XDG_BIN_DIR:-$HOME/.local/bin}&#34; LUA_BINDIR_SET=yes nvim -u NORC -c &#34;source ...&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;&lt;span&gt;🔨&lt;/span&gt; Manual installation&lt;/h3&gt; &#xA;&lt;p&gt;For manual installation, see &lt;a href=&#34;https://github.com/nvim-neorocks/rocks.nvim/wiki/Installing-rocks.nvim-manually,-without-the-installation-script&#34;&gt;this tutorial&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;📚&lt;/span&gt; Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Installing rocks&lt;/h3&gt; &#xA;&lt;p&gt;You can install rocks with the &lt;code&gt;:Rocks install {rock} {version?}&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;p&gt;Arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;rock&lt;/code&gt;: The luarocks package.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;version&lt;/code&gt;: Optional. Used to pin a rock to a specific version.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE]&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;The command provides fuzzy completions for rocks and versions on luarocks.org.&lt;/li&gt; &#xA;  &lt;li&gt;Installs the latest version if &lt;code&gt;version&lt;/code&gt; is omitted.&lt;/li&gt; &#xA;  &lt;li&gt;This plugin keeps track of installed plugins in a &lt;code&gt;rocks.toml&lt;/code&gt; file, which you can commit to version control.&lt;/li&gt; &#xA;  &lt;li&gt;If you specify &lt;code&gt;dev&lt;/code&gt; or &lt;code&gt;scm&lt;/code&gt; as the version, luarocks will search the &lt;code&gt;dev&lt;/code&gt; manifest. This has the side-effect that it will prioritise &lt;code&gt;dev&lt;/code&gt; versions of any dependencies that aren&#39;t declared with version constraints.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Updating rocks&lt;/h3&gt; &#xA;&lt;p&gt;Running the &lt;code&gt;:Rocks update&lt;/code&gt; command will attempt to update every available rock if it is not pinned.&lt;/p&gt; &#xA;&lt;h3&gt;Syncing rocks&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:Rocks sync&lt;/code&gt; command synchronizes the installed rocks with the &lt;code&gt;rocks.toml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE]&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Installs missing rocks.&lt;/li&gt; &#xA;  &lt;li&gt;Ensures that the correct versions are installed.&lt;/li&gt; &#xA;  &lt;li&gt;Uninstalls unneeded rocks.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Uninstalling rocks&lt;/h3&gt; &#xA;&lt;p&gt;To uninstall a rock and any of its dependencies, that are no longer needed, run the &lt;code&gt;:Rocks prune {rock}&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE]&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;The command provides fuzzy completions for rocks that can safely be pruned without breaking dependencies.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Editing &lt;code&gt;rocks.toml&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:Rocks edit&lt;/code&gt; command opens the &lt;code&gt;rocks.toml&lt;/code&gt; file for manual editing. Make sure to run &lt;code&gt;:Rocks sync&lt;/code&gt; when you are done.&lt;/p&gt; &#xA;&lt;h3&gt;Lazy loading plugins&lt;/h3&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;rocks.nvim&lt;/code&gt; will source all plugins at startup. To prevent it from sourcing a plugin, you can specify &lt;code&gt;opt = true&lt;/code&gt; in the &lt;code&gt;rocks.toml&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[plugins]&#xA;neorg = { version = &#34;1.0.0&#34;, opt = true }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[plugins.neorg]&#xA;version = &#34;1.0.0&#34;&#xA;opt = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then load the plugin with the &lt;code&gt;:Rocks[!] packadd {rock}&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE]&lt;/p&gt; &#xA; &lt;p&gt;A note on loading rocks:&lt;/p&gt; &#xA; &lt;p&gt;Luarocks packages are installed differently than you are used to from Git repositories.&lt;/p&gt; &#xA; &lt;p&gt;Specifically, &lt;code&gt;luarocks&lt;/code&gt; installs a rock&#39;s Lua API to the &lt;a href=&#34;https://neovim.io/doc/user/luaref.html#package.path&#34;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&#34;https://neovim.io/doc/user/luaref.html#package.cpath&#34;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt;. It does not have to be added to Neovim&#39;s runtime path (e.g. using &lt;code&gt;:Rocks packadd&lt;/code&gt;), for it to become available. This does not impact Neovim&#39;s startup time.&lt;/p&gt; &#xA; &lt;p&gt;Runtime directories (&lt;a href=&#34;https://neovim.io/doc/user/options.html#&#39;runtimepath&#39;&#34;&gt;&lt;code&gt;:h runtimepath&lt;/code&gt;&lt;/a&gt;), on the other hand, are installed to a separate location. Plugins that utilise these directories may impact startup time (if it has &lt;code&gt;ftdetect&lt;/code&gt; or &lt;code&gt;plugin&lt;/code&gt; scripts), so you may or may not benefit from loading them lazily.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;&lt;span&gt;🌳&lt;/span&gt; Enhanced tree-sitter support&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;re revolutionizing the way Neovim users interact with tree-sitter parsers. With the introduction of the &lt;a href=&#34;https://github.com/nvim-neorocks/nurr&#34;&gt;Neovim User Rocks Repository (NURR)&lt;/a&gt;, we have automated the packaging and publishing of many plugins and curated[^1] tree-sitter parsers for luarocks, ensuring a seamless and efficient user experience.&lt;/p&gt; &#xA;&lt;p&gt;[^1]: We only upload parsers which we can install in the NURR CI (tested on Linux).&lt;/p&gt; &#xA;&lt;p&gt;When installing, rocks.nvim will also search our &lt;a href=&#34;https://nvim-neorocks.github.io/rocks-binaries-dev/&#34;&gt;rocks-binaries (dev)&lt;/a&gt; server, which means you don&#39;t even need to compile many parsers on your machine.&lt;/p&gt; &#xA;&lt;h3&gt;Effortless installation for users&lt;/h3&gt; &#xA;&lt;p&gt;If you need a tree-sitter parser for syntax highlighting or other features, you can easily install them with rocks.nvim: &lt;code&gt;:Rocks install tree-sitter-&amp;lt;lang&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;They come bundled with queries, so once installed, all you need to do is run &lt;code&gt;vim.treesitter.start()&lt;/code&gt; to enable syntax highlighting[^3].&lt;/p&gt; &#xA;&lt;p&gt;[^3]: You can put this in a &lt;code&gt;ftplugin/&amp;lt;filetype&amp;gt;.lua&lt;/code&gt;, for example. &lt;a href=&#34;https://github.com/nvim-treesitter/nvim-treesitter&#34;&gt;nvim-treesitter&lt;/a&gt; is still required for tree-sitter based folding, indentation, etc., but you don&#39;t need to configure it to install any parsers.&lt;/p&gt; &#xA;&lt;!-- Or, if you want something that comes with lots of tree-sitter parsers and --&gt; &#xA;&lt;!-- automatically configures nvim-treesitter for you, --&gt; &#xA;&lt;!-- check out our [`rocks-treesiter.nvim` module](https://github.com/nvim-neorocks/rocks-treesitter.nvim). --&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!WARNING]&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt; &lt;p&gt;Tree-sitter is an experimental feature of Neovim. As is the case with nvim-treesitter, please consider tree-sitter support in rocks.nvim experimental.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;We are not affiliated with the nvim-treesitter maintainers. If you are facing issues with tree-sitter support in rocks.nvim, please don&#39;t bug them.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Simplifying dependencies&lt;/h3&gt; &#xA;&lt;p&gt;For plugin developers, specifying a tree-sitter parser as a dependency is now as straightforward as including it in their project&#39;s rockspec&lt;a href=&#34;https://raw.githubusercontent.com/nvim-neorocks/rocks.nvim/master/%5Bexample%5D(https://luarocks.org/modules/mrcjkb/neotest-haskell).&#34;&gt;^2&lt;/a&gt;. This eliminates the need for manual parser management and ensures that dependencies are automatically resolved and installed.&lt;/p&gt; &#xA;&lt;p&gt;Example rockspec dependency specification:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;dependencies = {&#xA;  &#34;neotest&#34;,&#xA;  &#34;tree-sitter-haskell&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;span&gt;📦&lt;/span&gt; Extending &lt;code&gt;rocks.nvim&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;This plugin provides a Lua API for extensibility. See &lt;a href=&#34;https://raw.githubusercontent.com/nvim-neorocks/rocks.nvim/master/doc/rocks.txt&#34;&gt;&lt;code&gt;:h rocks.api&lt;/code&gt;&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;p&gt;Following are some examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-neorocks/rocks-git.nvim&#34;&gt;&lt;code&gt;rocks-git.nvim&lt;/code&gt;&lt;/a&gt;: Adds the ability to install plugins from git.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-neorocks/rocks-config.nvim&#34;&gt;&lt;code&gt;rocks-config.nvim&lt;/code&gt;&lt;/a&gt;: Adds an API for safely loading plugin configurations.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-neorocks/rocks-dev.nvim&#34;&gt;&lt;code&gt;rocks-dev.nvim&lt;/code&gt;&lt;/a&gt;: Adds an API for developing and testing luarocks plugins locally.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To extend &lt;code&gt;rocks.nvim&lt;/code&gt;, simply install a module with &lt;code&gt;:Rocks install&lt;/code&gt;, and you&#39;re good to go!&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;🩺&lt;/span&gt; Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;:Rocks log&lt;/code&gt; command opens a log file for the current session, which contains the &lt;code&gt;luarocks&lt;/code&gt; stderr output, among other logs.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;🔗&lt;/span&gt; Related projects&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-neorocks/luarocks-tag-release&#34;&gt;luarocks-tag-release&lt;/a&gt;: A GitHub action that automates publishing to luarocks.org&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-neorocks/nurr&#34;&gt;NURR&lt;/a&gt;: A repository that publishes Neovim plugins and tree-sitter parsers to luarocks.org&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/camspiers/luarocks&#34;&gt;luarocks.nvim&lt;/a&gt;: Adds basic support for installing lua rocks to &lt;a href=&#34;https://github.com/folke/lazy.nvim&#34;&gt;lazy.nvim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;span&gt;📖&lt;/span&gt; License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;rocks.nvim&lt;/code&gt; is licensed under &lt;a href=&#34;https://raw.githubusercontent.com/nvim-neorocks/rocks.nvim/master/LICENSE&#34;&gt;GPLv3&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;💚&lt;/span&gt; Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are more than welcome! See &lt;a href=&#34;https://raw.githubusercontent.com/nvim-neorocks/rocks.nvim/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for a guide.&lt;/p&gt;</summary>
  </entry>
</feed>