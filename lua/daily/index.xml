<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-20T01:38:40Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>00sapo/visual.nvim</title>
    <updated>2023-07-20T01:38:40Z</updated>
    <id>tag:github.com,2023-07-20:/00sapo/visual.nvim</id>
    <link href="https://github.com/00sapo/visual.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;First select, then edit. A helix/kakoune-like editing in neovim&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Visual.nvim&lt;/h1&gt; &#xA;&lt;p&gt;First select, then edit. This should be the way.&lt;/p&gt; &#xA;&lt;p&gt;If you have been tempted by Kakoune and Helix editors, this may be your new plugin!&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Just install it using your preferred package manager.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Lazy: &lt;code&gt;{ &#39;00sapo/visual.nvim&#39; }&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Packer: &lt;code&gt;use { &#39;00sapo/visual.nvim&#39; }&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Suggested config&lt;/h3&gt; &#xA;&lt;p&gt;Example with Lazy and Treesitter incremental selection&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;    &#39;00sapo/visual.nvim&#39;,&#xA;    config = function ()&#xA;        require(&#39;nvim-treesitter.configs&#39;).setup { &#xA;            incremental_selection = { &#xA;                enable = true,&#xA;                keymaps = {&#xA;                    init_selection = &#34;gn&#34;,&#xA;                    node_incremental = &#34;|&#34;,&#xA;                    scope_incremental = &#34;_&#34;,&#xA;                    node_decremental = &#34;\&#34;&#34;,&#xA;                }&#xA;            } &#xA;        }&#xA;        -- in lunarvim:&#xA;        -- lvim.builtin.treesitter.incremental_selection = {&#xA;        --     enable = true,&#xA;        --     keymaps = {&#xA;        --         init_selection = &#34;gn&#34;,&#xA;        --         node_incremental = &#34;|&#34;,&#xA;        --         scope_incremental = _;&#34;,&#xA;        --         node_decremental = &#34;\&#34;&#34;,&#xA;        --     }&#xA;        -- }&#xA;    end,&#xA;    dependencies = { &#39;nvim-treesitter/nvim-treesitter&#39; }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How it works&lt;/h2&gt; &#xA;&lt;p&gt;The plugin remap keys so that they select text objects/regions before you can type the edit command. It&#39;s basically like having a &lt;code&gt;v&lt;/code&gt; key automatically typed before any command. Consequently, some keymaps already available will still be used, especially &lt;code&gt;o&lt;/code&gt; in visual mode will be your new companion key!&lt;/p&gt; &#xA;&lt;h2&gt;Keymaps&lt;/h2&gt; &#xA;&lt;p&gt;The plugin is highly customizable. It maps commands to keymaps, and you cna define new commands or edit the existing ones. The following is the default set-up. Read the comments to understand how to modify it.&lt;/p&gt; &#xA;&lt;p&gt;Feel free to suggest new default keybindings in the issues!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt; require(&#39;visual&#39;).setup{&#xA;     mappings = {&#xA;       -- a list of command names, mapped to a lhs of mapping for visual and&#xA;       -- normal mode&#xA;       WORD_next = &#34;E&#34;, -- select next WORD (punctuation included)&#xA;       word_next = &#34;e&#34;, -- select next word (no punctuation included)&#xA;       WORD_prev = &#34;gE&#34;, -- select previous WORD&#xA;       word_prev = &#34;ge&#34;, -- select previous word&#xA;       till_next_word = &#34;w&#34;, -- select next word including next its space&#xA;       till_next_WORD = &#34;W&#34;, -- select next WORD including its next space&#xA;       till_prev_word = &#34;b&#34;, -- select previous word including its previous space&#xA;       till_prev_WORD = &#34;B&#34;, -- select previous WORD including its previous space&#xA;       -- from_cursor_to_end_word = &#34;E&#34;, -- select from the cursor position to the end of the word (as traditional e)&#xA;       -- from_cursor_to_start_word = &#34;B&#34;, -- select from the cursor position to the beginning of the word (as traditional b)&#xA;       find_next = &#34;f&#34;, -- select to next char&#xA;       find_prev = &#34;F&#34;, -- select to previous char&#xA;       till_next = &#34;t&#34;, -- select till next char&#xA;       till_prev = &#34;T&#34;, -- select till previous char&#xA;       append_at_cursor = &#34;a&#34;, -- append at cursor position&#xA;       insert_at_cursor = &#34;i&#34;, -- insert at cursor position&#xA;       select_inside = &#34;si&#34;, -- select inside&#xA;       select_around = &#34;sa&#34;, -- select around&#xA;     },&#xA;     only_normal_mappings = {&#xA;       -- mappings applied to normal mode only:&#xA;       -- {lhs, {rhs1, rhs2, rhs3}}&#xA;       line_select = {&#34;x&#34;, {&#34;&amp;lt;S-v&amp;gt;&#34;}},&#xA;       block_select = {&#34;&amp;lt;S-x&amp;gt;&#34;, {&#34;&amp;lt;C-v&amp;gt;&#34;}},&#xA;       delete_char = {&#34;y&#34;, {&#34;x&#34;}}&#xA;     },&#xA;     only_visual_mappings = {&#xA;       -- mappings applied to visual mode only:&#xA;       -- {lhs, {rhs1, rhs2, rhs3}}&#xA;       line_select = {&#34;x&#34;, {&#34;&amp;lt;S-v&amp;gt;&#34;}},&#xA;       block_select = {&#34;X&#34;, {&#34;&amp;lt;C-v&amp;gt;&#34;}},&#xA;       restart_selection = {&#34;&#39;&#34;, {&#34;&amp;lt;esc&amp;gt;v&#34;}},&#xA;       delete_single_char = {&#34;D&#34;, {&#34;d&#34;}}, -- delete char under cursor&#xA;       replace_single_char = {&#34;R&#34;, {&#34;r&#34;}}, -- replace char under cursor&#xA;      -- if they are strings, use the value from &#34;commands&#34; table&#xA;       extend_word_end = &#34;-e&#34;, -- extend until end of word&#xA;       extend_word_prev = &#34;-b&#34;, -- extend current selection until previous begin of word&#xA;       extend_word_next = &#34;-w&#34;, -- extend current selection until next word&#xA;       extend_find_next = &#34;-f&#34;, -- extend current selection to next char&#xA;       extend_find_prev = &#34;-F&#34;, -- extend current selection to previous char&#xA;       extend_till_next = &#34;-t&#34;, -- extend current selection till next char&#xA;       extend_till_prev = &#34;-T&#34;, -- extend current selection till previous char&#xA;     },&#xA;     commands = {&#xA;       -- what each command name does:&#xA;       WORD_next = {&#xA;         -- first, the editor is switched to normal mode&#xA;         {&#34;W&#34;}, -- if the command is launched in visual mode, these keys are executed&#xA;         -- then, the editor is switched to visual mode&#xA;         {&#34;iW&#34;}, -- then, these keys are executed&#xA;         -- in place of keys, you can use one or more functions (no argument&#xA;         -- allowed), or both of them&#xA;         false&#xA;         -- the final argument indicates if this command can be counted (e.g. 3w, 4e,&#xA;         -- etc.)&#xA;         -- this is true by default and applies to the second set of keys only&#xA;       },&#xA;       &#xA;       word_next = {{&#34;w&#34;}, {&#34;iw&#34;}, false},&#xA;       WORD_prev = {{&#34;B&#34;}, {&#34;iWo&#34;}, false,},&#xA;       word_prev = {{&#34;b&#34;}, {&#34;iwo&#34;}, false},&#xA;       till_next_word = {{&#34;w&#34;}, {&#34;wh&#34;}},&#xA;       till_next_WORD = {{&#34;W&#34;}, {&#34;Wh&#34;}},&#xA;       till_prev_word = {{&#34;b&#34;}, {&#34;gelowgeo&#34;}},&#xA;       till_prev_WORD = {{&#34;B&#34;}, {&#34;gEloWgEo&#34;}},&#xA;       extend_word_end = {{}, {&#34;gve&#34;}},&#xA;       extend_word_prev = {{}, {&#34;gvb&#34;}},&#xA;       extend_word_next = {{}, {&#34;gvw&#34;}},&#xA;       extend_word_next = {{}, {&#34;gvw&#34;}},&#xA;       extend_find_next = {{}, {&#34;gvf&#34;}},&#xA;       extend_find_prev = {{}, {&#34;gvF&#34;}},&#xA;       extend_till_next = {{}, {&#34;gvt&#34;}},&#xA;       extend_till_prev = {{}, {&#34;gvT&#34;}},&#xA;       find_next = {{}, {&#34;f&#34;}},&#xA;       find_prev = {{}, {&#34;F&#34;}},&#xA;       till_next = {{}, {&#34;t&#34;}},&#xA;       till_prev = {{}, {&#34;T&#34;}},&#xA;       append_at_cursor = {{}, {&#34;&amp;lt;esc&amp;gt;a&#34;}, false},&#xA;       insert_at_cursor = {{}, {&#34;&amp;lt;esc&amp;gt;i&#34;}, false},&#xA;       select_inside = {{}, {&#34;i&#34;}, false},&#xA;       select_around = {{}, {&#34;a&#34;}, false},&#xA;     },&#xA;     -- commands that can be unmapped (for learning new keymaps)&#xA;     unmaps = {&#34;W&#34;, &#34;E&#34;, &#34;B&#34;, &#34;ys&#34;, &#34;d&#34;, &#34;&amp;lt;S-v&amp;gt;&#34;, &#34;&amp;lt;C-v&amp;gt;&#34;, &#34;gc&#34;},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;TODO&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Selection history is being developed&lt;/li&gt; &#xA; &lt;li&gt;Some commands misbehave the selection history (&lt;code&gt;gv&lt;/code&gt;). For instance, when using &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; in visual mode (replace and delete char at cursor position) or &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, the selection is lost; the history of selections will solve it&lt;/li&gt; &#xA; &lt;li&gt;History of selections will also improve commands for extending current selection&lt;/li&gt; &#xA; &lt;li&gt;History of selections will allow to edit/append/remove surrounding chars without additional plugins&lt;/li&gt; &#xA; &lt;li&gt;History of commands will allow to repeat commands, including edits&lt;/li&gt; &#xA; &lt;li&gt;Experiment with &lt;code&gt;vim-visual-multi&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Improve commands for extending selections&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>nvimdev/guard.nvim</title>
    <updated>2023-07-20T01:38:40Z</updated>
    <id>tag:github.com,2023-07-20:/nvimdev/guard.nvim</id>
    <link href="https://github.com/nvimdev/guard.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;async fast minimalist plugin make format easy in neovim&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;guard.nvim&lt;/h2&gt; &#xA;&lt;p&gt;Async formatting and linting utility for neovim.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Blazingly fast&lt;/li&gt; &#xA; &lt;li&gt;Async using coroutine and luv spawn&lt;/li&gt; &#xA; &lt;li&gt;Builtin support for popular formatters and linters&lt;/li&gt; &#xA; &lt;li&gt;Light-weight&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Use any plugin manager you like. Guard is configured in format like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;ft(&#39;c&#39;):fmt(&#39;tool-1&#39;)&#xA;       :append(&#39;tool-2&#39;)&#xA;       :lint(&#39;lint-tool-1&#39;)&#xA;       :append(&#39;lint-tool-2&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;if the tool is not supported, you will have to pass in a table instead of a string, see &lt;a href=&#34;https://github.com/nvimdev/guard.nvim/tree/main/lua%2Fguard%2Ftools&#34;&gt;here&lt;/a&gt; for some examples, more info below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local ft = require(&#39;guard.filetype&#39;)&#xA;&#xA;-- use clang-format and clang-tidy for c files&#xA;ft(&#39;c&#39;):fmt(&#39;clang-format&#39;)&#xA;       :lint(&#39;clang-tidy&#39;)&#xA;&#xA;-- use stylua to format lua files and no linter&#xA;ft(&#39;lua&#39;):fmt(&#39;stylua&#39;)&#xA;&#xA;-- use lsp to format first then use golines to format&#xA;ft(&#39;go&#39;):fmt(&#39;lsp&#39;)&#xA;        :append(&#39;golines&#39;)&#xA;        :lint(&#39;golangci&#39;)&#xA;&#xA;-- call setup LAST&#xA;require(&#39;guard&#39;).setup({&#xA;    -- the only option for the setup function&#xA;    fmt_on_save = true,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;GuardFmt&lt;/code&gt; to manually call format, use &lt;code&gt;GuardDisable&lt;/code&gt; to diable auto format. and you can create a keymap like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.keymap.set({&#39;n&#39;,&#39;v&#39;}, &#39;&amp;lt;cmd&amp;gt;GuardFmt&amp;lt;CR&amp;gt;&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Builtin tools&lt;/h3&gt; &#xA;&lt;h4&gt;Formatter&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp&lt;/code&gt; use &lt;code&gt;vim.lsp.buf.format&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clang-format&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;prettier&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rustfmt&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;stylua&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;golines&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;black&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rubocop&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Table format for custom tool:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    cmd              --string tool command&#xA;    args             --table command arugments&#xA;    fname            --string insert filename to args tail&#xA;    stdin            --boolean pass buffer contents into stdin&#xA;    timeout          --integer&#xA;    ignore_pattern   --table ignore run format when pattern match&#xA;    ignore_error     --when has lsp error ignore format&#xA;&#xA;    --special&#xA;    fn       --function if fn is set other field will not take effect&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Linter&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;clang-tidy&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Pylint&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rubocop&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Trobuleshooting&lt;/h2&gt; &#xA;&lt;p&gt;if guard does not auto format on save, run &lt;code&gt;checkhealth&lt;/code&gt; first.&lt;/p&gt; &#xA;&lt;h2&gt;License MIT&lt;/h2&gt;</summary>
  </entry>
  <entry>
    <title>wiremod/wire</title>
    <updated>2023-07-20T01:38:40Z</updated>
    <id>tag:github.com,2023-07-20:/wiremod/wire</id>
    <link href="https://github.com/wiremod/wire" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Garry&#39;s Mod add-on that allows users to wire up components in order to make more elaborate automatic and user-controlled contraptions.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Wiremod &lt;a href=&#34;https://raw.githubusercontent.com/wiremod/wire/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/wiremod/wire?color=red&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/H8UKY3Y&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/231131817640460288?label=Discord&amp;amp;logo=discord&amp;amp;logoColor=ffffff&amp;amp;labelColor=7289DA&amp;amp;color=2c2f33&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://steamcommunity.com/sharedfiles/filedetails/?id=160250458&#34;&gt;&lt;img src=&#34;https://img.shields.io/steam/subscriptions/160250458?logo=steam&#34; alt=&#34;Workshop&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;An addon for &lt;a href=&#34;https://garrysmod.com&#34;&gt;Garry&#39;s Mod&lt;/a&gt; which adds entities that communicate via wires. It can be used to create robots, vehicles, computers and much more!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;⬇️ Installation&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Addon&lt;/th&gt; &#xA;   &lt;th&gt;Workshop&lt;/th&gt; &#xA;   &lt;th&gt;GitHub&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Wiremod&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://steamcommunity.com/sharedfiles/filedetails/?id=160250458&#34;&gt;&lt;img src=&#34;https://img.shields.io/steam/subscriptions/160250458?logo=steam&#34; alt=&#34;Wiremod&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/wiremod/wire&#34;&gt;https://github.com/wiremod/wire&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;AdvDupe2&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://steamcommunity.com/sharedfiles/filedetails/?id=773402917&#34;&gt;&lt;img src=&#34;https://img.shields.io/steam/subscriptions/773402917?logo=steam&#34; alt=&#34;AdvDupe2&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/wiremod/advdupe2&#34;&gt;https://github.com/wiremod/advdupe2&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Wire Extras&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/wiremod/wire-extras/issues/113&#34;&gt;None yet&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/wiremod/wire-extras&#34;&gt;https://github.com/wiremod/wire-extras&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For git, inside of &lt;code&gt;steamapps/common/Garrysmod/garrysmod/addons&lt;/code&gt;, run &lt;code&gt;git clone https://github.com/wiremod/wire&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;📖 Documentation&lt;/h2&gt; &#xA;&lt;p&gt;You can find documentation &lt;a href=&#34;https://github.com/wiremod/wire/wiki&#34;&gt;on our wiki&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;🤝 Contributing&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Before contributing to wiremod, take a look at the &lt;a href=&#34;https://raw.githubusercontent.com/wiremod/wire/master/CODE_OF_CONDUCT.md&#34;&gt;code of conduct&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;💡 Suggestions&lt;/h3&gt; &#xA;&lt;p&gt;To submit a suggestion, &lt;a href=&#34;https://github.com/wiremod/wire/discussions/new?category=suggestions&#34;&gt;use the discussions page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;🐛 Bug Reports&lt;/h3&gt; &#xA;&lt;p&gt;To submit a bug report, &lt;a href=&#34;https://github.com/wiremod/wire/issues/new/choose&#34;&gt;make an issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;🧑‍💻 Pull Requests&lt;/h3&gt; &#xA;&lt;p&gt;Before making a PR, ensure your code follows the &lt;a href=&#34;https://github.com/wiremod/wire/wiki/Developer-Style-Guide&#34;&gt;developer style guide&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>