<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-31T01:35:18Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kevinhwang91/nvim-fundo</title>
    <updated>2023-08-31T01:35:18Z</updated>
    <id>tag:github.com,2023-08-31:/kevinhwang91/nvim-fundo</id>
    <link href="https://github.com/kevinhwang91/nvim-fundo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Forever undo in Neovim&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;nvim-fundo&lt;/h1&gt; &#xA;&lt;p&gt;The goal of nvim-fundo is to make Neovim&#39;s undo file become stable and useful.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/17562139/202656014-85bc84ca-30b1-4093-9546-a06f17effc73.mp4&#34;&gt;https://user-images.githubusercontent.com/17562139/202656014-85bc84ca-30b1-4093-9546-a06f17effc73.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;WIP. If you like this plugin, star it to let me speed up to end WIP state.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Restore undo history even if the file&#39;s content has been changed outside Neovim&lt;/li&gt; &#xA; &lt;li&gt;Limit size for archives&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;TODO Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Restore undo history even if the file has been moved&lt;/li&gt; &#xA; &lt;li&gt;Support useful use cases for undo file&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/neovim/neovim&#34;&gt;Neovim&lt;/a&gt; 0.7.2 or later&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Install with &lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;Packer.nvim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use {&#xA;    &#39;kevinhwang91/nvim-fundo&#39;, requires = &#39;kevinhwang91/promise-async&#39;,&#xA;     run = function() require(&#39;fundo&#39;).install() end&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Minimal configuration&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use {&#xA;    &#39;kevinhwang91/nvim-fundo&#39;, requires = &#39;kevinhwang91/promise-async&#39;,&#xA;     run = function() require(&#39;fundo&#39;).install() end&#xA;}&#xA;&#xA;vim.o.undofile = true&#xA;require(&#39;fundo&#39;).setup()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;Use undo file as usual.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;h3&gt;How does nvim-undo keep the undo history?&lt;/h3&gt; &#xA;&lt;p&gt;Fundo will keep the latest files as archives, in other words, it takes additional space in your disk. If the &lt;code&gt;BufReadPost&lt;/code&gt; event is fired, it will validate the undo file and restore it if necessary.&lt;/p&gt; &#xA;&lt;h3&gt;Setup and description&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;    archives_dir = {&#xA;        description = [[The directory to store the archives]],&#xA;        default = vim.fn.stdpath(&#39;cache&#39;) .. path.separator .. &#39;fundo&#39;&#xA;    },&#xA;    limit_archives_size = {&#xA;        description = [[Limit the archives directory size, unit is MB(megabyte), elder files will be&#xA;        removed based on their modified time]],&#xA;        default = 512&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;:h fundo&lt;/code&gt; may help you to get the all default configuration.&lt;/p&gt; &#xA;&lt;h3&gt;API&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kevinhwang91/nvim-fundo/main/lua/fundo.lua&#34;&gt;fundo.lua&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Run tests&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;make test&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Feedback&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you get an issue or come up with an awesome idea, don&#39;t hesitate to open an issue in github.&lt;/li&gt; &#xA; &lt;li&gt;If you think this plugin is useful or cool, consider rewarding it a star.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The project is licensed under a BSD-3-clause license. See &lt;a href=&#34;https://raw.githubusercontent.com/kevinhwang91/nvim-fundo/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>piersolenski/wtf.nvim</title>
    <updated>2023-08-31T01:35:18Z</updated>
    <id>tag:github.com,2023-08-31:/piersolenski/wtf.nvim</id>
    <link href="https://github.com/piersolenski/wtf.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Delicious diagnostic debugging in Neovim ü§§&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ü§Ø wtf.nvim&lt;/h1&gt; &#xA;&lt;p&gt;A Neovim plugin to help you work out &lt;em&gt;what the fudge&lt;/em&gt; that diagnostic means &lt;strong&gt;and&lt;/strong&gt; how to fix it!&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;wtf.nvim&lt;/code&gt; provides faster and more efficient ways of working with the buffer line&#39;s diagnostic messages by redirecting them to your favourite resources straight from Neovim.&lt;/p&gt; &#xA;&lt;p&gt;Works with any language that has &lt;a href=&#34;https://microsoft.github.io/language-server-protocol/&#34;&gt;LSP&lt;/a&gt; support in Neovim.&lt;/p&gt; &#xA;&lt;h2&gt;‚ú® Features&lt;/h2&gt; &#xA;&lt;h3&gt;AI powered diagnostic debugging&lt;/h3&gt; &#xA;&lt;p&gt;Use the power of &lt;a href=&#34;https://openai.com/blog/chatgpt&#34;&gt;ChatGPT&lt;/a&gt; to provide you with explanations &lt;em&gt;and&lt;/em&gt; solutions for how to fix diagnostics, custom tailored to the code responsible for them.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/piersolenski/wtf.nvim/assets/1285419/9b7ab8b1-2dc4-4a18-8051-68745305198a&#34;&gt;https://github.com/piersolenski/wtf.nvim/assets/1285419/9b7ab8b1-2dc4-4a18-8051-68745305198a&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Search the web for answers&lt;/h3&gt; &#xA;&lt;p&gt;Why spend time copying and pasting, or worse yet, typing out diagnostic messages, when you can open a search for them in Google, Stack Overflow and more, directly from Neovim?&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/piersolenski/wtf.nvim/assets/1285419/6697d9a5-c81c-4e54-b375-bbe900724077&#34;&gt;https://github.com/piersolenski/wtf.nvim/assets/1285419/6697d9a5-c81c-4e54-b375-bbe900724077&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üî© Installation&lt;/h2&gt; &#xA;&lt;p&gt;In order to use the AI functionality, set the environment variable &lt;code&gt;OPENAI_API_KEY&lt;/code&gt; to your &lt;a href=&#34;https://platform.openai.com/account/api-keys&#34;&gt;openai api key&lt;/a&gt; (the search functionality will still work without it).&lt;/p&gt; &#xA;&lt;p&gt;Install the plugin with your preferred package manager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Packer&#xA;use({&#xA;  &#34;piersolenski/wtf.nvim&#34;,&#xA;    config = function()&#xA;      require(&#34;wtf&#34;).setup()&#xA;    end,&#xA;    requires = {&#xA;      &#34;MunifTanjim/nui.nvim&#34;,&#xA;    }&#xA;})&#xA;&#xA;-- Lazy&#xA;{&#xA;&#x9;&#34;piersolenski/wtf.nvim&#34;,&#xA;&#x9;dependencies = {&#xA;&#x9;&#x9;&#34;MunifTanjim/nui.nvim&#34;,&#xA;&#x9;},&#xA;&#x9;event = &#34;VeryLazy&#34;,&#xA;  &#x9;opts = {},&#xA;&#x9;keys = {&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#34;gw&#34;,&#xA;&#x9;&#x9;&#x9;mode = { &#34;n&#34; },&#xA;&#x9;&#x9;&#x9;function()&#xA;&#x9;&#x9;&#x9;&#x9;require(&#34;wtf&#34;).ai()&#xA;&#x9;&#x9;&#x9;end,&#xA;&#x9;&#x9;&#x9;desc = &#34;Debug diagnostic with AI&#34;,&#xA;&#x9;&#x9;},&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;mode = { &#34;n&#34; },&#xA;&#x9;&#x9;&#x9;&#34;gW&#34;,&#xA;&#x9;&#x9;&#x9;function()&#xA;&#x9;&#x9;&#x9;&#x9;require(&#34;wtf&#34;).search()&#xA;&#x9;&#x9;&#x9;end,&#xA;&#x9;&#x9;&#x9;desc = &#34;Search diagnostic with Google&#34;,&#xA;&#x9;&#x9;},&#xA;&#x9;},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;‚öôÔ∏è Configuration&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;    -- Default AI popup type&#xA;    popup_type = &#34;popup&#34; | &#34;horizontal&#34; | &#34;vertical&#34;,&#xA;    -- An alternative way to set your OpenAI api key&#xA;    openai_api_key = &#34;sk-xxxxxxxxxxxxxx&#34;,&#xA;    -- ChatGPT Model&#xA;    openai_model_id = &#34;gpt-3.5-turbo&#34;,&#xA;    -- Set your preferred language for the response&#xA;    language = &#34;english&#34;,&#xA;    -- Any additional instructions&#xA;    additional_instructions = &#34;Start the reply with &#39;OH HAI THERE&#39;&#34;,&#xA;    -- Default search engine, can be overridden by passing an option to WtfSeatch &#xA;    search_engine = &#34;google&#34; | &#34;duck_duck_go&#34; | &#34;stack_overflow&#34; | &#34;github&#34;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;üöÄ Usage&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;wtf.nvim&lt;/code&gt; works by sending the line&#39;s diagnostic messages along with contextual information (such as the offending code, file type and severity level) to various sources you can configure.&lt;/p&gt; &#xA;&lt;p&gt;To use it, whenever you have an hint, warning or error in an LSP enabled environment, invoke one of the commands anywhere on that line in Normal mode:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;:Wtf [additional_instructions]&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Sends the current line along with all diagnostic messages to ChatGPT. Additional instructions can also be specified, which might be useful if you want to refine the response further.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;:WtfSearch [search_engine]&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Uses a search engine (defaults to the one in the setup or Google if not provided) to search for the &lt;strong&gt;first&lt;/strong&gt; diagnostic. It will attempt to filter out unrelated strings specific to your local environment, such as file paths, for broader results.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Custom status hooks&lt;/h3&gt; &#xA;&lt;p&gt;You can add custom hooks to update your status line or other UI elements, for example, this code updates the status line colour to yellow whilst the request is in progress.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.g[&#34;wtf_hooks&#34;] = {&#xA;&#x9;request_started = function()&#xA;&#x9;&#x9;vim.cmd(&#34;hi StatusLine ctermbg=NONE ctermfg=yellow&#34;)&#xA;&#x9;end,&#xA;  request_finished = vim.schedule_wrap(function()&#xA;&#x9;&#x9;vim.cmd(&#34;hi StatusLine ctermbg=NONE ctermfg=NONE&#34;)&#xA;&#x9;end)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Lualine Status Component&lt;/h3&gt; &#xA;&lt;p&gt;There is a helper function &lt;code&gt;get_status&lt;/code&gt; so that you can add a status component to &lt;a href=&#34;https://github.com/nvim-lualine/lualine.nvim&#34;&gt;lualine&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local wtf = require(&#34;wtf&#34;)&#xA;&#xA;require(&#39;lualine&#39;).setup({&#xA;    sections = {&#xA;        lualine_x = { wtf.get_status },&#xA;    }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;üí° Inspiration&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/yoavbls/pretty-ts-errors&#34;&gt;Pretty TypeScript Errors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/james1236/backseat.nvim/&#34;&gt;backseat.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dpayne/CodeGPT.nvim&#34;&gt;CodeGPT.nvim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>lewis6991/pckr.nvim</title>
    <updated>2023-08-31T01:35:18Z</updated>
    <id>tag:github.com,2023-08-31:/lewis6991/pckr.nvim</id>
    <link href="https://github.com/lewis6991/pckr.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Spiritual successor of https://github.com/wbthomason/packer.nvim&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;pckr.nvim&lt;/h1&gt; &#xA;&lt;p&gt;Spiritual successor of &lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;https://github.com/wbthomason/packer.nvim&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üöß WIP üöß&lt;/h2&gt; &#xA;&lt;p&gt;Main differences to pckr.nvim:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Heavily refactored&lt;/li&gt; &#xA; &lt;li&gt;Lockfile support&lt;/li&gt; &#xA; &lt;li&gt;No compilation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lewis6991/pckr.nvim/main/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lewis6991/pckr.nvim/main/#requirements&#34;&gt;Requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lewis6991/pckr.nvim/main/#quickstart&#34;&gt;Quickstart&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lewis6991/pckr.nvim/main/#example&#34;&gt;Example&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lewis6991/pckr.nvim/main/#commands&#34;&gt;Commands&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lewis6991/pckr.nvim/main/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lewis6991/pckr.nvim/main/#the-setup-and-add-function&#34;&gt;The setup and add functions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lewis6991/pckr.nvim/main/#custom-initialization&#34;&gt;Custom Initialization&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lewis6991/pckr.nvim/main/#specifying-plugins&#34;&gt;Specifying Plugins&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lewis6991/pckr.nvim/main/#performing-plugin-management-operations&#34;&gt;Performing plugin management operations&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lewis6991/pckr.nvim/main/#debugging&#34;&gt;Debugging&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Declarative plugin specification&lt;/li&gt; &#xA; &lt;li&gt;Support for dependencies&lt;/li&gt; &#xA; &lt;li&gt;Extensible&lt;/li&gt; &#xA; &lt;li&gt;Post-install/update hooks&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;code&gt;git&lt;/code&gt; tags, branches, revisions&lt;/li&gt; &#xA; &lt;li&gt;Support for local plugins&lt;/li&gt; &#xA; &lt;li&gt;Lockfile support&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;You need to be running Neovim v0.9 or newer&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;If you are on Windows 10, you need developer mode enabled in order to use local plugins (creating symbolic links requires admin privileges on Windows - credit to @TimUntersberger for this note)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;If you want to automatically install and set up &lt;code&gt;pckr.nvim&lt;/code&gt; on any machine you clone your configuration to, add the following snippet somewhere in your config &lt;strong&gt;before&lt;/strong&gt; your first usage of &lt;code&gt;pckr&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local function bootstrap_pckr()&#xA;  local pckr_path = vim.fn.stdpath(&#34;data&#34;) .. &#34;/pckr/pckr.nvim&#34;&#xA;&#xA;  if not vim.loop.fs_stat(pckr_path) then&#xA;    vim.fn.system({&#xA;      &#39;git&#39;,&#xA;      &#39;clone&#39;,&#xA;      &#34;--filter=blob:none&#34;,&#xA;      &#39;https://github.com/lewis6991/pckr.nvim&#39;,&#xA;      pckr_path&#xA;    })&#xA;  end&#xA;&#xA;  vim.opt.rtp:prepend(pckr_path)&#xA;end&#xA;&#xA;bootstrap_pckr()&#xA;&#xA;require(&#39;pckr&#39;).add{&#xA;  -- My plugins here&#xA;  -- &#39;foo1/bar1.nvim&#39;;&#xA;  -- &#39;foo2/bar2.nvim&#39;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- This file can be loaded by calling `lua require(&#39;plugins&#39;)` from your init.vim&#xA;&#xA;local cmd = require(&#39;pckr.loader.cmd&#39;)&#xA;local keys = require(&#39;pckr.loader.keys&#39;)&#xA;&#xA;require(&#39;pckr&#39;).add{&#xA;  -- Simple plugins can be specified as strings&#xA;  &#39;9mm/vim-closer&#39;;&#xA;&#xA;  -- Lazy loading:&#xA;  -- Load on specific commands&#xA;  {&#39;tpope/vim-dispatch&#39;,&#xA;    cond = {&#xA;      cmd {&#39;Dispatch&#39;, &#39;Make&#39;, &#39;Focus&#39;, &#39;Start&#39;}&#xA;    }&#xA;  };&#xA;&#xA;  -- Load on specific keymap&#xA;  {&#39;tpope/vim-commentary&#39;, cond = keys(&#39;n&#39;, &#39;gc&#39;) },&#xA;&#xA;  -- Load on a combination of conditions: specific filetypes or commands&#xA;  -- Also run code after load (see the &#34;config&#34; key)&#xA;  { &#39;w0rp/ale&#39;,&#xA;    cond = cmd(&#39;ALEEnable&#39;),&#xA;    config = function()&#xA;      vim.cmd[[ALEEnable]]&#xA;    end&#xA;  };&#xA;&#xA;  -- Local plugins can be included&#xA;  &#39;~/projects/personal/hover.nvim&#39;;&#xA;&#xA;  -- Plugins can have post-install/update hooks&#xA;  {&#39;iamcco/markdown-preview.nvim&#39;, run = &#39;cd app &amp;amp;&amp;amp; yarn install&#39;, cond = cmd(&#39;MarkdownPreview&#39;)};&#xA;&#xA;  -- Post-install/update hook with neovim command&#xA;  { &#39;nvim-treesitter/nvim-treesitter&#39;, run = &#39;:TSUpdate&#39; };&#xA;&#xA;  -- Post-install/update hook with call of vimscript function with argument&#xA;  { &#39;glacambre/firenvim&#39;, run = function()&#xA;    vim.fn[&#39;firenvim#install&#39;](0)&#xA;  end };&#xA;&#xA;  -- Use specific branch, dependency and run lua file after load&#xA;  { &#39;glepnir/galaxyline.nvim&#39;,&#xA;    branch = &#39;main&#39;,&#xA;    requires = {&#39;kyazdani42/nvim-web-devicons&#39;},&#xA;    config = function()&#xA;      require&#39;statusline&#39;&#xA;    end&#xA;  };&#xA;&#xA;  -- Run config *before* the plugin is loaded&#xA;  {&#39;whatyouhide/vim-lengthmatters&#39;, config_pre = function()&#xA;    vim.g.lengthmatters_highlight_one_column = 1&#xA;    vim.g.lengthmatters_excluded = {&#39;pckr&#39;}&#xA;  end},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Commands&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;pckr&lt;/code&gt; provides the following commands.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;&#34; Remove any disabled or unused plugins&#xA;:Pckr clean&#xA;&#xA;&#34; Install missing plugins&#xA;:Pckr install&#xA;&#xA;&#34; Update installed plugins&#xA;:Pckr update [plugin]&#xA;&#xA;&#34; Clean, fix, install then update&#xA;&#34; supports the `--preview` flag as an optional first argument to preview updates&#xA;:Pckr sync&#xA;&#xA;&#34; View status of plugins&#xA;:Pckr status&#xA;&#xA;&#34; Create a lockfile of plugins with their current commits&#xA;:Pckr lock&#xA;&#xA;&#34; Restore plugins using saved lockfile&#xA;:Pckr restore&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The following is a more in-depth explanation of &lt;code&gt;pckr&lt;/code&gt;&#39;s features and use.&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; functions&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;pckr&lt;/code&gt; provides&lt;code&gt;pckr.add(spec)&lt;/code&gt;, which is used in the above examples where &lt;code&gt;spec&lt;/code&gt; is a table specifying a single or multiple plugins.&lt;/p&gt; &#xA;&lt;h3&gt;Custom Initialization&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;pckr.setup()&lt;/code&gt; can be used to provide custom configuration (note that this is optional). The default configuration values (and structure of the configuration table) are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;pckr&#39;).setup{&#xA;  package_root        = util.join_paths(vim.fn.stdpath(&#39;data&#39;), &#39;site&#39;, &#39;pack&#39;),&#xA;  max_jobs            = nil, -- Limit the number of simultaneous jobs. nil means no limit&#xA;  autoremove          = false, -- Remove unused plugins&#xA;  autoinstall         = true, -- Auto install plugins&#xA;  git = {&#xA;    cmd = &#39;git&#39;, -- The base command for git operations&#xA;    depth = 1, -- Git clone depth&#xA;    clone_timeout = 60, -- Timeout, in seconds, for git clones&#xA;    default_url_format = &#39;https://github.com/%s&#39; -- Lua format string used for &#34;aaa/bbb&#34; style plugins&#xA;  },&#xA;  log = { level = &#39;warn&#39; }, -- The default print log level. One of: &#34;trace&#34;, &#34;debug&#34;, &#34;info&#34;, &#34;warn&#34;, &#34;error&#34;, &#34;fatal&#34;.&#xA;  opt_dir = ...,&#xA;  start_dir = ...,&#xA;  lockfile = {&#xA;    path = util.join_paths(vim.fn.stdpath(&#39;config&#39;, &#39;pckr&#39;, &#39;lockfile.lua&#39;))&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying plugins&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;pckr&lt;/code&gt; is based around declarative specification of plugins.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Absolute paths to a local plugin&lt;/li&gt; &#xA; &lt;li&gt;Full URLs (treated as plugins managed with &lt;code&gt;git&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;username/repo&lt;/code&gt; paths (treated as Github &lt;code&gt;git&lt;/code&gt; plugins)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Plugin specs can take two forms:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;A list of plugin specifications (strings or tables)&lt;/li&gt; &#xA; &lt;li&gt;A table specifying a single plugin. It must have a plugin location string as its first element, and may additionally have a number of optional keyword elements, shown below:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  &#39;myusername/example&#39;,    -- The plugin location string&#xA;&#xA;  -- The following keys are all optional&#xA;&#xA;  -- Specifies a git branch to use&#xA;  branch: string?,&#xA;&#xA;  -- Specifies a git tag to use. Supports &#39;*&#39; for &#34;latest tag&#34;&#xA;  tag: string?,&#xA;&#xA;  -- Specifies a git commit to use&#xA;  commit: string?,&#xA;&#xA;  -- Skip updating this plugin in updates/syncs. Still cleans.&#xA;  lock: boolean?,&#xA;&#xA;  -- Post-update/install hook. See &#34;update/install hooks&#34;.&#xA;  run: string|function,&#xA;&#xA;  -- Specifies plugin dependencies. See &#34;dependencies&#34;.&#xA;  requires: string|string[],&#xA;&#xA;  -- Specifies code to run after this plugin is loaded. If string then require it.&#xA;  -- E.g:&#xA;  --   config = function() require(&#39;mod&#39;) end&#xA;  -- is equivalent to:&#xA;  --   config = &#39;mod&#39;&#xA;  config: string|function,&#xA;&#xA;  -- Specifies code to run before this plugin is loaded. If string then require it.&#xA;  config_pre: string|function,&#xA;&#xA;  cond: function|function[],    -- Specifies custom loader&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Update/install hooks&lt;/h4&gt; &#xA;&lt;p&gt;You may specify operations to be run after successful installs/updates of a plugin with the &lt;code&gt;run&lt;/code&gt; key. This key may either be a Lua function, which will be called with the &lt;code&gt;plugin&lt;/code&gt; table for this plugin (containing the information passed to the spec as well as output from the installation/update commands, the installation path of the plugin, etc.), a string, or a table of functions and strings.&lt;/p&gt; &#xA;&lt;p&gt;If an element of &lt;code&gt;run&lt;/code&gt; is a string, then either:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;If the first character of &lt;code&gt;run&lt;/code&gt; is &#34;:&#34;, it is treated as a Neovim command and executed.&lt;/li&gt; &#xA; &lt;li&gt;Otherwise, &lt;code&gt;run&lt;/code&gt; is treated as a shell command and run in the installation directory of the plugin via &lt;code&gt;$SHELL -c &#39;&amp;lt;run&amp;gt;&#39;&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Dependencies&lt;/h4&gt; &#xA;&lt;p&gt;Plugins may specify dependencies via the &lt;code&gt;requires&lt;/code&gt; key. This key can be a string or a list (table).&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;requires&lt;/code&gt; is a string, it is treated as specifying a single plugin. If a plugin with the name given in &lt;code&gt;requires&lt;/code&gt; is already known in the managed set, nothing happens. Otherwise, the string is treated as a plugin location string and the corresponding plugin is added to the managed set.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;requires&lt;/code&gt; is a list, it is treated as a list of plugin specifications following the format given above.&lt;/p&gt; &#xA;&lt;p&gt;Plugins specified in &lt;code&gt;requires&lt;/code&gt; are removed when no active plugins require them.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üöß &lt;strong&gt;TODO&lt;/strong&gt;: explain that plugins can only be specified as a table once.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Custom loader&lt;/h4&gt; &#xA;&lt;p&gt;A custom loader for a plugin may be specified via &lt;code&gt;cond&lt;/code&gt;. This is a function which has a function as its first argument. When this function argument is called, the plugin is loaded.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following plugin is lazy-loaded on the key mapping &lt;code&gt;ga&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;pckr.add{&#xA;  {&#34;my/plugin&#34;, cond = function(load_plugin)&#xA;    vim.keymap.set(&#39;n&#39;, &#39;ga&#39;, function()&#xA;      vim.keymap.del(&#39;n&#39;, &#39;ga&#39;)&#xA;      load_plugin()&#xA;      vim.api.nvim_input(&#39;ga&#39;)&#xA;    end)&#xA;  end}&#xA;}&#xA;&#xA;  -- equivalent to --&#xA;&#xA;local keys = require(&#39;pckr.loader.keys&#39;)&#xA;pckr.add{&#xA;  {&#34;my/plugin&#34;, cond = keys(&#39;n&#39;, &#39;ga&#39;) },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Performing plugin management operations&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üöß &lt;strong&gt;TODO&lt;/strong&gt;:&lt;/p&gt; &#xA; &lt;p&gt;API here will be similar to what it was before with the only exception being the final argument to every command will be a callback which is called when the operation finishes.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;code&gt;pckr&lt;/code&gt; exposes the following functions for common plugin management operations. In all of the below, &lt;code&gt;plugins&lt;/code&gt; is an optional table of plugin names; if not provided, the default is &#34;all managed plugins&#34;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;pckr.install(plugins)&lt;/code&gt;: Install the specified plugins if they are not already installed&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pckr.update(plugins)&lt;/code&gt;: Update the specified plugins, installing any that are missing&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pckr.update(opts, plugins)&lt;/code&gt;: First argument can be a table specifying options, such as &lt;code&gt;{preview_updates = true}&lt;/code&gt; to preview potential changes before updating (same as &lt;code&gt;PckrUpdate --preview&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pckr.clean()&lt;/code&gt;: Remove any disabled or no longer managed plugins&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Debugging&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;pckr.nvim&lt;/code&gt; logs to &lt;code&gt;stdpath(cache)/pckr.nvim.log&lt;/code&gt;. Looking at this file is usually a good start if something isn&#39;t working as expected.&lt;/p&gt;</summary>
  </entry>
</feed>