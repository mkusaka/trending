<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-16T01:35:57Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Mycroft-Studios/Mycroft-Farewell</title>
    <updated>2022-11-16T01:35:57Z</updated>
    <id>tag:github.com,2022-11-16:/Mycroft-Studios/Mycroft-Farewell</id>
    <link href="https://github.com/Mycroft-Studios/Mycroft-Farewell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;[Mycroft] Final Farewell&lt;/h1&gt; &#xA;&lt;p&gt;For those of you whom are reading this, thank you.&lt;/p&gt; &#xA;&lt;p&gt;My time within the FiveM community has been amazing, going from a simple developer making a little server to the Owner and Director of ESX.&lt;/p&gt; &#xA;&lt;p&gt;But, as the time passes, so does my enjoyment and passion. And unfortunately, I just no longer have the motivation or passion to continue making things for FiveM.&lt;/p&gt; &#xA;&lt;p&gt;So, to say my goodbyes, I am leaving behind a final pack. This pack contains everything that i have worked on between 2020-2022 that is not yet public. The States of these resources vairy from barely started to completely finished. But, i would rather have them out in the public, for people to see and maybe learn from.&lt;/p&gt; &#xA;&lt;p&gt;Finally, i want to say thank you to FuraXx and ArkSeyonet/LazarusRising for giving me such amazing opportunities and i wish the Best of luck to Benzo &amp;amp; Jean-Baptiste on their adventure continuing the amazing Work at ESX. I also wish the best of luck to ChatDisabled on his adventures making Qbox, which looks very promising and will extend my hopes and wishes to Kakarot in hopes that QB-Core can make a promising comeback from their publicly known downwards spiral they have been in recently.&lt;/p&gt; &#xA;&lt;p&gt;Thanks for Reading, Mycroft.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cshuaimin/ssr.nvim</title>
    <updated>2022-11-16T01:35:57Z</updated>
    <id>tag:github.com,2022-11-16:/cshuaimin/ssr.nvim</id>
    <link href="https://github.com/cshuaimin/ssr.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Treesitter based structural search and replace plugin for Neovim.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ssr.nvim&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.jetbrains.com/help/idea/structural-search-and-replace.html&#34;&gt;Structural search and replace&lt;/a&gt; for Neovim.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/24775746/199903092-a499dee1-af0a-444f-8ac1-24102454196f.mov&#34;&gt;https://user-images.githubusercontent.com/24775746/199903092-a499dee1-af0a-444f-8ac1-24102454196f.mov&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;with packer.nvim:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use {&#xA;  &#34;cshuaimin/ssr.nvim&#34;,&#xA;  module = &#34;ssr&#34;,&#xA;  -- Calling setup is optional.&#xA;  config = function()&#xA;    require(&#34;ssr&#34;).setup {&#xA;      min_width = 50,&#xA;      min_height = 5,&#xA;      keymaps = {&#xA;        close = &#34;q&#34;,&#xA;        next_match = &#34;n&#34;,&#xA;        prev_match = &#34;N&#34;,&#xA;        replace_all = &#34;&amp;lt;leader&amp;gt;&amp;lt;cr&amp;gt;&#34;,&#xA;      },&#xA;    }&#xA;  end&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then add a mapping to open SSR:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.keymap.set({ &#34;n&#34;, &#34;x&#34; }, &#34;&amp;lt;leader&amp;gt;sr&#34;, function() require(&#34;ssr&#34;).open() end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;First put your cursor on the structure you want to search and replace (if you are not sure, select a region instead), then open SSR by pressing &lt;code&gt;&amp;lt;leader&amp;gt;sr&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In the SSR float window you can see the placeholder search code, you can replace part of it with wildcards. A whildcard is an identifier starts with &lt;code&gt;$&lt;/code&gt;, like &lt;code&gt;$name&lt;/code&gt;. A &lt;code&gt;$name&lt;/code&gt; wildcard in the search pattern will match any AST node and &lt;code&gt;$name&lt;/code&gt; will reference it in the replacement.&lt;/p&gt; &#xA;&lt;p&gt;Press &lt;code&gt;&amp;lt;leader&amp;gt;&amp;lt;cr&amp;gt;&lt;/code&gt; to replace all matches in current buffer.&lt;/p&gt; &#xA;&lt;h2&gt;The context&lt;/h2&gt; &#xA;&lt;p&gt;When opening SSR, the cursor position is important, you need to put the cursor on the structure you want to search. If the placeholder code is not correct, exit SSR with &lt;code&gt;q&lt;/code&gt; and select the region instead.&lt;/p&gt; &#xA;&lt;p&gt;ssr.nvim parses your search pattern to syntax trees to perform structural searching. However directly parsing code without context is not accurate, for example TypeScript function argument &lt;code&gt;foo: number&lt;/code&gt; will be parsed as a label without context, so ssr.nvim parses pattern in it&#39;s original context.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;ssr.nvim performs searching and replacing at AST level and doesn&#39;t understand code as much as LSP servers do. Use LSP server&#39;s ssr implementation if possible.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Wansmer/treesj</title>
    <updated>2022-11-16T01:35:57Z</updated>
    <id>tag:github.com,2022-11-16:/Wansmer/treesj</id>
    <link href="https://github.com/Wansmer/treesj" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Neovim plugin for splitting/joining blocks of code&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;TreeSJ: split or join blocks of code&lt;/h1&gt; &#xA;&lt;p&gt;Neovim plugin for splitting/joining blocks of code like arrays, hashes, statements, objects, dictionaries, etc. Written in Lua, using &lt;a href=&#34;https://tree-sitter.github.io/tree-sitter/&#34;&gt;Tree-Sitter&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Inspired by and partly repeats the functionality of &lt;a href=&#34;https://github.com/AndrewRadev/splitjoin.vim&#34;&gt;splitjoin.vim&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;âš¡Disclaimer: The plugin is under active development. Documentation will be added when all planned features are implemented. Feel free to open an issue or PR ðŸ’ª&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/46977173/201088511-b336cec5-cec4-437f-95b3-0208c83377fd.mov&#34;&gt;https://user-images.githubusercontent.com/46977173/201088511-b336cec5-cec4-437f-95b3-0208c83377fd.mov&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;sup align=&#34;center&#34;&gt;Theme: &lt;a href=&#34;https://github.com/catppuccin/nvim&#34;&gt;Catppuccin&lt;/a&gt;, Font: JetBrains Mono&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Can be called from anywhere in the block&lt;/strong&gt;: No need to move cursor to specified place to split/join block of code;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Make cursor sticky&lt;/strong&gt;: The cursor follows the text on which it was called;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Autodetect mode&lt;/strong&gt;: Toggle-mode present. Split or join blocks by same key mapping;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Do it recursively&lt;/strong&gt;: Expand or collapse all nested nodes? Yes, you can;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Recognize nested languages&lt;/strong&gt;: Filetype doesn&#39;t matter, detect language with treesitter.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/neovim/neovim/releases&#34;&gt;Neovim 0.8+&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-treesitter/nvim-treesitter&#34;&gt;nvim-treesitter&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;packer.nvim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use({&#xA;  &#39;Wansmer/treesj&#39;,&#xA;  requires = { &#39;nvim-treesitter&#39; },&#xA;  config = function()&#xA;    require(&#39;treesj&#39;).setup({--[[ your config ]]})&#xA;  end,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h3&gt;Plugin configuration&lt;/h3&gt; &#xA;&lt;p&gt;Default configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local tsj = require(&#39;treesj&#39;)&#xA;&#xA;local langs = {--[[ configuration for languages ]]}&#xA;&#xA;tsj.setup({&#xA;  -- Use default keymaps&#xA;  -- (&amp;lt;space&amp;gt;m - toggle, &amp;lt;space&amp;gt;j - join, &amp;lt;space&amp;gt;s - split)&#xA;  use_default_keymaps = true,&#xA;&#xA;  -- Node with syntax error will not be formatted&#xA;  check_syntax_error = true,&#xA;&#xA;  -- If line after join will be longer than max value,&#xA;  -- node will not be formatted&#xA;  max_join_length = 120,&#xA;&#xA;  -- hold|start|end:&#xA;  -- hold - cursor follows the node/place on which it was called&#xA;  -- start - cursor jumps to the first symbol of the node being formatted&#xA;  -- end - cursor jumps to the last symbol of the node being formatted&#xA;  cursor_behavior = &#39;hold&#39;,&#xA;&#xA;  -- Notify about possible problems or not&#xA;  notify = true,&#xA;  langs = langs,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, TreeSJ provide user commands:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;:TSJToggle&lt;/code&gt; - toggle node under cursor (split if one-line and join if multiline);&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:TSJSplit&lt;/code&gt; - split node under cursor;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:TSJJoin&lt;/code&gt; - split node under cursor;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Languages configuration&lt;/h3&gt; &#xA;&lt;p&gt;By default, TreeSJ has presets for these languages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Javascript&lt;/strong&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Typescript&lt;/strong&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Lua&lt;/strong&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;CSS&lt;/strong&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;SCSS&lt;/strong&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;HTML&lt;/strong&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Vue&lt;/strong&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;JSON&lt;/strong&gt;;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For adding your favorite language, add it to &lt;code&gt;langs&lt;/code&gt; sections in your configuration.&lt;/p&gt; &#xA;&lt;p&gt;To find out what nodes are called in your language, analyze your code with &lt;a href=&#34;https://github.com/nvim-treesitter/playground&#34;&gt;nvim-treesitter/playground&lt;/a&gt; or look in the &lt;a href=&#34;https://tree-sitter.github.io/tree-sitter/&#34;&gt;source code of the parsers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local langs = {&#xA;  javascript = {&#xA;    array = {--[[ preset ]]},&#xA;    object = {--[[ preset ]]}&#xA;    [&#39;function&#39;] = { target_nodes = {--[[ targets ]]}}&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have completely configured your language, and it works as well as you expected, feel free to open PR and share it.&lt;/p&gt; &#xA;&lt;h3&gt;Nodes configuration&lt;/h3&gt; &#xA;&lt;p&gt;Default preset for node:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local somenode = {&#xA;  -- Use for split and join. Will merge to both resulting presets&#xA;  -- If you need various values for different modes,&#xA;  -- it can be overridden in modes sections&#xA;  both = {&#xA;    -- string[]: TreeSJ will stop if node contains node from list&#xA;    no_format_with = { &#39;comment&#39; },&#xA;&#xA;    -- string: Separator for arrays, objects, hash e.c.t.&#xA;    -- Will auto add to option &#39;omit&#39; for &#39;both&#39;&#xA;    separator = &#39;&#39;,&#xA;&#xA;    -- boolean: Set last separator or not&#xA;    last_separator = false,&#xA;&#xA;    -- string[]: Nodes in list will be joined for previous node&#xA;    -- (e.g. tag_name in HTML start_tag or separator (&#39;,&#39;) in JS object) &#xA;    -- NOTE: Must be same for both modes&#xA;    omit = {},&#xA;  },&#xA;&#xA;  -- Use only for join. If contains field from &#39;both&#39;,&#xA;  -- field here have higher priority&#xA;  join = {&#xA;&#xA;    -- Adding space in framing brackets or last/end element&#xA;    space_in_brackets = false,&#xA;&#xA;    -- Count of spaces between nodes&#xA;    space_separator = 1,&#xA;&#xA;    -- string: Add instruction separator like &#39;;&#39; in statement block&#xA;    -- Will auto add to option &#39;omit&#39; for &#39;both&#39;&#xA;    force_insert = &#39;&#39;,&#xA;&#xA;    -- string[]: The insert symbol will be omitted if node contains in this list &#xA;    -- (e.g. function_declaration inside statement_block in JS no require instruction separator (&#39;;&#39;))&#xA;    no_insert_if = {},&#xA;&#xA;    -- boolean: All nested configured nodes will process according to their presets&#xA;    recursive = true,&#xA;&#xA;    -- [string]: Type of configured node that must be ignored &#xA;    recursive_ignore = {},&#xA;  },&#xA;&#xA;  -- Use only for split. If contains field from &#39;both&#39;,&#xA;  -- field here have higher priority&#xA;  split = {&#xA;    -- boolean: All nested configured nodes will process according to their presets&#xA;    recursive = false,&#xA;&#xA;    -- [string]: Type of configured node that must be ignored &#xA;    -- E.g., you probably don&#39;t want the parameters of each nested function to be expanded.&#xA;    recursive_ignore = {},&#xA;  },&#xA;  -- If &#39;true&#39;, node will be completely removed from langs preset&#xA;  disable = false,&#xA;&#xA;  -- TreeSJ will search child from list into this node and redirect to found child&#xA;  -- If list not empty, another fields (split, join) will be ignored&#xA;  target_nodes = {},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All nodes in every language have similar characteristics. TreeSJ provide default presets for common nodes:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;set_default_preset(override)&lt;/code&gt; - default.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;set_preset_for_list(override)&lt;/code&gt; - list-like nodes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;set_preset_for_dict(override)&lt;/code&gt; - dict-like nodes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;set_preset_for_statement(override)&lt;/code&gt; - statement-like nodes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;set_preset_for_args(override)&lt;/code&gt; - arguments-like nodes.&lt;/p&gt; &#xA;&lt;p&gt;Takes a table with the settings to be overwritten as an argument.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage example&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local tsj_utils = require(&#39;treesj.langs.utils&#39;)&#xA;&#xA;local langs = {&#xA;  javascript = {&#xA;    object = tsj_utils.set_preset_for_dict(),&#xA;    array = tsj_utils.set_preset_for_list(),&#xA;    formal_parameters = tsj_utils.set_preset_for_args(),&#xA;    arguments = tsj_utils.set_preset_for_args(),&#xA;    statement_block = tsj_utils.set_preset_for_statement({&#xA;      join = {&#xA;        no_insert_if = {&#xA;          &#39;function_declaration&#39;,&#xA;          &#39;try_statement&#39;,&#xA;          &#39;if_statement&#39;,&#xA;        },&#xA;      },&#xA;    }),&#xA;  },&#xA;  lua = {&#xA;    table_constructor = tsj_utils.set_preset_for_dict(),&#xA;    arguments = tsj_utils.set_preset_for_args(),&#xA;    parameters = tsj_utils.set_preset_for_args(),&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, you can use whole preset for language if your language has the same types of nodes:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;For example, &lt;code&gt;css&lt;/code&gt; and &lt;code&gt;scss&lt;/code&gt; have the same structure, and you can use already configured preset&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local tsj_utils = require(&#39;treesj.langs.utils&#39;)&#xA;local css = require(&#39;treesj.langs.css&#39;)&#xA;&#xA;local langs = {&#xA;  scss = u.merge_preset(css, {--[[&#xA;    Here you can override existing nodes &#xA;    or add language-specific nodes&#xA;]]})&#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How it works&lt;/h2&gt; &#xA;&lt;p&gt;When you run the plugin, TreeSJ detects the node under the cursor, recognizes the language, and looks for it in the presets. If the current node is not configured, TreeSJ checks the parent node, and so on, until a configured node is found.&lt;/p&gt; &#xA;&lt;p&gt;Presets for node can be two types:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;With preset for self - if this type is found, the node will be formatted;&lt;/li&gt; &#xA; &lt;li&gt;With referens for nested nodes - in this case, search will be continued among this node descendants;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&#34;|&#34; - meaning cursor&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const arr = [ 1, 2, 3 ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;// with preset for self&#xA;const arr = [ 1, |2, 3 ];&#xA;                 |      &#xA;    first node is &#39;number&#39; - not configured,&#xA;    parent node is &#39;array&#39; - configured and will be split&#xA;&#xA;// with referens&#xA;cons|t arr = [ 1, 2, 3 ];&#xA;    |      &#xA;  first node is &#39;variable_declarator&#39; - not configured,&#xA;  parent node is &#39;lexical_declaration&#39; - configured and has reference&#xA;  { target_nodes = { &#39;array&#39;, &#39;object&#39; } },&#xA;  first configured nested node is &#39;array&#39; and array will be splitted&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>