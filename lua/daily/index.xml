<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-19T01:35:43Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zbirenbaum/copilot.lua</title>
    <updated>2022-10-19T01:35:43Z</updated>
    <id>tag:github.com,2022-10-19:/zbirenbaum/copilot.lua</id>
    <link href="https://github.com/zbirenbaum/copilot.lua" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lua plugin for starting and interacting with github copilot&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;copilot.lua&lt;/h1&gt; &#xA;&lt;p&gt;This plugin is the pure lua replacement for &lt;a href=&#34;https://github.com/github/copilot.vim&#34;&gt;github/copilot.vim&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Motivation behind `copilot.lua`&lt;/summary&gt; &#xA; &lt;p&gt;While using &lt;code&gt;copilot.vim&lt;/code&gt;, for the first time since I started using neovim my laptop began to overheat. Additionally, I found the large chunks of ghost text moving around my code, and interfering with my existing cmp ghost text disturbing. As lua is far more efficient and makes things easier to integrate with modern plugins, this repository was created.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;Install the plugin with your preferred plugin manager. For example, with &lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;packer.nvim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use { &#34;zbirenbaum/copilot.lua&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Authentication&lt;/h3&gt; &#xA;&lt;p&gt;Once copilot is started, run &lt;code&gt;:Copilot auth&lt;/code&gt; to start the authentication process.&lt;/p&gt; &#xA;&lt;h2&gt;Setup and Configuration&lt;/h2&gt; &#xA;&lt;p&gt;You have to run the &lt;code&gt;require(&#34;copilot&#34;).setup(options)&lt;/code&gt; function in order to start Copilot. If no options are provided, the defaults are used.&lt;/p&gt; &#xA;&lt;p&gt;Because the copilot server takes some time to start up, It is recommend that you lazy load copilot. This can be done in multiple ways, the best one will depend on your existing config and the speed of your machine:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;On &lt;code&gt;VimEnter&lt;/code&gt; event + defer (preferred method, works well with fast configs):&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use {&#xA;  &#34;zbirenbaum/copilot.lua&#34;,&#xA;  event = &#34;VimEnter&#34;,&#xA;  config = function()&#xA;    vim.defer_fn(function()&#xA;      require(&#34;copilot&#34;).setup()&#xA;    end, 100)&#xA;  end,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Load after statusline + defer (if option 1 causes statusline to flicker, try this):&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use {&#xA;  &#34;zbirenbaum/copilot.lua&#34;,&#xA;  after = &#34;feline.nvim&#34;, -- whichever statusline plugin you use here&#xA;  config = function ()&#xA;    vim.defer_fn(function()&#xA;      require(&#34;copilot&#34;).setup()&#xA;    end, 100)&#xA;  end,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;On &lt;code&gt;InsertEnter&lt;/code&gt; event (safest way to avoid startup lag):&lt;br&gt; Note: suggestions may take a moment to start showing up.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use {&#xA;  &#34;zbirenbaum/copilot.lua&#34;,&#xA;  event = &#34;InsertEnter&#34;,&#xA;  config = function ()&#xA;    vim.schedule(function()&#xA;      require(&#34;copilot&#34;).setup()&#xA;    end)&#xA;  end,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following is the default configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;copilot&#39;).setup({&#xA;  panel = {&#xA;    enabled = true,&#xA;    auto_refresh = false,&#xA;    keymap = {&#xA;      jump_prev = &#34;[[&#34;,&#xA;      jump_next = &#34;]]&#34;,&#xA;      accept = &#34;&amp;lt;CR&amp;gt;&#34;,&#xA;      refresh = &#34;gr&#34;,&#xA;      open = &#34;&amp;lt;M-CR&amp;gt;&#34;&#xA;    },&#xA;  },&#xA;  suggestion = {&#xA;    enabled = true,&#xA;    auto_trigger = false,&#xA;    debounce = 75,&#xA;    keymap = {&#xA;     accept = &#34;&amp;lt;M-l&amp;gt;&#34;,&#xA;     next = &#34;&amp;lt;M-]&amp;gt;&#34;,&#xA;     prev = &#34;&amp;lt;M-[&amp;gt;&#34;,&#xA;     dismiss = &#34;&amp;lt;C-]&amp;gt;&#34;,&#xA;    },&#xA;  },&#xA;  filetypes = {&#xA;    yaml = false,&#xA;    markdown = false,&#xA;    help = false,&#xA;    gitcommit = false,&#xA;    gitrebase = false,&#xA;    hgcommit = false,&#xA;    svn = false,&#xA;    cvs = false,&#xA;    [&#34;.&#34;] = false,&#xA;  },&#xA;  copilot_node_command = &#39;node&#39;, -- Node version must be &amp;lt; 18&#xA;  plugin_manager_path = vim.fn.stdpath(&#34;data&#34;) .. &#34;/site/pack/packer&#34;,&#xA;  server_opts_overrides = {},&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;panel&lt;/h3&gt; &#xA;&lt;p&gt;Panel can be used to preview suggestions in a split window. You can run the &lt;code&gt;:Copilot panel&lt;/code&gt; command to open it.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;auto_refresh&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the suggestions are refreshed as you type in the buffer.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;copilot.panel&lt;/code&gt; module exposes the following functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;copilot.panel&#34;).accept()&#xA;require(&#34;copilot.panel&#34;).jump_next()&#xA;require(&#34;copilot.panel&#34;).jump_prev()&#xA;require(&#34;copilot.panel&#34;).open()&#xA;require(&#34;copilot.panel&#34;).refresh()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;suggestion&lt;/h3&gt; &#xA;&lt;p&gt;When &lt;code&gt;auto_trigger&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, copilot starts suggesting as soon as you enter insert mode.&lt;/p&gt; &#xA;&lt;p&gt;When &lt;code&gt;auto_trigger&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, use the &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;prev&lt;/code&gt; keymap to trigger copilot suggestion.&lt;/p&gt; &#xA;&lt;p&gt;To toggle auto trigger for the current buffer, use &lt;code&gt;require(&#34;copilot.suggestion&#34;).toggle_auto_trigger()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Copilot suggestion is automatically hidden when &lt;code&gt;popupmenu-completion&lt;/code&gt; is open. In case you use a custom menu for completion, you can set the &lt;code&gt;copilot_suggestion_hidden&lt;/code&gt; buffer variable to &lt;code&gt;true&lt;/code&gt; to have the same behavior. For example, with &lt;code&gt;nvim-cmp&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;cmp.event:on(&#34;menu_opened&#34;, function()&#xA;  vim.b.copilot_suggestion_hidden = true&#xA;end)&#xA;&#xA;cmp.event:on(&#34;menu_closed&#34;, function()&#xA;  vim.b.copilot_suggestion_hidden = false&#xA;end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;copilot.suggestion&lt;/code&gt; module exposes the following functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;copilot.suggestion&#34;).is_visible()&#xA;require(&#34;copilot.suggestion&#34;).accept()&#xA;require(&#34;copilot.suggestion&#34;).next()&#xA;require(&#34;copilot.suggestion&#34;).prev()&#xA;require(&#34;copilot.suggestion&#34;).dismiss()&#xA;require(&#34;copilot.suggestion&#34;).toggle_auto_trigger()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;filetypes&lt;/h3&gt; &#xA;&lt;p&gt;Specify filetypes for attaching copilot.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;copilot&#34;).setup {&#xA;  filetypes = {&#xA;    markdown = true, -- overrides default&#xA;    terraform = false, -- disallow specific filetype&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you add &lt;code&gt;&#34;*&#34;&lt;/code&gt; as a filetype, the default configuration for &lt;code&gt;filetypes&lt;/code&gt; won&#39;t be used anymore. e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;copilot&#34;).setup {&#xA;  filetypes = {&#xA;    javascript = true, -- allow specific filetype&#xA;    typescript = true, -- allow specific filetype&#xA;    [&#34;*&#34;] = false, -- disable for all other filetypes and ignore default `filetypes`&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;copilot_node_command&lt;/h3&gt; &#xA;&lt;p&gt;Use this field to provide the path to a specific node version such as one installed by nvm. Node version must be &amp;lt; 18. The LTS version of node (16.17.0) is recommended.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;copilot_node_command = vim.fn.expand(&#34;$HOME&#34;) .. &#34;/.config/nvm/versions/node/v16.14.2/bin/node&#34;, -- Node version must be &amp;lt; 18&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;plugin_manager_path&lt;/h3&gt; &#xA;&lt;p&gt;This is installation path of Packer, change this to the plugin manager installation path of your choice.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;copilot&#34;).setup {&#xA;  plugin_manager_path = vim.fn.stdpath(&#34;data&#34;) .. &#34;/site/pack/packer&#34;, &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;server_opts_overrides&lt;/h3&gt; &#xA;&lt;p&gt;Override copilot lsp client settings. The &lt;code&gt;settings&lt;/code&gt; field is where you can set the values of the options defined in &lt;a href=&#34;https://raw.githubusercontent.com/zbirenbaum/copilot.lua/master/SettingsOpts.md&#34;&gt;SettingsOpts.md&lt;/a&gt;. These options are specific to the copilot lsp and can be used to customize its behavior. Ensure that the name field is not overriden as is is used for efficiency reasons in numerous checks to verify copilot is actually running. See &lt;code&gt;:h vim.lsp.start_client&lt;/code&gt; for list of options.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;copilot&#34;).setup {&#xA;  server_opts_overrides = {&#xA;    trace = &#34;verbose&#34;,&#xA;    settings = {&#xA;      advanced = {&#xA;        listCount = 10, -- #completions for panel&#xA;        inlineSuggestCount = 3, -- #completions for getCompletions&#xA;      }&#xA;    },&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Commands&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;copilot.lua&lt;/code&gt; defines the &lt;code&gt;:Copilot&lt;/code&gt; command that can perform various actions. It has completion support, so try it out.&lt;/p&gt; &#xA;&lt;h2&gt;Integrations&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;copilot.api&lt;/code&gt; module can be used to build integrations on top of &lt;code&gt;copilot.lua&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/zbirenbaum/copilot-cmp&#34;&gt;zbirenbaum/copilot-cmp&lt;/a&gt;: Integration with &lt;a href=&#34;https://github.com/hrsh7th/nvim-cmp&#34;&gt;&lt;code&gt;nvim-cmp&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>letoram/cat9</title>
    <updated>2022-10-19T01:35:43Z</updated>
    <id>tag:github.com,2022-10-19:/letoram/cat9</id>
    <link href="https://github.com/letoram/cat9" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A User shell for LASH&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cat9&lt;/h1&gt; &#xA;&lt;h1&gt;What is it?&lt;/h1&gt; &#xA;&lt;p&gt;Cat9 is a user shell script for LASH - a command-line shell that discriminates against terminal emulators, written in Lua. You probably have not heard of LASH before. If you really must know, check the Backstory section below.&lt;/p&gt; &#xA;&lt;p&gt;LASH just provides some basic shared infrastructure and a recovery shell. It then runs a user provided script that actually provides most of the rules for how the command line is supposed to look and behave.&lt;/p&gt; &#xA;&lt;p&gt;That brings us back to Cat9, which is my such script. You can use it as is or remix it into something different that fits you - see HACKING.md for more tips.&lt;/p&gt; &#xA;&lt;h1&gt;What can it do?&lt;/h1&gt; &#xA;&lt;p&gt;One of the bigger conveniences, on top of being quite snappy, is to run and cleanly separate multiple concurrent jobs asynchronously, with the results from &#39;out&#39; and &#39;err&#39; being kept until you decide to reuse or forget it. At the same time, traditionally noisy tasks like changing directories are blocked from polluting your view with irrelevant information.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/5888792/161494772-2abccac4-bb92-4a12-9a69-987e66201719.mp4&#34;&gt;https://user-images.githubusercontent.com/5888792/161494772-2abccac4-bb92-4a12-9a69-987e66201719.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This allows for neat visuals like changing layouts, reordering presentation, folding and unfolding. It also allows for reusing results of a previous job without thinking much about it - caching is the default and you don&#39;t need to redirect results to files just for reuse or re-execute pipelines when all you wanted was different processing of its old outputs.&lt;/p&gt; &#xA;&lt;p&gt;It is also designed with the intention of being able to frontend- legacy cli tools with little effort - the set of builtins that the shell provides can be contextually swapped for something specific to working with some domain or tool specific context. In this way, famously unfriendly tools can be worked around and integrated into your workflow as seemless as possible.&lt;/p&gt; &#xA;&lt;p&gt;It cooperates with your desktop window manager (should you have one), letting it take care of splitting out things into new windows or even embedding media or graphical application output into clipped regions of its own window.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/5888792/161494402-9e5636e3-dd78-4fcf-bff0-fe5c3dd0a369.mp4&#34;&gt;https://user-images.githubusercontent.com/5888792/161494402-9e5636e3-dd78-4fcf-bff0-fe5c3dd0a369.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;Building and setting this up is currently not for the faint of heart. It might look simple at first glance, but going against the grain of decades of accumulated legacy comes with some friction.&lt;/p&gt; &#xA;&lt;p&gt;For starters you want an Arcan build that comes straight from the source. The things needed here are new, unlikely covered by any release, and is actively worked on. &lt;a href=&#34;https://github.com/letoram/arcan&#34;&gt;Arcan&lt;/a&gt; is unpleasant to build from source and, if you want it to replace your entire display server, also a pain to setup. Twice the fun.&lt;/p&gt; &#xA;&lt;p&gt;For our ends here, it works just fine as a window that looks strangely much like a terminal emulator would look, but its innards are entirely different.&lt;/p&gt; &#xA;&lt;p&gt;If you managed to build Arcan to your liking, you then need to start Arcan with a suitable window manager.&lt;/p&gt; &#xA;&lt;p&gt;There are several to chose from, notable ones being:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Durden - Full tiling/stacking will all bells and whistles imaginable.&lt;/li&gt; &#xA; &lt;li&gt;Pipeworld - ZUI dataflow which is both crazy and awesome at the same time.&lt;/li&gt; &#xA; &lt;li&gt;Safespaces - VR, some say it is the future and others the future of the past.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Then there is the much more humble &#39;console&#39; that mimics the BSD/Linux console with just fullscreen and invisible tabs. Since it comes included with Arcan itself, we will go for that one. The way to actually start lash from within these vary, for console it is easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;arcan console lash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This should convince Arcan to setup a simple fullscreen graphical shell that then runs the textual command-line shell in lash. Alas the shell will be kindof useless. This is where Cat9 comes in.&lt;/p&gt; &#xA;&lt;p&gt;Underneath the surface it actually runs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ARCAN_ARG=cli=lua afsrv_terminal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;copy or link cat9.lua to $HOME/.arcan/lash/default.lua or cat9.lua (make the directory should it not exist) as well as the cat9 subdirectory so that there is a $HOME/.arcan/lash/cat9.&lt;/p&gt; &#xA;&lt;p&gt;Similarly, in Durden it would be global/open/terminal=cli=lua and for safespaces, tack on cli=lua to the terminal spawn line, e.g. layers/current/terminal=cli=lua. In recent Durden versions this has a shortcut as global/open/lash, and is also bound to m1+m2+enter.&lt;/p&gt; &#xA;&lt;p&gt;Next time you start the arcan console like above, if you picked the default.lua route it will start immediately - otherwise you have to manually tell lash to run the cat9 rulset with the shell command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;shell cat9&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This scans LASH_BASE, HOME/.arcan/lash and XDG_CONFIG_HOME/arcan/lash for a matching cat9.lua and switches over to that. It is also possible to set LASH_SHELL=cat9 and cat9.lua will be tried immediately instead of default.lua&lt;/p&gt; &#xA;&lt;p&gt;This extra set of steps is to allow multiple shells to coexist, so that there is a premade path for other rulesets to join the scene with less of a disadvantage.&lt;/p&gt; &#xA;&lt;h1&gt;Use&lt;/h1&gt; &#xA;&lt;p&gt;By default, commands will get tracked as a &#39;job&#39;. These get numeric identifiers and are referenced by a pound sign:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;find /tmp&#xA;repeat #0 flush&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These pounds can also use relative addresses, #-2 would point to the second latest job to be created. There are also special jobs, like #csel pointing to the currently cursor-selected job, and #last pointing to the latest created job.&lt;/p&gt; &#xA;&lt;p&gt;Most builtin commands use job references in one way or another. The context of these jobs, e.g. environment variables and path is tracked separately. By starting a command with a job reference, the current context is temporarily set to that of a previous job.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /usr/share&#xA;find . -&amp;gt; becomes job #0&#xA;cd /tmp&#xA;#0 pwd -&amp;gt; /usr/share&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Most strings entered will be executed as non-tty jobs. To run something specifically as a tty (ncurses or other &#39;terminal-tui&#39; like application), mark it with a ! to spawn a new window bound to a terminal emulator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;!vim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Window creation and process environment can be controlled (e.g. vertical split):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;v!vim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To forego any parsing or internal pipelineing and run the entire line verbatim (forwarded to sh -c) use !!:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;!!find /usr |grep share&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is also useful when you need to do shell expansions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;!!rm -rf *&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Certain clients really want a pseudoterminal or they refuse to do anything, for those clients, start with p! like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;p!vim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These will default switch to &#39;view wrap vt100&#39; that has a rudimentary terminal emulator state machine that need some more work (see base/vt100*).&lt;/p&gt; &#xA;&lt;p&gt;Data can be sliced out of a job into the current command-line with ctrl+space:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rm #0(1,3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and pressing ctrl+space would copy lines 1 and 3 and expand them into the current command line. This argument format is also supported by some builtins, typing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;copy #0(1-5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and pressing enter would copy the lines 1 to 5 into a new job.&lt;/p&gt; &#xA;&lt;h2&gt;Customisation&lt;/h2&gt; &#xA;&lt;p&gt;The config/default.lua file can be edited to change presentation, layout and similar options, including the formats for prompts and titlebars. Most of these options can also be reached at runtime via the &#39;config&#39; builtin, further below.&lt;/p&gt; &#xA;&lt;p&gt;Keybindings and mouse button presses act just like lines typed on the prompt, but are defined in the config/bindings.lua file. Keybindings are activated on ctrl+[key]. The following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bnd[tui.keys.A] = &#34;forget #-1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;would create a binding that whenever ctrl-A is pressed, the latest job created would be removed.&lt;/p&gt; &#xA;&lt;p&gt;Mouse buttons are similar, but the &#39;key&#39; is slightly more complex as they are split based on where you are clicking (titlebar, data body, ...). The currently most complex binding looks something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bnd.m2_data_col_click = &#34;view #csel select $=crow&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Would apply the builtin view command on the mouse-selected job at the current row offset if the second mouse button was clicked on the first column (line-number).&lt;/p&gt; &#xA;&lt;h2&gt;Builtins&lt;/h2&gt; &#xA;&lt;p&gt;There are a number of builtin commands. These are defined by a basedir, filled with separate files per builtin command along with a chainloader that match the name of the basedir:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cat9/default.lua&#xA;cat9/default/cd.lua&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reason for this structure is to allow lash to be reused for building CLI frontends to other tools, maintain a unified look and feel and swap between them quickly at will. You can also modify/extend this to mimic the behaviour of other common shells.&lt;/p&gt; &#xA;&lt;p&gt;These also include a set of views. A view is a script that defines how to present the data within a job, and controls things like colour and formatting, optional elements like line numbers as well as wrapping behaviour.&lt;/p&gt; &#xA;&lt;p&gt;The commands included in the default set are as follows:&lt;/p&gt; &#xA;&lt;h3&gt;Input&lt;/h3&gt; &#xA;&lt;p&gt;The input command is for controlling how parts of the UI responds to mouse or keyboard inputs. By default the keyboard is grabbed by the command-line. This grab can be released with CTRL+ESCAPE.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;input #jobid&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will only trigger for jobs that have a working input sink, and retain current focus if it does not.&lt;/p&gt; &#xA;&lt;h3&gt;Signal&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;signal #jobid or pid [signal: kill, hup, user1, user2, stop, quit, continue]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The signal commands send a signal to an active running job or a process based on a process identifier (number).&lt;/p&gt; &#xA;&lt;h3&gt;Config&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;config key value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The config options changes the runtime shell behavior configuration. It is populated by the keys and values in config/default.lua.&lt;/p&gt; &#xA;&lt;p&gt;Certain targets also allow properties to set, e.g. persistence or an alias:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;config #id alias myname&#xA;config #myname persist auto&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can be used to hot-reload settings and the code for default builtins:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;config =reload&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can be used to define aliases:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;config myalias &#34;my longer command&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When ctrl+space is used with readline, the last word will be swapped for the alias. This will not have a commit action, so the expansion is visible to avoid unpleasant surprises.&lt;/p&gt; &#xA;&lt;h3&gt;Open&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;open file or #job [hex] [new | vnew | tab]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This tries to open the contents of [file] through a designated handler. For the job mode specifically, it either switches the window to a text or hex buffer. It is also possible to pop it out as a new window or tab.&lt;/p&gt; &#xA;&lt;h3&gt;Forget&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;forget #job1 #job2&#xA;forget #job1  .. #job3&#xA;forget all-bad&#xA;forget all-passive&#xA;forget all-hard&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will remove the contents and tracking of previous jobs, either by specifying one or several distinct jobs, or a range. If any marked job is still active and tied to a running process, that process will be killed. There are also special presets: all-bad, all-hard and all-passive; all-bad forgets the completed jobs with !0 return status code; all-hard removes all jobs, passive and running; all-passive removes all jobs that have completed running.&lt;/p&gt; &#xA;&lt;h3&gt;Repeat&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;repeat #job [flush | edit]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will re-execute a previously job that has completed. If the flush argument is specified, any collected data from its previous run will be discarded. If the edit argument is specified, the command-line which spawned the job will be copied into the command line - and if executed, will append or flush into the existing job identifier.&lt;/p&gt; &#xA;&lt;h3&gt;Cd&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd directory&#xA;cd #job&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Change the current directory to the specified one, with regular absolute or relative syntax. It is also possible to cd back into the directory that was current when a specific job was created.&lt;/p&gt; &#xA;&lt;p&gt;Cd also tracks which directories commands are being run from and adds them to a history. This can be accessed via the special:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd f ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where the f will be omitted and the set of suggested completions will come from the list of favourites. This can be manually altered, using f- to remove a path and f+ . or f+ /some/path to add it to the favorites.&lt;/p&gt; &#xA;&lt;h3&gt;View&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;view #job stream [opt1] [opt2] .. [optn]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Changes job presentation based on the provided set of options. The possible options are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;scroll n - move the starting presentation offset from the last line read to n lines or bytes backwards.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;out or stdout - set the presentation buffer to be what is read from the standard output of the job.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;err or stderr - set the presentation buffer to be what is read from the standard error output of the job.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;col or collapse - only present a small number of lines.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;exp or expand - present as much of the buffer as possible.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;tog or toggle - switch between col and exp mode&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;linenumber - toggle showing a column with line numbers on/off&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There are also a number of dynamic views that can apply higher level transforms on the contents to change how it presents. One such view is &#39;wrap&#39;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;view #job wrap [vt100] [max-col]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This implements word wrap, optionally filtered through a terminal state machine (vt100) and with a custom column cap.&lt;/p&gt; &#xA;&lt;h3&gt;Copy&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;copy src [opts] [dst]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The copy command is used to copy data in and out of Cat9 itself, such as taking the output of a previous job and storing it in a file, into another running job or into a new job (if dst is not provided).&lt;/p&gt; &#xA;&lt;p&gt;By default, src and dst are treated as just names with normal semantics for absolute or relative paths. Depending on a prefix used, the role can change:&lt;/p&gt; &#xA;&lt;p&gt;Using # will treat it as a job reference.&lt;/p&gt; &#xA;&lt;p&gt;Using pick: will treat it as a request to an outer graphical shell (i.e. your wm) to provide a file, optionally with an extension hint:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;copy pick:iso test.iso&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The optional source arguments can be used to slice out subranges, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;copy #0 (1-10,20) dst&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which would copy lines 1 to 10 and line 20 of the current view buffer into the destination.&lt;/p&gt; &#xA;&lt;p&gt;Copy destinations do not have to be files, they can also be other interactive jobs, or special ones like clipboard: that would forward to the outer WM clipboard.&lt;/p&gt; &#xA;&lt;h3&gt;Env&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;env [#job] key value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is used to change the environment for new jobs. It can also be used to update the cached environment for an existing job. This environment will be applied if the job is repeated, or if a new job is derived from the context of one:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;env #0 LS_COLOR yes&#xA;#0 ls /tmp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Trigger&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;trigger #job condition [delay n] action&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is possible to attach several event triggers to a job that has an external action attached. The command for that is &#39;trigger&#39;. The condition can be either &#39;ok&#39; or &#39;fail&#39;, with an optional delay in seconds. The action is any regular command-line string (remember to encapsulate with &#34;&#34;).&lt;/p&gt; &#xA;&lt;p&gt;To remove previously set triggers, use &#39;flush&#39; instead of action.&lt;/p&gt; &#xA;&lt;p&gt;A common case for trigger is to repeat a job that finished:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;trigger #0 ok delay 10 &#34;repeat #0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Would keep the job #0 relaunching 10 seconds after completing until removed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;trigger #0 ok flush&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Backstory&lt;/h1&gt; &#xA;&lt;p&gt;Arcan is what some would call an ambitious project that takes more than a few minutes to wrap your head around. Among its many subprojects are SHMIF and TUI. SHMIF is an IPC system -- initially to compartment and sandbox media parsing that quickly evolved to encompass all inter-process communication needed for something on the scale of a full desktop.&lt;/p&gt; &#xA;&lt;p&gt;TUI is an API layered on top of SHMIF client side, along with a text packing format (TPACK). It was first used to write a terminal emulator that came bundled with Arcan, and then evolved towards replacing all uses of ECMA-48 and related escape codes, as well as kernel-tty and userspace layers. The end goal being completely replacing all traces of ncurses, readline, in-band signalling and so on -- to get much needed improved CLIs and TUIs that cooperate with an outer graphical desktop shell rather than obliviously combat it.&lt;/p&gt; &#xA;&lt;p&gt;This journey has been covered in several articles, the most important ones being &#39;the dawn of a new command line interface&#39; and the more recent &#39;the day of a new command line interface: shell&#39;.&lt;/p&gt; &#xA;&lt;p&gt;The later steps then has been a migration toggle in the previous arcan terminal emulator that allows a switch over to scripts with embedded Lua based bindings to the TUI API and its widgets. This later mode and support scripts is what we refer to as Lash. Lash in turn is too barebones to be useful, and a set of user scripts are plugged in, Cat9 is one such set.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>nat-418/boole.nvim</title>
    <updated>2022-10-19T01:35:43Z</updated>
    <id>tag:github.com,2022-10-19:/nat-418/boole.nvim</id>
    <link href="https://github.com/nat-418/boole.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Neovim plugin for toggling booleans, etc.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;boole.nvim&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/nat-418/boole.nvim/main/boole.jpg&#34; alt=&#34;A bust of George Boole&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Boole is a simple Neovim plugin that extends the default increment and decrement functionality of CTRL-A and CTRL-X to allow for toggling boolean values like &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; as well as cycling through:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Days of the week and their abbreviations (e.g., &lt;code&gt;Monday&lt;/code&gt; → &lt;code&gt;Tuesday&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Months of the year and their abbreviations (e.g., &lt;code&gt;Jan&lt;/code&gt; → &lt;code&gt;Feb&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;X11 / Web color names (e.g., &lt;code&gt;Orange&lt;/code&gt; → &lt;code&gt;OrangeRed&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Canonical hours (e.g., &lt;code&gt;Compline&lt;/code&gt; → &lt;code&gt;Vigil&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Letter + number &#34;words&#34; (e.g., &lt;code&gt;F1&lt;/code&gt; → &lt;code&gt;F2&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This plugin ships one command:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:Boole {increment|decrement}&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This command can be safely mapped to CTRL-A and CTRL-X. See the configuration section below for an example.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Using &lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;Packer&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use({&#xA;  &#39;https://github.com/nat-418/boole.nvim&#39;,&#xA;  config = function()&#xA;    require(&#39;boole&#39;).setup()&#xA;  end&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Boole can be mapped to a key by passing a configuration table to the &lt;code&gt;setup&lt;/code&gt; function. You can also add any cycle of words you would like. Feel free to submit an issue and pull request with additions you think would make good defaults.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;boole&#39;).setup({&#xA;  mappings = {&#xA;    increment = &#39;&amp;lt;C-a&amp;gt;&#39;,&#xA;    decrement = &#39;&amp;lt;C-x&amp;gt;&#39;&#xA;  },&#xA;  -- User defined loops&#xA;  additions = {&#xA;    {&#39;Foo&#39;, &#39;Bar&#39;}&#xA;    {&#39;tic&#39;, &#39;tac&#39;, &#39;toe&#39;}&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>