<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-09T01:38:02Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cbochs/grapple.nvim</title>
    <updated>2023-03-09T01:38:02Z</updated>
    <id>tag:github.com,2023-03-09:/cbochs/grapple.nvim</id>
    <link href="https://github.com/cbochs/grapple.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Neovim plugin for tagging important files&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Grapple.nvim&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/2467016/207667062-13883515-fd21-4d40-be87-656665de3d0e.gif&#34; alt=&#34;grapple_showcase&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Theme: &lt;a href=&#34;https://github.com/rebelot/kanagawa.nvim&#34;&gt;kanagawa&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Grapple is a plugin that aims to provide immediate navigation to important files (and their last known cursor location) by means of persistent &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#file-tags&#34;&gt;file tags&lt;/a&gt; within a &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#project-scopes&#34;&gt;project scope&lt;/a&gt;. Tagged files can be bound to a &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#suggested-keymaps&#34;&gt;keymap&lt;/a&gt; or selected from within an editable &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#popup-menu&#34;&gt;popup menu&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#quickstart&#34;&gt;quickstart&lt;/a&gt; section to get started.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Project scoped&lt;/strong&gt; file tagging for immediate navigation&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Persistent&lt;/strong&gt; cursor tracking for tagged files&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Popup&lt;/strong&gt; menu to manage tags and scopes as regular text&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Integration&lt;/strong&gt; with &lt;a href=&#34;https://github.com/cbochs/portal.nvim&#34;&gt;portal.nvim&lt;/a&gt; for additional jump options&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/neovim/neovim/releases/tag/v0.8.0&#34;&gt;Neovim &amp;gt;= 0.8&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Neovim &amp;gt;= 0.9 - optional, for &lt;a href=&#34;https://github.com/neovim/neovim/issues/17458&#34;&gt;floating window title&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-lua/plenary.nvim&#34;&gt;plenary.nvim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#installation&#34;&gt;Install&lt;/a&gt; Grapple.nvim using your preferred package manager&lt;/li&gt; &#xA; &lt;li&gt;Add a keybind to &lt;code&gt;tag&lt;/code&gt;, &lt;code&gt;untag&lt;/code&gt;, or &lt;code&gt;toggle&lt;/code&gt; a tag. For example,&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.keymap.set(&#34;n&#34;, &#34;&amp;lt;leader&amp;gt;m&#34;, require(&#34;grapple&#34;).toggle)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Next steps&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Check out the default settings in the &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#settings&#34;&gt;settings&lt;/a&gt; section&lt;/li&gt; &#xA; &lt;li&gt;View your tags &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#popup-menu&#34;&gt;in a popup&lt;/a&gt; using &lt;code&gt;:GrapplePopup tags&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Know when a file is tagged by adding &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#statusline&#34;&gt;statusline component&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Choose a &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#project-scopes&#34;&gt;builtin&lt;/a&gt; scope or try your hand at creating a &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#scope-api&#34;&gt;custom&lt;/a&gt; scope to store your tags&lt;/li&gt; &#xA; &lt;li&gt;Explore the &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapple-api&#34;&gt;Grapple&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#scope-api&#34;&gt;Scope&lt;/a&gt; APIs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;lazy.nvim&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;    &#34;cbochs/grapple.nvim&#34;,&#xA;    dependencies = { &#34;nvim-lua/plenary.nvim&#34; },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;packer&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use {&#xA;    &#34;cbochs/grapple.nvim&#34;,&#xA;    requires = { &#34;nvim-lua/plenary.nvim&#34; },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;vim-plug&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Plug &#34;nvim-lua/plenary.nvim&#34;&#xA;Plug &#34;cbochs/grapple.nvim&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Settings&lt;/h2&gt; &#xA;&lt;p&gt;The following are the default settings for Grapple. &lt;strong&gt;Setup is not required&lt;/strong&gt;, but settings may be overridden by passing them as table arguments to the &lt;code&gt;grapple#setup&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Default Settings&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;grapple&#34;).setup({&#xA;    ---@type &#34;debug&#34; | &#34;info&#34; | &#34;warn&#34; | &#34;error&#34;&#xA;    log_level = &#34;warn&#34;,&#xA;&#xA;    ---Can be either the name of a builtin scope resolver,&#xA;    ---or a custom scope resolver&#xA;    ---@type string | Grapple.ScopeResolver&#xA;    scope = &#34;git&#34;,&#xA;&#xA;    ---The save location for tags&#xA;    ---@type string&#xA;    save_path = tostring(Path:new(vim.fn.stdpath(&#34;data&#34;)) / &#34;grapple&#34;),&#xA;&#xA;    ---Window options used for the popup menu&#xA;    popup_options = {&#xA;        relative = &#34;editor&#34;,&#xA;        width = 60,&#xA;        height = 12,&#xA;        style = &#34;minimal&#34;,&#xA;        focusable = false,&#xA;        border = &#34;single&#34;,&#xA;    },&#xA;&#xA;    integrations = {&#xA;        ---Support for saving tag state using resession.nvim&#xA;        resession = false,&#xA;    },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Grapple API&lt;/h3&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Grapple API and Examples&lt;/summary&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple#tag&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Create a scoped tag on a file or buffer with an (optional) tag key.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Command&lt;/strong&gt;: &lt;code&gt;:GrappleTag [key={index} or key={name}] [buffer={buffer}] [file_path={file_path}] [scope={scope}]&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple&#34;).tag(opts)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;opts?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappleoptions&#34;&gt;&lt;code&gt;Grapple.Options&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;buffer?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;integer&lt;/code&gt; (default: &lt;code&gt;0&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;file_path?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; (overrides &lt;code&gt;buffer&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;key?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappletagkey&#34;&gt;&lt;code&gt;Grapple.TagKey&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;scope?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolverlike&#34;&gt;&lt;code&gt;Grapple.ScopeResolverLike&lt;/code&gt;&lt;/a&gt; (default: &lt;code&gt;settings.scope&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: only one tag can be created &lt;em&gt;per scope per file&lt;/em&gt;. If a tag already exists for the given file or buffer, it will be overridden with the new tag.&lt;/p&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Tag the current buffer&#xA;require(&#34;grapple&#34;).tag()&#xA;&#xA;-- Tag a file using its file path&#xA;require(&#34;grapple&#34;).tag({ file_path = &#34;{file_path}&#34; })&#xA;&#xA;-- Tag the current buffer using a specified key&#xA;require(&#34;grapple&#34;).tag({ key = 1 })&#xA;require(&#34;grapple&#34;).tag({ key = &#34;{name}&#34; })&#xA;&#xA;-- Tag the current buffer in a specified scope&#xA;require(&#34;grapple&#34;).tag({ scope = &#34;global&#34; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple#untag&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Remove a scoped tag on a file or buffer.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Command&lt;/strong&gt;: &lt;code&gt;:GrappleUntag [key={name} or key={index}] [buffer={buffer}] [file_path={file_path}] [scope={scope}]&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple&#34;).untag(opts)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;opts&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappleoptions&#34;&gt;&lt;code&gt;Grapple.Options&lt;/code&gt;&lt;/a&gt; (one of)&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;buffer?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;integer&lt;/code&gt; (default: &lt;code&gt;0&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;file_path?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; (overrides &lt;code&gt;buffer&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;key?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappletagkey&#34;&gt;&lt;code&gt;Grapple.TagKey&lt;/code&gt;&lt;/a&gt; (overrides &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;file_path&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;scope?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolverlike&#34;&gt;&lt;code&gt;Grapple.ScopeResolverLike&lt;/code&gt;&lt;/a&gt; (default: &lt;code&gt;settings.scope&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Untag the current buffer&#xA;require(&#34;grapple&#34;).untag()&#xA;&#xA;-- Untag a file using its file path&#xA;require(&#34;grapple&#34;).untag({ file_path = &#34;{file_path}&#34; })&#xA;&#xA;-- Untag a file using its tag key&#xA;require(&#34;grapple&#34;).untag({ key = 1 })&#xA;require(&#34;grapple&#34;).untag({ key = &#34;{name}&#34; })&#xA;&#xA;-- Untag a the current buffer from a scope&#xA;require(&#34;grapple&#34;).untag({ scope = &#34;global&#34; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple#toggle&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Toggle a tag or untag on a file or buffer.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Command&lt;/strong&gt;: &lt;code&gt;:GrappleToggle [key={index} or key={name}] [buffer={buffer}] [file_path={file_path}] [scope={scope}]&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple&#34;).toggle(opts)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;opts&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappleoptions&#34;&gt;&lt;code&gt;Grapple.Options&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;buffer?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;integer&lt;/code&gt; (default: &lt;code&gt;0&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;file_path?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; (overrides &lt;code&gt;buffer&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;key?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappletagkey&#34;&gt;&lt;code&gt;Grapple.TagKey&lt;/code&gt;&lt;/a&gt; (behaviour inherited from &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappletag&#34;&gt;grapple#tag&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappleuntag&#34;&gt;grapple#untag&lt;/a&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;scope?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolverlike&#34;&gt;&lt;code&gt;Grapple.ScopeResolverLike&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Toggle a tag on the current buffer&#xA;require(&#34;grapple&#34;).toggle()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple#select&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Select and open a tagged file or buffer in the current window.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Command&lt;/strong&gt;: &lt;code&gt;:GrappleSelect [key={index} or key={name}]&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple&#34;).select(opts)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;opts&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappleoptions&#34;&gt;&lt;code&gt;Grapple.Options&lt;/code&gt;&lt;/a&gt; (one of)&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;buffer?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;integer&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;file_path?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;key?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappletagkey&#34;&gt;&lt;code&gt;Grapple.TagKey&lt;/code&gt;&lt;/a&gt; (preferred)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Select an anonymous (numbered) tag&#xA;require(&#34;grapple&#34;).select({ key = 1 })&#xA;&#xA;-- Select a named tag&#xA;require(&#34;grapple&#34;).select({ key = &#34;{name}&#34; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple#find&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Attempt to find a scoped tag.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple&#34;).find(opts)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;returns&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappletag-1&#34;&gt;&lt;code&gt;Grapple.Tag&lt;/code&gt;&lt;/a&gt; | &lt;code&gt;nil&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;opts?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappleoptions&#34;&gt;&lt;code&gt;Grapple.Options&lt;/code&gt;&lt;/a&gt; (one of)&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;buffer?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;integer&lt;/code&gt; (default: &lt;code&gt;0&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;file_path?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; (overrides &lt;code&gt;buffer&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;key?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappletagkey&#34;&gt;&lt;code&gt;Grapple.TagKey&lt;/code&gt;&lt;/a&gt; (overrides &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;file_path&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Find the tag associated with the current buffer&#xA;require(&#34;grapple&#34;).find()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple#key&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Attempt to find the key associated with a file tag.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple&#34;).key(opts)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;returns&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappletagkey&#34;&gt;&lt;code&gt;Grapple.TagKey&lt;/code&gt;&lt;/a&gt; | &lt;code&gt;nil&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;opts?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappleoptions&#34;&gt;&lt;code&gt;Grapple.Options&lt;/code&gt;&lt;/a&gt; (one of)&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;buffer?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;integer&lt;/code&gt; (default: &lt;code&gt;0&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;file_path?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; (overrides &lt;code&gt;buffer&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;key?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappletagkey&#34;&gt;&lt;code&gt;Grapple.TagKey&lt;/code&gt;&lt;/a&gt; (overrides &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;file_path&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Find the tag key associated with the current buffer&#xA;require(&#34;grapple&#34;).key()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple#exists&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple&#34;).exists(opts)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;returns&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;opts?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappleoptions&#34;&gt;&lt;code&gt;Grapple.Options&lt;/code&gt;&lt;/a&gt; (one of)&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;buffer?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;integer&lt;/code&gt; (default: &lt;code&gt;0&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;file_path?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; (overrides &lt;code&gt;buffer&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;key?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappletagkey&#34;&gt;&lt;code&gt;Grapple.TagKey&lt;/code&gt;&lt;/a&gt; (overrides &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;file_path&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;scope?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolverlike&#34;&gt;&lt;code&gt;Grapple.ScopeResolverLike&lt;/code&gt;&lt;/a&gt; (default: &lt;code&gt;settings.scope&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Check whether the current buffer is tagged or not&#xA;require(&#34;grapple&#34;).exists()&#xA;&#xA;-- Check for a tag in a different scope&#xA;require(&#34;grapple&#34;).exists({ scope = &#34;global&#34; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple#cycle&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Cycle through and select from the available tagged files in a scoped tag list.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Command&lt;/strong&gt;: &lt;code&gt;:GrappleCycle {direction}&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;require(&#34;grapple&#34;).cycle(direction)&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;require(&#34;grapple&#34;).cycle_backward()&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;require(&#34;grapple&#34;).cycle_forward()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;direction&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;&#34;backward&#34;&lt;/code&gt; | &lt;code&gt;&#34;forward&#34;&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: only &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#anonymous-tags&#34;&gt;anonymous tags&lt;/a&gt; are cycled through, not &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#named-tags&#34;&gt;named tags&lt;/a&gt;.&lt;/p&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Cycle to the previous tagged file&#xA;require(&#34;grapple&#34;).cycle_backward()&#xA;&#xA;-- Cycle to the next tagged file&#xA;require(&#34;grapple&#34;).cycle_forward()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple#tags&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Return all tags for a given project scope.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Command&lt;/strong&gt;: &lt;code&gt;:Grapple tags {scope}&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple&#34;).tags(scope)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;scope?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolverlike&#34;&gt;&lt;code&gt;Grapple.ScopeResolverLike&lt;/code&gt;&lt;/a&gt; (default: &lt;code&gt;settings.scope&lt;/code&gt;)&lt;/p&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Get all tags for the current scope&#xA;require(&#34;grapple&#34;).tags()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple#reset&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Clear all tags for a given project scope.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Command&lt;/strong&gt;: &lt;code&gt;:GrappleReset [scope]&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple&#34;).reset(scope)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;scope?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolverlike&#34;&gt;&lt;code&gt;Grapple.ScopeResolverLike&lt;/code&gt;&lt;/a&gt; (default: &lt;code&gt;settings.scope&lt;/code&gt;)&lt;/p&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Reset tags for the current scope&#xA;require(&#34;grapple&#34;).reset()&#xA;&#xA;-- Reset tags for a specified scope&#xA;require(&#34;grapple&#34;).reset(&#34;global&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple#quickfix&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Open the quickfix menu and populate the quickfix list with a project scope&#39;s tags.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple&#34;).quickfix(scope)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;scope?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolverlike&#34;&gt;&lt;code&gt;Grapple.ScopeResolverLike&lt;/code&gt;&lt;/a&gt; (default: &lt;code&gt;settings.scope&lt;/code&gt;)&lt;/p&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Open the quickfix menu for the current scope&#xA;require(&#34;grapple&#34;).quickfix()&#xA;&#xA;-- Open the quickfix menu for a specified scope&#xA;require(&#34;grapple&#34;).quickfix(&#34;global&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Scope API&lt;/h3&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Scope API and Examples&lt;/summary&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple.scope#resolver&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Create a scope resolver that generates a project scope.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple.scope&#34;).resolver(scope_callback, opts)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;returns&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolver-1&#34;&gt;&lt;code&gt;Grapple.ScopeResolver&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;scope_callback&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopefunction&#34;&gt;&lt;code&gt;Grapple.ScopeFunction&lt;/code&gt;&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopejob&#34;&gt;&lt;code&gt;Grapple.ScopeJob&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;opts?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopeoptions&#34;&gt;&lt;code&gt;Grapple.ScopeOptions&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;cache?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; | &lt;code&gt;string&lt;/code&gt; | &lt;code&gt;string[]&lt;/code&gt; | &lt;code&gt;integer&lt;/code&gt; (default: &lt;code&gt;true&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;persist?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; (default: &lt;code&gt;true&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Create a scope resolver that updates when the current working&#xA;-- directory changes&#xA;require(&#34;grapple.scope&#34;).resolver(function()&#xA;    return vim.fn.getcwd()&#xA;end, { cache = &#34;DirChanged&#34; })&#xA;&#xA;-- Create an scope resolver that asynchronously runs the &#34;echo&#34;&#xA;-- shell command and uses its output as the resolved scope&#xA;require(&#34;grapple.scope&#34;).resolver({&#xA;    command = &#34;echo&#34;,&#xA;    args = [ &#34;hello_world&#34; ],&#xA;    cwd = vim.fn.getcwd(),&#xA;    on_exit = function(job, return_value)&#xA;        return job:result()[1]&#xA;    end&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple.scope#root&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Create a scope resolver that generates a project scope by looking upwards for directories containing a specific file or directory.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple.scope&#34;).root(root_names, opts)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;returns&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolver-1&#34;&gt;&lt;code&gt;Grapple.ScopeResolver&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;root_names&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; | &lt;code&gt;string[]&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;opts?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopeoptions&#34;&gt;&lt;code&gt;Grapple.ScopeOptions&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;cache?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; | &lt;code&gt;string&lt;/code&gt; | &lt;code&gt;string[]&lt;/code&gt; | &lt;code&gt;integer&lt;/code&gt; (default: &lt;code&gt;&#34;DirChanged&#34;&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;persist?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; (default: &lt;code&gt;true&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: it is recommended to use this with a &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopefallback&#34;&gt;fallback scope resolver&lt;/a&gt;&lt;/strong&gt; to guarantee that a scope is found.&lt;/p&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Create a root scope resolver that looks for a directory containing&#xA;-- a &#34;Cargo.toml&#34; file&#xA;require(&#34;grapple.scope&#34;).root(&#34;Cargo.toml&#34;)&#xA;&#xA;-- Create a root scope resolver that falls back to using the initial working&#xA;-- directory for your neovim session&#xA;require(&#34;grapple.scope&#34;).fallback({&#xA;    require(&#34;grapple.scope&#34;).root(&#34;Cargo.toml&#34;),&#xA;    require(&#34;grapple&#34;).resolvers.static,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple.scope#root_from_buffer&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Create a scope resolver that generates a project scope by looking upwards for directories containing a specific file or directory &lt;em&gt;from the current buffer&lt;/em&gt;.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple.scope&#34;).root(root_names, opts)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;returns&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolver-1&#34;&gt;&lt;code&gt;Grapple.ScopeResolver&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;root_names&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; | &lt;code&gt;string[]&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;opts?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopeoptions&#34;&gt;&lt;code&gt;Grapple.ScopeOptions&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;cache?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; | &lt;code&gt;string&lt;/code&gt; | &lt;code&gt;string[]&lt;/code&gt; | &lt;code&gt;integer&lt;/code&gt; (default: &lt;code&gt;&#34;BufEnter&#34;&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;persist?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; (default: &lt;code&gt;true&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: it is recommended to use this with a &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopefallback&#34;&gt;fallback scope resolver&lt;/a&gt;&lt;/strong&gt; to guarantee that a scope is found.&lt;/p&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Create a buffer-based root scope resolver that looks for a directory&#xA;-- containing a &#34;Cargo.toml&#34; file&#xA;require(&#34;grapple.scope&#34;).root_from_buffer(&#34;Cargo.toml&#34;)&#xA;&#xA;-- Create a buffer-based root scope resolver that falls back to using&#xA;-- the initial working directory for your neovim session&#xA;require(&#34;grapple.scope&#34;).fallback({&#xA;    require(&#34;grapple.scope&#34;).root_from_buffer(&#34;Cargo.toml&#34;),&#xA;    require(&#34;grapple&#34;).resolvers.static,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple.scope#fallback&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Create a scope resolver that generates a project scope by attempting to get the project scope of other scope resolvers, in order.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple.scope&#34;).fallback(scope_resolvers, opts)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;returns&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolver-1&#34;&gt;&lt;code&gt;Grapple.ScopeResolver&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;scope_resolvers&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolver-1&#34;&gt;&lt;code&gt;Grapple.ScopeResolver[]&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;opts?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopeoptions&#34;&gt;&lt;code&gt;Grapple.ScopeOptions&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;cache?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; | &lt;code&gt;string&lt;/code&gt; | &lt;code&gt;string[]&lt;/code&gt; | &lt;code&gt;integer&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;persist?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; (default: &lt;code&gt;true&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Create a fallback scope resolver that first tries to use the LSP for a scope&#xA;-- path, then looks for a &#34;.git&#34; repository, and finally falls back on using&#xA;-- the initial working directory that neovim was started in&#xA;require(&#34;grapple.scope&#34;).fallback({&#xA;    require(&#34;grapple&#34;).resolvers.lsp_fallback,&#xA;    require(&#34;grapple&#34;).resolvers.git_fallback,&#xA;    require(&#34;grapple&#34;).resolvers.static&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple.scope#suffix&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Create a scope resolver that takes in two scope resolvers: a &lt;strong&gt;path resolver&lt;/strong&gt; and a &lt;strong&gt;suffix&lt;/strong&gt; resolver. If the scope determined from the path resolver is not nil, then the scope from the suffix resolver may be appended to it. Useful in situations where you may want to append additional project information (i.e. the current git branch).&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple.scope&#34;).suffix(path_resolver, suffix_resolver, opts)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;returns&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolver-1&#34;&gt;&lt;code&gt;Grapple.ScopeResolver&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;path_resolver&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolver-1&#34;&gt;&lt;code&gt;Grapple.ScopeResolver&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;suffix_resolver&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolver-1&#34;&gt;&lt;code&gt;Grapple.ScopeResolver&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;opts?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopeoptions&#34;&gt;&lt;code&gt;Grapple.ScopeOptions&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;cache?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; | &lt;code&gt;string&lt;/code&gt; | &lt;code&gt;string[]&lt;/code&gt; | &lt;code&gt;integer&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;persist?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; (default: &lt;code&gt;true&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Create a suffix scope resolver that duplicates a static resolver&#xA;-- and appends it to itself (e.g. &#34;asdf#asdf&#34;)&#xA;require(&#34;grapple.scope&#34;).suffix(&#xA;    require(&#34;grapple.scope&#34;).static(&#34;asdf&#34;),&#xA;    require(&#34;grapple.scope&#34;).static(&#34;asdf&#34;),&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple.scope#static&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Create a scope resolver that simply returns a static string. Useful when creating sub-groups with &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopesuffix&#34;&gt;&lt;code&gt;grapple.scope#suffix&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple.scope&#34;).static(plain_string, opts)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;returns&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolver-1&#34;&gt;&lt;code&gt;Grapple.ScopeResolver&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;plain_string&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;opts?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopeoptions&#34;&gt;&lt;code&gt;Grapple.ScopeOptions&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;cache?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; | &lt;code&gt;string&lt;/code&gt; | &lt;code&gt;string[]&lt;/code&gt; | &lt;code&gt;integer&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;persist?&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; (default: &lt;code&gt;true&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Create a static scope resolver that simply returns &#34;I&#39;m a teapot&#34;&#xA;require(&#34;grapple.scope&#34;).static(&#34;I&#39;m a teapot&#34;)&#xA;&#xA;-- Create a suffix scope resolver that appends the suffix &#34;commands&#34;&#xA;-- to the end of the git scope resolver&#xA;require(&#34;grapple.scope&#34;).suffix(&#xA;    require(&#34;grapple&#34;).resolvers.git,&#xA;    require(&#34;grapple.scope&#34;).static(&#34;commands&#34;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple.scope#invalidate&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Clear the cached project scope, forcing the next call to get the project scope to re-resolve and re-instantiate the cache.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple.scope&#34;).invalidate(scope_resolver)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;scope_resolver&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolverlike&#34;&gt;&lt;code&gt;Grapple.ScopeResolverLike&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local my_resolver = require(&#34;grapple.scope&#34;).resolver(function()&#xA;    return vim.fn.getcwd()&#xA;end)&#xA;&#xA;-- Invalidate a cached scope associated with a scope resolver&#xA;require(&#34;grapple.scope&#34;).invalidate(my_resolver)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA; &lt;h4&gt;&lt;code&gt;grapple.scope#update&lt;/code&gt;&lt;/h4&gt; &#xA; &lt;p&gt;Update the cached project scope. Unlike &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopeinvalidate&#34;&gt;&lt;code&gt;grapple.scope#invalidate&lt;/code&gt;&lt;/a&gt; which lazily updates the project scope, this immediately updates the cached project scope.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple.scope&#34;).update(scope_resolver)&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;code&gt;scope_resolver&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolverlike&#34;&gt;&lt;code&gt;Grapple.ScopeResolverLike&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;details&gt; &#xA;  &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local my_resolver = require(&#34;grapple.scope&#34;).resolver(function()&#xA;    return vim.fn.getcwd()&#xA;end)&#xA;&#xA;-- Update a cached scope associated with a scope resolver&#xA;require(&#34;grapple.scope&#34;).update(my_resolver)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/details&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;File Tags&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;strong&gt;tag&lt;/strong&gt; is a persistent tag on a file or buffer. It is a means of indicating a file you want to return to. When a file is tagged, Grapple will save your cursor location so that when you jump back, your cursor is placed right where you left off. In a sense, tags are like file-level marks (&lt;code&gt;:h mark&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;There are a couple types of tag types available, each with a different use-case in mind. The options available are &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#anonymous-tags&#34;&gt;anonymous&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#named-tags&#34;&gt;named&lt;/a&gt; tags. In addition, tags are &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#project-scopes&#34;&gt;scoped&lt;/a&gt; to prevent tags in one project polluting the namespace of another. For command and API information, please see the &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapple-api&#34;&gt;Grapple API&lt;/a&gt;. For additional examples, see the &lt;a href=&#34;https://github.com/cbochs/grapple.nvim/wiki/File-Tags&#34;&gt;Wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Anonymous Tags&lt;/h3&gt; &#xA;&lt;p&gt;This is the &lt;em&gt;default&lt;/em&gt; tag type. Anonymous tags are added to a list, where they may be selected by index, cycled through, or jumped to using the &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#tag-popup-menu&#34;&gt;tag popup menu&lt;/a&gt; or plugins such as &lt;a href=&#34;https://github.com/cbochs/portal.nvim&#34;&gt;portal.nvim&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Anonymous tags are similar to those found in plugins like &lt;a href=&#34;https://github.com/ThePrimeagen/harpoon&#34;&gt;harpoon&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Named Tags&lt;/h3&gt; &#xA;&lt;p&gt;Tags that are given a name are considered to be &lt;strong&gt;named tags&lt;/strong&gt;. These tags will not be cycled through with &lt;code&gt;cycle_{backward, forward}&lt;/code&gt;, but instead must be explicitly selected.&lt;/p&gt; &#xA;&lt;p&gt;Named tags are useful if you want one or two keymaps to be used for tagging and selecting. For example, the pairs &lt;code&gt;&amp;lt;leader&amp;gt;j/J&lt;/code&gt; and &lt;code&gt;&amp;lt;leader&amp;gt;k/K&lt;/code&gt; to &lt;code&gt;select/toggle&lt;/code&gt; a file tag (see: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#named-tag-keymaps&#34;&gt;suggested keymaps&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Project Scopes&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;strong&gt;scope&lt;/strong&gt; is a means of namespacing tags to a specific project. During runtime, scopes are typically resolved into an absolute directory path (i.e. current working directory), which - in turn - is used as the &#34;root&#34; location for a set of tags.&lt;/p&gt; &#xA;&lt;p&gt;Project scopes are &lt;em&gt;cached by default&lt;/em&gt;, and will only update when the cache is &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopeinvalidate&#34;&gt;explicitly invalidated&lt;/a&gt;, an associated (&lt;a href=&#34;https://neovim.io/doc/user/autocmd.html&#34;&gt;&lt;code&gt;:h autocmd&lt;/code&gt;&lt;/a&gt;) is triggered, or at a specified interval. For example, the &lt;code&gt;static&lt;/code&gt; scope never updates once cached; the &lt;code&gt;directory&lt;/code&gt; scope only updates on &lt;code&gt;DirChanged&lt;/code&gt;; and the &lt;code&gt;lsp&lt;/code&gt; scope updates on either &lt;code&gt;LspAttach&lt;/code&gt; or &lt;code&gt;LspDetach&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;strong&gt;project scope&lt;/strong&gt; is determined by means of a &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolver&#34;&gt;scope resolver&lt;/a&gt;&lt;/strong&gt;. The builtin options are as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;none&lt;/code&gt;: tags are ephemeral and deleted on exit&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;global&lt;/code&gt;: tags are scoped to a global namespace&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;static&lt;/code&gt;: tags are scoped to neovim&#39;s initial working directory&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;directory&lt;/code&gt;: tags are scoped to the current working directory&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp&lt;/code&gt;: tags are scoped using the &lt;code&gt;root_dir&lt;/code&gt; of the current buffer&#39;s attached LSP server, &lt;strong&gt;fallback&lt;/strong&gt;: &lt;code&gt;static&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;git&lt;/code&gt;: tags are scoped to the current git repository, &lt;strong&gt;fallback&lt;/strong&gt;: &lt;code&gt;static&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;git_branch&lt;/code&gt;: tags are scoped to the current git repository and branch (async), &lt;strong&gt;fallback&lt;/strong&gt;: &lt;code&gt;static&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There are three additional scope resolvers which should be preferred when creating a &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopefallback&#34;&gt;fallback scope resolver&lt;/a&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopesuffix&#34;&gt;suffix scope resolver&lt;/a&gt;&lt;/strong&gt;. These resolvers act identically to their similarly named counterparts, but do not have default fallbacks.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp_fallback&lt;/code&gt;: the same as &lt;code&gt;lsp&lt;/code&gt;, but without a fallback&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;git_fallback&lt;/code&gt;: the same as &lt;code&gt;git&lt;/code&gt;, but without a fallback&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;git_branch_suffix&lt;/code&gt;: resolves suffix (branch) for &lt;code&gt;git_branch&lt;/code&gt; (async)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is also possible to create your own &lt;strong&gt;custom scope resolver&lt;/strong&gt;. For the available scope resolver types, please see the &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#scope-api&#34;&gt;Scope API&lt;/a&gt;. For additional examples, see the &lt;a href=&#34;https://github.com/cbochs/grapple.nvim/wiki/Project-Scopes&#34;&gt;Wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Setup using a builtin scope resolver&#xA;require(&#34;grapple&#34;).setup({&#xA;    scope = require(&#34;grapple&#34;).resolvers.git&#xA;})&#xA;&#xA;-- Setup using a custom scope resolver&#xA;require(&#34;grapple&#34;).setup({&#xA;    scope = require(&#34;grapple.scope&#34;).resolver(function()&#xA;        return vim.fn.getcwd()&#xA;    end, { cache = &#34;DirChanged&#34; })&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Popup Menu&lt;/h2&gt; &#xA;&lt;p&gt;A popup menu is available to enable easy management of tags and scopes. The opened buffer (filetype: &lt;code&gt;grapple&lt;/code&gt;) can be modified like a regular buffer; meaning items can be selected, modified, reordered, or deleted with well-known vim motions. Currently, there are two available popup menus: one for &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#tag-popup-menu&#34;&gt;tags&lt;/a&gt; and another for &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#scope-popup-menu&#34;&gt;scopes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;img width=&#34;1038&#34; alt=&#34;Screenshot 2022-12-15 at 09 05 07&#34; src=&#34;https://user-images.githubusercontent.com/2467016/207909857-98e7bc5d-8b48-4650-acb9-5993dde87a0f.png&#34;&gt; &#xA;&lt;h3&gt;Tag Popup Menu&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;strong&gt;tags popup menu&lt;/strong&gt; opens a floating window containing all the tags within a specified scope. The floating window can be exited with either &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;&amp;lt;esc&amp;gt;&lt;/code&gt;, or any keybinding that is bound to &lt;code&gt;&amp;lt;esc&amp;gt;&lt;/code&gt;. Several actions are available within the tags popup menu:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Selection&lt;/strong&gt;: a tag can be selected by moving to its corresponding line and pressing enter (&lt;code&gt;&amp;lt;cr&amp;gt;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Deletion&lt;/strong&gt;: a tag (or tags) can be removed by deleting them from the popup menu (i.e. NORMAL &lt;code&gt;dd&lt;/code&gt; and VISUAL &lt;code&gt;d&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Reordering&lt;/strong&gt;: an &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#anonymous-tags&#34;&gt;anonymous tag&lt;/a&gt; (or tags) can be reordered by moving them up or down within the popup menu. Ordering is determined by the tags position within the popup menu: top (first index) to bottom (last index)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Renaming&lt;/strong&gt;: a &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#named-tags&#34;&gt;named tag&lt;/a&gt; can be renamed by editing its key value between the &lt;code&gt;[&lt;/code&gt; square brackets &lt;code&gt;]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Quickfix (&lt;code&gt;&amp;lt;c-q&amp;gt;&lt;/code&gt;)&lt;/strong&gt;: all tags will be &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplequickfix&#34;&gt;sent to the quickfix list&lt;/a&gt;, the popup menu closed, and the quickfix menu opened&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Split (&lt;code&gt;&amp;lt;c-v&amp;gt;&lt;/code&gt;)&lt;/strong&gt;: similar to tag selection, but the tagged file opened in a vertical split&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Command&lt;/strong&gt;: &lt;code&gt;:GrapplePopup tags&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple&#34;).popup_tags(scope)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;scope?&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolverlike&#34;&gt;&lt;code&gt;Grapple.ScopeResolverLike&lt;/code&gt;&lt;/a&gt; (default: &lt;code&gt;settings.scope&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Open the tags popup menu in the current scope&#xA;require(&#34;grapple&#34;).popup_tags()&#xA;&#xA;-- Open the tags popup menu in a different scope&#xA;require(&#34;grapple&#34;).popup_tags(&#34;global&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Scope Popup Menu&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;strong&gt;scopes popup menu&lt;/strong&gt; opens a floating window containing all the loaded project scopes. A scope (or scopes) can be deleted with typical vim edits (i.e. NORMAL &lt;code&gt;dd&lt;/code&gt; and VISUAL &lt;code&gt;d&lt;/code&gt;). The floating window can be exited with either &lt;code&gt;q&lt;/code&gt; or any keybinding that is bound to &lt;code&gt;&amp;lt;esc&amp;gt;&lt;/code&gt;. The total number of tags within a scope will be displayed to the left of the project scope.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Command&lt;/strong&gt;: &lt;code&gt;:GrapplePopup scopes&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;: &lt;code&gt;require(&#34;grapple.popup_scopes()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;b&gt;Examples&lt;/b&gt;&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Open the scopes popup menu&#xA;require(&#34;grapple&#34;).popup_scopes()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Persistent State&lt;/h2&gt; &#xA;&lt;p&gt;Grapple saves all &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#project-scopes&#34;&gt;project scopes&lt;/a&gt; to a common directory. This directory is aptly named &lt;code&gt;grapple&lt;/code&gt; and lives in Neovim&#39;s &lt;code&gt;&#34;data&#34;&lt;/code&gt; directory (see: &lt;a href=&#34;https://neovim.io/doc/user/starting.html#standard-path&#34;&gt;&lt;code&gt;:h standard-path&lt;/code&gt;&lt;/a&gt;). Each non-empty scope (scope contains at least one item) will be saved as an individiual scope file; serialized as a JSON blob, and named using the resolved scope&#39;s path.&lt;/p&gt; &#xA;&lt;p&gt;Each tag in a scope will contain two pieces of information: the absolute &lt;code&gt;file path&lt;/code&gt; of the tagged file and its last known &lt;code&gt;cursor&lt;/code&gt; location.&lt;/p&gt; &#xA;&lt;p&gt;When a user starts Neovim, no scopes are initially loaded. Instead, Grapple will wait until the user requests a project scope (e.g. &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappletag&#34;&gt;tagging a file&lt;/a&gt; or opening the &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#tag-popup-menu&#34;&gt;tags popup menu&lt;/a&gt;). At that point, one of three things can occur:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the scope is &lt;strong&gt;already loaded&lt;/strong&gt;, nothing is needed to be done&lt;/li&gt; &#xA; &lt;li&gt;the scope has &lt;strong&gt;not been loaded&lt;/strong&gt;, attempt to load scope state from its associated scope file&lt;/li&gt; &#xA; &lt;li&gt;the scope file was &lt;strong&gt;not found&lt;/strong&gt;, initialize the scope state as an empty table&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Suggested Keymaps&lt;/h2&gt; &#xA;&lt;h4&gt;Anonymous tag keymaps&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.keymap.set(&#34;n&#34;, &#34;&amp;lt;leader&amp;gt;m&#34;, require(&#34;grapple&#34;).toggle)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Named tag keymaps&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.keymap.set(&#34;n&#34;, &#34;&amp;lt;leader&amp;gt;j&#34;, function()&#xA;    require(&#34;grapple&#34;).select({ key = &#34;{name}&#34; })&#xA;end)&#xA;&#xA;vim.keymap.set(&#34;n&#34;, &#34;&amp;lt;leader&amp;gt;J&#34;, function()&#xA;    require(&#34;grapple&#34;).toggle({ key = &#34;{name}&#34; })&#xA;end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Integrations&lt;/h2&gt; &#xA;&lt;h3&gt;Statusline&lt;/h3&gt; &#xA;&lt;p&gt;A statusline component can be easily added to show whether a buffer is tagged or not by using either (or both) &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplekey&#34;&gt;&lt;code&gt;grapple#key&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplefind&#34;&gt;&lt;code&gt;grapple#find&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Simple &lt;a href=&#34;https://github.com/nvim-lualine/lualine.nvim&#34;&gt;lualine.nvim&lt;/a&gt; statusline&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;lualine&#34;).setup({&#xA;    sections = {&#xA;        lualine_b = {&#xA;            {&#xA;                require(&#34;grapple&#34;).key,&#xA;                cond = require(&#34;grapple&#34;).exists&#xA;            }&#xA;        }&#xA;    }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Slightly nicer &lt;a href=&#34;https://github.com/nvim-lualine/lualine.nvim&#34;&gt;lualine.nvim&lt;/a&gt; statusline&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;lualine&#34;).setup({&#xA;    sections = {&#xA;        lualine_b = {&#xA;            {&#xA;                function()&#xA;                    local key = require(&#34;grapple&#34;).key()&#xA;                    return &#34;  [&#34; .. key .. &#34;]&#34;&#xA;                end,&#xA;                cond = require(&#34;grapple&#34;).exists,&#xA;            }&#xA;        }&#xA;    }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Grapple Types&lt;/h2&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Type Definitions&lt;/summary&gt; &#xA; &lt;h3&gt;&lt;code&gt;Grapple.Options&lt;/code&gt;&lt;/h3&gt; &#xA; &lt;p&gt;Options available for most top-level tagging actions (e.g. tag, untag, select, toggle, etc).&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Type&lt;/strong&gt;: &lt;code&gt;table&lt;/code&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;buffer&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;integer&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;file_path&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;key&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappletagkey&#34;&gt;&lt;code&gt;Grapple.TagKey&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolverlike&#34;&gt;&lt;code&gt;Grapple.ScopeResolverLike&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;hr&gt; &#xA; &lt;h3&gt;&lt;code&gt;Grapple.Tag&lt;/code&gt;&lt;/h3&gt; &#xA; &lt;p&gt;A tag contains two pieces of information: the absolute &lt;code&gt;file_path&lt;/code&gt; of the tagged file, and the last known &lt;code&gt;cursor&lt;/code&gt; location. A tag is stored in a tag table keyed with a &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grappletagkey&#34;&gt;&lt;code&gt;Grapple.TagKey&lt;/code&gt;&lt;/a&gt;, but can only be deterministically identified by its &lt;code&gt;file_path&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Type&lt;/strong&gt;: &lt;code&gt;table&lt;/code&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;file_path&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;cursor&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;integer[2]&lt;/code&gt; (row, column)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;hr&gt; &#xA; &lt;h3&gt;&lt;code&gt;Grapple.TagKey&lt;/code&gt;&lt;/h3&gt; &#xA; &lt;p&gt;A tag may be referenced as an &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#anonymous-tags&#34;&gt;anonymous tag&lt;/a&gt; by its index (&lt;code&gt;integer&lt;/code&gt;) or a &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#named-tags&#34;&gt;named tag&lt;/a&gt; by its key (&lt;code&gt;string&lt;/code&gt;).&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Type&lt;/strong&gt;: &lt;code&gt;integer&lt;/code&gt; | &lt;code&gt;string&lt;/code&gt;&lt;/p&gt; &#xA; &lt;hr&gt; &#xA; &lt;h3&gt;&lt;code&gt;Grapple.ScopeOptions&lt;/code&gt;&lt;/h3&gt; &#xA; &lt;p&gt;Options available when creating custom scope resolvers. Builtin resolvers&lt;/p&gt; &#xA; &lt;p&gt;Giving a scope resolver a &lt;code&gt;key&lt;/code&gt; will allow it to be identified within the &lt;code&gt;require(&#34;grapple&#34;).resolvers&lt;/code&gt; table. For a scope to persisted, the &lt;code&gt;persist&lt;/code&gt; options must be set to &lt;code&gt;true&lt;/code&gt;; otherwise, any scope that is resolved by the scope resolver will be deleted when Neovim exits.&lt;/p&gt; &#xA; &lt;p&gt;In addition to scope persistence, a scope may also be cached for faster access during a Neovim session. The &lt;code&gt;cache&lt;/code&gt; option may be one of the following:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;cache = true&lt;/code&gt;: project scope is resolved once and cached until explicitly invalidated&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;cache = false&lt;/code&gt; project scope is never cached and must always be resolved&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;cache = string | string[]&lt;/code&gt; project scope is cached and invalidated when a given autocommand event is triggered (see: &lt;a href=&#34;https://neovim.io/doc/user/autocmd.html&#34;&gt;&lt;code&gt;:h autocmd&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;cache = integer&lt;/code&gt; project scope is cached and updated on a given interval (in milliseconds)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;strong&gt;Type&lt;/strong&gt;: &lt;code&gt;table&lt;/code&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;cache&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; | &lt;code&gt;string&lt;/code&gt; | &lt;code&gt;string[]&lt;/code&gt; | &lt;code&gt;integer&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;persist&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;hr&gt; &#xA; &lt;h3&gt;&lt;code&gt;Grapple.ScopeFunction&lt;/code&gt;&lt;/h3&gt; &#xA; &lt;p&gt;A &lt;em&gt;synchronous&lt;/em&gt; scope resolving callback function. Used when creating a scope resolver.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Type&lt;/strong&gt;: &lt;code&gt;fun(): Grapple.Scope | nil&lt;/code&gt;&lt;/p&gt; &#xA; &lt;hr&gt; &#xA; &lt;h3&gt;&lt;code&gt;Grapple.ScopeJob&lt;/code&gt;&lt;/h3&gt; &#xA; &lt;p&gt;An &lt;em&gt;asynchronous&lt;/em&gt; scope resolving callback command. Used when creating a scope resolver. The &lt;code&gt;command&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; should specify a complete shell command to execute. The &lt;code&gt;on_exit&lt;/code&gt; callback should understand how to parse the output of the command into a project scope (&lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescope&#34;&gt;&lt;code&gt;Grapple.Scope&lt;/code&gt;&lt;/a&gt;), or return &lt;code&gt;nil&lt;/code&gt; on execution failure. The &lt;code&gt;cwd&lt;/code&gt; must be specified as the directory which the command should be executed in.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Type&lt;/strong&gt;: &lt;code&gt;table&lt;/code&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;command&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;args&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string[]&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;cwd&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;on_exit&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;fun(job, return_value): Grapple.Scope | nil&lt;/code&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;hr&gt; &#xA; &lt;h3&gt;&lt;code&gt;Grapple.ScopeResolver&lt;/code&gt;&lt;/h3&gt; &#xA; &lt;p&gt;Resolves into a &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescope&#34;&gt;&lt;code&gt;Grapple.Scope&lt;/code&gt;&lt;/a&gt;. Should be created using the Scope API (e.g. &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolver&#34;&gt;&lt;code&gt;grapple.scope#resolver&lt;/code&gt;&lt;/a&gt;). For more information, see &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#project-scopes&#34;&gt;project scopes&lt;/a&gt;.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Type&lt;/strong&gt;: &lt;code&gt;table&lt;/code&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;key&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;integer&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;callback&lt;/code&gt;&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopefunction&#34;&gt;&lt;code&gt;Grapple.ScopeFunction&lt;/code&gt;&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescopejob&#34;&gt;&lt;code&gt;Grapple.ScopeJob&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;cache&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;boolean&lt;/code&gt; | &lt;code&gt;string&lt;/code&gt; | &lt;code&gt;string[]&lt;/code&gt; | &lt;code&gt;integer&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;strong&gt;&lt;code&gt;autocmd&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;number&lt;/code&gt; | &lt;code&gt;nil&lt;/code&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;hr&gt; &#xA; &lt;h3&gt;&lt;code&gt;Grapple.ScopeResolverLike&lt;/code&gt;&lt;/h3&gt; &#xA; &lt;p&gt;Either the name of a &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#project-scopes&#34;&gt;builtin&lt;/a&gt; scope resolver, or a scope resolver.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Type&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolver-1&#34;&gt;&lt;code&gt;Grapple.ScopeResolver&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;hr&gt; &#xA; &lt;h3&gt;&lt;code&gt;Grapple.Scope&lt;/code&gt;&lt;/h3&gt; &#xA; &lt;p&gt;The name of a project scope that has been resolved from a &lt;a href=&#34;https://raw.githubusercontent.com/cbochs/grapple.nvim/main/#grapplescoperesolver-1&#34;&gt;&lt;code&gt;Grapple.ScopeResolver&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Type&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Inspiration and Thanks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;tjdevries &lt;a href=&#34;https://github.com/tjdevries/vlog.nvim&#34;&gt;vlog.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;ThePrimeagen&#39;s &lt;a href=&#34;https://github.com/ThePrimeagen/harpoon&#34;&gt;harpoon&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;kwarlwang&#39;s &lt;a href=&#34;https://github.com/kwkarlwang/bufjump.nvim&#34;&gt;bufjump.nvim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>