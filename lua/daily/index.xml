<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-03T01:37:51Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Vigemus/iron.nvim</title>
    <updated>2023-04-03T01:37:51Z</updated>
    <id>tag:github.com,2023-04-03:/Vigemus/iron.nvim</id>
    <link href="https://github.com/Vigemus/iron.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Interactive Repl Over Neovim&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;iron.nvim&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sponsors/hkupty&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/sponsors/hkupty?style=flat-square&#34; alt=&#34;Sponsor me&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://matrix.to/#/#iron.nvim:matrix.org&#34;&gt;&lt;img src=&#34;https://matrix.to/img/matrix-badge.svg?sanitize=true&#34; alt=&#34;Chat on Matrix&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Interactive Repls Over Neovim&lt;/p&gt; &#xA;&lt;h2&gt;What is iron.nvim&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/495376&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/495376.svg?sanitize=true&#34; alt=&#34;asciicast&#34;&gt;&lt;/a&gt; Iron allows you to quickly interact with the repl without having to leave your work buffer&lt;/p&gt; &#xA;&lt;p&gt;It both a plugin and a library, allowing for better user experience and extensibility at the same time.&lt;/p&gt; &#xA;&lt;h2&gt;How to install&lt;/h2&gt; &#xA;&lt;p&gt;Using &lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;packer.nvim&lt;/a&gt; (or the plugin manager of your choice):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;  use {&#39;hkupty/iron.nvim&#39;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As of version 3.0, Iron uses milestones and tags to manage releases. If you want to use the stable versions, use the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;  use {&#39;hkupty/iron.nvim&#39;, tag = &#34;&amp;lt;most recent tag&amp;gt;&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How to configure&lt;/h2&gt; &#xA;&lt;p&gt;Below is a very simple configuration for iron:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local iron = require(&#34;iron.core&#34;)&#xA;&#xA;iron.setup {&#xA;  config = {&#xA;    -- Whether a repl should be discarded or not&#xA;    scratch_repl = true,&#xA;    -- Your repl definitions come here&#xA;    repl_definition = {&#xA;      sh = {&#xA;        -- Can be a table or a function that&#xA;        -- returns a table (see below)&#xA;        command = {&#34;zsh&#34;}&#xA;      }&#xA;    },&#xA;    -- How the repl window will be displayed&#xA;    -- See below for more information&#xA;    repl_open_cmd = require(&#39;iron.view&#39;).bottom(40),&#xA;  },&#xA;  -- Iron doesn&#39;t set keymaps by default anymore.&#xA;  -- You can set them here or manually add keymaps to the functions in iron.core&#xA;  keymaps = {&#xA;    send_motion = &#34;&amp;lt;space&amp;gt;sc&#34;,&#xA;    visual_send = &#34;&amp;lt;space&amp;gt;sc&#34;,&#xA;    send_file = &#34;&amp;lt;space&amp;gt;sf&#34;,&#xA;    send_line = &#34;&amp;lt;space&amp;gt;sl&#34;,&#xA;    send_mark = &#34;&amp;lt;space&amp;gt;sm&#34;,&#xA;    mark_motion = &#34;&amp;lt;space&amp;gt;mc&#34;,&#xA;    mark_visual = &#34;&amp;lt;space&amp;gt;mc&#34;,&#xA;    remove_mark = &#34;&amp;lt;space&amp;gt;md&#34;,&#xA;    cr = &#34;&amp;lt;space&amp;gt;s&amp;lt;cr&amp;gt;&#34;,&#xA;    interrupt = &#34;&amp;lt;space&amp;gt;s&amp;lt;space&amp;gt;&#34;,&#xA;    exit = &#34;&amp;lt;space&amp;gt;sq&#34;,&#xA;    clear = &#34;&amp;lt;space&amp;gt;cl&#34;,&#xA;  },&#xA;  -- If the highlight is on, you can change how it looks&#xA;  -- For the available options, check nvim_set_hl&#xA;  highlight = {&#xA;    italic = true&#xA;  },&#xA;  ignore_blank_lines = true, -- ignore blank lines when sending visual select lines&#xA;}&#xA;&#xA;-- iron also has a list of commands, see :h iron-commands for all available commands&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;space&amp;gt;rs&#39;, &#39;&amp;lt;cmd&amp;gt;IronRepl&amp;lt;cr&amp;gt;&#39;)&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;space&amp;gt;rr&#39;, &#39;&amp;lt;cmd&amp;gt;IronRestart&amp;lt;cr&amp;gt;&#39;)&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;space&amp;gt;rf&#39;, &#39;&amp;lt;cmd&amp;gt;IronFocus&amp;lt;cr&amp;gt;&#39;)&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;space&amp;gt;rh&#39;, &#39;&amp;lt;cmd&amp;gt;IronHide&amp;lt;cr&amp;gt;&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The repl &lt;code&gt;command&lt;/code&gt; can also be a function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;iron.setup{&#xA;  config = {&#xA;    repl_definition = {&#xA;      -- custom repl that loads the current file&#xA;      haskell = {&#xA;        command = function(meta)&#xA;          local filename = vim.api.nvim_buf_get_name(meta.current_bufnr)&#xA;          return { &#39;cabal&#39;, &#39;v2-repl&#39;, filename}&#xA;        end&#xA;      }&#xA;    },&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;REPL windows&lt;/h3&gt; &#xA;&lt;p&gt;iron.nvim supports both splits and floating windows and has helper functions for opening new repls in either of them:&lt;/p&gt; &#xA;&lt;h4&gt;For splits&lt;/h4&gt; &#xA;&lt;p&gt;If you prefer using splits to your repls, iron provides a few utility functions to make it simpler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local view = require(&#34;iron.view&#34;)&#xA;&#xA;-- iron.setup {...&#xA;&#xA;-- One can always use the default commands from vim directly&#xA;repl_open_cmd = &#34;vertical botright 80 split&#34;&#xA;&#xA;-- But iron provides some utility functions to allow you to declare that dynamically,&#xA;-- based on editor size or custom logic, for example.&#xA;&#xA;-- Vertical 50 columns split&#xA;-- Split has a metatable that allows you to set up the arguments in a &#34;fluent&#34; API&#xA;-- you can write as you would write a vim command.&#xA;-- It accepts:&#xA;--   - vertical&#xA;--   - leftabove/aboveleft&#xA;--   - rightbelow/belowright&#xA;--   - topleft&#xA;--   - botright&#xA;-- They&#39;ll return a metatable that allows you to set up the next argument&#xA;-- or call it with a size parameter&#xA;repl_open_cmd = view.split.vertical.botright(50)&#xA;&#xA;-- If the supplied number is a fraction between 1 and 0,&#xA;-- it will be used as a proportion&#xA;repl_open_cmd = view.split.vertical.botright(0.61903398875)&#xA;&#xA;-- The size parameter can be a number, a string or a function.&#xA;-- When it&#39;s a *number*, it will be the size in rows/columns&#xA;-- If it&#39;s a *string*, it requires a &#34;%&#34; sign at the end and is calculated&#xA;-- as a percentage of the editor size&#xA;-- If it&#39;s a *function*, it should return a number for the size of rows/columns&#xA;&#xA;repl_open_cmd = view.split(&#34;40%&#34;)&#xA;&#xA;-- You can supply custom logic&#xA;-- to determine the size of your&#xA;-- repl&#39;s window&#xA;repl_open_cmd = view.split.topleft(function()&#xA;  if some_check then&#xA;    return vim.o.lines * 0.4&#xA;  end&#xA;  return 20&#xA;end)&#xA;&#xA;-- An optional set of options can be given to the split function if one&#xA;-- wants to configure the window behavior.&#xA;-- Note that, by default `winfixwidth` and `winfixheight` are set&#xA;-- to `true`. If you want to overwrite those values,&#xA;-- you need to specify the keys in the option map as the example below&#xA;&#xA;repl_open_cmd = view.split(&#34;40%&#34;, {&#xA;  winfixwidth = false,&#xA;  winfixheight = false,&#xA;  -- any window-local configuration can be used here&#xA;  number = true&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;For floats&lt;/h4&gt; &#xA;&lt;p&gt;If you prefer floats, the API is the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local view = require(&#34;iron.view&#34;)&#xA;&#xA;-- iron.setup {...&#xA;&#xA;-- The same size arguments are valid for float functions&#xA;repl_open_cmd = view.top(&#34;10%&#34;)&#xA;&#xA;-- `view.center` takes either one or two arguments&#xA;repl_open_cmd = view.center(&#34;30%&#34;, 20)&#xA;&#xA;-- If you supply only one, it will be used for both dimensions&#xA;-- The function takes an argument to whether the orientation is vertical(true) or&#xA;-- horizontal (false)&#xA;repl_open_cmd = view.center(function(vertical)&#xA;-- Useless function, but it will be called twice,&#xA;-- once for each dimension (width, height)&#xA;  if vertical then&#xA;    return 50&#xA;  end&#xA;  return 20&#xA;end)&#xA;&#xA;-- `view.offset` allows you to control both the size of each dimension and&#xA;-- the distance of them from the top-left corner of the screen&#xA;repl_open_cmd = view.offset{&#xA;  width = 60,&#xA;  height = vim.o.height * 0.75&#xA;  w_offset = 0,&#xA;  h_offset = &#34;5%&#34;&#xA;}&#xA;&#xA;-- Some helper functions allow you to calculate the offset&#xA;-- in relation to the size of the window.&#xA;-- While all other sizing functions take only the orientation boolean (vertical or not),&#xA;-- for offsets, the functions will also take the repl size in that dimension&#xA;-- as argument. The helper functions then return a function that takes two arguments&#xA;-- to calculate the offset&#xA;repl_open_cmd = view.offset{&#xA;  width = 60,&#xA;  height = vim.o.height * 0.75&#xA;  -- `view.helpers.flip` will subtract the size of the REPL&#xA;  -- window from the total dimension, then apply an offset.&#xA;  -- Effectively, it flips the top/left to bottom/right orientation&#xA;  w_offset = view.helpers.flip(2),&#xA;  -- `view.helpers.proportion` allows you to apply a relative&#xA;  -- offset considering the REPL window size.&#xA;  -- for example, 0.5 will centralize the REPL in that dimension,&#xA;  -- 0 will pin it to the top/left and 1 will pin it to the bottom/right.&#xA;  h_offset = view.helpers.proportion(0.5)&#xA;}&#xA;&#xA;-- Differently from `view.center`, all arguments are required&#xA;-- and no defaults will be applied if something is missing.&#xA;repl_open_cmd = view.offset{&#xA;  width = 60,&#xA;  height = vim.o.height * 0.75&#xA;  -- Since we know we&#39;re using this function in the width offset&#xA;  -- calculation, we can ignore the argument&#xA;  w_offset = function(_, repl_size)&#xA;    -- Ideally this function calculates a value based on something..&#xA;    return 42&#xA;  end,&#xA;  h_offset = view.helpers.flip(2)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Support iron.nvim&lt;/h2&gt; &#xA;&lt;p&gt;iron.nvim is developed and maintained by &lt;a href=&#34;https://github.com/sponsors/hkupty&#34;&gt;@hkupty&lt;/a&gt;. Please consider sponsoring the development of iron. Alternatively, pay me a coffee by sending me some BTC in &lt;code&gt;1Dnb3onNAc4XK4FL8cp7NAQ2NFspTZLNRi&lt;/code&gt;. Cheers!&lt;/p&gt;</summary>
  </entry>
</feed>