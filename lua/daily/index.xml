<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-12T01:35:23Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Robitx/gp.nvim</title>
    <updated>2023-11-12T01:35:23Z</updated>
    <id>tag:github.com,2023-11-12:/Robitx/gp.nvim</id>
    <link href="https://github.com/Robitx/gp.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Gp.nvim (GPT prompt) Neovim AI plugin: ChatGPT sessions &amp; Instructable text/code operations &amp; Speech to text [OpenAI]&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Gp (GPT prompt) plugin for Neovim&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Robitx/gp.nvim/raw/main/LICENSE&#34;&gt;&lt;img alt=&#34;GitHub&#34; src=&#34;https://img.shields.io/github/license/robitx/gp.nvim&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Robitx/gp.nvim/stargazers&#34;&gt;&lt;img alt=&#34;GitHub Repo stars&#34; src=&#34;https://img.shields.io/github/stars/Robitx/gp.nvim&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Robitx/gp.nvim/issues&#34;&gt;&lt;img alt=&#34;GitHub closed issues&#34; src=&#34;https://img.shields.io/github/issues-closed/Robitx/gp.nvim&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Robitx/gp.nvim/pulls&#34;&gt;&lt;img alt=&#34;GitHub closed pull requests&#34; src=&#34;https://img.shields.io/github/issues-pr-closed/Robitx/gp.nvim&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Robitx/gp.nvim/graphs/contributors&#34;&gt;&lt;img alt=&#34;GitHub contributors&#34; src=&#34;https://img.shields.io/github/contributors-anon/Robitx/gp.nvim&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/search?q=%2Frequire%5C%28%5B%27%22%5Dgp%5B%27%22%5D%5C%29%5C.setup%2F+language%3ALua&amp;amp;type=code&amp;amp;p=2&#34;&gt;&lt;img alt=&#34;Static Badge&#34; src=&#34;https://img.shields.io/badge/Use%20in%20the%20Wild-8A2BE2&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Gp.nvim provides you ChatGPT like sessions and instructable text/code operations in your favorite editor.&lt;/p&gt; &#xA;&lt;p align=&#34;left&#34;&gt; &lt;img src=&#34;https://github.com/Robitx/gp.nvim/assets/8431097/cb288094-2308-42d6-9060-4eb21b3ba74c&#34; width=&#34;49%&#34;&gt; &lt;img src=&#34;https://github.com/Robitx/gp.nvim/assets/8431097/c538f0a2-4667-444e-8671-13f8ea261be1&#34; width=&#34;49%&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=wPDcBnQgNCc&#34;&gt;Here is an older 5 minute example of using the plugin (needs update)&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h2&gt;Goals and Features&lt;/h2&gt; &#xA;&lt;p&gt;The goal is to extend Neovim with the &lt;strong&gt;power of GPT models in a simple unobtrusive extensible way.&lt;/strong&gt;&lt;br&gt; Trying to keep things as native as possible - reusing and integrating well with the natural features of (Neo)vim.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Streaming responses&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;no spinner wheel and waiting for the full answer&lt;/li&gt; &#xA;   &lt;li&gt;response generation can be canceled half way through&lt;/li&gt; &#xA;   &lt;li&gt;properly working undo (response can be undone with a single &lt;code&gt;u&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Infinitely extensible&lt;/strong&gt; via hook functions specified as part of the config &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;hooks have access to everything in the plugin and are automatically registered as commands&lt;/li&gt; &#xA;   &lt;li&gt;see &lt;a href=&#34;https://raw.githubusercontent.com/Robitx/gp.nvim/main/#4-configuration&#34;&gt;Configuration&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/Robitx/gp.nvim/main/#extend-functionality&#34;&gt;Extend functionality&lt;/a&gt; sections for details&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Minimum dependencies&lt;/strong&gt; (&lt;code&gt;neovim&lt;/code&gt;, &lt;code&gt;curl&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt; and optionally &lt;code&gt;sox&lt;/code&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;zero dependencies on other lua plugins to minimize chance of breakage&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ChatGPT like sessions&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;just good old neovim buffers formated as markdown with autosave and few buffer bound shortcuts&lt;/li&gt; &#xA;   &lt;li&gt;last chat also quickly accessible via toggable popup window&lt;/li&gt; &#xA;   &lt;li&gt;chat finder - management popup for searching, previewing, deleting and opening chat sessions&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Instructable text/code operations&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;templating mechanism to combine user instructions, selections etc into the gpt query&lt;/li&gt; &#xA;   &lt;li&gt;multimodal - same command works for normal/insert mode, with selection or a range&lt;/li&gt; &#xA;   &lt;li&gt;many possible output targets - rewrite, prepend, append, new buffer, popup&lt;/li&gt; &#xA;   &lt;li&gt;non interactive command mode available for common repetitive tasks implementable as simple hooks&lt;br&gt; (explain something in a popup window, write unit tests for selected code into a new buffer,&lt;br&gt; finish selected code based on comments in it, etc.)&lt;/li&gt; &#xA;   &lt;li&gt;custom instructions per repository with &lt;code&gt;.gp.md&lt;/code&gt; file&lt;br&gt; (instruct gpt to generate code using certain libs, packages, conventions and so on)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Speech to text support&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;a mouth is 2-4x faster than fingers when it comes to outputting words - use it where it makes sense&lt;br&gt; (dicating comments and notes, asking gpt questions, giving instructions for code operations, ..)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;h3&gt;1. Install the plugin with your preferred package manager:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- lazy.nvim&#xA;{&#xA;&#x9;&#34;robitx/gp.nvim&#34;,&#xA;&#x9;config = function()&#xA;&#x9;&#x9;require(&#34;gp&#34;).setup()&#xA;&#xA;&#x9;&#x9;-- or setup with your own config (see Install &amp;gt; Configuration in Readme)&#xA;&#x9;&#x9;-- require(&#34;gp&#34;).setup(conf)&#xA;&#xA;        &#x9;-- shortcuts might be setup here (see Usage &amp;gt; Shortcuts in Readme)&#xA;&#x9;end,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- packer.nvim&#xA;use({&#xA;    &#34;robitx/gp.nvim&#34;,&#xA;    config = function()&#xA;        require(&#34;gp&#34;).setup()&#xA;&#xA;&#x9;-- or setup with your own config (see Install &amp;gt; Configuration in Readme)&#xA;&#x9;-- require(&#34;gp&#34;).setup(conf)&#xA;&#xA;        -- shortcuts might be setup here (see Usage &amp;gt; Shortcuts in Readme)&#xA;    end,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;2. OpenAI API key&lt;/h3&gt; &#xA;&lt;p&gt;Make sure you have OpenAI API key. &lt;a href=&#34;https://platform.openai.com/account/api-keys&#34;&gt;Get one here&lt;/a&gt; and use it in the &lt;a href=&#34;https://raw.githubusercontent.com/Robitx/gp.nvim/main/#4-configuration&#34;&gt;config&lt;/a&gt; (or &lt;strong&gt;setup env &lt;code&gt;OPENAI_API_KEY&lt;/code&gt;&lt;/strong&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Also consider setting up &lt;a href=&#34;https://platform.openai.com/account/billing/limits&#34;&gt;usage limits&lt;/a&gt; so you won&#39;t get suprised at the end of the month.&lt;/p&gt; &#xA;&lt;h3&gt;3. Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;The core plugin only needs &lt;code&gt;curl&lt;/code&gt; installed to make calls to OpenAI API and &lt;code&gt;grep&lt;/code&gt; for ChatFinder. So Linux, BSD and Mac OS should be covered.&lt;/p&gt; &#xA;&lt;p&gt;Voice commands (&lt;code&gt;:GpWhisper*&lt;/code&gt;) depend on &lt;code&gt;SoX&lt;/code&gt; (Sound eXchange) to handle audio recording and processing:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mac OS: &lt;code&gt;brew install sox&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Ubuntu/Debian: &lt;code&gt;apt-get install sox&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Arch Linux: &lt;code&gt;pacman -S sox&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Redhat/CentOS: &lt;code&gt;yum install sox&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;NixOS: &lt;code&gt;nix-env -i sox&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;4. Configuration&lt;/h3&gt; &#xA;&lt;p&gt;Here are the default values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local conf = {&#xA;&#x9;-- required openai api key&#xA;&#x9;openai_api_key = os.getenv(&#34;OPENAI_API_KEY&#34;),&#xA;&#x9;-- api endpoint (you can change this to azure endpoint)&#xA;&#x9;openai_api_endpoint = &#34;https://api.openai.com/v1/chat/completions&#34;,&#xA;&#x9;-- openai_api_endpoint = &#34;https://$URL.openai.azure.com/openai/deployments/{{model}}/chat/completions?api-version=2023-03-15-preview&#34;,&#xA;&#x9;-- prefix for all commands&#xA;&#x9;cmd_prefix = &#34;Gp&#34;,&#xA;&#x9;-- optional curl parameters (for proxy, etc.)&#xA;&#x9;-- curl_params = { &#34;--proxy&#34;, &#34;http://X.X.X.X:XXXX&#34; }&#xA;&#x9;curl_params = {},&#xA;&#xA;&#x9;-- directory for storing chat files&#xA;&#x9;chat_dir = vim.fn.stdpath(&#34;data&#34;):gsub(&#34;/$&#34;, &#34;&#34;) .. &#34;/gp/chats&#34;,&#xA;&#x9;-- chat model (string with model name or table with model name and parameters)&#xA;&#x9;chat_model = { model = &#34;gpt-4&#34;, temperature = 1.1, top_p = 1 },&#xA;&#x9;-- chat model system prompt (use this to specify the persona/role of the AI)&#xA;&#x9;chat_system_prompt = &#34;You are a general AI assistant.&#34;,&#xA;&#x9;-- chat custom instructions (not visible in the chat but prepended to model prompt)&#xA;&#x9;chat_custom_instructions = &#34;The user provided the additional info about how they would like you to respond:\n\n&#34;&#xA;&#x9;&#x9;.. &#34;- If you&#39;re unsure don&#39;t guess and say you don&#39;t know instead.\n&#34;&#xA;&#x9;&#x9;.. &#34;- Ask question if you need clarification to provide better answer.\n&#34;&#xA;&#x9;&#x9;.. &#34;- Think deeply and carefully from first principles step by step.\n&#34;&#xA;&#x9;&#x9;.. &#34;- Zoom out first to see the big picture and then zoom in to details.\n&#34;&#xA;&#x9;&#x9;.. &#34;- Use Socratic method to improve your thinking and coding skills.\n&#34;&#xA;&#x9;&#x9;.. &#34;- Don&#39;t elide any code from your output if the answer requires coding.\n&#34;&#xA;&#x9;&#x9;.. &#34;- Take a deep breath; You&#39;ve got this!\n&#34;,&#xA;&#x9;-- chat user prompt prefix&#xA;&#x9;chat_user_prefix = &#34;🗨:&#34;,&#xA;&#x9;-- chat assistant prompt prefix&#xA;&#x9;chat_assistant_prefix = &#34;🤖:&#34;,&#xA;&#x9;-- chat topic generation prompt&#xA;&#x9;chat_topic_gen_prompt = &#34;Summarize the topic of our conversation above&#34;&#xA;&#x9;&#x9;.. &#34; in two or three words. Respond only with those words.&#34;,&#xA;&#x9;-- chat topic model (string with model name or table with model name and parameters)&#xA;&#x9;chat_topic_gen_model = &#34;gpt-3.5-turbo-16k&#34;,&#xA;&#x9;-- explicitly confirm deletion of a chat file&#xA;&#x9;chat_confirm_delete = true,&#xA;&#x9;-- conceal model parameters in chat&#xA;&#x9;chat_conceal_model_params = true,&#xA;&#x9;-- local shortcuts bound to the chat buffer&#xA;&#x9;-- (be careful to choose something which will work across specified modes)&#xA;&#x9;chat_shortcut_respond = { modes = { &#34;n&#34;, &#34;i&#34;, &#34;v&#34;, &#34;x&#34; }, shortcut = &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-g&amp;gt;&#34; },&#xA;&#x9;chat_shortcut_delete = { modes = { &#34;n&#34;, &#34;i&#34;, &#34;v&#34;, &#34;x&#34; }, shortcut = &#34;&amp;lt;C-g&amp;gt;d&#34; },&#xA;&#x9;chat_shortcut_new = { modes = { &#34;n&#34;, &#34;i&#34;, &#34;v&#34;, &#34;x&#34; }, shortcut = &#34;&amp;lt;C-g&amp;gt;n&#34; },&#xA;&#x9;-- default search term when using :GpChatFinder&#xA;&#x9;chat_finder_pattern = &#34;topic &#34;,&#xA;&#xA;&#x9;-- command config and templates bellow are used by commands like GpRewrite, GpEnew, etc.&#xA;&#x9;-- command prompt prefix for asking user for input&#xA;&#x9;command_prompt_prefix = &#34;🤖 ~ &#34;,&#xA;&#x9;-- command model (string with model name or table with model name and parameters)&#xA;&#x9;command_model = { model = &#34;gpt-4&#34;, temperature = 1.1, top_p = 1 },&#xA;&#x9;-- command system prompt&#xA;&#x9;command_system_prompt = &#34;You are an AI working as code editor.\n\n&#34;&#xA;&#x9;&#x9;.. &#34;Please AVOID COMMENTARY OUTSIDE OF SNIPPET RESPONSE.\n&#34;&#xA;&#x9;&#x9;.. &#34;Start and end your answer with:\n\n```&#34;,&#xA;&#x9;-- auto select command response (easier chaining of commands)&#xA;&#x9;command_auto_select_response = true,&#xA;&#xA;&#x9;-- templates&#xA;&#x9;template_selection = &#34;I have the following code from {{filename}}:&#34;&#xA;&#x9;&#x9;.. &#34;\n\n```{{filetype}}\n{{selection}}\n```\n\n{{command}}&#34;,&#xA;&#x9;template_rewrite = &#34;I have the following code from {{filename}}:&#34;&#xA;&#x9;&#x9;.. &#34;\n\n```{{filetype}}\n{{selection}}\n```\n\n{{command}}&#34;&#xA;&#x9;&#x9;.. &#34;\n\nRespond exclusively with the snippet that should replace the code above.&#34;,&#xA;&#x9;template_append = &#34;I have the following code from {{filename}}:&#34;&#xA;&#x9;&#x9;.. &#34;\n\n```{{filetype}}\n{{selection}}\n```\n\n{{command}}&#34;&#xA;&#x9;&#x9;.. &#34;\n\nRespond exclusively with the snippet that should be appended after the code above.&#34;,&#xA;&#x9;template_prepend = &#34;I have the following code from {{filename}}:&#34;&#xA;&#x9;&#x9;.. &#34;\n\n```{{filetype}}\n{{selection}}\n```\n\n{{command}}&#34;&#xA;&#x9;&#x9;.. &#34;\n\nRespond exclusively with the snippet that should be prepended before the code above.&#34;,&#xA;&#x9;template_command = &#34;{{command}}&#34;,&#xA;&#xA;&#x9;-- https://platform.openai.com/docs/guides/speech-to-text/quickstart&#xA;&#x9;-- Whisper costs $0.006 / minute (rounded to the nearest second)&#xA;&#x9;-- by eliminating silence and speeding up the tempo of the recording&#xA;&#x9;-- we can reduce the cost by 50% or more and get the results faster&#xA;&#x9;-- directory for storing whisper files&#xA;&#x9;whisper_dir = &#34;/tmp/gp_whisper&#34;,&#xA;&#x9;-- multiplier of RMS level dB for threshold used by sox to detect silence vs speech&#xA;&#x9;-- decibels are negative, the recording is normalized to -3dB =&amp;gt;&#xA;&#x9;-- increase this number to pick up more (weaker) sounds as possible speech&#xA;&#x9;-- decrease this number to pick up only louder sounds as possible speech&#xA;&#x9;-- you can disable silence trimming by setting this a very high number (like 1000.0)&#xA;&#x9;whisper_silence = &#34;1.75&#34;,&#xA;&#x9;-- whisper max recording time (mm:ss)&#xA;&#x9;whisper_max_time = &#34;05:00&#34;,&#xA;&#x9;-- whisper tempo (1.0 is normal speed)&#xA;&#x9;whisper_tempo = &#34;1.75&#34;,&#xA;&#xA;&#x9;-- example hook functions (see Extend functionality section in the README)&#xA;&#x9;hooks = {&#xA;&#x9;&#x9;InspectPlugin = function(plugin, params)&#xA;&#x9;&#x9;&#x9;print(string.format(&#34;Plugin structure:\n%s&#34;, vim.inspect(plugin)))&#xA;&#x9;&#x9;&#x9;print(string.format(&#34;Command params:\n%s&#34;, vim.inspect(params)))&#xA;&#x9;&#x9;end,&#xA;&#xA;&#x9;&#x9;-- GpImplement rewrites the provided selection/range based on comments in the code&#xA;&#x9;&#x9;Implement = function(gp, params)&#xA;&#x9;&#x9;&#x9;local template = &#34;Having following from {{filename}}:\n\n&#34;&#xA;&#x9;&#x9;&#x9;&#x9;.. &#34;```{{filetype}}\n{{selection}}\n```\n\n&#34;&#xA;&#x9;&#x9;&#x9;&#x9;.. &#34;Please rewrite this code according to the comment instructions.&#34;&#xA;&#x9;&#x9;&#x9;&#x9;.. &#34;\n\nRespond only with the snippet of finalized code:&#34;&#xA;&#xA;&#x9;&#x9;&#x9;gp.Prompt(&#xA;&#x9;&#x9;&#x9;&#x9;params,&#xA;&#x9;&#x9;&#x9;&#x9;gp.Target.rewrite,&#xA;&#x9;&#x9;&#x9;&#x9;nil, -- command will run directly without any prompting for user input&#xA;&#x9;&#x9;&#x9;&#x9;gp.config.command_model,&#xA;&#x9;&#x9;&#x9;&#x9;template,&#xA;&#x9;&#x9;&#x9;&#x9;gp.config.command_system_prompt&#xA;&#x9;&#x9;&#x9;)&#xA;&#x9;&#x9;end,&#xA;&#xA;&#x9;&#x9;-- your own functions can go here, see README for more examples like&#xA;&#x9;&#x9;-- :GpExplain, :GpUnitTests.., :GpBetterChatNew, ..&#xA;&#xA;&#x9;},&#xA;}&#xA;&#xA;...&#xA;&#xA;-- call setup on your config&#xA;require(&#34;gp&#34;).setup(conf)&#xA;&#xA;-- shortcuts might be setup here (see Usage &amp;gt; Shortcuts in Readme)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Commands&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Have ChatGPT experience directly in neovim:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpChatNew&lt;/code&gt; - open fresh chat in the current window&lt;br&gt; (either empty or with the visual selection or specified range as a context)&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpChatPaste&lt;/code&gt; - paste the selection or specified range to the latest chat (simplifies adding code from multiple files into a single chat buffer)&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpChatToggle&lt;/code&gt; - open chat in toggleable popup window&lt;br&gt; (the last active chat or a fresh one with selection or a range as a context)&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpChatFinder&lt;/code&gt; - open a dialog to search through chats&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpChatRespond&lt;/code&gt; - request new gpt response for the current chat&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpChatRespond N&lt;/code&gt; - request new gpt response with only last N messages as a context&lt;br&gt; (using everything from the end up to Nth instance of &lt;code&gt;🗨:..&lt;/code&gt; =&amp;gt; &lt;code&gt;N=1&lt;/code&gt; is like asking a question in a new chat)&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpChatDelete&lt;/code&gt; - delete the current chat&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;when calling &lt;code&gt;:GpChatNew&lt;/code&gt; or &lt;code&gt;:GpChatPaste&lt;/code&gt; you can also specify where to display chat using subcommands: &lt;img src=&#34;https://github.com/Robitx/gp.nvim/assets/8431097/350b38ce-52fb-4df7-b2a5-d6e51581f0c3&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ask GPT and get response to the specified output:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpRewrite&lt;/code&gt; - answer replaces the current line, visual selection or range&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpAppend&lt;/code&gt; - answers after the current line, visual selection or range&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpPrepend&lt;/code&gt; - answers before the current line, selection or range&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpEnew&lt;/code&gt; - answers into new buffer&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpPopup&lt;/code&gt; - answers into pop up window&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpImplement&lt;/code&gt; - default example hook command for finishing the code&lt;br&gt; based on comments provided in visual selection or specified range&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;all these command work either:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;as pure user commands without any other context in normal/insert mode&lt;/li&gt; &#xA;   &lt;li&gt;with current selection (using whole lines) as a context in visual/Visual mode&lt;/li&gt; &#xA;   &lt;li&gt;with specified range (such as &lt;code&gt;%&lt;/code&gt; for the entire current buffer =&amp;gt; &lt;code&gt;:%GpRewrite&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Voice commands transcribed by Whisper API:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpWhisper&lt;/code&gt; - transcription replaces the current line, visual selection or range&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpWhisperRewrite&lt;/code&gt; - answer replaces the current line, visual selection or range&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpWhisperAppend&lt;/code&gt; - answers after the current line, visual selection or range&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpWhisperPrepend&lt;/code&gt; - answers before the current line, selection or range&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpWhisperEnew&lt;/code&gt; - answers into new buffer&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpWhisperPopup&lt;/code&gt; - answers into pop up window&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To stop the stream of currently running gpt response you can use &lt;code&gt;:GpStop&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run your own custom hook commands:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpInspectPlugin&lt;/code&gt; - inspect GPT prompt plugin object&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;GpDone autocommand to run consequent actions&lt;/h3&gt; &#xA;&lt;p&gt;Commands like &lt;code&gt;GpRewrite&lt;/code&gt;, &lt;code&gt;GpAppend&lt;/code&gt; etc. run asynchronously and generate event &lt;code&gt;GpDone&lt;/code&gt;, so you can define autocmd (like auto formating) to run when gp finishes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    vim.api.nvim_create_autocmd({ &#34;User&#34; }, {&#xA;        pattern = {&#34;GpDone&#34;},&#xA;        callback = function(event)&#xA;            print(&#34;event fired:\n&#34;, vim.inspect(event))&#xA;            -- local b = event.buf&#xA;            -- DO something&#xA;        end,&#xA;    })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom instructions per repository&lt;/h3&gt; &#xA;&lt;p&gt;You can make &lt;code&gt;.gp.md&lt;/code&gt; (markdown) file in a root of a repository and commands such as &lt;code&gt;:GpRewrite&lt;/code&gt;, &lt;code&gt;:GpAppend&lt;/code&gt; will respect instructions provided in this file (works better with gpt4, gpt 3.5 doesn&#39;t always listen to system commands). For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-md&#34;&gt;Use ‎C++17.&#xA;Use Testify library when writing Go tests.&#xA;Use Early return/Guard Clauses pattern to avoid excessive nesting.&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Scripting and multifile edits&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;GpDone&lt;/code&gt; event + &lt;code&gt;.gp.md&lt;/code&gt; custom instructions provide a possibility to run gp.nvim using headless (neo)vim from terminal or shell script. So you can let gp run edits accross many files if you put it in a loop.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;test&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1&#xA;2&#xA;3&#xA;4&#xA;5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;.gp.md&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;If user says hello, please respond with:&#xA;&#xA;```&#xA;Ahoy there!&#xA;```&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;calling gp.nvim from terminal/script:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;register autocommand to save and quit nvim when Gp is done&lt;/li&gt; &#xA; &lt;li&gt;second jumps to occurrence of something I want to rewrite/append/prepend to (in this case number &lt;code&gt;3&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;selecting the line&lt;/li&gt; &#xA; &lt;li&gt;calling gp.nvim acction&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ nvim --headless -c &#34;autocmd User GpDone wq&#34; -c &#34;/3&#34; -c &#34;normal V&#34; -c &#34;GpAppend hello there&#34;  test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;resulting &lt;code&gt;test&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1&#xA;2&#xA;3&#xA;Ahoy there!&#xA;4&#xA;5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Shortcuts&lt;/h3&gt; &#xA;&lt;p&gt;There are no default global shortcuts to mess with your own config. Bellow are examples for you to adjust or just use directly.&lt;/p&gt; &#xA;&lt;h4&gt;Native&lt;/h4&gt; &#xA;&lt;p&gt;You can use the good old &lt;code&gt;vim.keymap.set&lt;/code&gt; and paste the following after &lt;code&gt;require(&#34;gp&#34;).setup(conf)&lt;/code&gt; call (or anywhere you keep shortcuts if you want them at one place).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local function keymapOptions(desc)&#xA;    return {&#xA;        noremap = true,&#xA;        silent = true,&#xA;        nowait = true,&#xA;        desc = &#34;GPT prompt &#34; .. desc,&#xA;    }&#xA;end&#xA;&#xA;-- Chat commands&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;c&#34;, &#34;&amp;lt;cmd&amp;gt;GpChatNew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;New Chat&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;t&#34;, &#34;&amp;lt;cmd&amp;gt;GpChatToggle&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Toggle Popup Chat&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;f&#34;, &#34;&amp;lt;cmd&amp;gt;GpChatFinder&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Chat Finder&#34;))&#xA;&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;c&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatNew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Chat New&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;v&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatPaste&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Chat Paste&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;t&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatToggle&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Popup Chat&#34;))&#xA;&#xA;vim.keymap.set({ &#34;n&#34;, &#34;i&#34; }, &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-x&amp;gt;&#34;, &#34;&amp;lt;cmd&amp;gt;GpChatNew split&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;New Chat split&#34;))&#xA;vim.keymap.set({ &#34;n&#34;, &#34;i&#34; }, &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-v&amp;gt;&#34;, &#34;&amp;lt;cmd&amp;gt;GpChatNew vsplit&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;New Chat vsplit&#34;))&#xA;vim.keymap.set({ &#34;n&#34;, &#34;i&#34; }, &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-t&amp;gt;&#34;, &#34;&amp;lt;cmd&amp;gt;GpChatNew tabnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;New Chat tabnew&#34;))&#xA;&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-x&amp;gt;&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatNew split&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Chat New split&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-v&amp;gt;&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatNew vsplit&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Chat New vsplit&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-t&amp;gt;&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatNew tabnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Chat New tabnew&#34;))&#xA;&#xA;-- Prompt commands&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;r&#34;, &#34;&amp;lt;cmd&amp;gt;GpRewrite&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Inline Rewrite&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;a&#34;, &#34;&amp;lt;cmd&amp;gt;GpAppend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Append&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;b&#34;, &#34;&amp;lt;cmd&amp;gt;GpPrepend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Prepend&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;e&#34;, &#34;&amp;lt;cmd&amp;gt;GpEnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Enew&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;p&#34;, &#34;&amp;lt;cmd&amp;gt;GpPopup&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Popup&#34;))&#xA;&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;r&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpRewrite&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Rewrite&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;a&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpAppend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Append&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;b&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpPrepend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Prepend&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;e&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpEnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Enew&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;p&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpPopup&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Popup&#34;))&#xA;&#xA;&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;, &#34;v&#34;, &#34;x&#34;}, &#34;&amp;lt;C-g&amp;gt;s&#34;, &#34;&amp;lt;cmd&amp;gt;GpStop&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Stop&#34;))&#xA;&#xA;&#xA;-- optional Whisper commands&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;w&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisper&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Whisper&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;R&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisperRewrite&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Inline Rewrite&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;A&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisperAppend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Append&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;B&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisperPrepend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Prepend&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;E&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisperEnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Enew&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;P&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisperPopup&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Popup&#34;))&#xA;&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;w&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisper&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Whisper&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;R&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperRewrite&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Rewrite&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;A&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperAppend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Append&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;B&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperPrepend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Prepend&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;E&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperEnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Enew&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;P&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperPopup&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Popup&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Whichkey&lt;/h4&gt; &#xA;&lt;p&gt;Or go more fancy by using &lt;a href=&#34;https://github.com/folke/which-key.nvim&#34;&gt;which-key.nvim&lt;/a&gt; plugin:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- VISUAL mode mappings&#xA;-- s, x, v modes are handled the same way by which_key&#xA;require(&#34;which-key&#34;).register({&#xA;    -- ...&#xA;&#x9;[&#34;&amp;lt;C-g&amp;gt;&#34;] = {&#xA;&#x9;&#x9;c = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatNew&amp;lt;cr&amp;gt;&#34;, &#34;Visual Chat New&#34; },&#xA;&#x9;&#x9;v = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatPaste&amp;lt;cr&amp;gt;&#34;, &#34;Visual Chat Paste&#34; },&#xA;&#x9;&#x9;t = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatToggle&amp;lt;cr&amp;gt;&#34;, &#34;Visual Popup Chat&#34; },&#xA;&#xA;&#x9;&#x9;[&#34;&amp;lt;C-x&amp;gt;&#34;] = { &#34;:&#39;&amp;lt;,&#39;&amp;gt;GpChatNew split&amp;lt;CR&amp;gt;&#34;, &#34;Visual Chat New split&#34; },&#xA;&#x9;&#x9;[&#34;&amp;lt;C-v&amp;gt;&#34;] = { &#34;:&#39;&amp;lt;,&#39;&amp;gt;GpChatNew vsplit&amp;lt;CR&amp;gt;&#34;, &#34;Visual Chat New vsplit&#34; },&#xA;&#x9;&#x9;[&#34;&amp;lt;C-t&amp;gt;&#34;] = { &#34;:&#39;&amp;lt;,&#39;&amp;gt;GpChatNew tabnew&amp;lt;CR&amp;gt;&#34;, &#34;Visual Chat New tabnew&#34; },&#xA;&#xA;&#x9;&#x9;r = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpRewrite&amp;lt;cr&amp;gt;&#34;, &#34;Visual Rewrite&#34; },&#xA;&#x9;&#x9;a = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpAppend&amp;lt;cr&amp;gt;&#34;, &#34;Visual Append&#34; },&#xA;&#x9;&#x9;b = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpPrepend&amp;lt;cr&amp;gt;&#34;, &#34;Visual Prepend&#34; },&#xA;&#x9;&#x9;e = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpEnew&amp;lt;cr&amp;gt;&#34;, &#34;Visual Enew&#34; },&#xA;&#x9;&#x9;p = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpPopup&amp;lt;cr&amp;gt;&#34;, &#34;Visual Popup&#34; },&#xA;&#x9;&#x9;s = { &#34;&amp;lt;cmd&amp;gt;GpStop&amp;lt;cr&amp;gt;&#34;, &#34;Stop&#34; },&#xA;&#xA;&#xA;                -- optional Whisper commands&#xA;&#x9;&#x9;w = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisper&amp;lt;cr&amp;gt;&#34;, &#34;Whisper&#34; },&#xA;&#x9;&#x9;R = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperRewrite&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Visual Rewrite&#34; },&#xA;&#x9;&#x9;A = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperAppend&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Visual Append&#34; },&#xA;&#x9;&#x9;B = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperPrepend&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Visual Prepend&#34; },&#xA;&#x9;&#x9;E = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperEnew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Visual Enew&#34; },&#xA;&#x9;&#x9;P = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperPopup&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Visual Popup&#34; },&#xA;&#x9;},&#xA;    -- ...&#xA;}, {&#xA;&#x9;mode = &#34;v&#34;, -- VISUAL mode&#xA;&#x9;prefix = &#34;&#34;,&#xA;&#x9;buffer = nil,&#xA;&#x9;silent = true,&#xA;&#x9;noremap = true,&#xA;&#x9;nowait = true,&#xA;})&#xA;&#xA;-- NORMAL mode mappings&#xA;require(&#34;which-key&#34;).register({&#xA;    -- ...&#xA;&#x9;[&#34;&amp;lt;C-g&amp;gt;&#34;] = {&#xA;&#x9;&#x9;c = { &#34;&amp;lt;cmd&amp;gt;GpChatNew&amp;lt;cr&amp;gt;&#34;, &#34;New Chat&#34; },&#xA;&#x9;&#x9;t = { &#34;&amp;lt;cmd&amp;gt;GpChatToggle&amp;lt;cr&amp;gt;&#34;, &#34;Toggle Popup Chat&#34; },&#xA;&#x9;&#x9;f = { &#34;&amp;lt;cmd&amp;gt;GpChatFinder&amp;lt;cr&amp;gt;&#34;, &#34;Chat Finder&#34; },&#xA;&#xA;&#x9;&#x9;[&#34;&amp;lt;C-x&amp;gt;&#34;] = { &#34;&amp;lt;cmd&amp;gt;GpChatNew split&amp;lt;cr&amp;gt;&#34;, &#34;New Chat split&#34; },&#xA;&#x9;&#x9;[&#34;&amp;lt;C-v&amp;gt;&#34;] = { &#34;&amp;lt;cmd&amp;gt;GpChatNew vsplit&amp;lt;cr&amp;gt;&#34;, &#34;New Chat vsplit&#34; },&#xA;&#x9;&#x9;[&#34;&amp;lt;C-t&amp;gt;&#34;] = { &#34;&amp;lt;cmd&amp;gt;GpChatNew tabnew&amp;lt;cr&amp;gt;&#34;, &#34;New Chat tabnew&#34; },&#xA;&#xA;&#x9;&#x9;r = { &#34;&amp;lt;cmd&amp;gt;GpRewrite&amp;lt;cr&amp;gt;&#34;, &#34;Inline Rewrite&#34; },&#xA;&#x9;&#x9;a = { &#34;&amp;lt;cmd&amp;gt;GpAppend&amp;lt;cr&amp;gt;&#34;, &#34;Append&#34; },&#xA;&#x9;&#x9;b = { &#34;&amp;lt;cmd&amp;gt;GpPrepend&amp;lt;cr&amp;gt;&#34;, &#34;Prepend&#34; },&#xA;&#x9;&#x9;e = { &#34;&amp;lt;cmd&amp;gt;GpEnew&amp;lt;cr&amp;gt;&#34;, &#34;Enew&#34; },&#xA;&#x9;&#x9;p = { &#34;&amp;lt;cmd&amp;gt;GpPopup&amp;lt;cr&amp;gt;&#34;, &#34;Popup&#34; },&#xA;&#x9;&#x9;s = { &#34;&amp;lt;cmd&amp;gt;GpStop&amp;lt;cr&amp;gt;&#34;, &#34;Stop&#34; },&#xA;&#xA;                -- optional Whisper commands&#xA;&#x9;&#x9;w = { &#34;&amp;lt;cmd&amp;gt;GpWhisper&amp;lt;cr&amp;gt;&#34;, &#34;Whisper&#34; },&#xA;&#x9;&#x9;R = { &#34;&amp;lt;cmd&amp;gt;GpWhisperRewrite&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Inline Rewrite&#34; },&#xA;&#x9;&#x9;A = { &#34;&amp;lt;cmd&amp;gt;GpWhisperAppend&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Append&#34; },&#xA;&#x9;&#x9;B = { &#34;&amp;lt;cmd&amp;gt;GpWhisperPrepend&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Prepend&#34; },&#xA;&#x9;&#x9;E = { &#34;&amp;lt;cmd&amp;gt;GpWhisperEnew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Enew&#34; },&#xA;&#x9;&#x9;P = { &#34;&amp;lt;cmd&amp;gt;GpWhisperPopup&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Popup&#34; },&#xA;&#x9;},&#xA;    -- ...&#xA;}, {&#xA;&#x9;mode = &#34;n&#34;, -- NORMAL mode&#xA;&#x9;prefix = &#34;&#34;,&#xA;&#x9;buffer = nil,&#xA;&#x9;silent = true,&#xA;&#x9;noremap = true,&#xA;&#x9;nowait = true,&#xA;})&#xA;&#xA;-- INSERT mode mappings&#xA;require(&#34;which-key&#34;).register({&#xA;    -- ...&#xA;&#x9;[&#34;&amp;lt;C-g&amp;gt;&#34;] = {&#xA;&#x9;&#x9;c = { &#34;&amp;lt;cmd&amp;gt;GpChatNew&amp;lt;cr&amp;gt;&#34;, &#34;New Chat&#34; },&#xA;&#x9;&#x9;t = { &#34;&amp;lt;cmd&amp;gt;GpChatToggle&amp;lt;cr&amp;gt;&#34;, &#34;Toggle Popup Chat&#34; },&#xA;&#x9;&#x9;f = { &#34;&amp;lt;cmd&amp;gt;GpChatFinder&amp;lt;cr&amp;gt;&#34;, &#34;Chat Finder&#34; },&#xA;&#xA;&#x9;&#x9;[&#34;&amp;lt;C-x&amp;gt;&#34;] = { &#34;&amp;lt;cmd&amp;gt;GpChatNew split&amp;lt;cr&amp;gt;&#34;, &#34;New Chat split&#34; },&#xA;&#x9;&#x9;[&#34;&amp;lt;C-v&amp;gt;&#34;] = { &#34;&amp;lt;cmd&amp;gt;GpChatNew vsplit&amp;lt;cr&amp;gt;&#34;, &#34;New Chat vsplit&#34; },&#xA;&#x9;&#x9;[&#34;&amp;lt;C-t&amp;gt;&#34;] = { &#34;&amp;lt;cmd&amp;gt;GpChatNew tabnew&amp;lt;cr&amp;gt;&#34;, &#34;New Chat tabnew&#34; },&#xA;&#xA;&#x9;&#x9;r = { &#34;&amp;lt;cmd&amp;gt;GpRewrite&amp;lt;cr&amp;gt;&#34;, &#34;Inline Rewrite&#34; },&#xA;&#x9;&#x9;a = { &#34;&amp;lt;cmd&amp;gt;GpAppend&amp;lt;cr&amp;gt;&#34;, &#34;Append&#34; },&#xA;&#x9;&#x9;b = { &#34;&amp;lt;cmd&amp;gt;GpPrepend&amp;lt;cr&amp;gt;&#34;, &#34;Prepend&#34; },&#xA;&#x9;&#x9;e = { &#34;&amp;lt;cmd&amp;gt;GpEnew&amp;lt;cr&amp;gt;&#34;, &#34;Enew&#34; },&#xA;&#x9;&#x9;p = { &#34;&amp;lt;cmd&amp;gt;GpPopup&amp;lt;cr&amp;gt;&#34;, &#34;Popup&#34; },&#xA;&#x9;&#x9;s = { &#34;&amp;lt;cmd&amp;gt;GpStop&amp;lt;cr&amp;gt;&#34;, &#34;Stop&#34; },&#xA;&#xA;                -- optional Whisper commands&#xA;&#x9;&#x9;w = { &#34;&amp;lt;cmd&amp;gt;GpWhisper&amp;lt;cr&amp;gt;&#34;, &#34;Whisper&#34; },&#xA;&#x9;&#x9;R = { &#34;&amp;lt;cmd&amp;gt;GpWhisperRewrite&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Inline Rewrite&#34; },&#xA;&#x9;&#x9;A = { &#34;&amp;lt;cmd&amp;gt;GpWhisperAppend&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Append&#34; },&#xA;&#x9;&#x9;B = { &#34;&amp;lt;cmd&amp;gt;GpWhisperPrepend&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Prepend&#34; },&#xA;&#x9;&#x9;E = { &#34;&amp;lt;cmd&amp;gt;GpWhisperEnew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Enew&#34; },&#xA;&#x9;&#x9;P = { &#34;&amp;lt;cmd&amp;gt;GpWhisperPopup&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Popup&#34; },&#xA;&#x9;},&#xA;    -- ...&#xA;}, {&#xA;&#x9;mode = &#34;i&#34;, -- INSERT mode&#xA;&#x9;prefix = &#34;&#34;,&#xA;&#x9;buffer = nil,&#xA;&#x9;silent = true,&#xA;&#x9;noremap = true,&#xA;&#x9;nowait = true,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Extend functionality&lt;/h2&gt; &#xA;&lt;p&gt;You can extend/override the plugin functionality with your own, by putting functions into &lt;code&gt;config.hooks&lt;/code&gt;. Hooks have access to everything (see &lt;code&gt;InspectPlugin&lt;/code&gt; example in defaults) and are automatically registered as commands (&lt;code&gt;GpInspectPlugin&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Here are some more examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpUnitTests&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- example of adding command which writes unit tests for the selected code&#xA;UnitTests = function(gp, params)&#xA;    local template = &#34;I have the following code from {{filename}}:\n\n&#34;&#xA;        .. &#34;```{{filetype}}\n{{selection}}\n```\n\n&#34;&#xA;        .. &#34;Please respond by writing table driven unit tests for the code above.&#34;&#xA;    gp.Prompt(params, gp.Target.enew, nil, gp.config.command_model,&#xA;        template, gp.config.command_system_prompt)&#xA;end,&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpExplain&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- example of adding command which explains the selected code&#xA;Explain = function(gp, params)&#xA;    local template = &#34;I have the following code from {{filename}}:\n\n&#34;&#xA;        .. &#34;```{{filetype}}\n{{selection}}\n```\n\n&#34;&#xA;        .. &#34;Please respond by explaining the code above.&#34;&#xA;    gp.Prompt(params, gp.Target.popup, nil, gp.config.command_model,&#xA;        template, gp.config.chat_system_prompt)&#xA;end,&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpCodeReview&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- example of usig enew as a function specifying type for the new buffer&#xA;CodeReview = function(gp, params)&#xA;    local template = &#34;I have the following code from {{filename}}:\n\n&#34;&#xA;        .. &#34;```{{filetype}}\n{{selection}}\n```\n\n&#34;&#xA;        .. &#34;Please analyze for code smells and suggest improvements.&#34;&#xA;        gp.Prompt(params, gp.Target.enew(&#34;markdown&#34;), nil, gp.config.command_model,&#xA;            template, gp.config.command_system_prompt)&#xA;    end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpBufferChatNew&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- example of making :%GpChatNew a dedicated command which&#xA;-- opens new chat with the entire current buffer as a context&#xA;BufferChatNew = function(gp, _)&#xA;    -- call GpChatNew command in range mode on whole buffer&#xA;    vim.api.nvim_command(&#34;%&#34; .. gp.config.cmd_prefix .. &#34;ChatNew&#34;)&#xA;end,&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpBetterChatNew&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- example of adding a custom chat command with non-default parameters&#xA;-- (configured default might be gpt-3 and sometimes you might want to use gpt-4)&#xA;BetterChatNew = function(gp, params)&#xA;    local chat_model = { model = &#34;gpt-4&#34;, temperature = 0.7, top_p = 1 }&#xA;    local chat_system_prompt = &#34;You are a general AI assistant.&#34;&#xA;    gp.cmd.ChatNew(params, chat_model, chat_system_prompt)&#xA;end,&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The raw plugin text editing method &lt;code&gt;Prompt&lt;/code&gt; has seven aprameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;params&lt;/code&gt; is a &lt;a href=&#34;https://neovim.io/doc/user/lua-guide.html#lua-guide-commands-create&#34;&gt;table passed to neovim user commands&lt;/a&gt;, &lt;code&gt;Prompt&lt;/code&gt; currently uses:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;range, line1, line2&lt;/code&gt; to work with &lt;a href=&#34;https://neovim.io/doc/user/usr_10.html#10.3&#34;&gt;ranges&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;args&lt;/code&gt; so instructions can be passed directly after command (&lt;code&gt;:GpRewrite something something&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;params = {&#xA;      args = &#34;&#34;,&#xA;      bang = false,&#xA;      count = -1,&#xA;      fargs = {},&#xA;      line1 = 1352,&#xA;      line2 = 1352,&#xA;      mods = &#34;&#34;,&#xA;      name = &#34;GpChatNew&#34;,&#xA;      range = 0,&#xA;      reg = &#34;&#34;,&#xA;      smods = {&#xA;            browse = false,&#xA;            confirm = false,&#xA;            emsg_silent = false,&#xA;            hide = false,&#xA;            horizontal = false,&#xA;            keepalt = false,&#xA;            keepjumps = false,&#xA;            keepmarks = false,&#xA;            keeppatterns = false,&#xA;            lockmarks = false,&#xA;            noautocmd = false,&#xA;            noswapfile = false,&#xA;            sandbox = false,&#xA;            silent = false,&#xA;            split = &#34;&#34;,&#xA;            tab = -1,&#xA;            unsilent = false,&#xA;            verbose = -1,&#xA;            vertical = false&#xA;      }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;target&lt;/code&gt; specifying where to direct GPT response&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;enew can be used as a function so you can pass in a filetype for the new buffer (&lt;code&gt;enew/enew()/enew(&#34;markdown&#34;)/..&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;M.Target = {&#xA;    rewrite = 0, -- for replacing the selection, range or the current line&#xA;    append = 1, -- for appending after the selection, range or the current line&#xA;    prepend = 2, -- for prepending before the selection, range or the current line&#xA;    popup = 3, -- for writing into the popup window&#xA;&#xA;    -- for writing into a new buffer&#xA;    ---@param filetype nil | string # nil = same as the original buffer&#xA;    ---@return table # a table with type=4 and filetype=filetype&#xA;    enew = function(filetype)&#xA;        return { type = 4, filetype = filetype }&#xA;    end,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;prompt&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;string used similarly as bash/zsh prompt in terminal, when plugin asks for user command to gpt.&lt;/li&gt; &#xA;   &lt;li&gt;if &lt;code&gt;nil&lt;/code&gt;, user is not asked to provide input (for specific predefined commands - document this, explain that, write tests ..)&lt;/li&gt; &#xA;   &lt;li&gt;simple &lt;code&gt;🤖 ~ &lt;/code&gt; might be used or you could use different msg to convey info about the method which is called&lt;br&gt; (&lt;code&gt;🤖 rewrite ~&lt;/code&gt;, &lt;code&gt;🤖 popup ~&lt;/code&gt;, &lt;code&gt;🤖 enew ~&lt;/code&gt;, &lt;code&gt;🤖 inline ~&lt;/code&gt;, etc.)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;model&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;see &lt;a href=&#34;https://platform.openai.com/docs/models/overview&#34;&gt;gpt model overview&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;template&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;template of the user message send to gpt&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;string can include variables bellow:&lt;/p&gt; &#xA;    &lt;table&gt; &#xA;     &lt;thead&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;th&gt;name&lt;/th&gt; &#xA;       &lt;th&gt;Description&lt;/th&gt; &#xA;      &lt;/tr&gt; &#xA;     &lt;/thead&gt; &#xA;     &lt;tbody&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;td&gt;&lt;code&gt;{{filetype}}&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td&gt;filetype of the current buffer&lt;/td&gt; &#xA;      &lt;/tr&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;td&gt;&lt;code&gt;{{selection}}&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td&gt;last or currently selected text&lt;/td&gt; &#xA;      &lt;/tr&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;td&gt;&lt;code&gt;{{command}}&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td&gt;instructions provided by the user&lt;/td&gt; &#xA;      &lt;/tr&gt; &#xA;     &lt;/tbody&gt; &#xA;    &lt;/table&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;system_template&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;See &lt;a href=&#34;https://platform.openai.com/docs/guides/chat/introduction&#34;&gt;gpt api intro&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;whisper&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;optional string serving as a default for input prompt (for example generated from speech by Whisper)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>