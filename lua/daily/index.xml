<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-27T01:27:48Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ThePrimeagen/vim-with-me</title>
    <updated>2024-04-27T01:27:48Z</updated>
    <id>tag:github.com,2024-04-27:/ThePrimeagen/vim-with-me</id>
    <link href="https://github.com/ThePrimeagen/vim-with-me" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Version 2 Protocol Thoughts&lt;/h1&gt; &#xA;&lt;h2&gt;One location Three Items&lt;/h2&gt; &#xA;&lt;p&gt;Version 2 of the protocol can consider having location as the top level encode and then dangle off *Foreground *Background and Ascii value&lt;/p&gt; &#xA;&lt;p&gt;Then the window could just track the diffs and send down minimum amounts of information for the change, thus we only have to specify the 2 byte location once for ascii + color change.&lt;/p&gt; &#xA;&lt;h2&gt;Color&lt;/h2&gt; &#xA;&lt;p&gt;Encode color as 2 bytes&lt;/p&gt; &#xA;&lt;p&gt;1 2-6 7-11 12-16 +--+----------+----------+----------+ |F | Red | Green | Blue | +--+----------+----------+----------+&lt;/p&gt; &#xA;&lt;p&gt;33% reduction in color space requirements&lt;/p&gt; &#xA;&lt;h2&gt;Color Again&lt;/h2&gt; &#xA;&lt;p&gt;We could do color compression but only have a specified color table ahead of time that encodes up to 128 colors as 1 byte values, with one bit reserved for F/B&lt;/p&gt; &#xA;&lt;p&gt;66% savings on the most frequent&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>danielfalk/smart-open.nvim</title>
    <updated>2024-04-27T01:27:48Z</updated>
    <id>tag:github.com,2024-04-27:/danielfalk/smart-open.nvim</id>
    <link href="https://github.com/danielfalk/smart-open.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Neovim plugin for fast file-finding&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;smart-open.nvim&lt;/h1&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://github.com/nvim-telescope/telescope.nvim&#34;&gt;telescope.nvim&lt;/a&gt; extension designed to provide the best possible suggestions for quickly opening files in Neovim. smart-open will improve its suggestions over time, adapting to your usage.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt; ⚠️ smart-open is &lt;strong&gt;beta&lt;/strong&gt; at this time. Contributions welcome.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/GShkgXm.gif&#34; alt=&#34;Preview&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Isn&#39;t this yet another fuzzy file finding plugin?&lt;/h2&gt; &#xA;&lt;p&gt;In a way, but most other solutions require multiple mappings to search:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;git files&lt;/li&gt; &#xA; &lt;li&gt;open buffers&lt;/li&gt; &#xA; &lt;li&gt;recent files&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The goal of smart-open is to give you highly relevant results with as few keystrokes as possible--so much so that only a single mapping is needed for searching everything while still managing to be quick about it.&lt;/p&gt; &#xA;&lt;h2&gt;How it works&lt;/h2&gt; &#xA;&lt;p&gt;The source of suggestions is a combination of files under the current working directory, and your history. Ranking takes the following factors into account:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;How well the file path matches the search text&lt;/li&gt; &#xA; &lt;li&gt;How well the file &lt;em&gt;name&lt;/em&gt; matches the search text (see notes for file name details)&lt;/li&gt; &#xA; &lt;li&gt;Recency of last open&lt;/li&gt; &#xA; &lt;li&gt;Whether the file is the last-edited (that is, alternate buffer)&lt;/li&gt; &#xA; &lt;li&gt;The file is currently open&lt;/li&gt; &#xA; &lt;li&gt;How close the file&#39;s parent directory is to the currently-open file&#39;s&lt;/li&gt; &#xA; &lt;li&gt;&#34;Frecency&#34; - how frequently the file has been opened, with a bias toward recent opens. (See notes on frecency)&lt;/li&gt; &#xA; &lt;li&gt;Whether the file is anywhere under the current working directory. This is especially useful if using an extension that cd&#39;s to your project&#39;s top-level directory.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This ranking algorithm is self-tuning. Over time, the weights of the factors above will be adjusted based upon your interaction with it. The tuning process is especially sensitive to selecting a suggestion that is not at the top. Weights will be adjusted relative to the higher-ranked suggestions that were not selected.&lt;/p&gt; &#xA;&lt;p&gt;Calculating and tuning all these factors might sound slow, but this is not the case. Results return quickly and the impact of these calculations are optimized to be negligible.&lt;/p&gt; &#xA;&lt;h1&gt;Notes&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;In certain cases, both the parent directory as well as the filename are treated as the &#34;file name&#34;. This is because for some file structures, the filename itself isn&#39;t informative. For example, if your JavaScript project uses the convention of &lt;code&gt;directoryName/index.js&lt;/code&gt; throughout, then searching for &#34;index&#34; isn&#39;t going to be very useful. As a result, we treat &lt;code&gt;index.js&lt;/code&gt; and &lt;code&gt;init.lua&lt;/code&gt; as special cases, and treat &lt;code&gt;parentDirectory/filename&lt;/code&gt; as though it were the filename.&lt;/li&gt; &#xA; &lt;li&gt;Search text matching uses the fzy algorithm. If telescope-fzy-native is installed, it will be used.&lt;/li&gt; &#xA; &lt;li&gt;Determining how close two files&#39; directories are is just a function of how many directories the two files have in common. This means that for any pair of files in the same directory, the score is more significant the deeper that directory is.&lt;/li&gt; &#xA; &lt;li&gt;Frecency controls how long a given file is preserved in history. While it can be replenished by opening that file, this value otherwise dwindles over time. When the value is fully depleted, the file can be cleared from the history, improving performance and disk usage. Frecency uses an implementation of Mozilla&#39;s &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm&#34;&gt;Frecency algorithm&lt;/a&gt; (used in &lt;a href=&#34;https://support.mozilla.org/en-US/kb/address-bar-autocomplete-firefox&#34;&gt;Firefox&#39;s address bar&lt;/a&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Acknowledgements&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Thanks to telescope-frecency.nvim for inspiration. This code is also adapted from that code base.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Using an implementation of Mozilla&#39;s &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm&#34;&gt;Frecency algorithm&lt;/a&gt; (used in &lt;a href=&#34;https://support.mozilla.org/en-US/kb/address-bar-autocomplete-firefox&#34;&gt;Firefox&#39;s address bar&lt;/a&gt;), files edited &lt;em&gt;frecently&lt;/em&gt; are given higher precedence in the list index.&lt;/p&gt; &#xA;&lt;p&gt;As the extension learns your editing habits over time, the sorting of the list is dynamically altered to prioritize the files you&#39;re likely to need.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;neovim 0.6+ (required)&lt;/li&gt; &#xA; &lt;li&gt;ripgrep (required)&lt;/li&gt; &#xA; &lt;li&gt;sqlite3 (required)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-telescope/telescope.nvim&#34;&gt;telescope.nvim&lt;/a&gt; (required)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kkharji/sqlite.lua&#34;&gt;sqlite.lua&lt;/a&gt; (required)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kyazdani42/nvim-web-devicons&#34;&gt;nvim-web-devicons&lt;/a&gt; (optional)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-telescope/telescope-fzy-native.nvim&#34;&gt;telescope-fzy-native.nvim&lt;/a&gt; (optional)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-telescope/telescope-fzf-native.nvim&#34;&gt;telescope-fzf-native.nvim&lt;/a&gt; (optional)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Timestamps, scoring weights, and file records are stored in an &lt;a href=&#34;https://www.sqlite.org/index.html&#34;&gt;SQLite3&lt;/a&gt; database for persistence and speed.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/folke/lazy.nvim&#34;&gt;Lazy.nvim&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Put the following in your &lt;code&gt;lazy.setup(...)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  &#34;danielfalk/smart-open.nvim&#34;,&#xA;  branch = &#34;0.2.x&#34;,&#xA;  config = function()&#xA;    require(&#34;telescope&#34;).load_extension(&#34;smart_open&#34;)&#xA;  end,&#xA;  dependencies = {&#xA;    &#34;kkharji/sqlite.lua&#34;,&#xA;    -- Only required if using match_algorithm fzf&#xA;    { &#34;nvim-telescope/telescope-fzf-native.nvim&#34;, build = &#34;make&#34; },&#xA;    -- Optional.  If installed, native fzy will be used when match_algorithm is fzy&#xA;    { &#34;nvim-telescope/telescope-fzy-native.nvim&#34; },&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;Packer.nvim&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use {&#xA;  &#34;danielfalk/smart-open.nvim&#34;,&#xA;  branch = &#34;0.2.x&#34;,&#xA;  config = function()&#xA;    require&#34;telescope&#34;.load_extension(&#34;smart_open&#34;)&#xA;  end,&#xA;  requires = {&#xA;    {&#34;kkharji/sqlite.lua&#34;},&#xA;    -- Only required if using match_algorithm fzf&#xA;    { &#34;nvim-telescope/telescope-fzf-native.nvim&#34;, run = &#34;make&#34; },&#xA;    -- Optional.  If installed, native fzy will be used when match_algorithm is fzy&#xA;    { &#34;nvim-telescope/telescope-fzy-native.nvim&#34; },&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;sqlite3 (required)&lt;/h3&gt; &#xA;&lt;p&gt;sqlite3 must be installed locally. (if you are on mac it might be installed already)&lt;/p&gt; &#xA;&lt;h4&gt;Windows&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.sqlite.org/download.html&#34;&gt;Download precompiled&lt;/a&gt; and set &lt;code&gt;let g:sqlite_clib_path = path/to/sqlite3.dll&lt;/code&gt; (note: &lt;code&gt;/&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;h4&gt;Linux&lt;/h4&gt; &#xA;&lt;h5&gt;Arch&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo pacman -S sqlite # Arch&#xA;sudo apt-get install sqlite3 libsqlite3-dev # Ubuntu&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Fedora&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo dnf install sqlite sqlite-devel sqlite-tcl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Nix (home-manager)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;programs.neovim.plugins = [&#xA;    {&#xA;      plugin = pkgs.vimPlugins.sqlite-lua;&#xA;      config = &#34;let g:sqlite_clib_path = &#39;${pkgs.sqlite.out}/lib/libsqlite3.so&#39;&#34;;&#xA;    }&#xA;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If no database is found when running Neovim with the plugin installed, a new one is created and entries from &lt;code&gt;shada&lt;/code&gt; &lt;code&gt;v:oldfiles&lt;/code&gt; are automatically imported.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;:Telescope smart_open&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;..or to map to a key:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.keymap.set(&#34;n&#34;, &#34;&amp;lt;leader&amp;gt;&amp;lt;leader&amp;gt;&#34;, function ()&#xA;  require(&#34;telescope&#34;).extensions.smart_open.smart_open()&#xA;end, { noremap = true, silent = true })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Options&lt;/h2&gt; &#xA;&lt;p&gt;Options can be set when opening the picker. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;telescope&#39;).extensions.smart_open.smart_open {&#xA;  cwd_only = true,&#xA;  filename_first = false,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cwd_only&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;Limit the results to files under the current working directory. This is normally not needed because if you prefer this pattern of access, then the plugin will pick up on that over time regardless, to the point where files under &lt;code&gt;cwd&lt;/code&gt; will be recommended above all others.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;filename_first&lt;/code&gt; (default: &lt;code&gt;true&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;Format filename as &#34;filename path/to/parent/directory&#34; if &lt;code&gt;true&lt;/code&gt; and &#34;path/to/parent/directory/filename&#34; if &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/nvim-telescope/telescope.nvim#telescope-defaults&#34;&gt;default configuration&lt;/a&gt; for full details on configuring Telescope.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;show_scores&lt;/code&gt; (default : &lt;code&gt;false&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;To see the scores generated by the algorithm in the results, set this to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ignore_patterns&lt;/code&gt; (default: &lt;code&gt;{&#34;*.git/*&#34;, &#34;*/tmp/*&#34;}&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;Patterns in this table control which files are indexed (and subsequently which you&#39;ll see in the finder results).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;match_algorithm&lt;/code&gt; (default: &lt;code&gt;fzy&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;The algorithm to use for determining how well each file path matches the typed-in search text. Options are &lt;code&gt;fzf&lt;/code&gt; and &lt;code&gt;fzy&lt;/code&gt;. Entered text is not the only factor considered in ranking but is typically the most significant.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;disable_devicons&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;Disable devicons (if available)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;open_buffer_indicators&lt;/code&gt; (default: &lt;code&gt;{previous = &#34;•&#34;, others = &#34;∘&#34;}&lt;/code&gt;)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Example Configuration:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;telescope.setup {&#xA;  extensions = {&#xA;    smart_open = {&#xA;      match_algorithm = &#34;fzf&#34;,&#xA;      disable_devicons = false,&#xA;    },&#xA;  },&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Known Limitations&lt;/h3&gt; &#xA;&lt;p&gt;For files not already in your history, smart-open uses ripgrep for scanning the current directory. (The command is roughly: &lt;code&gt;rg --files --glob-case-insensitive --hidden --ignore-file=&amp;lt;cwd&amp;gt;/.ff-ignore -g &amp;lt;ignore_patterns...&amp;gt;&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;As a result, files added to git, &lt;em&gt;but also ignored by git&lt;/em&gt;, will not be included. While not common, this is something that git allows. If this becomes a problem you can work around it by either changing your git ignore patterns, editing the file in neovim in some other way, (thereby adding it to the history), or by using ripgrep&#39;s &lt;code&gt;.ignore&lt;/code&gt; file for overriding git.&lt;/p&gt; &#xA;&lt;h3&gt;Highlight Groups&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Directory&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>