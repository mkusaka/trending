<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-02T01:35:08Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>PickleModifications/ptelevision</title>
    <updated>2022-11-02T01:35:08Z</updated>
    <id>tag:github.com,2022-11-02:/PickleModifications/ptelevision</id>
    <link href="https://github.com/PickleModifications/ptelevision" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Free &amp; Open Source Television Script for FiveM.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt;&#xA; &lt;img src=&#34;https://user-images.githubusercontent.com/111543470/198868741-d78353cf-0576-4f2e-8554-1f7e4ef4c986.png&#34;&gt;&#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34;&gt;&#xA; &lt;h3&gt;&lt;a href=&#34;https://pickle-mods.tebex.io/&#34;&gt;More Information &amp;amp; Scripts can be found here!&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;/div&gt; &#xA;&lt;h2&gt;What is this?&lt;/h2&gt; &#xA;&lt;p&gt;Basically, this serves as a free resource for servers that need a television script.&lt;/p&gt; &#xA;&lt;p&gt;With this resource, you will be able to do the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Watch Youtube &amp;amp; Twitch Videos / Streams.&lt;/li&gt; &#xA; &lt;li&gt;Broadcast your Youtube / Twitch Stream as a server-wide channel.&lt;/li&gt; &#xA; &lt;li&gt;Display &amp;amp; Browse the Web.&lt;/li&gt; &#xA; &lt;li&gt;Display Images and Videos (via direct link in the browser).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What do I need?&lt;/h2&gt; &#xA;&lt;p&gt;You will need the following for this script to work.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ox Lib (works with any framework)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to make a fork, please obtain permission with a valid reason.&lt;/p&gt; &#xA;&lt;h2&gt;Need Support?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pickle-mods.tebex.io/contact&#34;&gt;Click here!&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ggandor/leap-spooky.nvim</title>
    <updated>2022-11-02T01:35:08Z</updated>
    <id>tag:github.com,2022-11-02:/ggandor/leap-spooky.nvim</id>
    <link href="https://github.com/ggandor/leap-spooky.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸ‘» Actions at a distance&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;leap-spooky.nvim ðŸ‘»&lt;/h1&gt; &#xA;&lt;p&gt;Spooky is a &lt;a href=&#34;https://github.com/ggandor/leap.nvim&#34;&gt;Leap&lt;/a&gt; extension that allows for remote operations on Vim&#39;s native text objects: that is, it exposes atomic bundles of (virtual or actual) leaping motions and text object selections.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ggandor/leap-spooky.nvim/media/showcase.gif?raw=true&#34; alt=&#34;showcase&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;AFAIK, the basic idea first appeared in &lt;a href=&#34;https://github.com/goldfeld/vim-seek&#34;&gt;vim-seek&lt;/a&gt;, one of &lt;a href=&#34;https://github.com/justinmk/vim-sneak&#34;&gt;vim-sneak&lt;/a&gt;&#39;s predecessors. (The feature is coincidentally called &#34;leaping motions&#34; there, no kidding.)&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s not just the number of keystrokes that matter here, but the potentially more intuitive workflow achieved through these higher abstractions, that are nevertheless obvious extensions of Vim&#39;s grammar. As usual, the aim is to sharpen the saw; there are no big list of new commands to learn, except for two affixes that can be added to all existing text objects. &lt;code&gt;carb&amp;lt;leap&amp;gt;&lt;/code&gt; (&#34;change around remote block [marked by leap motion]&#34;) in no time will be just as natural as targets.vim&#39;s &lt;code&gt;canb&lt;/code&gt; (&#34;change around next block&#34;).&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Leap is automatically invoked once the text object is specified; after e.g. &lt;code&gt;yarw&lt;/code&gt;, start typing the 2-character search pattern, and select the target as you would usually do. The difference is that instead of jumping there, the word will be yanked.&lt;/p&gt; &#xA;&lt;h2&gt;What are some fun things you can do with this?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;delete/fold/comment/etc. paragraphs without leaving your position (&lt;code&gt;zfarp&amp;lt;leap&amp;gt;&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Clone text objects in the blink of an eye, even from another window, by turning on auto-paste after yanking (&lt;code&gt;yarp&amp;lt;leap&amp;gt;&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Fix a typo with a short, atomic command sequence (&lt;code&gt;cimw&amp;lt;leap&amp;gt;&amp;lt;correction&amp;gt;&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Operate on distant lines: &lt;code&gt;drr&amp;lt;leap&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;code&gt;count&lt;/code&gt;: e.g. &lt;code&gt;y3rr&amp;lt;leap&amp;gt;&lt;/code&gt; yanks 3 lines, just as &lt;code&gt;3yy&lt;/code&gt; would do.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;WIP - everything is experimental at the moment.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ggandor/leap.nvim&#34;&gt;leap.nvim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;setup&lt;/code&gt; creates all the necessary mappings - you can call it without arguments, if the defaults are okay:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;leap-spooky&#39;).setup {&#xA;  affixes = {&#xA;    -- These will generate mappings for all native text objects, like:&#xA;    -- (ir|ar|iR|aR|im|am|iM|aM){obj}.&#xA;    -- Special line objects will also be added, by repeating the affixes.&#xA;    -- E.g. `yrr&amp;lt;leap&amp;gt;` and `ymm&amp;lt;leap&amp;gt;` will yank a line in the current&#xA;    -- window.&#xA;    -- You can also use &#39;rest&#39; &amp;amp; &#39;move&#39; as mnemonics.&#xA;    remote   = { window = &#39;r&#39;, cross_window = &#39;R&#39; },&#xA;    magnetic = { window = &#39;m&#39;, cross_window = &#39;M&#39; },&#xA;  },&#xA;  -- If this option is set to true, the yanked text will automatically be pasted&#xA;  -- at the cursor position if the unnamed register is in use (and the object is&#xA;  -- &#34;non-magnetic&#34;).&#xA;  yank_paste = false,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Customisation&lt;/h2&gt; &#xA;&lt;p&gt;Note: This is absolutely not stable API, just a current snapshot for people who would like to experiment.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;spooky_action&lt;/code&gt; returns a one-argument function that can be used as &lt;code&gt;leap&lt;/code&gt;&#39;s &lt;code&gt;action&lt;/code&gt; parameter. That is, you have to call it when used in a mapping.&lt;/p&gt; &#xA;&lt;p&gt;The signature looks like: &lt;code&gt;spooky_action(action, {opts})&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;action&lt;/code&gt;: a function returning a string to be passed to &lt;code&gt;:normal&lt;/code&gt; (by default, the expected action is a text object selection, like &lt;code&gt;viw&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;opts.on_return&lt;/code&gt;: like &lt;code&gt;action&lt;/code&gt;, but the command is be executed after the operation has been finished&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;opts.keeppos&lt;/code&gt;: if true, execute the action remotely (jump back afterwards)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;leap&#39;).leap {&#xA;  target_windows = { vim.fn.win_getid() }&#xA;  action = require(&#39;leap-spooky&#39;).spooky_action(&#xA;    function () return &#34;viw&#34; end,&#xA;    { keeppos = true, on_return = (vim.v.operator == &#39;y&#39;) and &#39;p&#39;, },&#xA;  ),&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also check the source code for ideas, or if something is unclear.&lt;/p&gt; &#xA;&lt;h2&gt;Planned features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;It would be awesome to restrict the search area to the given text objects. E.g. &lt;code&gt;cr]&lt;/code&gt; would only give matches inside square brackets. This could often add a huge speed boost and reduce the visual noise a lot. We could even highlight the active areas.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Label the text objects themselves (at least blocks, paragraphs, etc.), so that you can immediately choose one, instead of having to specify the reference point with a default 2-char Leap motion.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;API for &#34;spookifying&#34; custom (non-native) text objects.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>