<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-10T01:40:47Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>leandromoreira/cdn-up-and-running</title>
    <updated>2023-01-10T01:40:47Z</updated>
    <id>tag:github.com,2023-01-10:/leandromoreira/cdn-up-and-running</id>
    <link href="https://github.com/leandromoreira/cdn-up-and-running" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CDN Up and Running - Building a CDN from Scratch to Learn about CDN&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CDN Up and Running&lt;/h1&gt; &#xA;&lt;p&gt;The objective of this repo is to build a body of knowledge on how CDNs work by coding one from &#34;scratch&#34;. The CDN we&#39;re going to design uses: nginx, lua, docker, docker-compose, Prometheus, grafana, and wrk.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ll start creating a single backend service and expand from there to a multi-node, latency simulated, observable, and testable CDN. In each section, there are discussions regarding the challenges and trade-offs of building/managing/operating a CDN.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/4.0.1_metrics.webp&#34; alt=&#34;grafana screenshot&#34; title=&#34;grafana screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is a CDN?&lt;/h2&gt; &#xA;&lt;p&gt;A Content Delivery Network is a set of computers, spatially distributed in order to provide high availability and &lt;strong&gt;better performance&lt;/strong&gt; for systems that have their &lt;strong&gt;work cached&lt;/strong&gt; on this network.&lt;/p&gt; &#xA;&lt;h2&gt;Why do you need a CDN?&lt;/h2&gt; &#xA;&lt;p&gt;A CDN helps to improve:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;loading times (smoother streaming, instant page to buy, quick friends feed, etc)&lt;/li&gt; &#xA; &lt;li&gt;accommodate traffic spikes (black friday, popular streaming release, breaking news, etc)&lt;/li&gt; &#xA; &lt;li&gt;decrease costs (traffic offloading)&lt;/li&gt; &#xA; &lt;li&gt;scalability for millions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How does a CDN work?&lt;/h2&gt; &#xA;&lt;p&gt;CDNs are able to make services faster by placing the content (media files, pages, games, javascript, a json response, etc) closer to the users.&lt;/p&gt; &#xA;&lt;p&gt;When a user wants to consume a service, the CDN routing system will deliver the &#34;best&#34; node where the content is likely &lt;strong&gt;already cached and closer to the client&lt;/strong&gt;. Don&#39;t worry about the loose use of the word best in here. I hope that throughout the reading, the understanding of what is the best node will be elucidated.&lt;/p&gt; &#xA;&lt;h2&gt;The CDN stack&lt;/h2&gt; &#xA;&lt;p&gt;The CDN we&#39;ll build relies on:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.linux.org/&#34;&gt;&lt;code&gt;Linux/GNU/Kernel&lt;/code&gt;&lt;/a&gt; - a kernel / operating system with outstanding networking capabilities as well as IO excellence.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nginx.org/&#34;&gt;&lt;code&gt;Nginx&lt;/code&gt;&lt;/a&gt; - an excellent web server that can be used as a reverse proxy providing caching capability.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://luajit.org/&#34;&gt;&lt;code&gt;Lua(jit)&lt;/code&gt;&lt;/a&gt; - a simple powerful language to add features into nginx.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://prometheus.io/&#34;&gt;&lt;code&gt;Prometheus&lt;/code&gt;&lt;/a&gt; - A system with a dimensional data model, flexible query language, efficient time series database.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/grafana/grafana&#34;&gt;&lt;code&gt;Grafana&lt;/code&gt;&lt;/a&gt; - An open source analytics &amp;amp; monitoring tool that plugs with many sources, including prometheus.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.docker.com/&#34;&gt;&lt;code&gt;Containers&lt;/code&gt;&lt;/a&gt; - technology to package, deploy, and isolate applications, we&#39;ll use docker and docker compose.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Origin - the backend service&lt;/h1&gt; &#xA;&lt;p&gt;Origin is the system where the content is created - or at least it&#39;s the source to the CDN. The sample service we&#39;re going to build will be a straightforward JSON API. The backend service could be returning an image, video, javascript, HTML page, game, or anything you want to deliver to your clients.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ll use Nginx and Lua to design the backend service. It&#39;s a great excuse to introduce Nginx and Lua since we&#39;re going to use them a lot here.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Heads up: the backend service could be written in any language you like.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Nginx - quick introduction&lt;/h2&gt; &#xA;&lt;p&gt;Nginx is a web server that will follow its &lt;a href=&#34;http://nginx.org/en/docs/beginners_guide.html#conf_structure&#34;&gt;configuration&lt;/a&gt;. The config file uses &lt;a href=&#34;http://nginx.org/en/docs/dirindex.html&#34;&gt;directives&lt;/a&gt; as the dominant factor. A directive is a simple construction to set properties in nginx. There are two types of directives: &lt;strong&gt;simple and block (context)&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;strong&gt;simple directive&lt;/strong&gt; is formed by its name followed by parameters ending with a semicolon.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;# Syntax: &amp;lt;name&amp;gt; &amp;lt;parameters&amp;gt;;&#xA;# Example&#xA;add_header X-Header AnyValue;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;strong&gt;block directive&lt;/strong&gt; follows the same pattern, but instead of a semicolon, it ends surrounded by curly braces. A block directive can also have directives within it. This block is also known as context.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;# Syntax: &amp;lt;name&amp;gt; &amp;lt;parameters&amp;gt; &amp;lt;block&amp;gt;&#xA;location / {&#xA;  add_header X-Header AnyValue;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Nginx uses workers (processes) to handle the requests. The &lt;a href=&#34;https://www.aosabook.org/en/nginx.html&#34;&gt;nginx architecture&lt;/a&gt; plays a crucial role in its performance.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/simplified_workers_nginx_architecture.webp&#34; alt=&#34;simplified workers nginx architecture&#34; title=&#34;simplified workers nginx architecture&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Heads up: Although a single accept queue serving multiple workers is common, there are other models to &lt;a href=&#34;https://blog.cloudflare.com/the-sad-state-of-linux-socket-balancing/&#34;&gt;load balance the incoming requests&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Backend service conf&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s walk through the backend JSON API nginx configuration. I think it&#39;ll be much easier if we see it in action.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;events {&#xA;  worker_connections 1024;&#xA;}&#xA;error_log stderr;&#xA;&#xA;http {&#xA;  access_log /dev/stdout;&#xA;&#xA;  server {&#xA;    listen 8080;&#xA;&#xA;    location / {&#xA;      content_by_lua_block {&#xA;        ngx.header[&#39;Content-Type&#39;] = &#39;application/json&#39;&#xA;        ngx.say(&#39;{&#34;service&#34;: &#34;api&#34;, &#34;value&#34;: 42}&#39;)&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Were you able to understand what this config is doing? In any case, let&#39;s break it down by making comments on each directive.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;http://nginx.org/en/docs/ngx_core_module.html#events&#34;&gt;&lt;code&gt;events&lt;/code&gt;&lt;/a&gt; provides context for &lt;a href=&#34;http://nginx.org/en/docs/events.html&#34;&gt;connection processing configurations&lt;/a&gt;, and the &lt;a href=&#34;http://nginx.org/en/docs/ngx_core_module.html#worker_connections&#34;&gt;&lt;code&gt;worker_connections&lt;/code&gt;&lt;/a&gt; defines the maximum number of simultaneous connections that can be opened by a worker process.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;events {&#xA;  worker_connections 1024;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;http://nginx.org/en/docs/ngx_core_module.html#error_log&#34;&gt;&lt;code&gt;error_log&lt;/code&gt;&lt;/a&gt; configures logging for error. Here we just send all the errors to the stdout (error)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;error_log stderr;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_core_module.html#http&#34;&gt;&lt;code&gt;http&lt;/code&gt;&lt;/a&gt; provides a root context to set up all the http/s servers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;http {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_log_module.html#access_log&#34;&gt;&lt;code&gt;access_log&lt;/code&gt;&lt;/a&gt; configures the path (and optionally format, etc) for the access logging.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;access_log /dev/stdout;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_core_module.html#server&#34;&gt;&lt;code&gt;server&lt;/code&gt;&lt;/a&gt; sets the root configuration for a server, aka where we&#39;re going to setup specific behavior to the server. You can have multiple &lt;code&gt;server&lt;/code&gt; blocks per &lt;code&gt;http&lt;/code&gt; context.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Within the &lt;code&gt;server&lt;/code&gt; we can set the &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_core_module.html#listen&#34;&gt;&lt;code&gt;listen&lt;/code&gt;&lt;/a&gt; directive controlling the address and/or the port on which the &lt;a href=&#34;http://nginx.org/en/docs/http/request_processing.html&#34;&gt;server will accept requests&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;listen 8080;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the server configuration, we can specify a route by using the &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_core_module.html#location&#34;&gt;&lt;code&gt;location&lt;/code&gt;&lt;/a&gt; directive. This will be used to provide specific configuration for that matching request path.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;location / {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Within this location (by the way, &lt;code&gt;/&lt;/code&gt; will handle all the requests) we&#39;ll use Lua to create the response. There&#39;s a directive called &lt;a href=&#34;https://github.com/openresty/lua-nginx-module#content_by_lua_block&#34;&gt;&lt;code&gt;content_by_lua_block&lt;/code&gt;&lt;/a&gt; which provides a context where the Lua code will run.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;content_by_lua_block {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, we&#39;ll use Lua and the basic &lt;a href=&#34;https://github.com/openresty/lua-nginx-module#nginx-api-for-lua&#34;&gt;Nginx Lua API&lt;/a&gt; to set the desired behavior.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- ngx.header sets the current response header that is to be sent.&#xA;ngx.header[&#39;Content-Type&#39;] = &#39;application/json&#39;&#xA;-- ngx.say will write the response body&#xA;ngx.say(&#39;{&#34;service&#34;: &#34;api&#34;, &#34;value&#34;: 42}&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that most of the directives contain their scope. For instance, the &lt;code&gt;location&lt;/code&gt; is only applicable within the &lt;code&gt;location&lt;/code&gt; (recursively) and &lt;code&gt;server&lt;/code&gt; context.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/nginx_directive_restriction.webp&#34; alt=&#34;directive restriction&#34; title=&#34;directive restriction&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Heads up: we won&#39;t comment on each directive we add from now on, we&#39;ll only describe the most relevant for the section.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;CDN 1.0.0 Demo time&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s see what we did.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout 1.0.0 # going back to specific configuration&#xA;docker-compose run --rm --service-ports backend # run the containers exposing the service&#xA;http http://localhost:8080/path/to/my/content.ext # consuming the service, I used httpie but you can use curl or anything you like&#xA;&#xA;# you should see the json response :)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Adding caching capabilities&lt;/h2&gt; &#xA;&lt;p&gt;For the backend service to be cacheable we need to set up the caching policy. We&#39;ll use the HTTP header &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control&#34;&gt;Cache-Control&lt;/a&gt; to setup what caching behavior we want.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Lua&#34;&gt;-- we want the content to be cached by 10 seconds OR the provided max_age (ex: /path/to/service?max_age=40 for 40 seconds)&#xA;ngx.header[&#39;Cache-Control&#39;] = &#39;public, max-age=&#39; .. (ngx.var.arg_max_age or 10)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And, if you want, make sure to check the returned response header &lt;code&gt;Cache-Control&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout 1.0.1 # going back to specific configuration&#xA;docker-compose run --rm --service-ports backend&#xA;http &#34;http://localhost:8080/path/to/my/content.ext?max_age=30&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Adding metrics&lt;/h2&gt; &#xA;&lt;p&gt;Checking the logging is fine for debugging. But once we&#39;re reaching more traffic, it&#39;ll be nearly impossible to understand how the service is operating. To tackle this case, we&#39;re going to use &lt;a href=&#34;https://github.com/vozlt/nginx-module-vts&#34;&gt;VTS&lt;/a&gt;, an nginx module which adds metrics measurements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;vhost_traffic_status_zone shared:vhost_traffic_status:12m;&#xA;vhost_traffic_status_filter_by_set_key $status status::*;&#xA;vhost_traffic_status_histogram_buckets 0.005 0.01 0.05 0.1 0.5 1 5 10; # buckets are in seconds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/vozlt/nginx-module-vts#vhost_traffic_status_zone&#34;&gt;&lt;code&gt;vhost_traffic_status_zone&lt;/code&gt;&lt;/a&gt; sets a memory space required for the metrics. The &lt;a href=&#34;https://github.com/vozlt/nginx-module-vts#vhost_traffic_status_filter_by_set_key&#34;&gt;&lt;code&gt;vhost_traffic_status_filter_by_set_key&lt;/code&gt;&lt;/a&gt; groups metrics by a given variable (for instance, we decided to group metrics by &lt;code&gt;status&lt;/code&gt;) and finally, the &lt;a href=&#34;https://github.com/vozlt/nginx-module-vts#vhost_traffic_status_histogram_buckets&#34;&gt;&lt;code&gt;vhost_traffic_status_histogram_buckets&lt;/code&gt;&lt;/a&gt; provides a way to bucketize the metrics in seconds. We decided to create buckets varying from &lt;code&gt;0.005&lt;/code&gt; to &lt;code&gt;10&lt;/code&gt; seconds, because they will help us to create percentiles (&lt;code&gt;p99&lt;/code&gt;, &lt;code&gt;p50&lt;/code&gt;, etc).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;location /status {&#xA;  vhost_traffic_status_display;&#xA;  vhost_traffic_status_display_format html;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We also must expose the metrics in a location. We will use the &lt;code&gt;/status&lt;/code&gt; to do it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout 1.1.0&#xA;docker-compose run --rm --service-ports backend&#xA;# if you go to http://localhost:8080/status/format/html you&#39;ll see information about the server 8080&#xA;# notice that VTS also provides other formats such as status/format/prometheus, which will be pretty helpful for us in near future&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/metrics_status.webp&#34; alt=&#34;nginx vts status page&#34; title=&#34;nginx vts status page&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;With metrics, we can run (load) tests and see if the configuration changes we made are resulting in a better performance or not.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Heads up&lt;/strong&gt;: You can &lt;a href=&#34;https://github.com/leandromoreira/cdn-up-and-running/commit/105f54a27d1b58b88659789ae024d70c89d4a478&#34;&gt;group the metrics under a custom namespace&lt;/a&gt;. This is useful when you have a single location that behaves differently depending on the context.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Refactoring the nginx conf&lt;/h2&gt; &#xA;&lt;p&gt;As the configuration becomes bigger, it also gets harder to comprehend. Nginx offers a neat directive called &lt;a href=&#34;http://nginx.org/en/docs/ngx_core_module.html#include&#34;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt; which allows us to create partial config files and include them into the root configuration file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-    location /status {&#xA;-      vhost_traffic_status_display;&#xA;-      vhost_traffic_status_display_format html;&#xA;-    }&#xA;+    include basic_vts_location.conf;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can extract location, group configurations per similarities, or anything that makes sense to a file. We can do &lt;a href=&#34;https://github.com/openresty/lua-nginx-module#lua_package_path&#34;&gt;a similar thing for the Lua code&lt;/a&gt; as well.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;       content_by_lua_block {&#xA;-        ngx.header[&#39;Content-Type&#39;] = &#39;application/json&#39;&#xA;-        ngx.header[&#39;Cache-Control&#39;] = &#39;public, max-age=&#39; .. (ngx.var.arg_max_age or 10)&#xA;-&#xA;-        ngx.say(&#39;{&#34;service&#34;: &#34;api&#34;, &#34;value&#34;: 42, &#34;request&#34;: &#34;&#39; .. ngx.var.uri .. &#39;&#34;}&#39;)&#xA;+        local backend = require &#34;backend&#34;&#xA;+        backend.generate_content()&#xA;       }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All these modifications were made to improve readability, but it also promotes reuse.&lt;/p&gt; &#xA;&lt;h1&gt;The CDN - siting in front of the backend&lt;/h1&gt; &#xA;&lt;h2&gt;Proxying&lt;/h2&gt; &#xA;&lt;p&gt;What we did so far has nothing to do with the CDN. Now it&#39;s time to start building the CDN. For that, we&#39;ll create another node with nginx, just adding a few new directives to connect the &lt;code&gt;edge&lt;/code&gt; (CDN) node with the &lt;code&gt;backend&lt;/code&gt; node.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/edge_backend.webp&#34; alt=&#34;backend edge architecture&#34; title=&#34;backend edge architecture&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s really nothing fancy here, it&#39;s just an &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream&#34;&gt;&lt;code&gt;upstream&lt;/code&gt;&lt;/a&gt; block with a server pointing to our &lt;code&gt;backend&lt;/code&gt; endpoint. In the location, we do not provide the content, but instead we point to the upstream, using the &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass&#34;&gt;&lt;code&gt;proxy_pass&lt;/code&gt;&lt;/a&gt;, we just created.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;upstream backend {&#xA;  server backend:8080;&#xA;  keepalive 10;  # connection pool for reuse&#xA;}&#xA;&#xA;server {&#xA;  listen 8080;&#xA;&#xA;  location / {&#xA;    proxy_pass http://backend;&#xA;    add_header X-Cache-Status $upstream_cache_status;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We also added a new header (X-Cache-Status) to indicate whether the &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#variables&#34;&gt;cache was used or not&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;HIT&lt;/strong&gt;: when the content is in the CDN, the &lt;code&gt;X-Cache-Status&lt;/code&gt; should return a hit.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;MISS&lt;/strong&gt;: when the content isn&#39;t in the CDN, the &lt;code&gt;X-Cache-Status&lt;/code&gt; should return a miss.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout 2.0.0&#xA;docker-compose up&#xA;# we still can fetch the content from the backend&#xA;http &#34;http://localhost:8080/path/to/my/content.ext&#34;&#xA;# but we really want to access the content through the edge (CDN)&#xA;http &#34;http://localhost:8081/path/to/my/content.ext&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Caching&lt;/h2&gt; &#xA;&lt;p&gt;When we try to fetch content, the &lt;code&gt;X-Cache-Status&lt;/code&gt; header is absent. It seems that the edge node is always invariably requesting the backend. This is not the way a CDN should work, right?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;backend_1     | 172.22.0.4 - - [05/Jan/2022:17:24:48 +0000] &#34;GET /path/to/my/content.ext HTTP/1.0&#34; 200 70 &#34;-&#34; &#34;HTTPie/2.6.0&#34;&#xA;edge_1        | 172.22.0.1 - - [05/Jan/2022:17:24:48 +0000] &#34;GET /path/to/my/content.ext HTTP/1.1&#34; 200 70 &#34;-&#34; &#34;HTTPie/2.6.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The edge is just proxying the clients to the backend. What are we missing? Is there any reason to use a &#34;simple&#34; proxy at all? Well, it does, maybe you want to provide throttling, authentication, authorization, tls termination, or a gateway for multiple services, but that&#39;s not what we want.&lt;/p&gt; &#xA;&lt;p&gt;We need to create a cache area on nginx through the directive &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path&#34;&gt;&lt;code&gt;proxy_cache_path&lt;/code&gt;&lt;/a&gt;. It&#39;s setting up the path where the cached content will reside, the shared memory &lt;code&gt;key_zone&lt;/code&gt;, and policies such as &lt;code&gt;inactive&lt;/code&gt;, &lt;code&gt;max_size&lt;/code&gt;, among others, to control how we want the cache to behave.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;proxy_cache_path /cache/ levels=2:2 keys_zone=zone_1:10m max_size=10m inactive=10m use_temp_path=off;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once we&#39;ve configured a proper cache, we must also set up the &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache&#34;&gt;&lt;code&gt;proxy_cache&lt;/code&gt;&lt;/a&gt; pointing to the right zone (via &lt;code&gt;proxy_cache_path keys_zone=&amp;lt;name&amp;gt;:size&lt;/code&gt;), and the &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass&#34;&gt;&lt;code&gt;proxy_pass&lt;/code&gt;&lt;/a&gt; linking to the upstream we&#39;ve created.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;location / {&#xA;    # ...&#xA;    proxy_pass http://backend;&#xA;    proxy_cache zone_1;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is another important aspect of caching which is managed by the directive &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_key&#34;&gt;&lt;code&gt;proxy_cache_key&lt;/code&gt;&lt;/a&gt;. When a client requests content from nginx, it will (highly simplified):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Receive the request (let&#39;s say: &lt;code&gt;GET /path/to/something.txt&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Apply a hash md5 function over the cache key value (let&#39;s assume that the cache key is the &lt;code&gt;uri&lt;/code&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;md5(&#34;/path/to/something.txt&#34;) =&amp;gt; &lt;code&gt;b3c4c5e7dc10b13dc2e3f852e52afcf3&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;you can check that on your terminarl &lt;code&gt;echo -n &#34;/path/to/something.txt&#34; | md5&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;It checks whether the content (hash &lt;code&gt;b3c4..&lt;/code&gt;) is cached or not&lt;/li&gt; &#xA; &lt;li&gt;If it&#39;s cached, it just returns the object otherwise it fetches the content from the backend &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;It also saves locally (in memory and on disk) to avoid future requests&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Let&#39;s create a variable called &lt;code&gt;cache_key&lt;/code&gt; using the lua directive &lt;a href=&#34;https://github.com/openresty/lua-nginx-module#set_by_lua&#34;&gt;&lt;code&gt;set_by_lua_block&lt;/code&gt;&lt;/a&gt;. It will, for each incoming request, fill the &lt;code&gt;cache_key&lt;/code&gt; with the &lt;code&gt;uri&lt;/code&gt; &lt;strong&gt;value&lt;/strong&gt;. Beyond that, we also need to update the &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_key&#34;&gt;&lt;code&gt;proxy_cache_key&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;location / {&#xA;    set_by_lua_block $cache_key {&#xA;      return ngx.var.uri&#xA;    }&#xA;    # ...&#xA;    proxy_cache_key $cache_key;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Heads up&lt;/strong&gt;: Using &lt;code&gt;uri&lt;/code&gt; as cache key will make the following two requests &lt;a href=&#34;http://example.com/path/to/content.ext&#34;&gt;http://example.com/path/to/content.ext&lt;/a&gt; and &lt;a href=&#34;http://example.edu/path/to/content.ext&#34;&gt;http://example.edu/path/to/content.ext&lt;/a&gt; (if they&#39;re using the same cache proxy) as if they were a single object. If you do not provide a cache key, nginx will use a reasonable &lt;strong&gt;default value&lt;/strong&gt; &lt;code&gt;$scheme$proxy_host$request_uri&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Now we can see the caching properly working.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout 2.1.0&#xA;docker-compose up&#xA;http &#34;http://localhost:8081/path/to/my/content.ext&#34;&#xA;# the second request must get the content from the CDN without leaving to the backend&#xA;http &#34;http://localhost:8081/path/to/my/content.ext&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/cache_hit.webp&#34; alt=&#34;cache hit header&#34; title=&#34;cache hit header&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Monitoring Tools&lt;/h2&gt; &#xA;&lt;p&gt;Checking the cache effectiveness by looking at the command line isn&#39;t efficient. It&#39;s better if we use a tool for that. &lt;strong&gt;Prometheus&lt;/strong&gt; will be used to scrape metrics on all servers, and &lt;strong&gt;Grafana&lt;/strong&gt; will show graphics based on the metrics collected by the prometheus.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/metrics_architecture.webp&#34; alt=&#34;instrumentalization architecture&#34; title=&#34;instrumentalization architecture&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Prometheus configuration will look like this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;global:&#xA;  scrape_interval:     10s # each 10s prometheus will scrape targets&#xA;  evaluation_interval: 10s&#xA;  scrape_timeout: 2s&#xA;&#xA;  external_labels:&#xA;      monitor: &#39;CDN&#39;&#xA;&#xA;scrape_configs:&#xA;  - job_name: &#39;prometheus&#39;&#xA;    metrics_path: &#39;/status/format/prometheus&#39;&#xA;    static_configs:&#xA;      - targets: [&#39;edge:8080&#39;, &#39;backend:8080&#39;] # the server list to be scrapped by the scrap_path&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, we need to add a prometheus source for Grafana.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/add_source.webp&#34; alt=&#34;grafana source&#34; title=&#34;grafana source&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;And set the proper prometheus server.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/set_source.webp&#34; alt=&#34;grafana source set&#34; title=&#34;grafana source set&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Simulated Work (latency)&lt;/h2&gt; &#xA;&lt;p&gt;The backend server is artificially creating responses. We&#39;ll add simulated latency using lua. The idea is to make it closer to real-world situations. We&#39;re going to model the latency using &lt;a href=&#34;https://www.mathsisfun.com/data/percentiles.html&#34;&gt;percentiles&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;percentile_config={&#xA;    {p=50, min=1, max=20,}, {p=90, min=21, max=50,}, {p=95, min=51, max=150,}, {p=99, min=151, max=500,},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We randomly pick a number from 1 to 100, and then we apply another random using the respective &lt;code&gt;percentile profile&lt;/code&gt; ranging from the min to the max. Finally, we &lt;a href=&#34;https://github.com/openresty/lua-nginx-module#ngxsleep&#34;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt; that duration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local current_percentage = random(1, 100) -- decide with percentile this request will be&#xA;-- let&#39;s assume we picked 94&#xA;-- therefore we&#39;ll use the percentile_config with p90&#xA;local sleep_duration = random(p90.min, p90.max)&#xA;sleep(sleep_seconds)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This model lets us freely try to emulate closer to &lt;a href=&#34;https://research.google/pubs/pub40801/&#34;&gt;real-world observed latencies&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Load Testing&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;ll run some load testing to learn more about the solution we&#39;re building. Wrk is an HTTP benchmarking tool that you can dynamically configure using lua. We pick a random number from 1 to 100 and request that item.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;request = function()&#xA;  local item = &#34;item_&#34; .. random(1, 100)&#xA;&#xA;  return wrk.format(nil, &#34;/&#34; .. item .. &#34;.ext&#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The command line will run the tests for 10 minutes (600s), using two threads, and 10 connections.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wrk -c10 -t2 -d600s -s ./src/load_tests.lua --latency http://localhost:8081&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course, you can run this on your machine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-compose up&#xA;&#xA;# run the tests&#xA;./load_test.sh&#xA;&#xA;# go check on grafana, how the system is behaving&#xA;http://localhost:9091&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;wrk&lt;/code&gt; output was as shown bellow. There were &lt;strong&gt;37k&lt;/strong&gt; requests with &lt;strong&gt;674&lt;/strong&gt; failing requests in total.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Running 10m test @ http://localhost:8081&#xA;  2 threads and 10 connections&#xA;  Thread Stats   Avg      Stdev     Max   +/- Stdev&#xA;    Latency   218.31ms  236.55ms   1.99s    84.32%&#xA;    Req/Sec    35.14     29.02   202.00     79.15%&#xA;  Latency Distribution&#xA;     50%  162.73ms&#xA;     75%  350.33ms&#xA;     90%  519.56ms&#xA;     99%    1.02s&#xA;  37689 requests in 10.00m, 15.50MB read&#xA;  Non-2xx or 3xx responses: 674&#xA;Requests/sec:     62.80&#xA;Transfer/sec:     26.44KB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Grafana showed that in a given instant, &lt;strong&gt;68&lt;/strong&gt; requests were responded by the &lt;code&gt;edge&lt;/code&gt;. From these requests, &lt;strong&gt;16&lt;/strong&gt; went through the &lt;code&gt;backend&lt;/code&gt;. The &lt;a href=&#34;https://www.cloudflare.com/learning/cdn/what-is-a-cache-hit-ratio/&#34;&gt;cache efficiency&lt;/a&gt; was &lt;strong&gt;76%&lt;/strong&gt;, 1% of the request&#39;s latency was longer than &lt;strong&gt;3.6s&lt;/strong&gt;, 5% observed more than &lt;strong&gt;786ms&lt;/strong&gt;, and the median was around &lt;strong&gt;73ms&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/2.2.0_metrics.webp&#34; alt=&#34;grafana result for 2.2.0&#34; title=&#34;grafana result for 2.2.0&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Learning by testing - let&#39;s change the cache ttl (max age)&lt;/h2&gt; &#xA;&lt;p&gt;This project should engage you to experiment, change parameters values, run load testing, and check the results. I think this loop can be a great to learn. Let&#39;s try to see what happens when we change the cache behavior.&lt;/p&gt; &#xA;&lt;h3&gt;1s&lt;/h3&gt; &#xA;&lt;p&gt;Using 1s for cache validity.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;request = function()&#xA;  local item = &#34;item_&#34; .. random(1, 100)&#xA;&#xA;  return wrk.format(nil, &#34;/&#34; .. item .. &#34;.ext?max_age=1&#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the tests, and the result is: only 16k requests with 773 errors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Running 10m test @ http://localhost:8081&#xA;  2 threads and 10 connections&#xA;  Thread Stats   Avg      Stdev     Max   +/- Stdev&#xA;    Latency   378.72ms  254.21ms   1.46s    68.40%&#xA;    Req/Sec    15.11      9.98    90.00     74.18%&#xA;  Latency Distribution&#xA;     50%  396.15ms&#xA;     75%  507.22ms&#xA;     90%  664.18ms&#xA;     99%    1.05s&#xA;  16643 requests in 10.00m, 6.83MB read&#xA;  Non-2xx or 3xx responses: 773&#xA;Requests/sec:     27.74&#xA;Transfer/sec:     11.66KB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We also noticed that the cache hit went down significantly &lt;code&gt;(23%)&lt;/code&gt;, and many more requests leaked to the backend.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/2.2.1_metrics_1s.webp&#34; alt=&#34;grafana result for 2.2.1 1 second&#34; title=&#34;grafana result for 2.2.1 1 second&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;60s&lt;/h3&gt; &#xA;&lt;p&gt;What if instead we increase the caching expire to a complete minute?!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;request = function()&#xA;  local item = &#34;item_&#34; .. random(1, 100)&#xA;&#xA;  return wrk.format(nil, &#34;/&#34; .. item .. &#34;.ext?max_age=60&#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the tests, and the result now is: 45k requests with 551 errors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Running 10m test @ http://localhost:8081&#xA;  2 threads and 10 connections&#xA;  Thread Stats   Avg      Stdev     Max   +/- Stdev&#xA;    Latency   196.27ms  223.43ms   1.79s    84.74%&#xA;    Req/Sec    42.31     34.80   242.00     78.01%&#xA;  Latency Distribution&#xA;     50%   79.67ms&#xA;     75%  321.06ms&#xA;     90%  494.41ms&#xA;     99%    1.01s&#xA;  45695 requests in 10.00m, 18.79MB read&#xA;  Non-2xx or 3xx responses: 551&#xA;Requests/sec:     76.15&#xA;Transfer/sec:     32.06KB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We see a much better &lt;strong&gt;cache efficiency (80% vs 23%)&lt;/strong&gt; and &lt;strong&gt;throughput (45k vs 16k requests)&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/2.2.1_metrics_60s.webp&#34; alt=&#34;grafana result for 2.2.1 60 seconds&#34; title=&#34;grafana result for 2.2.1 60 seconds&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Heads up&lt;/strong&gt;: caching for longer helps improve performance but at the cost of stale content.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Fine tunning - cache lock, stale, timeout, network&lt;/h2&gt; &#xA;&lt;p&gt;Using default configurations for Nginx, linux, and others will be sufficient for many small workloads. But when you&#39;re goal is more ambitious, you will inevitably need to fine-tune the CDN for your need.&lt;/p&gt; &#xA;&lt;p&gt;The process of fine-tuning a web server is gigantic. It goes from managing how &lt;a href=&#34;https://blog.cloudflare.com/the-sad-state-of-linux-socket-balancing/&#34;&gt;&lt;code&gt;nginx/Linux process sockets&lt;/code&gt;&lt;/a&gt;, to &lt;a href=&#34;https://github.com/leandromoreira/linux-network-performance-parameters&#34;&gt;&lt;code&gt;linux network queuing&lt;/code&gt;&lt;/a&gt;, how &lt;a href=&#34;https://serverfault.com/questions/796665/what-are-the-performance-implications-for-millions-of-files-in-a-modern-file-sys&#34;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt; affects performance, among other aspects. There is a lot of symbiosis between the &lt;a href=&#34;https://nginx.org/en/docs/http/ngx_http_core_module.html#sendfile&#34;&gt;application and OS&lt;/a&gt; with direct implications to the performance, for instance &lt;a href=&#34;https://docs.kernel.org/networking/tls-offload.html&#34;&gt;saving user land switch context with ktls&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll be reading a lot of man pages, mostly tweaking timeouts and buffers. The test loop can help you build confidence in your ideas, let&#39;s see.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You have a hypothesis or have observed something weird and want to test a parameter value &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;stick to a single set of related parameters each time&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Set the new value&lt;/li&gt; &#xA; &lt;li&gt;Run the tests&lt;/li&gt; &#xA; &lt;li&gt;Check results against the same server with the old parameter&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Heads up&lt;/strong&gt;: doing tests locally is fine for learning, but most of the time you&#39;ll only trust your production results. Be prepared to do a partial deployment, compare old system/config to newer test parameters.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Did you notice that the errors were all related to timeout? It seems that the &lt;code&gt;backend&lt;/code&gt; is taking longer to respond than what the &lt;code&gt;edge&lt;/code&gt; is willing to wait.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;edge_1        | 2021/12/29 11:52:45 [error] 8#8: *3 upstream timed out (110: Operation timed out) while reading response header from upstream, client: 172.25.0.1, server: , request: &#34;GET /item_34.ext HTTP/1.1&#34;, upstream: &#34;http://172.25.0.3:8080/item_34.ext&#34;, host: &#34;localhost:8081&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To solve this problem we can try to increase the proxy timeouts. We&#39;re also using a neat directive &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_use_stale&#34;&gt;&lt;code&gt;proxy_cache_use_stale&lt;/code&gt;&lt;/a&gt; that serves &lt;code&gt;stale content&lt;/code&gt; when nginx is dealing with &lt;code&gt;errors, timeout, or even updating the cache&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;proxy_cache_lock_timeout 2s;&#xA;proxy_read_timeout 2s;&#xA;proxy_send_timeout 2s;&#xA;proxy_cache_use_stale error timeout updating;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While we were reading about proxy caching, something catch our attention. There&#39;s a directive called &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_lock&#34;&gt;&lt;code&gt;proxy_cache_lock&lt;/code&gt;&lt;/a&gt; that collapses multiple user requests for the same content into a single request going &lt;code&gt;upstream&lt;/code&gt; to fetch the content at a time. This is very often known as &lt;a href=&#34;https://cloud.google.com/cdn/docs/caching#request-coalescing&#34;&gt;coalescing&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;proxy_cache_lock on&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/cache_lock.webp&#34; alt=&#34;caching lock&#34; title=&#34;caching lock&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Running the tests we observed that we decrease the timeout errors but we also got less throughput. Why? Maybe it&#39;s because of lock contention. The big benefit of this feature it&#39;s to avoid the &lt;a href=&#34;https://alexpareto.com/2020/06/15/thundering-herds.html&#34;&gt;thundering herd&lt;/a&gt; in the backend. Traffic went down from &lt;strong&gt;6k to 3k&lt;/strong&gt; and requests from &lt;strong&gt;16 to 8&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/3.0.0_metrics.webp&#34; alt=&#34;grafana result for test 3.0.0&#34; title=&#34;grafana result for test 3.0.0&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;From normal to long tail distribution&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;ve been running load testing assuming a &lt;a href=&#34;https://en.wikipedia.org/wiki/Normal_distribution&#34;&gt;normal distribution&lt;/a&gt; but that&#39;s far from reality. What we might see in production is &lt;a href=&#34;https://en.wikipedia.org/wiki/Long_tail&#34;&gt;most of the requests will be towards a few items&lt;/a&gt;. To closer simulate that, we&#39;ll tweak our code to randomly pick a number from 1 to 100 and then decide if it&#39;s a popular item or not.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local popular_percentage = 96 -- 96% of users are requesting top 5 content&#xA;local popular_items_quantity = 5 -- top content quantity&#xA;local max_total_items = 200 -- total items clientes are requesting&#xA;&#xA;request = function()&#xA;  local is_popular = random(1, 100) &amp;lt;= popular_percentage&#xA;  local item = &#34;&#34;&#xA;&#xA;  if is_popular then -- if it&#39;s popular let&#39;s pick one of the top content&#xA;    item = &#34;item-&#34; .. random(1, popular_items_quantity)&#xA;  else -- otherwise let&#39;s pick any resting items&#xA;    item = &#34;item-&#34; .. random(popular_items_quantity + 1, popular_items_quantity + max_total_items)&#xA;  end&#xA;&#xA;  return wrk.format(nil, &#34;/path/&#34; .. item .. &#34;.ext&#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Heads-up&lt;/strong&gt;: we could model the long tail using &lt;a href=&#34;https://firstmonday.org/ojs/index.php/fm/article/view/1832/1716&#34;&gt;a formula&lt;/a&gt;, but for the purpose of this repo, this extrapolation might be good enough.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Now, let&#39;s test again with &lt;code&gt;proxy_cache_lock&lt;/code&gt; &lt;code&gt;off&lt;/code&gt; and &lt;code&gt;on&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Long tail &lt;code&gt;proxy_cache_lock&lt;/code&gt; off&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/3.1.0_metrics.webp&#34; alt=&#34;grafana result for test 3.1.0&#34; title=&#34;grafana result for test 3.1.0&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Long tail &lt;code&gt;proxy_cache_lock&lt;/code&gt; on&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/3.1.1_metrics.webp&#34; alt=&#34;grafana result for test 3.1.1&#34; title=&#34;grafana result for test 3.1.1&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s pretty close, even though the &lt;code&gt;lock off&lt;/code&gt; is still better marginally. This feature might go to production to show if it&#39;s worthy or not.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Heads up&lt;/strong&gt;: the &lt;code&gt;proxy_cache_lock_timeout&lt;/code&gt; is dangerous but necessary, if the configured time has passed, all the requests will go to the backend.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Routing challenges&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;ve been testing a single edge but in reality, there will be hundreds of nodes. Having more edge nodes is necessary for scalability, resilience and also to provide closer to user responses. Introducing multiple nodes also introduces another challenge, clients need somehow to figure out which node to fetch the content.&lt;/p&gt; &#xA;&lt;p&gt;There are many ways to overcome this complication, and we&#39;ll try to explore some of them.&lt;/p&gt; &#xA;&lt;h3&gt;Load balancing&lt;/h3&gt; &#xA;&lt;p&gt;A load balancer will spread the client&#39;s requests among all the edges.&lt;/p&gt; &#xA;&lt;h4&gt;Round-robin&lt;/h4&gt; &#xA;&lt;p&gt;Round-robin is a balancing policy that takes an ordered list of edges and goes serving requests picking a server each time and wrapping around when the server list ends.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;# on nginx, if we do not specify anything the default policy is weighted round-robin&#xA;# http://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream&#xA;upstream backend {&#xA;  server edge:8080;&#xA;  server edge1:8080;&#xA;  server edge2:8080;&#xA;}&#xA;&#xA;server {&#xA;  listen 8080;&#xA;&#xA;  location / {&#xA;    proxy_pass http://backend;&#xA;    add_header X-Edge LoadBaalancer;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What&#39;s good about &lt;code&gt;round-robin&lt;/code&gt;? The requests are shared almost equally to all servers. There might be slower servers or responses which may enqueue lots of requests. There is the &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#least_conn&#34;&gt;&lt;code&gt;least_conn&lt;/code&gt;&lt;/a&gt; that also considers many connections.&lt;/p&gt; &#xA;&lt;p&gt;What&#39;s not good about it? It&#39;s not caching-aware, meaning multiple clients will face higher latencies because they&#39;re asking uncached servers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# demo time&#xA;git checkout 4.0.0&#xA;docker-compose up&#xA;./load_test.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/4.0.0_metrics.webp&#34; alt=&#34;round-robin grafana&#34; title=&#34;round-robin grafana&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Heads up&lt;/strong&gt;: the load balancer itself here plays a single point of failure role. &lt;a href=&#34;https://www.youtube.com/watch?v=bxhYNfFeVF4&#34;&gt;Facebook has a great talk explaining&lt;/a&gt; how they created a load balancer that is resilient, maintainable, and scalable.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Consistent Hashing&lt;/h4&gt; &#xA;&lt;p&gt;Knowing that caching awareness is important for a CDN, it&#39;s hard to use round-robin as it is. There is a balancing method known as &lt;a href=&#34;https://en.wikipedia.org/wiki/Consistent_hashing&#34;&gt;&lt;code&gt;consistent hashing&lt;/code&gt;&lt;/a&gt; which tries to solve this problem by choosing a signal (the &lt;code&gt;uri&lt;/code&gt; for instance) and mapping it to a hash table, consistently sending all the requests to the same server.&lt;/p&gt; &#xA;&lt;p&gt;There is a directive for that on nginx as well, it&#39;s called &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#hash&#34;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;upstream backend {&#xA;  hash $request_uri consistent;&#xA;  server edge:8080;&#xA;  server edge1:8080;&#xA;  server edge2:8080;&#xA;}&#xA;&#xA;server {&#xA;  listen 8080;&#xA;&#xA;  location / {&#xA;    proxy_pass http://backend;&#xA;    add_header X-Edge LoadBaalancer;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What&#39;s good about &lt;code&gt;consistent hashing&lt;/code&gt;? It enforces a policy that will increase the chances of a cache hit.&lt;/p&gt; &#xA;&lt;p&gt;What&#39;s not good about it? Imagine a single content (video, game) is peaking and now we have a problem of a small number of servers to respond to most of the clients.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Heads up&lt;/strong&gt; &lt;a href=&#34;https://medium.com/vimeo-engineering-blog/improving-load-balancing-with-a-new-consistent-hashing-algorithm-9f1bd75709ed&#34;&gt;Consistent Hashing With Bounded Load&lt;/a&gt; born to solve this problem.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# demo time&#xA;git checkout 4.0.1&#xA;docker-compose up&#xA;./load_test.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/leandromoreira/cdn-up-and-running/main/img/4.0.1_metrics.webp&#34; alt=&#34;consistent hashing grafana&#34; title=&#34;consistent hashing grafana&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Heads up&lt;/strong&gt; Initially I used a lua library because I thought the consistent hashing was only available for comercial nginx.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Load balancer bottleneck&lt;/h4&gt; &#xA;&lt;p&gt;There are at least two problems (beyond it being a &lt;a href=&#34;https://en.wikipedia.org/wiki/Single_point_of_failure&#34;&gt;SPoF&lt;/a&gt;) with a load balancer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Network egress - the input/output bandwidth capacity of the load balancer must be at least sum of all its servers. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;one could use &lt;a href=&#34;https://www.loadbalancer.org/blog/yahoos-l3-direct-server-return-an-alternative-to-lvs-tun-explored/&#34;&gt;DSR&lt;/a&gt; or &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307&#34;&gt;307&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Distributed edges - there might be nodes geographically sparsed that impose a hard time for a load balancer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Network reachability&lt;/h3&gt; &#xA;&lt;p&gt;Many of the problems we saw on the load balancer section are about network reachability. Here we&#39;re going to discuss some of the ways we can tackle that, and each one with their ups and downs.&lt;/p&gt; &#xA;&lt;h4&gt;API&lt;/h4&gt; &#xA;&lt;p&gt;We could introduce an &lt;code&gt;API (cdn routing)&lt;/code&gt;, all clients will only know where to find a content (&lt;code&gt;a specific edge node&lt;/code&gt;) after asking for this API. Clients might need to deal with failover.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Heads up&lt;/strong&gt; solving on the software side, one could mix the best of all worlds: start balacing using &lt;code&gt;consistent hashing&lt;/code&gt; and then when a given content becames popular uses &lt;a href=&#34;https://brooker.co.za/blog/2012/01/17/two-random.html&#34;&gt;a better natural distribution&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;DNS&lt;/h4&gt; &#xA;&lt;p&gt;We could use DNS for that. It looks pretty similar to the API but we&#39;re going to rely on dns caching ttl for that. Failover on this case is even harder.&lt;/p&gt; &#xA;&lt;h4&gt;Anycast&lt;/h4&gt; &#xA;&lt;p&gt;We could also use a single &lt;a href=&#34;https://en.wikipedia.org/wiki/Anycast&#34;&gt;Domain/IP, announcing the IP&lt;/a&gt; in all places we have nodes, leave the &lt;a href=&#34;https://www.youtube.com/watch?v=O6tCoD5c_U0&#34;&gt;network routing protocols&lt;/a&gt; to find the closest node for a given user.&lt;/p&gt; &#xA;&lt;h2&gt;Miscellaneous&lt;/h2&gt; &#xA;&lt;p&gt;We didn&#39;t talk about lots of important aspects of a CDN such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.peeringdb.com/&#34;&gt;Peering&lt;/a&gt; - CDNs will host their nodes/content on ISPs, public peering places and private places.&lt;/li&gt; &#xA; &lt;li&gt;Security - CDNs suffer a lot of attacks, DDoS, &lt;a href=&#34;https://youst.in/posts/cache-poisoning-at-scale/&#34;&gt;caching poisoning&lt;/a&gt;, and others.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://netflixtechblog.com/netflix-and-fill-c43a32b490c0&#34;&gt;Caching strategies&lt;/a&gt; - in some cases, instead of pulling the content from the backend, the backend pushes the content to the edge.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Multitenancy&#34;&gt;Tenants&lt;/a&gt;/Isolation - CDNs will host multiple clients on the same nodes, isolation is a must. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;metrics, caching area, configurations (caching policies, backend), and etc.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Tokens - CDNs offer some form of &lt;a href=&#34;https://en.wikipedia.org/wiki/JSON_Web_Token&#34;&gt;token protection&lt;/a&gt; for content from unauthorized clients.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/1TIzPL4878Q?t=782&#34;&gt;Health check (fault detection)&lt;/a&gt; - stating whether a node is functional or not.&lt;/li&gt; &#xA; &lt;li&gt;HTTP Headers - very often (i.e. &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&#34;&gt;CORS&lt;/a&gt;) a client wants to add some headers (sometimes dynamically)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/leev/ngx_http_geoip2_module#example-usage&#34;&gt;Geoblocking&lt;/a&gt; - to save money or enforce contractual restrictions, your CDN will employ some policy regarding the locality of users.&lt;/li&gt; &#xA; &lt;li&gt;Purging - the ability to &lt;a href=&#34;https://docs.nginx.com/nginx/admin-guide/content-cache/content-caching/#purging-content-from-the-cache&#34;&gt;purge content from the cache&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/leandromoreira/nginx-lua-redis-rate-measuring#use-case-distributed-throttling&#34;&gt;Throttling&lt;/a&gt; - limit the number of concurrent requests.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://leandromoreira.com/2020/04/19/building-an-edge-computing-platform/&#34;&gt;Edge computing&lt;/a&gt; - ability to run code as a filter for the content hosted.&lt;/li&gt; &#xA; &lt;li&gt;and so on...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;I hope you learned a little bit about how a CDN works. It&#39;s a complex endeavor, highly dependent on how close your nodes are to the clients and how well you can distribute the load, taking caching into consideration, to accommodate spikes and low traffics likewise.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>spAnser/pioneer-village</title>
    <updated>2023-01-10T01:40:47Z</updated>
    <id>tag:github.com,2023-01-10:/spAnser/pioneer-village</id>
    <link href="https://github.com/spAnser/pioneer-village" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Pioneer Village&lt;/h1&gt; &#xA;&lt;p&gt;A RedM Framework.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Separated Game and API server.&lt;/li&gt; &#xA; &lt;li&gt;Single UI resource using layers that looks the same at all resolutions. Constrained to 16:9.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spAnser/pioneer-village/master/docs/README.md&#34;&gt;Documentation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.patreon.com/spAnser&#34;&gt;Patreon&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spAnser/pioneer-village/master/LICENSE.txt&#34;&gt;License&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>