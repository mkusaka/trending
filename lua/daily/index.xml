<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-17T01:32:02Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fabridamicelli/cronex.nvim</title>
    <updated>2024-04-17T01:32:02Z</updated>
    <id>tag:github.com,2024-04-17:/fabridamicelli/cronex.nvim</id>
    <link href="https://github.com/fabridamicelli/cronex.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Human-readable inline cron expressions in Neovim&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/fabridamicelli/cronex.nvim/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/fabridamicelli/cronex.nvim/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you find this work useful, don&#39;t forget to give it a GitHub ‚≠ê to help others find and trust it!&lt;/p&gt; &#xA;&lt;h1&gt;cronex.nvim&lt;/h1&gt; &#xA;&lt;p&gt;Human-readable cron expressions in Neovim&lt;/p&gt; &#xA;&lt;h2&gt;What is Cronex&lt;/h2&gt; &#xA;&lt;p&gt;Cronex is a Neovim plugin to render in-line, human-readable explanations of &lt;a href=&#34;https://en.wikipedia.org/wiki/Cron&#34;&gt;cron expressions&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/fabridamicelli/cronex.nvim/main/images/screencast-usage.gif&#34; width=&#34;800&#34;&gt; &#xA;&lt;p&gt;This plugin is &lt;strong&gt;not&lt;/strong&gt; a cron expression parser/checker by itself. Cronex is rather the &#34;client&#34; that allows the Neovim user to integrate and customize &#34;servers&#34; (cron expression &#34;explainers&#34;) in a flexible fashion. There are several implementations of those out there (see below). You can use any of those with Cronex.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;You will need a cron expression explainer installed. The default is &lt;a href=&#34;https://www.npmjs.com/package/cronstrue&#34;&gt;cronstrue&lt;/a&gt;, which is the one used by the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=tumido.cron-explained&#34;&gt;vscode package &lt;code&gt;cron-explained&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/cronstrue&#34;&gt;Install the &lt;code&gt;cronstrue&lt;/code&gt; library&lt;/a&gt; and make sure that the command &lt;code&gt;cronstrue&lt;/code&gt; is available in the environment where your buffer is being shown.&lt;/p&gt; &#xA;&lt;p&gt;That will use the &lt;code&gt;cronstrue&lt;/code&gt; library under the hood to generate the explanations.&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Using &lt;a href=&#34;https://github.com/folke/lazy.nvim&#34;&gt;lazy.nvim&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- init.lua:&#xA;    {&#xA;    &#39;fabridamicelli/cronex.nvim&#39;,&#xA;    opts = {}, &#xA;    }&#xA;&#xA;-- Or&#xA;-- plugins/cronex.lua:&#xA;return {&#xA;    &#39;fabridamicelli/cronex.nvim&#39;,&#xA;    opts = {},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Calling setup makes the explainer available and set explanations when leaving insert mode.&lt;br&gt; Entering insert mode clears the explanations. Cronex can be also disabled/enabled on any file (see Commands).&lt;/p&gt; &#xA;&lt;h3&gt;Commands&lt;/h3&gt; &#xA;&lt;p&gt;The setup will make the following commands available:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CronExplainedDisable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Turn off the explanations permanently&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CronExplainedEnable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Turn on the explanations again (regardless of filetype)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Customization&lt;/h2&gt; &#xA;&lt;h3&gt;Cronex setup structure&lt;/h3&gt; &#xA;&lt;p&gt;The plugin consists of three building blocks:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Module&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;extractor&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Logic to extract cron expressions from current buffer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;explainer&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Program that will parse and explain the cron expressions&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;format&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Postprocess the output string produced by the explainer for final display&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Default configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;cronex&#34;).setup({&#xA;    -- The plugin will automatically start (with autocommand) for these types of files.&#xA;    -- User can manually on any filetype turn explanations on(off) with the commands CronExplainedEnable(CronExplainedDisable)&#xA;    file_patterns = { &#34;*.yaml&#34;, &#34;*.yml&#34;, &#34;*.tf&#34;, &#34;*.cfg&#34;, &#34;*.config&#34;, &#34;*.conf&#34; },&#xA;    extractor = { -- Configuration on how to extract cron expressions goes here:&#xA;        -- cron_from_line: Function to search cron expression in line &#xA;        cron_from_line = require(&#34;cronex.cron_from_line&#34;).cron_from_line,&#xA;        -- extract: Function returning a table with pairs (line_number, cron)&#xA;        extract = require(&#34;cronex.extract&#34;).extract,&#xA;        },&#xA;    explainer = { -- Configuration on how to explain one cron expression goes here&#xA;        -- Command to call an external program that will translate the cron expression&#xA;        -- eg: &#34;* * * * *&#34; -&amp;gt; Every minute&#xA;        -- Any command that is available in your command line can be used here.&#xA;        -- examples:&#xA;        -- &#34;/path/to/miniconda3/envs/neovim/bin/cronstrue&#34; (point to a conda virtualenv)&#xA;        -- &#34;python explainer.py&#34; (assuming you have such a python script available)&#xA;        cmd = &#34;cronstrue&#34;,&#xA;        -- Optional arguments to pass to the command&#xA;        -- eg: &#34;/path/to/a/go/binary&#34;  (assuming you have a go binary)&#xA;        -- args = { &#34;-print-all&#34; }  (assuming the program understands the flag &#39;print-all&#39;)&#xA;        args = {}&#xA;    },&#xA;    -- Configure the post-processing of the explanation string.&#xA;    -- eg: transform &#34;* * * * *&#34;: Every minute --to--&amp;gt; Every minute&#xA;    -- using require(&#34;cronex.format&#34;).all_after_colon,&#xA;    format = function(s)&#xA;        return s&#xA;    end&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Extractor&lt;/h3&gt; &#xA;&lt;p&gt;Logic of the default extractor can be found here in &lt;code&gt;/cronex/cron_from_line.lua&lt;/code&gt;.&lt;br&gt; Default extractor searches for at most 1 expression per line of length 7, 6 or 5 (in that order).&lt;br&gt; But Cronex allows the user to hook in and swap this by any arbitrary logic.&lt;/p&gt; &#xA;&lt;p&gt;The extractor has 2 parts: &lt;code&gt;cron_from_line&lt;/code&gt; and &lt;code&gt;extract&lt;/code&gt;, both are functions.&lt;br&gt; You can swap any or both of the two with custom functions, provided you respect the following interfaces:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cron_from_line&lt;/code&gt;: Function with signature &lt;code&gt;string -&amp;gt; string|nil&lt;/code&gt;. Returns the cron expression if found (else &lt;code&gt;nil&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;extract&lt;/code&gt;: Function with signature &lt;code&gt;function -&amp;gt; table&lt;/code&gt; The input &lt;code&gt;function&lt;/code&gt; processes each buffer line (may be identity, i.e. just return line as is). Output &lt;code&gt;table&lt;/code&gt; of pairs (&lt;code&gt;line_number&lt;/code&gt;, &lt;code&gt;cron_expression&lt;/code&gt;), empty if no cron expressions found.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a toy example on how to customize the functions, that will set &#34;line &amp;lt;LINE_NUMBER&amp;gt; says --&amp;gt; hello world&#34; on every line of the buffer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;cronex&#34;).setup({&#xA;    extractor = {&#xA;        cron_from_line = function(_)&#xA;            -- This commented block is what you would actually do in a real scenario&#xA;            -- local cron = do_something_to_extract_cron(buffer_line)&#xA;            -- if cron then&#xA;            --     return cron&#xA;            -- end&#xA;            -- return nil&#xA;            return &#34;hello world&#34; -- let&#39;s hard-code something :)&#xA;        end,&#xA;        extract = function(cron_from_line)&#xA;            local t = {}&#xA;            for i, line in ipairs(vim.api.nvim_buf_get_lines(0, 0, -1, false)) do&#xA;                t[i - 1] = string.format(&#34;line %s says --&amp;gt; %s &#34;, i - 1, cron_from_line(line))&#xA;            end&#xA;            return t&#xA;        end&#xA;    },&#xA;    explainer = {&#xA;        cmd = &#34;echo&#34; -- just echo the what extract produces&#xA;    },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Under the hood, &lt;code&gt;cron_from_line&lt;/code&gt; will be passed to &lt;code&gt;extract&lt;/code&gt; like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;extract(cron_from_line)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This allows you to plug a custom function to extract cron from line and still use the default &lt;code&gt;extract&lt;/code&gt; function&lt;/p&gt; &#xA;&lt;p&gt;You may even just set &lt;code&gt;cron_from_line&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; and use the &lt;code&gt;extract&lt;/code&gt; function to send the whole buffer to another program from which you capture the output. All that matters is that &lt;code&gt;extract&lt;/code&gt; returns the table with pairs (&lt;code&gt;line_number&lt;/code&gt;, &lt;code&gt;cron_expression&lt;/code&gt;). For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;    require(&#34;cronex&#34;).setup({&#xA;        extractor = {&#xA;            cron_from_line = nil,&#xA;            extract = function(_)&#xA;                local t = {}&#xA;                local out = send_buffer_to_external_program_and_collect_crons()&#xA;                for lnum, cron in out do&#xA;                    t[lnum] = cron&#xA;                end&#xA;                return t&#xA;            end&#xA;        }&#xA;&#xA;    })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Explainer&lt;/h3&gt; &#xA;&lt;p&gt;As already mentioned above, Cronex is the integrates the functionality of external cron expression explainers into Neovim. There are several implementations of those &lt;a href=&#34;&#34;&gt;out there&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;More generally, it&#39;s up to the user which explainer program to use in the background. Cronex will call such program via the command (&lt;code&gt;cmd&lt;/code&gt;), collect the output and pass it along to Neovim.&lt;br&gt; This is the default:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;cronex&#34;).setup({&#xA;    explainer = {&#xA;        cmd = &#34;cronstrue&#34;,&#xA;        args = {}&#xA;    } &#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example, you can have &lt;code&gt;cronstrue&lt;/code&gt; installed in a conda virtualenv. If the virtualenv is active, everything should work out of the box. But you may not want to install &lt;code&gt;cronstrue&lt;/code&gt; in every virtualenv, so you can have only one central environment with &lt;code&gt;cronstrue&lt;/code&gt; installed and point to that binary explicitly in the config:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;    require(&#34;cronex&#34;).setup({&#xA;    explainer = {&#xA;        cmd = &#34;/home/username/miniconda3/envs/neovim/bin/cronstrue&#34;&#xA;    })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In fact &lt;code&gt;cmd&lt;/code&gt; can call anything that knows how to deal with the cron expression. For example, calling a go program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;    require(&#34;cronex&#34;).setup({&#xA;        explainer = {&#xA;            cmd = { &#34;go&#34;, &#34;run&#34;, &#34;/path/to/go/app/cmd/module/main.go&#34; },&#xA;            -- or if you pre-compiled it (recommended):&#xA;            -- cmd = { &#34;/path/to/go/app/cmd/module/binary&#34; },&#xA;            args = { &#34;-arg1&#34;, &#34;-arg2&#34; }&#xA;        }&#xA;    })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here are a few of those third-party libraries as well as the Cronex command to use them:&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;code&gt;cronstrue:&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt; This is the default explainer by Cronex and the very same library used by the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=tumido.cron-explained&#34;&gt;vscode package &lt;code&gt;cron-explained&lt;/code&gt;&lt;/a&gt;. You need first install the &lt;a href=&#34;https://www.npmjs.com/package/cronstrue&#34;&gt;&lt;code&gt;cronstrue&lt;/code&gt; library&lt;/a&gt; and make sure that the command &lt;code&gt;cronstrue&lt;/code&gt; is available in the environment where your buffer is being shown. For example, you can use it inside of a Python virtual environment (in this case managed by conda to install &lt;code&gt;nodejs&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;conda create -n venv&#xA;conda activate venv&#xA;conda install nodejs -c conda-forge&#xA;npm install cronstrue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that &lt;code&gt;cronstrue&lt;/code&gt; will only be installed inside &lt;code&gt;venv&lt;/code&gt; (thus only available there).&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;code&gt;hcron:&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt; This explainer is written in Go and much considerably faster than the default. But it is not as widely used and the project does not seem to be that well maintained. Recommendation: Compile the binary&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a (non-exhaustive) overview cron explainers out there:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Language&lt;/th&gt; &#xA;   &lt;th&gt;Link&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;JavaScript&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/bradymholt/cronstrue&#34;&gt;https://github.com/bradymholt/cronstrue&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Go&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/lnquy/cron&#34;&gt;https://github.com/lnquy/cron&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Python&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Salamek/cron-descriptor&#34;&gt;https://github.com/Salamek/cron-descriptor&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;.NET&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/bradymholt/cron-expression-descriptor&#34;&gt;https://github.com/bradymholt/cron-expression-descriptor&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Java&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/grahamar/cron-parser&#34;&gt;https://github.com/grahamar/cron-parser&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Rust&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/zslayton/cron&#34;&gt;https://github.com/zslayton/cron&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;format&lt;/h3&gt; &#xA;&lt;p&gt;We might want to modify the output from the third-party explainer libraries. For example, some explainers show the input as well in the output like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;* * * * *&#34;: Every minute&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In that case, you could use the function &lt;code&gt;require(&#34;cronex.format&#34;).all_after_colon&lt;/code&gt;) to transform the output to just show &#34;Every minute&#34;.&lt;br&gt; But the user can do any other transformation by defining a lua function, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;    require(&#34;cronex&#34;).setup({&#xA;        format = function(explanation)&#xA;            local colon = string.find(explanation, &#34;: &#34;)&#xA;            if colon then&#xA;                return &#34;Human-readable:&#34; .. string.sub(explanation, colon + 2)&#xA;            end&#xA;            return explanation&#xA;        end&#xA;        })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That will transform it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;* * * * *&#34;: Every minute --&amp;gt; Human-readable: Every minute&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;The current &lt;code&gt;extract&lt;/code&gt; logic is a bit rudimentary (partly because regex in lua are a bit trickier than normal (at least for me). Any improvement along those lines is more than welcome.&lt;/p&gt; &#xA;&lt;p&gt;The call to the explainer is a blocking operation. While testing I found that to be a problem only if there are unrealistically many cron expressions in the buffer.&lt;br&gt; Also, the Go implementation of the explainer is so fast that even having hundreds of expressions in a buffer everything runs decently fast.&lt;br&gt; In short, my guess is that almost no user (if any at all) will notice this. Having said that, a few potential ideas to improve performance:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Accelerating extraction, for example, by using &lt;code&gt;ripgrep&lt;/code&gt; to extract all crons in one shot (instead of iterating over lines)&lt;/li&gt; &#xA; &lt;li&gt;Implementing the explainer in pure lua to avoid external calls&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Default behaviour considers only 1 cron expression is per line. So having repeated expressions in one line will result in no explanation at all. I haven&#39;t seen use-cases where it makes sense to have more than one, but I&#39;d be open to consider it if that makes sense.&lt;/li&gt; &#xA; &lt;li&gt;If encountering problems with an expression, disable the format in order to see the exact output coming from the explainer&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>