<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-07T01:45:21Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>onsails/lspkind.nvim</title>
    <updated>2022-08-07T01:45:21Z</updated>
    <id>tag:github.com,2022-08-07:/onsails/lspkind.nvim</id>
    <link href="https://github.com/onsails/lspkind.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;vscode-like pictograms for neovim lsp completion items&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;lspkind-nvim&lt;/h1&gt; &#xA;&lt;p&gt;This tiny plugin adds vscode-like pictograms to neovim built-in lsp:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/onsails/lspkind-nvim/raw/images/images/screenshot.png&#34; alt=&#34;Screenshot&#34; title=&#34;Screenshot&#34;&gt; &lt;sup&gt;&lt;a href=&#34;https://github.com/hrsh7th/nvim-compe&#34;&gt;nvim-compe&lt;/a&gt;, &lt;a href=&#34;https://github.com/hrsh7th/vim-vsnip&#34;&gt;vim-vsnip&lt;/a&gt;, &lt;a href=&#34;https://github.com/hrsh7th/vim-vsnip-integ&#34;&gt;vim-vsnip-integ&lt;/a&gt;, &lt;a href=&#34;https://github.com/metalelf0/jellybeans-nvim&#34;&gt;jellybeans-nvim&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h3&gt;Option 1: vanilla Neovim LSP&lt;/h3&gt; &#xA;&lt;p&gt;Wherever you configure lsp put the following lua command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;lspkind&#39;).init({&#xA;    -- DEPRECATED (use mode instead): enables text annotations&#xA;    --&#xA;    -- default: true&#xA;    -- with_text = true,&#xA;&#xA;    -- defines how annotations are shown&#xA;    -- default: symbol&#xA;    -- options: &#39;text&#39;, &#39;text_symbol&#39;, &#39;symbol_text&#39;, &#39;symbol&#39;&#xA;    mode = &#39;symbol_text&#39;,&#xA;&#xA;    -- default symbol map&#xA;    -- can be either &#39;default&#39; (requires nerd-fonts font) or&#xA;    -- &#39;codicons&#39; for codicon preset (requires vscode-codicons font)&#xA;    --&#xA;    -- default: &#39;default&#39;&#xA;    preset = &#39;codicons&#39;,&#xA;&#xA;    -- override preset symbols&#xA;    --&#xA;    -- default: {}&#xA;    symbol_map = {&#xA;      Text = &#34;Ôùæ&#34;,&#xA;      Method = &#34;Ôö¶&#34;,&#xA;      Function = &#34;Ôûî&#34;,&#xA;      Constructor = &#34;Ôê£&#34;,&#xA;      Field = &#34;Ô∞†&#34;,&#xA;      Variable = &#34;Ôî™&#34;,&#xA;      Class = &#34;Ô¥Ø&#34;,&#xA;      Interface = &#34;ÔÉ®&#34;,&#xA;      Module = &#34;Ôíá&#34;,&#xA;      Property = &#34;Ô∞†&#34;,&#xA;      Unit = &#34;Ô•¨&#34;,&#xA;      Value = &#34;Ô¢ü&#34;,&#xA;      Enum = &#34;ÔÖù&#34;,&#xA;      Keyword = &#34;Ô†ä&#34;,&#xA;      Snippet = &#34;Ôëè&#34;,&#xA;      Color = &#34;Ô£ó&#34;,&#xA;      File = &#34;Ôúò&#34;,&#xA;      Reference = &#34;ÔúÜ&#34;,&#xA;      Folder = &#34;Ôùä&#34;,&#xA;      EnumMember = &#34;ÔÖù&#34;,&#xA;      Constant = &#34;Ô£æ&#34;,&#xA;      Struct = &#34;Ô≠Ñ&#34;,&#xA;      Event = &#34;ÔÉß&#34;,&#xA;      Operator = &#34;Ôöî&#34;,&#xA;      TypeParameter = &#34;&#34;&#xA;    },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Option 2: &lt;a href=&#34;https://github.com/hrsh7th/nvim-cmp&#34;&gt;nvim-cmp&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local lspkind = require(&#39;lspkind&#39;)&#xA;cmp.setup {&#xA;  formatting = {&#xA;    format = lspkind.cmp_format({&#xA;      mode = &#39;symbol&#39;, -- show only symbol annotations&#xA;      maxwidth = 50, -- prevent the popup from showing more than provided characters (e.g 50 will not show more than 50 characters)&#xA;&#xA;      -- The function below will be called before any actual modifications from lspkind&#xA;      -- so that you can provide more controls on popup customization. (See [#30](https://github.com/onsails/lspkind-nvim/pull/30))&#xA;      before = function (entry, vim_item)&#xA;        ...&#xA;        return vim_item&#xA;      end&#xA;    })&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Related LSP plugins&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/onsails/diaglist.nvim&#34;&gt;diaglist.nvim&lt;/a&gt; ‚Äì live render workspace diagnostics in quickfix with current buf errors on top, buffer diagnostics in loclist&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>qbcore-framework/qb-vehiclekeys</title>
    <updated>2022-08-07T01:45:21Z</updated>
    <id>tag:github.com,2022-08-07:/qbcore-framework/qb-vehiclekeys</id>
    <link href="https://github.com/qbcore-framework/qb-vehiclekeys" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Vehicle Keys System For QB-Core üîë&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;qb-vehiclekeys&lt;/h1&gt; &#xA;&lt;p&gt;Vehicle Keys System For QB-Core&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;QBCore Framework&#xA;Copyright (C) 2021 Joshua Eger&#xA;&#xA;This program is free software: you can redistribute it and/or modify&#xA;it under the terms of the GNU General Public License as published by&#xA;the Free Software Foundation, either version 3 of the License, or&#xA;(at your option) any later version.&#xA;&#xA;This program is distributed in the hope that it will be useful,&#xA;but WITHOUT ANY WARRANTY; without even the implied warranty of&#xA;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#xA;GNU General Public License for more details.&#xA;&#xA;You should have received a copy of the GNU General Public License&#xA;along with this program.  If not, see &amp;lt;https://www.gnu.org/licenses/&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>openresty/lua-resty-redis</title>
    <updated>2022-08-07T01:45:21Z</updated>
    <id>tag:github.com,2022-08-07:/openresty/lua-resty-redis</id>
    <link href="https://github.com/openresty/lua-resty-redis" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lua redis client driver for the ngx_lua based on the cosocket API&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Name&lt;/h1&gt; &#xA;&lt;p&gt;lua-resty-redis - Lua redis client driver for the ngx_lua based on the cosocket API&lt;/p&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#name&#34;&gt;Name&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#status&#34;&gt;Status&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#description&#34;&gt;Description&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#methods&#34;&gt;Methods&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#new&#34;&gt;new&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#connect&#34;&gt;connect&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#set_timeout&#34;&gt;set_timeout&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#set_timeouts&#34;&gt;set_timeouts&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#set_keepalive&#34;&gt;set_keepalive&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#get_reused_times&#34;&gt;get_reused_times&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#close&#34;&gt;close&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#init_pipeline&#34;&gt;init_pipeline&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#commit_pipeline&#34;&gt;commit_pipeline&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#cancel_pipeline&#34;&gt;cancel_pipeline&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#hmset&#34;&gt;hmset&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#array_to_hash&#34;&gt;array_to_hash&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#read_reply&#34;&gt;read_reply&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#add_commands&#34;&gt;add_commands&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#redis-authentication&#34;&gt;Redis Authentication&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#redis-transactions&#34;&gt;Redis Transactions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#load-balancing-and-failover&#34;&gt;Load Balancing and Failover&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#debugging&#34;&gt;Debugging&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#automatic-error-logging&#34;&gt;Automatic Error Logging&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#check-list-for-issues&#34;&gt;Check List for Issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#todo&#34;&gt;TODO&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#community&#34;&gt;Community&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#english-mailing-list&#34;&gt;English Mailing List&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#chinese-mailing-list&#34;&gt;Chinese Mailing List&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#bugs-and-patches&#34;&gt;Bugs and Patches&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#author&#34;&gt;Author&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#copyright-and-license&#34;&gt;Copyright and License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#see-also&#34;&gt;See Also&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Status&lt;/h1&gt; &#xA;&lt;p&gt;This library is considered production ready.&lt;/p&gt; &#xA;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;This Lua library is a Redis client driver for the ngx_lua nginx module:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/openresty/lua-nginx-module/#readme&#34;&gt;https://github.com/openresty/lua-nginx-module/#readme&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This Lua library takes advantage of ngx_lua&#39;s cosocket API, which ensures 100% nonblocking behavior.&lt;/p&gt; &#xA;&lt;p&gt;Note that at least &lt;a href=&#34;https://github.com/chaoslawful/lua-nginx-module/tags&#34;&gt;ngx_lua 0.5.14&lt;/a&gt; or &lt;a href=&#34;http://openresty.org/#Download&#34;&gt;OpenResty 1.2.1.14&lt;/a&gt; is required.&lt;/p&gt; &#xA;&lt;h1&gt;Synopsis&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    # you do not need the following line if you are using&#xA;    # the OpenResty bundle:&#xA;    lua_package_path &#34;/path/to/lua-resty-redis/lib/?.lua;;&#34;;&#xA;&#xA;    server {&#xA;        location /test {&#xA;            -- need to specify the resolver to resolve the hostname&#xA;            resolver 8.8.8.8;&#xA;&#xA;            content_by_lua_block {&#xA;                local redis = require &#34;resty.redis&#34;&#xA;                local red = redis:new()&#xA;&#xA;                red:set_timeouts(1000, 1000, 1000) -- 1 sec&#xA;&#xA;                -- or connect to a unix domain socket file listened&#xA;                -- by a redis server:&#xA;                --     local ok, err = red:connect(&#34;unix:/path/to/redis.sock&#34;)&#xA;&#xA;                -- connect via ip address directly&#xA;                local ok, err = red:connect(&#34;127.0.0.1&#34;, 6379)&#xA;&#xA;                -- or connect via hostname, need to specify resolver just like above&#xA;                local ok, err = red:connect(&#34;redis.openresty.com&#34;, 6379)&#xA;&#xA;                if not ok then&#xA;                    ngx.say(&#34;failed to connect: &#34;, err)&#xA;                    return&#xA;                end&#xA;&#xA;                ok, err = red:set(&#34;dog&#34;, &#34;an animal&#34;)&#xA;                if not ok then&#xA;                    ngx.say(&#34;failed to set dog: &#34;, err)&#xA;                    return&#xA;                end&#xA;&#xA;                ngx.say(&#34;set result: &#34;, ok)&#xA;&#xA;                local res, err = red:get(&#34;dog&#34;)&#xA;                if not res then&#xA;                    ngx.say(&#34;failed to get dog: &#34;, err)&#xA;                    return&#xA;                end&#xA;&#xA;                if res == ngx.null then&#xA;                    ngx.say(&#34;dog not found.&#34;)&#xA;                    return&#xA;                end&#xA;&#xA;                ngx.say(&#34;dog: &#34;, res)&#xA;&#xA;                red:init_pipeline()&#xA;                red:set(&#34;cat&#34;, &#34;Marry&#34;)&#xA;                red:set(&#34;horse&#34;, &#34;Bob&#34;)&#xA;                red:get(&#34;cat&#34;)&#xA;                red:get(&#34;horse&#34;)&#xA;                local results, err = red:commit_pipeline()&#xA;                if not results then&#xA;                    ngx.say(&#34;failed to commit the pipelined requests: &#34;, err)&#xA;                    return&#xA;                end&#xA;&#xA;                for i, res in ipairs(results) do&#xA;                    if type(res) == &#34;table&#34; then&#xA;                        if res[1] == false then&#xA;                            ngx.say(&#34;failed to run command &#34;, i, &#34;: &#34;, res[2])&#xA;                        else&#xA;                            -- process the table value&#xA;                        end&#xA;                    else&#xA;                        -- process the scalar value&#xA;                    end&#xA;                end&#xA;&#xA;                -- put it into the connection pool of size 100,&#xA;                -- with 10 seconds max idle time&#xA;                local ok, err = red:set_keepalive(10000, 100)&#xA;                if not ok then&#xA;                    ngx.say(&#34;failed to set keepalive: &#34;, err)&#xA;                    return&#xA;                end&#xA;&#xA;                -- or just close the connection right away:&#xA;                -- local ok, err = red:close()&#xA;                -- if not ok then&#xA;                --     ngx.say(&#34;failed to close: &#34;, err)&#xA;                --     return&#xA;                -- end&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Methods&lt;/h1&gt; &#xA;&lt;p&gt;All of the Redis commands have their own methods with the same name except all in lower case.&lt;/p&gt; &#xA;&lt;p&gt;You can find the complete list of Redis commands here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://redis.io/commands&#34;&gt;http://redis.io/commands&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;You need to check out this Redis command reference to see what Redis command accepts what arguments.&lt;/p&gt; &#xA;&lt;p&gt;The Redis command arguments can be directly fed into the corresponding method call. For example, the &#34;GET&#34; redis command accepts a single key argument, then you can just call the &#34;get&#34; method like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    local res, err = red:get(&#34;key&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, the &#34;LRANGE&#34; redis command accepts threee arguments, then you should call the &#34;lrange&#34; method like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    local res, err = red:lrange(&#34;nokey&#34;, 0, 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example, &#34;SET&#34;, &#34;GET&#34;, &#34;LRANGE&#34;, and &#34;BLPOP&#34; commands correspond to the methods &#34;set&#34;, &#34;get&#34;, &#34;lrange&#34;, and &#34;blpop&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Here are some more examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    -- HMGET myhash field1 field2 nofield&#xA;    local res, err = red:hmget(&#34;myhash&#34;, &#34;field1&#34;, &#34;field2&#34;, &#34;nofield&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    -- HMSET myhash field1 &#34;Hello&#34; field2 &#34;World&#34;&#xA;    local res, err = red:hmset(&#34;myhash&#34;, &#34;field1&#34;, &#34;Hello&#34;, &#34;field2&#34;, &#34;World&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All these command methods returns a single result in success and &lt;code&gt;nil&lt;/code&gt; otherwise. In case of errors or failures, it will also return a second value which is a string describing the error.&lt;/p&gt; &#xA;&lt;p&gt;A Redis &#34;status reply&#34; results in a string typed return value with the &#34;+&#34; prefix stripped.&lt;/p&gt; &#xA;&lt;p&gt;A Redis &#34;integer reply&#34; results in a Lua number typed return value.&lt;/p&gt; &#xA;&lt;p&gt;A Redis &#34;error reply&#34; results in a &lt;code&gt;false&lt;/code&gt; value &lt;em&gt;and&lt;/em&gt; a string describing the error.&lt;/p&gt; &#xA;&lt;p&gt;A non-nil Redis &#34;bulk reply&#34; results in a Lua string as the return value. A nil bulk reply results in a &lt;code&gt;ngx.null&lt;/code&gt; return value.&lt;/p&gt; &#xA;&lt;p&gt;A non-nil Redis &#34;multi-bulk reply&#34; results in a Lua table holding all the composing values (if any). If any of the composing value is a valid redis error value, then it will be a two element table &lt;code&gt;{false, err}&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A nil multi-bulk reply returns in a &lt;code&gt;ngx.null&lt;/code&gt; value.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://redis.io/topics/protocol&#34;&gt;http://redis.io/topics/protocol&lt;/a&gt; for details regarding various Redis reply types.&lt;/p&gt; &#xA;&lt;p&gt;In addition to all those redis command methods, the following methods are also provided:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;new&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: red, err = redis:new()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Creates a redis object. In case of failures, returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;connect&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: ok, err = red:connect(host, port, options_table?)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: ok, err = red:connect(&#34;unix:/path/to/unix.sock&#34;, options_table?)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Attempts to connect to the remote host and port that the redis server is listening to or a local unix domain socket file listened by the redis server.&lt;/p&gt; &#xA;&lt;p&gt;Before actually resolving the host name and connecting to the remote backend, this method will always look up the connection pool for matched idle connections created by previous calls of this method.&lt;/p&gt; &#xA;&lt;p&gt;The optional &lt;code&gt;options_table&lt;/code&gt; argument is a Lua table holding the following keys:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/p&gt; &lt;p&gt;If set to true, then uses SSL to connect to redis (defaults to false).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ssl_verify&lt;/code&gt;&lt;/p&gt; &lt;p&gt;If set to true, then verifies the validity of the server SSL certificate (defaults to false). Note that you need to configure the lua_ssl_trusted_certificate to specify the CA (or server) certificate used by your redis server. You may also need to configure lua_ssl_verify_depth accordingly.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;server_name&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Specifies the server name for the new TLS extension Server Name Indication (SNI) when connecting over SSL.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;pool&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Specifies a custom name for the connection pool being used. If omitted, then the connection pool name will be generated from the string template &lt;code&gt;&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;unix-socket-path&amp;gt;&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;pool_size&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Specifies the size of the connection pool. If omitted and no &lt;code&gt;backlog&lt;/code&gt; option was provided, no pool will be created. If omitted but &lt;code&gt;backlog&lt;/code&gt; was provided, the pool will be created with a default size equal to the value of the &lt;a href=&#34;https://github.com/openresty/lua-nginx-module#lua_socket_pool_size&#34;&gt;lua_socket_pool_size&lt;/a&gt; directive. The connection pool holds up to &lt;code&gt;pool_size&lt;/code&gt; alive connections ready to be reused by subsequent calls to &lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#connect&#34;&gt;connect&lt;/a&gt;, but note that there is no upper limit to the total number of opened connections outside of the pool. If you need to restrict the total number of opened connections, specify the &lt;code&gt;backlog&lt;/code&gt; option. When the connection pool would exceed its size limit, the least recently used (kept-alive) connection already in the pool will be closed to make room for the current connection. Note that the cosocket connection pool is per Nginx worker process rather than per Nginx server instance, so the size limit specified here also applies to every single Nginx worker process. Also note that the size of the connection pool cannot be changed once it has been created. Note that at least &lt;a href=&#34;https://github.com/openresty/lua-nginx-module/tags&#34;&gt;ngx_lua 0.10.14&lt;/a&gt; is required to use this options.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;backlog&lt;/code&gt;&lt;/p&gt; &lt;p&gt;If specified, this module will limit the total number of opened connections for this pool. No more connections than &lt;code&gt;pool_size&lt;/code&gt; can be opened for this pool at any time. If the connection pool is full, subsequent connect operations will be queued into a queue equal to this option&#39;s value (the &#34;backlog&#34; queue). If the number of queued connect operations is equal to &lt;code&gt;backlog&lt;/code&gt;, subsequent connect operations will fail and return nil plus the error string &lt;code&gt;&#34;too many waiting connect operations&#34;&lt;/code&gt;. The queued connect operations will be resumed once the number of connections in the pool is less than &lt;code&gt;pool_size&lt;/code&gt;. The queued connect operation will abort once they have been queued for more than &lt;code&gt;connect_timeout&lt;/code&gt;, controlled by &lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#set_timeout&#34;&gt;set_timeout&lt;/a&gt;, and will return nil plus the error string &#34;timeout&#34;. Note that at least &lt;a href=&#34;https://github.com/openresty/lua-nginx-module/tags&#34;&gt;ngx_lua 0.10.14&lt;/a&gt; is required to use this options.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;set_timeout&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: red:set_timeout(time)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Sets the timeout (in ms) protection for subsequent operations, including the &lt;code&gt;connect&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;Since version &lt;code&gt;v0.28&lt;/code&gt; of this module, it is advised that &lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#set_timeouts&#34;&gt;set_timeouts&lt;/a&gt; be used in favor of this method.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;set_timeouts&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: red:set_timeouts(connect_timeout, send_timeout, read_timeout)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Respectively sets the connect, send, and read timeout thresholds (in ms), for subsequent socket operations. Setting timeout thresholds with this method offers more granularity than &lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#set_timeout&#34;&gt;set_timeout&lt;/a&gt;. As such, it is preferred to use &lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#set_timeouts&#34;&gt;set_timeouts&lt;/a&gt; over &lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#set_timeout&#34;&gt;set_timeout&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This method was added in the &lt;code&gt;v0.28&lt;/code&gt; release.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;set_keepalive&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: ok, err = red:set_keepalive(max_idle_timeout, pool_size)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Puts the current Redis connection immediately into the ngx_lua cosocket connection pool.&lt;/p&gt; &#xA;&lt;p&gt;You can specify the max idle timeout (in ms) when the connection is in the pool and the maximal size of the pool every nginx worker process.&lt;/p&gt; &#xA;&lt;p&gt;In case of success, returns &lt;code&gt;1&lt;/code&gt;. In case of errors, returns &lt;code&gt;nil&lt;/code&gt; with a string describing the error.&lt;/p&gt; &#xA;&lt;p&gt;Only call this method in the place you would have called the &lt;code&gt;close&lt;/code&gt; method instead. Calling this method will immediately turn the current redis object into the &lt;code&gt;closed&lt;/code&gt; state. Any subsequent operations other than &lt;code&gt;connect()&lt;/code&gt; on the current object will return the &lt;code&gt;closed&lt;/code&gt; error.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;get_reused_times&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: times, err = red:get_reused_times()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This method returns the (successfully) reused times for the current connection. In case of error, it returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error.&lt;/p&gt; &#xA;&lt;p&gt;If the current connection does not come from the built-in connection pool, then this method always returns &lt;code&gt;0&lt;/code&gt;, that is, the connection has never been reused (yet). If the connection comes from the connection pool, then the return value is always non-zero. So this method can also be used to determine if the current connection comes from the pool.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;close&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: ok, err = red:close()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Closes the current redis connection and returns the status.&lt;/p&gt; &#xA;&lt;p&gt;In case of success, returns &lt;code&gt;1&lt;/code&gt;. In case of errors, returns &lt;code&gt;nil&lt;/code&gt; with a string describing the error.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;init_pipeline&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: red:init_pipeline()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: red:init_pipeline(n)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Enable the redis pipelining mode. All subsequent calls to Redis command methods will automatically get cached and will send to the server in one run when the &lt;code&gt;commit_pipeline&lt;/code&gt; method is called or get cancelled by calling the &lt;code&gt;cancel_pipeline&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;This method always succeeds.&lt;/p&gt; &#xA;&lt;p&gt;If the redis object is already in the Redis pipelining mode, then calling this method will discard existing cached Redis queries.&lt;/p&gt; &#xA;&lt;p&gt;The optional &lt;code&gt;n&lt;/code&gt; argument specifies the (approximate) number of commands that are going to add to this pipeline, which can make things a little faster.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;commit_pipeline&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: results, err = red:commit_pipeline()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Quits the pipelining mode by committing all the cached Redis queries to the remote server in a single run. All the replies for these queries will be collected automatically and are returned as if a big multi-bulk reply at the highest level.&lt;/p&gt; &#xA;&lt;p&gt;This method returns &lt;code&gt;nil&lt;/code&gt; and a Lua string describing the error upon failures.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;cancel_pipeline&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: red:cancel_pipeline()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Quits the pipelining mode by discarding all existing cached Redis commands since the last call to the &lt;code&gt;init_pipeline&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;This method always succeeds.&lt;/p&gt; &#xA;&lt;p&gt;If the redis object is not in the Redis pipelining mode, then this method is a no-op.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;hmset&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: res, err = red:hmset(myhash, field1, value1, field2, value2, ...)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: res, err = red:hmset(myhash, { field1 = value1, field2 = value2, ... })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Special wrapper for the Redis &#34;hmset&#34; command.&lt;/p&gt; &#xA;&lt;p&gt;When there are only three arguments (including the &#34;red&#34; object itself), then the last argument must be a Lua table holding all the field/value pairs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;array_to_hash&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: hash = red:array_to_hash(array)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Auxiliary function that converts an array-like Lua table into a hash-like table.&lt;/p&gt; &#xA;&lt;p&gt;This method was first introduced in the &lt;code&gt;v0.11&lt;/code&gt; release.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;read_reply&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: res, err = red:read_reply()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Reading a reply from the redis server. This method is mostly useful for the &lt;a href=&#34;http://redis.io/topics/pubsub/&#34;&gt;Redis Pub/Sub API&lt;/a&gt;, for example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    local cjson = require &#34;cjson&#34;&#xA;    local redis = require &#34;resty.redis&#34;&#xA;&#xA;    local red = redis:new()&#xA;    local red2 = redis:new()&#xA;&#xA;    red:set_timeouts(1000, 1000, 1000) -- 1 sec&#xA;    red2:set_timeouts(1000, 1000, 1000) -- 1 sec&#xA;&#xA;    local ok, err = red:connect(&#34;127.0.0.1&#34;, 6379)&#xA;    if not ok then&#xA;        ngx.say(&#34;1: failed to connect: &#34;, err)&#xA;        return&#xA;    end&#xA;&#xA;    ok, err = red2:connect(&#34;127.0.0.1&#34;, 6379)&#xA;    if not ok then&#xA;        ngx.say(&#34;2: failed to connect: &#34;, err)&#xA;        return&#xA;    end&#xA;&#xA;    local res, err = red:subscribe(&#34;dog&#34;)&#xA;    if not res then&#xA;        ngx.say(&#34;1: failed to subscribe: &#34;, err)&#xA;        return&#xA;    end&#xA;&#xA;    ngx.say(&#34;1: subscribe: &#34;, cjson.encode(res))&#xA;&#xA;    res, err = red2:publish(&#34;dog&#34;, &#34;Hello&#34;)&#xA;    if not res then&#xA;        ngx.say(&#34;2: failed to publish: &#34;, err)&#xA;        return&#xA;    end&#xA;&#xA;    ngx.say(&#34;2: publish: &#34;, cjson.encode(res))&#xA;&#xA;    res, err = red:read_reply()&#xA;    if not res then&#xA;        ngx.say(&#34;1: failed to read reply: &#34;, err)&#xA;        return&#xA;    end&#xA;&#xA;    ngx.say(&#34;1: receive: &#34;, cjson.encode(res))&#xA;&#xA;    red:close()&#xA;    red2:close()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running this example gives the output like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1: subscribe: [&#34;subscribe&#34;,&#34;dog&#34;,1]&#xA;2: publish: 1&#xA;1: receive: [&#34;message&#34;,&#34;dog&#34;,&#34;Hello&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following class methods are provieded:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;add_commands&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;syntax: hash = redis.add_commands(cmd_name1, cmd_name2, ...)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;WARNING&lt;/em&gt; this method is now deprecated since we already do automatic Lua method generation for any redis commands the user attempts to use and thus we no longer need this.&lt;/p&gt; &#xA;&lt;p&gt;Adds new redis commands to the &lt;code&gt;resty.redis&lt;/code&gt; class. Here is an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    local redis = require &#34;resty.redis&#34;&#xA;&#xA;    redis.add_commands(&#34;foo&#34;, &#34;bar&#34;)&#xA;&#xA;    local red = redis:new()&#xA;&#xA;    red:set_timeouts(1000, 1000, 1000) -- 1 sec&#xA;&#xA;    local ok, err = red:connect(&#34;127.0.0.1&#34;, 6379)&#xA;    if not ok then&#xA;        ngx.say(&#34;failed to connect: &#34;, err)&#xA;        return&#xA;    end&#xA;&#xA;    local res, err = red:foo(&#34;a&#34;)&#xA;    if not res then&#xA;        ngx.say(&#34;failed to foo: &#34;, err)&#xA;    end&#xA;&#xA;    res, err = red:bar()&#xA;    if not res then&#xA;        ngx.say(&#34;failed to bar: &#34;, err)&#xA;    end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Redis Authentication&lt;/h1&gt; &#xA;&lt;p&gt;Redis uses the &lt;code&gt;AUTH&lt;/code&gt; command to do authentication: &lt;a href=&#34;http://redis.io/commands/auth&#34;&gt;http://redis.io/commands/auth&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;There is nothing special for this command as compared to other Redis commands like &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt;. So one can just invoke the &lt;code&gt;auth&lt;/code&gt; method on your &lt;code&gt;resty.redis&lt;/code&gt; instance. Here is an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    local redis = require &#34;resty.redis&#34;&#xA;    local red = redis:new()&#xA;&#xA;    red:set_timeouts(1000, 1000, 1000) -- 1 sec&#xA;&#xA;    local ok, err = red:connect(&#34;127.0.0.1&#34;, 6379)&#xA;    if not ok then&#xA;        ngx.say(&#34;failed to connect: &#34;, err)&#xA;        return&#xA;    end&#xA;&#xA;    local res, err = red:auth(&#34;foobared&#34;)&#xA;    if not res then&#xA;        ngx.say(&#34;failed to authenticate: &#34;, err)&#xA;        return&#xA;    end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where we assume that the Redis server is configured with the password &lt;code&gt;foobared&lt;/code&gt; in the &lt;code&gt;redis.conf&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;requirepass foobared&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the password specified is wrong, then the sample above will output the following to the HTTP client:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;failed to authenticate: ERR invalid password&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Redis Transactions&lt;/h1&gt; &#xA;&lt;p&gt;This library supports the &lt;a href=&#34;http://redis.io/topics/transactions/&#34;&gt;Redis transactions&lt;/a&gt;. Here is an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    local cjson = require &#34;cjson&#34;&#xA;    local redis = require &#34;resty.redis&#34;&#xA;    local red = redis:new()&#xA;&#xA;    red:set_timeouts(1000, 1000, 1000) -- 1 sec&#xA;&#xA;    local ok, err = red:connect(&#34;127.0.0.1&#34;, 6379)&#xA;    if not ok then&#xA;        ngx.say(&#34;failed to connect: &#34;, err)&#xA;        return&#xA;    end&#xA;&#xA;    local ok, err = red:multi()&#xA;    if not ok then&#xA;        ngx.say(&#34;failed to run multi: &#34;, err)&#xA;        return&#xA;    end&#xA;    ngx.say(&#34;multi ans: &#34;, cjson.encode(ok))&#xA;&#xA;    local ans, err = red:set(&#34;a&#34;, &#34;abc&#34;)&#xA;    if not ans then&#xA;        ngx.say(&#34;failed to run sort: &#34;, err)&#xA;        return&#xA;    end&#xA;    ngx.say(&#34;set ans: &#34;, cjson.encode(ans))&#xA;&#xA;    local ans, err = red:lpop(&#34;a&#34;)&#xA;    if not ans then&#xA;        ngx.say(&#34;failed to run sort: &#34;, err)&#xA;        return&#xA;    end&#xA;    ngx.say(&#34;set ans: &#34;, cjson.encode(ans))&#xA;&#xA;    ans, err = red:exec()&#xA;    ngx.say(&#34;exec ans: &#34;, cjson.encode(ans))&#xA;&#xA;    red:close()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then the output will be&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;multi ans: &#34;OK&#34;&#xA;set ans: &#34;QUEUED&#34;&#xA;set ans: &#34;QUEUED&#34;&#xA;exec ans: [&#34;OK&#34;,[false,&#34;ERR Operation against a key holding the wrong kind of value&#34;]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Redis Module&lt;/h1&gt; &#xA;&lt;p&gt;This library supports the Redis module. Here is an example with RedisBloom module:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    local cjson = require &#34;cjson&#34;&#xA;    local redis = require &#34;resty.redis&#34;&#xA;    -- register the module prefix &#34;bf&#34; for RedisBloom&#xA;    redis.register_module_prefix(&#34;bf&#34;)&#xA;&#xA;    local red = redis:new()&#xA;&#xA;    local ok, err = red:connect(&#34;127.0.0.1&#34;, 6379)&#xA;    if not ok then&#xA;        ngx.say(&#34;failed to connect: &#34;, err)&#xA;        return&#xA;    end&#xA;&#xA;    -- call BF.ADD command with the prefix &#39;bf&#39;&#xA;    res, err = red:bf():add(&#34;dog&#34;, 1)&#xA;    if not res then&#xA;        ngx.say(err)&#xA;        return&#xA;    end&#xA;    ngx.say(&#34;receive: &#34;, cjson.encode(res))&#xA;&#xA;    -- call BF.EXISTS command&#xA;    res, err = red:bf():exists(&#34;dog&#34;)&#xA;    if not res then&#xA;        ngx.say(err)&#xA;        return&#xA;    end&#xA;    ngx.say(&#34;receive: &#34;, cjson.encode(res))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Load Balancing and Failover&lt;/h1&gt; &#xA;&lt;p&gt;You can trivially implement your own Redis load balancing logic yourself in Lua. Just keep a Lua table of all available Redis backend information (like host name and port numbers) and pick one server according to some rule (like round-robin or key-based hashing) from the Lua table at every request. You can keep track of the current rule state in your own Lua module&#39;s data, see &lt;a href=&#34;https://github.com/openresty/lua-nginx-module/#data-sharing-within-an-nginx-worker&#34;&gt;https://github.com/openresty/lua-nginx-module/#data-sharing-within-an-nginx-worker&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Similarly, you can implement automatic failover logic in Lua at great flexibility.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Debugging&lt;/h1&gt; &#xA;&lt;p&gt;It is usually convenient to use the &lt;a href=&#34;http://www.kyne.com.au/~mark/software/lua-cjson.php&#34;&gt;lua-cjson&lt;/a&gt; library to encode the return values of the redis command methods to JSON. For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    local cjson = require &#34;cjson&#34;&#xA;    ...&#xA;    local res, err = red:mget(&#34;h1234&#34;, &#34;h5678&#34;)&#xA;    if res then&#xA;        print(&#34;res: &#34;, cjson.encode(res))&#xA;    end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Automatic Error Logging&lt;/h1&gt; &#xA;&lt;p&gt;By default the underlying &lt;a href=&#34;https://github.com/openresty/lua-nginx-module/#readme&#34;&gt;ngx_lua&lt;/a&gt; module does error logging when socket errors happen. If you are already doing proper error handling in your own Lua code, then you are recommended to disable this automatic error logging by turning off &lt;a href=&#34;https://github.com/openresty/lua-nginx-module/#readme&#34;&gt;ngx_lua&lt;/a&gt;&#39;s &lt;a href=&#34;https://github.com/openresty/lua-nginx-module/#lua_socket_log_errors&#34;&gt;lua_socket_log_errors&lt;/a&gt; directive, that is,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;    lua_socket_log_errors off;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Check List for Issues&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Ensure you configure the connection pool size properly in the &lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#set_keepalive&#34;&gt;set_keepalive&lt;/a&gt;. Basically if your Redis can handle &lt;code&gt;n&lt;/code&gt; concurrent connections and your NGINX has &lt;code&gt;m&lt;/code&gt; workers, then the connection pool size should be configured as &lt;code&gt;n/m&lt;/code&gt;. For example, if your Redis usually handles 1000 concurrent requests and you have 10 NGINX workers, then the connection pool size should be 100. Similarly if you have &lt;code&gt;p&lt;/code&gt; different NGINX instances, then connection pool size should be &lt;code&gt;n/m/p&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Ensure the backlog setting on the Redis side is large enough. For Redis 2.8+, you can directly tune the &lt;code&gt;tcp-backlog&lt;/code&gt; parameter in the &lt;code&gt;redis.conf&lt;/code&gt; file (and also tune the kernel parameter &lt;code&gt;SOMAXCONN&lt;/code&gt; accordingly at least on Linux). You may also want to tune the &lt;code&gt;maxclients&lt;/code&gt; parameter in &lt;code&gt;redis.conf&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Ensure you are not using too short timeout setting in the &lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#set_timeout&#34;&gt;set_timeout&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#set_timeouts&#34;&gt;set_timeouts&lt;/a&gt; methods. If you have to, try redoing the operation upon timeout and turning off &lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#automatic-error-logging&#34;&gt;automatic error logging&lt;/a&gt; (because you are already doing proper error handling in your own Lua code).&lt;/li&gt; &#xA; &lt;li&gt;If your NGINX worker processes&#39; CPU usage is very high under load, then the NGINX event loop might be blocked by the CPU computation too much. Try sampling a &lt;a href=&#34;https://github.com/agentzh/nginx-systemtap-toolkit#sample-bt&#34;&gt;C-land on-CPU Flame Graph&lt;/a&gt; and &lt;a href=&#34;https://github.com/agentzh/stapxx#ngx-lj-lua-stacks&#34;&gt;Lua-land on-CPU Flame Graph&lt;/a&gt; for a typical NGINX worker process. You can optimize the CPU-bound things according to these Flame Graphs.&lt;/li&gt; &#xA; &lt;li&gt;If your NGINX worker processes&#39; CPU usage is very low under load, then the NGINX event loop might be blocked by some blocking system calls (like file IO system calls). You can confirm the issue by running the &lt;a href=&#34;https://github.com/agentzh/stapxx#epoll-loop-blocking-distr&#34;&gt;epoll-loop-blocking-distr&lt;/a&gt; tool against a typical NGINX worker process. If it is indeed the case, then you can further sample a &lt;a href=&#34;https://github.com/agentzh/nginx-systemtap-toolkit#sample-bt-off-cpu&#34;&gt;C-land off-CPU Flame Graph&lt;/a&gt; for a NGINX worker process to analyze the actual blockers.&lt;/li&gt; &#xA; &lt;li&gt;If your &lt;code&gt;redis-server&lt;/code&gt; process is running near 100% CPU usage, then you should consider scale your Redis backend by multiple nodes or use the &lt;a href=&#34;https://github.com/agentzh/nginx-systemtap-toolkit#sample-bt&#34;&gt;C-land on-CPU Flame Graph tool&lt;/a&gt; to analyze the internal bottlenecks within the Redis server process.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Limitations&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This library cannot be used in code contexts like init_by_lua*, set_by_lua*, log_by_lua*, and header_filter_by_lua* where the ngx_lua cosocket API is not available.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;resty.redis&lt;/code&gt; object instance cannot be stored in a Lua variable at the Lua module level, because it will then be shared by all the concurrent requests handled by the same nginx worker process (see &lt;a href=&#34;https://github.com/openresty/lua-nginx-module/#data-sharing-within-an-nginx-worker&#34;&gt;https://github.com/openresty/lua-nginx-module/#data-sharing-within-an-nginx-worker&lt;/a&gt; ) and result in bad race conditions when concurrent requests are trying to use the same &lt;code&gt;resty.redis&lt;/code&gt; instance (you would see the &#34;bad request&#34; or &#34;socket busy&#34; error to be returned from the method calls). You should always initiate &lt;code&gt;resty.redis&lt;/code&gt; objects in function local variables or in the &lt;code&gt;ngx.ctx&lt;/code&gt; table. These places all have their own data copies for each request.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;If you are using the OpenResty bundle (&lt;a href=&#34;http://openresty.org&#34;&gt;http://openresty.org&lt;/a&gt; ), then you do not need to do anything because it already includes and enables lua-resty-redis by default. And you can just use it in your Lua code, as in&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    local redis = require &#34;resty.redis&#34;&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are using your own nginx + ngx_lua build, then you need to configure the lua_package_path directive to add the path of your lua-resty-redis source tree to ngx_lua&#39;s LUA_PATH search path, as in&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;    # nginx.conf&#xA;    http {&#xA;        lua_package_path &#34;/path/to/lua-resty-redis/lib/?.lua;;&#34;;&#xA;        ...&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Ensure that the system account running your Nginx &#39;&#39;worker&#39;&#39; proceses have enough permission to read the &lt;code&gt;.lua&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;TODO&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Community&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;English Mailing List&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://groups.google.com/group/openresty-en&#34;&gt;openresty-en&lt;/a&gt; mailing list is for English speakers.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Chinese Mailing List&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://groups.google.com/group/openresty&#34;&gt;openresty&lt;/a&gt; mailing list is for Chinese speakers.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Bugs and Patches&lt;/h1&gt; &#xA;&lt;p&gt;Please report bugs or submit patches by&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;creating a ticket on the &lt;a href=&#34;http://github.com/agentzh/lua-resty-redis/issues&#34;&gt;GitHub Issue Tracker&lt;/a&gt;,&lt;/li&gt; &#xA; &lt;li&gt;or posting to the &lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#community&#34;&gt;OpenResty community&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Author&lt;/h1&gt; &#xA;&lt;p&gt;Yichun &#34;agentzh&#34; Zhang (Á´†‰∫¶Êò•) &lt;a href=&#34;mailto:agentzh@gmail.com&#34;&gt;agentzh@gmail.com&lt;/a&gt;, OpenResty Inc.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Copyright and License&lt;/h1&gt; &#xA;&lt;p&gt;This module is licensed under the BSD license.&lt;/p&gt; &#xA;&lt;p&gt;Copyright (C) 2012-2017, by Yichun Zhang (agentzh) &lt;a href=&#34;mailto:agentzh@gmail.com&#34;&gt;agentzh@gmail.com&lt;/a&gt;, OpenResty Inc.&lt;/p&gt; &#xA;&lt;p&gt;All rights reserved.&lt;/p&gt; &#xA;&lt;p&gt;Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;See Also&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the ngx_lua module: &lt;a href=&#34;https://github.com/openresty/lua-nginx-module/#readme&#34;&gt;https://github.com/openresty/lua-nginx-module/#readme&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;the redis wired protocol specification: &lt;a href=&#34;http://redis.io/topics/protocol&#34;&gt;http://redis.io/topics/protocol&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;the &lt;a href=&#34;https://github.com/agentzh/lua-resty-memcached&#34;&gt;lua-resty-memcached&lt;/a&gt; library&lt;/li&gt; &#xA; &lt;li&gt;the &lt;a href=&#34;https://github.com/agentzh/lua-resty-mysql&#34;&gt;lua-resty-mysql&lt;/a&gt; library&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/openresty/lua-resty-redis/master/#table-of-contents&#34;&gt;Back to TOC&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>