<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-07-04T01:32:25Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>alp1x/um-idcard</title>
    <updated>2024-07-04T01:32:25Z</updated>
    <id>tag:github.com,2024-07-04:/alp1x/um-idcard</id>
    <link href="https://github.com/alp1x/um-idcard" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ü™™this is a FiveM script that generates identity cards with mugshots and metadata, specifically designed to be compatible with QBCore,ESX,QBox.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;‚ö†Ô∏è If you are having problems with um-idcard, you can wait for an update or alternatively use the following scripts suggested by um&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Byte-Labs-Studio/bl_idcard&#34;&gt;bl_idcard&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cinquina/five-idcard&#34;&gt;five_idcard&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;um-idcard | old (&lt;del&gt;qb-idcard&lt;/del&gt;)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;b&gt;qb-idcard&lt;/b&gt; has been updated and renamed as &lt;b&gt;um-idcard&lt;/b&gt;, and it is now compatible with &lt;b&gt;ESX&lt;/b&gt; and &lt;b&gt;QBCore&lt;/b&gt; and &lt;b&gt;Qbox&lt;/b&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Setup&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Make sure you have the items in &lt;strong&gt;Config.Licenses&lt;/strong&gt;, otherwise add them.&lt;/li&gt; &#xA; &lt;li&gt;After &lt;strong&gt;&lt;a href=&#34;https://github.com/overextended/ox_lib/releases&#34;&gt;ox_lib&lt;/a&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;a href=&#34;https://github.com/BaziForYou/MugShotBase64&#34;&gt;MugShotBase64&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ensure um-idcard&lt;/code&gt; or &lt;code&gt;ensure [um] folder&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;üìÑ &lt;strong&gt;&lt;a href=&#34;https://alp1x.github.io/um-idcard/Starter%20Setup/qbcore&#34;&gt;QBCore Starter Setup&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;üìÑ &lt;strong&gt;&lt;a href=&#34;https://alp1x.github.io/um-idcard/Starter%20Setup/esx&#34;&gt;ESX Starter Setup&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Just use the item&lt;/li&gt; &#xA; &lt;li&gt;If there is someone near you, it will be visible to them, otherwise only you will see it.&lt;/li&gt; &#xA; &lt;li&gt;It takes a mugshot of you on the first use of the item and saves it in metadata.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;How to create a custom identity card?&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://alp1x.github.io/um-idcard-maker/&#34;&gt;um-idcard-maker&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;How can add an identity card with metadata?&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://alp1x.github.io/um-idcard/exports&#34;&gt;Exports&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Optional&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/alp1x/um-idcard-menu&#34;&gt;um-idcard-menu&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Inventory&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/overextended/ox_inventory/releases&#34;&gt;ox_inventory&lt;/a&gt;&lt;/strong&gt; (ESX or QBCore)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/qbcore-framework/qb-inventory&#34;&gt;qb-inventory or lj-inventory &lt;/a&gt;&lt;/strong&gt; (QBCore)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;a href=&#34;https://github.com/alp1x/um-idcard/graphs/contributors&#34;&gt; &lt;img src=&#34;https://contrib.rocks/image?repo=alp1x/um-idcard&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://choosealicense.com/licenses/gpl-3.0/&#34;&gt;GNU General Public License v3.0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Star History&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://star-history.com/#alp1x/um-idcard&amp;amp;Date&#34;&gt;&lt;img src=&#34;https://api.star-history.com/svg?repos=alp1x/um-idcard&amp;amp;type=Date&#34; alt=&#34;Star History Chart&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Shatur/neovim-session-manager</title>
    <updated>2024-07-04T01:32:25Z</updated>
    <id>tag:github.com,2024-07-04:/Shatur/neovim-session-manager</id>
    <link href="https://github.com/Shatur/neovim-session-manager" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A simple wrapper around :mksession.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Neovim Session Manager&lt;/h1&gt; &#xA;&lt;p&gt;A Neovim plugin that use built-in &lt;code&gt;:mksession&lt;/code&gt; to manage sessions like folders in VSCode. It allows you to save the current folder as a session to open it later. The plugin can also automatically load the last session on startup, save the current one on exit and switch between session folders.&lt;/p&gt; &#xA;&lt;p&gt;The plugin saves the sessions in the specified folder (see &lt;a href=&#34;https://raw.githubusercontent.com/Shatur/neovim-session-manager/master/#configuration&#34;&gt;configuration&lt;/a&gt;). The session corresponds to the working directory. If a session already exists for the current folder, it will be overwritten.&lt;/p&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-lua/plenary.nvim&#34;&gt;plenary.nvim&lt;/a&gt; for internal helpers.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Commands&lt;/h2&gt; &#xA;&lt;p&gt;Use the command &lt;code&gt;:SessionManager[!]&lt;/code&gt; with one of the following arguments:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Argument&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;load_session&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Select and load session. (Your current session won&#39;t appear on the list).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;load_last_session&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Removes all buffers and tries to &lt;code&gt;:source&lt;/code&gt; the last saved session. Returns &lt;code&gt;true&lt;/code&gt; if the session was restored and &lt;code&gt;false&lt;/code&gt; otherwise.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;load_current_dir_session&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Removes all buffers and tries to &lt;code&gt;:source&lt;/code&gt; the last saved session of the current directory. Returns &lt;code&gt;true&lt;/code&gt; if the session was restored and &lt;code&gt;false&lt;/code&gt; otherwise.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;load_git_session&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;When in a git repo, removes all buffers and tries to &lt;code&gt;:source&lt;/code&gt; the last saved session of the git repo root directory. Returns &lt;code&gt;true&lt;/code&gt; if the session was restored and &lt;code&gt;false&lt;/code&gt; otherwise.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;save_current_session&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Works like &lt;code&gt;:mksession&lt;/code&gt;, but saves/creates current directory as a session in &lt;code&gt;sessions_dir&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;delete_session&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Select and delete session.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;delete_current_dir_session&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Deletes the session associated with the current directory.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;When &lt;code&gt;!&lt;/code&gt; is specified, the modified buffers will not be saved.&lt;/p&gt; &#xA;&lt;p&gt;Commands &lt;code&gt;load_session&lt;/code&gt; and &lt;code&gt;delete_session&lt;/code&gt; use &lt;code&gt;vim.ui.select()&lt;/code&gt;. To use your favorite picker like Telescope, consider installing &lt;a href=&#34;https://github.com/stevearc/dressing.nvim&#34;&gt;dressing.nvim&lt;/a&gt; or &lt;a href=&#34;https://github.com/nvim-telescope/telescope-ui-select.nvim&#34;&gt;telescope-ui-select.nvim&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;To configure the plugin, you can call &lt;code&gt;require(&#39;session_manager&#39;).setup(values)&lt;/code&gt;, where &lt;code&gt;values&lt;/code&gt; is a dictionary with the parameters you want to override. Here are the defaults:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local Path = require(&#39;plenary.path&#39;)&#xA;local config = require(&#39;session_manager.config&#39;)&#xA;require(&#39;session_manager&#39;).setup({&#xA;  sessions_dir = Path:new(vim.fn.stdpath(&#39;data&#39;), &#39;sessions&#39;), -- The directory where the session files will be saved.&#xA;  session_filename_to_dir = session_filename_to_dir, -- Function that replaces symbols into separators and colons to transform filename into a session directory.&#xA;  dir_to_session_filename = dir_to_session_filename, -- Function that replaces separators and colons into special symbols to transform session directory into a filename. Should use `vim.uv.cwd()` if the passed `dir` is `nil`.&#xA;  autoload_mode = config.AutoloadMode.LastSession, -- Define what to do when Neovim is started without arguments. See &#34;Autoload mode&#34; section below.&#xA;  autosave_last_session = true, -- Automatically save last session on exit and on session switch.&#xA;  autosave_ignore_not_normal = true, -- Plugin will not save a session when no buffers are opened, or all of them aren&#39;t writable or listed.&#xA;  autosave_ignore_dirs = {}, -- A list of directories where the session will not be autosaved.&#xA;  autosave_ignore_filetypes = { -- All buffers of these file types will be closed before the session is saved.&#xA;    &#39;gitcommit&#39;,&#xA;    &#39;gitrebase&#39;,&#xA;  },&#xA;  autosave_ignore_buftypes = {}, -- All buffers of these bufer types will be closed before the session is saved.&#xA;  autosave_only_in_session = false, -- Always autosaves session. If true, only autosaves after a session is active.&#xA;  max_path_length = 80,  -- Shorten the display path if length exceeds this threshold. Use 0 if don&#39;t want to shorten the path at all.&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Autoload mode&lt;/h3&gt; &#xA;&lt;p&gt;If Neovim is started without arguments the value of the autoload_mode option is used to determine which session to initially load. The following modes are supported:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Mode&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Disabled&lt;/td&gt; &#xA;   &lt;td&gt;No session will be loaded.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CurrentDir&lt;/td&gt; &#xA;   &lt;td&gt;The session in the current working directory will be loaded.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;LastSession&lt;/td&gt; &#xA;   &lt;td&gt;The last session will be loaded. This is the default.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GitSession&lt;/td&gt; &#xA;   &lt;td&gt;If in a git repo the session for repository root will be loaded&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;code&gt;autoload_mode&lt;/code&gt; can be set to either a single mode or an array of modes, in which case each mode will be tried until one succeeds e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;autoload_mode = { config.AutoloadMode.CurrentDir, config.AutoloadMode.LastSession }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Would attempt to load the current directory session and then fallback to the last session.&lt;/p&gt; &#xA;&lt;h2&gt;Autocommands&lt;/h2&gt; &#xA;&lt;p&gt;You can specify commands to be executed automatically after saving or loading a session using the following events:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Event&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SessionSavePre&lt;/td&gt; &#xA;   &lt;td&gt;Executed before a session is saved&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SessionSavePost&lt;/td&gt; &#xA;   &lt;td&gt;Executed after a session is saved&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SessionLoadPre&lt;/td&gt; &#xA;   &lt;td&gt;Executed before a session is loaded&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SessionLoadPost&lt;/td&gt; &#xA;   &lt;td&gt;Executed after a session is loaded&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For example, if you would like to have NvimTree or any other file tree automatically opened after a session load, have this somewhere in your config file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local config_group = vim.api.nvim_create_augroup(&#39;MyConfigGroup&#39;, {}) -- A global group for all your config autocommands&#xA;&#xA;vim.api.nvim_create_autocmd({ &#39;User&#39; }, {&#xA;  pattern = &#34;SessionLoadPost&#34;,&#xA;  group = config_group,&#xA;  callback = function()&#xA;    require(&#39;nvim-tree.api&#39;).tree.toggle(false, true)&#xA;  end,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Save session on BufWrite&lt;/h2&gt; &#xA;&lt;p&gt;You can enable this opt in feature with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Auto save session&#xA;vim.api.nvim_create_autocmd({ &#39;BufWritePre&#39; }, {&#xA;  callback = function ()&#xA;    for _, buf in ipairs(vim.api.nvim_list_bufs()) do&#xA;      -- Don&#39;t save while there&#39;s any &#39;nofile&#39; buffer open.&#xA;      if vim.api.nvim_get_option_value(&#34;buftype&#34;, { buf = buf }) == &#39;nofile&#39; then&#xA;        return&#xA;      end&#xA;    end&#xA;    session_manager.save_current_session()&#xA;  end&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information about autocmd and its event, see also:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://neovim.io/doc/user/autocmd.html&#34;&gt;&lt;code&gt;:help autocmd&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://neovim.io/doc/user/autocmd.html#events&#34;&gt;&lt;code&gt;:help events&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://neovim.io/doc/user/autocmd.html#User&#34;&gt;&lt;code&gt;:help User&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>