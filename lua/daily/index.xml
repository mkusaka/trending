<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-03T01:46:40Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mhartington/formatter.nvim</title>
    <updated>2022-07-03T01:46:40Z</updated>
    <id>tag:github.com,2022-07-03:/mhartington/formatter.nvim</id>
    <link href="https://github.com/mhartington/formatter.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Formatter.nvim&lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h3&gt;A format runner for &lt;code&gt;Neovim&lt;/code&gt;.&lt;/h3&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/mhartington/formatter.nvim/master/asset/splash.gif&#34; alt=&#34;splash&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;We want to thank the &lt;a href=&#34;https://github.com/sbdchd/neoformat&#34;&gt;&lt;code&gt;neoformat&lt;/code&gt;&lt;/a&gt; contributors. They developed a lot of formatter configurations that we used as a reference to create our own opt-in default formatter configurations.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Written in &lt;code&gt;Lua&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Asynchronous execution&lt;/li&gt; &#xA; &lt;li&gt;Opt-in default formatter configurations&lt;/li&gt; &#xA; &lt;li&gt;Conditional formatting&lt;/li&gt; &#xA; &lt;li&gt;Before/after format hooks&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;&lt;code&gt;packer.nvim&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;packer&#39;).use { &#39;mhartington/formatter.nvim&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://github.com/savq/paq-nvim&#34;&gt;&lt;code&gt;paq-nvim&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;paq&#34;) { &#39;mhartington/formatter.nvim&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://github.com/junegunn/vim-plug&#34;&gt;&lt;code&gt;vim-plug&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Plug &#39;mhartington/formatter.nvim&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://github.com/VundleVim/Vundle.vim&#34;&gt;&lt;code&gt;Vundle.vim&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Plugin &#39;mhartington/formatter.nvim&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://github.com/tpope/vim-pathogen&#34;&gt;&lt;code&gt;vim-pathogen&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd ~/.vim/bundle &amp;amp;&amp;amp; \&#xA;git clone https://github.com/mhartington/formatter.nvim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://github.com/Shougo/dein.vim&#34;&gt;&lt;code&gt;dein.vim&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;call dein#add(&#39;mhartington/formatter.nvim&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configure&lt;/h2&gt; &#xA;&lt;p&gt;Setup:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Utilities for creating configurations&#xA;local util = require &#34;formatter.util&#34;&#xA;&#xA;-- Provides the Format and FormatWrite commands&#xA;require(&#34;formatter&#34;).setup {&#xA;  -- Enable or disable logging&#xA;  logging = true,&#xA;  -- Set the log level&#xA;  log_level = vim.log.levels.WARN,&#xA;  -- All formatter configurations are opt-in&#xA;  filetype = {&#xA;    -- Formatter configurations for filetype &#34;lua&#34; go here&#xA;    -- and will be executed in order&#xA;    lua = {&#xA;      -- &#34;formatter.filetypes.lua&#34; defines default configurations for the&#xA;      -- &#34;lua&#34; filetype&#xA;      require(&#34;formatter.filetypes.lua&#34;).stylua,&#xA;&#xA;      -- You can also define your own configuration&#xA;      function()&#xA;        -- Supports conditional formatting&#xA;        if util.get_current_buffer_file_name() == &#34;special.lua&#34; then&#xA;          return nil&#xA;        end&#xA;&#xA;        -- Full specification of configurations is down below and in Vim help&#xA;        -- files&#xA;        return {&#xA;          exe = &#34;stylua&#34;,&#xA;          args = {&#xA;            &#34;--search-parent-directories&#34;,&#xA;            &#34;--stdin-filepath&#34;,&#xA;            util.escape_path(util.get_current_buffer_file_path()),&#xA;            &#34;--&#34;,&#xA;            &#34;-&#34;,&#xA;          },&#xA;          stdin = true,&#xA;        }&#xA;      end&#xA;    },&#xA;&#xA;    -- Use the special &#34;*&#34; filetype for defining formatter configurations on&#xA;    -- any filetype&#xA;    [&#34;*&#34;] = {&#xA;      -- &#34;formatter.filetypes.any&#34; defines default configurations for any&#xA;      -- filetype&#xA;      require(&#34;formatter.filetypes.any&#34;).remove_trailing_whitespace&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Opt-in formatters&lt;/h3&gt; &#xA;&lt;p&gt;By default, there are no preconfigured formatters. You can opt-into &lt;a href=&#34;https://raw.githubusercontent.com/mhartington/formatter.nvim/master/lua/formatter/defaults&#34;&gt;default configurations per formatter&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/mhartington/formatter.nvim/master/lua/formatter/filetypes&#34;&gt;default configurations per &lt;code&gt;filetype&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/mhartington/formatter.nvim/master/lua/formatter/filetypes/any.lua&#34;&gt;default configurations for any &lt;code&gt;filetype&lt;/code&gt;&lt;/a&gt; or write your own. It is hard to predict what everyone wants, but at the same time we realize that most formatter configurations are the same. See the discussion in &lt;a href=&#34;https://github.com/mhartington/formatter.nvim/issues/97&#34;&gt;#97&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;You can use the &lt;a href=&#34;https://raw.githubusercontent.com/mhartington/formatter.nvim/master/lua/formatter/defaults&#34;&gt;default configurations per formatter&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/mhartington/formatter.nvim/master/lua/formatter/filetypes&#34;&gt;default configurations per &lt;code&gt;filetype&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/mhartington/formatter.nvim/master/lua/formatter/filetypes/any.lua&#34;&gt;default configurations for any &lt;code&gt;filetype&lt;/code&gt;&lt;/a&gt; as a starting point for creating your configurations. Feel free to contribute to this repository by creating or improving default configurations that everyone can use! The guide for contributing to default configurations is below.&lt;/p&gt; &#xA;&lt;p&gt;You can use the &lt;a href=&#34;https://raw.githubusercontent.com/mhartington/formatter.nvim/master/lua/formatter/util&#34;&gt;&lt;code&gt;util&lt;/code&gt; module&lt;/a&gt; which has various functions that help with creating default configurations as shown above.&lt;/p&gt; &#xA;&lt;h3&gt;Map keys&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;nnoremap &amp;lt;silent&amp;gt; &amp;lt;leader&amp;gt;f :Format&amp;lt;CR&amp;gt;&#xA;nnoremap &amp;lt;silent&amp;gt; &amp;lt;leader&amp;gt;F :FormatWrite&amp;lt;CR&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Format after save&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;augroup FormatAutogroup&#xA;  autocmd!&#xA;  autocmd BufWritePost * FormatWrite&#xA;augroup END&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Before/after format hooks&lt;/h3&gt; &#xA;&lt;p&gt;You can execute code before and after formatting like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;augroup FormatAutogroup&#xA;  autocmd!&#xA;  autocmd User FormatterPre lua print &#34;This will print before formatting&#34;&#xA;  autocmd User FormatterPost lua print &#34;This will print after formatting&#34;&#xA;augroup END&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that these commands are executed using &lt;code&gt;silent&lt;/code&gt; when the &lt;code&gt;log_level&lt;/code&gt; is higher than &lt;code&gt;vim.log.levels.DEBUG&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Configuration specification&lt;/h3&gt; &#xA;&lt;p&gt;Each formatter configuration is a function that returns a table. Because each entry is a function, the tables for each &lt;code&gt;filetype&lt;/code&gt; act as an ordered list (or array). This means things run in the order you list them, keep this in mind. You can also return &lt;code&gt;nil&lt;/code&gt; from these functions to conditionally apply formatters.&lt;/p&gt; &#xA;&lt;p&gt;Each formatter configuration should return a table that consist of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;exe&lt;/code&gt;: the program you wish to run.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;args&lt;/code&gt;: a table of arguments to pass (optional)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;stdin&lt;/code&gt;: if it should use the standard input (optional)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cwd&lt;/code&gt; : the path to run the program from (optional)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;try_node_modules&lt;/code&gt;: tries to run a formatter from locally install npm packages (optional) (to be implemented)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;no_append&lt;/code&gt; : don&#39;t append the path of the file to the formatter command (optional)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_exitcode&lt;/code&gt; : set to true if the program expects non-zero success exit code (optional)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;transform&lt;/code&gt; : pass a function that takes in the formatted text and returns the text to be applied to the buffer (optional) (see &lt;a href=&#34;https://raw.githubusercontent.com/mhartington/formatter.nvim/master/lua/formatter/filetypes/ruby&#34;&gt;&lt;code&gt;ruby&lt;/code&gt; &lt;code&gt;rubocop&lt;/code&gt;&lt;/a&gt; default formatter configuration as an example)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tempfile_dir&lt;/code&gt;: directory for temp file when not using &lt;code&gt;stdin&lt;/code&gt; (optional)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tempfile_prefix&lt;/code&gt;: prefix for temp file when not using &lt;code&gt;stdin&lt;/code&gt; (optional)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tempfile_postfix&lt;/code&gt;: postfix for temp file when not using &lt;code&gt;stdin&lt;/code&gt; (optional)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;cwd&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;cwd&lt;/code&gt; argument can be used for in example monolithic projects which contain sources with different styles. Setting &lt;code&gt;cwd&lt;/code&gt; to the path of the file being formatted causes, for example, &lt;code&gt;clang-format&lt;/code&gt; to search for the nearest &lt;code&gt;.clang-format&lt;/code&gt; file in the file&#39;s parent directories.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;try_node_modules&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;try_node_modules&lt;/code&gt; argument is not yet implemented, but feel free to use this argument in your configurations. When we add support for it, you get the &lt;code&gt;node_modules&lt;/code&gt; package scanning functionality automatically!&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;no_append&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;no_append&lt;/code&gt; argument is important for formatters that don&#39;t take the path to the formatted file as the last argument. A small minority of formatters take the path to the formatted file as a named argument. For an example, check the &lt;a href=&#34;https://raw.githubusercontent.com/mhartington/formatter.nvim/master/lua/formatter/filetypes/javascript.lua&#34;&gt;default &lt;code&gt;javascript&lt;/code&gt; &lt;code&gt;prettydiff&lt;/code&gt; configuration&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;p&gt;Refer to the &lt;a href=&#34;https://raw.githubusercontent.com/mhartington/formatter.nvim/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; file for more information.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ahmedkhalf/project.nvim</title>
    <updated>2022-07-03T01:46:40Z</updated>
    <id>tag:github.com,2022-07-03:/ahmedkhalf/project.nvim</id>
    <link href="https://github.com/ahmedkhalf/project.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The superior project management solution for neovim.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;🗃️ project.nvim&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;project.nvim&lt;/strong&gt; is an all in one neovim plugin written in lua that provides superior project management.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/36672196/129409509-62340f10-4dd0-4c1a-9252-8bfedf2a9945.png&#34; alt=&#34;Telescope Integration&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;⚡ Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Neovim &amp;gt;= 0.5.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;✨ Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Automagically cd to project directory using nvim lsp &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Dependency free, does not rely on lspconfig&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;If no lsp then uses pattern matching to cd to root directory&lt;/li&gt; &#xA; &lt;li&gt;Telescope integration &lt;code&gt;:Telescope projects&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Access your recently opened projects from telescope!&lt;/li&gt; &#xA;   &lt;li&gt;Asynchronous file io so it will not slow down vim when reading the history file on startup.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;Nvim-tree.lua support/integration&lt;/del&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Please add the following to your config instead: &lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;&#34; Vim Script&#xA;lua &amp;lt;&amp;lt; EOF&#xA;require(&#34;nvim-tree&#34;).setup({&#xA;  update_cwd = true,&#xA;  respect_buf_cwd = true,&#xA;  update_focused_file = {&#xA;    enable = true,&#xA;    update_cwd = true&#xA;  },&#xA;})&#xA;EOF&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- lua&#xA;require(&#34;nvim-tree&#34;).setup({&#xA;  respect_buf_cwd = true,&#xA;  update_cwd = true,&#xA;  update_focused_file = {&#xA;    enable = true,&#xA;    update_cwd = true&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;📦 Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install the plugin with your preferred package manager:&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/junegunn/vim-plug&#34;&gt;vim-plug&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;&#34; Vim Script&#xA;Plug &#39;ahmedkhalf/project.nvim&#39;&#xA;&#xA;lua &amp;lt;&amp;lt; EOF&#xA;  require(&#34;project_nvim&#34;).setup {&#xA;    -- your configuration comes here&#xA;    -- or leave it empty to use the default settings&#xA;    -- refer to the configuration section below&#xA;  }&#xA;EOF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;packer&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Lua&#xA;use {&#xA;  &#34;ahmedkhalf/project.nvim&#34;,&#xA;  config = function()&#xA;    require(&#34;project_nvim&#34;).setup {&#xA;      -- your configuration comes here&#xA;      -- or leave it empty to use the default settings&#xA;      -- refer to the configuration section below&#xA;    }&#xA;  end&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;⚙️ Configuration&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;project.nvim&lt;/strong&gt; comes with the following defaults:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  -- Manual mode doesn&#39;t automatically change your root directory, so you have&#xA;  -- the option to manually do so using `:ProjectRoot` command.&#xA;  manual_mode = false,&#xA;&#xA;  -- Methods of detecting the root directory. **&#34;lsp&#34;** uses the native neovim&#xA;  -- lsp, while **&#34;pattern&#34;** uses vim-rooter like glob pattern matching. Here&#xA;  -- order matters: if one is not detected, the other is used as fallback. You&#xA;  -- can also delete or rearangne the detection methods.&#xA;  detection_methods = { &#34;lsp&#34;, &#34;pattern&#34; },&#xA;&#xA;  -- All the patterns used to detect root dir, when **&#34;pattern&#34;** is in&#xA;  -- detection_methods&#xA;  patterns = { &#34;.git&#34;, &#34;_darcs&#34;, &#34;.hg&#34;, &#34;.bzr&#34;, &#34;.svn&#34;, &#34;Makefile&#34;, &#34;package.json&#34; },&#xA;&#xA;  -- Table of lsp clients to ignore by name&#xA;  -- eg: { &#34;efm&#34;, ... }&#xA;  ignore_lsp = {},&#xA;&#xA;  -- Don&#39;t calculate root dir on specific directories&#xA;  -- Ex: { &#34;~/.cargo/*&#34;, ... }&#xA;  exclude_dirs = {},&#xA;&#xA;  -- Show hidden files in telescope&#xA;  show_hidden = false,&#xA;&#xA;  -- When set to false, you will get a message when project.nvim changes your&#xA;  -- directory.&#xA;  silent_chdir = true,&#xA;&#xA;  -- Path where project.nvim will store the project history for use in&#xA;  -- telescope&#xA;  datapath = vim.fn.stdpath(&#34;data&#34;),&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Even if you are pleased with the defaults, please note that &lt;code&gt;setup {}&lt;/code&gt; must be called for the plugin to start.&lt;/p&gt; &#xA;&lt;h3&gt;Pattern Matching&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;project.nvim&lt;/strong&gt;&#39;s pattern engine uses the same expressions as vim-rooter, but for your convenience, I will copy paste them here:&lt;/p&gt; &#xA;&lt;p&gt;To specify the root is a certain directory, prefix it with &lt;code&gt;=&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;detection_methods = { &#34;=src&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To specify the root has a certain directory or file (which may be a glob), just give the name:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;detection_methods = { &#34;.git&#34;, &#34;Makefile&#34;, &#34;*.sln&#34;, &#34;build/env.sh&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To specify the root has a certain directory as an ancestor (useful for excluding directories), prefix it with &lt;code&gt;^&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;detection_methods = { &#34;^fixtures&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To specify the root has a certain directory as its direct ancestor / parent (useful when you put working projects in a common directory), prefix it with &lt;code&gt;&amp;gt;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;detection_methods = { &#34;&amp;gt;Latex&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To exclude a pattern, prefix it with &lt;code&gt;!&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;detection_methods = { &#34;!.git/worktrees&#34;, &#34;!=extras&#34;, &#34;!^fixtures&#34;, &#34;!build/env.sh&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;List your exclusions before the patterns you do want.&lt;/p&gt; &#xA;&lt;h3&gt;Telescope Integration&lt;/h3&gt; &#xA;&lt;p&gt;To enable telescope integration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;telescope&#39;).load_extension(&#39;projects&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Telescope mappings&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;project.nvim&lt;/strong&gt; comes with the following mappings:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Normal mode&lt;/th&gt; &#xA;   &lt;th&gt;Insert mode&lt;/th&gt; &#xA;   &lt;th&gt;Action&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;f&lt;/td&gt; &#xA;   &lt;td&gt;&amp;lt;c-f&amp;gt;&lt;/td&gt; &#xA;   &lt;td&gt;find_project_files&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;b&lt;/td&gt; &#xA;   &lt;td&gt;&amp;lt;c-b&amp;gt;&lt;/td&gt; &#xA;   &lt;td&gt;browse_project_files&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;d&lt;/td&gt; &#xA;   &lt;td&gt;&amp;lt;c-d&amp;gt;&lt;/td&gt; &#xA;   &lt;td&gt;delete_project&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;s&lt;/td&gt; &#xA;   &lt;td&gt;&amp;lt;c-s&amp;gt;&lt;/td&gt; &#xA;   &lt;td&gt;search_in_project_files&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;r&lt;/td&gt; &#xA;   &lt;td&gt;&amp;lt;c-r&amp;gt;&lt;/td&gt; &#xA;   &lt;td&gt;recent_project_files&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;w&lt;/td&gt; &#xA;   &lt;td&gt;&amp;lt;c-w&amp;gt;&lt;/td&gt; &#xA;   &lt;td&gt;change_working_directory&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;p&gt;Get a list of recent projects:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local project_nvim = require(&#34;project_nvim&#34;)&#xA;local recent_projects = project_nvim.get_recent_projects()&#xA;&#xA;print(vim.inspect(recent_projects))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;🤝 Contributing&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All pull requests are welcome.&lt;/li&gt; &#xA; &lt;li&gt;If you encounter bugs please open an issue.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>ray-x/go.nvim</title>
    <updated>2022-07-03T01:46:40Z</updated>
    <id>tag:github.com,2022-07-03:/ray-x/go.nvim</id>
    <link href="https://github.com/ray-x/go.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Modern Go plugin for Neovim, based on gopls, treesitter AST, Dap and a variety of go tools.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;go.nvim&lt;/h1&gt; &#xA;&lt;p&gt;A modern go neovim plugin based on treesitter, nvim-lsp and dap debugger. It is written in Lua and async as much as possible. PR &amp;amp; Suggestions welcome. The plugin covers most features required for a gopher.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Perproject setup. Allows you setup plugin behavior per project based on project files(launch.json, .gonvim)&lt;/li&gt; &#xA; &lt;li&gt;Async jobs with libuv&lt;/li&gt; &#xA; &lt;li&gt;Syntax highlight &amp;amp; Texobject: Native treesitter support is faster and more accurate. All you need is a theme support treesitter, try &lt;a href=&#34;https://github.com/ray-x/aurora&#34;&gt;aurora&lt;/a&gt;, &lt;a href=&#34;https://github.com/ray-x/starry.nvim&#34;&gt;starry.nvim&lt;/a&gt;. Also, there are quite a few listed in &lt;a href=&#34;https://github.com/rockerBOO/awesome-neovim&#34;&gt;awesome-neovim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;All the GoToXxx (E.g reference, implementation, definition, goto doc, peek code/doc etc) You need lspconfig setup. There are lots of posts on how to set it up. You can also check my &lt;a href=&#34;https://github.com/ray-x/navigator.lua&#34;&gt;navigator&lt;/a&gt; gopls setup &lt;a href=&#34;https://github.com/ray-x/navigator.lua/raw/master/lua/navigator/lspclient/clients.lua&#34;&gt;lspconfig.lua&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Runtime lint/vet/compile: Supported by lsp (once you setup up your lsp client), GoLint with golangci-lint also supported&lt;/li&gt; &#xA; &lt;li&gt;Build/Make/Test: Go.nvim provides supports for these by an async job wrapper.&lt;/li&gt; &#xA; &lt;li&gt;Test coverage: run test coverage and show coverage sign and function metrics&lt;/li&gt; &#xA; &lt;li&gt;Dlv Debug: with &lt;a href=&#34;https://github.com/mfussenegger/nvim-dap&#34;&gt;nvim-dap&lt;/a&gt; and &lt;a href=&#34;https://github.com/rcarriga/nvim-dap-ui&#34;&gt;Dap UI&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Load vscode launch configuration&lt;/li&gt; &#xA; &lt;li&gt;Unit test: generate unit test framework with &lt;a href=&#34;https://github.com/cweill/gotests&#34;&gt;gotests&lt;/a&gt;. Run test with richgo/ginkgo/gotestsum/go test&lt;/li&gt; &#xA; &lt;li&gt;Add and remove tag for struct with tag modify(gomodifytags)&lt;/li&gt; &#xA; &lt;li&gt;Code format: Supports LSP format and GoFmt(with golines)&lt;/li&gt; &#xA; &lt;li&gt;CodeLens : gopls codelens and codelens action support&lt;/li&gt; &#xA; &lt;li&gt;Comments: Add autodocument for your package/function/struct/interface. This feature is unique and can help you suppress golint errors...&lt;/li&gt; &#xA; &lt;li&gt;Go to alternative go file (between test and source)&lt;/li&gt; &#xA; &lt;li&gt;Test with ginkgo, richgo inside floaterm (to enable floaterm, guihua.lua has to be installed)&lt;/li&gt; &#xA; &lt;li&gt;Go 1.18 support, configure your go to &lt;code&gt;go1.18&lt;/code&gt; in config&lt;/li&gt; &#xA; &lt;li&gt;Code refactor made easy: GoFixPlural, FixStruct, FixSwitch, Add comment, IfErr, ModTidy, GoGet, extract function/block with codeactions... Most of the tools are built on top of treesitter AST or go AST. It is fast and accurate.&lt;/li&gt; &#xA; &lt;li&gt;GoCheat get go cheatsheet from &lt;a href=&#34;https://cheat.sh/&#34;&gt;cheat.sh&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Smart build tag detection when debug/run tests (e.g. &lt;code&gt;//go:build integration&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Use your favorite package manager to install. The dependency &lt;code&gt;treesitter&lt;/code&gt; (and optionally, treesitter-objects) should be installed the first time you use it. Also Run &lt;code&gt;TSInstall go&lt;/code&gt; to install the go parser if not installed yet. &lt;code&gt;sed&lt;/code&gt; is recommand to run this plugin.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/junegunn/vim-plug&#34;&gt;vim-plug&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Plug &#39;ray-x/go.nvim&#39;&#xA;Plug &#39;ray-x/guihua.lua&#39; ; recommanded if need floating window support&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;packer.nvim&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use &#39;ray-x/go.nvim&#39;&#xA;use &#39;ray-x/guihua.lua&#39; -- recommanded if need floating window support&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure the &lt;code&gt;$GOPATH/bin&lt;/code&gt; path is added to your &lt;code&gt;$PATH&lt;/code&gt; environment variable. To check this you can run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo $PATH | grep &#34;$GOPATH/bin&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If nothing shows up, you can add the following to your shell config file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export PATH=$PATH:$GOPATH/bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add format in your vimrc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;autocmd BufWritePre *.go :silent! lua require(&#39;go.format&#39;).gofmt()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To startup/setup the plugin&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;go&#39;).setup()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Screenshots&lt;/h2&gt; &#xA;&lt;h3&gt;Add comments&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/ray-x/files/raw/master/img/go.nvim/comment.gif?raw=true&#34; alt=&#34;auto comments&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Add/Remove tags&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/ray-x/files/raw/master/img/go.nvim/tags.gif?raw=true&#34; alt=&#34;auto tag&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;GoTest in floating term&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1681295/143160335-b8046ffa-82cd-4d84-af3e-3b0dbb4c609e.png&#34; alt=&#34;gotest&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;:GoTermClose&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To close the floating term.&lt;/p&gt; &#xA;&lt;h2&gt;refactor gorename&lt;/h2&gt; &#xA;&lt;p&gt;gorename as an alternative to gopls rename as it supports rename across packages Note: use with care Command: GoRename&lt;/p&gt; &#xA;&lt;h2&gt;code format&lt;/h2&gt; &#xA;&lt;p&gt;nvim-lsp support goimport by default.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;autocmd BufWritePre (InsertLeave?) &amp;lt;buffer&amp;gt; lua vim.lsp.buf.formatting_sync(nil,500)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The plugin provides code format, by default is goline + gofumpt (stricter version of gofmt)&lt;/p&gt; &#xA;&lt;p&gt;Use following code to format go code&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;go.format&#34;).gofmt()  -- gofmt only&#xA;require(&#34;go.format&#34;).goimport()  -- goimport + gofmt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Format on save&lt;/h3&gt; &#xA;&lt;p&gt;To config format on save, add one of the following to your init.lua:&lt;/p&gt; &#xA;&lt;h4&gt;Run gofmt on save&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Run gofmt on save&#xA;vim.api.nvim_exec([[ autocmd BufWritePre *.go :silent! lua require(&#39;go.format&#39;).gofmt() ]], false)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Run gofmt + goimport on save&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Run gofmt + goimport on save&#xA;vim.api.nvim_exec([[ autocmd BufWritePre *.go :silent! lua require(&#39;go.format&#39;).goimport() ]], false)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Auto fill&lt;/h2&gt; &#xA;&lt;p&gt;Note: auto fill struct also supported by gopls lsp-action&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoFillStruct&lt;/td&gt; &#xA;   &lt;td&gt;auto fill struct&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoFillSwitch&lt;/td&gt; &#xA;   &lt;td&gt;fill switch&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoIfErr&lt;/td&gt; &#xA;   &lt;td&gt;Add if err&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoFixPlurals&lt;/td&gt; &#xA;   &lt;td&gt;change func foo(b int, a int, r int) -&amp;gt; func foo(b, a, r int)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://www.youtube.com/watch?v=IP67Gkb5-qA&#34; alt=&#34;GoFixPlurals Youtube video&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package foo&#xA;&#xA;import &#34;io&#34;&#xA;&#xA;func Foo() (io.Reader, error) { // the cursor on this line to add if err statement&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/ray-x/files/raw/master/img/go.nvim/fstruct.gif?raw=true&#34; alt=&#34;auto struct&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Textobject&lt;/h2&gt; &#xA;&lt;p&gt;Supported by treesitter. TS provided better parse result compared to regular expression. See the example &lt;a href=&#34;https://github.com/ray-x/go.nvim#text-object&#34;&gt;treesitter config file&lt;/a&gt; on how to setup textobjects. Also with treesitter-objects, you can move, swap the selected blocks of codes, which is fast and accurate. &lt;code&gt;go.nvim&lt;/code&gt; will load textobject with treesiteter, with default keybindings, if you what to set it up yourself, you can set &lt;code&gt;textobject&lt;/code&gt; to false.&lt;/p&gt; &#xA;&lt;h2&gt;Go binaries install and update&lt;/h2&gt; &#xA;&lt;p&gt;The following go binaries are used in &lt;code&gt;go.nvim&lt;/code&gt; (depends on your setup):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;gofumpt&lt;/li&gt; &#xA; &lt;li&gt;golines&lt;/li&gt; &#xA; &lt;li&gt;goimports&lt;/li&gt; &#xA; &lt;li&gt;gorename&lt;/li&gt; &#xA; &lt;li&gt;gomodifytags&lt;/li&gt; &#xA; &lt;li&gt;gotests&lt;/li&gt; &#xA; &lt;li&gt;iferr&lt;/li&gt; &#xA; &lt;li&gt;impl&lt;/li&gt; &#xA; &lt;li&gt;fillstruct&lt;/li&gt; &#xA; &lt;li&gt;fillswitch&lt;/li&gt; &#xA; &lt;li&gt;dlv&lt;/li&gt; &#xA; &lt;li&gt;ginkgo&lt;/li&gt; &#xA; &lt;li&gt;richgo&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Normally if you run &lt;code&gt;GoFmt&lt;/code&gt; and the configured binary (e.g. golines) was not installed, the plugin will install it for you. But the first run of &lt;code&gt;GoFmt&lt;/code&gt; may fail. It is recommended to run &lt;code&gt;GoInstallBinaries&lt;/code&gt; to install all binaries before using the plugin.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoInstallBinary go_binary_name&lt;/td&gt; &#xA;   &lt;td&gt;use &lt;code&gt;go install go_binary_url@latest&lt;/code&gt; to install tool, if installed will skip&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoUpdateBinary go_binary_name&lt;/td&gt; &#xA;   &lt;td&gt;use &lt;code&gt;go install go_binary_url@latest&lt;/code&gt; Will force re-install if already installed, otherwise same as GoInstallBinary&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoInstallBinaries&lt;/td&gt; &#xA;   &lt;td&gt;use &lt;code&gt;go install&lt;/code&gt; to install all tools, skip the ones installed&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoUpdateBinaries&lt;/td&gt; &#xA;   &lt;td&gt;use &lt;code&gt;go install&lt;/code&gt; to update all tools to the latest version&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Build and test&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoMake&lt;/td&gt; &#xA;   &lt;td&gt;async make, use with other commands&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoBuild&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoGenerate&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoRun {args}&lt;/td&gt; &#xA;   &lt;td&gt;e.g. GoRun equal to &lt;code&gt;go run .&lt;/code&gt;; or &lt;code&gt;GoRun ./cmd&lt;/code&gt; equal to &lt;code&gt;go run ./cmd, Additional args: -F run in floaterm&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoStop {job_id}&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;stop the job started with GoRun&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTest&lt;/td&gt; &#xA;   &lt;td&gt;go test ./...&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTest -c&lt;/td&gt; &#xA;   &lt;td&gt;go test -c current_file_path&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTest -n&lt;/td&gt; &#xA;   &lt;td&gt;test nearest, see GoTestFunc&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTest -f&lt;/td&gt; &#xA;   &lt;td&gt;test current file, see GoTestFile&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTest -p&lt;/td&gt; &#xA;   &lt;td&gt;test current package, see GoTestPkg&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTest -t yourtags&lt;/td&gt; &#xA;   &lt;td&gt;go test ./... -tags=yourtags, see notes&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTest package_path -t yourtags&lt;/td&gt; &#xA;   &lt;td&gt;go test packagepath -tags=yourtags&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTest package_path -t yourtags other_args&lt;/td&gt; &#xA;   &lt;td&gt;go test packagepath -tags=yourtags other_args&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoLint&lt;/td&gt; &#xA;   &lt;td&gt;golangci-lint&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoGet {package_url}&lt;/td&gt; &#xA;   &lt;td&gt;go get package_url and restart gopls. Note1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoVet&lt;/td&gt; &#xA;   &lt;td&gt;go vet&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoCoverage&lt;/td&gt; &#xA;   &lt;td&gt;go test -coverprofile&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoCoverage -f coverage_file_name&lt;/td&gt; &#xA;   &lt;td&gt;load coverage file&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoCoverage {flags}&lt;/td&gt; &#xA;   &lt;td&gt;-t : toggle, -r: remove signs, -R remove sings from all files, -m show metrics&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTermClose&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;closes the floating term&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Note:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;if package_url not provided, will check current line is a valid package url or not, if it is valid, will fetch current url&lt;/li&gt; &#xA; &lt;li&gt;tags: if &lt;code&gt;//+build tags&lt;/code&gt; exist it will be added automatically&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Show test coverage:&lt;/p&gt; &#xA;&lt;img width=&#34;479&#34; alt=&#34;GoTestCoverage&#34; src=&#34;https://user-images.githubusercontent.com/1681295/130821038-fa2545c6-16f6-4448-9a0c-91a1ab333750.png&#34;&gt; &#xA;&lt;p&gt;Provided wrapper for gobulild/test etc with async make Also suggest to use &lt;a href=&#34;https://github.com/vim-test/vim-test&#34;&gt;vim-test&lt;/a&gt;, which can run running tests on different granularities.&lt;/p&gt; &#xA;&lt;h2&gt;Unit test with &lt;a href=&#34;https://github.com/cweill/gotests&#34;&gt;gotests&lt;/a&gt; and testify&lt;/h2&gt; &#xA;&lt;p&gt;Support table based unit test auto generate, parse current function/method name using treesitter&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTestFunc&lt;/td&gt; &#xA;   &lt;td&gt;run test for current func&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTestFunc -s&lt;/td&gt; &#xA;   &lt;td&gt;select the test function you want to run&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTestFunc -tags=yourtag&lt;/td&gt; &#xA;   &lt;td&gt;run test for current func with &lt;code&gt;-tags yourtag&lt;/code&gt; option&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTestFile&lt;/td&gt; &#xA;   &lt;td&gt;run test for current file&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTestFile -tags=yourtag&lt;/td&gt; &#xA;   &lt;td&gt;run test for current folder with &lt;code&gt;-tags yourtag&lt;/code&gt; option&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTestPkg&lt;/td&gt; &#xA;   &lt;td&gt;run test for current package/folder&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoTestPkg -tags=yourtag&lt;/td&gt; &#xA;   &lt;td&gt;run test for current folder with &lt;code&gt;-tags yourtag&lt;/code&gt; option&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoAddTest [-parallel]&lt;/td&gt; &#xA;   &lt;td&gt;Add test for current func&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoAddExpTest [-parallel]&lt;/td&gt; &#xA;   &lt;td&gt;Add tests for exported funcs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoAddAllTest [-parallel]&lt;/td&gt; &#xA;   &lt;td&gt;Add tests for all funcs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;GoTestXXX Arguments&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;arguments&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-v&lt;/td&gt; &#xA;   &lt;td&gt;verbose mode&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-c&lt;/td&gt; &#xA;   &lt;td&gt;compile&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-t&lt;/td&gt; &#xA;   &lt;td&gt;tags&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-b&lt;/td&gt; &#xA;   &lt;td&gt;bench&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-F&lt;/td&gt; &#xA;   &lt;td&gt;floaterm mode&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Note: For GoTestXXX You can add available arguments e.g. &lt;code&gt;GoTest -tags=integration ./internal/web -bench=. -count=1 -&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;GoCheat&lt;/h2&gt; &#xA;&lt;p&gt;Show cheat.sh for api in neovim new buffer. e.g. &lt;code&gt;GoCheat &lt;/code&gt;sort&lt;/p&gt; &#xA;&lt;h2&gt;GoDoc&lt;/h2&gt; &#xA;&lt;p&gt;Show go doc for api in neovim floating window. e.g. &lt;code&gt;GoDoc fmt.Println&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1681295/133886804-cc110fae-6fbf-4218-9c22-07fc9d6a64d2.jpg&#34; alt=&#34;Godoc&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;If no argument provided, fallback to lsp.hover()&lt;/p&gt; &#xA;&lt;h2&gt;GoPkgOutline&lt;/h2&gt; &#xA;&lt;p&gt;A symbole outline for all symbols (var, const, func, struct, interface etc) inside a package You can still use navigator or sidebar plugins (e.g. vista, symbols-outline) to check outline within a file. But it is more useful for go to check the symbols in a package, as those symbols are visuals inside package, also the method can be defined in different source file.&lt;/p&gt; &#xA;&lt;p&gt;Command format: GoPkgOutline {options} options: -f: show in floatwing window (default side panel, both require quihua.lua) -p package_name: the package you want to list. e.g. GoPkgOutline -p json; default package is current file&#39;s package If guihua not installed fallback to loclist&lt;/p&gt; &#xA;&lt;img width=&#34;902&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/1681295/175231905-82df4e4b-a508-4bb8-b878-9f0029643005.png&#34;&gt; &#xA;&lt;h2&gt;Modifytags&lt;/h2&gt; &#xA;&lt;p&gt;Modify struct tags by &lt;a href=&#34;https://github.com/fatih/gomodifytags&#34;&gt;&lt;code&gt;gomodifytags&lt;/code&gt;&lt;/a&gt; and treesitter&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoAddTag&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoRmTag&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoClearTag&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;GoFmt&lt;/h2&gt; &#xA;&lt;p&gt;nvim-lsp support goimport by default. The plugin provided a new formatter, goline + gofumpt (stricter version of gofmt)&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoFmt {opts}&lt;/td&gt; &#xA;   &lt;td&gt;goline + gofumpt&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoImport&lt;/td&gt; &#xA;   &lt;td&gt;goline + goimport + gofumpt&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoImport package_path&lt;/td&gt; &#xA;   &lt;td&gt;gopls add_import package&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;{opts} : &lt;code&gt;-a&lt;/code&gt; format all buffers&lt;/p&gt; &#xA;&lt;h2&gt;GoImpl&lt;/h2&gt; &#xA;&lt;p&gt;generate method stubs for implementing an interface&lt;/p&gt; &#xA;&lt;p&gt;Usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:GoImpl {receiver} {interface}&#xA;&#xA;Also you can put cursor on struct and run&#xA;&#xA;```vim&#xA;:GoImpl {interface}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:GoImpl f *File io.Reader&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or simply put your cursor in a struct and do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:GoImpl io.Reader&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Debug&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDebug&lt;/td&gt; &#xA;   &lt;td&gt;start debug session, Note 1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDebug -h&lt;/td&gt; &#xA;   &lt;td&gt;show helps info&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDebug -c&lt;/td&gt; &#xA;   &lt;td&gt;compile only&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDebug -t&lt;/td&gt; &#xA;   &lt;td&gt;start debug session for go test file, Note 2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDebug -R&lt;/td&gt; &#xA;   &lt;td&gt;restart debug session&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDebug -n&lt;/td&gt; &#xA;   &lt;td&gt;start debug session for nearest go test function&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDebug -p&lt;/td&gt; &#xA;   &lt;td&gt;launch package test and start debug&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDebug -a&lt;/td&gt; &#xA;   &lt;td&gt;attach to remote process&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDebug -s&lt;/td&gt; &#xA;   &lt;td&gt;stop debug session and unmap debug keymap&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDbgKeys&lt;/td&gt; &#xA;   &lt;td&gt;show debug keymaps in a floating window (guihua)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoBreakToggle&lt;/td&gt; &#xA;   &lt;td&gt;GoDebug -b&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDbgStop&lt;/td&gt; &#xA;   &lt;td&gt;Same as GoDebug -s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDbgContinue&lt;/td&gt; &#xA;   &lt;td&gt;Continue debug session&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;BreakCondition&lt;/td&gt; &#xA;   &lt;td&gt;conditional break&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Notes:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Without any argument, will check if launch.json existed or not, if existed, using launch.json and popup input. If launch.json not existed, will start debug session for current file, if current file is package main will run main(), else will start debug package test&lt;/li&gt; &#xA; &lt;li&gt;with -t option, if current file is not test file, will switch to test file and run test for current function&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Switch between go and test file&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoAlt / GoAlt!&lt;/td&gt; &#xA;   &lt;td&gt;open alternative go file (use ! to create if not exist)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoAltS / GoAltS!&lt;/td&gt; &#xA;   &lt;td&gt;open alternative go file in split&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoAltV / GoAltV!&lt;/td&gt; &#xA;   &lt;td&gt;open alternative go file in vertical split&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Comments and Doc&lt;/h2&gt; &#xA;&lt;p&gt;Auto doc (to suppress golang-lint warning), generate comments by treesitter parsing result&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type GoLintComplaining struct{}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt; lua.require(&#39;go.comment&#39;).gen() -- or your faviourite key binding and setup placeholder &#34;no more complaint ;P&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The code will be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// GoLintComplaining struct no more complaint ;P&#xA;type GoLintComplaining struct{}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoCmt&lt;/td&gt; &#xA;   &lt;td&gt;Add comment&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;GoModTidy&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoModInit&lt;/td&gt; &#xA;   &lt;td&gt;run &lt;code&gt;go mod init&lt;/code&gt; and restart gopls&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoModTidy&lt;/td&gt; &#xA;   &lt;td&gt;run &lt;code&gt;go mod tidy&lt;/code&gt; and restart gopls&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoModVendor&lt;/td&gt; &#xA;   &lt;td&gt;run &lt;code&gt;go mod vendor&lt;/code&gt; and restart gopls&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;run &lt;code&gt;go mod tidy&lt;/code&gt; and restart gopls&lt;/p&gt; &#xA;&lt;h2&gt;LSP&lt;/h2&gt; &#xA;&lt;p&gt;Nvim-lsp is good enough for a gopher. If you looking for a better GUI. You can install &lt;a href=&#34;https://github.com/ray-x/navigator.lua&#34;&gt;navigator&lt;/a&gt;, or lspsaga, and lsp-utils etc. The goal of go.nvim is more provide unique functions releated to gopls instead of a general lsp gui client. The lsp config in go.nvim has a none default setup and contains some improvement and I would suggest you to use.&lt;/p&gt; &#xA;&lt;h2&gt;LSP cmp support&lt;/h2&gt; &#xA;&lt;p&gt;The latest version enabled lsp snippets (and other setups) by default. In case you need flowing the setup from cmp README.md, please use flowing command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local capabilities = require(&#39;cmp_nvim_lsp&#39;).update_capabilities(vim.lsp.protocol.make_client_capabilities())&#xA;require(&#39;go&#39;).setup({&#xA;  -- other setups ....&#xA;  lsp_cfg = {&#xA;    capabilities = capabilities,&#xA;    -- other setups&#xA;  },&#xA;})&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;LSP CodeLens&lt;/h2&gt; &#xA;&lt;p&gt;Gopls supports code lens. To run gopls code lens action &lt;code&gt;GoCodeLenAct&lt;/code&gt; Note: codelens need to be enabled in gopls, check default config in&lt;/p&gt; &#xA;&lt;h2&gt;LSP CodeActions&lt;/h2&gt; &#xA;&lt;p&gt;You can use native code action provided by lspconfig. If you installed guihua, you can also use a GUI version of code action &lt;code&gt;GoCodeAction&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Lint&lt;/h2&gt; &#xA;&lt;p&gt;Supported by LSP, also GoLint command (by calling golangcl-lint) if you need background golangci-lint check, you can configure it with ALE&lt;/p&gt; &#xA;&lt;h2&gt;Debug with dlv&lt;/h2&gt; &#xA;&lt;p&gt;Setup for Debug provided. Need Dap and Dap UI plugin &lt;img src=&#34;https://user-images.githubusercontent.com/1681295/125160289-743ba080-e1bf-11eb-804f-6a6d227ec33b.jpg&#34; alt=&#34;dap&#34;&gt; GDB style key mapping is used&lt;/p&gt; &#xA;&lt;h3&gt;Keymaps&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;key&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;c&lt;/td&gt; &#xA;   &lt;td&gt;continue&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;n&lt;/td&gt; &#xA;   &lt;td&gt;next&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;s&lt;/td&gt; &#xA;   &lt;td&gt;step&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;o&lt;/td&gt; &#xA;   &lt;td&gt;stepout&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;S&lt;/td&gt; &#xA;   &lt;td&gt;cap S: stop debug&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;u&lt;/td&gt; &#xA;   &lt;td&gt;up&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;D&lt;/td&gt; &#xA;   &lt;td&gt;cap D: down&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;   &lt;td&gt;cap C: run to cursor&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;b&lt;/td&gt; &#xA;   &lt;td&gt;toggle breakpoint&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;P&lt;/td&gt; &#xA;   &lt;td&gt;cap P: pause&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;p&lt;/td&gt; &#xA;   &lt;td&gt;print, hover value (also in visual mode)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Moving from vscode-go debug&lt;/h3&gt; &#xA;&lt;p&gt;Please check &lt;a href=&#34;https://code.visualstudio.com/docs/editor/debugging#_launch-configurations&#34;&gt;Vscode Launch configurations&lt;/a&gt; for more info go.nvim support launch debuger from vscode-go .vscode/launch.json configurations If launch.json is valid, run &lt;code&gt;GoDebug&lt;/code&gt; will launch from the launch.json configuration.&lt;/p&gt; &#xA;&lt;h4&gt;Note:&lt;/h4&gt; &#xA;&lt;p&gt;Please use jsonls/null-ls check your launch.json is valid json file. Following syntax is not supported&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Trailing comma&lt;/li&gt; &#xA; &lt;li&gt;Comment&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here is a sample &lt;a href=&#34;https://github.com/ray-x/go.nvim/raw/master/playground/sampleApp/.vscode/launch.json&#34;&gt;launch.json&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Commands&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDebug&lt;/td&gt; &#xA;   &lt;td&gt;Start debugger, to debug test, run &lt;code&gt;GoDebug test&lt;/code&gt;, to add addition args run &lt;code&gt;GoDebug arg1 arg2&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoDebugConfig&lt;/td&gt; &#xA;   &lt;td&gt;Open launch.json file&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoBreakSave&lt;/td&gt; &#xA;   &lt;td&gt;save all breakpoints to project file&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoBreakLoad&lt;/td&gt; &#xA;   &lt;td&gt;load all breakpoints from project file&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GoBreakToggle&lt;/td&gt; &#xA;   &lt;td&gt;toggle break point&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;BreakCondition&lt;/td&gt; &#xA;   &lt;td&gt;conditional break point&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ReplRun&lt;/td&gt; &#xA;   &lt;td&gt;dap repl run_last&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ReplToggle&lt;/td&gt; &#xA;   &lt;td&gt;dap repl toggle&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Required DAP plugins&lt;/h3&gt; &#xA;&lt;p&gt;The plugin will setup debugger. But you need to install&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;dap&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&#39;mfussenegger/nvim-dap&#39;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;dap ui (optional)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&#39;rcarriga/nvim-dap-ui&#39;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;dap virtual text (optional)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&#39;theHamsta/nvim-dap-virtual-text&#39;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also you can check telescope dap extension : nvim-telescope/telescope-dap.nvim&lt;/p&gt; &#xA;&lt;p&gt;Sample vimrc for DAP&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-viml&#34;&gt; Plug &#39;mfussenegger/nvim-dap&#39;&#xA; Plug &#39;rcarriga/nvim-dap-ui&#39;&#xA; Plug &#39;theHamsta/nvim-dap-virtual-text&#39;&#xA; &#34; Plug &#39;nvim-telescope/telescope-dap.nvim&#39;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Commands&lt;/h2&gt; &#xA;&lt;p&gt;Check &lt;a href=&#34;https://github.com/ray-x/go.nvim/raw/master/lua/go.lua&#34;&gt;go.lua&lt;/a&gt; on all the commands provided&lt;/p&gt; &#xA;&lt;h2&gt;configuration&lt;/h2&gt; &#xA;&lt;p&gt;Configure from lua suggested, The default setup:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;go&#39;).setup({&#xA;  go=&#39;go&#39;, -- go command, can be go[default] or go1.18beta1&#xA;  goimport=&#39;gopls&#39;, -- goimport command, can be gopls[default] or goimport&#xA;  fillstruct = &#39;gopls&#39;, -- can be nil (use fillstruct, slower) and gopls&#xA;  gofmt = &#39;gofumpt&#39;, --gofmt cmd,&#xA;  max_line_len = 120, -- max line length in goline format&#xA;  tag_transform = false, -- can be transform option(&#34;snakecase&#34;, &#34;camelcase&#34;, etc) check gomodifytags for details and more options&#xA;  gotests_template = &#34;&#34;, -- sets gotests -template parameter (check gotests for details)&#xA;  gotests_template_dir = &#34;&#34;, -- sets gotests -template_dir parameter (check gotests for details)&#xA;  comment_placeholder = &#39;&#39; ,  -- comment_placeholder your cool placeholder e.g. ﳑ       &#xA;  icons = {breakpoint = &#39;🧘&#39;, currentpos = &#39;🏃&#39;},  -- setup to `false` to disable icons setup&#xA;  verbose = false,  -- output loginf in messages&#xA;  lsp_cfg = false, -- true: use non-default gopls setup specified in go/lsp.lua&#xA;                   -- false: do nothing&#xA;                   -- if lsp_cfg is a table, merge table with with non-default gopls setup in go/lsp.lua, e.g.&#xA;                   --   lsp_cfg = {settings={gopls={matcher=&#39;CaseInsensitive&#39;, [&#39;local&#39;] = &#39;your_local_module_path&#39;, gofumpt = true }}}&#xA;  lsp_gofumpt = false, -- true: set default gofmt in gopls format to gofumpt&#xA;  lsp_on_attach = nil, -- nil: use on_attach function defined in go/lsp.lua,&#xA;                       --      when lsp_cfg is true&#xA;                       -- if lsp_on_attach is a function: use this function as on_attach function for gopls&#xA;  lsp_keymaps = true, -- set to false to disable gopls/lsp keymap&#xA;  lsp_codelens = true, -- set to false to disable codelens, true by default, you can use a function&#xA;  -- function(bufnr)&#xA;  --    vim.api.nvim_buf_set_keymap(bufnr, &#34;n&#34;, &#34;&amp;lt;space&amp;gt;F&#34;, &#34;&amp;lt;cmd&amp;gt;lua vim.lsp.buf.formatting()&amp;lt;CR&amp;gt;&#34;, {noremap=true, silent=true})&#xA;  -- end&#xA;  -- to setup a table of codelens&#xA;  lsp_diag_hdlr = true, -- hook lsp diag handler&#xA;  -- virtual text setup&#xA;  lsp_diag_virtual_text = { space = 0, prefix = &#34;&#34; },&#xA;  lsp_diag_signs = true,&#xA;  lsp_diag_update_in_insert = false,&#xA;  lsp_document_formatting = true,&#xA;  -- set to true: use gopls to format&#xA;  -- false if you want to use other formatter tool(e.g. efm, nulls)&#xA;  gopls_cmd = nil, -- if you need to specify gopls path and cmd, e.g {&#34;/home/user/lsp/gopls&#34;, &#34;-logfile&#34;,&#34;/var/log/gopls.log&#34; }&#xA;  gopls_remote_auto = true, -- add -remote=auto to gopls&#xA;  dap_debug = true, -- set to false to disable dap&#xA;  dap_debug_keymap = true, -- true: use keymap for debugger defined in go/dap.lua&#xA;                           -- false: do not use keymap in go/dap.lua.  you must define your own.&#xA;                           -- windows: use visual studio keymap&#xA;  dap_debug_gui = true, -- set to true to enable dap gui, highly recommand&#xA;  dap_debug_vt = true, -- set to true to enable dap virtual text&#xA;  build_tags = &#34;tag1,tag2&#34;, -- set default build tags&#xA;  textobjects = true, -- enable default text jobects through treesittter-text-objects&#xA;  test_runner = &#39;go&#39;, -- one of {`go`, `richgo`, `dlv`, `ginkgo`}&#xA;  verbose_tests = true, -- set to add verbose flag to tests&#xA;  run_in_floaterm = false, -- set to true to run in float window. :GoTermClose closes the floatterm&#xA;                           -- float term recommand if you use richgo/ginkgo with terminal color&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will need to add keybind yourself: e.g&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;  vim.cmd(&#34;autocmd FileType go nmap &amp;lt;Leader&amp;gt;&amp;lt;Leader&amp;gt;l GoLint&#34;)&#xA;  vim.cmd(&#34;autocmd FileType go nmap &amp;lt;Leader&amp;gt;gc :lua require(&#39;go.comment&#39;).gen()&#34;)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Project setup&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;go.nvim&lt;/code&gt; allow you override your setup by a project file. Put &lt;code&gt;.gonvim/init.lua&lt;/code&gt; in your root folder. It is a small lua script and will be run durning go.setup(). The return value is used to override &lt;code&gt;go.nvim&lt;/code&gt; setup. The sample project setup. You can check the &lt;a href=&#34;https://www.youtube.com/watch?v=XrxSUp0E9Qw&#34;&gt;youtube video here&lt;/a&gt; on how to use this feature.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- .gonvim/init.lua project config&#xA;vim.g.null_ls_disable = true&#xA;&#xA;return {&#xA;  go = &#34;go&#34;, -- set to go1.18beta1 if necessary&#xA;  goimport = &#34;gopls&#34;, -- if set to &#39;gopls&#39; will use gopls format, also goimport&#xA;  fillstruct = &#34;gopls&#34;,&#xA;  gofmt = &#34;gofumpt&#34;, -- if set to gopls will use gopls format&#xA;  max_line_len = 120&#xA;  null_ls_document_formatting_disable = true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will override your global &lt;code&gt;go.nvim&lt;/code&gt; setup&lt;/p&gt; &#xA;&lt;h2&gt;Text object&lt;/h2&gt; &#xA;&lt;p&gt;I did not provide textobject support in the plugin. Please use treesitter textobject plugin. My treesitter config:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;  require &#34;nvim-treesitter.configs&#34;.setup {&#xA;    incremental_selection = {&#xA;      enable = enable,&#xA;      keymaps = {&#xA;        -- mappings for incremental selection (visual mappings)&#xA;        init_selection = &#34;gnn&#34;, -- maps in normal mode to init the node/scope selection&#xA;        node_incremental = &#34;grn&#34;, -- increment to the upper named parent&#xA;        scope_incremental = &#34;grc&#34;, -- increment to the upper scope (as defined in locals.scm)&#xA;        node_decremental = &#34;grm&#34; -- decrement to the previous node&#xA;      }&#xA;    },&#xA;&#xA;    textobjects = {&#xA;      -- syntax-aware textobjects&#xA;      enable = enable,&#xA;      lsp_interop = {&#xA;        enable = enable,&#xA;        peek_definition_code = {&#xA;          [&#34;DF&#34;] = &#34;@function.outer&#34;,&#xA;          [&#34;DF&#34;] = &#34;@class.outer&#34;&#xA;        }&#xA;      },&#xA;      keymaps = {&#xA;        [&#34;iL&#34;] = {&#xA;          -- you can define your own textobjects directly here&#xA;          go = &#34;(function_definition) @function&#34;,&#xA;        },&#xA;        -- or you use the queries from supported languages with textobjects.scm&#xA;        [&#34;af&#34;] = &#34;@function.outer&#34;,&#xA;        [&#34;if&#34;] = &#34;@function.inner&#34;,&#xA;        [&#34;aC&#34;] = &#34;@class.outer&#34;,&#xA;        [&#34;iC&#34;] = &#34;@class.inner&#34;,&#xA;        [&#34;ac&#34;] = &#34;@conditional.outer&#34;,&#xA;        [&#34;ic&#34;] = &#34;@conditional.inner&#34;,&#xA;        [&#34;ae&#34;] = &#34;@block.outer&#34;,&#xA;        [&#34;ie&#34;] = &#34;@block.inner&#34;,&#xA;        [&#34;al&#34;] = &#34;@loop.outer&#34;,&#xA;        [&#34;il&#34;] = &#34;@loop.inner&#34;,&#xA;        [&#34;is&#34;] = &#34;@statement.inner&#34;,&#xA;        [&#34;as&#34;] = &#34;@statement.outer&#34;,&#xA;        [&#34;ad&#34;] = &#34;@comment.outer&#34;,&#xA;        [&#34;am&#34;] = &#34;@call.outer&#34;,&#xA;        [&#34;im&#34;] = &#34;@call.inner&#34;&#xA;      },&#xA;      move = {&#xA;        enable = enable,&#xA;        set_jumps = true, -- whether to set jumps in the jumplist&#xA;        goto_next_start = {&#xA;          [&#34;]m&#34;] = &#34;@function.outer&#34;,&#xA;          [&#34;]]&#34;] = &#34;@class.outer&#34;&#xA;        },&#xA;        goto_next_end = {&#xA;          [&#34;]M&#34;] = &#34;@function.outer&#34;,&#xA;          [&#34;][&#34;] = &#34;@class.outer&#34;&#xA;        },&#xA;        goto_previous_start = {&#xA;          [&#34;[m&#34;] = &#34;@function.outer&#34;,&#xA;          [&#34;[[&#34;] = &#34;@class.outer&#34;&#xA;        },&#xA;        goto_previous_end = {&#xA;          [&#34;[M&#34;] = &#34;@function.outer&#34;,&#xA;          [&#34;[]&#34;] = &#34;@class.outer&#34;&#xA;        }&#xA;      },&#xA;      select = {&#xA;        enable = enable,&#xA;        keymaps = {&#xA;          -- You can use the capture groups defined in textobjects.scm&#xA;          [&#34;af&#34;] = &#34;@function.outer&#34;,&#xA;          [&#34;if&#34;] = &#34;@function.inner&#34;,&#xA;          [&#34;ac&#34;] = &#34;@class.outer&#34;,&#xA;          [&#34;ic&#34;] = &#34;@class.inner&#34;,&#xA;          -- Or you can define your own textobjects like this&#xA;          [&#34;iF&#34;] = {&#xA;            python = &#34;(function_definition) @function&#34;,&#xA;            cpp = &#34;(function_definition) @function&#34;,&#xA;            c = &#34;(function_definition) @function&#34;,&#xA;            java = &#34;(method_declaration) @function&#34;,&#xA;            go = &#34;(method_declaration) @function&#34;&#xA;          }&#xA;        }&#xA;      },&#xA;      swap = {&#xA;        enable = enable,&#xA;        swap_next = {&#xA;          [&#34;&amp;lt;leader&amp;gt;a&#34;] = &#34;@parameter.inner&#34;&#xA;        },&#xA;        swap_previous = {&#xA;          [&#34;&amp;lt;leader&amp;gt;A&#34;] = &#34;@parameter.inner&#34;&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Nvim LSP setup&lt;/h2&gt; &#xA;&lt;p&gt;go.nvim provided a better non-default setup for gopls (includes debounce, staticcheck, diagnosticsDelay etc)&lt;/p&gt; &#xA;&lt;p&gt;This gopls setup provided by go.nvim works perfectly fine for most of the cases. You can also install &lt;a href=&#34;https://github.com/ray-x/navigator.lua&#34;&gt;navigator.lua&lt;/a&gt; which can auto setup all lsp clients and provides a better GUI.&lt;/p&gt; &#xA;&lt;p&gt;For diagnostic issue, you can use the default setup. There are also quite a few plugins that you can use to explore issues, e.g. &lt;a href=&#34;https://github.com/ray-x/navigator.lua&#34;&gt;navigator.lua&lt;/a&gt;, &lt;a href=&#34;https://github.com/folke/lsp-trouble.nvim&#34;&gt;folke/lsp-trouble.nvim&lt;/a&gt;. &lt;a href=&#34;https://github.com/kyazdani42/nvim-tree.lua&#34;&gt;Nvim-tree&lt;/a&gt; and &lt;a href=&#34;https://github.com/akinsho/nvim-bufferline.lua&#34;&gt;Bufferline&lt;/a&gt; also introduced lsp diagnostic hooks.&lt;/p&gt; &#xA;&lt;h2&gt;Integrate with nvim-lsp-installer&lt;/h2&gt; &#xA;&lt;p&gt;(suggested by @mattbailey)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local path = require &#39;nvim-lsp-installer.core.path&#39;&#xA;local install_root_dir = path.concat {vim.fn.stdpath &#39;data&#39;, &#39;lsp_servers&#39;}&#xA;&#xA;require(&#39;go&#39;).setup({&#xA;  gopls_cmd = {install_root_dir .. &#39;/go/gopls&#39;},&#xA;  fillstruct = &#39;gopls&#39;,&#xA;  dap_debug = true,&#xA;  dap_debug_gui = true&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use gopls setup provided by go.nvim&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;&#xA;-- setup your go.nvim&#xA;-- make sure lsp_cfg is disabled&#xA;require(&#39;go&#39;).setup{...}&#xA;&#xA;local lsp_installer_servers = require&#39;nvim-lsp-installer.servers&#39;&#xA;&#xA;local server_available, requested_server = lsp_installer_servers.get_server(&#34;gopls&#34;)&#xA;if server_available then&#xA;    requested_server:on_ready(function ()&#xA;        local opts = require&#39;go.lsp&#39;.config() -- config() return the go.nvim gopls setup&#xA;        requested_server:setup(opts)&#xA;    end)&#xA;    if not requested_server:is_installed() then&#xA;        -- Queue the server to be installed&#xA;        requested_server:install()&#xA;    end&#xA;end&#xA;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Sample vimrc&lt;/h2&gt; &#xA;&lt;p&gt;The following vimrc will enable all features provided by go.nvim&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-viml&#34;&gt;set termguicolors&#xA;call plug#begin(&#39;~/.vim/plugged&#39;)&#xA;Plug &#39;neovim/nvim-lspconfig&#39;&#xA;Plug &#39;nvim-treesitter/nvim-treesitter&#39;&#xA;&#xA;Plug &#39;mfussenegger/nvim-dap&#39;&#xA;Plug &#39;rcarriga/nvim-dap-ui&#39;&#xA;Plug &#39;theHamsta/nvim-dap-virtual-text&#39;&#xA;Plug &#39;ray-x/guihua.lua&#39; &#34; float term, codeaction and codelens gui support&#xA;&#xA;Plug &#39;ray-x/go.nvim&#39;&#xA;&#xA;call plug#end()&#xA;&#xA;lua &amp;lt;&amp;lt;EOF&#xA;require &#39;go&#39;.setup({&#xA;  goimport = &#39;gopls&#39;, -- if set to &#39;gopls&#39; will use golsp format&#xA;  gofmt = &#39;gopls&#39;, -- if set to gopls will use golsp format&#xA;  max_line_len = 120,&#xA;  tag_transform = false,&#xA;  test_dir = &#39;&#39;,&#xA;  comment_placeholder = &#39;   &#39;,&#xA;  lsp_cfg = true, -- false: use your own lspconfig&#xA;  lsp_gofumpt = true, -- true: set default gofmt in gopls format to gofumpt&#xA;  lsp_on_attach = true, -- use on_attach from go.nvim&#xA;  dap_debug = true,&#xA;})&#xA;&#xA;local protocol = require&#39;vim.lsp.protocol&#39;&#xA;&#xA;EOF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will setup gopls with non default configure provided by go.nvim (Includes lspconfig default keymaps)&lt;/p&gt; &#xA;&lt;h2&gt;Q &amp;amp; A:&lt;/h2&gt; &#xA;&lt;p&gt;Q: What is &lt;code&gt;Toggle gc annotation details&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: This is a codelens message, please run codelens &lt;code&gt;GoCodeLenAct&lt;/code&gt; and get more info&lt;/p&gt;</summary>
  </entry>
</feed>