<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-24T01:40:55Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tjdevries/sPoNGe-BoB.NvIm</title>
    <updated>2023-06-24T01:40:55Z</updated>
    <id>tag:github.com,2023-06-24:/tjdevries/sPoNGe-BoB.NvIm</id>
    <link href="https://github.com/tjdevries/sPoNGe-BoB.NvIm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The most important plugin you&#39;ll ever install&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;sPoNGe-BoB.NvIm&lt;/h1&gt; &#xA;&lt;p&gt;dO YoU EveR JuSt wAnT To tYpE StUfF LiKe tHiS aNd iT&#39;S A BiT ToO AnOyInG To bE AbLe tO AcTuAlLy WrItE It?&lt;/p&gt; &#xA;&lt;p&gt;wElL, i kNeW It wOuLd bE EaSy tO Do tHiS In nEoViM sO I FiNaLlY DiD iT.&lt;/p&gt; &#xA;&lt;p&gt;YoU CaN JuSt rUn &lt;code&gt;:SpOnGeBoBtOgGlE&lt;/code&gt; tO ToGgLe iNsErT mOde fLiPpInG Of yOuR EvErY ChArAcTeR.&lt;/p&gt; &#xA;&lt;p&gt;PlEaSe eNjOy, AnD DoN&#39;T FOrGeT To lEaVe a sTaR fOr SuCh iNnOvAtIvE PlUgInS.&lt;/p&gt; &#xA;&lt;p&gt;We mAdE ThIs pLuGiN &lt;strong&gt;lIvE&lt;/strong&gt; On tWiTcH!!!!&lt;/p&gt; &#xA;&lt;p&gt;tWiTcH.Tv/tEeJ_Dv&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>folke/flash.nvim</title>
    <updated>2023-06-24T01:40:55Z</updated>
    <id>tag:github.com,2023-06-24:/folke/flash.nvim</id>
    <link href="https://github.com/folke/flash.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Navigate your code with search labels, enhanced character motions and Treesitter integration&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;‚ö°flash.nvim&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;flash.nvim&lt;/code&gt; lets you navigate your code with search labels, enhanced character motions, and Treesitter integration.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Search Integration&lt;/th&gt; &#xA;   &lt;th&gt;Standalone Jump&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://github.com/folke/flash.nvim/assets/292349/e0ac4cbc-fa54-4505-8261-43ec0505518d&#34;&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://github.com/folke/flash.nvim/assets/292349/90af85e3-3f22-4c51-af4b-2a2488c9560b&#34;&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;code&gt;f&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;Treesitter&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://github.com/folke/flash.nvim/assets/292349/379cb2de-8ec3-4acf-8811-d3590a5854b6&#34;&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://github.com/folke/flash.nvim/assets/292349/b963b05e-3d28-45ff-b43a-928a06e5f92a&#34;&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h2&gt;‚ú® Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üîç &lt;strong&gt;Search Integration&lt;/strong&gt;: integrate &lt;strong&gt;flash.nvim&lt;/strong&gt; with your regular search using &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;. Labels appear next to the matches, allowing you to quickly jump to any location. Labels are guaranteed not to exist as a continuation of the search pattern.&lt;/li&gt; &#xA; &lt;li&gt;‚å®Ô∏è &lt;strong&gt;type as many characters as you want&lt;/strong&gt; before using a jump label.&lt;/li&gt; &#xA; &lt;li&gt;‚ö° &lt;strong&gt;Enhanced &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; motions&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;üå≥ &lt;strong&gt;Treesitter Integration&lt;/strong&gt;: all parents of the Treesitter node under your cursor are highlighted with a label for quick selection of a specific Treesitter node.&lt;/li&gt; &#xA; &lt;li&gt;üéØ &lt;strong&gt;Jump Mode&lt;/strong&gt;: a standalone jumping mode similar to search&lt;/li&gt; &#xA; &lt;li&gt;üîé &lt;strong&gt;Search Modes&lt;/strong&gt;: &lt;code&gt;exact&lt;/code&gt;, &lt;code&gt;search&lt;/code&gt; (regex), and &lt;code&gt;fuzzy&lt;/code&gt; search modes&lt;/li&gt; &#xA; &lt;li&gt;ü™ü &lt;strong&gt;Multi Window&lt;/strong&gt; jumping&lt;/li&gt; &#xA; &lt;li&gt;üåê &lt;strong&gt;Remote Actions&lt;/strong&gt;: perform motions in remote locations&lt;/li&gt; &#xA; &lt;li&gt;‚ö´ &lt;strong&gt;dot-repeatable&lt;/strong&gt; jumps&lt;/li&gt; &#xA; &lt;li&gt;üì° &lt;strong&gt;highly extensible&lt;/strong&gt;: check the &lt;a href=&#34;https://github.com/folke/flash.nvim#-examples&#34;&gt;examples&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üìã Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Neovim &amp;gt;= &lt;strong&gt;0.8.0&lt;/strong&gt; (needs to be built with &lt;strong&gt;LuaJIT&lt;/strong&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üì¶ Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install the plugin with your preferred package manager:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/folke/lazy.nvim&#34;&gt;lazy.nvim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  &#34;folke/flash.nvim&#34;,&#xA;  event = &#34;VeryLazy&#34;,&#xA;  ---@type Flash.Config&#xA;  opts = {},&#xA;  keys = {&#xA;    {&#xA;      &#34;s&#34;,&#xA;      mode = { &#34;n&#34;, &#34;x&#34;, &#34;o&#34; },&#xA;      function()&#xA;        -- default options: exact mode, multi window, all directions, with a backdrop&#xA;        require(&#34;flash&#34;).jump()&#xA;      end,&#xA;      desc = &#34;Flash&#34;,&#xA;    },&#xA;    {&#xA;      &#34;S&#34;,&#xA;      mode = { &#34;n&#34;, &#34;o&#34;, &#34;x&#34; },&#xA;      function()&#xA;        require(&#34;flash&#34;).treesitter()&#xA;      end,&#xA;      desc = &#34;Flash Treesitter&#34;,&#xA;    },&#xA;    {&#xA;      &#34;r&#34;,&#xA;      mode = &#34;o&#34;,&#xA;      function()&#xA;        require(&#34;flash&#34;).remote()&#xA;      end,&#xA;      desc = &#34;Remote Flash&#34;,&#xA;    },&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;‚öôÔ∏è Configuration&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;flash.nvim&lt;/strong&gt; is highly configurable. Please refer to the default settings below.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Default Settings&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  -- labels = &#34;abcdefghijklmnopqrstuvwxyz&#34;,&#xA;  labels = &#34;asdfghjklqwertyuiopzxcvbnm&#34;,&#xA;  search = {&#xA;    -- search/jump in all windows&#xA;    multi_window = true,&#xA;    -- search direction&#xA;    forward = true,&#xA;    -- when `false`, find only matches in the given direction&#xA;    wrap = true,&#xA;    ---@type Flash.Pattern.Mode&#xA;    -- Each mode will take ignorecase and smartcase into account.&#xA;    -- * exact: exact match&#xA;    -- * search: regular search&#xA;    -- * fuzzy: fuzzy search&#xA;    -- * fun(str): custom function that returns a pattern&#xA;    --   For example, to only match at the beginning of a word:&#xA;    --   mode = function(str)&#xA;    --     return &#34;\\&amp;lt;&#34; .. str&#xA;    --   end,&#xA;    mode = &#34;exact&#34;,&#xA;    -- behave like `incsearch`&#xA;    incremental = false,&#xA;    -- Excluded filetypes and custom window filters&#xA;    ---@type (string|fun(win:window))[]&#xA;    exclude = {&#xA;      &#34;notify&#34;,&#xA;      &#34;noice&#34;,&#xA;      &#34;cmp_menu&#34;,&#xA;      function(win)&#xA;        -- exclude non-focusable windows&#xA;        return not vim.api.nvim_win_get_config(win).focusable&#xA;      end,&#xA;    },&#xA;    -- Optional trigger character that needs to be typed before&#xA;    -- a jump label can be used. It&#39;s NOT recommended to set this,&#xA;    -- unless you know what you&#39;re doing&#xA;    trigger = &#34;&#34;,&#xA;  },&#xA;  jump = {&#xA;    -- save location in the jumplist&#xA;    jumplist = true,&#xA;    -- jump position&#xA;    pos = &#34;start&#34;, ---@type &#34;start&#34; | &#34;end&#34; | &#34;range&#34;&#xA;    -- add pattern to search history&#xA;    history = false,&#xA;    -- add pattern to search register&#xA;    register = false,&#xA;    -- clear highlight after jump&#xA;    nohlsearch = false,&#xA;    -- automatically jump when there is only one match&#xA;    autojump = false,&#xA;  },&#xA;  highlight = {&#xA;    label = {&#xA;      -- add a label for the first match in the current window.&#xA;      -- you can always jump to the first match with `&amp;lt;CR&amp;gt;`&#xA;      current = true,&#xA;      -- show the label after the match&#xA;      after = true, ---@type boolean|number[]&#xA;      -- show the label before the match&#xA;      before = false, ---@type boolean|number[]&#xA;      -- position of the label extmark&#xA;      style = &#34;overlay&#34;, ---@type &#34;eol&#34; | &#34;overlay&#34; | &#34;right_align&#34; | &#34;inline&#34;&#xA;      -- flash tries to re-use labels that were already assigned to a position,&#xA;      -- when typing more characters. By default only lower-case labels are re-used.&#xA;      reuse = &#34;lowercase&#34;, ---@type &#34;lowercase&#34; | &#34;all&#34;&#xA;    },&#xA;    -- show a backdrop with hl FlashBackdrop&#xA;    backdrop = true,&#xA;    -- Highlight the search matches&#xA;    matches = true,&#xA;    -- extmark priority&#xA;    priority = 5000,&#xA;    groups = {&#xA;      match = &#34;FlashMatch&#34;,&#xA;      current = &#34;FlashCurrent&#34;,&#xA;      backdrop = &#34;FlashBackdrop&#34;,&#xA;      label = &#34;FlashLabel&#34;,&#xA;    },&#xA;  },&#xA;  -- action to perform when picking a label.&#xA;  -- defaults to the jumping logic depending on the mode.&#xA;  ---@type fun(match:Flash.Match, state:Flash.State)|nil&#xA;  action = nil,&#xA;  -- initial pattern to use when opening flash&#xA;  pattern = &#34;&#34;,&#xA;  -- You can override the default options for a specific mode.&#xA;  -- Use it with `require(&#34;flash&#34;).jump({mode = &#34;forward&#34;})`&#xA;  ---@type table&amp;lt;string, Flash.Config&amp;gt;&#xA;  modes = {&#xA;    -- options used when flash is activated through&#xA;    -- a regular search with `/` or `?`&#xA;    search = {&#xA;      enabled = true, -- enable flash for search&#xA;      highlight = { backdrop = false },&#xA;      jump = { history = true, register = true, nohlsearch = true },&#xA;      search = {&#xA;        -- `forward` will be automatically set to the search direction&#xA;        -- `mode` is always set to `search`&#xA;        -- `incremental` is set to `true` when `incsearch` is enabled&#xA;      },&#xA;    },&#xA;    -- options used when flash is activated through&#xA;    -- `f`, `F`, `t`, `T`, `;` and `,` motions&#xA;    char = {&#xA;      enabled = true,&#xA;      -- by default all keymaps are enabled, but you can disable some of them,&#xA;      -- by removing them from the list.&#xA;      keys = { &#34;f&#34;, &#34;F&#34;, &#34;t&#34;, &#34;T&#34;, &#34;;&#34;, &#34;,&#34; },&#xA;      search = { wrap = false },&#xA;      highlight = { backdrop = true },&#xA;      jump = { register = false },&#xA;    },&#xA;    -- options used for treesitter selections&#xA;    -- `require(&#34;flash&#34;).treesitter()`&#xA;    treesitter = {&#xA;      labels = &#34;abcdefghijklmnopqrstuvwxyz&#34;,&#xA;      jump = { pos = &#34;range&#34; },&#xA;      highlight = {&#xA;        label = { before = true, after = true, style = &#34;inline&#34; },&#xA;        backdrop = false,&#xA;        matches = false,&#xA;      },&#xA;    },&#xA;    -- options used for remote flash&#xA;    remote = {}&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;üöÄ Usage&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Treesitter&lt;/strong&gt;: &lt;code&gt;require(&#34;flash&#34;).treesitter(opts?)&lt;/code&gt; opens &lt;strong&gt;flash&lt;/strong&gt; in &lt;strong&gt;Treesitter&lt;/strong&gt; mode &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;use a jump label, or use &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;,&lt;/code&gt; to increase/decrease the selection&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;regular search&lt;/strong&gt;: search as you normally do, but enhanced with jump labels&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;f&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; motions: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;After typing &lt;code&gt;f{char}&lt;/code&gt; or &lt;code&gt;F{char},&lt;/code&gt; you can repeat the motion with &lt;code&gt;f&lt;/code&gt; or go to the previous match with &lt;code&gt;F&lt;/code&gt; to undo a jump.&lt;/li&gt; &#xA;   &lt;li&gt;Similarly, after typing &lt;code&gt;t{char}&lt;/code&gt; or &lt;code&gt;T{char},&lt;/code&gt; you can repeat the motion with &lt;code&gt;t&lt;/code&gt; or go to the previous match with &lt;code&gt;T&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;You can also go to the next match with &lt;code&gt;;&lt;/code&gt; or previous match with &lt;code&gt;,&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Any highlights clear automatically when moving, changing buffers, or pressing &lt;code&gt;&amp;lt;esc&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;remote&lt;/strong&gt;: &lt;code&gt;require(&#34;flash&#34;).remote(opts?)&lt;/code&gt; opens &lt;strong&gt;flash&lt;/strong&gt; in &lt;strong&gt;remote&lt;/strong&gt; mode &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;this is only useful in operator pending mode.&lt;/li&gt; &#xA;   &lt;li&gt;For example, press &lt;code&gt;yr&lt;/code&gt; to start yanking and open flash &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;select a label to set the cursor position&lt;/li&gt; &#xA;     &lt;li&gt;perform any motion, like &lt;code&gt;iw&lt;/code&gt; or even start flash Treesitter with &lt;code&gt;S&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;the yank will be performed on the new selection&lt;/li&gt; &#xA;     &lt;li&gt;you&#39;ll be back in the original window / position&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;jump&lt;/strong&gt;: &lt;code&gt;require(&#34;flash&#34;).jump(opts?)&lt;/code&gt; opens &lt;strong&gt;flash&lt;/strong&gt; with the given options &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;type any number of characters before typing a jump label&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üì° API&lt;/h2&gt; &#xA;&lt;p&gt;The options for &lt;code&gt;require(&#34;flash&#34;).jump(opts?)&lt;/code&gt;, are the same as those in the config section, but can additionally have the following fields:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;matcher&lt;/code&gt;: a custom function that generates matches for a given window&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;labeler&lt;/code&gt;: a custom function to label matches&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can also add labels in the &lt;code&gt;matcher&lt;/code&gt; function and then set &lt;code&gt;labeler&lt;/code&gt; to an empty function &lt;code&gt;labeler = function() end&lt;/code&gt;&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Type Definitions&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;type FlashMatcher = (win: number, state: FlashState) =&amp;gt; FlashMatch[];&#xA;type FlashLabeler = (matches: FlashMatch[], state: FlashState) =&amp;gt; void;&#xA;&#xA;interface FlashMatch {&#xA;  win: number;&#xA;  pos: [number, number]; // (1,0)-indexed&#xA;  end_pos: [number, number]; // (1,0)-indexed&#xA;  label?: string;&#xA;}&#xA;&#xA;// Check the code for the full definition&#xA;// of Flash.State at `lua/flash/state.lua`&#xA;type FlashState = {};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;üí° Examples&lt;/h2&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Forward search only&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  search = { forward = true, wrap = false, multi_window = false },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Backward search only&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  search = { forward = false, wrap = false, multi_window = false },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Show diagnostics at target, without changing cursor position&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  action = function(match, state)&#xA;    vim.api.nvim_win_call(match.win, function()&#xA;      vim.api.nvim_win_set_cursor(match.win, match.pos)&#xA;      vim.diagnostic.open_float()&#xA;      vim.api.nvim_win_set_cursor(match.win, state.pos)&#xA;    end)&#xA;  end,&#xA;})&#xA;&#xA;-- More advanced example that also highlights diagnostics:&#xA;require(&#34;flash&#34;).jump({&#xA;  matcher = function(win)&#xA;    ---@param diag Diagnostic&#xA;    return vim.tbl_map(function(diag)&#xA;      return {&#xA;        pos = { diag.lnum + 1, diag.col },&#xA;        end_pos = { diag.end_lnum + 1, diag.end_col - 1 },&#xA;      }&#xA;    end, vim.diagnostic.get(vim.api.nvim_win_get_buf(win)))&#xA;  end,&#xA;  action = function(match, state)&#xA;    vim.api.nvim_win_call(match.win, function()&#xA;      vim.api.nvim_win_set_cursor(match.win, match.pos)&#xA;      vim.diagnostic.open_float()&#xA;      vim.api.nvim_win_set_cursor(match.win, state.pos)&#xA;    end)&#xA;  end,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Match beginning of words only&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  search = {&#xA;    mode = function(str)&#xA;      return &#34;\\&amp;lt;&#34; .. str&#xA;    end,&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Initialize flash with the word under the cursor&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  pattern = vim.fn.expand(&#34;&amp;lt;cword&amp;gt;&#34;),&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Jump to a line&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  search = { mode = &#34;search&#34; },&#xA;  highlight = { label = { after = { 0, 0 } } },&#xA;  pattern = &#34;^&#34;&#xA;})&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Select any word&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  pattern = &#34;.&#34;, -- initialize pattern with any char&#xA;  search = {&#xA;    mode = function(pattern)&#xA;      -- remove leading dot&#xA;      if pattern:sub(1, 1) == &#34;.&#34; then&#xA;        pattern = pattern:sub(2)&#xA;      end&#xA;      -- return word pattern and proper skip pattern&#xA;      return ([[\v&amp;lt;%s\w*&amp;gt;]]):format(pattern), ([[\v&amp;lt;%s]]):format(pattern)&#xA;    end,&#xA;  },&#xA;  -- select the range&#xA;  jump = { pos = &#34;range&#34; },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Jump to a position, make a Treesitter selection and jump back&lt;/summary&gt; &#xA; &lt;p&gt;This should be bound to a keymap like &lt;code&gt;&amp;lt;leader&amp;gt;t&lt;/code&gt;. Then you could do &lt;code&gt;y&amp;lt;leader&amp;gt;t&lt;/code&gt; to remotely yank a Treesitter selection.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.keymap.set({ &#34;n&#34;, &#34;x&#34;, &#34;o&#34; }, &#34;&amp;lt;leader&amp;gt;t&#34;, function()&#xA;  local win = vim.api.nvim_get_current_win()&#xA;  local view = vim.fn.winsaveview()&#xA;  require(&#34;flash&#34;).jump({&#xA;    action = function(match, state)&#xA;      state:hide()&#xA;      vim.api.nvim_set_current_win(match.win)&#xA;      vim.api.nvim_win_set_cursor(match.win, match.pos)&#xA;      require(&#34;flash&#34;).treesitter()&#xA;      vim.schedule(function()&#xA;        vim.api.nvim_set_current_win(win)&#xA;        vim.fn.winrestview(view)&#xA;      end)&#xA;    end,&#xA;  })&#xA;end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Alternatively, this can be achieved using a remote action:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;yr&lt;/code&gt; to start yank and remote&lt;/li&gt; &#xA;  &lt;li&gt;select a label&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;S&lt;/code&gt; to start Treesitter node selection&lt;/li&gt; &#xA;  &lt;li&gt;pick a Treesitter label&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;üåà Highlights&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Group&lt;/th&gt; &#xA;   &lt;th&gt;Default&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;FlashBackdrop&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Comment&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;backdrop&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;FlashMatch&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Search&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;search matches&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;FlashCurrent&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;IncSearch&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;current match&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;FlashLabel&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Substitute&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;jump label&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;üì¶ Alternatives&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ggandor/leap.nvim&#34;&gt;leap.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ggandor/lightspeed.nvim&#34;&gt;lightspeed.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/justinmk/vim-sneak&#34;&gt;vim-sneak&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/echasnovski/mini.nvim/raw/main/readmes/mini-jump.md&#34;&gt;mini.jump&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/echasnovski/mini.nvim/raw/main/readmes/mini-jump2d.md&#34;&gt;mini.jump2d&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/phaazon/hop.nvim&#34;&gt;hop.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rlane/pounce.nvim&#34;&gt;pounce.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/woosaaahh/sj.nvim&#34;&gt;sj.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mfussenegger/nvim-treehopper&#34;&gt;nvim-treehopper&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ggandor/flit.nvim&#34;&gt;flit.nvim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>rgroli/other.nvim</title>
    <updated>2023-06-24T01:40:55Z</updated>
    <id>tag:github.com,2023-06-24:/rgroli/other.nvim</id>
    <link href="https://github.com/rgroli/other.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Open alternative files for the current buffer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;other.nvim&lt;/h1&gt; &#xA;&lt;p&gt;Open alternative files for the current buffer.&lt;/p&gt; &#xA;&lt;h2&gt;tl;dr&lt;/h2&gt; &#xA;&lt;p&gt;This plugin allows you to open associated files for the currently active buffer. For example, while editing a controller, you can conveniently open a view, model, or testcase without using a fuzzy finder or tree.&lt;/p&gt; &#xA;&lt;p&gt;The plugin is inspired by plugins like &lt;a href=&#34;https://github.com/vim-scripts/a.vim&#34;&gt;a.vim&lt;/a&gt;, &lt;a href=&#34;https://github.com/tpope/vim-projectionist&#34;&gt;vim-projectionist&lt;/a&gt; or &lt;a href=&#34;https://plugins.jetbrains.com/plugin/1475-altn8&#34;&gt;AltN8&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;The plugin in a rails project.&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rgroli/other.nvim/main/other-nvim.gif&#34; alt=&#34;screen-gif&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The plugin opens a file picker when there&#39;s no perfect match. By default it memorizes the selection.&lt;/p&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;Neovim &amp;gt; 0.7&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;After setting up the plugin with builtin or custom mapping, it provides this set of command:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;:Other&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Opens the other/alternative file according to the configured mapping.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;:OtherSplit&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Like &lt;code&gt;:Other&lt;/code&gt;but opens the file in an horizontal split.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;:OtherVSplit&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Like &lt;code&gt;:Other&lt;/code&gt;but opens the file in a vertical split.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For each command you can pass an optional &lt;code&gt;context&lt;/code&gt; which is described under mappings. For example &lt;code&gt;:Other test&lt;/code&gt; could be used to open the testcase for the current buffer.&lt;/p&gt; &#xA;&lt;p&gt;The last list of possible matches is stored in the global variable &lt;code&gt;vim.g.other_lastmatches&lt;/code&gt;. The last file opened with the plugin is stored in the global variable &lt;code&gt;vim.g.other_lastopened&lt;/code&gt;. This might be useful for integration with other plugins.&lt;/p&gt; &#xA;&lt;h3&gt;Keybindings&lt;/h3&gt; &#xA;&lt;p&gt;When the file-picker is opened it can be used with the following keybindings: &lt;img src=&#34;https://raw.githubusercontent.com/rgroli/other.nvim/main/other-nvim-overlay.jpg&#34; alt=&#34;screen-gif&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;üí° Additionally you can open the selected line in a split without the shortcut by pressing &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; to open it in a vertical split.&lt;/p&gt; &#xA;&lt;p&gt;The default keybindings can be overwritten using the keybindings table in the config:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#x9;keybindings = {&#xA;&#x9;&#x9;[&#34;&amp;lt;cr&amp;gt;&#34;] = &#34;open_file()&#34;,&#xA;&#x9;&#x9;[&#34;&amp;lt;esc&amp;gt;&#34;] = &#34;close_window()&#34;,&#xA;&#x9;&#x9;o = &#34;open_file()&#34;,&#xA;&#x9;&#x9;q = &#34;close_window()&#34;,&#xA;&#x9;&#x9;v = &#34;open_file_vs()&#34;,&#xA;&#x9;&#x9;s = &#34;open_file_sp()&#34;,&#xA;&#x9;},&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation / Setup&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Plug &#39;rgroli/other.nvim&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After the installation the plugin needs to be initialized. When you&#39;re using an &lt;code&gt;init.lua&lt;/code&gt; a setup could look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;other-nvim&#34;).setup({&#xA;    mappings = {&#xA;        -- builtin mappings&#xA;        &#34;livewire&#34;,&#xA;        &#34;angular&#34;,&#xA;        &#34;laravel&#34;,&#xA;        &#34;rails&#34;,&#xA;        &#34;golang&#34;,&#xA;        -- custom mapping&#xA;        {&#xA;            pattern = &#34;/path/to/file/src/app/(.*)/.*.ext$&#34;,&#xA;            target = &#34;/path/to/file/src/view/%1/&#34;,&#xA;            transformer = &#34;lowercase&#34;&#xA;        }&#xA;    },&#xA;    transformers = {&#xA;        -- defining a custom transformer&#xA;        lowercase = function (inputString)&#xA;            return inputString:lower()&#xA;        end&#xA;    },&#xA;    style = {&#xA;        -- How the plugin paints its window borders&#xA;        -- Allowed values are none, single, double, rounded, solid and shadow&#xA;        border = &#34;solid&#34;,&#xA;&#xA;        -- Column seperator for the window&#xA;        seperator = &#34;|&#34;,&#xA;&#xA;&#x9;-- width of the window in percent. e.g. 0.5 is 50%, 1.0 is 100%&#xA;&#x9;width = 0.7,&#xA;&#xA;&#x9;-- min height in rows.&#xA;&#x9;-- when more columns are needed this value is extended automatically&#xA;&#x9;minHeight = 2&#xA;    },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A simple configuration with basic keybinding would look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;other-nvim&#34;).setup({&#xA;&#x9;mappings = {&#xA;&#x9;&#x9;&#34;livewire&#34;,&#xA;&#x9;&#x9;&#34;angular&#34;,&#xA;&#x9;&#x9;&#34;laravel&#34;,&#xA;&#x9;&#x9;&#34;rails&#34;,&#xA;&#x9;&#x9;&#34;golang&#34;,&#xA;&#x9;},&#xA;})&#xA;&#xA;vim.api.nvim_set_keymap(&#34;n&#34;, &#34;&amp;lt;leader&amp;gt;ll&#34;, &#34;&amp;lt;cmd&amp;gt;:Other&amp;lt;CR&amp;gt;&#34;, { noremap = true, silent = true })&#xA;vim.api.nvim_set_keymap(&#34;n&#34;, &#34;&amp;lt;leader&amp;gt;lp&#34;, &#34;&amp;lt;cmd&amp;gt;:OtherSplit&amp;lt;CR&amp;gt;&#34;, { noremap = true, silent = true })&#xA;vim.api.nvim_set_keymap(&#34;n&#34;, &#34;&amp;lt;leader&amp;gt;lv&#34;, &#34;&amp;lt;cmd&amp;gt;:OtherVSplit&amp;lt;CR&amp;gt;&#34;, { noremap = true, silent = true })&#xA;vim.api.nvim_set_keymap(&#34;n&#34;, &#34;&amp;lt;leader&amp;gt;lc&#34;, &#34;&amp;lt;cmd&amp;gt;:OtherClear&amp;lt;CR&amp;gt;&#34;, { noremap = true, silent = true })&#xA;&#xA;-- Context specific bindings&#xA;vim.api.nvim_set_keymap(&#34;n&#34;, &#34;&amp;lt;leader&amp;gt;lt&#34;, &#34;&amp;lt;cmd&amp;gt;:Other test&amp;lt;CR&amp;gt;&#34;, { noremap = true, silent = true })&#xA;vim.api.nvim_set_keymap(&#34;n&#34;, &#34;&amp;lt;leader&amp;gt;ls&#34;, &#34;&amp;lt;cmd&amp;gt;:Other scss&amp;lt;CR&amp;gt;&#34;, { noremap = true, silent = true })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After the installation the following commands are offered:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Value&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:Other&lt;/td&gt; &#xA;   &lt;td&gt;Tries to open the other/alternative file based on the configured mappings. When there is a perfect match the corresponding file will be opened. If there are multiple candidates, a file picker will be opened. After picking a file, the two files hold an internal reference to each other. In that way you only have to pick the other/alternative file once. This behaviour can be turned off by setting the configuration-option &lt;code&gt;rememberBuffers&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:OtherSplit&lt;/td&gt; &#xA;   &lt;td&gt;Same as &lt;code&gt;:Other&lt;/code&gt; but the file is opened in a horizontal split.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:OtherVSplit&lt;/td&gt; &#xA;   &lt;td&gt;Same as &lt;code&gt;:OtherSplit&lt;/code&gt; but the split is vertical.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:OtherClear&lt;/td&gt; &#xA;   &lt;td&gt;Clears the internal reference to the other/alternative file. Afterwards a file picker will be opened again if there are multiple matches for the current file.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The commands &lt;code&gt;:Other&lt;/code&gt;, &lt;code&gt;:OtherSplit&lt;/code&gt; and &lt;code&gt;:OtherVSplit&lt;/code&gt; accept the optional parameter &lt;code&gt;context&lt;/code&gt;. When the context is provided only the mappings with the given context are used for looking up the corresponding file. This can be useful to open specific files like stylesheets, models, tests, etc. and bind that to a specific key.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;To adjust the behavior of the plugin, you the pass a configuration to the setup function. The default-configuration looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- default settings&#xA;local defaults = {&#xA;&#xA;&#x9;-- by default there are no mappings enabled&#xA;&#x9;mappings = {},&#xA;&#xA;&#x9;-- default transformers&#xA;&#x9;transformers = {&#xA;&#x9;&#x9;camelToKebap = transformers.camelToKebap,&#xA;&#x9;&#x9;kebapToCamel = transformers.kebapToCamel,&#xA;&#x9;&#x9;pluralize = transformers.pluralize,&#xA;&#x9;&#x9;singularize = transformers.singularize,&#xA;&#x9;},&#xA;&#xA;&#x9;-- Should the window show files which do not exist yet based on&#xA;&#x9;-- pattern matching. Selecting the files will create the file.&#xA;&#x9;showMissingFiles = true,&#xA;&#xA;&#x9;-- When a mapping requires an initial selection of the other file, this setting controls,&#xA;&#x9;-- wether the selection should be remembered for the current user session.&#xA;&#x9;-- When this option is set to false reference between the two buffers are never saved.&#xA;&#x9;-- Existing references can be removed on the buffer with :OtherClear&#xA;&#x9;rememberBuffers = true,&#xA;&#xA;&#x9;keybindings = {&#xA;&#x9;&#x9;[&#34;&amp;lt;cr&amp;gt;&#34;] = &#34;open_file()&#34;,&#xA;&#x9;&#x9;[&#34;&amp;lt;esc&amp;gt;&#34;] = &#34;close_window()&#34;,&#xA;&#x9;&#x9;o = &#34;open_file()&#34;,&#xA;&#x9;&#x9;q = &#34;close_window()&#34;,&#xA;&#x9;&#x9;v = &#34;open_file_vs()&#34;,&#xA;&#x9;&#x9;s = &#34;open_file_sp()&#34;,&#xA;&#x9;},&#xA;&#xA;&#x9;hooks = {&#xA;&#x9;&#x9;-- This hook which is executed when the file-picker is shown.&#xA;&#x9;&#x9;-- It could be used to filter or reorder the files in the filepicker.&#xA;&#x9;&#x9;-- The function must return a lua table with the same structure as the input parameter.&#xA;&#x9;&#x9;--&#xA;&#x9;&#x9;-- The input parameter &#34;files&#34; is a lua table with each entry containing:&#xA;&#x9;&#x9;-- @param table (filename (string), context (string), exists (boolean))&#xA;&#x9;&#x9;-- @return table&#xA;&#x9;&#x9;filePickerBeforeShow = function(files)&#xA;&#x9;&#x9;&#x9;return files&#xA;&#x9;&#x9;end,&#xA;&#xA;&#x9;&#x9;-- This hook is called whenever a file is about to be opened.&#xA;&#x9;&#x9;-- One example how this can be used: a non existing file needs to be opened by another plugin, which provides a template.&#xA;&#x9;&#x9;--&#xA;&#x9;&#x9;-- @param filename (string) the full-path of the file&#xA;&#x9;&#x9;-- @param exists (boolean) doess the file already exist&#xA;&#x9;&#x9;-- @return (boolean) When true (default) the plugin takes care of opening the file, when the function returns false this indicated that opening of the file is done in the hook.&#xA;&#x9;&#x9;onOpenFile = function(filename, exists)&#xA;&#x9;&#x9;&#x9;return true&#xA;&#x9;&#x9;end,&#xA;&#x9;},&#xA;&#xA;&#x9;style = {&#xA;&#x9;&#x9;-- How the plugin paints its window borders&#xA;&#x9;&#x9;-- Allowed values are none, single, double, rounded, solid and shadow&#xA;&#x9;&#x9;border = &#34;solid&#34;,&#xA;&#xA;&#x9;&#x9;-- Column seperator for the window&#xA;&#x9;&#x9;seperator = &#34;|&#34;,&#xA;&#xA;&#x9;&#x9;-- Indicator showing that the file does not yet exist&#xA;&#x9;&#x9;newFileIndicator = &#34;(* new *)&#34;,&#xA;&#xA;&#x9;&#x9;-- width of the window in percent. e.g. 0.5 is 50%, 1 is 100%&#xA;&#x9;&#x9;width = 0.7,&#xA;&#xA;&#x9;&#x9;-- min height in rows.&#xA;&#x9;&#x9;-- when more columns are needed this value is extended automatically&#xA;&#x9;&#x9;minHeight = 2,&#xA;&#x9;},&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Value&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;mappings&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Settings to find other/alternative files for the current buffer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;transformers&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;List of functions which are used to transform values when mapping the target file.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;rememberBuffers&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;When this option is set to false the reference between two buffers is never saved.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;style&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Options to change the appearance of the window.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;hooks&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Lua functions to modify the behaviour of plugin events&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Mappings&lt;/h3&gt; &#xA;&lt;p&gt;Mappings are the heart of the plugin and describe how to find the other/alternative file for the current buffer.&lt;/p&gt; &#xA;&lt;p&gt;For example in an angular project, the mapping of a HTML-template to a typescript component and vice-versa can be done as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;other-nvim&#34;).setup({&#xA;    mappings = {&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;pattern = &#34;/src/app/(.*)/.*.ts$&#34;,&#xA;&#x9;&#x9;&#x9;target = &#34;/src/app/%1/%1.component.html&#34;,&#xA;            &#x9;&#x9;context = &#34;component&#34; -- optional&#xA;&#x9;&#x9;},&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;pattern = &#34;/src/app/(.*)/.*.html$&#34;,&#xA;&#x9;&#x9;&#x9;target = &#34;/src/app/%1/%1.component.ts&#34;,&#xA;            &#x9;&#x9;context = &#34;view&#34;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The mapping between a controller and a view file in a laravel project can be done with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;other-nvim&#34;).setup({&#xA;    mappings = {&#xA;        &#x9;{&#xA;        &#x9;&#x9;pattern = &#34;/app/Http/Controllers/(.*)Controller.php$&#34;,&#xA;        &#x9;&#x9;target = &#34;/resources/views/%1/&#34;,&#xA;                &#x9;context = &#34;controller&#34;&#xA;        &#x9;&#x9;transformer = &#34;camelToKebap&#34;,&#xA;        &#x9;},&#xA;        &#x9;{&#xA;        &#x9;&#x9;pattern = &#34;/resources/views/(.*)/.*&#34;,&#xA;        &#x9;&#x9;target = &#34;/app/Http/Controllers/%1Controller.php&#34;,&#xA;                &#x9;context = &#34;view&#34;&#xA;        &#x9;&#x9;transformer = &#34;kebapToCamel&#34;,&#xA;        &#x9;},&#xA;&#x9;}&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mapping multiple targets to one filetype (in this case .ts to .html or .spec.ts) can be done like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;other-nvim&#34;).setup({&#xA;    mappings = {&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;pattern = &#34;/src/app/(.*)/.*.ts$&#34;,&#xA;&#x9;&#x9;&#x9;target = &#34;/src/app/%1/%1.component.html&#34;,&#xA;            &#x9;&#x9;context = &#34;component&#34;&#xA;&#x9;&#x9;},&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;pattern = &#34;/src/app/(.*)/.*.html$&#34;,&#xA;&#x9;&#x9;&#x9;target = &#34;/src/app/%1/%1.component.ts&#34;,&#xA;            &#x9;&#x9;context = &#34;view&#34;&#xA;&#x9;&#x9;},&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;pattern = &#34;/src/app/(.*)/.*.ts$&#34;,&#xA;&#x9;&#x9;&#x9;target = &#34;/src/app/%1/%1.component.html&#34;,&#xA;            &#x9;&#x9;context = &#34;component&#34;&#xA;&#x9;&#x9;},&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;pattern = &#34;/src/app/(.*)/.*.spec.ts$&#34;,&#xA;&#x9;&#x9;&#x9;target = &#34;/src/app/%1/%1.component.html&#34;,&#xA;            &#x9;&#x9;context = &#34;test&#34;&#xA;&#x9;&#x9;},&#xA;&#x9;}&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;this can even be described in shorter syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;other-nvim&#34;).setup({&#xA;    mappings = {&#xA;    &#x9;{&#xA;            pattern = &#34;/(.*)/(.*)/.*.ts$&#34;,&#xA;            target = {&#xA;                {&#xA;                    target = &#34;/%1/%2/%2.component.html&#34;,&#xA;                    context = &#34;html&#34;&#xA;                },&#xA;                {&#xA;                    target = &#34;/%1/%2/%2.component.spec.ts&#34;,&#xA;                    context = &#34;test&#34;&#xA;                }&#xA;            }&#xA;        }&#xA;&#x9;},&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;üí° Mappins also allow for using glob-like patterns in the pattern-section:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;other-nvim&#34;).setup({&#xA;    mappings = {&#xA;&#x9;&#x9;--- [...]&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;    pattern = &#34;/src/(.*)/.*.js$&#34;,&#xA;&#x9;&#x9;    target = &#34;/src/%1/\\(*.css\\|*.scss\\)&#34;,&#xA;&#x9;&#x9;},&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Special characters need to be escaped with double slashes.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A mapping can have the following settings:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Setting&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pattern&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A regular expression to find an available mapping for the current buffer. The pattern can have one ore more capturing group &lt;code&gt;(.*)&lt;/code&gt; which can be used in the target setting.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;target&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A string to resolve the other/alternative file. The &lt;code&gt;%1&lt;/code&gt; in the string represents a match in the first capturing group of the pattern. &lt;code&gt;%2&lt;/code&gt; would reference a second capturing group&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;transformer&lt;/code&gt; (optional)&lt;/td&gt; &#xA;   &lt;td&gt;A function to transform the captured group of the pattern before it is used in the target.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;context&lt;/code&gt; (optional)&lt;/td&gt; &#xA;   &lt;td&gt;A string defining an extra context beyond the standard mapping. An example would be &#34;test&#34; for opening the test case of a component. The context is also used to display additional information when picking a file in the window.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;üí° &lt;strong&gt;Escaping in &#39;pattern&#39;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;When using regexes in the pattern be aware that some characters need to be escaped with an &lt;code&gt;%&lt;/code&gt;. These characters need escaping when they should be used literally: &lt;code&gt;( ) . % + - * ? [ ^ $&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;For instance when something like &lt;code&gt;some-folder&lt;/code&gt; is part of the pattern it should be written as &lt;code&gt;some%-folder&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Builtin Mappings&lt;/h4&gt; &#xA;&lt;p&gt;Right now there are builtin mappings for&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;angular&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rails&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;golang&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;laravel&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;livewire&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The rails mappings now include functionality for the the testframeworks &lt;code&gt;minitest&lt;/code&gt; and &lt;code&gt;rspec&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The implementation of the mappings is straightforward and can be viewed &lt;a href=&#34;https://github.com/rgroli/other.nvim/raw/main/lua/other-nvim/builtin/mappings/&#34;&gt;here&lt;/a&gt;. I&#39;d ‚ù§Ô∏è to see contributions to extend this list. To use the builtin mappings they can be passed as string to the mappings in the setup.&lt;/p&gt; &#xA;&lt;p&gt;üí° If there are multiple mappings matching the current path a file picker will be shown to select the desired file.&lt;/p&gt; &#xA;&lt;h4&gt;Non existing files&lt;/h4&gt; &#xA;&lt;p&gt;When &lt;code&gt;showMissingFiles&lt;/code&gt; is true, the plugin also displays files that have a matching mapping but do not exist yet.&lt;/p&gt; &#xA;&lt;p&gt;The configuration option &lt;code&gt;newFileIndicator&lt;/code&gt; is the string which is displayed in front of the non-existing file. When the file is opened with the file picker it is created.&lt;/p&gt; &#xA;&lt;p&gt;To apply more custom logic like for instance using another plugin to prepopulate the contents of the created file based on a template, it is also possible to use the &lt;code&gt;onOpenFile&lt;/code&gt; hook.&lt;/p&gt; &#xA;&lt;h3&gt;Transformers&lt;/h3&gt; &#xA;&lt;p&gt;Transformers are lua functions to transform the captured group of the pattern before being used in the target. Right now the plugin has two builtin transformers &lt;code&gt;camelToKebap&lt;/code&gt; and &lt;code&gt;kebapToCamel&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is easy to create a custom transformers in the setup as well. A transformer must have this signature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;function (inputString)&#xA;   -- transforming here&#xA;   return transformedValue;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Custom transformers are defined in the setup and can directly used in the mappings. In this example the custom &lt;code&gt;lowercase&lt;/code&gt; transformer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;other-nvim&#34;).setup({&#xA;    -- [...]&#xA;    mappings = {&#xA;        -- custom mapping&#xA;        {&#xA;            pattern = &#34;/path/to/file/src/app/(.*)/.*.ext$&#34;,&#xA;            target = &#34;/path/to/file/src/view/%1/&#34;,&#xA;            transformer = &#34;lowercase&#34;&#xA;        }&#xA;    },&#xA;    transformers = {&#xA;        lowercase = function (inputString)&#xA;            return inputString:lower()&#xA;        end&#xA;    },&#xA;    -- [...]&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>