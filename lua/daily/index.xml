<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-09T01:27:14Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>meetric1/GWater-V3</title>
    <updated>2024-03-09T01:27:14Z</updated>
    <id>tag:github.com,2024-03-09:/meetric1/GWater-V3</id>
    <link href="https://github.com/meetric1/GWater-V3" rel="alternate"></link>
    <summary type="html">&lt;p&gt;GWater, but this time I know a little more C++&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GWATER v1.4 &lt;a href=&#34;https://&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/made_with-mee%2B%2B-2ea44f&#34; alt=&#34;made with - mee++&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;This is the repository for the GWater source code and its binary module releases!&lt;br&gt; Remember, you also need the workshop addon for this to work! &lt;a href=&#34;https://steamcommunity.com/sharedfiles/filedetails/?id=2700933866&#34;&gt;https://steamcommunity.com/sharedfiles/filedetails/?id=2700933866&lt;/a&gt;&lt;br&gt; If you&#39;re looking to install the GWater module, you can watch this tutorial: &lt;a href=&#34;https://www.youtube.com/watch?v=rlIyqdFmE8k&#34;&gt;https://www.youtube.com/watch?v=rlIyqdFmE8k&lt;/a&gt;&lt;br&gt; If you prefer text, here&#39;s a step-by-step guide:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Go to the Releases and find the newest release&lt;br&gt; &lt;strong&gt;2.&lt;/strong&gt; Download the GWater installer (&lt;code&gt;GWater.exe&lt;/code&gt;)&lt;br&gt; &lt;strong&gt;3.&lt;/strong&gt; Run it!&lt;br&gt; It will try to auto-detect your Garry&#39;s Mod folder, but if it can&#39;t, click the Browse button and select the &lt;code&gt;GarrysMod&lt;/code&gt; folder (Not &lt;code&gt;GarrysMod/garrysmod&lt;/code&gt;!)&lt;br&gt; &lt;strong&gt;4.&lt;/strong&gt; Close Garry&#39;s Mod if it&#39;s currently open.&lt;br&gt; &lt;strong&gt;5.&lt;/strong&gt; Press the Install button. It will install the necessary DLLs in the right locations!&lt;/p&gt; &#xA;&lt;h3&gt;IN CASE THE INSTALLER FAILS: (or any other reason)&lt;/h3&gt; &#xA;&lt;p&gt;Manual install method:&lt;br&gt; &lt;strong&gt;1.&lt;/strong&gt; Go to the Releases tab and find the newest release&lt;br&gt; &lt;strong&gt;2.&lt;/strong&gt; Download the &lt;code&gt;GWater.zip&lt;/code&gt; archive&lt;br&gt; &lt;strong&gt;3.&lt;/strong&gt; Unpack its contents to a folder, you should see a bunch of dlls&lt;br&gt; &lt;strong&gt;4.&lt;/strong&gt; Open your &lt;code&gt;GarrysMod&lt;/code&gt; folder and your &lt;code&gt;GarrysMod/garrysmod/lua/bin&lt;/code&gt; folder&lt;br&gt; &lt;strong&gt;5.&lt;/strong&gt; Move the DLLs that &lt;em&gt;don&#39;t&lt;/em&gt; start with &lt;code&gt;gmcl_&lt;/code&gt; to the &lt;code&gt;GarrysMod&lt;/code&gt; folder&lt;br&gt; &lt;strong&gt;6.&lt;/strong&gt; Move the DLLs that &lt;em&gt;do&lt;/em&gt; start with &lt;code&gt;gmcl_&lt;/code&gt; (should be 2) to the lua/bin folder from above&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re having trouble, ask us in &lt;a href=&#34;https://discord.gg/vdsgHsFrx2&#34;&gt;the server we developed GWater in&lt;/a&gt;!&lt;br&gt; Please note that this addon is still in beta.&lt;br&gt; It &lt;em&gt;will&lt;/em&gt; have bugs and issues, but we&#39;re working to fix them and make the experience better for you!&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;ancient readme:&lt;/h1&gt; &#xA;&lt;p&gt;hello and welcome our ocean of code&lt;br&gt; it&#39;s a SEA of exceptions and errors&lt;br&gt; we&#39;re plseaed to have you here&lt;br&gt; our code is cleaner than a lake&lt;/p&gt; &#xA;&lt;p&gt;ðŸ—¿&lt;/p&gt; &#xA;&lt;p&gt;DONT TELL MEE i randomly remembered this repo exists &lt;img alt=&#34;trollface&#34; src=&#34;https://github.githubassets.com/images/icons/emoji/trollface.png?v8&#34;&gt;)&lt;br&gt; you guys should know that there may or may not be a net message in gwater code, meant for swimming code,&lt;br&gt; that lets anyone fly around the map (even with noclip disabled) which i purposefully added&lt;br&gt; now go figure it out and cause chaos in shitty addon-stuffed darkrp servers &lt;img alt=&#34;trollface&#34; src=&#34;https://github.githubassets.com/images/icons/emoji/trollface.png?v8&#34;&gt;)&lt;br&gt; - andrew&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>version-fox/version-fox-plugins</title>
    <updated>2024-03-09T01:27:14Z</updated>
    <id>tag:github.com,2024-03-09:/version-fox/version-fox-plugins</id>
    <link href="https://github.com/version-fox/version-fox-plugins" rel="alternate"></link>
    <summary type="html">&lt;p&gt;plugins repository for VersionFox&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;VersionFox Plugins&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The repository that stores some useful plugins of VersionFox&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Supported Plugins&lt;/h2&gt; &#xA;&lt;!-- TABLE_START --&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Version&lt;/th&gt; &#xA;   &lt;th&gt;Author&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;dart/dart&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.1&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Aooohan&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;dart plugin, support for getting stable, dev, beta version&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;deno/deno&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.1&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Aooohan&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Deno plugin, https://deno.com/&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;dotnet/dotnet&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.1&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Korbinian Habereder&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;dotnet plugin, support for dotnet sdks 6.0, 7.0, 8.0&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;flutter/flutter-cn&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.1&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Aooohan&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;flutter plugin for China, support for getting stable, dev, beta version&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;flutter/flutter&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.2&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Aooohan&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;flutter plugin, support for getting stable, dev, beta version&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;golang/golang&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.2&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Aooohan&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;gradle/gradle&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.1&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;ahai&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;gradle&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;java/adoptium-jdk&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.1&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;aooohan&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Adoptium JDK&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;java/azul-jdk&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.2&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;yimiaoxiehou&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Azul JDK, also known as Zulu&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;java/graalvm&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.1&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;ahai&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;graalvm JDK&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;kotlin/kotlin&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.1&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Aooohan&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Kotlin plugin&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;maven/maven&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.1&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Aooohan&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;nodejs/nodejs&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.4&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Aooohan&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Node.js&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;nodejs/npmmirror&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.2&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;yimiaoxiehou&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;install Node.js use https://cdn.npmmirror.com&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;python/npmmirror&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.3&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;aooohan&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;vfox &amp;gt;= 0.2.3 !!! From npmmirror.org. For Windows, only support &amp;gt;=3.5.0, but no restrictions for unix-like&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;python/python&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.3&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;aooohan&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;vfox &amp;gt;= 0.2.3 !! For Windows, only support &amp;gt;=3.5.0, but no restrictions for unix-like&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;small&gt;&lt;b&gt;zig/zig&lt;/b&gt;&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;0.0.4&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;aooohan&lt;/small&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;small&gt;Zig&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;!-- TABLE_END --&gt;</summary>
  </entry>
  <entry>
    <title>starwing/lua-protobuf</title>
    <updated>2024-03-09T01:27:14Z</updated>
    <id>tag:github.com,2024-03-09:/starwing/lua-protobuf</id>
    <link href="https://github.com/starwing/lua-protobuf" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Lua module to work with Google protobuf&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Google protobuf support for Lua&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/starwing/lua-protobuf/actions?query=branch%3Amaster&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/starwing/lua-protobuf/test.yml?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://coveralls.io/github/starwing/lua-protobuf?branch=master&#34;&gt;&lt;img src=&#34;https://img.shields.io/coveralls/github/starwing/lua-protobuf&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;English | &lt;a href=&#34;https://github.com/starwing/lua-protobuf/raw/master/README.zh.md&#34;&gt;ä¸­æ–‡&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;This project offers a C module for Lua (5.1, 5.2, 5.3, 5.4 and LuaJIT) manipulating Google&#39;s protobuf protocol, both for version 2 and 3 syntax and semantics. It splits to the lower-level and the high-level parts for different goals.&lt;/p&gt; &#xA;&lt;p&gt;For converting between binary protobuf data with Lua tables, using &lt;code&gt;pb.load()&lt;/code&gt; loads the compiled protobuf schema content (&lt;code&gt;*.pb&lt;/code&gt; file) generated by Google protobuf&#39;s compiler named &lt;code&gt;protoc&lt;/code&gt; and call &lt;code&gt;pb.encode()&lt;/code&gt;/&lt;code&gt;pb.decode()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Or use these modules to manipulate the raw wire format in lower-level way:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;pb.slice&lt;/code&gt;: a wire format decoding module.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pb.buffer&lt;/code&gt;: a buffer implement that use to encode basic types into protobuf&#39;s wire format. It can be used to support streaming decode protobuf data.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pb.conv&lt;/code&gt;: a module converting integers in the protobuf wire format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pb.io&lt;/code&gt;: a module access &lt;code&gt;stdin/stdout&lt;/code&gt; or other files in binary mode.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you don&#39;t want to depend Google&#39;s protobuf compiler, &lt;code&gt;protoc.lua&lt;/code&gt; is a pure Lua module translating text-based protobuf schema content into the &lt;code&gt;*.pb&lt;/code&gt; binary format.&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;To install, you could just use &lt;code&gt;luarocks&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;luarocks install lua-protobuf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to build it from source, just clone the repo and use luarocks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/starwing/lua-protobuf&#xA;luarocks make rockspecs/lua-protobuf-scm-1.rockspec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t have luarocks, use &lt;code&gt;hererocks&lt;/code&gt; to install Lua and luarocks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip install hererocks&#xA;git clone https://github.com/starwing/lua-protobuf&#xA;hererocks -j 2.0 -rlatest .&#xA;bin/luarocks make lua-protobuf/rockspecs/lua-protobuf-scm-1.rockspec CFLAGS=&#34;-fPIC -Wall -Wextra&#34; LIBFLAGS=&#34;-shared&#34;&#xA;cp protoc.lua pb.so ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can build it by hand, it only has a pure Lua module &lt;code&gt;protoc.lua&lt;/code&gt; and a pair of C source: &lt;code&gt;pb.h&lt;/code&gt; and &lt;code&gt;pb.c&lt;/code&gt;. &lt;em&gt;Notice&lt;/em&gt; that in order to build the &lt;code&gt;pb&lt;/code&gt; C module, you need Lua header file and/or libary file installed. replace &lt;code&gt;$LUA_HEADERS&lt;/code&gt; and &lt;code&gt;$LUA_LIBS&lt;/code&gt; below to real install locations.&lt;/p&gt; &#xA;&lt;p&gt;To build it on macOS, use your favor compiler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;gcc -O2 -shared -undefined dynamic_lookup -I &#34;$LUA_HEADERS&#34; pb.c -o pb.so&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Linux, use the nearly same command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;gcc -O2 -shared -fPIC -I &#34;$LUA_HEADERS&#34; pb.c -o pb.so&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Windows, you could use MinGW or MSVC, create a &lt;code&gt;*.sln&lt;/code&gt; project or build it on the command line (notice the &lt;code&gt;Lua_BUILD_AS_DLL&lt;/code&gt; flag):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cl /O2 /LD /Fepb.dll /I &#34;$LUA_HEADERS&#34; /DLUA_BUILD_AS_DLL pb.c &#34;$LUA_LIBS&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local pb = require &#34;pb&#34;&#xA;local protoc = require &#34;protoc&#34;&#xA;&#xA;-- load schema from text (just for demo, use protoc.new() in real world)&#xA;assert(protoc:load [[&#xA;   message Phone {&#xA;      optional string name        = 1;&#xA;      optional int64  phonenumber = 2;&#xA;   }&#xA;   message Person {&#xA;      optional string name     = 1;&#xA;      optional int32  age      = 2;&#xA;      optional string address  = 3;&#xA;      repeated Phone  contacts = 4;&#xA;   } ]])&#xA;&#xA;-- lua table data&#xA;local data = {&#xA;   name = &#34;ilse&#34;,&#xA;   age  = 18,&#xA;   contacts = {&#xA;      { name = &#34;alice&#34;, phonenumber = 12312341234 },&#xA;      { name = &#34;bob&#34;,   phonenumber = 45645674567 }&#xA;   }&#xA;}&#xA;&#xA;-- encode lua table data into binary format in lua string and return&#xA;local bytes = assert(pb.encode(&#34;Person&#34;, data))&#xA;print(pb.tohex(bytes))&#xA;&#xA;-- and decode the binary data back into lua table&#xA;local data2 = assert(pb.decode(&#34;Person&#34;, bytes))&#xA;print(require &#34;serpent&#34;.block(data2))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Use case&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://djwk.qq.com&#34;&gt;&lt;img src=&#34;https://img.tapimg.com/market/images/e59627dc9039ff22ba7d000b5c9fe7f6.jpg?imageView2/2/h/560/q/40/format/jpg/interlace/1/ignore-error/1&#34; alt=&#34;é›¶å¢ƒäº¤é”™&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;protoc&lt;/code&gt; Module&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Function&lt;/th&gt; &#xA;   &lt;th&gt;Returns&lt;/th&gt; &#xA;   &lt;th&gt;Descriptions&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;protoc.new()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Proroc object&lt;/td&gt; &#xA;   &lt;td&gt;create a new compiler instance&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;protoc.reload()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;true&lt;/td&gt; &#xA;   &lt;td&gt;reload all google standard messages into &lt;code&gt;pb&lt;/code&gt; module&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;p:parse(string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;table&lt;/td&gt; &#xA;   &lt;td&gt;transform schema to &lt;code&gt;DescriptorProto&lt;/code&gt; table&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;p:compile(string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;string&lt;/td&gt; &#xA;   &lt;td&gt;transform schema to binary *.pb format data&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;p:load(string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;true&lt;/td&gt; &#xA;   &lt;td&gt;load schema into &lt;code&gt;pb&lt;/code&gt; module&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;p.loaded&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;table&lt;/td&gt; &#xA;   &lt;td&gt;contains all parsed &lt;code&gt;DescriptorProto&lt;/code&gt; table&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;p.unknown_import&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;see below&lt;/td&gt; &#xA;   &lt;td&gt;handle schema import error&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;p.unknown_type&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;see below&lt;/td&gt; &#xA;   &lt;td&gt;handle unknown type in schema&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;p.include_imports&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;bool&lt;/td&gt; &#xA;   &lt;td&gt;auto load imported proto&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;To parse a text schema content, create a compiler instance first:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local p = protoc.new()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, set some options to the compiler, e.g. the unknown handlers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- set some hooks&#xA;p.unknown_import = function(self, module_name) ... end&#xA;p.unknown_type   = function(self, type_name) ... end&#xA;-- ... and options&#xA;p.include_imports = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;unknown_import&lt;/code&gt; and &lt;code&gt;unknown_type&lt;/code&gt; handle could be &lt;code&gt;true&lt;/code&gt;, string or a function. Seting it to &lt;code&gt;true&lt;/code&gt; means all &lt;em&gt;non-exist&lt;/em&gt; modules and types are given a default value without triggering an error; A string means a Lua pattern that indicates whether an unknown module or type should raise an error, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;p.unknown_type = &#34;Foo.*&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;means all types prefixed by &lt;code&gt;Foo&lt;/code&gt; will be treat as existing type and do not trigger errors.&lt;/p&gt; &#xA;&lt;p&gt;If these are functions, the unknown type and module name will be passed to functions. For module handler, it should return a &lt;code&gt;DescriptorProto&lt;/code&gt; Table produced by &lt;code&gt;p:load()&lt;/code&gt; functions, for type handler, it should return a type name and type, such as &lt;code&gt;message&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt;, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;function p:unknown_import(name)&#xA;  -- if can not find &#34;foo.proto&#34;, load &#34;my_foo.proto&#34; instead&#xA;  return p:parsefile(&#34;my_&#34;..name)&#xA;end&#xA;&#xA;function p:unknown_type(name)&#xA;  -- if cannot find &#34;Type&#34;, treat it as &#34;.MyType&#34; and is a message type return &#34;.My&#34;..name, &#34;message&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After setting options, use &lt;code&gt;load()&lt;/code&gt; or &lt;code&gt;compile()&lt;/code&gt; or &lt;code&gt;parse()&lt;/code&gt; function to get result.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;pb&lt;/code&gt; Module&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;pb&lt;/code&gt; module has high-level routines to manipulate protobuf messages.&lt;/p&gt; &#xA;&lt;p&gt;In below table of functions, we have several types that have special means:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;type&lt;/code&gt;: a string that indicates the protobuf message type, &lt;code&gt;&#34;.Foo&#34;&lt;/code&gt; means the type in a proto definition that has not &lt;code&gt;package&lt;/code&gt; statement declared. &lt;code&gt;&#34;foo.Foo&#34;&lt;/code&gt; means the type in a proto definition that declared &lt;code&gt;package foo;&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;data&lt;/code&gt;: could be string, &lt;code&gt;pb.Slice&lt;/code&gt; value or &lt;code&gt;pb.Buffer&lt;/code&gt; value.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;iterator&lt;/code&gt;: a function that can use in Lua &lt;code&gt;for in&lt;/code&gt; statement, e.g.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;for name in pb.types() do&#xA;  print(name)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTICE&lt;/strong&gt;: Only &lt;code&gt;pb.load()&lt;/code&gt; returns error on failure, &lt;em&gt;do check&lt;/em&gt; the result it returns. Other routines raise a error when failure for convenience.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Function&lt;/th&gt; &#xA;   &lt;th&gt;Returns&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.clear()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;None&lt;/td&gt; &#xA;   &lt;td&gt;clear all types&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.clear(type)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;None&lt;/td&gt; &#xA;   &lt;td&gt;delete specific type&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.load(data)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;boolean,integer&lt;/td&gt; &#xA;   &lt;td&gt;load a binary schema data into &lt;code&gt;pb&lt;/code&gt; module&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.encode(type, table)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;string&lt;/td&gt; &#xA;   &lt;td&gt;encode a message table into binary form&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.encode(type, table, b)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;buffer&lt;/td&gt; &#xA;   &lt;td&gt;encode a message table into binary form to buffer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.decode(type, data)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;table&lt;/td&gt; &#xA;   &lt;td&gt;decode a binary message into Lua table&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.decode(type, data, table)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;table&lt;/td&gt; &#xA;   &lt;td&gt;decode a binary message into a given Lua table&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.pack(fmt, ...)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;string&lt;/td&gt; &#xA;   &lt;td&gt;same as &lt;code&gt;buffer.pack()&lt;/code&gt; but return string&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.unpack(data, fmt, ...)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;values...&lt;/td&gt; &#xA;   &lt;td&gt;same as &lt;code&gt;slice.unpack()&lt;/code&gt; but accept data&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.types()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;iterator&lt;/td&gt; &#xA;   &lt;td&gt;iterate all types in &lt;code&gt;pb&lt;/code&gt; module&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.type(type)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;see below&lt;/td&gt; &#xA;   &lt;td&gt;return informations for specific type&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.fields(type)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;iterator&lt;/td&gt; &#xA;   &lt;td&gt;iterate all fields in a message&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.field(type, string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;see below&lt;/td&gt; &#xA;   &lt;td&gt;return informations for specific field of type&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.typefmt(type)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;String&lt;/td&gt; &#xA;   &lt;td&gt;transform type name of field into pack/unpack formatter&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.enum(type, string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;number&lt;/td&gt; &#xA;   &lt;td&gt;get the value of a enum by name&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.enum(type, number)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;string&lt;/td&gt; &#xA;   &lt;td&gt;get the name of a enum by value&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.defaults(type[, table/nil])&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;table&lt;/td&gt; &#xA;   &lt;td&gt;get the default table of type&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.hook(type[, function])&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;function&lt;/td&gt; &#xA;   &lt;td&gt;get or set hook functions&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.option(string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;string&lt;/td&gt; &#xA;   &lt;td&gt;set options to decoder/encoder&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.state()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.State&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;retrieve current pb state&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.state(newstate | nil)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.State&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;set new pb state and retrieve the old one&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Schema loading&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;pb.load()&lt;/code&gt; accepts the schema binary data and returns a boolean indicates the result of loading, success or failure, and a offset reading in schema so far that is useful to figure out the reason of failure.&lt;/p&gt; &#xA;&lt;h4&gt;Type mapping&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Protobuf Types&lt;/th&gt; &#xA;   &lt;th&gt;Lua Types&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;double&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;number&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;fixed32&lt;/code&gt;, &lt;code&gt;sfixed32&lt;/code&gt;, &lt;code&gt;sint32&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;number&lt;/code&gt; or &lt;code&gt;integer&lt;/code&gt; in Lua 5.3+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;, &lt;code&gt;fixed64&lt;/code&gt;, &lt;code&gt;sfixed64&lt;/code&gt;, &lt;code&gt;sint64&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;number&lt;/code&gt; or &lt;code&gt;&#34;#&#34;&lt;/code&gt; prefixed &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;integer&lt;/code&gt; in Lua 5.3+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bytes&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;message&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;table&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Type Information&lt;/h4&gt; &#xA;&lt;p&gt;Using &lt;code&gt;pb.(type|field)[s]()&lt;/code&gt; functions retrieve type information for loaded messages.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;pb.type()&lt;/code&gt; returns multiple informations for specified type:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;name : the full qualifier name of type, e.g. &#34;.package.TypeName&#34;&lt;/li&gt; &#xA; &lt;li&gt;basename: the type name without package prefix, e.g. &#34;TypeName&#34;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;map&#34;&lt;/code&gt; | &lt;code&gt;&#34;enum&#34;&lt;/code&gt; | &lt;code&gt;&#34;message&#34;&lt;/code&gt;: whether the type is a map_entry type, enum type or message type.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;pb.types()&lt;/code&gt; returns a iterators, behavior like call &lt;code&gt;pb.type()&lt;/code&gt; on every types of all messages.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;print(pb.type &#34;MyType&#34;)&#xA;&#xA;-- list all types that loaded into pb&#xA;for name, basename, type in pb.types() do&#xA;  print(name, basename, type)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;pb.field()&lt;/code&gt; returns information of the specified field for one type:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;name: the name of the field&lt;/li&gt; &#xA; &lt;li&gt;number: number of field in the schema&lt;/li&gt; &#xA; &lt;li&gt;type: field type&lt;/li&gt; &#xA; &lt;li&gt;default value: if no default value, nil&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;packed&#34;&lt;/code&gt;|&lt;code&gt;&#34;repeated&#34;&lt;/code&gt;| &lt;code&gt;&#34;optional&#34;&lt;/code&gt;: label of the field, optional or repeated, required is not supported&lt;/li&gt; &#xA; &lt;li&gt;[oneof_name, oneof_index]: if this is a &lt;code&gt;oneof&lt;/code&gt; field, this is the &lt;code&gt;oneof&lt;/code&gt; name and index&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And &lt;code&gt;pb.fields()&lt;/code&gt; iterates all fields in a message:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;print(pb.field(&#34;MyType&#34;, &#34;the_first_field&#34;))&#xA;&#xA;-- notice that you needn&#39;t receive all return values from iterator&#xA;for name, number, type in pb.fields &#34;MyType&#34; do&#xA;  print(name, number, type)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;pb.enum()&lt;/code&gt; maps from enum name and value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;protoc:load [[&#xA;enum Color { Red = 1; Green = 2; Blue = 3 }&#xA;]]&#xA;print(pb.enum(&#34;Color&#34;, &#34;Red&#34;)) --&amp;gt; 1&#xA;print(pb.enum(&#34;Color&#34;, 2)) --&amp;gt; &#34;Green&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Default Values&lt;/h4&gt; &#xA;&lt;p&gt;Using &lt;code&gt;pb.defaults()&lt;/code&gt; to get or set a table with all default values from a message. this table will be used as the metatable of the corresponding decoded message table when setting &lt;code&gt;use_default_metatable&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;p&gt;You could also call &lt;code&gt;pb.defaults&lt;/code&gt; with &lt;code&gt;&#34;*map&#34;&lt;/code&gt; or &lt;code&gt;&#34;*array&#34;&lt;/code&gt; to get the default metatable for map and array when decoding a message. These settings will bypass &lt;code&gt;use_default_metatable&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;p&gt;To clear a default metatable, just pass &lt;code&gt;nil&lt;/code&gt; as second argument to &lt;code&gt;pb.defaults()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;   check_load [[&#xA;      message TestDefault {&#xA;         optional int32 defaulted_int = 10 [ default = 777 ];&#xA;         optional bool defaulted_bool = 11 [ default = true ];&#xA;         optional string defaulted_str = 12 [ default = &#34;foo&#34; ];&#xA;         optional float defaulted_num = 13 [ default = 0.125 ];&#xA;      } ]]&#xA;   print(require &#34;serpent&#34;.block(pb.defaults &#34;TestDefault&#34;))&#xA;-- output:&#xA;-- {&#xA;--   defaulted_bool = true,&#xA;--   defaulted_int = 777,&#xA;--   defaulted_num = 0.125,&#xA;--   defaulted_str = &#34;foo&#34;&#xA;-- } --[[table: 0x7f8c1e52b050]]&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Hooks&lt;/h4&gt; &#xA;&lt;p&gt;If set &lt;code&gt;pb.option &#34;enable_hooks&#34;&lt;/code&gt;, the hook function will be enabled. you could use &lt;code&gt;pb.hook()&lt;/code&gt; and &lt;code&gt;pb.encode_hook&lt;/code&gt; to set or get a decode or encode hook function, respectively: call it with type name directly get current setted hook; call it with two arguments to set a hook; and call it with &lt;code&gt;nil&lt;/code&gt; as the second argument to remove the hook. in all case, the original one will be returned.&lt;/p&gt; &#xA;&lt;p&gt;After the hook function setted and hook enabled, the decode function will be called &lt;em&gt;after&lt;/em&gt; a message get decoded and encode functions will be called &lt;em&gt;before&lt;/em&gt; the message is encoded. So you could get all values in the table passed to hook function. That&#39;s the only argument of hook.&lt;/p&gt; &#xA;&lt;p&gt;If you need type name in hook functions, use this helper:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local function make_hook(name, func)&#xA;  return pb.hook(name, function(t)&#xA;    return func(name, t)&#xA;  end)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Options&lt;/h4&gt; &#xA;&lt;p&gt;Setting options to change the behavior of other routines. These options are supported currently:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Option&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;enum_as_name&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;set value to enum name when decode a enum &lt;strong&gt;(default)&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;enum_as_value&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;set value to enum value when decode a enum&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;int64_as_number&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;set value to integer when it fit into uint32, otherwise return a number &lt;strong&gt;(default)&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;int64_as_string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;same as above, but return a string instead&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;int64_as_hexstring&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;same as above, but return a hexadigit string instead&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;auto_default_values&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;act as &lt;code&gt;use_default_values&lt;/code&gt; for proto3 and act as &lt;code&gt;no_default_values&lt;/code&gt; for the others &lt;strong&gt;(default)&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;no_default_values&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;do not default values for decoded message table&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;use_default_values&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;set default values by copy values from default table before decode&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;use_default_metatable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;set default values by set table from &lt;code&gt;pb.default()&lt;/code&gt; as the metatable&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;enable_hooks&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.decode&lt;/code&gt; will call &lt;code&gt;pb.hooks()&lt;/code&gt; hook functions&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;disable_hooks&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;pb.decode&lt;/code&gt; do not call hooks &lt;strong&gt;(default)&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;encode_default_values&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;default values also encode&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;no_encode_default_values&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;do not encode default values &lt;strong&gt;(default)&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;decode_default_array&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;work with &lt;code&gt;no_default_values&lt;/code&gt;,decode null to empty table for array&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;no_decode_default_array&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;work with &lt;code&gt;no_default_values&lt;/code&gt;,decode null to nil for array &lt;strong&gt;(default)&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;encode_order&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;guarantees the same message will be encoded into the same result with the same schema and the same data (but the order itself is not specified)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;no_encode_order&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;do not have guarantees about encode orders &lt;strong&gt;(default)&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;decode_default_message&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;decode null message to default message table&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;no_decode_default_message&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;decode null message to null &lt;strong&gt;(default)&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: The string returned by &lt;code&gt;int64_as_string&lt;/code&gt; or &lt;code&gt;int64_as_hexstring&lt;/code&gt; will prefix a &lt;code&gt;&#39;#&#39;&lt;/code&gt; character. Because Lua may convert between string with number, prefix a &lt;code&gt;&#39;#&#39;&lt;/code&gt; makes Lua return the string as-is.&lt;/p&gt; &#xA;&lt;p&gt;all routines in all module accepts &lt;code&gt;&#39;#&#39;&lt;/code&gt; prefix &lt;code&gt;string&lt;/code&gt;/&lt;code&gt;hex string&lt;/code&gt; as arguments regardless of the option setting.&lt;/p&gt; &#xA;&lt;h4&gt;Multiple State&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;pb&lt;/code&gt; module support multiple states. A state is a database that contains all type information of registered messages. You can retrieve current state by &lt;code&gt;pb.state()&lt;/code&gt;, or set new state by &lt;code&gt;pb.state(newstate)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;pb.state(nil)&lt;/code&gt; to discard current state, but not to set a new one (the following routines call that use the state will create a new default state automatedly). Use &lt;code&gt;pb.state()&lt;/code&gt; to retrieve current state without setting a new one. e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local old = pb.state(nil)&#xA;-- if you use protoc.lua, call protoc.reload() here.&#xA;assert(pb.load(...))&#xA;-- do someting ...&#xA;pb.state(old)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that if you use &lt;code&gt;protoc.lua&lt;/code&gt; module, it will register some message to the state, so you should call &lt;code&gt;proto.reload()&lt;/code&gt; after setting a new state.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;pb.io&lt;/code&gt; Module&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;pb.io&lt;/code&gt; module reads binary data from a file or &lt;code&gt;stdin&lt;/code&gt;/&lt;code&gt;stdout&lt;/code&gt;, &lt;code&gt;pb.io.read()&lt;/code&gt; reads binary data from a file, or &lt;code&gt;stdin&lt;/code&gt; if no file name given as the first parameter.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;pb.io.write()&lt;/code&gt; and &lt;code&gt;pb.io.dump()&lt;/code&gt; are same as Lua&#39;s &lt;code&gt;io.write()&lt;/code&gt; except they write binary data. the former writes data to &lt;code&gt;stdout&lt;/code&gt;, and the latter writes data to a file specified by the first parameter as the file name.&lt;/p&gt; &#xA;&lt;p&gt;All these functions return a true value when success, and return &lt;code&gt;nil, errmsg&lt;/code&gt; when an error occurs.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Function&lt;/th&gt; &#xA;   &lt;th&gt;Returns&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;io.read()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;string&lt;/td&gt; &#xA;   &lt;td&gt;read all binary data from &lt;code&gt;stdin&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;io.read(string)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;string&lt;/td&gt; &#xA;   &lt;td&gt;read all binary data from file name&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;io.write(...)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;true&lt;/td&gt; &#xA;   &lt;td&gt;write binary data to &lt;code&gt;stdout&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;io.dump(string, ...)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;string&lt;/td&gt; &#xA;   &lt;td&gt;write binary data to file name&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;&lt;code&gt;pb.conv&lt;/code&gt; Module&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;pb.conv&lt;/code&gt; provide functions to convert between numbers.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Encode Function&lt;/th&gt; &#xA;   &lt;th&gt;Decode Function&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;conv.encode_int32()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;conv.decode_int32()&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;conv.encode_uint32()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;conv.decode_uint32()&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;conv.encode_sint32()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;conv.decode_sint32()&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;conv.encode_sint64()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;conv.decode_sint64()&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;conv.encode_float()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;conv.decode_float()&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;conv.encode_double()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;conv.decode_double()&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;&lt;code&gt;pb.slice&lt;/code&gt; Module&lt;/h3&gt; &#xA;&lt;p&gt;Slice object parse binary protobuf data in a low-level way. Use &lt;code&gt;slice.new()&lt;/code&gt; to create a slice object, with the optional offset &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; to access a subpart of the original data (named a &lt;em&gt;view&lt;/em&gt;).&lt;/p&gt; &#xA;&lt;p&gt;As protobuf usually nest sub message with in a range of slice, a slice object has a stack itself to support this. Calling &lt;code&gt;s:enter(i, j)&lt;/code&gt; saves current position and enters next level with the optional offset &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; just as &lt;code&gt;slice.new()&lt;/code&gt;. calling &lt;code&gt;s:leave()&lt;/code&gt; restore the prior view. &lt;code&gt;s:level()&lt;/code&gt; returns the current level, and &lt;code&gt;s:level(n)&lt;/code&gt; returns the current position, the start and the end position information of the &lt;code&gt;n&lt;/code&gt;th level. calling &lt;code&gt;s:enter()&lt;/code&gt; without parameter will read a length delimited type value from the slice and enter the view in reading value. Using &lt;code&gt;#a&lt;/code&gt; to get the count of bytes remains in current view.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local s = slice.new(&#34;&amp;lt;data here&amp;gt;&#34;)&#xA;local tag = s:unpack &#34;v&#34;&#xA;if tag%8 == 2 then -- tag has a type of string/bytes? maybe it&#39;s a sub-message.&#xA;  s:enter() -- read following bytes value, and enter the view of bytes value.&#xA;  -- do something with bytes value, e.g. reads a lot of fixed32 integers from bytes.&#xA;  local t = {}&#xA;  while #s &amp;gt; 0 do&#xA;    t[#t+1] = s:unpack &#34;d&#34;&#xA;  end&#xA;  s:leave() -- after done, leave bytes value and ready to read next value.&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To read values from slice, use &lt;code&gt;slice.unpack()&lt;/code&gt;, it use a format string to control how to read into a slice as below table (same format character are also used in &lt;code&gt;buffer.pack()&lt;/code&gt;). Notice that you can use &lt;code&gt;pb.typefmt()&lt;/code&gt; to convert between format and protobuf type names (returned from &lt;code&gt;pb.field()&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Format&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v&lt;/td&gt; &#xA;   &lt;td&gt;variable Int value&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;d&lt;/td&gt; &#xA;   &lt;td&gt;4 bytes fixed32 value&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;q&lt;/td&gt; &#xA;   &lt;td&gt;8 bytes fixed64 value&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;s&lt;/td&gt; &#xA;   &lt;td&gt;length delimited value, usually a &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bytes&lt;/code&gt; or &lt;code&gt;message&lt;/code&gt; in protobuf.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;c&lt;/td&gt; &#xA;   &lt;td&gt;receive a extra number parameter &lt;code&gt;count&lt;/code&gt; after the format, and reads &lt;code&gt;count&lt;/code&gt; bytes in slice.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;b&lt;/td&gt; &#xA;   &lt;td&gt;variable int value as a Lua &lt;code&gt;boolean&lt;/code&gt; value.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;f&lt;/td&gt; &#xA;   &lt;td&gt;4 bytes &lt;code&gt;fixed32&lt;/code&gt; value as floating point &lt;code&gt;number&lt;/code&gt; value.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;F&lt;/td&gt; &#xA;   &lt;td&gt;8 bytes &lt;code&gt;fixed64&lt;/code&gt; value as floating point &lt;code&gt;number&lt;/code&gt; value.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;i&lt;/td&gt; &#xA;   &lt;td&gt;variable int value as signed int value, i.e. &lt;code&gt;int32&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;j&lt;/td&gt; &#xA;   &lt;td&gt;variable int value as zig-zad encoded signed int value, i.e.&lt;code&gt;sint32&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;u&lt;/td&gt; &#xA;   &lt;td&gt;variable int value as unsigned int value, i.e. &lt;code&gt;uint32&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;x&lt;/td&gt; &#xA;   &lt;td&gt;4 bytes fixed32 value as unsigned fixed32 value, i.e.&lt;code&gt;fixed32&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;y&lt;/td&gt; &#xA;   &lt;td&gt;4 bytes fixed32 value as signed fixed32 value, i.e. &lt;code&gt;sfixed32&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;I&lt;/td&gt; &#xA;   &lt;td&gt;variable int value as signed int value, i.e.&lt;code&gt;int64&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;J&lt;/td&gt; &#xA;   &lt;td&gt;variable int value as zig-zad encoded signed int value, i.e. &lt;code&gt;sint64&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;U&lt;/td&gt; &#xA;   &lt;td&gt;variable int value and treat it as &lt;code&gt;uint64&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;8 bytes fixed64 value as unsigned fixed64 value, i.e. &lt;code&gt;fixed64&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Y&lt;/td&gt; &#xA;   &lt;td&gt;8 bytes fixed64 value as signed fixed64 value, i.e. &lt;code&gt;sfixed64&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;And extra format can be used to control the read cursor in one &lt;code&gt;slice.unpack()&lt;/code&gt; process:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Format&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;@&lt;/td&gt; &#xA;   &lt;td&gt;returns current cursor position in the slice, related with the beginning of the current view.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;*&lt;/td&gt; &#xA;   &lt;td&gt;set the current cursor position to the extra parameter after format string.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;+&lt;/td&gt; &#xA;   &lt;td&gt;set the relate cursor position, i.e. add the extra parameter to the current position.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;e.g. If you want to read a &lt;code&gt;varint&lt;/code&gt; value twice, you can write it as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local v1, v2 = s:unpack(&#34;v*v&#34;, 1)&#xA;-- v: reads a `varint` value&#xA;-- *: receive the second parameter 1 and set it to the current cursor position, i.e. restore the cursor to the head of the view&#xA;-- v: reads the first `varint` value again&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All routines in &lt;code&gt;pb.slice&lt;/code&gt; module:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Function&lt;/th&gt; &#xA;   &lt;th&gt;Returns&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;slice.new(data[,i[,j]])&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Slice object&lt;/td&gt; &#xA;   &lt;td&gt;create a new slice object&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;s:delete()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;none&lt;/td&gt; &#xA;   &lt;td&gt;same as &lt;code&gt;s:reset()&lt;/code&gt;, free it&#39;s content&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;tostring(s)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;string&lt;/td&gt; &#xA;   &lt;td&gt;return the string repr of the object&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;#s&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;number&lt;/td&gt; &#xA;   &lt;td&gt;returns the count of bytes can read in current view&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;s:result([i[, j]])&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;String&lt;/td&gt; &#xA;   &lt;td&gt;return the remaining bytes in current view&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;s:reset([...])&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;self&lt;/td&gt; &#xA;   &lt;td&gt;reset object to another data&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;s:level()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;number&lt;/td&gt; &#xA;   &lt;td&gt;returns the count of stored state&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;s:level(number)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;p, i, j&lt;/td&gt; &#xA;   &lt;td&gt;returns the informations of the &lt;code&gt;n&lt;/code&gt;th stored state&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;s:enter()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;self&lt;/td&gt; &#xA;   &lt;td&gt;reads a bytes value, and enter it&#39;s view&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;s:enter(i[, j])&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;self&lt;/td&gt; &#xA;   &lt;td&gt;enter a view start at &lt;code&gt;i&lt;/code&gt; and ends at &lt;code&gt;j&lt;/code&gt;, includes&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;s:leave([number])&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;self, n&lt;/td&gt; &#xA;   &lt;td&gt;leave the number count of level (default 1) and return current level&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;s:unpack(fmt, ...)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;values...&lt;/td&gt; &#xA;   &lt;td&gt;reads values of current view from slice&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;&lt;code&gt;pb.buffer&lt;/code&gt; Module&lt;/h3&gt; &#xA;&lt;p&gt;Buffer module used to construct a protobuf data format stream in a low-level way. It&#39;s just a bytes data buffer. using &lt;code&gt;buffer.pack()&lt;/code&gt; to append values to the buffer, and &lt;code&gt;buffer.result()&lt;/code&gt; to get the encoded raw data, or &lt;code&gt;buffer.tohex()&lt;/code&gt; to get the human-readable hex digit value of data.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;buffer.pack()&lt;/code&gt; use the same format syntax with &lt;code&gt;slice.unpack()&lt;/code&gt;, and support &lt;code&gt;&#39;()&#39;&lt;/code&gt; format means the inner value will be encoded as a length delimited value, i.e. a message value encoded format.&lt;/p&gt; &#xA;&lt;p&gt;parenthesis can be nested.&lt;/p&gt; &#xA;&lt;p&gt;e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;b:pack(&#34;(vvv)&#34;, 1, 2, 3) -- get a bytes value that contains three varint value.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;buffer.pack()&lt;/code&gt; also support &#39;#&#39; format, it means prepends a length into the buffer.&lt;/p&gt; &#xA;&lt;p&gt;e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;b:pack(&#34;#&#34;, 5) -- prepends a varint length #b-5+1 at offset 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All routines in &lt;code&gt;pb.buffer&lt;/code&gt; module:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Function&lt;/th&gt; &#xA;   &lt;th&gt;Returns&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;buffer.new([...])&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Buffer object&lt;/td&gt; &#xA;   &lt;td&gt;create a new buffer object, extra args will passed to &lt;code&gt;b:reset()&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;b:delete()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;none&lt;/td&gt; &#xA;   &lt;td&gt;same as &lt;code&gt;b:reset()&lt;/code&gt;, free it&#39;s content&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;tostring(b)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;string&lt;/td&gt; &#xA;   &lt;td&gt;returns the string repr of the object&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;#b&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;number&lt;/td&gt; &#xA;   &lt;td&gt;returns the encoded count of bytes in buffer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;b:reset()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;self&lt;/td&gt; &#xA;   &lt;td&gt;reset to a empty buffer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;b:reset([...])&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;self&lt;/td&gt; &#xA;   &lt;td&gt;resets the buffer and set its content as the concat of it&#39;s args&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;b:tohex([i[, j]])&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;string&lt;/td&gt; &#xA;   &lt;td&gt;return the string of hexadigit represent of the data, &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; are ranges in encoded data, includes. Omit it means the whole range&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;b:result([i[,j]])&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;string&lt;/td&gt; &#xA;   &lt;td&gt;return the raw data, &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; are ranges in encoded data, includes,. Omit it means the whole range&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;b:pack(fmt, ...)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;self&lt;/td&gt; &#xA;   &lt;td&gt;encode the values passed to &lt;code&gt;b:pack()&lt;/code&gt;, use &lt;code&gt;fmt&lt;/code&gt; to indicate how to encode value&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
</feed>