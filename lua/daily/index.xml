<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-12T01:34:10Z</updated>
  <subtitle>Daily Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>m-demare/hlargs.nvim</title>
    <updated>2022-12-12T01:34:10Z</updated>
    <id>tag:github.com,2022-12-12:/m-demare/hlargs.nvim</id>
    <link href="https://github.com/m-demare/hlargs.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Highlight arguments&#39; definitions and usages, using Treesitter&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;hlargs.nvim&lt;/h1&gt; &#xA;&lt;p&gt;Highlight arguments&#39; definitions and usages, asynchronously, using Treesitter&lt;/p&gt; &#xA;&lt;h2&gt;Preview&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Before&lt;/th&gt; &#xA;   &lt;th&gt;After&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/34817965/153656813-8c037f48-70a8-486d-890a-484695b33067.png&#34; alt=&#34;before&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/34817965/153656820-65bc6144-c4e7-4b5c-a671-0ada8cd8c0eb.png&#34; alt=&#34;after&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;This plugin is for &lt;a href=&#34;https://neovim.io/&#34;&gt;neovim&lt;/a&gt; only. Version 0.7+ is recommended. If you are using 0.6, use the branch &lt;code&gt;0.6-compat&lt;/code&gt; and an appropriate nvim-treesitter version (installation instructions in the README of that branch).&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;packer.nvim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use {&#xA;  &#39;m-demare/hlargs.nvim&#39;,&#xA;  requires = { &#39;nvim-treesitter/nvim-treesitter&#39; }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/junegunn/vim-plug&#34;&gt;vim-plug&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;Plug &#39;nvim-treesitter/nvim-treesitter&#39;&#xA;Plug &#39;m-demare/hlargs.nvim&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;If you are ok with the default settings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;hlargs&#39;).setup()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To change the settings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;hlargs&#39;).setup {&#xA;  color = &#39;#ef9062&#39;,&#xA;  highlight = {},&#xA;  excluded_filetypes = {},&#xA;  disable = function(lang, bufnr) -- If changed, `excluded_filetypes` will be ignored&#xA;    return vim.tbl_contains(opts.excluded_filetypes, lang)&#xA;  end,&#xA;  paint_arg_declarations = true,&#xA;  paint_arg_usages = true,&#xA;  paint_catch_blocks = {&#xA;    declarations = false,&#xA;    usages = false&#xA;  },&#xA;  extras = {&#xA;    named_parameters = false,&#xA;  },&#xA;  hl_priority = 10000,&#xA;  excluded_argnames = {&#xA;    declarations = {},&#xA;    usages = {&#xA;      python = { &#39;self&#39;, &#39;cls&#39; },&#xA;      lua = { &#39;self&#39; }&#xA;    }&#xA;  },&#xA;  performance = {&#xA;    parse_delay = 1,&#xA;    slow_parse_delay = 50,&#xA;    max_iterations = 400,&#xA;    max_concurrent_partial_parses = 30,&#xA;    debounce = {&#xA;      partial_parse = 3,&#xA;      partial_insert_mode = 100,&#xA;      total_parse = 700,&#xA;      slow_parse = 5000&#xA;    }&#xA;  }&#xA;}&#xA;-- (You may omit the settings whose defaults you&#39;re ok with)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To understand the performance settings see &lt;a href=&#34;https://raw.githubusercontent.com/m-demare/hlargs.nvim/main/#performance&#34;&gt;performance&lt;/a&gt;. The other settings should be self explainatory&lt;/p&gt; &#xA;&lt;p&gt;After setup, the plugin will be enabled. You can enable/disable/toggle it using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;hlargs&#39;).enable()&#xA;require(&#39;hlargs&#39;).disable()&#xA;require(&#39;hlargs&#39;).toggle()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Dynamically change color&lt;/h2&gt; &#xA;&lt;p&gt;If you want to change the color dynamically, according to filetype or whatever, you can do that using the highlight group &lt;code&gt;Hlargs&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Supported languages&lt;/h2&gt; &#xA;&lt;p&gt;Currently these languages are supported&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;c&lt;/li&gt; &#xA; &lt;li&gt;cpp&lt;/li&gt; &#xA; &lt;li&gt;go&lt;/li&gt; &#xA; &lt;li&gt;java&lt;/li&gt; &#xA; &lt;li&gt;javascript&lt;/li&gt; &#xA; &lt;li&gt;jsx (react)&lt;/li&gt; &#xA; &lt;li&gt;julia&lt;/li&gt; &#xA; &lt;li&gt;lua&lt;/li&gt; &#xA; &lt;li&gt;php&lt;/li&gt; &#xA; &lt;li&gt;python&lt;/li&gt; &#xA; &lt;li&gt;r&lt;/li&gt; &#xA; &lt;li&gt;ruby&lt;/li&gt; &#xA; &lt;li&gt;rust&lt;/li&gt; &#xA; &lt;li&gt;tsx (react)&lt;/li&gt; &#xA; &lt;li&gt;typescript&lt;/li&gt; &#xA; &lt;li&gt;vim&lt;/li&gt; &#xA; &lt;li&gt;zig&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that you have to install each language&#39;s parser using &lt;code&gt;:TSInstall {lang}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;jsx&lt;/code&gt; parser gets installed with the &lt;code&gt;javascript&lt;/code&gt; one, but &lt;code&gt;tsx&lt;/code&gt; parser is independent from the &lt;code&gt;typescript&lt;/code&gt; one&lt;/p&gt; &#xA;&lt;h3&gt;Request new language&lt;/h3&gt; &#xA;&lt;p&gt;Please include a sample file with your request, that covers most of the edge cases that specific language allows for (nested functions, lambda functions, member functions, parameter destructuring, optional parameters, rest paratemeters, etc). See &lt;a href=&#34;https://github.com/m-demare/hlargs.nvim/tree/main/testfiles&#34;&gt;examples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Also do note that I can&#39;t support a language that doesn&#39;t have a Treesitter parser implemented. Check &lt;a href=&#34;https://github.com/nvim-treesitter/nvim-treesitter#supported-languages&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;This plugin uses a combination of incremental and total parsing, to achieve both great speed and consistent highlighting results. It works as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When a new buffer is opened, or when a file is externally modified, a total parse task is launched. This is CPU intensive, but should rarely happen&lt;/li&gt; &#xA; &lt;li&gt;When the buffer is modified, a partial task is launched for every modified group of lines (identifying the region that should be parsed depending on what was modified), up to &lt;code&gt;max_concurrent_partial_parses&lt;/code&gt;. If this is exceeded (e.g. by a big find and replace), a total parse task is launched. Partial tasks are extremely fast/lightweight, allowing for real time highlighting with barely any CPU impact. However, it is not 100% precise, in some weird edge cases it might miss some usages. Hence, upon every change, with a big debouncing, a &#34;slow&#34; task is launched&lt;/li&gt; &#xA; &lt;li&gt;Slow tasks are the same as total tasks, except they are throttled on purpose so that they use basically 0 CPU. The idea is that partial tasks are generally very precise, so these just run in the background when needed to fix some of the small imprecisions that might be left&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The results of these 3 types of tasks are merged in order to always show the most up to date information&lt;/p&gt; &#xA;&lt;p&gt;There are a couple of settings that let you adjust performance to your own use case. I recommend only playing with them if you are having some specific issue, otherwise the defaults should work fine&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;parse_delay&lt;/code&gt; is the time between parsing iterations, left for vim to compute other events. Longer means less CPU load, but slower parsing (default: 1ms)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;slow_parse_delay &lt;/code&gt; is the same as &lt;code&gt;parse_delay&lt;/code&gt;, but for slow tasks. I should be set in a value such that CPU usage from slow parses is negligible (default: 50ms)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max_iterations&lt;/code&gt; is the maximum amount of functions it will parse. The main objective of this is that it doesn&#39;t waste too much time parsing huge minified files, but you can set it lower if your PC struggles with smaller files (default: 400)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max_concurrent_partial_parses&lt;/code&gt; is the maximum amount of partial parsing tasks allowed. If the limit is exceeded, no more partial tasks will launch, and instead a single total task will be used (default: 30)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;debounce.partial_parse&lt;/code&gt;: the time it waits for new changes before launching the partial tasks for some changes. The idea is that when multiple changes happen in a short amount of time, overlapping changes can be merged into a single task (default: 3ms)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;debounce.partial_insert_mode&lt;/code&gt;: same as previous, but for insert mode. If you don&#39;t want real time highlighting in insert mode, you can increase this to 1-2 seconds (default: 100ms)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;debounce.total_parse&lt;/code&gt;: same but for total parses. Rarely used. (default: 700ms)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;debounce.slow_parse&lt;/code&gt;: same but for slow parses. It affects how quickly the highlighting will regain consistency after it is lost, but you shouldn&#39;t set it too low, it might have a big impact (default: 5000ms)&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>