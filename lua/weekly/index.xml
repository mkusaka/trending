<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-11-17T01:40:17Z</updated>
  <subtitle>Weekly Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Saghen/blink.cmp</title>
    <updated>2024-11-17T01:40:17Z</updated>
    <id>tag:github.com,2024-11-17:/Saghen/blink.cmp</id>
    <link href="https://github.com/Saghen/blink.cmp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Performant, batteries-included completion plugin for Neovim&lt;/p&gt;&lt;hr&gt;&lt;blockquote&gt; &#xA; &lt;p&gt;[!WARNING] This plugin is &lt;em&gt;beta&lt;/em&gt; quality. Expect breaking changes and many bugs&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Blink Completion (blink.cmp)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;blink.cmp&lt;/strong&gt; is a completion plugin with support for LSPs and external sources that updates on every keystroke with minimal overhead (0.5-4ms async). It use a &lt;a href=&#34;https://github.com/saghen/frizbee&#34;&gt;custom SIMD fuzzy searcher&lt;/a&gt; to easily handle &amp;gt;20k items. It provides extensibility via hooks into the trigger, sources and rendering pipeline. Plenty of work has been put into making each stage of the pipeline as intelligent as possible, such as frecency and proximity bonus on fuzzy matching, and this work is on-going.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/user-attachments/assets/9849e57a-3c2c-49a8-959c-dbb7fef78c80&#34;&gt;https://github.com/user-attachments/assets/9849e57a-3c2c-49a8-959c-dbb7fef78c80&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Works out of the box with no additional configuration&lt;/li&gt; &#xA; &lt;li&gt;Updates on every keystroke (0.5-4ms async, single core)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/saghen/frizbee&#34;&gt;Typo resistant fuzzy&lt;/a&gt; with frecency and proximity bonus&lt;/li&gt; &#xA; &lt;li&gt;Extensive LSP support (&lt;a href=&#34;https://raw.githubusercontent.com/Saghen/blink.cmp/main/LSP_TRACKER.md&#34;&gt;tracker&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Native &lt;code&gt;vim.snippet&lt;/code&gt; support (including &lt;code&gt;friendly-snippets&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;External sources support (&lt;a href=&#34;https://github.com/Saghen/blink.compat&#34;&gt;compatibility layer for &lt;code&gt;nvim-cmp&lt;/code&gt; sources&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Auto-bracket support based on semantic tokens (experimental, opt-in)&lt;/li&gt; &#xA; &lt;li&gt;Signature help (experimental, opt-in)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Saghen/blink.cmp/main/#compared-to-nvim-cmp&#34;&gt;Comparison with nvim-cmp&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Neovim 0.10+&lt;/li&gt; &#xA; &lt;li&gt;curl&lt;/li&gt; &#xA; &lt;li&gt;git&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;lazy.nvim&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  &#39;saghen/blink.cmp&#39;,&#xA;  lazy = false, -- lazy loading handled internally&#xA;  -- optional: provides snippets for the snippet source&#xA;  dependencies = &#39;rafamadriz/friendly-snippets&#39;,&#xA;&#xA;  -- use a release tag to download pre-built binaries&#xA;  version = &#39;v0.*&#39;,&#xA;  -- OR build from source, requires nightly: https://rust-lang.github.io/rustup/concepts/channels.html#working-with-nightly-rust&#xA;  -- build = &#39;cargo build --release&#39;,&#xA;  -- If you use nix, you can build from source using latest nightly rust with:&#xA;  -- build = &#39;nix run .#build-plugin&#39;,&#xA;&#xA;  ---@module &#39;blink.cmp&#39;&#xA;  ---@type blink.cmp.Config&#xA;  opts = {&#xA;    -- &#39;default&#39; for mappings similar to built-in completion&#xA;    -- &#39;super-tab&#39; for mappings similar to vscode (tab to accept, arrow keys to navigate)&#xA;    -- &#39;enter&#39; for mappings similar to &#39;super-tab&#39; but with &#39;enter&#39; to accept&#xA;    -- see the &#34;default configuration&#34; section below for full documentation on how to define&#xA;    -- your own keymap.&#xA;    keymap = { preset = &#39;default&#39; },&#xA;&#xA;    highlight = {&#xA;      -- sets the fallback highlight groups to nvim-cmp&#39;s highlight groups&#xA;      -- useful for when your theme doesn&#39;t support blink.cmp&#xA;      -- will be removed in a future release, assuming themes add support&#xA;      use_nvim_cmp_as_default = true,&#xA;    },&#xA;    -- set to &#39;mono&#39; for &#39;Nerd Font Mono&#39; or &#39;normal&#39; for &#39;Nerd Font&#39;&#xA;    -- adjusts spacing to ensure icons are aligned&#xA;    nerd_font_variant = &#39;mono&#39;,&#xA;&#xA;    -- experimental auto-brackets support&#xA;    -- accept = { auto_brackets = { enabled = true } }&#xA;&#xA;    -- experimental signature help support&#xA;    -- trigger = { signature_help = { enabled = true } }&#xA;  },&#xA;  -- allows extending the enabled_providers array elsewhere in your config&#xA;  -- without having to redefining it&#xA;  opts_extend = { &#34;sources.completion.enabled_providers&#34; }&#xA;},&#xA;&#xA;-- LSP servers and clients communicate what features they support through &#34;capabilities&#34;.&#xA;--  By default, Neovim support a subset of the LSP specification.&#xA;--  With blink.cmp, Neovim has *more* capabilities which are communicated to the LSP servers.&#xA;--  Explanation from TJ: https://youtu.be/m8C0Cq9Uv9o?t=1275&#xA;--&#xA;-- This can vary by config, but in general for nvim-lspconfig:&#xA;&#xA;{&#xA;  &#39;neovim/nvim-lspconfig&#39;,&#xA;  dependencies = { &#39;saghen/blink.cmp&#39; },&#xA;  config = function(_, opts)&#xA;    local lspconfig = require(&#39;lspconfig&#39;)&#xA;    for server, config in pairs(opts.servers or {}) do&#xA;      config.capabilities = require(&#39;blink.cmp&#39;).get_lsp_capabilities(config.capabilities)&#xA;      lspconfig[server].setup(config)&#xA;    end&#xA;  end&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;mini.deps&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- use a release tag to download pre-built binaries&#xA;MiniDeps.add({&#xA;  source = &#34;saghen/blink.cmp&#34;,&#xA;  depends = {&#xA;  &#34;rafamadriz/friendly-snippets&#34;,&#xA;  },&#xA;  checkout = &#34;some.version&#34;, -- check releases for latest tag&#xA;})&#xA;&#xA;-- OR build from source, requires nightly: https://rust-lang.github.io/rustup/concepts/channels.html#working-with-nightly-rust&#xA;local function build_blink(params)&#xA;  vim.notify(&#39;Building blink.cmp&#39;, vim.log.levels.INFO)&#xA;  local obj = vim.system({ &#39;cargo&#39;, &#39;build&#39;, &#39;--release&#39; }, { cwd = params.path }):wait()&#xA;  if obj.code == 0 then&#xA;    vim.notify(&#39;Building blink.cmp done&#39;, vim.log.levels.INFO)&#xA;  else&#xA;    vim.notify(&#39;Building blink.cmp failed&#39;, vim.log.levels.ERROR)&#xA;  end&#xA;end&#xA;&#xA;MiniDeps.add({&#xA;  source = &#39;Saghen/blink.cmp&#39;,&#xA;  hooks = {&#xA;    post_install = build_blink,&#xA;    post_checkout = build_blink,&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Highlight groups&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;table&gt; &#xA;  &lt;thead&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;th&gt;Group&lt;/th&gt; &#xA;    &lt;th&gt;Default&lt;/th&gt; &#xA;    &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/thead&gt; &#xA;  &lt;tbody&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpMenu&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;Pmenu&lt;/td&gt; &#xA;    &lt;td&gt;The completion menu window&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpMenuBorder&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;Pmenu&lt;/td&gt; &#xA;    &lt;td&gt;The completion menu window border&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpMenuSelection&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;PmenuSel&lt;/td&gt; &#xA;    &lt;td&gt;The completion menu window selected item&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpScrollBarThumb&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;PmenuThumb&lt;/td&gt; &#xA;    &lt;td&gt;The scrollbar thumb&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpScrollBarGutter&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;PmenuSbar&lt;/td&gt; &#xA;    &lt;td&gt;The scrollbar gutter&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpLabel&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;Pmenu&lt;/td&gt; &#xA;    &lt;td&gt;Label of the completion item&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpLabelDeprecated&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;Comment&lt;/td&gt; &#xA;    &lt;td&gt;Deprecated label of the completion item&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpLabelMatch&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;Pmenu&lt;/td&gt; &#xA;    &lt;td&gt;(Currently unused) Label of the completion item when it matches the query&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpGhostText&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;Comment&lt;/td&gt; &#xA;    &lt;td&gt;Preview item with ghost text&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpKind&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;Special&lt;/td&gt; &#xA;    &lt;td&gt;Kind icon/text of the completion item&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpKind&amp;lt;kind&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;Special&lt;/td&gt; &#xA;    &lt;td&gt;Kind icon/text of the completion item&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpDoc&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;NormalFloat&lt;/td&gt; &#xA;    &lt;td&gt;The documentation window&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpDocBorder&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;NormalFloat&lt;/td&gt; &#xA;    &lt;td&gt;The documentation window border&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpDocCursorLine&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;Visual&lt;/td&gt; &#xA;    &lt;td&gt;The documentation window cursor line&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpSignatureHelp&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;NormalFloat&lt;/td&gt; &#xA;    &lt;td&gt;The signature help window&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpSignatureHelpBorder&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;NormalFloat&lt;/td&gt; &#xA;    &lt;td&gt;The signature help window border&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;code&gt;BlinkCmpSignatureHelpActiveParameter&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;LspSignatureActiveParameter&lt;/td&gt; &#xA;    &lt;td&gt;Active parameter of the signature help&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/tbody&gt; &#xA; &lt;/table&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Default configuration&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;!-- config:start --&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  -- The keymap can be:&#xA;  --   - A preset (&#39;default&#39; | &#39;super-tab&#39; | &#39;enter&#39;)&#xA;  --   - A table of keys =&amp;gt; command[] (optionally with a &#34;preset&#34; key to merge with a preset)&#xA;  --&#xA;  -- When specifying &#39;preset&#39; in the keymap table, the custom key mappings are merged with the preset,&#xA;  -- and any conflicting keys will overwrite the preset mappings.&#xA;  -- The &#34;fallback&#34; command will run the next non blink keymap.&#xA;  --&#xA;  -- Example:&#xA;  --&#xA;  -- keymap = {&#xA;  --   preset = &#39;default&#39;,&#xA;  --   [&#39;&amp;lt;Up&amp;gt;&#39;] = { &#39;select_prev&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;Down&amp;gt;&#39;] = { &#39;select_next&#39;, &#39;fallback&#39; },&#xA;  -- &#xA;  --   -- disable a keymap from the preset&#xA;  --   [&#39;&amp;lt;C-e&amp;gt;&#39;] = {},&#xA;  -- },&#xA;  --&#xA;  -- When defining your own keymaps without a preset, no keybinds will be assigned automatically.&#xA;  --&#xA;  -- Available commands:&#xA;  --   show, hide, accept, select_and_accept, select_prev, select_next, show_documentation, hide_documentation,&#xA;  --   scroll_documentation_up, scroll_documentation_down, snippet_forward, snippet_backward, fallback&#xA;  --&#xA;  -- &#34;default&#34; keymap&#xA;  --   [&#39;&amp;lt;C-space&amp;gt;&#39;] = { &#39;show&#39;, &#39;show_documentation&#39;, &#39;hide_documentation&#39; },&#xA;  --   [&#39;&amp;lt;C-e&amp;gt;&#39;] = { &#39;hide&#39; },&#xA;  --   [&#39;&amp;lt;C-y&amp;gt;&#39;] = { &#39;select_and_accept&#39; },&#xA;  --&#xA;  --   [&#39;&amp;lt;C-p&amp;gt;&#39;] = { &#39;select_prev&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;C-n&amp;gt;&#39;] = { &#39;select_next&#39;, &#39;fallback&#39; },&#xA;  --&#xA;  --   [&#39;&amp;lt;C-b&amp;gt;&#39;] = { &#39;scroll_documentation_up&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;C-f&amp;gt;&#39;] = { &#39;scroll_documentation_down&#39;, &#39;fallback&#39; },&#xA;  --&#xA;  --   [&#39;&amp;lt;Tab&amp;gt;&#39;] = { &#39;snippet_forward&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;S-Tab&amp;gt;&#39;] = { &#39;snippet_backward&#39;, &#39;fallback&#39; },&#xA;  --&#xA;  -- &#34;super-tab&#34; keymap&#xA;  --   you may want to set `trigger.completion.show_in_snippet = false`&#xA;  --   or use `window.autocomplete.selection = &#34;manual&#34; | &#34;auto_insert&#34;`&#xA;  --&#xA;  --   [&#39;&amp;lt;C-space&amp;gt;&#39;] = { &#39;show&#39;, &#39;show_documentation&#39;, &#39;hide_documentation&#39; },&#xA;  --   [&#39;&amp;lt;C-e&amp;gt;&#39;] = { &#39;hide&#39;, &#39;fallback&#39; },&#xA;  --&#xA;  --   [&#39;&amp;lt;Tab&amp;gt;&#39;] = {&#xA;  --     function(cmp)&#xA;  --       if cmp.is_in_snippet() then return cmp.accept()&#xA;  --       else return cmp.select_and_accept() end&#xA;  --     end,&#xA;  --     &#39;snippet_forward&#39;,&#xA;  --     &#39;fallback&#39;&#xA;  --   },&#xA;  --   [&#39;&amp;lt;S-Tab&amp;gt;&#39;] = { &#39;snippet_backward&#39;, &#39;fallback&#39; },&#xA;  --&#xA;  --   [&#39;&amp;lt;Up&amp;gt;&#39;] = { &#39;select_prev&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;Down&amp;gt;&#39;] = { &#39;select_next&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;C-p&amp;gt;&#39;] = { &#39;select_prev&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;C-n&amp;gt;&#39;] = { &#39;select_next&#39;, &#39;fallback&#39; },&#xA;  --&#xA;  --   [&#39;&amp;lt;C-b&amp;gt;&#39;] = { &#39;scroll_documentation_up&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;C-f&amp;gt;&#39;] = { &#39;scroll_documentation_down&#39;, &#39;fallback&#39; },&#xA;  --&#xA;  -- &#34;enter&#34; keymap&#xA;  --   you may want to set `window.autocomplete.selection = &#34;manual&#34; | &#34;auto_insert&#34;`&#xA;  --&#xA;  --   [&#39;&amp;lt;C-space&amp;gt;&#39;] = { &#39;show&#39;, &#39;show_documentation&#39;, &#39;hide_documentation&#39; },&#xA;  --   [&#39;&amp;lt;C-e&amp;gt;&#39;] = { &#39;hide&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;CR&amp;gt;&#39;] = { &#39;accept&#39;, &#39;fallback&#39; },&#xA;  --&#xA;  --   [&#39;&amp;lt;Tab&amp;gt;&#39;] = { &#39;snippet_forward&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;S-Tab&amp;gt;&#39;] = { &#39;snippet_backward&#39;, &#39;fallback&#39; },&#xA;  --&#xA;  --   [&#39;&amp;lt;Up&amp;gt;&#39;] = { &#39;select_prev&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;Down&amp;gt;&#39;] = { &#39;select_next&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;C-p&amp;gt;&#39;] = { &#39;select_prev&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;C-n&amp;gt;&#39;] = { &#39;select_next&#39;, &#39;fallback&#39; },&#xA;  --&#xA;  --   [&#39;&amp;lt;C-b&amp;gt;&#39;] = { &#39;scroll_documentation_up&#39;, &#39;fallback&#39; },&#xA;  --   [&#39;&amp;lt;C-f&amp;gt;&#39;] = { &#39;scroll_documentation_down&#39;, &#39;fallback&#39; },&#xA;  keymap = &#39;default&#39;,&#xA;&#xA;  accept = {&#xA;    create_undo_point = true,&#xA;    -- Function used to expand snippets, some possible values:&#xA;    -- require(&#39;luasnip&#39;).lsp_expand     -- For `luasnip` users.&#xA;    -- require(&#39;snippy&#39;).expand_snippet  -- For `snippy` users.&#xA;    -- vim.fn[&#34;UltiSnips#Anon&#34;]          -- For `ultisnips` users.&#xA;    expand_snippet = vim.snippet.expand,&#xA;&#xA;    auto_brackets = {&#xA;      enabled = false,&#xA;      default_brackets = { &#39;(&#39;, &#39;)&#39; },&#xA;      override_brackets_for_filetypes = {},&#xA;      -- Overrides the default blocked filetypes&#xA;      force_allow_filetypes = {},&#xA;      blocked_filetypes = {},&#xA;      -- Synchronously use the kind of the item to determine if brackets should be added&#xA;      kind_resolution = {&#xA;        enabled = true,&#xA;        blocked_filetypes = { &#39;typescriptreact&#39;, &#39;javascriptreact&#39;, &#39;vue&#39; },&#xA;      },&#xA;      -- Asynchronously use semantic token to determine if brackets should be added&#xA;      semantic_token_resolution = {&#xA;        enabled = true,&#xA;        blocked_filetypes = {},&#xA;        -- How long to wait for semantic tokens to return before assuming no brackets should be added&#xA;        timeout_ms = 400,&#xA;      },&#xA;    },&#xA;  },&#xA;&#xA;  trigger = {&#xA;    completion = {&#xA;      -- &#39;prefix&#39; will fuzzy match on the text before the cursor&#xA;      -- &#39;full&#39; will fuzzy match on the text before *and* after the cursor&#xA;      -- example: &#39;foo_|_bar&#39; will match &#39;foo_&#39; for &#39;prefix&#39; and &#39;foo__bar&#39; for &#39;full&#39;&#xA;      keyword_range = &#39;prefix&#39;,&#xA;      -- regex used to get the text when fuzzy matching&#xA;      -- changing this may break some sources, so please report if you run into issues&#xA;      -- TODO: shouldnt this also affect the accept command? should this also be per language?&#xA;      keyword_regex = &#39;[%w_\\-]&#39;,&#xA;      -- after matching with keyword_regex, any characters matching this regex at the prefix will be excluded&#xA;      exclude_from_prefix_regex = &#39;[\\-]&#39;,&#xA;      -- LSPs can indicate when to show the completion window via trigger characters&#xA;      -- however, some LSPs (i.e. tsserver) return characters that would essentially&#xA;      -- always show the window. We block these by default&#xA;      blocked_trigger_characters = { &#39; &#39;, &#39;\n&#39;, &#39;\t&#39; },&#xA;      -- when true, will show the completion window when the cursor comes after a trigger character after accepting an item&#xA;      show_on_accept_on_trigger_character = true,&#xA;      -- when true, will show the completion window when the cursor comes after a trigger character when entering insert mode&#xA;      show_on_insert_on_trigger_character = true,&#xA;      -- list of additional trigger characters that won&#39;t trigger the completion window when the cursor comes after a trigger character when entering insert mode/accepting an item&#xA;      show_on_x_blocked_trigger_characters = { &#34;&#39;&#34;, &#39;&#34;&#39;, &#39;(&#39; },&#xA;      -- when false, will not show the completion window automatically when in a snippet&#xA;      show_in_snippet = true,&#xA;    },&#xA;&#xA;    signature_help = {&#xA;      enabled = false,&#xA;      blocked_trigger_characters = {},&#xA;      blocked_retrigger_characters = {},&#xA;      -- when true, will show the signature help window when the cursor comes after a trigger character when entering insert mode&#xA;      show_on_insert_on_trigger_character = true,&#xA;    },&#xA;  },&#xA;&#xA;  fuzzy = {&#xA;    -- when enabled, allows for a number of typos relative to the length of the query&#xA;    -- disabling this matches the behavior of fzf&#xA;    use_typo_resistance = true,&#xA;    -- frencency tracks the most recently/frequently used items and boosts the score of the item&#xA;    use_frecency = true,&#xA;    -- proximity bonus boosts the score of items matching nearby words&#xA;    use_proximity = true,&#xA;    max_items = 200,&#xA;    -- controls which sorts to use and in which order, these three are currently the only allowed options&#xA;    sorts = { &#39;label&#39;, &#39;kind&#39;, &#39;score&#39; },&#xA;&#xA;    prebuilt_binaries = {&#xA;      -- Whether or not to automatically download a prebuilt binary from github. If this is set to `false`&#xA;      -- you will need to manually build the fuzzy binary dependencies by running `cargo build --release`&#xA;      download = true,&#xA;      -- When downloading a prebuilt binary, force the downloader to resolve this version. If this is unset&#xA;      -- then the downloader will attempt to infer the version from the checked out git tag (if any).&#xA;      --&#xA;      -- Beware that if the FFI ABI changes while tracking main then this may result in blink breaking.&#xA;      force_version = nil,&#xA;      -- When downloading a prebuilt binary, force the downloader to use this system triple. If this is unset&#xA;      -- then the downloader will attempt to infer the system triple from `jit.os` and `jit.arch`.&#xA;      -- Check the latest release for all available system triples&#xA;      --&#xA;      -- Beware that if the FFI ABI changes while tracking main then this may result in blink breaking.&#xA;      force_system_triple = nil,&#xA;    },&#xA;  },&#xA;&#xA;  sources = {&#xA;    -- list of enabled providers&#xA;    completion = {&#xA;      enabled_providers = { &#39;lsp&#39;, &#39;path&#39;, &#39;snippets&#39;, &#39;buffer&#39; },&#xA;    }&#xA;&#xA;    -- Please see https://github.com/Saghen/blink.compat for using `nvim-cmp` sources&#xA;    providers = {&#xA;      lsp = {&#xA;        name = &#39;LSP&#39;,&#xA;        module = &#39;blink.cmp.sources.lsp&#39;,&#xA;&#xA;        --- *All* of the providers have the following options available&#xA;        --- NOTE: All of these options may be functions to get dynamic behavior&#xA;        --- See the type definitions for more information&#xA;        enabled = true, -- whether or not to enable the provider&#xA;        transform_items = nil, -- function to transform the items before they&#39;re returned&#xA;        should_show_items = true, -- whether or not to show the items&#xA;        max_items = nil, -- maximum number of items to return&#xA;        min_keyword_length = 0, -- minimum number of characters to trigger the provider&#xA;        fallback_for = {}, -- if any of these providers return 0 items, it will fallback to this provider&#xA;        score_offset = 0, -- boost/penalize the score of the items&#xA;        override = nil, -- override the source&#39;s functions&#xA;      },&#xA;      path = {&#xA;        name = &#39;Path&#39;,&#xA;        module = &#39;blink.cmp.sources.path&#39;,&#xA;        score_offset = 3,&#xA;        opts = {&#xA;          trailing_slash = false,&#xA;          label_trailing_slash = true,&#xA;          get_cwd = function(context) return vim.fn.expand((&#39;#%d:p:h&#39;):format(context.bufnr)) end,&#xA;          show_hidden_files_by_default = false,&#xA;        }&#xA;      },&#xA;      snippets = {&#xA;        name = &#39;Snippets&#39;,&#xA;        module = &#39;blink.cmp.sources.snippets&#39;,&#xA;        score_offset = -3,&#xA;        opts = {&#xA;          friendly_snippets = true,&#xA;          search_paths = { vim.fn.stdpath(&#39;config&#39;) .. &#39;/snippets&#39; },&#xA;          global_snippets = { &#39;all&#39; },&#xA;          extended_filetypes = {},&#xA;          ignored_filetypes = {},&#xA;        }&#xA;&#xA;        --- Example usage for disabling the snippet provider after pressing trigger characters (i.e. &#34;.&#34;)&#xA;        -- enabled = function(ctx) return ctx ~= nil and ctx.trigger.kind == vim.lsp.protocol.CompletionTriggerKind.TriggerCharacter end,&#xA;      },&#xA;      buffer = {&#xA;        name = &#39;Buffer&#39;,&#xA;        module = &#39;blink.cmp.sources.buffer&#39;,&#xA;        fallback_for = { &#39;lsp&#39; },&#xA;      },&#xA;    },&#xA;  },&#xA;&#xA;  windows = {&#xA;    autocomplete = {&#xA;      min_width = 15,&#xA;      max_height = 10,&#xA;      border = &#39;none&#39;,&#xA;      winblend = 0,&#xA;      winhighlight = &#39;Normal:BlinkCmpMenu,FloatBorder:BlinkCmpMenuBorder,CursorLine:BlinkCmpMenuSelection,Search:None&#39;,&#xA;      -- keep the cursor X lines away from the top/bottom of the window&#xA;      scrolloff = 2,&#xA;      -- note that the gutter will be disabled when border ~= &#39;none&#39;&#xA;      scrollbar = true,&#xA;      -- which directions to show the window,&#xA;      -- falling back to the next direction when there&#39;s not enough space&#xA;      direction_priority = { &#39;s&#39;, &#39;n&#39; },&#xA;      -- Controls whether the completion window will automatically show when typing&#xA;      auto_show = true,&#xA;      -- Controls how the completion items are selected&#xA;      -- &#39;preselect&#39; will automatically select the first item in the completion list&#xA;      -- &#39;manual&#39; will not select any item by default&#xA;      -- &#39;auto_insert&#39; will not select any item by default, and insert the completion items automatically when selecting them&#xA;      selection = &#39;preselect&#39;,&#xA;      -- Controls how the completion items are rendered on the popup window&#xA;      draw = {&#xA;        align_to_component = &#39;label&#39;, -- or &#39;none&#39; to disable&#xA;        -- Left and right padding, optionally { left, right } for different padding on each side&#xA;        padding = 1,&#xA;        -- Gap between columns&#xA;        gap = 1,&#xA;&#xA;        -- Components to render, grouped by column&#xA;        columns = { { &#39;kind_icon&#39; }, { &#39;label&#39;, &#39;label_description&#39;, gap = 1 } },&#xA;        -- for a setup similar to nvim-cmp: https://github.com/Saghen/blink.cmp/pull/245#issuecomment-2463659508&#xA;        -- columns = { { &#34;label&#34;, &#34;label_description&#34;, gap = 1 }, { &#34;kind_icon&#34;, &#34;kind&#34; } },&#xA;&#xA;        -- Definitions for possible components to render. Each component defines:&#xA;        --   ellipsis: whether to add an ellipsis when truncating the text&#xA;        --   width: control the min, max and fill behavior of the component&#xA;        --   text function: will be called for each item&#xA;        --   highlight function: will be called only when the line appears on screen&#xA;        components = {&#xA;          kind_icon = {&#xA;            ellipsis = false,&#xA;            text = function(ctx) return ctx.kind_icon .. ctx.icon_gap end,&#xA;            highlight = function(ctx) return utils.get_tailwind_hl(ctx) or &#39;BlinkCmpKind&#39; .. ctx.kind end,&#xA;          },&#xA;&#xA;          kind = {&#xA;            ellipsis = false,&#xA;            width = { fill = true },&#xA;            text = function(ctx) return ctx.kind end,&#xA;            highlight = function(ctx) return utils.get_tailwind_hl(ctx) or &#39;BlinkCmpKind&#39; .. ctx.kind end,&#xA;          },&#xA;&#xA;          label = {&#xA;            width = { fill = true, max = 60 },&#xA;            text = function(ctx) return ctx.label .. ctx.label_detail end,&#xA;            highlight = function(ctx)&#xA;              -- label and label details&#xA;              local highlights = {&#xA;                { 0, #ctx.label, group = ctx.deprecated and &#39;BlinkCmpLabelDeprecated&#39; or &#39;BlinkCmpLabel&#39; },&#xA;              }&#xA;              if ctx.label_detail then&#xA;                table.insert(highlights, { #ctx.label, #ctx.label + #ctx.label_detail, group = &#39;BlinkCmpLabelDetail&#39; })&#xA;              end&#xA;&#xA;              -- characters matched on the label by the fuzzy matcher&#xA;              for _, idx in ipairs(ctx.label_matched_indices) do&#xA;                table.insert(highlights, { idx, idx + 1, group = &#39;BlinkCmpLabelMatch&#39; })&#xA;              end&#xA;&#xA;              return highlights&#xA;            end,&#xA;          },&#xA;&#xA;          label_description = {&#xA;            width = { max = 30 },&#xA;            text = function(ctx) return ctx.label_description end,&#xA;            highlight = &#39;BlinkCmpLabelDescription&#39;,&#xA;          },&#xA;        },&#xA;      },&#xA;      -- Controls the cycling behavior when reaching the beginning or end of the completion list.&#xA;      cycle = {&#xA;        -- When `true`, calling `select_next` at the *bottom* of the completion list will select the *first* completion item.&#xA;        from_bottom = true,&#xA;        -- When `true`, calling `select_prev` at the *top* of the completion list will select the *last* completion item.&#xA;        from_top = true,&#xA;      },&#xA;    },&#xA;    documentation = {&#xA;      min_width = 10,&#xA;      max_width = 60,&#xA;      max_height = 20,&#xA;      border = &#39;padded&#39;,&#xA;      winblend = 0,&#xA;      winhighlight = &#39;Normal:BlinkCmpDoc,FloatBorder:BlinkCmpDocBorder,CursorLine:BlinkCmpDocCursorLine,Search:None&#39;,&#xA;      -- note that the gutter will be disabled when border ~= &#39;none&#39;&#xA;      scrollbar = true,&#xA;      -- which directions to show the documentation window,&#xA;      -- for each of the possible autocomplete window directions,&#xA;      -- falling back to the next direction when there&#39;s not enough space&#xA;      direction_priority = {&#xA;        autocomplete_north = { &#39;e&#39;, &#39;w&#39;, &#39;n&#39;, &#39;s&#39; },&#xA;        autocomplete_south = { &#39;e&#39;, &#39;w&#39;, &#39;s&#39;, &#39;n&#39; },&#xA;      },&#xA;      -- Controls whether the documentation window will automatically show when selecting a completion item&#xA;      auto_show = false,&#xA;      auto_show_delay_ms = 500,&#xA;      update_delay_ms = 50,&#xA;      -- whether to use treesitter highlighting, disable if you run into performance issues&#xA;      -- WARN: temporary, eventually blink will support regex highlighting&#xA;      treesitter_highlighting = true,&#xA;    },&#xA;    signature_help = {&#xA;      min_width = 1,&#xA;      max_width = 100,&#xA;      max_height = 10,&#xA;      border = &#39;padded&#39;,&#xA;      winblend = 0,&#xA;      winhighlight = &#39;Normal:BlinkCmpSignatureHelp,FloatBorder:BlinkCmpSignatureHelpBorder&#39;,&#xA;      -- note that the gutter will be disabled when border ~= &#39;none&#39;&#xA;      scrollbar = false,&#xA;&#xA;      -- which directions to show the window,&#xA;      -- falling back to the next direction when there&#39;s not enough space&#xA;      direction_priority = { &#39;n&#39;, &#39;s&#39; },&#xA;      -- whether to use treesitter highlighting, disable if you run into performance issues&#xA;      -- WARN: temporary, eventually blink will support regex highlighting&#xA;      treesitter_highlighting = true,&#xA;    },&#xA;    ghost_text = {&#xA;      enabled = false,&#xA;    },&#xA;  },&#xA;&#xA;  highlight = {&#xA;    ns = vim.api.nvim_create_namespace(&#39;blink_cmp&#39;),&#xA;    -- sets the fallback highlight groups to nvim-cmp&#39;s highlight groups&#xA;    -- useful for when your theme doesn&#39;t support blink.cmp&#xA;    -- will be removed in a future release, assuming themes add support&#xA;    use_nvim_cmp_as_default = false,&#xA;  },&#xA;&#xA;  -- set to &#39;mono&#39; for &#39;Nerd Font Mono&#39; or &#39;normal&#39; for &#39;Nerd Font&#39;&#xA;  -- adjusts spacing to ensure icons are aligned&#xA;  nerd_font_variant = &#39;mono&#39;,&#xA;&#xA;  -- don&#39;t show completions or signature help for these filetypes. Keymaps are also disabled.&#xA;  blocked_filetypes = {},&#xA;&#xA;  kind_icons = {&#xA;    Text = &#39;ó°‰¿&#39;,&#xA;    Method = &#39;ó°Š•&#39;,&#xA;    Function = &#39;ó°Š•&#39;,&#xA;    Constructor = &#39;ó°’“&#39;,&#xA;&#xA;    Field = &#39;ó°œ¢&#39;,&#xA;    Variable = &#39;ó°†¦&#39;,&#xA;    Property = &#39;ó°–·&#39;,&#xA;&#xA;    Class = &#39;ó±¡ &#39;,&#xA;    Interface = &#39;ó±¡ &#39;,&#xA;    Struct = &#39;ó±¡ &#39;,&#xA;    Module = &#39;ó°…©&#39;,&#xA;&#xA;    Unit = &#39;ó°ªš&#39;,&#xA;    Value = &#39;ó°¦¨&#39;,&#xA;    Enum = &#39;ó°¦¨&#39;,&#xA;    EnumMember = &#39;ó°¦¨&#39;,&#xA;&#xA;    Keyword = &#39;ó°»¾&#39;,&#xA;    Constant = &#39;ó°¿&#39;,&#xA;&#xA;    Snippet = &#39;ó±„½&#39;,&#xA;    Color = &#39;ó°˜&#39;,&#xA;    File = &#39;ó°ˆ”&#39;,&#xA;    Reference = &#39;ó°¬²&#39;,&#xA;    Folder = &#39;ó°‰‹&#39;,&#xA;    Event = &#39;ó±‹&#39;,&#xA;    Operator = &#39;ó°ªš&#39;,&#xA;    TypeParameter = &#39;ó°¬›&#39;,&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;!-- config:end --&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;strong&gt;Community Sources&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/folke/lazydev.nvim&#34;&gt;lazydev&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/netmute/blink-cmp-ctags&#34;&gt;ctags&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/niuiic/blink-cmp-rg.nvim&#34;&gt;ripgrep&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/mikavilpas/blink-ripgrep.nvim&#34;&gt;blink-ripgrep&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/kristijanhusak/vim-dadbod-completion&#34;&gt;vim-dadbod-completion&lt;/a&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;How it works&lt;/h2&gt; &#xA;&lt;p&gt;The plugin use a 4 stage pipeline: trigger -&amp;gt; sources -&amp;gt; fuzzy -&amp;gt; render&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Trigger:&lt;/strong&gt; Controls when to request completion items from the sources and provides a context downstream with the current query (i.e. &lt;code&gt;hello.wo|&lt;/code&gt;, the query would be &lt;code&gt;wo&lt;/code&gt;) and the treesitter object under the cursor (i.e. for intelligently enabling/disabling sources). It respects trigger characters passed by the LSP (or any other source) and includes it in the context for sending to the LSP.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Sources:&lt;/strong&gt; Provides a common interface for and merges the results of completion, trigger character, resolution of additional information and cancellation. Some sources are builtin: &lt;code&gt;LSP&lt;/code&gt;, &lt;code&gt;buffer&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;snippets&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fuzzy:&lt;/strong&gt; Rust &amp;lt;-&amp;gt; Lua FFI which performs both filtering and sorting of the items&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;Filtering:&lt;/strong&gt; The fuzzy matching uses smith-waterman, same as FZF, but implemented in SIMD for ~6x the performance of FZF (TODO: add benchmarks). Due to the SIMD&#39;s performance, the prefiltering phase on FZF was dropped to allow for typos. Similar to fzy/fzf, additional points are given to prefix matches, characters with capitals (to promote camelCase/PascalCase first char matching) and matches after delimiters (to promote snake_case first char matching)&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;Sorting:&lt;/strong&gt; Combines fuzzy matching score with frecency and proximity bonus. Each completion item may also include a &lt;code&gt;score_offset&lt;/code&gt; which will be added to this score to demote certain sources. The &lt;code&gt;snippets&lt;/code&gt; source takes advantage of this to avoid taking precedence over the LSP source. The parameters here still need to be tuned, so please let me know if you find some magical parameters!&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Windows:&lt;/strong&gt; Responsible for placing the autocomplete, documentation and function parameters windows. All of the rendering can be overridden following a syntax similar to incline.nvim. It uses the neovim window decoration provider to provide next to no overhead from highlighting.&lt;/p&gt; &#xA;&lt;h2&gt;Compared to nvim-cmp&lt;/h2&gt; &#xA;&lt;h3&gt;Advantages&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Avoids the complexity of nvim-cmp&#39;s configuration by providing sensible defaults&lt;/li&gt; &#xA; &lt;li&gt;Updates on every keystroke with 0.5-4ms of overhead, versus nvim-cmp&#39;s default debounce of 60ms with 2-50ms hitches from processing &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Setting nvim-cmp&#39;s debounce to 0ms leads to visible stuttering. If you&#39;d like to stick with nvim-cmp, try &lt;a href=&#34;https://github.com/yioneko/nvim-cmp&#34;&gt;yioneko&#39;s fork&lt;/a&gt; or the more recent &lt;a href=&#34;https://github.com/iguanacucumber/magazine.nvim&#34;&gt;magazine.nvim&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Boosts completion item score via frecency &lt;em&gt;and&lt;/em&gt; proximity bonus. nvim-cmp only boosts score via proximity bonus and optionally by recency&lt;/li&gt; &#xA; &lt;li&gt;Typo-resistant fuzzy matching unlike nvim-cmp&#39;s fzf-style fuzzy matching&lt;/li&gt; &#xA; &lt;li&gt;Core sources (buffer, snippets, path, lsp) are built-in versus nvim-cmp&#39;s exclusively external sources&lt;/li&gt; &#xA; &lt;li&gt;Built-in auto bracket and signature help support&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Planned missing features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Significantly more testing and documentation&lt;/li&gt; &#xA; &lt;li&gt;Cmdline completions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Special Thanks&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/hrsh7th/&#34;&gt;@hrsh7th&lt;/a&gt; nvim-cmp used as inspiration and nvim-path implementation modified for path source&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/garymjr&#34;&gt;@garymjr&lt;/a&gt; nvim-snippets implementation modified for snippets source&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/redxtech&#34;&gt;@redxtech&lt;/a&gt; Help with design and testing&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/aaditya-sahay&#34;&gt;@aaditya-sahay&lt;/a&gt; Help with rust, design and testing&lt;/p&gt; &#xA;&lt;h3&gt;Contributors&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/stefanboca&#34;&gt;@stefanboca&lt;/a&gt; Author of &lt;a href=&#34;https://github.com/saghen/blink.compat&#34;&gt;blink.compat&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/lopi-py&#34;&gt;@lopi-py&lt;/a&gt; Contributes to the windowing code&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/scottmckendry&#34;&gt;@scottmckendry&lt;/a&gt; Contributes to the CI and prebuilt binaries&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Balssh&#34;&gt;@balssh&lt;/a&gt; Manages nixpkg and nixvim&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>linkease/istore</title>
    <updated>2024-11-17T01:40:17Z</updated>
    <id>tag:github.com,2024-11-17:/linkease/istore</id>
    <link href="https://github.com/linkease/istore" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ä¸€ä¸ª Openwrt æ ‡å‡†çš„è½¯ä»¶ä¸­å¿ƒï¼Œçº¯è„šæœ¬å®ç°ï¼Œåªä¾èµ–Openwrtæ ‡å‡†ç»„ä»¶ã€‚æ”¯æŒå…¶å®ƒå›ºä»¶å¼€å‘è€…é›†æˆåˆ°è‡ªå·±çš„å›ºä»¶é‡Œé¢ã€‚æ›´æ–¹ä¾¿å…¥é—¨ç”¨æˆ·æœç´¢å®‰è£…æ’ä»¶ã€‚The iStore is a app store for OpenWRT&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;iStore&lt;/h1&gt; &#xA;&lt;h2&gt;ä»‹ç»&lt;/h2&gt; &#xA;&lt;p&gt;iStore æ˜¯ä¸€ä¸ª&lt;a href=&#34;https://github.com/linkease/istore&#34;&gt;å¼€æº&lt;/a&gt;ä¸”æ ‡å‡†çš„ OpenWRT è½¯ä»¶ä¸­å¿ƒå®ç°ã€‚&lt;/p&gt; &#xA;&lt;p&gt;æ˜¯å±äºæ˜“æœ‰äº‘å›¢é˜Ÿçš„å›ºä»¶ &lt;a href=&#34;https://github.com/istoreos&#34;&gt;iStoreOS&lt;/a&gt; çš„ä¸€éƒ¨åˆ†ã€‚&lt;/p&gt; &#xA;&lt;p&gt;iStore çš„è®¾è®¡ç›®æ ‡ï¼š&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;æ–¹ä¾¿ç”¨æˆ·å®‰è£…æ’ä»¶&lt;/li&gt; &#xA; &lt;li&gt;æ¯ä¸ªæ’ä»¶éƒ½æœ‰æ•™ç¨‹ï¼Œæ–¹ä¾¿åˆå­¦è€…å…¥é—¨ä½¿ç”¨æ’ä»¶&lt;/li&gt; &#xA; &lt;li&gt;é€‚é…æ‰€æœ‰çš„ OpenWRT çš®è‚¤ï¼Œä»¥åŠç§»åŠ¨ç«¯&lt;/li&gt; &#xA; &lt;li&gt;å…¨éƒ¨åŸºäº OpenWRT çš„æ ‡å‡†æ¥å£å¼€å‘ï¼Œä¸ç”¨ä»¥å‰ KoolShare LEDE çš„ç‰¹æœ‰çš„æ’ä»¶é£æ ¼çš„è½¯ä»¶ä¸­å¿ƒ&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;iStore çš„æ— æ³•å¼¥è¡¥çš„ç¼ºé™·ï¼š&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;å› ä¸º OpenWRT ç‰ˆæœ¬ç‰¹åˆ«å¤šï¼Œå¯¼è‡´ä¸åŒå¹³å°çš„æ’ä»¶ä¾èµ–ä¸ä¸€æ ·ã€‚æ‰€ä»¥å³ä½¿ä½ çš„ç³»ç»Ÿèƒ½å®‰è£… iStoreï¼ŒiStore é‡Œé¢çš„æ’ä»¶ä¸ä¸€å®šèƒ½å®‰è£…&lt;/li&gt; &#xA; &lt;li&gt;æˆ‘ä»¬éœ€è¦å›ºä»¶å¼€å‘è€…è‡ªä¸»é›†æˆ iStoreï¼Œå¹¶è§£å†³ iStore é‡Œé¢çš„å„ç§æ’ä»¶çš„ä¾èµ–&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;æˆ‘ä»¬å»ºè®®å›ºä»¶å¼€å‘è€…é›†æˆ iStoreï¼Œè¿™æ ·å›ºä»¶å¼€å‘è€…åªéœ€è¦å‘å¸ƒä¸€ä¸ªç²¾ç®€å›ºä»¶ï¼Œç”¨æˆ·å¯ä»¥æŒ‰éœ€å®‰è£…è‡ªå·±å–œæ¬¢çš„æ’ä»¶ã€‚è¿˜èƒ½å…±äº«æ’ä»¶çš„æ•™ç¨‹ï¼Œç‹¬ç«‹æ›´æ–°æŸä¸ªæ’ä»¶ç‰ˆæœ¬ã€‚&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;21ç‰ˆæœ¬çš„å›ºä»¶å®‰è£… iStore éœ€è¦ä¾èµ– &lt;code&gt;luci-compat&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;å®‰è£… iStore åˆ° OpenWRT å®˜æ–¹å›ºä»¶&lt;/h2&gt; &#xA;&lt;p&gt;åªæ”¯æŒ x86_64 å’Œ arm64 è®¾å¤‡ã€‚&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;opkg update || exit 1&#xA;cd /tmp&#xA;wget https://github.com/linkease/openwrt-app-actions/raw/main/applications/luci-app-systools/root/usr/share/systools/istore-reinstall.run&#xA;chmod 755 istore-reinstall.run&#xA;./istore-reinstall.run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;é›†æˆåˆ°è‡ªå·±ç¼–è¯‘çš„å›ºä»¶ä¸­&lt;/h2&gt; &#xA;&lt;p&gt;iStore å®˜æ–¹çš„è½¯ä»¶ä»“åº“æ”¯æŒ &lt;code&gt;x86_64&lt;/code&gt;ï¼Œ&lt;code&gt;arm64&lt;/code&gt; ä¸¤ä¸ªæ¶æ„ï¼Œè¿™ä¸¤ä¸ªæ¶æ„çš„åŸºäº &lt;strong&gt;OpenWRT&lt;/strong&gt; å›ºä»¶éƒ½å¯ä»¥ç›´æ¥é›†æˆ iStore&lt;/p&gt; &#xA;&lt;p&gt;åªéœ€åœ¨å›ºä»¶ç¼–è¯‘ç›®å½•ä¸‹æ‰§è¡Œï¼š&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &amp;gt;&amp;gt; feeds.conf.default&#xA;echo &#39;src-git istore https://github.com/linkease/istore;main&#39; &amp;gt;&amp;gt; feeds.conf.default&#xA;./scripts/feeds update istore&#xA;./scripts/feeds install -d y -p istore luci-app-store&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ç„¶åæ­£å¸¸ç¼–è¯‘å›ºä»¶å³å¯&lt;/p&gt; &#xA;&lt;h2&gt;åŠŸèƒ½é¢„è§ˆ&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/linkease/istore/main/preview/istore-preview.png&#34; alt=&#34;istore-preview.png&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>frankroeder/parrot.nvim</title>
    <updated>2024-11-17T01:40:17Z</updated>
    <id>tag:github.com,2024-11-17:/frankroeder/parrot.nvim</id>
    <link href="https://github.com/frankroeder/parrot.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;parrot.nvim ğŸ¦œ - the plugin that brings stochastic parrots to Neovim. This is a gp.nvim-fork focused on simplicity.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;parrot.nvim ğŸ¦œ&lt;/h1&gt; &#xA; &lt;p&gt;This is &lt;a href=&#34;https://github.com/frankroeder/parrot.nvim&#34;&gt;parrot.nvim&lt;/a&gt;, the ultimate &lt;a href=&#34;https://en.wikipedia.org/wiki/Stochastic_parrot&#34;&gt;stochastic parrot&lt;/a&gt; to support your text editing inside Neovim.&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/frankroeder/parrot.nvim/main/#features&#34;&gt;Features&lt;/a&gt; â€¢ &lt;a href=&#34;https://raw.githubusercontent.com/frankroeder/parrot.nvim/main/#demo&#34;&gt;Demo&lt;/a&gt; â€¢ &lt;a href=&#34;https://raw.githubusercontent.com/frankroeder/parrot.nvim/main/#getting-started&#34;&gt;Getting Started&lt;/a&gt; â€¢ &lt;a href=&#34;https://raw.githubusercontent.com/frankroeder/parrot.nvim/main/#commands&#34;&gt;Commands&lt;/a&gt; â€¢ &lt;a href=&#34;https://raw.githubusercontent.com/frankroeder/parrot.nvim/main/#configuration&#34;&gt;Configuration&lt;/a&gt; â€¢ &lt;a href=&#34;https://raw.githubusercontent.com/frankroeder/parrot.nvim/main/#roadmap&#34;&gt;Roadmap&lt;/a&gt; â€¢ &lt;a href=&#34;https://raw.githubusercontent.com/frankroeder/parrot.nvim/main/#faq&#34;&gt;FAQ&lt;/a&gt;&lt;/p&gt; &#xA; &lt;img src=&#34;https://github.com/frankroeder/parrot.nvim/assets/19746932/b19c5260-1713-400a-bd55-3faa87f4b509&#34; alt=&#34;parrot.nvim logo&#34; width=&#34;50%&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/frankroeder/parrot.nvim&#34;&gt;parrot.nvim&lt;/a&gt; offers a seamless out-of-the-box experience, providing tight integration of current LLM APIs into your Neovim workflows, with a focus solely on text generation. The selected core features include on-demand text completion and editing, as well as chat-like sessions within native Neovim buffers. While this project is still under development, a substantial part of the code is based on an early fork of the brilliant work by Tibor Schmidt&#39;s &lt;a href=&#34;https://github.com/Robitx/gp.nvim&#34;&gt;gp.nvim&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Persistent conversations stored as markdown files within Neovim&#39;s standard path or a user-defined location&lt;/li&gt; &#xA; &lt;li&gt;Custom hooks for inline text editing based on user instructions and chats with predefined system prompts&lt;/li&gt; &#xA; &lt;li&gt;Support for multiple providers: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://www.anthropic.com/api&#34;&gt;Anthropic API&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://blog.perplexity.ai/blog/introducing-pplx-api&#34;&gt;Perplexity.ai API&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://platform.openai.com/&#34;&gt;OpenAI API&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://docs.mistral.ai/api/&#34;&gt;Mistral API&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://ai.google.dev/gemini-api/docs&#34;&gt;Gemini API&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://console.groq.com&#34;&gt;Groq API&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Local and offline serving via &lt;a href=&#34;https://github.com/ollama/ollama&#34;&gt;ollama&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/marketplace/models&#34;&gt;GitHub Models&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://docs.api.nvidia.com&#34;&gt;NVIDIA API&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://console.x.ai&#34;&gt;xAI API&lt;/a&gt; for &lt;strong&gt;Grok&lt;/strong&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Flexible API credential management from various sources: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Environment variables&lt;/li&gt; &#xA;   &lt;li&gt;Bash commands&lt;/li&gt; &#xA;   &lt;li&gt;Password manager CLIs (lazy evaluation)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Repository-specific instructions via &lt;code&gt;.parrot.md&lt;/code&gt; file using the &lt;code&gt;PrtContext&lt;/code&gt; command&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;No&lt;/strong&gt; autocompletion and &lt;strong&gt;no&lt;/strong&gt; hidden requests in the background to analyze your files&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Demo&lt;/h2&gt; &#xA;&lt;p&gt;Seamlessly switch between providers and models.&lt;/p&gt; &#xA;&lt;div align=&#34;left&#34;&gt; &#xA; &lt;img src=&#34;https://github.com/user-attachments/assets/0df0348f-85c0-4a2d-ba1f-ede2738c6d02&#34; width=&#34;100%&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Trigger code completions based on comments.&lt;/p&gt; &#xA;&lt;div align=&#34;left&#34;&gt; &#xA; &lt;img src=&#34;https://github.com/user-attachments/assets/197f99ac-9854-4fe9-bddb-394c1b64f6b6&#34; width=&#34;100%&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Let the parrot fix your bugs.&lt;/p&gt; &#xA;&lt;div align=&#34;left&#34;&gt; &#xA; &lt;img src=&#34;https://github.com/user-attachments/assets/d3a0b261-a9dd-45e6-b508-dc5280594b06&#34; width=&#34;100%&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;hr&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Rewrite a visual selection with `PrtRewrite`.&lt;/summary&gt; &#xA; &lt;div align=&#34;left&#34;&gt; &#xA;  &lt;img src=&#34;https://github.com/user-attachments/assets/c3d38702-7558-4e9e-96a3-c43312a543d0&#34; width=&#34;100%&#34;&gt; &#xA; &lt;/div&gt; &#xA;&lt;/details&gt; &#xA;&lt;hr&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Append code with the visual selection as context with `PrtAppend`.&lt;/summary&gt; &#xA; &lt;div align=&#34;left&#34;&gt; &#xA;  &lt;img src=&#34;https://github.com/user-attachments/assets/80af02fa-cd88-4023-8a55-f2d3c0a2f28e&#34; width=&#34;100%&#34;&gt; &#xA; &lt;/div&gt; &#xA;&lt;/details&gt; &#xA;&lt;hr&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Add comments to a function with `PrtPrepend`.&lt;/summary&gt; &#xA; &lt;div align=&#34;left&#34;&gt; &#xA;  &lt;img src=&#34;https://github.com/user-attachments/assets/9a6bfe66-4bc7-4b63-8694-67bf9c23c064&#34; width=&#34;100%&#34;&gt; &#xA; &lt;/div&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Retry your latest rewrite, append or prepend with `PrtRetry`.&lt;/summary&gt; &#xA; &lt;div align=&#34;left&#34;&gt; &#xA;  &lt;img src=&#34;https://github.com/user-attachments/assets/03442f34-687b-482e-b7f1-7812f70739cc&#34; width=&#34;100%&#34;&gt; &#xA; &lt;/div&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;This plugin requires the latest version of Neovim and relies on a carefully selected set of established plugins.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/neovim/neovim/releases&#34;&gt;&lt;code&gt;neovim 0.10+&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-lua/plenary.nvim&#34;&gt;&lt;code&gt;plenary&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/BurntSushi/ripgrep&#34;&gt;&lt;code&gt;ripgrep&lt;/code&gt;&lt;/a&gt; (optional)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/junegunn/fzf&#34;&gt;&lt;code&gt;fzf&lt;/code&gt;&lt;/a&gt; (optional, requires ripgrep)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;lazy.nvim&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  &#34;frankroeder/parrot.nvim&#34;,&#xA;  dependencies = { &#34;ibhagwan/fzf-lua&#34;, &#34;nvim-lua/plenary.nvim&#34; },&#xA;  opts = {}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Packer&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;packer&#34;).startup(function()&#xA;  use({&#xA;    &#34;frankroeder/parrot.nvim&#34;,&#xA;    requires = { &#39;ibhagwan/fzf-lua&#39;, &#39;nvim-lua/plenary.nvim&#39;},&#xA;    config = function()&#xA;      require(&#34;parrot&#34;).setup()&#xA;    end,&#xA;  })&#xA;end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Neovim native package&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone --depth=1 https://github.com/frankroeder/parrot.nvim.git \&#xA;  &#34;${XDG_DATA_HOME:-$HOME/.local/share}&#34;/nvim/site/pack/parrot/start/parrot.nvim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Setup&lt;/h3&gt; &#xA;&lt;p&gt;The minimal requirement is to at least set up one provider, hence one from the selection below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  &#34;frankroeder/parrot.nvim&#34;,&#xA;  dependencies = { &#39;ibhagwan/fzf-lua&#39;, &#39;nvim-lua/plenary.nvim&#39; },&#xA;  -- optionally include &#34;rcarriga/nvim-notify&#34; for beautiful notifications&#xA;  config = function()&#xA;    require(&#34;parrot&#34;).setup {&#xA;      -- Providers must be explicitly added to make them available.&#xA;      providers = {&#xA;        anthropic = {&#xA;          api_key = os.getenv &#34;ANTHROPIC_API_KEY&#34;,&#xA;        },&#xA;        gemini = {&#xA;          api_key = os.getenv &#34;GEMINI_API_KEY&#34;,&#xA;        },&#xA;        groq = {&#xA;          api_key = os.getenv &#34;GROQ_API_KEY&#34;,&#xA;        },&#xA;        mistral = {&#xA;          api_key = os.getenv &#34;MISTRAL_API_KEY&#34;,&#xA;        },&#xA;        pplx = {&#xA;          api_key = os.getenv &#34;PERPLEXITY_API_KEY&#34;,&#xA;        },&#xA;        -- provide an empty list to make provider available (no API key required)&#xA;        ollama = {},&#xA;        openai = {&#xA;          api_key = os.getenv &#34;OPENAI_API_KEY&#34;,&#xA;        },&#xA;        github = {&#xA;          api_key = os.getenv &#34;GITHUB_TOKEN&#34;,&#xA;        },&#xA;        nvidia = {&#xA;          api_key = os.getenv &#34;NVIDIA_API_KEY&#34;,&#xA;        },&#xA;        xai = {&#xA;          api_key = os.getenv &#34;XAI_API_KEY&#34;,&#xA;        },&#xA;      },&#xA;    }&#xA;  end,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Commands&lt;/h2&gt; &#xA;&lt;p&gt;Below are the available commands that can be configured as keybindings. These commands are included in the default setup. Additional useful commands are implemented through hooks (see below).&lt;/p&gt; &#xA;&lt;h3&gt;General&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtChatNew &amp;lt;target&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Open a new chat&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtChatToggle &amp;lt;target&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Toggle chat (open last chat or new one)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtChatPaste &amp;lt;target&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Paste visual selection into the latest chat&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtInfo&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Print plugin config&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtContext &amp;lt;target&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Edits the local context file&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtChatFinder&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Fuzzy search chat files using fzf&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtChatDelete&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Delete the current chat file&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtChatRespond&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Trigger chat respond (in chat file)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtStop&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Interrupt ongoing respond&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtProvider &amp;lt;provider&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Switch the provider (empty arg triggers fzf)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtModel &amp;lt;model&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Switch the model (empty arg triggers fzf)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtStatus&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Prints current provider and model selection&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Interactive&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtRewrite&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Rewrites the visual selection based on a provided prompt&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtAppend&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Append text to the visual selection based on a provided prompt&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtPrepend&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Prepend text to the visual selection based on a provided prompt&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtNew&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Prompt the model to respond in a new window&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtEnew&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Prompt the model to respond in a new buffer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtVnew&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Prompt the model to respond in a vsplit&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtTabnew&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Prompt the model to respond in a new tab&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtRetry&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Repeats the last rewrite/append/prepend&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Example Hooks&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtImplement&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Takes the visual selection as prompt to generate code&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PrtAsk&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Ask the model a question&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;With &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt;, we indicate the command to open the chat within one of the following target locations (defaults to &lt;code&gt;toggle_target&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;popup&lt;/code&gt;: open a popup window which can be configured via the options provided below&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;split&lt;/code&gt;: open the chat in a horizontal split&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;vsplit&lt;/code&gt;: open the chat in a vertical split&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tabnew&lt;/code&gt;: open the chat in a new tab&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All chat commands (&lt;code&gt;PrtChatNew, PrtChatToggle&lt;/code&gt;) and custom hooks support the visual selection to appear in the chat when triggered. Interactive commands require the user to make use of the &lt;a href=&#34;https://raw.githubusercontent.com/frankroeder/parrot.nvim/main/#template-placeholders&#34;&gt;template placeholders&lt;/a&gt; to consider a visual selection within an API request.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h3&gt;Options&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;    -- The provider definitions include endpoints, API keys, default parameters,&#xA;    -- and topic model arguments for chat summarization, with an example provided for Anthropic.&#xA;    providers = {&#xA;      anthropic = {&#xA;        api_key = os.getenv(&#34;ANTHROPIC_API_KEY&#34;),&#xA;        -- OPTIONAL: Alternative methods to retrieve API key&#xA;        -- Using GPG for decryption:&#xA;        -- api_key = { &#34;gpg&#34;, &#34;--decrypt&#34;, vim.fn.expand(&#34;$HOME&#34;) .. &#34;/anthropic_api_key.txt.gpg&#34; },&#xA;        -- Using macOS Keychain:&#xA;        -- api_key = { &#34;/usr/bin/security&#34;, &#34;find-generic-password&#34;, &#34;-s anthropic-api-key&#34;, &#34;-w&#34; },&#xA;        endpoint = &#34;https://api.anthropic.com/v1/messages&#34;,&#xA;        topic_prompt = &#34;You only respond with 3 to 4 words to summarize the past conversation.&#34;,&#xA;        -- usually a cheap and fast model to generate the chat topic based on&#xA;        -- the whole chat history&#xA;        topic = {&#xA;          model = &#34;claude-3-haiku-20240307&#34;,&#xA;          params = { max_tokens = 32 },&#xA;        },&#xA;        -- default parameters for the actual model&#xA;        params = {&#xA;          chat = { max_tokens = 4096 },&#xA;          command = { max_tokens = 4096 },&#xA;        },&#xA;      },&#xA;      ...&#xA;    }&#xA;&#xA;    -- default system prompts used for the chat sessions and the command routines&#xA;    system_prompt = {&#xA;      chat = ...,&#xA;      command = ...&#xA;    },&#xA;&#xA;    -- the prefix used for all commands&#xA;    cmd_prefix = &#34;Prt&#34;,&#xA;&#xA;    -- optional parameters for curl&#xA;    curl_params = {},&#xA;&#xA;    -- The directory to store persisted state information like the&#xA;    -- current provider and the selected models&#xA;    state_dir = vim.fn.stdpath(&#34;data&#34;):gsub(&#34;/$&#34;, &#34;&#34;) .. &#34;/parrot/persisted&#34;,&#xA;&#xA;    -- The directory to store the chats (searched with PrtChatFinder)&#xA;    chat_dir = vim.fn.stdpath(&#34;data&#34;):gsub(&#34;/$&#34;, &#34;&#34;) .. &#34;/parrot/chats&#34;,&#xA;&#xA;    -- Chat user prompt prefix&#xA;    chat_user_prefix = &#34;ğŸ—¨:&#34;,&#xA;&#xA;    -- llm prompt prefix&#xA;    llm_prefix = &#34;ğŸ¦œ:&#34;,&#xA;&#xA;    -- Explicitly confirm deletion of a chat file&#xA;    chat_confirm_delete = true,&#xA;&#xA;    -- When available, call API for model selection&#xA;    online_model_selection = false,&#xA;&#xA;    -- Local chat buffer shortcuts&#xA;    chat_shortcut_respond = { modes = { &#34;n&#34;, &#34;i&#34;, &#34;v&#34;, &#34;x&#34; }, shortcut = &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-g&amp;gt;&#34; },&#xA;    chat_shortcut_delete = { modes = { &#34;n&#34;, &#34;i&#34;, &#34;v&#34;, &#34;x&#34; }, shortcut = &#34;&amp;lt;C-g&amp;gt;d&#34; },&#xA;    chat_shortcut_stop = { modes = { &#34;n&#34;, &#34;i&#34;, &#34;v&#34;, &#34;x&#34; }, shortcut = &#34;&amp;lt;C-g&amp;gt;s&#34; },&#xA;    chat_shortcut_new = { modes = { &#34;n&#34;, &#34;i&#34;, &#34;v&#34;, &#34;x&#34; }, shortcut = &#34;&amp;lt;C-g&amp;gt;c&#34; },&#xA;&#xA;    -- Option to move the cursor to the end of the file after finished respond&#xA;    chat_free_cursor = false,&#xA;&#xA;     -- use prompt buftype for chats (:h prompt-buffer)&#xA;    chat_prompt_buf_type = false,&#xA;&#xA;    -- Default target for  PrtChatToggle, PrtChatNew, PrtContext and the chats opened from the ChatFinder&#xA;    -- values: popup / split / vsplit / tabnew&#xA;    toggle_target = &#34;vsplit&#34;,&#xA;&#xA;    -- The interactive user input appearing when can be &#34;native&#34; for&#xA;    -- vim.ui.input or &#34;buffer&#34; to query the input within a native nvim buffer&#xA;    -- (see video demonstrations below)&#xA;    user_input_ui = &#34;native&#34;,&#xA;&#xA;    -- Popup window layout&#xA;    -- border: &#34;single&#34;, &#34;double&#34;, &#34;rounded&#34;, &#34;solid&#34;, &#34;shadow&#34;, &#34;none&#34;&#xA;    style_popup_border = &#34;single&#34;,&#xA;&#xA;    -- margins are number of characters or lines&#xA;    style_popup_margin_bottom = 8,&#xA;    style_popup_margin_left = 1,&#xA;    style_popup_margin_right = 2,&#xA;    style_popup_margin_top = 2,&#xA;    style_popup_max_width = 160&#xA;&#xA;    -- Prompt used for interactive LLM calls like PrtRewrite where {{llm}} is&#xA;    -- a placeholder for the llm name&#xA;    command_prompt_prefix_template = &#34;ğŸ¤– {{llm}} ~ &#34;,&#xA;&#xA;    -- auto select command response (easier chaining of commands)&#xA;    -- if false it also frees up the buffer cursor for further editing elsewhere&#xA;    command_auto_select_response = true,&#xA;&#xA;    -- fzf_lua options for PrtModel and PrtChatFinder when plugin is installed&#xA;    fzf_lua_opts = {&#xA;        [&#34;--ansi&#34;] = true,&#xA;        [&#34;--sort&#34;] = &#34;&#34;,&#xA;        [&#34;--info&#34;] = &#34;inline&#34;,&#xA;        [&#34;--layout&#34;] = &#34;reverse&#34;,&#xA;        [&#34;--preview-window&#34;] = &#34;nohidden:right:75%&#34;,&#xA;    },&#xA;&#xA;    -- Enables the query spinner animation &#xA;    enable_spinner = true,&#xA;    -- Type of spinner animation to display while loading&#xA;    -- Available options: &#34;dots&#34;, &#34;line&#34;, &#34;star&#34;, &#34;bouncing_bar&#34;, &#34;bouncing_ball&#34;&#xA;    spinner_type = &#34;star&#34;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Demonstrations&lt;/h4&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;With `user_input_ui = &#34;native&#34;`, use `vim.ui.input` as slim input interface.&lt;/summary&gt; &#xA; &lt;div align=&#34;left&#34;&gt; &#xA;  &lt;img src=&#34;https://github.com/user-attachments/assets/c2fe3bde-a35a-4f2a-957b-687e4f6f2e5c&#34; width=&#34;100%&#34;&gt; &#xA; &lt;/div&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;With `user_input_ui = &#34;buffer&#34;`, your input is simply a buffer. All of the content is passed to the API when closed.&lt;/summary&gt; &#xA; &lt;div align=&#34;left&#34;&gt; &#xA;  &lt;img src=&#34;https://github.com/user-attachments/assets/63e6e1c4-a2ab-4c60-9b43-332e4b581360&#34; width=&#34;100%&#34;&gt; &#xA; &lt;/div&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;The spinner is a useful indicator for providers that take longer to respond.&lt;/summary&gt; &#xA; &lt;div align=&#34;left&#34;&gt; &#xA;  &lt;img src=&#34;https://github.com/user-attachments/assets/ebcd27cb-da00-4150-a0f8-1d2e1afa0acb&#34; width=&#34;100%&#34;&gt; &#xA; &lt;/div&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Key Bindings&lt;/h3&gt; &#xA;&lt;p&gt;This plugin provides the following default key mappings:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Keymap&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;&amp;lt;C-g&amp;gt;c&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Opens a new chat via &lt;code&gt;PrtChatNew&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;&amp;lt;C-g&amp;gt;&amp;lt;C-g&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Trigger the API to generate a response via &lt;code&gt;PrtChatRespond&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;&amp;lt;C-g&amp;gt;s&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Stop the current text generation via &lt;code&gt;PrtStop&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;&amp;lt;C-g&amp;gt;d&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Delete the current chat file via &lt;code&gt;PrtChatDelete&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Adding a new command&lt;/h3&gt; &#xA;&lt;h4&gt;Ask a single-turn question and receive the answer in a popup window&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;parrot&#34;).setup {&#xA;    -- ...&#xA;    hooks = {&#xA;      Ask = function(parrot, params)&#xA;        local template = [[&#xA;          In light of your existing knowledge base, please generate a response that&#xA;          is succinct and directly addresses the question posed. Prioritize accuracy&#xA;          and relevance in your answer, drawing upon the most recent information&#xA;          available to you. Aim to deliver your response in a concise manner,&#xA;          focusing on the essence of the inquiry.&#xA;          Question: {{command}}&#xA;        ]]&#xA;        local model_obj = parrot.get_model(&#34;command&#34;)&#xA;        parrot.logger.info(&#34;Asking model: &#34; .. model_obj.name)&#xA;        parrot.Prompt(params, parrot.ui.Target.popup, model_obj, &#34;ğŸ¤– Ask ~ &#34;, template)&#xA;      end,&#xA;    }&#xA;    -- ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Start a chat with a predefined chat prompt to check your spelling.&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;parrot&#34;).setup {&#xA;    -- ...&#xA;    hooks = {&#xA;      SpellCheck = function(prt, params)&#xA;        local chat_prompt = [[&#xA;          Your task is to take the text provided and rewrite it into a clear,&#xA;          grammatically correct version while preserving the original meaning&#xA;          as closely as possible. Correct any spelling mistakes, punctuation&#xA;          errors, verb tense issues, word choice problems, and other&#xA;          grammatical mistakes.&#xA;        ]]&#xA;        prt.ChatNew(params, chat_prompt)&#xA;      end,&#xA;    }&#xA;    -- ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Refer to my &lt;a href=&#34;https://github.com/frankroeder/dotfiles/raw/master/nvim/lua/plugins/parrot.lua&#34;&gt;personal lazy.nvim setup&lt;/a&gt; or those of &lt;a href=&#34;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=frankroeder%2Fparrot.nvim+language%3ALua&amp;amp;type=code&amp;amp;l=Lua&#34;&gt;other users&lt;/a&gt; for further hooks and key bindings.&lt;/p&gt; &#xA;&lt;h3&gt;Template Placeholders&lt;/h3&gt; &#xA;&lt;p&gt;Users can utilize the following placeholders in their hook and system templates to inject additional context:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Placeholder&lt;/th&gt; &#xA;   &lt;th&gt;Content&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;{{selection}}&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Current visual selection&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;{{filetype}}&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Filetype of the current buffer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;{{filepath}}&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Full path of the current file&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;{{filecontent}}&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Full content of the current buffer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;{{multifilecontent}}&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Full content of all open buffers&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Below is an example of how to use these placeholders in a completion hook, which receives the full file context and the selected code snippet as input.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;parrot&#34;).setup {&#xA;    -- ...&#xA;    hooks = {&#xA;      CompleteFullContext = function(prt, params)&#xA;        local template = [[&#xA;        I have the following code from {{filename}}:&#xA;&#xA;        ```{{filetype}}&#xA;        {filecontent}}&#xA;        ```&#xA;&#xA;        Please look at the following section specifically:&#xA;        ```{{filetype}}&#xA;        {{selection}}&#xA;        ```&#xA;&#xA;        Please finish the code above carefully and logically.&#xA;        Respond just with the snippet of code that should be inserted.&#xA;        ]]&#xA;        local model_obj = prt.get_model(&#34;command&#34;)&#xA;        prt.Prompt(params, prt.ui.Target.append, model_obj, nil, template)&#xA;      end,&#xA;    }&#xA;    -- ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The placeholders &lt;code&gt;{{filetype}}&lt;/code&gt; and &lt;code&gt;{{filecontent}}&lt;/code&gt; can also be used in the &lt;code&gt;chat_prompt&lt;/code&gt; when creating custom hooks calling &lt;code&gt;prt.ChatNew(params, chat_prompt)&lt;/code&gt; to directly inject the whole file content.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;parrot&#34;).setup {&#xA;    -- ...&#xA;      CodeConsultant = function(prt, params)&#xA;        local chat_prompt = [[&#xA;          Your task is to analyze the provided {{filetype}} code and suggest&#xA;          improvements to optimize its performance. Identify areas where the&#xA;          code can be made more efficient, faster, or less resource-intensive.&#xA;          Provide specific suggestions for optimization, along with explanations&#xA;          of how these changes can enhance the code&#39;s performance. The optimized&#xA;          code should maintain the same functionality as the original code while&#xA;          demonstrating improved efficiency.&#xA;&#xA;          Here is the code&#xA;          ```{{filetype}}&#xA;          {{filecontent}}&#xA;          ```&#xA;        ]]&#xA;        prt.ChatNew(params, chat_prompt)&#xA;      end,&#xA;    }&#xA;    -- ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Statusline Support&lt;/h2&gt; &#xA;&lt;p&gt;Knowing the current chat or command model can be shown using your favorite statusline plugin. Below, we provide an example for &lt;a href=&#34;https://github.com/nvim-lualine/lualine.nvim&#34;&gt;lualine&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;  -- define function and formatting of the information&#xA;  local function parrot_status()&#xA;    local status_info = require(&#34;parrot.config&#34;).get_status_info()&#xA;    local status = &#34;&#34;&#xA;    if status_info.is_chat then&#xA;      status = status_info.prov.chat.name&#xA;    else&#xA;      status = status_info.prov.command.name&#xA;    end&#xA;    return string.format(&#34;%s(%s)&#34;, status, status_info.model)&#xA;  end&#xA;&#xA;  -- add to lueline section&#xA;  require(&#39;lualine&#39;).setup {&#xA;    sections = {&#xA;      lualine_a = { parrot_status }&#xA;  }&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Bonus&lt;/h2&gt; &#xA;&lt;p&gt;Access parrot.nvim directly from your terminal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;command nvim -c &#34;PrtChatNew&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also works by piping content directly into the chat:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ls -l | command nvim - -c &#34;normal ggVGy&#34; -c &#34;:PrtChatNew&#34; -c &#34;normal p&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add status line integration/ notifications for summary of tokens used or money spent&lt;/li&gt; &#xA; &lt;li&gt;Improve the documentation&lt;/li&gt; &#xA; &lt;li&gt;Create a tutorial video&lt;/li&gt; &#xA; &lt;li&gt;Reduce overall code complexity and improve robustness&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;I am encountering errors related to the state. &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;If the state is corrupted, simply delete the file &lt;code&gt;~/.local/share/nvim/parrot/persisted/state.json&lt;/code&gt;.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt;The completion feature is not functioning, and I am receiving errors. &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;Ensure that you have an adequate amount of API credits and examine the log file &lt;code&gt;~/.local/state/nvim/parrot.nvim.log&lt;/code&gt; for any errors.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt;I have discovered a bug, have a feature suggestion, or possess a general idea to enhance this project. &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;Everyone is invited to contribute to this project! If you have any suggestions, ideas, or bug reports, please feel free to submit an issue.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Related Projects&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/frankroeder/parrot.nvim&#34;&gt;parrot.nvim&lt;/a&gt; is a fork of an earlier version of &lt;a href=&#34;https://github.com/Robitx/gp.nvim&#34;&gt;robitx/gp.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/huynle/ogpt.nvim&#34;&gt;huynle/ogpt.nvim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Star History&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://star-history.com/#frankroeder/parrot.nvim&amp;amp;Date&#34;&gt;&lt;img src=&#34;https://api.star-history.com/svg?repos=frankroeder/parrot.nvim&amp;amp;type=Date&#34; alt=&#34;Star History Chart&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>