<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-04-27T01:46:02Z</updated>
  <subtitle>Weekly Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Exafunction/windsurf.nvim</title>
    <updated>2025-04-27T01:46:02Z</updated>
    <id>tag:github.com,2025-04-27:/Exafunction/windsurf.nvim</id>
    <link href="https://github.com/Exafunction/windsurf.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A native neovim extension for Codeium&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;300&#34; alt=&#34;Windsurf&#34; src=&#34;https://raw.githubusercontent.com/Exafunction/windsurf.nvim/main/windsurf.png&#34;&gt; &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/3XFf78nAx5&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/1027685395649015980?label=community&amp;amp;color=5865F2&amp;amp;logo=discord&amp;amp;logoColor=FFFFFF&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=windsurf_ai&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/style--blue?style=social&amp;amp;logo=twitter&amp;amp;label=Follow%20%40windsurf_ai&#34; alt=&#34;Twitter Follow&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/license/Exafunction/windsurf.vim&#34; alt=&#34;License&#34;&gt; &lt;a href=&#34;https://docs.windsurf.com&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Windsurf%20Docs-09B6A2&#34; alt=&#34;Docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://windsurf.canny.io/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Feature%20Requests-6b69ff&#34; alt=&#34;Canny Board&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://windsurf.com?repo_name=exafunction%2Fwindsurf.vim&#34;&gt;&lt;img src=&#34;https://windsurf.com/badges/main&#34; alt=&#34;built with Windsurf&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=Codeium.codeium&#34;&gt;&lt;img src=&#34;https://img.shields.io/visual-studio-marketplace/i/Codeium.codeium?label=Visual%20Studio&amp;amp;logo=visualstudio&#34; alt=&#34;Visual Studio&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://plugins.jetbrains.com/plugin/20540-codeium/&#34;&gt;&lt;img src=&#34;https://img.shields.io/jetbrains/plugin/d/20540?label=JetBrains&#34; alt=&#34;JetBrains&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://open-vsx.org/extension/Codeium/codeium&#34;&gt;&lt;img src=&#34;https://img.shields.io/open-vsx/dt/Codeium/codeium?label=Open%20VSX&#34; alt=&#34;Open VSX&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://chrome.google.com/webstore/detail/codeium/hobjkcpmjhlegmobgonaagepfckjkceh&#34;&gt;&lt;img src=&#34;https://img.shields.io/chrome-web-store/users/hobjkcpmjhlegmobgonaagepfckjkceh?label=Google%20Chrome&amp;amp;logo=googlechrome&amp;amp;logoColor=FFFFFF&#34; alt=&#34;Google Chrome&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;windsurf.nvim&lt;/h1&gt; &#xA;&lt;p&gt;Native &lt;a href=&#34;https://www.windsurf.com/&#34;&gt;Windsurf&lt;/a&gt; plugin for Neovim.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Feel free to create an issue/PR if you want to see anything else implemented.&lt;/p&gt; &#xA;&lt;h2&gt;Screenshots&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/522465/215312040-d5e91a6b-cffa-48f1-909f-360328b5af79.webm&#34;&gt;Completion in Action&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;packer.nvim&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use {&#xA;    &#34;Exafunction/windsurf.nvim&#34;,&#xA;    requires = {&#xA;        &#34;nvim-lua/plenary.nvim&#34;,&#xA;        &#34;hrsh7th/nvim-cmp&#34;,&#xA;    },&#xA;    config = function()&#xA;        require(&#34;codeium&#34;).setup({&#xA;        })&#xA;    end&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/folke/lazy.nvim&#34;&gt;lazy.nvim&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;    &#34;Exafunction/windsurf.nvim&#34;,&#xA;    dependencies = {&#xA;        &#34;nvim-lua/plenary.nvim&#34;,&#xA;        &#34;hrsh7th/nvim-cmp&#34;,&#xA;    },&#xA;    config = function()&#xA;        require(&#34;codeium&#34;).setup({&#xA;        })&#xA;    end&#xA;},&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;After installation and configuration, you will need to authenticate with Windsurf. This can be done by running &lt;code&gt;:Codeium Auth&lt;/code&gt;, copying the token from your browser and pasting it into API token request.&lt;/p&gt; &#xA;&lt;p&gt;To use Windsurf Chat, execute the &lt;code&gt;:Codeium Chat&lt;/code&gt; command. The chat will be opened in your default browser using the xdg-open command.&lt;/p&gt; &#xA;&lt;p&gt;You can globaly enable or disable Codeium Completion with &lt;code&gt;:Codeium Toggle&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;h2&gt;Options&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;config_path&lt;/code&gt;: the path to the config file, used to store the API key.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;bin_path&lt;/code&gt;: the path to the directory where the Windsurf server will be downloaded to.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;api&lt;/code&gt;: information about the API server to use:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;host&lt;/code&gt;: the hostname. Example: &lt;code&gt;&#34;codeium.example.com&#34;&lt;/code&gt;. Required when using enterprise mode&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;port&lt;/code&gt;: the port. Defaults to &lt;code&gt;443&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;path&lt;/code&gt;: the path prefix to the API server. Default for enterprise: &lt;code&gt;&#34;/_route/api_server&#34;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;portal_url&lt;/code&gt;: the portal URL to use (for enterprise mode). Defaults to &lt;code&gt;host:port&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;enterprise_mode&lt;/code&gt;: enable enterprise mode&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;detect_proxy&lt;/code&gt;: enable or disable proxy detection&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;enable_chat&lt;/code&gt;: enable chat functionality&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;enable_cmp_source&lt;/code&gt;: defaults to true. Set &lt;code&gt;false&lt;/code&gt; to disable registering a &lt;code&gt;cmp&lt;/code&gt; source&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;virtual_text&lt;/code&gt;: configuration for showing completions in virtual text&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt;: defaults to &lt;code&gt;false&lt;/code&gt;. Set &lt;code&gt;true&lt;/code&gt; to enable the virtual text feature&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;filetypes&lt;/code&gt;: A mapping of filetype to true or false, to enable virtual text&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;default_filetype_enabled&lt;/code&gt;: Whether to enable virtual text of not for types not listed in &lt;code&gt;filetypes&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;manual&lt;/code&gt;: Set &lt;code&gt;true&lt;/code&gt; to only trigger Codeium using a manual Lua function call&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;idle_delay&lt;/code&gt;: defaults to &lt;code&gt;75&lt;/code&gt;. Time in ms to wait before requesting completions after typing stops.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;virtual_text_priority&lt;/code&gt;: defaults to &lt;code&gt;65535&lt;/code&gt;. Priority of the virtual text&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;map_keys&lt;/code&gt;: defaults to &lt;code&gt;true&lt;/code&gt;. Set &lt;code&gt;false&lt;/code&gt; to not set any key bindings for completions&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;accept_fallback&lt;/code&gt;: Emulate pressing this key when using the accept key binding but there is no completion. Defaults to &#34;\t&#34;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;key_bindings&lt;/code&gt;: key bindings for accepting and cycling through completions &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;accept&lt;/code&gt;: key binding for accepting a completion, default is &lt;code&gt;&amp;lt;Tab&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;accept_word&lt;/code&gt;: key binding for accepting only the next word, default is not set&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;accept_line&lt;/code&gt;: key binding for accepting only the next line, default is not set&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;clear&lt;/code&gt;: key binding for clearing the virtual text, default is not set&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;next&lt;/code&gt;: key binding for cycling to the next completion, default is &lt;code&gt;&amp;lt;M-]&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;prev&lt;/code&gt;: key binding for cycling to the previous completion, default is &lt;code&gt;&amp;lt;M-[&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;workspace_root&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;use_lsp&lt;/code&gt;: Use Neovim&#39;s LSP support to find the workspace root, if possible.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;paths&lt;/code&gt;: paths to files that indicate a workspace root when not using the LSP support&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;find_root&lt;/code&gt;: An optional function that the plugin will call to find the workspace root.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;tools&lt;/code&gt;: paths to binaries used by the plugin:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;uname&lt;/code&gt;: not needed on Windows, defaults given.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;uuidgen&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;curl&lt;/code&gt;:&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;gzip&lt;/code&gt;: not needed on Windows, default implemenation given using powershell.exe Expand-Archive instead&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;language_server&lt;/code&gt;: The path to the language server downloaded from the &lt;a href=&#34;https://github.com/Exafunction/codeium/releases/tag/language-server-v1.1.32&#34;&gt;official source.&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;wrapper&lt;/code&gt;: the path to a wrapper script/binary that is used to execute any binaries not listed under &lt;code&gt;tools&lt;/code&gt;. This is primarily useful for NixOS, where a FHS wrapper can be used for the downloaded codeium server.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/hrsh7th/nvim-cmp&#34;&gt;nvim-cmp&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;After calling &lt;code&gt;setup&lt;/code&gt;, this plugin will register a source in nvim-cmp. nvim-cmp can then be set up to use this source using the &lt;code&gt;sources&lt;/code&gt; configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;cmp.setup({&#xA;    -- ...&#xA;    sources = {&#xA;        -- ...&#xA;        { name = &#34;codeium&#34; }&#xA;    }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are seeing the &lt;code&gt;codeium&lt;/code&gt; source as unused in &lt;code&gt;:CmpStatus&lt;/code&gt;, make sure that &lt;code&gt;nvim-cmp&lt;/code&gt; setup happens before the &lt;code&gt;windsurf.nvim&lt;/code&gt; setup.&lt;/p&gt; &#xA;&lt;p&gt;To set a symbol for windsurf using lspkind, use the &lt;code&gt;Codeium&lt;/code&gt; keyword. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;cmp.setup({&#xA;    -- ...&#xA;    formatting = {&#xA;        format = require(&#39;lspkind&#39;).cmp_format({&#xA;            mode = &#34;symbol&#34;,&#xA;            maxwidth = 50,&#xA;            ellipsis_char = &#39;...&#39;,&#xA;            symbol_map = { Codeium = &#34;&#34;, }&#xA;        })&#xA;    }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;blink.cmp&lt;/h3&gt; &#xA;&lt;p&gt;Configuration example for &lt;a href=&#34;https://github.com/Saghen/blink.cmp&#34;&gt;blink.cmp&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  &#39;saghen/blink.cmp&#39;,&#xA;  dependencies = {&#xA;    {&#xA;      &#39;Exafunction/codeium.nvim&#39;,&#xA;    },&#xA;  },&#xA;  opts = {&#xA;    sources = {&#xA;      default = { &#39;lsp&#39;, &#39;path&#39;, &#39;snippets&#39;, &#39;buffer&#39;, &#39;codeium&#39; },&#xA;      providers = {&#xA;        codeium = { name = &#39;Codeium&#39;, module = &#39;codeium.blink&#39;, async = true },&#xA;      },&#xA;    },&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Virtual Text&lt;/h3&gt; &#xA;&lt;p&gt;The plugin supports showing completions in virtual text. Set &lt;code&gt;virtual_text.enabled&lt;/code&gt; in the options to &lt;code&gt;true&lt;/code&gt; to enable it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;codeium&#34;).setup({&#xA;    -- Optionally disable cmp source if using virtual text only&#xA;    enable_cmp_source = false,&#xA;    virtual_text = {&#xA;        enabled = true,&#xA;&#xA;        -- These are the defaults&#xA;&#xA;        -- Set to true if you never want completions to be shown automatically.&#xA;        manual = false,&#xA;        -- A mapping of filetype to true or false, to enable virtual text.&#xA;        filetypes = {},&#xA;        -- Whether to enable virtual text of not for filetypes not specifically listed above.&#xA;        default_filetype_enabled = true,&#xA;        -- How long to wait (in ms) before requesting completions after typing stops.&#xA;        idle_delay = 75,&#xA;        -- Priority of the virtual text. This usually ensures that the completions appear on top of&#xA;        -- other plugins that also add virtual text, such as LSP inlay hints, but can be modified if&#xA;        -- desired.&#xA;        virtual_text_priority = 65535,&#xA;        -- Set to false to disable all key bindings for managing completions.&#xA;        map_keys = true,&#xA;        -- The key to press when hitting the accept keybinding but no completion is showing.&#xA;        -- Defaults to \t normally or &amp;lt;c-n&amp;gt; when a popup is showing. &#xA;        accept_fallback = nil,&#xA;        -- Key bindings for managing completions in virtual text mode.&#xA;        key_bindings = {&#xA;            -- Accept the current completion.&#xA;            accept = &#34;&amp;lt;Tab&amp;gt;&#34;,&#xA;            -- Accept the next word.&#xA;            accept_word = false,&#xA;            -- Accept the next line.&#xA;            accept_line = false,&#xA;            -- Clear the virtual text.&#xA;            clear = false,&#xA;            -- Cycle to the next completion.&#xA;            next = &#34;&amp;lt;M-]&amp;gt;&#34;,&#xA;            -- Cycle to the previous completion.&#xA;            prev = &#34;&amp;lt;M-[&amp;gt;&#34;,&#xA;        }&#xA;    }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Virtual Text Keybindings&lt;/h4&gt; &#xA;&lt;p&gt;The plugin defines a number of key bindings for managing completion in virtual text mode. You can override these by setting &lt;code&gt;virtual_text.key_bindings&lt;/code&gt;. If you don&#39;t want any key bindings, set &lt;code&gt;virtual_text.map_keys&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, or you can set specific bindings to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When &lt;code&gt;manual&lt;/code&gt; mode is enabled, you can call any of these functions to show completions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- Request completions immediately.&#xA;require(&#39;codeium.virtual_text&#39;).complete()&#xA;&#xA;-- Request a completion, or cycle to the next if we already have some&#xA;require(&#39;codeium.virtual_text&#39;).cycle_or_complete()&#xA;&#xA;-- Complete only after idle_delay has passed with no other calls to debounced_complete().&#xA;require(&#39;codeium.virtual_text&#39;).debounced_complete()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Virtual Text Filetypes&lt;/h4&gt; &#xA;&lt;p&gt;You can set the &lt;code&gt;filetypes&lt;/code&gt; and &lt;code&gt;default_filetype_enabled&lt;/code&gt; options in the &lt;code&gt;virtual_text&lt;/code&gt; table to configure which filetypes should use virtual text.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;codeium.virtual_text&#39;).setup({&#xA;    virtual_text = {&#xA;        filetypes = { &#xA;            python = true,&#xA;            markdown = false&#xA;        },&#xA;        default_filetype_enabled = true&#xA;    }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Show Windsurf status in statusline&lt;/h3&gt; &#xA;&lt;p&gt;When using virtual text, Windsurf status can be generated by calling &lt;code&gt;require(&#39;codeium.virtual_text&#39;).status_string()&lt;/code&gt;. It produces a 3 char long string with Windsurf status:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#39;3/8&#39;&lt;/code&gt; - third suggestion out of 8&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#39;0&#39;&lt;/code&gt; - Windsurf returned no suggestions&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#39;*&#39;&lt;/code&gt; - waiting for Windsurf response&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In order to show it in status line add following line to your &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;set statusline+=%3{v:lua.require(&#39;codeium.virtual_text&#39;).status_string()}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Please check &lt;code&gt;:help statusline&lt;/code&gt; for further information about building statusline in VIM.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;status_string&lt;/code&gt; function can also be used with other statusline plugins. You can call the &lt;code&gt;set_statusbar_refresh&lt;/code&gt; function to customize how the plugin refreshes the status bar.&lt;/p&gt; &#xA;&lt;p&gt;For example, this sets up the plugin with lualine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;codeium.virtual_text&#39;).set_statusbar_refresh(function()&#xA;&#x9;require(&#39;lualine&#39;).refresh()&#xA;end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more customization, you can also call the &lt;code&gt;status&lt;/code&gt; function which returns an object that can be used to create a status string.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;function custom_status()&#xA;&#x9;local status = require(&#39;codeium.virtual_text&#39;).status()&#xA;&#xA;&#x9;if status.state == &#39;idle&#39; then&#xA;&#x9;&#x9;-- Output was cleared, for example when leaving insert mode&#xA;        return &#39; &#39;&#xA;    end&#xA;&#xA;&#x9;if status.state == &#39;waiting&#39; then&#xA;&#x9;&#x9;-- Waiting for response&#xA;&#x9;&#x9;return &#34;Waiting...&#34;&#xA;    end&#xA;&#xA;&#x9;if status.state == &#39;completions&#39; and status.total &amp;gt; 0 then&#xA;        return string.format(&#39;%d/%d&#39;, status.current, status.total)&#xA;    end&#xA;&#xA;&#x9;return &#39; 0 &#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Workspace Root Directory&lt;/h3&gt; &#xA;&lt;p&gt;The plugin uses a few techniques to find the workspace root directory, which helps to inform the autocomplete and chat context.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Call the optional &lt;code&gt;workspace_root.find_root&lt;/code&gt; function, if provided. This is described below.&lt;/li&gt; &#xA; &lt;li&gt;Query Neovim&#39;s built-in LSP support for the workspace root, if &lt;code&gt;workspace_root.use_lsp&lt;/code&gt; is not set to &lt;code&gt;false&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Search upward in the filesystem for a file or directory in &lt;code&gt;workspace_root.paths&lt;/code&gt; that indicates a workspace root.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The default configuration is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;codeium&#39;).setup({&#xA;&#x9;workspace_root = {&#xA;&#x9;&#x9;use_lsp = true,&#xA;&#x9;&#x9;find_root = nil,&#xA;&#x9;&#x9;paths = {&#xA;&#x9;&#x9;&#x9;&#34;.bzr&#34;,&#xA;&#x9;&#x9;&#x9;&#34;.git&#34;,&#xA;&#x9;&#x9;&#x9;&#34;.hg&#34;,&#xA;&#x9;&#x9;&#x9;&#34;.svn&#34;,&#xA;&#x9;&#x9;&#x9;&#34;_FOSSIL_&#34;,&#xA;&#x9;&#x9;&#x9;&#34;package.json&#34;,&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;find_root&lt;/code&gt; function can help the plugin find the workspace root when you are not using Neovim&#39;s built-in LSP provider. For example, this snippet calls into &lt;code&gt;coc.nvim&lt;/code&gt; to find the workspace root.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;codeium&#39;).setup({&#xA;&#x9;workspace_root = {&#xA;&#x9;&#x9;find_root = function()&#xA;&#x9;&#x9;&#x9;return vim.fn.CocAction(&#34;currentWorkspacePath&#34;)&#xA;&#x9;&#x9;end&#xA;&#x9;}&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;The plugin log is written to &lt;code&gt;~/.cache/nvim/codeium/codeium.log&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can set the logging level to one of &lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;debug&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; by exporting the &lt;code&gt;DEBUG_CODEIUM&lt;/code&gt; environment variable.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;This plugin was initially developed by &lt;a href=&#34;https://github.com/jcdickinson&#34;&gt;@jcdickinson&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>rmagatti/auto-session</title>
    <updated>2025-04-27T01:46:02Z</updated>
    <id>tag:github.com,2025-04-27:/rmagatti/auto-session</id>
    <link href="https://github.com/rmagatti/auto-session" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A small automated session manager for Neovim&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;🗒️ AutoSession&lt;/h1&gt; &#xA;&lt;p&gt;AutoSession takes advantage of Neovim&#39;s existing session management capabilities to provide seamless automatic session management.&lt;/p&gt; &#xA;&lt;img src=&#34;https://github.com/rmagatti/readme-assets/raw/main/auto-session-new-example.gif&#34; width=&#34;800&#34;&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rmagatti/auto-session/actions/workflows/tests.yml&#34;&gt;&lt;img alt=&#34;GitHub Actions Workflow Status&#34; src=&#34;https://img.shields.io/github/actions/workflow/status/rmagatti/auto-session/tests.yml?style=for-the-badge&amp;amp;label=tests&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;📦 Installation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/folke/lazy.nvim&#34;&gt;Lazy.nvim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  &#39;rmagatti/auto-session&#39;,&#xA;  lazy = false,&#xA;&#xA;  ---enables autocomplete for opts&#xA;  ---@module &#34;auto-session&#34;&#xA;  ---@type AutoSession.Config&#xA;  opts = {&#xA;    suppressed_dirs = { &#39;~/&#39;, &#39;~/Projects&#39;, &#39;~/Downloads&#39;, &#39;/&#39; },&#xA;    -- log_level = &#39;debug&#39;,&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;Packer.nvim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use {&#xA;  &#39;rmagatti/auto-session&#39;,&#xA;  config = function()&#xA;    require(&#34;auto-session&#34;).setup {&#xA;      suppressed_dirs = { &#34;~/&#34;, &#34;~/Projects&#34;, &#34;~/Downloads&#34;, &#34;/&#34;},&#xA;    }&#xA;  end&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;💡 Behaviour&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;When starting &lt;code&gt;nvim&lt;/code&gt; with no arguments, AutoSession will try to restore an existing session for the current &lt;code&gt;cwd&lt;/code&gt; if one exists.&lt;/li&gt; &#xA; &lt;li&gt;When starting &lt;code&gt;nvim .&lt;/code&gt; (or another directory), AutoSession will try to restore the session for that directory. See &lt;a href=&#34;https://raw.githubusercontent.com/rmagatti/auto-session/main/#%EF%B8%8F-argument-handling&#34;&gt;argument handling&lt;/a&gt; for more details.&lt;/li&gt; &#xA; &lt;li&gt;When starting &lt;code&gt;nvim some_file.txt&lt;/code&gt; (or multiple files), by default, AutoSession won&#39;t do anything. See &lt;a href=&#34;https://raw.githubusercontent.com/rmagatti/auto-session/main/#%EF%B8%8F-argument-handling&#34;&gt;argument handling&lt;/a&gt; for more details.&lt;/li&gt; &#xA; &lt;li&gt;Even after starting &lt;code&gt;nvim&lt;/code&gt; with a file argument, a session can still be manually restored by running &lt;code&gt;:SessionRestore&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Any session saving and restoration takes into consideration the current working directory &lt;code&gt;cwd&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;When piping to &lt;code&gt;nvim&lt;/code&gt;, e.g: &lt;code&gt;cat myfile | nvim&lt;/code&gt;, AutoSession won&#39;t do anything.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;span&gt;⚠&lt;/span&gt; Please note that if there are errors in your config, restoring the session might fail, if that happens, auto session will then disable auto saving for the current session. Manually saving a session can still be done by calling &lt;code&gt;:SessionSave&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;⚙️ Configuration&lt;/h1&gt; &#xA;&lt;p&gt;Here are the default settings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  enabled = true, -- Enables/disables auto creating, saving and restoring&#xA;  root_dir = vim.fn.stdpath &#34;data&#34; .. &#34;/sessions/&#34;, -- Root dir where sessions will be stored&#xA;  auto_save = true, -- Enables/disables auto saving session on exit&#xA;  auto_restore = true, -- Enables/disables auto restoring session on start&#xA;  auto_create = true, -- Enables/disables auto creating new session files. Can take a function that should return true/false if a new session file should be created or not&#xA;  suppressed_dirs = nil, -- Suppress session restore/create in certain directories&#xA;  allowed_dirs = nil, -- Allow session restore/create in certain directories&#xA;  auto_restore_last_session = false, -- On startup, loads the last saved session if session for cwd does not exist&#xA;  git_use_branch_name = false, -- Include git branch name in session name&#xA;  git_auto_restore_on_branch_change = false, -- Should we auto-restore the session when the git branch changes. Requires git_use_branch_name&#xA;  lazy_support = true, -- Automatically detect if Lazy.nvim is being used and wait until Lazy is done to make sure session is restored correctly. Does nothing if Lazy isn&#39;t being used. Can be disabled if a problem is suspected or for debugging&#xA;  bypass_save_filetypes = nil, -- List of filetypes to bypass auto save when the only buffer open is one of the file types listed, useful to ignore dashboards&#xA;  close_unsupported_windows = true, -- Close windows that aren&#39;t backed by normal file before autosaving a session&#xA;  args_allow_single_directory = true, -- Follow normal sesion save/load logic if launched with a single directory as the only argument&#xA;  args_allow_files_auto_save = false, -- Allow saving a session even when launched with a file argument (or multiple files/dirs). It does not load any existing session first. While you can just set this to true, you probably want to set it to a function that decides when to save a session when launched with file args. See documentation for more detail&#xA;  continue_restore_on_error = true, -- Keep loading the session even if there&#39;s an error&#xA;  show_auto_restore_notif = false, -- Whether to show a notification when auto-restoring&#xA;  cwd_change_handling = false, -- Follow cwd changes, saving a session before change and restoring after&#xA;  lsp_stop_on_restore = false, -- Should language servers be stopped when restoring a session. Can also be a function that will be called if set. Not called on autorestore from startup&#xA;  restore_error_handler = nil, -- Called when there&#39;s an error restoring. By default, it ignores fold errors otherwise it displays the error and returns false to disable auto_save&#xA;  purge_after_minutes = nil, -- Sessions older than purge_after_minutes will be deleted asynchronously on startup, e.g. set to 14400 to delete sessions that haven&#39;t been accessed for more than 10 days, defaults to off (no purging), requires &amp;gt;= nvim 0.10&#xA;  log_level = &#34;error&#34;, -- Sets the log level of the plugin (debug, info, warn, error).&#xA;&#xA;  session_lens = {&#xA;    load_on_setup = true, -- Initialize on startup (requires Telescope)&#xA;    theme_conf = { -- Pass through for Telescope theme options&#xA;      -- layout_config = { -- As one example, can change width/height of picker&#xA;      --   width = 0.8,    -- percent of window&#xA;      --   height = 0.5,&#xA;      -- },&#xA;    },&#xA;    previewer = false, -- File preview for session picker&#xA;&#xA;    mappings = {&#xA;      -- Mode can be a string or a table, e.g. {&#34;i&#34;, &#34;n&#34;} for both insert and normal mode&#xA;      delete_session = { &#34;i&#34;, &#34;&amp;lt;C-D&amp;gt;&#34; },&#xA;      alternate_session = { &#34;i&#34;, &#34;&amp;lt;C-S&amp;gt;&#34; },&#xA;      copy_session = { &#34;i&#34;, &#34;&amp;lt;C-Y&amp;gt;&#34; },&#xA;    },&#xA;&#xA;    session_control = {&#xA;      control_dir = vim.fn.stdpath &#34;data&#34; .. &#34;/auto_session/&#34;, -- Auto session control dir, for control files, like alternating between two sessions with session-lens&#xA;      control_filename = &#34;session_control.json&#34;, -- File name of the session control file&#xA;    },&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: Older configuration names are still currently supported and will be automatically translated to the names above. If you want to update your config to the new names, &lt;code&gt;:checkhealth auto-session&lt;/code&gt; will show you your config using the new names.&lt;/p&gt; &#xA;&lt;h4&gt;Recommended sessionoptions config&lt;/h4&gt; &#xA;&lt;p&gt;For a better experience with the plugin overall using this config for &lt;code&gt;sessionoptions&lt;/code&gt; is recommended:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lua&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.o.sessionoptions=&#34;blank,buffers,curdir,folds,help,tabpages,winsize,winpos,terminal,localoptions&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;VimL&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-viml&#34;&gt;set sessionoptions+=winpos,terminal,folds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;⚠&lt;/span&gt; if you use &lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;packer.nvim&lt;/a&gt;&#39;s lazy loading feature, and you have the &lt;code&gt;options&lt;/code&gt; value in your &lt;code&gt;sessionoptions&lt;/code&gt; beware it might lead to weird behaviour with the lazy loading, especially around key-based lazy loading where keymaps are kept and thus the lazy loading mapping packer creates never gets set again.&lt;/p&gt; &#xA;&lt;h1&gt;📢 Commands&lt;/h1&gt; &#xA;&lt;p&gt;AutoSession exposes the following commands that can be used or mapped to any keybindings for manually saving and restoring sessions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-viml&#34;&gt;:SessionSave &#34; saves a session based on the `cwd` in `root_dir`&#xA;:SessionSave my_session &#34; saves a session called `my_session` in `root_dir`&#xA;&#xA;:SessionRestore &#34; restores a session based on the `cwd` from `root_dir`&#xA;:SessionRestore my_session &#34; restores `my_session` from `root_dir`&#xA;&#xA;:SessionDelete &#34; deletes a session based on the `cwd` from `root_dir`&#xA;:SessionDelete my_session &#34; deletes `my_sesion` from `root_dir`&#xA;&#xA;:SessionDisableAutoSave &#34; disables autosave&#xA;:SessionDisableAutoSave! &#34; enables autosave (still does all checks in the config)&#xA;:SessionToggleAutoSave &#34; toggles autosave&#xA;&#xA;:SessionPurgeOrphaned &#34; removes all orphaned sessions with no working directory left.&#xA;&#xA;:SessionSearch &#34; open a session picker, uses Telescope or Snacks if installed, vim.ui.select otherwise&#xA;&#xA;:Autosession search &#34; open a vim.ui.select picker to choose a session to load.&#xA;:Autosession delete &#34; open a vim.ui.select picker to choose a session to delete.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you create a manually named session via &lt;code&gt;SessionSave my_session&lt;/code&gt; or you restore one, that same session will be auto-saved (assuming that&#39;s enabled) when you exit.&lt;/p&gt; &#xA;&lt;h1&gt;📖 More Configuration Details&lt;/h1&gt; &#xA;&lt;h2&gt;🔭 Session Lens&lt;/h2&gt; &#xA;&lt;p&gt;You can use Telescope or &lt;a href=&#34;https://github.com/folke/snacks.nvim&#34;&gt;snacks.nvim&lt;/a&gt; to see, load, and delete your sessions. It&#39;s enabled by default if you have Telescope, but here&#39;s the Lazy config that shows the configuration options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;&#xA;{&#xA;  &#39;rmagatti/auto-session&#39;,&#xA;  lazy = false,&#xA;  keys = {&#xA;    -- Will use Telescope if installed or a vim.ui.select picker otherwise&#xA;    { &#39;&amp;lt;leader&amp;gt;wr&#39;, &#39;&amp;lt;cmd&amp;gt;SessionSearch&amp;lt;CR&amp;gt;&#39;, desc = &#39;Session search&#39; },&#xA;    { &#39;&amp;lt;leader&amp;gt;ws&#39;, &#39;&amp;lt;cmd&amp;gt;SessionSave&amp;lt;CR&amp;gt;&#39;, desc = &#39;Save session&#39; },&#xA;    { &#39;&amp;lt;leader&amp;gt;wa&#39;, &#39;&amp;lt;cmd&amp;gt;SessionToggleAutoSave&amp;lt;CR&amp;gt;&#39;, desc = &#39;Toggle autosave&#39; },&#xA;  },&#xA;&#xA;  ---enables autocomplete for opts&#xA;  ---@module &#34;auto-session&#34;&#xA;  ---@type AutoSession.Config&#xA;  opts = {&#xA;    -- ⚠️ This will only work if Telescope.nvim is installed&#xA;    -- The following are already the default values, no need to provide them if these are already the settings you want.&#xA;    session_lens = {&#xA;      -- If load_on_setup is false, make sure you use `:SessionSearch` to open the picker as it will initialize everything first&#xA;      load_on_setup = true,&#xA;      previewer = false,&#xA;      mappings = {&#xA;        -- Mode can be a string or a table, e.g. {&#34;i&#34;, &#34;n&#34;} for both insert and normal mode&#xA;        delete_session = { &#34;i&#34;, &#34;&amp;lt;C-D&amp;gt;&#34; },&#xA;        alternate_session = { &#34;i&#34;, &#34;&amp;lt;C-S&amp;gt;&#34; },&#xA;        copy_session = { &#34;i&#34;, &#34;&amp;lt;C-Y&amp;gt;&#34; },&#xA;      },&#xA;      -- Can also set some Telescope picker options&#xA;      -- For all options, see: https://github.com/nvim-telescope/telescope.nvim/blob/master/doc/telescope.txt#L112&#xA;      theme_conf = {&#xA;        border = true,&#xA;        -- layout_config = {&#xA;        --   width = 0.8, -- Can set width and height as percent of window&#xA;        --   height = 0.5,&#xA;        -- },&#xA;      },&#xA;    },&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;:SessionSearch&lt;/code&gt; to launch the session picker. If &lt;code&gt;load_on_setup = false&lt;/code&gt;, &lt;code&gt;:SessionSearch&lt;/code&gt; will initialize the Telescope extension when called. You can also use &lt;code&gt;:Telescope session-lens&lt;/code&gt; to launch the session picker but only if &lt;code&gt;load_on_setup = true&lt;/code&gt; or you&#39;ve previously called &lt;code&gt;SessionSearch&lt;/code&gt;. If you don&#39;t have Telescope installed but do have Snacks installed (and the picker enabled), AutoSession will use Snacks as the session picker. No change in configuration is needed (e.g. it will use the same keymap config).&lt;/p&gt; &#xA;&lt;p&gt;The following default keymaps are available when the session-lens picker is open:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt; loads the currently highlighted session.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;C-S&amp;gt;&lt;/code&gt; swaps to the previously opened session. This can give you a nice flow if you&#39;re constantly switching between two projects.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;C-D&amp;gt;&lt;/code&gt; will delete the currently highlighted session. This makes it easy to keep the session list clean.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;NOTE: If you previously installed &lt;code&gt;rmagatti/session-lens&lt;/code&gt;, you should remove it from your config as it is no longer necessary.&lt;/p&gt; &#xA;&lt;h3&gt;Preview&lt;/h3&gt; &#xA;&lt;img src=&#34;https://github.com/rmagatti/readme-assets/raw/main/session-lens.gif&#34; width=&#34;800&#34;&gt; &#xA;&lt;h2&gt;📁 Allowed / Suppressed directories&lt;/h2&gt; &#xA;&lt;p&gt;There are two config options, &lt;code&gt;allowed_dirs&lt;/code&gt; and &lt;code&gt;suppressed_dirs&lt;/code&gt;, that control which directories AutoSession will auto-save a session for. If &lt;code&gt;allowed_dirs&lt;/code&gt; is set, sessions will only be auto-saved in matching directories. If &lt;code&gt;suppressed_dirs&lt;/code&gt; is set, then a session won&#39;t be auto-saved for a matching directory. If both are set, a session will only be auto-saved if it matches an allowed dir and does not match a suppressed dir.&lt;/p&gt; &#xA;&lt;p&gt;Both options are a table of directories, with support for globs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;  allowed_dirs = { &#39;/some/dir/&#39;, &#39;/projects/*&#39; }&#xA;  suppressed_dirs = { &#39;/projects/secret&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With those options, sessions would only be auto-saved for &lt;code&gt;/some/dir&lt;/code&gt; and any direct child of &lt;code&gt;/projects&lt;/code&gt; (e.g. &lt;code&gt;/projects/myproject&lt;/code&gt; but not &lt;code&gt;/projects/myproject/submodule&lt;/code&gt;) except &lt;code&gt;/projects/secret&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you want even more fine-grained control, you can instead set &lt;code&gt;auto_create&lt;/code&gt; to a function to &lt;a href=&#34;https://raw.githubusercontent.com/rmagatti/auto-session/main/#conditionally-creating-a-session&#34;&gt;conditionally create a session&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;🚶 Current Working Directory&lt;/h2&gt; &#xA;&lt;p&gt;AutoSession can track &lt;code&gt;cwd&lt;/code&gt; changes!&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s disabled by default, but when enabled it works as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;DirChangedPre (before the cwd actually changes): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Save the current session&lt;/li&gt; &#xA;   &lt;li&gt;Clear all buffers &lt;code&gt;%bw!&lt;/code&gt;. This guarantees buffers don&#39;t bleed to the next session.&lt;/li&gt; &#xA;   &lt;li&gt;Clear jumps. Also done so there is no bleeding between sessions.&lt;/li&gt; &#xA;   &lt;li&gt;Run the &lt;code&gt;pre_cwd_changed&lt;/code&gt; hook&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;DirChanged (after the cwd has changed): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Restore session using new cwd&lt;/li&gt; &#xA;   &lt;li&gt;Run the &lt;code&gt;post_cwd_changed&lt;/code&gt; hook&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Now when you changes the cwd with &lt;code&gt;:cd some/new/dir&lt;/code&gt; AutoSession handles it gracefully, saving the current session so there aren&#39;t losses and loading the session for the upcoming cwd if it exists.&lt;/p&gt; &#xA;&lt;p&gt;Hooks are available for custom actions &lt;em&gt;before&lt;/em&gt; and &lt;em&gt;after&lt;/em&gt; the &lt;code&gt;cwd&lt;/code&gt; is changed. Here&#39;s the config for tracking cwd and a hook example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;auto-session&#39;).setup({&#xA;  suppressed_dirs = { &#39;~/&#39;, &#39;~/Projects&#39;, &#39;~/Downloads&#39;, &#39;/&#39; },&#xA;&#xA;  cwd_change_handling = true&#xA;&#xA;  pre_cwd_changed_cmds = {&#xA;    &#34;tabdo NERDTreeClose&#34; -- Close NERDTree before saving session&#xA;  }&#xA;&#xA;  post_cwd_changed_cmds = {&#xA;    function()&#xA;      require(&#34;lualine&#34;).refresh() -- example refreshing the lualine status line _after_ the cwd changes&#xA;    end&#xA;  }&#xA;&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;🖥️ Dashboards&lt;/h2&gt; &#xA;&lt;p&gt;If you use a dashboard, you probably don&#39;t want to try and save a session when just the dashboard is open. To avoid that, add your dashboard filetype to the bypass list as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;auto-session&#39;).setup({&#xA;  bypass_save_filetypes = { &#39;alpha&#39;, &#39;dashboard&#39; } -- or whatever dashboard you use&#xA;})&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;🪝 Command Hooks&lt;/h2&gt; &#xA;&lt;h4&gt;Command hooks are a list of commands that get executed at different stages of the session management lifecycle.&lt;/h4&gt; &#xA;&lt;p&gt;Command hooks exist in the format: {hook_name}&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;{pre_save}&lt;/code&gt;: executes &lt;em&gt;before&lt;/em&gt; a session is saved&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{save_extra}&lt;/code&gt;: executes &lt;em&gt;after&lt;/em&gt; a session is saved, saves returned string or table to &lt;code&gt;*x.vim&lt;/code&gt;, reference &lt;code&gt;:help mks&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{post_save}&lt;/code&gt;: executes &lt;em&gt;after&lt;/em&gt; a session is saved&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{pre_restore}&lt;/code&gt;: executes &lt;em&gt;before&lt;/em&gt; a session is restored&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{post_restore}&lt;/code&gt;: executes &lt;em&gt;after&lt;/em&gt; a session is restored&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{pre_delete}&lt;/code&gt;: executes &lt;em&gt;before&lt;/em&gt; a session is deleted&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{post_delete}&lt;/code&gt;: executes &lt;em&gt;after&lt;/em&gt; a session is deleted&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{no_restore}&lt;/code&gt;: executes &lt;em&gt;at&lt;/em&gt; &lt;code&gt;VimEnter&lt;/code&gt; &lt;em&gt;when&lt;/em&gt; no session is restored&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{pre_cwd_changed}&lt;/code&gt;: executes &lt;em&gt;before&lt;/em&gt; a directory is changed (if &lt;code&gt;cwd_change_handling&lt;/code&gt; is enabled)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{post_cwd_changed}&lt;/code&gt;: executes &lt;em&gt;after&lt;/em&gt; a directory is changed (if &lt;code&gt;cwd_change_handling&lt;/code&gt; is enabled)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Each hook is a table of vim commands or lua functions (or a mix of both):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;auto-session&#39;).setup {&#xA;  -- {hook_name}_cmds = {&#34;{hook_command1}&#34;, &#34;{hook_command2}&#34;}&#xA;&#xA;  pre_save_cmds = {&#xA;    &#34;tabdo NERDTreeClose&#34; -- Close NERDTree before saving session&#xA;  },&#xA;&#xA;  post_restore_cmds = {&#xA;    &#34;someOtherVimCommand&#34;,&#xA;    function()&#xA;      -- Restore nvim-tree after a session is restored&#xA;      local nvim_tree_api = require(&#39;nvim-tree.api&#39;)&#xA;      nvim_tree_api.tree.open()&#xA;      nvim_tree_api.tree.change_root(vim.fn.getcwd())&#xA;      nvim_tree_api.tree.reload()&#xA;    end&#xA;  },&#xA;&#xA;  -- Save quickfix list and open it when restoring the session&#xA;  save_extra_cmds = {&#xA;    function()&#xA;      local qflist = vim.fn.getqflist()&#xA;      -- return nil to clear any old qflist&#xA;      if #qflist == 0 then return nil end&#xA;      local qfinfo = vim.fn.getqflist({ title = 1 })&#xA;&#xA;      for _, entry in ipairs(qflist) do&#xA;        -- use filename instead of bufnr so it can be reloaded&#xA;        entry.filename = vim.api.nvim_buf_get_name(entry.bufnr)&#xA;        entry.bufnr = nil&#xA;      end&#xA;&#xA;      local setqflist = &#39;call setqflist(&#39; .. vim.fn.string(qflist) .. &#39;)&#39;&#xA;      local setqfinfo = &#39;call setqflist([], &#34;a&#34;, &#39; .. vim.fn.string(qfinfo) .. &#39;)&#39;&#xA;      return { setqflist, setqfinfo, &#39;copen&#39; }&#xA;    end,&#xA;  },&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;➖ Statusline&lt;/h2&gt; &#xA;&lt;p&gt;You can show the current session name in the statusline by using the function &lt;code&gt;current_session_name()&lt;/code&gt;. With no arguments, it will return the full session name. For automatically created sessions that will be the path where the session was saved. If you only want the last directory in the path, you can call &lt;code&gt;current_session_name(true)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example using &lt;a href=&#34;https://github.com/nvim-lualine/lualine.nvim&#34;&gt;Lualine&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;lualine&#39;).setup{&#xA;  options = {&#xA;    theme = &#39;tokyonight&#39;,&#xA;  },&#xA;  sections = {&#xA;    lualine_c = {&#xA;      function()&#xA;        return require(&#39;auto-session.lib&#39;).current_session_name(true)&#xA;      end&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img width=&#34;1904&#34; alt=&#34;Screen Shot 2021-10-30 at 3 58 57 PM&#34; src=&#34;https://user-images.githubusercontent.com/2881382/139559478-8edefdb8-8254-42e7-a0f3-babd3dfd6ff2.png&#34;&gt; &#xA;&lt;h2&gt;⏮️ Last Session&lt;/h2&gt; &#xA;&lt;p&gt;This optional feature enables the keeping track and loading of the last session. The last session is only loaded at startup if there isn&#39;t already a session for the current working directory. This feature can come in handy when starting Neovim from a GUI for example.&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;⚠&lt;/span&gt; If the directory does not exist, default directory will be used and an error message will be printed.&lt;br&gt; &lt;span&gt;⚠&lt;/span&gt; This feature is still experimental and as of right now it interferes with the plugin&#39;s ability to auto create new sessions when opening Neovim in a new directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;auto-session&#39;).setup {&#xA;    auto_restore_last_session = true,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A quick workaround for inability to auto create new sessions is to conditionally enable last session.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;auto-session&#39;).setup {&#xA;    auto_restore_last_session = vim.loop.cwd() == vim.loop.os_homedir(),&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now last session will be restored only when Neovim is launched in the home directory, which is usually right after launching the terminal or Neovim GUI clients.&lt;/p&gt; &#xA;&lt;h2&gt;Conditionally creating a session&lt;/h2&gt; &#xA;&lt;p&gt;With &lt;code&gt;auto_create = false&lt;/code&gt;, AutoSession won&#39;t create a session automatically. If you manually save a session via &lt;code&gt;:SessionSave&lt;/code&gt;, though, it will automatically update it whenever you exit &lt;code&gt;nvim&lt;/code&gt;. You can use that to manually control where sessions are created.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;auto_create&lt;/code&gt; doesn&#39;t just have to be a boolean, it can also take a function that returns if a session should be created or not as part of auto saving. As one example, you could use this to only automatically create new session files inside of git projects:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;&#xA;require(&#39;auto-session&#39;).setup({&#xA;  auto_create = function()&#xA;    local cmd = &#39;git rev-parse --is-inside-work-tree&#39;&#xA;    return vim.fn.system(cmd) == &#39;true\n&#39;&#xA;  end,&#xA;})&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With the above, AutoSession will allow automatically creating a session inside of a git project but won&#39;t automatically create a session in any other directory. If you manually save a session in a directory, though, it will then update that session automatically whenever you exit &lt;code&gt;nvim&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;🗃️ Argument Handling&lt;/h2&gt; &#xA;&lt;p&gt;By default, when &lt;code&gt;nvim&lt;/code&gt; is run with a single directory argument, AutoSession will try to restore the session for that directory. If &lt;code&gt;nvim&lt;/code&gt; is run with multiple directories or any file arguments, AutoSession won&#39;t try to restore a session and won&#39;t auto-save a session on exit (if enabled). Those behaviors can be changed with these config parameters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;  args_allow_single_directory = true, -- boolean Follow normal sesion save/load logic if launched with a single directory as the only argument&#xA;  args_allow_files_auto_save = false, -- boolean|function Allow saving a session even when launched with a file argument (or multiple files/dirs). It does not load any existing session first. While you can just set this to true, you probably want to set it to a function that decides when to save a session when launched with file args. See documentation for more detail&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;code&gt;args_allow_single_directory&lt;/code&gt;, if you frequently use &lt;code&gt;netrw&lt;/code&gt; to look at directories, you might want to add it to &lt;code&gt;bypass_save_filetypes&lt;/code&gt; if you don&#39;t want to create a session for each directory you look at:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;      bypass_save_filetypes = { &#39;netrw&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, if you use a plugin that handles directory arguments (e.g. file trees/explorers), it may prevent AutoSession from loading or saving sessions when launched with a directory argument. You can avoid that by lazy loading that plugin (e.g. &lt;a href=&#34;https://github.com/rmagatti/auto-session/issues/372#issuecomment-2471077783&#34;&gt;Oil&lt;/a&gt;, &lt;a href=&#34;https://github.com/rmagatti/auto-session/issues/393#issuecomment-2474797271&#34;&gt;NvimTree&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;args_allow_files_auto_save&lt;/code&gt; is true, AutoSession won&#39;t load any session when &lt;code&gt;nvim&lt;/code&gt; is launched with file argument(s) but it will save on exit. What&#39;s probably more useful is to set &lt;code&gt;args_allow_files_auto_save&lt;/code&gt; to a function that returns true if a session should be saved and false otherwise. AutoSession will call that function on auto save when run with arguments. Here&#39;s one example config where it will save the session if at least two buffers are open after being launched with arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;auto-session&#39;).setup({&#xA;  args_allow_files_auto_save = function()&#xA;    local supported = 0&#xA;&#xA;    local buffers = vim.api.nvim_list_bufs()&#xA;    for _, buf in ipairs(buffers) do&#xA;      -- Check if the buffer is valid and loaded&#xA;      if vim.api.nvim_buf_is_valid(buf) and vim.api.nvim_buf_is_loaded(buf) then&#xA;        local path = vim.api.nvim_buf_get_name(buf)&#xA;        if vim.fn.filereadable(path) ~= 0 then supported = supported + 1 end&#xA;      end&#xA;    end&#xA;&#xA;    -- If we have more 2 or more supported buffers, save the session&#xA;    return supported &amp;gt;= 2&#xA;  end,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Another possibility is to only save the session if there are at least two windows with buffers backed by normal files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;auto-session&#39;).setup({&#xA;  args_allow_files_auto_save = function()&#xA;    local supported = 0&#xA;&#xA;    local tabpages = vim.api.nvim_list_tabpages()&#xA;    for _, tabpage in ipairs(tabpages) do&#xA;      local windows = vim.api.nvim_tabpage_list_wins(tabpage)&#xA;      for _, window in ipairs(windows) do&#xA;        local buffer = vim.api.nvim_win_get_buf(window)&#xA;        local file_name = vim.api.nvim_buf_get_name(buffer)&#xA;        if vim.fn.filereadable(file_name) ~= 0 then supported = supported + 1 end&#xA;      end&#xA;    end&#xA;&#xA;    -- If we have 2 or more windows with supported buffers, save the session&#xA;    return supported &amp;gt;= 2&#xA;  end,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;🚫 Disabling the plugin&lt;/h2&gt; &#xA;&lt;p&gt;You might run into issues with Firenvim or another plugin and want to disable &lt;code&gt;auto_session&lt;/code&gt; altogether based on some condition. For this example, as to not try and save sessions for Firenvim, we disable the plugin if the &lt;code&gt;started_by_firenvim&lt;/code&gt; variable is set.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-viml&#34;&gt;if exists(&#39;g:started_by_firenvim&#39;)&#xA;  let g:auto_session_enabled = v:false&#xA;endif&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One can also disable the plugin by setting the &lt;code&gt;auto_session_enabled&lt;/code&gt; option to false at startup.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nvim --cmd &#34;let g:auto_session_enabled = v:false&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;🚧 Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;First run &lt;code&gt;:checkhealth auto-session&lt;/code&gt; to see if it detects any problems.&lt;/p&gt; &#xA;&lt;p&gt;If that doesn&#39;t help, you can:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;refer to the &lt;a href=&#34;https://github.com/rmagatti/auto-session/wiki/Troubleshooting&#34;&gt;wiki page&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;check the &lt;a href=&#34;https://github.com/rmagatti/auto-session/discussions&#34;&gt;Discussions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;or file an &lt;a href=&#34;https://github.com/rmagatti/auto-session/issues&#34;&gt;Issue&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Compatibility&lt;/h1&gt; &#xA;&lt;p&gt;Neovim &amp;gt; 0.7&lt;/p&gt; &#xA;&lt;p&gt;Tested with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;NVIM v0.7.2 - NVIM 0.11.0&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>