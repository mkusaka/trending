<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-02-02T01:43:19Z</updated>
  <subtitle>Weekly Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mrjones2014/smart-splits.nvim</title>
    <updated>2025-02-02T01:43:19Z</updated>
    <id>tag:github.com,2025-02-02:/mrjones2014/smart-splits.nvim</id>
    <link href="https://github.com/mrjones2014/smart-splits.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸ§  Smart, seamless, directional navigation and resizing of Neovim + terminal multiplexer splits. Supports tmux, Wezterm, and Kitty. Think about splits in terms of &#34;up/down/left/right&#34;.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;ðŸ§  &lt;code&gt;smart-splits.nvim&lt;/code&gt;&lt;/h1&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;ðŸ§  Smarter and more intuitive split pane management that uses a mental model of left/right/up/down instead of wider/narrower/taller/shorter for resizing. Supports seamless navigation between Neovim and terminal multiplexer split panes. See &lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#multiplexer-integrations&#34;&gt;Multiplexer Integrations&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/8648891/201928611-4338e3cb-cca9-4e15-92c6-0405b7072279.gif&#34; alt=&#34;demo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#install&#34;&gt;Install&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#configuration&#34;&gt;Configuration&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#hooks&#34;&gt;Hooks&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#examples&#34;&gt;Examples:&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#multiplexer-integrations&#34;&gt;Multiplexer Integrations&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#tmux&#34;&gt;Tmux&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#wezterm&#34;&gt;Wezterm&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#kitty&#34;&gt;Kitty&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#multiplexer-lua-api&#34;&gt;Multiplexer Lua API&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;smart-splits.nvim&lt;/code&gt; now supports semantic versioning via git tags. See &lt;a href=&#34;https://github.com/mrjones2014/smart-splits.nvim/releases&#34;&gt;Releases&lt;/a&gt; for a full list of versions and their changelogs, starting from 1.0.0.&lt;/p&gt; &#xA;&lt;p&gt;With Packer.nvim:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use(&#39;mrjones2014/smart-splits.nvim&#39;)&#xA;-- or use a specific version&#xA;use({ &#39;mrjones2014/smart-splits.nvim&#39;, tag = &#39;v1.0.0&#39; })&#xA;-- to use Kitty multiplexer support, run the post install hook&#xA;use({ &#39;mrjones2014/smart-splits.nvim&#39;, run = &#39;./kitty/install-kittens.bash&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With Lazy.nvim:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{ &#39;mrjones2014/smart-splits.nvim&#39; }&#xA;-- or use a specific version, or a range of versions using lazy.nvim&#39;s version API&#xA;{ &#39;mrjones2014/smart-splits.nvim&#39;, version = &#39;&amp;gt;=1.0.0&#39; }&#xA;-- to use Kitty multiplexer support, run the post install hook&#xA;{ &#39;mrjones2014/smart-splits.nvim&#39;, build = &#39;./kitty/install-kittens.bash&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;You can set ignored &lt;code&gt;buftype&lt;/code&gt;s or &lt;code&gt;filetype&lt;/code&gt;s which will be ignored when figuring out if your cursor is currently at an edge split for resizing. This is useful in order to ignore &#34;sidebar&#34; type buffers while resizing, such as &lt;a href=&#34;https://github.com/kyazdani42/nvim-tree.lua&#34;&gt;nvim-tree.lua&lt;/a&gt; which tries to maintain its own width unless manually resized. Note that nothing is ignored when moving between splits, only when resizing.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] &lt;br&gt; &lt;code&gt;smart-splits.nvim&lt;/code&gt; does not map any keys on it&#39;s own. See &lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#usage&#34;&gt;Usage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Defaults are shown below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;smart-splits&#39;).setup({&#xA;  -- Ignored buffer types (only while resizing)&#xA;  ignored_buftypes = {&#xA;    &#39;nofile&#39;,&#xA;    &#39;quickfix&#39;,&#xA;    &#39;prompt&#39;,&#xA;  },&#xA;  -- Ignored filetypes (only while resizing)&#xA;  ignored_filetypes = { &#39;NvimTree&#39; },&#xA;  -- the default number of lines/columns to resize by at a time&#xA;  default_amount = 3,&#xA;  -- Desired behavior when your cursor is at an edge and you&#xA;  -- are moving towards that same edge:&#xA;  -- &#39;wrap&#39; =&amp;gt; Wrap to opposite side&#xA;  -- &#39;split&#39; =&amp;gt; Create a new split in the desired direction&#xA;  -- &#39;stop&#39; =&amp;gt; Do nothing&#xA;  -- function =&amp;gt; You handle the behavior yourself&#xA;  -- NOTE: If using a function, the function will be called with&#xA;  -- a context object with the following fields:&#xA;  -- {&#xA;  --    mux = {&#xA;  --      type:&#39;tmux&#39;|&#39;wezterm&#39;|&#39;kitty&#39;&#xA;  --      current_pane_id():number,&#xA;  --      is_in_session(): boolean&#xA;  --      current_pane_is_zoomed():boolean,&#xA;  --      -- following methods return a boolean to indicate success or failure&#xA;  --      current_pane_at_edge(direction:&#39;left&#39;|&#39;right&#39;|&#39;up&#39;|&#39;down&#39;):boolean&#xA;  --      next_pane(direction:&#39;left&#39;|&#39;right&#39;|&#39;up&#39;|&#39;down&#39;):boolean&#xA;  --      resize_pane(direction:&#39;left&#39;|&#39;right&#39;|&#39;up&#39;|&#39;down&#39;):boolean&#xA;  --      split_pane(direction:&#39;left&#39;|&#39;right&#39;|&#39;up&#39;|&#39;down&#39;,size:number|nil):boolean&#xA;  --    },&#xA;  --    direction = &#39;left&#39;|&#39;right&#39;|&#39;up&#39;|&#39;down&#39;,&#xA;  --    split(), -- utility function to split current Neovim pane in the current direction&#xA;  --    wrap(), -- utility function to wrap to opposite Neovim pane&#xA;  -- }&#xA;  -- NOTE: `at_edge = &#39;wrap&#39;` is not supported on Kitty terminal&#xA;  -- multiplexer, as there is no way to determine layout via the CLI&#xA;  at_edge = &#39;wrap&#39;,&#xA;  -- Desired behavior when the current window is floating:&#xA;  -- &#39;previous&#39; =&amp;gt; Focus previous Vim window and perform action&#xA;  -- &#39;mux&#39; =&amp;gt; Always forward action to multiplexer&#xA;  float_win_behavior = &#39;previous&#39;,&#xA;  -- when moving cursor between splits left or right,&#xA;  -- place the cursor on the same row of the *screen*&#xA;  -- regardless of line numbers. False by default.&#xA;  -- Can be overridden via function parameter, see Usage.&#xA;  move_cursor_same_row = false,&#xA;  -- whether the cursor should follow the buffer when swapping&#xA;  -- buffers by default; it can also be controlled by passing&#xA;  -- `{ move_cursor = true }` or `{ move_cursor = false }`&#xA;  -- when calling the Lua function.&#xA;  cursor_follows_swapped_bufs = false,&#xA;  -- resize mode options&#xA;  resize_mode = {&#xA;    -- key to exit persistent resize mode&#xA;    quit_key = &#39;&amp;lt;ESC&amp;gt;&#39;,&#xA;    -- keys to use for moving in resize mode&#xA;    -- in order of left, down, up&#39; right&#xA;    resize_keys = { &#39;h&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39; },&#xA;    -- set to true to silence the notifications&#xA;    -- when entering/exiting persistent resize mode&#xA;    silent = false,&#xA;    -- must be functions, they will be executed when&#xA;    -- entering or exiting the resize mode&#xA;    hooks = {&#xA;      on_enter = nil,&#xA;      on_leave = nil,&#xA;    },&#xA;  },&#xA;  -- ignore these autocmd events (via :h eventignore) while processing&#xA;  -- smart-splits.nvim computations, which involve visiting different&#xA;  -- buffers and windows. These events will be ignored during processing,&#xA;  -- and un-ignored on completed. This only applies to resize events,&#xA;  -- not cursor movement events.&#xA;  ignored_events = {&#xA;    &#39;BufEnter&#39;,&#xA;    &#39;WinEnter&#39;,&#xA;  },&#xA;  -- enable or disable a multiplexer integration;&#xA;  -- automatically determined, unless explicitly disabled or set,&#xA;  -- by checking the $TERM_PROGRAM environment variable,&#xA;  -- and the $KITTY_LISTEN_ON environment variable for Kitty.&#xA;  -- You can also set this value by setting `vim.g.smart_splits_multiplexer_integration`&#xA;  -- before the plugin is loaded (e.g. for lazy environments).&#xA;  multiplexer_integration = nil,&#xA;  -- disable multiplexer navigation if current multiplexer pane is zoomed&#xA;  -- this functionality is only supported on tmux and Wezterm due to kitty&#xA;  -- not having a way to check if a pane is zoomed&#xA;  disable_multiplexer_nav_when_zoomed = true,&#xA;  -- Supply a Kitty remote control password if needed,&#xA;  -- or you can also set vim.g.smart_splits_kitty_password&#xA;  -- see https://sw.kovidgoyal.net/kitty/conf/#opt-kitty.remote_control_password&#xA;  kitty_password = nil,&#xA;  -- default logging level, one of: &#39;trace&#39;|&#39;debug&#39;|&#39;info&#39;|&#39;warn&#39;|&#39;error&#39;|&#39;fatal&#39;&#xA;  log_level = &#39;info&#39;,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Hooks&lt;/h3&gt; &#xA;&lt;p&gt;The hook table allows you to define callbacks for the &lt;code&gt;on_enter&lt;/code&gt; and &lt;code&gt;on_leave&lt;/code&gt; events of the resize mode.&lt;/p&gt; &#xA;&lt;h5&gt;Examples&lt;/h5&gt; &#xA;&lt;p&gt;Integration with &lt;a href=&#34;https://github.com/kwkarlwang/bufresize.nvim&#34;&gt;bufresize.nvim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;smart-splits&#39;).setup({&#xA;  resize_mode = {&#xA;    hooks = {&#xA;      on_leave = require(&#39;bufresize&#39;).register,&#xA;    },&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Custom messages when using resize mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;smart-splits&#39;).setup({&#xA;  resize_mode = {&#xA;    silent = true,&#xA;    hooks = {&#xA;      on_enter = function()&#xA;        vim.notify(&#39;Entering resize mode&#39;)&#xA;      end,&#xA;      on_leave = function()&#xA;        vim.notify(&#39;Exiting resize mode, bye&#39;)&#xA;      end,&#xA;    },&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Key Mappings&lt;/h3&gt; &#xA;&lt;p&gt;If you are a &lt;a href=&#34;https://github.com/mrjones2014/legendary.nvim&#34;&gt;legendary.nvim&lt;/a&gt; (&amp;gt;= v2.10.0) user, you can quickly easily and easily create with the &lt;code&gt;legendary.nvim&lt;/code&gt; extension for &lt;code&gt;smart-splits.nvim&lt;/code&gt;. See more option in the &lt;a href=&#34;https://github.com/mrjones2014/legendary.nvim/raw/master/doc/EXTENSIONS.md#smart-splitsnvim&#34;&gt;extension documentation in &lt;code&gt;legendary.nvim&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;legendary&#39;).setup({&#xA;  extensions = {&#xA;    -- to use default settings:&#xA;    smart_splits = {},&#xA;    -- default settings shown below:&#xA;    smart_splits = {&#xA;      directions = { &#39;h&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39; },&#xA;      mods = {&#xA;        -- for moving cursor between windows&#xA;        move = &#39;&amp;lt;C&amp;gt;&#39;,&#xA;        -- for resizing windows&#xA;        resize = &#39;&amp;lt;M&amp;gt;&#39;,&#xA;        -- for swapping window buffers&#xA;        swap = false, -- false disables creating a binding&#xA;      },&#xA;    },&#xA;    -- or, customize the mappings&#xA;    smart_splits = {&#xA;      mods = {&#xA;        -- any of the mods can also be a table of the following form&#xA;        swap = {&#xA;          -- this will create the mapping like&#xA;          -- &amp;lt;leader&amp;gt;&amp;lt;C-h&amp;gt;&#xA;          -- &amp;lt;leader&amp;gt;&amp;lt;C-j&amp;gt;&#xA;          -- &amp;lt;leader&amp;gt;&amp;lt;C-k&amp;gt;&#xA;          -- &amp;lt;leader&amp;gt;&amp;lt;C-l&amp;gt;&#xA;          mod = &#39;&amp;lt;C&amp;gt;&#39;,&#xA;          prefix = &#39;&amp;lt;leader&amp;gt;&#39;,&#xA;        },&#xA;      },&#xA;    },&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Otherwise, here are some recommended mappings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- recommended mappings&#xA;-- resizing splits&#xA;-- these keymaps will also accept a range,&#xA;-- for example `10&amp;lt;A-h&amp;gt;` will `resize_left` by `(10 * config.default_amount)`&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;A-h&amp;gt;&#39;, require(&#39;smart-splits&#39;).resize_left)&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;A-j&amp;gt;&#39;, require(&#39;smart-splits&#39;).resize_down)&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;A-k&amp;gt;&#39;, require(&#39;smart-splits&#39;).resize_up)&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;A-l&amp;gt;&#39;, require(&#39;smart-splits&#39;).resize_right)&#xA;-- moving between splits&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;C-h&amp;gt;&#39;, require(&#39;smart-splits&#39;).move_cursor_left)&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;C-j&amp;gt;&#39;, require(&#39;smart-splits&#39;).move_cursor_down)&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;C-k&amp;gt;&#39;, require(&#39;smart-splits&#39;).move_cursor_up)&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;C-l&amp;gt;&#39;, require(&#39;smart-splits&#39;).move_cursor_right)&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;C-\\&amp;gt;&#39;, require(&#39;smart-splits&#39;).move_cursor_previous)&#xA;-- swapping buffers between windows&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;leader&amp;gt;&amp;lt;leader&amp;gt;h&#39;, require(&#39;smart-splits&#39;).swap_buf_left)&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;leader&amp;gt;&amp;lt;leader&amp;gt;j&#39;, require(&#39;smart-splits&#39;).swap_buf_down)&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;leader&amp;gt;&amp;lt;leader&amp;gt;k&#39;, require(&#39;smart-splits&#39;).swap_buf_up)&#xA;vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;leader&amp;gt;&amp;lt;leader&amp;gt;l&#39;, require(&#39;smart-splits&#39;).swap_buf_right)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Lua API&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- resizing splits&#xA;-- amount defaults to 3 if not specified&#xA;-- use absolute values, no + or -&#xA;-- the functions also check for a range,&#xA;-- so for example if you bind `&amp;lt;A-h&amp;gt;` to `resize_left`,&#xA;-- then `10&amp;lt;A-h&amp;gt;` will `resize_left` by `(10 * config.default_amount)`&#xA;require(&#39;smart-splits&#39;).resize_up(amount)&#xA;require(&#39;smart-splits&#39;).resize_down(amount)&#xA;require(&#39;smart-splits&#39;).resize_left(amount)&#xA;require(&#39;smart-splits&#39;).resize_right(amount)&#xA;-- moving between splits&#xA;-- You can override config.at_edge and&#xA;-- config.move_cursor_same_row via opts&#xA;-- See Configuration.&#xA;require(&#39;smart-splits&#39;).move_cursor_up({ same_row = boolean, at_edge = &#39;wrap&#39; | &#39;split&#39; | &#39;stop&#39; })&#xA;require(&#39;smart-splits&#39;).move_cursor_down()&#xA;require(&#39;smart-splits&#39;).move_cursor_left()&#xA;require(&#39;smart-splits&#39;).move_cursor_right()&#xA;require(&#39;smart-splits&#39;).move_cursor_previous()&#xA;-- Swapping buffers directionally with the window to the specified direction&#xA;require(&#39;smart-splits&#39;).swap_buf_up()&#xA;require(&#39;smart-splits&#39;).swap_buf_down()&#xA;require(&#39;smart-splits&#39;).swap_buf_left()&#xA;require(&#39;smart-splits&#39;).swap_buf_right()&#xA;-- the buffer swap functions can also take an `opts` table to override the&#xA;-- default behavior of whether or not the cursor follows the buffer&#xA;require(&#39;smart-splits&#39;).swap_buf_right({ move_cursor = true })&#xA;-- persistent resize mode&#xA;-- temporarily remap your configured resize keys to&#xA;-- smart resize left, down, up, and right, respectively,&#xA;-- press &amp;lt;ESC&amp;gt; to stop resize mode (unless you&#39;ve set a different key in config)&#xA;-- resize keys also accept a range, e.e. pressing `5j` will resize down 5 times the default_amount&#xA;require(&#39;smart-splits&#39;).start_resize_mode()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiplexer Integrations&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;smart-splits.nvim&lt;/code&gt; can also enable seamless navigation between Neovim splits and &lt;code&gt;tmux&lt;/code&gt;, &lt;code&gt;wezterm&lt;/code&gt;, or &lt;code&gt;kitty&lt;/code&gt; panes. You will need to set up keymaps in your &lt;code&gt;tmux&lt;/code&gt;, &lt;code&gt;wezterm&lt;/code&gt;, or &lt;code&gt;kitty&lt;/code&gt; configs to match the Neovim keymaps.&lt;/p&gt; &#xA;&lt;p&gt;You can also set the desired multiplexer integration in lazy environments before the plugin is loaded by setting &lt;code&gt;vim.g.smart_splits_multiplexer_integration&lt;/code&gt;. The values are the same as described in &lt;a href=&#34;https://raw.githubusercontent.com/mrjones2014/smart-splits.nvim/master/#configuration&#34;&gt;Configuration&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Tmux&lt;/h4&gt; &#xA;&lt;p&gt;Add the following snippet to your &lt;code&gt;~/.tmux.conf&lt;/code&gt;/&lt;code&gt;~/.config/tmux/tmux.conf&lt;/code&gt; file (customizing the keys and resize amount if desired):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-tmux&#34;&gt;# &#39;@pane-is-vim&#39; is a pane-local option that is set by the plugin on load,&#xA;# and unset when Neovim exits or suspends; note that this means you&#39;ll probably&#xA;# not want to lazy-load smart-splits.nvim, as the variable won&#39;t be set until&#xA;# the plugin is loaded&#xA;&#xA;# Smart pane switching with awareness of Neovim splits.&#xA;bind-key -n C-h if -F &#34;#{@pane-is-vim}&#34; &#39;send-keys C-h&#39;  &#39;select-pane -L&#39;&#xA;bind-key -n C-j if -F &#34;#{@pane-is-vim}&#34; &#39;send-keys C-j&#39;  &#39;select-pane -D&#39;&#xA;bind-key -n C-k if -F &#34;#{@pane-is-vim}&#34; &#39;send-keys C-k&#39;  &#39;select-pane -U&#39;&#xA;bind-key -n C-l if -F &#34;#{@pane-is-vim}&#34; &#39;send-keys C-l&#39;  &#39;select-pane -R&#39;&#xA;&#xA;# Alternatively, if you want to disable wrapping when moving in non-neovim panes, use these bindings&#xA;# bind-key -n C-h if -F &#39;#{@pane-is-vim}&#39; { send-keys C-h } { if -F &#39;#{pane_at_left}&#39;   &#39;&#39; &#39;select-pane -L&#39; }&#xA;# bind-key -n C-j if -F &#39;#{@pane-is-vim}&#39; { send-keys C-j } { if -F &#39;#{pane_at_bottom}&#39; &#39;&#39; &#39;select-pane -D&#39; }&#xA;# bind-key -n C-k if -F &#39;#{@pane-is-vim}&#39; { send-keys C-k } { if -F &#39;#{pane_at_top}&#39;    &#39;&#39; &#39;select-pane -U&#39; }&#xA;# bind-key -n C-l if -F &#39;#{@pane-is-vim}&#39; { send-keys C-l } { if -F &#39;#{pane_at_right}&#39;  &#39;&#39; &#39;select-pane -R&#39; }&#xA;&#xA;# Smart pane resizing with awareness of Neovim splits.&#xA;bind-key -n M-h if -F &#34;#{@pane-is-vim}&#34; &#39;send-keys M-h&#39; &#39;resize-pane -L 3&#39;&#xA;bind-key -n M-j if -F &#34;#{@pane-is-vim}&#34; &#39;send-keys M-j&#39; &#39;resize-pane -D 3&#39;&#xA;bind-key -n M-k if -F &#34;#{@pane-is-vim}&#34; &#39;send-keys M-k&#39; &#39;resize-pane -U 3&#39;&#xA;bind-key -n M-l if -F &#34;#{@pane-is-vim}&#34; &#39;send-keys M-l&#39; &#39;resize-pane -R 3&#39;&#xA;&#xA;tmux_version=&#39;$(tmux -V | sed -En &#34;s/^tmux ([0-9]+(.[0-9]+)?).*/\1/p&#34;)&#39;&#xA;if-shell -b &#39;[ &#34;$(echo &#34;$tmux_version &amp;lt; 3.0&#34; | bc)&#34; = 1 ]&#39; \&#xA;    &#34;bind-key -n &#39;C-\\&#39; if -F \&#34;#{@pane-is-vim}\&#34; &#39;send-keys C-\\&#39;  &#39;select-pane -l&#39;&#34;&#xA;if-shell -b &#39;[ &#34;$(echo &#34;$tmux_version &amp;gt;= 3.0&#34; | bc)&#34; = 1 ]&#39; \&#xA;    &#34;bind-key -n &#39;C-\\&#39; if -F \&#34;#{@pane-is-vim}\&#34; &#39;send-keys C-\\\\&#39;  &#39;select-pane -l&#39;&#34;&#xA;&#xA;bind-key -T copy-mode-vi &#39;C-h&#39; select-pane -L&#xA;bind-key -T copy-mode-vi &#39;C-j&#39; select-pane -D&#xA;bind-key -T copy-mode-vi &#39;C-k&#39; select-pane -U&#xA;bind-key -T copy-mode-vi &#39;C-l&#39; select-pane -R&#xA;bind-key -T copy-mode-vi &#39;C-\&#39; select-pane -l&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Quirks with Alacritty&lt;/h5&gt; &#xA;&lt;p&gt;By default, on macOS, Alacritty does not treat the &lt;code&gt;Option&lt;/code&gt; key as an &lt;code&gt;Alt&lt;/code&gt;/&lt;code&gt;Meta&lt;/code&gt; key. This is not useful and probably not what you want. If you want to use &lt;code&gt;Option&lt;/code&gt; key as an &lt;code&gt;Alt&lt;/code&gt; key for keymaps in &lt;code&gt;tmux&lt;/code&gt;, you will have to configure Alacritty to interpret the key code correctly. &lt;br&gt; &lt;a href=&#34;https://alacritty.org/config-alacritty.html#s20&#34;&gt;reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;window:&#xA;  option_as_alt: &#34;Both&#34; # or &#34;OnlyLeft&#34; or &#34;OnlyRight&#34; if you prefer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Wezterm&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] It is recommended &lt;em&gt;not to lazy load&lt;/em&gt; &lt;code&gt;smart-splits.nvim&lt;/code&gt; if using the Wezterm integration. If you need to lazy load, you need to use a different &lt;code&gt;is_vim()&lt;/code&gt; implementation below. The plugin is small, and smart about not loading modules unnecessarily, so it should have minimal impact on your startup time. It adds about 0.07ms on my setup.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] Pane resizing currently requires a nightly build of Wezterm. Check the output of &lt;code&gt;wezterm cli adjust-pane-size --help&lt;/code&gt; to see if your build supports it; if not, you can check how to obtain a nightly build by &lt;a href=&#34;https://wezfurlong.org/wezterm/installation.html&#34;&gt;following the instructions here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;First, ensure that the &lt;code&gt;wezterm&lt;/code&gt; CLI is on your &lt;code&gt;$PATH&lt;/code&gt;, as the CLI is used by the integration.&lt;/p&gt; &#xA;&lt;p&gt;Then, if you&#39;re on Wezterm nightly, you can use Wezterm&#39;s &lt;a href=&#34;https://github.com/wez/wezterm/commit/e4ae8a844d8feaa43e1de34c5cc8b4f07ce525dd&#34;&gt;experimental plugin loader&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local wezterm = require(&#39;wezterm&#39;)&#xA;local smart_splits = wezterm.plugin.require(&#39;https://github.com/mrjones2014/smart-splits.nvim&#39;)&#xA;local config = wezterm.config_builder()&#xA;-- you can put the rest of your Wezterm config here&#xA;smart_splits.apply_to_config(config, {&#xA;  -- the default config is here, if you&#39;d like to use the default keys,&#xA;  -- you can omit this configuration table parameter and just use&#xA;  -- smart_splits.apply_to_config(config)&#xA;&#xA;  -- directional keys to use in order of: left, down, up, right&#xA;  direction_keys = { &#39;h&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39; },&#xA;  -- if you want to use separate direction keys for move vs. resize, you&#xA;  -- can also do this:&#xA;  direction_keys = {&#xA;    move = { &#39;h&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39; },&#xA;    resize = { &#39;LeftArrow&#39;, &#39;DownArrow&#39;, &#39;UpArrow&#39;, &#39;RightArrow&#39; },&#xA;  },&#xA;  -- modifier keys to combine with direction_keys&#xA;  modifiers = {&#xA;    move = &#39;CTRL&#39;, -- modifier to use for pane movement, e.g. CTRL+h to move left&#xA;    resize = &#39;META&#39;, -- modifier to use for pane resize, e.g. META+h to resize to the left&#xA;  },&#xA;  -- log level to use: info, warn, error&#xA;  log_level = &#39;info&#39;,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Otherwise, add the following snippet to your &lt;code&gt;~/.config/wezterm/wezterm.lua&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local w = require(&#39;wezterm&#39;)&#xA;&#xA;-- if you are *NOT* lazy-loading smart-splits.nvim (recommended)&#xA;local function is_vim(pane)&#xA;  -- this is set by the plugin, and unset on ExitPre in Neovim&#xA;  return pane:get_user_vars().IS_NVIM == &#39;true&#39;&#xA;end&#xA;&#xA;-- if you *ARE* lazy-loading smart-splits.nvim (not recommended)&#xA;-- you have to use this instead, but note that this will not work&#xA;-- in all cases (e.g. over an SSH connection). Also note that&#xA;-- `pane:get_foreground_process_name()` can have high and highly variable&#xA;-- latency, so the other implementation of `is_vim()` will be more&#xA;-- performant as well.&#xA;local function is_vim(pane)&#xA;  -- This gsub is equivalent to POSIX basename(3)&#xA;  -- Given &#34;/foo/bar&#34; returns &#34;bar&#34;&#xA;  -- Given &#34;c:\\foo\\bar&#34; returns &#34;bar&#34;&#xA;  local process_name = string.gsub(pane:get_foreground_process_name(), &#39;(.*[/\\])(.*)&#39;, &#39;%2&#39;)&#xA;  return process_name == &#39;nvim&#39; or process_name == &#39;vim&#39;&#xA;end&#xA;&#xA;local direction_keys = {&#xA;  h = &#39;Left&#39;,&#xA;  j = &#39;Down&#39;,&#xA;  k = &#39;Up&#39;,&#xA;  l = &#39;Right&#39;,&#xA;}&#xA;&#xA;local function split_nav(resize_or_move, key)&#xA;  return {&#xA;    key = key,&#xA;    mods = resize_or_move == &#39;resize&#39; and &#39;META&#39; or &#39;CTRL&#39;,&#xA;    action = w.action_callback(function(win, pane)&#xA;      if is_vim(pane) then&#xA;        -- pass the keys through to vim/nvim&#xA;        win:perform_action({&#xA;          SendKey = { key = key, mods = resize_or_move == &#39;resize&#39; and &#39;META&#39; or &#39;CTRL&#39; },&#xA;        }, pane)&#xA;      else&#xA;        if resize_or_move == &#39;resize&#39; then&#xA;          win:perform_action({ AdjustPaneSize = { direction_keys[key], 3 } }, pane)&#xA;        else&#xA;          win:perform_action({ ActivatePaneDirection = direction_keys[key] }, pane)&#xA;        end&#xA;      end&#xA;    end),&#xA;  }&#xA;end&#xA;&#xA;return {&#xA;  keys = {&#xA;    -- move between split panes&#xA;    split_nav(&#39;move&#39;, &#39;h&#39;),&#xA;    split_nav(&#39;move&#39;, &#39;j&#39;),&#xA;    split_nav(&#39;move&#39;, &#39;k&#39;),&#xA;    split_nav(&#39;move&#39;, &#39;l&#39;),&#xA;    -- resize panes&#xA;    split_nav(&#39;resize&#39;, &#39;h&#39;),&#xA;    split_nav(&#39;resize&#39;, &#39;j&#39;),&#xA;    split_nav(&#39;resize&#39;, &#39;k&#39;),&#xA;    split_nav(&#39;resize&#39;, &#39;l&#39;),&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Kitty&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] It is recommended &lt;em&gt;not to lazy load&lt;/em&gt; &lt;code&gt;smart-splits.nvim&lt;/code&gt; if using the Kitty integration, since it depends on the plugin setting the &lt;code&gt;IS_NVIM&lt;/code&gt; Kitty user variable on startup. The plugin is small, and smart about not loading modules unnecessarily, so it should have minimal impact on your startup time. It adds about 0.07ms on my setup.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] The &lt;code&gt;config.at_edge = &#39;wrap&#39;&lt;/code&gt; option is not supoprted in Kitty terminal multiplexer due to inability to determine pane layout from CLI.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;By default the plugin sets a kitty user-var &lt;code&gt;IS_NVIM&lt;/code&gt; when it loads. You can take advantage of this together with kittys &lt;a href=&#34;https://sw.kovidgoyal.net/kitty/mapping/#conditional-mappings-depending-on-the-state-of-the-focused-window&#34;&gt;conditional mappings feature&lt;/a&gt; to use the same keybind for both kitty and neovim.&lt;/p&gt; &#xA;&lt;p&gt;Add the following snippet to &lt;code&gt;~/.config/kitty/kitty.conf&lt;/code&gt;, adjusting the keymaps and resize amount as desired.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;map ctrl+j neighboring_window down&#xA;map ctrl+k neighboring_window up&#xA;map ctrl+h neighboring_window left&#xA;map ctrl+l neighboring_window right&#xA;&#xA;# Unset the mapping to pass the keys to neovim&#xA;map --when-focus-on var:IS_NVIM ctrl+j&#xA;map --when-focus-on var:IS_NVIM ctrl+k&#xA;map --when-focus-on var:IS_NVIM ctrl+h&#xA;map --when-focus-on var:IS_NVIM ctrl+l&#xA;&#xA;# the 3 here is the resize amount, adjust as needed&#xA;map alt+j kitten relative_resize.py down  3&#xA;map alt+k kitten relative_resize.py up    3&#xA;map alt+h kitten relative_resize.py left  3&#xA;map alt+l kitten relative_resize.py right 3&#xA;&#xA;map --when-focus-on var:IS_NVIM alt+j&#xA;map --when-focus-on var:IS_NVIM alt+k&#xA;map --when-focus-on var:IS_NVIM alt+h&#xA;map --when-focus-on var:IS_NVIM alt+l&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, you must allow Kitty to listen for remote commands on a socket. You can do this either by running Kitty with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# For linux only:&#xA;kitty -o allow_remote_control=yes --single-instance --listen-on unix:@mykitty&#xA;&#xA;# Other unix systems:&#xA;kitty -o allow_remote_control=yes --single-instance --listen-on unix:/tmp/mykitty&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, by adding the following to &lt;code&gt;~/.config/kitty/kitty.conf&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# For linux only:&#xA;allow_remote_control yes&#xA;listen_on unix:@mykitty&#xA;&#xA;# Other unix systems:&#xA;allow_remote_control yes&#xA;listen_on unix:/tmp/mykitty&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Credits&lt;/h5&gt; &#xA;&lt;p&gt;Thanks @knubie for inspiration for the Kitty implementation from &lt;a href=&#34;https://github.com/knubie/vim-kitty-navigator&#34;&gt;vim-kitty-navigator&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Thanks to @chancez for the relative resize &lt;a href=&#34;https://github.com/chancez/dotfiles/raw/badc69d3895a6a942285126b8c372a55d77533e1/kitty/.config/kitty/relative_resize.py&#34;&gt;Python kitten&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Multiplexer Lua API&lt;/h3&gt; &#xA;&lt;p&gt;You can directly access the multiplexer API for scripting purposes as well. To get a handle to the current multiplexer backend, you can do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local mux = require(&#39;smart-splits.mux&#39;).get()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This returns the currently enabled multiplexer backend, or &lt;code&gt;nil&lt;/code&gt; if none is currently in use. The API offers the following methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local mux = require(&#39;smart-splits.mux&#39;).get()&#xA;-- mux matches the following type annotations&#xA;---@class SmartSplitsMultiplexer&#xA;---@field current_pane_id fun():number|nil&#xA;---@field current_pane_at_edge fun(direction:&#39;left&#39;|&#39;right&#39;|&#39;up&#39;|&#39;down&#39;):boolean&#xA;---@field is_in_session fun():boolean&#xA;---@field current_pane_is_zoomed fun():boolean&#xA;---@field next_pane fun(direction:&#39;left&#39;|&#39;right&#39;|&#39;up&#39;|&#39;down&#39;):boolean&#xA;---@field resize_pane fun(direction:&#39;left&#39;|&#39;right&#39;|&#39;up&#39;|&#39;down&#39;, amount:number):boolean&#xA;---@field split_pane fun(direction:&#39;left&#39;|&#39;right&#39;|&#39;up&#39;|&#39;down&#39;,size:number|nil):boolean&#xA;---@field type &#39;tmux&#39;|&#39;wezterm&#39;|&#39;kitty&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>MathIsFun0/Cryptid</title>
    <updated>2025-02-02T01:43:19Z</updated>
    <id>tag:github.com,2025-02-02:/MathIsFun0/Cryptid</id>
    <link href="https://github.com/MathIsFun0/Cryptid" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An unbalanced Balatro mod&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cryptid&lt;/h1&gt; &#xA;&lt;p&gt;An unbalanced Balatro mod.&lt;/p&gt; &#xA;&lt;p&gt;Note: Cryptid requires &lt;a href=&#34;https://github.com/Steamodded/smods/archive/refs/tags/old-calc.zip&#34;&gt;Steamodded &lt;strong&gt;1.0.0-Alpha&lt;/strong&gt; (old calc)&lt;/a&gt; and &lt;a href=&#34;https://github.com/MathIsFun0/Talisman/releases/latest&#34;&gt;Talisman&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Cryptid currently adds: &lt;img src=&#34;https://github.com/user-attachments/assets/0a03d6b2-d57f-4f92-9f42-a9ff201c5f2f&#34; alt=&#34;image&#34;&gt; &lt;img src=&#34;https://github.com/user-attachments/assets/c3f26d4d-2fb4-4b07-8f43-0d7a730e986d&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://discord.gg/eUf9Ur6RyB&#34;&gt;Official Discord&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=aUr0gXE77rk&#34;&gt;Video Installation Guide&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h3&gt;Frequently asked questions&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Credit to @jenwalter666 for creating this FAQ (forwarded from Cryptid Discord)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;General&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;My game is crashing on startup/something doesn&#39;t appear to be loading!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Make sure everything is properly installed. For Talisman, the folder that contains Talisman should be named &lt;code&gt;Talisman&lt;/code&gt;. If you&#39;ve downloaded the source code from GitHub (by clicking on [Code] and then [Download ZIP]), the folder within the ZIP may be called &lt;code&gt;Talisman-main&lt;/code&gt;, which will cause a problem. Simply rename the folder(s) so that the &lt;code&gt;-main&lt;/code&gt; part of the name is removed, so that the folder is just called &lt;code&gt;Talisman&lt;/code&gt;. Whenever you are manually updating Talisman or Cryptid, or any other mod for that matter, it&#39;s a good approach to instead delete the contents of the folder, then install the contents of the folder from the ZIP into the existing folder to avoid having to constantly rename the folder over and over. For automatic updates, try using the &lt;a href=&#34;https://discord.com/channels/1264429948970733782/1268911536638787625&#34;&gt;automatic update script&lt;/a&gt;. It could also be that Steamodded is out of date, sometimes mods may use features of a new version that&#39;s absent in an older version, but don&#39;t change the version that they ask for. You can grab the latest Steamodded by &lt;a href=&#34;https://github.com/Steamopollys/Steamodded/archive/refs/heads/main.zip&#34;&gt;clicking here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;I can&#39;t see any new jokers/content!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If you&#39;ve installed everything correctly, but no new jokers, blinds, etc. are ingame, check the Mods list by clicking on [MODS] in the main menu, and look for Cryptid/Talisman. If they show up red, that means there&#39;s a problem. Hover over the mod icon (which should be an exclamation mark) to see what said problem is. It could be an outdated dependency in most cases.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;What&#39;s up with all the &#34;M&#34; jokers/references to Jolly Joker?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&#34;M&#34; is a reference to an incident in the official Balatro Discord where a user named mjiojio was spamming the letter &#34;m&#34; in various channels. When asked what their least favourite joker was, they answered with Jolly Joker, and that&#39;s how the &#34;M&#34; joke became a thing!&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;There&#39;s some content in the mod I don&#39;t like! Is there any way to remove them?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;You can disable some features of the mod by opening your Settings, going over to the Spectral Pack tab, clicking [Cryptid], then checking/unchecking what you want. You can also enable/disable certain music tracks. If you&#39;re a streamer, consider disabling the Jimball music for your safety!&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;I&#39;m hitting infinity very often, is there any way to raise the limit of the scoring system?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Talisman may be configured to be on &lt;strong&gt;BigNum&lt;/strong&gt; mode, which has a maximum limit of ee308. You can make the limit virtually disappear by changing it to &lt;strong&gt;OmegaNum&lt;/strong&gt;, which can handle e10##1000. You can configure it the same way; going into Settings, then the Spectral Pack tab, then Talisman. Be careful; if you have a saved run that was on a different number system, you won&#39;t be able to load it (unless if you switch back)!&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;I&#39;ve experienced a crash/bug!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Be sure to give us as much information about the bug/crash as possible. A way to reproduce the bug/crash is also especially useful information to help us fix it. Remember; just saying you&#39;re crashing doesn&#39;t tell us anything. We need to know the details!&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;How can I disable a specific boss blind/joker/etc.?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Let&#39;s use Blinds as an example.&lt;/p&gt; &#xA;&lt;p&gt;In your Balatro mods folder, navigate to &lt;code&gt;\Cryptid\Items&lt;/code&gt; and find &lt;code&gt;Blinds.lua&lt;/code&gt;. (Different types of items will be contained in different Lua files in this folder.)&lt;/p&gt; &#xA;&lt;p&gt;Towards the end of the file, there&#39;s an array named &lt;code&gt;items_togo&lt;/code&gt;, near line 1230. You can disable specific Blinds by deleting the relevant lines here. These settings will take effect on a restart. Most other files will have a similar items array near the bottom of the file that you can modify to remove specific things from Cryptid. This system will be changed to be in-game before Cryptid 0.6.0.&lt;/p&gt;</summary>
  </entry>
</feed>