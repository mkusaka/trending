<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-03-16T01:45:43Z</updated>
  <subtitle>Weekly Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>MagicDuck/grug-far.nvim</title>
    <updated>2025-03-16T01:45:43Z</updated>
    <id>tag:github.com,2025-03-16:/MagicDuck/grug-far.nvim</id>
    <link href="https://github.com/MagicDuck/grug-far.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Find And Replace plugin for neovim&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;grug-far.nvim&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;F&lt;/strong&gt;ind &lt;strong&gt;A&lt;/strong&gt;nd &lt;strong&gt;R&lt;/strong&gt;eplace plugin for neovim&lt;/p&gt; &#xA;&lt;img width=&#34;500&#34; alt=&#34;image&#34; src=&#34;https://github.com/MagicDuck/grug-far.nvim/assets/95201/770900e2-36c6-488c-9117-5fcb514454cb&#34;&gt; &#xA;&lt;p&gt;Grug find! Grug replace! Grug happy!&lt;/p&gt; &#xA;&lt;h2&gt;‚ú® Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Search using the &lt;strong&gt;full power&lt;/strong&gt; of &lt;code&gt;rg&lt;/code&gt; or &lt;code&gt;ast-grep&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Replace using almost the &lt;strong&gt;full power&lt;/strong&gt; of &lt;code&gt;rg&lt;/code&gt; or &lt;code&gt;ast-grep&lt;/code&gt;. For example, for &lt;code&gt;rg&lt;/code&gt;, some flags such as &lt;code&gt;--binary&lt;/code&gt; and &lt;code&gt;--json&lt;/code&gt;, etc. are &lt;a href=&#34;https://raw.githubusercontent.com/MagicDuck/grug-far.nvim/main/lua/grug-far/engine/ripgrep/blacklistedReplaceFlags.lua&#34;&gt;blacklisted&lt;/a&gt; in order to prevent unexpected output. The UI will warn you and prevent replace when using such flags.&lt;/li&gt; &#xA; &lt;li&gt;Automatic debounced search or manual search on leaving insert mode (and normal mode changes)&lt;/li&gt; &#xA; &lt;li&gt;Open search results in quickfix list&lt;/li&gt; &#xA; &lt;li&gt;Goto file/line/column of match when pressing &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; in normal mode on lines in the results output (keybind configurable).&lt;/li&gt; &#xA; &lt;li&gt;Inline edit result lines and sync them back to their originating file locations using a configurable keybinding.&lt;/li&gt; &#xA; &lt;li&gt;Manual/auto-save search history and reload&lt;/li&gt; &#xA; &lt;li&gt;Syntax highlighted search results&lt;/li&gt; &#xA; &lt;li&gt;Search results folding&lt;/li&gt; &#xA; &lt;li&gt;Multiline search &amp;amp; replace&lt;/li&gt; &#xA; &lt;li&gt;Search/Replace within buffer range denoted by visual selection&lt;/li&gt; &#xA; &lt;li&gt;&#34;Preview&#34; result source while &#34;scrolling&#34; through results&lt;/li&gt; &#xA; &lt;li&gt;Replace using lua interpreted replacement for each match&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Searching:&lt;/h4&gt; &#xA;&lt;img width=&#34;1263&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/7851bc37-bd88-473d-a09a-1510088e074c&#34;&gt; &#xA;&lt;h4&gt;Replacing:&lt;/h4&gt; &#xA;&lt;img width=&#34;1260&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/c8edd521-9321-4e83-a4ce-e3d98ac1b346&#34;&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;More screenshots:&lt;/summary&gt; &#xA; &lt;h4&gt;Rg teaching you its ways&lt;/h4&gt; &#xA; &lt;img width=&#34;1258&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/c59da414-2836-4e1c-93cd-9ac4568c819c&#34;&gt; &#xA; &lt;h4&gt;Help:&lt;/h4&gt; &#xA; &lt;img width=&#34;1252&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/5da63e72-f768-46e7-a807-b26c6f44c42c&#34;&gt; &#xA; &lt;h4&gt;Searching within buffer range&lt;/h4&gt; &#xA; &lt;img width=&#34;2500&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/497e8024-4823-4331-92ac-d78cdae332f0&#34;&gt; &#xA; &lt;h4&gt;History:&lt;/h4&gt; &#xA; &lt;img width=&#34;1252&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/ee96bea6-62bc-4c39-b924-e5d42e70196a&#34;&gt; &#xA; &lt;h4&gt;Ast-grep multiline search and replace:&lt;/h4&gt; &#xA; &lt;img width=&#34;1254&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/1f07c536-ef41-476f-9a15-7f0715c0579c&#34;&gt; &#xA; &lt;h4&gt;Ast-grep debug-query&lt;/h4&gt; &#xA; &lt;img width=&#34;1251&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/20fab223-56b6-42ff-825b-0df3c0e8d625&#34;&gt; &#xA; &lt;h4&gt;Ripgrep with lua interpreted replacement&lt;/h4&gt; &#xA; &lt;img width=&#34;1259&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/e2b9ca48-e0cc-49d1-b048-5042f40b774b&#34;&gt; &#xA; &lt;h4&gt;Ast-grep with vimscript interpreted replacement&lt;/h4&gt; &#xA; &lt;img width=&#34;1257&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/34eebeda-4e29-4fed-a751-eac3f879425c&#34;&gt; &#xA; &lt;h4&gt;Ast-grep rules&lt;/h4&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://github.com/user-attachments/assets/123c5c3e-85c1-45d3-89a1-167dc3376b62&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Video&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;linkarzu&lt;/em&gt; has kindly made a video which shows off some of the features in action (don&#39;t forget to thank him for his hard work by liking if you found it helpful):&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=AK1TSwJrB3k&#34;&gt;&lt;img src=&#34;https://img.youtube.com/vi/AK1TSwJrB3k/0.jpg&#34; alt=&#34;linkarzu youtube video&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;ü§î Philosophy&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;em&gt;strives for reduced mental overhead.&lt;/em&gt; All actions you can take and as much help as possible is in your face (some configurable). Grug often forget how to do capture groups or which flag does what.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;transparency.&lt;/em&gt; Does not try to hide away the underlying tool. For instance, error messages from &lt;code&gt;rg&lt;/code&gt; are shown as they are actually quite friendly when you mess up your regex. You can gradually learn &lt;code&gt;rg&lt;/code&gt; or &lt;code&gt;ast-grep&lt;/code&gt; flags or use existing knowledge from running it in the CLI. You can even input the &lt;code&gt;--help&lt;/code&gt; flag to see the full &lt;code&gt;rg&lt;/code&gt; help or the &lt;code&gt;--debug-query=ast&lt;/code&gt; flag to debug your &lt;code&gt;ast-grep&lt;/code&gt; query. Grug like!&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;reuse muscle memory.&lt;/em&gt; Does not try to block any type of buffer edits, such as deleting lines, etc. It&#39;s very easy to get such things wrong and when you do, Grug becomes unable to modify text in the middle of writing a large regex. Grug mad!! Only ensures graceful recovery in order to preserve basic UI integrity (possible due to the magic of extmarks). Recovery should be simple undo away.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;uniformity.&lt;/em&gt; only uses one tool for both search and applying replace to keep things consistent. For example, does not combine &lt;code&gt;rg&lt;/code&gt; with other tools like &lt;code&gt;sed&lt;/code&gt;, even though &lt;code&gt;rg&lt;/code&gt; does not support replacement directly. One should not have to worry about compatibility differences when writing regexes. Additionally it opens the door to use many fancy &lt;code&gt;rg&lt;/code&gt; flags such as different regex engine that would not be possible in a mixed environment. There is currently one small exception for this due to the fact that &lt;code&gt;ast-grep&lt;/code&gt; does not currently support something like a &lt;code&gt;--glob&lt;/code&gt; flag, so we have to filter files through &lt;code&gt;rg&lt;/code&gt;, but hopefully that can be rectified in the future.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;‚ö°Ô∏è Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Neovim &amp;gt;= &lt;strong&gt;0.10.0&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/BurntSushi/ripgrep&#34;&gt;BurntSushi/ripgrep&lt;/a&gt; &amp;gt;= 14 recommended&lt;/li&gt; &#xA; &lt;li&gt;a &lt;a href=&#34;https://www.nerdfonts.com/&#34;&gt;Nerd Font&lt;/a&gt; &lt;strong&gt;&lt;em&gt;(optional)&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ast-grep.github.io&#34;&gt;ast-grep&lt;/a&gt; &lt;strong&gt;&lt;em&gt;(optional)&lt;/em&gt;&lt;/strong&gt; if you would like to use the &lt;code&gt;ast-grep&lt;/code&gt; search engine. ersion &amp;gt;= &lt;code&gt;0.36&lt;/code&gt; recommended.&lt;/li&gt; &#xA; &lt;li&gt;either &lt;a href=&#34;https://github.com/nvim-tree/nvim-web-devicons&#34;&gt;nvim-web-devicons&lt;/a&gt; or &lt;a href=&#34;https://github.com/echasnovski/mini.icons&#34;&gt;mini.icons&lt;/a&gt; for file icons support &lt;strong&gt;&lt;em&gt;(optional)&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Run &lt;code&gt;:checkhealth grug-far&lt;/code&gt; if you see unexpected issues.&lt;/p&gt; &#xA;&lt;h2&gt;üì¶ Installation&lt;/h2&gt; &#xA;&lt;p&gt;Using &lt;a href=&#34;https://github.com/folke/lazy.nvim&#34;&gt;lazy.nvim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;  {&#xA;    &#39;MagicDuck/grug-far.nvim&#39;,&#xA;    config = function()&#xA;      -- optional setup call to override plugin options&#xA;      -- alternatively you can set options with vim.g.grug_far = { ... }&#xA;      require(&#39;grug-far&#39;).setup({&#xA;        -- options, see Configuration section below&#xA;        -- there are no required options atm&#xA;        -- engine = &#39;ripgrep&#39; is default, but &#39;astgrep&#39; or &#39;astgrep-rules&#39; can&#xA;        -- be specified&#xA;      });&#xA;    end&#xA;  },&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;‚öôÔ∏è Configuration&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;grug-far.nvim&lt;/strong&gt; comes with the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MagicDuck/grug-far.nvim/main/lua/grug-far/opts.lua&#34;&gt;default options&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MagicDuck/grug-far.nvim/main/lua/grug-far/highlights.lua&#34;&gt;highlights&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note on the key mappings&lt;/strong&gt;: By default, grug-far, will use &lt;code&gt;&amp;lt;localleader&amp;gt;&lt;/code&gt; for it&#39;s keymaps as that is the vim recommended way for plugins. See &lt;a href=&#34;https://learnvimscriptthehardway.stevelosh.com/chapters/11.html#local-leader&#34;&gt;https://learnvimscriptthehardway.stevelosh.com/chapters/11.html#local-leader&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;So to use that, make sure you have &lt;code&gt;&amp;lt;localleader&amp;gt;&lt;/code&gt; configured. For example, to use &lt;code&gt;,&lt;/code&gt; as the local leader:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;vim.g.maplocalleader = &#39;,&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;üöÄ Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Opening and editing&lt;/h3&gt; &#xA;&lt;p&gt;You can open a new &lt;em&gt;grug-far.nvim&lt;/em&gt; vertical split buffer with the &lt;code&gt;:GrugFar&lt;/code&gt; command. Note that command supports the typical &lt;code&gt;command-modifiers&lt;/code&gt; like &lt;code&gt;botright&lt;/code&gt;, &lt;code&gt;aboveleft&lt;/code&gt;, etc. and visual ranges. In visual mode, the command will pre-fill the search string with the current visual selection. Note that if you would like to search and replace &lt;em&gt;within&lt;/em&gt; the visual selection range, you should use &lt;code&gt;:GrugFarWithin&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;p&gt;Possibly best to map a keybind to it for easy triggering. Since it&#39;s &lt;em&gt;just a buffer&lt;/em&gt;, you can edit in it as you see fit. The UI will try to guide you along and recover gracefully if you do things like &lt;code&gt;ggVGd&lt;/code&gt; (delete all lines). Ultimately it leaves the power in your hands, and in any case recovery is just a few &lt;code&gt;u&lt;/code&gt; taps away.&lt;/p&gt; &#xA;&lt;p&gt;You can create multiple such buffers with potentially different searches, which will reflect in each buffer&#39;s title (configurable). The buffers should be visible in the buffers list if you need to toggle to them.&lt;/p&gt; &#xA;&lt;h3&gt;Searching and replacing&lt;/h3&gt; &#xA;&lt;p&gt;Search and replace is accomplished by simply typing text on appropriately marked lines. Search will happen in a debounced manner as you type. In the options, you can also specify a minimum number of characters that one has to enter before search is triggered. You can also specify a files filter to narrow down your search and more ripgrep flags to refine it further. Error messages from ripgrep when entering invalid flags and so on are displayed to guide you along.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; When replacing matches with the empty string, you will be prompted to confirm, as the change is not visible in the results area due to UI considering it just a search. If you would like to see the actual replacement in the results area, add &lt;code&gt;--replace=&lt;/code&gt; to the flags.&lt;/p&gt; &#xA;&lt;h3&gt;Replacing each match with the result of an interpreted script&lt;/h3&gt; &#xA;&lt;p&gt;Some situations require the power of arbitrary code executed for each search to determine the proper replacements. In those cases, you can use the &lt;code&gt;Swap Replacement Interpreter&lt;/code&gt; action to switch to a desired replacement interpreter, such as &lt;code&gt;lua&lt;/code&gt; or &lt;code&gt;vimscript&lt;/code&gt;. For example with the &lt;code&gt;lua&lt;/code&gt; interpreter, this will allow you to write multi-line lua code, essentially the body of a lua function, in the &lt;code&gt;Replace:&lt;/code&gt; input.&lt;/p&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;match&lt;/code&gt; to refer to each match and need to &lt;code&gt;return&lt;/code&gt; the value you want to be the replacement. In the case of the &lt;code&gt;astgrep&lt;/code&gt; engine, you will also have access to the meta variables by accessing them through the &lt;code&gt;vars&lt;/code&gt; table. e.g. &lt;code&gt;$A&lt;/code&gt; is referred to by &lt;code&gt;vars.A&lt;/code&gt;, &lt;code&gt;$$$ARGS&lt;/code&gt; is referred to by &lt;code&gt;vars.ARGS&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is a similar situation for the &lt;code&gt;vimscript&lt;/code&gt; interpreter.&lt;/p&gt; &#xA;&lt;h3&gt;Syncing results lines back to originating files&lt;/h3&gt; &#xA;&lt;p&gt;It is possible to sync the text of the lines in the results area back to their originating files. There are 3 types of actions that can accomplish this operation:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;Sync Line&lt;/code&gt; - syncs current line&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Sync All&lt;/code&gt; - syncs all lines&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Apply Next&lt;/code&gt;/&lt;code&gt;Apply Prev&lt;/code&gt; - syncs current line/diff and smartly deletes it from the result buffer&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;A sync will happen only if a line has changed in some way compared to the source file, so if there&#39;s either a replacement taking place or you have manually edited it.&lt;/p&gt; &#xA;&lt;p&gt;Deleting result lines will cause them to be excluded from being synced by &lt;code&gt;Sync All&lt;/code&gt; action. This can be a nice way to refine a replacement in some situations if you want to exclude a particular file or some particular matches.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; sync is only supported by &lt;code&gt;ripgrep&lt;/code&gt; engine. The following explanation is &lt;code&gt;ripgrep&lt;/code&gt; engine specific:&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t edit the results list, &lt;code&gt;Sync All&lt;/code&gt; and &lt;code&gt;Replace&lt;/code&gt; have equivalent outcomes, except for one case. When you do multi-line replace with &lt;code&gt;--multiline&lt;/code&gt; and &lt;code&gt;--multiline-dot-all&lt;/code&gt; flags, sync won&#39;t work so you have to use replace. Essentially the difference it that &lt;code&gt;Replace&lt;/code&gt; runs &lt;code&gt;rg --replace=... --passthrough&lt;/code&gt; on each file and does not depend at all on what&#39;s in the results area. &lt;code&gt;Sync All&lt;/code&gt; does a line by line sync based on what&#39;s in the results area.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; changing the &lt;code&gt;&amp;lt;line-number&amp;gt;:&amp;lt;column&amp;gt;:&lt;/code&gt; prefix of result lines will disable sync for that line&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; sync is disabled when doing multiline replacement (&lt;code&gt;--multiline&lt;/code&gt; flag)&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; if you would like sync to work when doing a replacement with empty string, please add &lt;code&gt;--replace=&lt;/code&gt; to the flags.&lt;/p&gt; &#xA;&lt;h3&gt;Going to / Opening / Previewing Result Location&lt;/h3&gt; &#xA;&lt;p&gt;When the cursor is placed on a result file path, you can go to that file by pressing &lt;code&gt;&amp;lt;enter&amp;gt;&lt;/code&gt; in normal mode (&lt;code&gt;Goto&lt;/code&gt; action default keybind). When it&#39;s placed over a result match line, you will be taken to the file/line/column of the match. By default, the file buffer is opened in the last window you were in before opening grug-far, which is typically the other vertical split.&lt;/p&gt; &#xA;&lt;p&gt;If you would like to do the same thing, but have the cursor stay in place, you can use the &lt;code&gt;Open&lt;/code&gt; action instead.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; for both &lt;code&gt;Goto&lt;/code&gt; and &lt;code&gt;Open&lt;/code&gt; actions, if a &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; is entered beforehand, the location corresponding to &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; result line is used instead of the current cursor line. You can set the option &lt;code&gt;resultLocation.showNumberLabel = true&lt;/code&gt; if you would like to have a visual indication of the &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In order to smoothly &lt;code&gt;Open&lt;/code&gt; each result location in sequence, you can use the &lt;code&gt;Open Next&lt;/code&gt; and &lt;code&gt;Open Prev&lt;/code&gt; actions.&lt;/p&gt; &#xA;&lt;p&gt;If you would like to keep the buffers layout, you can use the &lt;code&gt;Preview&lt;/code&gt; action instead, which will open location in a floating window.&lt;/p&gt; &#xA;&lt;h3&gt;Opening result lines in quickfix list&lt;/h3&gt; &#xA;&lt;p&gt;Result lines can be opened in the quickfix list. Deleting result lines will cause them not to be included.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; changing the &lt;code&gt;&amp;lt;line-number&amp;gt;:&amp;lt;column&amp;gt;:&lt;/code&gt; prefix of result lines will remove lines from consideration&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; quickfix list is disabled when doing multiline replacement (&lt;code&gt;--multiline&lt;/code&gt; flag)&lt;/p&gt; &#xA;&lt;h3&gt;History&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;grug-far&lt;/strong&gt; can keep track of your search history. This is done either by manually adding a history entry with &lt;code&gt;History Add&lt;/code&gt; action or automatically on certain successful actions like &lt;code&gt;Replace&lt;/code&gt; and &lt;code&gt;Sync All&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When you would like to pick one of your history entries to reuse, you can use the &lt;code&gt;History Open&lt;/code&gt; action to open the search history as a buffer. From there you can pick an entry that will be auto-filled in.&lt;/p&gt; &#xA;&lt;p&gt;Note that you can edit the history buffer and save just like any other buffer if you need to do some cleanup. The format of a history entry looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;optional comment, e.g. My special search&amp;gt;&#xA;Engine: &amp;lt;astgrep|astgrep-rules|ripgrep&amp;gt;(|lua)?&#xA;Search: &amp;lt;text&amp;gt;&#xA;Replace: &amp;lt;text&amp;gt;&#xA;Files Filter: &amp;lt;text&amp;gt;&#xA;Flags: &amp;lt;text&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; can span multiple line with the aid of a &#34;continuation prefix&#34; (&lt;code&gt;| &lt;/code&gt;). e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Replace: something&#xA;| additional replace text&#xA;| more replace text&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that some engines might use other inputs. For example, &lt;code&gt;astgrep-rules&lt;/code&gt; uses &lt;code&gt;Rules&lt;/code&gt; instead of &lt;code&gt;Search&lt;/code&gt; and does not have &lt;code&gt;Replace&lt;/code&gt;. History entries are separated by one or more empty lines.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: &lt;strong&gt;grug-far&lt;/strong&gt; will ignore lines that do not start with the prefixes above&lt;/p&gt; &#xA;&lt;h3&gt;Seeing the full search command&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes, mostly for debug purposes, it&#39;s useful to see the full CLI command that gets executed on search. You can toggle that on with the &lt;code&gt;Toggle Show rg Command&lt;/code&gt; action, and the command will appear as the first thing in the search results area.&lt;/p&gt; &#xA;&lt;p&gt;The command is shell-escaped, so you can copy and execute it in a shell manually if you need to.&lt;/p&gt; &#xA;&lt;h3&gt;Aborting&lt;/h3&gt; &#xA;&lt;p&gt;If you inadvertently launched a wrong search/sync/replace, you can abort early using the &lt;code&gt;Abort&lt;/code&gt; action.&lt;/p&gt; &#xA;&lt;h3&gt;Swapping search engine&lt;/h3&gt; &#xA;&lt;p&gt;You can swap search engines with the &lt;code&gt;Swap Engine&lt;/code&gt; action. Currently &lt;code&gt;ripgrep&lt;/code&gt; (default), &lt;code&gt;astgrep&lt;/code&gt;, and &lt;code&gt;astgrep-rules&lt;/code&gt; are supported.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ripgrep&lt;/code&gt; uses the &lt;code&gt;rg&lt;/code&gt; CLI command to search and replace. See &lt;a href=&#34;https://github.com/BurntSushi/ripgrep&#34;&gt;ripgrep docs&lt;/a&gt; for more information about CLI options and regex syntax.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;astgrep&lt;/code&gt; and &lt;code&gt;astgrep-rules&lt;/code&gt; are two different interfaces to the &lt;code&gt;sg&lt;/code&gt; CLI command. &lt;code&gt;astgrep&lt;/code&gt; is limited to single &lt;a href=&#34;https://ast-grep.github.io/guide/pattern-syntax.html&#34;&gt;patterns&lt;/a&gt;, with &lt;code&gt;astgrep run --pattern=&amp;lt;your_search_string&amp;gt;&lt;/code&gt;. &lt;code&gt;astgrep-rules&lt;/code&gt; takes YAML input to define &lt;a href=&#34;https://ast-grep.github.io/guide/rule-config.html&#34;&gt;rules&lt;/a&gt;, run with &lt;code&gt;sg scan --inline-rules=&amp;lt;your_rules_yaml&amp;gt;&lt;/code&gt;, which is more verbose but more powerful. See &lt;a href=&#34;https://ast-grep.github.io/guide/introduction.html&#34;&gt;ast-grep docs&lt;/a&gt; for more information. grug-far will attempt to pre-populate reasonable YAML boilerplate when selecting the &lt;code&gt;astgrep-rules&lt;/code&gt; engine. If you&#39;ve been working on a pattern with &lt;code&gt;astgrep&lt;/code&gt;, then swap engine to &lt;code&gt;astgrep-rules&lt;/code&gt;, grug-far will include your existing pattern in the rule so you can build on it from there.&lt;/p&gt; &#xA;&lt;h3&gt;Closing&lt;/h3&gt; &#xA;&lt;p&gt;When you are done, it is recommended to close the buffer with the configured keybinding (see Configuration section above) or just &lt;code&gt;:bd&lt;/code&gt; in order to save on resources as some search results can be quite beefy in size. The advantage of using the &lt;code&gt;Close&lt;/code&gt; action as opposed to just &lt;code&gt;:bd&lt;/code&gt; is that it will ask you to confirm if there is a replace/sync in progress, as those would be aborted.&lt;/p&gt; &#xA;&lt;h3&gt;Filetype&lt;/h3&gt; &#xA;&lt;p&gt;Note that &lt;em&gt;grug-far.nvim&lt;/em&gt; buffers will have &lt;code&gt;filetype=grug-far&lt;/code&gt;, history buffers will have &lt;code&gt;filetype=grug-far-history&lt;/code&gt; and help will have &lt;code&gt;filetype=grug-far-help&lt;/code&gt; if you need filter/exclude them in any situations. Excluding seems to be necessary with copilot at the time of writing this.&lt;/p&gt; &#xA;&lt;h3&gt;‚öíÔ∏è Lua API&lt;/h3&gt; &#xA;&lt;p&gt;For more control, you can programmatically open a grug-far buffer like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;require(&#39;grug-far&#39;).open(opts)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the above is called while in visual mode, it will pre-fill current visual selection as search text. (note, this will also set &lt;code&gt;--fixed-strings&lt;/code&gt; flag as selection can contain special characters)&lt;/p&gt; &#xA;&lt;p&gt;Note that if you want to pre-fill current visual selection from command mode, you would have to use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:lua require(&#39;grug-far&#39;).with_visual_selection(opts)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(command mode is the only case where this is necessary in order to force using the visual selection)&lt;/p&gt; &#xA;&lt;p&gt;where &lt;code&gt;opts&lt;/code&gt; will be merged with and override the global plugin options configured at setup time.&lt;/p&gt; &#xA;&lt;p&gt;See here for all the available &lt;a href=&#34;https://raw.githubusercontent.com/MagicDuck/grug-far.nvim/main/lua/grug-far/opts.lua&#34;&gt;options&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;For more API, see &lt;a href=&#34;https://raw.githubusercontent.com/MagicDuck/grug-far.nvim/main/doc/grug-far.txt&#34;&gt;docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;ü•™ Cookbook&lt;/h3&gt; &#xA;&lt;h4&gt;Launch with the current word under the cursor as the search string&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;:lua require(&#39;grug-far&#39;).open({ prefills = { search = vim.fn.expand(&#34;&amp;lt;cword&amp;gt;&#34;) } })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Launch with ast-grep engine&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;:lua require(&#39;grug-far&#39;).open({ engine = &#39;astgrep&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Launch as a transient buffer which is both unlisted and fully deletes itself when not in use&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;:lua require(&#39;grug-far&#39;).open({ transient = true })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Launch, limiting search/replace to current file&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;:lua require(&#39;grug-far&#39;).open({ prefills = { paths = vim.fn.expand(&#34;%&#34;) } })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Launch with the current visual selection, searching only current file&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;:&amp;lt;C-u&amp;gt;lua require(&#39;grug-far&#39;).with_visual_selection({ prefills = { paths = vim.fn.expand(&#34;%&#34;) } })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Launch, limiting search to the current buffer visual selection range&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;:GrugFarWithin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or as a keymap if you want to go fully lua:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.keymap.set({ &#39;n&#39;, &#39;x&#39; }, &#39;&amp;lt;leader&amp;gt;si&#39;, function()&#xA;  require(&#39;grug-far&#39;).open({ visualSelectionUsage = &#39;operate-within-range&#39; })&#xA;end, { desc = &#39;grug-far: Search within range&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Toggle visibility of a particular instance and set title to a fixed string&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;:lua require(&#39;grug-far&#39;).toggle_instance({ instanceName=&#34;far&#34;, staticTitle=&#34;Find and Replace&#34; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Create a buffer local keybinding to toggle --fixed-strings flag&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.api.nvim_create_autocmd(&#39;FileType&#39;, {&#xA;  group =  vim.api.nvim_create_augroup(&#39;my-grug-far-custom-keybinds&#39;, { clear = true }),&#xA;  pattern = { &#39;grug-far&#39; },&#xA;  callback = function()&#xA;    vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;localleader&amp;gt;w&#39;, function()&#xA;      local state = unpack(require(&#39;grug-far&#39;).toggle_flags({ &#39;--fixed-strings&#39; }))&#xA;      vim.notify(&#39;grug-far: toggled --fixed-strings &#39; .. (state and &#39;ON&#39; or &#39;OFF&#39;))&#xA;    end, { buffer = true })&#xA;  end,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Create a buffer local keybinding to open a result location and immediately close grug-far.nvim&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.api.nvim_create_autocmd(&#39;FileType&#39;, {&#xA;  group = vim.api.nvim_create_augroup(&#39;grug-far-keybindings&#39;, { clear = true }),&#xA;  pattern = { &#39;grug-far&#39; },&#xA;  callback = function()&#xA;    vim.api.nvim_buf_set_keymap(0, &#39;n&#39;, &#39;&amp;lt;C-enter&amp;gt;&#39;, &#39;&amp;lt;localleader&amp;gt;o&amp;lt;localleader&amp;gt;c&#39;, {})&#xA;  end,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(where &lt;code&gt;&amp;lt;localleader&amp;gt;o&lt;/code&gt; and &lt;code&gt;&amp;lt;localleader&amp;gt;c&lt;/code&gt; are the default keybindings for Open and Close actions. You will need to change them if you set them to something different)&lt;/p&gt; &#xA;&lt;h4&gt;Create a buffer local keybinding to jump back to Search input&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;vim.api.nvim_create_autocmd(&#39;FileType&#39;, {&#xA;  group = vim.api.nvim_create_augroup(&#39;grug-far-keymap&#39;, { clear = true }),&#xA;  pattern = { &#39;grug-far&#39; },&#xA;  callback = function()&#xA;    -- jump back to search input by hitting left arrow in normal mode:&#xA;    vim.keymap.set(&#39;n&#39;, &#39;&amp;lt;left&amp;gt;&#39;, function()&#xA;      vim.api.nvim_win_set_cursor(vim.fn.bufwinid(0), { 2, 0 })&#xA;    end, { buffer = true })&#xA;  end,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Add neo-tree integration to open search limited to focused directory or file&lt;/h4&gt; &#xA;&lt;p&gt;Create a hotkey &lt;code&gt;z&lt;/code&gt; in &lt;code&gt;neo-tree&lt;/code&gt; that will create/open a named instance of grug-far with the current directory of the file or directory in focus. On the second trigger, path of the grug-far instance will be updated, leaving other fields intact.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Neo tree lazy plugin setup&lt;/summary&gt; &#xA; &lt;p&gt;Small video of it in action: &lt;a href=&#34;https://github.com/MagicDuck/grug-far.nvim/issues/165#issuecomment-2257439367&#34;&gt;https://github.com/MagicDuck/grug-far.nvim/issues/165#issuecomment-2257439367&lt;/a&gt;&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;return {&#xA;  &#34;nvim-neo-tree/neo-tree.nvim&#34;,&#xA;  dependencies = &#34;nvim-tree/nvim-web-devicons&#34;,&#xA;  config = function()&#xA;    local function open_grug_far(prefills)&#xA;      local grug_far = require(&#34;grug-far&#34;)&#xA;&#xA;      if not grug_far.has_instance(&#34;explorer&#34;) then&#xA;        grug_far.open({ instanceName = &#34;explorer&#34; })&#xA;      else&#xA;        grug_far.open_instance(&#34;explorer&#34;)&#xA;      end&#xA;      -- doing it seperately because multiple paths doesn&#39;t open work when passed with open&#xA;      -- updating the prefills without clearing the search and other fields&#xA;      grug_far.update_instance_prefills(&#34;explorer&#34;, prefills, false)&#xA;    end&#xA;    require(&#34;neo-tree&#34;).setup {&#xA;      commands = {&#xA;        -- create a new neo-tree command&#xA;        grug_far_replace = function(state)&#xA;          local node = state.tree:get_node()&#xA;          local prefills = {&#xA;            -- also escape the paths if space is there&#xA;            -- if you want files to be selected, use &#39;:p&#39; only, see filename-modifiers&#xA;            paths = node.type == &#34;directory&#34; and vim.fn.fnameescape(vim.fn.fnamemodify(node:get_id(), &#34;:p&#34;))&#xA;        or vim.fn.fnameescape(vim.fn.fnamemodify(node:get_id(), &#34;:h&#34;)),&#xA;          }&#xA;          open_grug_far(prefills)&#xA;        end,&#xA;        -- https://github.com/nvim-neo-tree/neo-tree.nvim/blob/fbb631e818f48591d0c3a590817003d36d0de691/doc/neo-tree.txt#L535&#xA;        grug_far_replace_visual = function(state, selected_nodes, callback)&#xA;          local paths = {}&#xA;          for _, node in pairs(selected_nodes) do&#xA;            -- also escape the paths if space is there&#xA;            -- if you want files to be selected, use &#39;:p&#39; only, see filename-modifiers&#xA;            local path = node.type == &#34;directory&#34; and vim.fn.fnameescape(vim.fn.fnamemodify(node:get_id(), &#34;:p&#34;))&#xA;        or vim.fn.fnameescape(vim.fn.fnamemodify(node:get_id(), &#34;:h&#34;))&#xA;            table.insert(paths, path)&#xA;          end&#xA;          local prefills = { paths = table.concat(paths, &#34;\n&#34;) }&#xA;          open_grug_far(prefills)&#xA;        end,&#xA;      },&#xA;      window = {&#xA;        mappings = {&#xA;          -- map our new command to z&#xA;          z = &#34;grug_far_replace&#34;,&#xA;        },&#xA;      },&#xA;      -- rest of your config&#xA;    }&#xA;  end,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h4&gt;Add oil.nvim integration to open search limited to focused directory&lt;/h4&gt; &#xA;&lt;p&gt;Create a hotkey &lt;code&gt;gs&lt;/code&gt; in &lt;code&gt;oil.nvim&lt;/code&gt; that will create/open a named instance of grug-far with the current directory in focus. On the second trigger, path of the grug-far instance will be updated, leaving other fields intact.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Oil explorer lazy plugin setup&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;return {&#xA;  &#34;stevearc/oil.nvim&#34;,&#xA;  config = function()&#xA;    local oil = require &#34;oil&#34;&#xA;    oil.setup {&#xA;      keymaps = {&#xA;        -- create a new mapping, gs, to search and replace in the current directory&#xA;        gs = {&#xA;          callback = function()&#xA;            -- get the current directory&#xA;            local prefills = { paths = oil.get_current_dir() }&#xA;&#xA;            local grug_far = require &#34;grug-far&#34;&#xA;            -- instance check&#xA;            if not grug_far.has_instance &#34;explorer&#34; then&#xA;              grug_far.open {&#xA;                instanceName = &#34;explorer&#34;,&#xA;                prefills = prefills,&#xA;                staticTitle = &#34;Find and Replace from Explorer&#34;,&#xA;              }&#xA;            else&#xA;              grug_far.open_instance &#34;explorer&#34;&#xA;              -- updating the prefills without clearing the search and other fields&#xA;              grug_far.update_instance_prefills(&#34;explorer&#34;, prefills, false)&#xA;            end&#xA;          end,&#xA;          desc = &#34;oil: Search in directory&#34;,&#xA;        },&#xA;      },&#xA;      -- rest of your config&#xA;    }&#xA;  end,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h4&gt;Add mini.files integration to open search limited to focused directory&lt;/h4&gt; &#xA;&lt;p&gt;Create a hotkey &lt;code&gt;gs&lt;/code&gt; in &lt;code&gt;mini.files&lt;/code&gt; that will create/open a named instance of grug-far with the current directory in focus. On the second trigger, the path of the grug-far instance will be updated, leaving other fields intact.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;MiniFiles explorer lazy plugin setup&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;return {&#xA;  &#34;echasnovski/mini.files&#34;,&#xA;  config = function()&#xA;    local MiniFiles = require &#34;mini.files&#34;&#xA;&#xA;    MiniFiles.setup({&#xA;      -- your config&#xA;    })&#xA;&#xA;    &#xA;    local files_grug_far_replace = function(path)&#xA;      -- works only if cursor is on the valid file system entry&#xA;      local cur_entry_path = MiniFiles.get_fs_entry().path&#xA;      local prefills = { paths = vim.fs.dirname(cur_entry_path) }&#xA;&#xA;      local grug_far = require &#34;grug-far&#34;&#xA;&#xA;      -- instance check&#xA;      if not grug_far.has_instance &#34;explorer&#34; then&#xA;        grug_far.open {&#xA;          instanceName = &#34;explorer&#34;,&#xA;          prefills = prefills,&#xA;          staticTitle = &#34;Find and Replace from Explorer&#34;,&#xA;        }&#xA;      else&#xA;        grug_far.open_instance &#34;explorer&#34;&#xA;        -- updating the prefills without crealing the search and other fields&#xA;        grug_far.update_instance_prefills(&#34;explorer&#34;, prefills, false)&#xA;      end&#xA;    end&#xA;&#xA;    vim.api.nvim_create_autocmd(&#34;User&#34;, {&#xA;      pattern = &#34;MiniFilesBufferCreate&#34;,&#xA;      callback = function(args)&#xA;        vim.keymap.set(&#34;n&#34;, &#34;gs&#34;, files_grug_far_replace, { buffer = args.data.buf_id, desc = &#34;Search in directory&#34; })&#xA;      end,&#xA;    })&#xA;  end,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;‚ùì Q&amp;amp;A&lt;/h2&gt; &#xA;&lt;h4&gt;1. Getting RPC[Error] ... Document for URI could not be found: file:///.../Grug%20FAR%20-%20...&lt;/h4&gt; &#xA;&lt;p&gt;Chances are that you are using copilot.nvim and the fix is to exclude &lt;code&gt;grug-far&lt;/code&gt; file types in copilot config:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;filetypes = {&#xA;  [&#34;grug-far&#34;] = false,&#xA;  [&#34;grug-far-history&#34;] = false,&#xA;  [&#34;grug-far-help&#34;] = false,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;üì¶ Similar Plugins / Inspiration&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-pack/nvim-spectre&#34;&gt;nvim-spectre&lt;/a&gt;: the OG find and replace in a buffer plugin, great inspiration!&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvim-telescope/telescope.nvim&#34;&gt;telescope.nvim&lt;/a&gt;: lifted &lt;code&gt;rg&lt;/code&gt; healthcheck from there :P&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/folke/lazy.nvim&#34;&gt;lazy.nvim&lt;/a&gt;: used their beautiful &lt;code&gt;README.md&lt;/code&gt; as a template&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/m00qek/plugin-template.nvim/tree/main&#34;&gt;plugin-template.nvim&lt;/a&gt;: super handy template, this plugin is based on it!&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>