<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-21T02:00:01Z</updated>
  <subtitle>Weekly Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Robitx/gp.nvim</title>
    <updated>2024-01-21T02:00:01Z</updated>
    <id>tag:github.com,2024-01-21:/Robitx/gp.nvim</id>
    <link href="https://github.com/Robitx/gp.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Gp.nvim (GPT prompt) Neovim AI plugin: ChatGPT sessions &amp; Instructable text/code operations &amp; Speech to text [OpenAI]&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/Robitx/gp.nvim/raw/main/LICENSE&#34;&gt;&lt;img alt=&#34;GitHub&#34; src=&#34;https://img.shields.io/github/license/robitx/gp.nvim&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Robitx/gp.nvim/stargazers&#34;&gt;&lt;img alt=&#34;GitHub Repo stars&#34; src=&#34;https://img.shields.io/github/stars/Robitx/gp.nvim&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Robitx/gp.nvim/issues&#34;&gt;&lt;img alt=&#34;GitHub closed issues&#34; src=&#34;https://img.shields.io/github/issues-closed/Robitx/gp.nvim&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Robitx/gp.nvim/pulls&#34;&gt;&lt;img alt=&#34;GitHub closed pull requests&#34; src=&#34;https://img.shields.io/github/issues-pr-closed/Robitx/gp.nvim&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Robitx/gp.nvim/graphs/contributors&#34;&gt;&lt;img alt=&#34;GitHub contributors&#34; src=&#34;https://img.shields.io/github/contributors-anon/Robitx/gp.nvim&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/search?q=%2F%5E%5B%5Cs%5D*require%5C%28%5B%27%22%5Dgp%5B%27%22%5D%5C%29%5C.setup%2F+language%3ALua&amp;amp;type=code&amp;amp;p=1&#34;&gt;&lt;img alt=&#34;Static Badge&#34; src=&#34;https://img.shields.io/badge/Use%20in%20the%20Wild-8A2BE2&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Gp.nvim (GPT prompt) Neovim AI plugin&lt;/h1&gt; &#xA;&lt;!-- panvimdoc-ignore-end --&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;ChatGPT like sessions, Instructable text/code operations, Speech to text and Image generation in your favorite editor.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;left&#34;&gt; &lt;img src=&#34;https://github.com/Robitx/gp.nvim/assets/8431097/cb288094-2308-42d6-9060-4eb21b3ba74c&#34; width=&#34;49%&#34;&gt; &lt;img src=&#34;https://github.com/Robitx/gp.nvim/assets/8431097/c538f0a2-4667-444e-8671-13f8ea261be1&#34; width=&#34;49%&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;Youtube demos&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=X-cT7s47PLo&#34;&gt;5-min-demo&lt;/a&gt; (December 2023)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=wPDcBnQgNCc&#34;&gt;older-5-min-demo&lt;/a&gt; (screen capture, no sound)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Goals and Features&lt;/h1&gt; &#xA;&lt;p&gt;The goal is to extend Neovim with the &lt;strong&gt;power of GPT models in a simple unobtrusive extensible way.&lt;/strong&gt;&lt;br&gt; Trying to keep things as native as possible - reusing and integrating well with the natural features of (Neo)vim.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Streaming responses&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;no spinner wheel and waiting for the full answer&lt;/li&gt; &#xA;   &lt;li&gt;response generation can be canceled half way through&lt;/li&gt; &#xA;   &lt;li&gt;properly working undo (response can be undone with a single &lt;code&gt;u&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Infinitely extensible&lt;/strong&gt; via hook functions specified as part of the config &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;hooks have access to everything in the plugin and are automatically registered as commands&lt;/li&gt; &#xA;   &lt;li&gt;see &lt;a href=&#34;https://raw.githubusercontent.com/Robitx/gp.nvim/main/#4-configuration&#34;&gt;4. Configuration&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/Robitx/gp.nvim/main/#extend-functionality&#34;&gt;Extend functionality&lt;/a&gt; sections for details&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Minimum dependencies&lt;/strong&gt; (&lt;code&gt;neovim&lt;/code&gt;, &lt;code&gt;curl&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt; and optionally &lt;code&gt;sox&lt;/code&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;zero dependencies on other lua plugins to minimize chance of breakage&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ChatGPT like sessions&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;just good old neovim buffers formated as markdown with autosave and few buffer bound shortcuts&lt;/li&gt; &#xA;   &lt;li&gt;last chat also quickly accessible via toggable popup window&lt;/li&gt; &#xA;   &lt;li&gt;chat finder - management popup for searching, previewing, deleting and opening chat sessions&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Instructable text/code operations&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;templating mechanism to combine user instructions, selections etc into the gpt query&lt;/li&gt; &#xA;   &lt;li&gt;multimodal - same command works for normal/insert mode, with selection or a range&lt;/li&gt; &#xA;   &lt;li&gt;many possible output targets - rewrite, prepend, append, new buffer, popup&lt;/li&gt; &#xA;   &lt;li&gt;non interactive command mode available for common repetitive tasks implementable as simple hooks&lt;br&gt; (explain something in a popup window, write unit tests for selected code into a new buffer,&lt;br&gt; finish selected code based on comments in it, etc.)&lt;/li&gt; &#xA;   &lt;li&gt;custom instructions per repository with &lt;code&gt;.gp.md&lt;/code&gt; file&lt;br&gt; (instruct gpt to generate code using certain libs, packages, conventions and so on)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Speech to text support&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;a mouth is 2-4x faster than fingers when it comes to outputting words - use it where it makes sense&lt;br&gt; (dicating comments and notes, asking gpt questions, giving instructions for code operations, ..)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Image generation&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;be even less tempted to open the browser with the ability to generate images directly from Neovim&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Install&lt;/h1&gt; &#xA;&lt;h2&gt;1. Install the plugin&lt;/h2&gt; &#xA;&lt;p&gt;Snippets for your preferred package manager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- lazy.nvim&#xA;{&#xA;&#x9;&#34;robitx/gp.nvim&#34;,&#xA;&#x9;config = function()&#xA;&#x9;&#x9;require(&#34;gp&#34;).setup()&#xA;&#xA;&#x9;&#x9;-- or setup with your own config (see Install &amp;gt; Configuration in Readme)&#xA;&#x9;&#x9;-- require(&#34;gp&#34;).setup(config)&#xA;&#xA;        &#x9;-- shortcuts might be setup here (see Usage &amp;gt; Shortcuts in Readme)&#xA;&#x9;end,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- packer.nvim&#xA;use({&#xA;    &#34;robitx/gp.nvim&#34;,&#xA;    config = function()&#xA;        require(&#34;gp&#34;).setup()&#xA;&#xA;&#x9;-- or setup with your own config (see Install &amp;gt; Configuration in Readme)&#xA;&#x9;-- require(&#34;gp&#34;).setup(config)&#xA;&#xA;        -- shortcuts might be setup here (see Usage &amp;gt; Shortcuts in Readme)&#xA;    end,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;2. OpenAI API key&lt;/h2&gt; &#xA;&lt;p&gt;Make sure you have OpenAI API key. &lt;a href=&#34;https://platform.openai.com/account/api-keys&#34;&gt;Get one here&lt;/a&gt; and use it in the &lt;a href=&#34;https://raw.githubusercontent.com/Robitx/gp.nvim/main/#4-configuration&#34;&gt;4. Configuration&lt;/a&gt;. Also consider setting up &lt;a href=&#34;https://platform.openai.com/account/billing/limits&#34;&gt;usage limits&lt;/a&gt; so you won&#39;t get suprised at the end of the month.&lt;/p&gt; &#xA;&lt;p&gt;The OpenAI API key can be passed to the plugin in multiple ways:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Method&lt;/th&gt; &#xA;   &lt;th&gt;Example&lt;/th&gt; &#xA;   &lt;th&gt;Security Level&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;hardcoded string&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;openai_api_key: &#34;sk-...&#34;,&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Low&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;default env var&lt;/td&gt; &#xA;   &lt;td&gt;set &lt;code&gt;OPENAI_API_KEY&lt;/code&gt; environment variable in shell config&lt;/td&gt; &#xA;   &lt;td&gt;Medium&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;custom env var&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;openai_api_key = os.getenv(&#34;CUSTOM_ENV_NAME&#34;),&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Medium&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;read from file&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;openai_api_key = { &#34;cat&#34;, &#34;path_to_api_key&#34; },&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Medium-High&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;password manager&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;openai_api_key = { &#34;bw&#34;, &#34;get&#34;, &#34;password&#34;, &#34;OAI_API_KEY&#34; },&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;High&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;If &lt;code&gt;openai_api_key&lt;/code&gt; is a table, Gp runs it asynchronously to avoid blocking Neovim (password managers can take a second or two).&lt;/p&gt; &#xA;&lt;h2&gt;3. Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;The core plugin only needs &lt;code&gt;curl&lt;/code&gt; installed to make calls to OpenAI API and &lt;code&gt;grep&lt;/code&gt; for ChatFinder. So Linux, BSD and Mac OS should be covered.&lt;/p&gt; &#xA;&lt;p&gt;Voice commands (&lt;code&gt;:GpWhisper*&lt;/code&gt;) depend on &lt;code&gt;SoX&lt;/code&gt; (Sound eXchange) to handle audio recording and processing:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mac OS: &lt;code&gt;brew install sox&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Ubuntu/Debian: &lt;code&gt;apt-get install sox libsox-fmt-mp3&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Arch Linux: &lt;code&gt;pacman -S sox&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Redhat/CentOS: &lt;code&gt;yum install sox&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;NixOS: &lt;code&gt;nix-env -i sox&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;4. Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Bellow is a linked snippet with the default values, but I suggest starting with minimal config possible (just &lt;code&gt;openai_api_key&lt;/code&gt; if you don&#39;t have &lt;code&gt;OPENAI_API_KEY&lt;/code&gt; env set up). Defaults change over time to improve things, options might get deprecated and so on - it&#39;s better to change only things where the default doesn&#39;t fit your needs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Robitx/gp.nvim/raw/d90816b2e9185202d72f7b1346b6d33b36350886/lua/gp/config.lua#L8-L355&#34;&gt;https://github.com/Robitx/gp.nvim/blob/d90816b2e9185202d72f7b1346b6d33b36350886/lua/gp/config.lua#L8-L355&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;Chat commands&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpChatNew&lt;/code&gt; &#xA; &lt;!-- {doc=:GpChatNew}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Open a fresh chat in the current window. It can be either empty or include the visual selection or specified range as context. This command also supports subcommands for layout specification:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:GpChatNew vsplit&lt;/code&gt; Open a fresh chat in a vertical split window.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:GpChatNew split&lt;/code&gt; Open a fresh chat in a horizontal split window.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:GpChatNew tabnew&lt;/code&gt; Open a fresh chat in a new tab.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:GpChatNew popup&lt;/code&gt; Open a fresh chat in a popup window.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpChatPaste&lt;/code&gt; &#xA; &lt;!-- {doc=:GpChatPaste}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Paste the selection or specified range into the latest chat, simplifying the addition of code from multiple files into a single chat buffer. This command also supports subcommands for layout specification:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:GpChatPaste vsplit&lt;/code&gt; Paste into the latest chat in a vertical split window.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:GpChatPaste split&lt;/code&gt; Paste into the latest chat in a horizontal split window.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:GpChatPaste tabnew&lt;/code&gt; Paste into the latest chat in a new tab.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:GpChatPaste popup&lt;/code&gt; Paste into the latest chat in a popup window.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpChatToggle&lt;/code&gt; &#xA; &lt;!-- {doc=:GpChatToggle}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Open chat in a toggleable popup window, showing the last active chat or a fresh one with selection or a range as a context. This command also supports subcommands for layout specification:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:GpChatToggle vsplit&lt;/code&gt; Toggle chat in a vertical split window.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:GpChatToggle split&lt;/code&gt; Toggle chat in a horizontal split window.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:GpChatToggle tabnew&lt;/code&gt; Toggle chat in a new tab.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:GpChatToggle popup&lt;/code&gt; Toggle chat in a popup window.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpChatFinder&lt;/code&gt; &#xA; &lt;!-- {doc=:GpChatFinder}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Open a dialog to search through chats.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpChatRespond&lt;/code&gt; &#xA; &lt;!-- {doc=:GpChatRespond}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Request a new GPT response for the current chat. Usin&lt;code&gt;:GpChatRespond N&lt;/code&gt; request a new GPT response with only the last N messages as context, using everything from the end up to the Nth instance of &lt;code&gt;ðŸ—¨:..&lt;/code&gt; (N=1 is like asking a question in a new chat).&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpChatDelete&lt;/code&gt; &#xA; &lt;!-- {doc=:GpChatDelete}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Delete the current chat. By default requires confirmation before delete, which can be disabled in config using &lt;code&gt;chat_confirm_delete = false,&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Text/Code commands&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpRewrite&lt;/code&gt;&#xA; &lt;!-- {doc=:GpRewrite}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Opens a dialog for entering a prompt. After providing prompt instructions into the dialog, the generated response replaces the current line in normal/insert mode, selected lines in visual mode, or the specified range (e.g., &lt;code&gt;:%GpRewrite&lt;/code&gt; applies the rewrite to the entire buffer).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;:GpRewrite {prompt}&lt;/code&gt; Executes directly with specified &lt;code&gt;{prompt}&lt;/code&gt; instructions, bypassing the dialog. Suitable for mapping repetitive tasks to keyboard shortcuts or for automation using headless Neovim via terminal or shell scripts.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpAppend&lt;/code&gt; &#xA; &lt;!-- {doc=:GpAppend}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpRewrite&lt;/code&gt;, but the answer is added after the current line, visual selection, or range.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpPrepend&lt;/code&gt; &#xA; &lt;!-- {doc=:GpPrepend}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpRewrite&lt;/code&gt;, but the answer is added before the current line, visual selection, or range.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpEnew&lt;/code&gt; &#xA; &lt;!-- {doc=:GpEnew}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpRewrite&lt;/code&gt;, but the answer is added into a new buffer in the current window.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpNew&lt;/code&gt; &#xA; &lt;!-- {doc=:GpNew}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpRewrite&lt;/code&gt;, but the answer is added into a new horizontal split window.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpVnew&lt;/code&gt; &#xA; &lt;!-- {doc=:GpVnew}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpRewrite&lt;/code&gt;, but the answer is added into a new vertical split window.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpTabnew&lt;/code&gt; &#xA; &lt;!-- {doc=:GpTabnew}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpRewrite&lt;/code&gt;, but the answer is added into a new tab.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpPopup&lt;/code&gt; &#xA; &lt;!-- {doc=:GpPopup}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpRewrite&lt;/code&gt;, but the answer is added into a pop-up window.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpImplement&lt;/code&gt; &#xA; &lt;!-- {doc=:GpImplement}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Example hook command to develop code from comments in a visual selection or specified range.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpContext&lt;/code&gt;&#xA; &lt;!-- {doc=:GpContext}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Provides custom context per repository:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;opens &lt;code&gt;.gp.md&lt;/code&gt; file for a given repository in a toggable window.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;appends selection/range to the context file when used in visual/range mode.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;also supports subcommands for layout specification:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpContext vsplit&lt;/code&gt; Open &lt;code&gt;.gp.md&lt;/code&gt; in a vertical split window.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpContext split&lt;/code&gt; Open &lt;code&gt;.gp.md&lt;/code&gt; in a horizontal split window.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpContext tabnew&lt;/code&gt; Open &lt;code&gt;.gp.md&lt;/code&gt; in a new tab.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:GpContext popup&lt;/code&gt; Open &lt;code&gt;.gp.md&lt;/code&gt; in a popup window.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;refer to &lt;a href=&#34;https://raw.githubusercontent.com/Robitx/gp.nvim/main/#custom-instructions&#34;&gt;Custom Instructions&lt;/a&gt; for more details.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Speech commands&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpWhisper&lt;/code&gt; &#xA; &lt;!-- {doc=:GpWhisper}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Transcription replaces the current line, visual selection or range in the current buffer. Use your mouth to ask a question in a chat buffer instead of writing it by hand, dictate some comments for the code, notes or even your next novel..&lt;/p&gt; &#xA;&lt;p&gt;For the rest of the whisper commands, the transcription is used as an editable prompt for the equivalent non whisper command - &lt;code&gt;GpWhisperRewrite&lt;/code&gt; dictates instructions for &lt;code&gt;GpRewrite&lt;/code&gt; etc.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpWhisperRewrite&lt;/code&gt; &#xA; &lt;!-- {doc=:GpWhisperRewrite}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpRewrite&lt;/code&gt;, but the prompt instruction dialog uses transcribed spoken instructions.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpWhisperAppend&lt;/code&gt; &#xA; &lt;!-- {doc=:GpWhisperAppend}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpAppend&lt;/code&gt;, but the prompt instruction dialog uses transcribed spoken instructions for adding content after the current line, visual selection, or range.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpWhisperPrepend&lt;/code&gt; &#xA; &lt;!-- {doc=:GpWhisperPrepend}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpPrepend&lt;/code&gt;, but the prompt instruction dialog uses transcribed spoken instructions for adding content before the current line, selection, or range.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpWhisperEnew&lt;/code&gt; &#xA; &lt;!-- {doc=:GpWhisperEnew}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpEnew&lt;/code&gt;, but the prompt instruction dialog uses transcribed spoken instructions for opening content in a new buffer within the current window.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpWhisperNew&lt;/code&gt; &#xA; &lt;!-- {doc=:GpWhisperNew}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpNew&lt;/code&gt;, but the prompt instruction dialog uses transcribed spoken instructions for opening content in a new horizontal split window.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpWhisperVnew&lt;/code&gt; &#xA; &lt;!-- {doc=:GpWhisperVnew}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpVnew&lt;/code&gt;, but the prompt instruction dialog uses transcribed spoken instructions for opening content in a new vertical split window.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpWhisperTabnew&lt;/code&gt; &#xA; &lt;!-- {doc=:GpWhisperTabnew}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpTabnew&lt;/code&gt;, but the prompt instruction dialog uses transcribed spoken instructions for opening content in a new tab.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpWhisperPopup&lt;/code&gt; &#xA; &lt;!-- {doc=:GpWhisperPopup}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:GpPopup&lt;/code&gt;, but the prompt instruction dialog uses transcribed spoken instructions for displaying content in a pop-up window.&lt;/p&gt; &#xA;&lt;h2&gt;Agent commands&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpNextAgent&lt;/code&gt; &#xA; &lt;!-- {doc=:GpNextAgent}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Cycles between available agents based on the current buffer (chat agents if current buffer is a chat and command agents otherwise). The agent setting is persisted on disk across Neovim instances.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpAgent&lt;/code&gt; &#xA; &lt;!-- {doc=:GpAgent}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Displays currently used agents for chat and command instructions.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpAgent XY&lt;/code&gt; &#xA; &lt;!-- {doc=:GpAgent-XY}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Choose a new agent based on its name, listing options based on the current buffer (chat agents if current buffer is a chat and command agents otherwise). The agent setting is persisted on disk across Neovim instances.&lt;/p&gt; &#xA;&lt;h2&gt;Image commands&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpImage&lt;/code&gt; &#xA; &lt;!-- {doc=:GpImage}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Opens a dialog for entering a prompt describing wanted images. When the generation is done it opens dialog for storing the image to the disk.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpImageAgent&lt;/code&gt; &#xA; &lt;!-- {doc=:GpImageAgent}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Displays currently used image agent (configuration).&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpImageAgent XY&lt;/code&gt; &#xA; &lt;!-- {doc=:GpImageAgent-XY}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Choose a new &#34;image agent&#34; based on its name. In the context of images, agent is basically a configuration for model, image size, quality and so on. The agent setting is persisted on disk across Neovim instances.&lt;/p&gt; &#xA;&lt;h2&gt;Other commands&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpStop&lt;/code&gt; &#xA; &lt;!-- {doc=:GpStop}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Stops all currently running responses and jobs.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:GpInspectPlugin&lt;/code&gt; &#xA; &lt;!-- {doc=:GpInspectPlugin}  --&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Inspects the GPT prompt plugin object in a new scratch buffer.&lt;/p&gt; &#xA;&lt;h2&gt;GpDone autocommand&lt;/h2&gt; &#xA;&lt;p&gt;Commands like &lt;code&gt;GpRewrite&lt;/code&gt;, &lt;code&gt;GpAppend&lt;/code&gt; etc. run asynchronously and generate event &lt;code&gt;GpDone&lt;/code&gt;, so you can define autocmd (like auto formating) to run when gp finishes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;    vim.api.nvim_create_autocmd({ &#34;User&#34; }, {&#xA;        pattern = {&#34;GpDone&#34;},&#xA;        callback = function(event)&#xA;            print(&#34;event fired:\n&#34;, vim.inspect(event))&#xA;            -- local b = event.buf&#xA;            -- DO something&#xA;        end,&#xA;    })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom instructions&lt;/h2&gt; &#xA;&lt;p&gt;By calling &lt;code&gt;:GpContext&lt;/code&gt; you can make &lt;code&gt;.gp.md&lt;/code&gt; markdown file in a root of a repository. Commands such as &lt;code&gt;:GpRewrite&lt;/code&gt;, &lt;code&gt;:GpAppend&lt;/code&gt; etc. will respect instructions provided in this file (works better with gpt4, gpt 3.5 doesn&#39;t always listen to system commands). For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-md&#34;&gt;Use â€ŽC++17.&#xA;Use Testify library when writing Go tests.&#xA;Use Early return/Guard Clauses pattern to avoid excessive nesting.&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is &lt;a href=&#34;https://github.com/Robitx/gp.nvim/raw/main/.gp.md&#34;&gt;another example&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Scripting&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;GpDone&lt;/code&gt; event + &lt;code&gt;.gp.md&lt;/code&gt; custom instructions provide a possibility to run gp.nvim using headless (neo)vim from terminal or shell script. So you can let gp run edits accross many files if you put it in a loop.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;test&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1&#xA;2&#xA;3&#xA;4&#xA;5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;.gp.md&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;If user says hello, please respond with:&#xA;&#xA;```&#xA;Ahoy there!&#xA;```&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;calling gp.nvim from terminal/script:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;register autocommand to save and quit nvim when Gp is done&lt;/li&gt; &#xA; &lt;li&gt;second jumps to occurrence of something I want to rewrite/append/prepend to (in this case number &lt;code&gt;3&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;selecting the line&lt;/li&gt; &#xA; &lt;li&gt;calling gp.nvim acction&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ nvim --headless -c &#34;autocmd User GpDone wq&#34; -c &#34;/3&#34; -c &#34;normal V&#34; -c &#34;GpAppend hello there&#34;  test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;resulting &lt;code&gt;test&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1&#xA;2&#xA;3&#xA;Ahoy there!&#xA;4&#xA;5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Shortcuts&lt;/h1&gt; &#xA;&lt;p&gt;There are no default global shortcuts to mess with your own config. Bellow are examples for you to adjust or just use directly.&lt;/p&gt; &#xA;&lt;h2&gt;Native&lt;/h2&gt; &#xA;&lt;p&gt;You can use the good old &lt;code&gt;vim.keymap.set&lt;/code&gt; and paste the following after &lt;code&gt;require(&#34;gp&#34;).setup(conf)&lt;/code&gt; call (or anywhere you keep shortcuts if you want them at one place).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local function keymapOptions(desc)&#xA;    return {&#xA;        noremap = true,&#xA;        silent = true,&#xA;        nowait = true,&#xA;        desc = &#34;GPT prompt &#34; .. desc,&#xA;    }&#xA;end&#xA;&#xA;-- Chat commands&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;c&#34;, &#34;&amp;lt;cmd&amp;gt;GpChatNew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;New Chat&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;t&#34;, &#34;&amp;lt;cmd&amp;gt;GpChatToggle&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Toggle Chat&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;f&#34;, &#34;&amp;lt;cmd&amp;gt;GpChatFinder&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Chat Finder&#34;))&#xA;&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;c&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatNew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Chat New&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;p&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatPaste&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Chat Paste&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;t&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatToggle&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Toggle Chat&#34;))&#xA;&#xA;vim.keymap.set({ &#34;n&#34;, &#34;i&#34; }, &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-x&amp;gt;&#34;, &#34;&amp;lt;cmd&amp;gt;GpChatNew split&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;New Chat split&#34;))&#xA;vim.keymap.set({ &#34;n&#34;, &#34;i&#34; }, &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-v&amp;gt;&#34;, &#34;&amp;lt;cmd&amp;gt;GpChatNew vsplit&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;New Chat vsplit&#34;))&#xA;vim.keymap.set({ &#34;n&#34;, &#34;i&#34; }, &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-t&amp;gt;&#34;, &#34;&amp;lt;cmd&amp;gt;GpChatNew tabnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;New Chat tabnew&#34;))&#xA;&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-x&amp;gt;&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatNew split&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Chat New split&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-v&amp;gt;&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatNew vsplit&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Chat New vsplit&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;&amp;lt;C-t&amp;gt;&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatNew tabnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Chat New tabnew&#34;))&#xA;&#xA;-- Prompt commands&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;r&#34;, &#34;&amp;lt;cmd&amp;gt;GpRewrite&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Inline Rewrite&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;a&#34;, &#34;&amp;lt;cmd&amp;gt;GpAppend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Append (after)&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;b&#34;, &#34;&amp;lt;cmd&amp;gt;GpPrepend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Prepend (before)&#34;))&#xA;&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;r&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpRewrite&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Rewrite&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;a&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpAppend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Append (after)&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;b&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpPrepend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Prepend (before)&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;i&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpImplement&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Implement selection&#34;))&#xA;&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;gp&#34;, &#34;&amp;lt;cmd&amp;gt;GpPopup&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Popup&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;ge&#34;, &#34;&amp;lt;cmd&amp;gt;GpEnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;GpEnew&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;gn&#34;, &#34;&amp;lt;cmd&amp;gt;GpNew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;GpNew&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;gv&#34;, &#34;&amp;lt;cmd&amp;gt;GpVnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;GpVnew&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;gt&#34;, &#34;&amp;lt;cmd&amp;gt;GpTabnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;GpTabnew&#34;))&#xA;&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;gp&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpPopup&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Popup&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;ge&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpEnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual GpEnew&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;gn&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpNew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual GpNew&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;gv&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpVnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual GpVnew&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;gt&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpTabnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual GpTabnew&#34;))&#xA;&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;x&#34;, &#34;&amp;lt;cmd&amp;gt;GpContext&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Toggle Context&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;x&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpContext&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Toggle Context&#34;))&#xA;&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;, &#34;v&#34;, &#34;x&#34;}, &#34;&amp;lt;C-g&amp;gt;s&#34;, &#34;&amp;lt;cmd&amp;gt;GpStop&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Stop&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;, &#34;v&#34;, &#34;x&#34;}, &#34;&amp;lt;C-g&amp;gt;n&#34;, &#34;&amp;lt;cmd&amp;gt;GpNextAgent&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Next Agent&#34;))&#xA;&#xA;-- optional Whisper commands with prefix &amp;lt;C-g&amp;gt;w&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;ww&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisper&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Whisper&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;ww&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisper&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Whisper&#34;))&#xA;&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;wr&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisperRewrite&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Whisper Inline Rewrite&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;wa&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisperAppend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Whisper Append (after)&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;wb&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisperPrepend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Whisper Prepend (before) &#34;))&#xA;&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;wr&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperRewrite&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Whisper Rewrite&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;wa&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperAppend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Whisper Append (after)&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;wb&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperPrepend&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Whisper Prepend (before)&#34;))&#xA;&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;wp&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisperPopup&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Whisper Popup&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;we&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisperEnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Whisper Enew&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;wn&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisperNew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Whisper New&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;wv&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisperVnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Whisper Vnew&#34;))&#xA;vim.keymap.set({&#34;n&#34;, &#34;i&#34;}, &#34;&amp;lt;C-g&amp;gt;wt&#34;, &#34;&amp;lt;cmd&amp;gt;GpWhisperTabnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Whisper Tabnew&#34;))&#xA;&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;wp&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperPopup&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Whisper Popup&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;we&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperEnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Whisper Enew&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;wn&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperNew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Whisper New&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;wv&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperVnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Whisper Vnew&#34;))&#xA;vim.keymap.set(&#34;v&#34;, &#34;&amp;lt;C-g&amp;gt;wt&#34;, &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperTabnew&amp;lt;cr&amp;gt;&#34;, keymapOptions(&#34;Visual Whisper Tabnew&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Whichkey&lt;/h2&gt; &#xA;&lt;p&gt;Or go more fancy by using &lt;a href=&#34;https://github.com/folke/which-key.nvim&#34;&gt;which-key.nvim&lt;/a&gt; plugin:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- VISUAL mode mappings&#xA;-- s, x, v modes are handled the same way by which_key&#xA;require(&#34;which-key&#34;).register({&#xA;    -- ...&#xA;    [&#34;&amp;lt;C-g&amp;gt;&#34;] = {&#xA;        c = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatNew&amp;lt;cr&amp;gt;&#34;, &#34;Visual Chat New&#34; },&#xA;        p = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatPaste&amp;lt;cr&amp;gt;&#34;, &#34;Visual Chat Paste&#34; },&#xA;        t = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatToggle&amp;lt;cr&amp;gt;&#34;, &#34;Visual Toggle Chat&#34; },&#xA;&#xA;        [&#34;&amp;lt;C-x&amp;gt;&#34;] = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatNew split&amp;lt;cr&amp;gt;&#34;, &#34;Visual Chat New split&#34; },&#xA;        [&#34;&amp;lt;C-v&amp;gt;&#34;] = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatNew vsplit&amp;lt;cr&amp;gt;&#34;, &#34;Visual Chat New vsplit&#34; },&#xA;        [&#34;&amp;lt;C-t&amp;gt;&#34;] = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpChatNew tabnew&amp;lt;cr&amp;gt;&#34;, &#34;Visual Chat New tabnew&#34; },&#xA;&#xA;        r = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpRewrite&amp;lt;cr&amp;gt;&#34;, &#34;Visual Rewrite&#34; },&#xA;        a = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpAppend&amp;lt;cr&amp;gt;&#34;, &#34;Visual Append (after)&#34; },&#xA;        b = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpPrepend&amp;lt;cr&amp;gt;&#34;, &#34;Visual Prepend (before)&#34; },&#xA;        i = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpImplement&amp;lt;cr&amp;gt;&#34;, &#34;Implement selection&#34; },&#xA;&#xA;        g = {&#xA;            name = &#34;generate into new ..&#34;,&#xA;            p = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpPopup&amp;lt;cr&amp;gt;&#34;, &#34;Visual Popup&#34; },&#xA;            e = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpEnew&amp;lt;cr&amp;gt;&#34;, &#34;Visual GpEnew&#34; },&#xA;            n = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpNew&amp;lt;cr&amp;gt;&#34;, &#34;Visual GpNew&#34; },&#xA;            v = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpVnew&amp;lt;cr&amp;gt;&#34;, &#34;Visual GpVnew&#34; },&#xA;            t = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpTabnew&amp;lt;cr&amp;gt;&#34;, &#34;Visual GpTabnew&#34; },&#xA;        },&#xA;&#xA;        n = { &#34;&amp;lt;cmd&amp;gt;GpNextAgent&amp;lt;cr&amp;gt;&#34;, &#34;Next Agent&#34; },&#xA;        s = { &#34;&amp;lt;cmd&amp;gt;GpStop&amp;lt;cr&amp;gt;&#34;, &#34;GpStop&#34; },&#xA;        x = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpContext&amp;lt;cr&amp;gt;&#34;, &#34;Visual GpContext&#34; },&#xA;&#xA;        w = {&#xA;            name = &#34;Whisper&#34;,&#xA;            w = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisper&amp;lt;cr&amp;gt;&#34;, &#34;Whisper&#34; },&#xA;            r = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperRewrite&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Rewrite&#34; },&#xA;            a = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperAppend&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Append (after)&#34; },&#xA;            b = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperPrepend&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Prepend (before)&#34; },&#xA;            p = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperPopup&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Popup&#34; },&#xA;            e = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperEnew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Enew&#34; },&#xA;            n = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperNew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper New&#34; },&#xA;            v = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperVnew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Vnew&#34; },&#xA;            t = { &#34;:&amp;lt;C-u&amp;gt;&#39;&amp;lt;,&#39;&amp;gt;GpWhisperTabnew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Tabnew&#34; },&#xA;        },&#xA;    },&#xA;    -- ...&#xA;}, {&#xA;    mode = &#34;v&#34;, -- VISUAL mode&#xA;    prefix = &#34;&#34;,&#xA;    buffer = nil,&#xA;    silent = true,&#xA;    noremap = true,&#xA;    nowait = true,&#xA;})&#xA;&#xA;-- NORMAL mode mappings&#xA;require(&#34;which-key&#34;).register({&#xA;    -- ...&#xA;    [&#34;&amp;lt;C-g&amp;gt;&#34;] = {&#xA;        c = { &#34;&amp;lt;cmd&amp;gt;GpChatNew&amp;lt;cr&amp;gt;&#34;, &#34;New Chat&#34; },&#xA;        t = { &#34;&amp;lt;cmd&amp;gt;GpChatToggle&amp;lt;cr&amp;gt;&#34;, &#34;Toggle Chat&#34; },&#xA;        f = { &#34;&amp;lt;cmd&amp;gt;GpChatFinder&amp;lt;cr&amp;gt;&#34;, &#34;Chat Finder&#34; },&#xA;&#xA;        [&#34;&amp;lt;C-x&amp;gt;&#34;] = { &#34;&amp;lt;cmd&amp;gt;GpChatNew split&amp;lt;cr&amp;gt;&#34;, &#34;New Chat split&#34; },&#xA;        [&#34;&amp;lt;C-v&amp;gt;&#34;] = { &#34;&amp;lt;cmd&amp;gt;GpChatNew vsplit&amp;lt;cr&amp;gt;&#34;, &#34;New Chat vsplit&#34; },&#xA;        [&#34;&amp;lt;C-t&amp;gt;&#34;] = { &#34;&amp;lt;cmd&amp;gt;GpChatNew tabnew&amp;lt;cr&amp;gt;&#34;, &#34;New Chat tabnew&#34; },&#xA;&#xA;        r = { &#34;&amp;lt;cmd&amp;gt;GpRewrite&amp;lt;cr&amp;gt;&#34;, &#34;Inline Rewrite&#34; },&#xA;        a = { &#34;&amp;lt;cmd&amp;gt;GpAppend&amp;lt;cr&amp;gt;&#34;, &#34;Append (after)&#34; },&#xA;        b = { &#34;&amp;lt;cmd&amp;gt;GpPrepend&amp;lt;cr&amp;gt;&#34;, &#34;Prepend (before)&#34; },&#xA;&#xA;        g = {&#xA;            name = &#34;generate into new ..&#34;,&#xA;            p = { &#34;&amp;lt;cmd&amp;gt;GpPopup&amp;lt;cr&amp;gt;&#34;, &#34;Popup&#34; },&#xA;            e = { &#34;&amp;lt;cmd&amp;gt;GpEnew&amp;lt;cr&amp;gt;&#34;, &#34;GpEnew&#34; },&#xA;            n = { &#34;&amp;lt;cmd&amp;gt;GpNew&amp;lt;cr&amp;gt;&#34;, &#34;GpNew&#34; },&#xA;            v = { &#34;&amp;lt;cmd&amp;gt;GpVnew&amp;lt;cr&amp;gt;&#34;, &#34;GpVnew&#34; },&#xA;            t = { &#34;&amp;lt;cmd&amp;gt;GpTabnew&amp;lt;cr&amp;gt;&#34;, &#34;GpTabnew&#34; },&#xA;        },&#xA;&#xA;        n = { &#34;&amp;lt;cmd&amp;gt;GpNextAgent&amp;lt;cr&amp;gt;&#34;, &#34;Next Agent&#34; },&#xA;        s = { &#34;&amp;lt;cmd&amp;gt;GpStop&amp;lt;cr&amp;gt;&#34;, &#34;GpStop&#34; },&#xA;        x = { &#34;&amp;lt;cmd&amp;gt;GpContext&amp;lt;cr&amp;gt;&#34;, &#34;Toggle GpContext&#34; },&#xA;&#xA;        w = {&#xA;            name = &#34;Whisper&#34;,&#xA;            w = { &#34;&amp;lt;cmd&amp;gt;GpWhisper&amp;lt;cr&amp;gt;&#34;, &#34;Whisper&#34; },&#xA;            r = { &#34;&amp;lt;cmd&amp;gt;GpWhisperRewrite&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Inline Rewrite&#34; },&#xA;            a = { &#34;&amp;lt;cmd&amp;gt;GpWhisperAppend&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Append (after)&#34; },&#xA;            b = { &#34;&amp;lt;cmd&amp;gt;GpWhisperPrepend&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Prepend (before)&#34; },&#xA;            p = { &#34;&amp;lt;cmd&amp;gt;GpWhisperPopup&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Popup&#34; },&#xA;            e = { &#34;&amp;lt;cmd&amp;gt;GpWhisperEnew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Enew&#34; },&#xA;            n = { &#34;&amp;lt;cmd&amp;gt;GpWhisperNew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper New&#34; },&#xA;            v = { &#34;&amp;lt;cmd&amp;gt;GpWhisperVnew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Vnew&#34; },&#xA;            t = { &#34;&amp;lt;cmd&amp;gt;GpWhisperTabnew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Tabnew&#34; },&#xA;        },&#xA;    },&#xA;    -- ...&#xA;}, {&#xA;    mode = &#34;n&#34;, -- NORMAL mode&#xA;    prefix = &#34;&#34;,&#xA;    buffer = nil,&#xA;    silent = true,&#xA;    noremap = true,&#xA;    nowait = true,&#xA;})&#xA;&#xA;-- INSERT mode mappings&#xA;require(&#34;which-key&#34;).register({&#xA;    -- ...&#xA;    [&#34;&amp;lt;C-g&amp;gt;&#34;] = {&#xA;        c = { &#34;&amp;lt;cmd&amp;gt;GpChatNew&amp;lt;cr&amp;gt;&#34;, &#34;New Chat&#34; },&#xA;        t = { &#34;&amp;lt;cmd&amp;gt;GpChatToggle&amp;lt;cr&amp;gt;&#34;, &#34;Toggle Chat&#34; },&#xA;        f = { &#34;&amp;lt;cmd&amp;gt;GpChatFinder&amp;lt;cr&amp;gt;&#34;, &#34;Chat Finder&#34; },&#xA;&#xA;        [&#34;&amp;lt;C-x&amp;gt;&#34;] = { &#34;&amp;lt;cmd&amp;gt;GpChatNew split&amp;lt;cr&amp;gt;&#34;, &#34;New Chat split&#34; },&#xA;        [&#34;&amp;lt;C-v&amp;gt;&#34;] = { &#34;&amp;lt;cmd&amp;gt;GpChatNew vsplit&amp;lt;cr&amp;gt;&#34;, &#34;New Chat vsplit&#34; },&#xA;        [&#34;&amp;lt;C-t&amp;gt;&#34;] = { &#34;&amp;lt;cmd&amp;gt;GpChatNew tabnew&amp;lt;cr&amp;gt;&#34;, &#34;New Chat tabnew&#34; },&#xA;&#xA;        r = { &#34;&amp;lt;cmd&amp;gt;GpRewrite&amp;lt;cr&amp;gt;&#34;, &#34;Inline Rewrite&#34; },&#xA;        a = { &#34;&amp;lt;cmd&amp;gt;GpAppend&amp;lt;cr&amp;gt;&#34;, &#34;Append (after)&#34; },&#xA;        b = { &#34;&amp;lt;cmd&amp;gt;GpPrepend&amp;lt;cr&amp;gt;&#34;, &#34;Prepend (before)&#34; },&#xA;&#xA;        g = {&#xA;            name = &#34;generate into new ..&#34;,&#xA;            p = { &#34;&amp;lt;cmd&amp;gt;GpPopup&amp;lt;cr&amp;gt;&#34;, &#34;Popup&#34; },&#xA;            e = { &#34;&amp;lt;cmd&amp;gt;GpEnew&amp;lt;cr&amp;gt;&#34;, &#34;GpEnew&#34; },&#xA;            n = { &#34;&amp;lt;cmd&amp;gt;GpNew&amp;lt;cr&amp;gt;&#34;, &#34;GpNew&#34; },&#xA;            v = { &#34;&amp;lt;cmd&amp;gt;GpVnew&amp;lt;cr&amp;gt;&#34;, &#34;GpVnew&#34; },&#xA;            t = { &#34;&amp;lt;cmd&amp;gt;GpTabnew&amp;lt;cr&amp;gt;&#34;, &#34;GpTabnew&#34; },&#xA;        },&#xA;&#xA;        x = { &#34;&amp;lt;cmd&amp;gt;GpContext&amp;lt;cr&amp;gt;&#34;, &#34;Toggle GpContext&#34; },&#xA;        s = { &#34;&amp;lt;cmd&amp;gt;GpStop&amp;lt;cr&amp;gt;&#34;, &#34;GpStop&#34; },&#xA;        n = { &#34;&amp;lt;cmd&amp;gt;GpNextAgent&amp;lt;cr&amp;gt;&#34;, &#34;Next Agent&#34; },&#xA;&#xA;        w = {&#xA;            name = &#34;Whisper&#34;,&#xA;            w = { &#34;&amp;lt;cmd&amp;gt;GpWhisper&amp;lt;cr&amp;gt;&#34;, &#34;Whisper&#34; },&#xA;            r = { &#34;&amp;lt;cmd&amp;gt;GpWhisperRewrite&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Inline Rewrite&#34; },&#xA;            a = { &#34;&amp;lt;cmd&amp;gt;GpWhisperAppend&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Append (after)&#34; },&#xA;            b = { &#34;&amp;lt;cmd&amp;gt;GpWhisperPrepend&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Prepend (before)&#34; },&#xA;            p = { &#34;&amp;lt;cmd&amp;gt;GpWhisperPopup&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Popup&#34; },&#xA;            e = { &#34;&amp;lt;cmd&amp;gt;GpWhisperEnew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Enew&#34; },&#xA;            n = { &#34;&amp;lt;cmd&amp;gt;GpWhisperNew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper New&#34; },&#xA;            v = { &#34;&amp;lt;cmd&amp;gt;GpWhisperVnew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Vnew&#34; },&#xA;            t = { &#34;&amp;lt;cmd&amp;gt;GpWhisperTabnew&amp;lt;cr&amp;gt;&#34;, &#34;Whisper Tabnew&#34; },&#xA;        },&#xA;    },&#xA;    -- ...&#xA;}, {&#xA;    mode = &#34;i&#34;, -- INSERT mode&#xA;    prefix = &#34;&#34;,&#xA;    buffer = nil,&#xA;    silent = true,&#xA;    noremap = true,&#xA;    nowait = true,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Extend functionality&lt;/h1&gt; &#xA;&lt;p&gt;You can extend/override the plugin functionality with your own, by putting functions into &lt;code&gt;config.hooks&lt;/code&gt;. Hooks have access to everything (see &lt;code&gt;InspectPlugin&lt;/code&gt; example in defaults) and are automatically registered as commands (&lt;code&gt;GpInspectPlugin&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Here are some more examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpUnitTests&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- example of adding command which writes unit tests for the selected code&#xA;UnitTests = function(gp, params)&#xA;    local template = &#34;I have the following code from {{filename}}:\n\n&#34;&#xA;        .. &#34;```{{filetype}}\n{{selection}}\n```\n\n&#34;&#xA;        .. &#34;Please respond by writing table driven unit tests for the code above.&#34;&#xA;    local agent = gp.get_command_agent()&#xA;    gp.Prompt(params, gp.Target.enew, nil, agent.model, template, agent.system_prompt)&#xA;end,&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpExplain&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- example of adding command which explains the selected code&#xA;Explain = function(gp, params)&#xA;    local template = &#34;I have the following code from {{filename}}:\n\n&#34;&#xA;        .. &#34;```{{filetype}}\n{{selection}}\n```\n\n&#34;&#xA;        .. &#34;Please respond by explaining the code above.&#34;&#xA;    local agent = gp.get_chat_agent()&#xA;    gp.Prompt(params, gp.Target.popup, nil, agent.model, template, agent.system_prompt)&#xA;end,&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpCodeReview&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- example of usig enew as a function specifying type for the new buffer&#xA;CodeReview = function(gp, params)&#xA;    local template = &#34;I have the following code from {{filename}}:\n\n&#34;&#xA;        .. &#34;```{{filetype}}\n{{selection}}\n```\n\n&#34;&#xA;        .. &#34;Please analyze for code smells and suggest improvements.&#34;&#xA;    local agent = gp.get_chat_agent()&#xA;    gp.Prompt(params, gp.Target.enew(&#34;markdown&#34;), nil, agent.model, template, agent.system_prompt)&#xA;end,&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpTranslator&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- example of adding command which opens new chat dedicated for translation&#xA;Translator = function(gp, params)&#xA;  local agent = gp.get_command_agent()&#xA;local chat_system_prompt = &#34;You are a Translator, please translate between English and Chinese.&#34;&#xA;gp.cmd.ChatNew(params, agent.model, chat_system_prompt)&#xA;end,&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;:GpBufferChatNew&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- example of making :%GpChatNew a dedicated command which&#xA;-- opens new chat with the entire current buffer as a context&#xA;BufferChatNew = function(gp, _)&#xA;    -- call GpChatNew command in range mode on whole buffer&#xA;    vim.api.nvim_command(&#34;%&#34; .. gp.config.cmd_prefix .. &#34;ChatNew&#34;)&#xA;end,&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The raw plugin text editing method &lt;code&gt;Prompt&lt;/code&gt; has seven aprameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;params&lt;/code&gt; is a &lt;a href=&#34;https://neovim.io/doc/user/lua-guide.html#lua-guide-commands-create&#34;&gt;table passed to neovim user commands&lt;/a&gt;, &lt;code&gt;Prompt&lt;/code&gt; currently uses:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;range, line1, line2&lt;/code&gt; to work with &lt;a href=&#34;https://neovim.io/doc/user/usr_10.html#10.3&#34;&gt;ranges&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;args&lt;/code&gt; so instructions can be passed directly after command (&lt;code&gt;:GpRewrite something something&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;params = {&#xA;      args = &#34;&#34;,&#xA;      bang = false,&#xA;      count = -1,&#xA;      fargs = {},&#xA;      line1 = 1352,&#xA;      line2 = 1352,&#xA;      mods = &#34;&#34;,&#xA;      name = &#34;GpChatNew&#34;,&#xA;      range = 0,&#xA;      reg = &#34;&#34;,&#xA;      smods = {&#xA;            browse = false,&#xA;            confirm = false,&#xA;            emsg_silent = false,&#xA;            hide = false,&#xA;            horizontal = false,&#xA;            keepalt = false,&#xA;            keepjumps = false,&#xA;            keepmarks = false,&#xA;            keeppatterns = false,&#xA;            lockmarks = false,&#xA;            noautocmd = false,&#xA;            noswapfile = false,&#xA;            sandbox = false,&#xA;            silent = false,&#xA;            split = &#34;&#34;,&#xA;            tab = -1,&#xA;            unsilent = false,&#xA;            verbose = -1,&#xA;            vertical = false&#xA;      }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;target&lt;/code&gt; specifying where to direct GPT response&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;enew/new/vnew/tabnew can be used as a function so you can pass in a filetype for the new buffer (&lt;code&gt;enew/enew()/enew(&#34;markdown&#34;)/..&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;M.Target = {&#xA;    rewrite = 0, -- for replacing the selection, range or the current line&#xA;    append = 1, -- for appending after the selection, range or the current line&#xA;    prepend = 2, -- for prepending before the selection, range or the current line&#xA;    popup = 3, -- for writing into the popup window&#xA;&#xA;    -- for writing into a new buffer&#xA;    ---@param filetype nil | string # nil = same as the original buffer&#xA;    ---@return table # a table with type=4 and filetype=filetype&#xA;    enew = function(filetype)&#xA;        return { type = 4, filetype = filetype }&#xA;    end,&#xA;&#xA;    --- for creating a new horizontal split&#xA;    ---@param filetype nil | string # nil = same as the original buffer&#xA;    ---@return table # a table with type=5 and filetype=filetype&#xA;    new = function(filetype)&#xA;        return { type = 5, filetype = filetype }&#xA;    end,&#xA;&#xA;    --- for creating a new vertical split&#xA;    ---@param filetype nil | string # nil = same as the original buffer&#xA;    ---@return table # a table with type=6 and filetype=filetype&#xA;    vnew = function(filetype)&#xA;        return { type = 6, filetype = filetype }&#xA;    end,&#xA;&#xA;    --- for creating a new tab&#xA;    ---@param filetype nil | string # nil = same as the original buffer&#xA;    ---@return table # a table with type=7 and filetype=filetype&#xA;    tabnew = function(filetype)&#xA;        return { type = 7, filetype = filetype }&#xA;    end,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;prompt&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;string used similarly as bash/zsh prompt in terminal, when plugin asks for user command to gpt.&lt;/li&gt; &#xA;   &lt;li&gt;if &lt;code&gt;nil&lt;/code&gt;, user is not asked to provide input (for specific predefined commands - document this, explain that, write tests ..)&lt;/li&gt; &#xA;   &lt;li&gt;simple &lt;code&gt;ðŸ¤– ~ &lt;/code&gt; might be used or you could use different msg to convey info about the method which is called&lt;br&gt; (&lt;code&gt;ðŸ¤– rewrite ~&lt;/code&gt;, &lt;code&gt;ðŸ¤– popup ~&lt;/code&gt;, &lt;code&gt;ðŸ¤– enew ~&lt;/code&gt;, &lt;code&gt;ðŸ¤– inline ~&lt;/code&gt;, etc.)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;model&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;see &lt;a href=&#34;https://platform.openai.com/docs/models/overview&#34;&gt;gpt model overview&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;template&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;template of the user message send to gpt&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;string can include variables bellow:&lt;/p&gt; &#xA;    &lt;table&gt; &#xA;     &lt;thead&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;th&gt;name&lt;/th&gt; &#xA;       &lt;th&gt;Description&lt;/th&gt; &#xA;      &lt;/tr&gt; &#xA;     &lt;/thead&gt; &#xA;     &lt;tbody&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;td&gt;&lt;code&gt;{{filetype}}&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td&gt;filetype of the current buffer&lt;/td&gt; &#xA;      &lt;/tr&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;td&gt;&lt;code&gt;{{selection}}&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td&gt;last or currently selected text&lt;/td&gt; &#xA;      &lt;/tr&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;td&gt;&lt;code&gt;{{command}}&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td&gt;instructions provided by the user&lt;/td&gt; &#xA;      &lt;/tr&gt; &#xA;     &lt;/tbody&gt; &#xA;    &lt;/table&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;system_template&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;See &lt;a href=&#34;https://platform.openai.com/docs/guides/chat/introduction&#34;&gt;gpt api intro&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;whisper&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;optional string serving as a default for input prompt (for example generated from speech by Whisper)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>ThePrimeagen/vim-apm</title>
    <updated>2024-01-21T02:00:01Z</updated>
    <id>tag:github.com,2024-01-21:/ThePrimeagen/vim-apm</id>
    <link href="https://github.com/ThePrimeagen/vim-apm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Vim APM, Actions per minute, is the greatest plugin since vim-slicedbread&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Vim APM&lt;/h2&gt; &#xA;&lt;p&gt;This is still a very alpha application but should be a good time to use.&lt;/p&gt; &#xA;&lt;h3&gt;Please file issues for&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;anytime you get an error&lt;/li&gt; &#xA; &lt;li&gt;absolutely not working&lt;/li&gt; &#xA; &lt;li&gt;missing motions or incorrect motions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Getting Started&lt;/h3&gt; &#xA;&lt;p&gt;Here is my Lazy &lt;code&gt;config&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local apm = require(&#34;vim-apm&#34;)&#xA;&#xA;apm:setup({})&#xA;vim.keymap.set(&#34;n&#34;, &#34;&amp;lt;leader&amp;gt;apm&#34;, function() apm:toggle_monitor() end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t know how to install plugins, this is probably not for you in this moment&lt;/p&gt; &#xA;&lt;h2&gt;Why Go?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/ThePrimeagen/status/1745166587781349888&#34;&gt;i did a poll&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;I want to use go templates and htmx and live that simple life style&lt;/li&gt; &#xA; &lt;li&gt;I want to use charm cli&lt;/li&gt; &#xA; &lt;li&gt;I like go more than typescript&lt;/li&gt; &#xA; &lt;li&gt;I like go more than javascript&lt;/li&gt; &#xA; &lt;li&gt;I like go more than elixir (ok i haven&#39;t tried elixir)&lt;/li&gt; &#xA; &lt;li&gt;I don&#39;t ackshually know how to program rust&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>rose-pine/neovim</title>
    <updated>2024-01-21T02:00:01Z</updated>
    <id>tag:github.com,2024-01-21:/rose-pine/neovim</id>
    <link href="https://github.com/rose-pine/neovim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Soho vibes for Neovim&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/rose-pine/rose-pine-theme/raw/main/assets/icon.png&#34; width=&#34;80&#34;&gt; &lt;/p&gt;&#xA;&lt;h2 align=&#34;center&#34;&gt;RosÃ© Pine for Neovim&lt;/h2&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;All natural pine, faux fur and a bit of soho vibes for the classy minimalist&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/rose-pine/rose-pine-theme&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/community-rosÃ©%20pine-26233a?labelColor=191724&amp;amp;logo=data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUwIiBoZWlnaHQ9IjIzNyIgdmlld0JveD0iMCAwIDI1MCAyMzciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0xNjEuMjI3IDE2MS4yNTFDMTMyLjE1NCAxNjkuMDQxIDExNC45MDEgMTk4LjkyNCAxMjIuNjkxIDIyNy45OTdDMTIzLjkyNSAyMzIuNjAzIDEyOC42NTkgMjM1LjMzNiAxMzMuMjY0IDIzNC4xMDJMMTg1LjkwNyAyMTkuOTk2QzIxOS41ODUgMjEwLjk3MiAyMzkuNTcgMTc2LjM1NCAyMzAuNTQ2IDE0Mi42NzdMMTYxLjIyNyAxNjEuMjUxWiIgZmlsbD0iIzI0NjI3QiIvPgo8cGF0aCBkPSJNODguMTgzNiAxNTkuOTg4QzExNy4yNTcgMTY3Ljc3OCAxMzQuNTEgMTk3LjY2MiAxMjYuNzIgMjI2LjczNUMxMjUuNDg2IDIzMS4zNCAxMjAuNzUyIDIzNC4wNzMgMTE2LjE0NyAyMzIuODM5TDYzLjUwNDEgMjE4LjczM0MyOS44MjY0IDIwOS43MSA5Ljg0MDk0IDE3NS4wOTIgMTguODY0OSAxNDEuNDE0TDg4LjE4MzYgMTU5Ljk4OFoiIGZpbGw9IiMyNDYyN0IiLz4KPHBhdGggZD0iTTE4Ni44NjcgMTcyLjk4QzE1Mi4wMDIgMTcyLjk4IDEyMy43MzcgMjAxLjI0NSAxMjMuNzM3IDIzNi4xMTFIMTg2Ljg3QzIyMS43MzYgMjM2LjExMSAyNTAgMjA3Ljg0NiAyNTAgMTcyLjk4TDE4Ni44NjcgMTcyLjk4WiIgZmlsbD0iIzMxNzQ4RiIvPgo8cGF0aCBkPSJNNjMuMTMyNyAxNzIuOThDOTcuOTk4NCAxNzIuOTggMTI2LjI2MyAyMDEuMjQ1IDEyNi4yNjMgMjM2LjExMUg2My4xM0MyOC4yNjQyIDIzNi4xMTEgLTEuNTI0MDNlLTA2IDIwNy44NDYgMCAxNzIuOThMNjMuMTMyNyAxNzIuOThaIiBmaWxsPSIjMzE3NDhGIi8+CjxwYXRoIGQ9Ik0xNzEuNzE3IDc1LjEyNjNDMTcxLjcxNyAxMDEuMjc2IDE1MC41MTggMTIyLjQ3NSAxMjQuMzY5IDEyMi40NzVDOTguMjE4OCAxMjIuNDc1IDc3LjAyMDIgMTAxLjI3NiA3Ny4wMjAyIDc1LjEyNjNDNzcuMDIwMiA0OC45NzY0IDk4LjIxODggMjcuNzc3OCAxMjQuMzY5IDI3Ljc3NzhDMTUwLjUxOCAyNy43Nzc4IDE3MS43MTcgNDguOTc2NCAxNzEuNzE3IDc1LjEyNjNaIiBmaWxsPSIjRUJCQ0JBIi8+CjxwYXRoIGQ9Ik0xNDQuMjE3IDg2LjIzNzlDMTYxLjY0OSA1Ni4wNDMyIDE1MS4zMDMgMTcuNDMyOSAxMjEuMTA4IDBMMTA2LjA2IDI2LjA2NDRDODguNjI3IDU2LjI1OSA5OC45NzM2IDk0Ljg2OTQgMTI5LjE2OCAxMTIuMzAyTDE0NC4yMTcgODYuMjM3OVoiIGZpbGw9IiNFQkJDQkEiLz4KPHBhdGggZD0iTTEyNS4yOTkgNjAuOTc4OUMxMTYuMjc1IDI3LjMwMTIgODEuNjU3NSA3LjMxNTY3IDQ3Ljk3OTcgMTYuMzM5Nkw2NC4zMTk3IDc3LjMyMTFDNzMuMzQzNiAxMTAuOTk5IDEwNy45NjEgMTMwLjk4NCAxNDEuNjM5IDEyMS45NkwxMjUuMjk5IDYwLjk3ODlaIiBmaWxsPSIjRUJCQ0JBIi8+CjxwYXRoIGQ9Ik0xMjQuOTI2IDYwLjk3ODlDMTMzLjk1IDI3LjMwMTIgMTY4LjU2NyA3LjMxNTY3IDIwMi4yNDUgMTYuMzM5NkwxODUuOTA1IDc3LjMyMTFDMTc2Ljg4MSAxMTAuOTk5IDE0Mi4yNjMgMTMwLjk4NCAxMDguNTg2IDEyMS45NkwxMjQuOTI2IDYwLjk3ODlaIiBmaWxsPSIjRUJCQ0JBIi8+Cjwvc3ZnPgo=&amp;amp;style=for-the-badge&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;Install &lt;code&gt;rose-pine/neovim&lt;/code&gt; using your favourite plugin manager:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;paq-nvim&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{ &#39;rose-pine/neovim&#39;, as = &#39;rose-pine&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;lazy.nvim&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{ &#39;rose-pine/neovim&#39;, name = &#39;rose-pine&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Gallery&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;RosÃ© Pine&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1973/163921570-0f577baf-3199-4f09-9779-a7eb9238151a.png&#34; alt=&#34;RosÃ© Pine with Neovim&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;RosÃ© Pine Moon&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1973/163921620-d3acd0d2-d227-4d28-a5e8-97ff22e56c6d.png&#34; alt=&#34;RosÃ© Pine Moon with Neovim&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;RosÃ© Pine Dawn&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1973/163921656-644a2db3-c55c-4e89-9bdd-39cdd7a2681b.png&#34; alt=&#34;RosÃ© Pine Dawn with Neovim&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Options&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] Configure options &lt;em&gt;before&lt;/em&gt; setting colorscheme.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;RosÃ© Pine has three variants: main, moon, and dawn. By default, &lt;code&gt;vim.o.background&lt;/code&gt; is followed, using dawn when light and &lt;code&gt;dark_variant&lt;/code&gt; when dark.&lt;/p&gt; &#xA;&lt;p&gt;Colour values accept named colours from the &lt;a href=&#34;https://rosepinetheme.com/palette/ingredients/&#34;&gt;RosÃ© Pine palette&lt;/a&gt;, e.g. &#34;foam&#34;, or valid hex, e.g. &#34;#fa8072&#34;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;rose-pine&#39;).setup({&#xA;    variant = &#34;auto&#34;, -- auto, main, moon, or dawn&#xA;    dark_variant = &#34;main&#34;, -- main, moon, or dawn&#xA;    dim_inactive_windows = false,&#xA;    extend_background_behind_borders = true,&#xA;&#xA;    styles = {&#xA;        bold = true,&#xA;        italic = true,&#xA;        transparency = false,&#xA;    },&#xA;&#xA;    groups = {&#xA;        border = &#34;muted&#34;,&#xA;        link = &#34;iris&#34;,&#xA;        panel = &#34;surface&#34;,&#xA;&#xA;        error = &#34;love&#34;,&#xA;        hint = &#34;iris&#34;,&#xA;        info = &#34;foam&#34;,&#xA;        warn = &#34;gold&#34;,&#xA;&#xA;        git_add = &#34;foam&#34;,&#xA;        git_change = &#34;rose&#34;,&#xA;        git_delete = &#34;love&#34;,&#xA;        git_dirty = &#34;rose&#34;,&#xA;        git_ignore = &#34;muted&#34;,&#xA;        git_merge = &#34;iris&#34;,&#xA;        git_rename = &#34;pine&#34;,&#xA;        git_stage = &#34;iris&#34;,&#xA;        git_text = &#34;rose&#34;,&#xA;        git_untracked = &#34;subtle&#34;,&#xA;&#xA;        headings = {&#xA;            h1 = &#34;iris&#34;,&#xA;            h2 = &#34;foam&#34;,&#xA;            h3 = &#34;rose&#34;,&#xA;            h4 = &#34;gold&#34;,&#xA;            h5 = &#34;pine&#34;,&#xA;            h6 = &#34;foam&#34;,&#xA;        },&#xA;        -- Alternatively, set all headings at once.&#xA;        -- headings = &#34;subtle&#34;,&#xA;    },&#xA;&#xA;    highlight_groups = {&#xA;        -- Comment = { fg = &#34;foam&#34; },&#xA;        -- VertSplit = { fg = &#34;muted&#34;, bg = &#34;muted&#34; },&#xA;    },&#xA;&#xA;    before_highlight = function(group, highlight, palette)&#xA;        -- Disable all undercurls&#xA;        -- if highlight.undercurl then&#xA;        --     highlight.undercurl = false&#xA;        -- end&#xA;        --&#xA;        -- Change palette colour&#xA;        -- if highlight.fg == palette.pine then&#xA;        --     highlight.fg = palette.foam&#xA;        -- end&#xA;    end,&#xA;})&#xA;&#xA;vim.cmd(&#39;colorscheme rose-pine&#39;)&#xA;-- vim.cmd(&#39;colorscheme rose-pine-main&#39;)&#xA;-- vim.cmd(&#39;colorscheme rose-pine-moon&#39;)&#xA;-- vim.cmd(&#39;colorscheme rose-pine-dawn&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] Visit the &lt;a href=&#34;https://github.com/rose-pine/neovim/wiki&#34;&gt;wiki&lt;/a&gt; for &lt;a href=&#34;https://github.com/rose-pine/neovim/wiki/Plugin-configurations&#34;&gt;plugin configurations&lt;/a&gt; and &lt;a href=&#34;https://github.com/rose-pine/neovim/wiki/Recipes&#34;&gt;recipes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We welcome and appreciate contributions of any kind. Create an issue or start a discussion for any proposed changes. Pull requests are encouraged for supporting additional plugins.&lt;/p&gt; &#xA;&lt;p&gt;Feel free to update the &lt;a href=&#34;https://github.com/rose-pine/neovim/wiki/&#34;&gt;wiki&lt;/a&gt; with any &lt;a href=&#34;https://github.com/rose-pine/neovim/wiki/Recipes&#34;&gt;recipes&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>