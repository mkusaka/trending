<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Lua Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-09T01:59:04Z</updated>
  <subtitle>Weekly Trending of Lua in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>folke/flash.nvim</title>
    <updated>2023-07-09T01:59:04Z</updated>
    <id>tag:github.com,2023-07-09:/folke/flash.nvim</id>
    <link href="https://github.com/folke/flash.nvim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Navigate your code with search labels, enhanced character motions and Treesitter integration&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;‚ö°flash.nvim&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;flash.nvim&lt;/code&gt; lets you navigate your code with search labels, enhanced character motions, and Treesitter integration.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Search Integration&lt;/th&gt; &#xA;   &lt;th&gt;Standalone Jump&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://github.com/folke/flash.nvim/assets/292349/e0ac4cbc-fa54-4505-8261-43ec0505518d&#34;&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://github.com/folke/flash.nvim/assets/292349/90af85e3-3f22-4c51-af4b-2a2488c9560b&#34;&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;code&gt;f&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;Treesitter&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://github.com/folke/flash.nvim/assets/292349/379cb2de-8ec3-4acf-8811-d3590a5854b6&#34;&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://github.com/folke/flash.nvim/assets/292349/b963b05e-3d28-45ff-b43a-928a06e5f92a&#34;&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h2&gt;‚ú® Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üîç &lt;strong&gt;Search Integration&lt;/strong&gt;: integrate &lt;strong&gt;flash.nvim&lt;/strong&gt; with your regular search using &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;. Labels appear next to the matches, allowing you to quickly jump to any location. Labels are guaranteed not to exist as a continuation of the search pattern.&lt;/li&gt; &#xA; &lt;li&gt;‚å®Ô∏è &lt;strong&gt;type as many characters as you want&lt;/strong&gt; before using a jump label.&lt;/li&gt; &#xA; &lt;li&gt;‚ö° &lt;strong&gt;Enhanced &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; motions&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;üå≥ &lt;strong&gt;Treesitter Integration&lt;/strong&gt;: all parents of the Treesitter node under your cursor are highlighted with a label for quick selection of a specific Treesitter node.&lt;/li&gt; &#xA; &lt;li&gt;üéØ &lt;strong&gt;Jump Mode&lt;/strong&gt;: a standalone jumping mode similar to search&lt;/li&gt; &#xA; &lt;li&gt;üîé &lt;strong&gt;Search Modes&lt;/strong&gt;: &lt;code&gt;exact&lt;/code&gt;, &lt;code&gt;search&lt;/code&gt; (regex), and &lt;code&gt;fuzzy&lt;/code&gt; search modes&lt;/li&gt; &#xA; &lt;li&gt;ü™ü &lt;strong&gt;Multi Window&lt;/strong&gt; jumping&lt;/li&gt; &#xA; &lt;li&gt;üåê &lt;strong&gt;Remote Actions&lt;/strong&gt;: perform motions in remote locations&lt;/li&gt; &#xA; &lt;li&gt;‚ö´ &lt;strong&gt;dot-repeatable&lt;/strong&gt; jumps&lt;/li&gt; &#xA; &lt;li&gt;üì° &lt;strong&gt;highly extensible&lt;/strong&gt;: check the &lt;a href=&#34;https://github.com/folke/flash.nvim#-examples&#34;&gt;examples&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üìã Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Neovim &amp;gt;= &lt;strong&gt;0.8.0&lt;/strong&gt; (needs to be built with &lt;strong&gt;LuaJIT&lt;/strong&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üì¶ Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install the plugin with your preferred package manager:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/folke/lazy.nvim&#34;&gt;lazy.nvim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;!-- setup:start --&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  &#34;folke/flash.nvim&#34;,&#xA;  event = &#34;VeryLazy&#34;,&#xA;  ---@type Flash.Config&#xA;  opts = {},&#xA;  keys = {&#xA;    {&#xA;      &#34;s&#34;,&#xA;      mode = { &#34;n&#34;, &#34;x&#34;, &#34;o&#34; },&#xA;      function()&#xA;        require(&#34;flash&#34;).jump()&#xA;      end,&#xA;      desc = &#34;Flash&#34;,&#xA;    },&#xA;    {&#xA;      &#34;S&#34;,&#xA;      mode = { &#34;n&#34;, &#34;o&#34;, &#34;x&#34; },&#xA;      function()&#xA;        require(&#34;flash&#34;).treesitter()&#xA;      end,&#xA;      desc = &#34;Flash Treesitter&#34;,&#xA;    },&#xA;    {&#xA;      &#34;r&#34;,&#xA;      mode = &#34;o&#34;,&#xA;      function()&#xA;        require(&#34;flash&#34;).remote()&#xA;      end,&#xA;      desc = &#34;Remote Flash&#34;,&#xA;    },&#xA;    {&#xA;      &#34;R&#34;,&#xA;      mode = { &#34;o&#34;, &#34;x&#34; },&#xA;      function()&#xA;        require(&#34;flash&#34;).treesitter_search()&#xA;      end,&#xA;      desc = &#34;Flash Treesitter Search&#34;,&#xA;    },&#xA;    {&#xA;      &#34;&amp;lt;c-s&amp;gt;&#34;,&#xA;      mode = { &#34;c&#34; },&#xA;      function()&#xA;        require(&#34;flash&#34;).toggle()&#xA;      end,&#xA;      desc = &#34;Toggle Flash Search&#34;,&#xA;    },&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;!-- setup:end --&gt; &#xA;&lt;h2&gt;‚öôÔ∏è Configuration&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;flash.nvim&lt;/strong&gt; is highly configurable. Please refer to the default settings below.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Default Settings&lt;/summary&gt; &#xA; &lt;!-- config:start --&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;  -- labels = &#34;abcdefghijklmnopqrstuvwxyz&#34;,&#xA;  labels = &#34;asdfghjklqwertyuiopzxcvbnm&#34;,&#xA;  search = {&#xA;    -- search/jump in all windows&#xA;    multi_window = true,&#xA;    -- search direction&#xA;    forward = true,&#xA;    -- when `false`, find only matches in the given direction&#xA;    wrap = true,&#xA;    ---@type Flash.Pattern.Mode&#xA;    -- Each mode will take ignorecase and smartcase into account.&#xA;    -- * exact: exact match&#xA;    -- * search: regular search&#xA;    -- * fuzzy: fuzzy search&#xA;    -- * fun(str): custom function that returns a pattern&#xA;    --   For example, to only match at the beginning of a word:&#xA;    --   mode = function(str)&#xA;    --     return &#34;\\&amp;lt;&#34; .. str&#xA;    --   end,&#xA;    mode = &#34;exact&#34;,&#xA;    -- behave like `incsearch`&#xA;    incremental = false,&#xA;    -- Excluded filetypes and custom window filters&#xA;    ---@type (string|fun(win:window))[]&#xA;    exclude = {&#xA;      &#34;notify&#34;,&#xA;      &#34;cmp_menu&#34;,&#xA;      &#34;noice&#34;,&#xA;      &#34;flash_prompt&#34;,&#xA;      function(win)&#xA;        -- exclude non-focusable windows&#xA;        return not vim.api.nvim_win_get_config(win).focusable&#xA;      end,&#xA;    },&#xA;    -- Optional trigger character that needs to be typed before&#xA;    -- a jump label can be used. It&#39;s NOT recommended to set this,&#xA;    -- unless you know what you&#39;re doing&#xA;    trigger = &#34;&#34;,&#xA;    -- max pattern length. If the pattern length is equal to this&#xA;    -- labels will no longer be skipped. When it exceeds this length&#xA;    -- it will either end in a jump or terminate the search&#xA;    max_length = nil, ---@type number?&#xA;  },&#xA;  jump = {&#xA;    -- save location in the jumplist&#xA;    jumplist = true,&#xA;    -- jump position&#xA;    pos = &#34;start&#34;, ---@type &#34;start&#34; | &#34;end&#34; | &#34;range&#34;&#xA;    -- add pattern to search history&#xA;    history = false,&#xA;    -- add pattern to search register&#xA;    register = false,&#xA;    -- clear highlight after jump&#xA;    nohlsearch = false,&#xA;    -- automatically jump when there is only one match&#xA;    autojump = false,&#xA;    -- You can force inclusive/exclusive jumps by setting the&#xA;    -- `inclusive` option. By default it will be automatically&#xA;    -- set based on the mode.&#xA;    inclusive = nil, ---@type boolean?&#xA;    -- jump position offset. Not used for range jumps.&#xA;    -- 0: default&#xA;    -- 1: when pos == &#34;end&#34; and pos &amp;lt; current position&#xA;    offset = nil, ---@type number&#xA;  },&#xA;  label = {&#xA;    -- allow uppercase labels&#xA;    uppercase = true,&#xA;    -- add any labels with the correct case here, that you want to exclude&#xA;    exclude = &#34;&#34;,&#xA;    -- add a label for the first match in the current window.&#xA;    -- you can always jump to the first match with `&amp;lt;CR&amp;gt;`&#xA;    current = true,&#xA;    -- show the label after the match&#xA;    after = true, ---@type boolean|number[]&#xA;    -- show the label before the match&#xA;    before = false, ---@type boolean|number[]&#xA;    -- position of the label extmark&#xA;    style = &#34;overlay&#34;, ---@type &#34;eol&#34; | &#34;overlay&#34; | &#34;right_align&#34; | &#34;inline&#34;&#xA;    -- flash tries to re-use labels that were already assigned to a position,&#xA;    -- when typing more characters. By default only lower-case labels are re-used.&#xA;    reuse = &#34;lowercase&#34;, ---@type &#34;lowercase&#34; | &#34;all&#34;&#xA;    -- for the current window, label targets closer to the cursor first&#xA;    distance = true,&#xA;    -- minimum pattern length to show labels&#xA;    -- Ignored for custom labelers.&#xA;    min_pattern_length = 0,&#xA;    -- Enable this to use rainbow colors to highlight labels&#xA;    -- Can be useful for visualizing Treesitter ranges.&#xA;    rainbow = {&#xA;      enabled = false,&#xA;      -- number between 1 and 9&#xA;      shade = 5,&#xA;    },&#xA;    -- With `format`, you can change how the label is rendered.&#xA;    -- Should return a list of `[text, highlight]` tuples.&#xA;    ---@class Flash.Format&#xA;    ---@field state Flash.State&#xA;    ---@field match Flash.Match&#xA;    ---@field hl_group string&#xA;    ---@field after boolean&#xA;    ---@type fun(opts:Flash.Format): string[][]&#xA;    format = function(opts)&#xA;      return { { opts.match.label, opts.hl_group } }&#xA;    end,&#xA;  },&#xA;  highlight = {&#xA;    -- show a backdrop with hl FlashBackdrop&#xA;    backdrop = true,&#xA;    -- Highlight the search matches&#xA;    matches = true,&#xA;    -- extmark priority&#xA;    priority = 5000,&#xA;    groups = {&#xA;      match = &#34;FlashMatch&#34;,&#xA;      current = &#34;FlashCurrent&#34;,&#xA;      backdrop = &#34;FlashBackdrop&#34;,&#xA;      label = &#34;FlashLabel&#34;,&#xA;    },&#xA;  },&#xA;  -- action to perform when picking a label.&#xA;  -- defaults to the jumping logic depending on the mode.&#xA;  ---@type fun(match:Flash.Match, state:Flash.State)|nil&#xA;  action = nil,&#xA;  -- initial pattern to use when opening flash&#xA;  pattern = &#34;&#34;,&#xA;  -- When `true`, flash will try to continue the last search&#xA;  continue = false,&#xA;  -- Set config to a function to dynamically change the config&#xA;  config = nil, ---@type fun(opts:Flash.Config)|nil&#xA;  -- You can override the default options for a specific mode.&#xA;  -- Use it with `require(&#34;flash&#34;).jump({mode = &#34;forward&#34;})`&#xA;  ---@type table&amp;lt;string, Flash.Config&amp;gt;&#xA;  modes = {&#xA;    -- options used when flash is activated through&#xA;    -- a regular search with `/` or `?`&#xA;    search = {&#xA;      -- when `true`, flash will be activated during regular search by default.&#xA;      -- You can always toggle when searching with `require(&#34;flash&#34;).toggle()`&#xA;      enabled = true,&#xA;      highlight = { backdrop = false },&#xA;      jump = { history = true, register = true, nohlsearch = true },&#xA;      search = {&#xA;        -- `forward` will be automatically set to the search direction&#xA;        -- `mode` is always set to `search`&#xA;        -- `incremental` is set to `true` when `incsearch` is enabled&#xA;      },&#xA;    },&#xA;    -- options used when flash is activated through&#xA;    -- `f`, `F`, `t`, `T`, `;` and `,` motions&#xA;    char = {&#xA;      enabled = true,&#xA;      -- dynamic configuration for ftFT motions&#xA;      config = function(opts)&#xA;        -- autohide flash when in operator-pending mode&#xA;        opts.autohide = vim.fn.mode(true):find(&#34;no&#34;) and vim.v.operator == &#34;y&#34;&#xA;&#xA;        -- disable jump labels when enabled and when using a count&#xA;        opts.jump_labels = opts.jump_labels and vim.v.count == 0&#xA;&#xA;        -- Show jump labels only in operator-pending mode&#xA;        -- opts.jump_labels = vim.v.count == 0 and vim.fn.mode(true):find(&#34;o&#34;)&#xA;      end,&#xA;      -- hide after jump when not using jump labels&#xA;      autohide = false,&#xA;      -- show jump labels&#xA;      jump_labels = false,&#xA;      -- set to `false` to use the current line only&#xA;      multi_line = true,&#xA;      -- When using jump labels, don&#39;t use these keys&#xA;      -- This allows using those keys directly after the motion&#xA;      label = { exclude = &#34;hjkliardc&#34; },&#xA;      -- by default all keymaps are enabled, but you can disable some of them,&#xA;      -- by removing them from the list.&#xA;      -- If you rather use another key, you can map them&#xA;      -- to something else, e.g., { [&#34;;&#34;] = &#34;L&#34;, [&#34;,&#34;] = H }&#xA;      keys = { &#34;f&#34;, &#34;F&#34;, &#34;t&#34;, &#34;T&#34;, &#34;;&#34;, &#34;,&#34; },&#xA;      ---@alias Flash.CharActions table&amp;lt;string, &#34;next&#34; | &#34;prev&#34; | &#34;right&#34; | &#34;left&#34;&amp;gt;&#xA;      -- The direction for `prev` and `next` is determined by the motion.&#xA;      -- `left` and `right` are always left and right.&#xA;      char_actions = function(motion)&#xA;        return {&#xA;          [&#34;;&#34;] = &#34;next&#34;, -- set to `right` to always go right&#xA;          [&#34;,&#34;] = &#34;prev&#34;, -- set to `left` to always go left&#xA;          -- clever-f style&#xA;          [motion:lower()] = &#34;next&#34;,&#xA;          [motion:upper()] = &#34;prev&#34;,&#xA;          -- jump2d style: same case goes next, opposite case goes prev&#xA;          -- [motion] = &#34;next&#34;,&#xA;          -- [motion:match(&#34;%l&#34;) and motion:upper() or motion:lower()] = &#34;prev&#34;,&#xA;        }&#xA;      end,&#xA;      search = { wrap = false },&#xA;      highlight = { backdrop = true },&#xA;      jump = { register = false },&#xA;    },&#xA;    -- options used for treesitter selections&#xA;    -- `require(&#34;flash&#34;).treesitter()`&#xA;    treesitter = {&#xA;      labels = &#34;abcdefghijklmnopqrstuvwxyz&#34;,&#xA;      jump = { pos = &#34;range&#34; },&#xA;      search = { incremental = false },&#xA;      label = { before = true, after = true, style = &#34;inline&#34; },&#xA;      highlight = {&#xA;        backdrop = false,&#xA;        matches = false,&#xA;      },&#xA;    },&#xA;    treesitter_search = {&#xA;      jump = { pos = &#34;range&#34; },&#xA;      search = { multi_window = true, wrap = true, incremental = false },&#xA;      remote_op = { restore = true },&#xA;      label = { before = true, after = true, style = &#34;inline&#34; },&#xA;    },&#xA;    -- options used for remote flash&#xA;    remote = {&#xA;      remote_op = { restore = true, motion = true },&#xA;    },&#xA;  },&#xA;  -- options for the floating window that shows the prompt,&#xA;  -- for regular jumps&#xA;  prompt = {&#xA;    enabled = true,&#xA;    prefix = { { &#34;‚ö°&#34;, &#34;FlashPromptIcon&#34; } },&#xA;    win_config = {&#xA;      relative = &#34;editor&#34;,&#xA;      width = 1, -- when &amp;lt;=1 it&#39;s a percentage of the editor width&#xA;      height = 1,&#xA;      row = -1, -- when negative it&#39;s an offset from the bottom&#xA;      col = 0, -- when negative it&#39;s an offset from the right&#xA;      zindex = 1000,&#xA;    },&#xA;  },&#xA;  -- options for remote operator pending mode&#xA;  remote_op = {&#xA;    -- restore window views and cursor position&#xA;    -- after doing a remote operation&#xA;    restore = false,&#xA;    -- For `jump.pos = &#34;range&#34;`, this setting is ignored.&#xA;    -- `true`: always enter a new motion when doing a remote operation&#xA;    -- `false`: use the window&#39;s cursor position and jump target&#xA;    -- `nil`: act as `true` for remote windows, `false` for the current window&#xA;    motion = false,&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;!-- config:end --&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;üöÄ Usage&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Treesitter&lt;/strong&gt;: &lt;code&gt;require(&#34;flash&#34;).treesitter(opts?)&lt;/code&gt; opens &lt;strong&gt;flash&lt;/strong&gt; in &lt;strong&gt;Treesitter&lt;/strong&gt; mode &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;use a jump label, or use &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;,&lt;/code&gt; to increase/decrease the selection&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;regular search&lt;/strong&gt;: search as you normally do, but enhanced with jump labels&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;f&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; motions: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;After typing &lt;code&gt;f{char}&lt;/code&gt; or &lt;code&gt;F{char},&lt;/code&gt; you can repeat the motion with &lt;code&gt;f&lt;/code&gt; or go to the previous match with &lt;code&gt;F&lt;/code&gt; to undo a jump.&lt;/li&gt; &#xA;   &lt;li&gt;Similarly, after typing &lt;code&gt;t{char}&lt;/code&gt; or &lt;code&gt;T{char},&lt;/code&gt; you can repeat the motion with &lt;code&gt;t&lt;/code&gt; or go to the previous match with &lt;code&gt;T&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;You can also go to the next match with &lt;code&gt;;&lt;/code&gt; or previous match with &lt;code&gt;,&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Any highlights clear automatically when moving, changing buffers, or pressing &lt;code&gt;&amp;lt;esc&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;toggle Search&lt;/strong&gt;: &lt;code&gt;require(&#34;flash&#34;).toggle(boolean?)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;toggles &lt;strong&gt;flash&lt;/strong&gt; on or off while using regular search&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Treesitter Search&lt;/strong&gt;: &lt;code&gt;require(&#34;flash&#34;).treesitter_search(opts?)&lt;/code&gt; opens &lt;strong&gt;flash&lt;/strong&gt; in &lt;strong&gt;Treesitter Search&lt;/strong&gt; mode &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;combination of &lt;strong&gt;Treesitter&lt;/strong&gt; and &lt;strong&gt;Search&lt;/strong&gt; modes&lt;/li&gt; &#xA;   &lt;li&gt;do something like &lt;code&gt;yR&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;you can now start typing a search pattern.&lt;/li&gt; &#xA;   &lt;li&gt;arround your matches, all the surrounding Treesitter nodes will be labeled.&lt;/li&gt; &#xA;   &lt;li&gt;select a label to perform the operator on the new selection&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;remote&lt;/strong&gt;: &lt;code&gt;require(&#34;flash&#34;).remote(opts?)&lt;/code&gt; opens &lt;strong&gt;flash&lt;/strong&gt; in &lt;strong&gt;remote&lt;/strong&gt; mode &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;equivalent to: &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  remote_op = {&#xA;    restore = true,&#xA;    motion = true,&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;   &lt;li&gt;this is only useful in operator pending mode.&lt;/li&gt; &#xA;   &lt;li&gt;For example, press &lt;code&gt;yr&lt;/code&gt; to start yanking and open flash &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;select a label to set the cursor position&lt;/li&gt; &#xA;     &lt;li&gt;perform any motion, like &lt;code&gt;iw&lt;/code&gt; or even start flash Treesitter with &lt;code&gt;S&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;the yank will be performed on the new selection&lt;/li&gt; &#xA;     &lt;li&gt;you&#39;ll be back in the original window / position&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;You can also configure the &lt;code&gt;remote_op&lt;/code&gt; options by default, so that &lt;code&gt;ys&lt;/code&gt;, behaves like &lt;code&gt;yr&lt;/code&gt; for remote operations &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  remote_op = {&#xA;    restore = true,&#xA;    motion = nil,&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;jump&lt;/strong&gt;: &lt;code&gt;require(&#34;flash&#34;).jump(opts?)&lt;/code&gt; opens &lt;strong&gt;flash&lt;/strong&gt; with the given options &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;type any number of characters before typing a jump label&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;VS Code&lt;/strong&gt;: some functionality is changed/disabled when running &lt;strong&gt;flash&lt;/strong&gt; in &lt;strong&gt;VS Code&lt;/strong&gt;: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;prompt&lt;/code&gt; is disabled&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;highlights&lt;/code&gt; are set to different defaults that will actually work in VS Code&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;search.multi_window&lt;/code&gt; is disabled, since VS Code has problems with &lt;code&gt;vim.api.nvim_set_current_win&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üì° API&lt;/h2&gt; &#xA;&lt;p&gt;The options for &lt;code&gt;require(&#34;flash&#34;).jump(opts?)&lt;/code&gt;, are the same as those in the config section, but can additionally have the following fields:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;matcher&lt;/code&gt;: a custom function that generates matches for a given window&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;labeler&lt;/code&gt;: a custom function to label matches&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can also add labels in the &lt;code&gt;matcher&lt;/code&gt; function and then set &lt;code&gt;labeler&lt;/code&gt; to an empty function &lt;code&gt;labeler = function() end&lt;/code&gt;&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Type Definitions&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;type FlashMatcher = (win: number, state: FlashState) =&amp;gt; FlashMatch[];&#xA;type FlashLabeler = (matches: FlashMatch[], state: FlashState) =&amp;gt; void;&#xA;&#xA;interface FlashMatch {&#xA;  win: number;&#xA;  pos: [number, number]; // (1,0)-indexed&#xA;  end_pos: [number, number]; // (1,0)-indexed&#xA;  label?: string | false; // set to false to never show a label for this match&#xA;  highlight?: boolean; // override opts.highlight.matches for this match&#xA;}&#xA;&#xA;// Check the code for the full definition&#xA;// of Flash.State at `lua/flash/state.lua`&#xA;type FlashState = {};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;üí° Examples&lt;/h2&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Forward search only&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  search = { forward = true, wrap = false, multi_window = false },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Backward search only&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  search = { forward = false, wrap = false, multi_window = false },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Show diagnostics at target, without changing cursor position&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  action = function(match, state)&#xA;    vim.api.nvim_win_call(match.win, function()&#xA;      vim.api.nvim_win_set_cursor(match.win, match.pos)&#xA;      vim.diagnostic.open_float()&#xA;    end)&#xA;    state:restore()&#xA;  end,&#xA;})&#xA;&#xA;-- More advanced example that also highlights diagnostics:&#xA;require(&#34;flash&#34;).jump({&#xA;  matcher = function(win)&#xA;    ---@param diag Diagnostic&#xA;    return vim.tbl_map(function(diag)&#xA;      return {&#xA;        pos = { diag.lnum + 1, diag.col },&#xA;        end_pos = { diag.end_lnum + 1, diag.end_col - 1 },&#xA;      }&#xA;    end, vim.diagnostic.get(vim.api.nvim_win_get_buf(win)))&#xA;  end,&#xA;  action = function(match, state)&#xA;    vim.api.nvim_win_call(match.win, function()&#xA;      vim.api.nvim_win_set_cursor(match.win, match.pos)&#xA;      vim.diagnostic.open_float()&#xA;    end)&#xA;    state:restore()&#xA;  end,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Match beginning of words only&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  search = {&#xA;    mode = function(str)&#xA;      return &#34;\\&amp;lt;&#34; .. str&#xA;    end,&#xA;  },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Initialize flash with the word under the cursor&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  pattern = vim.fn.expand(&#34;&amp;lt;cword&amp;gt;&#34;),&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Jump to a line&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  search = { mode = &#34;search&#34;, max_length = 0 },&#xA;  label = { after = { 0, 0 } },&#xA;  pattern = &#34;^&#34;&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Select any word&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({&#xA;  pattern = &#34;.&#34;, -- initialize pattern with any char&#xA;  search = {&#xA;    mode = function(pattern)&#xA;      -- remove leading dot&#xA;      if pattern:sub(1, 1) == &#34;.&#34; then&#xA;        pattern = pattern:sub(2)&#xA;      end&#xA;      -- return word pattern and proper skip pattern&#xA;      return ([[\v&amp;lt;%s\w*&amp;gt;]]):format(pattern), ([[\v&amp;lt;%s]]):format(pattern)&#xA;    end,&#xA;  },&#xA;  -- select the range&#xA;  jump = { pos = &#34;range&#34; },&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;&lt;code&gt;f&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; with labels&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- to use this, make sure to set `opts.modes.char.enabled = false`&#xA;local Config = require(&#34;flash.config&#34;)&#xA;local Char = require(&#34;flash.plugins.char&#34;)&#xA;for _, motion in ipairs({ &#34;f&#34;, &#34;t&#34;, &#34;F&#34;, &#34;T&#34; }) do&#xA;  vim.keymap.set({ &#34;n&#34;, &#34;x&#34;, &#34;o&#34; }, motion, function()&#xA;    require(&#34;flash&#34;).jump(Config.get({&#xA;      mode = &#34;char&#34;,&#xA;      search = {&#xA;        mode = Char.mode(motion),&#xA;        max_length = 1,&#xA;      },&#xA;    }, Char.motions[motion]))&#xA;  end)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Telescope integration&lt;/summary&gt; &#xA; &lt;p&gt;This will allow you to use &lt;code&gt;s&lt;/code&gt; in normal mode and &lt;code&gt;&amp;lt;c-s&amp;gt;&lt;/code&gt; in insert mode, to jump to a label in Telescope results.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;{&#xA;    &#34;nvim-telescope/telescope.nvim&#34;,&#xA;    optional = true,&#xA;    opts = function(_, opts)&#xA;      local function flash(prompt_bufnr)&#xA;        require(&#34;flash&#34;).jump({&#xA;          pattern = &#34;^&#34;,&#xA;          label = { after = { 0, 0 } },&#xA;          search = {&#xA;            mode = &#34;search&#34;,&#xA;            exclude = {&#xA;              function(win)&#xA;                return vim.bo[vim.api.nvim_win_get_buf(win)].filetype ~= &#34;TelescopeResults&#34;&#xA;              end,&#xA;            },&#xA;          },&#xA;          action = function(match)&#xA;            local picker = require(&#34;telescope.actions.state&#34;).get_current_picker(prompt_bufnr)&#xA;            picker:set_selection(match.pos[1] - 1)&#xA;          end,&#xA;        })&#xA;      end&#xA;      opts.defaults = vim.tbl_deep_extend(&#34;force&#34;, opts.defaults or {}, {&#xA;        mappings = {&#xA;          n = { s = flash },&#xA;          i = { [&#34;&amp;lt;c-s&amp;gt;&#34;] = flash },&#xA;        },&#xA;      })&#xA;    end,&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Continue last search&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;flash&#34;).jump({continue = true})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;2-char jump, similar to &lt;a href=&#34;https://github.com/echasnovski/mini.nvim/raw/main/readmes/mini-jump2d.md&#34;&gt; mini.jump2d &lt;/a&gt; or &lt;a href=&#34;https://github.com/phaazon/hop.nvim&#34;&gt; HopWord (hop.nvim) &lt;/a&gt; &lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local Flash = require(&#34;flash&#34;)&#xA;&#xA;---@param opts Flash.Format&#xA;local function format(opts)&#xA;  -- always show first and second label&#xA;  return {&#xA;    { opts.match.label1, &#34;FlashMatch&#34; },&#xA;    { opts.match.label2, &#34;FlashLabel&#34; },&#xA;  }&#xA;end&#xA;&#xA;Flash.jump({&#xA;  search = { mode = &#34;search&#34; },&#xA;  label = { after = false, before = { 0, 0 }, uppercase = false, format = format },&#xA;  pattern = [[\&amp;lt;]],&#xA;  action = function(match, state)&#xA;    state:hide()&#xA;    Flash.jump({&#xA;      search = { max_length = 0 },&#xA;      highlight = { matches = false },&#xA;      label = { format = format },&#xA;      matcher = function(win)&#xA;        -- limit matches to the current label&#xA;        return vim.tbl_filter(function(m)&#xA;          return m.label == match.label and m.win == win&#xA;        end, state.results)&#xA;      end,&#xA;      labeler = function(matches)&#xA;        for _, m in ipairs(matches) do&#xA;          m.label = m.label2 -- use the second label&#xA;        end&#xA;      end,&#xA;    })&#xA;  end,&#xA;  labeler = function(matches, state)&#xA;    local labels = state:labels()&#xA;    for m, match in ipairs(matches) do&#xA;      match.label1 = labels[math.floor((m - 1) / #labels) + 1]&#xA;      match.label2 = labels[(m - 1) % #labels + 1]&#xA;      match.label = match.label1&#xA;    end&#xA;  end,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;üåà Highlights&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Group&lt;/th&gt; &#xA;   &lt;th&gt;Default&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;FlashBackdrop&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Comment&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;backdrop&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;FlashMatch&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Search&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;search matches&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;FlashCurrent&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;IncSearch&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;current match&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;FlashLabel&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Substitute&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;jump label&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;üì¶ Alternatives&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ggandor/leap.nvim&#34;&gt;leap.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ggandor/lightspeed.nvim&#34;&gt;lightspeed.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/justinmk/vim-sneak&#34;&gt;vim-sneak&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/echasnovski/mini.nvim/raw/main/readmes/mini-jump.md&#34;&gt;mini.jump&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/echasnovski/mini.nvim/raw/main/readmes/mini-jump2d.md&#34;&gt;mini.jump2d&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/phaazon/hop.nvim&#34;&gt;hop.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rlane/pounce.nvim&#34;&gt;pounce.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/woosaaahh/sj.nvim&#34;&gt;sj.nvim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mfussenegger/nvim-treehopper&#34;&gt;nvim-treehopper&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ggandor/flit.nvim&#34;&gt;flit.nvim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>zbirenbaum/copilot.lua</title>
    <updated>2023-07-09T01:59:04Z</updated>
    <id>tag:github.com,2023-07-09:/zbirenbaum/copilot.lua</id>
    <link href="https://github.com/zbirenbaum/copilot.lua" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fully featured &amp; enhanced replacement for copilot.vim complete with API for interacting with Github Copilot&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;copilot.lua&lt;/h1&gt; &#xA;&lt;p&gt;This plugin is the pure lua replacement for &lt;a href=&#34;https://github.com/github/copilot.vim&#34;&gt;github/copilot.vim&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Motivation behind `copilot.lua`&lt;/summary&gt; &#xA; &lt;p&gt;While using &lt;code&gt;copilot.vim&lt;/code&gt;, for the first time since I started using neovim my laptop began to overheat. Additionally, I found the large chunks of ghost text moving around my code, and interfering with my existing cmp ghost text disturbing. As lua is far more efficient and makes things easier to integrate with modern plugins, this repository was created.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;Install the plugin with your preferred plugin manager. For example, with &lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;packer.nvim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use { &#34;zbirenbaum/copilot.lua&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Authentication&lt;/h3&gt; &#xA;&lt;p&gt;Once copilot is running, run &lt;code&gt;:Copilot auth&lt;/code&gt; to start the authentication process.&lt;/p&gt; &#xA;&lt;h2&gt;Setup and Configuration&lt;/h2&gt; &#xA;&lt;p&gt;You have to run the &lt;code&gt;require(&#34;copilot&#34;).setup(options)&lt;/code&gt; function in order to start Copilot. If no options are provided, the defaults are used.&lt;/p&gt; &#xA;&lt;p&gt;Because the copilot server takes some time to start up, it is recommend that you lazy load copilot. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;use {&#xA;  &#34;zbirenbaum/copilot.lua&#34;,&#xA;  cmd = &#34;Copilot&#34;,&#xA;  event = &#34;InsertEnter&#34;,&#xA;  config = function()&#xA;    require(&#34;copilot&#34;).setup({})&#xA;  end,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following is the default configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#39;copilot&#39;).setup({&#xA;  panel = {&#xA;    enabled = true,&#xA;    auto_refresh = false,&#xA;    keymap = {&#xA;      jump_prev = &#34;[[&#34;,&#xA;      jump_next = &#34;]]&#34;,&#xA;      accept = &#34;&amp;lt;CR&amp;gt;&#34;,&#xA;      refresh = &#34;gr&#34;,&#xA;      open = &#34;&amp;lt;M-CR&amp;gt;&#34;&#xA;    },&#xA;    layout = {&#xA;      position = &#34;bottom&#34;, -- | top | left | right&#xA;      ratio = 0.4&#xA;    },&#xA;  },&#xA;  suggestion = {&#xA;    enabled = true,&#xA;    auto_trigger = false,&#xA;    debounce = 75,&#xA;    keymap = {&#xA;      accept = &#34;&amp;lt;M-l&amp;gt;&#34;,&#xA;      accept_word = false,&#xA;      accept_line = false,&#xA;      next = &#34;&amp;lt;M-]&amp;gt;&#34;,&#xA;      prev = &#34;&amp;lt;M-[&amp;gt;&#34;,&#xA;      dismiss = &#34;&amp;lt;C-]&amp;gt;&#34;,&#xA;    },&#xA;  },&#xA;  filetypes = {&#xA;    yaml = false,&#xA;    markdown = false,&#xA;    help = false,&#xA;    gitcommit = false,&#xA;    gitrebase = false,&#xA;    hgcommit = false,&#xA;    svn = false,&#xA;    cvs = false,&#xA;    [&#34;.&#34;] = false,&#xA;  },&#xA;  copilot_node_command = &#39;node&#39;, -- Node.js version must be &amp;gt; 16.x&#xA;  server_opts_overrides = {},&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;panel&lt;/h3&gt; &#xA;&lt;p&gt;Panel can be used to preview suggestions in a split window. You can run the &lt;code&gt;:Copilot panel&lt;/code&gt; command to open it.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;auto_refresh&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the suggestions are refreshed as you type in the buffer.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;copilot.panel&lt;/code&gt; module exposes the following functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;copilot.panel&#34;).accept()&#xA;require(&#34;copilot.panel&#34;).jump_next()&#xA;require(&#34;copilot.panel&#34;).jump_prev()&#xA;require(&#34;copilot.panel&#34;).open({postion, ratio})&#xA;require(&#34;copilot.panel&#34;).refresh()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;suggestion&lt;/h3&gt; &#xA;&lt;p&gt;When &lt;code&gt;auto_trigger&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, copilot starts suggesting as soon as you enter insert mode.&lt;/p&gt; &#xA;&lt;p&gt;When &lt;code&gt;auto_trigger&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, use the &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;prev&lt;/code&gt; keymap to trigger copilot suggestion.&lt;/p&gt; &#xA;&lt;p&gt;To toggle auto trigger for the current buffer, use &lt;code&gt;require(&#34;copilot.suggestion&#34;).toggle_auto_trigger()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Copilot suggestion is automatically hidden when &lt;code&gt;popupmenu-completion&lt;/code&gt; is open. In case you use a custom menu for completion, you can set the &lt;code&gt;copilot_suggestion_hidden&lt;/code&gt; buffer variable to &lt;code&gt;true&lt;/code&gt; to have the same behavior. For example, with &lt;code&gt;nvim-cmp&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;cmp.event:on(&#34;menu_opened&#34;, function()&#xA;  vim.b.copilot_suggestion_hidden = true&#xA;end)&#xA;&#xA;cmp.event:on(&#34;menu_closed&#34;, function()&#xA;  vim.b.copilot_suggestion_hidden = false&#xA;end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;copilot.suggestion&lt;/code&gt; module exposes the following functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;copilot.suggestion&#34;).is_visible()&#xA;require(&#34;copilot.suggestion&#34;).accept(modifier)&#xA;require(&#34;copilot.suggestion&#34;).accept_word()&#xA;require(&#34;copilot.suggestion&#34;).accept_line()&#xA;require(&#34;copilot.suggestion&#34;).next()&#xA;require(&#34;copilot.suggestion&#34;).prev()&#xA;require(&#34;copilot.suggestion&#34;).dismiss()&#xA;require(&#34;copilot.suggestion&#34;).toggle_auto_trigger()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;filetypes&lt;/h3&gt; &#xA;&lt;p&gt;Specify filetypes for attaching copilot.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;copilot&#34;).setup {&#xA;  filetypes = {&#xA;    markdown = true, -- overrides default&#xA;    terraform = false, -- disallow specific filetype&#xA;    sh = function ()&#xA;      if string.match(vim.fs.basename(vim.api.nvim_buf_get_name(0)), &#39;^%.env.*&#39;) then&#xA;        -- disable for .env files&#xA;        return false&#xA;      end&#xA;      return true&#xA;    end,&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you add &lt;code&gt;&#34;*&#34;&lt;/code&gt; as a filetype, the default configuration for &lt;code&gt;filetypes&lt;/code&gt; won&#39;t be used anymore. e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;copilot&#34;).setup {&#xA;  filetypes = {&#xA;    javascript = true, -- allow specific filetype&#xA;    typescript = true, -- allow specific filetype&#xA;    [&#34;*&#34;] = false, -- disable for all other filetypes and ignore default `filetypes`&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;copilot_node_command&lt;/h3&gt; &#xA;&lt;p&gt;Use this field to provide the path to a specific node version such as one installed by nvm. Node.js version must be 16.x or newer.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;copilot_node_command = vim.fn.expand(&#34;$HOME&#34;) .. &#34;/.config/nvm/versions/node/v16.14.2/bin/node&#34;, -- Node.js version must be &amp;gt; 16.x&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;server_opts_overrides&lt;/h3&gt; &#xA;&lt;p&gt;Override copilot lsp client settings. The &lt;code&gt;settings&lt;/code&gt; field is where you can set the values of the options defined in &lt;a href=&#34;https://raw.githubusercontent.com/zbirenbaum/copilot.lua/master/SettingsOpts.md&#34;&gt;SettingsOpts.md&lt;/a&gt;. These options are specific to the copilot lsp and can be used to customize its behavior. Ensure that the name field is not overriden as is is used for efficiency reasons in numerous checks to verify copilot is actually running. See &lt;code&gt;:h vim.lsp.start_client&lt;/code&gt; for list of options.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&#34;copilot&#34;).setup {&#xA;  server_opts_overrides = {&#xA;    trace = &#34;verbose&#34;,&#xA;    settings = {&#xA;      advanced = {&#xA;        listCount = 10, -- #completions for panel&#xA;        inlineSuggestCount = 3, -- #completions for getCompletions&#xA;      }&#xA;    },&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Commands&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;copilot.lua&lt;/code&gt; defines the &lt;code&gt;:Copilot&lt;/code&gt; command that can perform various actions. It has completion support, so try it out.&lt;/p&gt; &#xA;&lt;h2&gt;Integrations&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;copilot.api&lt;/code&gt; module can be used to build integrations on top of &lt;code&gt;copilot.lua&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/zbirenbaum/copilot-cmp&#34;&gt;zbirenbaum/copilot-cmp&lt;/a&gt;: Integration with &lt;a href=&#34;https://github.com/hrsh7th/nvim-cmp&#34;&gt;&lt;code&gt;nvim-cmp&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>NeogitOrg/neogit</title>
    <updated>2023-07-09T01:59:04Z</updated>
    <id>tag:github.com,2023-07-09:/NeogitOrg/neogit</id>
    <link href="https://github.com/NeogitOrg/neogit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;magit for neovim&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Neogit&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/32014449/109874516-8042af00-7c6f-11eb-8afc-65ef52448c7a.png&#34; alt=&#34;preview&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A &lt;strong&gt;work-in-progress&lt;/strong&gt; &lt;a href=&#34;https://magit.vc&#34;&gt;Magit&lt;/a&gt; clone for &lt;a href=&#34;https://neovim.io&#34;&gt;Neovim&lt;/a&gt; that is geared toward the Vim philosophy.&lt;/p&gt; &#xA;&lt;h2&gt;Notice&lt;/h2&gt; &#xA;&lt;p&gt;Neogit has moved to an organization at &lt;a href=&#34;https://github.com/NeogitOrg/neogit/issues&#34;&gt;https://github.com/NeogitOrg/neogit/issues&lt;/a&gt; to ensure the longevity of this project and ensure that it is more accessible to collaborators.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: We depend on &lt;a href=&#34;https://github.com/nvim-lua/plenary.nvim&#34;&gt;plenary.nvim&lt;/a&gt;, so to use this plugin, you will additionally need to require &lt;code&gt;nvim-lua/plenary.nvim&lt;/code&gt; using your plugin manager of choice, before requiring this plugin.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Plugin Manager&lt;/th&gt; &#xA;   &lt;th&gt;Command&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/folke/lazy.nvim&#34;&gt;Lazy&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;return { &#39;NeogitOrg/neogit&#39;, dependencies = &#39;nvim-lua/plenary.nvim&#39; }&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/wbthomason/packer.nvim&#34;&gt;Packer&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;use { &#39;NeogitOrg/neogit&#39;, requires = &#39;nvim-lua/plenary.nvim&#39; }&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/junegunn/vim-plug&#34;&gt;Vim-plug&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Plug &#39;NeogitOrg/neogit&#39;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Shougo/neobundle.vim&#34;&gt;NeoBundle&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;NeoBundle &#39;NeogitOrg/neogit&#39;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/VundleVim/Vundle.vim&#34;&gt;Vundle&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Bundle &#39;NeogitOrg/neogit&#39;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/tpope/vim-pathogen&#34;&gt;Pathogen&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;git clone https://github.com/NeogitOrg/neogit.git ~/.vim/bundle/neogit&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Shougo/dein.vim&#34;&gt;Dein&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;call dein#add(&#39;NeogitOrg/neogit&#39;)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/chiyadev/dep&#34;&gt;Dep&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;{&#39;NeogitOrg/neogit&#39;, requires = {&#39;nvim-lua/plenary.nvim&#39;}}&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;You also use in the built-in package manager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone --depth 1 https://github.com/NeogitOrg/neogit $XDG_CONFIG_HOME/nvim/pack/plugins/start/neogit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you have to add the following lines to your &lt;code&gt;init.lua&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local neogit = require(&#39;neogit&#39;)&#xA;&#xA;neogit.setup {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;You can either open neogit by using the &lt;code&gt;Neogit&lt;/code&gt; command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;:Neogit &#34; Open the status buffer in a new tab&#xA;:Neogit cwd=&amp;lt;cwd&amp;gt; &#34; Use a different repository path&#xA;:Neogit cwd=%:p:h &#34; Uses the repository of the current file&#xA;&#xA;:Neogit kind=&amp;lt;kind&amp;gt; &#34; Open specified popup directly&#xA;&#xA;:Neogit commit &#34; Open commit popup&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or using the lua api:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local neogit = require(&#39;neogit&#39;)&#xA;&#xA;-- open using defaults&#xA;neogit.open()&#xA;&#xA;-- open commit popup&#xA;neogit.open({ &#34;commit&#34; })&#xA;&#xA;-- open with split kind&#xA;neogit.open({ kind = &#34;split&#34; })&#xA;&#xA;-- open home directory&#xA;neogit.open({ cwd = &#34;~&#34; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The create function takes 1 optional argument that can be one of the following values:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;tab (default)&lt;/li&gt; &#xA; &lt;li&gt;replace&lt;/li&gt; &#xA; &lt;li&gt;floating (This currently doesn&#39;t work with popups. Very unstable)&lt;/li&gt; &#xA; &lt;li&gt;split&lt;/li&gt; &#xA; &lt;li&gt;split_above&lt;/li&gt; &#xA; &lt;li&gt;vsplit&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Status Keybindings&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Keybinding&lt;/th&gt; &#xA;   &lt;th&gt;Function&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Tab&lt;/td&gt; &#xA;   &lt;td&gt;Toggle diff&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1, 2, 3, 4&lt;/td&gt; &#xA;   &lt;td&gt;Set a foldlevel&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;$&lt;/td&gt; &#xA;   &lt;td&gt;Command history&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;b&lt;/td&gt; &#xA;   &lt;td&gt;Branch popup&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;s&lt;/td&gt; &#xA;   &lt;td&gt;Stage (also supports staging selection/hunk)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;S&lt;/td&gt; &#xA;   &lt;td&gt;Stage unstaged changes&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&amp;lt;C-s&amp;gt;&lt;/td&gt; &#xA;   &lt;td&gt;Stage Everything&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;u&lt;/td&gt; &#xA;   &lt;td&gt;Unstage (also supports staging selection/hunk)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;U&lt;/td&gt; &#xA;   &lt;td&gt;Unstage staged changes&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;c&lt;/td&gt; &#xA;   &lt;td&gt;Open commit popup&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;r&lt;/td&gt; &#xA;   &lt;td&gt;Open rebase popup&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;m&lt;/td&gt; &#xA;   &lt;td&gt;Open merge popup&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;f&lt;/td&gt; &#xA;   &lt;td&gt;Open fetch popup&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;L&lt;/td&gt; &#xA;   &lt;td&gt;Open log popup&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;p&lt;/td&gt; &#xA;   &lt;td&gt;Open pull popup&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;P&lt;/td&gt; &#xA;   &lt;td&gt;Open push popup&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Z&lt;/td&gt; &#xA;   &lt;td&gt;Open stash popup&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;?&lt;/td&gt; &#xA;   &lt;td&gt;Open help popup&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;x&lt;/td&gt; &#xA;   &lt;td&gt;Discard changes (also supports discarding hunks)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&amp;lt;enter&amp;gt;&lt;/td&gt; &#xA;   &lt;td&gt;Go to file&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&amp;lt;C-r&amp;gt;&lt;/td&gt; &#xA;   &lt;td&gt;Refresh Buffer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;With &lt;code&gt;diffview&lt;/code&gt; integration enabled&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Keybinding&lt;/th&gt; &#xA;   &lt;th&gt;Function&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;d&lt;/td&gt; &#xA;   &lt;td&gt;Open &lt;code&gt;diffview.nvim&lt;/code&gt; at hovered file&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;D (TODO)&lt;/td&gt; &#xA;   &lt;td&gt;Open diff popup&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;You can configure neogit by running the &lt;code&gt;neogit.setup&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local neogit = require(&#34;neogit&#34;)&#xA;&#xA;neogit.setup {&#xA;  disable_signs = false,&#xA;  disable_hint = false,&#xA;  disable_context_highlighting = false,&#xA;  disable_commit_confirmation = false,&#xA;  -- Neogit refreshes its internal state after specific events, which can be expensive depending on the repository size.&#xA;  -- Disabling `auto_refresh` will make it so you have to manually refresh the status after you open it.&#xA;  auto_refresh = true,&#xA;  -- Value used for `--sort` option for `git branch` command&#xA;  -- By default, branches will be sorted by commit date descending&#xA;  -- Flag description: https://git-scm.com/docs/git-branch#Documentation/git-branch.txt---sortltkeygt&#xA;  -- Sorting keys: https://git-scm.com/docs/git-for-each-ref#_options&#xA;  sort_branches = &#34;-committerdate&#34;,&#xA;  disable_builtin_notifications = false,&#xA;  use_magit_keybindings = false,&#xA;  -- Change the default way of opening neogit&#xA;  kind = &#34;tab&#34;,&#xA;  -- The time after which an output console is shown for slow running commands&#xA;  console_timeout = 2000,&#xA;  -- Automatically show console if a command takes more than console_timeout milliseconds&#xA;  auto_show_console = true,&#xA;  -- Persist the values of switches/options within and across sessions&#xA;  remember_settings = true,&#xA;  -- Scope persisted settings on a per-project basis&#xA;  use_per_project_settings = true,&#xA;  -- Array-like table of settings to never persist. Uses format &#34;Filetype--cli-value&#34;&#xA;  --   ie: `{ &#34;NeogitCommitPopup--author&#34;, &#34;NeogitCommitPopup--no-verify&#34; }`&#xA;  ignored_settings = {},&#xA;  -- Change the default way of opening the commit popup&#xA;  commit_popup = {&#xA;    kind = &#34;split&#34;,&#xA;  },&#xA;  -- Change the default way of opening the preview buffer&#xA;  preview_buffer = {&#xA;    kind = &#34;split&#34;,&#xA;  },&#xA;  -- Change the default way of opening popups&#xA;  popup = {&#xA;    kind = &#34;split&#34;,&#xA;  },&#xA;  -- customize displayed signs&#xA;  signs = {&#xA;    -- { CLOSED, OPENED }&#xA;    section = { &#34;&amp;gt;&#34;, &#34;v&#34; },&#xA;    item = { &#34;&amp;gt;&#34;, &#34;v&#34; },&#xA;    hunk = { &#34;&#34;, &#34;&#34; },&#xA;  },&#xA;  integrations = {&#xA;    -- Neogit only provides inline diffs. If you want a more traditional way to look at diffs, you can use `sindrets/diffview.nvim`.&#xA;    -- The diffview integration enables the diff popup, which is a wrapper around `sindrets/diffview.nvim`.&#xA;    --&#xA;    -- Requires you to have `sindrets/diffview.nvim` installed.&#xA;    -- use {&#xA;    --   &#39;TimUntersberger/neogit&#39;,&#xA;    --   requires = {&#xA;    --     &#39;nvim-lua/plenary.nvim&#39;,&#xA;    --     &#39;sindrets/diffview.nvim&#39;&#xA;    --   }&#xA;    -- }&#xA;    --&#xA;    diffview = false&#xA;  },&#xA;  -- Setting any section to `false` will make the section not render at all&#xA;  sections = {&#xA;    untracked = {&#xA;      folded = false&#xA;    },&#xA;    unstaged = {&#xA;      folded = false&#xA;    },&#xA;    staged = {&#xA;      folded = false&#xA;    },&#xA;    stashes = {&#xA;      folded = true&#xA;    },&#xA;    unpulled = {&#xA;      folded = true&#xA;    },&#xA;    unmerged = {&#xA;      folded = false&#xA;    },&#xA;    recent = {&#xA;      folded = true&#xA;    },&#xA;  },&#xA;  -- override/add mappings&#xA;  mappings = {&#xA;    -- modify status buffer mappings&#xA;    status = {&#xA;      -- Adds a mapping with &#34;B&#34; as key that does the &#34;BranchPopup&#34; command&#xA;      [&#34;B&#34;] = &#34;BranchPopup&#34;,&#xA;      -- Removes the default mapping of &#34;s&#34;&#xA;      [&#34;s&#34;] = &#34;&#34;,&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Right now, only the status buffer supports custom mappings.&lt;/p&gt; &#xA;&lt;p&gt;List of status commands:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Close&lt;/li&gt; &#xA; &lt;li&gt;InitRepo&lt;/li&gt; &#xA; &lt;li&gt;Depth1 (Set foldlevel to 1)&lt;/li&gt; &#xA; &lt;li&gt;Depth2 (Set foldlevel to 2)&lt;/li&gt; &#xA; &lt;li&gt;Depth3 (Set foldlevel to 3)&lt;/li&gt; &#xA; &lt;li&gt;Depth4 (Set foldlevel to 4)&lt;/li&gt; &#xA; &lt;li&gt;Toggle&lt;/li&gt; &#xA; &lt;li&gt;Discard (Normal and visual mode)&lt;/li&gt; &#xA; &lt;li&gt;Stage (Normal and visual mode)&lt;/li&gt; &#xA; &lt;li&gt;StageUnstaged&lt;/li&gt; &#xA; &lt;li&gt;StageAll&lt;/li&gt; &#xA; &lt;li&gt;GoToFile&lt;/li&gt; &#xA; &lt;li&gt;Unstage (Normal and visual mode)&lt;/li&gt; &#xA; &lt;li&gt;UnstageStaged&lt;/li&gt; &#xA; &lt;li&gt;CommandHistory&lt;/li&gt; &#xA; &lt;li&gt;RefreshBuffer&lt;/li&gt; &#xA; &lt;li&gt;HelpPopup&lt;/li&gt; &#xA; &lt;li&gt;PullPopup&lt;/li&gt; &#xA; &lt;li&gt;PushPopup&lt;/li&gt; &#xA; &lt;li&gt;FetchPopup&lt;/li&gt; &#xA; &lt;li&gt;CommitPopup&lt;/li&gt; &#xA; &lt;li&gt;LogPopup&lt;/li&gt; &#xA; &lt;li&gt;StashPopup&lt;/li&gt; &#xA; &lt;li&gt;BranchPopup&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Notification Highlighting&lt;/h2&gt; &#xA;&lt;p&gt;Neogit defines three highlight groups for the notifications:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;hi NeogitNotificationInfo guifg=#80ff95&#xA;hi NeogitNotificationWarning guifg=#fff454&#xA;hi NeogitNotificationError guifg=#c44323&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can override them to fit your colorscheme in your vim configuration.&lt;/p&gt; &#xA;&lt;h2&gt;Contextual Highlighting&lt;/h2&gt; &#xA;&lt;p&gt;The colors for contextual highlighting are defined with these highlight groups:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;hi def NeogitDiffAddHighlight guibg=#404040 guifg=#859900&#xA;hi def NeogitDiffDeleteHighlight guibg=#404040 guifg=#dc322f&#xA;hi def NeogitDiffContextHighlight guibg=#333333 guifg=#b2b2b2&#xA;hi def NeogitHunkHeader guifg=#cccccc guibg=#404040&#xA;hi def NeogitHunkHeaderHighlight guifg=#cccccc guibg=#4d4d4d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can override them to fit your colorscheme by creating a &lt;code&gt;syntax/NeogitStatus.vim&lt;/code&gt; in your vim configuration and adding your custom highlights there.&lt;/p&gt; &#xA;&lt;h3&gt;Disabling Contextual Highlighting&lt;/h3&gt; &#xA;&lt;p&gt;Set &lt;code&gt;disable_context_highlighting = true&lt;/code&gt; in your call to &lt;a href=&#34;https://raw.githubusercontent.com/NeogitOrg/neogit/master/#configuration&#34;&gt;&lt;code&gt;setup&lt;/code&gt;&lt;/a&gt; to disable context highlighting altogether.&lt;/p&gt; &#xA;&lt;h2&gt;Disabling Hint&lt;/h2&gt; &#xA;&lt;p&gt;Set &lt;code&gt;disable_hint = true&lt;/code&gt; in your call to &lt;a href=&#34;https://raw.githubusercontent.com/NeogitOrg/neogit/master/#configuration&#34;&gt;&lt;code&gt;setup&lt;/code&gt;&lt;/a&gt; to hide hints on top of the panel.&lt;/p&gt; &#xA;&lt;h2&gt;Disabling Commit Confirmation&lt;/h2&gt; &#xA;&lt;p&gt;Set &lt;code&gt;disable_commit_confirmation = true&lt;/code&gt; in your call to &lt;a href=&#34;https://raw.githubusercontent.com/NeogitOrg/neogit/master/#configuration&#34;&gt;&lt;code&gt;setup&lt;/code&gt;&lt;/a&gt; to disable the &#34;Are you sure you want to commit?&#34; prompt after saving the commit message buffer.&lt;/p&gt; &#xA;&lt;h2&gt;Disabling Insert On Commit&lt;/h2&gt; &#xA;&lt;p&gt;Set &lt;code&gt;disable_insert_on_commit = true&lt;/code&gt; in your call to &lt;a href=&#34;https://raw.githubusercontent.com/NeogitOrg/neogit/master/#configuration&#34;&gt;&lt;code&gt;setup&lt;/code&gt;&lt;/a&gt; to disable automatically changing to insert mode when opening the commit message buffer. (Disabled is the default)&lt;/p&gt; &#xA;&lt;h2&gt;Events&lt;/h2&gt; &#xA;&lt;p&gt;Neogit emits the following events:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Event&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;NeogitStatusRefreshed&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Status has been reloaded&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;NeogitCommitComplete&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Commit has been created&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;NeogitPushComplete&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Push has completed&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;NeogitPullComplete&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Pull has completed&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;NeogitFetchComplete&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Fetch has completed&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;You can listen to the events using the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;autocmd User NeogitStatusRefreshed echom &#34;Hello World!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, if you prefer to configure autocommands via Lua:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local group = vim.api.nvim_create_augroup(&#39;MyCustomNeogitEvents&#39;, { clear = true })&#xA;vim.api.nvim_create_autocmd(&#39;User&#39;, {&#xA;  pattern = &#39;NeogitPushComplete&#39;,&#xA;  group = group,&#xA;  callback = require(&#39;neogit&#39;).close,&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Magit-style Keybindings&lt;/h2&gt; &#xA;&lt;p&gt;Neogit uses &#39;p&#39; for pulling instead of &#39;F&#39;.&lt;/p&gt; &#xA;&lt;p&gt;Set &lt;code&gt;use_magit_keybindings = true&lt;/code&gt; in your call to &lt;a href=&#34;https://raw.githubusercontent.com/NeogitOrg/neogit/master/#configuration&#34;&gt;&lt;code&gt;setup&lt;/code&gt;&lt;/a&gt; to use magit-style keybindings.&lt;/p&gt; &#xA;&lt;h2&gt;Refreshing Neogit&lt;/h2&gt; &#xA;&lt;p&gt;If you would like to refresh Neogit manually, you can use &lt;code&gt;neogit#refresh_manually&lt;/code&gt; in Vimscript or &lt;code&gt;require(&#39;neogit&#39;).refresh_manually&lt;/code&gt; in lua. They both require a single file parameter.&lt;/p&gt; &#xA;&lt;p&gt;This allows you to refresh Neogit on your own custom events&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;augroup DefaultRefreshEvents&#xA;  au!&#xA;  au BufWritePost,BufEnter,FocusGained,ShellCmdPost,VimResume * call &amp;lt;SID&amp;gt;neogit#refresh_manually(expand(&#39;&amp;lt;afile&amp;gt;&#39;))&#xA;augroup END&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Todo&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note: This file is no longer being updated.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The todo file does not represent ALL of the missing features. This file just shows the features which I noticed were missing and I have to implement.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NeogitOrg/neogit/master/todo.md&#34;&gt;TODO&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;Assure that you have &lt;a href=&#34;https://github.com/nvim-lua/plenary.nvim&#34;&gt;plenary.nvim&lt;/a&gt; installed as a plugin for your neovim instance. Afterwards, run &lt;code&gt;make test&lt;/code&gt; to run the unit test suite.&lt;/p&gt; &#xA;&lt;p&gt;Plenary uses it&#39;s own port of busted and a bundled luassert, so consult their code and the respective &lt;a href=&#34;http://olivinelabs.com/busted/&#34;&gt;busted&lt;/a&gt; and &lt;a href=&#34;http://olivinelabs.com/busted/#asserts&#34;&gt;luassert&lt;/a&gt; docs for what methods are available.&lt;/p&gt;</summary>
  </entry>
</feed>