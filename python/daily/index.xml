<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Python Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-13T01:45:28Z</updated>
  <subtitle>Daily Trending of Python in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>graphdeco-inria/gaussian-splatting</title>
    <updated>2023-07-13T01:45:28Z</updated>
    <id>tag:github.com,2023-07-13:/graphdeco-inria/gaussian-splatting</id>
    <link href="https://github.com/graphdeco-inria/gaussian-splatting" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Original reference implementation of &#34;3D Gaussian Splatting for Real-Time Radiance Field Rendering&#34;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;3D Gaussian Splatting for Real-Time Radiance Field Rendering&lt;/h1&gt; &#xA;&lt;p&gt;Bernhard Kerbl*, Georgios Kopanas*, Thomas Leimkühler, George Drettakis (* indicates equal contribution)&lt;br&gt; | &lt;a href=&#34;https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/&#34;&gt;Webpage&lt;/a&gt; | &lt;a href=&#34;https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/3d_gaussian_splatting_high.pdf&#34;&gt;Full Paper&lt;/a&gt; | &lt;a href=&#34;https://youtu.be/T_kXY43VZnk&#34;&gt;Video&lt;/a&gt; | &lt;a href=&#34;http://www-sop.inria.fr/reves/publis/gdindex.php&#34;&gt;Other GRAPHDECO Publications&lt;/a&gt; | &lt;a href=&#34;https://fungraph.inria.fr&#34;&gt;FUNGRAPH project page&lt;/a&gt; |&lt;/p&gt; &#xA;&lt;p&gt;| &lt;a href=&#34;https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/datasets/input/tandt_db.zip&#34;&gt;T&amp;amp;T+DB COLMAP (650MB)&lt;/a&gt; | &lt;a href=&#34;https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/datasets/pretrained/models.zip&#34;&gt;Pre-trained Models (14 GB)&lt;/a&gt; | &lt;a href=&#34;https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/binaries/viewers.zip&#34;&gt;Viewers for Windows (60MB)&lt;/a&gt; | &lt;a href=&#34;https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/evaluation/images.zip&#34;&gt;Evaluation Images (7 GB)&lt;/a&gt; | &lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/graphdeco-inria/gaussian-splatting/main/assets/teaser.png&#34; alt=&#34;Teaser image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This repository contains the official authors implementation associated with the paper &#34;3D Gaussian Splatting for Real-Time Radiance Field Rendering&#34;, which can be found &lt;a href=&#34;https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/&#34;&gt;here&lt;/a&gt;. We further provide the reference images used to create the error metrics reported in the paper, as well as recently created, pre-trained models.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.inria.fr/&#34;&gt;&lt;img height=&#34;100&#34; src=&#34;https://raw.githubusercontent.com/graphdeco-inria/gaussian-splatting/main/assets/logo_inria.png&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://univ-cotedazur.eu/&#34;&gt;&lt;img height=&#34;100&#34; src=&#34;https://raw.githubusercontent.com/graphdeco-inria/gaussian-splatting/main/assets/logo_uca.png&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://www.mpi-inf.mpg.de&#34;&gt;&lt;img height=&#34;100&#34; src=&#34;https://raw.githubusercontent.com/graphdeco-inria/gaussian-splatting/main/assets/logo_mpi.png&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://team.inria.fr/graphdeco/&#34;&gt; &lt;img style=&#34;width:100%;&#34; src=&#34;https://raw.githubusercontent.com/graphdeco-inria/gaussian-splatting/main/assets/logo_graphdeco.png&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Abstract: &lt;em&gt;Radiance Field methods have recently revolutionized novel-view synthesis of scenes captured with multiple photos or videos. However, achieving high visual quality still requires neural networks that are costly to train and render, while recent faster methods inevitably trade off speed for quality. For unbounded and complete scenes (rather than isolated objects) and 1080p resolution rendering, no current method can achieve real-time display rates. We introduce three key elements that allow us to achieve state-of-the-art visual quality while maintaining competitive training times and importantly allow high-quality real-time (≥ 30 fps) novel-view synthesis at 1080p resolution. First, starting from sparse points produced during camera calibration, we represent the scene with 3D Gaussians that preserve desirable properties of continuous volumetric radiance fields for scene optimization while avoiding unnecessary computation in empty space; Second, we perform interleaved optimization/density control of the 3D Gaussians, notably optimizing anisotropic covariance to achieve an accurate representation of the scene; Third, we develop a fast visibility-aware rendering algorithm that supports anisotropic splatting and both accelerates training and allows realtime rendering. We demonstrate state-of-the-art visual quality and real-time rendering on several established datasets.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;section class=&#34;section&#34; id=&#34;BibTeX&#34;&gt; &#xA; &lt;div class=&#34;container is-max-desktop content&#34;&gt; &#xA;  &lt;h2 class=&#34;title&#34;&gt;BibTeX&lt;/h2&gt; &#xA;  &lt;pre&gt;&lt;code&gt;@Article{kerbl3Dgaussians,&#xA;      author       = {Kerbl, Bernhard and Kopanas, Georgios and Leimk{\&#34;u}hler, Thomas and Drettakis, George},&#xA;      title        = {3D Gaussian Splatting for Real-Time Radiance Field Rendering},&#xA;      journal      = {ACM Transactions on Graphics},&#xA;      number       = {4},&#xA;      volume       = {42},&#xA;      month        = {July},&#xA;      year         = {2023},&#xA;      url          = {https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/}&#xA;}&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/div&gt; &#xA;&lt;/section&gt; &#xA;&lt;h2&gt;Funding and Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;This research was funded by the ERC Advanced grant FUNGRAPH No 788065. The authors are grateful to Adobe for generous donations, the OPAL infrastructure from Université Côte d’Azur and for the HPC resources from GENCI–IDRIS (Grant 2022-AD011013409). The authors thank the anonymous reviewers for their valuable feedback, P. Hedman and A. Tewari for proofreading earlier drafts also T. Müller, A. Yu and S. Fridovich-Keil for helping with the comparisons.&lt;/p&gt; &#xA;&lt;h2&gt;Cloning the Repository&lt;/h2&gt; &#xA;&lt;p&gt;The repository contains submodules, thus please check it out with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# SSH&#xA;git clone git@github.com:graphdeco-inria/gaussian-splatting.git --recursive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# HTTPS&#xA;git clone https://github.com/graphdeco-inria/gaussian-splatting --recursive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;The codebase has 4 main components:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A PyTorch-based optimizer to produce a 3D Gaussian model from SfM inputs&lt;/li&gt; &#xA; &lt;li&gt;A network viewer that allows to connect to and visualize the optimization process&lt;/li&gt; &#xA; &lt;li&gt;An OpenGL-based real-time viewer to render trained models in real-time.&lt;/li&gt; &#xA; &lt;li&gt;A script to help you turn your own images into optimization-ready SfM data sets&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The components have different requirements w.r.t. both hardware and software. They have been tested on Windows 10 and Ubuntu Linux 22.04. Instructions for setting up and running each of them are found in the sections below.&lt;/p&gt; &#xA;&lt;h2&gt;Optimizer&lt;/h2&gt; &#xA;&lt;p&gt;The optimizer uses PyTorch and CUDA extensions in a Python environment to produce trained models.&lt;/p&gt; &#xA;&lt;h3&gt;Hardware Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CUDA-ready GPU with Compute Capability 7.0+&lt;/li&gt; &#xA; &lt;li&gt;24 GB VRAM (to train to paper evaluation quality)&lt;/li&gt; &#xA; &lt;li&gt;Please see FAQ for smaller VRAM configurations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Software Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Conda (recommended for easy setup)&lt;/li&gt; &#xA; &lt;li&gt;C++ Compiler for PyTorch extensions (we used Visual Studio 2019 for Windows)&lt;/li&gt; &#xA; &lt;li&gt;CUDA SDK 11.7+ for PyTorch extensions (we used 11.8, &lt;strong&gt;known issues with 11.6&lt;/strong&gt;)&lt;/li&gt; &#xA; &lt;li&gt;C++ Compiler and CUDA SDK must be compatible&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Setup&lt;/h3&gt; &#xA;&lt;p&gt;Our provided install method is based on Conda package and environment management:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;SET DISTUTILS_USE_SDK=1 # Windows only&#xA;conda env create --file environment.yml&#xA;conda activate gaussian_splatting&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Tip: Downloading packages and creating a new environment with Conda can require a significant amount of disk space. By default, Conda will use the main system hard drive. You can avoid this by specifying a different package download location and an environment on a different drive:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;conda config --add pkgs_dirs &amp;lt;Drive&amp;gt;/&amp;lt;pkg_path&amp;gt;&#xA;conda env create --file environment.yml --prefix &amp;lt;Drive&amp;gt;/&amp;lt;env_path&amp;gt;/gaussian_splatting&#xA;conda activate &amp;lt;Drive&amp;gt;/&amp;lt;env_path&amp;gt;/gaussian_splatting&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you can afford the disk space, we recommend using our environment files for setting up a training environment identical to ours. If you want to make modifications, please note that major version changes might affect the results of our method. However, our (limited) experiments suggest that the codebase works just fine inside a more up-to-date environment (Python 3.8, PyTorch 2.0.0, CUDA 11.8).&lt;/p&gt; &#xA;&lt;h3&gt;Running&lt;/h3&gt; &#xA;&lt;p&gt;To run the optimizer, simply use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python train.py -s &amp;lt;path to COLMAP or NeRF Synthetic dataset&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;Command Line Arguments for train.py&lt;/span&gt;&lt;/summary&gt; &#xA; &lt;h4&gt;--source_path / -s&lt;/h4&gt; &#xA; &lt;p&gt;Path to the source directory containing a COLMAP or Synthetic NeRF data set.&lt;/p&gt; &#xA; &lt;h4&gt;--model_path / -m&lt;/h4&gt; &#xA; &lt;p&gt;Path where the trained model should be stored (&lt;code&gt;output/&amp;lt;random&amp;gt;&lt;/code&gt; by default).&lt;/p&gt; &#xA; &lt;h4&gt;--images / -i&lt;/h4&gt; &#xA; &lt;p&gt;Alternative subdirectory for COLMAP images (&lt;code&gt;images&lt;/code&gt; by default).&lt;/p&gt; &#xA; &lt;h4&gt;--eval&lt;/h4&gt; &#xA; &lt;p&gt;Add this flag to use a MipNeRF360-style training/test split for evaluation.&lt;/p&gt; &#xA; &lt;h4&gt;--resolution / -r&lt;/h4&gt; &#xA; &lt;p&gt;Specifies resolution of the loaded images before training. If provided &lt;code&gt;1, 2, 4&lt;/code&gt; or &lt;code&gt;8&lt;/code&gt;, uses original, 1/2, 1/4 or 1/8 resolution, respectively. For all other values, rescales the width to the given number while maintaining image aspect. &lt;strong&gt;If not set and input image width exceeds 1.6K pixels, inputs are automatically rescaled to this target.&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;h4&gt;--data_device&lt;/h4&gt; &#xA; &lt;p&gt;Specifies where to put the source image data, &lt;code&gt;cuda&lt;/code&gt; by default, recommended to use &lt;code&gt;cpu&lt;/code&gt; if training on large/high-resolution dataset, will reduce VRAM consumption, but slightly slow down training.&lt;/p&gt; &#xA; &lt;h4&gt;--white_background / -w&lt;/h4&gt; &#xA; &lt;p&gt;Add this flag to use white background instead of black (default), e.g., for evaluation of NeRF Synthetic dataset.&lt;/p&gt; &#xA; &lt;h4&gt;--sh_degree&lt;/h4&gt; &#xA; &lt;p&gt;Order of spherical harmonics to be used (no larger than 3). &lt;code&gt;3&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--convert_SHs_python&lt;/h4&gt; &#xA; &lt;p&gt;Flag to make pipeline compute forward and backward of SHs with PyTorch instead of ours.&lt;/p&gt; &#xA; &lt;h4&gt;--convert_cov3D_python&lt;/h4&gt; &#xA; &lt;p&gt;Flag to make pipeline compute forward and backward of the 3D covariance with PyTorch instead of ours.&lt;/p&gt; &#xA; &lt;h4&gt;--iterations&lt;/h4&gt; &#xA; &lt;p&gt;Number of total iterations to train for, &lt;code&gt;30_000&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--feature_lr&lt;/h4&gt; &#xA; &lt;p&gt;Spherical harmonics features learning rate, &lt;code&gt;0.0025&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--opacity_lr&lt;/h4&gt; &#xA; &lt;p&gt;Opacity learning rate, &lt;code&gt;0.05&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--scaling_lr&lt;/h4&gt; &#xA; &lt;p&gt;Scaling learning rate, &lt;code&gt;0.001&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--rotation_lr&lt;/h4&gt; &#xA; &lt;p&gt;Rotation learning rate, &lt;code&gt;0.001&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--position_lr_max_steps&lt;/h4&gt; &#xA; &lt;p&gt;Number of steps (from 0) where position learning rate goes from &lt;code&gt;initial&lt;/code&gt; to &lt;code&gt;final&lt;/code&gt;. &lt;code&gt;30_000&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--position_lr_init&lt;/h4&gt; &#xA; &lt;p&gt;Initial 3D position learning rate, &lt;code&gt;0.00016&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--position_lr_final&lt;/h4&gt; &#xA; &lt;p&gt;Final 3D position learning rate, &lt;code&gt;0.0000016&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--position_lr_delay_mult&lt;/h4&gt; &#xA; &lt;p&gt;Position learning rate multiplier (cf. Plenoxels), &lt;code&gt;0.01&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--densify_from_iter&lt;/h4&gt; &#xA; &lt;p&gt;Iteration where densification starts, &lt;code&gt;500&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--densify_until_iter&lt;/h4&gt; &#xA; &lt;p&gt;Iteration where densification stops, &lt;code&gt;15_000&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--densify_grad_threshold&lt;/h4&gt; &#xA; &lt;p&gt;Limit that decides if points should be densified based on 2D position gradient, &lt;code&gt;0.0002&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--densification_interal&lt;/h4&gt; &#xA; &lt;p&gt;How frequently to densify, &lt;code&gt;100&lt;/code&gt; (every 100 iterations) by default.&lt;/p&gt; &#xA; &lt;h4&gt;--opacity_reset_interval&lt;/h4&gt; &#xA; &lt;p&gt;How frequently to reset opacity, &lt;code&gt;3_000&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--lambda_dssim&lt;/h4&gt; &#xA; &lt;p&gt;Influence of SSIM on total loss from 0 to 1, &lt;code&gt;0.2&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--percent_dense&lt;/h4&gt; &#xA; &lt;p&gt;Percentage of scene extent (0--1) a point must exceed to be forcibly densified, &lt;code&gt;0.1&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--ip&lt;/h4&gt; &#xA; &lt;p&gt;IP to start GUI server on, &lt;code&gt;127.0.0.1&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--port&lt;/h4&gt; &#xA; &lt;p&gt;Port to use for GUI server, &lt;code&gt;6009&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--test_iterations&lt;/h4&gt; &#xA; &lt;p&gt;Space-separated iterations at which the training script computes L1 and PSNR over test set, &lt;code&gt;7000 30000&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--save_iterations&lt;/h4&gt; &#xA; &lt;p&gt;Space-separated iterations at which the training script saves the Gaussian model, &lt;code&gt;7000 30000 &amp;lt;iterations&amp;gt;&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--quiet&lt;/h4&gt; &#xA; &lt;p&gt;Flag to omit any text written to standard out pipe.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;Note that similar to MipNeRF360, we target images at resolutions in the 1-1.6K pixel range. For convenience, arbitrary-size inputs can be passed and will be automatically resized if their width exceeds 1600 pixels. We recommend to keep this behavior, but you may force training to use your higher-resolution images by setting &lt;code&gt;-r 1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The MipNeRF360 scenes are hosted by the paper authors &lt;a href=&#34;https://jonbarron.info/mipnerf360/&#34;&gt;here&lt;/a&gt;. You can find our SfM data sets for Tanks&amp;amp;Temples and Deep Blending &lt;a href=&#34;https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/datasets/input/tandt+db.zip&#34;&gt;here&lt;/a&gt;. If you do not provide an output model directory (&lt;code&gt;-m&lt;/code&gt;), trained models are written to folders with randomized unique names inside the &lt;code&gt;output&lt;/code&gt; directory. At this point, the trained models may be viewed with the real-time viewer (see further below).&lt;/p&gt; &#xA;&lt;h3&gt;Evaluation&lt;/h3&gt; &#xA;&lt;p&gt;By default, the trained models use all available images in the dataset. To train them while withholding a test set for evaluation, use the &lt;code&gt;--eval&lt;/code&gt; flag. This way, you can render training/test sets and produce error metrics as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python train.py -s &amp;lt;path to COLMAP or NeRF Synthetic dataset&amp;gt; --eval # Train with train/test split&#xA;python render.py -m &amp;lt;path to trained model&amp;gt; # Generate renderings&#xA;python metrics.py -m &amp;lt;path to trained model&amp;gt; # Compute error metrics on renderings&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to evaluate our &lt;a href=&#34;https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/datasets/pretrained/models.zip&#34;&gt;pre-trained models&lt;/a&gt;, you will have to download the corresponding source data sets and indicate their location to &lt;code&gt;render.py&lt;/code&gt; with an additional &lt;code&gt;--source_path/-s&lt;/code&gt; flag. Note: The pre-trained models were created with the release codebase. This code base has been cleaned up and includes bugfixes, hence the metrics you get from evaluating them will differ from those in the paper.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python render.py -m &amp;lt;path to pre-trained model&amp;gt; -s &amp;lt;path to COLMAP dataset&amp;gt;&#xA;python metrics.py -m &amp;lt;path to pre-trained model&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;Command Line Arguments for render.py&lt;/span&gt;&lt;/summary&gt; &#xA; &lt;h4&gt;--model_path / -m&lt;/h4&gt; &#xA; &lt;p&gt;Path to the trained model directory you want to create renderings for.&lt;/p&gt; &#xA; &lt;h4&gt;--skip_train&lt;/h4&gt; &#xA; &lt;p&gt;Flag to skip rendering the training set.&lt;/p&gt; &#xA; &lt;h4&gt;--skip_test&lt;/h4&gt; &#xA; &lt;p&gt;Flag to skip rendering the test set.&lt;/p&gt; &#xA; &lt;h4&gt;--quiet&lt;/h4&gt; &#xA; &lt;p&gt;Flag to omit any text written to standard out pipe.&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;The below parameters will be read automatically from the model path, based on what was used for training. However, you may override them by providing them explicitly on the command line.&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;h4&gt;--source_path / -s&lt;/h4&gt; &#xA; &lt;p&gt;Path to the source directory containing a COLMAP or Synthetic NeRF data set.&lt;/p&gt; &#xA; &lt;h4&gt;--images / -i&lt;/h4&gt; &#xA; &lt;p&gt;Alternative subdirectory for COLMAP images (&lt;code&gt;images&lt;/code&gt; by default).&lt;/p&gt; &#xA; &lt;h4&gt;--eval&lt;/h4&gt; &#xA; &lt;p&gt;Add this flag to use a MipNeRF360-style training/test split for evaluation.&lt;/p&gt; &#xA; &lt;h4&gt;--resolution / -r&lt;/h4&gt; &#xA; &lt;p&gt;Changes the resolution of the loaded images before training. If provided &lt;code&gt;1, 2, 4&lt;/code&gt; or &lt;code&gt;8&lt;/code&gt;, uses original, 1/2, 1/4 or 1/8 resolution, respectively. For all other values, rescales the width to the given number while maintaining image aspect. &lt;code&gt;1&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--white_background / -w&lt;/h4&gt; &#xA; &lt;p&gt;Add this flag to use white background instead of black (default), e.g., for evaluation of NeRF Synthetic dataset.&lt;/p&gt; &#xA; &lt;h4&gt;--convert_SHs_python&lt;/h4&gt; &#xA; &lt;p&gt;Flag to make pipeline render with computed SHs from PyTorch instead of ours.&lt;/p&gt; &#xA; &lt;h4&gt;--convert_cov3D_python&lt;/h4&gt; &#xA; &lt;p&gt;Flag to make pipeline render with computed 3D covariance from PyTorch instead of ours.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;Command Line Arguments for metrics.py&lt;/span&gt;&lt;/summary&gt; &#xA; &lt;h4&gt;--model_paths / -m&lt;/h4&gt; &#xA; &lt;p&gt;Space-separated list of model paths for which metrics should be computed.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;We further provide the &lt;code&gt;full_eval.py&lt;/code&gt; script. This script specifies the routine used in our evaluation and demonstrates the use of some additional parameters, e.g., &lt;code&gt;--images (-i)&lt;/code&gt; to define alternative image directories within COLMAP data sets. If you have downloaded and extracted all the training data, you can run it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python full_eval.py -m360 &amp;lt;mipnerf360 folder&amp;gt; -tat &amp;lt;tanks and temples folder&amp;gt; -db &amp;lt;deep blending folder&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the current version, this process takes about 7h on our reference machine containing an A6000. If you want to do the full evaluation on our pre-trained models, you can specify their download location and skip training.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python full_eval.py -o &amp;lt;directory with pretrained models&amp;gt; --skip_training -m360 &amp;lt;mipnerf360 folder&amp;gt; -tat &amp;lt;tanks and temples folder&amp;gt; -db &amp;lt;deep blending folder&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to compute the metrics on our paper&#39;s &lt;a href=&#34;https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/evaluation/images.zip&#34;&gt;evaluation images&lt;/a&gt;, you can also skip rendering. In this case it is not necessary to provide the source datasets. You can compute metrics for multiple image sets at a time.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python full_eval.py -m &amp;lt;directory with evaluation images&amp;gt;/garden ... --skip_training --skip_rendering&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;Command Line Arguments for full_eval.py&lt;/span&gt;&lt;/summary&gt; &#xA; &lt;h4&gt;--skip_training&lt;/h4&gt; &#xA; &lt;p&gt;Flag to skip training stage.&lt;/p&gt; &#xA; &lt;h4&gt;--skip_rendering&lt;/h4&gt; &#xA; &lt;p&gt;Flag to skip rendering stage.&lt;/p&gt; &#xA; &lt;h4&gt;--skip_metrics&lt;/h4&gt; &#xA; &lt;p&gt;Flag to skip metrics calculation stage.&lt;/p&gt; &#xA; &lt;h4&gt;--output_path&lt;/h4&gt; &#xA; &lt;p&gt;Directory to put renderings and results in, &lt;code&gt;./eval&lt;/code&gt; by default, set to pre-trained model location if evaluating them.&lt;/p&gt; &#xA; &lt;h4&gt;--mipnerf360 / -m360&lt;/h4&gt; &#xA; &lt;p&gt;Path to MipNeRF360 source datasets, required if training or rendering.&lt;/p&gt; &#xA; &lt;h4&gt;--tanksandtemples / -tat&lt;/h4&gt; &#xA; &lt;p&gt;Path to Tanks&amp;amp;Temples source datasets, required if training or rendering.&lt;/p&gt; &#xA; &lt;h4&gt;--deepblending / -db&lt;/h4&gt; &#xA; &lt;p&gt;Path to Deep Blending source datasets, required if training or rendering.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Interactive Viewers&lt;/h2&gt; &#xA;&lt;p&gt;We provide two interactive iewers for our method: remote and real-time. Our viewing solutions are based on the &lt;a href=&#34;https://sibr.gitlabpages.inria.fr/&#34;&gt;SIBR&lt;/a&gt; framework, developed by the GRAPHDECO group for several novel-view synthesis projects.&lt;/p&gt; &#xA;&lt;h3&gt;Hardware Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;OpenGL 4.5-ready GPU&lt;/li&gt; &#xA; &lt;li&gt;4 GB VRAM recommended&lt;/li&gt; &#xA; &lt;li&gt;CUDA-ready GPU with Compute Capability 7.0+ (only for Real-Time Viewer)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Software Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Visual Studio or g++, &lt;strong&gt;not Clang&lt;/strong&gt; (we used Visual Studio 2019 for Windows)&lt;/li&gt; &#xA; &lt;li&gt;CUDA SDK 11 (we used 11.8)&lt;/li&gt; &#xA; &lt;li&gt;CMake (recent version, we used 3.24)&lt;/li&gt; &#xA; &lt;li&gt;7zip (only on Windows)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Pre-built Windows Binaries&lt;/h3&gt; &#xA;&lt;p&gt;We provide pre-built binaries for Windows &lt;a href=&#34;https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/binaries/viewers.zip&#34;&gt;here&lt;/a&gt;. We recommend using them on Windows for an efficient setup, since the building of SIBR involves several external dependencies that must be downloaded and compiled on-the-fly.&lt;/p&gt; &#xA;&lt;h3&gt;Installation from Source&lt;/h3&gt; &#xA;&lt;p&gt;If you cloned with submodules (e.g., using &lt;code&gt;--recursive&lt;/code&gt;), the source code for the viewers is found in &lt;code&gt;SIBR_viewers&lt;/code&gt;. The network viewer runs within the SIBR framework for Image-based Rendering applications.&lt;/p&gt; &#xA;&lt;h4&gt;Windows&lt;/h4&gt; &#xA;&lt;p&gt;CMake should take care of your dependencies.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd SIBR_viewers&#xA;cmake -Bbuild .&#xA;cmake --build build --target install --config RelWithDebInfo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may specify a different configuration, e.g. &lt;code&gt;Debug&lt;/code&gt; if you need more control during development.&lt;/p&gt; &#xA;&lt;h4&gt;Ubuntu 22.04&lt;/h4&gt; &#xA;&lt;p&gt;You will need to install a few dependencies before running the project setup.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Dependencies&#xA;sudo apt install -y libglew-dev libassimp-dev libboost-all-dev libgtk-3-dev libopencv-dev libglfw3-dev libavdevice-dev libavcodec-dev libeigen3-dev libxxf86vm-dev libembree-dev&#xA;# Project setup&#xA;cd SIBR_viewers&#xA;cmake -Bbuild .&#xA;cmake --build build -j 24 --target install --config Release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Ubuntu 20.04&lt;/h4&gt; &#xA;&lt;p&gt;Backwards compatibility with Focal Fossa is not fully tested, but building SIBR with CMake should still work after invoking&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git checkout fossa_compatibility&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Navigation in SIBR Viewers&lt;/h3&gt; &#xA;&lt;p&gt;The SIBR interface provides several methods of navigating the scene. By default, you will be started with an FPS navigator, which you can control with &lt;code&gt;W, A, S, D, Q, E&lt;/code&gt; for camera translation and &lt;code&gt;I, K, J, L, U, O&lt;/code&gt; for rotation. Alternatively, you may want to use a Trackball-style navigator (select from the floating menu). You can also snap to a camera from the data set with the &lt;code&gt;Snap to&lt;/code&gt; button or find the closest camera with &lt;code&gt;Snap to closest&lt;/code&gt;. The floating menues also allow you to change the navigation speed. You can use the &lt;code&gt;Scaling Modifier&lt;/code&gt; to control the size of the displayed Gaussians, or show the initial point cloud.&lt;/p&gt; &#xA;&lt;h3&gt;Running the Network Viewer&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/graphdeco-inria/gaussian-splatting/assets/40643808/90a2e4d3-cf2e-4633-b35f-bfe284e28ff7&#34;&gt;https://github.com/graphdeco-inria/gaussian-splatting/assets/40643808/90a2e4d3-cf2e-4633-b35f-bfe284e28ff7&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;After extracting or installing the viewers, you may run the compiled &lt;code&gt;SIBR_remoteGaussian_app[_config]&lt;/code&gt; app in &lt;code&gt;&amp;lt;SIBR install dir&amp;gt;/bin&lt;/code&gt;, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./&amp;lt;SIBR install dir&amp;gt;/bin/SIBR_remoteGaussian_app&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The network viewer allows you to connect to a running training process on the same or a different machine. If you are training on the same machine and OS, no command line parameters should be required: the optimizer communicates the location of the training data to the network viewer. By default, optimizer and network viewer will try to establish a connection on &lt;strong&gt;localhost&lt;/strong&gt; on port &lt;strong&gt;6009&lt;/strong&gt;. You can change this behavior by providing matching &lt;code&gt;--ip&lt;/code&gt; and &lt;code&gt;--port&lt;/code&gt; parameters to both the optimizer and the network viewer. If for some reason the path used by the optimizer to find the training data is not reachable by the network viewer (e.g., due to them running on different (virtual) machines), you may specify an override location to the viewer by using &lt;code&gt;-s &amp;lt;source path&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;Primary Command Line Arguments for Network Viewer&lt;/span&gt;&lt;/summary&gt; &#xA; &lt;h4&gt;--path / -s&lt;/h4&gt; &#xA; &lt;p&gt;Argument to override model&#39;s path to source dataset.&lt;/p&gt; &#xA; &lt;h4&gt;--ip&lt;/h4&gt; &#xA; &lt;p&gt;IP to use for connection to a running training script.&lt;/p&gt; &#xA; &lt;h4&gt;--port&lt;/h4&gt; &#xA; &lt;p&gt;Port to use for connection to a running training script.&lt;/p&gt; &#xA; &lt;h4&gt;--rendering-size&lt;/h4&gt; &#xA; &lt;p&gt;Takes two space separated numbers to define the resolution at which network rendering occurs, &lt;code&gt;1200&lt;/code&gt; width by default. Note that to enforce an aspect that differs from the input images, you need &lt;code&gt;--force-aspect-ratio&lt;/code&gt; too.&lt;/p&gt; &#xA; &lt;h4&gt;--load_images&lt;/h4&gt; &#xA; &lt;p&gt;Flag to load source dataset images to be displayed in the top view for each camera.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Running the Real-Time Viewer&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/graphdeco-inria/gaussian-splatting/assets/40643808/0940547f-1d82-4c2f-a616-44eabbf0f816&#34;&gt;https://github.com/graphdeco-inria/gaussian-splatting/assets/40643808/0940547f-1d82-4c2f-a616-44eabbf0f816&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;After extracting or installing the viewers, you may run the compiled &lt;code&gt;SIBR_gaussianViewer_app[_config]&lt;/code&gt; app in &lt;code&gt;&amp;lt;SIBR install dir&amp;gt;/bin&lt;/code&gt;, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./&amp;lt;SIBR install dir&amp;gt;/bin/SIBR_gaussianViewer_app -m &amp;lt;path to trained model&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It should suffice to provide the &lt;code&gt;-m&lt;/code&gt; parameter pointing to a trained model directory. Alternatively, you can specify an override location for training input data using &lt;code&gt;-s&lt;/code&gt;. To use a specific resolution other than the auto-chosen one, specify &lt;code&gt;--rendering-size &amp;lt;width&amp;gt; &amp;lt;height&amp;gt;&lt;/code&gt;. Combine it with &lt;code&gt;--force-aspect-ratio&lt;/code&gt; if you want the exact resolution and don&#39;t mind image distortion.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;To unlock the full frame rate, please disable V-Sync on your machine and also in the application (Menu → Display). In a multi-GPU system (e.g., laptop) your OpenGL/Display GPU should be the same as your CUDA GPU (e.g., by setting the application&#39;s GPU preference on Windows, see below) for maximum performance.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/graphdeco-inria/gaussian-splatting/main/assets/select.png&#34; alt=&#34;Teaser image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In addition to the intial point cloud and the splats, you also have the option to visualize the Gaussians by rendering them as ellipsoids from the floating menu. SIBR has many other functionalities, please see the &lt;a href=&#34;https://sibr.gitlabpages.inria.fr/&#34;&gt;documentation&lt;/a&gt; for more details on the viewer, navigation options etc. There is also a Top View (available from the menu) that shows the placement of the input cameras and the original SfM point cloud; please note that Top View slows rendering when enabled. The real-time viewer also uses slightly more aggressive, fast culling, which can be toggled in the floating menu. If you ever encounter an issue that can be solved by turning fast culling off, please let us know.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;Primary Command Line Arguments for Real-Time Viewer&lt;/span&gt;&lt;/summary&gt; &#xA; &lt;h4&gt;--model-path / -m&lt;/h4&gt; &#xA; &lt;p&gt;Path to trained model.&lt;/p&gt; &#xA; &lt;h4&gt;--iteration&lt;/h4&gt; &#xA; &lt;p&gt;Specifies which of state to load if multiple are available. Defaults to latest available iteration.&lt;/p&gt; &#xA; &lt;h4&gt;--path / -s&lt;/h4&gt; &#xA; &lt;p&gt;Argument to override model&#39;s path to source dataset.&lt;/p&gt; &#xA; &lt;h4&gt;--rendering-size&lt;/h4&gt; &#xA; &lt;p&gt;Takes two space separated numbers to define the resolution at which real-time rendering occurs, &lt;code&gt;1200&lt;/code&gt; width by default. Note that to enforce an aspect that differs from the input images, you need &lt;code&gt;--force-aspect-ratio&lt;/code&gt; too.&lt;/p&gt; &#xA; &lt;h4&gt;--load_images&lt;/h4&gt; &#xA; &lt;p&gt;Flag to load source dataset images to be displayed in the top view for each camera.&lt;/p&gt; &#xA; &lt;h4&gt;--device&lt;/h4&gt; &#xA; &lt;p&gt;Index of CUDA device to use for rasterization if multiple are available, &lt;code&gt;0&lt;/code&gt; by default.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Processing your own Scenes&lt;/h2&gt; &#xA;&lt;p&gt;Our COLMAP loaders expect the following dataset structure in the source path location:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;location&amp;gt;&#xA;|---images&#xA;|   |---&amp;lt;image 0&amp;gt;&#xA;|   |---&amp;lt;image 1&amp;gt;&#xA;|   |---...&#xA;|---sparse&#xA;    |---0&#xA;        |---cameras.bin&#xA;        |---images.bin&#xA;        |---points3D.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For rasterization, the camera models must be either a SIMPLE_PINHOLE or PINHOLE camera. We provide a converter script &lt;code&gt;convert.py&lt;/code&gt;, to extract undistorted images and SfM information from input images. Optionally, you can use ImageMagick to resize the undistorted images. This rescaling is similar to MipNeRF360, i.e., it creates images with 1/2, 1/4 and 1/8 the original resolution in corresponding folders. To use them, please first install a recent version of COLMAP (ideally CUDA-powered) and ImageMagick. Put the images you want to use in a directory &lt;code&gt;&amp;lt;location&amp;gt;/input&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;location&amp;gt;&#xA;|---input&#xA;    |---&amp;lt;image 0&amp;gt;&#xA;    |---&amp;lt;image 1&amp;gt;&#xA;    |---...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have COLMAP and ImageMagick on your system path, you can simply run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python convert.py -s &amp;lt;location&amp;gt; [--resize] #If not resizing, ImageMagick is not needed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can use the optional parameters &lt;code&gt;--colmap_executable&lt;/code&gt; and &lt;code&gt;--magick_executable&lt;/code&gt; to point to the respective paths. Please note that on Windows, the executable should point to the COLMAP &lt;code&gt;.bat&lt;/code&gt; file that takes care of setting the execution environment. Once done, &lt;code&gt;&amp;lt;location&amp;gt;&lt;/code&gt; will contain the expected COLMAP data set structure with undistorted, resized input images, in addition to your original images and some temporary (distorted) data in the directory &lt;code&gt;distorted&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you have your own COLMAP dataset without undistortion (e.g., using &lt;code&gt;OPENCV&lt;/code&gt; camera), you can try to just run the last part of the script: Put the images in &lt;code&gt;input&lt;/code&gt; and the COLMAP info in a subdirectory &lt;code&gt;distorted&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;location&amp;gt;&#xA;|---input&#xA;|   |---&amp;lt;image 0&amp;gt;&#xA;|   |---&amp;lt;image 1&amp;gt;&#xA;|   |---...&#xA;|---distorted&#xA;    |---database.db&#xA;    |---sparse&#xA;        |---0&#xA;            |---...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python convert.py -s &amp;lt;location&amp;gt; --skip_matching [--resize] #If not resizing, ImageMagick is not needed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;Command Line Arguments for convert.py&lt;/span&gt;&lt;/summary&gt; &#xA; &lt;h4&gt;--no_gpu&lt;/h4&gt; &#xA; &lt;p&gt;Flag to avoid using GPU in COLMAP.&lt;/p&gt; &#xA; &lt;h4&gt;--skip_matching&lt;/h4&gt; &#xA; &lt;p&gt;Flag to indicate that COLMAP info is available for images.&lt;/p&gt; &#xA; &lt;h4&gt;--source_path / -s&lt;/h4&gt; &#xA; &lt;p&gt;Location of the inputs.&lt;/p&gt; &#xA; &lt;h4&gt;--camera&lt;/h4&gt; &#xA; &lt;p&gt;Which camera model to use for the early matching steps, &lt;code&gt;OPENCV&lt;/code&gt; by default.&lt;/p&gt; &#xA; &lt;h4&gt;--resize&lt;/h4&gt; &#xA; &lt;p&gt;Flag for creating resized versions of input images.&lt;/p&gt; &#xA; &lt;h4&gt;--colmap_executable&lt;/h4&gt; &#xA; &lt;p&gt;Path to the COLMAP executable (&lt;code&gt;.bat&lt;/code&gt; on Windows).&lt;/p&gt; &#xA; &lt;h4&gt;--magick_executable&lt;/h4&gt; &#xA; &lt;p&gt;Path to the ImageMagick executable.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Where do I get data sets, e.g., those referenced in &lt;code&gt;full_eval.py&lt;/code&gt;?&lt;/em&gt; The MipNeRF360 data set is provided by the authors of the original paper on the project site. Note that two of the data sets cannot be openly shared and require you to consult the authors directly. For Tanks&amp;amp;Temples and Deep Blending, please use the download links provided at the top of the page.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;I don&#39;t have 24 GB of VRAM for training, what do I do?&lt;/em&gt; The VRAM consumption is determined by the number of points that are being optimized, which increases over time. If you only want to train to 7k iterations, you will need significantly less. To do the full training routine and avoid running out of memory, you can increase the &lt;code&gt;--densify_grad_threshold&lt;/code&gt;, &lt;code&gt;--densification_interval&lt;/code&gt; or reduce the value of &lt;code&gt;--densify_until_iter&lt;/code&gt;. Note however that this will affect the quality of the result. Also try setting &lt;code&gt;--test_iterations&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt; to avoid memory spikes during testing. If &lt;code&gt;--densify_grad_threshold&lt;/code&gt; is very high, no densification should occur and training should complete if the scene itself loads successfully.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;24 GB of VRAM for reference quality training is still a lot! Can&#39;t we do it with less?&lt;/em&gt; Yes, most likely. By our calculations it should be possible with &lt;strong&gt;way&lt;/strong&gt; less memory (~8GB). If we can find the time we will try to achieve this. If some PyTorch veteran out there wants to tackle this, we look forward to your pull request!&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;How can I use this for a much larger dataset, like a city district?&lt;/em&gt; Given enough memory, this should work out fine, but it will require to adapt the &lt;code&gt;--scaling_lr&lt;/code&gt; and &lt;code&gt;--position_lr_init/final&lt;/code&gt;. To avoid manual tuning, a suggestion is to check the loss: if it diverges early on, reset and use a lower scaling / position learning rate.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;How can I use the differentiable Gaussian rasterizer for my own project?&lt;/em&gt; Easy, it is included in this repo as a submodule &lt;code&gt;diff-gaussian-rasterization&lt;/code&gt;. Feel free to check out and install the package. It&#39;s not really documented, but using it from the Python side is very straightforward (cf. &lt;code&gt;gaussian_renderer/__init__.py&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Wait, but &lt;code&gt;&amp;lt;insert feature&amp;gt;&lt;/code&gt; isn&#39;t optimized and could be much better?&lt;/em&gt; There are several parts we didn&#39;t even have time to think about improving (yet). The performance you get with this prototype is probably a rather slow baseline for what is physically possible.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Something is broken, how did this happen?&lt;/em&gt; We tried hard to provide a solid and comprehensible basis to make use of the paper&#39;s method. We have refactored the code quite a bit, but we have limited capacity to test all possible usage scenarios. Thus, if part of the website, the code or the performance is lacking, please create an issue. If we find the time, we will do our best to address it.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>baichuan-inc/Baichuan-7B</title>
    <updated>2023-07-13T01:45:28Z</updated>
    <id>tag:github.com,2023-07-13:/baichuan-inc/Baichuan-7B</id>
    <link href="https://github.com/baichuan-inc/Baichuan-7B" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A large-scale 7B pretraining language model developed by BaiChuan-Inc.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt; Baichuan-7B &lt;/h1&gt; &#xA;&lt;/div&gt; &#xA;&lt;p align=&#34;center&#34;&gt; 🤗 &lt;a href=&#34;https://huggingface.co/baichuan-inc/Baichuan-7B&#34; target=&#34;_blank&#34;&gt;Hugging Face&lt;/a&gt; • 🤖 &lt;a href=&#34;https://modelscope.cn/organization/baichuan-inc&#34; target=&#34;_blank&#34;&gt;ModelScope&lt;/a&gt; • 💬 &lt;a href=&#34;https://github.com/baichuan-inc/Baichuan-7B/raw/main/media/wechat.jpeg?raw=true&#34; target=&#34;_blank&#34;&gt;WeChat&lt;/a&gt; &lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/baichuan-inc/Baichuan-7B/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/modelscope/modelscope.svg?sanitize=true&#34; alt=&#34;license&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;h4 align=&#34;center&#34;&gt; &lt;p&gt; &lt;b&gt;中文&lt;/b&gt; | &lt;a href=&#34;https://github.com/baichuan-inc/Baichuan-7B/raw/main/README_EN.md&#34;&gt;English&lt;/a&gt; &lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;/h4&gt; &#xA;&lt;/div&gt; &#xA;&lt;h1&gt;介绍&lt;/h1&gt; &#xA;&lt;p&gt;Baichuan-7B 是由百川智能开发的一个开源可商用的大规模预训练语言模型。基于 Transformer 结构，在大约 1.2 万亿 tokens 上训练的 70 亿参数模型，支持中英双语，上下文窗口长度为 4096。在标准的中文和英文 benchmark（C-Eval/MMLU）上均取得同尺寸最好的效果。&lt;/p&gt; &#xA;&lt;h1&gt;公开benchmark榜单&lt;/h1&gt; &#xA;&lt;h2&gt;中文评测&lt;/h2&gt; &#xA;&lt;h3&gt;C-Eval&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cevalbenchmark.com/index.html&#34;&gt;C-Eval 数据集&lt;/a&gt;是一个全面的中文基础模型评测数据集，涵盖了 52 个学科和四个难度的级别。我们使用该数据集的 dev 集作为 few-shot 的来源，在 test 集上进行了 &lt;code&gt;5-shot&lt;/code&gt; 测试。通过执行执行下面的命令：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd evaluation&#xA;python evaluate_zh.py --model_name_or_path &#39;your/model/path&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;结果&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Model 5-shot&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Average&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Avg(Hard)&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;STEM&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Social Sciences&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Humanities&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Others&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;GPT-4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;68.7&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;54.9&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;67.1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;77.6&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;64.5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;67.8&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;ChatGPT&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;54.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;41.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;52.9&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;61.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;50.9&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;53.6&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Claude-v1.3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;54.2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;39.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;51.9&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;61.7&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;52.1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;53.7&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Claude-instant-v1.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;45.9&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;35.5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;43.1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;53.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;44.2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;45.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;BLOOMZ-7B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;35.7&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;31.3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;43.5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;36.6&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;35.6&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;ChatGLM-6B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;34.5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;23.1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;30.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;39.6&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;37.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;34.5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Ziya-LLaMA-13B-pretrain&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;30.2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;22.7&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;27.7&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;34.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;32.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;28.9&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;moss-moon-003-base (16B)&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;27.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;24.5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;27.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;29.1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;27.2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;26.9&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;LLaMA-7B-hf&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;27.1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.9&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;27.1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;26.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;27.9&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;26.3&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Falcon-7B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;24.3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;26.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.6&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;TigerBot-7B-base&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.7&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;27.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;27.3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;24.7&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;23.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;26.1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Aquila-7B&lt;sup&gt;*&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.6&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;24.6&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;26.6&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Open-LLaMA-v2-pretrain (7B)&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;24.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;22.5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;23.1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;23.2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;BLOOM-7B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;22.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;20.2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;21.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;23.3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;23.9&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;23.3&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Baichuan-7B&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;42.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;31.5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;38.2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;52.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;46.2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;39.3&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Gaokao&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/OpenLMLab/GAOKAO-Bench&#34;&gt;Gaokao&lt;/a&gt; 是一个以中国高考题作为评测大语言模型能力的数据集，用以评估模型的语言能力和逻辑推理能力。 我们只保留了其中的单项选择题，随机划分后对所有模型进行统一 &lt;code&gt;5-shot&lt;/code&gt; 测试。&lt;/p&gt; &#xA;&lt;h3&gt;结果&lt;/h3&gt; &#xA;&lt;p&gt;以下是测试的结果。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Model&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Average&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;BLOOMZ-7B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;28.72&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;LLaMA-7B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;27.81&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;BLOOM-7B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;26.96&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;TigerBot-7B-base&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.94&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Falcon-7B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;23.98&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Ziya-LLaMA-13B-pretrain&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;23.17&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;ChatGLM-6B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;21.41&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Open-LLaMA-v2-pretrain&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;21.41&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Aquila-7B&lt;sup&gt;*&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;24.39&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Baichuan-7B&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;36.24&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;AGIEval&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/microsoft/AGIEval&#34;&gt;AGIEval&lt;/a&gt; 旨在评估模型的认知和解决问题相关的任务中的一般能力。 我们只保留了其中的四选一单项选择题，随机划分后对所有模型进行了统一 &lt;code&gt;5-shot&lt;/code&gt; 测试。&lt;/p&gt; &#xA;&lt;h3&gt;结果&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Model&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Average&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;BLOOMZ-7B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;30.27&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;LLaMA-7B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;28.17&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Ziya-LLaMA-13B-pretrain&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;27.64&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Falcon-7B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;27.18&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;BLOOM-7B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;26.55&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Aquila-7B&lt;sup&gt;*&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.58&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;TigerBot-7B-base&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.19&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;ChatGLM-6B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;23.49&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Open-LLaMA-v2-pretrain&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;23.49&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Baichuan-7B&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;34.44&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;sup&gt;*&lt;/sup&gt;其中 Aquila 模型来源于智源官方网站(&lt;a href=&#34;https://model.baai.ac.cn/model-detail/100098&#34;&gt;https://model.baai.ac.cn/model-detail/100098&lt;/a&gt;) 仅做参考&lt;/p&gt; &#xA;&lt;h2&gt;英文榜单&lt;/h2&gt; &#xA;&lt;p&gt;除了中文之外，Baichuan-7B也测试了模型在英文上的效果，&lt;a href=&#34;https://arxiv.org/abs/2009.03300&#34;&gt;MMLU&lt;/a&gt; 是包含 57 个多选任务的英文评测数据集，涵盖了初等数学、美国历史、计算机科学、法律等，难度覆盖高中水平到专家水平，是目前主流的LLM评测数据集。我们采用了&lt;a href=&#34;https://github.com/hendrycks/test&#34;&gt;开源&lt;/a&gt; 的评测方案，最终 &lt;code&gt;5-shot&lt;/code&gt; 结果如下所示：&lt;/p&gt; &#xA;&lt;h3&gt;结果&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Model&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Humanities&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Social Sciences&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;STEM&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Other&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Average&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;ChatGLM-6B&lt;sup&gt;0&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;35.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;41.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;31.3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;40.5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;36.9&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;BLOOMZ-7B&lt;sup&gt;0&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;31.3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;42.1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;34.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;39.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;36.1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;mpt-7B&lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;35.6&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;LLaMA-7B&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;34.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;38.3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;30.5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;38.1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;35.1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Falcon-7B&lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;35.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;moss-moon-003-sft (16B)&lt;sup&gt;0&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;30.5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;33.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;29.3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;34.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;31.9&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;BLOOM-7B&lt;sup&gt;0&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.0&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;24.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;26.5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;26.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25.5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;moss-moon-003-base (16B)&lt;sup&gt;0&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;24.2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;22.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;22.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;24.4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;23.6&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Baichuan-7B&lt;sup&gt;0&lt;/sup&gt;&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;38.4&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;48.9&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;35.6&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;48.1&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;42.3&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;sup&gt;0: 重新复现&lt;/sup&gt;&lt;br&gt; &lt;sup&gt;1: &lt;a href=&#34;https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard&#34;&gt;https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard&lt;/a&gt;&lt;/sup&gt;&lt;br&gt; &lt;sup&gt;2: &lt;a href=&#34;https://paperswithcode.com/sota/multi-task-language-understanding-on-mmlu&#34;&gt;https://paperswithcode.com/sota/multi-task-language-understanding-on-mmlu&lt;/a&gt;&lt;/sup&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;h3&gt;复现方法&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/hendrycks/test&#xA;cd test&#xA;wget https://people.eecs.berkeley.edu/~hendrycks/data.tar&#xA;tar xf data.tar&#xA;mkdir results&#xA;cp ../evaluate_mmlu.py .&#xA;python evaluate_mmlu.py -m /path/to/Baichuan-7B&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;其中在 MMLU 上57个任务的具体细指标如下图：&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/baichuan-inc/Baichuan-7B/main/media/MMLU-57-tasks.png&#34; width=&#34;90%&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;其中各个学科的指标如下图：&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;media/MMLU 21 Subjects.png&#34; width=&#34;90%&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;推理方法&lt;/h1&gt; &#xA;&lt;p&gt;推理代码已经在&lt;a href=&#34;https://huggingface.co/baichuan-inc/Baichuan-7B&#34;&gt;官方 Huggingface 库&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from transformers import AutoModelForCausalLM, AutoTokenizer&#xA;&#xA;tokenizer = AutoTokenizer.from_pretrained(&#34;baichuan-inc/Baichuan-7B&#34;, trust_remote_code=True)&#xA;model = AutoModelForCausalLM.from_pretrained(&#34;baichuan-inc/Baichuan-7B&#34;, device_map=&#34;auto&#34;, trust_remote_code=True)&#xA;inputs = tokenizer(&#39;登鹳雀楼-&amp;gt;王之涣\n夜雨寄北-&amp;gt;&#39;, return_tensors=&#39;pt&#39;)&#xA;inputs = inputs.to(&#39;cuda:0&#39;)&#xA;pred = model.generate(**inputs, max_new_tokens=64,repetition_penalty=1.1)&#xA;print(tokenizer.decode(pred.cpu()[0], skip_special_tokens=True))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;数据&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;原始数据包括开源的中英文数据和自行抓取的中文互联网数据，以及部分高质量知识性数据。&lt;/li&gt; &#xA; &lt;li&gt;参考相关数据工作，频率和质量是数据处理环节重点考虑的两个维度。 我们基于启发式规则和质量模型打分，对原始数据集进行篇章和句子粒度的过滤。在全量数据上，利用局部敏感哈希方法，对篇章和句子粒度做滤重。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;整体流程如下所示：&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/baichuan-inc/Baichuan-7B/main/media/data_process.png&#34; width=&#34;90%&#34;&gt; &lt;br&gt; &lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;经过不断的调整和多轮测试，最终确认了一个在下游任务上表现最好的中英文配比。&lt;/li&gt; &#xA; &lt;li&gt;我们使用了一个基于自动学习的数据权重策略，对不同类别的数据进行配比。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;分词&lt;/h1&gt; &#xA;&lt;p&gt;我们参考学术界方案使用 SentencePiece 中的 Byte-Pair Encoding (BPE) 作为分词算法，并且进行了以下的优化：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;目前大部分开源模型主要基于英文优化，因此对中文语料存在效率较低的问题。我们使用 2000 万条以中英为主的多语言语料训练分词模型，显著提升对于中文的压缩率。&lt;/li&gt; &#xA; &lt;li&gt;对于数学领域，我们参考了 LLaMA 和 Galactica 中的方案，对数字的每一位单独分开，避免出现数字不一致的问题，对于提升数学能力有重要帮助。&lt;/li&gt; &#xA; &lt;li&gt;对于罕见字词（如特殊符号等），支持 UTF-8 characters 的 byte 编码，因此做到未知字词的全覆盖。&lt;/li&gt; &#xA; &lt;li&gt;我们分析了不同分词器对语料的压缩率，如下表，可见我们的分词器明显优于 LLaMA, Falcon 等开源模型，并且对比其他中文分词器在压缩率相当的情况下，训练和推理效率更高。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Model&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Baichuan-7B&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;LLaMA&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Falcon&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;mpt-7B&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;ChatGLM&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;moss-moon-003&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Compress Rate&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.737&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.312&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.049&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.206&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.631&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.659&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Vocab Size&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;64,000&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;32,000&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;65,024&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;50,254&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;130,344&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;106,029&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;模型结构&lt;/h1&gt; &#xA;&lt;p&gt;整体模型基于标准的 Transformer 结构，我们采用了和 LLaMA 一样的模型设计&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;位置编码：&lt;a href=&#34;https://arxiv.org/abs/2104.09864&#34;&gt;rotary-embedding&lt;/a&gt; 是现阶段被大多模型采用的位置编码方案，具有更好的外延效果。虽然训练过程中最大长度为4096，但是实际测试中模型可以很好的扩展到 5000 tokens 以上，如下图：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/baichuan-inc/Baichuan-7B/main/media/long-context-ppl.png&#34; width=&#34;90%&#34;&gt; &lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;激活层：SwiGLU, Feedforward 变化为 8/3 倍的隐含层大小，即 11,008&lt;/li&gt; &#xA; &lt;li&gt;Layer-Normalization: 基于 &lt;a href=&#34;https://arxiv.org/abs/1910.07467&#34;&gt;RMSNorm&lt;/a&gt; 的 Pre-Normalization&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;训练稳定性和吞吐&lt;/h1&gt; &#xA;&lt;p&gt;我们在原本的 LLaMA 框架上进行诸多修改以提升训练时的吞吐，具体包括：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;算子优化技术：采用更高效算子，如 Flash-Attention，NVIDIA apex 的 RMSNorm 等。&lt;/li&gt; &#xA; &lt;li&gt;算子切分技术：将部分计算算子进行切分，减小内存峰值。&lt;/li&gt; &#xA; &lt;li&gt;混合精度技术：降低在不损失模型精度的情况下加速计算过程。&lt;/li&gt; &#xA; &lt;li&gt;训练容灾技术：训练平台和训练框架联合优化，IaaS + PaaS 实现分钟级的故障定位和任务恢复。&lt;/li&gt; &#xA; &lt;li&gt;通信优化技术，具体包括： &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;采用拓扑感知的集合通信算法，避免网络拥塞问题，提高通信效率。&lt;/li&gt; &#xA;   &lt;li&gt;根据卡数自适应设置 bucket size，提高带宽利用率。&lt;/li&gt; &#xA;   &lt;li&gt;根据模型和集群环境，调优通信原语的触发时机，从而将计算和通信重叠。&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;基于上述的几个优化技术，我们在千卡 A800 显卡上达到了 7B 模型 182 TFLOPS 的吞吐，GPU 峰值算力利用率高达 58.3%。&lt;/p&gt; &#xA;&lt;p&gt;最终的loss如下图：&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/baichuan-inc/Baichuan-7B/main/media/7b.loss.png&#34; width=&#34;90%&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;训练方法&lt;/h1&gt; &#xA;&lt;h2&gt;安装依赖&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install -r requirements.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;准备数据&lt;/h2&gt; &#xA;&lt;p&gt;用户将训练语料按总rank数的倍数均匀切分成多个 UTF-8 文本文件，放置在语料目录（默认为 &lt;code&gt;data_dir&lt;/code&gt; ）下。各个rank进程将会读取语料目录下的不同文件，全部加载到内存后，开始后续训练过程。以上是简化的示范流程，建议用户在正式训练任务中，根据需求调整数据生产逻辑。&lt;/p&gt; &#xA;&lt;h2&gt;下载 tokenizer 模型&lt;/h2&gt; &#xA;&lt;p&gt;下载 tokenizer 模型文件 &lt;a href=&#34;https://huggingface.co/baichuan-inc/Baichuan-7B/blob/main/tokenizer.model&#34;&gt;tokenizer.model&lt;/a&gt; ，放置在项目目录下。&lt;/p&gt; &#xA;&lt;h2&gt;配置 DeepSpeed&lt;/h2&gt; &#xA;&lt;p&gt;本示范代码采用 DeepSpeed 框架进行训练。用户需根据集群情况，修改 &lt;code&gt;config/hostfile&lt;/code&gt; ，如果是多机多卡，需要修改 ssh 中各个节点的 IP 配置。具体可以参见 DeepSpeed &lt;a href=&#34;https://www.deepspeed.ai/&#34;&gt;官方说明&lt;/a&gt; 。&lt;/p&gt; &#xA;&lt;h2&gt;执行训练&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;scripts/train.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;协议&lt;/h1&gt; &#xA;&lt;p&gt;对本仓库源码的使用遵循开源许可协议 &lt;a href=&#34;https://github.com/baichuan-inc/Baichuan-7B/raw/main/LICENSE&#34;&gt;Apache 2.0&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;p&gt;Baichuan-7B 支持商用。如果将 Baichuan-7B 模型或其衍生品用作商业用途，请您按照如下方式联系许可方，以进行登记并向许可方申请书面授权：联系邮箱：&lt;a href=&#34;mailto:opensource@baichuan-inc.com&#34;&gt;opensource@baichuan-inc.com&lt;/a&gt;， 具体许可协议可见&lt;a href=&#34;https://huggingface.co/baichuan-inc/Baichuan-7B/resolve/main/baichuan-7B%20%E6%A8%A1%E5%9E%8B%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE.pdf&#34;&gt;《Baichuan-7B 模型许可协议》&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h1&gt;Third-Party Resources&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hiyouga/LLaMA-Efficient-Tuning&#34;&gt;LLaMA Efficient Tuning&lt;/a&gt; 支持Baichuan-7B使用Qlora进行Finetune，支持RLHF，支持WebDemo。使用经过sft的模型见 &lt;a href=&#34;https://huggingface.co/hiyouga/baichuan-7b-sft&#34;&gt;hiyouga/baichuan-7b-sft&lt;/a&gt;。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://huggingface.co/fireballoon/baichuan-vicuna-chinese-7b&#34;&gt;fireballoon/baichuan-vicuna-chinese-7b&lt;/a&gt; 使用 ShareGPT, ShareGPT-ZH, COT &amp;amp; COT-ZH, Leetcode, dummy等包含中英文的数据Finetune后的模型，训练代码参考FastChat。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://huggingface.co/fireballoon/baichuan-vicuna-7b&#34;&gt;fireballoon/baichuan-vicuna-7b&lt;/a&gt; 使用ShareGPT, COT 和 Leetcode等数据混合Finetune后的模型，训练代码参考FastChat。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jianzhnie/Efficient-Tuning-LLMs&#34;&gt;Efficient-Tuning-LLMs&lt;/a&gt; 支持Baichuan-7B使用Qlora进行Finetune和4bit inference。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ztxz16/fastllm&#34;&gt;fastllm&lt;/a&gt; fastllm是纯c++实现，无第三方依赖的大模型库，支持Baichuan-7B在手机端运行。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://huggingface.co/TheBloke/baichuan-7B-GPTQ&#34;&gt;TheBloke/baichuan-7B-GPTQ&lt;/a&gt; 对Baichuan-7B的GPTQ 4bit量化。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Star History&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://star-history.com/#baichuan-inc/Baichuan-7B&amp;amp;Date&#34;&gt;&lt;img src=&#34;https://api.star-history.com/svg?repos=baichuan-inc/Baichuan-7B&amp;amp;type=Date&#34; alt=&#34;Star History Chart&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>pynecone-io/reflex</title>
    <updated>2023-07-13T01:45:28Z</updated>
    <id>tag:github.com,2023-07-13:/pynecone-io/reflex</id>
    <link href="https://github.com/pynecone-io/reflex" rel="alternate"></link>
    <summary type="html">&lt;p&gt;🕸 Web apps in pure Python 🐍&lt;/p&gt;&lt;hr&gt;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;+ Searching for Pynecone? You are in the right repo. Pynecone has been renamed to Reflex. +&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/pynecone-io/reflex/main/docs/images/reflex.png&#34;&gt; &#xA; &lt;hr&gt; &#xA; &lt;h1&gt;&lt;strong&gt;Reflex&lt;/strong&gt;&lt;/h1&gt; &#xA; &lt;p&gt;&lt;strong&gt;✨ Performant, customizable web apps in pure Python. Deploy in seconds.&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;📑 &lt;a href=&#34;https://reflex.dev/docs/getting-started/introduction&#34;&gt;Docs&lt;/a&gt; &amp;nbsp; 📱 &lt;a href=&#34;https://reflex.dev/docs/library&#34;&gt;Component Library&lt;/a&gt; &amp;nbsp; 🖼️ &lt;a href=&#34;https://reflex.dev/docs/gallery&#34;&gt;Gallery&lt;/a&gt; &amp;nbsp; 🛸 &lt;a href=&#34;https://reflex.dev/docs/hosting/deploy&#34;&gt;Deployment&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://badge.fury.io/py/reflex&#34;&gt;&lt;img src=&#34;https://badge.fury.io/py/reflex.svg?sanitize=true&#34; alt=&#34;PyPI version&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/pynecone-io/pynecone/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;tests&#34;&gt; &lt;img src=&#34;https://img.shields.io/pypi/pyversions/reflex.svg?sanitize=true&#34; alt=&#34;versions&#34;&gt; &lt;a href=&#34;https://discord.gg/T5WSbC2YtQ&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/1029853095527727165?color=%237289da&amp;amp;label=Discord&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h3&gt;README in different language&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pynecone-io/reflex/main/README.md&#34;&gt;English&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/pynecone-io/reflex/main/docs/zh/zh_tw/README.md&#34;&gt;繁體中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;📦 1. Install&lt;/h2&gt; &#xA;&lt;p&gt;Reflex requires the following to get started:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Python 3.7+&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nodejs.org/en/&#34;&gt;Node.js 16.8.0+&lt;/a&gt; (Don&#39;t worry, you won’t have to write any JavaScript!)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip install reflex&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;🥳 2. Create your first app&lt;/h2&gt; &#xA;&lt;p&gt;Installing &lt;code&gt;reflex&lt;/code&gt; also installs the &lt;code&gt;reflex&lt;/code&gt; command line tool. Test that the install was successful by creating a new project.&lt;/p&gt; &#xA;&lt;p&gt;Replace my_app_name with your project name:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mkdir my_app_name&#xA;cd my_app_name&#xA;reflex init&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you run this command for the first time, we will download and install &lt;a href=&#34;https://bun.sh/&#34;&gt;bun&lt;/a&gt; automatically.&lt;/p&gt; &#xA;&lt;p&gt;This command initializes a template app in your new directory.&lt;/p&gt; &#xA;&lt;h2&gt;🏃 3. Run your app&lt;/h2&gt; &#xA;&lt;p&gt;You can run this app in development mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;reflex run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should see your app running at &lt;a href=&#34;http://localhost:3000&#34;&gt;http://localhost:3000&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Now you can modify the source code in &lt;code&gt;my_app_name/my_app_name.py&lt;/code&gt;. Reflex has fast refreshes so you can see your changes instantly when you save your code.&lt;/p&gt; &#xA;&lt;h2&gt;🫧 Example&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s go over an example: creating an image generation UI around DALL·E. For simplicity, we just call the OpenAI API, but you could replace this with an ML model run locally.&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp;&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/pynecone-io/reflex/main/docs/images/dalle.gif&#34; alt=&#34;A frontend wrapper for DALL·E, shown in the process of generating an image.&#34; width=&#34;550&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;&amp;nbsp;&lt;/p&gt; &#xA;&lt;p&gt;Here is the complete code to create this. This is all done in one Python file!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import reflex as rx&#xA;import openai&#xA;&#xA;openai.api_key = &#34;YOUR_API_KEY&#34;&#xA;&#xA;class State(rx.State):&#xA;    &#34;&#34;&#34;The app state.&#34;&#34;&#34;&#xA;    prompt = &#34;&#34;&#xA;    image_url = &#34;&#34;&#xA;    processing = False&#xA;    complete = False&#xA;&#xA;    def get_image(self):&#xA;        &#34;&#34;&#34;Get the image from the prompt.&#34;&#34;&#34;&#xA;        if self.prompt == &#34;&#34;:&#xA;            return rx.window_alert(&#34;Prompt Empty&#34;)&#xA;&#xA;        self.processing, self.complete = True, False&#xA;        yield&#xA;        response = openai.Image.create(prompt=self.prompt, n=1, size=&#34;1024x1024&#34;)&#xA;        self.image_url = response[&#34;data&#34;][0][&#34;url&#34;]&#xA;        self.processing, self.complete = False, True&#xA;        &#xA;&#xA;def index():&#xA;    return rx.center(&#xA;        rx.vstack(&#xA;            rx.heading(&#34;DALL·E&#34;),&#xA;            rx.input(placeholder=&#34;Enter a prompt&#34;, on_blur=State.set_prompt),&#xA;            rx.button(&#xA;                &#34;Generate Image&#34;,&#xA;                on_click=State.get_image,&#xA;                is_loading=State.processing,&#xA;                width=&#34;100%&#34;,&#xA;            ),&#xA;            rx.cond(&#xA;                State.complete,&#xA;                     rx.image(&#xA;                         src=State.image_url,&#xA;                         height=&#34;25em&#34;,&#xA;                         width=&#34;25em&#34;,&#xA;                    )&#xA;            ),&#xA;            padding=&#34;2em&#34;,&#xA;            shadow=&#34;lg&#34;,&#xA;            border_radius=&#34;lg&#34;,&#xA;        ),&#xA;        width=&#34;100%&#34;,&#xA;        height=&#34;100vh&#34;,&#xA;    )&#xA;&#xA;# Add state and page to the app.&#xA;app = rx.App(state=State)&#xA;app.add_page(index, title=&#34;reflex:DALL·E&#34;)&#xA;app.compile()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s break this down.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;strong&gt;UI In Reflex&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s start with the UI.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def index():&#xA;    return rx.center(&#xA;        ...&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This &lt;code&gt;index&lt;/code&gt; function defines the frontend of the app.&lt;/p&gt; &#xA;&lt;p&gt;We use different components such as &lt;code&gt;center&lt;/code&gt;, &lt;code&gt;vstack&lt;/code&gt;, &lt;code&gt;input&lt;/code&gt;, and &lt;code&gt;button&lt;/code&gt; to build the frontend. Components can be nested within each other to create complex layouts. And you can use keyword args to style them with the full power of CSS.&lt;/p&gt; &#xA;&lt;p&gt;Reflex comes with &lt;a href=&#34;https://reflex.dev/docs/library&#34;&gt;60+ built-in components&lt;/a&gt; to help you get started. We are actively adding more components, and it&#39;s easy to &lt;a href=&#34;https://reflex.dev/docs/advanced-guide/wrapping-react&#34;&gt;create your own components&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;strong&gt;State&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Reflex represents your UI as a function of your state.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class State(rx.State):&#xA;    &#34;&#34;&#34;The app state.&#34;&#34;&#34;&#xA;    prompt = &#34;&#34;&#xA;    image_url = &#34;&#34;&#xA;    processing = False&#xA;    complete = False&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The state defines all the variables (called vars) in an app that can change and the functions that change them.&lt;/p&gt; &#xA;&lt;p&gt;Here the state is comprised of a &lt;code&gt;prompt&lt;/code&gt; and &lt;code&gt;image_url&lt;/code&gt;. There are also the booleans &lt;code&gt;processing&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt; to indicate when to show the circular progress and image.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;strong&gt;Event Handlers&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get_image(self):&#xA;    &#34;&#34;&#34;Get the image from the prompt.&#34;&#34;&#34;&#xA;    if self.prompt == &#34;&#34;:&#xA;        return rx.window_alert(&#34;Prompt Empty&#34;)&#xA;&#xA;    self.processing, self.complete = True, False&#xA;    yield&#xA;    response = openai.Image.create(prompt=self.prompt, n=1, size=&#34;1024x1024&#34;)&#xA;    self.image_url = response[&#34;data&#34;][0][&#34;url&#34;]&#xA;    self.processing, self.complete = False, True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Within the state, we define functions called event handlers that change the state vars. Event handlers are the way that we can modify the state in Reflex. They can be called in response to user actions, such as clicking a button or typing in a text box. These actions are called events.&lt;/p&gt; &#xA;&lt;p&gt;Our DALL·E. app has an event handler, &lt;code&gt;get_image&lt;/code&gt; to which get this image from the OpenAI API. Using &lt;code&gt;yield&lt;/code&gt; in the middle of an event handler will cause the UI to update. Otherwise the UI will update at the end of the event handler.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;strong&gt;Routing&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Finally, we define our app and pass it our state.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app = rx.App(state=State)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We add a route from the root of the app to the index component. We also add a title that will show up in the page preview/browser tab.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app.add_page(index, title=&#34;DALL-E&#34;)&#xA;app.compile()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can create a multi-page app by adding more routes.&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;Reflex launched in December 2022 with the name Pynecone.&lt;/p&gt; &#xA;&lt;p&gt;As of June 2023, we are in the &lt;strong&gt;Public Beta&lt;/strong&gt; stage.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;span&gt;✅&lt;/span&gt; &lt;strong&gt;Public Alpha&lt;/strong&gt;: Anyone can install and use Reflex. There may be issues, but we are working to resolve them actively.&lt;/li&gt; &#xA; &lt;li&gt;&lt;span&gt;🔶&lt;/span&gt; &lt;strong&gt;Public Beta&lt;/strong&gt;: Stable enough for non-enterprise use-cases.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Public Hosting Beta&lt;/strong&gt;: &lt;em&gt;Optionally&lt;/em&gt;, deploy and host your apps on Reflex!&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Public&lt;/strong&gt;: Reflex is production ready.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Reflex has new releases and features coming every week! Make sure to &lt;span&gt;⭐&lt;/span&gt; star and &lt;span&gt;👀&lt;/span&gt; watch this repository to stay up to date.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We welcome contributions of any size! Below are some good ways to get started in the Reflex community.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Join Our Discord&lt;/strong&gt;: Our &lt;a href=&#34;https://discord.gg/T5WSbC2YtQ&#34;&gt;Discord&lt;/a&gt; is the best place to get help on your Reflex project and to discuss how you can contribute.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;GitHub Discussions&lt;/strong&gt;: A great way to talk about features you want added or things that are confusing/need clarification.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;GitHub Issues&lt;/strong&gt;: These are an excellent way to report bugs. Additionally, you can try and solve an existing issue and submit a PR.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We are actively looking for contributors, no matter your skill level or experience.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Reflex is open-source and licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/pynecone-io/reflex/main/LICENSE&#34;&gt;Apache License 2.0&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>