<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Python Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-07T01:38:25Z</updated>
  <subtitle>Daily Trending of Python in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>guoqincode/Open-AnimateAnyone</title>
    <updated>2024-01-07T01:38:25Z</updated>
    <id>tag:github.com,2024-01-07:/guoqincode/Open-AnimateAnyone</id>
    <link href="https://github.com/guoqincode/Open-AnimateAnyone" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Unofficial Implementation of Animate Anyone&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Unofficial Implementation of Animate Anyone&lt;/h1&gt; &#xA;&lt;p&gt;If you find this repository helpful, please consider giving us a star‚≠ê!&lt;/p&gt; &#xA;&lt;p&gt;We only train on small-scale datasets (such as TikTok, UBC), and it is difficult to achieve official results under the condition of insufficient data scale and quality. Because of the consideration of time and cost, we do not intend to collect and filter a large number of high-quality data. If someone has a robust model trained on a large amount of high-quality data and is willing to share it, make a pull request.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;This repository contains an simple and unofficial implementation of &lt;a href=&#34;https://humanaigc.github.io/animate-anyone/&#34;&gt;Animate Anyone&lt;/a&gt;. This project is built upon &lt;a href=&#34;https://github.com/magic-research/magic-animate/tree/main&#34;&gt;magic-animate&lt;/a&gt; and &lt;a href=&#34;https://github.com/guoyww/AnimateDiff&#34;&gt;AnimateDiff&lt;/a&gt;. This implementation is first developed by &lt;a href=&#34;https://github.com/guoqincode&#34;&gt;Qin Guo&lt;/a&gt; and then assisted by &lt;a href=&#34;https://zhenzhiwang.github.io/&#34;&gt;Zhenzhi Wang&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;News ü§óü§óü§ó&lt;/h2&gt; &#xA;&lt;p&gt;The first training phase basic test passed, currently in training and testing the second phase.&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;Training may be slow due to GPU shortage.üò¢&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;It only takes a few days to release the weights.üòÑ&lt;/p&gt; &#xA;&lt;h2&gt;Sample of Result on UBC-fashion dataset&lt;/h2&gt; &#xA;&lt;h3&gt;Stage 1&lt;/h3&gt; &#xA;&lt;p&gt;The current version of the face still has some artifacts. This model is trained on the UBC dataset rather than a large-scale dataset.&lt;/p&gt; &#xA;&lt;table class=&#34;center&#34;&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt;&#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/guoqincode/Open-AnimateAnyone/main/assets/stage1/1.png&#34;&gt;&lt;/td&gt;&#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/guoqincode/Open-AnimateAnyone/main/assets/stage1/2.png&#34;&gt;&lt;/td&gt;&#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt;&#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/guoqincode/Open-AnimateAnyone/main/assets/stage1/3.png&#34;&gt;&lt;/td&gt;&#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/guoqincode/Open-AnimateAnyone/main/assets/stage1/8.png&#34;&gt;&lt;/td&gt;&#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt;&#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/guoqincode/Open-AnimateAnyone/main/assets/stage1/9.png&#34;&gt;&lt;/td&gt;&#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/guoqincode/Open-AnimateAnyone/main/assets/stage1/10.png&#34;&gt;&lt;/td&gt;&#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt;&#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/guoqincode/Open-AnimateAnyone/main/assets/stage1/4.png&#34;&gt;&lt;/td&gt;&#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/guoqincode/Open-AnimateAnyone/main/assets/stage1/5.png&#34;&gt;&lt;/td&gt;&#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt;&#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/guoqincode/Open-AnimateAnyone/main/assets/stage1/6.png&#34;&gt;&lt;/td&gt;&#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/guoqincode/Open-AnimateAnyone/main/assets/stage1/7.png&#34;&gt;&lt;/td&gt;&#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p style=&#34;margin-left: 2em; margin-top: -1em&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Stage 2&lt;/h3&gt; &#xA;&lt;p&gt;The training of stage2 is challenging due to artifacts in the background. We select one of our best results here, and are still working on it. An important point is to ensure that training and inference resolution is consistent.&lt;/p&gt; &#xA;&lt;table class=&#34;center&#34;&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt;&#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/guoqincode/Open-AnimateAnyone/main/assets/stage2/1.gif&#34;&gt;&lt;/td&gt;&#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p style=&#34;margin-left: 2em; margin-top: -1em&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Note !!!&lt;/h2&gt; &#xA;&lt;p&gt;This project is under continuous development in part-time, there may be bugs in the code, welcome to correct them, I will optimize the code after the pre-trained model is released!&lt;/p&gt; &#xA;&lt;p&gt;In the current version, we recommend training on 8 or 16 A100,H100 (80G) at 512 or 768 resolution. &lt;strong&gt;Low resolution (256,384) does not give good results!!!(VAE is very poor at reconstruction at low resolution.)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;ToDo&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;strong&gt;Release Training Code.&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;strong&gt;Release Inference Code.&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;strong&gt;Release Unofficial Pre-trained Weights.&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;strong&gt;Release Gradio Demo.&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash fast_env.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;üé¨Gradio Demo&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;python3 -m demo.gradio_animate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a 13-second pose video, processing at 256 resolution requires 11G VRAM, and at 512 resolution, it requires 23.5G VRAM.&lt;/p&gt; &#xA;&lt;h2&gt;Training&lt;/h2&gt; &#xA;&lt;h3&gt;Original AnimateAnyone Architecture (It is difficult to control pose when training on a small dataset.)&lt;/h3&gt; &#xA;&lt;h4&gt;First Stage&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torchrun --nnodes=8 --nproc_per_node=8 train.py --config configs/training/train_stage_1.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Second Stage&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torchrun --nnodes=8 --nproc_per_node=8 train.py --config configs/training/train_stage_2.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Our Method (A more dense pose control scheme, the number of parameters is still small.) (Highly recommended)&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torchrun --nnodes=8 --nproc_per_node=8 train_hack.py --config configs/training/train_stage_1.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Second Stage&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torchrun --nnodes=8 --nproc_per_node=8 train_hack.py --config configs/training/train_stage_2.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;Special thanks to the original authors of the &lt;a href=&#34;https://humanaigc.github.io/animate-anyone/&#34;&gt;Animate Anyone&lt;/a&gt; project and the contributors to the &lt;a href=&#34;https://github.com/magic-research/magic-animate/tree/main&#34;&gt;magic-animate&lt;/a&gt; and &lt;a href=&#34;https://github.com/guoyww/AnimateDiff&#34;&gt;AnimateDiff&lt;/a&gt; repository for their open research and foundational work that inspired this unofficial implementation.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>facebookresearch/audio2photoreal</title>
    <updated>2024-01-07T01:38:25Z</updated>
    <id>tag:github.com,2024-01-07:/facebookresearch/audio2photoreal</id>
    <link href="https://github.com/facebookresearch/audio2photoreal" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Code and dataset for photorealistic Codec Avatars driven from audio&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;From Audio to Photoreal Embodiment: Synthesizing Humans in Conversations&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains a pytorch implementation of &lt;a href=&#34;https://people.eecs.berkeley.edu/~evonne_ng/projects/audio2photoreal/&#34;&gt;&#34;From Audio to Photoreal Embodiment: Synthesizing Humans in Conversations&#34;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/facebookresearch/audio2photoreal/assets/17986358/5cba4079-275e-48b6-aecc-f84f3108c810&#34;&gt;https://github.com/facebookresearch/audio2photoreal/assets/17986358/5cba4079-275e-48b6-aecc-f84f3108c810&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This codebase provides:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;train code&lt;/li&gt; &#xA; &lt;li&gt;test code&lt;/li&gt; &#xA; &lt;li&gt;pretrained motion models&lt;/li&gt; &#xA; &lt;li&gt;access to dataset&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you use the dataset or code, please cite our &lt;a href=&#34;https://arxiv.org/abs/2401.01885&#34;&gt;Paper&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@article{ng2024audio2photoreal,&#xA;  title={From Audio to Photoreal Embodiment: Synthesizing Humans in Conversations},&#xA;  author={Ng, Evonne and Romero, Javier and Bagautdinov, Timur and Bai, Shaojie and Darrell, Trevor and Kanazawa, Angjoo and Richard, Alexander},&#xA;  journal={arXiv preprint arXiv:2401.01885},&#xA;  year={2024}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Repository Contents&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#quickstart&#34;&gt;&lt;strong&gt;Quickstart:&lt;/strong&gt;&lt;/a&gt; easy gradio demo that lets you record audio and render a video&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#installation&#34;&gt;&lt;strong&gt;Installation:&lt;/strong&gt;&lt;/a&gt; environment setup and installation (for more details on the rendering pipeline, please refer to &lt;a href=&#34;https://github.com/facebookresearch/ca_body&#34;&gt;Codec Avatar Body&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#download-data-and-models&#34;&gt;&lt;strong&gt;Download data and models:&lt;/strong&gt;&lt;/a&gt; download annotations and pre-trained models &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#dataset&#34;&gt;Dataset desc.&lt;/a&gt;: description of dataset annotations&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#visualize-ground-truth&#34;&gt;Visualize Dataset&lt;/a&gt;: script for visualizing ground truth annotations&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#pretrained-models&#34;&gt;model desc.&lt;/a&gt;: description of pretrained models&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#running-the-pretrained-models&#34;&gt;&lt;strong&gt;Running the pretrained models:&lt;/strong&gt;&lt;/a&gt; how to generate results files and visualize the results using the rendering pipeline. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#face-generation&#34;&gt;Face generation&lt;/a&gt;: commands to generate the results file for the faces&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#body-generation&#34;&gt;Body generation&lt;/a&gt;: commands to generate the results file for the bodies&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#visualization&#34;&gt;Visualization&lt;/a&gt;: how to call into the rendering api. For full details, please refer to &lt;a href=&#34;https://github.com/facebookresearch/ca_body&#34;&gt;this repo&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#training-from-scratch&#34;&gt;&lt;strong&gt;Training from scratch (3 models):&lt;/strong&gt;&lt;/a&gt; scripts to get the training pipeline running from scratch for face, guide poses, and body models. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#1-face-diffusion-model&#34;&gt;Face diffusion model&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#2-body-diffusion-model&#34;&gt;Body diffusion&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#3-body-vq-vae&#34;&gt;Body vq vae&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#4-body-guide-transformer&#34;&gt;Body guide transformer&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We annotate code that you can directly copy and paste into your terminal using the &lt;span&gt;üëá&lt;/span&gt; icon.&lt;/p&gt; &#xA;&lt;h1&gt;Quickstart&lt;/h1&gt; &#xA;&lt;p&gt;With this demo, you can record an audio clip and select the number of samples you want to generate.&lt;/p&gt; &#xA;&lt;p&gt;Make sure you have CUDA 11.7 and gcc/++ 9.0 for pytorch3d compatibility&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; Install necessary components. This will do the environment configuration and install the corresponding rendering assets, prerequisite models, and pretrained models:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;conda create --name a2p_env python=3.9&#xA;conda activate a2p_env&#xA;sh demo/install.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; Run the demo. You can record your audio and then render corresponding results!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m demo.demo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;üé§&lt;/span&gt; First, record your audio&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/assets/demo1.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;‚åõ&lt;/span&gt; Hold tight because the rendering can take a while!&lt;/p&gt; &#xA;&lt;p&gt;You can change the number of samples (1-10) you want to generate, and download your favorite video by clicking on the download button on the top right of each video.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/assets/demo2.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;The code has been tested with CUDA 11.7 and python 3.9, gcc/++ 9.0&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; If you haven&#39;t done so already via the demo setup, configure the environments and download prerequisite models:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;conda create --name a2p_env python=3.9&#xA;conda activate a2p_env&#xA;pip install -r scripts/requirements.txt&#xA;sh scripts/download_prereq.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; To get the rendering working, please also make sure you install &lt;a href=&#34;https://github.com/facebookresearch/pytorch3d/raw/main/INSTALL.md&#34;&gt;pytorch3d&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip install &#34;git+https://github.com/facebookresearch/pytorch3d.git&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/facebookresearch/ca_body&#34;&gt;CA Bodies repo&lt;/a&gt; for more details on the renderer.&lt;/p&gt; &#xA;&lt;h1&gt;Download data and models&lt;/h1&gt; &#xA;&lt;p&gt;To download any of the datasets, you can find them at &lt;code&gt;https://github.com/facebookresearch/audio2photoreal/releases/download/v1.0/&amp;lt;person_id&amp;gt;.zip&lt;/code&gt;, where you can replace &lt;code&gt;&amp;lt;person_id&amp;gt;&lt;/code&gt; with any of &lt;code&gt;PXB184&lt;/code&gt;, &lt;code&gt;RLW104&lt;/code&gt;, &lt;code&gt;TXB805&lt;/code&gt;, or &lt;code&gt;GQS883&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;wget https://github.com/facebookresearch/audio2photoreal/releases/download/v1.0/&amp;lt;person_id&amp;gt;.zip&#xA;unzip &amp;lt;person_id&amp;gt;.zip -d dataset/&#xA;rm &amp;lt;person_id&amp;gt;.zip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; To download &lt;em&gt;all&lt;/em&gt; of the datasets, you can simply run the following which will download and unpack all the models.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sh scripts/download_alldatasets.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, to download any of the models, you can find them at &lt;code&gt;http://audio2photoreal_models.berkeleyvision.org/&amp;lt;person_id&amp;gt;_models.tar&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# download the motion generation&#xA;wget http://audio2photoreal_models.berkeleyvision.org/&amp;lt;person_id&amp;gt;_models.tar&#xA;tar xvf &amp;lt;person_id&amp;gt;_models.tar&#xA;rm &amp;lt;person_id&amp;gt;_models.tar&#xA;&#xA;# download the body decoder/rendering assets and place them in the right place&#xA;mkdir -p checkpoints/ca_body/data/&#xA;wget https://github.com/facebookresearch/ca_body/releases/download/v0.0.1-alpha/&amp;lt;person_id&amp;gt;.tar.gz&#xA;tar xvf &amp;lt;person_id&amp;gt;.tar.gz --directory checkpoints/ca_body/data/&#xA;rm &amp;lt;person_id&amp;gt;.tar.gz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; You can also download all of the models with this script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sh scripts/download_allmodels.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above model script will download &lt;em&gt;both&lt;/em&gt; the models for motion generation and the body decoder/rendering models. Please view the script for more details.&lt;/p&gt; &#xA;&lt;h3&gt;Dataset&lt;/h3&gt; &#xA;&lt;p&gt;Once the dataset is downloaded and unzipped (via &lt;code&gt;scripts/download_datasets.sh&lt;/code&gt;), it should unfold into the following directory structure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;|-- dataset/&#xA;    |-- PXB184/&#xA;        |-- data_stats.pth &#xA;        |-- scene01_audio.wav&#xA;        |-- scene01_body_pose.npy&#xA;        |-- scene01_face_expression.npy&#xA;        |-- scene01_missing_face_frames.npy&#xA;        |-- ...&#xA;        |-- scene30_audio.wav&#xA;        |-- scene30_body_pose.npy&#xA;        |-- scene30_face_expression.npy&#xA;        |-- scene30_missing_face_frames.npy&#xA;    |-- RLW104/&#xA;    |-- TXB805/&#xA;    |-- GQS883/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each of the four participants (&lt;code&gt;PXB184&lt;/code&gt;, &lt;code&gt;RLW104&lt;/code&gt;, &lt;code&gt;TXB805&lt;/code&gt;, &lt;code&gt;GQS883&lt;/code&gt;) should have independent &#34;scenes&#34; (1 to 26 or so). For each scene, there are 3 types of data annotations that we save.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*audio.wav: wavefile contining the raw audio (two channels, 1600*T samples) at 48kHz; channel 0 is the audio associated with the current person, channel 1 is the audio associated with their conversational partner.&#xA;&#xA;*body_pose.npy: (T x 104) array of joint angles in a kinematic skeleton. Not all of the joints are represented with 3DoF. Each 104-d vector can be used to reconstruct a full-body skeleton.&#xA;&#xA;*face_expression.npy: (T x 256) array of facial codes, where each 256-d vector reconstructs a face mesh.&#xA;&#xA;*missing_face_frames.npy: List of indices (t) where the facial code is missing or corrupted. &#xA;&#xA;data_stats.pth: carries the mean and std for each modality of each person.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For the train/val/test split the indices are defined in &lt;code&gt;data_loaders/data.py&lt;/code&gt; as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;train_idx = list(range(0, len(data_dict[&#34;data&#34;]) - 6))&#xA;val_idx = list(range(len(data_dict[&#34;data&#34;]) - 6, len(data_dict[&#34;data&#34;]) - 4))&#xA;test_idx = list(range(len(data_dict[&#34;data&#34;]) - 4, len(data_dict[&#34;data&#34;])))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;for any of the four dataset participants we train on.&lt;/p&gt; &#xA;&lt;h3&gt;Visualize ground truth&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;ve properly installed the rendering requirements, you can then visualize the full dataset with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m visualize.render_anno &#xA;    --save_dir &amp;lt;path/to/save/dir&amp;gt; &#xA;    --data_root &amp;lt;path/to/data/root&amp;gt; &#xA;    --max_seq_length &amp;lt;num&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The videos will be chunked lengths according to specified &lt;code&gt;--max_seq_length&lt;/code&gt; arg, which you can specify (the default is 600).&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; For example, to visualize ground truth annotations for &lt;code&gt;PXB184&lt;/code&gt;, you can run the following.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m visualize.render_anno --save_dir vis_anno_test --data_root dataset/PXB184 --max_seq_length 600&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Pretrained models&lt;/h3&gt; &#xA;&lt;p&gt;We train person-specific models, so each person should have an associated directory. For instance, for &lt;code&gt;PXB184&lt;/code&gt;, their complete models should unzip into the following structure.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;|-- checkpoints/&#xA;    |-- diffusion/&#xA;        |-- c1_face/&#xA;            |-- args.json&#xA;            |-- model:09d.pt&#xA;        |-- c1_pose/&#xA;            |-- args.json&#xA;            |-- model:09d.pt&#xA;    |-- guide/&#xA;        |-- c1_pose/&#xA;            |-- args.json&#xA;            |-- checkpoints/&#xA;                |-- iter-:07d.pt&#xA;    |-- vq/&#xA;        |-- c1_pose/&#xA;            |-- args.json&#xA;            |-- net_iter:06d.pth&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are 4 models for each person and each model has an associated &lt;code&gt;args.json&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;a face diffusion model that outputs 256 facial codes conditioned on audio&lt;/li&gt; &#xA; &lt;li&gt;a pose diffusion model that outputs 104 joint rotations conditioned on audio and guide poses&lt;/li&gt; &#xA; &lt;li&gt;a guide vq pose model that outputs vq tokens conditioned on audio at 1 fps&lt;/li&gt; &#xA; &lt;li&gt;a vq encoder-decoder model that vector quantizes the continuous 104-d pose space.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Running the pretrained models&lt;/h1&gt; &#xA;&lt;p&gt;To run the actual models, you will need to run the pretrained models and generate the associated results files before visualizing them.&lt;/p&gt; &#xA;&lt;h3&gt;Face generation&lt;/h3&gt; &#xA;&lt;p&gt;To generate the results file for the face,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m sample.generate &#xA;    --model_path &amp;lt;path/to/model&amp;gt; &#xA;    --num_samples &amp;lt;xsamples&amp;gt; &#xA;    --num_repetitions &amp;lt;xreps&amp;gt; &#xA;    --timestep_respacing ddim500 &#xA;    --guidance_param 10.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;&amp;lt;path/to/model&amp;gt;&lt;/code&gt; should be the path to the diffusion model that is associated with generating the face. E.g. for participant &lt;code&gt;PXB184&lt;/code&gt;, the path might be &lt;code&gt;./checkpoints/diffusion/c1_face/model000155000.pt&lt;/code&gt; The other parameters are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--num_samples: number of samples to generate. To sample the full dataset, use 56 (except for TXB805, whcih is 58).&#xA;--num_repetitions: number of times to repeat the sampling, such that total number of sequences generated is (num_samples * num_repetitions). &#xA;--timestep_respacing: how many diffusion steps to take. Format will always be ddim&amp;lt;number&amp;gt;.&#xA;--guidance_param: how influential the conditioning is on the results. I usually use range 2.0-10.0, and tend towards higher for the face.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; A full example of running the face model for &lt;code&gt;PXB184&lt;/code&gt; with the provided pretrained models would then be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m sample.generate --model_path checkpoints/diffusion/c1_face/model000155000.pt --num_samples 10 --num_repetitions 5 --timestep_respacing ddim500 --guidance_param 10.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This generates 10 samples from the dataset 1 time. The output results file will be saved to: &lt;code&gt;./checkpoints/diffusion/c1_face/samples_c1_face_000155000_seed10_/results.npy&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Body generation&lt;/h3&gt; &#xA;&lt;p&gt;To generate the corresponding body, it will be very similar to generating the face, except now we have to feed in the model for generating the guide poses as well.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m sample.generate &#xA;    --model_path &amp;lt;path/to/model&amp;gt; &#xA;    --resume_trans &amp;lt;path/to/guide/model&amp;gt; &#xA;    --num_samples &amp;lt;xsamples&amp;gt; &#xA;    --num_repetitions &amp;lt;xreps&amp;gt; &#xA;    --timestep_respacing ddim500 &#xA;    --guidance_param 10.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; Here, &lt;code&gt;&amp;lt;path/to/guide/model&amp;gt;&lt;/code&gt; should point to the guide transformer. The full command would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m sample.generate --model_path checkpoints/diffusion/c1_pose/model000340000.pt --resume_trans checkpoints/guide/c1_pose/checkpoints/iter-0100000.pt --num_samples 10 --num_repetitions 5 --timestep_respacing ddim500 --guidance_param 10.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, the output will be saved to: &lt;code&gt;./checkpoints/diffusion/c1_pose/samples_c1_pose_000340000_seed10_guide_iter-0100000.pt/results.npy&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Visualization&lt;/h3&gt; &#xA;&lt;p&gt;On the body generation side of things, you can also optionally pass in the &lt;code&gt;--plot&lt;/code&gt; flag in order to render out the photorealistic avatar. You will also need to pass in the corresponding generated face codes with the &lt;code&gt;--face_codes&lt;/code&gt; flag. Optionally, if you already have the poses precomputed, you an also pass in the generated body with the &lt;code&gt;--pose_codes&lt;/code&gt; flag. This will save videos in the same directory as where the body&#39;s &lt;code&gt;results.npy&lt;/code&gt; is stored.&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; An example of the full command with &lt;em&gt;the three new flags added is&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m sample.generate --model_path checkpoints/diffusion/c1_pose/model000340000.pt --resume_trans checkpoints/guide/c1_pose/checkpoints/iter-0100000.pt --num_samples 10 --num_repetitions 5 --timestep_respacing ddim500 --guidance_param 10.0 --face_codes ./checkpoints/diffusion/c1_face/samples_c1_face_000155000_seed10_/results.npy --pose_codes ./checkpoints/diffusion/c1_pose/samples_c1_pose_000340000_seed10_guide_iter-0100000.pt/results.npy --plot&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The remaining flags can be the same as before. For the actual rendering api, please see &lt;a href=&#34;https://github.com/facebookresearch/ca_body&#34;&gt;Codec Avatar Body&lt;/a&gt; for installation etc. &lt;em&gt;Important: in order to visualize the full photorealistic avatar, you will need to run the face codes first, then pass them into the body generation code.&lt;/em&gt; It will not work if you try to call generate with &lt;code&gt;--plot&lt;/code&gt; for the face codes.&lt;/p&gt; &#xA;&lt;h1&gt;Training from scratch&lt;/h1&gt; &#xA;&lt;p&gt;There are four possible models you will need to train: 1) the face diffusion model, 2) the body diffusion model, 3) the body vq vae, 4) the body guide transformer. The only dependency is that 3) is needed for 4). All other models can be trained in parallel.&lt;/p&gt; &#xA;&lt;h3&gt;1) Face diffusion model&lt;/h3&gt; &#xA;&lt;p&gt;To train the face model, you will need to run the following script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m train.train_diffusion &#xA;    --save_dir &amp;lt;path/to/save/dir&amp;gt;&#xA;    --data_root &amp;lt;path/to/data/root&amp;gt;&#xA;    --batch_size &amp;lt;bs&amp;gt;&#xA;    --dataset social  &#xA;    --data_format face &#xA;    --layers 8 &#xA;    --heads 8 &#xA;    --timestep_respacing &#39;&#39;&#xA;    --max_seq_length 600&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Importantly, a few of the flags are as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--save_dir: path to directory where all outputs are stored&#xA;--data_root: path to the directory of where to load the data from&#xA;--dataset: name of dataset to load; right now we only support the &#39;social&#39; dataset&#xA;--data_format: set to &#39;face&#39; for the face, as opposed to pose&#xA;--timestep_respacing: set to &#39;&#39; which does the default spacing of 1k diffusion steps&#xA;--max_seq_length: the maximum number of frames for a given sequence to train on&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; A full example for training on person &lt;code&gt;PXB184&lt;/code&gt; is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m train.train_diffusion --save_dir checkpoints/diffusion/c1_face_test --data_root ./dataset/PXB184/ --batch_size 4 --dataset social --data_format face --layers 8 --heads 8 --timestep_respacing &#39;&#39; --max_seq_length 600&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;2) Body diffusion model&lt;/h3&gt; &#xA;&lt;p&gt;Training the body model is similar to the face model, but with the following additional parameters&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m train.train_diffusion &#xA;    --save_dir &amp;lt;path/to/save/dir&amp;gt; &#xA;    --data_root &amp;lt;path/to/data/root&amp;gt;&#xA;    --lambda_vel &amp;lt;num&amp;gt;&#xA;    --batch_size &amp;lt;bs&amp;gt; &#xA;    --dataset social &#xA;    --add_frame_cond 1 &#xA;    --data_format pose &#xA;    --layers 6 &#xA;    --heads 8 &#xA;    --timestep_respacing &#39;&#39; &#xA;    --max_seq_length 600&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The flags that differ from the face training are as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--lambda_vel: additional auxilary loss for training with velocity&#xA;--add_frame_cond: set to &#39;1&#39; for 1 fps. if not specified, it will default to 30 fps.&#xA;--data_format: set to &#39;pose&#39; for the body, as opposed to face&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; A full example for training on person &lt;code&gt;PXB184&lt;/code&gt; is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m train.train_diffusion --save_dir checkpoints/diffusion/c1_pose_test --data_root ./dataset/PXB184/ --lambda_vel 2.0 --batch_size 4 --dataset social --add_frame_cond 1 --data_format pose --layers 6 --heads 8 --timestep_respacing &#39;&#39; --max_seq_length 600&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3) Body VQ VAE&lt;/h3&gt; &#xA;&lt;p&gt;To train a vq encoder-decoder, you will need to run the following script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m train.train_vq &#xA;    --out_dir &amp;lt;path/to/out/dir&amp;gt; &#xA;    --data_root &amp;lt;path/to/data/root&amp;gt;&#xA;    --batch_size &amp;lt;bs&amp;gt;&#xA;    --lr 1e-3 &#xA;    --code_dim 1024 &#xA;    --output_emb_width 64 &#xA;    --depth 4 &#xA;    --dataname social &#xA;    --loss_vel 0.0 &#xA;    --add_frame_cond 1 &#xA;    --data_format pose &#xA;    --max_seq_length 600&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; For person &lt;code&gt;PXB184&lt;/code&gt;, it would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m train.train_vq --out_dir checkpoints/vq/c1_vq_test --data_root ./dataset/PXB184/ --lr 1e-3 --code_dim 1024 --output_emb_width 64 --depth 4 --dataname social --loss_vel 0.0 --data_format pose --batch_size 4 --add_frame_cond 1 --max_seq_length 600&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;4) Body guide transformer&lt;/h3&gt; &#xA;&lt;p&gt;Once you have the vq trained from 3) you can then pass it in to train the body guide pose transformer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m train.train_guide &#xA;    --out_dir &amp;lt;path/to/out/dir&amp;gt;&#xA;    --data_root &amp;lt;path/to/data/root&amp;gt;&#xA;    --batch_size &amp;lt;bs&amp;gt;&#xA;    --resume_pth &amp;lt;path/to/vq/model&amp;gt;&#xA;    --add_frame_cond 1 &#xA;    --layers 6 &#xA;    --lr 2e-4 &#xA;    --gn &#xA;    --dim 64 &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;üëá&lt;/span&gt; For person &lt;code&gt;PXB184&lt;/code&gt;, it would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m train.train_guide --out_dir checkpoints/guide/c1_trans_test --data_root ./dataset/PXB184/ --batch_size 4 --resume_pth checkpoints/vq/c1_vq_test/net_iter300000.pth --add_frame_cond 1 --layers 6 --lr 2e-4 --gn --dim 64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After training these 4 models, you can now follow the &lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/audio2photoreal/main/#running-the-pretrained-models&#34;&gt;&#34;Running the pretrained models&#34;&lt;/a&gt; section to generate samples and visualize results.&lt;/p&gt; &#xA;&lt;p&gt;You can also visualize the corresponding ground truth sequences by passing in the &lt;code&gt;--render_gt&lt;/code&gt; flag.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;The code and dataset are released under &lt;a href=&#34;https://github.com/facebookresearch/audio2photoreal/raw/main/LICENSE&#34;&gt;CC-NC 4.0 International license&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>bclavie/RAGatouille</title>
    <updated>2024-01-07T01:38:25Z</updated>
    <id>tag:github.com,2024-01-07:/bclavie/RAGatouille</id>
    <link href="https://github.com/bclavie/RAGatouille" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Welcome to RAGatouille&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;Easily use and train state of the art retrieval methods in any RAG pipeline. Designed for modularity and ease-of-use, backed by research.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/bclavie/ragatouille/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/bclavie/ragatouille.svg?sanitize=true&#34; alt=&#34;GitHub stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://ben.clavie.eu/ragatouille/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/docs-available-brightgreen&#34; alt=&#34;Documentation&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/bclavie&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/bclavie?style=social&#34; alt=&#34;Twitter Follow&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img width=&#34;500&#34; alt=&#34;The RAGatouille logo, it&#39;s a cheerful rat on his laptop (branded with a slightly eaten piece of cheese) and a pile of books he&#39;s looking for information in.&#34; src=&#34;https://raw.githubusercontent.com/bclavie/RAGatouille/main/RAGatouille.png&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;The main motivation of RAGatouille is simple: bridging the gap between state-of-the-art research and alchemical RAG pipeline practices. RAG is complex, and there are many moving parts. To get the best performance, you need to optimise for many components: among them, a very important one is the models you use for retrieval.&lt;/p&gt; &#xA;&lt;p&gt;Dense retrieval, i.e. using embeddings such as OpenAI&#39;s &lt;code&gt;text-ada-002&lt;/code&gt;, is a good baseline, but there&#39;s a lot of research &lt;a href=&#34;https://arxiv.org/abs/2104.08663&#34;&gt;showing dense embeddings might not be the&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/2204.11447&#34;&gt;best fit for &lt;strong&gt;your&lt;/strong&gt; usecase&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The Information Retrieval research field has recently been booming, and models like ColBERT have been shown to &lt;a href=&#34;https://arxiv.org/abs/2203.10053&#34;&gt;generalise better&lt;/a&gt; &lt;a href=&#34;https://aclanthology.org/2022.findings-emnlp.78/&#34;&gt;to new or complex domains&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/2205.02870&#34;&gt;than dense embeddings&lt;/a&gt;, are &lt;a href=&#34;https://arxiv.org/abs/2309.06131&#34;&gt;ridiculously data-efficient&lt;/a&gt; and are even &lt;a href=&#34;https://arxiv.org/abs/2312.09508&#34;&gt;better suited to efficiently being trained&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/2312.16144&#34;&gt;on non-English languages with low amount of data&lt;/a&gt;! Unfortunately, most of those new approaches aren&#39;t very well known, and are much harder to use than dense embeddings.&lt;/p&gt; &#xA;&lt;p&gt;This is where &lt;strong&gt;RAGatouille&lt;/strong&gt; comes in: RAGatouille&#39;s purpose is to bridge this gap: make it easy to use state-of-the-art methods in your RAG pipeline, without having to worry about the details or the years of literature! At the moment, RAGatouille focuses on making ColBERT simple to use. If you want to check out what&#39;s coming next, you can check out our &lt;a href=&#34;https://ben.clavie.eu/ragatouille/roadmap&#34;&gt;broad roadmap&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;If you want to read more about the motivations, philosophy, and why the late-interaction approach used by ColBERT works so well, check out the &lt;a href=&#34;https://ben.clavie.eu/ragatouille/&#34;&gt;introduction in the docs&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Want to give it a try? Nothing easier, just run &lt;code&gt;pip install ragatouille&lt;/code&gt; and you&#39;re good to go!&lt;/p&gt; &#xA;&lt;p&gt;‚ö†Ô∏è RAGatouille currently has two running requirements: ‚ö†Ô∏è&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If running inside a script, you must run it inside &lt;code&gt;if __name__ == &#34;__main__&#34;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;It does not currently support Google Colab **&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Get Started&lt;/h2&gt; &#xA;&lt;p&gt;RAGatouille makes it as simple as can be to use ColBERT! We want the library to work on two levels:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Strong, but parameterable defaults: you should be able to get started with just a few lines of code and still leverage the full power of ColBERT, and you should be able to tweak any relevant parameter if you need to!&lt;/li&gt; &#xA; &lt;li&gt;Powerful yet simple re-usable components under-the-hood: any part of the library should be usable stand-alone. You can use our DataProcessor or our negative miners outside of &lt;code&gt;RAGPretrainedModel&lt;/code&gt; and &lt;code&gt;RagTrainer&lt;/code&gt;, and you can even write your own negative miner and use it in the pipeline if you want to!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- (more on [components](https://ben.clavie.eu/ragatouille/components)). --&gt; &#xA;&lt;p&gt;In this section, we&#39;ll quickly walk you through the three core aspects of RAGatouille:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bclavie/RAGatouille/main/#training-and-fine-tuning&#34;&gt;üöÄ Training and Fine-Tuning ColBERT models&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bclavie/RAGatouille/main/#indexing&#34;&gt;üóÑÔ∏è Embedding and Indexing Documents&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bclavie/RAGatouille/main/#retrieving-documents&#34;&gt;üîé Retrieving documents&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;‚û°Ô∏è If you want just want to see fully functional code examples, head over to the &lt;a href=&#34;https://github.com/bclavie/RAGatouille/tree/main/examples&#34;&gt;examples&lt;/a&gt;‚¨ÖÔ∏è&lt;/p&gt; &#xA;&lt;h3&gt;üöÄ Training and fine-tuning&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;If you&#39;re just prototyping, you don&#39;t need to train your own model! While finetuning can be useful, one of the strength of ColBERT is that the pretrained models are particularly good at generalisation, and &lt;a href=&#34;https://huggingface.co/colbert-ir/colbertv2.0&#34;&gt;ColBERTv2&lt;/a&gt; has &lt;a href=&#34;https://arxiv.org/abs/2303.00807&#34;&gt;repeatedly been shown to be extremely strong&lt;/a&gt; at zero-shot retrieval in new domains!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Data Processing&lt;/h4&gt; &#xA;&lt;p&gt;RAGatouille&#39;s RAGTrainer has a built-in &lt;code&gt;TrainingDataProcessor&lt;/code&gt;, which can take most forms of retrieval training data, and automatically convert it to training triplets, with data enhancements. The pipeline works as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Accepts pairs, labelled pairs and various forms of triplets as inputs (strings or list of strings) -- transparently!&lt;/li&gt; &#xA; &lt;li&gt;Automatically remove all duplicates and maps all positives/negatives to their respective query.&lt;/li&gt; &#xA; &lt;li&gt;By default, mine hard negatives: this means generating negatives that are hard to distinguish from positives, and that are therefore more useful for training.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is all handled by &lt;code&gt;RAGTrainer.prepare_training_data()&lt;/code&gt;, and is as easy as doing passing your data to it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ragatouille import RAGTrainer&#xA;&#xA;my_data = [&#xA;    (&#34;What is the meaning of life ?&#34;, &#34;The meaning of life is 42&#34;),&#xA;    (&#34;What is Neural Search?&#34;, &#34;Neural Search is a terms referring to a family of ...&#34;),&#xA;    ...&#xA;]  # Unlabelled pairs here&#xA;trainer = RAGTrainer()&#xA;trainer.prepare_training_data(raw_data=my_data)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ColBERT prefers to store processed training data on-file, which also makes easier to properly version training data via &lt;code&gt;wandb&lt;/code&gt; or &lt;code&gt;dvc&lt;/code&gt;. By default, it will write to &lt;code&gt;./data/&lt;/code&gt;, but you can override this by passing a &lt;code&gt;data_out_path&lt;/code&gt; argument to &lt;code&gt;prepare_training_data()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Just like all things in RAGatouille, &lt;code&gt;prepare_training_data&lt;/code&gt; uses strong defaults, but is also fully parameterable.&lt;/p&gt; &#xA;&lt;!-- Check out the [Data Processing](https://ben.clavie.eu/ragatouille/data-processing) section of the docs! --&gt; &#xA;&lt;h4&gt;Running the Training/Fine-Tuning&lt;/h4&gt; &#xA;&lt;p&gt;Training and Fine-Tuning follow the exact same process. When you instantiate &lt;code&gt;RAGTrainer&lt;/code&gt;, you must pass it a &lt;code&gt;pretrained_model_name&lt;/code&gt;. If this pretrained model is a ColBERT instance, the trainer will be in fine-tuning mode, if it&#39;s another kind of transformer, it will be in training mode to begin training a new ColBERT initialised from the model&#39;s weights!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ragatouille import RAGTrainer&#xA;from ragatouille.utils import get_wikipedia_page&#xA;&#xA;pairs = [&#xA;    (&#34;What is the meaning of life ?&#34;, &#34;The meaning of life is 42&#34;),&#xA;    (&#34;What is Neural Search?&#34;, &#34;Neural Search is a terms referring to a family of ...&#34;),&#xA;    # You need many more pairs to train! Check the examples for more details!&#xA;    ...&#xA;]&#xA;&#xA;my_full_corpus = [get_wikipedia_page(&#34;Hayao_Miyazaki&#34;), get_wikipedia_page(&#34;Studio_Ghibli&#34;)]&#xA;&#xA;&#xA;trainer = RAGTrainer(model_name = &#34;MyFineTunedColBERT&#34;,&#xA;        pretrained_model_name = &#34;colbert-ir/colbertv2.0&#34;) # In this example, we run fine-tuning&#xA;&#xA;# This step handles all the data processing, check the examples for more details!&#xA;trainer.prepare_training_data(raw_data=pairs,&#xA;                                data_out_path=&#34;./data/&#34;,&#xA;                                all_documents=my_full_corpus)&#xA;&#xA;trainer.train(batch_size=32) # Train with the default hyperparams&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you run &lt;code&gt;train()&lt;/code&gt;, it&#39;ll by default inherit its parent ColBERT hyperparameters if fine-tuning, or use the default training parameters if training a new ColBERT. Feel free to modify them as you see fit (check the example and API reference for more details!)&lt;/p&gt; &#xA;&lt;h3&gt;üóÑÔ∏è Indexing&lt;/h3&gt; &#xA;&lt;p&gt;To create an index, you&#39;ll need to load a trained model, this can be one of your own or a pretrained one from the hub! Creating an index with the default configuration is just a few lines of code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ragatouille import RAGPretrainedModel&#xA;from ragatouille.utils import get_wikipedia_page&#xA;&#xA;RAG = RAGPretrainedModel.from_pretrained(&#34;colbert-ir/colbertv2.0&#34;)&#xA;my_documents = [get_wikipedia_page(&#34;Hayao_Miyazaki&#34;), get_wikipedia_page(&#34;Studio_Ghibli&#34;)]&#xA;index_path = RAG.index(index_name=&#34;my_index&#34;, collection=my_documents)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once this is done running, your index will be saved on-disk and ready to be queried! RAGatouille and ColBERT handle everything here:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tokenizing your documents&lt;/li&gt; &#xA; &lt;li&gt;Identifying the individual terms&lt;/li&gt; &#xA; &lt;li&gt;Embedding the documents and generating the bags-of-embeddings&lt;/li&gt; &#xA; &lt;li&gt;Compressing the vectors and storing them on disk&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Curious about how this works? Check out the &lt;a href=&#34;https://ben.clavie.eu/ragatouille/concepts&#34;&gt;Late-Interaction &amp;amp; ColBERT concept explainer&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- or find out more about [indexing](https://ben.clavie.eu/ragatouille/indexing)! --&gt; &#xA;&lt;h3&gt;üîé Retrieving Documents&lt;/h3&gt; &#xA;&lt;p&gt;Once an index is created, querying it is just as simple as creating it! You can either load the model you need directly from an index&#39;s configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ragatouille import RAGPretrainedModel&#xA;&#xA;query = &#34;ColBERT my dear ColBERT, who is the fairest document of them all?&#34;&#xA;RAG = RAGPretrainedModel.from_index(&#34;path_to_your_index&#34;)&#xA;results = RAG.search(query)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is the preferred way of doing things, since every index saves the full configuration of the model used to create it, and you can easily load it back up. However, if you&#39;d rather do it yourself or want to use a slightly different configuration, you can spin-up an instance of &lt;code&gt;RAGPretrainedModel&lt;/code&gt; and specify the index you want to use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ragatouille import RAGPretrainedModel&#xA;&#xA;query = &#34;What manga did Hayao Miyazaki write?&#34;&#xA;RAG = RAGPretrainedModel.from_pretrained(&#34;colbert-ir/colbertv2.0&#34;)&#xA;results = RAG.search(query, index_name=&#34;my_index&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;RAG.search&lt;/code&gt; is a flexible method! You can set the &lt;code&gt;k&lt;/code&gt; value to however many results you want (it defaults to &lt;code&gt;10&lt;/code&gt;), and you can also use it to search for multiple queries at once:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;RAG.search([&#34;What manga did Hayao Miyazaki write?&#34;,&#xA;&#34;Who are the founders of Ghibli?&#34;&#xA;&#34;Who is the director of Spirited Away?&#34;],&#xA;index_name=&#34;my_index&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;RAG.search&lt;/code&gt; returns results in the form of a list of dictionaries, or a list of list of dictionaries if you used multiple queries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# single-query result&#xA;[&#xA;    {&#34;content&#34;: &#34;blablabla&#34;, &#34;score&#34;: 42.424242, &#34;rank&#34;: 1},&#xA;    ...,&#xA;    {&#34;content&#34;: &#34;albalbalba&#34;, &#34;score&#34;: 24.242424, &#34;rank&#34;: k},&#xA;]&#xA;# multi-query result&#xA;[&#xA;    [&#xA;        {&#34;content&#34;: &#34;blablabla&#34;, &#34;score&#34;: 42.424242, &#34;rank&#34;: 1},&#xA;        ...,&#xA;        {&#34;content&#34;: &#34;albalbalba&#34;, &#34;score&#34;: 24.242424, &#34;rank&#34;: k},&#xA;    ],&#xA;    [&#xA;        {&#34;content&#34;: &#34;blablabla&#34;, &#34;score&#34;: 42.424242, &#34;rank&#34;: 1},&#xA;        ...,&#xA;        {&#34;content&#34;: &#34;albalbalba&#34;, &#34;score&#34;: 24.242424, &#34;rank&#34;: k},&#xA;    ],&#xA; ],&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;I&#39;m sold, can I integrate late-interaction RAG into my project?&lt;/h2&gt; &#xA;&lt;p&gt;To get started, RAGatouille bundles everything you need to build a ColBERT native index and query it. Just look at the docs! RAGatouille persists indices on disk in compressed format, and a very viable production deployment is to simply integrate the index you need into your project and query it directly. Don&#39;t just take our word for it, this is what Spotify does in production with their own vector search framework, serving dozens of millions of users:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Statelessness: Many of Spotify‚Äôs systems use nearest-neighbor search in memory, enabling stateless deployments (via Kubernetes) and almost entirely removing the maintenance and cost burden of maintaining a stateful database cluster. (&lt;em&gt;&lt;a href=&#34;https://engineering.atspotify.com/2023/10/introducing-voyager-spotifys-new-nearest-neighbor-search-library/&#34;&gt;Spotify, announcing Voyager&lt;/a&gt;&lt;/em&gt;)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Integrations&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;d like to use more than RAGatouille, ColBERT has a growing number of integrations, and they all fully support models trained or fine-tuned with RAGatouille!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://github.com/stanford-futuredata/ColBERT&#34;&gt;official ColBERT implementation&lt;/a&gt; has a built-in query server (using Flask), which you can easily query via API requests and does support indexes generated with RAGatouille! This should be enough for most small applications, so long as you can persist the index on disk.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://vespa.ai&#34;&gt;Vespa&lt;/a&gt; offers a fully managed RAG engine with ColBERT support: it&#39;s essentially just like a vector DB, except with many more retrieval options! Full support for ColBERT models will be released in the next couple weeks, and using a RAGatouille-trained model will be as simple as loading it from the huggingface hub! &lt;strong&gt;Vespa is a well-tested, widely used framework and is &lt;a href=&#34;https://python.langchain.com/docs/integrations/providers/vespa&#34;&gt;fully-supported in LangChain&lt;/a&gt;, making it the ideal slot-in replacement to replace your current RAG pipeline with ColBERT!&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/IntelLabs/fastRAG&#34;&gt;Intel&#39;s FastRAG&lt;/a&gt; supports ColBERT models for RAG, and is fully compatible with RAGatouille-trained models.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.llamaindex.ai&#34;&gt;LlamaIndex&lt;/a&gt; is building ColBERT integrations and already &lt;a href=&#34;https://github.com/run-llama/llama_index/pull/9656&#34;&gt;has early ColBERT support, with active development continuing&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>