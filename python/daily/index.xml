<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Python Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-19T01:46:14Z</updated>
  <subtitle>Daily Trending of Python in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>iscyy/yoloair</title>
    <updated>2022-08-19T01:46:14Z</updated>
    <id>tag:github.com,2022-08-19:/iscyy/yoloair</id>
    <link href="https://github.com/iscyy/yoloair" rel="alternate"></link>
    <summary type="html">&lt;p&gt;🔥🔥🔥YOLOAir：Including YOLOv5, YOLOv7, Transformer, YOLOX, YOLOR and other networks... Support to improve backbone, head, loss, IoU, NMS...The original version was created based on YOLOv5&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;YOLOAir: Make the improvement of the YOLO model faster, more convenient and more complete&lt;/h2&gt; &#xA;&lt;p&gt;简体中文 | &lt;a href=&#34;https://raw.githubusercontent.com/iscyy/yoloair/main/README_EN.md&#34;&gt;English&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;YOLOAir算法库&amp;nbsp;是一个基于 PyTorch 的一系列 YOLO 检测算法组合工具箱。用来&lt;strong&gt;组合不同模块构建不同网络&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/iscyy/yoloair/main/docs/image/logo1.png&#34; width=&#34;500px&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;内置YOLOv5、YOLOv7、YOLOX、YOLOR、Transformer、Scaled_YOLOv4、YOLOv3、YOLOv4、YOLO-Facev2、TPH-YOLOv5、YOLOv5Lite、PicoDet等模型网络结构(持续更新中🚀)...&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;模块组件化&lt;/strong&gt;：帮助用户自定义快速组合Backbone、Neck、Head，使得网络模型多样化，助力科研改进检测算法、模型改进，网络排列组合🏆。构建强大的网络模型。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;统一模型代码框架、统一应用方式、统一调参、统一改进、易于模块组合、构建更强大的网络模型&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#xA;██╗   ██╗ ██████╗ ██╗      ██████╗      █████╗     ██╗    ██████╗ &#xA;╚██╗ ██╔╝██╔═══██╗██║     ██╔═══██╗    ██╔══██╗    ██║    ██╔══██╗&#xA; ╚████╔╝ ██║   ██║██║     ██║   ██║    ███████║    ██║    ██████╔╝&#xA;  ╚██╔╝  ██║   ██║██║     ██║   ██║    ██╔══██║    ██║    ██╔══██╗&#xA;   ██║   ╚██████╔╝███████╗╚██████╔╝    ██║  ██║    ██║    ██║  ██║&#xA;   ╚═╝    ╚═════╝ ╚══════╝ ╚═════╝     ╚═╝  ╚═╝    ╚═╝    ╚═╝  ╚═╝&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;基于 YOLOv5 代码框架，并同步适配 &lt;strong&gt;稳定的YOLOv5_v6.1更新&lt;/strong&gt;, 同步v6.1部署生态。使用这个项目之前, 您可以先了解YOLOv5库。&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/iscyy/yoloair/main/#Mainfeatures&#34;&gt;特性🚀&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/iscyy/yoloair/main/#Usage&#34;&gt;使用🍉&lt;/a&gt; • &lt;a href=&#34;https://github.com/iscyy/yoloair&#34;&gt;文档📒&lt;/a&gt; • &lt;a href=&#34;https://github.com/iscyy/yoloair/issues/new&#34;&gt;报告问题🌟&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/News-2022-red&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Update-YOLOAir-orange&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://visitor-badge.glitch.me/badge?page_id=iscyy.yoloair&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;支持&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/Support-YOLOv5-red&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Support-YOLOv7-brightgreen&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Support-YOLOX-yellow&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Support-YOLOv4-green&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Support-Scaled_YOLOv4-ff96b4&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Support-YOLOv3-yellowgreen&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Support-YOLOR-lightgrey&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Support-Transformer-9cf&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Support-Attention-green&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;项目地址:&amp;nbsp;&lt;a href=&#34;https://github.com/iscyy/yoloair&#34;&gt;https://github.com/iscyy/yoloair&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;部分改进说明演示: &lt;a href=&#34;https://blog.csdn.net/qq_38668236?type=blog&#34;&gt;芒果汁没有芒果&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;主要特性🚀&lt;/h3&gt; &#xA;&lt;p&gt;🚀支持更多的YOLO系列算法模型改进(持续更新...)&lt;/p&gt; &#xA;&lt;p&gt;YOLOAir 算法库汇总了多种主流YOLO系列检测模型，一套代码集成多种模型:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;内置集成 YOLOv5 模型网络结构、YOLOv7 模型网络结构、 YOLOR 模型网络结构、YOLOX 模型网络结构、Scaled_YOLOv4 模型网络结构、YOLOv4 模型网络结构、YOLOv3 模型网络结构、YOLO-FaceV2模型网络结构、TPH-YOLOv5模型网络结构、YOLOv5-Lite模型网络结构、PicoDet模型网络结构等持续更新中...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/iscyy/yoloair/main/docs/image/test.jpg&#34; width=&#34;500px&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/iscyy/yoloair/main/docs/image/zebra.jpg&#34; width=&#34;500px&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;以上多种检测算法使用统一模型代码框架，&lt;strong&gt;集成在 YOLOAir 库中，统一任务形式、统一应用方式&lt;/strong&gt;。🌟便于科研者用于论文算法模型改进，模型对比，实现网络组合多样化。🌟工程算法部署落地更便捷，包含轻量化模型和精度更高的模型，根据场景合理选择，在精度和速度俩个方面取得平衡。同时该库支持解耦不同的结构和模块组件，让模块组件化，通过组合不同的模块组件，用户可以根据不同数据集或不同业务场景自行定制化构建不同检测模型。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;🔥🔥🔥 重磅！！！作为注意力机制的开源项目补充，强烈推荐一个6300+🌟Star的注意力机制算法代码库👉&lt;a href=&#34;https://github.com/xmu-xiaoma666/External-Attention-pytorch&#34;&gt;External-Attention-pytorch&lt;/a&gt;，里面汇总整理很全面，包含各种Attention、Self-Attention等代码，代码简洁易读，一行代码实现Attention机制。欢迎大家来玩呀！&lt;/p&gt; &#xA;&lt;p&gt;🚀支持加载YOLOv3、YOLOv4、YOLOv5、YOLOv7、YOLOR等网络的官方预训练权重进行迁移学习&lt;/p&gt; &#xA;&lt;p&gt;🚀支持更多Backbone&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CSPDarkNet系列&lt;/code&gt;、&lt;code&gt;RepBlock系列&lt;/code&gt;、 &lt;code&gt;ResNet系列&lt;/code&gt;、&lt;code&gt;RegNet 系列&lt;/code&gt;、 &lt;code&gt;ShuffleNet系列&lt;/code&gt;、&lt;code&gt;Ghost系列&lt;/code&gt;、 &lt;code&gt;MobileNet系列&lt;/code&gt;、&lt;code&gt;EfficientNet系列&lt;/code&gt;、 &lt;code&gt;ConvNext系列&lt;/code&gt;、&lt;code&gt;RepLKNet系列&lt;/code&gt;、 &lt;code&gt;自注意力Transformer系列&lt;/code&gt;、&lt;code&gt;CNN和Transformer结合&lt;/code&gt; 持续更新中🎈&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;🚀支持更多Neck&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;neck包含&lt;code&gt;FPN&lt;/code&gt;、&lt;code&gt;PANet&lt;/code&gt;、&lt;code&gt;BiFPN&lt;/code&gt;等主流结构。 持续更新中🎈&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;🚀支持更多检测头Head&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;YOLOv4、YOLOv5 Head检测头、&lt;/li&gt; &#xA; &lt;li&gt;YOLOR 隐式学习Head检测头、&lt;/li&gt; &#xA; &lt;li&gt;YOLOX的解耦合检测头Decoupled Head、DetectX Head&lt;/li&gt; &#xA; &lt;li&gt;自适应空间特征融合 检测头ASFF Head、&lt;/li&gt; &#xA; &lt;li&gt;YOLOv7检测头IAuxDetect Head, IDetect Head等；&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;🚀支持更多即插即用的注意力机制&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;在网络任何部分即插即用式使用注意力机制 例如 Self Attention、Contextual Transformer、Bottleneck Transformer、S2-MLP Attention、SK Attention、CBAM Attention、SE Attention、Coordinate attention、NAM Attention、GAM attention、ECA Attention、Shuffle Attention、DANet Attention 等多种主流注意力机制&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;🚀支持更多IoU损失函数&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CIoU、DIoU、GIoU、EIoU、SIoU、alpha IOU等损失函数;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;🚀更多空间金字塔池化结构&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SPP、SPPF、ASPP、RFB、SPPCSPC等;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;🚀支持更多NMS&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;NMS、Merge-NMS、DIoU-NMS、Soft-NMS、CIoU_NMS、DIoU_NMS、GIoU_NMS、EIoU_NMS、SIoU_NMS、Soft-SIoUNMS、Soft-CIoUNMS、Soft-DIoUNMS、Soft-EIoUNMS、Soft-GIoUNMS等;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;🚀支持更多数据增强&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mosaic、Copy paste、Random affine(Rotation, Scale, Translation and Shear)、MixUp、Augment HSV(Hue, Saturation, Value、Random horizontal flip&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;🚀支持更多Loss&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ComputeLoss、ComputeNWDLoss、ComputeLoss(X)、ComputeLoss(v6)、ComputeLossAuxOTA(v7)、ComputeLossOTA(v7)等&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;🚀支持Anchor-base和Anchor-Free&lt;/p&gt; &#xA;&lt;p&gt;🚀支持加权框融合(WBF)&lt;/p&gt; &#xA;&lt;p&gt;🚀 内置多种网络模型模块化组件&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Conv, GhostConv, Bottleneck, GhostBottleneck, SPP, SPPF, DWConv, MixConv2d, Focus, CrossConv, BottleneckCSP, C3, C3TR, C3SPP, C3Ghost等 详细代码 &lt;strong&gt;./models/common.py文件&lt;/strong&gt; 内&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;👉&lt;a href=&#34;https://github.com/iscyy/yoloair/raw/main/docs/document/model_.md&#34;&gt;网络模型结构图&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;以上组件模块使用统一模型代码框架、统一任务形式、统一应用方式，&lt;strong&gt;模块组件化&lt;/strong&gt;🚀 可以帮助用户自定义快速组合Backbone、Neck、Head，使得网络模型多样化，助力科研改进检测算法，构建更强大的网络模型。&lt;/p&gt; &#xA;&lt;h3&gt;内置网络模型配置支持✨&lt;/h3&gt; &#xA;&lt;p&gt;🚀包括YOLOv3、YOLOv4、Scaled_YOLOv4、YOLOv5、YOLOv7、YOLOX、YOLOR、Transformer、YOLO-FaceV2、PicoDet、YOLOv5-Lite、TPH-YOLOv5、&lt;strong&gt;其他多种改进网络结构等算法模型&lt;/strong&gt;的yaml配置文件&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;技术交流 &lt;img title=&#34;&#34; src=&#34;https://user-images.githubusercontent.com/48054808/157800467-2a9946ad-30d1-49a9-b9db-ba33413d9c90.png&#34; alt=&#34;&#34; width=&#34;20&#34;&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;最新科研论文 推荐FightingCV公众号，分享最新论文解析和科技前沿动态！&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/iscyy/yoloair/main/docs/image/fightingcv.jpg&#34; width=&#34;200&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;欢迎加入FightingCV微信交流群（关注并回复小助手“加群”） 公众号每天都会进行论文、算法和代码的干货分享哦~&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;使用🍉&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;About the code.&lt;/strong&gt; Follow the design principle of &lt;a href=&#34;https://github.com/ultralytics/yolov5&#34;&gt;YOLOv5&lt;/a&gt;.&lt;br&gt; The original version was created based on YOLOv5(v6.1)&lt;/p&gt; &#xA;&lt;h3&gt;安装&lt;/h3&gt; &#xA;&lt;p&gt;在&lt;strong&gt;Python&amp;gt;=3.7.0&lt;/strong&gt;&amp;nbsp;的环境中克隆版本仓并安装&amp;nbsp;requirements.txt，包括&lt;strong&gt;PyTorch&amp;gt;=1.7&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git&amp;nbsp;clone&amp;nbsp;https://github.com/iscyy/yoloair.git&amp;nbsp;&amp;nbsp;#&amp;nbsp;克隆&#xA;$ cd&amp;nbsp;YOLOAir&#xA;$ pip&amp;nbsp;install&amp;nbsp;-r&amp;nbsp;requirements.txt&amp;nbsp;&amp;nbsp;#&amp;nbsp;安装&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;训练&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python&amp;nbsp;train.py&amp;nbsp;--data&amp;nbsp;coco128.yaml&amp;nbsp;--cfg&amp;nbsp;configs/yolov5/yolov5s.yaml #默认为yolo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;推理&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;detect.py&lt;/code&gt;&amp;nbsp;在各种数据源上运行推理, 并将检测结果保存到&amp;nbsp;&lt;code&gt;runs/detect&lt;/code&gt;&amp;nbsp;目录。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python&amp;nbsp;detect.py&amp;nbsp;--source&amp;nbsp;0&amp;nbsp;&amp;nbsp;#&amp;nbsp;网络摄像头&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;img.jpg&amp;nbsp;&amp;nbsp;#&amp;nbsp;图像&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;vid.mp4&amp;nbsp;&amp;nbsp;#&amp;nbsp;视频&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;path/&amp;nbsp;&amp;nbsp;#&amp;nbsp;文件夹&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;path/*.jpg&amp;nbsp;&amp;nbsp;#&amp;nbsp;glob&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;融合&lt;/h3&gt; &#xA;&lt;p&gt;如果您使用不同模型来推理数据集，则可以使用 wbf.py文件 通过加权框融合来集成结果。 您只需要在 wbf.py文件 中设置 img 路径和 txt 路径。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python wbf.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Benchmark&lt;/h3&gt; &#xA;&lt;p&gt;Updating...&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;YOLO网络模型具体改进方式教程及原理参考&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;9.&lt;a href=&#34;https://blog.csdn.net/qq_38668236/article/details/126333061&#34;&gt;改进YOLOv5系列：9.BoTNet Transformer结构的修改&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;8.&lt;a href=&#34;https://blog.csdn.net/qq_38668236/article/details/126302599&#34;&gt;改进YOLOv5系列：8.增加ACmix结构的修改,自注意力和卷积集成&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;7.&lt;a href=&#34;https://blog.csdn.net/qq_38668236/article/details/126243834&#34;&gt;改进YOLOv5系列：7.修改DIoU-NMS,SIoU-NMS,EIoU-NMS,CIoU-NMS,GIoU-NMS&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;6.&lt;a href=&#34;https://blog.csdn.net/qq_38668236/article/details/126245080&#34;&gt;改进YOLOv5系列：6.修改Soft-NMS,Soft-CIoUNMS,Soft-SIoUNMS&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;5.&lt;a href=&#34;https://blog.csdn.net/qq_38668236/article/details/126226726&#34;&gt;改进YOLOv5系列：5.CotNet Transformer结构的修改&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;4.&lt;a href=&#34;https://blog.csdn.net/qq_38668236/article/details/126157859&#34;&gt;改进YOLOv5系列：4.YOLOv5_最新MobileOne结构换Backbone修改&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;3.&lt;a href=&#34;https://blog.csdn.net/qq_38668236/article/details/126122888?spm=1001.2014.3001.5502&#34;&gt;改进YOLOv5系列：3.Swin Transformer结构的修改&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;2.&lt;a href=&#34;https://blog.csdn.net/qq_38668236/article/details/126087343?spm=1001.2014.3001.5502&#34;&gt;改进YOLOv5系列：2.PicoDet结构的修改&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;1.&lt;a href=&#34;https://blog.csdn.net/qq_38668236/article/details/126086716&#34;&gt;改进YOLOv5系列：1.多种注意力机制修改&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_43694096/article/details/126354660&#34;&gt;1.空间金字塔池化改进 SPP / SPPF / ASPP / RFB / SPPCSPC&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_43694096/article/details/124413941&#34;&gt;2.Yolov5更换激活函数&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_43694096/article/details/125416120&#34;&gt;3.Yolov5更换上采样方式&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;更多模块详细解释教程持续更新中...&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;YOLOv5官方教程✨&lt;/h3&gt; &#xA;&lt;p&gt;与YOLOv5框架同步&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5/wiki/Train-Custom-Data&#34;&gt;训练自定义数据&lt;/a&gt; 🚀 推荐&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5/wiki/Tips-for-Best-Training-Results&#34;&gt;获得最佳训练效果的技巧&lt;/a&gt; ☘️ 推荐&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5/issues/1289&#34;&gt;使用 Weights &amp;amp; Biases 记录实验&lt;/a&gt; 🌟 新&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5/issues/4975&#34;&gt;Roboflow：数据集、标签和主动学习&lt;/a&gt; 🌟 新&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5/issues/475&#34;&gt;多GPU训练&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5/issues/36&#34;&gt;PyTorch Hub&lt;/a&gt; ⭐ 新&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5/issues/251&#34;&gt;TFLite, ONNX, CoreML, TensorRT 导出&lt;/a&gt; 🚀&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5/issues/303&#34;&gt;测试时数据增强 (TTA)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5/issues/318&#34;&gt;模型集成&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5/issues/304&#34;&gt;模型剪枝/稀疏性&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5/issues/607&#34;&gt;超参数进化&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5/issues/1314&#34;&gt;带有冻结层的迁移学习&lt;/a&gt; ⭐ 新&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5/issues/6998&#34;&gt;架构概要&lt;/a&gt; ⭐ 新&lt;/li&gt; &#xA;&lt;/ul&gt;  &#xA;&lt;h3&gt;未来增强✨&lt;/h3&gt; &#xA;&lt;p&gt;后续会持续建设和完善 YOLOAir 生态&lt;br&gt; 完善集成更多 YOLO 系列模型，持续结合不同模块，构建更多不同网络模型&lt;br&gt; 横向拓展和引入关联技术，如半监督学习等等&lt;br&gt; 跟进：YOLO-mask &amp;amp; YOLO-pose&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Statement&lt;/h2&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt; &lt;b&gt;Expand&lt;/b&gt; &lt;/summary&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt; &lt;p&gt;The content of this site is only for sharing notes. If some content is infringing, please sending email.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;If you have any question, please discuss with me by sending email.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt; &lt;b&gt;Expand&lt;/b&gt; &lt;/summary&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5&#34;&gt;https://github.com/ultralytics/yolov5&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/AlexeyAB/darknet&#34;&gt;https://github.com/AlexeyAB/darknet&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/ultralytics/yolov3&#34;&gt;https://github.com/ultralytics/yolov3&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/WongKinYiu/PyTorch_YOLOv4&#34;&gt;https://github.com/WongKinYiu/PyTorch_YOLOv4&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/WongKinYiu/ScaledYOLOv4&#34;&gt;https://github.com/WongKinYiu/ScaledYOLOv4&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/meituan/YOLOv6&#34;&gt;https://github.com/meituan/YOLOv6&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/WongKinYiu/yolov7&#34;&gt;https://github.com/WongKinYiu/yolov7&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/WongKinYiu/yolor&#34;&gt;https://github.com/WongKinYiu/yolor&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/xmu-xiaoma666/External-Attention-pytorch&#34;&gt;https://github.com/xmu-xiaoma666/External-Attention-pytorch&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://gitee.com/SearchSource/yolov5_yolox&#34;&gt;https://gitee.com/SearchSource/yolov5_yolox&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/Krasjet-Yu/YOLO-FaceV2&#34;&gt;https://github.com/Krasjet-Yu/YOLO-FaceV2&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/positive666/yolov5_research&#34;&gt;https://github.com/positive666/yolov5_research/&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/ppogg/YOLOv5-Lite&#34;&gt;https://github.com/ppogg/YOLOv5-Lite&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/Gumpest/YOLOv5-Multibackbone-Compression&#34;&gt;https://github.com/Gumpest/YOLOv5-Multibackbone-Compression&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/cv516Buaa/tph-yolov5&#34;&gt;https://github.com/cv516Buaa/tph-yolov5&lt;/a&gt; Paper:&lt;a href=&#34;https://arxiv.org/abs/2208.02019&#34;&gt;https://arxiv.org/abs/2208.02019&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/details&gt;</summary>
  </entry>
  <entry>
    <title>archinetai/audio-diffusion-pytorch</title>
    <updated>2022-08-19T01:46:14Z</updated>
    <id>tag:github.com,2022-08-19:/archinetai/audio-diffusion-pytorch</id>
    <link href="https://github.com/archinetai/audio-diffusion-pytorch" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Audio generation using diffusion models, in PyTorch.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/archinetai/audio-diffusion-pytorch/main/LOGO.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Unconditional audio generation using diffusion models, in PyTorch. The goal of this repository is to explore different architectures and diffusion models to generate audio (speech and music) directly from/to the waveform. Progress will be documented in the &lt;a href=&#34;https://raw.githubusercontent.com/archinetai/audio-diffusion-pytorch/main/#experiments&#34;&gt;experiments&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install audio-diffusion-pytorch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pypi.org/project/audio-diffusion-pytorch/&#34;&gt;&lt;img src=&#34;https://img.shields.io/pypi/v/audio-diffusion-pytorch?style=flat&amp;amp;colorA=0f0f0f&amp;amp;colorB=0f0f0f&#34; alt=&#34;PyPI - Python Version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;from audio_diffusion_pytorch import AudioDiffusionModel&#xA;&#xA;model = AudioDiffusionModel()&#xA;&#xA;# Train model with audio sources&#xA;x = torch.randn(2, 1, 2 ** 18) # [batch, channels, samples], 2**18 ≈ 12s of audio at a frequency of 22050&#xA;loss = model(x)&#xA;loss.backward() # Do this many times&#xA;&#xA;# Sample 2 sources given start noise&#xA;noise = torch.randn(2, 1, 2 ** 18)&#xA;sampled = model.sample(&#xA;    noise=noise,&#xA;    num_steps=5 # Suggested range: 2-100&#xA;) # [2, 1, 262144]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage with Components&lt;/h2&gt; &#xA;&lt;h3&gt;UNet1d&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;from audio_diffusion_pytorch import UNet1d&#xA;&#xA;# UNet used to denoise our 1D (audio) data&#xA;unet = UNet1d(&#xA;    in_channels=1,&#xA;    patch_size=16,&#xA;    channels=128,&#xA;    multipliers=[1, 2, 4, 4, 4, 4, 4],&#xA;    factors=[4, 4, 4, 2, 2, 2],&#xA;    attentions=[False, False, False, True, True, True],&#xA;    num_blocks=[2, 2, 2, 2, 2, 2],&#xA;    attention_heads=8,&#xA;    attention_features=64,&#xA;    attention_multiplier=2,&#xA;    resnet_groups=8,&#xA;    kernel_multiplier_downsample=2,&#xA;    kernel_sizes_init=[1, 3, 7],&#xA;    use_nearest_upsample=False,&#xA;    use_skip_scale=True,&#xA;    use_attention_bottleneck=True,&#xA;    use_learned_time_embedding=True,&#xA;)&#xA;&#xA;x = torch.randn(3, 1, 2 ** 16)&#xA;t = torch.tensor([0.2, 0.8, 0.3])&#xA;&#xA;y = unet(x, t) # [3, 1, 32768], compute 3 samples of ~1.5 seconds at 22050Hz with the given noise levels t&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Diffusion&lt;/h3&gt; &#xA;&lt;h4&gt;Training&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from audio_diffusion_pytorch import Diffusion, LogNormalDistribution&#xA;&#xA;diffusion = Diffusion(&#xA;    net=unet,&#xA;    sigma_distribution=LogNormalDistribution(mean = -3.0, std = 1.0),&#xA;    sigma_data=0.1,&#xA;    dynamic_threshold=0.95&#xA;)&#xA;&#xA;x = torch.randn(3, 1, 2 ** 18) # Batch of training audio samples&#xA;loss = diffusion(x)&#xA;loss.backward() # Do this many times&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Sampling&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from audio_diffusion_pytorch import DiffusionSampler, KarrasSchedule&#xA;&#xA;sampler = DiffusionSampler(&#xA;    diffusion,&#xA;    num_steps=5, # Suggested range 2-100, higher better quality but takes longer&#xA;    sampler=ADPM2Sampler(rho=1),&#xA;    sigma_schedule=KarrasSchedule(sigma_min=0.0001, sigma_max=3.0, rho=9.0)&#xA;)&#xA;# Generate a sample starting from the provided noise&#xA;y = sampler(noise = torch.randn(1,1,2 ** 18))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Inpainting&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;from audio_diffusion_pytorch import DiffusionInpainter, KarrasSchedule, ADPM2Sampler&#xA;&#xA;inpainter = DiffusionInpainter(&#xA;    diffusion,&#xA;    num_steps=5, # Suggested range 2-100, higher for better quality&#xA;    num_resamples=1, # Suggested range 1-10, higher for better quality&#xA;    sigma_schedule=KarrasSchedule(sigma_min=0.0001, sigma_max=3.0, rho=9.0),&#xA;    sampler=ADPM2Sampler(rho=1.0),&#xA;)&#xA;&#xA;inpaint = torch.randn(1,1,2 ** 18) # Start track, e.g. one sampled with DiffusionSampler&#xA;inpaint_mask = torch.randint(0,2, (1,1,2 ** 18), dtype=torch.bool) # Set to `True` the parts you want to keep&#xA;y = inpainter(inpaint = inpaint, inpaint_mask = inpaint_mask)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Infinite Generation&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from audio_diffusion_pytorch import SpanBySpanComposer&#xA;&#xA;composer = SpanBySpanComposer(&#xA;    inpainter,&#xA;    num_spans=4 # Number of spans to inpaint after provided input&#xA;)&#xA;y_long = composer(y, keep_start=True) # [1, 1, 98304]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Experiments&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Report&lt;/th&gt; &#xA;   &lt;th&gt;Snapshot&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://wandb.ai/schneider/audio/reports/Audio-Diffusion-UNet-Alpha---VmlldzoyMjk3MzIz?accessToken=y0l3igdvnm4ogn4d3ph3b0i8twwcf7meufbviwt15f0qtasyn1i14hg340bkk1te&#34;&gt;Alpha&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/archinetai/audio-diffusion-pytorch/tree/6bd9279f192fc0c11eb8a21cd919d9c41181bf35&#34;&gt;6bd9279f19&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Initial tests on LJSpeech dataset with new architecture and basic DDPM diffusion model.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://wandb.ai/schneider/audio/reports/Audio-Diffusion-Bravo---VmlldzoyMzE4NjIx?accessToken=qt2w1jeqch9l5v3ffjns99p69jsmexk849dszyiennfbivgg396378u6ken2fm2d&#34;&gt;Bravo&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/archinetai/audio-diffusion-pytorch/tree/a05f30aa94e07600038d36cfb96f8492ef735a99&#34;&gt;a05f30aa94&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Elucidated diffusion, improved architecture with patching, longer duration, initial good (unsupervised) results on LJSpeech.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://wandb.ai/schneider/audio/reports/Audio-Diffusion-Charlie---VmlldzoyMzYyNDA1?accessToken=71gmurcwndv5e2abqrjnlh3n74j5555j3tycpd7h40tnv8fvb17k5pjkb57j9xxa&#34;&gt;Charlie&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/archinetai/audio-diffusion-pytorch/tree/50ecc30d70a211b92cb9c38d4b0250d7cc30533f&#34;&gt;50ecc30d70&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Train on music with &lt;a href=&#34;https://github.com/archinetai/audio-data-pytorch&#34;&gt;YoutubeDataset&lt;/a&gt;, larger patch tests for longer tracks, inpainting tests, initial test with infinite generation using SpanBySpanComposer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://wandb.ai/schneider/audio/reports/Audio-Diffusion-Delta---VmlldzoyNDYyMzk1?accessToken=n1d34n35qserpx7nhskkfdm1q12hlcxx1qcmfw5ypz53kjkzoh0ge2uvhshiseqx&#34;&gt;Delta&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(current)&lt;/td&gt; &#xA;   &lt;td&gt;Test model with the faster &lt;code&gt;ADPM2&lt;/code&gt; sampler and dynamic thresholding.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Add elucidated diffusion.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Add ancestral DPM2 sampler.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Add dynamic thresholding.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Add (variational) autoencoder option to compress audio before diffusion.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Fix inpainting and make it work with ADPM2 sampler.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Appreciation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://inf.ethz.ch/&#34;&gt;ETH Zurich&lt;/a&gt; for the compute, &lt;a href=&#34;https://zhijing-jin.com/&#34;&gt;Zhijing Jin&lt;/a&gt;, &lt;a href=&#34;http://www.mrinmaya.io/&#34;&gt;Mrinmaya Sachan&lt;/a&gt;, and &lt;a href=&#34;https://is.mpg.de/~bs&#34;&gt;Bernhard Schoelkopf&lt;/a&gt; for supervising this Thesis.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/lucidrains&#34;&gt;Phil Wang&lt;/a&gt; for the beautiful open source contributions on &lt;a href=&#34;https://github.com/lucidrains/denoising-diffusion-pytorch&#34;&gt;diffusion&lt;/a&gt; and &lt;a href=&#34;https://github.com/lucidrains/imagen-pytorch&#34;&gt;Imagen&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/crowsonkb&#34;&gt;Katherine Crowson&lt;/a&gt; for the experiments with &lt;a href=&#34;https://github.com/crowsonkb/k-diffusion&#34;&gt;k-diffusion&lt;/a&gt; and discovering the insane &lt;code&gt;ADPM2&lt;/code&gt; sampler.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Citations&lt;/h2&gt; &#xA;&lt;p&gt;DDPM&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@misc{2006.11239,&#xA;Author = {Jonathan Ho and Ajay Jain and Pieter Abbeel},&#xA;Title = {Denoising Diffusion Probabilistic Models},&#xA;Year = {2020},&#xA;Eprint = {arXiv:2006.11239},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Diffusion inpainting&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@misc{2201.09865,&#xA;Author = {Andreas Lugmayr and Martin Danelljan and Andres Romero and Fisher Yu and Radu Timofte and Luc Van Gool},&#xA;Title = {RePaint: Inpainting using Denoising Diffusion Probabilistic Models},&#xA;Year = {2022},&#xA;Eprint = {arXiv:2201.09865},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Diffusion weighted loss&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@misc{2204.00227,&#xA;Author = {Jooyoung Choi and Jungbeom Lee and Chaehun Shin and Sungwon Kim and Hyunwoo Kim and Sungroh Yoon},&#xA;Title = {Perception Prioritized Training of Diffusion Models},&#xA;Year = {2022},&#xA;Eprint = {arXiv:2204.00227},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Improved UNet architecture&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@misc{2205.11487,&#xA;Author = {Chitwan Saharia and William Chan and Saurabh Saxena and Lala Li and Jay Whang and Emily Denton and Seyed Kamyar Seyed Ghasemipour and Burcu Karagol Ayan and S. Sara Mahdavi and Rapha Gontijo Lopes and Tim Salimans and Jonathan Ho and David J Fleet and Mohammad Norouzi},&#xA;Title = {Photorealistic Text-to-Image Diffusion Models with Deep Language Understanding},&#xA;Year = {2022},&#xA;Eprint = {arXiv:2205.11487},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Elucidated diffusion&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@misc{2206.00364,&#xA;Author = {Tero Karras and Miika Aittala and Timo Aila and Samuli Laine},&#xA;Title = {Elucidating the Design Space of Diffusion-Based Generative Models},&#xA;Year = {2022},&#xA;Eprint = {arXiv:2206.00364},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>TimDettmers/bitsandbytes</title>
    <updated>2022-08-19T01:46:14Z</updated>
    <id>tag:github.com,2022-08-19:/TimDettmers/bitsandbytes</id>
    <link href="https://github.com/TimDettmers/bitsandbytes" rel="alternate"></link>
    <summary type="html">&lt;p&gt;8-bit CUDA functions for PyTorch&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;bitsandbytes&lt;/h1&gt; &#xA;&lt;p&gt;The bitsandbytes is a lightweight wrapper around CUDA custom functions, in particular 8-bit optimizers, matrix multiplication (LLM.int8()), and quantization functions.&lt;/p&gt; &#xA;&lt;p&gt;Resources:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2110.02861&#34;&gt;8-bit Optimizer Paper&lt;/a&gt; -- &lt;a href=&#34;https://www.youtube.com/watch?v=IxrlHAJtqKE&#34;&gt;Video&lt;/a&gt; -- &lt;a href=&#34;https://bitsandbytes.readthedocs.io/en/latest/&#34;&gt;Docs&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2208.07339&#34;&gt;LLM.int8() Paper&lt;/a&gt; -- &lt;a href=&#34;https://huggingface.co/blog/hf-bitsandbytes-integration&#34;&gt;LLM.int8() Software Blog Post&lt;/a&gt; -- &lt;a href=&#34;https://timdettmers.com/2022/08/17/llm-int8-and-emergent-features/&#34;&gt;LLM.int8() Emergent Features Blog Post&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;TL;DR&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Installation&lt;/strong&gt;: &lt;code&gt;pip install bitsandbytes&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Using 8-bit optimizer&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Comment out optimizer: &lt;code&gt;#torch.optim.Adam(....)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Add 8-bit optimizer of your choice &lt;code&gt;bnb.optim.Adam8bit(....)&lt;/code&gt; (arguments stay the same)&lt;/li&gt; &#xA; &lt;li&gt;Replace embedding layer if necessary: &lt;code&gt;torch.nn.Embedding(..) -&amp;gt; bnb.nn.Embedding(..)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Using 8-bit Inference&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Comment out torch.nn.Linear: &lt;code&gt;#linear = torch.nn.Linear(...)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Add bnb 8-bit linear light module: &lt;code&gt;linear = bnb.nn.Linear8bitLt(...)&lt;/code&gt; (base arguments stay the same)&lt;/li&gt; &#xA; &lt;li&gt;There are two modes: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Mixed 8-bit training with 16-bit main weights. Pass the argument &lt;code&gt;use_fp16_weights=True&lt;/code&gt; (default)&lt;/li&gt; &#xA;   &lt;li&gt;Int8 inference. Pass the argument &lt;code&gt;use_fp16_weights=False&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;To use the full LLM.int8() method, use the &lt;code&gt;threshold=k&lt;/code&gt; argument. We recommend &lt;code&gt;k=6.0&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# LLM.int8()&#xA;linear = bnb.nn.Linear8bitLt(dim1, dim2, bias=True, use_fp16_weights=False, threshold=6.0)&#xA;# inputs need to be fp16&#xA;out = linear(x.to(torch.float16))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;8-bit Matrix multiplication with mixed precision decomposition&lt;/li&gt; &#xA; &lt;li&gt;LLM.int8() inference&lt;/li&gt; &#xA; &lt;li&gt;8-bit Optimizers: Adam, AdamW, RMSProp, LARS, LAMB (saves 75% memory)&lt;/li&gt; &#xA; &lt;li&gt;Stable Embedding Layer: Improved stability through better initialization, and normalization&lt;/li&gt; &#xA; &lt;li&gt;8-bit quantization: Quantile, Linear, and Dynamic quantization&lt;/li&gt; &#xA; &lt;li&gt;Fast quantile estimation: Up to 100x faster than other algorithms&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements &amp;amp; Installation&lt;/h2&gt; &#xA;&lt;p&gt;Requirements: anaconda, cudatoolkit, pytorch&lt;/p&gt; &#xA;&lt;p&gt;Hardware requirements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;LLM.int8(): NVIDIA Turing (RTX 20xx; T4) or Ampere GPU (RTX 30xx; A4-A100); (a GPU from 2018 or older).&lt;/li&gt; &#xA; &lt;li&gt;8-bit optimizers and quantization: NVIDIA Maxwell GPU or newer (&amp;gt;=GTX 9XX).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported CUDA versions: 10.2 - 11.7&lt;/p&gt; &#xA;&lt;p&gt;The requirements can best be fulfilled by installing pytorch via anaconda. You can install PyTorch by following the &lt;a href=&#34;https://pytorch.org/get-started/locally/&#34;&gt;&#34;Get Started&#34;&lt;/a&gt; instructions on the official website.&lt;/p&gt; &#xA;&lt;h2&gt;Using bitsandbytes&lt;/h2&gt; &#xA;&lt;h3&gt;Using Int8 Matrix Multiplication&lt;/h3&gt; &#xA;&lt;p&gt;For straight Int8 matrix multiplication with mixed precision decomposition you can use &lt;code&gt;bnb.matmul(...)&lt;/code&gt;. To enable mixed precision decomposition, use the threshold parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;bnb.matmul(..., threshold=6.0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For instructions how to use LLM.int8() inference layers in your own code, see the TL;DR above or for extended instruction see &lt;a href=&#34;https://github.com/huggingface/transformers&#34;&gt;this blog post&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Using the 8-bit Optimizers&lt;/h3&gt; &#xA;&lt;p&gt;With bitsandbytes 8-bit optimizers can be used by changing a single line of code in your codebase. For NLP models we recommend also to use the StableEmbedding layers (see below) which improves results and helps with stable 8-bit optimization. To get started with 8-bit optimizers, it is sufficient to replace your old optimizer with the 8-bit optimizer in the following way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import bitsandbytes as bnb&#xA;&#xA;# adam = torch.optim.Adam(model.parameters(), lr=0.001, betas=(0.9, 0.995)) # comment out old optimizer&#xA;adam = bnb.optim.Adam8bit(model.parameters(), lr=0.001, betas=(0.9, 0.995)) # add bnb optimizer&#xA;adam = bnb.optim.Adam(model.parameters(), lr=0.001, betas=(0.9, 0.995), optim_bits=8) # equivalent&#xA;&#xA;&#xA;torch.nn.Embedding(...) -&amp;gt;  bnb.nn.StableEmbedding(...) # recommended for NLP models&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that by default all parameter tensors with less than 4096 elements are kept at 32-bit even if you initialize those parameters with 8-bit optimizers. This is done since such small tensors do not save much memory and often contain highly variable parameters (biases) or parameters that require high precision (batch norm, layer norm). You can change this behavior like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# parameter tensors with less than 16384 values are optimized in 32-bit&#xA;# it is recommended to use multiplies of 4096&#xA;adam = bnb.optim.Adam8bit(model.parameters(), min_8bit_size=16384) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Change Bits and other Hyperparameters for Individual Parameters&lt;/h3&gt; &#xA;&lt;p&gt;If you want to optimize some unstable parameters with 32-bit Adam and others with 8-bit Adam, you can use the &lt;code&gt;GlobalOptimManager&lt;/code&gt;. With this, we can also configure specific hyperparameters for particular layers, such as embedding layers. To do that, we need two things: (1) register the parameter while they are still on the CPU, (2) override the config with the new desired hyperparameters (anytime, anywhere). See our &lt;a href=&#34;https://raw.githubusercontent.com/TimDettmers/bitsandbytes/main/howto_config_override.md&#34;&gt;guide&lt;/a&gt; for more details&lt;/p&gt; &#xA;&lt;h3&gt;Fairseq Users&lt;/h3&gt; &#xA;&lt;p&gt;To use the Stable Embedding Layer, override the respective &lt;code&gt;build_embedding(...)&lt;/code&gt; function of your model. Make sure to also use the &lt;code&gt;--no-scale-embedding&lt;/code&gt; flag to disable scaling of the word embedding layer (nor replaced with layer norm). You can use the optimizers by replacing the optimizer in the respective file (&lt;code&gt;adam.py&lt;/code&gt; etc.).&lt;/p&gt; &#xA;&lt;h2&gt;Release and Feature History&lt;/h2&gt; &#xA;&lt;p&gt;For upcoming features and changes and full history see &lt;a href=&#34;https://raw.githubusercontent.com/TimDettmers/bitsandbytes/main/CHANGELOG.md&#34;&gt;Patch Notes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Errors&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;RuntimeError: CUDA error: no kernel image is available for execution on the device. &lt;a href=&#34;https://raw.githubusercontent.com/TimDettmers/bitsandbytes/main/errors_and_solutions.md#No-kernel-image-available&#34;&gt;Solution&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;_&lt;em&gt;fatbinwrap&lt;/em&gt;.. &lt;a href=&#34;https://raw.githubusercontent.com/TimDettmers/bitsandbytes/main/errors_and_solutions.md#fatbinwrap_&#34;&gt;Solution&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Compile from source&lt;/h2&gt; &#xA;&lt;p&gt;To compile from source, please follow the &lt;a href=&#34;https://raw.githubusercontent.com/TimDettmers/bitsandbytes/main/compile_from_source.md&#34;&gt;compile_from_source.md&lt;/a&gt; instructions.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The majority of bitsandbytes is licensed under MIT, however portions of the project are available under separate license terms: Pytorch is licensed under the BSD license.&lt;/p&gt; &#xA;&lt;p&gt;We thank Fabio Cannizzo for his work on &lt;a href=&#34;https://github.com/fabiocannizzo/FastBinarySearch&#34;&gt;FastBinarySearch&lt;/a&gt; which we use for CPU quantization.&lt;/p&gt; &#xA;&lt;h2&gt;How to cite us&lt;/h2&gt; &#xA;&lt;p&gt;If you found this library and found LLM.int8() useful, please consider citing our work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@article{dettmers2022llmint8,&#xA;  title={LLM.int8(): 8-bit Matrix Multiplication for Transformers at Scale},&#xA;  author={Dettmers, Tim and Lewis, Mike and Belkada, Younes and Zettlemoyer, Luke},&#xA;  journal={arXiv preprint arXiv:2208.07339},&#xA;  year={2022}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For 8-bit optimizers or quantization routines please consider citing the following work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@article{dettmers2022optimizers,&#xA;  title={8-bit Optimizers via Block-wise Quantization},&#xA;  author={Dettmers, Tim and Lewis, Mike and Shleifer, Sam and Zettlemoyer, Luke},&#xA;  journal={9th International Conference on Learning Representations, ICLR},&#xA;  year={2022}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>