<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Python Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-05T01:35:59Z</updated>
  <subtitle>Daily Trending of Python in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>prometheus/client_python</title>
    <updated>2022-11-05T01:35:59Z</updated>
    <id>tag:github.com,2022-11-05:/prometheus/client_python</id>
    <link href="https://github.com/prometheus/client_python" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Prometheus instrumentation library for Python applications&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Prometheus Python Client&lt;/h1&gt; &#xA;&lt;p&gt;The official Python client for &lt;a href=&#34;https://prometheus.io&#34;&gt;Prometheus&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Three Step Demo&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;One&lt;/strong&gt;: Install the client:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip install prometheus-client&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Two&lt;/strong&gt;: Paste the following into a Python interpreter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import start_http_server, Summary&#xA;import random&#xA;import time&#xA;&#xA;# Create a metric to track time spent and requests made.&#xA;REQUEST_TIME = Summary(&#39;request_processing_seconds&#39;, &#39;Time spent processing request&#39;)&#xA;&#xA;# Decorate function with metric.&#xA;@REQUEST_TIME.time()&#xA;def process_request(t):&#xA;    &#34;&#34;&#34;A dummy function that takes some time.&#34;&#34;&#34;&#xA;    time.sleep(t)&#xA;&#xA;if __name__ == &#39;__main__&#39;:&#xA;    # Start up the server to expose the metrics.&#xA;    start_http_server(8000)&#xA;    # Generate some requests.&#xA;    while True:&#xA;        process_request(random.random())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Three&lt;/strong&gt;: Visit &lt;a href=&#34;http://localhost:8000/&#34;&gt;http://localhost:8000/&lt;/a&gt; to view the metrics.&lt;/p&gt; &#xA;&lt;p&gt;From one easy to use decorator you get:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;request_processing_seconds_count&lt;/code&gt;: Number of times this function was called.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;request_processing_seconds_sum&lt;/code&gt;: Total amount of time spent in this function.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Prometheus&#39;s &lt;code&gt;rate&lt;/code&gt; function allows calculation of both requests per second, and latency over time from this data.&lt;/p&gt; &#xA;&lt;p&gt;In addition if you&#39;re on Linux the &lt;code&gt;process&lt;/code&gt; metrics expose CPU, memory and other information about the process for free!&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip install prometheus-client&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This package can be found on &lt;a href=&#34;https://pypi.python.org/pypi/prometheus_client&#34;&gt;PyPI&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Instrumenting&lt;/h2&gt; &#xA;&lt;p&gt;Four types of metric are offered: Counter, Gauge, Summary and Histogram. See the documentation on &lt;a href=&#34;http://prometheus.io/docs/concepts/metric_types/&#34;&gt;metric types&lt;/a&gt; and &lt;a href=&#34;https://prometheus.io/docs/practices/instrumentation/#counter-vs-gauge-summary-vs-histogram&#34;&gt;instrumentation best practices&lt;/a&gt; on how to use them.&lt;/p&gt; &#xA;&lt;h3&gt;Counter&lt;/h3&gt; &#xA;&lt;p&gt;Counters go up, and reset when the process restarts.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import Counter&#xA;c = Counter(&#39;my_failures&#39;, &#39;Description of counter&#39;)&#xA;c.inc()     # Increment by 1&#xA;c.inc(1.6)  # Increment by given value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If there is a suffix of &lt;code&gt;_total&lt;/code&gt; on the metric name, it will be removed. When exposing the time series for counter, a &lt;code&gt;_total&lt;/code&gt; suffix will be added. This is for compatibility between OpenMetrics and the Prometheus text format, as OpenMetrics requires the &lt;code&gt;_total&lt;/code&gt; suffix.&lt;/p&gt; &#xA;&lt;p&gt;There are utilities to count exceptions raised:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@c.count_exceptions()&#xA;def f():&#xA;  pass&#xA;&#xA;with c.count_exceptions():&#xA;  pass&#xA;&#xA;# Count only one type of exception&#xA;with c.count_exceptions(ValueError):&#xA;  pass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Gauge&lt;/h3&gt; &#xA;&lt;p&gt;Gauges can go up and down.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import Gauge&#xA;g = Gauge(&#39;my_inprogress_requests&#39;, &#39;Description of gauge&#39;)&#xA;g.inc()      # Increment by 1&#xA;g.dec(10)    # Decrement by given value&#xA;g.set(4.2)   # Set to a given value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are utilities for common use cases:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;g.set_to_current_time()   # Set to current unixtime&#xA;&#xA;# Increment when entered, decrement when exited.&#xA;@g.track_inprogress()&#xA;def f():&#xA;  pass&#xA;&#xA;with g.track_inprogress():&#xA;  pass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A Gauge can also take its value from a callback:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = Gauge(&#39;data_objects&#39;, &#39;Number of objects&#39;)&#xA;my_dict = {}&#xA;d.set_function(lambda: len(my_dict))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Summary&lt;/h3&gt; &#xA;&lt;p&gt;Summaries track the size and number of events.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import Summary&#xA;s = Summary(&#39;request_latency_seconds&#39;, &#39;Description of summary&#39;)&#xA;s.observe(4.7)    # Observe 4.7 (seconds in this case)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are utilities for timing code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@s.time()&#xA;def f():&#xA;  pass&#xA;&#xA;with s.time():&#xA;  pass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Python client doesn&#39;t store or expose quantile information at this time.&lt;/p&gt; &#xA;&lt;h3&gt;Histogram&lt;/h3&gt; &#xA;&lt;p&gt;Histograms track the size and number of events in buckets. This allows for aggregatable calculation of quantiles.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import Histogram&#xA;h = Histogram(&#39;request_latency_seconds&#39;, &#39;Description of histogram&#39;)&#xA;h.observe(4.7)    # Observe 4.7 (seconds in this case)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default buckets are intended to cover a typical web/rpc request from milliseconds to seconds. They can be overridden by passing &lt;code&gt;buckets&lt;/code&gt; keyword argument to &lt;code&gt;Histogram&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There are utilities for timing code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@h.time()&#xA;def f():&#xA;  pass&#xA;&#xA;with h.time():&#xA;  pass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Info&lt;/h3&gt; &#xA;&lt;p&gt;Info tracks key-value information, usually about a whole target.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import Info&#xA;i = Info(&#39;my_build_version&#39;, &#39;Description of info&#39;)&#xA;i.info({&#39;version&#39;: &#39;1.2.3&#39;, &#39;buildhost&#39;: &#39;foo@bar&#39;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Enum&lt;/h3&gt; &#xA;&lt;p&gt;Enum tracks which of a set of states something is currently in.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import Enum&#xA;e = Enum(&#39;my_task_state&#39;, &#39;Description of enum&#39;,&#xA;        states=[&#39;starting&#39;, &#39;running&#39;, &#39;stopped&#39;])&#xA;e.state(&#39;running&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Labels&lt;/h3&gt; &#xA;&lt;p&gt;All metrics can have labels, allowing grouping of related time series.&lt;/p&gt; &#xA;&lt;p&gt;See the best practices on &lt;a href=&#34;http://prometheus.io/docs/practices/naming/&#34;&gt;naming&lt;/a&gt; and &lt;a href=&#34;http://prometheus.io/docs/practices/instrumentation/#use-labels&#34;&gt;labels&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Taking a counter as an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import Counter&#xA;c = Counter(&#39;my_requests_total&#39;, &#39;HTTP Failures&#39;, [&#39;method&#39;, &#39;endpoint&#39;])&#xA;c.labels(&#39;get&#39;, &#39;/&#39;).inc()&#xA;c.labels(&#39;post&#39;, &#39;/submit&#39;).inc()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Labels can also be passed as keyword-arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import Counter&#xA;c = Counter(&#39;my_requests_total&#39;, &#39;HTTP Failures&#39;, [&#39;method&#39;, &#39;endpoint&#39;])&#xA;c.labels(method=&#39;get&#39;, endpoint=&#39;/&#39;).inc()&#xA;c.labels(method=&#39;post&#39;, endpoint=&#39;/submit&#39;).inc()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Metrics with labels are not initialized when declared, because the client can&#39;t know what values the label can have. It is recommended to initialize the label values by calling the &lt;code&gt;.labels()&lt;/code&gt; method alone:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import Counter&#xA;c = Counter(&#39;my_requests_total&#39;, &#39;HTTP Failures&#39;, [&#39;method&#39;, &#39;endpoint&#39;])&#xA;c.labels(&#39;get&#39;, &#39;/&#39;)&#xA;c.labels(&#39;post&#39;, &#39;/submit&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Exemplars&lt;/h3&gt; &#xA;&lt;p&gt;Exemplars can be added to counter and histogram metrics. Exemplars can be specified by passing a dict of label value pairs to be exposed as the exemplar. For example with a counter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import Counter&#xA;c = Counter(&#39;my_requests_total&#39;, &#39;HTTP Failures&#39;, [&#39;method&#39;, &#39;endpoint&#39;])&#xA;c.labels(&#39;get&#39;, &#39;/&#39;).inc(exemplar={&#39;trace_id&#39;: &#39;abc123&#39;})&#xA;c.labels(&#39;post&#39;, &#39;/submit&#39;).inc(1.0, {&#39;trace_id&#39;: &#39;def456&#39;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And with a histogram:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import Histogram&#xA;h = Histogram(&#39;request_latency_seconds&#39;, &#39;Description of histogram&#39;)&#xA;h.observe(4.7, {&#39;trace_id&#39;: &#39;abc123&#39;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Disabling &lt;code&gt;_created&lt;/code&gt; metrics&lt;/h3&gt; &#xA;&lt;p&gt;By default counters, histograms, and summaries export an additional series suffixed with &lt;code&gt;_created&lt;/code&gt; and a value of the unix timestamp for when the metric was created. If this information is not helpful, it can be disabled by setting the environment variable &lt;code&gt;PROMETHEUS_DISABLE_CREATED_SERIES=True&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Process Collector&lt;/h3&gt; &#xA;&lt;p&gt;The Python client automatically exports metrics about process CPU usage, RAM, file descriptors and start time. These all have the prefix &lt;code&gt;process&lt;/code&gt;, and are only currently available on Linux.&lt;/p&gt; &#xA;&lt;p&gt;The namespace and pid constructor arguments allows for exporting metrics about other processes, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ProcessCollector(namespace=&#39;mydaemon&#39;, pid=lambda: open(&#39;/var/run/daemon.pid&#39;).read())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Platform Collector&lt;/h3&gt; &#xA;&lt;p&gt;The client also automatically exports some metadata about Python. If using Jython, metadata about the JVM in use is also included. This information is available as labels on the &lt;code&gt;python_info&lt;/code&gt; metric. The value of the metric is 1, since it is the labels that carry information.&lt;/p&gt; &#xA;&lt;h3&gt;Disabling Default Collector metrics&lt;/h3&gt; &#xA;&lt;p&gt;By default the collected &lt;code&gt;process&lt;/code&gt;, &lt;code&gt;gc&lt;/code&gt;, and &lt;code&gt;platform&lt;/code&gt; collector metrics are exported. If this information is not helpful, it can be disabled using the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import prometheus_client&#xA;&#xA;prometheus_client.REGISTRY.unregister(prometheus_client.GC_COLLECTOR)&#xA;prometheus_client.REGISTRY.unregister(prometheus_client.PLATFORM_COLLECTOR)&#xA;prometheus_client.REGISTRY.unregister(prometheus_client.PROCESS_COLLECTOR)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Exporting&lt;/h2&gt; &#xA;&lt;p&gt;There are several options for exporting metrics.&lt;/p&gt; &#xA;&lt;h3&gt;HTTP&lt;/h3&gt; &#xA;&lt;p&gt;Metrics are usually exposed over HTTP, to be read by the Prometheus server.&lt;/p&gt; &#xA;&lt;p&gt;The easiest way to do this is via &lt;code&gt;start_http_server&lt;/code&gt;, which will start a HTTP server in a daemon thread on the given port:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import start_http_server&#xA;&#xA;start_http_server(8000)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Visit &lt;a href=&#34;http://localhost:8000/&#34;&gt;http://localhost:8000/&lt;/a&gt; to view the metrics.&lt;/p&gt; &#xA;&lt;p&gt;To add Prometheus exposition to an existing HTTP server, see the &lt;code&gt;MetricsHandler&lt;/code&gt; class which provides a &lt;code&gt;BaseHTTPRequestHandler&lt;/code&gt;. It also serves as a simple example of how to write a custom endpoint.&lt;/p&gt; &#xA;&lt;h4&gt;Twisted&lt;/h4&gt; &#xA;&lt;p&gt;To use prometheus with &lt;a href=&#34;https://twistedmatrix.com/&#34;&gt;twisted&lt;/a&gt;, there is &lt;code&gt;MetricsResource&lt;/code&gt; which exposes metrics as a twisted resource.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client.twisted import MetricsResource&#xA;from twisted.web.server import Site&#xA;from twisted.web.resource import Resource&#xA;from twisted.internet import reactor&#xA;&#xA;root = Resource()&#xA;root.putChild(b&#39;metrics&#39;, MetricsResource())&#xA;&#xA;factory = Site(root)&#xA;reactor.listenTCP(8000, factory)&#xA;reactor.run()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;WSGI&lt;/h4&gt; &#xA;&lt;p&gt;To use Prometheus with &lt;a href=&#34;http://wsgi.readthedocs.org/en/latest/&#34;&gt;WSGI&lt;/a&gt;, there is &lt;code&gt;make_wsgi_app&lt;/code&gt; which creates a WSGI application.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import make_wsgi_app&#xA;from wsgiref.simple_server import make_server&#xA;&#xA;app = make_wsgi_app()&#xA;httpd = make_server(&#39;&#39;, 8000, app)&#xA;httpd.serve_forever()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Such an application can be useful when integrating Prometheus metrics with WSGI apps.&lt;/p&gt; &#xA;&lt;p&gt;The method &lt;code&gt;start_wsgi_server&lt;/code&gt; can be used to serve the metrics through the WSGI reference implementation in a new thread.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import start_wsgi_server&#xA;&#xA;start_wsgi_server(8000)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the WSGI application will respect &lt;code&gt;Accept-Encoding:gzip&lt;/code&gt; headers used by Prometheus and compress the response if such a header is present. This behaviour can be disabled by passing &lt;code&gt;disable_compression=True&lt;/code&gt; when creating the app, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app = make_wsgi_app(disable_compression=True)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ASGI&lt;/h4&gt; &#xA;&lt;p&gt;To use Prometheus with &lt;a href=&#34;http://asgi.readthedocs.org/en/latest/&#34;&gt;ASGI&lt;/a&gt;, there is &lt;code&gt;make_asgi_app&lt;/code&gt; which creates an ASGI application.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import make_asgi_app&#xA;&#xA;app = make_asgi_app()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Such an application can be useful when integrating Prometheus metrics with ASGI apps.&lt;/p&gt; &#xA;&lt;p&gt;By default, the WSGI application will respect &lt;code&gt;Accept-Encoding:gzip&lt;/code&gt; headers used by Prometheus and compress the response if such a header is present. This behaviour can be disabled by passing &lt;code&gt;disable_compression=True&lt;/code&gt; when creating the app, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app = make_asgi_app(disable_compression=True)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Flask&lt;/h4&gt; &#xA;&lt;p&gt;To use Prometheus with &lt;a href=&#34;http://flask.pocoo.org/&#34;&gt;Flask&lt;/a&gt; we need to serve metrics through a Prometheus WSGI application. This can be achieved using &lt;a href=&#34;http://flask.pocoo.org/docs/latest/patterns/appdispatch/&#34;&gt;Flask&#39;s application dispatching&lt;/a&gt;. Below is a working example.&lt;/p&gt; &#xA;&lt;p&gt;Save the snippet below in a &lt;code&gt;myapp.py&lt;/code&gt; file&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from flask import Flask&#xA;from werkzeug.middleware.dispatcher import DispatcherMiddleware&#xA;from prometheus_client import make_wsgi_app&#xA;&#xA;# Create my app&#xA;app = Flask(__name__)&#xA;&#xA;# Add prometheus wsgi middleware to route /metrics requests&#xA;app.wsgi_app = DispatcherMiddleware(app.wsgi_app, {&#xA;    &#39;/metrics&#39;: make_wsgi_app()&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the example web application like this&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install uwsgi if you do not have it&#xA;pip install uwsgi&#xA;uwsgi --http 127.0.0.1:8000 --wsgi-file myapp.py --callable app&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Visit &lt;a href=&#34;http://localhost:8000/metrics&#34;&gt;http://localhost:8000/metrics&lt;/a&gt; to see the metrics&lt;/p&gt; &#xA;&lt;h3&gt;Node exporter textfile collector&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/prometheus/node_exporter#textfile-collector&#34;&gt;textfile collector&lt;/a&gt; allows machine-level statistics to be exported out via the Node exporter.&lt;/p&gt; &#xA;&lt;p&gt;This is useful for monitoring cronjobs, or for writing cronjobs to expose metrics about a machine system that the Node exporter does not support or would not make sense to perform at every scrape (for example, anything involving subprocesses).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import CollectorRegistry, Gauge, write_to_textfile&#xA;&#xA;registry = CollectorRegistry()&#xA;g = Gauge(&#39;raid_status&#39;, &#39;1 if raid array is okay&#39;, registry=registry)&#xA;g.set(1)&#xA;write_to_textfile(&#39;/configured/textfile/path/raid.prom&#39;, registry)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A separate registry is used, as the default registry may contain other metrics such as those from the Process Collector.&lt;/p&gt; &#xA;&lt;h2&gt;Exporting to a Pushgateway&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/prometheus/pushgateway&#34;&gt;Pushgateway&lt;/a&gt; allows ephemeral and batch jobs to expose their metrics to Prometheus.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import CollectorRegistry, Gauge, push_to_gateway&#xA;&#xA;registry = CollectorRegistry()&#xA;g = Gauge(&#39;job_last_success_unixtime&#39;, &#39;Last time a batch job successfully finished&#39;, registry=registry)&#xA;g.set_to_current_time()&#xA;push_to_gateway(&#39;localhost:9091&#39;, job=&#39;batchA&#39;, registry=registry)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A separate registry is used, as the default registry may contain other metrics such as those from the Process Collector.&lt;/p&gt; &#xA;&lt;p&gt;Pushgateway functions take a grouping key. &lt;code&gt;push_to_gateway&lt;/code&gt; replaces metrics with the same grouping key, &lt;code&gt;pushadd_to_gateway&lt;/code&gt; only replaces metrics with the same name and grouping key and &lt;code&gt;delete_from_gateway&lt;/code&gt; deletes metrics with the given job and grouping key. See the &lt;a href=&#34;https://github.com/prometheus/pushgateway/raw/master/README.md&#34;&gt;Pushgateway documentation&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;instance_ip_grouping_key&lt;/code&gt; returns a grouping key with the instance label set to the host&#39;s IP address.&lt;/p&gt; &#xA;&lt;h3&gt;Handlers for authentication&lt;/h3&gt; &#xA;&lt;p&gt;If the push gateway you are connecting to is protected with HTTP Basic Auth, you can use a special handler to set the Authorization header.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import CollectorRegistry, Gauge, push_to_gateway&#xA;from prometheus_client.exposition import basic_auth_handler&#xA;&#xA;def my_auth_handler(url, method, timeout, headers, data):&#xA;    username = &#39;foobar&#39;&#xA;    password = &#39;secret123&#39;&#xA;    return basic_auth_handler(url, method, timeout, headers, data, username, password)&#xA;registry = CollectorRegistry()&#xA;g = Gauge(&#39;job_last_success_unixtime&#39;, &#39;Last time a batch job successfully finished&#39;, registry=registry)&#xA;g.set_to_current_time()&#xA;push_to_gateway(&#39;localhost:9091&#39;, job=&#39;batchA&#39;, registry=registry, handler=my_auth_handler)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;TLS Auth is also supported when using the push gateway with a special handler.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import CollectorRegistry, Gauge, push_to_gateway&#xA;from prometheus_client.exposition import tls_handler&#xA;&#xA;&#xA;def my_auth_handler(url, method, timeout, headers, data):&#xA;    certfile = &#39;client-crt.pem&#39;&#xA;    keyfile = &#39;client-key.pem&#39;&#xA;    return tls_auth_handler(url, method, timeout, headers, data, certfile, keyfile)&#xA;&#xA;registry = CollectorRegistry()&#xA;g = Gauge(&#39;job_last_success_unixtime&#39;, &#39;Last time a batch job successfully finished&#39;, registry=registry)&#xA;g.set_to_current_time()&#xA;push_to_gateway(&#39;localhost:9091&#39;, job=&#39;batchA&#39;, registry=registry, handler=my_auth_handler)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Bridges&lt;/h2&gt; &#xA;&lt;p&gt;It is also possible to expose metrics to systems other than Prometheus. This allows you to take advantage of Prometheus instrumentation even if you are not quite ready to fully transition to Prometheus yet.&lt;/p&gt; &#xA;&lt;h3&gt;Graphite&lt;/h3&gt; &#xA;&lt;p&gt;Metrics are pushed over TCP in the Graphite plaintext format.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client.bridge.graphite import GraphiteBridge&#xA;&#xA;gb = GraphiteBridge((&#39;graphite.your.org&#39;, 2003))&#xA;# Push once.&#xA;gb.push()&#xA;# Push every 10 seconds in a daemon thread.&#xA;gb.start(10.0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Graphite &lt;a href=&#34;https://grafana.com/blog/2018/01/11/graphite-1.1-teaching-an-old-dog-new-tricks/&#34;&gt;tags&lt;/a&gt; are also supported.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client.bridge.graphite import GraphiteBridge&#xA;&#xA;gb = GraphiteBridge((&#39;graphite.your.org&#39;, 2003), tags=True)&#xA;c = Counter(&#39;my_requests_total&#39;, &#39;HTTP Failures&#39;, [&#39;method&#39;, &#39;endpoint&#39;])&#xA;c.labels(&#39;get&#39;, &#39;/&#39;).inc()&#xA;gb.push()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom Collectors&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes it is not possible to directly instrument code, as it is not in your control. This requires you to proxy metrics from other systems.&lt;/p&gt; &#xA;&lt;p&gt;To do so you need to create a custom collector, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client.core import GaugeMetricFamily, CounterMetricFamily, REGISTRY&#xA;&#xA;class CustomCollector(object):&#xA;    def collect(self):&#xA;        yield GaugeMetricFamily(&#39;my_gauge&#39;, &#39;Help text&#39;, value=7)&#xA;        c = CounterMetricFamily(&#39;my_counter_total&#39;, &#39;Help text&#39;, labels=[&#39;foo&#39;])&#xA;        c.add_metric([&#39;bar&#39;], 1.7)&#xA;        c.add_metric([&#39;baz&#39;], 3.8)&#xA;        yield c&#xA;&#xA;REGISTRY.register(CustomCollector())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;SummaryMetricFamily&lt;/code&gt;, &lt;code&gt;HistogramMetricFamily&lt;/code&gt; and &lt;code&gt;InfoMetricFamily&lt;/code&gt; work similarly.&lt;/p&gt; &#xA;&lt;p&gt;A collector may implement a &lt;code&gt;describe&lt;/code&gt; method which returns metrics in the same format as &lt;code&gt;collect&lt;/code&gt; (though you don&#39;t have to include the samples). This is used to predetermine the names of time series a &lt;code&gt;CollectorRegistry&lt;/code&gt; exposes and thus to detect collisions and duplicate registrations.&lt;/p&gt; &#xA;&lt;p&gt;Usually custom collectors do not have to implement &lt;code&gt;describe&lt;/code&gt;. If &lt;code&gt;describe&lt;/code&gt; is not implemented and the CollectorRegistry was created with &lt;code&gt;auto_describe=True&lt;/code&gt; (which is the case for the default registry) then &lt;code&gt;collect&lt;/code&gt; will be called at registration time instead of &lt;code&gt;describe&lt;/code&gt;. If this could cause problems, either implement a proper &lt;code&gt;describe&lt;/code&gt;, or if that&#39;s not practical have &lt;code&gt;describe&lt;/code&gt; return an empty list.&lt;/p&gt; &#xA;&lt;h2&gt;Multiprocess Mode (E.g. Gunicorn)&lt;/h2&gt; &#xA;&lt;p&gt;Prometheus client libraries presume a threaded model, where metrics are shared across workers. This doesn&#39;t work so well for languages such as Python where it&#39;s common to have processes rather than threads to handle large workloads.&lt;/p&gt; &#xA;&lt;p&gt;To handle this the client library can be put in multiprocess mode. This comes with a number of limitations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Registries can not be used as normal, all instantiated metrics are exported &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Registering metrics to a registry later used by a &lt;code&gt;MultiProcessCollector&lt;/code&gt; may cause duplicate metrics to be exported&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Custom collectors do not work (e.g. cpu and memory metrics)&lt;/li&gt; &#xA; &lt;li&gt;Info and Enum metrics do not work&lt;/li&gt; &#xA; &lt;li&gt;The pushgateway cannot be used&lt;/li&gt; &#xA; &lt;li&gt;Gauges cannot use the &lt;code&gt;pid&lt;/code&gt; label&lt;/li&gt; &#xA; &lt;li&gt;Exemplars are not supported&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There&#39;s several steps to getting this working:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;1. Deployment&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;PROMETHEUS_MULTIPROC_DIR&lt;/code&gt; environment variable must be set to a directory that the client library can use for metrics. This directory must be wiped between process/Gunicorn runs (before startup is recommended).&lt;/p&gt; &#xA;&lt;p&gt;This environment variable should be set from a start-up shell script, and not directly from Python (otherwise it may not propagate to child processes).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;2. Metrics collector&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;p&gt;The application must initialize a new &lt;code&gt;CollectorRegistry&lt;/code&gt;, and store the multi-process collector inside. It is a best practice to create this registry inside the context of a request to avoid metrics registering themselves to a collector used by a &lt;code&gt;MultiProcessCollector&lt;/code&gt;. If a registry with metrics registered is used by a &lt;code&gt;MultiProcessCollector&lt;/code&gt; duplicate metrics may be exported, one for multiprocess, and one for the process serving the request.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import multiprocess&#xA;from prometheus_client import generate_latest, CollectorRegistry, CONTENT_TYPE_LATEST, Counter&#xA;&#xA;MY_COUNTER = Counter(&#39;my_counter&#39;, &#39;Description of my counter&#39;)&#xA;&#xA;# Expose metrics.&#xA;def app(environ, start_response):&#xA;    registry = CollectorRegistry()&#xA;    multiprocess.MultiProcessCollector(registry)&#xA;    data = generate_latest(registry)&#xA;    status = &#39;200 OK&#39;&#xA;    response_headers = [&#xA;        (&#39;Content-type&#39;, CONTENT_TYPE_LATEST),&#xA;        (&#39;Content-Length&#39;, str(len(data)))&#xA;    ]&#xA;    start_response(status, response_headers)&#xA;    return iter([data])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;3. Gunicorn configuration&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;gunicorn&lt;/code&gt; configuration file needs to include the following function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import multiprocess&#xA;&#xA;def child_exit(server, worker):&#xA;    multiprocess.mark_process_dead(worker.pid)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;4. Metrics tuning (Gauge)&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;p&gt;When &lt;code&gt;Gauge&lt;/code&gt;s are used in multiprocess applications, you must decide how to handle the metrics reported by each process. Gauges have several modes they can run in, which can be selected with the &lt;code&gt;multiprocess_mode&lt;/code&gt; parameter.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#39;all&#39;: Default. Return a timeseries per process (alive or dead), labelled by the process&#39;s &lt;code&gt;pid&lt;/code&gt; (the label is added internally).&lt;/li&gt; &#xA; &lt;li&gt;&#39;min&#39;: Return a single timeseries that is the minimum of the values of all processes (alive or dead).&lt;/li&gt; &#xA; &lt;li&gt;&#39;max&#39;: Return a single timeseries that is the maximum of the values of all processes (alive or dead).&lt;/li&gt; &#xA; &lt;li&gt;&#39;sum&#39;: Return a single timeseries that is the sum of the values of all processes (alive or dead).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Prepend &#39;live&#39; to the beginning of the mode to return the same result but only considering living processes (e.g., &#39;liveall, &#39;livesum&#39;, &#39;livemax&#39;, &#39;livemin&#39;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client import Gauge&#xA;&#xA;# Example gauge&#xA;IN_PROGRESS = Gauge(&#34;inprogress_requests&#34;, &#34;help&#34;, multiprocess_mode=&#39;livesum&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Parser&lt;/h2&gt; &#xA;&lt;p&gt;The Python client supports parsing the Prometheus text format. This is intended for advanced use cases where you have servers exposing Prometheus metrics and need to get them into some other system.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from prometheus_client.parser import text_string_to_metric_families&#xA;for family in text_string_to_metric_families(u&#34;my_gauge 1.0\n&#34;):&#xA;  for sample in family.samples:&#xA;    print(&#34;Name: {0} Labels: {1} Value: {2}&#34;.format(*sample))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/prometheus/client_python/releases&#34;&gt;Releases&lt;/a&gt;: The releases page shows the history of the project and acts as a changelog.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pypi.python.org/pypi/prometheus_client&#34;&gt;PyPI&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>ucarno/ow-league-tokens</title>
    <updated>2022-11-05T01:35:59Z</updated>
    <id>tag:github.com,2022-11-05:/ucarno/ow-league-tokens</id>
    <link href="https://github.com/ucarno/ow-league-tokens" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Bot that farms Overwatch League tokens and Contenders skins by pretending you watch league streams&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;OWL Tokens and Contenders Skins farmer bot&lt;/h1&gt; &#xA;&lt;p&gt;This is a command line bot that &#34;watches&#34; league and contenders streams for you, without the need to worry about missing some. &lt;strong&gt;No password or other sort of authentication required. Just your username.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.python.org/downloads/release/python-3100/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/python-3.10-blue.svg?sanitize=true&#34; alt=&#34;Python 3.10&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.ibb.co/7YCrt1x/demo.gif&#34; alt=&#34;demo&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download zip archive from &lt;a href=&#34;https://github.com/ucarno/ow-league-tokens/releases/latest&#34;&gt;releases page&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Extract &lt;code&gt;OverwatchTokenFarmer&lt;/code&gt; directory wherever you want.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open &lt;code&gt;OverwatchTokenFarmer.exe&lt;/code&gt; located in app directory.&lt;/li&gt; &#xA; &lt;li&gt;Add an account.&lt;/li&gt; &#xA; &lt;li&gt;Start bot.&lt;/li&gt; &#xA; &lt;li&gt;Done! Bot is now working and next time it will remember your username.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Command line arguments&lt;/h2&gt; &#xA;&lt;p&gt;Program can be started without menu using &lt;code&gt;python main.py nomenu&lt;/code&gt;. But to do this you need to configure program using menu or use arguments.&lt;/p&gt; &#xA;&lt;h3&gt;Arguments&lt;/h3&gt; &#xA;&lt;p&gt;Arguments can be used only when starting program using &lt;code&gt;nomenu&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--owl&lt;/code&gt; | &lt;code&gt;--no-owl&lt;/code&gt; - either earn OWL Tokens or not - default is config value or &lt;code&gt;true&lt;/code&gt; if not specified&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--owc&lt;/code&gt; | &lt;code&gt;--no-owc&lt;/code&gt; - either earn Contenders Skins or not - default is config value or &lt;code&gt;true&lt;/code&gt; if not specified&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--ids&lt;/code&gt; - list of integer IDs that will be used instead of IDs from config (you can get your ID from this API: &lt;a href=&#34;https://playoverwatch.com/en-us/search/account-by-name/username/&#34;&gt;https://playoverwatch.com/en-us/search/account-by-name/username/&lt;/a&gt;) or &lt;a href=&#34;https://raw.githubusercontent.com/ucarno/ow-league-tokens/main/#manually-getting-your-account-id&#34;&gt;manually&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;python main.py nomenu --owl --no-owc&lt;/code&gt; - earn OWL Tokens, do not earn Contenders Skins, IDs from config&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;python main.py nomenu --ids 1234 4567 8910&lt;/code&gt; - &lt;code&gt;owl&lt;/code&gt; and &lt;code&gt;owc&lt;/code&gt; values from config, IDs from command line&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Manually getting your account ID&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The official Overwatch League website is storing account ID in a cookie named &lt;code&gt;account_id&lt;/code&gt;. To get cookie&#39;s value, follow these steps:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Go to &lt;a href=&#34;https://overwatchleague.com/en-us&#34;&gt;https://overwatchleague.com/en-us&lt;/a&gt; and login using your Battle.net account&lt;/li&gt; &#xA; &lt;li&gt;Open your browser&#39;s development tools (usually CTRL + Shift + I)&lt;/li&gt; &#xA; &lt;li&gt;Depending on your browser, use one of the following options: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Chrome: Go to the Application tab -&amp;gt; Cookies -&amp;gt; &lt;code&gt;https://overwatchleague.com&lt;/code&gt; -&amp;gt; Name: account_id&lt;/li&gt; &#xA;   &lt;li&gt;Firefox: Go to the Storage tab -&amp;gt; Cookies -&amp;gt; &lt;code&gt;https://overwatchleague.com&lt;/code&gt; -&amp;gt; Name: account_id&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Docker&lt;/h2&gt; &#xA;&lt;p&gt;This application supports Docker! You can either build it by using the supplied &lt;code&gt;docker-compose.yml&lt;/code&gt; or &lt;code&gt;Dockerfile&lt;/code&gt;! To use it, just clone this repository to your Docker Host.&lt;/p&gt; &#xA;&lt;h3&gt;Docker Compose (recommended way if using Docker)&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Make sure Docker Compose is installed on your machine! More info here: &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Docker Compose&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Edit &lt;code&gt;docker-compose.yml&lt;/code&gt; to include your IDs! Remove &lt;code&gt;owl&lt;/code&gt;/&lt;code&gt;owc&lt;/code&gt; options if needed (see &lt;a href=&#34;https://raw.githubusercontent.com/ucarno/ow-league-tokens/main/#arguments&#34;&gt;above&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker compose up -d&lt;/code&gt; - the container is built by &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Docker Compose&lt;/a&gt; using the Dockerfile. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker compose ps&lt;/code&gt; to verify if container is running!&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker compose logs -f&lt;/code&gt; to view container&#39;s logs.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Dockerfile&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Edit Dockerfile to include your IDs. Remove &lt;code&gt;owl&lt;/code&gt;/&lt;code&gt;owc&lt;/code&gt; options if needed (see &lt;a href=&#34;https://raw.githubusercontent.com/ucarno/ow-league-tokens/main/#arguments&#34;&gt;above&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker build -t ow-league-tokens .&lt;/code&gt; to build container using the Dockerfile.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;docker run -d ow-league-tokens:latest&lt;/code&gt; to start new container using the image. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker container ls&lt;/code&gt; to check if container is running&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;docker logs ow-league-tokens&lt;/code&gt; to view container&#39;s logs&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>marqo-ai/marqo</title>
    <updated>2022-11-05T01:35:59Z</updated>
    <id>tag:github.com,2022-11-05:/marqo-ai/marqo</id>
    <link href="https://github.com/marqo-ai/marqo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Tensor search for humans.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/marqo-ai/marqo/mainline/assets/logo2.svg?sanitize=true&#34; alt=&#34;Marqo&#34;&gt; &lt;/p&gt; &#xA;&lt;h1 align=&#34;center&#34;&gt;Marqo&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;b&gt;Tensor search for humans.&lt;/b&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://opensource.org/licenses/Apache-2.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache%202.0-blue.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pypi.org/project/marqo/&#34;&gt;&lt;img src=&#34;https://img.shields.io/pypi/v/marqo?label=PyPI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/marqo-ai/marqo/actions/workflows/CI.yml&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/marqo-ai/marqo/CI?label=CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pepy.tech/project/marqo&#34;&gt;&lt;img alt=&#34;PyPI - Downloads from pepy&#34; src=&#34;https://static.pepy.tech/personalized-badge/marqo?period=month&amp;amp;units=international_system&amp;amp;left_color=grey&amp;amp;right_color=blue&amp;amp;left_text=downloads/month&#34;&gt;&lt;/a&gt; &lt;a align=&#34;center&#34; href=&#34;https://join.slack.com/t/marqo-community/shared_invite/zt-1d737l76e-u~b3Rvey2IN2nGM4wyr44w&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Slack-blueviolet?logo=slack&amp;amp;logoColor=white&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;An open-source tensor search engine that seamlessly integrates with your applications, websites, and workflow.&lt;/p&gt; &#xA;&lt;p&gt;Marqo cloud ☁️ is in beta. If you&#39;re interested, apply here: &lt;a href=&#34;https://q78175g1wwa.typeform.com/to/d0PEuRPC&#34;&gt;https://q78175g1wwa.typeform.com/to/d0PEuRPC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is tensor search?&lt;/h2&gt; &#xA;&lt;p&gt;Tensor search involves transforming documents, images and other data into collections of vectors called &#34;tensors&#34;. Representing data as tensors allows us to match queries against documents with human-like understanding of the query and document&#39;s content. Tensor search can power a variety of use cases such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;end user search and recommendations&lt;/li&gt; &#xA; &lt;li&gt;multi-modal search (image-to-image, text-to-image, image-to-text)&lt;/li&gt; &#xA; &lt;li&gt;chat bots and question and answer systems&lt;/li&gt; &#xA; &lt;li&gt;text and image classification&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/marqo-ai/marqo/mainline/assets/output.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;!-- end marqo-description --&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Marqo requires docker. To install Docker go to the &lt;a href=&#34;https://docs.docker.com/get-docker/&#34;&gt;Docker Official website.&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Use docker to run Marqo (Mac users with M-series chips will need to &lt;a href=&#34;https://raw.githubusercontent.com/marqo-ai/marqo/mainline/#m-series-mac-users&#34;&gt;go here&lt;/a&gt;):&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker rm -f marqo;&#xA;docker pull marqoai/marqo:0.0.6;&#xA;docker run --name marqo -it --privileged -p 8882:8882 --add-host host.docker.internal:host-gateway marqoai/marqo:0.0.6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Install the Marqo client:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install marqo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Start indexing and searching! Let&#39;s look at a simple example below:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import marqo&#xA;&#xA;mq = marqo.Client(url=&#39;http://localhost:8882&#39;)&#xA;&#xA;mq.index(&#34;my-first-index&#34;).add_documents([&#xA;    {&#xA;        &#34;Title&#34;: &#34;The Travels of Marco Polo&#34;,&#xA;        &#34;Description&#34;: &#34;A 13th-century travelogue describing Polo&#39;s travels&#34;&#xA;    }, &#xA;    {&#xA;        &#34;Title&#34;: &#34;Extravehicular Mobility Unit (EMU)&#34;,&#xA;        &#34;Description&#34;: &#34;The EMU is a spacesuit that provides environmental protection, &#34;&#xA;                       &#34;mobility, life support, and communications for astronauts&#34;,&#xA;        &#34;_id&#34;: &#34;article_591&#34;&#xA;    }]&#xA;)&#xA;&#xA;results = mq.index(&#34;my-first-index&#34;).search(&#xA;    q=&#34;What is the best outfit to wear on the moon?&#34;&#xA;)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;mq&lt;/code&gt; is the client that wraps the &lt;code&gt;marqo&lt;/code&gt; API&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;add_documents()&lt;/code&gt; takes a list of documents, represented as python dicts, for indexing&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;add_documents()&lt;/code&gt; creates an index with default settings, if one does not already exist&lt;/li&gt; &#xA; &lt;li&gt;You can optionally set a document&#39;s ID with the special &lt;code&gt;_id&lt;/code&gt; field. Otherwise, Marqo will generate one.&lt;/li&gt; &#xA; &lt;li&gt;If the index doesn&#39;t exist, Marqo will create it. If it exists then Marqo will add the documents to the index.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Let&#39;s have a look at the results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# let&#39;s print out the results:&#xA;import pprint&#xA;pprint.pprint(results)&#xA;&#xA;{&#xA;    &#39;hits&#39;: [&#xA;        {   &#xA;            &#39;Title&#39;: &#39;Extravehicular Mobility Unit (EMU)&#39;,&#xA;            &#39;Description&#39;: &#39;The EMU is a spacesuit that provides environmental protection, mobility, life support, and&#39; &#xA;                           &#39;communications for astronauts&#39;,&#xA;            &#39;_highlights&#39;: {&#xA;                &#39;Description&#39;: &#39;The EMU is a spacesuit that provides environmental protection, &#39;&#xA;                               &#39;mobility, life support, and communications for astronauts&#39;&#xA;            },&#xA;            &#39;_id&#39;: &#39;article_591&#39;,&#xA;            &#39;_score&#39;: 0.61938936&#xA;        }, &#xA;        {   &#xA;            &#39;Title&#39;: &#39;The Travels of Marco Polo&#39;,&#xA;            &#39;Description&#39;: &#34;A 13th-century travelogue describing Polo&#39;s travels&#34;,&#xA;            &#39;_highlights&#39;: {&#39;Title&#39;: &#39;The Travels of Marco Polo&#39;},&#xA;            &#39;_id&#39;: &#39;e00d1a8d-894c-41a1-8e3b-d8b2a8fce12a&#39;,&#xA;            &#39;_score&#39;: 0.60237324&#xA;        }&#xA;    ],&#xA;    &#39;limit&#39;: 10,&#xA;    &#39;processingTimeMs&#39;: 49,&#xA;    &#39;query&#39;: &#39;What is the best outfit to wear on the moon?&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Each hit corresponds to a document that matched the search query&lt;/li&gt; &#xA; &lt;li&gt;They are ordered from most to least matching&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;limit&lt;/code&gt; is the maximum number of hits to be returned. This can be set as a parameter during search&lt;/li&gt; &#xA; &lt;li&gt;Each hit has a &lt;code&gt;_highlights&lt;/code&gt; field. This was the part of the document that matched the query the best&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Other basic operations&lt;/h2&gt; &#xA;&lt;h3&gt;Get document&lt;/h3&gt; &#xA;&lt;p&gt;Retrieve a document by ID.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result = mq.index(&#34;my-first-index&#34;).get_document(document_id=&#34;article_591&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that by adding the document using &lt;code&gt;add_documents&lt;/code&gt; again using the same &lt;code&gt;_id&lt;/code&gt; will cause a document to be updated.&lt;/p&gt; &#xA;&lt;h3&gt;Get index stats&lt;/h3&gt; &#xA;&lt;p&gt;Get information about an index.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;results = mq.index(&#34;my-first-index&#34;).get_stats()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Lexical search&lt;/h3&gt; &#xA;&lt;p&gt;Perform a keyword search.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result =  mq.index(&#34;my-first-index&#34;).search(&#39;marco polo&#39;, search_method=marqo.SearchMethods.LEXICAL)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Search specific fields&lt;/h3&gt; &#xA;&lt;p&gt;Using the default tensor search method&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result = mq.index(&#34;my-first-index&#34;).search(&#39;adventure&#39;, searchable_attributes=[&#39;Title&#39;])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Delete documents&lt;/h3&gt; &#xA;&lt;p&gt;Delete documents.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;results = mq.index(&#34;my-first-index&#34;).delete_documents(ids=[&#34;article_591&#34;, &#34;article_602&#34;])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Delete index&lt;/h3&gt; &#xA;&lt;p&gt;Delete an index.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;results = mq.index(&#34;my-first-index&#34;).delete()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Multi modal and cross modal search&lt;/h2&gt; &#xA;&lt;p&gt;To power image and text search, Marqo allows users to plug and play with CLIP models from HuggingFace. &lt;strong&gt;Note that if you do not configure multi modal search, image urls will be treated as strings.&lt;/strong&gt; To start indexing and searching with images, first create an index with a CLIP configuration, as below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#xA;settings = {&#xA;  &#34;treat_urls_and_pointers_as_images&#34;:True,   # allows us to find an image file and index it &#xA;  &#34;model&#34;:&#34;ViT-L/14&#34;&#xA;}&#xA;response = mq.create_index(&#34;my-multimodal-index&#34;, **settings)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Images can then be added within documents as follows. You can use urls from the internet (for example S3) or from the disk of the machine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#xA;response = mq.index(&#34;my-multimodal-index&#34;).add_documents([{&#xA;    &#34;My Image&#34;: &#34;https://upload.wikimedia.org/wikipedia/commons/thumb/f/f2/Portrait_Hippopotamus_in_the_water.jpg/440px-Portrait_Hippopotamus_in_the_water.jpg&#34;,&#xA;    &#34;Description&#34;: &#34;The hippopotamus, also called the common hippopotamus or river hippopotamus, is a large semiaquatic mammal native to sub-Saharan Africa&#34;,&#xA;    &#34;_id&#34;: &#34;hippo-facts&#34;&#xA;}])&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then search using text as usual. Both text and image fields will be searched:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#xA;results = mq.index(&#34;my-multimodal-index&#34;).search(&#39;animal&#39;)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Setting &lt;code&gt;searchable_attributes&lt;/code&gt; to the image field &lt;code&gt;[&#39;My Image&#39;] &lt;/code&gt; ensures only images are searched in this index:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#xA;results = mq.index(&#34;my-multimodal-index&#34;).search(&#39;animal&#39;,  searchable_attributes=[&#39;My Image&#39;])&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Searching using an image&lt;/h3&gt; &#xA;&lt;p&gt;Searching using an image can be achieved by providing the image link.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;results = mq.index(&#34;my-multimodal-index&#34;).search(&#39;https://upload.wikimedia.org/wikipedia/commons/thumb/9/96/Standing_Hippopotamus_MET_DP248993.jpg/440px-Standing_Hippopotamus_MET_DP248993.jpg&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The full documentation for Marqo can be found here &lt;a href=&#34;https://marqo.pages.dev/&#34;&gt;https://marqo.pages.dev/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Warning&lt;/h2&gt; &#xA;&lt;p&gt;Note that you should not run other applications on Marqo&#39;s Opensearch cluster as Marqo automatically changes and adapts the settings on the cluster.&lt;/p&gt; &#xA;&lt;h2&gt;M series Mac users&lt;/h2&gt; &#xA;&lt;p&gt;Marqo does not yet support the docker-in-docker backend configuration for the arm64 architecture. This means that if you have an M series Mac, you will also need to run marqo&#39;s backend, marqo-os, locally.&lt;/p&gt; &#xA;&lt;p&gt;To run Marqo on an M series Mac, follow the next steps.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;In one terminal run the following command to start opensearch:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker rm -f marqo-os; docker run -p 9200:9200 -p 9600:9600 -e &#34;discovery.type=single-node&#34; marqoai/marqo-os:0.0.2-arm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;In another terminal run the following command to launch Marqo:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker rm -f marqo; docker run --name marqo --privileged \&#xA;    -p 8882:8882 --add-host host.docker.internal:host-gateway \&#xA;    -e &#34;OPENSEARCH_URL=https://localhost:9200&#34; \&#xA;    marqoai/marqo:0.0.6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;Marqo is a community project with the goal of making tensor search accessible to the wider developer community. We are glad that you are interested in helping out! Please read &lt;a href=&#34;https://raw.githubusercontent.com/marqo-ai/marqo/mainline/CONTRIBUTING.md&#34;&gt;this&lt;/a&gt; to get started&lt;/p&gt; &#xA;&lt;h2&gt;Dev set up&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a virtual env &lt;code&gt;python -m venv ./venv&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Activate the virtual environment &lt;code&gt;source ./venv/bin/activate&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install requirements from the requirements file: &lt;code&gt;pip install -r requirements.txt&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run tests by running the tox file. CD into this dir and then run &#34;tox&#34;&lt;/li&gt; &#xA; &lt;li&gt;If you update dependencies, make sure to delete the .tox dir and rerun&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Merge instructions:&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run the full test suite (by using the command &lt;code&gt;tox&lt;/code&gt; in this dir).&lt;/li&gt; &#xA; &lt;li&gt;Create a pull request with an attached github issue.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Join our &lt;a href=&#34;https://join.slack.com/t/marqo-community/shared_invite/zt-1d737l76e-u~b3Rvey2IN2nGM4wyr44w&#34;&gt;Slack community&lt;/a&gt; and chat with other community members about ideas.&lt;/li&gt; &#xA; &lt;li&gt;Marqo community meetings (coming soon!)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Stargazers&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/marqo-ai/marqo/stargazers&#34;&gt;&lt;img src=&#34;https://reporoster.com/stars/marqo-ai/marqo&#34; alt=&#34;Stargazers repo roster for @marqo-ai/marqo&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Forkers&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/marqo-ai/marqo/network/members&#34;&gt;&lt;img src=&#34;https://reporoster.com/forks/marqo-ai/marqo&#34; alt=&#34;Forkers repo roster for @marqo-ai/marqo&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Translations&lt;/h2&gt; &#xA;&lt;p&gt;This readme is available in the following translations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marqo-ai/marqo/mainline/README.md&#34;&gt;English&lt;/a&gt;🇬🇧&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marqo-ai/marqo/mainline/README-translated/README-French.md&#34;&gt;Français&lt;/a&gt;🇫🇷&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marqo-ai/marqo/mainline/README-translated/README-Chinese.md&#34;&gt;中文 Chinese&lt;/a&gt;🇨🇳&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marqo-ai/marqo/mainline/README-translated/README-Polish.md&#34;&gt;Polski&lt;/a&gt;🇵🇱&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marqo-ai/marqo/mainline/README-translated/README-Ukrainian.md&#34;&gt;Українська&lt;/a&gt;🇺🇦&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>