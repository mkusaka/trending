<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Python Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-27T01:41:31Z</updated>
  <subtitle>Daily Trending of Python in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>AnthonyCalandra/modern-cpp-features</title>
    <updated>2022-09-27T01:41:31Z</updated>
    <id>tag:github.com,2022-09-27:/AnthonyCalandra/modern-cpp-features</id>
    <link href="https://github.com/AnthonyCalandra/modern-cpp-features" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A cheatsheet of modern C++ language and library features.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;C++20/17/14/11&lt;/h1&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;C++20 includes the following new language features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#coroutines&#34;&gt;coroutines&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#concepts&#34;&gt;concepts&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#designated-initializers&#34;&gt;designated initializers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#template-syntax-for-lambdas&#34;&gt;template syntax for lambdas&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#range-based-for-loop-with-initializer&#34;&gt;range-based for loop with initializer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#likely-and-unlikely-attributes&#34;&gt;likely and unlikely attributes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#deprecate-implicit-capture-of-this&#34;&gt;deprecate implicit capture of this&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#class-types-in-non-type-template-parameters&#34;&gt;class types in non-type template parameters&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#constexpr-virtual-functions&#34;&gt;constexpr virtual functions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#explicitbool&#34;&gt;explicit(bool)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#immediate-functions&#34;&gt;immediate functions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#using-enum&#34;&gt;using enum&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#lambda-capture-of-parameter-pack&#34;&gt;lambda capture of parameter pack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#char8_t&#34;&gt;char8_t&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;C++20 includes the following new library features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#concepts-library&#34;&gt;concepts library&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#synchronized-buffered-outputstream&#34;&gt;synchronized buffered outputstream&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdspan&#34;&gt;std::span&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#bit-operations&#34;&gt;bit operations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#math-constants&#34;&gt;math constants&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdis_constant_evaluated&#34;&gt;std::is_constant_evaluated&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdmake_shared-supports-arrays&#34;&gt;std::make_shared supports arrays&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#starts_with-and-ends_with-on-strings&#34;&gt;starts_with and ends_with on strings&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#check-if-associative-container-has-element&#34;&gt;check if associative container has element&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdbit_cast&#34;&gt;std::bit_cast&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdmidpoint&#34;&gt;std::midpoint&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdto_array&#34;&gt;std::to_array&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;C++17 includes the following new language features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#template-argument-deduction-for-class-templates&#34;&gt;template argument deduction for class templates&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#declaring-non-type-template-parameters-with-auto&#34;&gt;declaring non-type template parameters with auto&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#folding-expressions&#34;&gt;folding expressions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#new-rules-for-auto-deduction-from-braced-init-list&#34;&gt;new rules for auto deduction from braced-init-list&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#constexpr-lambda&#34;&gt;constexpr lambda&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#lambda-capture-this-by-value&#34;&gt;lambda capture this by value&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#inline-variables&#34;&gt;inline variables&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#nested-namespaces&#34;&gt;nested namespaces&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#structured-bindings&#34;&gt;structured bindings&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#selection-statements-with-initializer&#34;&gt;selection statements with initializer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#constexpr-if&#34;&gt;constexpr if&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#utf-8-character-literals&#34;&gt;utf-8 character literals&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#direct-list-initialization-of-enums&#34;&gt;direct-list-initialization of enums&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#fallthrough-nodiscard-maybe_unused-attributes&#34;&gt;fallthrough, nodiscard, maybe_unused attributes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#__has_include&#34;&gt;__has_include&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;C++17 includes the following new library features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdvariant&#34;&gt;std::variant&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdoptional&#34;&gt;std::optional&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdany&#34;&gt;std::any&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdstring_view&#34;&gt;std::string_view&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdinvoke&#34;&gt;std::invoke&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdapply&#34;&gt;std::apply&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdfilesystem&#34;&gt;std::filesystem&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdbyte&#34;&gt;std::byte&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#splicing-for-maps-and-sets&#34;&gt;splicing for maps and sets&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#parallel-algorithms&#34;&gt;parallel algorithms&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;C++14 includes the following new language features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#binary-literals&#34;&gt;binary literals&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#generic-lambda-expressions&#34;&gt;generic lambda expressions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#lambda-capture-initializers&#34;&gt;lambda capture initializers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#return-type-deduction&#34;&gt;return type deduction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#decltypeauto&#34;&gt;decltype(auto)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#relaxing-constraints-on-constexpr-functions&#34;&gt;relaxing constraints on constexpr functions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#variable-templates&#34;&gt;variable templates&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#deprecated-attribute&#34;&gt;[[deprecated]] attribute&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;C++14 includes the following new library features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#user-defined-literals-for-standard-library-types&#34;&gt;user-defined literals for standard library types&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#compile-time-integer-sequences&#34;&gt;compile-time integer sequences&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdmake_unique&#34;&gt;std::make_unique&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;C++11 includes the following new language features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#move-semantics&#34;&gt;move semantics&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#variadic-templates&#34;&gt;variadic templates&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#rvalue-references&#34;&gt;rvalue references&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#forwarding-references&#34;&gt;forwarding references&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#initializer-lists&#34;&gt;initializer lists&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#static-assertions&#34;&gt;static assertions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#auto&#34;&gt;auto&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#lambda-expressions&#34;&gt;lambda expressions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#decltype&#34;&gt;decltype&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#type-aliases&#34;&gt;type aliases&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#nullptr&#34;&gt;nullptr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#strongly-typed-enums&#34;&gt;strongly-typed enums&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#attributes&#34;&gt;attributes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#constexpr&#34;&gt;constexpr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#delegating-constructors&#34;&gt;delegating constructors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#user-defined-literals&#34;&gt;user-defined literals&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#explicit-virtual-overrides&#34;&gt;explicit virtual overrides&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#final-specifier&#34;&gt;final specifier&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#default-functions&#34;&gt;default functions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#deleted-functions&#34;&gt;deleted functions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#range-based-for-loops&#34;&gt;range-based for loops&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#special-member-functions-for-move-semantics&#34;&gt;special member functions for move semantics&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#converting-constructors&#34;&gt;converting constructors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#explicit-conversion-functions&#34;&gt;explicit conversion functions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#inline-namespaces&#34;&gt;inline-namespaces&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#non-static-data-member-initializers&#34;&gt;non-static data member initializers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#right-angle-brackets&#34;&gt;right angle brackets&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#ref-qualified-member-functions&#34;&gt;ref-qualified member functions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#trailing-return-types&#34;&gt;trailing return types&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#noexcept-specifier&#34;&gt;noexcept specifier&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#char32_t-and-char16_t&#34;&gt;char32_t and char16_t&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#raw-string-literals&#34;&gt;raw string literals&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;C++11 includes the following new library features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdmove&#34;&gt;std::move&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdforward&#34;&gt;std::forward&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdthread&#34;&gt;std::thread&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdto_string&#34;&gt;std::to_string&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#type-traits&#34;&gt;type traits&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#smart-pointers&#34;&gt;smart pointers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdchrono&#34;&gt;std::chrono&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#tuples&#34;&gt;tuples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdtie&#34;&gt;std::tie&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdarray&#34;&gt;std::array&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#unordered-containers&#34;&gt;unordered containers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdmake_shared&#34;&gt;std::make_shared&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdref&#34;&gt;std::ref&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#memory-model&#34;&gt;memory model&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdasync&#34;&gt;std::async&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdbeginend&#34;&gt;std::begin/end&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;C++20 Language Features&lt;/h2&gt; &#xA;&lt;h3&gt;Coroutines&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;Coroutines&lt;/em&gt; are special functions that can have their execution suspended and resumed. To define a coroutine, the &lt;code&gt;co_return&lt;/code&gt;, &lt;code&gt;co_await&lt;/code&gt;, or &lt;code&gt;co_yield&lt;/code&gt; keywords must be present in the function&#39;s body. C++20&#39;s coroutines are stackless; unless optimized out by the compiler, their state is allocated on the heap.&lt;/p&gt; &#xA;&lt;p&gt;An example of a coroutine is a &lt;em&gt;generator&lt;/em&gt; function, which yields (i.e. generates) a value at each invocation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;generator&amp;lt;int&amp;gt; range(int start, int end) {&#xA;  while (start &amp;lt; end) {&#xA;    co_yield start;&#xA;    start++;&#xA;  }&#xA;&#xA;  // Implicit co_return at the end of this function:&#xA;  // co_return;&#xA;}&#xA;&#xA;for (int n : range(0, 10)) {&#xA;  std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above &lt;code&gt;range&lt;/code&gt; generator function generates values starting at &lt;code&gt;start&lt;/code&gt; until &lt;code&gt;end&lt;/code&gt; (exclusive), with each iteration step yielding the current value stored in &lt;code&gt;start&lt;/code&gt;. The generator maintains its state across each invocation of &lt;code&gt;range&lt;/code&gt; (in this case, the invocation is for each iteration in the for loop). &lt;code&gt;co_yield&lt;/code&gt; takes the given expression, yields (i.e. returns) its value, and suspends the coroutine at that point. Upon resuming, execution continues after the &lt;code&gt;co_yield&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Another example of a coroutine is a &lt;em&gt;task&lt;/em&gt;, which is an asynchronous computation that is executed when the task is awaited:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;task&amp;lt;void&amp;gt; echo(socket s) {&#xA;  for (;;) {&#xA;    auto data = co_await s.async_read();&#xA;    co_await async_write(s, data);&#xA;  }&#xA;&#xA;  // Implicit co_return at the end of this function:&#xA;  // co_return;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, the &lt;code&gt;co_await&lt;/code&gt; keyword is introduced. This keyword takes an expression and suspends execution if the thing you&#39;re awaiting on (in this case, the read or write) is not ready, otherwise you continue execution. (Note that under the hood, &lt;code&gt;co_yield&lt;/code&gt; uses &lt;code&gt;co_await&lt;/code&gt;.)&lt;/p&gt; &#xA;&lt;p&gt;Using a task to lazily evaluate a value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;task&amp;lt;int&amp;gt; calculate_meaning_of_life() {&#xA;  co_return 42;&#xA;}&#xA;&#xA;auto meaning_of_life = calculate_meaning_of_life();&#xA;// ...&#xA;co_await meaning_of_life; // == 42&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; While these examples illustrate how to use coroutines at a basic level, there is lots more going on when the code is compiled. These examples are not meant to be complete coverage of C++20&#39;s coroutines. Since the &lt;code&gt;generator&lt;/code&gt; and &lt;code&gt;task&lt;/code&gt; classes are not provided by the standard library yet, I used the cppcoro library to compile these examples.&lt;/p&gt; &#xA;&lt;h3&gt;Concepts&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;Concepts&lt;/em&gt; are named compile-time predicates which constrain types. They take the following form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;template &amp;lt; template-parameter-list &amp;gt;&#xA;concept concept-name = constraint-expression;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &lt;code&gt;constraint-expression&lt;/code&gt; evaluates to a constexpr Boolean. &lt;em&gt;Constraints&lt;/em&gt; should model semantic requirements, such as whether a type is a numeric or hashable. A compiler error results if a given type does not satisfy the concept it&#39;s bound by (i.e. &lt;code&gt;constraint-expression&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;). Because constraints are evaluated at compile-time, they can provide more meaningful error messages and runtime safety.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// `T` is not limited by any constraints.&#xA;template &amp;lt;typename T&amp;gt;&#xA;concept always_satisfied = true;&#xA;// Limit `T` to integrals.&#xA;template &amp;lt;typename T&amp;gt;&#xA;concept integral = std::is_integral_v&amp;lt;T&amp;gt;;&#xA;// Limit `T` to both the `integral` constraint and signedness.&#xA;template &amp;lt;typename T&amp;gt;&#xA;concept signed_integral = integral&amp;lt;T&amp;gt; &amp;amp;&amp;amp; std::is_signed_v&amp;lt;T&amp;gt;;&#xA;// Limit `T` to both the `integral` constraint and the negation of the `signed_integral` constraint.&#xA;template &amp;lt;typename T&amp;gt;&#xA;concept unsigned_integral = integral&amp;lt;T&amp;gt; &amp;amp;&amp;amp; !signed_integral&amp;lt;T&amp;gt;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a variety of syntactic forms for enforcing concepts:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Forms for function parameters:&#xA;// `T` is a constrained type template parameter.&#xA;template &amp;lt;my_concept T&amp;gt;&#xA;void f(T v);&#xA;&#xA;// `T` is a constrained type template parameter.&#xA;template &amp;lt;typename T&amp;gt;&#xA;  requires my_concept&amp;lt;T&amp;gt;&#xA;void f(T v);&#xA;&#xA;// `T` is a constrained type template parameter.&#xA;template &amp;lt;typename T&amp;gt;&#xA;void f(T v) requires my_concept&amp;lt;T&amp;gt;;&#xA;&#xA;// `v` is a constrained deduced parameter.&#xA;void f(my_concept auto v);&#xA;&#xA;// `v` is a constrained non-type template parameter.&#xA;template &amp;lt;my_concept auto v&amp;gt;&#xA;void g();&#xA;&#xA;// Forms for auto-deduced variables:&#xA;// `foo` is a constrained auto-deduced value.&#xA;my_concept auto foo = ...;&#xA;&#xA;// Forms for lambdas:&#xA;// `T` is a constrained type template parameter.&#xA;auto f = []&amp;lt;my_concept T&amp;gt; (T v) {&#xA;  // ...&#xA;};&#xA;// `T` is a constrained type template parameter.&#xA;auto f = []&amp;lt;typename T&amp;gt; requires my_concept&amp;lt;T&amp;gt; (T v) {&#xA;  // ...&#xA;};&#xA;// `T` is a constrained type template parameter.&#xA;auto f = []&amp;lt;typename T&amp;gt; (T v) requires my_concept&amp;lt;T&amp;gt; {&#xA;  // ...&#xA;};&#xA;// `v` is a constrained deduced parameter.&#xA;auto f = [](my_concept auto v) {&#xA;  // ...&#xA;};&#xA;// `v` is a constrained non-type template parameter.&#xA;auto g = []&amp;lt;my_concept auto v&amp;gt; () {&#xA;  // ...&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;requires&lt;/code&gt; keyword is used either to start a &lt;code&gt;requires&lt;/code&gt; clause or a &lt;code&gt;requires&lt;/code&gt; expression:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename T&amp;gt;&#xA;  requires my_concept&amp;lt;T&amp;gt; // `requires` clause.&#xA;void f(T);&#xA;&#xA;template &amp;lt;typename T&amp;gt;&#xA;concept callable = requires (T f) { f(); }; // `requires` expression.&#xA;&#xA;template &amp;lt;typename T&amp;gt;&#xA;  requires requires (T x) { x + x; } // `requires` clause and expression on same line.&#xA;T add(T a, T b) {&#xA;  return a + b;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the parameter list in a &lt;code&gt;requires&lt;/code&gt; expression is optional. Each requirement in a &lt;code&gt;requires&lt;/code&gt; expression are one of the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Simple requirements&lt;/strong&gt; - asserts that the given expression is valid.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename T&amp;gt;&#xA;concept callable = requires (T f) { f(); };&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Type requirements&lt;/strong&gt; - denoted by the &lt;code&gt;typename&lt;/code&gt; keyword followed by a type name, asserts that the given type name is valid.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct foo {&#xA;  int foo;&#xA;};&#xA;&#xA;struct bar {&#xA;  using value = int;&#xA;  value data;&#xA;};&#xA;&#xA;struct baz {&#xA;  using value = int;&#xA;  value data;&#xA;};&#xA;&#xA;// Using SFINAE, enable if `T` is a `baz`.&#xA;template &amp;lt;typename T, typename = std::enable_if_t&amp;lt;std::is_same_v&amp;lt;T, baz&amp;gt;&amp;gt;&amp;gt;&#xA;struct S {};&#xA;&#xA;template &amp;lt;typename T&amp;gt;&#xA;using Ref = T&amp;amp;;&#xA;&#xA;template &amp;lt;typename T&amp;gt;&#xA;concept C = requires {&#xA;                     // Requirements on type `T`:&#xA;  typename T::value; // A) has an inner member named `value`&#xA;  typename S&amp;lt;T&amp;gt;;     // B) must have a valid class template specialization for `S`&#xA;  typename Ref&amp;lt;T&amp;gt;;   // C) must be a valid alias template substitution&#xA;};&#xA;&#xA;template &amp;lt;C T&amp;gt;&#xA;void g(T a);&#xA;&#xA;g(foo{}); // ERROR: Fails requirement A.&#xA;g(bar{}); // ERROR: Fails requirement B.&#xA;g(baz{}); // PASS.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Compound requirements&lt;/strong&gt; - an expression in braces followed by a trailing return type or type constraint.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename T&amp;gt;&#xA;concept C = requires(T x) {&#xA;  {*x} -&amp;gt; typename T::inner; // the type of the expression `*x` is convertible to `T::inner`&#xA;  {x + 1} -&amp;gt; std::same_as&amp;lt;int&amp;gt;; // the expression `x + 1` satisfies `std::same_as&amp;lt;decltype((x + 1))&amp;gt;`&#xA;  {x * 1} -&amp;gt; T; // the type of the expression `x * 1` is convertible to `T`&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Nested requirements&lt;/strong&gt; - denoted by the &lt;code&gt;requires&lt;/code&gt; keyword, specify additional constraints (such as those on local parameter arguments).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename T&amp;gt;&#xA;concept C = requires(T x) {&#xA;  requires std::same_as&amp;lt;sizeof(x), size_t&amp;gt;;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#concepts-library&#34;&gt;concepts library&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Designated initializers&lt;/h3&gt; &#xA;&lt;p&gt;C-style designated initializer syntax. Any member fields that are not explicitly listed in the designated initializer list are default-initialized.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct A {&#xA;  int x;&#xA;  int y;&#xA;  int z = 123;&#xA;};&#xA;&#xA;A a {.x = 1, .z = 2}; // a.x == 1, a.y == 0, a.z == 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Template syntax for lambdas&lt;/h3&gt; &#xA;&lt;p&gt;Use familiar template syntax in lambda expressions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto f = []&amp;lt;typename T&amp;gt;(std::vector&amp;lt;T&amp;gt; v) {&#xA;  // ...&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Range-based for loop with initializer&lt;/h3&gt; &#xA;&lt;p&gt;This feature simplifies common code patterns, helps keep scopes tight, and offers an elegant solution to a common lifetime problem.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (auto v = std::vector{1, 2, 3}; auto&amp;amp; e : v) {&#xA;  std::cout &amp;lt;&amp;lt; e;&#xA;}&#xA;// prints &#34;123&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;likely and unlikely attributes&lt;/h3&gt; &#xA;&lt;p&gt;Provides a hint to the optimizer that the labelled statement has a high probability of being executed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;switch (n) {&#xA;case 1:&#xA;  // ...&#xA;  break;&#xA;&#xA;[[likely]] case 2:  // n == 2 is considered to be arbitrarily more&#xA;  // ...            // likely than any other value of n&#xA;  break;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If one of the likely/unlikely attributes appears after the right parenthesis of an if-statement, it indicates that the branch is likely/unlikely to have its substatement (body) executed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int random = get_random_number_between_x_and_y(0, 3);&#xA;if (random &amp;gt; 0) [[likely]] {&#xA;  // body of if statement&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can also be applied to the substatement (body) of an iteration statement.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;while (unlikely_truthy_condition) [[unlikely]] {&#xA;  // body of while statement&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deprecate implicit capture of this&lt;/h3&gt; &#xA;&lt;p&gt;Implicitly capturing &lt;code&gt;this&lt;/code&gt; in a lambda capture using &lt;code&gt;[=]&lt;/code&gt; is now deprecated; prefer capturing explicitly using &lt;code&gt;[=, this]&lt;/code&gt; or &lt;code&gt;[=, *this]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct int_value {&#xA;  int n = 0;&#xA;  auto getter_fn() {&#xA;    // BAD:&#xA;    // return [=]() { return n; };&#xA;&#xA;    // GOOD:&#xA;    return [=, *this]() { return n; };&#xA;  }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Class types in non-type template parameters&lt;/h3&gt; &#xA;&lt;p&gt;Classes can now be used in non-type template parameters. Objects passed in as template arguments have the type &lt;code&gt;const T&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type of the object, and has static storage duration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct foo {&#xA;  foo() = default;&#xA;  constexpr foo(int) {}&#xA;};&#xA;&#xA;template &amp;lt;foo f&amp;gt;&#xA;auto get_foo() {&#xA;  return f;&#xA;}&#xA;&#xA;get_foo(); // uses implicit constructor&#xA;get_foo&amp;lt;foo{123}&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;constexpr virtual functions&lt;/h3&gt; &#xA;&lt;p&gt;Virtual functions can now be &lt;code&gt;constexpr&lt;/code&gt; and evaluated at compile-time. &lt;code&gt;constexpr&lt;/code&gt; virtual functions can override non-&lt;code&gt;constexpr&lt;/code&gt; virtual functions and vice-versa.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct X1 {&#xA;  virtual int f() const = 0;&#xA;};&#xA;&#xA;struct X2: public X1 {&#xA;  constexpr virtual int f() const { return 2; }&#xA;};&#xA;&#xA;struct X3: public X2 {&#xA;  virtual int f() const { return 3; }&#xA;};&#xA;&#xA;struct X4: public X3 {&#xA;  constexpr virtual int f() const { return 4; }&#xA;};&#xA;&#xA;constexpr X4 x4;&#xA;x4.f(); // == 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;explicit(bool)&lt;/h3&gt; &#xA;&lt;p&gt;Conditionally select at compile-time whether a constructor is made explicit or not. &lt;code&gt;explicit(true)&lt;/code&gt; is the same as specifying &lt;code&gt;explicit&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct foo {&#xA;  // Specify non-integral types (strings, floats, etc.) require explicit construction.&#xA;  template &amp;lt;typename T&amp;gt;&#xA;  explicit(!std::is_integral_v&amp;lt;T&amp;gt;) foo(T) {}&#xA;};&#xA;&#xA;foo a = 123; // OK&#xA;foo b = &#34;123&#34;; // ERROR: explicit constructor is not a candidate (explicit specifier evaluates to true)&#xA;foo c {&#34;123&#34;}; // OK&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Immediate functions&lt;/h3&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;constexpr&lt;/code&gt; functions, but functions with a &lt;code&gt;consteval&lt;/code&gt; specifier must produce a constant. These are called &lt;code&gt;immediate functions&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;consteval int sqr(int n) {&#xA;  return n * n;&#xA;}&#xA;&#xA;constexpr int r = sqr(100); // OK&#xA;int x = 100;&#xA;int r2 = sqr(x); // ERROR: the value of &#39;x&#39; is not usable in a constant expression&#xA;                 // OK if `sqr` were a `constexpr` function&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;using enum&lt;/h3&gt; &#xA;&lt;p&gt;Bring an enum&#39;s members into scope to improve readability. Before:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;enum class rgba_color_channel { red, green, blue, alpha };&#xA;&#xA;std::string_view to_string(rgba_color_channel channel) {&#xA;  switch (channel) {&#xA;    case rgba_color_channel::red:   return &#34;red&#34;;&#xA;    case rgba_color_channel::green: return &#34;green&#34;;&#xA;    case rgba_color_channel::blue:  return &#34;blue&#34;;&#xA;    case rgba_color_channel::alpha: return &#34;alpha&#34;;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;enum class rgba_color_channel { red, green, blue, alpha };&#xA;&#xA;std::string_view to_string(rgba_color_channel my_channel) {&#xA;  switch (my_channel) {&#xA;    using enum rgba_color_channel;&#xA;    case red:   return &#34;red&#34;;&#xA;    case green: return &#34;green&#34;;&#xA;    case blue:  return &#34;blue&#34;;&#xA;    case alpha: return &#34;alpha&#34;;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Lambda capture of parameter pack&lt;/h3&gt; &#xA;&lt;p&gt;Capture parameter packs by value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename... Args&amp;gt;&#xA;auto f(Args&amp;amp;&amp;amp;... args){&#xA;    // BY VALUE:&#xA;    return [...args = std::forward&amp;lt;Args&amp;gt;(args)] {&#xA;        // ...&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Capture parameter packs by reference:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename... Args&amp;gt;&#xA;auto f(Args&amp;amp;&amp;amp;... args){&#xA;    // BY REFERENCE:&#xA;    return [&amp;amp;...args = std::forward&amp;lt;Args&amp;gt;(args)] {&#xA;        // ...&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;char8_t&lt;/h3&gt; &#xA;&lt;p&gt;Provides a standard type for representing UTF-8 strings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;char8_t utf8_str[] = u8&#34;\u0123&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;C++20 Library Features&lt;/h2&gt; &#xA;&lt;h3&gt;Concepts library&lt;/h3&gt; &#xA;&lt;p&gt;Concepts are also provided by the standard library for building more complicated concepts. Some of these include:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Core language concepts:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;same_as&lt;/code&gt; - specifies two types are the same.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;derived_from&lt;/code&gt; - specifies that a type is derived from another type.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;convertible_to&lt;/code&gt; - specifies that a type is implicitly convertible to another type.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;common_with&lt;/code&gt; - specifies that two types share a common type.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;integral&lt;/code&gt; - specifies that a type is an integral type.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;default_constructible&lt;/code&gt; - specifies that an object of a type can be default-constructed.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Comparison concepts:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;boolean&lt;/code&gt; - specifies that a type can be used in Boolean contexts.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;equality_comparable&lt;/code&gt; - specifies that &lt;code&gt;operator==&lt;/code&gt; is an equivalence relation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Object concepts:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;movable&lt;/code&gt; - specifies that an object of a type can be moved and swapped.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;copyable&lt;/code&gt; - specifies that an object of a type can be copied, moved, and swapped.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;semiregular&lt;/code&gt; - specifies that an object of a type can be copied, moved, swapped, and default constructed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;regular&lt;/code&gt; - specifies that a type is &lt;em&gt;regular&lt;/em&gt;, that is, it is both &lt;code&gt;semiregular&lt;/code&gt; and &lt;code&gt;equality_comparable&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Callable concepts:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;invocable&lt;/code&gt; - specifies that a callable type can be invoked with a given set of argument types.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;predicate&lt;/code&gt; - specifies that a callable type is a Boolean predicate.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#concepts&#34;&gt;concepts&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Synchronized buffered outputstream&lt;/h3&gt; &#xA;&lt;p&gt;Buffers output operations for the wrapped output stream ensuring synchronization (i.e. no interleaving of output).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::osyncstream{std::cout} &amp;lt;&amp;lt; &#34;The value of x is:&#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::span&lt;/h3&gt; &#xA;&lt;p&gt;A span is a view (i.e. non-owning) of a container providing bounds-checked access to a contiguous group of elements. Since views do not own their elements they are cheap to construct and copy -- a simplified way to think about views is they are holding references to their data. Spans can be dynamically-sized or fixed-sized.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void f(std::span&amp;lt;int&amp;gt; ints) {&#xA;    std::for_each(ints.begin(), ints.end(), [](auto i) {&#xA;        // ...&#xA;    });&#xA;}&#xA;&#xA;std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};&#xA;f(v);&#xA;std::array&amp;lt;int, 3&amp;gt; a = {1, 2, 3};&#xA;f(a);&#xA;// etc.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example: as opposed to maintaining a pointer and length field, a span wraps both of those up in a single container.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;constexpr size_t LENGTH_ELEMENTS = 3;&#xA;int* arr = new int[LENGTH_ELEMENTS]; // arr = {0, 0, 0}&#xA;&#xA;// Fixed-sized span which provides a view of `arr`.&#xA;std::span&amp;lt;int, LENGTH_ELEMENTS&amp;gt; span = arr;&#xA;span[1] = 1; // arr = {0, 1, 0}&#xA;&#xA;// Dynamic-sized span which provides a view of `arr`.&#xA;std::span&amp;lt;int&amp;gt; d_span = arr;&#xA;span[0] = 1; // arr = {1, 1, 0}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;constexpr size_t LENGTH_ELEMENTS = 3;&#xA;int* arr = new int[LENGTH_ELEMENTS];&#xA;&#xA;std::span&amp;lt;int, LENGTH_ELEMENTS&amp;gt; span = arr; // OK&#xA;std::span&amp;lt;double, LENGTH_ELEMENTS&amp;gt; span2 = arr; // ERROR&#xA;std::span&amp;lt;int, 1&amp;gt; span3 = arr; // ERROR&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Bit operations&lt;/h3&gt; &#xA;&lt;p&gt;C++20 provides a new &lt;code&gt;&amp;lt;bit&amp;gt;&lt;/code&gt; header which provides some bit operations including popcount.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::popcount(0u); // 0&#xA;std::popcount(1u); // 1&#xA;std::popcount(0b1111&#39;0000u); // 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Math constants&lt;/h3&gt; &#xA;&lt;p&gt;Mathematical constants including PI, Euler&#39;s number, etc. defined in the &lt;code&gt;&amp;lt;numbers&amp;gt;&lt;/code&gt; header.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::numbers::pi; // 3.14159...&#xA;std::numbers::e; // 2.71828...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::is_constant_evaluated&lt;/h3&gt; &#xA;&lt;p&gt;Predicate function which is truthy when it is called in a compile-time context.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;constexpr bool is_compile_time() {&#xA;    return std::is_constant_evaluated();&#xA;}&#xA;&#xA;constexpr bool a = is_compile_time(); // true&#xA;bool b = is_compile_time(); // false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::make_shared supports arrays&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto p = std::make_shared&amp;lt;int[]&amp;gt;(5); // pointer to `int[5]`&#xA;// OR&#xA;auto p = std::make_shared&amp;lt;int[5]&amp;gt;(); // pointer to `int[5]`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;starts_with and ends_with on strings&lt;/h3&gt; &#xA;&lt;p&gt;Strings (and string views) now have the &lt;code&gt;starts_with&lt;/code&gt; and &lt;code&gt;ends_with&lt;/code&gt; member functions to check if a string starts or ends with the given string.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::string str = &#34;foobar&#34;;&#xA;str.starts_with(&#34;foo&#34;); // true&#xA;str.ends_with(&#34;baz&#34;); // false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Check if associative container has element&lt;/h3&gt; &#xA;&lt;p&gt;Associative containers such as sets and maps have a &lt;code&gt;contains&lt;/code&gt; member function, which can be used instead of the &#34;find and check end of iterator&#34; idiom.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::map&amp;lt;int, char&amp;gt; map {{1, &#39;a&#39;}, {2, &#39;b&#39;}};&#xA;map.contains(2); // true&#xA;map.contains(123); // false&#xA;&#xA;std::set&amp;lt;int&amp;gt; set {1, 2, 3};&#xA;set.contains(2); // true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::bit_cast&lt;/h3&gt; &#xA;&lt;p&gt;A safer way to reinterpret an object from one type to another.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;float f = 123.0;&#xA;int i = std::bit_cast&amp;lt;int&amp;gt;(f);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::midpoint&lt;/h3&gt; &#xA;&lt;p&gt;Calculate the midpoint of two integers safely (without overflow).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::midpoint(1, 3); // == 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::to_array&lt;/h3&gt; &#xA;&lt;p&gt;Converts the given array/&#34;array-like&#34; object to a &lt;code&gt;std::array&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::to_array(&#34;foo&#34;); // returns `std::array&amp;lt;char, 4&amp;gt;`&#xA;std::to_array&amp;lt;int&amp;gt;({1, 2, 3}); // returns `std::array&amp;lt;int, 3&amp;gt;`&#xA;&#xA;int a[] = {1, 2, 3};&#xA;std::to_array(a); // returns `std::array&amp;lt;int, 3&amp;gt;`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;C++17 Language Features&lt;/h2&gt; &#xA;&lt;h3&gt;Template argument deduction for class templates&lt;/h3&gt; &#xA;&lt;p&gt;Automatic template argument deduction much like how it&#39;s done for functions, but now including class constructors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename T = float&amp;gt;&#xA;struct MyContainer {&#xA;  T val;&#xA;  MyContainer() : val{} {}&#xA;  MyContainer(T val) : val{val} {}&#xA;  // ...&#xA;};&#xA;MyContainer c1 {1}; // OK MyContainer&amp;lt;int&amp;gt;&#xA;MyContainer c2; // OK MyContainer&amp;lt;float&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Declaring non-type template parameters with auto&lt;/h3&gt; &#xA;&lt;p&gt;Following the deduction rules of &lt;code&gt;auto&lt;/code&gt;, while respecting the non-type template parameter list of allowable types[*], template arguments can be deduced from the types of its arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;auto... seq&amp;gt;&#xA;struct my_integer_sequence {&#xA;  // Implementation here ...&#xA;};&#xA;&#xA;// Explicitly pass type `int` as template argument.&#xA;auto seq = std::integer_sequence&amp;lt;int, 0, 1, 2&amp;gt;();&#xA;// Type is deduced to be `int`.&#xA;auto seq2 = my_integer_sequence&amp;lt;0, 1, 2&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;* - For example, you cannot use a &lt;code&gt;double&lt;/code&gt; as a template parameter type, which also makes this an invalid deduction using &lt;code&gt;auto&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Folding expressions&lt;/h3&gt; &#xA;&lt;p&gt;A fold expression performs a fold of a template parameter pack over a binary operator.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;An expression of the form &lt;code&gt;(... op e)&lt;/code&gt; or &lt;code&gt;(e op ...)&lt;/code&gt;, where &lt;code&gt;op&lt;/code&gt; is a fold-operator and &lt;code&gt;e&lt;/code&gt; is an unexpanded parameter pack, are called &lt;em&gt;unary folds&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;An expression of the form &lt;code&gt;(e1 op ... op e2)&lt;/code&gt;, where &lt;code&gt;op&lt;/code&gt; are fold-operators, is called a &lt;em&gt;binary fold&lt;/em&gt;. Either &lt;code&gt;e1&lt;/code&gt; or &lt;code&gt;e2&lt;/code&gt; is an unexpanded parameter pack, but not both.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename... Args&amp;gt;&#xA;bool logicalAnd(Args... args) {&#xA;    // Binary folding.&#xA;    return (true &amp;amp;&amp;amp; ... &amp;amp;&amp;amp; args);&#xA;}&#xA;bool b = true;&#xA;bool&amp;amp; b2 = b;&#xA;logicalAnd(b, b2, true); // == true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename... Args&amp;gt;&#xA;auto sum(Args... args) {&#xA;    // Unary folding.&#xA;    return (... + args);&#xA;}&#xA;sum(1.0, 2.0f, 3); // == 6.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;New rules for auto deduction from braced-init-list&lt;/h3&gt; &#xA;&lt;p&gt;Changes to &lt;code&gt;auto&lt;/code&gt; deduction when used with the uniform initialization syntax. Previously, &lt;code&gt;auto x {3};&lt;/code&gt; deduces a &lt;code&gt;std::initializer_list&amp;lt;int&amp;gt;&lt;/code&gt;, which now deduces to &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto x1 {1, 2, 3}; // error: not a single element&#xA;auto x2 = {1, 2, 3}; // x2 is std::initializer_list&amp;lt;int&amp;gt;&#xA;auto x3 {3}; // x3 is int&#xA;auto x4 {3.0}; // x4 is double&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;constexpr lambda&lt;/h3&gt; &#xA;&lt;p&gt;Compile-time lambdas using &lt;code&gt;constexpr&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto identity = [](int n) constexpr { return n; };&#xA;static_assert(identity(123) == 123);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;constexpr auto add = [](int x, int y) {&#xA;  auto L = [=] { return x; };&#xA;  auto R = [=] { return y; };&#xA;  return [=] { return L() + R(); };&#xA;};&#xA;&#xA;static_assert(add(1, 2)() == 3);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;constexpr int addOne(int n) {&#xA;  return [n] { return n + 1; }();&#xA;}&#xA;&#xA;static_assert(addOne(1) == 2);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Lambda capture &lt;code&gt;this&lt;/code&gt; by value&lt;/h3&gt; &#xA;&lt;p&gt;Capturing &lt;code&gt;this&lt;/code&gt; in a lambda&#39;s environment was previously reference-only. An example of where this is problematic is asynchronous code using callbacks that require an object to be available, potentially past its lifetime. &lt;code&gt;*this&lt;/code&gt; (C++17) will now make a copy of the current object, while &lt;code&gt;this&lt;/code&gt; (C++11) continues to capture by reference.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct MyObj {&#xA;  int value {123};&#xA;  auto getValueCopy() {&#xA;    return [*this] { return value; };&#xA;  }&#xA;  auto getValueRef() {&#xA;    return [this] { return value; };&#xA;  }&#xA;};&#xA;MyObj mo;&#xA;auto valueCopy = mo.getValueCopy();&#xA;auto valueRef = mo.getValueRef();&#xA;mo.value = 321;&#xA;valueCopy(); // 123&#xA;valueRef(); // 321&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Inline variables&lt;/h3&gt; &#xA;&lt;p&gt;The inline specifier can be applied to variables as well as to functions. A variable declared inline has the same semantics as a function declared inline.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Disassembly example using compiler explorer.&#xA;struct S { int x; };&#xA;inline S x1 = S{321}; // mov esi, dword ptr [x1]&#xA;                      // x1: .long 321&#xA;&#xA;S x2 = S{123};        // mov eax, dword ptr [.L_ZZ4mainE2x2]&#xA;                      // mov dword ptr [rbp - 8], eax&#xA;                      // .L_ZZ4mainE2x2: .long 123&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can also be used to declare and define a static member variable, such that it does not need to be initialized in the source file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct S {&#xA;  S() : id{count++} {}&#xA;  ~S() { count--; }&#xA;  int id;&#xA;  static inline int count{0}; // declare and initialize count to 0 within the class&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Nested namespaces&lt;/h3&gt; &#xA;&lt;p&gt;Using the namespace resolution operator to create nested namespace definitions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;namespace A {&#xA;  namespace B {&#xA;    namespace C {&#xA;      int i;&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The code above can be written like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;namespace A::B::C {&#xA;  int i;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Structured bindings&lt;/h3&gt; &#xA;&lt;p&gt;A proposal for de-structuring initialization, that would allow writing &lt;code&gt;auto [ x, y, z ] = expr;&lt;/code&gt; where the type of &lt;code&gt;expr&lt;/code&gt; was a tuple-like object, whose elements would be bound to the variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; (which this construct declares). &lt;em&gt;Tuple-like objects&lt;/em&gt; include &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#tuples&#34;&gt;&lt;code&gt;std::tuple&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;std::pair&lt;/code&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdarray&#34;&gt;&lt;code&gt;std::array&lt;/code&gt;&lt;/a&gt;, and aggregate structures.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;using Coordinate = std::pair&amp;lt;int, int&amp;gt;;&#xA;Coordinate origin() {&#xA;  return Coordinate{0, 0};&#xA;}&#xA;&#xA;const auto [ x, y ] = origin();&#xA;x; // == 0&#xA;y; // == 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::unordered_map&amp;lt;std::string, int&amp;gt; mapping {&#xA;  {&#34;a&#34;, 1},&#xA;  {&#34;b&#34;, 2},&#xA;  {&#34;c&#34;, 3}&#xA;};&#xA;&#xA;// Destructure by reference.&#xA;for (const auto&amp;amp; [key, value] : mapping) {&#xA;  // Do something with key and value&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Selection statements with initializer&lt;/h3&gt; &#xA;&lt;p&gt;New versions of the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;switch&lt;/code&gt; statements which simplify common code patterns and help users keep scopes tight.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;{&#xA;  std::lock_guard&amp;lt;std::mutex&amp;gt; lk(mx);&#xA;  if (v.empty()) v.push_back(val);&#xA;}&#xA;// vs.&#xA;if (std::lock_guard&amp;lt;std::mutex&amp;gt; lk(mx); v.empty()) {&#xA;  v.push_back(val);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Foo gadget(args);&#xA;switch (auto s = gadget.status()) {&#xA;  case OK: gadget.zip(); break;&#xA;  case Bad: throw BadFoo(s.message());&#xA;}&#xA;// vs.&#xA;switch (Foo gadget(args); auto s = gadget.status()) {&#xA;  case OK: gadget.zip(); break;&#xA;  case Bad: throw BadFoo(s.message());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;constexpr if&lt;/h3&gt; &#xA;&lt;p&gt;Write code that is instantiated depending on a compile-time condition.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename T&amp;gt;&#xA;constexpr bool isIntegral() {&#xA;  if constexpr (std::is_integral&amp;lt;T&amp;gt;::value) {&#xA;    return true;&#xA;  } else {&#xA;    return false;&#xA;  }&#xA;}&#xA;static_assert(isIntegral&amp;lt;int&amp;gt;() == true);&#xA;static_assert(isIntegral&amp;lt;char&amp;gt;() == true);&#xA;static_assert(isIntegral&amp;lt;double&amp;gt;() == false);&#xA;struct S {};&#xA;static_assert(isIntegral&amp;lt;S&amp;gt;() == false);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;UTF-8 character literals&lt;/h3&gt; &#xA;&lt;p&gt;A character literal that begins with &lt;code&gt;u8&lt;/code&gt; is a character literal of type &lt;code&gt;char&lt;/code&gt;. The value of a UTF-8 character literal is equal to its ISO 10646 code point value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;char x = u8&#39;x&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Direct list initialization of enums&lt;/h3&gt; &#xA;&lt;p&gt;Enums can now be initialized using braced syntax.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;enum byte : unsigned char {};&#xA;byte b {0}; // OK&#xA;byte c {-1}; // ERROR&#xA;byte d = byte{1}; // OK&#xA;byte e = byte{256}; // ERROR&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;fallthrough, nodiscard, maybe_unused attributes&lt;/h3&gt; &#xA;&lt;p&gt;C++17 introduces three new attributes: &lt;code&gt;[[fallthrough]]&lt;/code&gt;, &lt;code&gt;[[nodiscard]]&lt;/code&gt; and &lt;code&gt;[[maybe_unused]]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;[[fallthrough]]&lt;/code&gt; indicates to the compiler that falling through in a switch statement is intended behavior.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;switch (n) {&#xA;  case 1: [[fallthrough]]&#xA;    // ...&#xA;  case 2:&#xA;    // ...&#xA;    break;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt; issues a warning when either a function or class has this attribute and its return value is discarded.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;[[nodiscard]] bool do_something() {&#xA;  return is_success; // true for success, false for failure&#xA;}&#xA;&#xA;do_something(); // warning: ignoring return value of &#39;bool do_something()&#39;,&#xA;                // declared with attribute &#39;nodiscard&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Only issues a warning when `error_info` is returned by value.&#xA;struct [[nodiscard]] error_info {&#xA;  // ...&#xA;};&#xA;&#xA;error_info do_something() {&#xA;  error_info ei;&#xA;  // ...&#xA;  return ei;&#xA;}&#xA;&#xA;do_something(); // warning: ignoring returned value of type &#39;error_info&#39;,&#xA;                // declared with attribute &#39;nodiscard&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;[[maybe_unused]]&lt;/code&gt; indicates to the compiler that a variable or parameter might be unused and is intended.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void my_callback(std::string msg, [[maybe_unused]] bool error) {&#xA;  // Don&#39;t care if `msg` is an error message, just log it.&#xA;  log(msg);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;__has_include&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;__has_include (operand)&lt;/code&gt; operator may be used in &lt;code&gt;#if&lt;/code&gt; and &lt;code&gt;#elif&lt;/code&gt; expressions to check whether a header or source file (&lt;code&gt;operand&lt;/code&gt;) is available for inclusion or not.&lt;/p&gt; &#xA;&lt;p&gt;One use case of this would be using two libraries that work the same way, using the backup/experimental one if the preferred one is not found on the system.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#ifdef __has_include&#xA;#  if __has_include(&amp;lt;optional&amp;gt;)&#xA;#    include &amp;lt;optional&amp;gt;&#xA;#    define have_optional 1&#xA;#  elif __has_include(&amp;lt;experimental/optional&amp;gt;)&#xA;#    include &amp;lt;experimental/optional&amp;gt;&#xA;#    define have_optional 1&#xA;#    define experimental_optional&#xA;#  else&#xA;#    define have_optional 0&#xA;#  endif&#xA;#endif&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can also be used to include headers existing under different names or locations on various platforms, without knowing which platform the program is running on, OpenGL headers are a good example for this which are located in &lt;code&gt;OpenGL\&lt;/code&gt; directory on macOS and &lt;code&gt;GL\&lt;/code&gt; on other platforms.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#ifdef __has_include&#xA;#  if __has_include(&amp;lt;OpenGL/gl.h&amp;gt;)&#xA;#    include &amp;lt;OpenGL/gl.h&amp;gt;&#xA;#    include &amp;lt;OpenGL/glu.h&amp;gt;&#xA;#  elif __has_include(&amp;lt;GL/gl.h&amp;gt;)&#xA;#    include &amp;lt;GL/gl.h&amp;gt;&#xA;#    include &amp;lt;GL/glu.h&amp;gt;&#xA;#  else&#xA;#    error No suitable OpenGL headers found.&#xA;# endif&#xA;#endif&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;C++17 Library Features&lt;/h2&gt; &#xA;&lt;h3&gt;std::variant&lt;/h3&gt; &#xA;&lt;p&gt;The class template &lt;code&gt;std::variant&lt;/code&gt; represents a type-safe &lt;code&gt;union&lt;/code&gt;. An instance of &lt;code&gt;std::variant&lt;/code&gt; at any given time holds a value of one of its alternative types (it&#39;s also possible for it to be valueless).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::variant&amp;lt;int, double&amp;gt; v{ 12 };&#xA;std::get&amp;lt;int&amp;gt;(v); // == 12&#xA;std::get&amp;lt;0&amp;gt;(v); // == 12&#xA;v = 12.0;&#xA;std::get&amp;lt;double&amp;gt;(v); // == 12.0&#xA;std::get&amp;lt;1&amp;gt;(v); // == 12.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::optional&lt;/h3&gt; &#xA;&lt;p&gt;The class template &lt;code&gt;std::optional&lt;/code&gt; manages an optional contained value, i.e. a value that may or may not be present. A common use case for optional is the return value of a function that may fail.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::optional&amp;lt;std::string&amp;gt; create(bool b) {&#xA;  if (b) {&#xA;    return &#34;Godzilla&#34;;&#xA;  } else {&#xA;    return {};&#xA;  }&#xA;}&#xA;&#xA;create(false).value_or(&#34;empty&#34;); // == &#34;empty&#34;&#xA;create(true).value(); // == &#34;Godzilla&#34;&#xA;// optional-returning factory functions are usable as conditions of while and if&#xA;if (auto str = create(true)) {&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::any&lt;/h3&gt; &#xA;&lt;p&gt;A type-safe container for single values of any type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::any x {5};&#xA;x.has_value() // == true&#xA;std::any_cast&amp;lt;int&amp;gt;(x) // == 5&#xA;std::any_cast&amp;lt;int&amp;amp;&amp;gt;(x) = 10;&#xA;std::any_cast&amp;lt;int&amp;gt;(x) // == 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::string_view&lt;/h3&gt; &#xA;&lt;p&gt;A non-owning reference to a string. Useful for providing an abstraction on top of strings (e.g. for parsing).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Regular strings.&#xA;std::string_view cppstr {&#34;foo&#34;};&#xA;// Wide strings.&#xA;std::wstring_view wcstr_v {L&#34;baz&#34;};&#xA;// Character arrays.&#xA;char array[3] = {&#39;b&#39;, &#39;a&#39;, &#39;r&#39;};&#xA;std::string_view array_v(array, std::size(array));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::string str {&#34;   trim me&#34;};&#xA;std::string_view v {str};&#xA;v.remove_prefix(std::min(v.find_first_not_of(&#34; &#34;), v.size()));&#xA;str; //  == &#34;   trim me&#34;&#xA;v; // == &#34;trim me&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::invoke&lt;/h3&gt; &#xA;&lt;p&gt;Invoke a &lt;code&gt;Callable&lt;/code&gt; object with parameters. Examples of &lt;code&gt;Callable&lt;/code&gt; objects are &lt;code&gt;std::function&lt;/code&gt; or &lt;code&gt;std::bind&lt;/code&gt; where an object can be called similarly to a regular function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename Callable&amp;gt;&#xA;class Proxy {&#xA;  Callable c;&#xA;public:&#xA;  Proxy(Callable c): c(c) {}&#xA;  template &amp;lt;class... Args&amp;gt;&#xA;  decltype(auto) operator()(Args&amp;amp;&amp;amp;... args) {&#xA;    // ...&#xA;    return std::invoke(c, std::forward&amp;lt;Args&amp;gt;(args)...);&#xA;  }&#xA;};&#xA;auto add = [](int x, int y) {&#xA;  return x + y;&#xA;};&#xA;Proxy&amp;lt;decltype(add)&amp;gt; p {add};&#xA;p(1, 2); // == 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::apply&lt;/h3&gt; &#xA;&lt;p&gt;Invoke a &lt;code&gt;Callable&lt;/code&gt; object with a tuple of arguments.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto add = [](int x, int y) {&#xA;  return x + y;&#xA;};&#xA;std::apply(add, std::make_tuple(1, 2)); // == 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::filesystem&lt;/h3&gt; &#xA;&lt;p&gt;The new &lt;code&gt;std::filesystem&lt;/code&gt; library provides a standard way to manipulate files, directories, and paths in a filesystem.&lt;/p&gt; &#xA;&lt;p&gt;Here, a big file is copied to a temporary path if there is available space:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const auto bigFilePath {&#34;bigFileToCopy&#34;};&#xA;if (std::filesystem::exists(bigFilePath)) {&#xA;  const auto bigFileSize {std::filesystem::file_size(bigFilePath)};&#xA;  std::filesystem::path tmpPath {&#34;/tmp&#34;};&#xA;  if (std::filesystem::space(tmpPath).available &amp;gt; bigFileSize) {&#xA;    std::filesystem::create_directory(tmpPath.append(&#34;example&#34;));&#xA;    std::filesystem::copy_file(bigFilePath, tmpPath.append(&#34;newFile&#34;));&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::byte&lt;/h3&gt; &#xA;&lt;p&gt;The new &lt;code&gt;std::byte&lt;/code&gt; type provides a standard way of representing data as a byte. Benefits of using &lt;code&gt;std::byte&lt;/code&gt; over &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; is that it is not a character type, and is also not an arithmetic type; while the only operator overloads available are bitwise operations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::byte a {0};&#xA;std::byte b {0xFF};&#xA;int i = std::to_integer&amp;lt;int&amp;gt;(b); // 0xFF&#xA;std::byte c = a &amp;amp; b;&#xA;int j = std::to_integer&amp;lt;int&amp;gt;(c); // 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;std::byte&lt;/code&gt; is simply an enum, and braced initialization of enums become possible thanks to &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#direct-list-initialization-of-enums&#34;&gt;direct-list-initialization of enums&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Splicing for maps and sets&lt;/h3&gt; &#xA;&lt;p&gt;Moving nodes and merging containers without the overhead of expensive copies, moves, or heap allocations/deallocations.&lt;/p&gt; &#xA;&lt;p&gt;Moving elements from one map to another:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::map&amp;lt;int, string&amp;gt; src {{1, &#34;one&#34;}, {2, &#34;two&#34;}, {3, &#34;buckle my shoe&#34;}};&#xA;std::map&amp;lt;int, string&amp;gt; dst {{3, &#34;three&#34;}};&#xA;dst.insert(src.extract(src.find(1))); // Cheap remove and insert of { 1, &#34;one&#34; } from `src` to `dst`.&#xA;dst.insert(src.extract(2)); // Cheap remove and insert of { 2, &#34;two&#34; } from `src` to `dst`.&#xA;// dst == { { 1, &#34;one&#34; }, { 2, &#34;two&#34; }, { 3, &#34;three&#34; } };&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Inserting an entire set:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::set&amp;lt;int&amp;gt; src {1, 3, 5};&#xA;std::set&amp;lt;int&amp;gt; dst {2, 4, 5};&#xA;dst.merge(src);&#xA;// src == { 5 }&#xA;// dst == { 1, 2, 3, 4, 5 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Inserting elements which outlive the container:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto elementFactory() {&#xA;  std::set&amp;lt;...&amp;gt; s;&#xA;  s.emplace(...);&#xA;  return s.extract(s.begin());&#xA;}&#xA;s2.insert(elementFactory());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Changing the key of a map element:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::map&amp;lt;int, string&amp;gt; m {{1, &#34;one&#34;}, {2, &#34;two&#34;}, {3, &#34;three&#34;}};&#xA;auto e = m.extract(2);&#xA;e.key() = 4;&#xA;m.insert(std::move(e));&#xA;// m == { { 1, &#34;one&#34; }, { 3, &#34;three&#34; }, { 4, &#34;two&#34; } }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parallel algorithms&lt;/h3&gt; &#xA;&lt;p&gt;Many of the STL algorithms, such as the &lt;code&gt;copy&lt;/code&gt;, &lt;code&gt;find&lt;/code&gt; and &lt;code&gt;sort&lt;/code&gt; methods, started to support the &lt;em&gt;parallel execution policies&lt;/em&gt;: &lt;code&gt;seq&lt;/code&gt;, &lt;code&gt;par&lt;/code&gt; and &lt;code&gt;par_unseq&lt;/code&gt; which translate to &#34;sequentially&#34;, &#34;parallel&#34; and &#34;parallel unsequenced&#34;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::vector&amp;lt;int&amp;gt; longVector;&#xA;// Find element using parallel execution policy&#xA;auto result1 = std::find(std::execution::par, std::begin(longVector), std::end(longVector), 2);&#xA;// Sort elements using sequential execution policy&#xA;auto result2 = std::sort(std::execution::seq, std::begin(longVector), std::end(longVector));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;C++14 Language Features&lt;/h2&gt; &#xA;&lt;h3&gt;Binary literals&lt;/h3&gt; &#xA;&lt;p&gt;Binary literals provide a convenient way to represent a base-2 number. It is possible to separate digits with &lt;code&gt;&#39;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;0b110 // == 6&#xA;0b1111&#39;1111 // == 255&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Generic lambda expressions&lt;/h3&gt; &#xA;&lt;p&gt;C++14 now allows the &lt;code&gt;auto&lt;/code&gt; type-specifier in the parameter list, enabling polymorphic lambdas.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto identity = [](auto x) { return x; };&#xA;int three = identity(3); // == 3&#xA;std::string foo = identity(&#34;foo&#34;); // == &#34;foo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Lambda capture initializers&lt;/h3&gt; &#xA;&lt;p&gt;This allows creating lambda captures initialized with arbitrary expressions. The name given to the captured value does not need to be related to any variables in the enclosing scopes and introduces a new name inside the lambda body. The initializing expression is evaluated when the lambda is &lt;em&gt;created&lt;/em&gt; (not when it is &lt;em&gt;invoked&lt;/em&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int factory(int i) { return i * 10; }&#xA;auto f = [x = factory(2)] { return x; }; // returns 20&#xA;&#xA;auto generator = [x = 0] () mutable {&#xA;  // this would not compile without &#39;mutable&#39; as we are modifying x on each call&#xA;  return x++;&#xA;};&#xA;auto a = generator(); // == 0&#xA;auto b = generator(); // == 1&#xA;auto c = generator(); // == 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because it is now possible to &lt;em&gt;move&lt;/em&gt; (or &lt;em&gt;forward&lt;/em&gt;) values into a lambda that could previously be only captured by copy or reference we can now capture move-only types in a lambda by value. Note that in the below example the &lt;code&gt;p&lt;/code&gt; in the capture-list of &lt;code&gt;task2&lt;/code&gt; on the left-hand-side of &lt;code&gt;=&lt;/code&gt; is a new variable private to the lambda body and does not refer to the original &lt;code&gt;p&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto p = std::make_unique&amp;lt;int&amp;gt;(1);&#xA;&#xA;auto task1 = [=] { *p = 5; }; // ERROR: std::unique_ptr cannot be copied&#xA;// vs.&#xA;auto task2 = [p = std::move(p)] { *p = 5; }; // OK: p is move-constructed into the closure object&#xA;// the original p is empty after task2 is created&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using this reference-captures can have different names than the referenced variable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto x = 1;&#xA;auto f = [&amp;amp;r = x, x = x * 10] {&#xA;  ++r;&#xA;  return r + x;&#xA;};&#xA;f(); // sets x to 2 and returns 12&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Return type deduction&lt;/h3&gt; &#xA;&lt;p&gt;Using an &lt;code&gt;auto&lt;/code&gt; return type in C++14, the compiler will attempt to deduce the type for you. With lambdas, you can now deduce its return type using &lt;code&gt;auto&lt;/code&gt;, which makes returning a deduced reference or rvalue reference possible.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Deduce return type as `int`.&#xA;auto f(int i) {&#xA; return i;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename T&amp;gt;&#xA;auto&amp;amp; f(T&amp;amp; t) {&#xA;  return t;&#xA;}&#xA;&#xA;// Returns a reference to a deduced type.&#xA;auto g = [](auto&amp;amp; x) -&amp;gt; auto&amp;amp; { return f(x); };&#xA;int y = 123;&#xA;int&amp;amp; z = g(y); // reference to `y`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;decltype(auto)&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;decltype(auto)&lt;/code&gt; type-specifier also deduces a type like &lt;code&gt;auto&lt;/code&gt; does. However, it deduces return types while keeping their references and cv-qualifiers, while &lt;code&gt;auto&lt;/code&gt; will not.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int x = 0;&#xA;auto x1 = x; // int&#xA;decltype(auto) x2 = x; // const int&#xA;int y = 0;&#xA;int&amp;amp; y1 = y;&#xA;auto y2 = y1; // int&#xA;decltype(auto) y3 = y1; // int&amp;amp;&#xA;int&amp;amp;&amp;amp; z = 0;&#xA;auto z1 = std::move(z); // int&#xA;decltype(auto) z2 = std::move(z); // int&amp;amp;&amp;amp;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Note: Especially useful for generic code!&#xA;&#xA;// Return type is `int`.&#xA;auto f(const int&amp;amp; i) {&#xA; return i;&#xA;}&#xA;&#xA;// Return type is `const int&amp;amp;`.&#xA;decltype(auto) g(const int&amp;amp; i) {&#xA; return i;&#xA;}&#xA;&#xA;int x = 123;&#xA;static_assert(std::is_same&amp;lt;const int&amp;amp;, decltype(f(x))&amp;gt;::value == 0);&#xA;static_assert(std::is_same&amp;lt;int, decltype(f(x))&amp;gt;::value == 1);&#xA;static_assert(std::is_same&amp;lt;const int&amp;amp;, decltype(g(x))&amp;gt;::value == 1);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#decltype&#34;&gt;&lt;code&gt;decltype (C++11)&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Relaxing constraints on constexpr functions&lt;/h3&gt; &#xA;&lt;p&gt;In C++11, &lt;code&gt;constexpr&lt;/code&gt; function bodies could only contain a very limited set of syntaxes, including (but not limited to): &lt;code&gt;typedef&lt;/code&gt;s, &lt;code&gt;using&lt;/code&gt;s, and a single &lt;code&gt;return&lt;/code&gt; statement. In C++14, the set of allowable syntaxes expands greatly to include the most common syntax such as &lt;code&gt;if&lt;/code&gt; statements, multiple &lt;code&gt;return&lt;/code&gt;s, loops, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;constexpr int factorial(int n) {&#xA;  if (n &amp;lt;= 1) {&#xA;    return 1;&#xA;  } else {&#xA;    return n * factorial(n - 1);&#xA;  }&#xA;}&#xA;factorial(5); // == 120&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Variable templates&lt;/h3&gt; &#xA;&lt;p&gt;C++14 allows variables to be templated:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt;class T&amp;gt;&#xA;constexpr T pi = T(3.1415926535897932385);&#xA;template&amp;lt;class T&amp;gt;&#xA;constexpr T e  = T(2.7182818284590452353);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;[[deprecated]] attribute&lt;/h3&gt; &#xA;&lt;p&gt;C++14 introduces the &lt;code&gt;[[deprecated]]&lt;/code&gt; attribute to indicate that a unit (function, class, etc.) is discouraged and likely yield compilation warnings. If a reason is provided, it will be included in the warnings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;[[deprecated]]&#xA;void old_method();&#xA;[[deprecated(&#34;Use new_method instead&#34;)]]&#xA;void legacy_method();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;C++14 Library Features&lt;/h2&gt; &#xA;&lt;h3&gt;User-defined literals for standard library types&lt;/h3&gt; &#xA;&lt;p&gt;New user-defined literals for standard library types, including new built-in literals for &lt;code&gt;chrono&lt;/code&gt; and &lt;code&gt;basic_string&lt;/code&gt;. These can be &lt;code&gt;constexpr&lt;/code&gt; meaning they can be used at compile-time. Some uses for these literals include compile-time integer parsing, binary literals, and imaginary number literals.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;using namespace std::chrono_literals;&#xA;auto day = 24h;&#xA;day.count(); // == 24&#xA;std::chrono::duration_cast&amp;lt;std::chrono::minutes&amp;gt;(day).count(); // == 1440&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compile-time integer sequences&lt;/h3&gt; &#xA;&lt;p&gt;The class template &lt;code&gt;std::integer_sequence&lt;/code&gt; represents a compile-time sequence of integers. There are a few helpers built on top:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;std::make_integer_sequence&amp;lt;T, N&amp;gt;&lt;/code&gt; - creates a sequence of &lt;code&gt;0, ..., N - 1&lt;/code&gt; with type &lt;code&gt;T&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::index_sequence_for&amp;lt;T...&amp;gt;&lt;/code&gt; - converts a template parameter pack into an integer sequence.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Convert an array into a tuple:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt;typename Array, std::size_t... I&amp;gt;&#xA;decltype(auto) a2t_impl(const Array&amp;amp; a, std::integer_sequence&amp;lt;std::size_t, I...&amp;gt;) {&#xA;  return std::make_tuple(a[I]...);&#xA;}&#xA;&#xA;template&amp;lt;typename T, std::size_t N, typename Indices = std::make_index_sequence&amp;lt;N&amp;gt;&amp;gt;&#xA;decltype(auto) a2t(const std::array&amp;lt;T, N&amp;gt;&amp;amp; a) {&#xA;  return a2t_impl(a, Indices());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::make_unique&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;std::make_unique&lt;/code&gt; is the recommended way to create instances of &lt;code&gt;std::unique_ptr&lt;/code&gt;s due to the following reasons:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Avoid having to use the &lt;code&gt;new&lt;/code&gt; operator.&lt;/li&gt; &#xA; &lt;li&gt;Prevents code repetition when specifying the underlying type the pointer shall hold.&lt;/li&gt; &#xA; &lt;li&gt;Most importantly, it provides exception-safety. Suppose we were calling a function &lt;code&gt;foo&lt;/code&gt; like so:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;foo(std::unique_ptr&amp;lt;T&amp;gt;{new T{}}, function_that_throws(), std::unique_ptr&amp;lt;T&amp;gt;{new T{}});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The compiler is free to call &lt;code&gt;new T{}&lt;/code&gt;, then &lt;code&gt;function_that_throws()&lt;/code&gt;, and so on... Since we have allocated data on the heap in the first construction of a &lt;code&gt;T&lt;/code&gt;, we have introduced a leak here. With &lt;code&gt;std::make_unique&lt;/code&gt;, we are given exception-safety:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;foo(std::make_unique&amp;lt;T&amp;gt;(), function_that_throws(), std::make_unique&amp;lt;T&amp;gt;());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the section on &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#smart-pointers&#34;&gt;smart pointers (C++11)&lt;/a&gt; for more information on &lt;code&gt;std::unique_ptr&lt;/code&gt; and &lt;code&gt;std::shared_ptr&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;C++11 Language Features&lt;/h2&gt; &#xA;&lt;h3&gt;Move semantics&lt;/h3&gt; &#xA;&lt;p&gt;Moving an object means to transfer ownership of some resource it manages to another object.&lt;/p&gt; &#xA;&lt;p&gt;The first benefit of move semantics is performance optimization. When an object is about to reach the end of its lifetime, either because it&#39;s a temporary or by explicitly calling &lt;code&gt;std::move&lt;/code&gt;, a move is often a cheaper way to transfer resources. For example, moving a &lt;code&gt;std::vector&lt;/code&gt; is just copying some pointers and internal state over to the new vector -- copying would involve having to copy every single contained element in the vector, which is expensive and unnecessary if the old vector will soon be destroyed.&lt;/p&gt; &#xA;&lt;p&gt;Moves also make it possible for non-copyable types such as &lt;code&gt;std::unique_ptr&lt;/code&gt;s (&lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#smart-pointers&#34;&gt;smart pointers&lt;/a&gt;) to guarantee at the language level that there is only ever one instance of a resource being managed at a time, while being able to transfer an instance between scopes.&lt;/p&gt; &#xA;&lt;p&gt;See the sections on: &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#rvalue-references&#34;&gt;rvalue references&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#special-member-functions-for-move-semantics&#34;&gt;special member functions for move semantics&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdmove&#34;&gt;&lt;code&gt;std::move&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdforward&#34;&gt;&lt;code&gt;std::forward&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#forwarding-references&#34;&gt;&lt;code&gt;forwarding references&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Rvalue references&lt;/h3&gt; &#xA;&lt;p&gt;C++11 introduces a new reference termed the &lt;em&gt;rvalue reference&lt;/em&gt;. An rvalue reference to &lt;code&gt;T&lt;/code&gt;, which is a non-template type parameter (such as &lt;code&gt;int&lt;/code&gt;, or a user-defined type), is created with the syntax &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;. Rvalue references only bind to rvalues.&lt;/p&gt; &#xA;&lt;p&gt;Type deduction with lvalues and rvalues:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int x = 0; // `x` is an lvalue of type `int`&#xA;int&amp;amp; xl = x; // `xl` is an lvalue of type `int&amp;amp;`&#xA;int&amp;amp;&amp;amp; xr = x; // compiler error -- `x` is an lvalue&#xA;int&amp;amp;&amp;amp; xr2 = 0; // `xr2` is an lvalue of type `int&amp;amp;&amp;amp;` -- binds to the rvalue temporary, `0`&#xA;&#xA;void f(int&amp;amp; x) {}&#xA;void f(int&amp;amp;&amp;amp; x) {}&#xA;&#xA;f(x);  // calls f(int&amp;amp;)&#xA;f(xl); // calls f(int&amp;amp;)&#xA;f(3);  // calls f(int&amp;amp;&amp;amp;)&#xA;f(std::move(x)); // calls f(int&amp;amp;&amp;amp;)&#xA;&#xA;f(xr2);           // calls f(int&amp;amp;)&#xA;f(std::move(xr2)); // calls f(int&amp;amp;&amp;amp; x)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdmove&#34;&gt;&lt;code&gt;std::move&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdforward&#34;&gt;&lt;code&gt;std::forward&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#forwarding-references&#34;&gt;&lt;code&gt;forwarding references&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Forwarding references&lt;/h3&gt; &#xA;&lt;p&gt;Also known (unofficially) as &lt;em&gt;universal references&lt;/em&gt;. A forwarding reference is created with the syntax &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a template type parameter, or using &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt;. This enables &lt;em&gt;perfect forwarding&lt;/em&gt;: the ability to pass arguments while maintaining their value category (e.g. lvalues stay as lvalues, temporaries are forwarded as rvalues).&lt;/p&gt; &#xA;&lt;p&gt;Forwarding references allow a reference to bind to either an lvalue or rvalue depending on the type. Forwarding references follow the rules of &lt;em&gt;reference collapsing&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;T&amp;amp; &amp;amp;&lt;/code&gt; becomes &lt;code&gt;T&amp;amp;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;T&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; becomes &lt;code&gt;T&amp;amp;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;T&amp;amp;&amp;amp; &amp;amp;&lt;/code&gt; becomes &lt;code&gt;T&amp;amp;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;T&amp;amp;&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt; becomes &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; type deduction with lvalues and rvalues:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int x = 0; // `x` is an lvalue of type `int`&#xA;auto&amp;amp;&amp;amp; al = x; // `al` is an lvalue of type `int&amp;amp;` -- binds to the lvalue, `x`&#xA;auto&amp;amp;&amp;amp; ar = 0; // `ar` is an lvalue of type `int&amp;amp;&amp;amp;` -- binds to the rvalue temporary, `0`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Template type parameter deduction with lvalues and rvalues:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Since C++14 or later:&#xA;void f(auto&amp;amp;&amp;amp; t) {&#xA;  // ...&#xA;}&#xA;&#xA;// Since C++11 or later:&#xA;template &amp;lt;typename T&amp;gt;&#xA;void f(T&amp;amp;&amp;amp; t) {&#xA;  // ...&#xA;}&#xA;&#xA;int x = 0;&#xA;f(0); // T is int, deduces as f(int &amp;amp;&amp;amp;) =&amp;gt; f(int&amp;amp;&amp;amp;)&#xA;f(x); // T is int&amp;amp;, deduces as f(int&amp;amp; &amp;amp;&amp;amp;) =&amp;gt; f(int&amp;amp;)&#xA;&#xA;int&amp;amp; y = x;&#xA;f(y); // T is int&amp;amp;, deduces as f(int&amp;amp; &amp;amp;&amp;amp;) =&amp;gt; f(int&amp;amp;)&#xA;&#xA;int&amp;amp;&amp;amp; z = 0; // NOTE: `z` is an lvalue with type `int&amp;amp;&amp;amp;`.&#xA;f(z); // T is int&amp;amp;, deduces as f(int&amp;amp; &amp;amp;&amp;amp;) =&amp;gt; f(int&amp;amp;)&#xA;f(std::move(z)); // T is int, deduces as f(int &amp;amp;&amp;amp;) =&amp;gt; f(int&amp;amp;&amp;amp;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdmove&#34;&gt;&lt;code&gt;std::move&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdforward&#34;&gt;&lt;code&gt;std::forward&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#rvalue-references&#34;&gt;&lt;code&gt;rvalue references&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Variadic templates&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;...&lt;/code&gt; syntax creates a &lt;em&gt;parameter pack&lt;/em&gt; or expands one. A template &lt;em&gt;parameter pack&lt;/em&gt; is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A template with at least one parameter pack is called a &lt;em&gt;variadic template&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename... T&amp;gt;&#xA;struct arity {&#xA;  constexpr static int value = sizeof...(T);&#xA;};&#xA;static_assert(arity&amp;lt;&amp;gt;::value == 0);&#xA;static_assert(arity&amp;lt;char, short, int&amp;gt;::value == 3);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An interesting use for this is creating an &lt;em&gt;initializer list&lt;/em&gt; from a &lt;em&gt;parameter pack&lt;/em&gt; in order to iterate over variadic function arguments.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename First, typename... Args&amp;gt;&#xA;auto sum(const First first, const Args... args) -&amp;gt; decltype(first) {&#xA;  const auto values = {first, args...};&#xA;  return std::accumulate(values.begin(), values.end(), First{0});&#xA;}&#xA;&#xA;sum(1, 2, 3, 4, 5); // 15&#xA;sum(1, 2, 3);       // 6&#xA;sum(1.5, 2.0, 3.7); // 7.2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Initializer lists&lt;/h3&gt; &#xA;&lt;p&gt;A lightweight array-like container of elements created using a &#34;braced list&#34; syntax. For example, &lt;code&gt;{ 1, 2, 3 }&lt;/code&gt; creates a sequences of integers, that has type &lt;code&gt;std::initializer_list&amp;lt;int&amp;gt;&lt;/code&gt;. Useful as a replacement to passing a vector of objects to a function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int sum(const std::initializer_list&amp;lt;int&amp;gt;&amp;amp; list) {&#xA;  int total = 0;&#xA;  for (auto&amp;amp; e : list) {&#xA;    total += e;&#xA;  }&#xA;&#xA;  return total;&#xA;}&#xA;&#xA;auto list = {1, 2, 3};&#xA;sum(list); // == 6&#xA;sum({1, 2, 3}); // == 6&#xA;sum({}); // == 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Static assertions&lt;/h3&gt; &#xA;&lt;p&gt;Assertions that are evaluated at compile-time.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;constexpr int x = 0;&#xA;constexpr int y = 1;&#xA;static_assert(x == y, &#34;x != y&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;auto&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;-typed variables are deduced by the compiler according to the type of their initializer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto a = 3.14; // double&#xA;auto b = 1; // int&#xA;auto&amp;amp; c = b; // int&amp;amp;&#xA;auto d = { 0 }; // std::initializer_list&amp;lt;int&amp;gt;&#xA;auto&amp;amp;&amp;amp; e = 1; // int&amp;amp;&amp;amp;&#xA;auto&amp;amp;&amp;amp; f = b; // int&amp;amp;&#xA;auto g = new auto(123); // int*&#xA;const auto h = 1; // const int&#xA;auto i = 1, j = 2, k = 3; // int, int, int&#xA;auto l = 1, m = true, n = 1.61; // error -- `l` deduced to be int, `m` is bool&#xA;auto o; // error -- `o` requires initializer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Extremely useful for readability, especially for complicated types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::vector&amp;lt;int&amp;gt; v = ...;&#xA;std::vector&amp;lt;int&amp;gt;::const_iterator cit = v.cbegin();&#xA;// vs.&#xA;auto cit = v.cbegin();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Functions can also deduce the return type using &lt;code&gt;auto&lt;/code&gt;. In C++11, a return type must be specified either explicitly, or using &lt;code&gt;decltype&lt;/code&gt; like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename X, typename Y&amp;gt;&#xA;auto add(X x, Y y) -&amp;gt; decltype(x + y) {&#xA;  return x + y;&#xA;}&#xA;add(1, 2); // == 3&#xA;add(1, 2.0); // == 3.0&#xA;add(1.5, 1.5); // == 3.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The trailing return type in the above example is the &lt;em&gt;declared type&lt;/em&gt; (see section on &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#decltype&#34;&gt;&lt;code&gt;decltype&lt;/code&gt;&lt;/a&gt;) of the expression &lt;code&gt;x + y&lt;/code&gt;. For example, if &lt;code&gt;x&lt;/code&gt; is an integer and &lt;code&gt;y&lt;/code&gt; is a double, &lt;code&gt;decltype(x + y)&lt;/code&gt; is a double. Therefore, the above function will deduce the type depending on what type the expression &lt;code&gt;x + y&lt;/code&gt; yields. Notice that the trailing return type has access to its parameters, and &lt;code&gt;this&lt;/code&gt; when appropriate.&lt;/p&gt; &#xA;&lt;h3&gt;Lambda expressions&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;lambda&lt;/code&gt; is an unnamed function object capable of capturing variables in scope. It features: a &lt;em&gt;capture list&lt;/em&gt;; an optional set of parameters with an optional trailing return type; and a body. Examples of capture lists:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;[]&lt;/code&gt; - captures nothing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[=]&lt;/code&gt; - capture local objects (local variables, parameters) in scope by value.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt; - capture local objects (local variables, parameters) in scope by reference.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[this]&lt;/code&gt; - capture &lt;code&gt;this&lt;/code&gt; by reference.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[a, &amp;amp;b]&lt;/code&gt; - capture objects &lt;code&gt;a&lt;/code&gt; by value, &lt;code&gt;b&lt;/code&gt; by reference.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int x = 1;&#xA;&#xA;auto getX = [=] { return x; };&#xA;getX(); // == 1&#xA;&#xA;auto addX = [=](int y) { return x + y; };&#xA;addX(1); // == 2&#xA;&#xA;auto getXRef = [&amp;amp;]() -&amp;gt; int&amp;amp; { return x; };&#xA;getXRef(); // int&amp;amp; to `x`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, value-captures cannot be modified inside the lambda because the compiler-generated method is marked as &lt;code&gt;const&lt;/code&gt;. The &lt;code&gt;mutable&lt;/code&gt; keyword allows modifying captured variables. The keyword is placed after the parameter-list (which must be present even if it is empty).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int x = 1;&#xA;&#xA;auto f1 = [&amp;amp;x] { x = 2; }; // OK: x is a reference and modifies the original&#xA;&#xA;auto f2 = [x] { x = 2; }; // ERROR: the lambda can only perform const-operations on the captured value&#xA;// vs.&#xA;auto f3 = [x]() mutable { x = 2; }; // OK: the lambda can perform any operations on the captured value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;decltype&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;decltype&lt;/code&gt; is an operator which returns the &lt;em&gt;declared type&lt;/em&gt; of an expression passed to it. cv-qualifiers and references are maintained if they are part of the expression. Examples of &lt;code&gt;decltype&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int a = 1; // `a` is declared as type `int`&#xA;decltype(a) b = a; // `decltype(a)` is `int`&#xA;const int&amp;amp; c = a; // `c` is declared as type `const int&amp;amp;`&#xA;decltype(c) d = a; // `decltype(c)` is `const int&amp;amp;`&#xA;decltype(123) e = 123; // `decltype(123)` is `int`&#xA;int&amp;amp;&amp;amp; f = 1; // `f` is declared as type `int&amp;amp;&amp;amp;`&#xA;decltype(f) g = 1; // `decltype(f) is `int&amp;amp;&amp;amp;`&#xA;decltype((a)) h = g; // `decltype((a))` is int&amp;amp;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename X, typename Y&amp;gt;&#xA;auto add(X x, Y y) -&amp;gt; decltype(x + y) {&#xA;  return x + y;&#xA;}&#xA;add(1, 2.0); // `decltype(x + y)` =&amp;gt; `decltype(3.0)` =&amp;gt; `double`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#decltypeauto&#34;&gt;&lt;code&gt;decltype(auto) (C++14)&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Type aliases&lt;/h3&gt; &#xA;&lt;p&gt;Semantically similar to using a &lt;code&gt;typedef&lt;/code&gt; however, type aliases with &lt;code&gt;using&lt;/code&gt; are easier to read and are compatible with templates.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename T&amp;gt;&#xA;using Vec = std::vector&amp;lt;T&amp;gt;;&#xA;Vec&amp;lt;int&amp;gt; v; // std::vector&amp;lt;int&amp;gt;&#xA;&#xA;using String = std::string;&#xA;String s {&#34;foo&#34;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;nullptr&lt;/h3&gt; &#xA;&lt;p&gt;C++11 introduces a new null pointer type designed to replace C&#39;s &lt;code&gt;NULL&lt;/code&gt; macro. &lt;code&gt;nullptr&lt;/code&gt; itself is of type &lt;code&gt;std::nullptr_t&lt;/code&gt; and can be implicitly converted into pointer types, and unlike &lt;code&gt;NULL&lt;/code&gt;, not convertible to integral types except &lt;code&gt;bool&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void foo(int);&#xA;void foo(char*);&#xA;foo(NULL); // error -- ambiguous&#xA;foo(nullptr); // calls foo(char*)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Strongly-typed enums&lt;/h3&gt; &#xA;&lt;p&gt;Type-safe enums that solve a variety of problems with C-style enums including: implicit conversions, inability to specify the underlying type, scope pollution.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Specifying underlying type as `unsigned int`&#xA;enum class Color : unsigned int { Red = 0xff0000, Green = 0xff00, Blue = 0xff };&#xA;// `Red`/`Green` in `Alert` don&#39;t conflict with `Color`&#xA;enum class Alert : bool { Red, Green };&#xA;Color c = Color::Red;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Attributes&lt;/h3&gt; &#xA;&lt;p&gt;Attributes provide a universal syntax over &lt;code&gt;__attribute__(...)&lt;/code&gt;, &lt;code&gt;__declspec&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// `noreturn` attribute indicates `f` doesn&#39;t return.&#xA;[[ noreturn ]] void f() {&#xA;  throw &#34;error&#34;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;constexpr&lt;/h3&gt; &#xA;&lt;p&gt;Constant expressions are expressions evaluated by the compiler at compile-time. Only non-complex computations can be carried out in a constant expression. Use the &lt;code&gt;constexpr&lt;/code&gt; specifier to indicate the variable, function, etc. is a constant expression.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;constexpr int square(int x) {&#xA;  return x * x;&#xA;}&#xA;&#xA;int square2(int x) {&#xA;  return x * x;&#xA;}&#xA;&#xA;int a = square(2);  // mov DWORD PTR [rbp-4], 4&#xA;&#xA;int b = square2(2); // mov edi, 2&#xA;                    // call square2(int)&#xA;                    // mov DWORD PTR [rbp-8], eax&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt; values are those that the compiler can evaluate at compile-time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int x = 123;&#xA;constexpr const int&amp;amp; y = x; // error -- constexpr variable `y` must be initialized by a constant expression&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Constant expressions with classes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Complex {&#xA;  constexpr Complex(double r, double i) : re{r}, im{i} { }&#xA;  constexpr double real() { return re; }&#xA;  constexpr double imag() { return im; }&#xA;&#xA;private:&#xA;  double re;&#xA;  double im;&#xA;};&#xA;&#xA;constexpr Complex I(0, 1);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Delegating constructors&lt;/h3&gt; &#xA;&lt;p&gt;Constructors can now call other constructors in the same class using an initializer list.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Foo {&#xA;  int foo;&#xA;  Foo(int foo) : foo{foo} {}&#xA;  Foo() : Foo(0) {}&#xA;};&#xA;&#xA;Foo foo;&#xA;foo.foo; // == 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;User-defined literals&lt;/h3&gt; &#xA;&lt;p&gt;User-defined literals allow you to extend the language and add your own syntax. To create a literal, define a &lt;code&gt;T operator &#34;&#34; X(...) { ... }&lt;/code&gt; function that returns a type &lt;code&gt;T&lt;/code&gt;, with a name &lt;code&gt;X&lt;/code&gt;. Note that the name of this function defines the name of the literal. Any literal names not starting with an underscore are reserved and won&#39;t be invoked. There are rules on what parameters a user-defined literal function should accept, according to what type the literal is called on.&lt;/p&gt; &#xA;&lt;p&gt;Converting Celsius to Fahrenheit:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// `unsigned long long` parameter required for integer literal.&#xA;long long operator &#34;&#34; _celsius(unsigned long long tempCelsius) {&#xA;  return std::llround(tempCelsius * 1.8 + 32);&#xA;}&#xA;24_celsius; // == 75&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;String to integer conversion:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// `const char*` and `std::size_t` required as parameters.&#xA;int operator &#34;&#34; _int(const char* str, std::size_t) {&#xA;  return std::stoi(str);&#xA;}&#xA;&#xA;&#34;123&#34;_int; // == 123, with type `int`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Explicit virtual overrides&lt;/h3&gt; &#xA;&lt;p&gt;Specifies that a virtual function overrides another virtual function. If the virtual function does not override a parent&#39;s virtual function, throws a compiler error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct A {&#xA;  virtual void foo();&#xA;  void bar();&#xA;};&#xA;&#xA;struct B : A {&#xA;  void foo() override; // correct -- B::foo overrides A::foo&#xA;  void bar() override; // error -- A::bar is not virtual&#xA;  void baz() override; // error -- B::baz does not override A::baz&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Final specifier&lt;/h3&gt; &#xA;&lt;p&gt;Specifies that a virtual function cannot be overridden in a derived class or that a class cannot be inherited from.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct A {&#xA;  virtual void foo();&#xA;};&#xA;&#xA;struct B : A {&#xA;  virtual void foo() final;&#xA;};&#xA;&#xA;struct C : B {&#xA;  virtual void foo(); // error -- declaration of &#39;foo&#39; overrides a &#39;final&#39; function&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Class cannot be inherited from.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct A final {};&#xA;struct B : A {}; // error -- base &#39;A&#39; is marked &#39;final&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Default functions&lt;/h3&gt; &#xA;&lt;p&gt;A more elegant, efficient way to provide a default implementation of a function, such as a constructor.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct A {&#xA;  A() = default;&#xA;  A(int x) : x{x} {}&#xA;  int x {1};&#xA;};&#xA;A a; // a.x == 1&#xA;A a2 {123}; // a.x == 123&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With inheritance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct B {&#xA;  B() : x{1} {}&#xA;  int x;&#xA;};&#xA;&#xA;struct C : B {&#xA;  // Calls B::B&#xA;  C() = default;&#xA;};&#xA;&#xA;C c; // c.x == 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deleted functions&lt;/h3&gt; &#xA;&lt;p&gt;A more elegant, efficient way to provide a deleted implementation of a function. Useful for preventing copies on objects.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class A {&#xA;  int x;&#xA;&#xA;public:&#xA;  A(int x) : x{x} {};&#xA;  A(const A&amp;amp;) = delete;&#xA;  A&amp;amp; operator=(const A&amp;amp;) = delete;&#xA;};&#xA;&#xA;A x {123};&#xA;A y = x; // error -- call to deleted copy constructor&#xA;y = x; // error -- operator= deleted&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Range-based for loops&lt;/h3&gt; &#xA;&lt;p&gt;Syntactic sugar for iterating over a container&#39;s elements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::array&amp;lt;int, 5&amp;gt; a {1, 2, 3, 4, 5};&#xA;for (int&amp;amp; x : a) x *= 2;&#xA;// a == { 2, 4, 6, 8, 10 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note the difference when using &lt;code&gt;int&lt;/code&gt; as opposed to &lt;code&gt;int&amp;amp;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::array&amp;lt;int, 5&amp;gt; a {1, 2, 3, 4, 5};&#xA;for (int x : a) x *= 2;&#xA;// a == { 1, 2, 3, 4, 5 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Special member functions for move semantics&lt;/h3&gt; &#xA;&lt;p&gt;The copy constructor and copy assignment operator are called when copies are made, and with C++11&#39;s introduction of move semantics, there is now a move constructor and move assignment operator for moves.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct A {&#xA;  std::string s;&#xA;  A() : s{&#34;test&#34;} {}&#xA;  A(const A&amp;amp; o) : s{o.s} {}&#xA;  A(A&amp;amp;&amp;amp; o) : s{std::move(o.s)} {}&#xA;  A&amp;amp; operator=(A&amp;amp;&amp;amp; o) {&#xA;   s = std::move(o.s);&#xA;   return *this;&#xA;  }&#xA;};&#xA;&#xA;A f(A a) {&#xA;  return a;&#xA;}&#xA;&#xA;A a1 = f(A{}); // move-constructed from rvalue temporary&#xA;A a2 = std::move(a1); // move-constructed using std::move&#xA;A a3 = A{};&#xA;a2 = std::move(a3); // move-assignment using std::move&#xA;a1 = f(A{}); // move-assignment from rvalue temporary&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Converting constructors&lt;/h3&gt; &#xA;&lt;p&gt;Converting constructors will convert values of braced list syntax into constructor arguments.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct A {&#xA;  A(int) {}&#xA;  A(int, int) {}&#xA;  A(int, int, int) {}&#xA;};&#xA;&#xA;A a {0, 0}; // calls A::A(int, int)&#xA;A b(0, 0); // calls A::A(int, int)&#xA;A c = {0, 0}; // calls A::A(int, int)&#xA;A d {0, 0, 0}; // calls A::A(int, int, int)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the braced list syntax does not allow narrowing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct A {&#xA;  A(int) {}&#xA;};&#xA;&#xA;A a(1.1); // OK&#xA;A b {1.1}; // Error narrowing conversion from double to int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that if a constructor accepts a &lt;code&gt;std::initializer_list&lt;/code&gt;, it will be called instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct A {&#xA;  A(int) {}&#xA;  A(int, int) {}&#xA;  A(int, int, int) {}&#xA;  A(std::initializer_list&amp;lt;int&amp;gt;) {}&#xA;};&#xA;&#xA;A a {0, 0}; // calls A::A(std::initializer_list&amp;lt;int&amp;gt;)&#xA;A b(0, 0); // calls A::A(int, int)&#xA;A c = {0, 0}; // calls A::A(std::initializer_list&amp;lt;int&amp;gt;)&#xA;A d {0, 0, 0}; // calls A::A(std::initializer_list&amp;lt;int&amp;gt;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Explicit conversion functions&lt;/h3&gt; &#xA;&lt;p&gt;Conversion functions can now be made explicit using the &lt;code&gt;explicit&lt;/code&gt; specifier.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct A {&#xA;  operator bool() const { return true; }&#xA;};&#xA;&#xA;struct B {&#xA;  explicit operator bool() const { return true; }&#xA;};&#xA;&#xA;A a;&#xA;if (a); // OK calls A::operator bool()&#xA;bool ba = a; // OK copy-initialization selects A::operator bool()&#xA;&#xA;B b;&#xA;if (b); // OK calls B::operator bool()&#xA;bool bb = b; // error copy-initialization does not consider B::operator bool()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Inline namespaces&lt;/h3&gt; &#xA;&lt;p&gt;All members of an inline namespace are treated as if they were part of its parent namespace, allowing specialization of functions and easing the process of versioning. This is a transitive property, if A contains B, which in turn contains C and both B and C are inline namespaces, C&#39;s members can be used as if they were on A.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;namespace Program {&#xA;  namespace Version1 {&#xA;    int getVersion() { return 1; }&#xA;    bool isFirstVersion() { return true; }&#xA;  }&#xA;  inline namespace Version2 {&#xA;    int getVersion() { return 2; }&#xA;  }&#xA;}&#xA;&#xA;int version {Program::getVersion()};              // Uses getVersion() from Version2&#xA;int oldVersion {Program::Version1::getVersion()}; // Uses getVersion() from Version1&#xA;bool firstVersion {Program::isFirstVersion()};    // Does not compile when Version2 is added&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Non-static data member initializers&lt;/h3&gt; &#xA;&lt;p&gt;Allows non-static data members to be initialized where they are declared, potentially cleaning up constructors of default initializations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Default initialization prior to C++11&#xA;class Human {&#xA;    Human() : age{0} {}&#xA;  private:&#xA;    unsigned age;&#xA;};&#xA;// Default initialization on C++11&#xA;class Human {&#xA;  private:&#xA;    unsigned age {0};&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Right angle brackets&lt;/h3&gt; &#xA;&lt;p&gt;C++11 is now able to infer when a series of right angle brackets is used as an operator or as a closing statement of typedef, without having to add whitespace.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef std::map&amp;lt;int, std::map &amp;lt;int, std::map &amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; cpp98LongTypedef;&#xA;typedef std::map&amp;lt;int, std::map &amp;lt;int, std::map &amp;lt;int, int&amp;gt;&amp;gt;&amp;gt;   cpp11LongTypedef;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Ref-qualified member functions&lt;/h3&gt; &#xA;&lt;p&gt;Member functions can now be qualified depending on whether &lt;code&gt;*this&lt;/code&gt; is an lvalue or rvalue reference.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Bar {&#xA;  // ...&#xA;};&#xA;&#xA;struct Foo {&#xA;  Bar getBar() &amp;amp; { return bar; }&#xA;  Bar getBar() const&amp;amp; { return bar; }&#xA;  Bar getBar() &amp;amp;&amp;amp; { return std::move(bar); }&#xA;private:&#xA;  Bar bar;&#xA;};&#xA;&#xA;Foo foo{};&#xA;Bar bar = foo.getBar(); // calls `Bar getBar() &amp;amp;`&#xA;&#xA;const Foo foo2{};&#xA;Bar bar2 = foo2.getBar(); // calls `Bar Foo::getBar() const&amp;amp;`&#xA;&#xA;Foo{}.getBar(); // calls `Bar Foo::getBar() &amp;amp;&amp;amp;`&#xA;std::move(foo).getBar(); // calls `Bar Foo::getBar() &amp;amp;&amp;amp;`&#xA;&#xA;std::move(foo2).getBar(); // calls `Bar Foo::getBar() const&amp;amp;&amp;amp;`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Trailing return types&lt;/h3&gt; &#xA;&lt;p&gt;C++11 allows functions and lambdas an alternative syntax for specifying their return types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int f() {&#xA;  return 123;&#xA;}&#xA;// vs.&#xA;auto f() -&amp;gt; int {&#xA;  return 123;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto g = []() -&amp;gt; int {&#xA;  return 123;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This feature is especially useful when certain return types cannot be resolved:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// NOTE: This does not compile!&#xA;template &amp;lt;typename T, typename U&amp;gt;&#xA;decltype(a + b) add(T a, U b) {&#xA;    return a + b;&#xA;}&#xA;&#xA;// Trailing return types allows this:&#xA;template &amp;lt;typename T, typename U&amp;gt;&#xA;auto add(T a, U b) -&amp;gt; decltype(a + b) {&#xA;    return a + b;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In C++14, &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#decltypeauto&#34;&gt;&lt;code&gt;decltype(auto) (C++14)&lt;/code&gt;&lt;/a&gt; can be used instead.&lt;/p&gt; &#xA;&lt;h3&gt;Noexcept specifier&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;noexcept&lt;/code&gt; specifier specifies whether a function could throw exceptions. It is an improved version of &lt;code&gt;throw()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void func1() noexcept;        // does not throw&#xA;void func2() noexcept(true);  // does not throw&#xA;void func3() throw();         // does not throw&#xA;&#xA;void func4() noexcept(false); // may throw&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Non-throwing functions are permitted to call potentially-throwing functions. Whenever an exception is thrown and the search for a handler encounters the outermost block of a non-throwing function, the function std::terminate is called.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern void f();  // potentially-throwing&#xA;void g() noexcept {&#xA;    f();          // valid, even if f throws&#xA;    throw 42;     // valid, effectively a call to std::terminate&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;char32_t and char16_t&lt;/h3&gt; &#xA;&lt;p&gt;Provides standard types for representing UTF-8 strings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;char32_t utf8_str[] = U&#34;\u0123&#34;;&#xA;char16_t utf8_str[] = u&#34;\u0123&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Raw string literals&lt;/h3&gt; &#xA;&lt;p&gt;C++11 introduces a new way to declare string literals as &#34;raw string literals&#34;. Characters issued from an escape sequence (tabs, line feeds, single backslashes, etc.) can be inputted raw while preserving formatting. This is useful, for example, to write literary text, which might contain a lot of quotes or special formatting. This can make your string literals easier to read and maintain.&lt;/p&gt; &#xA;&lt;p&gt;A raw string literal is declared using the following syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;R&#34;delimiter(raw_characters)delimiter&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;delimiter&lt;/code&gt; is an optional sequence of characters made of any source character except parentheses, backslashes and spaces.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;raw_characters&lt;/code&gt; is any raw character sequence; must not contain the closing sequence &lt;code&gt;&#34;)delimiter&#34;&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// msg1 and msg2 are equivalent.&#xA;const char* msg1 = &#34;\nHello,\n\tworld!\n&#34;;&#xA;const char* msg2 = R&#34;(&#xA;Hello,&#xA;&#x9;world!&#xA;)&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;C++11 Library Features&lt;/h2&gt; &#xA;&lt;h3&gt;std::move&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;std::move&lt;/code&gt; indicates that the object passed to it may have its resources transferred. Using objects that have been moved from should be used with care, as they can be left in an unspecified state (see: &lt;a href=&#34;http://stackoverflow.com/questions/7027523/what-can-i-do-with-a-moved-from-object&#34;&gt;What can I do with a moved-from object?&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;A definition of &lt;code&gt;std::move&lt;/code&gt; (performing a move is nothing more than casting to an rvalue reference):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename T&amp;gt;&#xA;typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp; move(T&amp;amp;&amp;amp; arg) {&#xA;  return static_cast&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(arg);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Transferring &lt;code&gt;std::unique_ptr&lt;/code&gt;s:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::unique_ptr&amp;lt;int&amp;gt; p1 {new int{0}};  // in practice, use std::make_unique&#xA;std::unique_ptr&amp;lt;int&amp;gt; p2 = p1; // error -- cannot copy unique pointers&#xA;std::unique_ptr&amp;lt;int&amp;gt; p3 = std::move(p1); // move `p1` into `p3`&#xA;                                         // now unsafe to dereference object held by `p1`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::forward&lt;/h3&gt; &#xA;&lt;p&gt;Returns the arguments passed to it while maintaining their value category and cv-qualifiers. Useful for generic code and factories. Used in conjunction with &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#forwarding-references&#34;&gt;&lt;code&gt;forwarding references&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A definition of &lt;code&gt;std::forward&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename T&amp;gt;&#xA;T&amp;amp;&amp;amp; forward(typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp; arg) {&#xA;  return static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(arg);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An example of a function &lt;code&gt;wrapper&lt;/code&gt; which just forwards other &lt;code&gt;A&lt;/code&gt; objects to a new &lt;code&gt;A&lt;/code&gt; object&#39;s copy or move constructor:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct A {&#xA;  A() = default;&#xA;  A(const A&amp;amp; o) { std::cout &amp;lt;&amp;lt; &#34;copied&#34; &amp;lt;&amp;lt; std::endl; }&#xA;  A(A&amp;amp;&amp;amp; o) { std::cout &amp;lt;&amp;lt; &#34;moved&#34; &amp;lt;&amp;lt; std::endl; }&#xA;};&#xA;&#xA;template &amp;lt;typename T&amp;gt;&#xA;A wrapper(T&amp;amp;&amp;amp; arg) {&#xA;  return A{std::forward&amp;lt;T&amp;gt;(arg)};&#xA;}&#xA;&#xA;wrapper(A{}); // moved&#xA;A a;&#xA;wrapper(a); // copied&#xA;wrapper(std::move(a)); // moved&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#forwarding-references&#34;&gt;&lt;code&gt;forwarding references&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#rvalue-references&#34;&gt;&lt;code&gt;rvalue references&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;std::thread&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;std::thread&lt;/code&gt; library provides a standard way to control threads, such as spawning and killing them. In the example below, multiple threads are spawned to do different calculations and then the program waits for all of them to finish.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void foo(bool clause) { /* do something... */ }&#xA;&#xA;std::vector&amp;lt;std::thread&amp;gt; threadsVector;&#xA;threadsVector.emplace_back([]() {&#xA;  // Lambda function that will be invoked&#xA;});&#xA;threadsVector.emplace_back(foo, true);  // thread will run foo(true)&#xA;for (auto&amp;amp; thread : threadsVector) {&#xA;  thread.join(); // Wait for threads to finish&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::to_string&lt;/h3&gt; &#xA;&lt;p&gt;Converts a numeric argument to a &lt;code&gt;std::string&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::to_string(1.2); // == &#34;1.2&#34;&#xA;std::to_string(123); // == &#34;123&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Type traits&lt;/h3&gt; &#xA;&lt;p&gt;Type traits defines a compile-time template-based interface to query or modify the properties of types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static_assert(std::is_integral&amp;lt;int&amp;gt;::value);&#xA;static_assert(std::is_same&amp;lt;int, int&amp;gt;::value);&#xA;static_assert(std::is_same&amp;lt;std::conditional&amp;lt;true, int, double&amp;gt;::type, int&amp;gt;::value);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Smart pointers&lt;/h3&gt; &#xA;&lt;p&gt;C++11 introduces new smart pointers: &lt;code&gt;std::unique_ptr&lt;/code&gt;, &lt;code&gt;std::shared_ptr&lt;/code&gt;, &lt;code&gt;std::weak_ptr&lt;/code&gt;. &lt;code&gt;std::auto_ptr&lt;/code&gt; now becomes deprecated and then eventually removed in C++17.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; is a non-copyable, movable pointer that manages its own heap-allocated memory. &lt;strong&gt;Note: Prefer using the &lt;code&gt;std::make_X&lt;/code&gt; helper functions as opposed to using constructors. See the sections for &lt;a href=&#34;https://github.com/AnthonyCalandra/modern-cpp-features/raw/master/CPP14.md#stdmake_unique&#34;&gt;std::make_unique&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdmake_shared&#34;&gt;std::make_shared&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::unique_ptr&amp;lt;Foo&amp;gt; p1 { new Foo{} };  // `p1` owns `Foo`&#xA;if (p1) {&#xA;  p1-&amp;gt;bar();&#xA;}&#xA;&#xA;{&#xA;  std::unique_ptr&amp;lt;Foo&amp;gt; p2 {std::move(p1)};  // Now `p2` owns `Foo`&#xA;  f(*p2);&#xA;&#xA;  p1 = std::move(p2);  // Ownership returns to `p1` -- `p2` gets destroyed&#xA;}&#xA;&#xA;if (p1) {&#xA;  p1-&amp;gt;bar();&#xA;}&#xA;// `Foo` instance is destroyed when `p1` goes out of scope&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;std::shared_ptr&lt;/code&gt; is a smart pointer that manages a resource that is shared across multiple owners. A shared pointer holds a &lt;em&gt;control block&lt;/em&gt; which has a few components such as the managed object and a reference counter. All control block access is thread-safe, however, manipulating the managed object itself is &lt;em&gt;not&lt;/em&gt; thread-safe.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void foo(std::shared_ptr&amp;lt;T&amp;gt; t) {&#xA;  // Do something with `t`...&#xA;}&#xA;&#xA;void bar(std::shared_ptr&amp;lt;T&amp;gt; t) {&#xA;  // Do something with `t`...&#xA;}&#xA;&#xA;void baz(std::shared_ptr&amp;lt;T&amp;gt; t) {&#xA;  // Do something with `t`...&#xA;}&#xA;&#xA;std::shared_ptr&amp;lt;T&amp;gt; p1 {new T{}};&#xA;// Perhaps these take place in another threads?&#xA;foo(p1);&#xA;bar(p1);&#xA;baz(p1);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::chrono&lt;/h3&gt; &#xA;&lt;p&gt;The chrono library contains a set of utility functions and types that deal with &lt;em&gt;durations&lt;/em&gt;, &lt;em&gt;clocks&lt;/em&gt;, and &lt;em&gt;time points&lt;/em&gt;. One use case of this library is benchmarking code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::chrono::time_point&amp;lt;std::chrono::steady_clock&amp;gt; start, end;&#xA;start = std::chrono::steady_clock::now();&#xA;// Some computations...&#xA;end = std::chrono::steady_clock::now();&#xA;&#xA;std::chrono::duration&amp;lt;double&amp;gt; elapsed_seconds = end - start;&#xA;double t = elapsed_seconds.count(); // t number of seconds, represented as a `double`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tuples&lt;/h3&gt; &#xA;&lt;p&gt;Tuples are a fixed-size collection of heterogeneous values. Access the elements of a &lt;code&gt;std::tuple&lt;/code&gt; by unpacking using &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdtie&#34;&gt;&lt;code&gt;std::tie&lt;/code&gt;&lt;/a&gt;, or using &lt;code&gt;std::get&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// `playerProfile` has type `std::tuple&amp;lt;int, const char*, const char*&amp;gt;`.&#xA;auto playerProfile = std::make_tuple(51, &#34;Frans Nielsen&#34;, &#34;NYI&#34;);&#xA;std::get&amp;lt;0&amp;gt;(playerProfile); // 51&#xA;std::get&amp;lt;1&amp;gt;(playerProfile); // &#34;Frans Nielsen&#34;&#xA;std::get&amp;lt;2&amp;gt;(playerProfile); // &#34;NYI&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::tie&lt;/h3&gt; &#xA;&lt;p&gt;Creates a tuple of lvalue references. Useful for unpacking &lt;code&gt;std::pair&lt;/code&gt; and &lt;code&gt;std::tuple&lt;/code&gt; objects. Use &lt;code&gt;std::ignore&lt;/code&gt; as a placeholder for ignored values. In C++17, structured bindings should be used instead.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// With tuples...&#xA;std::string playerName;&#xA;std::tie(std::ignore, playerName, std::ignore) = std::make_tuple(91, &#34;John Tavares&#34;, &#34;NYI&#34;);&#xA;&#xA;// With pairs...&#xA;std::string yes, no;&#xA;std::tie(yes, no) = std::make_pair(&#34;yes&#34;, &#34;no&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::array&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;std::array&lt;/code&gt; is a container built on top of a C-style array. Supports common container operations such as sorting.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::array&amp;lt;int, 3&amp;gt; a = {2, 1, 3};&#xA;std::sort(a.begin(), a.end()); // a == { 1, 2, 3 }&#xA;for (int&amp;amp; x : a) x *= 2; // a == { 2, 4, 6 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unordered containers&lt;/h3&gt; &#xA;&lt;p&gt;These containers maintain average constant-time complexity for search, insert, and remove operations. In order to achieve constant-time complexity, sacrifices order for speed by hashing elements into buckets. There are four unordered containers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;unordered_set&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;unordered_multiset&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;unordered_map&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;unordered_multimap&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;std::make_shared&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;std::make_shared&lt;/code&gt; is the recommended way to create instances of &lt;code&gt;std::shared_ptr&lt;/code&gt;s due to the following reasons:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Avoid having to use the &lt;code&gt;new&lt;/code&gt; operator.&lt;/li&gt; &#xA; &lt;li&gt;Prevents code repetition when specifying the underlying type the pointer shall hold.&lt;/li&gt; &#xA; &lt;li&gt;It provides exception-safety. Suppose we were calling a function &lt;code&gt;foo&lt;/code&gt; like so:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;foo(std::shared_ptr&amp;lt;T&amp;gt;{new T{}}, function_that_throws(), std::shared_ptr&amp;lt;T&amp;gt;{new T{}});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The compiler is free to call &lt;code&gt;new T{}&lt;/code&gt;, then &lt;code&gt;function_that_throws()&lt;/code&gt;, and so on... Since we have allocated data on the heap in the first construction of a &lt;code&gt;T&lt;/code&gt;, we have introduced a leak here. With &lt;code&gt;std::make_shared&lt;/code&gt;, we are given exception-safety:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;foo(std::make_shared&amp;lt;T&amp;gt;(), function_that_throws(), std::make_shared&amp;lt;T&amp;gt;());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Prevents having to do two allocations. When calling &lt;code&gt;std::shared_ptr{ new T{} }&lt;/code&gt;, we have to allocate memory for &lt;code&gt;T&lt;/code&gt;, then in the shared pointer we have to allocate memory for the control block within the pointer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the section on &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#smart-pointers&#34;&gt;smart pointers&lt;/a&gt; for more information on &lt;code&gt;std::unique_ptr&lt;/code&gt; and &lt;code&gt;std::shared_ptr&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;std::ref&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;std::ref(val)&lt;/code&gt; is used to create object of type &lt;code&gt;std::reference_wrapper&lt;/code&gt; that holds reference of val. Used in cases when usual reference passing using &lt;code&gt;&amp;amp;&lt;/code&gt; does not compile or &lt;code&gt;&amp;amp;&lt;/code&gt; is dropped due to type deduction. &lt;code&gt;std::cref&lt;/code&gt; is similar but created reference wrapper holds a const reference to val.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// create a container to store reference of objects.&#xA;auto val = 99;&#xA;auto _ref = std::ref(val);&#xA;_ref++;&#xA;auto _cref = std::cref(val);&#xA;//_cref++; does not compile&#xA;std::vector&amp;lt;std::reference_wrapper&amp;lt;int&amp;gt;&amp;gt;vec; // vector&amp;lt;int&amp;amp;&amp;gt;vec does not compile&#xA;vec.push_back(_ref); // vec.push_back(&amp;amp;i) does not compile&#xA;cout &amp;lt;&amp;lt; val &amp;lt;&amp;lt; endl; // prints 100&#xA;cout &amp;lt;&amp;lt; vec[0] &amp;lt;&amp;lt; endl; // prints 100&#xA;cout &amp;lt;&amp;lt; _cref; // prints 100&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Memory model&lt;/h3&gt; &#xA;&lt;p&gt;C++11 introduces a memory model for C++, which means library support for threading and atomic operations. Some of these operations include (but aren&#39;t limited to) atomic loads/stores, compare-and-swap, atomic flags, promises, futures, locks, and condition variables.&lt;/p&gt; &#xA;&lt;p&gt;See the sections on: &lt;a href=&#34;https://raw.githubusercontent.com/AnthonyCalandra/modern-cpp-features/master/#stdthread&#34;&gt;std::thread&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;std::async&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;std::async&lt;/code&gt; runs the given function either asynchronously or lazily-evaluated, then returns a &lt;code&gt;std::future&lt;/code&gt; which holds the result of that function call.&lt;/p&gt; &#xA;&lt;p&gt;The first parameter is the policy which can be:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;std::launch::async | std::launch::deferred&lt;/code&gt; It is up to the implementation whether to perform asynchronous execution or lazy evaluation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::launch::async&lt;/code&gt; Run the callable object on a new thread.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::launch::deferred&lt;/code&gt; Perform lazy evaluation on the current thread.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int foo() {&#xA;  /* Do something here, then return the result. */&#xA;  return 1000;&#xA;}&#xA;&#xA;auto handle = std::async(std::launch::async, foo);  // create an async task&#xA;auto result = handle.get();  // wait for the result&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;std::begin/end&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;std::begin&lt;/code&gt; and &lt;code&gt;std::end&lt;/code&gt; free functions were added to return begin and end iterators of a container generically. These functions also work with raw arrays which do not have &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; member functions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;typename T&amp;gt;&#xA;int CountTwos(const T&amp;amp; container) {&#xA;  return std::count_if(std::begin(container), std::end(container), [](int item) {&#xA;    return item == 2;&#xA;  });&#xA;}&#xA;&#xA;std::vector&amp;lt;int&amp;gt; vec = {2, 2, 43, 435, 4543, 534};&#xA;int arr[8] = {2, 43, 45, 435, 32, 32, 32, 32};&#xA;auto a = CountTwos(vec); // 2&#xA;auto b = CountTwos(arr);  // 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp&#34;&gt;cppreference&lt;/a&gt; - especially useful for finding examples and documentation of new library features.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://thbecker.net/articles/rvalue_references/section_01.html&#34;&gt;C++ Rvalue References Explained&lt;/a&gt; - a great introduction I used to understand rvalue references, perfect forwarding, and move semantics.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://clang.llvm.org/cxx_status.html&#34;&gt;clang&lt;/a&gt; and &lt;a href=&#34;https://gcc.gnu.org/projects/cxx-status.html&#34;&gt;gcc&lt;/a&gt;&#39;s standards support pages. Also included here are the proposals for language/library features that I used to help find a description of, what it&#39;s meant to fix, and some examples.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godbolt.org/&#34;&gt;Compiler explorer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996&#34;&gt;Scott Meyers&#39; Effective Modern C++&lt;/a&gt; - highly recommended series of books!&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw&#34;&gt;Jason Turner&#39;s C++ Weekly&lt;/a&gt; - nice collection of C++-related videos.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/7027523/what-can-i-do-with-a-moved-from-object&#34;&gt;What can I do with a moved-from object?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto&#34;&gt;What are some uses of decltype(auto)?&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;Anthony Calandra&lt;/p&gt; &#xA;&lt;h2&gt;Content Contributors&lt;/h2&gt; &#xA;&lt;p&gt;See: &lt;a href=&#34;https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors&#34;&gt;https://github.com/AnthonyCalandra/modern-cpp-features/graphs/contributors&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Porchetta-Industries/CrackMapExec</title>
    <updated>2022-09-27T01:41:31Z</updated>
    <id>tag:github.com,2022-09-27:/Porchetta-Industries/CrackMapExec</id>
    <link href="https://github.com/Porchetta-Industries/CrackMapExec" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A swiss army knife for pentesting networks&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/python-3.7+-blue.svg?sanitize=true&#34; alt=&#34;Supported Python versions&#34;&gt; &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=byt3bl33d3r&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/byt3bl33d3r?label=byt3bl33d3r&amp;amp;style=social&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=mpgn_x64&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/mpgn_x64?label=mpgn_x64&amp;amp;style=social&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;&lt;/span&gt; This is the public repository of CrackMapExec, for latest version and updates please consider supporting us through &lt;a href=&#34;https://porchetta.industries/&#34;&gt;https://porchetta.industries/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;CrackMapExec&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://cloud.githubusercontent.com/assets/5151193/17577511/d312ceb4-5f3b-11e6-8de5-8822246289fd.jpg&#34; alt=&#34;cme&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;In partnership with&lt;/h2&gt; &#xA;&lt;p float=&#34;left&#34;&gt; &lt;a href=&#34;https://www.kali.org/&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/5151193/99304058-1cef5700-280f-11eb-8642-1f9553808d2d.png&#34; width=&#34;300&#34; align=&#34;left&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://focal-point.com/services/penetration-testing/&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/5151193/182207768-f53d7e0e-5bd5-40cf-8734-dfa6a40a738e.png&#34; width=&#34;300&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;&lt;/span&gt; Sponsors&lt;/h2&gt; &#xA;&lt;p&gt;If you want to sponsors this project and have the latest updates on CME, latest issues fixed, latest features, please support us on &lt;a href=&#34;https://porchetta.industries/&#34;&gt;https://porchetta.industries/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Official Discord Channel&lt;/h2&gt; &#xA;&lt;p&gt;Come hang out on Discord!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/ycGXUxy&#34;&gt;&lt;img src=&#34;https://discordapp.com/api/guilds/736724457258745996/widget.png?style=banner3&#34; alt=&#34;Porchetta Industries&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Acknowledgments&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;(These are the people who did the hard stuff)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;This project was originally inspired by:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/gojhonny/CredCrack&#34;&gt;CredCrack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pentestgeek/smbexec&#34;&gt;smbexec&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ShawnDEvans/smbmap&#34;&gt;smbmap&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Unintentional contributors:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://github.com/PowerShellEmpire/Empire&#34;&gt;Empire&lt;/a&gt; project&lt;/li&gt; &#xA; &lt;li&gt;@T-S-A&#39;s &lt;a href=&#34;https://github.com/T-S-A/smbspider&#34;&gt;smbspider&lt;/a&gt; script&lt;/li&gt; &#xA; &lt;li&gt;@ConsciousHacker&#39;s partial Python port of Invoke-obfuscation from the &lt;a href=&#34;https://github.com/GreatSCT/GreatSCT&#34;&gt;GreatSCT&lt;/a&gt; project&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Documentation, Tutorials, Examples&lt;/h1&gt; &#xA;&lt;p&gt;See the project&#39;s &lt;a href=&#34;https://mpgn.gitbook.io/crackmapexec/&#34;&gt;wiki&lt;/a&gt; for documentation and usage examples&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;Please see the installation on the &lt;a href=&#34;https://mpgn.gitbook.io/crackmapexec/&#34;&gt;GitBook&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;To do&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;0wn everything&lt;/del&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>m1guelpf/yt-whisper</title>
    <updated>2022-09-27T01:41:31Z</updated>
    <id>tag:github.com,2022-09-27:/m1guelpf/yt-whisper</id>
    <link href="https://github.com/m1guelpf/yt-whisper" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Using OpenAI&#39;s Whisper to automatically generate YouTube subtitles&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Automatic YouTube subtitle generation&lt;/h1&gt; &#xA;&lt;p&gt;This repository uses &lt;code&gt;youtube-dl&lt;/code&gt; and &lt;a href=&#34;https://openai.com/blog/whisper&#34;&gt;OpenAI&#39;s Whisper&lt;/a&gt; to generate subtitle files for any youtube video.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;To get started, you&#39;ll need Python 3.7 or newer. Install the binary by running the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip install git+https://github.com/m1guelpf/yt-whisper.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll also need to install &lt;a href=&#34;https://ffmpeg.org/&#34;&gt;&lt;code&gt;ffmpeg&lt;/code&gt;&lt;/a&gt;, which is available from most package managers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# on Ubuntu or Debian&#xA;sudo apt update &amp;amp;&amp;amp; sudo apt install ffmpeg&#xA;&#xA;# on MacOS using Homebrew (https://brew.sh/)&#xA;brew install ffmpeg&#xA;&#xA;# on Windows using Chocolatey (https://chocolatey.org/)&#xA;choco install ffmpeg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The following command will generate a VTT file from the specified YouTube video&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;yt_whisper https://www.youtube.com/watch?v=dQw4w9WgXcQ&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default setting (which selects the &lt;code&gt;small&lt;/code&gt; model) works well for transcribing English. You can optionally use a bigger model for better results (especially with other languages). The available models are &lt;code&gt;tiny&lt;/code&gt;, &lt;code&gt;tiny.en&lt;/code&gt;, &lt;code&gt;base&lt;/code&gt;, &lt;code&gt;base.en&lt;/code&gt;, &lt;code&gt;small&lt;/code&gt;, &lt;code&gt;small.en&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, &lt;code&gt;medium.en&lt;/code&gt;, &lt;code&gt;large&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;yt_whisper https://www.youtube.com/watch?v=dQw4w9WgXcQ --model medium&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Adding &lt;code&gt;--task translate&lt;/code&gt; will translate the subtitles into English:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;yt_whisper https://www.youtube.com/watch?v=dQw4w9WgXcQ --task translate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the following to view all available options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;yt_whisper --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This script is open-source and licensed under the MIT License. For more details, check the &lt;a href=&#34;https://raw.githubusercontent.com/m1guelpf/yt-whisper/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file.&lt;/p&gt;</summary>
  </entry>
</feed>