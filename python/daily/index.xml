<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Python Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-09T01:36:31Z</updated>
  <subtitle>Daily Trending of Python in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>langchain-ai/langmem</title>
    <updated>2025-06-09T01:36:31Z</updated>
    <id>tag:github.com,2025-06-09:/langchain-ai/langmem</id>
    <link href="https://github.com/langchain-ai/langmem" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LangMem&lt;/h1&gt; &#xA;&lt;p&gt;LangMem helps agents learn and adapt from their interactions over time.&lt;/p&gt; &#xA;&lt;p&gt;It provides tooling to extract important information from conversations, optimize agent behavior through prompt refinement, and maintain long-term memory.&lt;/p&gt; &#xA;&lt;p&gt;It offers both functional primitives you can use with any storage system and native integration with LangGraph&#39;s storage layer.&lt;/p&gt; &#xA;&lt;p&gt;This lets your agents continuously improve, personalize their responses, and maintain consistent behavior across sessions.&lt;/p&gt; &#xA;&lt;h2&gt;Key features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üß© &lt;strong&gt;Core memory API&lt;/strong&gt; that works with any storage system&lt;/li&gt; &#xA; &lt;li&gt;üß† &lt;strong&gt;Memory management tools&lt;/strong&gt; that agents can use to record and search information during active conversations &#34;in the hot path&#34;&lt;/li&gt; &#xA; &lt;li&gt;‚öôÔ∏è &lt;strong&gt;Background memory manager&lt;/strong&gt; that automatically extracts, consolidates, and updates agent knowledge&lt;/li&gt; &#xA; &lt;li&gt;‚ö° &lt;strong&gt;Native integration with LangGraph&#39;s Long-term Memory Store&lt;/strong&gt;, available by default in all LangGraph Platform deployments&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install -U langmem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configure your environment with an API key for your favorite LLM provider:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export ANTHROPIC_API_KEY=&#34;sk-...&#34;  # Or another supported LLM provider&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Creating an Agent&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s how to create an agent that actively manages its own long-term memory in just a few lines:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Import core components (1)&#xA;from langgraph.prebuilt import create_react_agent&#xA;from langgraph.store.memory import InMemoryStore&#xA;from langmem import create_manage_memory_tool, create_search_memory_tool&#xA;&#xA;# Set up storage (2)&#xA;store = InMemoryStore(&#xA;    index={&#xA;        &#34;dims&#34;: 1536,&#xA;        &#34;embed&#34;: &#34;openai:text-embedding-3-small&#34;,&#xA;    }&#xA;) &#xA;&#xA;# Create an agent with memory capabilities (3)&#xA;agent = create_react_agent(&#xA;    &#34;anthropic:claude-3-5-sonnet-latest&#34;,&#xA;    tools=[&#xA;        # Memory tools use LangGraph&#39;s BaseStore for persistence (4)&#xA;        create_manage_memory_tool(namespace=(&#34;memories&#34;,)),&#xA;        create_search_memory_tool(namespace=(&#34;memories&#34;,)),&#xA;    ],&#xA;    store=store,&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;The memory tools work in any LangGraph app. Here we use &lt;a href=&#34;https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.create_react_agent&#34;&gt;&lt;code&gt;create_react_agent&lt;/code&gt;&lt;/a&gt; to run an LLM with tools, but you can add these tools to your existing agents or build &lt;a href=&#34;https://raw.githubusercontent.com/langchain-ai/langmem/main/concepts/conceptual_guide.md#functional-core&#34;&gt;custom memory systems&lt;/a&gt; without agents.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://langchain-ai.github.io/langgraph/reference/store/#langgraph.store.memory.InMemoryStore&#34;&gt;&lt;code&gt;InMemoryStore&lt;/code&gt;&lt;/a&gt; keeps memories in process memory‚Äîthey&#39;ll be lost on restart. For production, use the &lt;a href=&#34;https://langchain-ai.github.io/langgraph/reference/store/#langgraph.store.postgres.AsyncPostgresStore&#34;&gt;AsyncPostgresStore&lt;/a&gt; or a similar DB-backed store to persist memories across server restarts.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The memory tools (&lt;a href=&#34;https://raw.githubusercontent.com/langchain-ai/langmem/main/reference/tools.md#langmem.create_manage_memory_tool&#34;&gt;&lt;code&gt;create_manage_memory_tool&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/langchain-ai/langmem/main/reference/tools.md#langmem.create_search_memory_tool&#34;&gt;&lt;code&gt;create_search_memory_tool&lt;/code&gt;&lt;/a&gt;) let you control what gets stored. The agent extracts key information from conversations, maintains memory consistency, and knows when to search past interactions. See &lt;a href=&#34;https://raw.githubusercontent.com/langchain-ai/langmem/main/guides/memory_tools.md&#34;&gt;Memory Tools&lt;/a&gt; for configuration options.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Then use the agent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Store a new memory (1)&#xA;agent.invoke(&#xA;    {&#34;messages&#34;: [{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Remember that I prefer dark mode.&#34;}]}&#xA;)&#xA;&#xA;# Retrieve the stored memory (2)&#xA;response = agent.invoke(&#xA;    {&#34;messages&#34;: [{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;What are my lighting preferences?&#34;}]}&#xA;)&#xA;print(response[&#34;messages&#34;][-1].content)&#xA;# Output: &#34;You&#39;ve told me that you prefer dark mode.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;The agent gets to decide what and when to store the memory. No special commands needed‚Äîjust chat normally and the agent uses &lt;a href=&#34;https://raw.githubusercontent.com/langchain-ai/langmem/main/reference/tools.md#langmem.create_manage_memory_tool&#34;&gt;&lt;code&gt;create_manage_memory_tool&lt;/code&gt;&lt;/a&gt; to store relevant details.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The agent maintains context between chats. When you ask about previous interactions, the LLM can invoke &lt;a href=&#34;https://raw.githubusercontent.com/langchain-ai/langmem/main/reference/tools.md#langmem.create_search_memory_tool&#34;&gt;&lt;code&gt;create_search_memory_tool&lt;/code&gt;&lt;/a&gt; to search for memories with similar content. See &lt;a href=&#34;https://raw.githubusercontent.com/langchain-ai/langmem/main/guides/memory_tools.md&#34;&gt;Memory Tools&lt;/a&gt; to customize memory storage and retrieval, and see the &lt;a href=&#34;https://langchain-ai.github.io/langmem/hot_path_quickstart&#34;&gt;hot path quickstart&lt;/a&gt; for a more complete example on how to include memories without the agent having to expliictly search.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The agent can now store important information from conversations, search its memory when relevant, and persist knowledge across conversations.&lt;/p&gt; &#xA;&lt;h2&gt;Next Steps&lt;/h2&gt; &#xA;&lt;p&gt;For more examples and detailed documentation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://langchain-ai.github.io/langmem/hot_path_quickstart&#34;&gt;Hot Path Quickstart&lt;/a&gt; - Learn how to let your LangGraph agent manage its own memory &#34;in the hot path&#34;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://langchain-ai.github.io/langmem/background_quickstart&#34;&gt;Background Quickstart&lt;/a&gt; - Learn how to use a memory manager &#34;in the background&#34;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://langchain-ai.github.io/langmem/concepts/conceptual_guide&#34;&gt;Core Concepts&lt;/a&gt; - Learn key ideas&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://langchain-ai.github.io/langmem/reference&#34;&gt;API Reference&lt;/a&gt; - Full function documentation&lt;/li&gt; &#xA; &lt;li&gt;Build RSI üôÇ&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>r-three/common-pile</title>
    <updated>2025-06-09T01:36:31Z</updated>
    <id>tag:github.com,2025-06-09:/r-three/common-pile</id>
    <link href="https://github.com/r-three/common-pile" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Code for collecting, processing, and preparing datasets for the Common Pile&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Common Pile&lt;/h1&gt; &#xA;&lt;p&gt;This repository tracks the code used to collect, process, and prepare the datasets for the Common Pile. The code used for the preparation of each source in the Common Pile can be found in the &lt;code&gt;sources/&lt;/code&gt; subdirectory. Source-agnostic utility code and scripts are provided in the &lt;code&gt;common_pile&lt;/code&gt; package. If you are looking for the data itself or our trained models, please see &lt;a href=&#34;https://huggingface.co/common-pile/&#34;&gt;our Hugging Face organization&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;The majority of packages required for dataset creation can be installed with &lt;code&gt;pip install -r requirements.txt&lt;/code&gt;. To make use of the shared functionality in the &lt;code&gt;common_pile&lt;/code&gt; pckage, run &lt;code&gt;pip install -e .&lt;/code&gt;. If you are on a system that doesn&#39;t support automatic installation of pandoc with &lt;code&gt;pypandoc_binary&lt;/code&gt;, change it to &lt;code&gt;pypandoc&lt;/code&gt; in the &lt;code&gt;requirements.txt&lt;/code&gt; and and install pandoc manually.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;d like to contribute a new source to the Common Pile, please &lt;a href=&#34;https://github.com/r-three/common-pile/issues/new&#34;&gt;start an issue&lt;/a&gt; to share details of the source. Generally, we expect each source to include code that 1) downloads the data, 2) processes it appropriately to retain primarily plain text, and 3) write out the results in the Dolma format (gzipped jsonl). You can find utilities to help with each of these steps in the &lt;code&gt;common_pile&lt;/code&gt; library. Alternatively, you can look at our existing sources for ideas as to how to prepare a source. We use git pre-commit hooks to format code and keep style consistent. You can install the pre-commit libraries with &lt;code&gt;pip install pre-commit&lt;/code&gt; and insert the pre-commit hooks with &lt;code&gt;pre-commit install&lt;/code&gt; from the repository root.&lt;/p&gt; &#xA;&lt;h2&gt;Tips&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/r-three/common-pile/tree/main/common_pile/scripts&#34;&gt;scripts subdirectory&lt;/a&gt; has various scripts that can be helpful for inspecting or computing statistics over data. Alternatively, the Dolma-formatted files can be inspected with &lt;a href=&#34;https://jqlang.org/&#34;&gt;&lt;code&gt;jq&lt;/code&gt;&lt;/a&gt; by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cat ${file}.jsonl.gz | gunzip | jq -s ${commmand}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>