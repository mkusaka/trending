<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Python Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-18T01:30:46Z</updated>
  <subtitle>Daily Trending of Python in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>THUDM/CogView2</title>
    <updated>2022-06-18T01:30:46Z</updated>
    <id>tag:github.com,2022-06-18:/THUDM/CogView2</id>
    <link href="https://github.com/THUDM/CogView2" rel="alternate"></link>
    <summary type="html">&lt;p&gt;official code repo for paper &#34;CogView2: Faster and Better Text-to-Image Generation via Hierarchical Transformers&#34;&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/THUDM/CogView2/main/assets/logo2.png&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;b&gt;Generate vivid Images for &lt;i&gt;Any&lt;/i&gt; (Chinese / English) text&lt;/b&gt; &lt;/p&gt; &#xA;&lt;p&gt;CogView2 is a hierarchical transformer (6B-9B-9B parameters) for text-to-image generation in general domain. This implementation is based on the &lt;a href=&#34;https://github.com/THUDM/SwissArmyTransformer&#34;&gt;SwissArmyTransformer&lt;/a&gt; library (v0.2).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Read&lt;/strong&gt; our paper &lt;a href=&#34;https://arxiv.org/abs/2204.14217&#34;&gt;CogView2: Faster and Better Text-to-Image Generation via Hierarchical Transformers&lt;/a&gt; on ArXiv for a formal introduction. The &lt;em&gt;LoPAR&lt;/em&gt; accelarate the generation and &lt;em&gt;CogLM&lt;/em&gt; enables the model for bidirectional completion.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Run&lt;/strong&gt; our pretrained models from text-to-image generation or text-guided completion! Please use A100 GPU.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Cite&lt;/strong&gt; our paper if you find our work is helpful~&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;@article{ding2022cogview2,&#xA;  title={CogView2: Faster and Better Text-to-Image Generation via Hierarchical Transformers},&#xA;  author={Ding, Ming and Zheng, Wendi and Hong, Wenyi and Tang, Jie},&#xA;  journal={arXiv preprint arXiv:2204.14217},&#xA;  year={2022}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Web Demo&lt;/h2&gt; &#xA;&lt;p&gt;Thank the Replicate team to deploy a web demo! Try at &lt;a href=&#34;https://replicate.com/thudm/cogview2&#34;&gt;&lt;img src=&#34;https://replicate.com/thudm/cogview2/badge&#34; alt=&#34;Replicate&#34;&gt;&lt;/a&gt; .&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Setup&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Hardware: Linux servers with Nvidia A100s are recommended, but it is also okay to run the pretrained models with smaller &lt;code&gt;--max-inference-batch-size&lt;/code&gt; or training smaller models on less powerful GPUs.&lt;/li&gt; &#xA; &lt;li&gt;Environment: install dependencies via &lt;code&gt;pip install -r requirements.txt&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;LocalAttention: Make sure you have CUDA installed and compile the local attention kernel.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/Sleepychord/Image-Local-Attention&#xA;cd Image-Local-Attention &amp;amp;&amp;amp; python setup.py install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t install this kernel, you can also run the first stage (20*20 tokens) via &lt;code&gt;--only-first-stage&lt;/code&gt; for text-to-image generation.&lt;/p&gt; &#xA;&lt;h3&gt;Download&lt;/h3&gt; &#xA;&lt;p&gt;Our code will automatically download or detect the models into the path defined by envrionment variable &lt;code&gt;SAT_HOME&lt;/code&gt;. You can download from &lt;a href=&#34;https://model.baai.ac.cn/model-detail/100041&#34;&gt;here&lt;/a&gt; and place them (folders named &lt;code&gt;coglm&lt;/code&gt;/&lt;code&gt;cogview2-dsr&lt;/code&gt;/&lt;code&gt;cogview2-itersr&lt;/code&gt;) under &lt;code&gt;SAT_HOME&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Text-to-Image Generation&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;./script/text2image.sh --input-source input.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Arguments useful in inference are mainly:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--input-source [path or &#34;interactive&#34;]&lt;/code&gt;. The path of the input file, can also be &#34;interactive&#34;, which will launch a CLI.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--output-path [path]&lt;/code&gt;. The folder containing the results.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--batch-size [int]&lt;/code&gt;. The number of samples will be generated per query.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--max-inference-batch-size [int]&lt;/code&gt;. Maximum batch size per forward. Reduce it if OOM.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--debug&lt;/code&gt;. Only save concatenated images for all generated samples, and name them by input text and date.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--with-id&lt;/code&gt;. When it toggled, you must specify an &#34;id&#34; before each input, e.g. &lt;code&gt;001\t一个漂亮的女孩&lt;/code&gt;, \t denoting TAB (&lt;strong&gt;NOT space&lt;/strong&gt;). It will generate &lt;code&gt;batch-size&lt;/code&gt; split images in a folder named &#34;id&#34; for each input. Confict with &lt;code&gt;--debug&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--device [int]&lt;/code&gt;. Running on which GPU.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--inverse-prompt&lt;/code&gt;. Use the perplexity to generate the original text to sort the generated images.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--only-first-stage&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--style&lt;/code&gt;. The style of the generated images, choices=[&#39;none&#39;, &#39;mainbody&#39;, &#39;photo&#39;, &#39;flat&#39;, &#39;comics&#39;, &#39;oil&#39;, &#39;sketch&#39;, &#39;isometric&#39;, &#39;chinese&#39;, &#39;watercolor&#39;]. The default style is &lt;code&gt;mainbody&lt;/code&gt;, usually an isolated object with white background.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You&#39;d better specify a environment variable &lt;code&gt;SAT_HOME&lt;/code&gt; to specify the path to store the downloaded model.&lt;/p&gt; &#xA;&lt;p&gt;Chinese input is usually much better than English input.&lt;/p&gt; &#xA;&lt;h3&gt;Text-guided Completion&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;./script/text_guided_completion.sh --input-source input_comp.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The format of input is &lt;code&gt;text image_path h0 w0 h1 w1&lt;/code&gt;, where all the separation are &lt;strong&gt;TAB&lt;/strong&gt; (&lt;strong&gt;NOT space&lt;/strong&gt;). The image at &lt;code&gt;image_path&lt;/code&gt; will be center-cropped to &lt;code&gt;480*480&lt;/code&gt; pixels and mask the square from &lt;code&gt;(h0,w0)&lt;/code&gt;to &lt;code&gt;(h1,w1)&lt;/code&gt;. These coordinations are range from 0 to 1. The model will fill the square with object described in &lt;code&gt;text&lt;/code&gt;. Please use a square much &lt;strong&gt;larger than the desired region&lt;/strong&gt;.&lt;br&gt; &lt;img width=&#34;741&#34; alt=&#34;comp_pipeline&#34; src=&#34;https://user-images.githubusercontent.com/9153807/174002452-3670850f-b234-4515-8ac8-2971de26f78a.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Gallery&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/THUDM/CogView2/files/8553662/big.1.pdf&#34; alt=&#34;more_samples&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>PaddlePaddle/PaddleClas</title>
    <updated>2022-06-18T01:30:46Z</updated>
    <id>tag:github.com,2022-06-18:/PaddlePaddle/PaddleClas</id>
    <link href="https://github.com/PaddlePaddle/PaddleClas" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A treasure chest for visual recognition powered by PaddlePaddle&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/README_ch.md&#34;&gt;简体中文&lt;/a&gt; | English&lt;/p&gt; &#xA;&lt;h1&gt;PaddleClas&lt;/h1&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;PaddleClas is an image classification and image recognition toolset for industry and academia, helping users train better computer vision models and apply them in real scenarios.&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/images/class_simple_en.gif&#34; width=&#34;600&#34;&gt; &#xA; &lt;p&gt;PULC demo images&lt;/p&gt; &#xA;&lt;/div&gt; &amp;nbsp; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/images/recognition.gif&#34; width=&#34;400&#34;&gt; &#xA; &lt;p&gt;PP-ShiTu demo images&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;&lt;strong&gt;Recent updates&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;2022.6.15 Release &lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_quickstart_en.md&#34;&gt;&lt;strong&gt;P&lt;/strong&gt;ractical &lt;strong&gt;U&lt;/strong&gt;ltra &lt;strong&gt;L&lt;/strong&gt;ight-weight image &lt;strong&gt;C&lt;/strong&gt;lassification solutions&lt;/a&gt;. PULC models inference within 3ms on CPU devices, with accuracy on par with SwinTransformer. We also release 9 practical classification models covering pedestrian, vehicle and OCR scenario.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;2022.4.21 Added the related &lt;a href=&#34;https://github.com/PaddlePaddle/PaddleClas/pull/1820/files&#34;&gt;code&lt;/a&gt; of the CVPR2022 oral paper &lt;a href=&#34;https://arxiv.org/pdf/2204.02557.pdf&#34;&gt;MixFormer&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;2021.09.17 Add PP-LCNet series model developed by PaddleClas, these models show strong competitiveness on Intel CPUs. For the introduction of PP-LCNet, please refer to &lt;a href=&#34;https://arxiv.org/pdf/2109.15099.pdf&#34;&gt;paper&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/models/PP-LCNet_en.md&#34;&gt;PP-LCNet model introduction&lt;/a&gt;. The metrics and pretrained model are available &lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/algorithm_introduction/ImageNet_models_en.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;2021.06.29 Add &lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/models/SwinTransformer_en.md&#34;&gt;Swin-transformer&lt;/a&gt;) series model，Highest top1 acc on ImageNet1k dataset reaches 87.2%, training, evaluation and inference are all supported. Pretrained models can be downloaded &lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/algorithm_introduction/ImageNet_models_en.md#16&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;2021.06.16 PaddleClas release/2.2. Add metric learning and vector search modules. Add product recognition, animation character recognition, vehicle recognition and logo recognition. Added 30 pretrained models of LeViT, Twins, TNT, DLA, HarDNet, and RedNet, and the accuracy is roughly the same as that of the paper.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/others/update_history_en.md&#34;&gt;more&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;PaddleClas release PP-HGNet、PP-LCNetv2、 PP-LCNet and &lt;strong&gt;S&lt;/strong&gt;imple &lt;strong&gt;S&lt;/strong&gt;emi-supervised &lt;strong&gt;L&lt;/strong&gt;abel &lt;strong&gt;D&lt;/strong&gt;istillation algorithms, and support plenty of image classification and image recognition algorithms. Based on th algorithms above, PaddleClas release PP-ShiTu image recognition system and &lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_quickstart_en.md&#34;&gt;&lt;strong&gt;P&lt;/strong&gt;ractical &lt;strong&gt;U&lt;/strong&gt;ltra &lt;strong&gt;L&lt;/strong&gt;ight-weight image &lt;strong&gt;C&lt;/strong&gt;lassification solutions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/19523330/173539361-68cf7ab1-7e3b-4e5e-b00f-1500719bd2a2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Welcome to Join the Technical Exchange Group&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can also scan the QR code below to join the PaddleClas QQ group and WeChat group (add and replay &#34;C&#34;) to get more efficient answers to your questions and to communicate with developers from all walks of life. We look forward to hearing from you.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://user-images.githubusercontent.com/80816848/164383225-e375eb86-716e-41b4-a9e0-4b8a3976c1aa.jpg&#34; width=&#34;200&#34;&gt; &#xA; &lt;img src=&#34;https://user-images.githubusercontent.com/48054808/160531099-9811bbe6-cfbb-47d5-8bdb-c2b40684d7dd.png&#34; width=&#34;200&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;Quick experience of PP-ShiTu image recognition system：&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/quick_start/quick_start_recognition_en.md&#34;&gt;Link&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Quick experience of &lt;strong&gt;P&lt;/strong&gt;ractical &lt;strong&gt;U&lt;/strong&gt;ltra &lt;strong&gt;L&lt;/strong&gt;ight-weight image &lt;strong&gt;C&lt;/strong&gt;lassification models：&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_quickstart_en.md&#34;&gt;Link&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Tutorials&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/installation/install_paddle_en.md&#34;&gt;Install Paddle&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/installation/install_paddleclas_en.md&#34;&gt;Install PaddleClas Environment&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_train_en.md&#34;&gt;Practical Ultra Light-weight image Classification solutions&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_quickstart_en.md&#34;&gt;PULC Quick Start&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_model_list_en.md&#34;&gt;PULC Model Zoo&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_person_exists_en.md&#34;&gt;PULC Classification Model of Someone or Nobody&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_person_attribute_en.md&#34;&gt;PULC Recognition Model of Person Attribute&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_safety_helmet_en.md&#34;&gt;PULC Classification Model of Wearing or Unwearing Safety Helmet&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_traffic_sign_en.md&#34;&gt;PULC Classification Model of Traffic Sign&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_vehicle_attribute_en.md&#34;&gt;PULC Recognition Model of Vehicle Attribute&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_car_exists_en.md&#34;&gt;PULC Classification Model of Containing or Uncontaining Car&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_text_image_orientation_en.md&#34;&gt;PULC Classification Model of Text Image Orientation&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_textline_orientation_en.md&#34;&gt;PULC Classification Model of Textline Orientation&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/PULC/PULC_language_classification_en.md&#34;&gt;PULC Classification Model of Language&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/quick_start/quick_start_recognition_en.md&#34;&gt;Quick Start of Recognition&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/#Introduction_to_Image_Recognition_Systems&#34;&gt;Introduction to Image Recognition Systems&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/#Rec_Demo_images&#34;&gt;Image Recognition Demo images&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/#Clas_Demo_images&#34;&gt;PULC demo images&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Algorithms Introduction &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/algorithm_introduction/ImageNet_models_en.md&#34;&gt;Backbone Network and Pre-trained Model Library&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/image_recognition_pipeline/mainbody_detection_en.md&#34;&gt;Mainbody Detection&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/image_recognition_pipeline/feature_extraction_en.md&#34;&gt;Feature Learning&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/deploy/vector_search/README.md&#34;&gt;Vector Search&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Inference Model Prediction &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/inference_deployment/python_deploy_en.md&#34;&gt;Python Inference&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/deploy/cpp/readme_en.md&#34;&gt;C++ Classfication Inference&lt;/a&gt;， &lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/deploy/cpp_shitu/readme_en.md&#34;&gt;C++ PP-ShiTu Inference&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Model Deploy (only support classification for now, recognition coming soon) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/deploy/hubserving/readme_en.md&#34;&gt;Hub Serving Deployment&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/deploy/lite/readme_en.md&#34;&gt;Mobile Deployment&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/inference_deployment/whl_deploy_en.md&#34;&gt;Inference Using whl&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Advanced Tutorial &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/advanced_tutorials/distillation/distillation_en.md&#34;&gt;Knowledge Distillation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/algorithm_introduction/model_prune_quantization_en.md&#34;&gt;Model Quantization&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/en/advanced_tutorials/DataAugmentation_en.md&#34;&gt;Data Augmentation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/#License&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/#Contribution&#34;&gt;Contribution&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;Introduction_to_PULC&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction to Practical Ultra Light-weight image Classification solutions&lt;/h2&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://user-images.githubusercontent.com/19523330/173011854-b10fcd7a-b799-4dfd-a1cf-9504952a3c44.png&#34; width=&#34;800&#34;&gt; &#xA;&lt;/div&gt; PULC solutions consists of PP-LCNet light-weight backbone, SSLD pretrained models, Ensemble of Data Augmentation strategy and SKL-UGI knowledge distillation. PULC models inference within 3ms on CPU devices, with accuracy comparable with SwinTransformer. We also release 9 practical models covering pedestrian, vehicle and OCR. &#xA;&lt;p&gt;&lt;a name=&#34;Introduction_to_Image_Recognition_Systems&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction to Image Recognition Systems&lt;/h2&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/images/structure.jpg&#34; width=&#34;800&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;Image recognition can be divided into three steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;（1）Identify region proposal for target objects through a detection model；&lt;/li&gt; &#xA; &lt;li&gt;（2）Extract features for each region proposal;&lt;/li&gt; &#xA; &lt;li&gt;（3）Search features in the retrieval database and output results;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For a new unknown category, there is no need to retrain the model, just prepare images of new category, extract features and update retrieval database and the category can be recognised.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;Clas_Demo_images&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;PULC demo images&lt;/h2&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/PaddlePaddle/PaddleClas/develop/docs/images/classification_en.gif&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;&lt;a name=&#34;Rec_Demo_images&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Image Recognition Demo images &lt;a href=&#34;https://github.com/PaddlePaddle/PaddleClas/tree/release/2.2/docs/images/recognition/more_demo_images&#34;&gt;more&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Product recognition&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://user-images.githubusercontent.com/18028216/122769644-51604f80-d2d7-11eb-8290-c53b12a5c1f6.gif&#34; width=&#34;400&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Cartoon character recognition&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://user-images.githubusercontent.com/18028216/122769746-6b019700-d2d7-11eb-86df-f1d710999ba6.gif&#34; width=&#34;400&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Logo recognition&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://user-images.githubusercontent.com/18028216/122769837-7fde2a80-d2d7-11eb-9b69-04140e9d785f.gif&#34; width=&#34;400&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Car recognition&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://user-images.githubusercontent.com/18028216/122769916-8ec4dd00-d2d7-11eb-8c60-42d89e25030c.gif&#34; width=&#34;400&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;&lt;a name=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;PaddleClas is released under the Apache 2.0 license &lt;a href=&#34;https://github.com/PaddlePaddle/PaddleCLS/raw/master/LICENSE&#34;&gt;Apache 2.0 license&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;Contribution&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contribution&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are highly welcomed and we would really appreciate your feedback!!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Thank &lt;a href=&#34;https://github.com/nblib&#34;&gt;nblib&lt;/a&gt; to fix bug of RandErasing.&lt;/li&gt; &#xA; &lt;li&gt;Thank &lt;a href=&#34;https://github.com/chenpy228&#34;&gt;chenpy228&lt;/a&gt; to fix some typos PaddleClas.&lt;/li&gt; &#xA; &lt;li&gt;Thank &lt;a href=&#34;https://github.com/jm12138&#34;&gt;jm12138&lt;/a&gt; to add ViT, DeiT models and RepVGG models into PaddleClas.&lt;/li&gt; &#xA; &lt;li&gt;Thank &lt;a href=&#34;https://aistudio.baidu.com/aistudio/personalcenter/thirdview/76563&#34;&gt;FutureSI&lt;/a&gt; to parse and summarize the PaddleClas code.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>google/jax</title>
    <updated>2022-06-18T01:30:46Z</updated>
    <id>tag:github.com,2022-06-18:/google/jax</id>
    <link href="https://github.com/google/jax" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Composable transformations of Python+NumPy programs: differentiate, vectorize, JIT to GPU/TPU, and more&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/google/jax/main/images/jax_logo_250px.png&#34; alt=&#34;logo&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h1&gt;JAX: Autograd and XLA&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/google/jax/workflows/Continuous%20integration/badge.svg?sanitize=true&#34; alt=&#34;Continuous integration&#34;&gt; &lt;img src=&#34;https://img.shields.io/pypi/v/jax&#34; alt=&#34;PyPI version&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#quickstart-colab-in-the-cloud&#34;&gt;&lt;strong&gt;Quickstart&lt;/strong&gt;&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#transformations&#34;&gt;&lt;strong&gt;Transformations&lt;/strong&gt;&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#installation&#34;&gt;&lt;strong&gt;Install guide&lt;/strong&gt;&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#neural-network-libraries&#34;&gt;&lt;strong&gt;Neural net libraries&lt;/strong&gt;&lt;/a&gt; | &lt;a href=&#34;https://jax.readthedocs.io/en/latest/changelog.html&#34;&gt;&lt;strong&gt;Change logs&lt;/strong&gt;&lt;/a&gt; | &lt;a href=&#34;https://jax.readthedocs.io/en/latest/&#34;&gt;&lt;strong&gt;Reference docs&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is JAX?&lt;/h2&gt; &#xA;&lt;p&gt;JAX is &lt;a href=&#34;https://github.com/hips/autograd&#34;&gt;Autograd&lt;/a&gt; and &lt;a href=&#34;https://www.tensorflow.org/xla&#34;&gt;XLA&lt;/a&gt;, brought together for high-performance machine learning research.&lt;/p&gt; &#xA;&lt;p&gt;With its updated version of &lt;a href=&#34;https://github.com/hips/autograd&#34;&gt;Autograd&lt;/a&gt;, JAX can automatically differentiate native Python and NumPy functions. It can differentiate through loops, branches, recursion, and closures, and it can take derivatives of derivatives of derivatives. It supports reverse-mode differentiation (a.k.a. backpropagation) via &lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#automatic-differentiation-with-grad&#34;&gt;&lt;code&gt;grad&lt;/code&gt;&lt;/a&gt; as well as forward-mode differentiation, and the two can be composed arbitrarily to any order.&lt;/p&gt; &#xA;&lt;p&gt;What’s new is that JAX uses &lt;a href=&#34;https://www.tensorflow.org/xla&#34;&gt;XLA&lt;/a&gt; to compile and run your NumPy programs on GPUs and TPUs. Compilation happens under the hood by default, with library calls getting just-in-time compiled and executed. But JAX also lets you just-in-time compile your own Python functions into XLA-optimized kernels using a one-function API, &lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#compilation-with-jit&#34;&gt;&lt;code&gt;jit&lt;/code&gt;&lt;/a&gt;. Compilation and automatic differentiation can be composed arbitrarily, so you can express sophisticated algorithms and get maximal performance without leaving Python. You can even program multiple GPUs or TPU cores at once using &lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#spmd-programming-with-pmap&#34;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt;, and differentiate through the whole thing.&lt;/p&gt; &#xA;&lt;p&gt;Dig a little deeper, and you&#39;ll see that JAX is really an extensible system for &lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#transformations&#34;&gt;composable function transformations&lt;/a&gt;. Both &lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#automatic-differentiation-with-grad&#34;&gt;&lt;code&gt;grad&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#compilation-with-jit&#34;&gt;&lt;code&gt;jit&lt;/code&gt;&lt;/a&gt; are instances of such transformations. Others are &lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#auto-vectorization-with-vmap&#34;&gt;&lt;code&gt;vmap&lt;/code&gt;&lt;/a&gt; for automatic vectorization and &lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#spmd-programming-with-pmap&#34;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; for single-program multiple-data (SPMD) parallel programming of multiple accelerators, with more to come.&lt;/p&gt; &#xA;&lt;p&gt;This is a research project, not an official Google product. Expect bugs and &lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html&#34;&gt;sharp edges&lt;/a&gt;. Please help by trying it out, &lt;a href=&#34;https://github.com/google/jax/issues&#34;&gt;reporting bugs&lt;/a&gt;, and letting us know what you think!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import jax.numpy as jnp&#xA;from jax import grad, jit, vmap&#xA;&#xA;def predict(params, inputs):&#xA;  for W, b in params:&#xA;    outputs = jnp.dot(inputs, W) + b&#xA;    inputs = jnp.tanh(outputs)  # inputs to the next layer&#xA;  return outputs                # no activation on last layer&#xA;&#xA;def loss(params, inputs, targets):&#xA;  preds = predict(params, inputs)&#xA;  return jnp.sum((preds - targets)**2)&#xA;&#xA;grad_loss = jit(grad(loss))  # compiled gradient evaluation function&#xA;perex_grads = jit(vmap(grad_loss, in_axes=(None, 0, 0)))  # fast per-example grads&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Contents&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#quickstart-colab-in-the-cloud&#34;&gt;Quickstart: Colab in the Cloud&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#transformations&#34;&gt;Transformations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#current-gotchas&#34;&gt;Current gotchas&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#neural-network-libraries&#34;&gt;Neural net libraries&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#citing-jax&#34;&gt;Citing JAX&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/#reference-documentation&#34;&gt;Reference documentation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quickstart: Colab in the Cloud&lt;/h2&gt; &#xA;&lt;p&gt;Jump right in using a notebook in your browser, connected to a Google Cloud GPU. Here are some starter notebooks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/quickstart.html&#34;&gt;The basics: NumPy on accelerators, &lt;code&gt;grad&lt;/code&gt; for differentiation, &lt;code&gt;jit&lt;/code&gt; for compilation, and &lt;code&gt;vmap&lt;/code&gt; for vectorization&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://colab.research.google.com/github/google/jax/blob/main/docs/notebooks/neural_network_with_tfds_data.ipynb&#34;&gt;Training a Simple Neural Network, with TensorFlow Dataset Data Loading&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;JAX now runs on Cloud TPUs.&lt;/strong&gt; To try out the preview, see the &lt;a href=&#34;https://github.com/google/jax/tree/main/cloud_tpu_colabs&#34;&gt;Cloud TPU Colabs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For a deeper dive into JAX:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html&#34;&gt;The Autodiff Cookbook, Part 1: easy and powerful automatic differentiation in JAX&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html&#34;&gt;Common gotchas and sharp edges&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;See the &lt;a href=&#34;https://github.com/google/jax/tree/main/docs/notebooks&#34;&gt;full list of notebooks&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can also take a look at &lt;a href=&#34;https://github.com/google/jax/tree/main/jax/example_libraries/README.md&#34;&gt;the mini-libraries in &lt;code&gt;jax.example_libraries&lt;/code&gt;&lt;/a&gt;, like &lt;a href=&#34;https://github.com/google/jax/tree/main/jax/example_libraries/README.md#neural-net-building-with-stax&#34;&gt;&lt;code&gt;stax&lt;/code&gt; for building neural networks&lt;/a&gt; and &lt;a href=&#34;https://github.com/google/jax/tree/main/jax/example_libraries/README.md#first-order-optimization&#34;&gt;&lt;code&gt;optimizers&lt;/code&gt; for first-order stochastic optimization&lt;/a&gt;, or the &lt;a href=&#34;https://github.com/google/jax/tree/main/examples&#34;&gt;examples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Transformations&lt;/h2&gt; &#xA;&lt;p&gt;At its core, JAX is an extensible system for transforming numerical functions. Here are four transformations of primary interest: &lt;code&gt;grad&lt;/code&gt;, &lt;code&gt;jit&lt;/code&gt;, &lt;code&gt;vmap&lt;/code&gt;, and &lt;code&gt;pmap&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Automatic differentiation with &lt;code&gt;grad&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;JAX has roughly the same API as &lt;a href=&#34;https://github.com/hips/autograd&#34;&gt;Autograd&lt;/a&gt;. The most popular function is &lt;a href=&#34;https://jax.readthedocs.io/en/latest/jax.html#jax.grad&#34;&gt;&lt;code&gt;grad&lt;/code&gt;&lt;/a&gt; for reverse-mode gradients:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from jax import grad&#xA;import jax.numpy as jnp&#xA;&#xA;def tanh(x):  # Define a function&#xA;  y = jnp.exp(-2.0 * x)&#xA;  return (1.0 - y) / (1.0 + y)&#xA;&#xA;grad_tanh = grad(tanh)  # Obtain its gradient function&#xA;print(grad_tanh(1.0))   # Evaluate it at x = 1.0&#xA;# prints 0.4199743&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can differentiate to any order with &lt;code&gt;grad&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(grad(grad(grad(tanh)))(1.0))&#xA;# prints 0.62162673&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced autodiff, you can use &lt;a href=&#34;https://jax.readthedocs.io/en/latest/jax.html#jax.vjp&#34;&gt;&lt;code&gt;jax.vjp&lt;/code&gt;&lt;/a&gt; for reverse-mode vector-Jacobian products and &lt;a href=&#34;https://jax.readthedocs.io/en/latest/jax.html#jax.jvp&#34;&gt;&lt;code&gt;jax.jvp&lt;/code&gt;&lt;/a&gt; for forward-mode Jacobian-vector products. The two can be composed arbitrarily with one another, and with other JAX transformations. Here&#39;s one way to compose those to make a function that efficiently computes &lt;a href=&#34;https://jax.readthedocs.io/en/latest/jax.html#jax.hessian&#34;&gt;full Hessian matrices&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from jax import jit, jacfwd, jacrev&#xA;&#xA;def hessian(fun):&#xA;  return jit(jacfwd(jacrev(fun)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with &lt;a href=&#34;https://github.com/hips/autograd&#34;&gt;Autograd&lt;/a&gt;, you&#39;re free to use differentiation with Python control structures:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def abs_val(x):&#xA;  if x &amp;gt; 0:&#xA;    return x&#xA;  else:&#xA;    return -x&#xA;&#xA;abs_val_grad = grad(abs_val)&#xA;print(abs_val_grad(1.0))   # prints 1.0&#xA;print(abs_val_grad(-1.0))  # prints -1.0 (abs_val is re-evaluated)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation&#34;&gt;reference docs on automatic differentiation&lt;/a&gt; and the &lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html&#34;&gt;JAX Autodiff Cookbook&lt;/a&gt; for more.&lt;/p&gt; &#xA;&lt;h3&gt;Compilation with &lt;code&gt;jit&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can use XLA to compile your functions end-to-end with &lt;a href=&#34;https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit&#34;&gt;&lt;code&gt;jit&lt;/code&gt;&lt;/a&gt;, used either as an &lt;code&gt;@jit&lt;/code&gt; decorator or as a higher-order function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import jax.numpy as jnp&#xA;from jax import jit&#xA;&#xA;def slow_f(x):&#xA;  # Element-wise ops see a large benefit from fusion&#xA;  return x * x + x * 2.0&#xA;&#xA;x = jnp.ones((5000, 5000))&#xA;fast_f = jit(slow_f)&#xA;%timeit -n10 -r3 fast_f(x)  # ~ 4.5 ms / loop on Titan X&#xA;%timeit -n10 -r3 slow_f(x)  # ~ 14.5 ms / loop (also on GPU via JAX)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can mix &lt;code&gt;jit&lt;/code&gt; and &lt;code&gt;grad&lt;/code&gt; and any other JAX transformation however you like.&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;code&gt;jit&lt;/code&gt; puts constraints on the kind of Python control flow the function can use; see the &lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#python-control-flow-+-JIT&#34;&gt;Gotchas Notebook&lt;/a&gt; for more.&lt;/p&gt; &#xA;&lt;h3&gt;Auto-vectorization with &lt;code&gt;vmap&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap&#34;&gt;&lt;code&gt;vmap&lt;/code&gt;&lt;/a&gt; is the vectorizing map. It has the familiar semantics of mapping a function along array axes, but instead of keeping the loop on the outside, it pushes the loop down into a function’s primitive operations for better performance.&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;code&gt;vmap&lt;/code&gt; can save you from having to carry around batch dimensions in your code. For example, consider this simple &lt;em&gt;unbatched&lt;/em&gt; neural network prediction function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def predict(params, input_vec):&#xA;  assert input_vec.ndim == 1&#xA;  activations = input_vec&#xA;  for W, b in params:&#xA;    outputs = jnp.dot(W, activations) + b  # `activations` on the right-hand side!&#xA;    activations = jnp.tanh(outputs)        # inputs to the next layer&#xA;  return outputs                           # no activation on last layer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We often instead write &lt;code&gt;jnp.dot(activations, W)&lt;/code&gt; to allow for a batch dimension on the left side of &lt;code&gt;activations&lt;/code&gt;, but we’ve written this particular prediction function to apply only to single input vectors. If we wanted to apply this function to a batch of inputs at once, semantically we could just write&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from functools import partial&#xA;predictions = jnp.stack(list(map(partial(predict, params), input_batch)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But pushing one example through the network at a time would be slow! It’s better to vectorize the computation, so that at every layer we’re doing matrix-matrix multiplication rather than matrix-vector multiplication.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;vmap&lt;/code&gt; function does that transformation for us. That is, if we write&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from jax import vmap&#xA;predictions = vmap(partial(predict, params))(input_batch)&#xA;# or, alternatively&#xA;predictions = vmap(predict, in_axes=(None, 0))(params, input_batch)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then the &lt;code&gt;vmap&lt;/code&gt; function will push the outer loop inside the function, and our machine will end up executing matrix-matrix multiplications exactly as if we’d done the batching by hand.&lt;/p&gt; &#xA;&lt;p&gt;It’s easy enough to manually batch a simple neural network without &lt;code&gt;vmap&lt;/code&gt;, but in other cases manual vectorization can be impractical or impossible. Take the problem of efficiently computing per-example gradients: that is, for a fixed set of parameters, we want to compute the gradient of our loss function evaluated separately at each example in a batch. With &lt;code&gt;vmap&lt;/code&gt;, it’s easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;per_example_gradients = vmap(partial(grad(loss), params))(inputs, targets)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course, &lt;code&gt;vmap&lt;/code&gt; can be arbitrarily composed with &lt;code&gt;jit&lt;/code&gt;, &lt;code&gt;grad&lt;/code&gt;, and any other JAX transformation! We use &lt;code&gt;vmap&lt;/code&gt; with both forward- and reverse-mode automatic differentiation for fast Jacobian and Hessian matrix calculations in &lt;code&gt;jax.jacfwd&lt;/code&gt;, &lt;code&gt;jax.jacrev&lt;/code&gt;, and &lt;code&gt;jax.hessian&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;SPMD programming with &lt;code&gt;pmap&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;For parallel programming of multiple accelerators, like multiple GPUs, use &lt;a href=&#34;https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap&#34;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt;. With &lt;code&gt;pmap&lt;/code&gt; you write single-program multiple-data (SPMD) programs, including fast parallel collective communication operations. Applying &lt;code&gt;pmap&lt;/code&gt; will mean that the function you write is compiled by XLA (similarly to &lt;code&gt;jit&lt;/code&gt;), then replicated and executed in parallel across devices.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example on an 8-GPU machine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from jax import random, pmap&#xA;import jax.numpy as jnp&#xA;&#xA;# Create 8 random 5000 x 6000 matrices, one per GPU&#xA;keys = random.split(random.PRNGKey(0), 8)&#xA;mats = pmap(lambda key: random.normal(key, (5000, 6000)))(keys)&#xA;&#xA;# Run a local matmul on each device in parallel (no data transfer)&#xA;result = pmap(lambda x: jnp.dot(x, x.T))(mats)  # result.shape is (8, 5000, 5000)&#xA;&#xA;# Compute the mean on each device in parallel and print the result&#xA;print(pmap(jnp.mean)(result))&#xA;# prints [1.1566595 1.1805978 ... 1.2321935 1.2015157]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition to expressing pure maps, you can use fast &lt;a href=&#34;https://jax.readthedocs.io/en/latest/jax.lax.html#parallel-operators&#34;&gt;collective communication operations&lt;/a&gt; between devices:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from functools import partial&#xA;from jax import lax&#xA;&#xA;@partial(pmap, axis_name=&#39;i&#39;)&#xA;def normalize(x):&#xA;  return x / lax.psum(x, &#39;i&#39;)&#xA;&#xA;print(normalize(jnp.arange(4.)))&#xA;# prints [0.         0.16666667 0.33333334 0.5       ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can even &lt;a href=&#34;https://colab.research.google.com/github/google/jax/blob/main/cloud_tpu_colabs/Pmap_Cookbook.ipynb#scrollTo=MdRscR5MONuN&#34;&gt;nest &lt;code&gt;pmap&lt;/code&gt; functions&lt;/a&gt; for more sophisticated communication patterns.&lt;/p&gt; &#xA;&lt;p&gt;It all composes, so you&#39;re free to differentiate through parallel computations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from jax import grad&#xA;&#xA;@pmap&#xA;def f(x):&#xA;  y = jnp.sin(x)&#xA;  @pmap&#xA;  def g(z):&#xA;    return jnp.cos(z) * jnp.tan(y.sum()) * jnp.tanh(x).sum()&#xA;  return grad(lambda w: jnp.sum(g(w)))(x)&#xA;&#xA;print(f(x))&#xA;# [[ 0.        , -0.7170853 ],&#xA;#  [-3.1085174 , -0.4824318 ],&#xA;#  [10.366636  , 13.135289  ],&#xA;#  [ 0.22163185, -0.52112055]]&#xA;&#xA;print(grad(lambda x: jnp.sum(f(x)))(x))&#xA;# [[ -3.2369726,  -1.6356447],&#xA;#  [  4.7572474,  11.606951 ],&#xA;#  [-98.524414 ,  42.76499  ],&#xA;#  [ -1.6007166,  -1.2568436]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When reverse-mode differentiating a &lt;code&gt;pmap&lt;/code&gt; function (e.g. with &lt;code&gt;grad&lt;/code&gt;), the backward pass of the computation is parallelized just like the forward pass.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://colab.research.google.com/github/google/jax/blob/main/cloud_tpu_colabs/Pmap_Cookbook.ipynb&#34;&gt;SPMD Cookbook&lt;/a&gt; and the &lt;a href=&#34;https://github.com/google/jax/raw/main/examples/spmd_mnist_classifier_fromscratch.py&#34;&gt;SPMD MNIST classifier from scratch example&lt;/a&gt; for more.&lt;/p&gt; &#xA;&lt;h2&gt;Current gotchas&lt;/h2&gt; &#xA;&lt;p&gt;For a more thorough survey of current gotchas, with examples and explanations, we highly recommend reading the &lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html&#34;&gt;Gotchas Notebook&lt;/a&gt;. Some standouts:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;JAX transformations only work on &lt;a href=&#34;https://en.wikipedia.org/wiki/Pure_function&#34;&gt;pure functions&lt;/a&gt;, which don&#39;t have side-effects and respect &lt;a href=&#34;https://en.wikipedia.org/wiki/Referential_transparency&#34;&gt;referential transparency&lt;/a&gt; (i.e. object identity testing with &lt;code&gt;is&lt;/code&gt; isn&#39;t preserved). If you use a JAX transformation on an impure Python function, you might see an error like &lt;code&gt;Exception: Can&#39;t lift Traced...&lt;/code&gt; or &lt;code&gt;Exception: Different traces at same level&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#in-place-updates&#34;&gt;In-place mutating updates of arrays&lt;/a&gt;, like &lt;code&gt;x[i] += y&lt;/code&gt;, aren&#39;t supported, but &lt;a href=&#34;https://jax.readthedocs.io/en/latest/jax.ops.html&#34;&gt;there are functional alternatives&lt;/a&gt;. Under a &lt;code&gt;jit&lt;/code&gt;, those functional alternatives will reuse buffers in-place automatically.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#random-numbers&#34;&gt;Random numbers are different&lt;/a&gt;, but for &lt;a href=&#34;https://github.com/google/jax/raw/main/docs/design_notes/prng.md&#34;&gt;good reasons&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If you&#39;re looking for &lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/convolutions.html&#34;&gt;convolution operators&lt;/a&gt;, they&#39;re in the &lt;code&gt;jax.lax&lt;/code&gt; package.&lt;/li&gt; &#xA; &lt;li&gt;JAX enforces single-precision (32-bit, e.g. &lt;code&gt;float32&lt;/code&gt;) values by default, and &lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#double-64bit-precision&#34;&gt;to enable double-precision&lt;/a&gt; (64-bit, e.g. &lt;code&gt;float64&lt;/code&gt;) one needs to set the &lt;code&gt;jax_enable_x64&lt;/code&gt; variable at startup (or set the environment variable &lt;code&gt;JAX_ENABLE_X64=True&lt;/code&gt;). On TPU, JAX uses 32-bit values by default for everything &lt;em&gt;except&lt;/em&gt; internal temporary variables in &#39;matmul-like&#39; operations, such as &lt;code&gt;jax.numpy.dot&lt;/code&gt; and &lt;code&gt;lax.conv&lt;/code&gt;. Those ops have a &lt;code&gt;precision&lt;/code&gt; parameter which can be used to simulate true 32-bit, with a cost of possibly slower runtime.&lt;/li&gt; &#xA; &lt;li&gt;Some of NumPy&#39;s dtype promotion semantics involving a mix of Python scalars and NumPy types aren&#39;t preserved, namely &lt;code&gt;np.add(1, np.array([2], np.float32)).dtype&lt;/code&gt; is &lt;code&gt;float64&lt;/code&gt; rather than &lt;code&gt;float32&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Some transformations, like &lt;code&gt;jit&lt;/code&gt;, &lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#control-flow&#34;&gt;constrain how you can use Python control flow&lt;/a&gt;. You&#39;ll always get loud errors if something goes wrong. You might have to use &lt;a href=&#34;https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit&#34;&gt;&lt;code&gt;jit&lt;/code&gt;&#39;s &lt;code&gt;static_argnums&lt;/code&gt; parameter&lt;/a&gt;, &lt;a href=&#34;https://jax.readthedocs.io/en/latest/jax.lax.html#control-flow-operators&#34;&gt;structured control flow primitives&lt;/a&gt; like &lt;a href=&#34;https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.scan.html#jax.lax.scan&#34;&gt;&lt;code&gt;lax.scan&lt;/code&gt;&lt;/a&gt;, or just use &lt;code&gt;jit&lt;/code&gt; on smaller subfunctions.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;JAX is written in pure Python, but it depends on XLA, which needs to be installed as the &lt;code&gt;jaxlib&lt;/code&gt; package. Use the following instructions to install a binary package with &lt;code&gt;pip&lt;/code&gt;, or to build JAX from source.&lt;/p&gt; &#xA;&lt;p&gt;We support installing or building &lt;code&gt;jaxlib&lt;/code&gt; on Linux (Ubuntu 16.04 or later) and macOS (10.12 or later) platforms. Windows users can use JAX on CPU and GPU via the &lt;a href=&#34;https://docs.microsoft.com/en-us/windows/wsl/about&#34;&gt;Windows Subsystem for Linux&lt;/a&gt;. There is some initial native Windows support, but since it is still somewhat immature, there are no binary releases and it must be &lt;a href=&#34;https://jax.readthedocs.io/en/latest/developer.html#additional-notes-for-building-jaxlib-from-source-on-windows&#34;&gt;built from source&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;pip installation: CPU&lt;/h3&gt; &#xA;&lt;p&gt;To install a CPU-only version of JAX, which might be useful for doing local development on a laptop, you can run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install --upgrade pip&#xA;pip install --upgrade &#34;jax[cpu]&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Linux, it is often necessary to first update &lt;code&gt;pip&lt;/code&gt; to a version that supports &lt;code&gt;manylinux2014&lt;/code&gt; wheels.&lt;/p&gt; &#xA;&lt;h3&gt;pip installation: GPU (CUDA)&lt;/h3&gt; &#xA;&lt;p&gt;If you want to install JAX with both CPU and NVidia GPU support, you must first install &lt;a href=&#34;https://developer.nvidia.com/cuda-downloads&#34;&gt;CUDA&lt;/a&gt; and &lt;a href=&#34;https://developer.nvidia.com/CUDNN&#34;&gt;CuDNN&lt;/a&gt;, if they have not already been installed. Unlike some other popular deep learning systems, JAX does not bundle CUDA or CuDNN as part of the &lt;code&gt;pip&lt;/code&gt; package.&lt;/p&gt; &#xA;&lt;p&gt;JAX provides pre-built CUDA-compatible wheels for &lt;strong&gt;Linux only&lt;/strong&gt;, with CUDA 11.1 or newer, and CuDNN 8.0.5 or newer. Other combinations of operating system, CUDA, and CuDNN are possible, but require building from source.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CUDA 11.1 or newer is &lt;em&gt;required&lt;/em&gt;. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You may be able to use older CUDA versions if you build from source, but there are known bugs in CUDA in all CUDA versions older than 11.1, so we do not ship prebuilt binaries for older CUDA versions.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The supported cuDNN versions for the prebuilt wheels are: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;cuDNN 8.2 or newer. We recommend using the cuDNN 8.2 wheel if your cuDNN installation is new enough, since it supports additional functionality.&lt;/li&gt; &#xA;   &lt;li&gt;cuDNN 8.0.5 or newer.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;You &lt;em&gt;must&lt;/em&gt; use an NVidia driver version that is at least as new as your &lt;a href=&#34;https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#cuda-major-component-versions__table-cuda-toolkit-driver-versions&#34;&gt;CUDA toolkit&#39;s corresponding driver version&lt;/a&gt;. For example, if you have CUDA 11.4 update 4 installed, you must use NVidia driver 470.82.01 or newer if on Linux. This is a strict requirement that exists because JAX relies on JIT-compiling code; older drivers may lead to failures. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If you need to use an newer CUDA toolkit with an older driver, for example on a cluster where you cannot update the NVidia driver easily, you may be able to use the &lt;a href=&#34;https://docs.nvidia.com/deploy/cuda-compatibility/&#34;&gt;CUDA forward compatibility packages&lt;/a&gt; that NVidia provides for this purpose.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Next, run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install --upgrade pip&#xA;# Installs the wheel compatible with CUDA 11 and cuDNN 8.2 or newer.&#xA;# Note: wheels only available on linux.&#xA;pip install --upgrade &#34;jax[cuda]&#34; -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The jaxlib version must correspond to the version of the existing CUDA installation you want to use. You can specify a particular CUDA and CuDNN version for jaxlib explicitly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install --upgrade pip&#xA;&#xA;# Installs the wheel compatible with Cuda &amp;gt;= 11.4 and cudnn &amp;gt;= 8.2&#xA;pip install &#34;jax[cuda11_cudnn82]&#34; -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html&#xA;&#xA;# Installs the wheel compatible with Cuda &amp;gt;= 11.1 and cudnn &amp;gt;= 8.0.5&#xA;pip install &#34;jax[cuda11_cudnn805]&#34; -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can find your CUDA version with the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nvcc --version&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some GPU functionality expects the CUDA installation to be at &lt;code&gt;/usr/local/cuda-X.X&lt;/code&gt;, where X.X should be replaced with the CUDA version number (e.g. &lt;code&gt;cuda-11.1&lt;/code&gt;). If CUDA is installed elsewhere on your system, you can either create a symlink:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ln -s /path/to/cuda /usr/local/cuda-X.X&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please let us know on &lt;a href=&#34;https://github.com/google/jax/issues&#34;&gt;the issue tracker&lt;/a&gt; if you run into any errors or problems with the prebuilt wheels.&lt;/p&gt; &#xA;&lt;h3&gt;pip installation: Google Cloud TPU&lt;/h3&gt; &#xA;&lt;p&gt;JAX also provides pre-built wheels for &lt;a href=&#34;https://cloud.google.com/tpu/docs/users-guide-tpu-vm&#34;&gt;Google Cloud TPU&lt;/a&gt;. To install JAX along with appropriate versions of &lt;code&gt;jaxlib&lt;/code&gt; and &lt;code&gt;libtpu&lt;/code&gt;, you can run the following in your cloud TPU VM:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install --upgrade pip&#xA;pip install &#34;jax[tpu]&amp;gt;=0.2.16&#34; -f https://storage.googleapis.com/jax-releases/libtpu_releases.html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;pip installation: Colab TPU&lt;/h3&gt; &#xA;&lt;p&gt;Colab TPU runtimes come with JAX pre-installed, but before importing JAX you must run the following code to initialize the TPU:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import jax.tools.colab_tpu&#xA;jax.tools.colab_tpu.setup_tpu()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Colab TPU runtimes use an older TPU architecture than Cloud TPU VMs, so installing &lt;code&gt;jax[tpu]&lt;/code&gt; should be avoided on Colab. If for any reason you would like to update the jax &amp;amp; jaxlib libraries on a Colab TPU runtime, follow the CPU instructions above (i.e. install &lt;code&gt;jax[cpu]&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Building JAX from source&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://jax.readthedocs.io/en/latest/developer.html#building-from-source&#34;&gt;Building JAX from source&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Neural network libraries&lt;/h2&gt; &#xA;&lt;p&gt;Multiple Google research groups develop and share libraries for training neural networks in JAX. If you want a fully featured library for neural network training with examples and how-to guides, try &lt;a href=&#34;https://github.com/google/flax&#34;&gt;Flax&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In addition, DeepMind has open-sourced an &lt;a href=&#34;https://deepmind.com/blog/article/using-jax-to-accelerate-our-research&#34;&gt;ecosystem of libraries around JAX&lt;/a&gt; including &lt;a href=&#34;https://github.com/deepmind/dm-haiku&#34;&gt;Haiku&lt;/a&gt; for neural network modules, &lt;a href=&#34;https://github.com/deepmind/optax&#34;&gt;Optax&lt;/a&gt; for gradient processing and optimization, &lt;a href=&#34;https://github.com/deepmind/rlax&#34;&gt;RLax&lt;/a&gt; for RL algorithms, and &lt;a href=&#34;https://github.com/deepmind/chex&#34;&gt;chex&lt;/a&gt; for reliable code and testing. (Watch the NeurIPS 2020 JAX Ecosystem at DeepMind talk &lt;a href=&#34;https://www.youtube.com/watch?v=iDxJxIyzSiM&#34;&gt;here&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;h2&gt;Citing JAX&lt;/h2&gt; &#xA;&lt;p&gt;To cite this repository:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@software{jax2018github,&#xA;  author = {James Bradbury and Roy Frostig and Peter Hawkins and Matthew James Johnson and Chris Leary and Dougal Maclaurin and George Necula and Adam Paszke and Jake Vander{P}las and Skye Wanderman-{M}ilne and Qiao Zhang},&#xA;  title = {{JAX}: composable transformations of {P}ython+{N}um{P}y programs},&#xA;  url = {http://github.com/google/jax},&#xA;  version = {0.3.13},&#xA;  year = {2018},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above bibtex entry, names are in alphabetical order, the version number is intended to be that from &lt;a href=&#34;https://raw.githubusercontent.com/google/jax/main/jax/version.py&#34;&gt;jax/version.py&lt;/a&gt;, and the year corresponds to the project&#39;s open-source release.&lt;/p&gt; &#xA;&lt;p&gt;A nascent version of JAX, supporting only automatic differentiation and compilation to XLA, was described in a &lt;a href=&#34;https://mlsys.org/Conferences/2019/doc/2018/146.pdf&#34;&gt;paper that appeared at SysML 2018&lt;/a&gt;. We&#39;re currently working on covering JAX&#39;s ideas and capabilities in a more comprehensive and up-to-date paper.&lt;/p&gt; &#xA;&lt;h2&gt;Reference documentation&lt;/h2&gt; &#xA;&lt;p&gt;For details about the JAX API, see the &lt;a href=&#34;https://jax.readthedocs.io/&#34;&gt;reference documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For getting started as a JAX developer, see the &lt;a href=&#34;https://jax.readthedocs.io/en/latest/developer.html&#34;&gt;developer documentation&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>