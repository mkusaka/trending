<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Python Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-12T01:39:13Z</updated>
  <subtitle>Daily Trending of Python in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nus-apr/auto-code-rover</title>
    <updated>2024-04-12T01:39:13Z</updated>
    <id>tag:github.com,2024-04-12:/nus-apr/auto-code-rover</id>
    <link href="https://github.com/nus-apr/auto-code-rover" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A project structure aware autonomous software engineer aiming for autonomous program improvement&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;AutoCodeRover: Autonomous Program Improvement&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/nus-apr/auto-code-rover/assets/48704330/0b8da9ad-588c-4f7d-9c99-53f33d723d35&#34; alt=&#34;overall-workflow&#34;&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://arxiv.org/abs/2404.05427&#34;&gt;&lt;strong&gt;ArXiv Paper&lt;/strong&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;üëã Overview&lt;/h2&gt; &#xA;&lt;p&gt;AutoCodeRover is a fully automated approach for resolving GitHub issues (bug fixing and feature addition) where LLMs are combined with analysis and debugging capabilities to prioritize patch locations ultimately leading to a patch.&lt;/p&gt; &#xA;&lt;p&gt;On &lt;a href=&#34;https://www.swebench.com/lite.html&#34;&gt;SWE-bench lite&lt;/a&gt;, which consists of 300 real-world GitHub issues, AutoCodeRover resolves ~&lt;strong&gt;22%&lt;/strong&gt; of issues, improving over the current state-of-the-art efficacy of AI software engineers.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/nus-apr/auto-code-rover/assets/48704330/28e26111-5f15-4ee4-acd1-fa6e2e6e0593&#34; width=&#34;330/&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;AutoCodeRover works in two stages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üîé Context retrieval: The LLM is provided with code search APIs to navigate the codebase and collect relevant context.&lt;/li&gt; &#xA; &lt;li&gt;üíä Patch generation: The LLM tries to write a patch, based on retrieved context.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;‚ú® Highlights&lt;/h3&gt; &#xA;&lt;p&gt;AutoCodeRover has two unique features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Code search APIs are &lt;em&gt;Program Structure Aware&lt;/em&gt;. Instead of searching over files by plain string matching, AutoCodeRover searches for relevant code context (methods/classes) in the abstract syntax tree.&lt;/li&gt; &#xA; &lt;li&gt;When a test suite is available, AutoCodeRover can take advantage of test cases to achieve an even higher repair rate, by performing &lt;em&gt;statistical fault localization&lt;/em&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üóé arXiv Paper&lt;/h2&gt; &#xA;&lt;h3&gt;AutoCodeRover: Autonomous Program Improvement &lt;a href=&#34;https://arxiv.org/abs/2404.05427&#34;&gt;[arXiv 2404.05427]&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://arxiv.org/abs/2404.05427&#34;&gt; &lt;img src=&#34;https://github.com/nus-apr/auto-code-rover/assets/48704330/3d42a873-dd9f-41f3-ae09-eba477db2420&#34; alt=&#34;First page of arXiv paper&#34; width=&#34;570&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;For referring to our work, please cite and mention:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@misc{zhang2024autocoderover,&#xA;      title={AutoCodeRover: Autonomous Program Improvement},&#xA;      author={Yuntong Zhang and Haifeng Ruan and Zhiyu Fan and Abhik Roychoudhury},&#xA;      year={2024},&#xA;      eprint={2404.05427},&#xA;      archivePrefix={arXiv},&#xA;      primaryClass={cs.SE}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;‚úîÔ∏è Example: Django Issue #32347&lt;/h2&gt; &#xA;&lt;p&gt;As an example, AutoCodeRover successfully fixed issue &lt;a href=&#34;https://code.djangoproject.com/ticket/32347&#34;&gt;#32347&lt;/a&gt; of Django. See the demo video for the full process:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/nus-apr/auto-code-rover/assets/48704330/719c7a56-40b8-4f3d-a90e-0069e37baad3&#34;&gt;https://github.com/nus-apr/auto-code-rover/assets/48704330/719c7a56-40b8-4f3d-a90e-0069e37baad3&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Enhancement: leveraging test cases&lt;/h3&gt; &#xA;&lt;p&gt;AutoCodeRover can resolve even more issues, if test cases are available. See an example in the video:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/nus-apr/auto-code-rover/assets/48704330/26c9d5d4-04e0-4b98-be55-61c1d10a36e5&#34;&gt;https://github.com/nus-apr/auto-code-rover/assets/48704330/26c9d5d4-04e0-4b98-be55-61c1d10a36e5&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üöÄ Setup &amp;amp; Running&lt;/h2&gt; &#xA;&lt;p&gt;We recommend running AutoCodeRover in a Docker container. First of all, build and start the docker image:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker build -f Dockerfile -t acr .&#xA;docker run -it acr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the docker container, set the &lt;code&gt;OPENAI_KEY&lt;/code&gt; env var to your &lt;a href=&#34;https://help.openai.com/en/articles/4936850-where-do-i-find-my-openai-api-key&#34;&gt;OpenAI key&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export OPENAI_KEY=xx-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Set up one or more tasks in SWE-bench&lt;/h3&gt; &#xA;&lt;p&gt;In the docker container, we need to first set up the tasks to run in SWE-bench (e.g., &lt;code&gt;django__django-11133&lt;/code&gt;). The list of all tasks can be found in &lt;a href=&#34;https://raw.githubusercontent.com/nus-apr/auto-code-rover/main/conf/swe_lite_tasks.txt&#34;&gt;&lt;code&gt;conf/swe_lite_tasks.txt&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The tasks need to be put in a file, one per line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /opt/SWE-bench&#xA;echo django__django-11133 &amp;gt; tasks.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, set up these tasks by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /opt/SWE-bench&#xA;conda activate swe-bench&#xA;python harness/run_setup.py --log_dir logs --testbed testbed --result_dir setup_result --subset_file tasks.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once the setup for this task is completed, the following two lines will be printed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;setup_map is saved to setup_result/setup_map.json&#xA;tasks_map is saved to setup_result/tasks_map.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;testbed&lt;/code&gt; directory will now contain the cloned source code of the target project. A conda environment will also be created for this task instance.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;If you want to set up multiple tasks together, put their ids in &lt;code&gt;tasks.txt&lt;/code&gt; and follow the same steps.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Run a single task&lt;/h3&gt; &#xA;&lt;p&gt;Before running the task (&lt;code&gt;django__django-11133&lt;/code&gt; here), make sure it has been set up as mentioned &lt;a href=&#34;https://raw.githubusercontent.com/nus-apr/auto-code-rover/main/#set-up-one-or-more-tasks-in-swe-bench&#34;&gt;above&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /opt/auto-code-rover&#xA;conda activate auto-code-rover&#xA;PYTHONPATH=. python app/main.py --enable-layered --model gpt-4-0125-preview --setup-map ../SWE-bench/setup_result/setup_map.json --tasks-map ../SWE-bench/setup_result/tasks_map.json --output-dir output --task django__django-11133&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output of the run can then be found in &lt;code&gt;output/&lt;/code&gt;. For example, the patch generated for &lt;code&gt;django__django-11133&lt;/code&gt; can be found at a location like this: &lt;code&gt;output/applicable_patch/django__django-11133_yyyy-MM-dd_HH-mm-ss/extracted_patch_1.diff&lt;/code&gt; (the date-time field in the directory name will be different depending on when the experiment was run).&lt;/p&gt; &#xA;&lt;h3&gt;Run multiple tasks&lt;/h3&gt; &#xA;&lt;p&gt;First, put the id&#39;s of all tasks to run in a file, one per line. Suppose this file is &lt;code&gt;tasks.txt&lt;/code&gt;, the tasks can be run with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PYTHONPATH=. python app/main.py --enable-layered --model gpt-4-0125-preview --setup-map ../SWE-bench/setup_result/setup_map.json --tasks-map ../SWE-bench/setup_result/tasks_map.json --output-dir output --task-list-file tasks.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: make sure that the tasks in &lt;code&gt;tasks.txt&lt;/code&gt; have all been set up in SWE-bench. See the steps &lt;a href=&#34;https://raw.githubusercontent.com/nus-apr/auto-code-rover/main/#set-up-one-or-more-tasks-in-swe-bench&#34;&gt;above&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Using a config file&lt;/h4&gt; &#xA;&lt;p&gt;Alternatively, a config file can be used to specify all parameters and tasks to run. See &lt;code&gt;conf/vanilla-lite.conf&lt;/code&gt; for an example. Also see &lt;a href=&#34;https://raw.githubusercontent.com/nus-apr/auto-code-rover/main/EXPERIMENT.md&#34;&gt;EXPERIMENT.md&lt;/a&gt; for the details of the items in a conf file. A config file can be used by:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python scripts/run.py conf/vanilla-lite.conf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Experiment Replication&lt;/h2&gt; &#xA;&lt;p&gt;Please refer to &lt;a href=&#34;https://raw.githubusercontent.com/nus-apr/auto-code-rover/main/EXPERIMENT.md&#34;&gt;EXPERIMENT.md&lt;/a&gt; for information on experiment replication.&lt;/p&gt; &#xA;&lt;h2&gt;‚úâÔ∏è Contacts&lt;/h2&gt; &#xA;&lt;p&gt;For any queries, you are welcome to open an issue.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, contact us at: {yuntong,hruan,zhiyufan}@comp.nus.edu.sg.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;This work was partially supported by a Singapore Ministry of Education (MoE) Tier 3 grant &#34;Automated Program Repair&#34;, MOE-MOET32021-0001.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cyrus-and/gdb-dashboard</title>
    <updated>2024-04-12T01:39:13Z</updated>
    <id>tag:github.com,2024-04-12:/cyrus-and/gdb-dashboard</id>
    <link href="https://github.com/cyrus-and/gdb-dashboard" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Modular visual interface for GDB in Python&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GDB dashboard&lt;/h1&gt; &#xA;&lt;p&gt;GDB dashboard is a standalone &lt;code&gt;.gdbinit&lt;/code&gt; file written using the &lt;a href=&#34;https://sourceware.org/gdb/onlinedocs/gdb/Python-API.html&#34;&gt;Python API&lt;/a&gt; that enables a modular interface showing relevant information about the program being debugged. Its main goal is to reduce the number of GDB commands needed to inspect the status of current program thus allowing the developer to primarily focus on the control flow.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wiki/cyrus-and/gdb-dashboard/Screenshot.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;Just place &lt;a href=&#34;https://raw.githubusercontent.com/cyrus-and/gdb-dashboard/master/.gdbinit&#34;&gt;&lt;code&gt;.gdbinit&lt;/code&gt;&lt;/a&gt; in your home directory, for example with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;wget -P ~ https://github.com/cyrus-and/gdb-dashboard/raw/master/.gdbinit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Optionally install &lt;a href=&#34;http://pygments.org/&#34;&gt;Pygments&lt;/a&gt; to enable syntax highlighting:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip install pygments&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then debug as usual, the dashboard will appear automatically every time the inferior program stops.&lt;/p&gt; &#xA;&lt;p&gt;Keep in mind that no GDB command has been redefined, instead all the features are available via the main &lt;code&gt;dashboard&lt;/code&gt; command (see &lt;code&gt;help dashboard&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Head to the &lt;a href=&#34;https://github.com/cyrus-and/gdb-dashboard/wiki&#34;&gt;wiki&lt;/a&gt; to learn how to perform the most important tasks.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>aixcoder-plugin/aiXcoder-7B</title>
    <updated>2024-04-12T01:39:13Z</updated>
    <id>tag:github.com,2024-04-12:/aixcoder-plugin/aiXcoder-7B</id>
    <link href="https://github.com/aixcoder-plugin/aiXcoder-7B" rel="alternate"></link>
    <summary type="html">&lt;p&gt;official repository of aiXcoder-7B Code Large Language Model&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;aiXcoder-7B Code Large Language Model&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; üè† &lt;a href=&#34;https://www.aixcoder.com/&#34; target=&#34;_blank&#34;&gt;Official website&lt;/a&gt;ÔΩúüõ† &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=aixcoder-plugin.aixcoder&#34; target=&#34;_blank&#34;&gt;VS Code Plugin&lt;/a&gt;ÔΩúüõ† &lt;a href=&#34;https://plugins.jetbrains.com/plugin/13574-aixcoder-code-completer&#34; target=&#34;_blank&#34;&gt;Jetbrains Plugin&lt;/a&gt;ÔΩúü§ó &lt;a href=&#34;https://huggingface.co/aiXcoder/aixcoder-7b-base&#34; target=&#34;_blank&#34;&gt;Model Weights&lt;/a&gt;ÔΩú&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/assets/wechat_1.jpg&#34; target=&#34;_blank&#34;&gt;WeChat&lt;/a&gt;ÔΩú&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/assets/wechat_2.jpg&#34; target=&#34;_blank&#34;&gt;WeChat Official Account&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;Welcome to the official repository of aiXcoder-7B Code Large Language Model. This model is designed to understand and generate code across multiple programming languages, offering state-of-the-art performance in code completion, comprehension, generation, and more tasks about programming languages.&lt;/p&gt; &#xA;&lt;p&gt;Table of Contents&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#model-introduction&#34;&gt;Model Introduction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#quickstart&#34;&gt;Quickstart&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#environment-requirements&#34;&gt;Environment Requirements&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#model-weights&#34;&gt;Model Weights&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#inference-example&#34;&gt;Inference Example&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#quantized-through-bitsandbytes&#34;&gt;Quantized through bitsandbytes&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#data-for-aixcoder-7b&#34;&gt;Data for aiXcoder 7B&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#training&#34;&gt;Training&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#training-hyperparameters&#34;&gt;Training Hyperparameters&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#batch-processing-method&#34;&gt;Batch processing method&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#pre-training-tasks&#34;&gt;Pre-training Tasks&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#details-of-experimental-results&#34;&gt;Details of Experimental Results&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#nl2code-benchmarks&#34;&gt;NL2Code Benchmarks&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#code-completion-fill-in-the-middle&#34;&gt;Code Completion (Fill in the Middle)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#cross-file-code-evaluation&#34;&gt;Cross-file Code Evaluation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/#acknowledgments&#34;&gt;Acknowledgments&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Model Introduction&lt;/h2&gt; &#xA;&lt;p&gt;As the capabilities of large code models are gradually being unearthed, aiXcoder has consistently pondered on how to make these models more beneficial in real development scenarios. To this end, we have open-sourced aiXcoder 7B Base, which has undergone extensive training on 1.2T Unique Tokens, and the model&#39;s pre-training tasks as well as the contextual information have been uniquely designed for real-world code generation contexts.&lt;/p&gt; &#xA;&lt;p&gt;aiXcoder 7B Base stands out as the most effective model in code completion scenarios among all models of similar parameter sizes, and it also surpasses mainstream models like codellama 34B and StarCoder2 15B in the average performance on the multilingual nl2code benchmark.&lt;/p&gt; &#xA;&lt;p&gt;In our ongoing exploration to apply large code models, the release of aiXcoder 7B Base represents a significant milestone. The current version of aiXcoder 7B Base is a foundational model that focuses on improving the efficiency and accuracy of code completion and code generation tasks, aiming to provide robust support for developers in these scenarios. It is important to note that this version has not undergone specific instruct-tuning, which means it might not yet offer optimal performance for specialized higher-level tasks such as test case generation and code debugging.&lt;/p&gt; &#xA;&lt;p&gt;However, we have plans for further development of the aiXcoder model series already in motion. In the near future, we aim to release new versions of the model that have been meticulously instruct-tuned for a wider range of programming tasks, including but not limited to test case generation and code debugging. Through these instruct-tuned models, we anticipate offering developers more comprehensive and deeper programming support, helping them to maximize efficiency at every stage of software development.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/assets/table_1.png&#34; alt=&#34;table_1&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;aiXcoder 7B surpasses mainstream models in nl2code benchmark. aiXcoder-7B is an enhancement of aiXcoder-7B-Base, fine-tuned on one hundred thousand data entries similar to Evol-instruct for one epoch.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;br&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/assets/table_3.png&#34; alt=&#34;table_3&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;aiXcoder 7B Base surpasses mainstream models in code completion scenarios.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;br&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;h3&gt;Environment Requirements&lt;/h3&gt; &#xA;&lt;h4&gt;Option 1: Build Env&lt;/h4&gt; &#xA;&lt;p&gt;To run the model inference code, you&#39;ll need the following environment setup:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Python 3.8 or higher&lt;/li&gt; &#xA; &lt;li&gt;PyTorch 2.1.0 or higher&lt;/li&gt; &#xA; &lt;li&gt;sentencepiece 0.2.0 or higher&lt;/li&gt; &#xA; &lt;li&gt;transformers 4.34.1 or higher (if run inference by transformers library)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please ensure all dependencies are installed using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;conda create -n aixcoder-7b python=3.11&#xA;conda activate aixcoder-7b&#xA;git clone git@github.com:aixcoder-plugin/aiXcoder-7b.git&#xA;cd aiXcoder-7b&#xA;pip install -r requirements.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;requirements.txt&lt;/code&gt; listed all necessary libraries and their versions.&lt;/p&gt; &#xA;&lt;p&gt;To achieve faster inference speeds, especially for large models, we recommend installing &lt;code&gt;flash attention&lt;/code&gt;. &lt;code&gt;Flash attention&lt;/code&gt; is an optimized attention mechanism that significantly reduces computation time for transformer-based models without sacrificing accuracy.&lt;/p&gt; &#xA;&lt;p&gt;Before proceeding, ensure your environment meets the CUDA requirements as &lt;code&gt;flash attention&lt;/code&gt; leverages GPU acceleration. Follow these steps to install &lt;code&gt;flash attention&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git@github.com:Dao-AILab/flash-attention.git&#xA;cd flash-attention&#xA;MAX_JOBS=8 python setup.py install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Option 2: Docker&lt;/h4&gt; &#xA;&lt;p&gt;For a consistent and isolated environment, we recommend running the model inference code using Docker. Here&#39;s how to set up and use Docker for our model:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install Docker: If you haven&#39;t already, install Docker on your machine.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Pull the Docker Image: Pull the Docker image from Docker Hub.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker pull pytorch/pytorch:2.1.0-cuda11.8-cudnn8-devel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Run the Container: Once the image is pulled, you can run the model inside a Docker container.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --gpus all -it -v /dev/shm:/dev/shm --name aix_instance pytorch/pytorch:2.1.0-cuda11.8-cudnn8-devel /bin/bash&#xA;pip install sentencepiece&#xA;git clone git@github.com:aixcoder-plugin/aiXcoder-7b.git&#xA;cd aiXcoder-7b&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This command starts a container named aix_instance from the pytorch image. You can interact with the model inside this container.&lt;/p&gt; &#xA;&lt;p&gt;To achieve faster inference speeds, especially for large models, we recommend installing &lt;code&gt;flash attention&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git@github.com:Dao-AILab/flash-attention.git&#xA;cd flash-attention&#xA;MAX_JOBS=8 python setup.py install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Model Inference: Within the Docker container, you can run the model inference code as described in the Inference Example section.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Using Docker provides a clean, controlled environment that minimizes issues related to software versions and dependencies.&lt;/p&gt; &#xA;&lt;h3&gt;Model Weights&lt;/h3&gt; &#xA;&lt;p&gt;You can download the model weights from the following link:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://huggingface.co/aiXcoder/aixcoder-7b-base&#34;&gt;aiXcoder Base Download&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;aiXcoder Instruct Download (Comming soon...)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Inference Example&lt;/h3&gt; &#xA;&lt;h4&gt;Command Line Execution&lt;/h4&gt; &#xA;&lt;p&gt;For a quick start, you can run the model inference directly from the command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;torchrun --nproc_per_node 1 sess_megatron.py --model_dir &#34;path/to/model_weights_dir&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Replace &#34;path/to/model_weights_dir&#34; with the actual path to your downloaded model weights.&lt;/p&gt; &#xA;&lt;p&gt;or run inference with huggingface&#39;s transformersÔºö&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python sess_huggingface.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Python Script Execution&lt;/h4&gt; &#xA;&lt;p&gt;Alternatively, you can invoke the model programmatically within your Python scripts. This method provides more flexibility for integrating the model into your applications or workflows. Here&#39;s a simple example on how to do it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#xA;from sess_megatron import TestInference&#xA;&#xA;infer = TestInference()&#xA;res = infer.run_infer(&#xA;    # for FIM style input, code_string stands for prefix context&#xA;    code_string=&#34;&#34;&#34;# Âø´ÈÄüÊéíÂ∫èÁÆóÊ≥ï&#34;&#34;&#34;, &#xA;    # for FIM style input, later_code stands for suffix context&#xA;    later_code=&#34;\n&#34;,&#xA;    # file_path should be a path from project to file&#xA;    file_path=&#34;test.py&#34;,&#xA;    # max num for generated tokens&#xA;    max_new_tokens=256,&#xA;)&#xA;print(res)&#xA;&#xA;&#34;&#34;&#34;output:&#xA;&#xA;def quick_sort(arr):&#xA;    if len(arr) &amp;lt;= 1:&#xA;        return arr&#xA;    pivot = arr[0]&#xA;    less = [i for i in arr[1:] if i &amp;lt;= pivot]&#xA;    greater = [i for i in arr[1:] if i &amp;gt; pivot]&#xA;    return quick_sort(less) + [pivot] + quick_sort(greater)&#xA;&#xA;&#xA;# ÊµãËØï&#xA;arr = [3, 2, 1, 4, 5]&#xA;print(quick_sort(arr))  # [1, 2, 3, 4, 5]&#xA;&#34;&#34;&#34;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#xA;&#xA;import torch&#xA;import sys&#xA;from hf_mini.utils import input_wrapper&#xA;from transformers import AutoModelForCausalLM, AutoTokenizer&#xA;&#xA;device = &#34;cuda&#34; # the device to load the model onto&#xA;&#xA;tokenizer = AutoTokenizer.from_pretrained(&#34;aiXcoder/aixcoder-7b-base&#34;)&#xA;model = AutoModelForCausalLM.from_pretrained(&#34;aiXcoder/aixcoder-7b-base&#34;, torch_dtype=torch.bfloat16)&#xA;&#xA;&#xA;text = input_wrapper(&#xA;    # for FIM style input, code_string stands for prefix context&#xA;    code_string=&#34;# Âø´ÈÄüÊéíÂ∫èÁÆóÊ≥ï&#34;,&#xA;    # for FIM style input, later_code stands for suffix context&#xA;    later_code=&#34;\n# ÊµãËØï\narr = [3, 2, 1, 4, 5]\nprint(quick_sort(arr))  # [1, 2, 3, 4, 5]&#34;,&#xA;    # file_path should be a path from project to file&#xA;    path=&#34;test.py&#34;&#xA;)&#xA;&#xA;if len(text) == 0:&#xA;    sys.exit()&#xA;&#xA;inputs = tokenizer(text, return_tensors=&#34;pt&#34;, return_token_type_ids=False)&#xA;&#xA;inputs = inputs.to(device)&#xA;model.to(device)&#xA;&#xA;outputs = model.generate(**inputs, max_new_tokens=256)&#xA;print(tokenizer.decode(outputs[0], skip_special_tokens=False))&#xA;&#xA;&#xA;&#xA;&#34;&#34;&#34;output:&#xA;def quick_sort(arr):&#xA;    # Â¶ÇÊûúÊï∞ÁªÑÈïøÂ∫¶Â∞è‰∫éÁ≠â‰∫é1ÔºåÁõ¥Êé•ËøîÂõû&#xA;    if len(arr) &amp;lt;= 1:&#xA;        return arr&#xA;    # ÈÄâÊã©Êï∞ÁªÑÁöÑÁ¨¨‰∏Ä‰∏™ÂÖÉÁ¥†‰Ωú‰∏∫Âü∫ÂáÜ&#xA;    pivot = arr[0]&#xA;    # ÂàùÂßãÂåñÂ∑¶Âè≥ÊåáÈíà&#xA;    left, right = 1, len(arr) - 1&#xA;    # Âæ™ÁéØÁõ¥Âà∞Â∑¶ÊåáÈíàÂ∞è‰∫éÂè≥ÊåáÈíà&#xA;    while left &amp;lt; right:&#xA;        # ‰ªéÂè≥Âà∞Â∑¶ÊâæÂà∞Á¨¨‰∏Ä‰∏™Â∞è‰∫éÂü∫ÂáÜÁöÑÂÖÉÁ¥†Ôºå‰∏éÂ∑¶ÊåáÈíàÂÖÉÁ¥†‰∫§Êç¢&#xA;        if arr[right] &amp;lt; pivot:&#xA;            arr[left], arr[right] = arr[right], arr[left]&#xA;            left += 1&#xA;        # ‰ªéÂ∑¶Âà∞Âè≥ÊâæÂà∞Á¨¨‰∏Ä‰∏™Â§ß‰∫éÁ≠â‰∫éÂü∫ÂáÜÁöÑÂÖÉÁ¥†Ôºå‰∏éÂè≥ÊåáÈíàÂÖÉÁ¥†‰∫§Êç¢&#xA;        if arr[left] &amp;gt;= pivot:&#xA;            right -= 1&#xA;    # Â∞ÜÂü∫ÂáÜÂÖÉÁ¥†‰∏éÂ∑¶ÊåáÈíàÂÖÉÁ¥†‰∫§Êç¢&#xA;    arr[left], arr[0] = arr[0], arr[left]&#xA;    # ÂØπÂ∑¶ÂçäÈÉ®ÂàÜËøõË°åÈÄíÂΩíÊéíÂ∫è&#xA;    quick_sort(arr[:left])&#xA;    # ÂØπÂè≥ÂçäÈÉ®ÂàÜËøõË°åÈÄíÂΩíÊéíÂ∫è&#xA;    quick_sort(arr[left + 1:])&#xA;    return arr&amp;lt;/s&amp;gt;&#xA;&#34;&#34;&#34;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Quantized through bitsandbytes&lt;/h3&gt; &#xA;&lt;p&gt;We can also install Bitsandbytes through &lt;code&gt;pip install bitsandbytes acceleration&lt;/code&gt;, and simply add configuration to perform int8 or int4 inference (if you need to further compress the temporary memory applied at runtime, it is recommended to install FlashAttention):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#xA;import sys&#xA;import torch&#xA;from hf_mini.utils import input_wrapper&#xA;from transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig    &#xA;&#xA;# to use 4bit use `load_in_4bit=True` instead&#xA;bnb_config = BitsAndBytesConfig(load_in_8bit=True) &#xA;&#xA;device = &#34;cuda&#34; # the device to load the model onto&#xA;&#xA;tokenizer = AutoTokenizer.from_pretrained(&#34;aiXcoder/aixcoder-7b-base&#34;)&#xA;model = AutoModelForCausalLM.from_pretrained(&#34;aiXcoder/aixcoder-7b-base&#34;, quantization_config=bnb_config, device_map=device, attn_implementation=&#39;flash_attention_2&#39;)&#xA;&#xA;text = input_wrapper(&#xA;    code_string=&#34;# Âø´ÈÄüÊéíÂ∫èÁÆóÊ≥ï&#34;,&#xA;    later_code=&#34;\n&#34;,&#xA;    path=&#34;test.py&#34;&#xA;)&#xA;&#xA;if len(text) == 0:&#xA;    sys.exit()&#xA;&#xA;inputs = tokenizer(text, return_tensors=&#34;pt&#34;, return_token_type_ids=False)&#xA;&#xA;inputs = inputs.to(device)    &#xA;&#xA;outputs = model.generate(**inputs, max_new_tokens=256)&#xA;print(f&#34;Model memory footprint: {model.get_memory_footprint() / 2**20:.2f} MB&#34;)&#xA;print(f&#34;Torch max memory allocated: {torch.cuda.max_memory_allocated() / 2**20:.2f} MB&#34;)&#xA;&#xA;&#34;&#34;&#34;&#xA;load_in_4bit=True:&#xA;    - Model memory footprint: 5656.52 MB&#xA;    - Torch max memory allocated: 6448.89 MB&#xA;&#xA;load_in_8bit=True:&#xA;    - Model memory footprint: 9008.52 MB&#xA;    - Torch max memory allocated: 10061.51 MB&#xA;&#34;&#34;&#34;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Data for aiXcoder 7B&lt;/h2&gt; &#xA;&lt;p&gt;The data for aiXcoder is divided into a core dataset and an extended dataset. The core dataset comprises the programming languages commonly used in development, as well as natural languages closely related to code. The core dataset&#39;s programming languages mainly include nearly a hundred mainstream languages such as C++, Python, Java, and JavaScript, while the natural language component primarily consists of StackOverflow Q&amp;amp;As, technical blogs, code documentation, and computer science papers. The extended data mainly consists of filtered open-source code datasets, high-quality English natural language datasets, and high-quality Chinese natural language datasets.&lt;/p&gt; &#xA;&lt;!-- &lt;br&gt;&#xA;&lt;br&gt;&#xA;&#xA;![table_0](./assets/table_0.png)&#xA;&#xA;&lt;br&gt;&#xA;&lt;br&gt; --&gt; &#xA;&lt;p&gt;The aiXcoder core dataset is mainly used to enhance the performance of the large code model in the aforementioned programming languages, undergoing a rigorous filtering and selection process. Specifically, this process includes the following steps: 1) Selection of raw data; 2) Comprehensive ranking and selection of projects; 3) Code deduplication and the removal of automatically generated code using methods such as MinHashes (Broder, 2000); 4) Identification and handling of personal sensitive information; 5) Cleaning of commented code; 6) Syntactic analysis to filter incorrect or anomalous code files; 7) Static analysis to detect and eliminate 163 types of high-risk bugs and 197 types of defects in mainstream programming languages such as Java, C++, Python, and JavaScript.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Raw Data Selection &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Exclude projects under copyleft licenses.&lt;/li&gt; &#xA;   &lt;li&gt;Deduplicate projects gathered from various code hosting platforms and open-source datasets&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Project-Level Comprehensive Ranking &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Calculate project metrics, including the number of Stars, Git Commit counts, and the quantity of Test files.&lt;/li&gt; &#xA;   &lt;li&gt;Exclude the lowest 10% of data based on a comprehensive score.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Code File-Level Filtering &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Remove automatically generated code.&lt;/li&gt; &#xA;   &lt;li&gt;Employ near-deduplication for redundancy removal.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Sensitive Information Removal &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Use named entity recognition models to identify and delete sensitive information such as names, IP addresses, account passwords, and URLs.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Commented Code &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Randomly deleting large sections of commented code&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Syntax Analysis &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Delete code with syntax parsing errors or syntactical errors in the top fifty languages.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Static Analysis &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Utilize static analysis tools to scan for and locate 161 types of Bugs affecting code reliability and maintainability, as well as 197 types of vulnerabilities impacting code security.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# &#34;__init__&#34; method should not return a value&#xA;&#xA;# Noncompliant: a TypeError will be raised&#xA;class MyClass(object):&#xA;    def __init__(self):&#xA;        self.message = &#39;HelloWorld&#39;&#xA;        return self  &#xA;&#xA;# Compliant solution&#xA;class MyClass(object):&#xA;    def __init__(self):&#xA;        self.message = &#39;HelloWorld&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The mentioned code illustrates a bug pattern in Python where the &lt;strong&gt;init&lt;/strong&gt; method should not return a value.&lt;/p&gt; &#xA;&lt;h2&gt;Training&lt;/h2&gt; &#xA;&lt;h3&gt;Training Hyperparameters&lt;/h3&gt; &#xA;&lt;p&gt;Tokenizer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Byte Pair Encoding (BPE) based on bytecode&lt;/li&gt; &#xA; &lt;li&gt;Vocabulary size of 49,152&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Model Structure:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RoPE (Rotary Positional Embedding) for relative position encoding&lt;/li&gt; &#xA; &lt;li&gt;SwiGLU as the intermediate layer&lt;/li&gt; &#xA; &lt;li&gt;Grouped Query Attention&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Training Parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Structured FIM (Fill in the middle) training tasks make up 70% of the training, while autoregressive training tasks account for 30%&lt;/li&gt; &#xA; &lt;li&gt;Pretraining sequence length of 32,768&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Batch processing method&lt;/h3&gt; &#xA;&lt;p&gt;After preprocessing, our code data is organized by project, with the order of files within a project considering both rules and randomness. Specifically, we attempt to cluster similar or dependent code files together using methods like Calling Graph, K-Means clustering, file path similarity, and TF-IDF distance, to help the model better understand the relationships between code files. However, the ordering of code files also incorporates randomness, since in real programming scenarios, projects are not complete, and code files with similarities or dependencies may not be fully developed yet.&lt;/p&gt; &#xA;&lt;p&gt;By ensuring that the project code files overall exhibit randomness while locally having similar or dependent relationships, we stretch the project code files into a vector and organize the sequence of batches using the Transformer-XL style processing. Even though the sequence length of a single batch has already reached 32,768 during the pre-training process, this method still allows for the extension of the visible sequence length to be even longer.&lt;/p&gt; &#xA;&lt;h3&gt;Pre-training Tasks&lt;/h3&gt; &#xA;&lt;p&gt;Unlike other natural language large models or code models, in the context of code programming, aiXcoder considers the structural characteristics of code itself, aiming to have the model predict complete code nodes. In simple terms, the aiXcoder 7b training tasks combine the fill in the middle (FIM, Bavarian et al., 2022) and parser generator tool techniques. When constructing training data, we parse the code into an abstract syntax tree (AST) and randomly select a complete node to construct a FIM task. The rationale behind this approach is twofold: first, we need to ensure that the input data is relatively complete, with both the preceding and subsequent parts being at the same hierarchical level. Secondly, we also want the model&#39;s predictions to be more complete, with the generated code having a full hierarchical structure.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(20):&#xA;    if i % 5 == 0:&#xA;        print(&#34;Hello World&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/assets/graphviz.svg?sanitize=true&#34; alt=&#34;table_0&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Given that simple code can be parsed into an abstract syntax tree (AST), we will construct structured Fill In the Middle (FIM) training tasks based on the nodes of the AST.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;br&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;Suppose we select the IF node in the above AST, then we will construct training samples from the IF node and its subtree. The following two examples are equivalent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&#xA;# fill in the middle, SPM mode&#xA;&#34;&amp;lt;s&amp;gt;‚ñÅ&amp;lt;AIX-SPAN-PRE&amp;gt;‚ñÅ&amp;lt;AIX-SPAN-POST&amp;gt;        print(\&#34;Hello World\&#34;)\n‚ñÅ&amp;lt;AIX-SPAN-MIDDLE&amp;gt;# the file path is: test.py\n# the code file is written by Python\nfor i in range(20):\n    if i % 5 == 0:&amp;lt;\s&amp;gt;&#34;&#xA;&#xA;# fill in the middle, PSM mode&#xA;&#34;&amp;lt;s&amp;gt;‚ñÅ&amp;lt;AIX-SPAN-PRE&amp;gt;# the file path is: test.py\n# the code file is written by Python\nfor i in range(20):\n    if ‚ñÅ&amp;lt;AIX-SPAN-POST&amp;gt;        print(\&#34;Hello World\&#34;)\n‚ñÅ&amp;lt;AIX-SPAN-MIDDLE&amp;gt;i % 5 == 0:&amp;lt;\s&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Details of Experimental Results&lt;/h2&gt; &#xA;&lt;h3&gt;NL2Code Benchmarks&lt;/h3&gt; &#xA;&lt;p&gt;Table 1 shows the performance of the aiXcoder-7B Base model on standalone method generation benchmarks. Our model achieves the current best results among the large-scale pre-trained base models within hundreds of billions of parameters.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/assets/table_1.png&#34; alt=&#34;table_1&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Code Completion (Fill in the Middle)&lt;/h3&gt; &#xA;&lt;p&gt;Different from the standalone nl2code task in Table 1, in real-world programming scenarios, we need to consider the code completion capability in the context of the cursor position. Generally, various open-source large language models for code incorporate the Fill in the Middle (FIM) mode during pre-training to enhance the model&#39;s ability to generate more accurate results when considering the code context. Therefore, we will use FIM as the default code completion method to evaluate the performance of each model in real-world programming scenarios.&lt;/p&gt; &#xA;&lt;p&gt;Currently, the mainstream evaluation dataset for context-aware code completion is the single-line evaluation method proposed by Santacoder (Ben Allal et al., 2023). This evaluation dataset extracts single lines of code from HumanEval or MultiPL-E and evaluates the Exact Match metric of the model&#39;s generated results, given the complete preceding and following context.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/assets/table_2.png&#34; alt=&#34;table_2&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;To further evaluate the code completion capabilities of large language models for code in a more fine-grained manner, aiXcoder has built an evaluation dataset that is larger in size, more diverse in the code being tested, longer in the context length of the code being tested, and closer to real-world development projects. This evaluation dataset will also be open-sourced on GitHub simultaneously. During the evaluation process, we ensure that different large language models for code use the same maximum sequence length of 16K and evaluate the generation performance in different scenarios, such as generating complete method blocks, conditional blocks, loop processing blocks, exception handling blocks, and a total of thirteen cases.&lt;/p&gt; &#xA;&lt;p&gt;Table 3 shows the average generation performance of different models in different languages. The final evaluation results are the average of all completion scenarios and evaluation samples. The aiXcoder 7B Base model achieves the best performance across major programming languages and various evaluation criteria, indicating that aiXcoder 7B Base has the best basic code completion capability among all open-source models of the same scale and is the most suitable base model for providing code completion capabilities in real-world programming scenarios.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/assets/table_3.png&#34; alt=&#34;table_3&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;For each evaluation result in Table 3, there are more detailed evaluation dimensions. Tables 4 to 7 show the details of the multi-dimensional evaluation of different models in different languages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Method signature&lt;/strong&gt; indicates the model&#39;s capability to generate method signatures based on context.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Method body&lt;/strong&gt; represents the model&#39;s ability to generate a complete method body based on context, including the function signature.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Single line&lt;/strong&gt; refers to the completion of single lines of code.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Method with comment&lt;/strong&gt; denotes generating a corresponding function body based on context, including function signatures and comments.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Empty&lt;/strong&gt; indicates the model&#39;s ability to predict emptiness in the case of complete context.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Method body top, mid, bottom&lt;/strong&gt; show the code generation performance respectively in the upper part of the function body, the middle part, and the lower part.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;If, for, while, try, switch statement&lt;/strong&gt; represent the effects of generating conditional code blocks, loop code blocks, exception catch blocks, and conditional branch blocks.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/assets/table_4.png&#34; alt=&#34;table_4&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/assets/table_5.png&#34; alt=&#34;table_5&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/assets/table_6.png&#34; alt=&#34;table_6&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/assets/table_7.png&#34; alt=&#34;table_7&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Cross-file Code Evaluation&lt;/h3&gt; &#xA;&lt;p&gt;Another important capability of large language models for code is the ability to understand code context across files, as developers often need to consider information from other files within the current project when writing code. Therefore, we adopted the CrossCodeEval (Ding et al., 2023) evaluation dataset to assess the model&#39;s ability to extract cross-file contextual information.&lt;/p&gt; &#xA;&lt;p&gt;In Table 8, we fix the context length for all models at 16K and format the input using the PSM pattern in FIM. After the model completes inference, all output results are decoded using Greedy Search. First, as a baseline, we evaluate the generation capabilities of various large code models in a single-file scenario.&lt;/p&gt; &#xA;&lt;p&gt;Then, using BM25 as the similarity metric, we search for the three most similar code blocks within the project as prompts to reassess the model&#39;s generation performance. Finally, &#34;w/Ref.&#34; indicates that we assume we know what the correct Reference code looks like, and then search for the three most similar codes within the project as prompts to re-evaluate the model&#39;s generation performance.&lt;/p&gt; &#xA;&lt;p&gt;Ultimately, the aiXcoder-7B model performs very well in all languages, demonstrating our model&#39;s ability to extract contextual information, especially cross-file contextual information.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/assets/table_8.png&#34; alt=&#34;table_8&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The source code in this repository is licensed under the &lt;a href=&#34;https://www.apache.org/licenses/LICENSE-2.0&#34;&gt;Apache-2.0&lt;/a&gt; License - see the LICENSE file for details. The model weights are licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/aixcoder-plugin/aiXcoder-7B/main/MODEL_LICENSE&#34;&gt;Model License&lt;/a&gt; for academic research use; for commercial use, please apply by sending an email to &lt;a href=&#34;mailto:support@aiXcoder.com&#34;&gt;support@aiXcoder.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;We would like to thank all contributors to the open-source projects and datasets that made this work possible.&lt;/p&gt; &#xA;&lt;p&gt;Thank you for your interest in our Code Large Language Model. We look forward to your contributions and feedback!&lt;/p&gt;</summary>
  </entry>
</feed>