<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Python Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-08T01:43:22Z</updated>
  <subtitle>Daily Trending of Python in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>helblazer811/ManimML</title>
    <updated>2023-01-08T01:43:22Z</updated>
    <id>tag:github.com,2023-01-08:/helblazer811/ManimML</id>
    <link href="https://github.com/helblazer811/ManimML" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ManimML is a project focused on providing animations and visualizations of common machine learning concepts with the Manim Community Library.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ManimML&lt;/h1&gt; &#xA;&lt;a href=&#34;https://github.com/helblazer811/ManimMachineLearning&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/helblazer811/ManimML/main/examples/media/ManimMLLogo.gif&#34;&gt; &lt;/a&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/helblazer811/ManimMachineLearning/raw/main/LICENSE.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/helblazer811/ManimMachineLearning&#34; alt=&#34;GitHub license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://img.shields.io/github/v/release/helblazer811/ManimMachineLearning&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/helblazer811/ManimMachineLearning&#34; alt=&#34;GitHub tag&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/pypi/dm/manim-ml&#34; alt=&#34;Pypi Downloads&#34;&gt; &lt;a href=&#34;https://twitter.com/alec_helbling&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/alec_helbling?style=social&#34; alt=&#34;Follow Twitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;ManimML is a project focused on providing animations and visualizations of common machine learning concepts with the &lt;a href=&#34;https://www.manim.community/&#34;&gt;Manim Community Library&lt;/a&gt;. We want this project to be a compilation of primitive visualizations that can be easily combined to create videos about complex machine learning concepts. Additionally, we want to provide a set of abstractions which allow users to focus on explanations instead of software engineering.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/helblazer811/ManimML/main/#getting-started&#34;&gt;Getting Started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/helblazer811/ManimML/main/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;First you will want to &lt;a href=&#34;https://docs.manim.community/en/stable/installation.html&#34;&gt;install manim&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Then install the package form source or &lt;code&gt;pip install manim_ml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then you can run the following to generate the example videos from python scripts.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;manim -pqh src/vae.py VAEScene&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Checkout the &lt;code&gt;examples&lt;/code&gt; directory for some example videos with source code.&lt;/p&gt; &#xA;&lt;h3&gt;Neural Networks&lt;/h3&gt; &#xA;&lt;p&gt;This is a visualization of a Variational Autoencoder made using ManimML. It has a Pytorch style list of layers that can be composed in arbitrary order. The following video is made with the code from below.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/helblazer811/ManimML/main/examples/media/VAEScene.gif&#34;&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class VariationalAutoencoderScene(Scene):&#xA;&#xA;    def construct(self):&#xA;        embedding_layer = EmbeddingLayer(dist_theme=&#34;ellipse&#34;).scale(2)&#xA;        &#xA;        image = Image.open(&#39;images/image.jpeg&#39;)&#xA;        numpy_image = np.asarray(image)&#xA;        # Make nn&#xA;        neural_network = NeuralNetwork([&#xA;            ImageLayer(numpy_image, height=1.4),&#xA;            FeedForwardLayer(5),&#xA;            FeedForwardLayer(3),&#xA;            embedding_layer,&#xA;            FeedForwardLayer(3),&#xA;            FeedForwardLayer(5),&#xA;            ImageLayer(numpy_image, height=1.4),&#xA;        ], layer_spacing=0.1)&#xA;&#xA;        neural_network.scale(1.3)&#xA;&#xA;        self.play(Create(neural_network))&#xA;        self.play(neural_network.make_forward_pass_animation(run_time=15))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Convolutional Neural Network&lt;/h3&gt; &#xA;&lt;p&gt;This is a visualization of a Convolutional Neural Network.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/helblazer811/ManimML/main/examples/media/CNNScene.gif&#34;&gt; &#xA;&lt;h3&gt;Generative Adversarial Network&lt;/h3&gt; &#xA;&lt;p&gt;This is a visualization of a Generative Adversarial Network made using ManimML.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/helblazer811/ManimML/main/examples/media/GANScene.gif&#34;&gt; &#xA;&lt;h3&gt;VAE Disentanglement&lt;/h3&gt; &#xA;&lt;p&gt;This is a visualization of disentanglement with a Variational Autoencoder&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/helblazer811/ManimML/main/examples/media/DisentanglementScene.gif&#34;&gt;</summary>
  </entry>
  <entry>
    <title>flet-dev/flet</title>
    <updated>2023-01-08T01:43:22Z</updated>
    <id>tag:github.com,2023-01-08:/flet-dev/flet</id>
    <link href="https://github.com/flet-dev/flet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Flet enables developers to easily build realtime web, mobile and desktop apps in Python. No frontend experience required.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Flet&lt;/h1&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/flet-dev/flet/main/media/logo/flet-logo.svg?sanitize=true&#34; width=&#34;50%&#34;&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ci.appveyor.com/project/flet-dev/flet/branch/main&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/xwablctxslvey576/branch/main?svg=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Flet is a framework that enables you to easily build realtime web, mobile and desktop apps in your favorite language and securely share them with your team. No frontend experience required.&lt;/p&gt; &#xA;&lt;h3&gt;‚ö°From idea to app in minutes&lt;/h3&gt; &#xA;&lt;p&gt;An internal tool or a dashboard for your team, weekend project, data entry form, kiosk app or high-fidelity prototype - Flet is an ideal framework to quickly hack a great-looking interactive apps to serve a group of users.&lt;/p&gt; &#xA;&lt;h3&gt;üìê Simple architecture&lt;/h3&gt; &#xA;&lt;p&gt;No more complex architecture with JavaScript frontend, REST API backend, database, cache, etc. With Flet you just write a monolith stateful app in Python only and get multi-user, realtime Single-Page Application (SPA).&lt;/p&gt; &#xA;&lt;h3&gt;üîãBatteries included&lt;/h3&gt; &#xA;&lt;p&gt;To start developing with Flet, you just need your favorite IDE or text editor. No SDKs, no thousands of dependencies, no complex tooling - Flet has built-in web server with assets hosting and desktop clients.&lt;/p&gt; &#xA;&lt;h3&gt;&amp;nbsp;&lt;img src=&#34;https://raw.githubusercontent.com/flet-dev/flet/main/media/flutter/icon_flutter.svg?sanitize=true&#34; height=&#34;20px&#34;&gt;&amp;nbsp;&amp;nbsp;Powered by Flutter&lt;/h3&gt; &#xA;&lt;p&gt;Flet UI is built with &lt;a href=&#34;https://flutter.dev/&#34;&gt;Flutter&lt;/a&gt;, so your app looks professional and could be delivered to any platform. Flet simplifies Flutter model by combining smaller &#34;widgets&#34; to ready-to-use &#34;controls&#34; with imperative programming model.&lt;/p&gt; &#xA;&lt;h3&gt;üåê Speaks your language&lt;/h3&gt; &#xA;&lt;p&gt;Flet is language-agnostic, so anyone on your team could develop Flet apps in their favorite language. &lt;a href=&#34;https://flet.dev/docs/guides/python/getting-started&#34;&gt;Python&lt;/a&gt; is already supported, Go, C# and others are &lt;a href=&#34;https://flet.dev/docs/roadmap&#34;&gt;coming next&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;üì± Deliver to any device&lt;/h3&gt; &#xA;&lt;p&gt;Deploy Flet app as a web app and view it in a browser. Package it as a standalone desktop app for Windows, macOS and Linux. Install it on mobile as &lt;a href=&#34;https://web.dev/what-are-pwas/&#34;&gt;PWA&lt;/a&gt; or view via Flet app for iOS and Android.&lt;/p&gt; &#xA;&lt;h2&gt;Flet app example&lt;/h2&gt; &#xA;&lt;p&gt;At the moment you can write Flet apps in Python and other languages will be added soon.&lt;/p&gt; &#xA;&lt;p&gt;Here is a sample &#34;Counter&#34; app:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import flet&#xA;from flet import IconButton, Page, Row, TextField, icons&#xA;&#xA;def main(page: Page):&#xA;    page.title = &#34;Flet counter example&#34;&#xA;    page.vertical_alignment = &#34;center&#34;&#xA;&#xA;    txt_number = TextField(value=&#34;0&#34;, text_align=&#34;right&#34;, width=100)&#xA;&#xA;    def minus_click(e):&#xA;        txt_number.value = int(txt_number.value) - 1&#xA;        page.update()&#xA;&#xA;    def plus_click(e):&#xA;        txt_number.value = int(txt_number.value) + 1&#xA;        page.update()&#xA;&#xA;    page.add(&#xA;        Row(&#xA;            [&#xA;                IconButton(icons.REMOVE, on_click=minus_click),&#xA;                txt_number,&#xA;                IconButton(icons.ADD, on_click=plus_click),&#xA;            ],&#xA;            alignment=&#34;center&#34;,&#xA;        )&#xA;    )&#xA;&#xA;flet.app(target=main)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run the app install &lt;code&gt;flet&lt;/code&gt; module:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install flet&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and run the program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python counter.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The app will be started in a native OS window - what a nice alternative to Electron!&lt;/p&gt; &#xA;&lt;img src=&#34;https://flet.dev/img/docs/getting-started/flet-counter-macos.png&#34; width=&#34;45%&#34;&gt; &#xA;&lt;p&gt;Now, if you want to run the app as a web app, just replace the last line with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;flet.app(target=main, view=flet.WEB_BROWSER)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;run again and now you instantly get a web app:&lt;/p&gt; &#xA;&lt;img src=&#34;https://flet.dev/img/docs/getting-started/flet-counter-safari.png&#34; width=&#34;60%&#34;&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://flet.dev/docs/guides/python/getting-started&#34;&gt;Creating Flet apps in Python&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://flet.dev/docs/controls&#34;&gt;Controls reference&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Sample apps in Python&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/flet-dev/examples/raw/main/python/apps/greeter/greeter.py&#34;&gt;Greeter&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/flet-dev/examples/raw/main/python/apps/counter/counter.py&#34;&gt;Counter&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/flet-dev/examples/raw/main/python/apps/todo/todo.py&#34;&gt;To-Do&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/flet-dev/examples/raw/main/python/apps/icons-browser/main.py&#34;&gt;Icons Browser&lt;/a&gt; (&lt;a href=&#34;https://flet-icons-browser.fly.dev/&#34;&gt;Online Demo&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/flet-dev/flet/discussions&#34;&gt;Discussions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://discord.gg/dzWXP8SHG8&#34;&gt;Discord&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/fletdev&#34;&gt;Twitter&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;mailto:hello@flet.dev&#34;&gt;Email&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contribute to this wonderful project&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Read the &lt;a href=&#34;https://github.com/flet-dev/flet/raw/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; file&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>8080labs/ppscore</title>
    <updated>2023-01-08T01:43:22Z</updated>
    <id>tag:github.com,2023-01-08:/8080labs/ppscore</id>
    <link href="https://github.com/8080labs/ppscore" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Predictive Power Score (PPS) in Python&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ppscore - a Python implementation of the Predictive Power Score (PPS)&lt;/h1&gt; &#xA;&lt;h3&gt;From the makers of &lt;a href=&#34;https://bamboolib.com&#34;&gt;bamboolib - a GUI for pandas DataFrames&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;If you don&#39;t know yet what the Predictive Power Score is, please read the following blog post:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://towardsdatascience.com/rip-correlation-introducing-the-predictive-power-score-3d90808b9598?sk=7ac6697576053896fb27d3356dd6db32&#34;&gt;RIP correlation. Introducing the Predictive Power Score&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The PPS is an asymmetric, data-type-agnostic score that can detect linear or non-linear relationships between two columns. The score ranges from 0 (no predictive power) to 1 (perfect predictive power). It can be used as an alternative to the correlation (matrix).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/8080labs/ppscore/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/8080labs/ppscore/master/#getting-started&#34;&gt;Getting started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/8080labs/ppscore/master/#api&#34;&gt;API&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/8080labs/ppscore/master/#calculation-of-the-pps&#34;&gt;Calculation of the PPS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/8080labs/ppscore/master/#about&#34;&gt;About&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;You need Python 3.6 or above.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;From the terminal (or Anaconda prompt in Windows), enter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install -U ppscore&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The examples refer to the newest version (1.2.0) of ppscore. &lt;a href=&#34;https://github.com/8080labs/ppscore/raw/master/CHANGELOG.md&#34;&gt;See changes&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;First, let&#39;s create some data:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd&#xA;import numpy as np&#xA;import ppscore as pps&#xA;&#xA;df = pd.DataFrame()&#xA;df[&#34;x&#34;] = np.random.uniform(-2, 2, 1_000_000)&#xA;df[&#34;error&#34;] = np.random.uniform(-0.5, 0.5, 1_000_000)&#xA;df[&#34;y&#34;] = df[&#34;x&#34;] * df[&#34;x&#34;] + df[&#34;error&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Based on the dataframe we can calculate the PPS of x predicting y:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pps.score(df, &#34;x&#34;, &#34;y&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can calculate the PPS of all the predictors in the dataframe against a target y:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pps.predictors(df, &#34;y&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is how we can calculate the PPS matrix between all columns:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pps.matrix(df)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Visualization of the results&lt;/h3&gt; &#xA;&lt;p&gt;For the visualization of the results you can use seaborn or your favorite viz library.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Plotting the PPS predictors:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import seaborn as sns&#xA;predictors_df = pps.predictors(df, y=&#34;y&#34;)&#xA;sns.barplot(data=predictors_df, x=&#34;x&#34;, y=&#34;ppscore&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Plotting the PPS matrix:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;(This needs some minor preprocessing because seaborn.heatmap unfortunately does not accept tidy data)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import seaborn as sns&#xA;matrix_df = pps.matrix(df)[[&#39;x&#39;, &#39;y&#39;, &#39;ppscore&#39;]].pivot(columns=&#39;x&#39;, index=&#39;y&#39;, values=&#39;ppscore&#39;)&#xA;sns.heatmap(matrix_df, vmin=0, vmax=1, cmap=&#34;Blues&#34;, linewidths=0.5, annot=True)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;h3&gt;ppscore.score(df, x, y, sample=5_000, cross_validation=4, random_seed=123, invalid_score=0, catch_errors=True)&lt;/h3&gt; &#xA;&lt;p&gt;Calculate the Predictive Power Score (PPS) for &#34;x predicts y&#34;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The score always ranges from 0 to 1 and is data-type agnostic.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A score of 0 means that the column x cannot predict the column y better than a naive baseline model.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A score of 1 means that the column x can perfectly predict the column y given the model.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A score between 0 and 1 states the ratio of how much potential predictive power the model achieved compared to the baseline model.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Parameters&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;df&lt;/strong&gt; : pandas.DataFrame &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Dataframe that contains the columns x and y&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;x&lt;/strong&gt; : str &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Name of the column x which acts as the feature&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;y&lt;/strong&gt; : str &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Name of the column y which acts as the target&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;sample&lt;/strong&gt; : int or &lt;code&gt;None&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Number of rows for sampling. The sampling decreases the calculation time of the PPS. If &lt;code&gt;None&lt;/code&gt; there will be no sampling.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;cross_validation&lt;/strong&gt; : int &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Number of iterations during cross-validation. This has the following implications: For example, if the number is 4, then it is possible to detect patterns when there are at least 4 times the same observation. If the limit is increased, the required minimum observations also increase. This is important, because this is the limit when sklearn will throw an error and the PPS cannot be calculated&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;random_seed&lt;/strong&gt; : int or &lt;code&gt;None&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Random seed for the parts of the calculation that require random numbers, e.g. shuffling or sampling. If the value is set, the results will be reproducible. If the value is &lt;code&gt;None&lt;/code&gt; a new random number is drawn at the start of each calculation.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;invalid_score&lt;/strong&gt; : any &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The score that is returned when a calculation is not valid, e.g. because the data type was not supported.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;catch_errors&lt;/strong&gt; : bool &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If &lt;code&gt;True&lt;/code&gt; all errors will be catched and reported as &lt;code&gt;unknown_error&lt;/code&gt; which ensures convenience. If &lt;code&gt;False&lt;/code&gt; errors will be raised. This is helpful for inspecting and debugging errors.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Returns&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Dict&lt;/strong&gt;: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A dict that contains multiple fields about the resulting PPS. The dict enables introspection into the calculations that have been performed under the hood&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;ppscore.predictors(df, y, output=&#34;df&#34;, sorted=True, **kwargs)&lt;/h3&gt; &#xA;&lt;p&gt;Calculate the Predictive Power Score (PPS) for all columns in the dataframe against a target (y) column&lt;/p&gt; &#xA;&lt;h4&gt;Parameters&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;df&lt;/strong&gt; : pandas.DataFrame &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The dataframe that contains the data&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;y&lt;/strong&gt; : str &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Name of the column y which acts as the target&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;output&lt;/strong&gt; : str - potential values: &#34;df&#34;, &#34;list&#34; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Control the type of the output. Either return a df or a list with all the PPS score dicts&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;sorted&lt;/strong&gt; : bool &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Whether or not to sort the output dataframe/list by the ppscore&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;kwargs&lt;/strong&gt; : &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Other key-word arguments that shall be forwarded to the pps.score method, e.g. &lt;strong&gt;sample&lt;/strong&gt;, &lt;strong&gt;cross_validation&lt;/strong&gt;, &lt;strong&gt;random_seed&lt;/strong&gt;, &lt;strong&gt;invalid_score&lt;/strong&gt;, &lt;strong&gt;catch_errors&lt;/strong&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Returns&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;pandas.DataFrame&lt;/strong&gt; or list of PPS dicts: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Either returns a df or a list of all the PPS dicts. This can be influenced by the output argument&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;ppscore.matrix(df, output=&#34;df&#34;, sorted=False, **kwargs)&lt;/h3&gt; &#xA;&lt;p&gt;Calculate the Predictive Power Score (PPS) matrix for all columns in the dataframe&lt;/p&gt; &#xA;&lt;h4&gt;Parameters&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;df&lt;/strong&gt; : pandas.DataFrame &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The dataframe that contains the data&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;output&lt;/strong&gt; : str - potential values: &#34;df&#34;, &#34;list&#34; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Control the type of the output. Either return a df or a list with all the PPS score dicts&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;sorted&lt;/strong&gt; : bool &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Whether or not to sort the output dataframe/list by the ppscore&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;kwargs&lt;/strong&gt; : &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Other key-word arguments that shall be forwarded to the pps.score method, e.g. &lt;strong&gt;sample&lt;/strong&gt;, &lt;strong&gt;cross_validation&lt;/strong&gt;, &lt;strong&gt;random_seed&lt;/strong&gt;, &lt;strong&gt;invalid_score&lt;/strong&gt;, &lt;strong&gt;catch_errors&lt;/strong&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Returns&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;pandas.DataFrame&lt;/strong&gt; or list of PPS dicts: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Either returns a df or a list of all the PPS dicts. This can be influenced by the output argument&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Calculation of the PPS&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If you are uncertain about some details, feel free to jump into the code to have a look at the exact implementation&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;There are multiple ways how you can calculate the PPS. The ppscore package provides a sample implementation that is based on the following calculations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The score is calculated using only 1 feature trying to predict the target column. This means there are no interaction effects between the scores of various features. Note that this is in contrast to feature importance&lt;/li&gt; &#xA; &lt;li&gt;The score is calculated on the test sets of a 4-fold cross-validation (number is adjustable via &lt;code&gt;cross_validation&lt;/code&gt;). For classification, stratifiedKFold is used. For regression, normal KFold. Please note that &lt;strong&gt;this sampling might not be valid for time series data sets&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;All rows which have a missing value in the feature or the target column are dropped&lt;/li&gt; &#xA; &lt;li&gt;In case that the dataset has more than 5,000 rows the score is only calculated on a random subset of 5,000 rows. You can adjust the number of rows or skip this sampling via &lt;code&gt;sample&lt;/code&gt;. However, in most scenarios the results will be very similar&lt;/li&gt; &#xA; &lt;li&gt;There is no grid search for optimal model parameters&lt;/li&gt; &#xA; &lt;li&gt;The result might change between calculations because the calculation contains random elements, e.g. the sampling of the rows or the shuffling of the rows before cross-validation. If you want to make sure that your results are reproducible you can set the random seed (&lt;code&gt;random_seed&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;If the score cannot be calculated, the package will not raise an error but return an object where &lt;code&gt;is_valid_score&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;. The reported score will be &lt;code&gt;invalid_score&lt;/code&gt;. We chose this behavior because we want to give you a quick overview where significant predictive power exists without you having to handle errors or edge cases. However, when you want to explicitly handle the errors, you can still do so.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Learning algorithm&lt;/h3&gt; &#xA;&lt;p&gt;As a learning algorithm, we currently use a Decision Tree because the Decision Tree has the following properties:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;can detect any non-linear bivariate relationship&lt;/li&gt; &#xA; &lt;li&gt;good predictive power in a wide variety of use cases&lt;/li&gt; &#xA; &lt;li&gt;low requirements for feature preprocessing&lt;/li&gt; &#xA; &lt;li&gt;robust model which can handle outliers and does not easily overfit&lt;/li&gt; &#xA; &lt;li&gt;can be used for classification and regression&lt;/li&gt; &#xA; &lt;li&gt;can be calculated quicker than many other algorithms&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We differentiate the exact implementation based on the data type of the target column:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If the target column is numeric, we use the sklearn.DecisionTreeRegressor&lt;/li&gt; &#xA; &lt;li&gt;If the target column is categoric, we use the sklearn.DecisionTreeClassifier&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Please note that we prefer a general good performance on a wide variety of use cases over better performance in some narrow use cases. If you have a proposal for a better/different learning algorithm, please open an issue&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;However, please note why we actively decided against the following algorithms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Correlation or Linear Regression: cannot detect non-linear bivariate relationships without extensive preprocessing&lt;/li&gt; &#xA; &lt;li&gt;GAMs: might have problems with very unsmooth functions&lt;/li&gt; &#xA; &lt;li&gt;SVM: potentially bad performance if the wrong kernel is selected&lt;/li&gt; &#xA; &lt;li&gt;Random Forest/Gradient Boosted Tree: slower than a single Decision Tree&lt;/li&gt; &#xA; &lt;li&gt;Neural Networks and Deep Learning: slower calculation than a Decision Tree and also needs more feature preprocessing&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Data preprocessing&lt;/h3&gt; &#xA;&lt;p&gt;Even though the Decision Tree is a very flexible learning algorithm, we need to perform the following preprocessing steps if a column represents categoric values - that means it has the pandas dtype &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;category&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;boolean&lt;/code&gt;.‚Äå&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If the target column is categoric, we use the &lt;code&gt;sklearn.LabelEncoder‚Äã&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;If the feature column is categoric, we use the &lt;code&gt;sklearn.OneHotEncoder‚Äã&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Choosing the prediction case&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;This logic was updated in version 1.0.0.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The choice of the case (&lt;code&gt;classification&lt;/code&gt; or &lt;code&gt;regression&lt;/code&gt;) has an influence on the final PPS and thus it is important that the correct case is chosen. The case is chosen based on the data types of the columns. That means, e.g. if you want to change the case from &lt;code&gt;regression&lt;/code&gt; to &lt;code&gt;classification&lt;/code&gt; that you have to change the data type from &lt;code&gt;float&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here are the two main cases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A &lt;strong&gt;classification&lt;/strong&gt; is chosen if the target has the dtype &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;category&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;boolean&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;A &lt;strong&gt;regression&lt;/strong&gt; is chosen if the target has the dtype &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Cases and their score metrics‚Äã&lt;/h3&gt; &#xA;&lt;p&gt;Each case uses a different evaluation score for calculating the final predictive power score (PPS).&lt;/p&gt; &#xA;&lt;h4&gt;Regression&lt;/h4&gt; &#xA;&lt;p&gt;In case of an regression, the ppscore uses the mean absolute error (MAE) as the underlying evaluation metric (MAE_model). The best possible score of the MAE is 0 and higher is worse. As a baseline score, we calculate the MAE of a naive model (MAE_naive) that always predicts the median of the target column. The PPS is the result of the following normalization (and never smaller than 0):&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;PPS = 1 - (MAE_model / MAE_naive)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Classification&lt;/h4&gt; &#xA;&lt;p&gt;If the task is a classification, we compute the weighted F1 score (wF1) as the underlying evaluation metric (F1_model). The F1 score can be interpreted as a weighted average of the precision and recall, where an F1 score reaches its best value at 1 and worst score at 0. The relative contribution of precision and recall to the F1 score are equal. The weighted F1 takes into account the precision and recall of all classes weighted by their support as described &lt;a href=&#34;https://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html&#34;&gt;here&lt;/a&gt;. As a baseline score (F1_naive), we calculate the weighted F1 score for a model that always predicts the most common class of the target column (F1_most_common) and a model that predicts random values (F1_random). F1_naive is set to the maximum of F1_most_common and F1_random. The PPS is the result of the following normalization (and never smaller than 0):&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;PPS = (F1_model - F1_naive) / (1 - F1_naive)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Special cases&lt;/h3&gt; &#xA;&lt;p&gt;There are various cases in which the PPS can be defined without fitting a model to save computation time or in which the PPS cannot be calculated at all. Those cases are described below.&lt;/p&gt; &#xA;&lt;h4&gt;Valid scores&lt;/h4&gt; &#xA;&lt;p&gt;In the following cases, the PPS is defined but we can save ourselves the computation time:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;feature_is_id&lt;/strong&gt; means that the feature column is categoric (see above for &lt;strong&gt;classification&lt;/strong&gt;) and that all categories appear only once. Such a feature can never predict a target during cross-validation and thus the PPS is 0.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;target_is_id&lt;/strong&gt; means that the target column is categoric (see above for &lt;strong&gt;classification&lt;/strong&gt;) and that all categories appear only once. Thus, the PPS is 0 because an ID column cannot be predicted by any other column as part of a cross-validation. There still might be a 1 to 1 relationship but this is not detectable by the current implementation of the PPS.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;target_is_constant&lt;/strong&gt; means that the target column only has a single value and thus the PPS is 0 because any column and baseline can perfectly predict a column that only has a single value. Therefore, the feature does not add any predictive power and we want to communicate that.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;predict_itself&lt;/strong&gt; means that the feature and target columns are the same and thus the PPS is 1 because a column can always perfectly predict its own value. Also, this leads to the typical diagonal of 1 that we are used to from the correlation matrix.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Invalid scores and other errors&lt;/h4&gt; &#xA;&lt;p&gt;In the following cases, the PPS is not defined and the score is set to &lt;code&gt;invalid_score&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;target_is_datetime&lt;/strong&gt; means that the target column has a datetime data type which is not supported. A possible solution might be to convert the target column to a string column.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;target_data_type_not_supported&lt;/strong&gt; means that the target column has a data type which is not supported. A possible solution might be to convert the target column to another data type.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;empty_dataframe_after_dropping_na&lt;/strong&gt; occurs when there are no valid rows left after rows with missing values have been dropped. A possible solution might be to replace the missing values with valid values.&lt;/li&gt; &#xA; &lt;li&gt;Last but not least, &lt;strong&gt;unknown_error&lt;/strong&gt; occurs for all other errors that might raise an exception. This case is only reported when &lt;code&gt;catch_errors&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;. If you want to inspect or debug the underlying error, please set &lt;code&gt;catch_errors&lt;/code&gt; to &lt;code&gt;False&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Citing ppscore&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://zenodo.org/badge/latestdoi/256518683&#34;&gt;&lt;img src=&#34;https://zenodo.org/badge/256518683.svg?sanitize=true&#34; alt=&#34;DOI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;ppscore is developed by &lt;a href=&#34;https://8080labs.com&#34;&gt;8080 Labs&lt;/a&gt; - we create tools for Python Data Scientists. If you like &lt;code&gt;ppscore&lt;/code&gt; you might want to check out our other project &lt;a href=&#34;https://bamboolib.com&#34;&gt;bamboolib - a GUI for pandas DataFrames&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>