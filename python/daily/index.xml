<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Python Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-18T01:34:58Z</updated>
  <subtitle>Daily Trending of Python in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>facebookresearch/vggt</title>
    <updated>2025-06-18T01:34:58Z</updated>
    <id>tag:github.com,2025-06-18:/facebookresearch/vggt</id>
    <link href="https://github.com/facebookresearch/vggt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;[CVPR 2025 Best Paper Award] VGGT: Visual Geometry Grounded Transformer&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;VGGT: Visual Geometry Grounded Transformer&lt;/h1&gt; &#xA; &lt;a href=&#34;https://jytime.github.io/data/VGGT_CVPR25.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Paper-VGGT&#34; alt=&#34;Paper PDF&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;https://arxiv.org/abs/2503.11651&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/arXiv-2503.11651-b31b1b&#34; alt=&#34;arXiv&#34;&gt;&lt;/a&gt; &#xA; &lt;a href=&#34;https://vgg-t.github.io/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Project_Page-green&#34; alt=&#34;Project Page&#34;&gt;&lt;/a&gt; &#xA; &lt;a href=&#34;https://huggingface.co/spaces/facebook/vggt&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/%F0%9F%A4%97%20Hugging%20Face-Demo-blue&#34;&gt;&lt;/a&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://www.robots.ox.ac.uk/~vgg/&#34;&gt;Visual Geometry Group, University of Oxford&lt;/a&gt;&lt;/strong&gt;; &lt;strong&gt;&lt;a href=&#34;https://ai.facebook.com/research/&#34;&gt;Meta AI&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://jytime.github.io/&#34;&gt;Jianyuan Wang&lt;/a&gt;, &lt;a href=&#34;https://silent-chen.github.io/&#34;&gt;Minghao Chen&lt;/a&gt;, &lt;a href=&#34;https://nikitakaraevv.github.io/&#34;&gt;Nikita Karaev&lt;/a&gt;, &lt;a href=&#34;https://www.robots.ox.ac.uk/~vedaldi/&#34;&gt;Andrea Vedaldi&lt;/a&gt;, &lt;a href=&#34;https://chrirupp.github.io/&#34;&gt;Christian Rupprecht&lt;/a&gt;, &lt;a href=&#34;https://d-novotny.github.io/&#34;&gt;David Novotny&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@inproceedings{wang2025vggt,&#xA;  title={VGGT: Visual Geometry Grounded Transformer},&#xA;  author={Wang, Jianyuan and Chen, Minghao and Karaev, Nikita and Vedaldi, Andrea and Rupprecht, Christian and Novotny, David},&#xA;  booktitle={Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition},&#xA;  year={2025}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Updates&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[June 13, 2025] Honored to receive the Best Paper Award at CVPR 2025! Apologies if I’m slow to respond to queries or GitHub issues these days. If you’re interested, our oral presentation is available &lt;a href=&#34;https://docs.google.com/presentation/d/1JVuPnuZx6RgAy-U5Ezobg73XpBi7FrOh/edit?usp=sharing&amp;amp;ouid=107115712143490405606&amp;amp;rtpof=true&amp;amp;sd=true&#34;&gt;here&lt;/a&gt;. (Note: it’s shared in .pptx format with animations — quite large, but feel free to use it as a template if helpful.)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[June 2, 2025] Added a script to run VGGT and save predictions in COLMAP format, with bundle adjustment support optional. The saved COLMAP files can be directly used with &lt;a href=&#34;https://github.com/nerfstudio-project/gsplat&#34;&gt;gsplat&lt;/a&gt; or other NeRF/Gaussian splatting libraries.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[May 3, 2025] Evaluation code for reproducing our camera pose estimation results on Co3D is now available in the &lt;a href=&#34;https://github.com/facebookresearch/vggt/tree/evaluation&#34;&gt;evaluation&lt;/a&gt; branch.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[Apr 13, 2025] Training code is being gradually cleaned and uploaded to the &lt;a href=&#34;https://github.com/facebookresearch/vggt/tree/training&#34;&gt;training&lt;/a&gt; branch. It will be merged into the main branch once finalized.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Visual Geometry Grounded Transformer (VGGT, CVPR 2025) is a feed-forward neural network that directly infers all key 3D attributes of a scene, including extrinsic and intrinsic camera parameters, point maps, depth maps, and 3D point tracks, &lt;strong&gt;from one, a few, or hundreds of its views, within seconds&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;First, clone this repository to your local machine, and install the dependencies (torch, torchvision, numpy, Pillow, and huggingface_hub).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git@github.com:facebookresearch/vggt.git &#xA;cd vggt&#xA;pip install -r requirements.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can install VGGT as a package (&lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/vggt/main/docs/package.md&#34;&gt;click here&lt;/a&gt; for details).&lt;/p&gt; &#xA;&lt;p&gt;Now, try the model with just a few lines of code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch&#xA;from vggt.models.vggt import VGGT&#xA;from vggt.utils.load_fn import load_and_preprocess_images&#xA;&#xA;device = &#34;cuda&#34; if torch.cuda.is_available() else &#34;cpu&#34;&#xA;# bfloat16 is supported on Ampere GPUs (Compute Capability 8.0+) &#xA;dtype = torch.bfloat16 if torch.cuda.get_device_capability()[0] &amp;gt;= 8 else torch.float16&#xA;&#xA;# Initialize the model and load the pretrained weights.&#xA;# This will automatically download the model weights the first time it&#39;s run, which may take a while.&#xA;model = VGGT.from_pretrained(&#34;facebook/VGGT-1B&#34;).to(device)&#xA;&#xA;# Load and preprocess example images (replace with your own image paths)&#xA;image_names = [&#34;path/to/imageA.png&#34;, &#34;path/to/imageB.png&#34;, &#34;path/to/imageC.png&#34;]  &#xA;images = load_and_preprocess_images(image_names).to(device)&#xA;&#xA;with torch.no_grad():&#xA;    with torch.cuda.amp.autocast(dtype=dtype):&#xA;        # Predict attributes including cameras, depth maps, and point maps.&#xA;        predictions = model(images)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The model weights will be automatically downloaded from Hugging Face. If you encounter issues such as slow loading, you can manually download them &lt;a href=&#34;https://huggingface.co/facebook/VGGT-1B/blob/main/model.pt&#34;&gt;here&lt;/a&gt; and load, or:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model = VGGT()&#xA;_URL = &#34;https://huggingface.co/facebook/VGGT-1B/resolve/main/model.pt&#34;&#xA;model.load_state_dict(torch.hub.load_state_dict_from_url(_URL))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Detailed Usage&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to expand&lt;/summary&gt; &#xA; &lt;p&gt;You can also optionally choose which attributes (branches) to predict, as shown below. This achieves the same result as the example above. This example uses a batch size of 1 (processing a single scene), but it naturally works for multiple scenes.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from vggt.utils.pose_enc import pose_encoding_to_extri_intri&#xA;from vggt.utils.geometry import unproject_depth_map_to_point_map&#xA;&#xA;with torch.no_grad():&#xA;    with torch.cuda.amp.autocast(dtype=dtype):&#xA;        images = images[None]  # add batch dimension&#xA;        aggregated_tokens_list, ps_idx = model.aggregator(images)&#xA;                &#xA;    # Predict Cameras&#xA;    pose_enc = model.camera_head(aggregated_tokens_list)[-1]&#xA;    # Extrinsic and intrinsic matrices, following OpenCV convention (camera from world)&#xA;    extrinsic, intrinsic = pose_encoding_to_extri_intri(pose_enc, images.shape[-2:])&#xA;&#xA;    # Predict Depth Maps&#xA;    depth_map, depth_conf = model.depth_head(aggregated_tokens_list, images, ps_idx)&#xA;&#xA;    # Predict Point Maps&#xA;    point_map, point_conf = model.point_head(aggregated_tokens_list, images, ps_idx)&#xA;        &#xA;    # Construct 3D Points from Depth Maps and Cameras&#xA;    # which usually leads to more accurate 3D points than point map branch&#xA;    point_map_by_unprojection = unproject_depth_map_to_point_map(depth_map.squeeze(0), &#xA;                                                                extrinsic.squeeze(0), &#xA;                                                                intrinsic.squeeze(0))&#xA;&#xA;    # Predict Tracks&#xA;    # choose your own points to track, with shape (N, 2) for one scene&#xA;    query_points = torch.FloatTensor([[100.0, 200.0], &#xA;                                        [60.72, 259.94]]).to(device)&#xA;    track_list, vis_score, conf_score = model.track_head(aggregated_tokens_list, images, ps_idx, query_points=query_points[None])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Furthermore, if certain pixels in the input frames are unwanted (e.g., reflective surfaces, sky, or water), you can simply mask them by setting the corresponding pixel values to 0 or 1. Precise segmentation masks aren&#39;t necessary - simple bounding box masks work effectively (check this &lt;a href=&#34;https://github.com/facebookresearch/vggt/issues/47&#34;&gt;issue&lt;/a&gt; for an example).&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Interactive Demo&lt;/h2&gt; &#xA;&lt;p&gt;We provide multiple ways to visualize your 3D reconstructions. Before using these visualization tools, install the required dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install -r requirements_demo.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Interactive 3D Visualization&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Please note:&lt;/strong&gt; VGGT typically reconstructs a scene in less than 1 second. However, visualizing 3D points may take tens of seconds due to third-party rendering, independent of VGGT&#39;s processing time. The visualization is slow especially when the number of images is large.&lt;/p&gt; &#xA;&lt;h4&gt;Gradio Web Interface&lt;/h4&gt; &#xA;&lt;p&gt;Our Gradio-based interface allows you to upload images/videos, run reconstruction, and interactively explore the 3D scene in your browser. You can launch this in your local machine or try it on &lt;a href=&#34;https://huggingface.co/spaces/facebook/vggt&#34;&gt;Hugging Face&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python demo_gradio.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to preview the Gradio interactive interface&lt;/summary&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://jytime.github.io/data/vggt_hf_demo_screen.png&#34; alt=&#34;Gradio Web Interface Preview&#34;&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h4&gt;Viser 3D Viewer&lt;/h4&gt; &#xA;&lt;p&gt;Run the following command to run reconstruction and visualize the point clouds in viser. Note this script requires a path to a folder containing images. It assumes only image files under the folder. You can set &lt;code&gt;--use_point_map&lt;/code&gt; to use the point cloud from the point map branch, instead of the depth-based point cloud.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python demo_viser.py --image_folder path/to/your/images/folder&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Exporting to COLMAP Format&lt;/h2&gt; &#xA;&lt;p&gt;We also support exporting VGGT&#39;s predictions directly to COLMAP format, by:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Feedforward prediction only&#xA;python demo_colmap.py --scene_dir=/YOUR/SCENE_DIR/ &#xA;&#xA;# With bundle adjustment&#xA;python demo_colmap.py --scene_dir=/YOUR/SCENE_DIR/ --use_ba&#xA;# check the file for additional bundle adjustment configuration options&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please ensure that the images are stored in &lt;code&gt;/YOUR/SCENE_DIR/images/&lt;/code&gt;. This folder should contain only the images. Check the examples folder for the desired data structure.&lt;/p&gt; &#xA;&lt;p&gt;The reconstruction result (camera parameters and 3D points) will be automatically saved under &lt;code&gt;/YOUR/SCENE_DIR/sparse/&lt;/code&gt; in the COLMAP format, such as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SCENE_DIR/&#xA;├── images/&#xA;└── sparse/&#xA;    ├── cameras.bin&#xA;    ├── images.bin&#xA;    └── points3D.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Integration with Gaussian Splatting&lt;/h2&gt; &#xA;&lt;p&gt;The exported COLMAP files can be directly used with &lt;a href=&#34;https://github.com/nerfstudio-project/gsplat&#34;&gt;gsplat&lt;/a&gt; for Gaussian Splatting training. Install &lt;code&gt;gsplat&lt;/code&gt; following their official instructions (we recommend &lt;code&gt;gsplat==1.3.0&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;p&gt;An example command to train the model is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd gsplat&#xA;python examples/simple_trainer.py  default --data_factor 1 --data_dir /YOUR/SCENE_DIR/ --result_dir /YOUR/RESULT_DIR/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Zero-shot Single-view Reconstruction&lt;/h2&gt; &#xA;&lt;p&gt;Our model shows surprisingly good performance on single-view reconstruction, although it was never trained for this task. The model does not need to duplicate the single-view image to a pair, instead, it can directly infer the 3D structure from the tokens of the single view image. Feel free to try it with our demos above, which naturally works for single-view reconstruction.&lt;/p&gt; &#xA;&lt;p&gt;We did not quantitatively test monocular depth estimation performance ourselves, but &lt;a href=&#34;https://github.com/kabouzeid&#34;&gt;@kabouzeid&lt;/a&gt; generously provided a comparison of VGGT to recent methods &lt;a href=&#34;https://github.com/facebookresearch/vggt/issues/36&#34;&gt;here&lt;/a&gt;. VGGT shows competitive or better results compared to state-of-the-art monocular approaches such as DepthAnything v2 or MoGe, despite never being explicitly trained for single-view tasks.&lt;/p&gt; &#xA;&lt;h2&gt;Runtime and GPU Memory&lt;/h2&gt; &#xA;&lt;p&gt;We benchmark the runtime and GPU memory usage of VGGT&#39;s aggregator on a single NVIDIA H100 GPU across various input sizes.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;strong&gt;Input Frames&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;1&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;2&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;4&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;8&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;10&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;20&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;50&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;100&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;200&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Time (s)&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.04&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.05&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.07&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.11&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.14&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.31&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.04&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;3.12&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;8.75&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Memory (GB)&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.88&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.07&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.45&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;3.23&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;3.63&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;5.58&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;11.41&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;21.15&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;40.63&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Note that these results were obtained using Flash Attention 3, which is faster than the default Flash Attention 2 implementation while maintaining almost the same memory usage. Feel free to compile Flash Attention 3 from source to get better performance.&lt;/p&gt; &#xA;&lt;h2&gt;Research Progression&lt;/h2&gt; &#xA;&lt;p&gt;Our work builds upon a series of previous research projects. If you&#39;re interested in understanding how our research evolved, check out our previous works:&lt;/p&gt; &#xA;&lt;table border=&#34;0&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt; &lt;a href=&#34;https://github.com/jytime/Deep-SfM-Revisited&#34;&gt;Deep SfM Revisited&lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td style=&#34;white-space: pre;&#34;&gt;──┐&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt; &lt;a href=&#34;https://github.com/facebookresearch/PoseDiffusion&#34;&gt;PoseDiffusion&lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td style=&#34;white-space: pre;&#34;&gt;─────►&lt;/td&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://github.com/facebookresearch/vggsfm&#34;&gt;VGGSfM&lt;/a&gt; ──► &lt;a href=&#34;https://github.com/facebookresearch/vggt&#34;&gt;VGGT&lt;/a&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt; &lt;a href=&#34;https://github.com/facebookresearch/co-tracker&#34;&gt;CoTracker&lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td style=&#34;white-space: pre;&#34;&gt;──┘&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to these great repositories: &lt;a href=&#34;https://github.com/facebookresearch/PoseDiffusion&#34;&gt;PoseDiffusion&lt;/a&gt;, &lt;a href=&#34;https://github.com/facebookresearch/vggsfm&#34;&gt;VGGSfM&lt;/a&gt;, &lt;a href=&#34;https://github.com/facebookresearch/co-tracker&#34;&gt;CoTracker&lt;/a&gt;, &lt;a href=&#34;https://github.com/facebookresearch/dinov2&#34;&gt;DINOv2&lt;/a&gt;, &lt;a href=&#34;https://github.com/naver/dust3r&#34;&gt;Dust3r&lt;/a&gt;, &lt;a href=&#34;https://github.com/microsoft/moge&#34;&gt;Moge&lt;/a&gt;, &lt;a href=&#34;https://github.com/facebookresearch/pytorch3d&#34;&gt;PyTorch3D&lt;/a&gt;, &lt;a href=&#34;https://github.com/xiongzhu666/Sky-Segmentation-and-Post-processing&#34;&gt;Sky Segmentation&lt;/a&gt;, &lt;a href=&#34;https://github.com/DepthAnything/Depth-Anything-V2&#34;&gt;Depth Anything V2&lt;/a&gt;, &lt;a href=&#34;https://github.com/YvanYin/Metric3D&#34;&gt;Metric3D&lt;/a&gt; and many other inspiring works in the community.&lt;/p&gt; &#xA;&lt;h2&gt;Checklist&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Release the training code&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Release VGGT-500M and VGGT-200M&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/vggt/main/LICENSE.txt&#34;&gt;LICENSE&lt;/a&gt; file for details about the license under which this code is made available.&lt;/p&gt;</summary>
  </entry>
</feed>