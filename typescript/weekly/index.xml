<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub TypeScript Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-31T02:27:32Z</updated>
  <subtitle>Weekly Trending of TypeScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>colinhacks/zod</title>
    <updated>2022-07-31T02:27:32Z</updated>
    <id>tag:github.com,2022-07-31:/colinhacks/zod</id>
    <link href="https://github.com/colinhacks/zod" rel="alternate"></link>
    <summary type="html">&lt;p&gt;TypeScript-first schema validation with static type inference&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/logo.svg?sanitize=true&#34; width=&#34;200px&#34; align=&#34;center&#34; alt=&#34;Zod logo&#34;&gt; &lt;/p&gt;&#xA;&lt;h1 align=&#34;center&#34;&gt;Zod&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; ✨ &lt;a href=&#34;https://zod.dev&#34;&gt;https://zod.dev&lt;/a&gt; ✨ &lt;br&gt; TypeScript-first schema validation with static type inference &lt;/p&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/colinhacks/zod/actions?query=branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/colinhacks/zod/actions/workflows/test.yml/badge.svg?event=push&amp;amp;branch=master&#34; alt=&#34;Zod CI status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/colinhacks&#34; rel=&#34;nofollow&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/created%20by-@colinhacks-4BBAAB.svg?sanitize=true&#34; alt=&#34;Created by Colin McDonnell&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34; rel=&#34;nofollow&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/colinhacks/zod&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.npmjs.com/package/zod&#34; rel=&#34;nofollow&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/dw/zod.svg?sanitize=true&#34; alt=&#34;npm&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.npmjs.com/package/zod&#34; rel=&#34;nofollow&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/colinhacks/zod&#34; alt=&#34;stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/KaSRdyX2vc&#34; rel=&#34;nofollow&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/893487829802418277?label=Discord&amp;amp;logo=discord&amp;amp;logoColor=white&#34; alt=&#34;discord server&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://zod.dev&#34;&gt;Documentation&lt;/a&gt; &#xA; &lt;span&gt;&amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&lt;/span&gt; &#xA; &lt;a href=&#34;https://discord.gg/RcG33DQJdf&#34;&gt;Discord&lt;/a&gt; &#xA; &lt;span&gt;&amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&lt;/span&gt; &#xA; &lt;a href=&#34;https://www.npmjs.com/package/zod&#34;&gt;npm&lt;/a&gt; &#xA; &lt;span&gt;&amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&lt;/span&gt; &#xA; &lt;a href=&#34;https://github.com/colinhacks/zod/issues/new&#34;&gt;Issues&lt;/a&gt; &#xA; &lt;span&gt;&amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&lt;/span&gt; &#xA; &lt;a href=&#34;https://twitter.com/colinhacks&#34;&gt;@colinhacks&lt;/a&gt; &#xA; &lt;span&gt;&amp;nbsp;&amp;nbsp;•&amp;nbsp;&amp;nbsp;&lt;/span&gt; &#xA; &lt;a href=&#34;https://trpc.io&#34;&gt;tRPC&lt;/a&gt; &#xA; &lt;br&gt; &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;br&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;These docs have been translated into &lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/README_ZH.md&#34;&gt;Chinese&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;!-- The full documentation is available both on the [official documentation site](https://zod.js.org/) (recommended) and in `README.md`.&#xA;&#xA;#### Go to [zod.js.org](https://zod.js.org) &gt;&gt; --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#introduction&#34;&gt;Introduction&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#sponsors&#34;&gt;Sponsors&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#ecosystem&#34;&gt;Ecosystem&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#Node/npm&#34;&gt;Node/npm&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#deno&#34;&gt;Deno&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#basic-usage&#34;&gt;Basic usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#primitives&#34;&gt;Primitives&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#literals&#34;&gt;Literals&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#strings&#34;&gt;Strings&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#numbers&#34;&gt;Numbers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#nans&#34;&gt;NaNs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#booleans&#34;&gt;Booleans&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#dates&#34;&gt;Dates&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#zod-enums&#34;&gt;Zod enums&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#native-enums&#34;&gt;Native enums&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#optionals&#34;&gt;Optionals&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#nullables&#34;&gt;Nullables&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#objects&#34;&gt;Objects&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#shape&#34;&gt;.shape&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#enum&#34;&gt;.enum&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#extend&#34;&gt;.extend&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#merge&#34;&gt;.merge&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#pickomit&#34;&gt;.pick/.omit&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#partial&#34;&gt;.partial&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#deepPartial&#34;&gt;.deepPartial&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#passthrough&#34;&gt;.passthrough&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#strict&#34;&gt;.strict&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#strip&#34;&gt;.strip&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#catchall&#34;&gt;.catchall&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#arrays&#34;&gt;Arrays&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#element&#34;&gt;.element&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#nonempty&#34;&gt;.nonempty&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#minmaxlength&#34;&gt;.min/.max/.length&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#tuples&#34;&gt;Tuples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#unions&#34;&gt;Unions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#discriminated-unions&#34;&gt;Discriminated Unions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#records&#34;&gt;Records&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#maps&#34;&gt;Maps&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#sets&#34;&gt;Sets&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#recursive-types&#34;&gt;Recursive types&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#json-type&#34;&gt;JSON type&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#cyclical-objects&#34;&gt;Cyclical data&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#promises&#34;&gt;Promises&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#instanceof&#34;&gt;Instanceof&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#function-schemas&#34;&gt;Function schemas&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#preprocess&#34;&gt;Preprocess&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#schema-methods&#34;&gt;Schema methods&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#parse&#34;&gt;.parse&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#parseasync&#34;&gt;.parseAsync&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#safeparse&#34;&gt;.safeParse&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#safeparseasync&#34;&gt;.safeParseAsync&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#refine&#34;&gt;.refine&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#superRefine&#34;&gt;.superRefine&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#transform&#34;&gt;.transform&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#default&#34;&gt;.default&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#optional&#34;&gt;.optional&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#nullable&#34;&gt;.nullable&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#nullish&#34;&gt;.nullish&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#array&#34;&gt;.array&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#promise&#34;&gt;.promise&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#or&#34;&gt;.or&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#and&#34;&gt;.and&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#guides-and-concepts&#34;&gt;Guides and concepts&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#type-inference&#34;&gt;Type inference&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#writing-generic-functions&#34;&gt;Writing generic functions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#error-handling&#34;&gt;Error handling&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#error-formatting&#34;&gt;Error formatting&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#comparison&#34;&gt;Comparison&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#joi&#34;&gt;Joi&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#yup&#34;&gt;Yup&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#io-ts&#34;&gt;io-ts&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#runtypes&#34;&gt;Runtypes&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#changelog&#34;&gt;Changelog&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- **Zod 2 is coming! Follow [@colinhacks](https://twitter.com/colinhacks) to stay updated and discuss the future of Zod.** --&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Zod is a TypeScript-first schema declaration and validation library. I&#39;m using the term &#34;schema&#34; to broadly refer to any data type, from a simple &lt;code&gt;string&lt;/code&gt; to a complex nested object.&lt;/p&gt; &#xA;&lt;p&gt;Zod is designed to be as developer-friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator &lt;em&gt;once&lt;/em&gt; and Zod will automatically infer the static TypeScript type. It&#39;s easy to compose simpler types into complex data structures.&lt;/p&gt; &#xA;&lt;p&gt;Some other great aspects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Zero dependencies&lt;/li&gt; &#xA; &lt;li&gt;Works in Node.js and all modern browsers&lt;/li&gt; &#xA; &lt;li&gt;Tiny: 8kb minified + zipped&lt;/li&gt; &#xA; &lt;li&gt;Immutable: methods (i.e. &lt;code&gt;.optional()&lt;/code&gt;) return a new instance&lt;/li&gt; &#xA; &lt;li&gt;Concise, chainable interface&lt;/li&gt; &#xA; &lt;li&gt;Functional approach: &lt;a href=&#34;https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/&#34;&gt;parse, don&#39;t validate&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Works with plain JavaScript too! You don&#39;t need to use TypeScript.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Sponsors&lt;/h3&gt; &#xA;&lt;p&gt;Sponsorship at any level is appreciated and encouraged. For individual developers, consider the &lt;a href=&#34;https://github.com/sponsors/colinhacks&#34;&gt;Cup of Coffee tier&lt;/a&gt;. If you built a paid product using Zod, consider one of the &lt;a href=&#34;https://github.com/sponsors/colinhacks&#34;&gt;podium tiers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Gold&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &lt;a href=&#34;https://astro.build/&#34;&gt; &lt;img src=&#34;https://avatars.githubusercontent.com/u/44914786?s=200&amp;amp;v=4&#34; width=&#34;200px;&#34; alt=&#34;Astro&#34;&gt; &lt;/a&gt; &lt;br&gt; &lt;b&gt;Astro&lt;/b&gt; &lt;br&gt; &lt;a href=&#34;https://astro.build&#34;&gt;astro.build&lt;/a&gt; &lt;br&gt; &lt;p width=&#34;200px&#34;&gt; Astro is a new kind of static &lt;br&gt; site builder for the modern web. &lt;br&gt; Powerful developer experience meets &lt;br&gt; lightweight output.&lt;/p&gt; &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &lt;a href=&#34;https://glow.app/&#34;&gt; &lt;img src=&#34;https://i.imgur.com/R0R43S2.jpg&#34; width=&#34;200px;&#34; alt=&#34;&#34;&gt; &lt;/a&gt; &lt;br&gt; &lt;b&gt;Glow Wallet&lt;/b&gt; &lt;br&gt; &lt;a href=&#34;https://glow.app/&#34;&gt;glow.app&lt;/a&gt; &lt;br&gt; &lt;p width=&#34;200px&#34;&gt;Your new favorite &lt;br&gt; Solana wallet.&lt;/p&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &lt;a href=&#34;https://deletype.com/&#34;&gt; &lt;img src=&#34;https://avatars0.githubusercontent.com/u/15068039?s=200&amp;amp;v=4&#34; width=&#34;200px;&#34; alt=&#34;&#34;&gt; &lt;/a&gt; &lt;br&gt; &lt;b&gt;Deletype&lt;/b&gt; &lt;br&gt; &lt;a href=&#34;https://deletype.com&#34;&gt;deletype.com&lt;/a&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Silver&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &lt;a href=&#34;https://snaplet.dev&#34;&gt; &lt;img src=&#34;https://avatars.githubusercontent.com/u/69029941?s=200&amp;amp;v=4&#34; width=&#34;150px;&#34; alt=&#34;&#34;&gt; &lt;/a&gt; &lt;br&gt; &lt;b&gt;Snaplet&lt;/b&gt; &lt;br&gt; &lt;a href=&#34;https://snaplet.dev&#34;&gt;snaplet.dev&lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &lt;a href=&#34;https://marcatopartners.com/&#34;&gt; &lt;img src=&#34;https://avatars.githubusercontent.com/u/84106192?s=200&amp;amp;v=4&#34; width=&#34;150px;&#34; alt=&#34;Marcato Partners&#34;&gt; &lt;/a&gt; &lt;br&gt; &lt;b&gt;Marcato Partners&lt;/b&gt; &lt;br&gt; &lt;a href=&#34;https://marcatopartners.com/&#34;&gt;marcatopartners.com&lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/macandcheese-spaghetticode&#34;&gt; &lt;img src=&#34;https://avatars.githubusercontent.com/u/76997592?v=4&#34; width=&#34;150px;&#34; alt=&#34;Trip&#34;&gt; &lt;/a&gt; &lt;br&gt; &lt;b&gt;Trip&lt;/b&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &lt;a href=&#34;https://seasoned.cc&#34;&gt; &lt;img src=&#34;https://avatars.githubusercontent.com/u/33913103?s=200&amp;amp;v=4&#34; width=&#34;150px;&#34; alt=&#34;&#34;&gt; &lt;/a&gt; &lt;br&gt; &lt;b&gt;Seasoned Software&lt;/b&gt; &lt;br&gt; &lt;a href=&#34;https://seasoned.cc&#34;&gt;seasoned.cc&lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &lt;a href=&#34;https://interval.com&#34;&gt; &lt;img src=&#34;https://avatars.githubusercontent.com/u/67802063?s=200&amp;amp;v=4&#34; width=&#34;150px;&#34; alt=&#34;&#34;&gt; &lt;/a&gt; &lt;br&gt; &lt;b&gt;Interval&lt;/b&gt; &lt;br&gt; &lt;a href=&#34;https://interval.com&#34;&gt;interval.com&lt;/a&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Bronze&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &lt;a href=&#34;https://twitter.com/flybayer&#34;&gt; &lt;img src=&#34;https://avatars2.githubusercontent.com/u/8813276?s=460&amp;amp;u=4ff8beb9a67b173015c4b426a92d89cab960af1b&amp;amp;v=4&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt; &lt;/a&gt; &lt;br&gt; &lt;b&gt;Brandon Bayer&lt;/b&gt; &lt;br&gt; &lt;a href=&#34;https://twitter.com/flybayer&#34;&gt;@flybayer&lt;/a&gt;, &lt;span&gt;creator of &lt;a href=&#34;https://blitzjs.com&#34;&gt;Blitz.js&lt;/a&gt;&lt;/span&gt; &lt;br&gt; &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/brabeji&#34;&gt; &lt;img src=&#34;https://avatars.githubusercontent.com/u/2237954?v=4&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt; &lt;/a&gt; &lt;br&gt; &lt;b&gt;Jiří Brabec&lt;/b&gt; &lt;br&gt; &lt;a href=&#34;https://github.com/brabeji&#34;&gt;@brabeji&lt;/a&gt; &lt;br&gt; &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &lt;a href=&#34;https://twitter.com/alexdotjs&#34;&gt; &lt;img src=&#34;https://avatars.githubusercontent.com/u/459267?v=4&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt; &lt;/a&gt; &lt;br&gt; &lt;b&gt;Alex Johansson&lt;/b&gt; &lt;br&gt; &lt;a href=&#34;https://twitter.com/alexdotjs&#34;&gt;@alexdotjs&lt;/a&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &lt;a href=&#34;https://adaptable.io/&#34;&gt; &lt;img src=&#34;https://avatars.githubusercontent.com/u/60378268?s=200&amp;amp;v=4&#34; width=&#34;100px;&#34; alt=&#34;&#34;&gt; &lt;/a&gt; &lt;br&gt; &lt;b&gt;Adaptable&lt;/b&gt; &lt;br&gt; &lt;a href=&#34;https://adaptable.io/&#34;&gt;adaptable.io&lt;/a&gt; &lt;br&gt; &lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt; &lt;a href=&#34;https://www.avanawallet.com/&#34;&gt; &lt;img src=&#34;https://avatars.githubusercontent.com/u/105452197?s=200&amp;amp;v=4&#34; width=&#34;100px;&#34; alt=&#34;Avana Wallet logo&#34;&gt; &lt;/a&gt; &lt;br&gt; &lt;b&gt;Avana Wallet&lt;/b&gt; &lt;br&gt; &lt;a href=&#34;https://www.avanawallet.com/&#34;&gt;avanawallet.com&lt;/a&gt;&lt;br&gt; &lt;span&gt;Solana non-custodial wallet&lt;/span&gt; &lt;br&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Ecosystem&lt;/h3&gt; &#xA;&lt;p&gt;There are a growing number of tools that are built atop or support Zod natively! If you&#39;ve built a tool or library on top of Zod, tell me about it &lt;a href=&#34;https://twitter.com/colinhacks&#34;&gt;on Twitter&lt;/a&gt; or &lt;a href=&#34;https://github.com/colinhacks/zod/discussions&#34;&gt;start a Discussion&lt;/a&gt;. I&#39;ll add it below and tweet it out.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/trpc/trpc&#34;&gt;&lt;code&gt;tRPC&lt;/code&gt;&lt;/a&gt;: Build end-to-end typesafe APIs without GraphQL.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fabien0102/ts-to-zod&#34;&gt;&lt;code&gt;ts-to-zod&lt;/code&gt;&lt;/a&gt;: Convert TypeScript definitions into Zod schemas.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sachinraja/zod-to-ts&#34;&gt;&lt;code&gt;zod-to-ts&lt;/code&gt;&lt;/a&gt;: Generate TypeScript definitions from Zod schemas.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/anatine/zod-plugins/tree/main/libs/zod-openapi&#34;&gt;&lt;code&gt;@anatine/zod-openapi&lt;/code&gt;&lt;/a&gt;: Converts a Zod schema to an OpenAPI v3.x &lt;code&gt;SchemaObject&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/anatine/zod-plugins/tree/main/libs/zod-mock&#34;&gt;&lt;code&gt;@anatine/zod-mock&lt;/code&gt;&lt;/a&gt;: Generate mock data from a Zod schema. Powered by &lt;a href=&#34;https://github.com/Marak/Faker.js&#34;&gt;faker.js&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/anatine/zod-plugins/tree/main/libs/zod-nestjs&#34;&gt;&lt;code&gt;@anatine/zod-nestjs&lt;/code&gt;&lt;/a&gt;: Helper methods for using Zod in a NestJS project.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dipasqualew/zod-mocking&#34;&gt;&lt;code&gt;zod-mocking&lt;/code&gt;&lt;/a&gt;: Generate mock data from your Zod schemas.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/DavidTimms/zod-fast-check&#34;&gt;&lt;code&gt;zod-fast-check&lt;/code&gt;&lt;/a&gt;: Generate &lt;code&gt;fast-check&lt;/code&gt; arbitraries from Zod schemas.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/flock-community/zod-endpoints&#34;&gt;&lt;code&gt;zod-endpoints&lt;/code&gt;&lt;/a&gt;: Contract-first strictly typed endpoints with Zod. OpenAPI compatible.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/RobinTail/express-zod-api&#34;&gt;&lt;code&gt;express-zod-api&lt;/code&gt;&lt;/a&gt;: Build Express-based APIs with I/O schema validation and custom middlewares.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/StefanTerdell/zod-to-json-schema&#34;&gt;&lt;code&gt;zod-to-json-schema&lt;/code&gt;&lt;/a&gt;: Convert your Zod schemas into &lt;a href=&#34;https://json-schema.org/&#34;&gt;JSON Schemas&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/StefanTerdell/json-schema-to-zod&#34;&gt;&lt;code&gt;json-schema-to-zod&lt;/code&gt;&lt;/a&gt;: Convert your &lt;a href=&#34;https://json-schema.org/&#34;&gt;JSON Schemas&lt;/a&gt; into Zod schemas. &lt;a href=&#34;https://StefanTerdell.github.io/json-schema-to-zod-react/&#34;&gt;Live demo&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rsinohara/json-to-zod&#34;&gt;&lt;code&gt;json-to-zod&lt;/code&gt;&lt;/a&gt;: Convert JSON objects into Zod schemas. &lt;a href=&#34;https://rsinohara.github.io/json-to-zod-react/&#34;&gt;Live demo&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kbkk/abitia/tree/master/packages/zod-dto&#34;&gt;&lt;code&gt;zod-dto&lt;/code&gt;&lt;/a&gt;: Generate Nest.js DTOs from a Zod schema.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mdbetancourt/soly&#34;&gt;&lt;code&gt;soly&lt;/code&gt;&lt;/a&gt;: Create CLI applications with zod.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Code-Hex/graphql-codegen-typescript-validation-schema&#34;&gt;&lt;code&gt;graphql-codegen-typescript-validation-schema&lt;/code&gt;&lt;/a&gt;: GraphQL Code Generator plugin to generate form validation schema from your GraphQL schema&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/CarterGrimmeisen/zod-prisma&#34;&gt;&lt;code&gt;zod-prisma&lt;/code&gt;&lt;/a&gt;: Generate Zod schemas from your Prisma schema.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/turkerdev/fastify-type-provider-zod&#34;&gt;&lt;code&gt;fastify-type-provider-zod&lt;/code&gt;&lt;/a&gt;: Create Fastify type providers from Zod schemas&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Southclaws/supervillain&#34;&gt;&lt;code&gt;Supervillain&lt;/code&gt;&lt;/a&gt;: Generate Zod schemas from your Go structs&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/asteasolutions/zod-to-openapi&#34;&gt;&lt;code&gt;zod-to-openapi&lt;/code&gt;&lt;/a&gt;: Generate full OpenAPI (Swagger) docs from Zod, including schemas, endpoints &amp;amp; parameters&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/omar-dulaimi/prisma-zod-generator&#34;&gt;&lt;code&gt;prisma-zod-generator&lt;/code&gt;&lt;/a&gt;: Emit Zod schemas from your Prisma schema.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/omar-dulaimi/prisma-trpc-generator&#34;&gt;&lt;code&gt;prisma-trpc-generator&lt;/code&gt;&lt;/a&gt;: Emit fully implemented tRPC routers and their validation schemas using Zod.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/incetarik/nestjs-graphql-zod&#34;&gt;&lt;code&gt;nestjs-graphql-zod&lt;/code&gt;&lt;/a&gt;: Generates NestJS GraphQL model classes from Zod schemas dynamically and provides GraphQL method decorators working with Zod schemas.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sidwebworks/zod-xlsx&#34;&gt;&lt;code&gt;zod-xlsx&lt;/code&gt;&lt;/a&gt;: A xlsx based resource validator using Zod schemas.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/SeasonedSoftware/remix-domains/&#34;&gt;&lt;code&gt;remix-domains&lt;/code&gt;&lt;/a&gt;: Improves end-to-end type safety in &lt;a href=&#34;https://remix.run/&#34;&gt;Remix&lt;/a&gt; by leveraging Zod to parse the framework&#39;s inputs such as FormData, URLSearchParams, etc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ecyrbe/zodios&#34;&gt;&lt;code&gt;@zodios/core&lt;/code&gt;&lt;/a&gt;: A typescript API client with runtime and compile time validation backed by axios and zod.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Form integrations&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/react-hook-form/resolvers#zod&#34;&gt;&lt;code&gt;react-hook-form&lt;/code&gt;&lt;/a&gt;: A first-party Zod resolver for React Hook Form&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/robertLichtnow/zod-formik-adapter&#34;&gt;&lt;code&gt;zod-formik-adapter&lt;/code&gt;&lt;/a&gt;: A community-maintained Formik adapter for Zod&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/esamattis/react-zorm&#34;&gt;&lt;code&gt;react-zorm&lt;/code&gt;&lt;/a&gt;: Standalone &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; generation and validation for React using Zod&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;TypeScript 4.1+!&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You must enable &lt;code&gt;strict&lt;/code&gt; mode in your &lt;code&gt;tsconfig.json&lt;/code&gt;. This is a best practice for all TypeScript projects.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// tsconfig.json&#xA;{&#xA;  // ...&#xA;  &#34;compilerOptions&#34;: {&#xA;    // ...&#xA;    &#34;strict&#34;: true&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Node/npm&lt;/h3&gt; &#xA;&lt;p&gt;To install Zod v3:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install zod       # npm&#xA;yarn add zod          # yarn&#xA;pnpm add zod          # pnpm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deno&lt;/h3&gt; &#xA;&lt;p&gt;Unlike Node, Deno relies on direct URL imports instead of a package manager like NPM. Zod is available on &lt;a href=&#34;https://deno.land/x&#34;&gt;deno.land/x&lt;/a&gt;. The latest version can be imported like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { z } from &#34;https://deno.land/x/zod/mod.ts&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also specify a particular version:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { z } from &#34;https://deno.land/x/zod@v3.16.1/mod.ts&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The rest of this README assumes you are using npm and importing directly from the &lt;code&gt;&#34;zod&#34;&lt;/code&gt; package.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Basic usage&lt;/h2&gt; &#xA;&lt;p&gt;Creating a simple string schema&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { z } from &#34;zod&#34;;&#xA;&#xA;// creating a schema for strings&#xA;const mySchema = z.string();&#xA;&#xA;// parsing&#xA;mySchema.parse(&#34;tuna&#34;); // =&amp;gt; &#34;tuna&#34;&#xA;mySchema.parse(12); // =&amp;gt; throws ZodError&#xA;&#xA;// &#34;safe&#34; parsing (doesn&#39;t throw error if validation fails)&#xA;mySchema.safeParse(&#34;tuna&#34;); // =&amp;gt; { success: true; data: &#34;tuna&#34; }&#xA;mySchema.safeParse(12); // =&amp;gt; { success: false; error: ZodError }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Creating an object schema&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { z } from &#34;zod&#34;;&#xA;&#xA;const User = z.object({&#xA;  username: z.string(),&#xA;});&#xA;&#xA;User.parse({ username: &#34;Ludwig&#34; });&#xA;&#xA;// extract the inferred type&#xA;type User = z.infer&amp;lt;typeof User&amp;gt;;&#xA;// { username: string }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Primitives&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { z } from &#34;zod&#34;;&#xA;&#xA;// primitive values&#xA;z.string();&#xA;z.number();&#xA;z.bigint();&#xA;z.boolean();&#xA;z.date();&#xA;&#xA;// empty types&#xA;z.undefined();&#xA;z.null();&#xA;z.void(); // accepts undefined&#xA;&#xA;// catch-all types&#xA;// allows any value&#xA;z.any();&#xA;z.unknown();&#xA;&#xA;// never type&#xA;// allows no values&#xA;z.never();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Literals&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const tuna = z.literal(&#34;tuna&#34;);&#xA;const twelve = z.literal(12);&#xA;const tru = z.literal(true);&#xA;&#xA;// retrieve literal value&#xA;tuna.value; // &#34;tuna&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Currently there is no support for Date literals in Zod. If you have a use case for this feature, please file an issue.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Strings&lt;/h2&gt; &#xA;&lt;p&gt;Zod includes a handful of string-specific validations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.string().max(5);&#xA;z.string().min(5);&#xA;z.string().length(5);&#xA;z.string().email();&#xA;z.string().url();&#xA;z.string().uuid();&#xA;z.string().cuid();&#xA;z.string().regex(regex);&#xA;z.string().startsWith(string);&#xA;z.string().endsWith(string);&#xA;&#xA;// trim whitespace&#xA;z.string().trim();&#xA;&#xA;// deprecated, equivalent to .min(1)&#xA;z.string().nonempty();&#xA;&#xA;// optional custom error message&#xA;z.string().nonempty({ message: &#34;Can&#39;t be empty&#34; });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Check out &lt;a href=&#34;https://github.com/validatorjs/validator.js&#34;&gt;validator.js&lt;/a&gt; for a bunch of other useful string validation functions.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;You can customize some common error messages when creating a string schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const name = z.string({&#xA;  required_error: &#34;Name is required&#34;,&#xA;  invalid_type_error: &#34;Name must be a string&#34;,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using validation methods, you can pass in an additional argument to provide a custom error message.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.string().min(5, { message: &#34;Must be 5 or more characters long&#34; });&#xA;z.string().max(5, { message: &#34;Must be 5 or fewer characters long&#34; });&#xA;z.string().length(5, { message: &#34;Must be exactly 5 characters long&#34; });&#xA;z.string().email({ message: &#34;Invalid email address&#34; });&#xA;z.string().url({ message: &#34;Invalid url&#34; });&#xA;z.string().uuid({ message: &#34;Invalid UUID&#34; });&#xA;z.string().startsWith(&#34;https://&#34;, { message: &#34;Must provide secure URL&#34; });&#xA;z.string().endsWith(&#34;.com&#34;, { message: &#34;Only .com domains allowed&#34; });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Numbers&lt;/h2&gt; &#xA;&lt;p&gt;You can customize certain error messages when creating a number schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const age = z.number({&#xA;  required_error: &#34;Age is required&#34;,&#xA;  invalid_type_error: &#34;Age must be a number&#34;,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Zod includes a handful of number-specific validations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.number().gt(5);&#xA;z.number().gte(5); // alias .min(5)&#xA;z.number().lt(5);&#xA;z.number().lte(5); // alias .max(5)&#xA;&#xA;z.number().int(); // value must be an integer&#xA;&#xA;z.number().positive(); //     &amp;gt; 0&#xA;z.number().nonnegative(); //  &amp;gt;= 0&#xA;z.number().negative(); //     &amp;lt; 0&#xA;z.number().nonpositive(); //  &amp;lt;= 0&#xA;&#xA;z.number().multipleOf(5); // Evenly divisible by 5. Alias .step(5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Optionally, you can pass in a second argument to provide a custom error message.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.number().lte(5, { message: &#34;this👏is👏too👏big&#34; });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;NaNs&lt;/h2&gt; &#xA;&lt;p&gt;You can customize certain error messages when creating a nan schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const isNaN = z.nan({&#xA;  required_error: &#34;isNaN is required&#34;,&#xA;  invalid_type_error: &#34;isNaN must be not a number&#34;,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Booleans&lt;/h2&gt; &#xA;&lt;p&gt;You can customize certain error messages when creating a boolean schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const isActive = z.boolean({&#xA;  required_error: &#34;isActive is required&#34;,&#xA;  invalid_type_error: &#34;isActive must be a boolean&#34;,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Dates&lt;/h2&gt; &#xA;&lt;p&gt;Use z.date() to validate &lt;code&gt;Date&lt;/code&gt; instances.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.date().safeParse(new Date()); // success: true&#xA;z.date().safeParse(&#34;2022-01-12T00:00:00.000Z&#34;); // success: false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can customize certain error messages when creating a date schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const myDateSchema = z.date({&#xA;  required_error: &#34;Please select a date and time&#34;,&#xA;  invalid_type_error: &#34;That&#39;s not a date!&#34;,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Zod provides a handful of date-specific validations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.date().min(new Date(&#34;1900-01-01&#34;), { message: &#34;Too old&#34; });&#xA;z.date().max(new Date(), { message: &#34;Too young!&#34; });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Supporting date strings&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;To write a schema that accepts either a &lt;code&gt;Date&lt;/code&gt; or a date string, use (&lt;code&gt;z.preprocess&lt;/code&gt;)[#preprocess].&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const dateSchema = z.preprocess((arg) =&amp;gt; {&#xA;  if (typeof arg == &#34;string&#34; || arg instanceof Date) return new Date(arg);&#xA;}, z.date());&#xA;type DateSchema = z.infer&amp;lt;typeof dateSchema&amp;gt;;&#xA;// type DateSchema = Date&#xA;&#xA;dateSchema.safeParse(new Date(&#34;1/12/22&#34;)); // success: true&#xA;dateSchema.safeParse(&#34;2022-01-12T00:00:00.000Z&#34;); // success: true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Zod enums&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const FishEnum = z.enum([&#34;Salmon&#34;, &#34;Tuna&#34;, &#34;Trout&#34;]);&#xA;type FishEnum = z.infer&amp;lt;typeof FishEnum&amp;gt;;&#xA;// &#39;Salmon&#39; | &#39;Tuna&#39; | &#39;Trout&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;z.enum&lt;/code&gt; is a Zod-native way to declare a schema with a fixed set of allowable &lt;em&gt;string&lt;/em&gt; values. Pass the array of values directly into &lt;code&gt;z.enum()&lt;/code&gt;. Alternatively, use &lt;code&gt;as const&lt;/code&gt; to define your enum values as a tuple of strings. See the &lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions&#34;&gt;const assertion docs&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const VALUES = [&#34;Salmon&#34;, &#34;Tuna&#34;, &#34;Trout&#34;] as const;&#xA;const FishEnum = z.enum(VALUES);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is not allowed, since Zod isn&#39;t able to infer the exact values of each element.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const fish = [&#34;Salmon&#34;, &#34;Tuna&#34;, &#34;Trout&#34;];&#xA;const FishEnum = z.enum(fish);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Autocompletion&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;To get autocompletion with a Zod enum, use the &lt;code&gt;.enum&lt;/code&gt; property of your schema:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;FishEnum.enum.Salmon; // =&amp;gt; autocompletes&#xA;&#xA;FishEnum.enum;&#xA;/*&#xA;=&amp;gt; {&#xA;  Salmon: &#34;Salmon&#34;,&#xA;  Tuna: &#34;Tuna&#34;,&#xA;  Trout: &#34;Trout&#34;,&#xA;}&#xA;*/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also retrieve the list of options as a tuple with the &lt;code&gt;.options&lt;/code&gt; property:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;FishEnum.options; // [&#34;Salmon&#34;, &#34;Tuna&#34;, &#34;Trout&#34;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Native enums&lt;/h2&gt; &#xA;&lt;p&gt;Zod enums are the recommended approach to defining and validating enums. But if you need to validate against an enum from a third-party library (or you don&#39;t want to rewrite your existing enums) you can use &lt;code&gt;z.nativeEnum()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Numeric enums&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;enum Fruits {&#xA;  Apple,&#xA;  Banana,&#xA;}&#xA;&#xA;const FruitEnum = z.nativeEnum(Fruits);&#xA;type FruitEnum = z.infer&amp;lt;typeof FruitEnum&amp;gt;; // Fruits&#xA;&#xA;FruitEnum.parse(Fruits.Apple); // passes&#xA;FruitEnum.parse(Fruits.Banana); // passes&#xA;FruitEnum.parse(0); // passes&#xA;FruitEnum.parse(1); // passes&#xA;FruitEnum.parse(3); // fails&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;String enums&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;enum Fruits {&#xA;  Apple = &#34;apple&#34;,&#xA;  Banana = &#34;banana&#34;,&#xA;  Cantaloupe, // you can mix numerical and string enums&#xA;}&#xA;&#xA;const FruitEnum = z.nativeEnum(Fruits);&#xA;type FruitEnum = z.infer&amp;lt;typeof FruitEnum&amp;gt;; // Fruits&#xA;&#xA;FruitEnum.parse(Fruits.Apple); // passes&#xA;FruitEnum.parse(Fruits.Cantaloupe); // passes&#xA;FruitEnum.parse(&#34;apple&#34;); // passes&#xA;FruitEnum.parse(&#34;banana&#34;); // passes&#xA;FruitEnum.parse(0); // passes&#xA;FruitEnum.parse(&#34;Cantaloupe&#34;); // fails&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Const enums&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;.nativeEnum()&lt;/code&gt; function works for &lt;code&gt;as const&lt;/code&gt; objects as well. ⚠️ &lt;code&gt;as const&lt;/code&gt; required TypeScript 3.4+!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const Fruits = {&#xA;  Apple: &#34;apple&#34;,&#xA;  Banana: &#34;banana&#34;,&#xA;  Cantaloupe: 3,&#xA;} as const;&#xA;&#xA;const FruitEnum = z.nativeEnum(Fruits);&#xA;type FruitEnum = z.infer&amp;lt;typeof FruitEnum&amp;gt;; // &#34;apple&#34; | &#34;banana&#34; | 3&#xA;&#xA;FruitEnum.parse(&#34;apple&#34;); // passes&#xA;FruitEnum.parse(&#34;banana&#34;); // passes&#xA;FruitEnum.parse(3); // passes&#xA;FruitEnum.parse(&#34;Cantaloupe&#34;); // fails&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can access the underlying object with the &lt;code&gt;.enum&lt;/code&gt; property:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;FruitEnum.enum.Apple; // &#34;apple&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Optionals&lt;/h2&gt; &#xA;&lt;p&gt;You can make any schema optional with &lt;code&gt;z.optional()&lt;/code&gt;. This wraps the schema in a &lt;code&gt;ZodOptional&lt;/code&gt; instance and returns the result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const schema = z.optional(z.string());&#xA;&#xA;schema.parse(undefined); // =&amp;gt; returns undefined&#xA;type A = z.infer&amp;lt;typeof schema&amp;gt;; // string | undefined&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For convenience, you can also call the &lt;code&gt;.optional()&lt;/code&gt; method on an existing schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const user = z.object({&#xA;  username: z.string().optional(),&#xA;});&#xA;type C = z.infer&amp;lt;typeof user&amp;gt;; // { username?: string | undefined };&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can extract the wrapped schema from a &lt;code&gt;ZodOptional&lt;/code&gt; instance with &lt;code&gt;.unwrap()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const stringSchema = z.string();&#xA;const optionalString = stringSchema.optional();&#xA;optionalString.unwrap() === stringSchema; // true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Nullables&lt;/h2&gt; &#xA;&lt;p&gt;Similarly, you can create nullable types with &lt;code&gt;z.nullable()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const nullableString = z.nullable(z.string());&#xA;nullableString.parse(&#34;asdf&#34;); // =&amp;gt; &#34;asdf&#34;&#xA;nullableString.parse(null); // =&amp;gt; null&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or use the &lt;code&gt;.nullable()&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const E = z.string().nullable(); // equivalent to D&#xA;type E = z.infer&amp;lt;typeof E&amp;gt;; // string | null&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Extract the inner schema with &lt;code&gt;.unwrap()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const stringSchema = z.string();&#xA;const nullableString = stringSchema.nullable();&#xA;nullableString.unwrap() === stringSchema; // true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Objects&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// all properties are required by default&#xA;const Dog = z.object({&#xA;  name: z.string(),&#xA;  age: z.number(),&#xA;});&#xA;&#xA;// extract the inferred type like this&#xA;type Dog = z.infer&amp;lt;typeof Dog&amp;gt;;&#xA;&#xA;// equivalent to:&#xA;type Dog = {&#xA;  name: string;&#xA;  age: number;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.shape&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Use &lt;code&gt;.shape&lt;/code&gt; to access the schemas for a particular key.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;Dog.shape.name; // =&amp;gt; string schema&#xA;Dog.shape.age; // =&amp;gt; number schema&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.keyof&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Use &lt;code&gt;.key&lt;/code&gt; to create a &lt;code&gt;ZodEnum&lt;/code&gt; schema from the keys of an object schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const keySchema = Dog.keyof();&#xA;keySchema; // ZodEnum&amp;lt;[&#34;name&#34;, &#34;age&#34;]&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.extend&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can add additional fields to an object schema with the &lt;code&gt;.extend&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const DogWithBreed = Dog.extend({&#xA;  breed: z.string(),&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;.extend&lt;/code&gt; to overwrite fields! Be careful with this power!&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;.merge&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Equivalent to &lt;code&gt;A.extend(B.shape)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const BaseTeacher = z.object({ students: z.array(z.string()) });&#xA;const HasID = z.object({ id: z.string() });&#xA;&#xA;const Teacher = BaseTeacher.merge(HasID);&#xA;type Teacher = z.infer&amp;lt;typeof Teacher&amp;gt;; // =&amp;gt; { students: string[], id: string }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If the two schemas share keys, the properties of B overrides the property of A. The returned schema also inherits the &#34;unknownKeys&#34; policy (strip/strict/passthrough) and the catchall schema of B.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;&lt;code&gt;.pick/.omit&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Inspired by TypeScript&#39;s built-in &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Omit&lt;/code&gt; utility types, all Zod object schemas have &lt;code&gt;.pick&lt;/code&gt; and &lt;code&gt;.omit&lt;/code&gt; methods that return a modified version. Consider this Recipe schema:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const Recipe = z.object({&#xA;  id: z.string(),&#xA;  name: z.string(),&#xA;  ingredients: z.array(z.string()),&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To only keep certain keys, use &lt;code&gt;.pick&lt;/code&gt; .&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const JustTheName = Recipe.pick({ name: true });&#xA;type JustTheName = z.infer&amp;lt;typeof JustTheName&amp;gt;;&#xA;// =&amp;gt; { name: string }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To remove certain keys, use &lt;code&gt;.omit&lt;/code&gt; .&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const NoIDRecipe = Recipe.omit({ id: true });&#xA;&#xA;type NoIDRecipe = z.infer&amp;lt;typeof NoIDRecipe&amp;gt;;&#xA;// =&amp;gt; { name: string, ingredients: string[] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.partial&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Inspired by the built-in TypeScript utility type &lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt&#34;&gt;Partial&lt;/a&gt;, the &lt;code&gt;.partial&lt;/code&gt; method makes all properties optional.&lt;/p&gt; &#xA;&lt;p&gt;Starting from this object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const user = z.object({&#xA;  email: z.string()&#xA;  username: z.string(),&#xA;});&#xA;// { email: string; username: string }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can create a partial version:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const partialUser = user.partial();&#xA;// { email?: string | undefined; username?: string | undefined }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also specify which properties to make optional:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const optionalEmail = user.partial({&#xA;  email: true,&#xA;});&#xA;/*&#xA;{&#xA;  email?: string | undefined;&#xA;  username: string&#xA;}&#xA;*/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.deepPartial&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;.partial&lt;/code&gt; method is shallow — it only applies one level deep. There is also a &#34;deep&#34; version:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const user = z.object({&#xA;  username: z.string(),&#xA;  location: z.object({&#xA;    latitude: z.number(),&#xA;    longitude: z.number(),&#xA;  }),&#xA;  strings: z.array(z.object({ value: z.string() })),&#xA;});&#xA;&#xA;const deepPartialUser = user.deepPartial();&#xA;&#xA;/*&#xA;{&#xA;  username?: string | undefined,&#xA;  location?: {&#xA;    latitude?: number | undefined;&#xA;    longitude?: number | undefined;&#xA;  } | undefined,&#xA;  strings?: { value?: string}[]&#xA;}&#xA;*/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Important limitation: deep partials only work as expected in hierarchies of objects, arrays, and tuples.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;&lt;code&gt;.passthrough&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;By default Zod object schemas strip out unrecognized keys during parsing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const person = z.object({&#xA;  name: z.string(),&#xA;});&#xA;&#xA;person.parse({&#xA;  name: &#34;bob dylan&#34;,&#xA;  extraKey: 61,&#xA;});&#xA;// =&amp;gt; { name: &#34;bob dylan&#34; }&#xA;// extraKey has been stripped&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead, if you want to pass through unknown keys, use &lt;code&gt;.passthrough()&lt;/code&gt; .&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;person.passthrough().parse({&#xA;  name: &#34;bob dylan&#34;,&#xA;  extraKey: 61,&#xA;});&#xA;// =&amp;gt; { name: &#34;bob dylan&#34;, extraKey: 61 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.strict&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;By default Zod object schemas strip out unrecognized keys during parsing. You can &lt;em&gt;disallow&lt;/em&gt; unknown keys with &lt;code&gt;.strict()&lt;/code&gt; . If there are any unknown keys in the input, Zod will throw an error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const person = z&#xA;  .object({&#xA;    name: z.string(),&#xA;  })&#xA;  .strict();&#xA;&#xA;person.parse({&#xA;  name: &#34;bob dylan&#34;,&#xA;  extraKey: 61,&#xA;});&#xA;// =&amp;gt; throws ZodError&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.strip&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;.strip&lt;/code&gt; method to reset an object schema to the default behavior (stripping unrecognized keys).&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;.catchall&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can pass a &#34;catchall&#34; schema into an object schema. All unknown keys will be validated against it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const person = z&#xA;  .object({&#xA;    name: z.string(),&#xA;  })&#xA;  .catchall(z.number());&#xA;&#xA;person.parse({&#xA;  name: &#34;bob dylan&#34;,&#xA;  validExtraKey: 61, // works fine&#xA;});&#xA;&#xA;person.parse({&#xA;  name: &#34;bob dylan&#34;,&#xA;  validExtraKey: false, // fails&#xA;});&#xA;// =&amp;gt; throws ZodError&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using &lt;code&gt;.catchall()&lt;/code&gt; obviates &lt;code&gt;.passthrough()&lt;/code&gt; , &lt;code&gt;.strip()&lt;/code&gt; , or &lt;code&gt;.strict()&lt;/code&gt;. All keys are now considered &#34;known&#34;.&lt;/p&gt; &#xA;&lt;h2&gt;Arrays&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const stringArray = z.array(z.string());&#xA;&#xA;// equivalent&#xA;const stringArray = z.string().array();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Be careful with the &lt;code&gt;.array()&lt;/code&gt; method. It returns a new &lt;code&gt;ZodArray&lt;/code&gt; instance. This means the &lt;em&gt;order&lt;/em&gt; in which you call methods matters. For instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.string().optional().array(); // (string | undefined)[]&#xA;z.string().array().optional(); // string[] | undefined&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.element&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Use &lt;code&gt;.element&lt;/code&gt; to access the schema for an element of the array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;stringArray.element; // =&amp;gt; string schema&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.nonempty&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;If you want to ensure that an array contains at least one element, use &lt;code&gt;.nonempty()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const nonEmptyStrings = z.string().array().nonempty();&#xA;// the inferred type is now&#xA;// [string, ...string[]]&#xA;&#xA;nonEmptyStrings.parse([]); // throws: &#34;Array cannot be empty&#34;&#xA;nonEmptyStrings.parse([&#34;Ariana Grande&#34;]); // passes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can optionally specify a custom error message:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// optional custom error message&#xA;const nonEmptyStrings = z.string().array().nonempty({&#xA;  message: &#34;Can&#39;t be empty!&#34;,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.min/.max/.length&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.string().array().min(5); // must contain 5 or more items&#xA;z.string().array().max(5); // must contain 5 or fewer items&#xA;z.string().array().length(5); // must contain 5 items exactly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unlike &lt;code&gt;.nonempty()&lt;/code&gt; these methods do not change the inferred type.&lt;/p&gt; &#xA;&lt;h2&gt;Tuples&lt;/h2&gt; &#xA;&lt;p&gt;Unlike arrays, tuples have a fixed number of elements and each element can have a different type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const athleteSchema = z.tuple([&#xA;  z.string(), // name&#xA;  z.number(), // jersey number&#xA;  z.object({&#xA;    pointsScored: z.number(),&#xA;  }), // statistics&#xA;]);&#xA;&#xA;type Athlete = z.infer&amp;lt;typeof athleteSchema&amp;gt;;&#xA;// type Athlete = [string, number, { pointsScored: number }]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Unions&lt;/h2&gt; &#xA;&lt;p&gt;Zod includes a built-in &lt;code&gt;z.union&lt;/code&gt; method for composing &#34;OR&#34; types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const stringOrNumber = z.union([z.string(), z.number()]);&#xA;&#xA;stringOrNumber.parse(&#34;foo&#34;); // passes&#xA;stringOrNumber.parse(14); // passes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Zod will test the input against each of the &#34;options&#34; in order and return the first value that validates successfully.&lt;/p&gt; &#xA;&lt;p&gt;For convenience, you can also use the &lt;code&gt;.or&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const stringOrNumber = z.string().or(z.number());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Discriminated unions&lt;/h2&gt; &#xA;&lt;p&gt;If the union consists of object schemas all identifiable by a common property, it is possible to use the &lt;code&gt;z.discriminatedUnion&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;The advantage is in more efficient evaluation and more human friendly errors. With the basic union method the input is tested against each of the provided &#34;options&#34;, and in the case of invalidity, issues for all the &#34;options&#34; are shown in the zod error. On the other hand, the discriminated union allows for selecting just one of the &#34;options&#34;, testing against it, and showing only the issues related to this &#34;option&#34;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const item = z&#xA;  .discriminatedUnion(&#34;type&#34;, [&#xA;    z.object({ type: z.literal(&#34;a&#34;), a: z.string() }),&#xA;    z.object({ type: z.literal(&#34;b&#34;), b: z.string() }),&#xA;  ])&#xA;  .parse({ type: &#34;a&#34;, a: &#34;abc&#34; });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Records&lt;/h2&gt; &#xA;&lt;p&gt;Record schemas are used to validate types such as &lt;code&gt;{ [k: string]: number }&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to validate the &lt;em&gt;values&lt;/em&gt; of an object against some schema but don&#39;t care about the keys, use &lt;code&gt;z.record(valueType)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const NumberCache = z.record(z.number());&#xA;&#xA;type NumberCache = z.infer&amp;lt;typeof NumberCache&amp;gt;;&#xA;// =&amp;gt; { [k: string]: number }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is particularly useful for storing or caching items by ID.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const userStore: UserStore = {};&#xA;&#xA;userStore[&#34;77d2586b-9e8e-4ecf-8b21-ea7e0530eadd&#34;] = {&#xA;  name: &#34;Carlotta&#34;,&#xA;}; // passes&#xA;&#xA;userStore[&#34;77d2586b-9e8e-4ecf-8b21-ea7e0530eadd&#34;] = {&#xA;  whatever: &#34;Ice cream sundae&#34;,&#xA;}; // TypeError&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Record key type&lt;/h3&gt; &#xA;&lt;p&gt;If you want to validate both the keys and the values, use &lt;code&gt;z.record(keyType, valueType)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const NoEmptyKeysSchema = z.record(z.string().min(1), z.number());&#xA;NoEmptyKeysSchema.parse({ count: 1 }); // =&amp;gt; { &#39;count&#39;: 1 }&#xA;NoEmptyKeysSchema.parse({ &#34;&#34;: 1 }); // fails&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;(Notice how when passing two arguments, &lt;code&gt;valueType&lt;/code&gt; is the second argument)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;A note on numerical keys&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;While &lt;code&gt;z.record(keyType, valueType)&lt;/code&gt; is able to accept numerical key types and TypeScript&#39;s built-in Record type is &lt;code&gt;Record&amp;lt;KeyType, ValueType&amp;gt;&lt;/code&gt;, it&#39;s hard to represent the TypeScript type &lt;code&gt;Record&amp;lt;number, any&amp;gt;&lt;/code&gt; in Zod.&lt;/p&gt; &#xA;&lt;p&gt;As it turns out, TypeScript&#39;s behavior surrounding &lt;code&gt;[k: number]&lt;/code&gt; is a little unintuitive:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const testMap: { [k: number]: string } = {&#xA;  1: &#34;one&#34;,&#xA;};&#xA;&#xA;for (const key in testMap) {&#xA;  console.log(`${key}: ${typeof key}`);&#xA;}&#xA;// prints: `1: string`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, JavaScript automatically casts all object keys to strings under the hood. Since Zod is trying to bridge the gap between static and runtime types, it doesn&#39;t make sense to provide a way of creating a record schema with numerical keys, since there&#39;s no such thing as a numerical key in runtime JavaScript.&lt;/p&gt; &#xA;&lt;h2&gt;Maps&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const stringNumberMap = z.map(z.string(), z.number());&#xA;&#xA;type StringNumberMap = z.infer&amp;lt;typeof stringNumberMap&amp;gt;;&#xA;// type StringNumberMap = Map&amp;lt;string, number&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Sets&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const numberSet = z.set(z.number());&#xA;type NumberSet = z.infer&amp;lt;typeof numberSet&amp;gt;;&#xA;// type NumberSet = Set&amp;lt;number&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set schemas can be further contrainted with the following utility methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.set(z.string()).nonempty(); // must contain at least one item&#xA;z.set(z.string()).min(5); // must contain 5 or more items&#xA;z.set(z.string()).max(5); // must contain 5 or fewer items&#xA;z.set(z.string()).size(5); // must contain 5 items exactly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Intersections&lt;/h2&gt; &#xA;&lt;p&gt;Intersections are useful for creating &#34;logical AND&#34; types. This is useful for intersecting two object types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const Person = z.object({&#xA;  name: z.string(),&#xA;});&#xA;&#xA;const Employee = z.object({&#xA;  role: z.string(),&#xA;});&#xA;&#xA;const EmployedPerson = z.intersection(Person, Employee);&#xA;&#xA;// equivalent to:&#xA;const EmployedPerson = Person.and(Employee);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Though in many cases, it is recommended to use &lt;code&gt;A.merge(B)&lt;/code&gt; to merge two objects. The &lt;code&gt;.merge&lt;/code&gt; method returns a new &lt;code&gt;ZodObject&lt;/code&gt; instance, whereas &lt;code&gt;A.and(B)&lt;/code&gt; returns a less useful &lt;code&gt;ZodIntersection&lt;/code&gt; instance that lacks common object methods like &lt;code&gt;pick&lt;/code&gt; and &lt;code&gt;omit&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const a = z.union([z.number(), z.string()]);&#xA;const b = z.union([z.number(), z.boolean()]);&#xA;const c = z.intersection(a, b);&#xA;&#xA;type c = z.infer&amp;lt;typeof c&amp;gt;; // =&amp;gt; number&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;!-- Intersections in Zod are not smart. Whatever data you pass into `.parse()` gets passed into the two intersected schemas. Because Zod object schemas don&#39;t allow any unknown keys by default, there are some unintuitive behavior surrounding intersections of object schemas. --&gt; &#xA;&lt;!--&#xA;&#xA;``` ts&#xA;const A = z.object({&#xA;  a: z.string(),&#xA;});&#xA;&#xA;const B = z.object({&#xA;  b: z.string(),&#xA;});&#xA;&#xA;const AB = z.intersection(A, B);&#xA;&#xA;type Teacher = z.infer&lt;typeof Teacher&gt;;&#xA;// { id:string; name:string };&#xA;```  --&gt; &#xA;&lt;h2&gt;Recursive types&lt;/h2&gt; &#xA;&lt;p&gt;You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can&#39;t be statically inferred. Instead you&#39;ll need to define the type definition manually, and provide it to Zod as a &#34;type hint&#34;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;interface Category {&#xA;  name: string;&#xA;  subcategories: Category[];&#xA;}&#xA;&#xA;// cast to z.ZodType&amp;lt;Category&amp;gt;&#xA;const Category: z.ZodType&amp;lt;Category&amp;gt; = z.lazy(() =&amp;gt;&#xA;  z.object({&#xA;    name: z.string(),&#xA;    subcategories: z.array(Category),&#xA;  })&#xA;);&#xA;&#xA;Category.parse({&#xA;  name: &#34;People&#34;,&#xA;  subcategories: [&#xA;    {&#xA;      name: &#34;Politicians&#34;,&#xA;      subcategories: [{ name: &#34;Presidents&#34;, subcategories: [] }],&#xA;    },&#xA;  ],&#xA;}); // passes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unfortunately this code is a bit duplicative, since you&#39;re declaring the types twice: once in the interface and again in the Zod definition.&lt;/p&gt; &#xA;&lt;!-- If your schema has lots of primitive fields, there&#39;s a way of reducing the amount of duplication:&#xA;&#xA;```ts&#xA;// define all the non-recursive stuff here&#xA;const BaseCategory = z.object({&#xA;  name: z.string(),&#xA;  tags: z.array(z.string()),&#xA;  itemCount: z.number(),&#xA;});&#xA;&#xA;// create an interface that extends the base schema&#xA;interface Category extends z.infer&lt;typeof BaseCategory&gt; {&#xA;  subcategories: Category[];&#xA;}&#xA;&#xA;// merge the base schema with&#xA;// a new Zod schema containing relations&#xA;const Category: z.ZodType&lt;Category&gt; = BaseCategory.merge(&#xA;  z.object({&#xA;    subcategories: z.lazy(() =&gt; z.array(Category)),&#xA;  })&#xA;);&#xA;``` --&gt; &#xA;&lt;h3&gt;JSON type&lt;/h3&gt; &#xA;&lt;p&gt;If you want to validate any JSON value, you can use the snippet below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);&#xA;type Literal = z.infer&amp;lt;typeof literalSchema&amp;gt;;&#xA;type Json = Literal | { [key: string]: Json } | Json[];&#xA;const jsonSchema: z.ZodType&amp;lt;Json&amp;gt; = z.lazy(() =&amp;gt;&#xA;  z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])&#xA;);&#xA;&#xA;jsonSchema.parse(data);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Thanks to &lt;a href=&#34;https://github.com/ggoodman&#34;&gt;ggoodman&lt;/a&gt; for suggesting this.&lt;/p&gt; &#xA;&lt;h3&gt;Cyclical objects&lt;/h3&gt; &#xA;&lt;p&gt;Despite supporting recursive schemas, passing cyclical data into Zod will cause an infinite loop.&lt;/p&gt; &#xA;&lt;h2&gt;Promises&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const numberPromise = z.promise(z.number());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&#34;Parsing&#34; works a little differently with promise schemas. Validation happens in two parts:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Zod synchronously checks that the input is an instance of Promise (i.e. an object with &lt;code&gt;.then&lt;/code&gt; and &lt;code&gt;.catch&lt;/code&gt; methods.).&lt;/li&gt; &#xA; &lt;li&gt;Zod uses &lt;code&gt;.then&lt;/code&gt; to attach an additional validation step onto the existing Promise. You&#39;ll have to use &lt;code&gt;.catch&lt;/code&gt; on the returned Promise to handle validation failures.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;numberPromise.parse(&#34;tuna&#34;);&#xA;// ZodError: Non-Promise type: string&#xA;&#xA;numberPromise.parse(Promise.resolve(&#34;tuna&#34;));&#xA;// =&amp;gt; Promise&amp;lt;number&amp;gt;&#xA;&#xA;const test = async () =&amp;gt; {&#xA;  await numberPromise.parse(Promise.resolve(&#34;tuna&#34;));&#xA;  // ZodError: Non-number type: string&#xA;&#xA;  await numberPromise.parse(Promise.resolve(3.14));&#xA;  // =&amp;gt; 3.14&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;!-- #### Non-native promise implementations&#xA;&#xA;When &#34;parsing&#34; a promise, Zod checks that the passed value is an object with `.then` and `.catch` methods — that&#39;s it. So you should be able to pass non-native Promises (Bluebird, etc) into `z.promise(...).parse` with no trouble. One gotcha: the return type of the parse function will be a _native_ `Promise` , so if you have downstream logic that uses non-standard Promise methods, this won&#39;t work. --&gt; &#xA;&lt;h2&gt;Instanceof&lt;/h2&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;z.instanceof&lt;/code&gt; to check that the input is an instance of a class. This is useful to validate inputs against classes that are exported from third-party libraries.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class Test {&#xA;  name: string;&#xA;}&#xA;&#xA;const TestSchema = z.instanceof(Test);&#xA;&#xA;const blob: any = &#34;whatever&#34;;&#xA;TestSchema.parse(new Test()); // passes&#xA;TestSchema.parse(&#34;blob&#34;); // throws&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Function schemas&lt;/h2&gt; &#xA;&lt;p&gt;Zod also lets you define &#34;function schemas&#34;. This makes it easy to validate the inputs and outputs of a function without intermixing your validation code and &#34;business logic&#34;.&lt;/p&gt; &#xA;&lt;p&gt;You can create a function schema with &lt;code&gt;z.function(args, returnType)&lt;/code&gt; .&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const myFunction = z.function();&#xA;&#xA;type myFunction = z.infer&amp;lt;typeof myFunction&amp;gt;;&#xA;// =&amp;gt; ()=&amp;gt;unknown&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Define inputs and outputs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const myFunction = z&#xA;  .function()&#xA;  .args(z.string(), z.number()) // accepts an arbitrary number of arguments&#xA;  .returns(z.boolean());&#xA;type myFunction = z.infer&amp;lt;typeof myFunction&amp;gt;;&#xA;// =&amp;gt; (arg0: string, arg1: number)=&amp;gt;boolean&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;!--&#xA;&#xA;``` ts&#xA;const args = z.tuple([z.string()]);&#xA;&#xA;const returnType = z.number();&#xA;&#xA;const myFunction = z.function(args, returnType);&#xA;type myFunction = z.infer&lt;typeof myFunction&gt;;&#xA;// =&gt; (arg0: string)=&gt;number&#xA;``` --&gt; &#xA;&lt;p&gt;Function schemas have an &lt;code&gt;.implement()&lt;/code&gt; method which accepts a function and returns a new function that automatically validates its inputs and outputs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const trimmedLength = z&#xA;  .function()&#xA;  .args(z.string()) // accepts an arbitrary number of arguments&#xA;  .returns(z.number())&#xA;  .implement((x) =&amp;gt; {&#xA;    // TypeScript knows x is a string!&#xA;    return x.trim().length;&#xA;  });&#xA;&#xA;trimmedLength(&#34;sandwich&#34;); // =&amp;gt; 8&#xA;trimmedLength(&#34; asdf &#34;); // =&amp;gt; 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you only care about validating inputs, just don&#39;t call the &lt;code&gt;.returns()&lt;/code&gt; method. The output type will be inferred from the implementation.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;You can use the special &lt;code&gt;z.void()&lt;/code&gt; option if your function doesn&#39;t return anything. This will let Zod properly infer the type of void-returning functions. (Void-returning functions actually return undefined.)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const myFunction = z&#xA;  .function()&#xA;  .args(z.string())&#xA;  .implement((arg) =&amp;gt; {&#xA;    return [arg.length]; //&#xA;  });&#xA;myFunction; // (arg: string)=&amp;gt;number[]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Extract the input and output schemas from a function schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;myFunction.parameters();&#xA;// =&amp;gt; ZodTuple&amp;lt;[ZodString, ZodNumber]&amp;gt;&#xA;&#xA;myFunction.returnType();&#xA;// =&amp;gt; ZodBoolean&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;!-- `z.function()` accepts two arguments:&#xA;&#xA;* `args: ZodTuple` The first argument is a tuple (created with `z.tuple([...])` and defines the schema of the arguments to your function. If the function doesn&#39;t accept arguments, you can pass an empty tuple (`z.tuple([])`).&#xA;* `returnType: any Zod schema` The second argument is the function&#39;s return type. This can be any Zod schema. --&gt; &#xA;&lt;h2&gt;Preprocess&lt;/h2&gt; &#xA;&lt;p&gt;Typically Zod operates under a &#34;parse then transform&#34; paradigm. Zod validates the input first, then passes it through a chain of transformation functions. (For more information about transforms, read the &lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#transform&#34;&gt;.transform docs&lt;/a&gt;.)&lt;/p&gt; &#xA;&lt;p&gt;But sometimes you want to apply some transform to the input &lt;em&gt;before&lt;/em&gt; parsing happens. A common use case: type coercion. Zod enables this with the &lt;code&gt;z.preprocess()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const castToString = z.preprocess((val) =&amp;gt; String(val), z.string());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This returns a &lt;code&gt;ZodEffects&lt;/code&gt; instance. &lt;code&gt;ZodEffects&lt;/code&gt; is a wrapper class that contains all logic pertaining to preprocessing, refinements, and transforms.&lt;/p&gt; &#xA;&lt;h2&gt;Schema methods&lt;/h2&gt; &#xA;&lt;p&gt;All Zod schemas contain certain methods.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;.parse&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;.parse(data:unknown): T&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Given any Zod schema, you can call its &lt;code&gt;.parse&lt;/code&gt; method to check &lt;code&gt;data&lt;/code&gt; is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;IMPORTANT: The value returned by &lt;code&gt;.parse&lt;/code&gt; is a &lt;em&gt;deep clone&lt;/em&gt; of the variable you passed in.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const stringSchema = z.string();&#xA;stringSchema.parse(&#34;fish&#34;); // =&amp;gt; returns &#34;fish&#34;&#xA;stringSchema.parse(12); // throws Error(&#39;Non-string type: number&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.parseAsync&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;.parseAsync(data:unknown): Promise&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you use asynchronous &lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#refine&#34;&gt;refinements&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#transform&#34;&gt;transforms&lt;/a&gt; (more on those later), you&#39;ll need to use &lt;code&gt;.parseAsync&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const stringSchema1 = z.string().refine(async (val) =&amp;gt; val.length &amp;lt; 20);&#xA;const value1 = await stringSchema.parseAsync(&#34;hello&#34;); // =&amp;gt; hello&#xA;&#xA;const stringSchema2 = z.string().refine(async (val) =&amp;gt; val.length &amp;gt; 20);&#xA;const value2 = await stringSchema.parseAsync(&#34;hello&#34;); // =&amp;gt; throws&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.safeParse&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;.safeParse(data:unknown): { success: true; data: T; } | { success: false; error: ZodError; }&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t want Zod to throw errors when validation fails, use &lt;code&gt;.safeParse&lt;/code&gt;. This method returns an object containing either the successfully parsed data or a ZodError instance containing detailed information about the validation problems.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;stringSchema.safeParse(12);&#xA;// =&amp;gt; { success: false; error: ZodError }&#xA;&#xA;stringSchema.safeParse(&#34;billie&#34;);&#xA;// =&amp;gt; { success: true; data: &#39;billie&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result is a &lt;em&gt;discriminated union&lt;/em&gt; so you can handle errors very conveniently:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const result = stringSchema.safeParse(&#34;billie&#34;);&#xA;if (!result.success) {&#xA;  // handle error then return&#xA;  result.error;&#xA;} else {&#xA;  // do something&#xA;  result.data;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.safeParseAsync&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Alias: &lt;code&gt;.spa&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;An asynchronous version of &lt;code&gt;safeParse&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;await stringSchema.safeParseAsync(&#34;billie&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For convenience, this has been aliased to &lt;code&gt;.spa&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;await stringSchema.spa(&#34;billie&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.refine&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;.refine(validator: (data:T)=&amp;gt;any, params?: RefineParams)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Zod lets you provide custom validation logic via &lt;em&gt;refinements&lt;/em&gt;. (For advanced features like creating multiple issues and customizing error codes, see &lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/#superrefine&#34;&gt;&lt;code&gt;.superRefine&lt;/code&gt;&lt;/a&gt;.)&lt;/p&gt; &#xA;&lt;p&gt;Zod was designed to mirror TypeScript as closely as possible. But there are many so-called &#34;refinement types&#34; you may wish to check for that can&#39;t be represented in TypeScript&#39;s type system. For instance: checking that a number is an integer or that a string is a valid email address.&lt;/p&gt; &#xA;&lt;p&gt;For example, you can define a custom validation check on &lt;em&gt;any&lt;/em&gt; Zod schema with &lt;code&gt;.refine&lt;/code&gt; :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const myString = z.string().refine((val) =&amp;gt; val.length &amp;lt;= 255, {&#xA;  message: &#34;String can&#39;t be more than 255 characters&#34;,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ Refinement functions should not throw. Instead they should return a falsy value to signal failure.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Arguments&lt;/h4&gt; &#xA;&lt;p&gt;As you can see, &lt;code&gt;.refine&lt;/code&gt; takes two arguments.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The first is the validation function. This function takes one input (of type &lt;code&gt;T&lt;/code&gt; — the inferred type of the schema) and returns &lt;code&gt;any&lt;/code&gt;. Any truthy value will pass validation. (Prior to zod@1.6.2 the validation function had to return a boolean.)&lt;/li&gt; &#xA; &lt;li&gt;The second argument accepts some options. You can use this to customize certain error-handling behavior:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;type RefineParams = {&#xA;  // override error message&#xA;  message?: string;&#xA;&#xA;  // appended to error path&#xA;  path?: (string | number)[];&#xA;&#xA;  // params object you can use to customize message&#xA;  // in error map&#xA;  params?: object;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For advanced cases, the second argument can also be a function that returns &lt;code&gt;RefineParams&lt;/code&gt;/&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.string().refine(&#xA;  (val) =&amp;gt; val.length &amp;gt; 10,&#xA;  (val) =&amp;gt; ({ message: `${val} is not more than 10 characters` })&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Customize error path&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const passwordForm = z&#xA;  .object({&#xA;    password: z.string(),&#xA;    confirm: z.string(),&#xA;  })&#xA;  .refine((data) =&amp;gt; data.password === data.confirm, {&#xA;    message: &#34;Passwords don&#39;t match&#34;,&#xA;    path: [&#34;confirm&#34;], // path of error&#xA;  })&#xA;  .parse({ password: &#34;asdf&#34;, confirm: &#34;qwer&#34; });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because you provided a &lt;code&gt;path&lt;/code&gt; parameter, the resulting error will be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;ZodError {&#xA;  issues: [{&#xA;    &#34;code&#34;: &#34;custom&#34;,&#xA;    &#34;path&#34;: [ &#34;confirm&#34; ],&#xA;    &#34;message&#34;: &#34;Passwords don&#39;t match&#34;&#xA;  }]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Asynchronous refinements&lt;/h4&gt; &#xA;&lt;p&gt;Refinements can also be async:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const userId = z.string().refine(async (id) =&amp;gt; {&#xA;  // verify that ID exists in database&#xA;  return true;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ If you use async refinements, you must use the &lt;code&gt;.parseAsync&lt;/code&gt; method to parse data! Otherwise Zod will throw an error.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Relationship to transforms&lt;/h4&gt; &#xA;&lt;p&gt;Transforms and refinements can be interleaved:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.string()&#xA;  .transform((val) =&amp;gt; val.length)&#xA;  .refine((val) =&amp;gt; val &amp;gt; 25);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;!-- Note that the `path` is set to `[&#34;confirm&#34;]` , so you can easily display this error underneath the &#34;Confirm password&#34; textbox.&#xA;&#xA;&#xA;```ts&#xA;const allForms = z.object({ passwordForm }).parse({&#xA;  passwordForm: {&#xA;    password: &#34;asdf&#34;,&#xA;    confirm: &#34;qwer&#34;,&#xA;  },&#xA;});&#xA;```&#xA;&#xA;would result in&#xA;&#xA;```&#xA;&#xA;ZodError {&#xA;  issues: [{&#xA;    &#34;code&#34;: &#34;custom&#34;,&#xA;    &#34;path&#34;: [ &#34;passwordForm&#34;, &#34;confirm&#34; ],&#xA;    &#34;message&#34;: &#34;Passwords don&#39;t match&#34;&#xA;  }]&#xA;}&#xA;``` --&gt; &#xA;&lt;h3&gt;&lt;code&gt;.superRefine&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;.refine&lt;/code&gt; method is actually syntactic sugar atop a more versatile (and verbose) method called &lt;code&gt;superRefine&lt;/code&gt;. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const Strings = z.array(z.string()).superRefine((val, ctx) =&amp;gt; {&#xA;  if (val.length &amp;gt; 3) {&#xA;    ctx.addIssue({&#xA;      code: z.ZodIssueCode.too_big,&#xA;      maximum: 3,&#xA;      type: &#34;array&#34;,&#xA;      inclusive: true,&#xA;      message: &#34;Too many items 😡&#34;,&#xA;    });&#xA;  }&#xA;&#xA;  if (val.length !== new Set(val).size) {&#xA;    ctx.addIssue({&#xA;      code: z.ZodIssueCode.custom,&#xA;      message: `No duplicates allowed.`,&#xA;    });&#xA;  }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can add as many issues as you like. If &lt;code&gt;ctx.addIssue&lt;/code&gt; is NOT called during the execution of the function, validation passes.&lt;/p&gt; &#xA;&lt;p&gt;Normally refinements always create issues with a &lt;code&gt;ZodIssueCode.custom&lt;/code&gt; error code, but with &lt;code&gt;superRefine&lt;/code&gt; you can create any issue of any code. Each issue code is described in detail in the Error Handling guide: &lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/ERROR_HANDLING.md&#34;&gt;ERROR_HANDLING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Abort early&lt;/h4&gt; &#xA;&lt;p&gt;By default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to &lt;em&gt;abort early&lt;/em&gt; to prevent later refinements from being executed. To achieve this, pass the &lt;code&gt;fatal&lt;/code&gt; flag to &lt;code&gt;ctx.addIssue&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const Strings = z&#xA;  .number()&#xA;  .superRefine((val, ctx) =&amp;gt; {&#xA;    if (val &amp;lt; 10) {&#xA;      ctx.addIssue({&#xA;        code: z.ZodIssueCode.custom,&#xA;        message: &#34;foo&#34;,&#xA;        fatal: true,&#xA;      });&#xA;    }&#xA;  })&#xA;  .superRefine((val, ctx) =&amp;gt; {&#xA;    if (val !== &#34; &#34;) {&#xA;      ctx.addIssue({&#xA;        code: z.ZodIssueCode.custom,&#xA;        message: &#34;bar&#34;,&#xA;      });&#xA;    }&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.transform&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;To transform data after parsing, use the &lt;code&gt;transform&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const stringToNumber = z.string().transform((val) =&amp;gt; val.length);&#xA;stringToNumber.parse(&#34;string&#34;); // =&amp;gt; 6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ Transform functions must not throw. Make sure to use refinements before the transform or addIssue within the transform to make sure the input can be parsed by the transform.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Chaining order&lt;/h4&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;stringToNumber&lt;/code&gt; above is an instance of the &lt;code&gt;ZodEffects&lt;/code&gt; subclass. It is NOT an instance of &lt;code&gt;ZodString&lt;/code&gt;. If you want to use the built-in methods of &lt;code&gt;ZodString&lt;/code&gt; (e.g. &lt;code&gt;.email()&lt;/code&gt;) you must apply those methods &lt;em&gt;before&lt;/em&gt; any transforms.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const emailToDomain = z&#xA;  .string()&#xA;  .email()&#xA;  .transform((val) =&amp;gt; val.split(&#34;@&#34;)[1]);&#xA;&#xA;emailToDomain.parse(&#34;colinhacks@example.com&#34;); // =&amp;gt; example.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Validating during transform&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;superRefine&lt;/code&gt;, &lt;code&gt;transform&lt;/code&gt; can optionally take a &lt;code&gt;ctx&lt;/code&gt;. This allows you to simultaneously validate and transform the value, which can be simpler than chaining &lt;code&gt;refine&lt;/code&gt; and &lt;code&gt;validate&lt;/code&gt;. When calling &lt;code&gt;ctx.addIssue&lt;/code&gt; make sure to still return a value of the correct type otherwise the inferred type will include &lt;code&gt;undefined&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const Strings = z.string().transform((val, ctx) =&amp;gt; {&#xA;  const parsed = parseInt(val);&#xA;  if (isNaN(parsed)) {&#xA;    ctx.addIssue({&#xA;      code: z.ZodIssueCode.custom,&#xA;      message: &#34;Not a number&#34;,&#xA;    });&#xA;  }&#xA;  return parsed;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Relationship to refinements&lt;/h4&gt; &#xA;&lt;p&gt;Transforms and refinements can be interleaved. These will be executed in the order they are declared.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.string()&#xA;  .transform((val) =&amp;gt; val.toUpperCase())&#xA;  .refine((val) =&amp;gt; val.length &amp;gt; 15)&#xA;  .transform((val) =&amp;gt; `Hello ${val}`)&#xA;  .refine((val) =&amp;gt; val.indexOf(&#34;!&#34;) === -1);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Async transforms&lt;/h4&gt; &#xA;&lt;p&gt;Transforms can also be async.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const IdToUser = z&#xA;  .string()&#xA;  .uuid()&#xA;  .transform(async (id) =&amp;gt; {&#xA;    return await getUserById(id);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ If your schema contains asynchronous transforms, you must use .parseAsync() or .safeParseAsync() to parse data. Otherwise Zod will throw an error.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;&lt;code&gt;.default&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can use transforms to implement the concept of &#34;default values&#34; in Zod.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const stringWithDefault = z.string().default(&#34;tuna&#34;);&#xA;&#xA;stringWithDefault.parse(undefined); // =&amp;gt; &#34;tuna&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Optionally, you can pass a function into &lt;code&gt;.default&lt;/code&gt; that will be re-executed whenever a default value needs to be generated:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const numberWithRandomDefault = z.number().default(Math.random);&#xA;&#xA;numberWithRandomDefault.parse(undefined); // =&amp;gt; 0.4413456736055323&#xA;numberWithRandomDefault.parse(undefined); // =&amp;gt; 0.1871840107401901&#xA;numberWithRandomDefault.parse(undefined); // =&amp;gt; 0.7223408162401552&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.optional&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A convenience method that returns an optional version of a schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const optionalString = z.string().optional(); // string | undefined&#xA;&#xA;// equivalent to&#xA;z.optional(z.string());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.nullable&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A convenience method that returns a nullable version of a schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const nullableString = z.string().nullable(); // string | null&#xA;&#xA;// equivalent to&#xA;z.nullable(z.string());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.nullish&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A convenience method that returns a &#34;nullish&#34; version of a schema. Nullish schemas will accept both &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;. Read more about the concept of &#34;nullish&#34; &lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing&#34;&gt;in the TypeScript 3.7 release notes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const nullishString = z.string().nullish(); // string | null | undefined&#xA;&#xA;// equivalent to&#xA;z.string().optional().nullable();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.array&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A convenience method that returns an array schema for the given type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const nullableString = z.string().array(); // string[]&#xA;&#xA;// equivalent to&#xA;z.array(z.string());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.promise&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A convenience method for promise types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const stringPromise = z.string().promise(); // Promise&amp;lt;string&amp;gt;&#xA;&#xA;// equivalent to&#xA;z.promise(z.string());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.or&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A convenience method for union types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.string().or(z.number()); // string | number&#xA;&#xA;// equivalent to&#xA;z.union([z.string(), z.number()]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.and&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A convenience method for creating intersection types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;z.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: string } &amp;amp; { age: number }&#xA;&#xA;// equivalent to&#xA;z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Guides and concepts&lt;/h2&gt; &#xA;&lt;h3&gt;Type inference&lt;/h3&gt; &#xA;&lt;p&gt;You can extract the TypeScript type of any schema with &lt;code&gt;z.infer&amp;lt;typeof mySchema&amp;gt;&lt;/code&gt; .&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const A = z.string();&#xA;type A = z.infer&amp;lt;typeof A&amp;gt;; // string&#xA;&#xA;const u: A = 12; // TypeError&#xA;const u: A = &#34;asdf&#34;; // compiles&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;What about transforms?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;In reality each Zod schema internally tracks &lt;strong&gt;two&lt;/strong&gt; types: an input and an output. For most schemas (e.g. &lt;code&gt;z.string()&lt;/code&gt;) these two are the same. But once you add transforms into the mix, these two values can diverge. For instance &lt;code&gt;z.string().transform(val =&amp;gt; val.length)&lt;/code&gt; has an input of &lt;code&gt;string&lt;/code&gt; and an output of &lt;code&gt;number&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can separately extract the input and output types like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const stringToNumber = z.string().transform((val) =&amp;gt; val.length);&#xA;&#xA;// ⚠️ Important: z.infer returns the OUTPUT type!&#xA;type input = z.input&amp;lt;typeof stringToNumber&amp;gt;; // string&#xA;type output = z.output&amp;lt;typeof stringToNumber&amp;gt;; // number&#xA;&#xA;// equivalent to z.output!&#xA;type inferred = z.infer&amp;lt;typeof stringToNumber&amp;gt;; // number&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Writing generic functions&lt;/h3&gt; &#xA;&lt;p&gt;When attempting to write a functions that accepts a Zod schemas as an input, it&#39;s common to try something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function makeSchemaOptional&amp;lt;T&amp;gt;(schema: z.ZodType&amp;lt;T&amp;gt;) {&#xA;  return schema.optional();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This approach has some issues. The &lt;code&gt;schema&lt;/code&gt; variable in this function is typed as an instance of &lt;code&gt;ZodType&lt;/code&gt;, which is an abstract class that all Zod schemas inherit from. This approach loses type information, namely &lt;em&gt;which subclass&lt;/em&gt; the input actually is.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const arg = makeSchemaOptional(z.string());&#xA;arg.unwrap();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A better approach is for the generate parameter to refer to &lt;em&gt;the schema as a whole&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function makeSchemaOptional&amp;lt;T extends z.ZodTypeAny&amp;gt;(schema: T) {&#xA;  return schema.optional();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;ZodTypeAny&lt;/code&gt; is just a shorthand for &lt;code&gt;ZodType&amp;lt;any, any, any&amp;gt;&lt;/code&gt;, a type that is broad enough to match any Zod schema.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;As you can see, &lt;code&gt;schema&lt;/code&gt; is now fully and properly typed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const arg = makeSchemaOptional(z.string());&#xA;arg.unwrap(); // ZodString&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Constraining allowable inputs&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;ZodType&lt;/code&gt; class has three generic parameters.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class ZodType&amp;lt;&#xA;  Output = any,&#xA;  Def extends ZodTypeDef = ZodTypeDef,&#xA;  Input = Output&#xA;&amp;gt; { ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By constraining these in your generic input, you can limit what schemas are allowable as inputs to your function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function makeSchemaOptional&amp;lt;T extends z.ZodType&amp;lt;string&amp;gt;&amp;gt;(schema: T) {&#xA;  return schema.optional();&#xA;}&#xA;&#xA;makeSchemaOptional(z.string());&#xA;// works fine&#xA;&#xA;makeSchemaOptional(z.number());&#xA;// Error: &#39;ZodNumber&#39; is not assignable to parameter of type &#39;ZodType&amp;lt;string, ZodTypeDef, string&amp;gt;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Error handling&lt;/h3&gt; &#xA;&lt;p&gt;Zod provides a subclass of Error called &lt;code&gt;ZodError&lt;/code&gt;. ZodErrors contain an &lt;code&gt;issues&lt;/code&gt; array containing detailed information about the validation problems.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const data = z&#xA;  .object({&#xA;    name: z.string(),&#xA;  })&#xA;  .safeParse({ name: 12 });&#xA;&#xA;if (!data.success) {&#xA;  data.error.issues;&#xA;  /* [&#xA;      {&#xA;        &#34;code&#34;: &#34;invalid_type&#34;,&#xA;        &#34;expected&#34;: &#34;string&#34;,&#xA;        &#34;received&#34;: &#34;number&#34;,&#xA;        &#34;path&#34;: [ &#34;name&#34; ],&#xA;        &#34;message&#34;: &#34;Expected string, received number&#34;&#xA;      }&#xA;  ] */&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;For detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide: &lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/ERROR_HANDLING.md&#34;&gt;ERROR_HANDLING.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Error formatting&lt;/h3&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;.format()&lt;/code&gt; method to convert this error into a nested object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const data = z&#xA;  .object({&#xA;    name: z.string(),&#xA;  })&#xA;  .safeParse({ name: 12 });&#xA;&#xA;if (!data.success) {&#xA;  const formatted = data.error.format();&#xA;  /* {&#xA;    name: { _errors: [ &#39;Expected string, received number&#39; ] }&#xA;  } */&#xA;&#xA;  formatted.name?._errors;&#xA;  // =&amp;gt; [&#34;Expected string, received number&#34;]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Comparison&lt;/h2&gt; &#xA;&lt;p&gt;There are a handful of other widely-used validation libraries, but all of them have certain design limitations that make for a non-ideal developer experience.&lt;/p&gt; &#xA;&lt;!-- The table below summarizes the feature differences. Below the table there are more involved discussions of certain alternatives, where necessary. --&gt; &#xA;&lt;!-- | Feature                                                                                                                | [Zod](https://github.com/colinhacks) | [Joi](https://github.com/hapijs/joi) | [Yup](https://github.com/jquense/yup) | [io-ts](https://github.com/gcanti/io-ts) | [Runtypes](https://github.com/pelotom/runtypes) | [ow](https://github.com/sindresorhus/ow) | [class-validator](https://github.com/typestack/class-validator) |&#xA;| ---------------------------------------------------------------------------------------------------------------------- | :-----------------------------: | :----------------------------------: | :-----------------------------------: | :--------------------------------------: | :---------------------------------------------: | :--------------------------------------: | :-------------------------------------------------------------: |&#xA;| &lt;abbr title=&#39;Any ability to extract a TypeScript type from a validator instance counts.&#39;&gt;Type inference&lt;/abbr&gt;         |               🟢                |                  🔴                  |                  🟢                   |                    🟢                    |                       🟢                        |                    🟢                    |                               🟢                                |&#xA;| &lt;abbr title=&#34;Yup&#39;s inferred types are incorrect in certain cases, see discussion below.&#34;&gt;Correct type inference&lt;/abbr&gt; |               🟢                |                  🔴                  |                  🔴                   |                    🟢                    |                       🟢                        |                    🟢                    |                               🟢                                |&#xA;&#xA;&lt;abbr title=&#34;number, string, boolean, null, undefined&#34;&gt;Primitive Types&lt;/abbr&gt;&#xA;&lt;abbr title=&#34;Includes any checks beyond &#39;Is this a string?&#39;, e.g. min/max length, isEmail, isURL, case checking, etc.&#34;&gt;String Validation&lt;/abbr&gt;&#xA;&lt;abbr title=&#34;Includes any checks beyond &#39;Is this a number?&#39;, e.g. min/max, isPositive, integer vs float, etc.&#34;&gt;Number Validation&lt;/abbr&gt;&#xA;Dates&#xA;&#xA;Primitive Literals&#xA;Object Literals&#xA;Tuple Literals&#xA;Objects&#xA;Arrays&#xA;Non-empty arrays&#xA;Unions&#xA;Optionals&#xA;Nullable&#xA;Enums&#xA;Enum Autocomplete&#xA;Intersections&#xA;Object Merging&#xA;Tuples&#xA;Recursive Types&#xA;Function Schemas&#xA;&#xA;&lt;abbr title=&#34;For instance, Yup allows custom error messages with the syntax yup.number().min(5, &#39;Number must be more than 5!&#39;)&#34;&gt;Validation Messages&lt;/abbr&gt;&#xA;Immutable instances&#xA;Type Guards&#xA;Validity Checking&#xA;Casting&#xA;Default Values&#xA;Rich Errors&#xA;Branded --&gt; &#xA;&lt;!-- - Missing object methods: (pick, omit, partial, deepPartial, merge, extend)&#xA;&#xA;* Missing nonempty arrays with proper typing (`[T, ...T[]]`)&#xA;* Missing lazy/recursive types&#xA;* Missing promise schemas&#xA;* Missing function schemas&#xA;* Missing union &amp; intersection schemas&#xA;* Missing support for parsing cyclical data (maybe)&#xA;* Missing error customization --&gt; &#xA;&lt;h3&gt;Joi&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/hapijs/joi&#34;&gt;https://github.com/hapijs/joi&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Doesn&#39;t support static type inference 😕&lt;/p&gt; &#xA;&lt;h3&gt;Yup&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/jquense/yup&#34;&gt;https://github.com/jquense/yup&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Yup is a full-featured library that was implemented first in vanilla JS, and later rewritten in TypeScript.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports casting and transforms&lt;/li&gt; &#xA; &lt;li&gt;All object fields are optional by default&lt;/li&gt; &#xA; &lt;li&gt;Missing object methods: (partial, deepPartial)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- - Missing nonempty arrays with proper typing (`[T, ...T[]]`) --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Missing promise schemas&lt;/li&gt; &#xA; &lt;li&gt;Missing function schemas&lt;/li&gt; &#xA; &lt;li&gt;Missing union &amp;amp; intersection schemas&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- ¹Yup has a strange interpretation of the word `required`. Instead of meaning &#34;not undefined&#34;, Yup uses it to mean &#34;not empty&#34;. So `yup.string().required()` will not accept an empty string, and `yup.array(yup.string()).required()` will not accept an empty array. Instead, Yup us Zod arrays there is a dedicated `.nonempty()` method to indicate this, or you can implement it with a custom refinement. --&gt; &#xA;&lt;h3&gt;io-ts&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/gcanti/io-ts&#34;&gt;https://github.com/gcanti/io-ts&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;io-ts is an excellent library by gcanti. The API of io-ts heavily inspired the design of Zod.&lt;/p&gt; &#xA;&lt;p&gt;In our experience, io-ts prioritizes functional programming purity over developer experience in many cases. This is a valid and admirable design goal, but it makes io-ts particularly hard to integrate into an existing codebase with a more procedural or object-oriented bias. For instance, consider how to define an object with optional properties in io-ts:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import * as t from &#34;io-ts&#34;;&#xA;&#xA;const A = t.type({&#xA;  foo: t.string,&#xA;});&#xA;&#xA;const B = t.partial({&#xA;  bar: t.number,&#xA;});&#xA;&#xA;const C = t.intersection([A, B]);&#xA;&#xA;type C = t.TypeOf&amp;lt;typeof C&amp;gt;;&#xA;// returns { foo: string; bar?: number | undefined }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You must define the required and optional props in separate object validators, pass the optionals through &lt;code&gt;t.partial&lt;/code&gt; (which marks all properties as optional), then combine them with &lt;code&gt;t.intersection&lt;/code&gt; .&lt;/p&gt; &#xA;&lt;p&gt;Consider the equivalent in Zod:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const C = z.object({&#xA;  foo: z.string(),&#xA;  bar: z.number().optional(),&#xA;});&#xA;&#xA;type C = z.infer&amp;lt;typeof C&amp;gt;;&#xA;// returns { foo: string; bar?: number | undefined }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This more declarative API makes schema definitions vastly more concise.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;io-ts&lt;/code&gt; also requires the use of gcanti&#39;s functional programming library &lt;code&gt;fp-ts&lt;/code&gt; to parse results and handle errors. This is another fantastic resource for developers looking to keep their codebase strictly functional. But depending on &lt;code&gt;fp-ts&lt;/code&gt; necessarily comes with a lot of intellectual overhead; a developer has to be familiar with functional programming concepts and the &lt;code&gt;fp-ts&lt;/code&gt; nomenclature to use the library.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports codecs with serialization &amp;amp; deserialization transforms&lt;/li&gt; &#xA; &lt;li&gt;Supports branded types&lt;/li&gt; &#xA; &lt;li&gt;Supports advanced functional programming, higher-kinded types, &lt;code&gt;fp-ts&lt;/code&gt; compatibility&lt;/li&gt; &#xA; &lt;li&gt;Missing object methods: (pick, omit, partial, deepPartial, merge, extend)&lt;/li&gt; &#xA; &lt;li&gt;Missing nonempty arrays with proper typing (&lt;code&gt;[T, ...T[]]&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Missing promise schemas&lt;/li&gt; &#xA; &lt;li&gt;Missing function schemas&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Runtypes&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pelotom/runtypes&#34;&gt;https://github.com/pelotom/runtypes&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Good type inference support, but limited options for object type masking (no &lt;code&gt;.pick&lt;/code&gt; , &lt;code&gt;.omit&lt;/code&gt; , &lt;code&gt;.extend&lt;/code&gt; , etc.). No support for &lt;code&gt;Record&lt;/code&gt; s (their &lt;code&gt;Record&lt;/code&gt; is equivalent to Zod&#39;s &lt;code&gt;object&lt;/code&gt; ). They DO support branded and readonly types, which Zod does not.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports &#34;pattern matching&#34;: computed properties that distribute over unions&lt;/li&gt; &#xA; &lt;li&gt;Supports readonly types&lt;/li&gt; &#xA; &lt;li&gt;Missing object methods: (deepPartial, merge)&lt;/li&gt; &#xA; &lt;li&gt;Missing nonempty arrays with proper typing (&lt;code&gt;[T, ...T[]]&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Missing promise schemas&lt;/li&gt; &#xA; &lt;li&gt;Missing error customization&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Ow&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sindresorhus/ow&#34;&gt;https://github.com/sindresorhus/ow&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ow is focused on function input validation. It&#39;s a library that makes it easy to express complicated assert statements, but it doesn&#39;t let you parse untyped data. They support a much wider variety of types; Zod has a nearly one-to-one mapping with TypeScript&#39;s type system, whereas ow lets you validate several highly-specific types out of the box (e.g. &lt;code&gt;int32Array&lt;/code&gt; , see full list in their README).&lt;/p&gt; &#xA;&lt;p&gt;If you want to validate function inputs, use function schemas in Zod! It&#39;s a much simpler approach that lets you reuse a function type declaration without repeating yourself (namely, copy-pasting a bunch of ow assertions at the beginning of every function). Also Zod lets you validate your return types as well, so you can be sure there won&#39;t be any unexpected data passed downstream.&lt;/p&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;View the changelog at &lt;a href=&#34;https://raw.githubusercontent.com/colinhacks/zod/master/CHANGELOG.md&#34;&gt;CHANGELOG.md&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>smartxworks/sunmao-ui</title>
    <updated>2022-07-31T02:27:32Z</updated>
    <id>tag:github.com,2022-07-31:/smartxworks/sunmao-ui</id>
    <link href="https://github.com/smartxworks/sunmao-ui" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Framework for Developing Low-code Tool&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://sunmao-ui.com&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/smartxworks/sunmao-ui/develop/docs/images/logo.png&#34; alt=&#34;logo&#34; width=&#34;200&#34;&gt; &lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;Sunmao&lt;/h1&gt; &#xA;&lt;/div&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img alt=&#34;Apache-2.0&#34; src=&#34;https://img.shields.io/github/license/smartxworks/sunmao-ui&#34;&gt; &lt;a href=&#34;https://github.com/smartxworks/sunmao-ui/issues&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/issues/smartxworks/sunmao-ui&#34; alt=&#34;GitHub issues&#34;&gt; &lt;/a&gt; &lt;img alt=&#34;Github Stars&#34; src=&#34;https://badgen.net/github/stars/smartxworks/sunmao-ui&#34;&gt; &lt;a href=&#34;https://join.slack.com/t/sunmao/shared_invite/zt-1cgk81ebm-DyG9p2D5GNFS6vtbQwWj7A&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/slack-@sunmao-purple.svg?logo=slack&#34; alt=&#34;Join the chat at Slack&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;Sunmao(榫卯 /suən mɑʊ/) is a front-end low-code framework. Through Sunmao, you can easily encapsulate any front-end UI components into low-code component libraries to build your own low-code UI development platform, making front-end development as tight as Sunmao(&#34;mortise and tenon&#34; in Chinese).&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/smartxworks/sunmao-ui/develop/docs/zh/README.md&#34;&gt;中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;DEMO&lt;/h2&gt; &#xA;&lt;p&gt;The offcial website of Sunmao is developed by Sunmao, try it from here: &lt;a href=&#34;https://sunmao-ui.com/dev.html&#34;&gt;Sunmao website editor&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;We also provide an open-to-use template: &lt;a href=&#34;https://github.com/webzard-io/sunmao-start&#34;&gt;Sunmao Starter Kit&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why Sunmao?&lt;/h2&gt; &#xA;&lt;h3&gt;Reactive rendering low-code framework&lt;/h3&gt; &#xA;&lt;p&gt;Sunmao chooses a reactive rendering solution that is easy to understand and has excellent performance, making Sunmao intuitive and quick to start.&lt;/p&gt; &#xA;&lt;h3&gt;Powerful low-code GUI editor&lt;/h3&gt; &#xA;&lt;p&gt;Sunmao has a built-in GUI editor, which almost includes all the capabilities that a complete low-code editor should have.&lt;/p&gt; &#xA;&lt;h3&gt;Extremely Extensible&lt;/h3&gt; &#xA;&lt;p&gt;Both the UI component library itself and the low-code editor support custom extensions. Developers can register various components to meet the needs of application and continue to use the existing visual design system.&lt;/p&gt; &#xA;&lt;h3&gt;Type Safety&lt;/h3&gt; &#xA;&lt;p&gt;You are in type safety both when developing Sunmao components and when using the Sunmao editor. Sunmao heavily uses Typescript and JSON schema for a great type system.&lt;/p&gt; &#xA;&lt;p&gt;For more details, read &lt;a href=&#34;https://raw.githubusercontent.com/smartxworks/sunmao-ui/develop/docs/en/what-is-sunmao.md&#34;&gt;Sunmao: A truly extensible low-code UI framework&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Tutorial&lt;/h2&gt; &#xA;&lt;p&gt;Sunmao users are divided into two roles, one is developer and the other is user.&lt;/p&gt; &#xA;&lt;p&gt;The responsibilities of developers are similar to those of common front-end developers. They are responsible for developing UI components and encapsulating common UI components to Sunmao components. Developers need to write code to implement the logic of components.&lt;/p&gt; &#xA;&lt;p&gt;The user&#39;s responsibility is to use the Sunmao components encapsulated by developers to build front-end applications in the Sunmao low-code editor. Users do not need front-end knowledge and programming skills. They can finish building the application through UI interaction only.&lt;/p&gt; &#xA;&lt;p&gt;We have prepared two tutorials for user and developer. The user only needs to read the user&#39;s tutorial, while the developer must read both.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/smartxworks/sunmao-ui/develop/docs/en/user.md&#34;&gt;User&#39;s Tutorial&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/smartxworks/sunmao-ui/develop/docs/en/developer.md&#34;&gt;Developer&#39;s Tutorial&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;local development&lt;/h2&gt; &#xA;&lt;h3&gt;Start&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;yarn&#xA;cd packages/editor&#xA;yarn dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Test&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yarn test:ci&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yarn&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;When you run the runtime or editor locally, if you modify the code of other packages, you must rebuild the modified package, otherwise, the runtime and editor will still run the old code.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Apache-2.0&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>TuSimple/naive-ui</title>
    <updated>2022-07-31T02:27:32Z</updated>
    <id>tag:github.com,2022-07-31:/TuSimple/naive-ui</id>
    <link href="https://github.com/TuSimple/naive-ui" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Vue 3 Component Library. Fairly Complete. Theme Customizable. Uses TypeScript. Fast.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;144px&#34; src=&#34;https://naiveui.oss-cn-hongkong.aliyuncs.com/naivelogo.svg?sanitize=true&#34;&gt; &lt;/p&gt; &#xA;&lt;h1 align=&#34;center&#34;&gt;Naive UI&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt;A Vue 3 Component Library&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;b&gt;Fairly Complete, Theme Customizable, Uses TypeScript, Fast&lt;/b&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;Kinda Interesting&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;English | &lt;a href=&#34;https://raw.githubusercontent.com/TuSimple/naive-ui/main/README.zh-CN.md&#34;&gt;中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.naiveui.com&#34;&gt;www.naiveui.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://discord.gg/Pqv7Mev5Dd&#34;&gt;Discord&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;DingTalk Group 1 (Member limit reached) 33482509&lt;/li&gt; &#xA; &lt;li&gt;DingTalk Group 2 (Member limit reached) 35886835&lt;/li&gt; &#xA; &lt;li&gt;DingTalk Group 3 32377370&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/naive-ui/awesome-naive&#34;&gt;Awesome Naive UI&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;h3&gt;Fairly Complete&lt;/h3&gt; &#xA;&lt;p&gt;There are more than 80 components. Hope they can help you write less code.&lt;/p&gt; &#xA;&lt;p&gt;What&#39;s more, they are all treeshakable.&lt;/p&gt; &#xA;&lt;h3&gt;Theme Customizable&lt;/h3&gt; &#xA;&lt;p&gt;We provide an advanced type safe theme system built using TypeScript. All you need is to provide a theme overrides object in JS. Then all the stuff will be done by us.&lt;/p&gt; &#xA;&lt;p&gt;What&#39;s more, no less/sass/css variables, no webpack loaders are required.&lt;/p&gt; &#xA;&lt;h3&gt;Uses TypeScript&lt;/h3&gt; &#xA;&lt;p&gt;All the stuff in Naive UI is written in TypeScript. It can work with your typescript project seamlessly.&lt;/p&gt; &#xA;&lt;p&gt;What&#39;s more, you don&#39;t need to import any CSS to use the components.&lt;/p&gt; &#xA;&lt;h3&gt;Fast&lt;/h3&gt; &#xA;&lt;p&gt;I try to make it not rather slow. At least select, tree, transfer, table and cascader work with virtual list.&lt;/p&gt; &#xA;&lt;p&gt;What&#39;s more, ..., no more. Just enjoy it.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;npm&lt;/h3&gt; &#xA;&lt;p&gt;Use npm to install.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm i -D naive-ui&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fonts&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm i -D vfonts&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Icons&lt;/h3&gt; &#xA;&lt;p&gt;Naive UI recommends using &lt;a href=&#34;https://www.xicons.org&#34;&gt;xicons&lt;/a&gt; as icon library.&lt;/p&gt; &#xA;&lt;h3&gt;Design Resources&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://naive-ui.oss-accelerate.aliyuncs.com/NaiveUI-Design-Library%28Square-Corner%29.sketch&#34;&gt;Naive UI (Sketch)&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/TuSimple/naive-ui/raw/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Naive UI is licensed under the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT license&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Graphics resouces of &lt;code&gt;result&lt;/code&gt; component is licensed under the &lt;a href=&#34;https://creativecommons.org/licenses/by/4.0/&#34;&gt;CC-BY 4.0&lt;/a&gt;. The graphics resources come from &lt;a href=&#34;https://github.com/twitter/twemoji&#34;&gt;Twemoji&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>