<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub TypeScript Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-15T01:47:01Z</updated>
  <subtitle>Weekly Trending of TypeScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>codexu/note-gen</title>
    <updated>2025-06-15T01:47:01Z</updated>
    <id>tag:github.com,2025-06-15:/codexu/note-gen</id>
    <link href="https://github.com/codexu/note-gen" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A cross-platform Markdown note-taking application dedicated to using AI to bridge recording and writing, organizing fragmented knowledge into a readable note.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://s2.loli.net/2025/06/13/UbVGPrhFl3etnQz.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;NoteGen&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/free-pricing?logo=free&amp;amp;color=%20%23155EEF&amp;amp;label=pricing&amp;amp;labelColor=%20%23528bff&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/version-beta-orange&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://github.com/codexu/note-gen/actions/workflows/release.yml/badge.svg?branch=release&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/codexu/note-gen&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/downloads/codexu/note-gen/total&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/commit-activity/m/codexu/note-gen&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;div&gt; &#xA; &lt;a href=&#34;https://trendshift.io/repositories/12784&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://trendshift.io/api/badge/repositories/12784&#34; alt=&#34;codexu%2Fnote-gen | Trendshift&#34; style=&#34;width: 250px; height: 55px;&#34; width=&#34;250&#34; height=&#34;55&#34;&gt;&lt;/a&gt; &#xA; &lt;a href=&#34;https://www.producthunt.com/products/notegen-2?embed=true&amp;amp;utm_source=badge-featured&amp;amp;utm_medium=badge&amp;amp;utm_source=badge-notegen-2&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://api.producthunt.com/widgets/embed-image/v1/featured.svg?post_id=956348&amp;amp;theme=light&amp;amp;t=1749194675492&#34; alt=&#34;NoteGen - A cross-platform Markdown note-taking application | Product Hunt&#34; style=&#34;width: 250px; height: 54px;&#34; width=&#34;250&#34; height=&#34;54&#34;&gt;&lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;English | &lt;a href=&#34;https://raw.githubusercontent.com/codexu/note-gen/dev/.github/README.zh.md&#34;&gt;ÁÆÄ‰Ωì‰∏≠Êñá&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/codexu/note-gen/dev/.github/README.ja.md&#34;&gt;Êó•Êú¨Ë™û&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Guide&lt;/h2&gt; &#xA;&lt;p&gt;NoteGen is a cross-platform &lt;code&gt;Markdown&lt;/code&gt; note-taking application dedicated to using AI to bridge recording and writing, organizing fragmented knowledge into a readable note.&lt;/p&gt; &#xA;&lt;p&gt;üñ•Ô∏è Official Document: &lt;a href=&#34;https://notegen.top&#34;&gt;https://notegen.top&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;üí¨ Join &lt;a href=&#34;https://github.com/codexu/note-gen/discussions/110&#34;&gt;WeChat/QQ Group&lt;/a&gt; | &lt;a href=&#34;https://discord.gg/SXyVZGpbpk&#34;&gt;Discord&lt;/a&gt; | &lt;a href=&#34;https://t.me/notegen&#34;&gt;Telegram&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why Choose NoteGen?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Lightweight: &lt;a href=&#34;https://github.com/codexu/note-gen/releases&#34;&gt;Installation package&lt;/a&gt; is &lt;strong&gt;only 20MB&lt;/strong&gt;, free with no ads or bundled software.&lt;/li&gt; &#xA; &lt;li&gt;Cross-platform: Supports Mac, Windows, Linux, and thanks to &lt;code&gt;Tauri2&lt;/code&gt;&#39;s cross-platform capabilities, IOS and Android are currently under development.&lt;/li&gt; &#xA; &lt;li&gt;Supports multiple recording methods including &lt;code&gt;screenshots&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;illustrations&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;links&lt;/code&gt;, etc., meeting fragmented recording needs across various scenarios.&lt;/li&gt; &#xA; &lt;li&gt;Native &lt;code&gt;Markdown(.md)&lt;/code&gt; as storage format, no modifications, easy to migrate.&lt;/li&gt; &#xA; &lt;li&gt;Native offline usage, supporting real-time synchronization to &lt;code&gt;GitHub, Gitee private repositories&lt;/code&gt; with history rollback, and WebDAV synchronization.&lt;/li&gt; &#xA; &lt;li&gt;AI-enhanced: Configurable with ChatGPT, Gemini, Ollama, LM Studio, Grok, and other models, with support for custom third-party model configuration.&lt;/li&gt; &#xA; &lt;li&gt;RAG: Your notes are your knowledge base. Support embedding models and reranking models.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;From Recording to Writing&lt;/h2&gt; &#xA;&lt;p&gt;Conventional note-taking applications typically don&#39;t provide recording functionality. Users need to manually copy and paste content for recording, which greatly reduces efficiency. When faced with scattered recorded content, it requires significant effort to organize.&lt;/p&gt; &#xA;&lt;p&gt;NoteGen is divided into &lt;code&gt;Recording&lt;/code&gt; and &lt;code&gt;Writing&lt;/code&gt; pages, with the following relationship:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Recordings can be organized into notes and transferred to the writing page for in-depth composition.&lt;/li&gt; &#xA; &lt;li&gt;During writing, you can insert recordings at any time.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Recording&lt;/h3&gt; &#xA;&lt;p&gt;The recording function is similar to an &lt;strong&gt;AI chatbot&lt;/strong&gt;, but when conversing with it, you can associate it with previously recorded content, switching from conversation mode to organization mode to arrange recordings into a readable note.&lt;/p&gt; &#xA;&lt;p&gt;The following auxiliary features can help you record more effectively:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Tags&lt;/strong&gt; to distinguish different recording scenarios.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Personas&lt;/strong&gt; with support for custom prompts to precisely control your AI assistant.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Clipboard Assistant&lt;/strong&gt; that automatically recognizes text or images in your clipboard and records them to your list.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Writing&lt;/h3&gt; &#xA;&lt;p&gt;The writing section is divided into two parts: &lt;strong&gt;File Manager&lt;/strong&gt; and &lt;strong&gt;Markdown Editor&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;File Manager&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports management of local Markdown files and GitHub synchronized files.&lt;/li&gt; &#xA; &lt;li&gt;Supports unlimited directory hierarchy.&lt;/li&gt; &#xA; &lt;li&gt;Supports multiple sorting methods.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Markdown Editor&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports WYSIWYG, instant rendering, and split-screen preview modes.&lt;/li&gt; &#xA; &lt;li&gt;Supports version control with history rollback.&lt;/li&gt; &#xA; &lt;li&gt;Supports AI assistance for conversation, continuation, polishing, and translation functions.&lt;/li&gt; &#xA; &lt;li&gt;Supports image hosting, uploading images and converting them to Markdown image links.&lt;/li&gt; &#xA; &lt;li&gt;Supports HTML to Markdown conversion, automatically converting copied browser content to Markdown format.&lt;/li&gt; &#xA; &lt;li&gt;Supports outlines, math formulas, mind maps, charts, flowcharts, Gantt charts, sequence diagrams, staves, multimedia, voice reading, title anchors, code highlighting and copying, graphviz rendering, and plantuml UML diagrams.&lt;/li&gt; &#xA; &lt;li&gt;Supports real-time local content saving, delayed (10s without editing) automatic synchronization, and history rollback.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Other Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Global search for quickly finding and jumping to specific content.&lt;/li&gt; &#xA; &lt;li&gt;Image hosting management for convenient management of image repository content.&lt;/li&gt; &#xA; &lt;li&gt;Themes and appearance with support for dark themes and appearance settings for Markdown, code, etc.&lt;/li&gt; &#xA; &lt;li&gt;Internationalization support, currently available in Chinese and English.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to Use?&lt;/h2&gt; &#xA;&lt;h3&gt;Download&lt;/h3&gt; &#xA;&lt;p&gt;Currently supports Mac, Windows, and Linux. Thanks to Tauri2&#39;s cross-platform capabilities, it will support iOS and Android in the future.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/codexu/note-gen/releases&#34;&gt;Download NoteGen (alpha)&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Provided by &lt;a href=&#34;http://upgrade.toolsetlink.com/upgrade/example/tauri-example.html&#34;&gt;UpgradeLink&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Enhancement&lt;/h3&gt; &#xA;&lt;p&gt;The note-taking application can be used directly without configuration. If you want a better experience, please open the settings page to configure AI and synchronization.&lt;/p&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/codexu/note-gen/dev/.github/CONTRIBUTING.md&#34;&gt;Read contribution guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/codexu/note-gen/issues/46&#34;&gt;Update plans&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/codexu/note-gen/issues&#34;&gt;Submit bugs or improvement suggestions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/codexu/note-gen/discussions&#34;&gt;Discussions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;a href=&#34;https://github.com/codexu/note-gen/graphs/contributors&#34;&gt; &lt;img src=&#34;https://contrib.rocks/image?repo=codexu/note-gen&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;Sponsors&lt;/h2&gt; &#xA;&lt;div&gt; &#xA; &lt;a href=&#34;https://docs.siliconflow.cn/cn/usercases/use-siliconcloud-in-NoteGen?utm_source=NoteGen&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://s2.loli.net/2025/06/11/65TLRh813e2YFzr.png&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;https://www.qiniu.com/products/ai-token-api?utm_source=NoteGen&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://s2.loli.net/2025/06/11/OKJq542lTs7U9xg.png&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;http://upgrade.toolsetlink.com/upgrade/example/tauri-example.html&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://s2.loli.net/2025/06/11/r2dqNIWVXp4RaFe.png&#34;&gt; &lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Star History&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.star-history.com/#codexu/note-gen&amp;amp;Date&#34;&gt;&lt;img src=&#34;https://api.star-history.com/svg?repos=codexu/note-gen&amp;amp;type=Date&#34; alt=&#34;Star History Chart&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cloudflare/workers-oauth-provider</title>
    <updated>2025-06-15T01:47:01Z</updated>
    <id>tag:github.com,2025-06-15:/cloudflare/workers-oauth-provider</id>
    <link href="https://github.com/cloudflare/workers-oauth-provider" rel="alternate"></link>
    <summary type="html">&lt;p&gt;OAuth provider library for Cloudflare Workers&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;OAuth 2.1 Provider Framework for Cloudflare Workers&lt;/h1&gt; &#xA;&lt;p&gt;This is a TypeScript library that implements the provider side of the OAuth 2.1 protocol with PKCE support. The library is intended to be used on Cloudflare Workers.&lt;/p&gt; &#xA;&lt;h2&gt;Beta&lt;/h2&gt; &#xA;&lt;p&gt;As of March, 2025, this library is very new, prerelease software. The API is still subject to change.&lt;/p&gt; &#xA;&lt;h2&gt;Benefits of this library&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The library acts as a wrapper around your Worker code, which adds authorization for your API endpoints.&lt;/li&gt; &#xA; &lt;li&gt;All token management is handled automatically.&lt;/li&gt; &#xA; &lt;li&gt;Your API handler is written like a regular fetch handler, but receives the already-authenticated user details as a parameter. No need to perform any checks of your own.&lt;/li&gt; &#xA; &lt;li&gt;The library is agnostic to how you manage and authenticate users.&lt;/li&gt; &#xA; &lt;li&gt;The library is agnostic to how you build your UI. Your authorization flow can be implemented using whatever UI framework you use for everything else.&lt;/li&gt; &#xA; &lt;li&gt;The library&#39;s storage does not store any secrets, only hashes of them.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;A Worker that uses the library might look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { OAuthProvider } from &#34;my-oauth&#34;;&#xA;import { WorkerEntrypoint } from &#34;cloudflare:workers&#34;;&#xA;&#xA;// We export the OAuthProvider instance as the entrypoint to our Worker. This means it&#xA;// implements the `fetch()` handler, receiving all HTTP requests.&#xA;export default new OAuthProvider({&#xA;  // Configure API routes. Any requests whose URL starts with any of these prefixes will be&#xA;  // considered API requests. The OAuth provider will check the access token on these requests,&#xA;  // and then, if the token is valid, send the request to the API handler.&#xA;  // You can provide:&#xA;  // - A single route (string) or multiple routes (array)&#xA;  // - Full URLs (which will match the hostname) or just paths (which will match any hostname)&#xA;  apiRoute: [&#xA;    &#34;/api/&#34;, // Path only - will match any hostname&#xA;    &#34;https://api.example.com/&#34; // Full URL - will check hostname&#xA;  ],&#xA;&#xA;  // When the OAuth system receives an API request with a valid access token, it passes the request&#xA;  // to this handler object&#39;s fetch method.&#xA;  // You can provide either an object with a fetch method (ExportedHandler)&#xA;  // or a class extending WorkerEntrypoint.&#xA;  apiHandler: ApiHandler, // Using a WorkerEntrypoint class&#xA;  &#xA;  // For multi-handler setups, you can use apiHandlers instead of apiRoute+apiHandler.&#xA;  // This allows you to use different handlers for different API routes.&#xA;  // Note: You must use either apiRoute+apiHandler (single-handler) OR apiHandlers (multi-handler), not both.&#xA;  // Example:&#xA;  // apiHandlers: {&#xA;  //   &#34;/api/users/&#34;: UsersApiHandler,&#xA;  //   &#34;/api/documents/&#34;: DocumentsApiHandler,&#xA;  //   &#34;https://api.example.com/&#34;: ExternalApiHandler,&#xA;  // },&#xA;&#xA;  // Any requests which aren&#39;t API request will be passed to the default handler instead.&#xA;  // Again, this can be either an object or a WorkerEntrypoint.&#xA;  defaultHandler: defaultHandler, // Using an object with a fetch method&#xA;&#xA;  // This specifies the URL of the OAuth authorization flow UI. This UI is NOT implemented by&#xA;  // the OAuthProvider. It is up to the application to implement a UI here. The only reason why&#xA;  // this URL is given to the OAuthProvider is so that it can implement the RFC-8414 metadata&#xA;  // discovery endpoint, i.e. `.well-known/oauth-authorization-server`.&#xA;  // Can also be specified as just a path (e.g., &#34;/authorize&#34;).&#xA;  authorizeEndpoint: &#34;https://example.com/authorize&#34;,&#xA;&#xA;  // This specifies the OAuth 2 token exchange endpoint. The OAuthProvider will implement this&#xA;  // endpoint (by directly responding to requests with a matching URL).&#xA;  // Can also be specified as just a path (e.g., &#34;/oauth/token&#34;).&#xA;  tokenEndpoint: &#34;https://example.com/oauth/token&#34;,&#xA;&#xA;  // This specifies the RFC-7591 dynamic client registration endpoint. This setting is optional,&#xA;  // but if provided, the OAuthProvider will implement this endpoint to allow dynamic client&#xA;  // registration.&#xA;  // Can also be specified as just a path (e.g., &#34;/oauth/register&#34;).&#xA;  clientRegistrationEndpoint: &#34;https://example.com/oauth/register&#34;,&#xA;&#xA;  // Optional list of scopes supported by this OAuth provider.&#xA;  // If provided, this will be included in the RFC 8414 metadata as &#39;scopes_supported&#39;.&#xA;  // If not provided, the &#39;scopes_supported&#39; field will be omitted from the metadata.&#xA;  scopesSupported: [&#34;document.read&#34;, &#34;document.write&#34;, &#34;profile&#34;],&#xA;&#xA;  // Optional: Controls whether the OAuth implicit flow is allowed.&#xA;  // The implicit flow is discouraged in OAuth 2.1 but may be needed for some clients.&#xA;  // Defaults to false.&#xA;  allowImplicitFlow: false,&#xA;&#xA;  // Optional: Controls whether public clients (clients without a secret, like SPAs)&#xA;  // can register via the dynamic client registration endpoint.&#xA;  // When true, only confidential clients can register.&#xA;  // Note: Creating public clients via the OAuthHelpers.createClient() method&#xA;  // is always allowed regardless of this setting.&#xA;  // Defaults to false.&#xA;  disallowPublicClientRegistration: false&#xA;});&#xA;&#xA;// The default handler object - the OAuthProvider will pass through HTTP requests to this object&#39;s fetch method&#xA;// if they aren&#39;t API requests or do not have a valid access token&#xA;const defaultHandler = {&#xA;  // This fetch method works just like a standard Cloudflare Workers fetch handler&#xA;  //&#xA;  // The `request`, `env`, and `ctx` parameters are the same as for a normal Cloudflare Workers fetch&#xA;  // handler, and are exactly the objects that the `OAuthProvider` itself received from the Workers&#xA;  // runtime.&#xA;  //&#xA;  // The `env.OAUTH_PROVIDER` provides an API by which the application can call back to the&#xA;  // OAuthProvider.&#xA;  async fetch(request: Request, env, ctx) {&#xA;    let url = new URL(request.url);&#xA;&#xA;    if (url.pathname == &#34;/authorize&#34;) {&#xA;      // This is a request for our OAuth authorization flow UI. It is up to the application to&#xA;      // implement this. However, the OAuthProvider library provides some helpers to assist.&#xA;&#xA;      // `env.OAUTH_PROVIDER.parseAuthRequest()` parses the OAuth authorization request to extract the parameters&#xA;      // required by the OAuth 2 standard, namely response_type, client_id, redirect_uri, scope, and&#xA;      // state. It returns an object containing all these (using idiomatic camelCase naming).&#xA;      let oauthReqInfo = await env.OAUTH_PROVIDER.parseAuthRequest(request);&#xA;&#xA;      // `env.OAUTH_PROVIDER.lookupClient()` looks up metadata about the client, as definetd by RFC-7591. This&#xA;      // includes things like redirect_uris, client_name, logo_uri, etc.&#xA;      let clientInfo = await env.OAUTH_PROVIDER.lookupClient(oauthReqInfo.clientId);&#xA;&#xA;      // At this point, the application should use `oauthReqInfo` and `clientInfo` to render an&#xA;      // authorization consent UI to the user. The details of this are up to the app so are not&#xA;      // shown here.&#xA;&#xA;      // After the user has granted consent, the application calls `env.OAUTH_PROVIDER.completeAuthorization()` to&#xA;      // grant the authorization.&#xA;      let {redirectTo} = await env.OAUTH_PROVIDER.completeAuthorization({&#xA;        // The application passes back the original OAuth request info that was returned by&#xA;        // `parseAuthRequest()` earlier.&#xA;        request: oauthReqInfo,&#xA;&#xA;        // The application must specify the user&#39;s ID, which is some sort of string. This is needed&#xA;        // so that the application can later query the OAuthProvider to enumerate all grants&#xA;        // belonging to a particular user, e.g. to implement an audit and revocation UI.&#xA;        userId: &#34;1234&#34;,&#xA;&#xA;        // The application can specify some arbitary metadata which describes this grant. The&#xA;        // metadata can contain any JSON-serializable content. This metadata is not used by the&#xA;        // OAuthProvider, but the application can read back the metadata attached to specific&#xA;        // grants when enumerating them later, again e.g. to implement an udit and revocation UI.&#xA;        metadata: {label: &#34;foo&#34;},&#xA;&#xA;        // The application specifies the list of OAuth scope identifiers that were granted. This&#xA;        // may or may not be the same as was requested in `oauthReqInfo.scope`.&#xA;        scope: [&#34;document.read&#34;, &#34;document.write&#34;],&#xA;&#xA;        // `props` is an arbitrary JSON-serializable object which will be passed back to the API&#xA;        // handler for every request authorized by this grant.&#xA;        props: {&#xA;          userId: 1234,&#xA;          username: &#34;Bob&#34;&#xA;        }&#xA;      });&#xA;&#xA;      // `completeAuthorization()` will have returned the URL to which the user should be redirected&#xA;      // in order to complete the authorization flow. This is the requesting client&#39;s OAuth&#xA;      // redirect_uri with the appropriate query parameters added to complete the flow and obtain&#xA;      // tokens.&#xA;      return Response.redirect(redirectTo, 302);&#xA;    }&#xA;&#xA;    // ... the application can implement other non-API HTTP endpoints here ...&#xA;&#xA;    return new Response(&#34;Not found&#34;, {status: 404});&#xA;  }&#xA;};&#xA;&#xA;// The API handler object - the OAuthProivder will pass authorized API requests to this object&#39;s fetch method&#xA;// (because we provided it as the `apiHandler` setting, above). This is ONLY called for API requests&#xA;// that had a valid access token.&#xA;class ApiHandler extends WorkerEntrypoint {&#xA;  // This fetch method works just like any other WorkerEntrypoint fetch method. The `request` is&#xA;  // passed as a parameter, while `env` and `ctx` are available as `this.env` and `this.ctx`.&#xA;  //&#xA;  // The `this.env.OAUTH_PROVIDER` is available just like in the default handler.&#xA;  //&#xA;  // The `this.ctx.props` property contains the `props` value that was passed to&#xA;  // `env.OAUTH_PROVIDER.completeAuthorization()` during the authorization flow that authorized this client.&#xA;  fetch(request: Request) {&#xA;    // The application can implement its API endpoints like normal. This app implements a single&#xA;    // endpoint, `/api/whoami`, which returns the user&#39;s authenticated identity.&#xA;&#xA;    let url = new URL(request.url);&#xA;    if (url.pathname == &#34;/api/whoami&#34;) {&#xA;      // Since the username is embedded in `ctx.props`, which came from the access token that the&#xA;      // OAuthProivder already verified, we don&#39;t need to do any other authentication steps.&#xA;      return new Response(`You are authenticated as: ${this.ctx.props.username}`);&#xA;    }&#xA;&#xA;    return new Response(&#34;Not found&#34;, {status: 404});&#xA;  }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This implementation requires that your worker is configured with a Workers KV namespace binding called &lt;code&gt;OAUTH_KV&lt;/code&gt;, which is used to store token information. See the file &lt;code&gt;storage-schema.md&lt;/code&gt; for details on the schema of this namespace.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;env.OAUTH_PROVIDER&lt;/code&gt; object available to the fetch handlers provides some methods to query the storage, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create, list, modify, and delete client_id registrations (in addition to &lt;code&gt;lookupClient()&lt;/code&gt;, already shown in the example code).&lt;/li&gt; &#xA; &lt;li&gt;List all active authorization grants for a particular user.&lt;/li&gt; &#xA; &lt;li&gt;Revoke (delete) an authorization grant.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the &lt;code&gt;OAuthHelpers&lt;/code&gt; interface definition for full API details.&lt;/p&gt; &#xA;&lt;h2&gt;Token Exchange Callback&lt;/h2&gt; &#xA;&lt;p&gt;This library allows you to update the &lt;code&gt;props&lt;/code&gt; value during token exchanges by configuring a callback function. This is useful for scenarios where the application needs to perform additional processing when tokens are issued or refreshed.&lt;/p&gt; &#xA;&lt;p&gt;For example, if your application is also a client to some other OAuth API, you might want to perform an equivalent upstream token exchange and store the result in the &lt;code&gt;props&lt;/code&gt;. The callback can be used to update the props for both the grant record and specific access tokens.&lt;/p&gt; &#xA;&lt;p&gt;To use this feature, provide a &lt;code&gt;tokenExchangeCallback&lt;/code&gt; in your OAuthProvider options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;new OAuthProvider({&#xA;  // ... other options ...&#xA;  tokenExchangeCallback: async (options) =&amp;gt; {&#xA;    // options.grantType is either &#39;authorization_code&#39; or &#39;refresh_token&#39;&#xA;    // options.props contains the current props&#xA;    // options.clientId, options.userId, and options.scope are also available&#xA;&#xA;    if (options.grantType === &#39;authorization_code&#39;) {&#xA;      // For authorization code exchange, might want to obtain upstream tokens&#xA;      const upstreamTokens = await exchangeUpstreamToken(options.props.someCode);&#xA;&#xA;      return {&#xA;        // Update the props stored in the access token&#xA;        accessTokenProps: {&#xA;          ...options.props,&#xA;          upstreamAccessToken: upstreamTokens.access_token&#xA;        },&#xA;        // Update the props stored in the grant (for future token refreshes)&#xA;        newProps: {&#xA;          ...options.props,&#xA;          upstreamRefreshToken: upstreamTokens.refresh_token&#xA;        }&#xA;      };&#xA;    }&#xA;&#xA;    if (options.grantType === &#39;refresh_token&#39;) {&#xA;      // For refresh token exchanges, might want to refresh upstream tokens too&#xA;      const upstreamTokens = await refreshUpstreamToken(options.props.upstreamRefreshToken);&#xA;&#xA;      return {&#xA;        accessTokenProps: {&#xA;          ...options.props,&#xA;          upstreamAccessToken: upstreamTokens.access_token&#xA;        },&#xA;        newProps: {&#xA;          ...options.props,&#xA;          upstreamRefreshToken: upstreamTokens.refresh_token || options.props.upstreamRefreshToken&#xA;        },&#xA;        // Optionally override the default access token TTL to match the upstream token&#xA;        accessTokenTTL: upstreamTokens.expires_in&#xA;      };&#xA;    }&#xA;  }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The callback can:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Return both &lt;code&gt;accessTokenProps&lt;/code&gt; and &lt;code&gt;newProps&lt;/code&gt; to update both&lt;/li&gt; &#xA; &lt;li&gt;Return only &lt;code&gt;accessTokenProps&lt;/code&gt; to update just the current access token&lt;/li&gt; &#xA; &lt;li&gt;Return only &lt;code&gt;newProps&lt;/code&gt; to update both the grant and access token (the access token inherits these props)&lt;/li&gt; &#xA; &lt;li&gt;Return &lt;code&gt;accessTokenTTL&lt;/code&gt; to override the default TTL for this specific access token&lt;/li&gt; &#xA; &lt;li&gt;Return nothing to keep the original props unchanged&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;accessTokenTTL&lt;/code&gt; override is particularly useful when the application is also an OAuth client to another service and wants to match its access token TTL to the upstream access token TTL. This helps prevent situations where the downstream token is still valid but the upstream token has expired.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;props&lt;/code&gt; values are end-to-end encrypted, so they can safely contain sensitive information.&lt;/p&gt; &#xA;&lt;h2&gt;Custom Error Responses&lt;/h2&gt; &#xA;&lt;p&gt;By using the &lt;code&gt;onError&lt;/code&gt; option, you can emit notifications or take other actions when an error response was to be emitted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;new OAuthProvider({&#xA;  // ... other options ...&#xA;  onError({ code, description, status, headers }) {&#xA;    Sentry.captureMessage(/* ... */)&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By returning a &lt;code&gt;Response&lt;/code&gt; you can also override what the OAuthProvider returns to your users:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;new OAuthProvider({&#xA;  // ... other options ...&#xA;  onError({ code, description, status, headers }) {&#xA;    if (code === &#39;unsupported_grant_type&#39;) {&#xA;      return new Response(&#39;...&#39;, { status, headers })&#xA;    }&#xA;    // returning undefined (i.e. void) uses the default Response generation&#xA;  }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the &lt;code&gt;onError&lt;/code&gt; callback is set to &lt;code&gt;({ status, code, description }) =&amp;gt; console.warn(`OAuth error response: ${status} ${code} - ${description}`)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Implementation Notes&lt;/h2&gt; &#xA;&lt;h3&gt;End-to-end encryption&lt;/h3&gt; &#xA;&lt;p&gt;This library stores records about authorization tokens in KV. The storage schema is carefully designed such that a complete leak of the storage only reveals mundane metadata about what has been granted. In particular:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Secrets (including access tokens, refresh tokens, authorization codes, and client secrets) are stored only by hash. Hence, such secrets cannot be derived from the storage alone.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;props&lt;/code&gt; associated with a grant (which are passed back to the application when API requests are performed) are stored encrypted with the secret token as key material. Hence, the contents of &lt;code&gt;props&lt;/code&gt; are impossible to derive from storage unless a valid token is provided.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that the &lt;code&gt;userId&lt;/code&gt; and the &lt;code&gt;metadata&lt;/code&gt; associated with each grant are not encrypted, because the purpose of these values is to allow grants to be enumerated for audit and revocation purposes. However, these values are completely opaque to the library. An application is free to omit them or apply its own encryption to them before passing them into the library, if it desires.&lt;/p&gt; &#xA;&lt;h3&gt;Single-use refresh tokens?&lt;/h3&gt; &#xA;&lt;p&gt;OAuth 2.1 requires that refresh tokens are either &#34;cryptographically bound&#34; to the client, or are single-use. This library currently does not implement any cryptographic binding, thus seemingly requiring single-use tokens. Under this requirement, every token refresh request invalidates the old refresh token and issues a new one.&lt;/p&gt; &#xA;&lt;p&gt;This requirement is seemingly fundamentally flawed as it assumes that every refresh request will complete with no errors. In the real world, a transient network error, machine failure, or software fault could mean that the client fails to store the new refresh token after a refresh request. In this case, the client would be permanently unable to make any further requests, as the only token it has is no longer valid.&lt;/p&gt; &#xA;&lt;p&gt;This library implements a compromise: At any particular time, a grant may have two valid refresh tokens. When the client uses one of them, the other one is invalidated, and a new one is generated and returned. Thus, if the client correctly uses the new refresh token each time, then older refresh tokens are continuously invalidated. But if a transient failure prevents the client from updating its token, it can always retry the request with the token it used previously.&lt;/p&gt; &#xA;&lt;h2&gt;Written using Claude&lt;/h2&gt; &#xA;&lt;p&gt;This library (including the schema documentation) was largely written with the help of &lt;a href=&#34;https://claude.ai&#34;&gt;Claude&lt;/a&gt;, the AI model by Anthropic. Claude&#39;s output was thoroughly reviewed by Cloudflare engineers with careful attention paid to security and compliance with standards. Many improvements were made on the initial output, mostly again by prompting Claude (and reviewing the results). Check out the commit history to see how Claude was prompted and what code it produced.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&#34;NOOOOOOOO!!!! You can&#39;t just use an LLM to write an auth library!&#34;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&#34;haha gpus go brrr&#34;&lt;/p&gt; &#xA;&lt;p&gt;In all seriousness, two months ago (January 2025), I (&lt;a href=&#34;https://github.com/kentonv&#34;&gt;@kentonv&lt;/a&gt;) would have agreed. I was an AI skeptic. I thought LLMs were glorified Markov chain generators that didn&#39;t actually understand code and couldn&#39;t produce anything novel. I started this project on a lark, fully expecting the AI to produce terrible code for me to laugh at. And then, uh... the code actually looked pretty good. Not perfect, but I just told the AI to fix things, and it did. I was shocked.&lt;/p&gt; &#xA;&lt;p&gt;To emphasize, &lt;strong&gt;this is not &#34;vibe coded&#34;&lt;/strong&gt;. Every line was thoroughly reviewed and cross-referenced with relevant RFCs, by security experts with previous experience with those RFCs. I was &lt;em&gt;trying&lt;/em&gt; to validate my skepticism. I ended up proving myself wrong.&lt;/p&gt; &#xA;&lt;p&gt;Again, please check out the commit history -- especially early commits -- to understand how this went.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ourongxing/newsnow</title>
    <updated>2025-06-15T01:47:01Z</updated>
    <id>tag:github.com,2025-06-15:/ourongxing/newsnow</id>
    <link href="https://github.com/ourongxing/newsnow" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Elegant reading of real-time and hottest news&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;NewsNow&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ourongxing/newsnow/main/public/og-image.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;English | &lt;a href=&#34;https://raw.githubusercontent.com/ourongxing/newsnow/main/README.zh-CN.md&#34;&gt;ÁÆÄ‰Ωì‰∏≠Êñá&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/ourongxing/newsnow/main/README.ja-JP.md&#34;&gt;Êó•Êú¨Ë™û&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] This is a demo version currently supporting Chinese only. A full-featured version with better customization and English content support will be released later.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Elegant reading of real-time and hottest news&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clean and elegant UI design for optimal reading experience&lt;/li&gt; &#xA; &lt;li&gt;Real-time updates on trending news&lt;/li&gt; &#xA; &lt;li&gt;GitHub OAuth login with data synchronization&lt;/li&gt; &#xA; &lt;li&gt;30-minute default cache duration (logged-in users can force refresh)&lt;/li&gt; &#xA; &lt;li&gt;Adaptive scraping interval (minimum 2 minutes) based on source update frequency to optimize resource usage and prevent IP bans&lt;/li&gt; &#xA; &lt;li&gt;support MCP server&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;mcpServers&#34;: {&#xA;    &#34;newsnow&#34;: {&#xA;      &#34;command&#34;: &#34;npx&#34;,&#xA;      &#34;args&#34;: [&#xA;        &#34;-y&#34;,&#xA;        &#34;newsnow-mcp-server&#34;&#xA;      ],&#xA;      &#34;env&#34;: {&#xA;        &#34;BASE_URL&#34;: &#34;https://newsnow.busiyi.world&#34;&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can change the &lt;code&gt;BASE_URL&lt;/code&gt; to your own domain.&lt;/p&gt; &#xA;&lt;h2&gt;Deployment&lt;/h2&gt; &#xA;&lt;h3&gt;Basic Deployment&lt;/h3&gt; &#xA;&lt;p&gt;For deployments without login and caching:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork this repository&lt;/li&gt; &#xA; &lt;li&gt;Import to platforms like Cloudflare Page or Vercel&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Cloudflare Page Configuration&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Build command: &lt;code&gt;pnpm run build&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Output directory: &lt;code&gt;dist/output/public&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;GitHub OAuth Setup&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/settings/applications/new&#34;&gt;Create a GitHub App&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;No special permissions required&lt;/li&gt; &#xA; &lt;li&gt;Set callback URL to: &lt;code&gt;https://your-domain.com/api/oauth/github&lt;/code&gt; (replace &lt;code&gt;your-domain&lt;/code&gt; with your actual domain)&lt;/li&gt; &#xA; &lt;li&gt;Obtain Client ID and Client Secret&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Environment Variables&lt;/h3&gt; &#xA;&lt;p&gt;Refer to &lt;code&gt;example.env.server&lt;/code&gt;. For local development, rename it to &lt;code&gt;.env.server&lt;/code&gt; and configure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-env&#34;&gt;# Github Client ID&#xA;G_CLIENT_ID=&#xA;# Github Client Secret&#xA;G_CLIENT_SECRET=&#xA;# JWT Secret, usually the same as Client Secret&#xA;JWT_SECRET=&#xA;# Initialize database, must be set to true on first run, can be turned off afterward&#xA;INIT_TABLE=true&#xA;# Whether to enable cache&#xA;ENABLE_CACHE=true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Database Support&lt;/h3&gt; &#xA;&lt;p&gt;Supported database connectors: &lt;a href=&#34;https://db0.unjs.io/connectors&#34;&gt;https://db0.unjs.io/connectors&lt;/a&gt; &lt;strong&gt;Cloudflare D1 Database&lt;/strong&gt; is recommended.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create D1 database in Cloudflare Worker dashboard&lt;/li&gt; &#xA; &lt;li&gt;Configure database_id and database_name in wrangler.toml&lt;/li&gt; &#xA; &lt;li&gt;If wrangler.toml doesn&#39;t exist, rename example.wrangler.toml and modify configurations&lt;/li&gt; &#xA; &lt;li&gt;Changes will take effect on next deployment&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Docker Deployment&lt;/h3&gt; &#xA;&lt;p&gt;In project root directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker compose up&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also set Environment Variables in &lt;code&gt;docker-compose.yml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!Note] Requires Node.js &amp;gt;= 20&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;corepack enable&#xA;pnpm i&#xA;pnpm dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Adding Data Sources&lt;/h3&gt; &#xA;&lt;p&gt;Refer to &lt;code&gt;shared/sources&lt;/code&gt; and &lt;code&gt;server/sources&lt;/code&gt; directories. The project provides complete type definitions and a clean architecture.&lt;/p&gt; &#xA;&lt;p&gt;For detailed instructions on how to add new sources, see &lt;a href=&#34;https://raw.githubusercontent.com/ourongxing/newsnow/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add &lt;strong&gt;multi-language support&lt;/strong&gt; (English, Chinese, more to come).&lt;/li&gt; &#xA; &lt;li&gt;Improve &lt;strong&gt;personalization options&lt;/strong&gt; (category-based news, saved preferences).&lt;/li&gt; &#xA; &lt;li&gt;Expand &lt;strong&gt;data sources&lt;/strong&gt; to cover global news in multiple languages.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;release when ready&lt;/em&gt;&lt;/strong&gt; &lt;img src=&#34;https://testmnbbs.oss-cn-zhangjiakou.aliyuncs.com/pic/20250328172146_rec_.gif?x-oss-process=base_webp&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are welcome! Feel free to submit pull requests or create issues for feature requests and bug reports.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/ourongxing/newsnow/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for detailed guidelines on how to contribute, especially for adding new data sources.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ourongxing/newsnow/main/LICENSE&#34;&gt;MIT&lt;/a&gt; ¬© ourongxing&lt;/p&gt;</summary>
  </entry>
</feed>