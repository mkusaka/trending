<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub TypeScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-27T01:47:14Z</updated>
  <subtitle>Daily Trending of TypeScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>koskimas/kysely</title>
    <updated>2023-01-27T01:47:14Z</updated>
    <id>tag:github.com,2023-01-27:/koskimas/kysely</id>
    <link href="https://github.com/koskimas/kysely" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A type-safe typescript SQL query builder&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://stand-with-ukraine.pp.ua&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vshymanskyy/StandWithUkraine/main/banner2-direct.svg?sanitize=true&#34; alt=&#34;Stand With Ukraine&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/xyBJ3GwvAm&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/890118421587578920&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/koskimas/kysely&#34;&gt;&lt;img src=&#34;https://github.com/koskimas/kysely/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;Tests&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://koskimas.github.io/kysely/index.html&#34;&gt;Kysely&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Kysely (pronounce “Key-Seh-Lee”) is a type-safe and autocompletion-friendly typescript SQL query builder. Inspired by &lt;a href=&#34;http://knexjs.org/&#34;&gt;knex&lt;/a&gt;. Mainly developed for &lt;a href=&#34;https://nodejs.org/en/&#34;&gt;node.js&lt;/a&gt; but also runs on &lt;a href=&#34;https://deno.land/&#34;&gt;deno&lt;/a&gt; and in the browser.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/koskimas/kysely/raw/master/assets/demo.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Kysely makes sure you only refer to tables and columns that are visible to the part of the query you&#39;re writing. The result type only has the selected columns with correct types and aliases. As an added bonus you get autocompletion for all that stuff.&lt;/p&gt; &#xA;&lt;p&gt;As shown in the gif above, through the pure magic of modern typescript, Kysely is even able to parse the alias given to &lt;code&gt;pet.name&lt;/code&gt; and add the &lt;code&gt;pet_name&lt;/code&gt; column to the result row type. Kysely is able to infer column names, aliases and types from selected subqueries, joined subqueries, &lt;code&gt;with&lt;/code&gt; statements and pretty much anything you can think of.&lt;/p&gt; &#xA;&lt;p&gt;Of course there are cases where things cannot be typed at compile time, and Kysely offers escape hatches for these situations. See the &lt;a href=&#34;https://koskimas.github.io/kysely/interfaces/Sql.html&#34;&gt;sql template tag&lt;/a&gt; and the &lt;a href=&#34;https://koskimas.github.io/kysely/classes/DynamicModule.html#ref&#34;&gt;DynamicModule&lt;/a&gt; for more info.&lt;/p&gt; &#xA;&lt;p&gt;All API documentation is written in the typing files and you can simply &lt;code&gt;cmd-click&lt;/code&gt; on the module, class or method you&#39;re using to see it. The same documentation is also hosted &lt;a href=&#34;https://github.com/koskimas/kysely&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you start using Kysely and can&#39;t find something you&#39;d want to use, please open an issue or join our &lt;a href=&#34;https://discord.gg/xyBJ3GwvAm&#34;&gt;discord server&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can find a more thorough introduction &lt;a href=&#34;https://www.jakso.me/blog/kysely-a-type-safe-sql-query-builder-for-typescript&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Table of contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#3rd-party-dialects&#34;&gt;3rd party dialects&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#minimal-example&#34;&gt;Minimal example&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#playground&#34;&gt;Playground&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#generating-types&#34;&gt;Generating types&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#query-examples&#34;&gt;Query examples&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#select-queries&#34;&gt;Select queries&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#stream-select-query-results&#34;&gt;Stream select query results&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#update-queries&#34;&gt;Update queries&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#insert-queries&#34;&gt;Insert queries&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#delete-queries&#34;&gt;Delete queries&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#recipes&#34;&gt;Recipes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#migrations&#34;&gt;Migrations&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#postgresql-migration-example&#34;&gt;PostgreSQL migration example&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#mysql-migration-example&#34;&gt;MySQL migration example&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#deno&#34;&gt;Deno&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#browser&#34;&gt;Browser&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/#why-not-just-contribute-to-knex&#34;&gt;Why not just contribute to knex&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;Kysely currently works on PostgreSQL, MySQL and SQLite. You can install it using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# PostgreSQL&#xA;npm install kysely pg&#xA;&#xA;# MySQL&#xA;npm install kysely mysql2&#xA;&#xA;# SQLite&#xA;npm install kysely better-sqlite3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More dialects will be added soon. Kysely also has a simple interface for &lt;a href=&#34;https://koskimas.github.io/kysely/interfaces/Dialect.html&#34;&gt;3rd party dialects&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;3rd party dialects&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/serverless-stack/kysely-data-api&#34;&gt;AWS Data API&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/depot/kysely-planetscale&#34;&gt;PlanetScale Serverless Driver&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/igalklebanov/kysely-singlestore&#34;&gt;SingleStore Data API&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/aidenwallis/kysely-d1&#34;&gt;D1&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/igalklebanov/kysely-surrealdb&#34;&gt;SurrealDB&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Minimal example&lt;/h1&gt; &#xA;&lt;p&gt;All you need to do is define an interface for each table in the database and pass those interfaces to the &lt;code&gt;Kysely&lt;/code&gt; constructor:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { Pool } from &#39;pg&#39;&#xA;import {&#xA;  Kysely,&#xA;  PostgresDialect,&#xA;  Generated,&#xA;  ColumnType,&#xA;  Selectable,&#xA;  Insertable,&#xA;  Updateable,&#xA;} from &#39;kysely&#39;&#xA;&#xA;interface PersonTable {&#xA;  // Columns that are generated by the database should be marked&#xA;  // using the `Generated` type. This way they are automatically&#xA;  // made optional in inserts and updates.&#xA;  id: Generated&amp;lt;number&amp;gt;&#xA;&#xA;  first_name: string&#xA;  gender: &#39;male&#39; | &#39;female&#39; | &#39;other&#39;&#xA;&#xA;  // If the column is nullable in the database, make its type nullable.&#xA;  // Don&#39;t use optional properties. Optionality is always determined&#xA;  // automatically by Kysely.&#xA;  last_name: string | null&#xA;&#xA;  // You can specify a different type for each operation (select, insert and&#xA;  // update) using the `ColumnType&amp;lt;SelectType, InsertType, UpdateType&amp;gt;`&#xA;  // wrapper. Here we define a column `modified_at` that is selected as&#xA;  // a `Date`, can optionally be provided as a `string` in inserts and&#xA;  // can never be updated:&#xA;  modified_at: ColumnType&amp;lt;Date, string | undefined, never&amp;gt;&#xA;}&#xA;&#xA;interface PetTable {&#xA;  id: Generated&amp;lt;number&amp;gt;&#xA;  name: string&#xA;  owner_id: number&#xA;  species: &#39;dog&#39; | &#39;cat&#39;&#xA;}&#xA;&#xA;interface MovieTable {&#xA;  id: Generated&amp;lt;string&amp;gt;&#xA;  stars: number&#xA;}&#xA;&#xA;// Keys of this interface are table names.&#xA;interface Database {&#xA;  person: PersonTable&#xA;  pet: PetTable&#xA;  movie: MovieTable&#xA;}&#xA;&#xA;// You&#39;d create one of these when you start your app.&#xA;const db = new Kysely&amp;lt;Database&amp;gt;({&#xA;  // Use MysqlDialect for MySQL and SqliteDialect for SQLite.&#xA;  dialect: new PostgresDialect({&#xA;    pool: new Pool({&#xA;      host: &#39;localhost&#39;,&#xA;      database: &#39;kysely_test&#39;&#xA;    })&#xA;  })&#xA;})&#xA;&#xA;async function demo() {&#xA;  const { id } = await db&#xA;    .insertInto(&#39;person&#39;)&#xA;    .values({ first_name: &#39;Jennifer&#39;, gender: &#39;female&#39; })&#xA;    .returning(&#39;id&#39;)&#xA;    .executeTakeFirstOrThrow()&#xA;&#xA;  await db&#xA;    .insertInto(&#39;pet&#39;)&#xA;    .values({ name: &#39;Catto&#39;, species: &#39;cat&#39;, owner_id: id })&#xA;    .execute()&#xA;&#xA;  const person = await db&#xA;    .selectFrom(&#39;person&#39;)&#xA;    .innerJoin(&#39;pet&#39;, &#39;pet.owner_id&#39;, &#39;person.id&#39;)&#xA;    .select([&#39;first_name&#39;, &#39;pet.name as pet_name&#39;])&#xA;    .where(&#39;person.id&#39;, &#39;=&#39;, id)&#xA;    .executeTakeFirst()&#xA;&#xA;  if (person) {&#xA;    person.pet_name&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// You can extract the select, insert and update interfaces like this&#xA;// if you want (you don&#39;t need to):&#xA;type Person = Selectable&amp;lt;PersonTable&amp;gt;&#xA;type InsertablePerson = Insertable&amp;lt;PersonTable&amp;gt;&#xA;type UpdateablePerson = Updateable&amp;lt;PersonTable&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Playground&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wirekang&#34;&gt;@wirekang&lt;/a&gt; has created a &lt;a href=&#34;https://wirekang.github.io/kysely-playground/?p=f&amp;amp;i=-NLp3n_P5fyeQKMQda8n&#34;&gt;playground for Kysely&lt;/a&gt;. You can use to quickly test stuff out and for creating code examples for your issues, PRs and discord messages.&lt;/p&gt; &#xA;&lt;h1&gt;Generating types&lt;/h1&gt; &#xA;&lt;p&gt;If you want to generate the table types automatically from the database schema please check out &lt;a href=&#34;https://github.com/RobinBlomberg/kysely-codegen&#34;&gt;this awesome project&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Query examples&lt;/h1&gt; &#xA;&lt;h2&gt;Select queries&lt;/h2&gt; &#xA;&lt;p&gt;You can find examples of select queries in the documentation of the &lt;a href=&#34;https://koskimas.github.io/kysely/classes/SelectQueryBuilder.html#select&#34;&gt;select method&lt;/a&gt; and the &lt;a href=&#34;https://koskimas.github.io/kysely/classes/SelectQueryBuilder.html#where&#34;&gt;where method&lt;/a&gt; among other places.&lt;/p&gt; &#xA;&lt;h3&gt;Stream select query results&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;Currently only supported by &lt;code&gt;postgres&lt;/code&gt; and &lt;code&gt;mysql&lt;/code&gt; dialects.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { Pool } from &#39;pg&#39;&#xA;// or `import * as Cursor from &#39;pg-cursor&#39;` depending on your tsconfig&#xA;import Cursor from &#39;pg-cursor&#39;&#xA;import { Kysely, PostgresDialect } from &#39;kysely&#39;&#xA;&#xA;const db = new Kysely&amp;lt;Database&amp;gt;({&#xA;  // PostgresDialect requires the Cursor dependency&#xA;  dialect: new PostgresDialect({&#xA;    pool: new Pool({&#xA;      host: &#39;localhost&#39;,&#xA;      database: &#39;kysely_test&#39;&#xA;    }),&#xA;    cursor: Cursor&#xA;  }),&#xA;  // MysqlDialect doesn&#39;t require any special configuration&#xA;})&#xA;&#xA;async function demo() {&#xA;  for await (const adult of db.selectFrom(&#39;person&#39;)&#xA;    .selectAll()&#xA;    .where(&#39;age&#39;, &#39;&amp;gt;&#39;, 18)&#xA;    .stream()&#xA;  ) {&#xA;    console.log(`Hello ${adult.first_name}!`)&#xA;&#xA;    if (adult.first_name === &#39;John&#39;) {&#xA;      // After this line the db connection is released and no more&#xA;      // rows are streamed from the database to the client&#xA;      break;&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Update queries&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://koskimas.github.io/kysely/classes/UpdateQueryBuilder.html#set&#34;&gt;set method&lt;/a&gt; and the &lt;a href=&#34;https://koskimas.github.io/kysely/classes/Kysely.html#updateTable&#34;&gt;updateTable method&lt;/a&gt; documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Insert queries&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://koskimas.github.io/kysely/classes/InsertQueryBuilder.html#values&#34;&gt;values method&lt;/a&gt; and the &lt;a href=&#34;https://koskimas.github.io/kysely/classes/Kysely.html#insertInto&#34;&gt;insertInto method&lt;/a&gt; documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Delete queries&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://koskimas.github.io/kysely/classes/Kysely.html#deleteFrom&#34;&gt;deleteFrom method&lt;/a&gt; documentation.&lt;/p&gt; &#xA;&lt;h1&gt;Recipes&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/koskimas/kysely/tree/master/recipes&#34;&gt;recipes&lt;/a&gt; folder contains a bunch of small tutorials or &#34;recipes&#34; for common use cases.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/koskimas/kysely/tree/master/recipes/conditional-selects.md&#34;&gt;Conditional selects&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/koskimas/kysely/tree/master/recipes/deduplicate-joins.md&#34;&gt;Deduplicate joins&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/koskimas/kysely/tree/master/recipes/extending-kysely.md&#34;&gt;Extending kysely&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/koskimas/kysely/tree/master/recipes/raw-sql.md&#34;&gt;Raw SQL&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/koskimas/kysely/tree/master/recipes/schemas.md&#34;&gt;Schemas&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/koskimas/kysely/tree/master/recipes/excessively-deep-types.md&#34;&gt;Dealing with the &lt;code&gt;Type instantiation is excessively deep and possibly infinite&lt;/code&gt; error&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Migrations&lt;/h1&gt; &#xA;&lt;p&gt;Migration files should look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { Kysely } from &#39;kysely&#39;&#xA;&#xA;export async function up(db: Kysely&amp;lt;any&amp;gt;): Promise&amp;lt;void&amp;gt; {&#xA;  // Migration code&#xA;}&#xA;&#xA;export async function down(db: Kysely&amp;lt;any&amp;gt;): Promise&amp;lt;void&amp;gt; {&#xA;  // Migration code&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;up&lt;/code&gt; function is called when you update your database schema to the next version and &lt;code&gt;down&lt;/code&gt; when you go back to previous version. The only argument for the functions is an instance of &lt;code&gt;Kysely&amp;lt;any&amp;gt;&lt;/code&gt;. It&#39;s important to use &lt;code&gt;Kysely&amp;lt;any&amp;gt;&lt;/code&gt; and not &lt;code&gt;Kysely&amp;lt;YourDatabase&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Migrations should never depend on the current code of your app because they need to work even when the app changes. Migrations need to be &#34;frozen in time&#34;.&lt;/p&gt; &#xA;&lt;p&gt;The migrations can use the &lt;a href=&#34;https://koskimas.github.io/kysely/classes/SchemaModule.html&#34;&gt;Kysely.schema&lt;/a&gt; module to modify the schema. Migrations can also run normal queries to modify data.&lt;/p&gt; &#xA;&lt;p&gt;Execution order of the migrations is the alpabetical order of their names. An excellent way to name your migrations is to prefix them with an ISO 8601 date string. A date prefix works well in large teams where multiple team members may add migrations at the same time in parallel commits without knowing about the other migrations.&lt;/p&gt; &#xA;&lt;p&gt;You don&#39;t need to store your migrations as separate files if you don&#39;t want to. You can easily implement your own &lt;a href=&#34;https://koskimas.github.io/kysely/interfaces/MigrationProvider.html&#34;&gt;MigrationProvider&lt;/a&gt; and give it to the &lt;a href=&#34;https://koskimas.github.io/kysely/classes/Migrator.html&#34;&gt;Migrator&lt;/a&gt; class when you instantiate one.&lt;/p&gt; &#xA;&lt;h3&gt;PostgreSQL migration example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { Kysely, sql } from &#39;kysely&#39;&#xA;&#xA;export async function up(db: Kysely&amp;lt;any&amp;gt;): Promise&amp;lt;void&amp;gt; {&#xA;  await db.schema&#xA;    .createTable(&#39;person&#39;)&#xA;    .addColumn(&#39;id&#39;, &#39;serial&#39;, (col) =&amp;gt; col.primaryKey())&#xA;    .addColumn(&#39;first_name&#39;, &#39;varchar&#39;, (col) =&amp;gt; col.notNull())&#xA;    .addColumn(&#39;last_name&#39;, &#39;varchar&#39;)&#xA;    .addColumn(&#39;gender&#39;, &#39;varchar(50)&#39;, (col) =&amp;gt; col.notNull())&#xA;    .addColumn(&#39;created_at&#39;, &#39;timestamp&#39;, (col) =&amp;gt; col.defaultTo(sql`now()`).notNull())&#xA;    .execute()&#xA;&#xA;  await db.schema&#xA;    .createTable(&#39;pet&#39;)&#xA;    .addColumn(&#39;id&#39;, &#39;serial&#39;, (col) =&amp;gt; col.primaryKey())&#xA;    .addColumn(&#39;name&#39;, &#39;varchar&#39;, (col) =&amp;gt; col.notNull().unique())&#xA;    .addColumn(&#39;owner_id&#39;, &#39;integer&#39;, (col) =&amp;gt;&#xA;      col.references(&#39;person.id&#39;).onDelete(&#39;cascade&#39;).notNull()&#xA;    )&#xA;    .addColumn(&#39;species&#39;, &#39;varchar&#39;, (col) =&amp;gt; col.notNull())&#xA;    .execute()&#xA;&#xA;  await db.schema&#xA;    .createIndex(&#39;pet_owner_id_index&#39;)&#xA;    .on(&#39;pet&#39;)&#xA;    .column(&#39;owner_id&#39;)&#xA;    .execute()&#xA;}&#xA;&#xA;export async function down(db: Kysely&amp;lt;any&amp;gt;): Promise&amp;lt;void&amp;gt; {&#xA;  await db.schema.dropTable(&#39;pet&#39;).execute()&#xA;  await db.schema.dropTable(&#39;person&#39;).execute()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MySQL migration example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { Kysely } from &#39;kysely&#39;&#xA;&#xA;export async function up(db: Kysely&amp;lt;any&amp;gt;): Promise&amp;lt;void&amp;gt; {&#xA;  await db.schema&#xA;    .createTable(&#39;person&#39;)&#xA;    .addColumn(&#39;id&#39;, &#39;integer&#39;, (col) =&amp;gt; col.autoIncrement().primaryKey())&#xA;    .addColumn(&#39;first_name&#39;, &#39;varchar(255)&#39;, (col) =&amp;gt; col.notNull())&#xA;    .addColumn(&#39;last_name&#39;, &#39;varchar(255)&#39;)&#xA;    .addColumn(&#39;gender&#39;, &#39;varchar(50)&#39;, (col) =&amp;gt; col.notNull())&#xA;    .execute()&#xA;&#xA;  await db.schema&#xA;    .createTable(&#39;pet&#39;)&#xA;    .addColumn(&#39;id&#39;, &#39;integer&#39;, (col) =&amp;gt; col.autoIncrement().primaryKey())&#xA;    .addColumn(&#39;name&#39;, &#39;varchar(255)&#39;, (col) =&amp;gt; col.notNull().unique())&#xA;    .addColumn(&#39;owner_id&#39;, &#39;integer&#39;, (col) =&amp;gt; col.notNull())&#xA;    .addColumn(&#39;species&#39;, &#39;varchar(255)&#39;, (col) =&amp;gt; col.notNull())&#xA;    .addForeignKeyConstraint(&#xA;      &#39;pet_owner_id_fk&#39;, [&#39;owner_id&#39;], &#39;person&#39;, [&#39;id&#39;],&#xA;      (cb) =&amp;gt; cb.onDelete(&#39;cascade&#39;)&#xA;    )&#xA;    .execute()&#xA;&#xA;  await db.schema&#xA;    .createIndex(&#39;pet_owner_id_index&#39;)&#xA;    .on(&#39;pet&#39;)&#xA;    .column(&#39;owner_id&#39;)&#xA;    .execute()&#xA;}&#xA;&#xA;export async function down(db: Kysely&amp;lt;any&amp;gt;): Promise&amp;lt;void&amp;gt; {&#xA;  await db.schema.dropTable(&#39;pet&#39;).execute()&#xA;  await db.schema.dropTable(&#39;person&#39;).execute()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const migrator = new Migrator(migratorConfig);&#xA;await migrator.migrateToLatest(pathToMigrationsFolder)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to run all migrations that have not yet been run. See the &lt;a href=&#34;https://koskimas.github.io/kysely/classes/Migrator.html&#34;&gt;Migrator&lt;/a&gt; class&#39;s documentation for more info.&lt;/p&gt; &#xA;&lt;p&gt;Kysely doesn&#39;t have a CLI for running migrations and probably never will. This is because Kysely&#39;s migrations are also written in typescript. To run the migrations, you need to first build the typescript code into javascript. A CLI would cause confusion over which migrations are being run, the typescript ones or the javascript ones. If we added support for both, the CLI would need to depend on a typescript compiler, which most production environments don&#39;t (and shouldn&#39;t) have. You will probably want to add a simple migration script to your projects like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import * as path from &#39;path&#39;&#xA;import {&amp;nbsp;Pool } from &#39;pg&#39;&#xA;import { promises as fs } from &#39;fs&#39;&#xA;import {&#xA;  Kysely,&#xA;  Migrator,&#xA;  PostgresDialect,&#xA;  FileMigrationProvider&#xA;} from &#39;kysely&#39;&#xA;&#xA;async function migrateToLatest() {&#xA;  const db = new Kysely&amp;lt;Database&amp;gt;({&#xA;    dialect: new PostgresDialect({&#xA;      pool: new Pool({&#xA;        host: &#39;localhost&#39;,&#xA;        database: &#39;kysely_test&#39;,&#xA;      })&#xA;    }),&#xA;  })&#xA;&#xA;  const migrator = new Migrator({&#xA;    db,&#xA;    provider: new FileMigrationProvider({&#xA;      fs,&#xA;      path,&#xA;      migrationFolder: &#39;some/path/to/migrations&#39;,&#xA;    })&#xA;  })&#xA;&#xA;  const { error, results } = await migrator.migrateToLatest()&#xA;&#xA;  results?.forEach((it) =&amp;gt; {&#xA;    if (it.status === &#39;Success&#39;) {&#xA;      console.log(`migration &#34;${it.migrationName}&#34; was executed successfully`)&#xA;    } else if (it.status === &#39;Error&#39;) {&#xA;      console.error(`failed to execute migration &#34;${it.migrationName}&#34;`)&#xA;    }&#xA;  })&#xA;&#xA;  if (error) {&#xA;    console.error(&#39;failed to migrate&#39;)&#xA;    console.error(error)&#xA;    process.exit(1)&#xA;  }&#xA;&#xA;  await db.destroy()&#xA;}&#xA;&#xA;migrateToLatest()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The migration methods use a lock on the database level and parallel calls are executed serially. This means that you can safely call &lt;code&gt;migrateToLatest&lt;/code&gt; and other migration methods from multiple server instances simultaneously and the migrations are guaranteed to only be executed once. The locks are also automatically released if the migration process crashes or the connection to the database fails.&lt;/p&gt; &#xA;&lt;h1&gt;Deno&lt;/h1&gt; &#xA;&lt;p&gt;Kysely doesn&#39;t include drivers for deno, but you can still use Kysely as a query builder or implement your own driver:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// We use jsdeliver to get Kysely from npm.&#xA;import {&#xA;  DummyDriver,&#xA;  Generated,&#xA;  Kysely,&#xA;  PostgresAdapter,&#xA;  PostgresIntrospector,&#xA;  PostgresQueryCompiler,&#xA;} from &#39;https://cdn.jsdelivr.net/npm/kysely/dist/esm/index.js&#39;&#xA;&#xA;interface Person {&#xA;  id: Generated&amp;lt;number&amp;gt;&#xA;  first_name: string&#xA;  last_name: string | null&#xA;}&#xA;&#xA;interface Database {&#xA;  person: Person&#xA;}&#xA;&#xA;const db = new Kysely&amp;lt;Database&amp;gt;({&#xA;  dialect: {&#xA;    createAdapter() {&#xA;      return new PostgresAdapter()&#xA;    },&#xA;    createDriver() {&#xA;      // You need a driver to be able to execute queries. In this example&#xA;      // we use the dummy driver that never does anything.&#xA;      return new DummyDriver()&#xA;    },&#xA;    createIntrospector(db: Kysely&amp;lt;unknown&amp;gt;) {&#xA;      return new PostgresIntrospector(db)&#xA;    },&#xA;    createQueryCompiler() {&#xA;      return new PostgresQueryCompiler()&#xA;    },&#xA;  },&#xA;})&#xA;&#xA;const query = db.selectFrom(&#39;person&#39;).select(&#39;id&#39;)&#xA;const sql = query.compile()&#xA;&#xA;console.log(sql.sql)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Browser&lt;/h1&gt; &#xA;&lt;p&gt;Kysely also runs in the browser:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import {&#xA;  Kysely,&#xA;  Generated,&#xA;  DummyDriver,&#xA;  SqliteAdapter,&#xA;  SqliteIntrospector,&#xA;  SqliteQueryCompiler,&#xA;} from &#39;kysely&#39;&#xA;&#xA;interface Person {&#xA;  id: Generated&amp;lt;number&amp;gt;&#xA;  first_name: string&#xA;  last_name: string | null&#xA;}&#xA;&#xA;interface Database {&#xA;  person: Person&#xA;}&#xA;&#xA;const db = new Kysely&amp;lt;Database&amp;gt;({&#xA;  dialect: {&#xA;    createAdapter() {&#xA;      return new SqliteAdapter()&#xA;    },&#xA;    createDriver() {&#xA;      return new DummyDriver()&#xA;    },&#xA;    createIntrospector(db: Kysely&amp;lt;unknown&amp;gt;) {&#xA;      return new SqliteIntrospector(db)&#xA;    },&#xA;    createQueryCompiler() {&#xA;      return new SqliteQueryCompiler()&#xA;    },&#xA;  },&#xA;})&#xA;&#xA;window.addEventListener(&#39;load&#39;, () =&amp;gt; {&#xA;  const sql = db.selectFrom(&#39;person&#39;).select(&#39;id&#39;).compile()&#xA;&#xA;  const result = document.createElement(&#39;span&#39;)&#xA;  result.id = &#39;result&#39;&#xA;  result.innerHTML = sql.sql&#xA;&#xA;  document.body.appendChild(result)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Why not just contribute to knex&lt;/h1&gt; &#xA;&lt;p&gt;Kysely is very similar to knex, but it also attempts to fix things that I personally find not-so-good in knex. Bringing the type system and the changes to knex would mean very significant breaking changes that aren&#39;t possible at this point of the project. Knex was also originally written for javascript and the typescript typings were added afterwards. That always leads to compromises in the types. Designing a library for typescript from the ground up produces much better and simpler types.&lt;/p&gt; &#xA;&lt;h1&gt;How to contribute to Kysely&lt;/h1&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/koskimas/kysely/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>luxdefi/market</title>
    <updated>2023-01-27T01:47:14Z</updated>
    <id>tag:github.com,2023-01-27:/luxdefi/market</id>
    <link href="https://github.com/luxdefi/market" rel="alternate"></link>
    <summary type="html">&lt;p&gt;▼ LUX Market interface to Real World Assets (RWAs).&lt;/p&gt;&lt;hr&gt;&lt;h3 align=&#34;center&#34;&gt;Lux Finance [BETA]&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;/p&gt;&#xA;&lt;p&gt;At &lt;a href=&#34;https://lux.partners&#34;&gt;Lux&lt;/a&gt;, we&#39;re building the future of real world assets.&lt;/p&gt; &#xA;&lt;p&gt;Lux Finance is an open source protocol built on the best in DeFi.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;h3&gt;Run the App&lt;/h3&gt; &#xA;&lt;p&gt;Once you have your setup ready, run:&lt;/p&gt; &#xA;&lt;p&gt;With yarn:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ yarn dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With npm:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ npm run dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deploy with Vercel&lt;/h3&gt; &#xA;&lt;p&gt;This is a Next.js app that can be easily deployed using &lt;a href=&#34;https://vercel.com/&#34;&gt;Vercel&lt;/a&gt;. For more information on how to deploy your Github repository with Vercel visit their &lt;a href=&#34;https://vercel.com/docs/concepts/projects/overview&#34;&gt;docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p align=&#34;right&#34;&gt;(&lt;a href=&#34;https://raw.githubusercontent.com/luxdefi/market/main/#top&#34;&gt;back to top&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;!-- CONTACT --&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;Twitter: &lt;a href=&#34;https://twitter.com/luxdefi&#34;&gt;@luxdefi&lt;/a&gt; Project Link: &lt;a href=&#34;https://lux.finance/&#34;&gt;Reservoir&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is MIT licensed.&lt;/p&gt;</summary>
  </entry>
</feed>