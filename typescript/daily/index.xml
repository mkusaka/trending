<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub TypeScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-17T01:36:27Z</updated>
  <subtitle>Daily Trending of TypeScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>reorproject/reor</title>
    <updated>2024-02-17T01:36:27Z</updated>
    <id>tag:github.com,2024-02-17:/reorproject/reor</id>
    <link href="https://github.com/reorproject/reor" rel="alternate"></link>
    <summary type="html">&lt;p&gt;AI note-taking app that runs models locally.&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;Reor Project&lt;/h1&gt; &#xA;&lt;!-- &lt;p align=&#34;center&#34;&gt;&#xA;    &lt;img src=&#34;logo_or_graphic_representation.png&#34; alt=&#34;Reor Logo&#34;&gt;&#xA;&lt;/p&gt; --&gt; &#xA;&lt;h4 align=&#34;center&#34;&gt; A self-organizing AI note-taking app that runs models locally.&lt;/h4&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/reorproject/reor/main/LICENSE&#34;&gt;&lt;img alt=&#34;License&#34; src=&#34;https://img.shields.io/badge/license-GPLv3-blue.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;img alt=&#34;GitHub Release Date - Published_At&#34; src=&#34;https://img.shields.io/github/release-date/reorproject/reor&#34;&gt; &lt;img alt=&#34;GitHub Repo stars&#34; src=&#34;https://img.shields.io/github/stars/reorproject/reor&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Reor&lt;/strong&gt; is an AI-powered desktop note-taking app: it automatically links related ideas, answers questions on your notes and provides semantic search. Everything is stored locally and you can edit your notes with an Obsidian-like markdown editor.&lt;/p&gt; &#xA;&lt;p&gt;The hypothesis of the project is that AI tools for thought should &lt;strong&gt;run models locally&lt;/strong&gt; by default. Reor stands on the shoulders of the giants &lt;a href=&#34;https://github.com/ggerganov/llama.cpp&#34;&gt;Llama.cpp&lt;/a&gt;, &lt;a href=&#34;https://github.com/xenova/transformers.js&#34;&gt;Transformers.js&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/lancedb/lancedb&#34;&gt;LanceDB&lt;/a&gt; to enable both LLMs and embedding models to run locally. (Connecting to OpenAI-compatible APIs like Oobabooga is also supported.)&lt;/p&gt; &#xA;&lt;h3&gt;How can it possibly be &#34;self-organizing&#34;?&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Every note you write is chunked and embedded into an internal vector database.&lt;/li&gt; &#xA; &lt;li&gt;Related notes are connected automatically via vector similarity.&lt;/li&gt; &#xA; &lt;li&gt;LLM-powered Q&amp;amp;A does RAG on the corpus of notes.&lt;/li&gt; &#xA; &lt;li&gt;Everything can be searched semantically.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;One way to think about Reor is as a RAG app with two generators: the LLM and the human. In Q&amp;amp;A mode, the LLM is fed retrieved context from the corpus to help answer a query. Similarly, in editor mode, the human can toggle the sidebar to reveal related notes &#34;retrieved&#34; from the corpus. This is quite a powerful way of &#34;augmenting&#34; your thoughts by cross-referencing ideas in a current note against related ideas from your corpus.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/reorproject/reor/assets/17236551/1bbc1b2d-c3d9-451c-a008-7f12c84f96db&#34;&gt;https://github.com/reorproject/reor/assets/17236551/1bbc1b2d-c3d9-451c-a008-7f12c84f96db&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Getting Started&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download from &lt;a href=&#34;https://reorproject.org&#34;&gt;reorproject.org&lt;/a&gt; or &lt;a href=&#34;https://github.com/reorproject/reor/releases&#34;&gt;releases&lt;/a&gt;. Mac, Linux &amp;amp; Windows are all supported.&lt;/li&gt; &#xA; &lt;li&gt;Install like a normal App.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Running local models&lt;/h3&gt; &#xA;&lt;p&gt;Reor interacts directly with &lt;a href=&#34;https://github.com/ggerganov/llama.cpp&#34;&gt;Llama.cpp&lt;/a&gt; libraries so there&#39;s no need to download Ollama. Although right now, we don&#39;t download models for you so you&#39;ll need to download your model of choice manually:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download a GGUF model file. &lt;a href=&#34;https://huggingface.co/models?sort=downloads&amp;amp;search=gguf&#34;&gt;Hugging Face&lt;/a&gt; has this nice page with the most popular models. I recommend starting with a 7B 4-bit model and see how that performs on your system.&lt;/li&gt; &#xA; &lt;li&gt;Connect it in Reor settings under &#34;Add a new local model&#34;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;You can also connect to an OpenAI-compatible API like Oobabooga, Ollama or OpenAI itself!&lt;/p&gt; &#xA;&lt;h3&gt;Importing notes from other apps&lt;/h3&gt; &#xA;&lt;p&gt;Reor works within a single directory in the filesystem. You choose the directory on first boot. To import notes/files from another app, you&#39;ll need to populate that directory manually with markdown files. Integrations with other apps are hopefully coming soon!&lt;/p&gt; &#xA;&lt;h3&gt;Building from source&lt;/h3&gt; &#xA;&lt;h4&gt;Clone repo:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/reorproject/reor.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Install dependencies:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;npm install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Run for dev:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;npm run dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Build:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;npm run build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Contributions&lt;/h3&gt; &#xA;&lt;p&gt;Contributions are welcome in all areas: features, ideas, bug fixes, design, etc. This is very much a community driven project. There are some open issues to choose from. For new features, please open an issue to discuss it before beginning work on a PR :)&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;GPL-3.0 license. See &lt;code&gt;LICENSE&lt;/code&gt; for details.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Reor means &#34;to think&#34; in Latin.&lt;/em&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>subsquid-quests/network-test-one-uniform-load-squid</title>
    <updated>2024-02-17T01:36:27Z</updated>
    <id>tag:github.com,2024-02-17:/subsquid-quests/network-test-one-uniform-load-squid</id>
    <link href="https://github.com/subsquid-quests/network-test-one-uniform-load-squid" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A quest squid designed to load Phase 2 Subsquid Network uniformly&lt;/p&gt;&lt;hr&gt;&lt;p&gt;w&lt;/p&gt;&#xA;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;picture&gt; &#xA;  &lt;source srcset=&#34;https://uploads-ssl.webflow.com/63b5a9958fccedcf67d716ac/64662df3a5a568fd99e3600c_Squid_Pose_1_White-transparent-slim%201.png&#34; media=&#34;(prefers-color-scheme: dark)&#34;&gt; &#xA;  &lt;img src=&#34;https://uploads-ssl.webflow.com/63b5a9958fccedcf67d716ac/64662df3a5a568fd99e3600c_Squid_Pose_1_White-transparent-slim%201.png&#34; alt=&#34;Subsquid Logo&#34;&gt; &#xA; &lt;/picture&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.subsquid.io/&#34;&gt;&lt;img src=&#34;https://docs.rs/leptos/badge.svg?sanitize=true&#34; alt=&#34;docs.rs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/subsquid&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/1031524867910148188?color=%237289DA&amp;amp;label=discord&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://subsquid.io&#34;&gt;Website&lt;/a&gt; | &lt;a href=&#34;https://docs.subsquid.io/&#34;&gt;Docs&lt;/a&gt; | &lt;a href=&#34;https://discord.gg/subsquid&#34;&gt;Discord&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.subsquid.io/subsquid-network/&#34;&gt;Subsquid Network Docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Network Test One: Uniform Load&lt;/h1&gt; &#xA;&lt;p&gt;Some tests of Subsquid Network Phase Two testnet require that all workers regularly serve some queries. You can help the team create this type of uniform load by running this squid.&lt;/p&gt; &#xA;&lt;p&gt;Note: you&#39;ll need to have at least 10 tSQD to complete this quest. Obtain them by doing other quests first.&lt;/p&gt; &#xA;&lt;h3&gt;I. Install dependencies: Node.js, Docker, Git.&lt;/h3&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;On Windows&lt;/summary&gt; &#xA; &lt;ol&gt; &#xA;  &lt;li&gt;Enable &lt;a href=&#34;https://learn.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v&#34;&gt;Hyper-V&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;li&gt;Install &lt;a href=&#34;https://docs.docker.com/desktop/install/windows-install/&#34;&gt;Docker for Windows&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;li&gt;Install NodeJS LTS using the &lt;a href=&#34;https://nodejs.org/en/download&#34;&gt;official installer&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;li&gt;Install &lt;a href=&#34;https://git-scm.com/download/win&#34;&gt;Git for Windows&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;/ol&gt; &#xA; &lt;p&gt;In all installs it is OK to leave all the options at their default values. You will need a terminal to complete this tutorial - &lt;a href=&#34;https://learn.microsoft.com/en-us/windows/wsl/install&#34;&gt;WSL&lt;/a&gt; bash is the preferred option.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;On Mac&lt;/summary&gt; &#xA; &lt;ol&gt; &#xA;  &lt;li&gt;Install &lt;a href=&#34;https://docs.docker.com/desktop/install/mac-install/&#34;&gt;Docker for Mac&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;li&gt;Install Git using the &lt;a href=&#34;https://sourceforge.net/projects/git-osx-installer/&#34;&gt;installer&lt;/a&gt; or by &lt;a href=&#34;https://git-scm.com/download/mac&#34;&gt;other means&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;li&gt;Install NodeJS LTS using the &lt;a href=&#34;https://nodejs.org/en/download&#34;&gt;official installer&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;/ol&gt; &#xA; &lt;p&gt;We recommend configuring NodeJS to install global packages to a folder owned by an unprivileged account. Create the folder by running&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir ~/global-node-packages&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;then configure NodeJS to use it&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm config set prefix ~/global-node-packages&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Make sure that the folder &lt;code&gt;~/global-node-packages/bin&lt;/code&gt; is in &lt;code&gt;PATH&lt;/code&gt;. That allows running globally installed NodeJS executables from any terminal. Here is a one-liner that detects your shell and takes care of setting &lt;code&gt;PATH&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;CURSHELL=`ps -hp $$ | awk &#39;{print $5}&#39;`; case `basename $CURSHELL` in &#39;bash&#39;) DEST=&#34;$HOME/.bash_profile&#34;;; &#39;zsh&#39;) DEST=&#34;$HOME/.zshenv&#34;;; esac; echo &#39;export PATH=&#34;${HOME}/global-node-packages/bin:$PATH&#34;&#39; &amp;gt;&amp;gt; &#34;$DEST&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Alternatively you can add the following line to &lt;code&gt;~/.zshenv&lt;/code&gt; (if you are using zsh) or &lt;code&gt;~/.bash_profile&lt;/code&gt; (if you are using bash) manually:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;export PATH=&#34;${HOME}/global-node-packages/bin:$PATH&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Re-open the terminal to apply the changes.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;On Linux&lt;/summary&gt; &#xA; &lt;p&gt;Install &lt;a href=&#34;https://nodejs.org/en/download/package-manager&#34;&gt;NodeJS (v16 or newer)&lt;/a&gt;, Git and Docker using your distro&#39;s package manager.&lt;/p&gt; &#xA; &lt;p&gt;We recommend configuring NodeJS to install global packages to a folder owned by an unprivileged account. Create the folder by running&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir ~/global-node-packages&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;then configure NodeJS to use it&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm config set prefix ~/global-node-packages&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Make sure that any executables globally installed by NodeJS are in &lt;code&gt;PATH&lt;/code&gt;. That allows running them from any terminal. Open the &lt;code&gt;~/.bashrc&lt;/code&gt; file in a text editor and add the following line at the end:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;export PATH=&#34;${HOME}/global-node-packages/bin:$PATH&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Re-open the terminal to apply the changes.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;II. Install Subsquid CLI&lt;/h3&gt; &#xA;&lt;p&gt;Open a terminal and run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install --global @subsquid/cli@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This adds the &lt;a href=&#34;https://docs.subsquid.io/squid-cli/&#34;&gt;&lt;code&gt;sqd&lt;/code&gt; command&lt;/a&gt;. Verify that the installation was successful by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sqd --version&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A healthy response should look similar to&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@subsquid/cli/2.8.0 linux-x64 node-v20.5.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;III. Run the squid&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open a terminal, navigate to any folder for which you have write permissions and run the following commands to retrieve the squid, enter its folder and install dependencies: &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sqd init uniform-load-squid -t https://github.com/subsquid-quests/network-test-one-uniform-load-squid&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd uniform-load-squid&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm ci&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] If you&#39;re on Windows, the terminal opens in &lt;code&gt;C:\Windows\system32&lt;/code&gt; by default. Do not download your squid there, navigate someplace else.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Press &#34;Get Key&#34; button in the quest card to obtain the &lt;code&gt;networkTestOneUniformLoad.key&lt;/code&gt; key file. Save it to the &lt;code&gt;./query-gateway/keys&lt;/code&gt; subfolder of the squid folder. The file will be used to identify your local query gateway when locking tSQD to allocate bandwidth and as it operates.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Get the peer ID of your future gateway by running:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sqd get-peer-id&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Register your future gateway using &lt;a href=&#34;https://app.subsquid.io/profile/gateways/add?testnet&#34;&gt;this page&lt;/a&gt;.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Use the peer ID you obtained in the previous step.&lt;/li&gt; &#xA;   &lt;li&gt;Leave the &#34;Publicly available&#34; switch disabled.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Lock 10 tSQD by selecting your gateway on &lt;a href=&#34;https://app.subsquid.io/profile/gateways?testnet&#34;&gt;this page&lt;/a&gt;, clicking &#34;Get CU&#34; and submitting the form. Once done, you will begin getting computation units (&lt;em&gt;CUs&lt;/em&gt;) once every epoch (~15 minutes).&lt;/p&gt; &lt;p&gt;The &#34;Lock blocks duration&#34; field lets you tune the length of time during which you&#39;ll be able to query the network, measured in blocks of Arbitrum Sepolia&#39;s L1 (that is, Ethereum Sepolia). The minumum is five hours, but you can opt to lock for longer if you intend to work on the quest over multiple days.&lt;/p&gt; &#xA;  &lt;table&gt; &#xA;   &lt;thead&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;th align=&#34;center&#34;&gt;Time&lt;/th&gt; &#xA;     &lt;th align=&#34;center&#34;&gt;Blocks&lt;/th&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/thead&gt; &#xA;   &lt;tbody&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td align=&#34;center&#34;&gt;5 hours (minimum)&lt;/td&gt; &#xA;     &lt;td align=&#34;center&#34;&gt;1500&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td align=&#34;center&#34;&gt;24 hours&lt;/td&gt; &#xA;     &lt;td align=&#34;center&#34;&gt;7200&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td align=&#34;center&#34;&gt;72 hours&lt;/td&gt; &#xA;     &lt;td align=&#34;center&#34;&gt;21600&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/tbody&gt; &#xA;  &lt;/table&gt; &lt;p&gt;Be aware that you&#39;ll need to unlock your tokens manually after the end of this period. The tokens you get back will be used in subsequent quests.&lt;/p&gt; &lt;p&gt;If the locking period expires before you finish your work, simply unlock your tokens, then lock them again.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Wait for about 15 minutes. This is the time it takes for Subsquid Network to enter a new epoch, at the beginning of which CUs will be allocated towards your gateway.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Start the query gateway with&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sqd up&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;If you&#39;d like to check if the locking was successful, you can inspect the logs of the query gateway container with &lt;code&gt;docker logs &amp;lt;query_gateway_container_name&amp;gt;&lt;/code&gt;. After one-two minutes required for the node startup it should contain some lines like this one:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;[2024-01-31T14:55:06Z INFO  query_gateway::chain_updates] allocated CU: 48300 spent CU: 0&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!TIP] If you get an error message about &lt;code&gt;unknown shorthand flag: &#39;d&#39; in -d&lt;/code&gt;, that means that you&#39;re using an old version of &lt;code&gt;docker&lt;/code&gt; that does not support the &lt;code&gt;compose&lt;/code&gt; command yet. Update Docker or edit the &lt;code&gt;commands.json&lt;/code&gt; file as follows:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;         &#34;up&#34;: {&#xA;         &#34;deps&#34;: [&#34;check-key&#34;],&#xA;         &#34;description&#34;: &#34;Start a PG database&#34;,&#xA;-        &#34;cmd&#34;: [&#34;docker&#34;, &#34;compose&#34;, &#34;up&#34;, &#34;-d&#34;]&#xA;+        &#34;cmd&#34;: [&#34;docker-compose&#34;, &#34;up&#34;, &#34;-d&#34;]&#xA;       },&#xA;       &#34;down&#34;: {&#xA;         &#34;description&#34;: &#34;Drop a PG database&#34;,&#xA;-        &#34;cmd&#34;: [&#34;docker&#34;, &#34;compose&#34;, &#34;down&#34;]&#xA;+        &#34;cmd&#34;: [&#34;docker-compose&#34;, &#34;down&#34;]&#xA;       },&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ol start=&#34;8&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Build the squid code&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sqd build&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Start your squid with&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sqd run .&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The command should output lines like these:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;[eth-processor] {&#34;level&#34;:2,&#34;time&#34;:1705681499120,&#34;ns&#34;:&#34;sqd:commands&#34;,&#34;msg&#34;:&#34;PROCESS:ETH&#34;}&#xA;[moonbeam-processor] {&#34;level&#34;:2,&#34;time&#34;:1705681499148,&#34;ns&#34;:&#34;sqd:commands&#34;,&#34;msg&#34;:&#34;PROCESS:MOONBEAM&#34;}&#xA;[base-processor] {&#34;level&#34;:2,&#34;time&#34;:1705681499155,&#34;ns&#34;:&#34;sqd:commands&#34;,&#34;msg&#34;:&#34;PROCESS:BASE&#34;}&#xA;[bsc-processor] {&#34;level&#34;:2,&#34;time&#34;:1705681499163,&#34;ns&#34;:&#34;sqd:commands&#34;,&#34;msg&#34;:&#34;PROCESS:BSC&#34;}&#xA;[eth-processor] 01:24:59 INFO  sqd:processor processing blocks from 955722&#xA;[base-processor] 01:24:59 INFO  sqd:processor processing blocks from 1208926&#xA;[moonbeam-processor] 01:24:59 INFO  sqd:processor processing blocks from 166845&#xA;[bsc-processor] 01:24:59 INFO  sqd:processor processing blocks from 16996735&#xA;[eth-processor] 01:24:59 INFO  sqd:processor using archive data source&#xA;[eth-processor] 01:24:59 INFO  sqd:processor prometheus metrics are served at port 34253&#xA;[base-processor] 01:24:59 INFO  sqd:processor using archive data source&#xA;[base-processor] 01:24:59 INFO  sqd:processor prometheus metrics are served at port 40205&#xA;[moonbeam-processor] 01:24:59 INFO  sqd:processor using archive data source&#xA;[moonbeam-processor] 01:24:59 INFO  sqd:processor prometheus metrics are served at port 33691&#xA;[bsc-processor] 01:24:59 INFO  sqd:processor using archive data source&#xA;[bsc-processor] 01:24:59 INFO  sqd:processor prometheus metrics are served at port 41199&#xA;[moonbeam-processor] 01:25:00 INFO  sqd:processor:mapping Got 0 burn txs and 0 USDT transfers&#xA;[moonbeam-processor] 01:25:00 INFO  sqd:processor 171971 / 5325985, rate: 3823 blocks/sec, mapping: 2729 blocks/sec, 1364 items/sec, eta: 23m&#xA;[base-processor] 01:25:00 INFO  sqd:processor:mapping Got 0 burn txs and 0 USDT transfers&#xA;[base-processor] 01:25:00 INFO  sqd:processor 1477379 / 9442733, rate: 175758 blocks/sec, mapping: 8032 blocks/sec, 1339 items/sec, eta: 45s&#xA;[base-processor] 01:25:02 INFO  sqd:processor:mapping Got 1 burn txs and 0 USDT transfers&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The squid should download enough data in 3-4 hours.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!TIP] Do not worry if the squid fails: any progress it made is saved. Simply restart it if it happens.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;When done, stop the squid processor with Ctrl-C, then stop and remove the query gateway container with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sqd down&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;10&#34;&gt; &#xA; &lt;li&gt;After the locking period ends, go to the &lt;a href=&#34;https://app.subsquid.io/profile/gateways/&#34;&gt;gateways page&lt;/a&gt; and unlock your tSQD - you will need them for other quests.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Quest Info&lt;/h1&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Category&lt;/th&gt; &#xA;   &lt;th&gt;Skill Level&lt;/th&gt; &#xA;   &lt;th&gt;Time required (minutes)&lt;/th&gt; &#xA;   &lt;th&gt;Max Participants&lt;/th&gt; &#xA;   &lt;th&gt;Reward&lt;/th&gt; &#xA;   &lt;th&gt;Status&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Squid Deployment&lt;/td&gt; &#xA;   &lt;td&gt;$\textcolor{green}{\textsf{Simple}}$&lt;/td&gt; &#xA;   &lt;td&gt;~250&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;$\textcolor{red}{\textsf{75tSQD}}$&lt;/td&gt; &#xA;   &lt;td&gt;open&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Acceptance critera&lt;/h1&gt; &#xA;&lt;p&gt;Sync this squid using the key from the quest card. The syncing progress is tracked by the amount of data the squid has retrieved from &lt;a href=&#34;https://docs.subsquid.io/subsquid-network&#34;&gt;Subsquid Network&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;About this squid&lt;/h1&gt; &#xA;&lt;p&gt;This &lt;a href=&#34;https://docs.subsquid.io/&#34;&gt;squid&lt;/a&gt; retrieves native token burns on ETH, BSC, Base and Moonbeam. It does not keep any data, as it&#39;s sole purpose is to stress test the network.&lt;/p&gt; &#xA;&lt;p&gt;Data ingester (&#34;processor&#34;) code is defined for all networks in &lt;code&gt;src/testConfig.ts&lt;/code&gt;. The executable &lt;code&gt;src/main.ts&lt;/code&gt; chooses the settings to use based on its sole command line argument. The scripts file &lt;code&gt;commands.json&lt;/code&gt; contains commands for running each processor (&lt;code&gt;process:eth&lt;/code&gt;, &lt;code&gt;process:bsc&lt;/code&gt;, &lt;code&gt;process:base&lt;/code&gt; and &lt;code&gt;process:moonbeam&lt;/code&gt;). You can also use &lt;code&gt;sqd run&lt;/code&gt; to run all the services at once; the list of services is kept in the &lt;a href=&#34;https://docs.subsquid.io/cloud/reference/manifest/&#34;&gt;squid manifest&lt;/a&gt; at &lt;code&gt;squid.yaml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The squid uses Phase Two &lt;a href=&#34;https://docs.subsquid.io/subsquid-network&#34;&gt;Subsquid Network&lt;/a&gt; as its primary data source.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>kolodny/safetest</title>
    <updated>2024-02-17T01:36:27Z</updated>
    <id>tag:github.com,2024-02-17:/kolodny/safetest</id>
    <link href="https://github.com/kolodny/safetest" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Safetest: Next Generation UI Testing Library&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://npmjs.org/package/safetest&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/v/safetest.svg?style=flat-square&#34; alt=&#34;NPM version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/kolodny/safetest/actions&#34;&gt;&lt;img src=&#34;https://github.com/kolodny/safetest/actions/workflows/safetest.yml/badge.svg?sanitize=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://npmjs.org/package/safetest&#34;&gt;&lt;img src=&#34;http://img.shields.io/npm/dm/safetest.svg?style=flat-square&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Safetest is a powerful UI testing library that combines Playwright, Jest/Vitest, and React for a powerful end-to-end testing solution for applications and component testing. With Safetest, you can easily test the functionality and appearance of your application, ensuring that it works as expected and looks great on all devices.&lt;/p&gt; &#xA;&lt;p&gt;Safetest provides a seamless testing experience by integrating with your existing development environment and offering a familiar, easy-to-use API for creating and managing tests.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Playwright Integration&lt;/strong&gt;: Run your tests on real browsers using Playwright. Safetest automatically handles browser management, so you can focus on just writing tests. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Screenshot diffing via &lt;a href=&#34;https://github.com/americanexpress/jest-image-snapshot&#34;&gt;jest-image-snapshot&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://playwright.dev/docs/videos&#34;&gt;Video recording&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://playwright.dev/docs/trace-viewer&#34;&gt;Trace Viewer&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://playwright.dev/docs/network#handle-requests&#34;&gt;Full control over network layer&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kolodny/safetest/main/#overrides&#34;&gt;Powerful overrides for complex test cases&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Jest Integration&lt;/strong&gt;: Safetest leverages the Jest test runner. Write your tests using familiar Jest syntax and benefit from its powerful assertion library and mocking capabilities.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Vitest Integration&lt;/strong&gt;: Safetest can also use the Vitest runner. If you have a &lt;code&gt;vite&lt;/code&gt; project you&#39;ll probably want to use this&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;React Support&lt;/strong&gt;: Safetest is designed with React applications in mind, so you can easily test your components and their interactions. This allows for focused testing of individual components, for Example testing that &lt;code&gt;&amp;lt;Header admin={true}&amp;gt;&lt;/code&gt; behaves as expected.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Framework agnostic&lt;/strong&gt;: Safetest also works with other frameworks like Vue, Svelte, and Angular. See the &lt;a href=&#34;https://raw.githubusercontent.com/kolodny/safetest/main/examples/&#34;&gt;examples&lt;/a&gt; folder for more details. Safetest even works to &lt;a href=&#34;https://github.com/kolodny/safetest/raw/main/examples/next-app/src/spec.safetest.tsx&#34;&gt;component test a NextJS&lt;/a&gt; application&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Easy Setup&lt;/strong&gt;: Safetest is easy to set up and configure, so you can start writing tests in no time. No need to worry about complex configurations or dependencies; Safetest takes care of it all.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Easy Auth Hooks&lt;/strong&gt;: If your app is testing an authenticated application, Safetest provides hooks to handles the auth flow in a reusable method across all your tests.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Why Safetest?&lt;/h2&gt; &#xA;&lt;p&gt;Fundamentally UI tests come in two flavors: &lt;strong&gt;Integration&lt;/strong&gt; test and &lt;strong&gt;E2E&lt;/strong&gt; test.&lt;/p&gt; &#xA;&lt;p&gt;Integration tests are usually ran via react-testing-library or similar. They are fast, easy to write, and test the components within an application. However they are limited in that they don&#39;t actually run the application or render actual items to a screen so regressions like having a bad z-index that causes the submit button to be un-clickable won&#39;t be caught by these tests. Another common issue is that while it&#39;s easy to write the setup for the test, it&#39;s hard to write the events needed to cause things on the page to happen. For example, displaying a fancy &lt;code&gt;&amp;lt;Dropdown /&amp;gt;&lt;/code&gt; isn&#39;t as simple as just calling &lt;code&gt;fireEvent.click(&#39;select&#39;)&lt;/code&gt; since the js-dom doesn&#39;t perfectly match the real browser, so you end up needing to mouseover the label and then click the &lt;code&gt;select&lt;/code&gt;. Along the same lines figuring out how to enter text on a smart &lt;code&gt;&amp;lt;Input /&amp;gt;&lt;/code&gt; has a similar battle. Figuring out the exact incantation to make this happen is hard and brittle. Debugging why something stopped working is also hard since you can&#39;t just open the browser and see what&#39;s going on.&lt;/p&gt; &#xA;&lt;p&gt;E2E tests like Cypress and Playwright are great for testing the actual application. They use a real browser and run against the actual application. They&#39;re able to test things like z-index issues, etc. However they lack the ability to test components in isolation, which is why some teams will end up having a Storybook adjacent build to point the E2E test at. Another issue is that it&#39;s hard to setup the different test fixtures. For example, if you want to test that an admin user has an edit button on the page while a regular user doesn&#39;t, you&#39;ll find some ways to override the auth service to return different results. Similarly, component testing isn&#39;t possible when we have external service dependencies like OAuth since Cypress and Playwright component testing do not run against an actual instance of the app, so any auth gating can make rendering components impossible.&lt;/p&gt; &#xA;&lt;p&gt;Essentially we end up with this breakdown:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Integration Tests Pros&lt;/th&gt; &#xA;   &lt;th&gt;Integration Test Cons&lt;/th&gt; &#xA;   &lt;th&gt;E2E Test Pros&lt;/th&gt; &#xA;   &lt;th&gt;E2E Test Cons&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Easy setup&lt;/td&gt; &#xA;   &lt;td&gt;Hard to drive&lt;/td&gt; &#xA;   &lt;td&gt;Easy to drive&lt;/td&gt; &#xA;   &lt;td&gt;Hard to setup&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Fast&lt;/td&gt; &#xA;   &lt;td&gt;Hard to debug&lt;/td&gt; &#xA;   &lt;td&gt;Easy to debug&lt;/td&gt; &#xA;   &lt;td&gt;Slow&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Mock services&lt;/td&gt; &#xA;   &lt;td&gt;Hard to override network&lt;/td&gt; &#xA;   &lt;td&gt;Easy to override network&lt;/td&gt; &#xA;   &lt;td&gt;No service mocking&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Can&#39;t test clickability of element&lt;/td&gt; &#xA;   &lt;td&gt;Can test clickability of element&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Can&#39;t test z-index&lt;/td&gt; &#xA;   &lt;td&gt;Can test z-index&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Can&#39;t easily set value on &lt;code&gt;&amp;lt;Input /&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Easy to set value on &lt;code&gt;&amp;lt;Input /&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;No screenshot testing&lt;/td&gt; &#xA;   &lt;td&gt;Screenshot testing&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;No video recording&lt;/td&gt; &#xA;   &lt;td&gt;Video recording&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;No trace viewer&lt;/td&gt; &#xA;   &lt;td&gt;Trace viewer&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;No confidence app works E2E&lt;/td&gt; &#xA;   &lt;td&gt;Confidence components work&lt;/td&gt; &#xA;   &lt;td&gt;Confidence app works E2E&lt;/td&gt; &#xA;   &lt;td&gt;No confidence components work&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;It&#39;s almost like the two are complementary, if only there was a way to combine the two...&lt;/p&gt; &#xA;&lt;p&gt;This is essentially what Safetest is trying to solve. It&#39;s a way to combine the best of both worlds. It allows us to write tests that are easy to setup, easy to drive, and can test the components in isolation, while also being able to test the application as a whole, test clickability of elements, and do screenshot testing, video recording, trace viewer, etc..&lt;/p&gt; &#xA;&lt;p&gt;Consider this example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;// Header.tsx&#xA;export const Header = ({ admin }: { admin: boolean }) =&amp;gt; (&#xA;  &amp;lt;div className=&#34;header&#34;&amp;gt;&#xA;    &amp;lt;div className=&#34;header-title&#34;&amp;gt;The App&amp;lt;/div&amp;gt;&#xA;    &amp;lt;div className=&#34;header-user&#34;&amp;gt;&#xA;      &amp;lt;div className=&#34;header-user-name&#34;&amp;gt;admin&amp;lt;/div&amp;gt;&#xA;      {admin &amp;amp;&amp;amp; &amp;lt;div className=&#34;header-user-admin&#34;&amp;gt;admin&amp;lt;/div&amp;gt;}&#xA;      &amp;lt;div className=&#34;header-user-logout&#34;&amp;gt;Logout&amp;lt;/div&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;  &amp;lt;/div&amp;gt;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;// Header.safetest.tsx&#xA;import { describe, it, expect } from &#39;safetest/jest&#39;;&#xA;import { render } from &#39;safetest/react&#39;;&#xA;import { Header } from &#39;./Header&#39;;&#xA;&#xA;describe(&#39;Header&#39;, () =&amp;gt; {&#xA;  it(&#39;can render a regular header&#39;, async () =&amp;gt; {&#xA;    const { page } = await render(&amp;lt;Header /&amp;gt;);&#xA;    await expect(page.locator(&#39;text=Logout&#39;)).toBeVisible();&#xA;    await expect(page.locator(&#39;text=admin&#39;)).not.toBeVisible();&#xA;    expect(await page.screenshot()).toMatchImageSnapshot();&#xA;  });&#xA;&#xA;  it(&#39;can render an admin header&#39;, async () =&amp;gt; {&#xA;    const { page } = await render(&amp;lt;Header admin={true} /&amp;gt;);&#xA;    await expect(page.locator(&#39;text=Logout&#39;)).toBeVisible();&#xA;    await expect(page.locator(&#39;text=admin&#39;)).toBeVisible();&#xA;    expect(await page.screenshot()).toMatchImageSnapshot();&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;To get started with Safetest, follow these steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;h3&gt;Install Safetest as a dependency in your project:&lt;/h3&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install --save-dev safetest&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Or, if you&#39;re using Yarn:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yarn add --dev safetest&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following instructions assume you&#39;re using &lt;code&gt;create-react-app&lt;/code&gt;. Look in the examples folder for other setup configurations.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h3&gt;Add run command to &lt;code&gt;package.json&lt;/code&gt; scripts:&lt;/h3&gt; &lt;p&gt;Add the following line to your &lt;code&gt;package.json&lt;/code&gt; scripts:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;scripts&#34;: {&#xA;    &#34;safetest&#34;: &#34;OPT_URL=${TARGET_URL:-http://localhost:3000} react-scripts --inspect test --runInBand --testMatch &#39;**/*.safetest.{j,t}s{,x}&#39; --setupFilesAfterEnv ./setup-safetest.tsx&#34;,&#xA;    &#34;safetest:ci&#34;: &#34;rm -f artifacts.json &amp;amp;&amp;amp; OPT_URL=${DEPLOYED_URL} OPT_CI=1 OPT_DOCKER=1 npm run safetest -- --watchAll=false --ci=1 --json --outputFile=results.json&#34;,&#xA;    &#34;safetest:regenerate-screenshots&#34;: &#34;OPT_DOCKER=1 npm run safetest -- --watchAll=false --update-snapshot&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The preceding script runs the default runner (&lt;code&gt;react-scripts&lt;/code&gt;) with a couple of flags and environment variables to make sure Safetest is loaded and run with jest and that all &lt;code&gt;.safetest.tsx&lt;/code&gt; test files are tested. You may need to adjust based on your specific setup, e.g., using &lt;code&gt;craco&lt;/code&gt; or &lt;code&gt;react-app-rewired&lt;/code&gt; instead.&lt;/p&gt; &#xA;  &lt;hr&gt; &lt;p&gt;If you&#39;re using Vitest you&#39;d use these scripts instead:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;scripts&#34;: {&#xA;    &#34;safetest&#34;: &#34;OPT_URL=${OPT_URL:-http://localhost:3000/} vitest --config vite.safetest.config&#34;,&#xA;    &#34;safetest:ci&#34;: &#34;rm -f artifacts.json &amp;amp;&amp;amp; OPT_URL=${DEPLOYED_URL} OPT_CI=1 OPT_DOCKER=1 OPT_ARTIFACTS=artifacts.json npm run safetest -- --run --bail=5&#34;,&#xA;    &#34;safetest:regenerate-screenshots&#34;: &#34;OPT_DOCKER=1 npm run safetest -- --run --update&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;hr&gt; &lt;p&gt;&lt;small&gt;A note about the &lt;code&gt;OPT_URL&lt;/code&gt; and similar variables. This is used to pass flags to Safetest which will flow through different testing frameworks spawning threads or any other mechanism that would make command line flag passing practically impossible&amp;lt;/s,all&amp;gt;&lt;/small&gt;&lt;/p&gt;&lt;small&gt; &lt;/small&gt;&lt;/li&gt;&#xA; &lt;small&gt; &lt;li&gt; &lt;h3&gt;Add &lt;code&gt;setup-safetest.tsx&lt;/code&gt; file:&lt;/h3&gt; &lt;p&gt;Create a file called &lt;code&gt;setup-safetest.tsx&lt;/code&gt; in the root of your project and add the following code:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { setup } from &#39;safetest/setup&#39;;&#xA;&#xA;setup({&#xA;  bootstrappedAt: require.resolve(&#39;./src/main.tsx&#39;),&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This file is the minimal setup required to get Safetest working with your project. It&#39;s also where you can configure Safetest by specifying options to the &lt;code&gt;setup&lt;/code&gt; function.&lt;/p&gt; &lt;p&gt;If you&#39;re using vitest you&#39;ll need to add a vitest.safetest.config.ts file with the following config:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// &amp;lt;reference types=&#34;vitest&#34; /&amp;gt;&#xA;&#xA;import { defineConfig } from &#39;vite&#39;;&#xA;&#xA;// https://vitejs.dev/config/&#xA;export default defineConfig({&#xA;  test: {&#xA;    globals: true,&#xA;    testTimeout: 30000,&#xA;    reporters: [&#39;basic&#39;, &#39;json&#39;],&#xA;    outputFile: &#39;results.json&#39;,&#xA;    setupFiles: [&#39;setup-safetest&#39;],&#xA;    include: [&#39;**/*.safetest.?(c|m)[jt]s?(x)&#39;],&#xA;    threads: process.env.CI ? true : false,&#xA;    inspect: process.env.CI ? false : true,&#xA;  },&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;li&gt; &lt;h3&gt;Bootstrapping your application&lt;/h3&gt; &lt;p&gt;In order for Safetest to be able to work with your application, you need to bootstrap it to load. This is done by modifying your application&#39;s entry point (usually &lt;code&gt;src/index.tsx&lt;/code&gt;) as follows:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import ReactDOM from &#34;react-dom&#34;;&#xA;+import { bootstrap } from &#39;safetest/react&#39;;&#xA; import App from &#34;./App&#34;;&#xA;&#xA;-ReactDOM.render(&#xA;-  &amp;lt;App /&amp;gt;,&#xA;-  document.getElementById(&#34;app&#34;)&#xA;-);&#xA;+const container = document.getElementById(&#34;app&#34;);&#xA;+const element = &amp;lt;App /&amp;gt;;&#xA;+&#xA;+const isDev = process.env.NODE_ENV !== &#39;production&#39;;&#xA;+&#xA;+bootstrap({&#xA;+  element,&#xA;+  render: (element) =&amp;gt; ReactDOM.render(element, container),&#xA;+  // If using React 18:&#xA;+  // render: (element) =&amp;gt; ReactDOM.createRoot(container).render(element),&#xA;+&#xA;+  // Add one of the following depending on your bundler...&#xA;+&#xA;+  // Webpack:&#xA;+  webpackContext: isDev &amp;amp;&amp;amp; import.meta.webpackContext(&#39;.&#39;, {&#xA;+    recursive: true,&#xA;+    regExp: /\.safetest$/,&#xA;+    mode: &#39;lazy&#39;&#xA;+  })&#xA;+&#xA;+  // Vite:&#xA;+  // importGlob: isDev &amp;amp;&amp;amp; import.meta.glob(&#39;./**/*.safetest.{j,t}s{,x}&#39;),&#xA;+&#xA;+  // Using the `npx safetest generate-import-map src/Bootstrap.tsx src &amp;gt; src/imports.tsx` syntax:&#xA;+  // imports, // Where imports is defined as `import imports from &#39;./imports&#39;;`&#xA;+&#xA;+  // Other:&#xA;+  // import: isDev &amp;amp;&amp;amp; async (s) =&amp;gt; import(`${s.replace(/.*src/, &#39;.&#39;).replace(/\.safetest$/, &#39;&#39;)}.safetest`),&#xA;+&#xA;+});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The above magic import makes use of &lt;a href=&#34;https://webpack.js.org/api/module-variables/#importmetawebpackcontext&#34;&gt;Webpack Context&lt;/a&gt; Or &lt;a href=&#34;https://vitejs.dev/guide/features.html#glob-import&#34;&gt;Vite Glob import&lt;/a&gt; (or &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import&#34;&gt;whatever flavor dynamic import is available&lt;/a&gt;) to bundle the &lt;code&gt;.safetest.tsx&lt;/code&gt; files in your project separately. This allows you to write tests for your application in the same project as your application, without having to worry about setting up a separate test project or about the tests being loaded when loading your application in a non-test context. The &lt;code&gt;isDev&lt;/code&gt; check is only really needed if you don&#39;t want to leak your tests into production, but it&#39;s not strictly necessary. In this project it&#39;s turned off for the examples since I want to test against the final deployed app to keep things simple.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h3&gt;Creating your first tests&lt;/h3&gt; &lt;p&gt;Now that you&#39;ve set up Safetest, you can start writing your first tests. Create a file called &lt;code&gt;src/App.safetest.tsx&lt;/code&gt; and add the following code:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { describe, it, expect } from &#39;safetest/jest&#39;;&#xA;import { render } from &#39;safetest/react&#39;;&#xA;&#xA;import { Header } from &#39;./Header&#39;;&#xA;&#xA;// Whole App testing&#xA;describe(&#39;App&#39;, () =&amp;gt; {&#xA;  it(&#39;renders without crashing&#39;, async () =&amp;gt; {&#xA;    const { page } = await render();&#xA;    await expect(page.locator(&#39;text=Welcome to The App&#39;)).toBeVisible();&#xA;  });&#xA;});&#xA;&#xA;// Component testing&#xA;describe(&#39;Header&#39;, () =&amp;gt; {&#xA;  it(&#39;renders without crashing&#39;, async () =&amp;gt; {&#xA;    const { page } = await render(&amp;lt;Header /&amp;gt;);&#xA;    await expect(page.locator(&#39;text=Logout&#39;)).toBeVisible();&#xA;    expect(await page.screenshot()).toMatchImageSnapshot();&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;li&gt; &lt;h3&gt;Running your tests&lt;/h3&gt; &lt;h1&gt;&lt;b&gt;Important: Your app needs to already be running to run the tests. Safetest will not start your app for you!&lt;/b&gt;&lt;/h1&gt; &lt;p&gt;Now that you&#39;ve created your first tests, you can run it using the following command:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm run safetest&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Additionally, you can pass it a a number of custom options via environment variables prefixed with &lt;code&gt;OPT_&lt;/code&gt;. (This is needed since the test runner may run in subprocesses and command line args aren&#39;t always passed through but environment variables always are.) Some examples: &lt;code&gt;OPT_HEADED&lt;/code&gt;, &lt;code&gt;OPT_URL&lt;/code&gt;, &lt;code&gt;OPT_ARTIFACTS&lt;/code&gt;, &lt;code&gt;OPT_DOCKER&lt;/code&gt;, &lt;code&gt;OPT_CI&lt;/code&gt;, etc. For example to see the browser window while the tests are running:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;OPT_HEADED=1 npm run safetest&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;li&gt; &lt;h3&gt;Integrating into CI&lt;/h3&gt; &lt;p&gt;Assuming part of your CI pipeline deploys the app to some url &lt;code&gt;https://my-app.com&lt;/code&gt;, you can add a step to the CI pipeline by either adding a script to manually invoke the following:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;OPT_CI=1 OPT_DOCKER=1 OPT_URL=https://my-app.com npm run safetest -- --watchAll=false --ci=1 --json --outputFile=results.json&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;/small&gt;&#xA;&lt;/ol&gt;&#xA;&lt;small&gt; &lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/kolodny/safetest/main/#reporting&#34;&gt;Reporting&lt;/a&gt; section about how to get an HTML report of the results with links to:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Trace viewer of each test&lt;/li&gt; &#xA;  &lt;li&gt;Video of test execution&lt;/li&gt; &#xA;  &lt;li&gt;Ability to open tested component in the deployed environment&lt;/li&gt; &#xA; &lt;/ul&gt; &lt;p&gt;&lt;a href=&#34;https://safetest-two.vercel.app/&#34;&gt;See here&lt;/a&gt; for a the reports (and apps) of each the &lt;a href=&#34;https://github.com/kolodny/safetest/tree/main/examples&#34;&gt;example projects&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Writing Tests&lt;/h2&gt; &lt;p&gt;Since Safetest is bootstrapped within the application, essentially every test is a component test. If you don&#39;t specify a component in &lt;code&gt;render&lt;/code&gt;, then it will just render the default component (for example &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; in the getting started section). &lt;code&gt;render&lt;/code&gt; also allows passing a function which will be called with the default component as an argument. This is useful for overriding props or wrapping the component in a provider.&lt;/p&gt; &lt;p&gt;If you just want to test your application as a whole, you can use this syntax&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const { page } = await render();&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;and just pretend everything after that line is a &lt;a href=&#34;https://playwright.dev/docs/writing-tests&#34;&gt;&lt;code&gt;@playwright/test&lt;/code&gt; test&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;The following section showcases a couple of common testing scenarios:&lt;/p&gt; &lt;h3&gt;Testing a component&lt;/h3&gt; &lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { describe, it, expect } from &#39;safetest/jest&#39;;&#xA;import { render } from &#39;safetest/react&#39;;&#xA;import { Header } from &#39;./Header&#39;;&#xA;&#xA;describe(&#39;Header&#39;, () =&amp;gt; {&#xA;  it(&#39;can render a regular header&#39;, async () =&amp;gt; {&#xA;    const { page } = await render(&amp;lt;Header /&amp;gt;);&#xA;    await expect(page.locator(&#39;text=Logout&#39;)).toBeVisible();&#xA;    await expect(page.locator(&#39;text=admin&#39;)).not.toBeVisible();&#xA;    expect(await page.screenshot()).toMatchImageSnapshot();&#xA;  });&#xA;&#xA;  it(&#39;can render an admin header&#39;, async () =&amp;gt; {&#xA;    const { page } = await render(&amp;lt;Header admin={true} /&amp;gt;);&#xA;    await expect(page.locator(&#39;text=Logout&#39;)).toBeVisible();&#xA;    await expect(page.locator(&#39;text=admin&#39;)).toBeVisible();&#xA;    expect(await page.screenshot()).toMatchImageSnapshot();&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;h4&gt;Snapshot testing&lt;/h4&gt; &lt;p&gt;Safetest comes out of the box with snapshot testing enabled via &lt;a href=&#34;https://github.com/americanexpress/jest-image-snapshot&#34;&gt;&lt;code&gt;jest-image-snapshot&lt;/code&gt;&lt;/a&gt;. A simple example of this is shown above. You can also mask over or remove DOM elements before the snapshot to have deterministic tests. A common scenario for this is to remove a date field from the UI before taking a snapshot, since the value will be different every time and will cause the screenshots not to match.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { describe, it, expect } from &#39;safetest/jest&#39;;&#xA;import { render } from &#39;safetest/react&#39;;&#xA;&#xA;describe(&#39;Snapshot&#39;, () =&amp;gt; {&#xA;  it(&#39;works with date fields&#39;, async () =&amp;gt; {&#xA;    const { page } = await render();&#xA;    await page.evaluate(() =&amp;gt; document.querySelector(&#39;.header-date&#39;)?.remove());&#xA;    expect(await page.screenshot()).toMatchImageSnapshot();&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;There is also a &lt;code&gt;mask&lt;/code&gt; option you can pass to &lt;code&gt;page.screenshot({ mask: ... })&lt;/code&gt;; however that only covers over the element. If the element&#39;s width changes across tests, the snapshot diffs will still fail.&lt;/p&gt; &lt;h4&gt;Deterministic snapshots&lt;/h4&gt; &lt;p&gt;Due to hardware and platform differences between dev machines and CI environments, there will be slight rendering differences between snapshots generated locally and in CI. To solve this problem and to ensure that a consistent and reproducible test setup is used, Safetest can run your tests in a docker container. This should be used in CI by default (via the &lt;code&gt;safetest:ci&lt;/code&gt; script). To run your tests in docker locally or to generate updated snapshots which will match CI, you can run:&lt;br&gt; &lt;code&gt;OPT_DOCKER=1 npm run safetest&lt;/code&gt; and &lt;code&gt;yarn safetest:regenerate-screenshots&lt;/code&gt; respectively.&lt;/p&gt; &lt;p&gt;Note that you can also run this on &#34;headed&#34; mode, which will open a browser window connected to the debugPort within the docker container as show below:&lt;/p&gt; &lt;h4&gt;Mocks and spies&lt;/h4&gt; &lt;p&gt;Safetest also has the ability to provide mocks and spies to component props which you can assert against in your tests. This is useful for testing that components behave as you&#39;d expect.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { describe, it, expect, browserMock } from &#39;safetest/jest&#39;;&#xA;import { render } from &#39;safetest/react&#39;;&#xA;import { Header } from &#39;./Header&#39;;&#xA;&#xA;describe(&#39;Header&#39;, () =&amp;gt; {&#xA;  /* ... */&#xA;&#xA;  it(&#39;calls the passed logout handler when clicked&#39;, async () =&amp;gt; {&#xA;    const spy = browserMock.fn();&#xA;    const { page } = await render(&amp;lt;Header handleLogout={spy} /&amp;gt;);&#xA;    await page.locator(&#39;text=Logout&#39;).click();&#xA;    expect(await spy).toHaveBeenCalled();&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;h4&gt;Communicating between node and the browser.&lt;/h4&gt; &lt;p&gt;In order to make Safetest work, the test code is run in both node and the browser (see the &lt;a href=&#34;https://raw.githubusercontent.com/kolodny/safetest/main/#how-safetest-works&#34;&gt;How Safetest works&lt;/a&gt; section for more details about this). What this means is that we have full control over both what happens in node as well as the browser as the test is running. This allows us to do some powerful communication between the two environments. One of these items is the ability to make assertions in node from the browser as seen above (the &lt;code&gt;await spy&lt;/code&gt; was not a typo, it&#39;s also type safe so don&#39;t worry about forgetting it). &lt;code&gt;render&lt;/code&gt; also returns a bridge function which we can use to coordinate some complex use cases. For example, here&#39;s how we&#39;d test that a loader component can recover from an error:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;// MoreLoader.tsx&#xA;interface LoaderProps&amp;lt;T&amp;gt; {&#xA;  getData: (lastId?: string) =&amp;gt; Promise&amp;lt;T[]&amp;gt;;&#xA;  renderItem: (t: T, index: number) =&amp;gt; React.ReactNode;&#xA;}&#xA;&#xA;// Pretend this is a real component&#xA;export const MoreLoader = &amp;lt;T&amp;gt;(props: LoaderProps&amp;lt;T&amp;gt;) =&amp;gt; {&#xA;  /* ... */&#xA;};&#xA;&#xA;describe(&#39;MoreLoader&#39;, () =&amp;gt; {&#xA;  it(&#39;can recover from errors&#39;, async () =&amp;gt; {&#xA;    let nextIndex = 0;&#xA;    let error = false;&#xA;    const { page, bridge } = render(&#xA;      &amp;lt;MoreLoader&amp;lt;number&amp;gt;&#xA;        getData={async () =&amp;gt; {&#xA;          if (error) throw new Error(&#39;Error&#39;);&#xA;          return nextIndex++;&#xA;        }}&#xA;        renderItem={(d) =&amp;gt; &amp;lt;&amp;gt;Number is {d}&amp;lt;/&amp;gt;}&#xA;      /&amp;gt;&#xA;    );&#xA;    await expect(page.locator(&#39;text=Number is 0&#39;)).toBeVisible();&#xA;    await page.locator(&#39;.load-more&#39;).click();&#xA;    await expect(page.locator(&#39;text=Number is 1&#39;)).toBeVisible();&#xA;    await bridge(() =&amp;gt; nextIndex = 10)&#xA;    await page.locator(&#39;.load-more&#39;).click();&#xA;    await expect(page.locator(&#39;text=Number is 10&#39;)).toBeVisible();&#xA;    await bridge(() =&amp;gt; error = true);&#xA;    await page.locator(&#39;.load-more&#39;).click();&#xA;    await expect(page.locator(&#39;text=Error loading item&#39;)).toBeVisible();&#xA;    await bridge(() =&amp;gt; error = false);&#xA;    await page.locator(&#39;.load-more&#39;).click();&#xA;    await expect(page.locator(&#39;text=Number is 11&#39;)).toBeVisible();&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;h4&gt;Overrides&lt;/h4&gt; &lt;p&gt;Sometimes the &lt;code&gt;bridge&lt;/code&gt; function doesn&#39;t cover all your use cases. For example, if you want to test that a component can recover from an error, you&#39;ll need to be able to override some logic within the component to simulate an error. For this use case, Safetest provides the &lt;code&gt;createOverride&lt;/code&gt; function. This function allows you to override any value within the component. For example let&#39;s pretend we have this existing component:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;// Records.tsx&#xA;export const Records = () =&amp;gt; {&#xA;  const { records, loading, error } = useGetRecordsQuery();&#xA;  if (loading) return &amp;lt;Loader /&amp;gt;;&#xA;  if (error) return &amp;lt;Error error={error} /&amp;gt;;&#xA;  return &amp;lt;RecordList records={records} /&amp;gt;;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Here&#39;s how to create and use an override for the &lt;code&gt;useGetRecordsQuery&lt;/code&gt; hook to simulate an error:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; // Records.tsx&#xA;+ const UseGetRecordsQuery = createOverride(useGetRecordsQuery)&#xA;&#xA; export const Records = () =&amp;gt; {&#xA;+  const useGetRecordQuery = UseGetRecordsQuery.useValue()&#xA;   const { records, loading, error } = useGetRecordsQuery();&#xA;   if (loading) return &amp;lt;Loader /&amp;gt;;&#xA;   if (error) return &amp;lt;Error error={error} /&amp;gt;;&#xA;   return &amp;lt;RecordList records={records} /&amp;gt;;&#xA; };&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The test would look like this:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;describe(&#39;Records&#39;, () =&amp;gt; {&#xA;  it(&#39;Has a loading state&#39;, async () =&amp;gt; {&#xA;    const { page } = render(&#xA;      &amp;lt;UseGetRecordQuery.Override with={(old) =&amp;gt; ({ ...old(), loading: true })}&amp;gt;&#xA;        &amp;lt;Records /&amp;gt;&#xA;      &amp;lt;/UseGetRecordQuery.Override&amp;gt;&#xA;    );&#xA;    await expect(await page.locator(&#39;text=Loading&#39;)).toBeVisible();&#xA;  });&#xA;&#xA;  it(&#39;Has an error state&#39;, async () =&amp;gt; {&#xA;    const { page } = render(&#xA;      &amp;lt;UseGetRecordQuery.Override&#xA;        with={(old) =&amp;gt; ({ ...old(), error: new Error(&#39;Test Error&#39;) })}&#xA;      &amp;gt;&#xA;        &amp;lt;Records /&amp;gt;&#xA;      &amp;lt;/UseGetRecordQuery.Override&amp;gt;&#xA;    );&#xA;    await expect(await page.locator(&#39;text=Test Error&#39;)).toBeVisible();&#xA;  });&#xA;&#xA;  it(&#39;Has a loaded state&#39;, async () =&amp;gt; {&#xA;    const { page } = render(&#xA;      &amp;lt;UseGetRecordQuery.Override&#xA;        with={(old) =&amp;gt; ({&#xA;          ...old(),&#xA;          loading: false,&#xA;          value: [{ name: &#39;Tester&#39; }],&#xA;        })}&#xA;      &amp;gt;&#xA;        &amp;lt;Records /&amp;gt;&#xA;      &amp;lt;/UseGetRecordQuery.Override&amp;gt;&#xA;    );&#xA;    await expect(await page.locator(&#39;text=Tester&#39;)).toBeVisible();&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This isn&#39;t limited to overriding a hook or a service, we can override anything we want. For example we can override the &lt;code&gt;Date.now()&lt;/code&gt; to get consistent time stamps in our tests. A powerful use case for this is when we have a component that combines 3 graphql calls, we can test what happens if only one of those call fails, etc.&lt;/p&gt; &lt;h4&gt;Targeted Injecting in App&lt;/h4&gt; &lt;p&gt;Since Safetest is bootstrapped within the application, we can test anything into the application. This ensures that even seemingly complex use cases can be tested. Here are some examples of this:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt; &lt;p&gt;Our app makes a bunch of GPRC calls and we want to test that if one of them fails the page doesn&#39;t crash. This isn&#39;t feasible using attempts to override the network calls, unless we can understand binary.&lt;/p&gt; &#xA;   &lt;details&gt; &#xA;    &lt;summary&gt;Solution&lt;/summary&gt; &#xA;    &lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;// Page.tsx&#xA;const myServiceClient = new MyServiceClient(&#39;http://localhost:8080&#39;);&#xA;const useGrpc = (dataType: string) =&amp;gt; {&#xA;  const [data, setData] = React.useState(null);&#xA;  const [error, setError] = React.useState(null);&#xA;  const [loading, setLoading] = React.useState(false);&#xA;&#xA;  React.useMemo(() =&amp;gt; {&#xA;    setLoading(true);&#xA;    const request = new DataRequest();&#xA;    request.setType(dataType);&#xA;    myServiceClient.getData(request, {}, (err, response) =&amp;gt; {&#xA;      setLoading(false);&#xA;      if (err) {&#xA;        setData(null);&#xA;        setError(err);&#xA;      } else {&#xA;        setData(response.toObject());&#xA;        setError(null);&#xA;      }&#xA;    });&#xA;  }, [dataType]);&#xA;&#xA;  return { loading, error, data };&#xA;};&#xA;&#xA;export const Page = () =&amp;gt; {&#xA;  const settingsPanel = useGrpc(&#39;settings&#39;);&#xA;  const alertsPanel = useGrpc(&#39;alerts&#39;);&#xA;  const todosPanel = useGrpc(&#39;todos&#39;);&#xA;  return (&#xA;    &amp;lt;Grid&amp;gt;&#xA;      &amp;lt;Settings settings={settingsPanel} /&amp;gt;&#xA;      &amp;lt;Alerts alerts={alertsPanel} /&amp;gt;&#xA;      &amp;lt;Todos todos={todosPanel} /&amp;gt;&#xA;    &amp;lt;/Grid&amp;gt;&#xA;  );&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;    &lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; // Updated Page.tsx&#xA; // ... snip&#xA;+export const UseGrpc = createOverride(useGrpc);&#xA;&#xA; export const Page = () =&amp;gt; {&#xA;+  const useGrpc = UseGrpc.useValue();&#xA;   const settingsPanel = useGrpc(&#39;settings&#39;);&#xA;   const alertsPanel = useGrpc(&#39;alerts&#39;);&#xA;   const todosPanel = useGrpc(&#39;todos&#39;);&#xA;   return (&#xA;     &amp;lt;Grid&amp;gt;&#xA;       &amp;lt;Settings settings={settingsPanel} /&amp;gt;&#xA;       &amp;lt;Alerts alerts={alertsPanel} /&amp;gt;&#xA;       &amp;lt;Todos todos={todosPanel} /&amp;gt;&#xA;     &amp;lt;/Grid&amp;gt;&#xA;   );&#xA; };&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;    &lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;// Page.safetest.tsx&#xA;describe(&#39;Page&#39;, () =&amp;gt; {&#xA;  it(&#39;can handle an error on the Alerts pane&#39;, async () =&amp;gt; {&#xA;    const UseGrpcOverride = UseGrpc.Override;&#xA;    const { page } = render((app) =&amp;gt; (&#xA;      &amp;lt;UseGrpcOverride&#xA;        with={(old) =&amp;gt; {&#xA;          return (dataType) =&amp;gt; {&#xA;            const oldValue = old(dataType);&#xA;            if (dataType === &#39;alerts&#39;) {&#xA;              return {&#xA;                ...oldValue,&#xA;                error: new Error(&#39;Test Error&#39;),&#xA;              };&#xA;            }&#xA;            return oldValue;&#xA;          };&#xA;        }}&#xA;      &amp;gt;&#xA;        {app}&#xA;      &amp;lt;/UseGrpcOverride&amp;gt;&#xA;    ));&#xA;    await page.locator(&#39;.view-panels&#39;).click();&#xA;    await expect(page.locator(&#39;text=Error loading alerts&#39;)).toBeVisible();&#xA;    await expect(&#xA;      page.locator(&#39;text=Error loading settings&#39;)&#xA;    ).not.toBeVisible();&#xA;    await expect(page.locator(&#39;text=Error loading todos&#39;)).not.toBeVisible();&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;   &lt;/details&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Part of our build process is to regenerate the graphql schema and now we want to test one of those calls failing, overriding the network calls means that anytime the schema changes we&#39;ll need to update our tests.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;!-- TODO demonstration --&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;There was a regression with debouncing/throttling and not using cached results in an autocomplete and we want to make sure it doesn&#39;t break in the future.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;!-- TODO demonstration --&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;We want to test that an absolutely positioned element set to the users width preference doesn&#39;t cover over a clickable element.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;!-- TODO demonstration --&gt; &lt;p&gt;With the tools above we can test pretty much any scenario we can think of. The guiding principle of Safetest is to make any test possible, no matter how complex or involved the test is.&lt;/p&gt; &lt;h3&gt;Providers and Contexts&lt;/h3&gt; &lt;p&gt;An issue that &lt;code&gt;React Testing Library&lt;/code&gt; and component testing libraries need to contend with is rewrapping the component in required providers and contexts. This is due to &lt;code&gt;react-query&lt;/code&gt;, &lt;code&gt;react-redux&lt;/code&gt;, &lt;code&gt;react-router&lt;/code&gt;, etc., all requiring a provider to be present in the tree. However, since Safetest is bootstrapped with the application, we can just shuffle around some code to make this works for all use cases. All that&#39;s required is to move the Providers/Contexts to a separate file (for example &lt;code&gt;src/Providers.tsx&lt;/code&gt;) and use it when bootstrapping the application:&lt;/p&gt; &lt;h4&gt;&lt;code&gt;src/Provider.tsx&lt;/code&gt;&lt;/h4&gt; &lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import React from &#39;react&#39;;&#xA;import { QueryClient, QueryClientProvider } from &#39;react-query&#39;;&#xA;import { ApolloClient, ApolloProvider } from &#39;@apollo/client&#39;;&#xA;&#xA;// Create provider clients.&#xA;const apolloClient = new ApolloClient({});&#xA;const queryClient = new QueryClient({});&#xA;&#xA;export const Provider: React.FC = ({ children }) =&amp;gt; (&#xA;  &amp;lt;QueryClientProvider client={new QueryClient()}&amp;gt;&#xA;    &amp;lt;ApolloProvider client={apolloClient}&amp;gt;{children}&amp;lt;/ApolloProvider&amp;gt;&#xA;  &amp;lt;/QueryClientProvider&amp;gt;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;h4&gt;&lt;code&gt;src/index.tsx&lt;/code&gt;&lt;/h4&gt; &lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { bootstrap } from &#39;safetest/react&#39;;&#xA;import { Provider } from &#39;./Provider&#39;;&#xA;bootstrap({&#xA;  element,&#xA;  render: (elem) =&amp;gt; ReactDOM.render(&amp;lt;Provider&amp;gt;{elem}&amp;lt;/Provider&amp;gt;, container),&#xA;  importGlob: import.meta.glob(&#39;./**/*.safetest.{j,t}s{,x}&#39;),&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Now you never need to think again about providers and contexts, just use &lt;code&gt;render&lt;/code&gt; as you normally would.&lt;/p&gt; &lt;h2&gt;Authentication&lt;/h2&gt; &lt;p&gt;Most corporate applications require some form of authentication. Safetest provides a simple way to handle authentication in your tests. Ideally you already have a service to generate a cookie for you, but if you don&#39;t, you&#39;ll need to create one. Here&#39;s an example of a service that generates a cookie for you:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// auth.ts&#xA;import { Cookie, Page, chromium } from &#39;playwright&#39;;&#xA;&#xA;let cookies: Cookie[];&#xA;&#xA;const getCookies = async () =&amp;gt; {&#xA;  const browser = await chromium.launch();&#xA;  const context = await browser.newContext();&#xA;  const page = await context.newPage();&#xA;  await page.goto(&#39;https://my-app.com/login&#39;);&#xA;  await page.fill(&#39;input[name=&#34;username&#34;]&#39;, process.env.USERNAME);&#xA;  await page.fill(&#39;input[name=&#34;password&#34;]&#39;, process.env.PASSWORD);&#xA;  await page.click(&#39;button[type=&#34;submit&#34;]&#39;);&#xA;  await page.waitForNavigation();&#xA;  cookies = await context.cookies();&#xA;  await browser.close();&#xA;};&#xA;&#xA;const addCookies = async (page: Page) =&amp;gt; {&#xA;  await page.context().addCookies(cookies);&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;To use it, you need to add the following code to your &lt;code&gt;setup-safetest.tsx&lt;/code&gt; file:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// setup-safetest.tsx&#xA;import { setup } from &#39;safetest/setup&#39;;&#xA;&#xA;import { getCookies, addCookies } from &#39;./auth&#39;;&#xA;&#xA;beforeAll(getCookies);&#xA;&#xA;setup({&#xA;  bootstrappedAt: require.resolve(&#39;./src/main.tsx&#39;),&#xA;  ciOptions: { usingArtifactsDir: &#39;artifacts&#39; },&#xA;  hooks: { beforeNavigate: [addCookies] },&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Debugging and Troubleshooting&lt;/h2&gt; &lt;p&gt;Safetest takes advantage of playwright and jest to provide a lot of debugging and troubleshooting tools. Here are some of the most useful ones. The script copied in the package.json file will open a debug port that you can connect to with the node inspector. You can just add a &lt;code&gt;debugger&lt;/code&gt; statement in your test and the node-inspector will just catch it. Alternately to can add a &lt;code&gt;launch.json&lt;/code&gt; file with &lt;a href=&#34;https://raw.githubusercontent.com/kolodny/safetest/main/TODO&#34;&gt;&lt;strong&gt;these run properties&lt;/strong&gt;&lt;/a&gt; and have vscode auto-attach to the process.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;render&lt;/code&gt; also returns a &lt;code&gt;pause&lt;/code&gt; method that will pause the execution of the page and allow you to inspect the page in the browser and to continue to use the playwright &lt;code&gt;page&lt;/code&gt; object.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;it(&#39;can pause&#39;, async () =&amp;gt; {&#xA;  const { page, pause } = await render();&#xA;  debugger;&#xA;  await pause();&#xA;  await expect(page.locator(&#39;text=Welcome to The App&#39;)).toBeVisible();&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kolodny/safetest/main/assets/safetest-debugger.png&#34; alt=&#34;Debugger&#34;&gt;&lt;/p&gt; &lt;p&gt;We can even run code live against this test!&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kolodny/safetest/main/assets/safetest-paused.png&#34; alt=&#34;Paused&#34;&gt;&lt;/p&gt; &#xA; &lt;!-- See [this video for a demo](TODO). --&gt; &lt;h2&gt;Reporting&lt;/h2&gt; &lt;p&gt;Safetest published an HTML Test Reporter that can be used to view the results of your tests. To use it, you just need to process the results json to include information about the artifact, you can use the cli command that safetest provides:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npx safetest add-artifact-info artifacts.json results.json&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Now you can either publish the &lt;code&gt;node_modules/safetest/report.html&lt;/code&gt; standalone html file or import the &lt;code&gt;Report&lt;/code&gt; component from &lt;code&gt;safetest/report&lt;/code&gt; and use it in your application.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;import { Report } from &#39;safetest/report&#39;;&#xA;&#xA;export const MyReport: React.FunctionComponent = () =&amp;gt; {&#xA;  return (&#xA;    &amp;lt;Report&#xA;      getTestUrl={(filename, test) =&amp;gt; {&#xA;        const relativeFile = `./${filename}`.replace(/\.[jt]sx?$/g, &#39;&#39;);&#xA;        const testName = test.trim().replace(/ /g, &#39;+&#39;);&#xA;        return `${process.env.DEPLOYED_URL}?test_path=${relativeFile}&amp;amp;test_name=${testName}`;&#xA;      }}&#xA;      renderArtifact={(type, path) =&amp;gt; {&#xA;        if (type === &#39;video&#39;)&#xA;          return &amp;lt;video src={`${process.env.DEPLOYED_URL}${path}`} controls /&amp;gt;;&#xA;        // etc&#xA;      }}&#xA;    /&amp;gt;&#xA;  );&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Here&#39;s an &lt;a href=&#34;https://safetest-two.vercel.app/report.html#results=vite-react-ts/artifacts/results.json&amp;amp;url=vite-react-ts/&#34;&gt;example of the vite-react example app report&lt;/a&gt;&lt;/p&gt; &lt;p&gt;Note that part of the report is a link to the test in the deployed environment. This is done by passing the &lt;code&gt;getTestUrl&lt;/code&gt; prop to the &lt;code&gt;Report&lt;/code&gt; component. This is useful for debugging tests that fail in CI but not locally. The &lt;code&gt;renderArtifact&lt;/code&gt; prop is used to render the artifacts that are generated by the tests. This is useful for rendering videos, trace viewer, etc. As an example here&#39;s a link to a &lt;a href=&#34;https://safetest-two.vercel.app/vite-react-ts/?test_path=./Another.safetest&amp;amp;test_name=Main2+can+do+many+interactions+fast&#34;&gt;Vite/React test&lt;/a&gt; and the associated &lt;a href=&#34;https://safetest-two.vercel.app/vite-react-ts/artifacts/trace/?trace=https://safetest-two.vercel.app/vite-react-ts/artifacts/trace/traces/src__nother_safetest_tsx_Main2_can_do_many_interactions_fast-attempt-0.zip&#34;&gt;trace&lt;/a&gt; and &lt;a href=&#34;https://safetest-two.vercel.app/vite-react-ts/artifacts/videos/src__nother_safetest_tsx_Main2_can_do_many_interactions_fast-attempt-0.webm&#34;&gt;video&lt;/a&gt; artifacts&lt;/p&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/kolodny/safetest/assets/1187604/8d27648d-afdf-4428-9210-3fe37abc3375&#34;&gt;src__nother_safetest_tsx_Main2_can_do_many_interactions_fast-attempt-0.webm&lt;/a&gt;&lt;/p&gt; &lt;h2&gt;How Safetest works&lt;/h2&gt; &lt;p&gt;Safetest is a combination of a few different technologies glued together intelligently to leverage the best parts of each. The essential technologies used are&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;A test runner (this can be Jest or Vitest, feel free to open a PR for other test runners, it&#39;s pretty &lt;a href=&#34;https://raw.githubusercontent.com/kolodny/safetest/main/src/jest.ts&#34;&gt;easy&lt;/a&gt; to &lt;a href=&#34;https://raw.githubusercontent.com/kolodny/safetest/main/src/vitest.ts&#34;&gt;add&lt;/a&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;A browser automation library (&lt;code&gt;Playwright&lt;/code&gt; is the default and only one used currently, this will be a bit harder to extend)&lt;/li&gt; &#xA;  &lt;li&gt;A UI framework (&lt;code&gt;React&lt;/code&gt; is the main example used in this Readme, but there are adapters for &lt;a href=&#34;https://raw.githubusercontent.com/kolodny/safetest/main/src/vue.ts&#34;&gt;vue&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/kolodny/safetest/main/src/svelte.ts&#34;&gt;svelte&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/kolodny/safetest/main/src/angular.ts&#34;&gt;angular&lt;/a&gt;, feel free to open a PR for other frameworks)&lt;/li&gt; &#xA; &lt;/ul&gt; &lt;p&gt;Take a look at the &lt;a href=&#34;https://raw.githubusercontent.com/kolodny/safetest/main/examples/&#34;&gt;examples&lt;/a&gt; folder to see different combinations of these technologies. Please feel free to open a PR with more examples.&lt;/p&gt; &lt;p&gt;When the runner first starts it will build a mapping of the test structure. For example suppose we have a test file &lt;code&gt;src/App.safetest.tsx&lt;/code&gt; with the following contents:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;import { describe, it, expect } from &#39;safetest/jest&#39;;&#xA;import { render } from &#39;safetest/react&#39;;&#xA;&#xA;import { Header } from &#39;./components/header&#39;;&#xA;&#xA;describe(&#39;App&#39;, () =&amp;gt; {&#xA;  it(&#39;renders the app&#39;, async () =&amp;gt; {&#xA;    const { page } = await render();&#xA;    await expect(page.locator(&#39;text=Welcome to The App&#39;)).toBeVisible();&#xA;  });&#xA;&#xA;  it(&#39;can render a regular header&#39;, async () =&amp;gt; {&#xA;    const { page } = await render(&amp;lt;Header /&amp;gt;);&#xA;    await expect(page.locator(&#39;text=Logout&#39;)).toBeVisible();&#xA;    await expect(page.locator(&#39;text=admin&#39;)).not.toBeVisible();&#xA;    expect(await page.screenshot()).toMatchImageSnapshot();&#xA;  });&#xA;&#xA;  it(&#39;can render an admin header&#39;, async () =&amp;gt; {&#xA;    const { page } = await render(&amp;lt;Header admin={true} /&amp;gt;);&#xA;    await expect(page.locator(&#39;text=Logout&#39;)).toBeVisible();&#xA;    await expect(page.locator(&#39;text=admin&#39;)).toBeVisible();&#xA;    expect(await page.screenshot()).toMatchImageSnapshot();&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Safetest will build a tree of the tests and their structure:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;{&#xA;  &#34;App&#34;: {&#xA;    &#34;renders the app&#34;: async () =&amp;gt; { /* ... */ },&#xA;    &#34;can render a regular header&#34;: async () =&amp;gt; { /* ... */ },&#xA;    &#34;can render an admin header&#34;: async () =&amp;gt; { /* ... */ },&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The test runner continues running, i.e., the &lt;code&gt;&#34;renders the app&#34;&lt;/code&gt; test runs and hits the &lt;code&gt;render()&lt;/code&gt; function, resulting in Safetest opening a browser and navigating to the page. Safetest controls the browser instance, exposes a &#34;magic&#34; function, gets info about the currently executing test &lt;code&gt;&#34;App renders the app&#34;&lt;/code&gt;. There&#39;s also an exposed, magic function that will be called when the browser page is &#34;ready&#34;.&lt;/p&gt; &lt;p&gt;On the browser side of things, when the call to bootstrap is called, the following happens:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt; &lt;p&gt;Safetest will check if there&#39;s a a &#34;magic&#34; function available that will give us information about the current executing test.&lt;/p&gt; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;If there is no test info available Safetest will render the page as normal and the bootstrapping process is done.&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Safetest will now call the &lt;code&gt;import&lt;/code&gt; function that was passed to bootstrap with the name of the test file.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;This will allow Safetest to build that same mapping in the browser.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Safetest will now execute the &lt;code&gt;mapping[&#34;app renders the app&#34;]&lt;/code&gt; function.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Safetest will hit the &lt;code&gt;render&lt;/code&gt; function. Safetest will now render this component on the page.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Safetest will now call the magic exposed function to signal that the page is ready for testing.&lt;/p&gt; &lt;p&gt;Back in node...&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;The await &lt;code&gt;render(...)&lt;/code&gt; call now resolves and we can continue with the test.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;/ul&gt; &lt;/small&gt;</summary>
  </entry>
</feed>