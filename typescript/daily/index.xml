<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub TypeScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-23T01:41:10Z</updated>
  <subtitle>Daily Trending of TypeScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SoraWebui/SoraWebui</title>
    <updated>2024-02-23T01:41:10Z</updated>
    <id>tag:github.com,2024-02-23:/SoraWebui/SoraWebui</id>
    <link href="https://github.com/SoraWebui/SoraWebui" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SoraWebui is an open-source Sora web client, enabling users to easily create videos from text with OpenAI&#39;s Sora model.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SoraWebui&lt;/h1&gt; &#xA;&lt;p&gt;SoraWebui is an open-source project that simplifies video creation by allowing users to generate videos online with OpenAI&#39;s Sora model using text, featuring easy one-click website deployment. ðŸ‘‰ &lt;a href=&#34;https://sorawebui.com&#34;&gt;SoraWebui&lt;/a&gt;&lt;/p&gt; &#xA;&lt;div align=&#34;left&#34;&gt; &#xA; &lt;p&gt;English | &lt;a href=&#34;https://github.com/SoraWebui/SoraWebui/raw/main/README.zh-CN.md&#34;&gt;ç®€ä½“ä¸­æ–‡&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Quick Started&lt;/h2&gt; &#xA;&lt;h3&gt;Deploy on Vercel&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2FSoraWebui%2FSoraWebui&amp;amp;project-name=SoraWebui&amp;amp;repository-name=SoraWebui&amp;amp;external-id=https%3A%2F%2Fgithub.com%2FSoraWebui%2FSoraWebui%2Ftree%2Fmain&#34;&gt;&lt;img src=&#34;https://vercel.com/button&#34; alt=&#34;Deploy with Vercel&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;1. Clone project&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git@github.com:SoraWebui/SoraWebui.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;2. Install dependencies&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd SoraWebui &amp;amp;&amp;amp; yarn&#xA;#or&#xA;cd SoraWebui &amp;amp;&amp;amp; npm install&#xA;#or&#xA;cd SoraWebui &amp;amp;&amp;amp; pnpm install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3. copy .env.example and rename it to .env.local&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# website URL&#xA;NEXT_PUBLIC_SITE_URL=http://localhost&#xA;&#xA;# openai config&#xA;OPENAI_API_KEY=sk-XXXXXX&#xA;OPENAI_API_BASE_URL=http://localhost:8081&#xA;OPENAI_API_MODEL=sora-1.0-turbo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;4. Run it&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yarn dev&#xA;#or&#xA;npm run dev&#xA;#or&#xA;pnpm dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;5. Open &lt;a href=&#34;http://localhost&#34;&gt;http://localhost&lt;/a&gt; with your browser to see it.&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://sorawebui.com/success_deploy.jpg&#34; alt=&#34;success_deploy.jpg&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Important&lt;/h3&gt; &#xA;&lt;p&gt;SoraWebui requires &lt;a href=&#34;https://github.com/SoraWebui/FakeSoraAPI&#34;&gt;FakeSoraAPI&lt;/a&gt; to function properly.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Project-DARC/DARC</title>
    <updated>2024-02-23T01:41:10Z</updated>
    <id>tag:github.com,2024-02-23:/Project-DARC/DARC</id>
    <link href="https://github.com/Project-DARC/DARC" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Decentralized Autonomous Regulated Company (DARC), a company virtual machine that runs on any EVM-compatible blockchain, with on-chain law system, multi-level tokens and dividends mechanism.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Decentralized Autonomous Regulated Company (DARC)&lt;/h1&gt; &#xA;&lt;p&gt;Welcome to the official repository for the Decentralized Autonomous Regulated Company (DARC) project. DARC is a project that aims to create a decentralized autonomous company that is regulated by a plugin system based on commercial laws. The project is currently in the early stages of development and is not yet ready for production use.&lt;/p&gt; &#xA;&lt;p&gt;English | &lt;a href=&#34;https://raw.githubusercontent.com/Project-DARC/DARC/main/README_cn.md&#34;&gt;ç®€ä½“ä¸­æ–‡&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/Project-DARC/DARC/main/README_ja.md&#34;&gt;æ—¥æœ¬èªž&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Join our community&lt;/h2&gt; &#xA;&lt;p&gt;Telegram: &lt;a href=&#34;https://t.me/projectdarc&#34;&gt;https://t.me/projectdarc&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is DARC?&lt;/h2&gt; &#xA;&lt;p&gt;Decentralized Autonomous Regulated Company (DARC) is a company virtual machine that can be compiled and deployed to EVM-compatible blockchains with following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Multi-level tokens&lt;/strong&gt;, each level token can be used as common stock, preferred stock, convertible bonds, board of directors, product tokens, non-fungible tokens (NFT), with different prices, voting power and dividend power, which are defined by the company&#39;s plugin(law) system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Program&lt;/strong&gt; composed of a series of DARC instructions that include managing tokens, dividends, voting, legislation, purchasing, withdrawing cash, and other company operations.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Dividend Mechanism&lt;/strong&gt; for distributing dividends to token holders according to certain rules.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Plugin-as-a-Law&lt;/strong&gt;.The plugin system serves as the by-law or commercial contract that supervises all operations. All company operations need to be approved by the plugin system or corresponding voting process.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;By-Law Script&lt;/h2&gt; &#xA;&lt;p&gt;By-law script is a JavaScript-like programming language that is used to define the company&#39;s commercial rules and operations on DARC. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;mint_tokens(   // mint token operation&#xA;    [addr1, addr2, addr3],   // token address&#xA;    [0, 0, 0],   // token class &#xA;    [500, 300, 200]  // number of tokens&#xA;);&#xA;&#xA;pay_cash(100000000, 0, 1); // pay 0.1 ETH as purchase&#xA;&#xA;transfer_tokens(   // transfer token operation&#xA;    [addr1, addr2, addr3],   // token address&#xA;    [0, 0, 0],   // token class &#xA;    [100, 100, 200]  // number of tokens&#xA;);&#xA;&#xA;add_withdraw_cash(10000000);  // add 0.01 ETH to withdraw balance&#xA;&#xA;withdraw_cash_to(  // withdraw cash from my account to other address&#xA;    [addr4, addr5],       // withdraw cash to addr4, addr5&#xA;    [10000000, 10000000]  // withdraw amount 0.01 ETH, 0.01 ETH&#xA;);&#xA;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Above By-law Script will be transpiled via code generator and sent to corresponding DARC VM contract. The DARC will execute the program if the plugin system approves. To add plugin and voting rules to the DARC, we can simple compose the plugin conditions and voting rules, then send them via operation &lt;code&gt;add_voting_rule()&lt;/code&gt;, &lt;code&gt;add_and_enable_plugins()&lt;/code&gt; or &lt;code&gt;add_plugins()&lt;/code&gt;, and they will be deployed and effective immediately if the current plugin system approves the operation.&lt;/p&gt; &#xA;&lt;p&gt;Here is a quick example, assume we need to limit the transfer of tokens by major shareholders (&amp;gt;25%) by asking the board of directors for an all-hand vote (assuming 5 tokens in total), and it requires 100% approval (5 out of 5) in 1 hour. We can add a new plugin and corresponding voting rule to the DARC VM contract:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;add_voting_rule(  // add a voting rule (as index 5)&#xA;    [&#xA;        {&#xA;            voting_class: [1], // voting token class: 1, level-1 token ownners (board of directors) are required to vote&#xA;            approve_percentage: 99,  // 99% voting power is required to approve&#xA;            voting_duration: 3600,  // voting duration: 1 hour (3600 seconds)&#xA;            execute_duration: 3600,  // pending duration for execution: 1 hour (3600 seconds)&#xA;            is_absolute_majority: true,  // absolute majority is required, not relative majority&#xA;        }&#xA;    ]&#xA;)&#xA;&#xA;add_and_enable_plugins(   // add and enable plugins (as index 7)&#xA;    [&#xA;        {&#xA;            condition:  // define the condition:&#xA;                (operation == &#34;transfer_tokens&#34;)   // if operation is transfer_tokens&#xA;                &amp;amp; (operator_total_voting_power_percentage &amp;gt; 25),  // and addr1&#39;s voting power &amp;gt; 25%&#xA;            return_type: voting_needed,  // return type: requires a vote&#xA;            return_level: 100,  // priority: 100&#xA;            votingRuleIndex: 5 // voting rule index 5 (ask board of directors to vote and must 100% approve)&#xA;            note: &#34;100% Approval is needed by board members to transfer tokens by major shareholders (&amp;gt;25%)&#34;&#xA;            is_before_operation: false,  // check the plugin after the operation is executed in sandbox&#xA;        }&#xA;    ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After above By-Law Script is executed, the DARC VM contract will add a new plugin and voting rule, and the plugin will be effective immediately (if there exists any voting procedure related to &lt;code&gt;add_voting_rule()&lt;/code&gt; and &lt;code&gt;add_and_enable_plugins()&lt;/code&gt;, the plugin will be effective after the voting process is approved). If the operator (&lt;code&gt;addr1&lt;/code&gt;) tries to transfer tokens to addr2, the plugin will check the condition and return &lt;code&gt;voting_needed&lt;/code&gt; to the DARC VM contract, and the DARC VM contract will ask the board of directors (level-1 token owners) to vote. If the board of directors approves the operation, the operation will be executed in the sandbox, otherwise the operation will be rejected. For example, if there are 3 voting rules are triggerd, the voting operation will be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;vote([true, true, true])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the voting process is approved by the existing voting rules and plugins, the new program will be approved to execute in the next execution pending duration (1 hour in this example), and the program owner or any other members can execute the program in the next 1 hour, or the program will be ignored and removed from the pending list.&lt;/p&gt; &#xA;&lt;h2&gt;&#34;Plugin-as-a-Law&#34;&lt;/h2&gt; &#xA;&lt;p&gt;The law of DARC is defined in below pseudo-code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (plugin_condition == true) {&#xA;    plugin_decision = allows / denies / requires a vote&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each plugin contains a condition expression tree and a corresponding decision (return type). When the condition tree is evaluated to true while the program is submitted before running, the plugin will make a decision by allows, denies or requires a vote. For example:&lt;/p&gt; &#xA;&lt;h3&gt;Example 1: Anti-Dilutive shares&lt;/h3&gt; &#xA;&lt;p&gt;Anti-Dilutive shares is a basic mechanism to prevent the company (including DAO and other on-chain &#34;tokenomics&#34;) from issuing too many shares and dilute the ownership of the existing shareholders. In DARC, the company and early-stage investors can define a law of &#34;anti-dilutive shares&#34;, and the law can be abolished by certain process.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Law 1 (Anti-Dilutive Shares): Shareholder X should always holds 10% of the total stock.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Design of Plugin: If operation is minting new level-0 tokens, plugin should check the state of token ownerships, X should always keep a minimum total voting power of 10%, as well as dividend power of 10% after executing the operation&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;In By-law script, we can define the plugin with following conditions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// define X&#39;s address&#xA;const x_addr = &#34;0x1234567890123456789012345678901234567890&#34;;&#xA;&#xA;// define the plugin&#xA;const anti_delutive = {&#xA;&#xA;    // define the trigger condition&#xA;    condition:&#xA;        ((operation == &#34;mint_tokens&#34;)             // if operator is minting new tokens&#xA;            | (operation == &#34;pay_to_mint_tokens&#34;))   // or operator is paying to mint new tokens&#xA;        &amp;amp;                                          // and        &#xA;        ((total_voting_power_percentage(x) &amp;lt; 10)    // X&#39;s total voting power &amp;lt; 10%&#xA;            | (total_dividend_power_percentage(x) &amp;lt; 10)),   // or X&#39;s total dividend power &amp;lt; 10%&#xA;&#xA;    // define the decision: reject the operation&#xA;    return_type: NO,&#xA;&#xA;    // define the priority: 100&#xA;    return_level: 100,&#xA;&#xA;    // check the plugin after the operation is executed in sandbox&#xA;    is_before_operation: false,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since it checks the state of token ownerships, the plugin should be executed after the operation is executed inside the DARC&#39;s sandbox. If the plugin&#39;s condition is evaluated to true, the plugin will deny the operation after executing in the sandbox, and the operation will be rejected to be executed in the real environment. Otherwise, &#34;minting new tokens&#34; will be allowed to execute.&lt;/p&gt; &#xA;&lt;p&gt;When this plugin is added to the DARC, the operator (the author of current program) must mint extra tokens to address &lt;code&gt;x_addr&lt;/code&gt; to satisfy the &lt;strong&gt;Law 1&lt;/strong&gt; above, otherwise it will be rejected. For example, the DARC has only one level of tokens (level 0, voting power = 1, dividend power = 1), the stock ownerships are:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;ShareHolders&lt;/th&gt; &#xA;   &lt;th&gt;Number of tokens&lt;/th&gt; &#xA;   &lt;th&gt;Percentage&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CEO&lt;/td&gt; &#xA;   &lt;td&gt;400&lt;/td&gt; &#xA;   &lt;td&gt;40%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CTO&lt;/td&gt; &#xA;   &lt;td&gt;300&lt;/td&gt; &#xA;   &lt;td&gt;30%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CFO&lt;/td&gt; &#xA;   &lt;td&gt;200&lt;/td&gt; &#xA;   &lt;td&gt;20%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;VC X&lt;/td&gt; &#xA;   &lt;td&gt;100&lt;/td&gt; &#xA;   &lt;td&gt;10%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Total&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1000&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;100%&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;If the operator want to mint 200 tokens and issue them to VC Y, the operator must mint 20 tokens to address &lt;code&gt;x_addr&lt;/code&gt; to satisfy the &lt;strong&gt;Law 1&lt;/strong&gt; above, otherwise the operation will be rejected. Here is a sample investment program by VC Y:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;pay_cash(1000000000000)  // pay 1000 ETH to the DARC&#xA;mint_tokens(20, 0, x_addr)  // mint 20 level-0 tokens to address x_addr&#xA;mint_tokens(180, 0, y_addr)  // mint 180 level-0 tokens to address y_addr&#xA;add_and_enable_plugin([new_law_1, new_law_2, new_law_3])  // investment laws by VC Y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After the operation, the stock ownerships are:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;ShareHolders&lt;/th&gt; &#xA;   &lt;th&gt;Number of tokens&lt;/th&gt; &#xA;   &lt;th&gt;Percentage&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CEO&lt;/td&gt; &#xA;   &lt;td&gt;400&lt;/td&gt; &#xA;   &lt;td&gt;33.33%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CTO&lt;/td&gt; &#xA;   &lt;td&gt;300&lt;/td&gt; &#xA;   &lt;td&gt;25%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CFO&lt;/td&gt; &#xA;   &lt;td&gt;200&lt;/td&gt; &#xA;   &lt;td&gt;16.67%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;VC X&lt;/td&gt; &#xA;   &lt;td&gt;120&lt;/td&gt; &#xA;   &lt;td&gt;10%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;VC Y&lt;/td&gt; &#xA;   &lt;td&gt;180&lt;/td&gt; &#xA;   &lt;td&gt;15%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Total&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1200&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;100%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Also another plugin should be added to the DARC to define the legislation of the &#34;Abolish Law 1&#34;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Law 1.1(Law 1 Appendix): Both Law 1 and Law 1 Appendix (current Law) can be abolished if and only if the operator is X&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Design of Plugin: If operation is &#34;disable_plugins&#34;, and the plugin that to be disabled is with &lt;code&gt;id == 1&lt;/code&gt; or &lt;code&gt;id == 2&lt;/code&gt;, and the operator is not X, then the plugin should reject the operation (assume the anti dilutive law index is 1, and the appendix law index is 2, both are before-operation plugins)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const law_1_appendix = {&#xA;&#xA;    // define the trigger condition&#xA;    condition:&#xA;        (operation == &#34;disable_plugins&#34;)&#xA;        &amp;amp; ((disable_after_op_plugin_id == 1) | (disable_after_op_plugin_id == 2))&#xA;        &amp;amp; (operator != x_addr),&#xA;&#xA;    // define the decision&#xA;    return_type: no,&#xA;&#xA;    // define the priority&#xA;    return_level: 100,&#xA;&#xA;    // reject the operation before sandbox&#xA;    is_before_operation: true,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example 2: Bet-on Agreement/Valuation-Adjustment Mechanism(VAM) Agreement&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Law2: If total revenue &amp;lt; 1000 ETH by 2035/01/01, shareholder X can take over 75% of total voting power and 90% of dividend power.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Design of Plugin: After executing in sandbox, check the following conditions:&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;timestamp &amp;gt;= 2035/01/01&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;revenue since 2000/01/01 &amp;lt; 1000 ETH&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;operation is &#34;mint_tokens&#34;&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;total voting power of x &amp;lt;= 75%&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;the dividend power of x &amp;lt;= 90%&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;then the plugin should approve the operation&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;In By-law script, we can define the above plugin as following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const bet_on_2 = {&#xA;&#xA;    // define the trigger condition&#xA;    condition:&#xA;        (timestamp &amp;gt;= toTimestamp(&#39;2035/01/01&#39;)) &amp;amp;&#xA;        (revenue_since(946706400) &amp;lt; 1000000000000) &amp;amp; // 1000000000000 Gwei = 1000 ETH&#xA;        (operation == &#34;mint_tokens&#34;) &amp;amp;&#xA;        (total_voting_power_percentage(x) &amp;lt; 75) &amp;amp;&#xA;        (total_dividend_power_percentage(x) &amp;lt; 90),&#xA;&#xA;    // define the decision&#xA;    return_type: yes,&#xA;&#xA;    // define the priority&#xA;    return_level: 100,&#xA;&#xA;    // approve the operation after executing in sandbox&#xA;    is_before_operation: false,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example 3: Employee Payroll&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Law 3: The payroll for employees with role level X should be 10 ETH per month.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Design of Plugin: If operation is &#34;add withdrawable cash&#34;, the amount is less than or equals to 10 ETH, and the last operation was at least 30 days, then this operation should be approved and skip sandbox check&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;In By-law script, we can define the plugin with following conditions (for example, level X = 2 can withdraw 10 ETH per 30 days):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const payroll_law_level_2 = {&#xA;    condition:&#xA;        (operation == &#34;add_withdrawable_cash&#34;) &amp;amp;   // operation is &#34;add withdrawable cash&#34;&#xA;        (member_role_level == 2) &amp;amp;   // the operator address is in role level 2&#xA;&#xA;        // add cash by &amp;lt; every 30 days = 2592000 seconds&#xA;        (operator_last_operation_window(&#34;add_withdrawable_cash&#34;) &amp;gt;= 2592000) &amp;amp;&#xA;        // each time add &amp;lt; 10000000000 Gwei = 10 ETH to the account&#xA;        (add_withdrawable_cash_amount &amp;lt;= 10000000000),&#xA;&#xA;    // approve the operation and skip sandbox check&#xA;    return_type: yes_and_skip_sandbox,&#xA;    return_level: 1&#xA;    is_before_operation: true,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With the plugin above, the operator can add withdrawable cash to the employee&#39;s account with amount less than or equals to 10 ETH, and the last operation was at least 30 days. The plugin will approve the operation and skip the sandbox check. When the employee address is disable, removed from role level X, or other plugins with higher priority deny the operation, these operations will be rejected.&lt;/p&gt; &#xA;&lt;h3&gt;Example 4: Voting and legislation&lt;/h3&gt; &#xA;&lt;p&gt;For daily operations, the board of directors can be defined as a group of addresses, and the voting mechanism can be used to make decisions. For example, let&#39;s design the voting mechanism for the following scenario:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Any address X with more than 10% total voting power can be added to the board by minting 1 token (level 2, board voting token), if and only if the behavior is approved by 2/3 of all the board members (voting rule 1).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const add_board_member = {&#xA;    condition:&#xA;        (operation == &#34;mint_tokens&#34;) &amp;amp;   // operation is &#34;mint_tokens&#34;&#xA;        (mint_tokens_level == 2) &amp;amp;  // the token level is 2&#xA;        (mint_tokens_amount == 1) &amp;amp;  // the amount is 1&#xA;        (operator_total_voting_power_percentage &amp;gt;= 10),   // the operator address holds at least 10% of the total voting power&#xA;    return_type: voting_needed,&#xA;    voting_rule: 1,  // Under the voting rule 1, the operation will be approved if and only if 2/3 of all the board members approve the operation&#xA;    return_level: 100,&#xA;    is_before_operation: false, // make the decision after executing in sandbox&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Any operator with more than 7% of all voting power can submit &lt;code&gt;enable_plugins()&lt;/code&gt; , and it needs to be approved by 100% of all the board members. Each operator can try to activate plugin per 10 days.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const enable_plugin = {&#xA;    condition:&#xA;        (operation == &#34;enable_plugins&#34;) &amp;amp;   // operation is &#34;enable_plugins&#34;&#xA;        (operator_total_voting_power_percentage &amp;gt;= 7) &amp;amp;   // the operator address holds at least 7% of the total voting power&#xA;        (operator_last_operation_window(&#34;enable_plugin&#34;) &amp;gt;= 864000),  // each operator can try to enable plugins once per 864000 seconds (10 days)&#xA;&#xA;    return_type: voting_needed,&#xA;    voting_rule: 2,  // Under the voting rule 2, the operation will be approved if and only if 100% of all the board members approve the operation&#xA;    return_level: 100,&#xA;    is_before_operation: false, // make the decision after executing in sandbox&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;To disable plugins 2,3 and 4, the operator needs to hold at least 20% of total voting power, and the operation needs to be approved by 70% of all common stock token(level-0) voters as relative majority(voting rule 2). For each member of DARC, this operation can be executed once per 15 days (1296000 seconds).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const disable_2_3_4 = {&#xA;    condition:&#xA;        (operation == &#34;disable_plugins&#34;) &amp;amp;   // operation is &#34;disable_plugins&#34;&#xA;        (&#xA;            disable_after_op_plugin_id == 2&#xA;            | disable_after_op_plugin_id == 3&#xA;            | disable_after_op_plugin_id == 4&#xA;        ) &amp;amp;  // disable after operation plugins 2,3 and 4&#xA;        (operator_total_voting_power_percentage &amp;gt;= 20) &amp;amp;   // the operator address holds at least 20% of the total voting power&#xA;        (operator_last_operation_window(&#34;disable_plugins&#34;) &amp;gt;= 1296000),  // each operator can try to disable plugins once per 1296000 seconds (15 days)&#xA;    return_type: voting_needed,&#xA;    voting_rule: 3,  // Under the voting rule 3, the operation will be approved if and only if 70% of all the common stock holders approve the operation&#xA;    is_before_operation: false, // make the decision after sandbox check&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example 5: Multi-level Tokens: Product tokens and Non-fungible tokens&lt;/h3&gt; &#xA;&lt;p&gt;Here is an example of how to design a token with different levels of voting power and dividend power. The voting power and dividend power are used to calculate the voting power and dividend power of each token holder. Here is the table of the token levels:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Level&lt;/th&gt; &#xA;   &lt;th&gt;Token&lt;/th&gt; &#xA;   &lt;th&gt;Voting Power&lt;/th&gt; &#xA;   &lt;th&gt;Dividend Power&lt;/th&gt; &#xA;   &lt;th&gt;Total Supply&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;Level-0 Common Stock&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;100,000&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;Level-1 Stock&lt;/td&gt; &#xA;   &lt;td&gt;20&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;10,000&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;Board of Directors&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;Executives&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;Non-Voting Shares&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;200,000&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;   &lt;td&gt;Product Token A (0.01 ETH/token)&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;âˆž&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;6&lt;/td&gt; &#xA;   &lt;td&gt;Product Token B (10 ETH/token)&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;âˆž&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;7&lt;/td&gt; &#xA;   &lt;td&gt;Non-Fungible Token #1&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;8&lt;/td&gt; &#xA;   &lt;td&gt;Non-Fungible Token #2&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;9&lt;/td&gt; &#xA;   &lt;td&gt;Non-Fungible Token #3&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;10&lt;/td&gt; &#xA;   &lt;td&gt;Non-Fungible Token #4&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;11&lt;/td&gt; &#xA;   &lt;td&gt;Non-Fungible Token #5&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;...&lt;/td&gt; &#xA;   &lt;td&gt;...&lt;/td&gt; &#xA;   &lt;td&gt;...&lt;/td&gt; &#xA;   &lt;td&gt;...&lt;/td&gt; &#xA;   &lt;td&gt;...&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;To pay for service or prochase for products, customers can use &lt;code&gt;pay_cash()&lt;/code&gt; to pay for the service directly, or use &lt;code&gt;pay_to_mint_tokens()&lt;/code&gt; as a payment method and receive product tokens/NFTs.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example about how to define &#34;Product Token A&#34; and &#34;NFT&#34; price and total supply.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const product_token_A_price_law = {&#xA;    condition:&#xA;        (operation == &#34;pay_to_mint_tokens&#34;) &amp;amp;   // operation is &#34;pay_to_mint_tokens&#34;&#xA;        (pay_to_mint_tokens_level == 5) &amp;amp;  // the token level is 5&#xA;        (pay_to_mint_price_per_token &amp;gt;= 10000000000000000),   // price per token &amp;gt;= 0.01 ETH = 10000000000000000 wei&#xA;&#xA;    return_type: yes_and_skip_sandbox,  // approve the operation and skip sandbox check&#xA;    return_level: 1,&#xA;    is_before_operation: true, // approve the operation and skip sandbox check&#xA;}&#xA;&#xA;const NFT_price_law = {&#xA;    condition:&#xA;        (operation == &#34;pay_to_mint_tokens&#34;) &amp;amp;   // operation is &#34;pay_to_mint_tokens&#34;&#xA;        (pay_to_mint_tokens_level &amp;gt;= 7) &amp;amp;  // the token level is 7 or higher&#xA;        (pay_to_mint_token_amount == 1) &amp;amp;  // only allow to mint 1 token at a time&#xA;        (pay_to_mint_current_level_total_supply == 0) &amp;amp;  // current total supply is 0&#xA;        (pay_to_mint_price_per_token &amp;gt;= 10000000000000000000),   // price per token &amp;gt;= 10 ETH = 10000000000000000000 wei&#xA;&#xA;    return_type: yes_and_skip_sandbox,  // approve the operation and skip sandbox check&#xA;    return_level: 1,&#xA;    is_before_operation: true, // approve the operation and skip sandbox check&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example 6: Lock dividend yield rate for 5 years&lt;/h3&gt; &#xA;&lt;p&gt;The dividend mechanism is designed to distribute dividends to token holders under certain rules:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;For each &lt;code&gt;X&lt;/code&gt; purchase transactions, take Yâ€± of the total income as the dividendable cash&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;offer_dividend()&lt;/code&gt; operation can be called, which will distribute the dividendable cash to token holders&#39; dividend withdraw balance&lt;/li&gt; &#xA; &lt;li&gt;The amount of dividends per token holder (X) is calculated by the following formula: &lt;code&gt;dividend_X = dividendable_cash * dividend_power(X) / total_dividend_power&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;After the &lt;code&gt;offer_dividend()&lt;/code&gt; operation is called, the dividendable cash and dividendable transaction counter will be set to 0, and the dividend withdraw balance of each token holder will be increased by &lt;code&gt;dividend_X&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;To make sure the dividend yield rate is stable, we can add a plugin to the DARC to lock the dividend yield rate for 5 years by limiting the &lt;code&gt;set_parameters()&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Law 6: The dividend yield rate should be locked &amp;gt; 500â€± (5%) before 2030-01-01.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const dividend_yield_rate_law = {&#xA;    condition:&#xA;        (operation == &#34;set_parameters&#34;) &amp;amp;  // operation is &#34;set_parameters&#34;&#xA;        (set_parameters_key == &#34;dividendPermyriadPerTransaction&#34;) &amp;amp;  // the key is &#34;dividend_yield_rate&#34;&#xA;        (set_parameters_value &amp;lt; 500) &amp;amp;  // the value is &amp;lt; 500â€± (5%)&#xA;        (timestamp &amp;lt; 1893477600),  // the timestamp &amp;lt; unix timestamp  2030-01-01 00:00:00 (UTC) &#xA;&#xA;    return_type: no,  // reject the operation&#xA;    return_level: 1,&#xA;    is_before_operation: true, // reject the operation and skip sandbox check&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example 7: Investment program package&lt;/h3&gt; &#xA;&lt;p&gt;Here is an unofficial example program of &lt;strong&gt;Simple agreement for future equity (SAFE)&lt;/strong&gt;, a common investment contract by a VC firm:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The VC firm will pay 1000 ETH (1000000000000 Gwei) cash to the DARC as investment&lt;/li&gt; &#xA; &lt;li&gt;The VC firm will be granted 100,000,000 level-0 tokens (common stock) and 1 level-2 token (board of members)&lt;/li&gt; &#xA; &lt;li&gt;The VC firm will be granted the right to disable plugins 5, 6, 7&lt;/li&gt; &#xA; &lt;li&gt;The VC firm will be granted the right to enable plugins 8, 9, 10, 11&lt;/li&gt; &#xA; &lt;li&gt;The VC firm will be granted the right to change its role to level-5 (majority shareholder level)&lt;/li&gt; &#xA; &lt;li&gt;It&#39;s recommended to sign and scan a PDF document to record the agreement, upload the PDF document to IPFS, and add the IPFS hash &lt;code&gt;QmcpxHN3a5HYnPurtuDs3jDfDSg1LPDe2KVBUG4RifcSbC&lt;/code&gt; to the DARC permanent storage array. This can help the emergency agent to verify and fix DARC technical issues if needed.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const vc_addr = &#34;0x1234567890123456789012345678901234567890&#34;;  // define my address&#xA;&#xA;pay_cash(1000000000000, 0, 1);  // pay 1000 ETH = 1000000000000 Gwei cash&#xA;&#xA;mint_token([vc_addr], [100000000], [0]);  // mint 100,000,000 level-0 tokens (common stock) to VC firm&#xA;&#xA;mint_token([vc_addr], [1], [2]);  // mint a single 2-level token (board of members) to VC firm&#xA;&#xA;disable_plugins([5, 6, 7], [false, false, false]) // disable previes after-operation plugins 5, 6, 7&#xA;&#xA;enable_plugins([8, 9, 10, 11], [false, false, false, false]) // enable new added plugins 8, 9, 10, which were added before this program&#xA;&#xA;change_member_role(vc_addr, 5);  // change the role of VC firm to level-5 (majority shareholder level)&#xA;&#xA;/** Finally, sign and scan a SAFE document,&#xA; * upload and pin on IPFS, and add the IPFS hash value to the DARC&#xA; * just in case if DARC needs emergency agent to take over the DARC&#xA; */&#xA;add_storage([&#39;QmcpxHN3a5HYnPurtuDs3jDfDSg1LPDe2KVBUG4RifcSbC&#39;]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building the source&lt;/h2&gt; &#xA;&lt;p&gt;Since Hardhat and OpenZeppelin are used, the project can be built using the following commands:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install dependencies&lt;/p&gt; &lt;p&gt;We recommend that you use &lt;code&gt;pnpm&lt;/code&gt; instead of &lt;code&gt;npm&lt;/code&gt;, but &lt;code&gt;npm&lt;/code&gt; can also work.&lt;/p&gt; &lt;p&gt;&lt;code&gt;pnpm&lt;/code&gt; is a newer package manager that has some advantages over npm. It is faster, more efficient, and disk-space friendly.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd darc-protocal&#xA;npm install&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Compile the contracts&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npx hardhat compile&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run the Darc test network&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm run node&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Test contracts&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npx hardhat test&#xA;REPORT_GAS=true npm run test&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Deploy contracts&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm run deploy&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>