<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub TypeScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-31T01:40:11Z</updated>
  <subtitle>Daily Trending of TypeScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>AykutSarac/jsoncrack.com</title>
    <updated>2022-08-31T01:40:11Z</updated>
    <id>tag:github.com,2022-08-31:/AykutSarac/jsoncrack.com</id>
    <link href="https://github.com/AykutSarac/jsoncrack.com" rel="alternate"></link>
    <summary type="html">&lt;p&gt;🔮 Seamlessly visualize your JSON data instantly into graphs; paste, import or fetch!&lt;/p&gt;&lt;hr&gt;&lt;center&gt; &#xA; &lt;a href=&#34;https://jsoncrack.com&#34;&gt; &lt;img width=&#34;1080&#34; alt=&#34;jsoncrack&#34; src=&#34;https://user-images.githubusercontent.com/47941171/187418000-8edea92b-b3ac-4b07-9c4c-e42f6763817d.png&#34;&gt; &lt;/a&gt; &#xA;&lt;/center&gt; &#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p align=&#34;center&#34;&gt; &lt;img alt=&#34;travis ci badge&#34; src=&#34;https://img.shields.io/travis/com/AykutSarac/jsoncrack.com/main?style=flat-square&#34;&gt; &lt;a href=&#34;https://github.com/AykutSarac/jsoncrack.com/raw/main/LICENSE&#34;&gt; &lt;img alt=&#34;license badge&#34; src=&#34;https://img.shields.io/github/license/AykutSarac/jsoncrack.com?style=flat-square&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/AykutSarac/jsoncrack.com/releases&#34;&gt; &lt;img alt=&#34;version badge&#34; src=&#34;https://img.shields.io/github/package-json/v/AykutSarac/jsoncrack.com?color=brightgreen&amp;amp;style=flat-square&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/sponsors/AykutSarac&#34;&gt; &lt;img alt=&#34;github sponsors&#34; src=&#34;https://img.shields.io/github/sponsors/AykutSarac?style=flat-square&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;i&gt;Simple json visualization tool for your data.&lt;/i&gt; &lt;/p&gt;&#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://www.producthunt.com/posts/json-crack?utm_source=badge-featured&amp;amp;utm_medium=badge&amp;amp;utm_souce=badge-json-crack&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://api.producthunt.com/widgets/embed-image/v1/featured.svg?post_id=332281&amp;amp;theme=light&#34; alt=&#34;JSON Crack - Simple visualization tool for your JSON data. | Product Hunt&#34; style=&#34;width: 250px; height: 54px;&#34; width=&#34;250&#34; height=&#34;54&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;800&#34; src=&#34;https://raw.githubusercontent.com/AykutSarac/jsoncrack.com/main/public/jsoncrack-screenshot.webp&#34; alt=&#34;preview 1&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;JSON Crack (jsoncrack.com)&lt;/h1&gt; &#xA;&lt;p&gt;JSON Crack is a tool that generates graph diagrams from JSON objects. These diagrams are much easier to navigate than the textual format and to make it even more convenient, the tool also allows you to search the nodes. Additionally, the generated diagrams can also be downloaded or clipboard as image.&lt;/p&gt; &#xA;&lt;p&gt;You can use the web version at &lt;a href=&#34;https://jsoncrack.com&#34;&gt;jsoncrack.com&lt;/a&gt; or also run it locally as &lt;a href=&#34;https://github.com/AykutSarac/jsoncrack.com#-docker&#34;&gt;Docker container&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;b&gt;&lt;a href=&#34;https://jsoncrack.com&#34;&gt;JSON Crack - Crack your data into pieces&lt;/a&gt;&lt;/b&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;⚡️ Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Search Nodes&lt;/li&gt; &#xA; &lt;li&gt;Share links &amp;amp; Create Embed Widgets&lt;/li&gt; &#xA; &lt;li&gt;Download/Clipboard as image&lt;/li&gt; &#xA; &lt;li&gt;Upload JSON locally or fetch from URL&lt;/li&gt; &#xA; &lt;li&gt;Great UI/UX&lt;/li&gt; &#xA; &lt;li&gt;Light/Dark Mode&lt;/li&gt; &#xA; &lt;li&gt;Advanced Error Messages&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;🛠 Development Setup&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;  npm install --legacy-peer-deps&#xA;  npm run dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;🐳 Docker&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;A Docker file is provided in the root of the repository.&#xA;If you want to run JSON Crack locally:&#xA;&#xA;* Build Docker image with `docker build -t jsoncrack .`&#xA;* Run locally with `docker run -p 8888:8080 jsoncrack`&#xA;* Go to [http://localhost:8888]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is open source and available under the &lt;a href=&#34;https://raw.githubusercontent.com/AykutSarac/jsoncrack.com/main/LICENSE&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Mereithhh/van-blog</title>
    <updated>2022-08-31T01:40:11Z</updated>
    <id>tag:github.com,2022-08-31:/Mereithhh/van-blog</id>
    <link href="https://github.com/Mereithhh/van-blog" rel="alternate"></link>
    <summary type="html">&lt;p&gt;一款简洁实用优雅的高性能个人博客系统&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Mereithhh/van-blog/master/img/logo.svg?sanitize=true&#34; style=&#34;width: 200px&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;strong&gt;VanBlog 是一款简洁实用优雅的高性能个人博客系统。支持 HTTPS 证书全自动按需申请、黑暗模式、移动端自适应和评论，内置流量统计与图床，内嵌评论系统，配有完备的、支持黑暗模式、支持移动端、支持一键上传剪切板图片到图床、带有强大的编辑器的后台管理面板。&lt;/strong&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/mereithhh/van-blog?display_name=tag&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/stars/mereithhh/van-blog&#34;&gt; &lt;img src=&#34;https://img.shields.io/bitbucket/issues/mereithhh/van-blog&#34;&gt; &lt;img src=&#34;https://github.com/mereithhh/van-blog/workflows/release/badge.svg?sanitize=true&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/license-GPL%20v3-yellow.svg?sanitize=true&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;strong&gt;项目主页: &lt;/strong&gt; &lt;a target=&#34;_blank&#34; href=&#34;https://vanblog.mereith.com&#34;&gt;vanblog.mereith.com&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;strong&gt;Demo(后台账号密码均为 demo): &lt;/strong&gt; &lt;a target=&#34;_blank&#34; href=&#34;https://blog-demo.mereith.com&#34;&gt;blog-demo.mereith.com&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;预览图&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Mereithhh/van-blog/master/img/%E5%89%8D%E5%8F%B0-%E7%99%BD%E8%89%B2.png&#34; alt=&#34;前台-白色&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Mereithhh/van-blog/master/img/%E5%89%8D%E5%8F%B0-%E9%BB%91%E8%89%B2.png&#34; alt=&#34;前台-黑色&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Mereithhh/van-blog/master/img/%E5%90%8E%E5%8F%B0-%E7%99%BD%E8%89%B2.png&#34; alt=&#34;后台-白色&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Mereithhh/van-blog/master/img/%E5%90%8E%E5%8F%B0-%E9%BB%91%E8%89%B2.png&#34; alt=&#34;后台-黑色&#34;&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Mereithhh/van-blog/master/img/lighthouse.png&#34; style=&#34;width: 400px&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;特性&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 快到极致的响应速度，Lighthouse 接近满分。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 独一份的按需全自动 HTTPS，甚至不用填域名。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 包括完整的前后台和服务端。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 前台和后台都为响应式设计，完美适配移动端和多尺寸设备。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 前台和后台都支持黑暗模式，并可自动切换。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 前台为静态网页（SSG），并支持秒级的增量渲染，每次改动无需重新构建全部页面。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; SEO 和无障碍友好。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 静态网页，CDN 友好。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 版本号展示和更新提醒。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 基于 React，项目工程化，二次开发友好。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 内置强大的分析功能，可统计访客等数据。并配有精美看板。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 内嵌评论系统。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 强大的 markdown 编辑器，支持图表和数学公式，一键插入 more 标记，一键剪切板及本地图片上传&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; TOC、草稿、代码复制、访客数、评论数、分类、标签、搜索、加密、友链、打赏、自定义导航栏。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 多个布局设置，可自定义页面细节。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 内置图床，并支持各种 OSS 图床、github 图床（外部图床基于 picgo）等。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 极致轻量化，没有花里胡哨。页面秒切换、图片懒加载。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; docker 一键部署，支持 ARM 平台。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 支持 GA、百度分析&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 简单易用的后台，支持数据的导出与导入。&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 完善的 API，完全利用本项目后台和服务端，自己写前端或适配其他页面生成器&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 有较完善的日志记录，后台可直接查看登录日志和 Caddy 日志。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;快速上手&lt;/h2&gt; &#xA;&lt;p&gt;请移步项目文档：&lt;a href=&#34;https://vanblog.mereith.com/guide/docker.html&#34;&gt;快速上手&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;常见问题&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://vanblog.mereith.com/ref/faq.html#%E5%9B%BE%E7%89%87%EF%BC%88%E4%BD%9C%E8%80%85%20logo%EF%BC%89%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%87%BA%E6%9D%A5&#34;&gt;作者 logo 无法加载&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://vanblog.mereith.com/ref/faq.html#%E9%83%A8%E7%BD%B2%E5%90%8E-http-error&#34;&gt;http error&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://www.runoob.com/docker/docker-mirror-acceleration.html&#34;&gt;docker 镜像拉取慢&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://vanblog.mereith.com/ref/faq.html&#34;&gt;更多常见问题&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;说明与文档&lt;/h2&gt; &#xA;&lt;p&gt;请移步项目主页： &lt;a href=&#34;https://vanblog.mereith.com&#34;&gt;https://vanblog.mereith.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;CHANGELOG&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mereithhh/van-blog/master/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;谁在用&lt;/h2&gt; &#xA;&lt;p&gt;目前就我自己- -&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.mereith.com&#34;&gt;Mereith&#39;s Blog&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 精简前台 js 体积，优化性能&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 精简打包体积&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 集成 HTTPS 和自动证书申请续期&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 后台增加登录日志&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 内嵌评论系统&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 支持 ARM64&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 支持 mermaid 语法&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 替换编辑器为 bytemd（掘金同款）（老的编辑器有些臃肿，复制偶尔会有格式会错乱的问题）&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 导入 md 创建文章/草稿功能&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; 标签管理&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; 黑暗模式图标样式优化&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; 内嵌评论的邮件通知和 webhook&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; 浏览器消息通知&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; RSS 订阅&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; 精简配置项，尽可能移动到运行时配置&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; 增加一些 e2e 测试，集成到 CI&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;问题反馈&lt;/h2&gt; &#xA;&lt;p&gt;请提 &lt;code&gt;issue&lt;/code&gt; ，如无特殊情况会在一天内解决。&lt;/p&gt; &#xA;&lt;h2&gt;Star 趋势图&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://star-history.com/#mereithhh/van-blog&amp;amp;Date&#34;&gt;&lt;img src=&#34;https://api.star-history.com/svg?repos=mereithhh/van-blog&amp;amp;type=Date&#34; alt=&#34;Star History Chart&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>gvergnaud/ts-pattern</title>
    <updated>2022-08-31T01:40:11Z</updated>
    <id>tag:github.com,2022-08-31:/gvergnaud/ts-pattern</id>
    <link href="https://github.com/gvergnaud/ts-pattern" rel="alternate"></link>
    <summary type="html">&lt;p&gt;🎨 The exhaustive Pattern Matching library for TypeScript, with smart type inference.&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;TS-Pattern&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; The exhaustive Pattern Matching library for &lt;a href=&#34;https://github.com/microsoft/TypeScript&#34;&gt;TypeScript&lt;/a&gt; with smart type inference. &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://www.npmjs.com/package/ts-pattern&#34;&gt; &lt;img src=&#34;https://img.shields.io/npm/dm/ts-pattern.svg?sanitize=true&#34; alt=&#34;downloads&#34; height=&#34;18&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://www.npmjs.com/package/ts-pattern&#34;&gt; &lt;img src=&#34;https://img.shields.io/npm/v/ts-pattern.svg?sanitize=true&#34; alt=&#34;npm version&#34; height=&#34;18&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/gvergnaud/ts-pattern&#34;&gt; &lt;img src=&#34;https://img.shields.io/npm/l/ts-pattern.svg?sanitize=true&#34; alt=&#34;MIT license&#34; height=&#34;18&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;type Data =&#xA;  | { type: &#39;text&#39;; content: string }&#xA;  | { type: &#39;img&#39;; src: string };&#xA;&#xA;type Result =&#xA;  | { type: &#39;ok&#39;; data: Data }&#xA;  | { type: &#39;error&#39;; error: Error };&#xA;&#xA;const result: Result = ...;&#xA;&#xA;return match(result)&#xA;  .with({ type: &#39;error&#39; }, () =&amp;gt; `&amp;lt;p&amp;gt;Oups! An error occured&amp;lt;/p&amp;gt;`)&#xA;  .with({ type: &#39;ok&#39;, data: { type: &#39;text&#39; } }, (res) =&amp;gt; `&amp;lt;p&amp;gt;${res.data.content}&amp;lt;/p&amp;gt;`)&#xA;  .with({ type: &#39;ok&#39;, data: { type: &#39;img&#39;, src: P.select() } }, (src) =&amp;gt; `&amp;lt;img src=${src} /&amp;gt;`)&#xA;  .exhaustive();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;Write &lt;strong&gt;better&lt;/strong&gt; and &lt;strong&gt;safer conditions&lt;/strong&gt;. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes &lt;strong&gt;shorter&lt;/strong&gt; and &lt;strong&gt;more readable&lt;/strong&gt;. Exhaustiveness checking ensures you haven’t forgotten &lt;strong&gt;any possible case&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pattern-match on &lt;strong&gt;any data structure&lt;/strong&gt;: nested &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#objects&#34;&gt;Objects&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#tuples-arrays&#34;&gt;Arrays&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#tuples-arrays&#34;&gt;Tuples&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#sets&#34;&gt;Sets&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#maps&#34;&gt;Maps&lt;/a&gt; and all primitive types.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Typesafe&lt;/strong&gt;, with helpful &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#type-inference&#34;&gt;type inference&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Exhaustiveness checking&lt;/strong&gt; support, enforcing that you are matching every possible case with &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#exhaustive&#34;&gt;&lt;code&gt;.exhaustive()&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#patterns&#34;&gt;patterns&lt;/a&gt; to &lt;strong&gt;validate&lt;/strong&gt; the shape of your data with &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#ismatching&#34;&gt;&lt;code&gt;isMatching&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Expressive API&lt;/strong&gt;, with catch-all and type specific &lt;strong&gt;wildcards&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#P_-wildcard&#34;&gt;&lt;code&gt;P._&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Pstring-wildcard&#34;&gt;&lt;code&gt;P.string&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Pnumber-wildcard&#34;&gt;&lt;code&gt;P.number&lt;/code&gt;&lt;/a&gt;, etc.&lt;/li&gt; &#xA; &lt;li&gt;Supports &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Pwhen-patterns&#34;&gt;&lt;strong&gt;predicates&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Punion-patterns&#34;&gt;&lt;strong&gt;unions&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Pintersection-patterns&#34;&gt;&lt;strong&gt;intersections&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Pnot-patterns&#34;&gt;&lt;strong&gt;exclusion&lt;/strong&gt;&lt;/a&gt; patterns for non-trivial cases.&lt;/li&gt; &#xA; &lt;li&gt;Supports properties selection, via the &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Pselect-patterns&#34;&gt;&lt;code&gt;P.select(name?)&lt;/code&gt;&lt;/a&gt; function.&lt;/li&gt; &#xA; &lt;li&gt;Tiny bundle footprint (&lt;a href=&#34;https://bundlephobia.com/package/ts-pattern&#34;&gt;&lt;strong&gt;only 1.7kB&lt;/strong&gt;&lt;/a&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What is Pattern Matching?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages&#34;&gt;Pattern Matching&lt;/a&gt; is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.&lt;/p&gt; &#xA;&lt;p&gt;Pattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is &lt;a href=&#34;https://github.com/tc39/proposal-pattern-matching&#34;&gt;a tc39 proposal&lt;/a&gt; to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn&#39;t likely to land before several years. Luckily, pattern matching can be implemented in userland. &lt;code&gt;ts-pattern&lt;/code&gt; Provides a typesafe pattern matching implementation that you can start using today.&lt;/p&gt; &#xA;&lt;p&gt;Read the introduction blog post: &lt;a href=&#34;https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k&#34;&gt;Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Via npm&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;npm install ts-pattern&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Via yarn&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;yarn add ts-pattern&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compatibility with different TypeScript versions&lt;/h3&gt; &#xA;&lt;p&gt;Note: TS-Pattern assumes &lt;a href=&#34;https://www.typescriptlang.org/tsconfig#strict&#34;&gt;Strict Mode&lt;/a&gt; is enabled in your &lt;code&gt;tsconfig.json&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;ts-pattern&lt;/th&gt; &#xA;   &lt;th&gt;TypeScript v4.5+&lt;/th&gt; &#xA;   &lt;th&gt;TypeScript v4.2+&lt;/th&gt; &#xA;   &lt;th&gt;TypeScript v4.1+&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v4.x &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#documentation&#34;&gt;(Docs)&lt;/a&gt; &lt;a href=&#34;https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md&#34;&gt;(Migration Guide)&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v3.x &lt;a href=&#34;https://github.com/gvergnaud/ts-pattern/tree/v3#documentation&#34;&gt;(Docs)&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;⚠️&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;v2.x &lt;a href=&#34;https://github.com/gvergnaud/ts-pattern/tree/v2#documentation&#34;&gt;(Docs)&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;✅ Full support&lt;/li&gt; &#xA; &lt;li&gt;⚠️ Partial support, All features except passing multiple patterns to &lt;code&gt;.with()&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;❌ Not supported&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;h4&gt;⚠️ This is the docs for &lt;strong&gt;TS-Pattern v4&lt;/strong&gt;. Find the docs for &lt;a href=&#34;https://github.com/gvergnaud/ts-pattern/tree/v3&#34;&gt;&lt;strong&gt;TS-Pattern v3 here&lt;/strong&gt;&lt;/a&gt;.&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#code-sandbox-examples&#34;&gt;Code Sandbox Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#getting-started&#34;&gt;Getting Started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#api-reference&#34;&gt;API Reference&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#match&#34;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#with&#34;&gt;&lt;code&gt;.with&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#when&#34;&gt;&lt;code&gt;.when&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#exhaustive&#34;&gt;&lt;code&gt;.exhaustive&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#otherwise&#34;&gt;&lt;code&gt;.otherwise&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#run&#34;&gt;&lt;code&gt;.run&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#ismatching&#34;&gt;&lt;code&gt;isMatching&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#patterns&#34;&gt;Patterns&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#literals&#34;&gt;Literals&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#wildcards&#34;&gt;Wildcards&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#objects&#34;&gt;Objects&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#tuples-arrays&#34;&gt;Tuples (arrays)&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#sets&#34;&gt;Sets&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#maps&#34;&gt;Maps&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Parray-patterns&#34;&gt;&lt;code&gt;P.array&lt;/code&gt; patterns&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Pwhen-patterns&#34;&gt;&lt;code&gt;P.when&lt;/code&gt; patterns&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Pnot-patterns&#34;&gt;&lt;code&gt;P.not&lt;/code&gt; patterns&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Pselect-patterns&#34;&gt;&lt;code&gt;P.select&lt;/code&gt; patterns&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Poptional-patterns&#34;&gt;&lt;code&gt;P.optional&lt;/code&gt; patterns&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Pinstanceof-patterns&#34;&gt;&lt;code&gt;P.instanceOf&lt;/code&gt; patterns&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Punion-patterns&#34;&gt;&lt;code&gt;P.union&lt;/code&gt; patterns&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Pintersection-patterns&#34;&gt;&lt;code&gt;P.intersection&lt;/code&gt; patterns&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#types&#34;&gt;Types&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#Pinfer&#34;&gt;&lt;code&gt;P.infer&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#PPattern&#34;&gt;&lt;code&gt;P.Pattern&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#type-inference&#34;&gt;Type inference&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#inspirations&#34;&gt;Inspirations&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Code Sandbox Examples&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx&#34;&gt;Basic Demo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx&#34;&gt;React gif fetcher app Demo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx&#34;&gt;React.useReducer Demo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx&#34;&gt;Handling untyped API response Demo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx&#34;&gt;&lt;code&gt;P.when&lt;/code&gt; Guard Demo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx&#34;&gt;&lt;code&gt;P.not&lt;/code&gt; Pattern Demo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx&#34;&gt;&lt;code&gt;P.select&lt;/code&gt; Pattern Demo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx&#34;&gt;&lt;code&gt;P.union&lt;/code&gt; Pattern Demo&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;As an example, we are going to create a state reducer for a frontend application fetching some data using an HTTP request.&lt;/p&gt; &#xA;&lt;h3&gt;Example: a state reducer with ts-pattern&lt;/h3&gt; &#xA;&lt;p&gt;Our application can be in four different states: &lt;code&gt;idle&lt;/code&gt;, &lt;code&gt;loading&lt;/code&gt;, &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt;. Depending on which state we are in, some events can occur. Here are all the possible types of event our application can respond to: &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;success&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;cancel&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;I use the word &lt;code&gt;event&lt;/code&gt; but you can replace it with &lt;code&gt;action&lt;/code&gt; if you are used to Redux&#39;s terminology.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;type State =&#xA;  | { status: &#39;idle&#39; }&#xA;  | { status: &#39;loading&#39;; startTime: number }&#xA;  | { status: &#39;success&#39;; data: string }&#xA;  | { status: &#39;error&#39;; error: Error };&#xA;&#xA;type Event =&#xA;  | { type: &#39;fetch&#39; }&#xA;  | { type: &#39;success&#39;; data: string }&#xA;  | { type: &#39;error&#39;; error: Error }&#xA;  | { type: &#39;cancel&#39; };&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Even though our application can handle 4 events, &lt;strong&gt;only a subset&lt;/strong&gt; of these events &lt;strong&gt;make sense for each given state&lt;/strong&gt;. For instance we can only &lt;code&gt;cancel&lt;/code&gt; a request if we are currently in the &lt;code&gt;loading&lt;/code&gt; state. To avoid unwanted state changes that could lead to bugs, we want to create a reducer function that &lt;strong&gt;matches on both the state and the event&lt;/strong&gt; and return a new state.&lt;/p&gt; &#xA;&lt;p&gt;This is a case where &lt;code&gt;match&lt;/code&gt; really shines. Instead of writing nested switch statements, we can do that in a very expressive way:&lt;/p&gt; &#xA;&lt;!-- prettier-ignore --&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;const reducer = (state: State, event: Event): State =&amp;gt;&#xA;  match&amp;lt;[State, Event], State&amp;gt;([state, event])&#xA;    .with(&#xA;      [{ status: &#39;loading&#39; }, { type: &#39;success&#39; }],&#xA;      ([, event]) =&amp;gt; ({&#xA;        status: &#39;success&#39;,&#xA;        data: event.data,&#xA;      })&#xA;    )&#xA;    .with(&#xA;      [{ status: &#39;loading&#39; }, { type: &#39;error&#39;, error: P.select() }],&#xA;      (error) =&amp;gt; ({&#xA;        status: &#39;error&#39;,&#xA;        error,&#xA;      })&#xA;    )&#xA;    .with(&#xA;      [{ status: P.not(&#39;loading&#39;) }, { type: &#39;fetch&#39; }],&#xA;      () =&amp;gt; ({&#xA;        status: &#39;loading&#39;,&#xA;        startTime: Date.now(),&#xA;      })&#xA;    )&#xA;    .with(&#xA;      [&#xA;        {&#xA;          status: &#39;loading&#39;,&#xA;          startTime: P.when((t) =&amp;gt; t + 2000 &amp;lt; Date.now()),&#xA;        },&#xA;        { type: &#39;cancel&#39; },&#xA;      ],&#xA;      () =&amp;gt; ({&#xA;        status: &#39;idle&#39;,&#xA;      })&#xA;    )&#xA;    .with(P._, () =&amp;gt; state)&#xA;    .exhaustive();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Let&#39;s go through this bit by bit:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;match(value)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;match&lt;/code&gt; takes a value and returns a &lt;a href=&#34;https://en.wikipedia.org/wiki/Builder_pattern&#34;&gt;&lt;em&gt;builder&lt;/em&gt;&lt;/a&gt; on which you can add your pattern matching cases.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;match&amp;lt;[State, Event], State&amp;gt;([state, event]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we wrap the state and the event objects in an array and we explicitly specify the type &lt;code&gt;[State, Event]&lt;/code&gt; to make sure it is interpreted as a &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#tuples-arrays&#34;&gt;Tuple&lt;/a&gt; by TypeScript, so we can match on each value separately.&lt;/p&gt; &#xA;&lt;p&gt;Most of the time, you don&#39;t need to specify the type of input and output with &lt;code&gt;match&amp;lt;Input, Output&amp;gt;(...)&lt;/code&gt; because &lt;code&gt;match&lt;/code&gt; is able to infer both of these types.&lt;/p&gt; &#xA;&lt;h3&gt;.with(pattern, handler)&lt;/h3&gt; &#xA;&lt;p&gt;Then we add a first &lt;code&gt;with&lt;/code&gt; clause:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;  .with(&#xA;    [{ status: &#39;loading&#39; }, { type: &#39;success&#39; }],&#xA;    ([state, event]) =&amp;gt; ({&#xA;      // `state` is inferred as { status: &#39;loading&#39; }&#xA;      // `event` is inferred as { type: &#39;success&#39;, data: string }&#xA;      status: &#39;success&#39;,&#xA;      data: event.data,&#xA;    })&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first argument is the &lt;strong&gt;pattern&lt;/strong&gt;: the &lt;strong&gt;shape of value&lt;/strong&gt; you expect for this branch.&lt;/p&gt; &#xA;&lt;p&gt;The second argument is the &lt;strong&gt;handler function&lt;/strong&gt;: the code &lt;strong&gt;branch&lt;/strong&gt; that will be called if the input value matches the pattern.&lt;/p&gt; &#xA;&lt;p&gt;The handler function takes the input value as first parameter with its type &lt;strong&gt;narrowed down&lt;/strong&gt; to what the pattern matches.&lt;/p&gt; &#xA;&lt;h3&gt;P.select(name?)&lt;/h3&gt; &#xA;&lt;p&gt;In the second &lt;code&gt;with&lt;/code&gt; clause, we use the &lt;code&gt;P.select&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;  .with(&#xA;    [&#xA;      { status: &#39;loading&#39; },&#xA;      { type: &#39;error&#39;, error: P.select() }&#xA;    ],&#xA;    (error) =&amp;gt; ({&#xA;      status: &#39;error&#39;,&#xA;      error,&#xA;    })&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;P.select()&lt;/code&gt; lets you &lt;strong&gt;extract&lt;/strong&gt; a piece of your input value and &lt;strong&gt;inject&lt;/strong&gt; it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.&lt;/p&gt; &#xA;&lt;p&gt;Since we didn&#39;t pass any name to &lt;code&gt;P.select()&lt;/code&gt;, It will inject the &lt;code&gt;event.error&lt;/code&gt; property as first argument to the handler function. Note that you can still access &lt;strong&gt;the full input value&lt;/strong&gt; with its type narrowed by your pattern as &lt;strong&gt;second argument&lt;/strong&gt; of the handler function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;  .with(&#xA;    [&#xA;      { status: &#39;loading&#39; },&#xA;      { type: &#39;error&#39;, error: P.select() }&#xA;    ],&#xA;    (error, stateAndEvent) =&amp;gt; {&#xA;      // error: Error&#xA;      // stateAndEvent: [{ status: &#39;loading&#39; }, { type: &#39;error&#39;, error: Error }]&#xA;    }&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In a pattern, we can only have a &lt;strong&gt;single&lt;/strong&gt; anonymous selection. If you need to select more properties on your input data structure, you will need to give them &lt;strong&gt;names&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;.with(&#xA;    [&#xA;      { status: &#39;success&#39;, data: P.select(&#39;prevData&#39;) },&#xA;      { type: &#39;error&#39;, error: P.select(&#39;err&#39;) }&#xA;    ],&#xA;    ({ prevData, err }) =&amp;gt; {&#xA;      // Do something with (prevData: string) and (err: Error).&#xA;    }&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each named selection will be injected inside a &lt;code&gt;selections&lt;/code&gt; object, passed as first argument to the handler function. Names can be any strings.&lt;/p&gt; &#xA;&lt;h3&gt;P.not(pattern)&lt;/h3&gt; &#xA;&lt;p&gt;If you need to match on everything &lt;strong&gt;but&lt;/strong&gt; a specific value, you can use a &lt;code&gt;P.not(&amp;lt;pattern&amp;gt;)&lt;/code&gt; pattern. it&#39;s a function taking a pattern and returning its opposite:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;  .with(&#xA;    [{ status: P.not(&#39;loading&#39;) }, { type: &#39;fetch&#39; }],&#xA;    () =&amp;gt; ({&#xA;      status: &#39;loading&#39;,&#xA;    })&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;P.when()&lt;/code&gt; and guard functions&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes, we need to make sure our input value respects a condition that can&#39;t be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use &lt;strong&gt;guard functions&lt;/strong&gt;: functions taking a value and returning a &lt;code&gt;boolean&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;With &lt;code&gt;ts-pattern&lt;/code&gt; there are two options to use a guard function:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;use &lt;code&gt;P.when(&amp;lt;guard function&amp;gt;)&lt;/code&gt; inside your pattern&lt;/li&gt; &#xA; &lt;li&gt;pass it as second parameter to &lt;code&gt;.with(...)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;using P.when(predicate)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;  .with(&#xA;    [&#xA;      {&#xA;        status: &#39;loading&#39;,&#xA;        startTime: P.when((t) =&amp;gt; t + 2000 &amp;lt; Date.now()),&#xA;      },&#xA;      { type: &#39;cancel&#39; },&#xA;    ],&#xA;    () =&amp;gt; ({&#xA;      status: &#39;idle&#39;,&#xA;    })&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Passing a guard function to &lt;code&gt;.with(...)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;.with&lt;/code&gt; optionally accepts a guard function as second parameter, between the &lt;code&gt;pattern&lt;/code&gt; and the &lt;code&gt;handler&lt;/code&gt; callback:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;  .with(&#xA;    [{ status: &#39;loading&#39; }, { type: &#39;cancel&#39; }],&#xA;    ([state, event]) =&amp;gt; state.startTime + 2000 &amp;lt; Date.now(),&#xA;    () =&amp;gt; ({&#xA;      status: &#39;idle&#39;&#xA;    })&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This pattern will only match if the guard function returns &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;the &lt;code&gt;P._&lt;/code&gt; wildcard&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;P._&lt;/code&gt; will match any value. You can use it either at the top level, or within another pattern.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;  .with(P._, () =&amp;gt; state)&#xA;&#xA;  // You could also use it inside another pattern:&#xA;  .with([P._, P._], () =&amp;gt; state)&#xA;&#xA;  // at any level:&#xA;  .with([P._, { type: P._ }], () =&amp;gt; state)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;.exhaustive(), .otherwise() and .run()&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;  .exhaustive();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;.exhaustive()&lt;/code&gt; &lt;strong&gt;executes&lt;/strong&gt; the pattern matching expression, and &lt;strong&gt;returns the result&lt;/strong&gt;. It also enables &lt;strong&gt;exhaustiveness checking&lt;/strong&gt;, making sure we don&#39;t forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.&lt;/p&gt; &#xA;&lt;p&gt;Note that exhaustive pattern matching is &lt;strong&gt;optional&lt;/strong&gt;. It comes with the trade-off of having &lt;strong&gt;longer compilation times&lt;/strong&gt; because the type checker has more work to do.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively you can use &lt;code&gt;.otherwise()&lt;/code&gt;, which takes an handler function returning a default value. &lt;code&gt;.otherwise(handler)&lt;/code&gt; is equivalent to &lt;code&gt;.with(P._, handler).exhaustive()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;  .otherwise(() =&amp;gt; state);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t want to use &lt;code&gt;.exhaustive()&lt;/code&gt; and also don&#39;t want to provide a default value with &lt;code&gt;.otherwise()&lt;/code&gt;, you can use &lt;code&gt;.run()&lt;/code&gt; instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;  .run();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s just like &lt;code&gt;.exhaustive()&lt;/code&gt;, but it&#39;s &lt;strong&gt;unsafe&lt;/strong&gt; and might throw runtime error if no branch matches your input value.&lt;/p&gt; &#xA;&lt;h3&gt;Matching several patterns&lt;/h3&gt; &#xA;&lt;p&gt;As you may know, &lt;code&gt;switch&lt;/code&gt; statements allow handling several cases with the same code block:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;switch (type) {&#xA;  case &#39;text&#39;:&#xA;  case &#39;span&#39;:&#xA;  case &#39;p&#39;:&#xA;    return &#39;text&#39;;&#xA;&#xA;  case &#39;btn&#39;:&#xA;  case &#39;button&#39;:&#xA;    return &#39;button&#39;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, ts-pattern lets you pass several patterns to &lt;code&gt;.with()&lt;/code&gt; and if one of these patterns matches your input, the handler function will be called:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const sanitize = (name: string) =&amp;gt;&#xA;  match(name)&#xA;    .with(&#39;text&#39;, &#39;span&#39;, &#39;p&#39;, () =&amp;gt; &#39;text&#39;)&#xA;    .with(&#39;btn&#39;, &#39;button&#39;, () =&amp;gt; &#39;button&#39;)&#xA;    .otherwise(() =&amp;gt; name);&#xA;&#xA;sanitize(&#39;span&#39;); // &#39;text&#39;&#xA;sanitize(&#39;p&#39;); // &#39;text&#39;&#xA;sanitize(&#39;button&#39;); // &#39;button&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.&lt;/p&gt; &#xA;&lt;h2&gt;API Reference&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;match&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;match(value);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create a &lt;code&gt;Match&lt;/code&gt; object on which you can later call &lt;code&gt;.with&lt;/code&gt;, &lt;code&gt;.when&lt;/code&gt;, &lt;code&gt;.otherwise&lt;/code&gt; and &lt;code&gt;.run&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Signature&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function match&amp;lt;TInput, TOutput&amp;gt;(input: TInput): Match&amp;lt;TInput, TOutput&amp;gt;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Arguments&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;input&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Required&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;the input value your patterns will be tested against.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;.with&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;match(...)&#xA;  .with(pattern, [...patterns], handler)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Signature&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function with(&#xA;  pattern: Pattern&amp;lt;TInput&amp;gt;,&#xA;  handler: (selections: Selections&amp;lt;TInput&amp;gt;, value: TInput) =&amp;gt; TOutput&#xA;): Match&amp;lt;TInput, TOutput&amp;gt;;&#xA;&#xA;// Overload for multiple patterns&#xA;function with(&#xA;  pattern1: Pattern&amp;lt;TInput&amp;gt;,&#xA;  ...patterns: Pattern&amp;lt;TInput&amp;gt;[],&#xA;  // no selection object is provided when using multiple patterns&#xA;  handler: (value: TInput) =&amp;gt; TOutput&#xA;): Match&amp;lt;TInput, TOutput&amp;gt;;&#xA;&#xA;// Overload for guard functions&#xA;function with(&#xA;  pattern: Pattern&amp;lt;TInput&amp;gt;,&#xA;  when: (value: TInput) =&amp;gt; unknown,&#xA;  handler: (&#xA;    selection: Selection&amp;lt;TInput&amp;gt;,&#xA;    value: TInput&#xA;  ) =&amp;gt; TOutput&#xA;): Match&amp;lt;TInput, TOutput&amp;gt;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Arguments&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;pattern: Pattern&amp;lt;TInput&amp;gt;&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Required&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;The pattern your input must match for the handler to be called.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#patterns&#34;&gt;See all valid patterns below&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;If you provide several patterns before providing the &lt;code&gt;handler&lt;/code&gt;, the &lt;code&gt;with&lt;/code&gt; clause will match if one of the patterns matches.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;when: (value: TInput) =&amp;gt; unknown&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Optional&lt;/li&gt; &#xA;   &lt;li&gt;Additional condition the input must satisfy for the handler to be called.&lt;/li&gt; &#xA;   &lt;li&gt;The input will match if your guard function returns a truthy value.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TInput&lt;/code&gt; might be narrowed to a more precise type using the &lt;code&gt;pattern&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;handler: (value: TInput, selections: Selections&amp;lt;TInput&amp;gt;) =&amp;gt; TOutput&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Required&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Function called when the match conditions are satisfied.&lt;/li&gt; &#xA;   &lt;li&gt;All handlers on a single &lt;code&gt;match&lt;/code&gt; case must return values of the same type, &lt;code&gt;TOutput&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TInput&lt;/code&gt; might be narrowed to a more precise type using the &lt;code&gt;pattern&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;selections&lt;/code&gt; is an object of properties selected from the input with the &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#select-patterns&#34;&gt;&lt;code&gt;select&lt;/code&gt; function&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;.when&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;match(...)&#xA;  .when(predicate, handler)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Signature&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function when(&#xA;  predicate: (value: TInput) =&amp;gt; unknown,&#xA;  handler: (value: TInput) =&amp;gt; TOutput&#xA;): Match&amp;lt;TInput, TOutput&amp;gt;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Arguments&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;predicate: (value: TInput) =&amp;gt; unknown&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Required&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Condition the input must satisfy for the handler to be called.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;handler: (value: TInput) =&amp;gt; TOutput&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Required&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Function called when the predicate condition is satisfied.&lt;/li&gt; &#xA;   &lt;li&gt;All handlers on a single &lt;code&gt;match&lt;/code&gt; case must return values of the same type, &lt;code&gt;TOutput&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;.exhaustive&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;match(...)&#xA;  .with(...)&#xA;  .exhaustive()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Runs the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.&lt;/p&gt; &#xA;&lt;h4&gt;Signature&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function exhaustive(): IOutput;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Example&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;type Permission = &#39;editor&#39; | &#39;viewer&#39;;&#xA;type Plan = &#39;basic&#39; | &#39;pro&#39;;&#xA;&#xA;const fn = (org: Plan, user: Permission) =&amp;gt;&#xA;  match([org, user] as const)&#xA;    .with([&#39;basic&#39;, &#39;viewer&#39;], () =&amp;gt; {})&#xA;    .with([&#39;basic&#39;, &#39;editor&#39;], () =&amp;gt; {})&#xA;    .with([&#39;pro&#39;, &#39;viewer&#39;], () =&amp;gt; {})&#xA;    // Fails with `NonExhaustiveError&amp;lt;[&#39;pro&#39;, &#39;editor&#39;]&amp;gt;`&#xA;    // because the `[&#39;pro&#39;, &#39;editor&#39;]` case isn&#39;t handled.&#xA;    .exhaustive();&#xA;&#xA;const fn2 = (org: Plan, user: Permission) =&amp;gt;&#xA;  match([org, user] as const)&#xA;    .with([&#39;basic&#39;, &#39;viewer&#39;], () =&amp;gt; {})&#xA;    .with([&#39;basic&#39;, &#39;editor&#39;], () =&amp;gt; {})&#xA;    .with([&#39;pro&#39;, &#39;viewer&#39;], () =&amp;gt; {})&#xA;    .with([&#39;pro&#39;, &#39;editor&#39;], () =&amp;gt; {})&#xA;    .exhaustive(); // Works!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.otherwise&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;match(...)&#xA;  .with(...)&#xA;  .otherwise(defaultHandler)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Runs the pattern-matching expression with a default handler which will be called if no previous &lt;code&gt;.with()&lt;/code&gt; clause match the input value, and returns the result.&lt;/p&gt; &#xA;&lt;h4&gt;Signature&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function otherwise(defaultHandler: (value: TInput) =&amp;gt; TOutput): TOutput;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Arguments&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;defaultHandler: (value: TInput) =&amp;gt; TOutput&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Required&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Function called if no pattern matched the input value.&lt;/li&gt; &#xA;   &lt;li&gt;Think of it as the &lt;code&gt;default:&lt;/code&gt; case of &lt;code&gt;switch&lt;/code&gt; statements.&lt;/li&gt; &#xA;   &lt;li&gt;All handlers on a single &lt;code&gt;match&lt;/code&gt; case must return values of the same type, &lt;code&gt;TOutput&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;.run&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;match(...)&#xA;  .with(...)&#xA;  .run()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Runs the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as &lt;code&gt;exhaustive()&lt;/code&gt;. However, unlike &lt;code&gt;.exhaustive()&lt;/code&gt;, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.&lt;/p&gt; &#xA;&lt;h4&gt;Signature&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function run(): TOutput;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;isMatching&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;if (isMatching(pattern, value))  {&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;isMatching&lt;/code&gt; is a type guard function which checks if a pattern matches a given value. It is &lt;em&gt;curried&lt;/em&gt;, which means it can be used in two ways.&lt;/p&gt; &#xA;&lt;p&gt;With a single argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { isMatching, P } from &#39;ts-pattern&#39;;&#xA;&#xA;const isBlogPost = isMatching({&#xA;  title: P.string,&#xA;  description: P.string,&#xA;});&#xA;&#xA;if (isBlogPost(value)) {&#xA;  // value: { title: string, description: string }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With two arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const blogPostPattern = {&#xA;  title: P.string,&#xA;  description: P.string,&#xA;};&#xA;&#xA;if (isMatching(blogPostPattern, value)) {&#xA;  // value: { title: string, description: string }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Signature&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export function isMatching&amp;lt;p extends Pattern&amp;lt;any&amp;gt;&amp;gt;(&#xA;  pattern: p&#xA;): (value: any) =&amp;gt; value is InvertPattern&amp;lt;p&amp;gt;;&#xA;export function isMatching&amp;lt;p extends Pattern&amp;lt;any&amp;gt;&amp;gt;(&#xA;  pattern: p,&#xA;  value: any&#xA;): value is InvertPattern&amp;lt;p&amp;gt;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Arguments&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;pattern: Pattern&amp;lt;any&amp;gt;&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Required&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;The pattern a value should match.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value?: any&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Optional&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;if a value is given as second argument, &lt;code&gt;isMatching&lt;/code&gt; will return a boolean telling us whether the pattern matches the value or not.&lt;/li&gt; &#xA;   &lt;li&gt;if we only give the pattern to the function, &lt;code&gt;isMatching&lt;/code&gt; will return another &lt;strong&gt;type guard function&lt;/strong&gt; taking a value and returning a boolean which tells us whether the pattern matches the value or not.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Patterns&lt;/h2&gt; &#xA;&lt;p&gt;A pattern is a description of the expected shape of your input value.&lt;/p&gt; &#xA;&lt;p&gt;Patterns can be regular JavaScript values (&lt;code&gt;&#34;some string&#34;&lt;/code&gt;, &lt;code&gt;10&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, ...), data structures (&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#objects&#34;&gt;objects&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#tuples-arrays&#34;&gt;arrays&lt;/a&gt;, ...), wildcards (&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#P_-wildcard&#34;&gt;&lt;code&gt;P._&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#pstring-wildcard&#34;&gt;&lt;code&gt;P.string&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#pnumber-wildcard&#34;&gt;&lt;code&gt;P.number&lt;/code&gt;&lt;/a&gt;, ...), or special matcher functions (&lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#pnot-patterns&#34;&gt;&lt;code&gt;P.not&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#pwhen-patterns&#34;&gt;&lt;code&gt;P.when&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/gvergnaud/ts-pattern/main/#pselect-patterns&#34;&gt;&lt;code&gt;P.select&lt;/code&gt;&lt;/a&gt;, ...).&lt;/p&gt; &#xA;&lt;p&gt;All wildcards and matcher functions can be imported either as &lt;code&gt;Pattern&lt;/code&gt; or as &lt;code&gt;P&lt;/code&gt; from the &lt;code&gt;ts-pattern&lt;/code&gt; module.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, Pattern } from &#39;ts-pattern&#39;;&#xA;&#xA;const toString = (value: unknown): string =&amp;gt;&#xA;  match(value)&#xA;    .with(Pattern.string, (str) =&amp;gt; str)&#xA;    .with(Pattern.number, (num) =&amp;gt; num.toFixed())&#xA;    .with(Pattern.boolean, (bool) =&amp;gt; `${bool}`)&#xA;    .otherwise(() =&amp;gt; &#39;Unknown&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;const toString = (value: unknown): string =&amp;gt;&#xA;  match(value)&#xA;    .with(P.string, (str) =&amp;gt; str)&#xA;    .with(P.number, (num) =&amp;gt; num.toFixed())&#xA;    .with(P.boolean, (bool) =&amp;gt; `${bool}`)&#xA;    .otherwise(() =&amp;gt; &#39;Unknown&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your input isn&#39;t typed, (if it&#39;s a &lt;code&gt;any&lt;/code&gt; or a &lt;code&gt;unknown&lt;/code&gt;), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.&lt;/p&gt; &#xA;&lt;h3&gt;Literals&lt;/h3&gt; &#xA;&lt;p&gt;Literals are primitive JavaScript values, like &lt;code&gt;numbers&lt;/code&gt;, &lt;code&gt;strings&lt;/code&gt;, &lt;code&gt;booleans&lt;/code&gt;, &lt;code&gt;bigints&lt;/code&gt;, &lt;code&gt;symbols&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;NaN&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match } from &#39;ts-pattern&#39;;&#xA;&#xA;const input: unknown = 2;&#xA;&#xA;const output = match(input)&#xA;  .with(2, () =&amp;gt; &#39;number: two&#39;)&#xA;  .with(true, () =&amp;gt; &#39;boolean: true&#39;)&#xA;  .with(&#39;hello&#39;, () =&amp;gt; &#39;string: hello&#39;)&#xA;  .with(undefined, () =&amp;gt; &#39;undefined&#39;)&#xA;  .with(null, () =&amp;gt; &#39;null&#39;)&#xA;  .with(NaN, () =&amp;gt; &#39;number: NaN&#39;)&#xA;  .with(20n, () =&amp;gt; &#39;bigint: 20n&#39;)&#xA;  .otherwise(() =&amp;gt; &#39;something else&#39;);&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;two&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Wildcards&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;code&gt;P._&lt;/code&gt; wildcard&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;P._&lt;/code&gt; pattern will match any value. You can also use &lt;code&gt;P.any&lt;/code&gt;, which is an alias to &lt;code&gt;P._&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;const input = &#39;hello&#39;;&#xA;&#xA;const output = match(input)&#xA;  .with(P._, () =&amp;gt; &#39;It will always match&#39;)&#xA;  // OR&#xA;  .with(P.any, () =&amp;gt; &#39;It will always match&#39;)&#xA;  .otherwise(() =&amp;gt; &#39;This string will never be used&#39;);&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;It will always match&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;P.string&lt;/code&gt; wildcard&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;P.string&lt;/code&gt; pattern will match any value of type &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;const input = &#39;hello&#39;;&#xA;&#xA;const output = match(input)&#xA;  .with(&#39;bonjour&#39;, () =&amp;gt; &#39;Won‘t match&#39;)&#xA;  .with(P.string, () =&amp;gt; &#39;it is a string!&#39;)&#xA;  .exhaustive();&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;it is a string!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;P.number&lt;/code&gt; wildcard&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;P.number&lt;/code&gt; pattern will match any value of type &lt;code&gt;number&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;const input = 2;&#xA;&#xA;const output = match&amp;lt;number | string&amp;gt;(input)&#xA;  .with(P.string, () =&amp;gt; &#39;it is a string!&#39;)&#xA;  .with(P.number, () =&amp;gt; &#39;it is a number!&#39;)&#xA;  .exhaustive();&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;it is a number!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;P.boolean&lt;/code&gt; wildcard&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;P.boolean&lt;/code&gt; pattern will match any value of type &lt;code&gt;boolean&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;const input = true;&#xA;&#xA;const output = match&amp;lt;number | string | boolean&amp;gt;(input)&#xA;  .with(P.string, () =&amp;gt; &#39;it is a string!&#39;)&#xA;  .with(P.number, () =&amp;gt; &#39;it is a number!&#39;)&#xA;  .with(P.boolean, () =&amp;gt; &#39;it is a boolean!&#39;)&#xA;  .exhaustive();&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;it is a boolean!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;P.nullish&lt;/code&gt; wildcard&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;P.nullish&lt;/code&gt; pattern will match any value of type &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Even though &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; can be used as literal patterns, sometimes they appear in a union together (e.g. &lt;code&gt;null | undefined | string&lt;/code&gt;) and you may want to treat them as equivalent using &lt;code&gt;P.nullish&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;const input = null;&#xA;&#xA;const output = match&amp;lt;number | null | undefined&amp;gt;(input)&#xA;  .with(P.number, () =&amp;gt; &#39;it is a number!&#39;)&#xA;  .with(P.nullish, () =&amp;gt; &#39;it is either null or undefined!&#39;)&#xA;  .with(null, () =&amp;gt; &#39;it is null!&#39;)&#xA;  .with(undefined, () =&amp;gt; &#39;it is undefined!&#39;)&#xA;  .exhaustive();&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;it is either null or undefined!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;P.bigint&lt;/code&gt; wildcard&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;P.bigint&lt;/code&gt; pattern will match any value of type &lt;code&gt;bigint&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;const input = 20000000n;&#xA;&#xA;const output = match&amp;lt;bigint | null&amp;gt;(input)&#xA;  .with(P.bigint, () =&amp;gt; &#39;it is a bigint!&#39;)&#xA;  .otherwise(() =&amp;gt; &#39;?&#39;);&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;it is a bigint!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;P.symbol&lt;/code&gt; wildcard&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;P.symbol&lt;/code&gt; pattern will match any value of type &lt;code&gt;symbol&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;const input = Symbol(&#39;some symbol&#39;);&#xA;&#xA;const output = match&amp;lt;symbol | null&amp;gt;(input)&#xA;  .with(P.symbol, () =&amp;gt; &#39;it is a symbol!&#39;)&#xA;  .otherwise(() =&amp;gt; &#39;?&#39;);&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;it is a symbol!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Objects&lt;/h3&gt; &#xA;&lt;p&gt;Patterns can be objects containing sub-patterns. An object pattern will match If and only if the input value &lt;strong&gt;is an object&lt;/strong&gt;, contains &lt;strong&gt;all properties&lt;/strong&gt; the pattern defines and each property &lt;strong&gt;matches&lt;/strong&gt; the corresponding sub-pattern.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match } from &#39;ts-pattern&#39;;&#xA;&#xA;type Input =&#xA;  | { type: &#39;user&#39;; name: string }&#xA;  | { type: &#39;image&#39;; src: string }&#xA;  | { type: &#39;video&#39;; seconds: number };&#xA;&#xA;let input: Input = { type: &#39;user&#39;, name: &#39;Gabriel&#39; };&#xA;&#xA;const output = match(input)&#xA;  .with({ type: &#39;image&#39; }, () =&amp;gt; &#39;image&#39;)&#xA;  .with({ type: &#39;video&#39;, seconds: 10 }, () =&amp;gt; &#39;video of 10 seconds.&#39;)&#xA;  .with({ type: &#39;user&#39; }, ({ name }) =&amp;gt; `user of name: ${name}`)&#xA;  .otherwise(() =&amp;gt; &#39;something else&#39;);&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;user of name: Gabriel&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tuples (arrays)&lt;/h3&gt; &#xA;&lt;p&gt;In TypeScript, &lt;a href=&#34;https://en.wikipedia.org/wiki/Tuple&#34;&gt;Tuples&lt;/a&gt; are arrays with a fixed number of elements which can be of different types. You can pattern-match on tuples using a tuple pattern. A tuple pattern will match if the input value &lt;strong&gt;is an array of the same length&lt;/strong&gt;, and each item match the corresponding sub-pattern.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;type Input =&#xA;  | [number, &#39;+&#39;, number]&#xA;  | [number, &#39;-&#39;, number]&#xA;  | [number, &#39;*&#39;, number]&#xA;  | [&#39;-&#39;, number];&#xA;&#xA;const input: Input = [3, &#39;*&#39;, 4];&#xA;&#xA;const output = match(input)&#xA;  .with([P._, &#39;+&#39;, P._], ([x, , y]) =&amp;gt; x + y)&#xA;  .with([P._, &#39;-&#39;, P._], ([x, , y]) =&amp;gt; x - y)&#xA;  .with([P._, &#39;*&#39;, P._], ([x, , y]) =&amp;gt; x * y)&#xA;  .with([&#39;-&#39;, P._], ([, x]) =&amp;gt; -x)&#xA;  .otherwise(() =&amp;gt; NaN);&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; 12&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;P.array&lt;/code&gt; patterns&lt;/h3&gt; &#xA;&lt;p&gt;To match on arrays of unknown size, you can use &lt;code&gt;P.array(subpattern)&lt;/code&gt;. It takes a sub-pattern, and will match if &lt;strong&gt;all elements&lt;/strong&gt; in the input array match this sub-pattern.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;type Input = { title: string; content: string }[];&#xA;&#xA;let input: Input = [&#xA;  { title: &#39;Hello world!&#39;, content: &#39;This is a very interesting content&#39; },&#xA;  { title: &#39;Bonjour!&#39;, content: &#39;This is a very interesting content too&#39; },&#xA;];&#xA;&#xA;const output = match(input)&#xA;  .with(&#xA;    P.array({ title: P.string, content: P.string }),&#xA;    (posts) =&amp;gt; &#39;a list of posts!&#39;&#xA;  )&#xA;  .otherwise(() =&amp;gt; &#39;something else&#39;);&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;a list of posts!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sets&lt;/h3&gt; &#xA;&lt;p&gt;Patterns can be Sets.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;type Input = Set&amp;lt;string | number&amp;gt;;&#xA;&#xA;const input: Input = new Set([1, 2, 3]);&#xA;&#xA;const output = match(input)&#xA;  .with(new Set([1, &#39;hello&#39;]), (set) =&amp;gt; `Set contains 1 and &#39;hello&#39;`)&#xA;  .with(new Set([1, 2]), (set) =&amp;gt; `Set contains 1 and 2`)&#xA;  .with(new Set([P.string]), (set) =&amp;gt; `Set contains only strings`)&#xA;  .with(new Set([P.number]), (set) =&amp;gt; `Set contains only numbers`)&#xA;  .otherwise(() =&amp;gt; &#39;&#39;);&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;Set contains 1 and 2&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If a Set pattern contains one single wildcard pattern, it will match if each value in the input set match the wildcard.&lt;/p&gt; &#xA;&lt;p&gt;If a Set pattern contains several values, it will match if the input Set contains each of these values.&lt;/p&gt; &#xA;&lt;h3&gt;Maps&lt;/h3&gt; &#xA;&lt;p&gt;Patterns can be Maps. They match if the input is a Map, and if each value match the corresponding sub-pattern.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;type Input = Map&amp;lt;string, string | number&amp;gt;;&#xA;&#xA;const input: Input = new Map([&#xA;  [&#39;a&#39;, 1],&#xA;  [&#39;b&#39;, 2],&#xA;  [&#39;c&#39;, 3],&#xA;]);&#xA;&#xA;const output = match(input)&#xA;  .with(new Map([[&#39;b&#39;, 2]]), (map) =&amp;gt; `map.get(&#39;b&#39;) is 2`)&#xA;  .with(new Map([[&#39;a&#39;, P.string]]), (map) =&amp;gt; `map.get(&#39;a&#39;) is a string`)&#xA;  .with(&#xA;    new Map([&#xA;      [&#39;a&#39;, P.number],&#xA;      [&#39;c&#39;, P.number],&#xA;    ]),&#xA;    (map) =&amp;gt; `map.get(&#39;a&#39;) and map.get(&#39;c&#39;) are number`&#xA;  )&#xA;  .otherwise(() =&amp;gt; &#39;&#39;);&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;map.get(&#39;b&#39;) is 2&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;P.when&lt;/code&gt; patterns&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;P.when&lt;/code&gt; lets you define your own logic to check if the pattern should match or not. If the &lt;code&gt;predicate&lt;/code&gt; function given to when returns a truthy value, then the pattern will match for this input.&lt;/p&gt; &#xA;&lt;p&gt;Note that you can narrow down the type of your input by providing a &lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards&#34;&gt;Type Guard function&lt;/a&gt; to &lt;code&gt;P.when&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;type Input = { score: number };&#xA;&#xA;const output = match({ score: 10 })&#xA;  .with(&#xA;    {&#xA;      score: P.when((score): score is 5 =&amp;gt; score === 5),&#xA;    },&#xA;    (input) =&amp;gt; &#39;😐&#39; // input is inferred as { score: 5 }&#xA;  )&#xA;  .with({ score: P.when((score) =&amp;gt; score &amp;lt; 5) }, () =&amp;gt; &#39;😞&#39;)&#xA;  .with({ score: P.when((score) =&amp;gt; score &amp;gt; 5) }, () =&amp;gt; &#39;🙂&#39;)&#xA;  .run();&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;🙂&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;P.not&lt;/code&gt; patterns&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;P.not&lt;/code&gt; lets you match on everything &lt;strong&gt;but&lt;/strong&gt; a specific value. it&#39;s a function taking a pattern and returning the opposite pattern.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;type Input = boolean | number;&#xA;&#xA;const toNumber = (input: Input) =&amp;gt;&#xA;  match(input)&#xA;    .with(P.not(P.boolean), (n) =&amp;gt; n) // n: number&#xA;    .with(true, () =&amp;gt; 1)&#xA;    .with(false, () =&amp;gt; 0)&#xA;    .run();&#xA;&#xA;console.log(toNumber(2));&#xA;// =&amp;gt; 2&#xA;console.log(toNumber(true));&#xA;// =&amp;gt; 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;P.select&lt;/code&gt; patterns&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;P.select&lt;/code&gt; lets you pick a piece of your input data-structure and injects it in your handler function.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s especially useful when pattern matching on deep data structure to avoid the hassle of destructuring it in the handler function.&lt;/p&gt; &#xA;&lt;p&gt;Selections can be either named (with &lt;code&gt;P.select(&#39;someName&#39;)&lt;/code&gt;) or anonymous (with &lt;code&gt;P.select()&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;You can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;type Input =&#xA;  | { type: &#39;post&#39;; user: { name: string } }&#xA;  | { ... };&#xA;&#xA;const input: Input = { type: &#39;post&#39;, user: { name: &#39;Gabriel&#39; } }&#xA;&#xA;const output = match(input)&#xA;    .with(&#xA;      { type: &#39;post&#39;, user: { name: P.select() } },&#xA;      username =&amp;gt; username // username: string&#xA;    )&#xA;    .otherwise(() =&amp;gt; &#39;anonymous&#39;);&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;Gabriel&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to select several things inside your input data structure, you can name your selections by giving a string to &lt;code&gt;P.select(&amp;lt;name&amp;gt;)&lt;/code&gt;. Each selection will be passed as first argument to your handler in an object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;type Input =&#xA;  | { type: &#39;post&#39;; user: { name: string }, content: string }&#xA;  | { ... };&#xA;&#xA;const input: Input = { type: &#39;post&#39;, user: { name: &#39;Gabriel&#39; }, content: &#39;Hello!&#39; }&#xA;&#xA;const output = match(input)&#xA;    .with(&#xA;      { type: &#39;post&#39;, user: { name: P.select(&#39;name&#39;) }, content: P.select(&#39;body&#39;) },&#xA;      ({ name, body }) =&amp;gt; `${name} wrote &#34;${body}&#34;`&#xA;    )&#xA;    .otherwise(() =&amp;gt; &#39;&#39;);&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;Gabriel wrote &#34;Hello!&#34;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also pass a sub-pattern to &lt;code&gt;P.select&lt;/code&gt; if you want it to only select values which match this sub-pattern:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;type User = { age: number; name: string };&#xA;type Post = { body: string };&#xA;type Input = { author: User; content: Post };&#xA;&#xA;declare const input: Input;&#xA;&#xA;const output = match(input)&#xA;  .with(&#xA;    {&#xA;      author: P.select({ age: P.when((age) =&amp;gt; age &amp;gt; 18) }),&#xA;    },&#xA;    (author) =&amp;gt; author // author: User&#xA;  )&#xA;  .with(&#xA;    {&#xA;      author: P.select(&#39;author&#39;, { age: P.when((age) =&amp;gt; age &amp;gt; 18) }),&#xA;      content: P.select(),&#xA;    },&#xA;    ({ author, content }) =&amp;gt; author // author: User, content: Post&#xA;  )&#xA;  .otherwise(() =&amp;gt; &#39;anonymous&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;P.optional&lt;/code&gt; patterns&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;P.optional(subpattern)&lt;/code&gt; lets you annotate a key in an object pattern as being optional, but if it is defined it should match a given sub-pattern.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;type Input = { key?: string | number };&#xA;&#xA;const output = match(input)&#xA;  .with({ key: P.optional(P.string) }, (a) =&amp;gt; {&#xA;    return a.key; // string | undefined&#xA;  })&#xA;  .with({ key: P.optional(P.number) }, (a) =&amp;gt; {&#xA;    return a.key; // number | undefined&#xA;  })&#xA;  .exhaustive();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;P.instanceOf&lt;/code&gt; patterns&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;P.instanceOf&lt;/code&gt; function lets you build a pattern to check if a value is an instance of a class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;class A {&#xA;  a = &#39;a&#39;;&#xA;}&#xA;class B {&#xA;  b = &#39;b&#39;;&#xA;}&#xA;&#xA;type Input = { value: A | B };&#xA;&#xA;const input: Input = { value: new A() };&#xA;&#xA;const output = match(input)&#xA;  .with({ value: P.instanceOf(A) }, (a) =&amp;gt; {&#xA;    return &#39;instance of A!&#39;;&#xA;  })&#xA;  .with({ value: P.instanceOf(B) }, (b) =&amp;gt; {&#xA;    return &#39;instance of B!&#39;;&#xA;  })&#xA;  .exhaustive();&#xA;&#xA;console.log(output);&#xA;// =&amp;gt; &#39;instance of A!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;P.union&lt;/code&gt; patterns&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;P.union(...subpatterns)&lt;/code&gt; lets you test several patterns and will match if one of these patterns do. It&#39;s particularly handy when you want to handle some cases of a union type in the same code branch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { match, P } from &#39;ts-pattern&#39;;&#xA;&#xA;type Input =&#xA;  | { type: &#39;user&#39;; name: string }&#xA;  | { type: &#39;org&#39;; name: string }&#xA;  | { type: &#39;text&#39;; content: string }&#xA;  | { type: &#39;img&#39;; src: string };&#xA;&#xA;declare const input: Input;&#xA;&#xA;const output = match(input)&#xA;  .with({ type: P.union(&#39;user&#39;, &#39;org&#39;) }, (userOrOrg) =&amp;gt; {&#xA;    // userOrOrg: User | Org&#xA;    return userOrOrg.name;&#xA;  })&#xA;  .otherwise(() =&amp;gt; &#39;&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;P.intersection&lt;/code&gt; patterns&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;P.intersection(...subpatterns)&lt;/code&gt; lets you ensure that the input matches &lt;strong&gt;all&lt;/strong&gt; sub-patterns passed as parameters.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class A {&#xA;  constructor(public foo: &#39;bar&#39; | &#39;baz&#39;) {}&#xA;}&#xA;&#xA;class B {&#xA;  constructor(public str: string) {}&#xA;}&#xA;&#xA;type Input = { prop: A | B };&#xA;&#xA;declare const input: Input;&#xA;&#xA;const output = match(input)&#xA;  .with(&#xA;    { prop: P.intersection(P.instanceOf(A), { foo: &#39;bar&#39; }) },&#xA;    ({ prop }) =&amp;gt; prop.foo // prop: A &amp;amp; { foo: &#39;bar&#39; }&#xA;  )&#xA;  .with(&#xA;    { prop: P.intersection(P.instanceOf(A), { foo: &#39;baz&#39; }) },&#xA;    ({ prop }) =&amp;gt; prop.foo // prop: A &amp;amp; { foo: &#39;baz&#39; }&#xA;  )&#xA;  .otherwise(() =&amp;gt; &#39;&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Types&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;P.infer&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;P.infer&amp;lt;typeof somePattern&amp;gt;&lt;/code&gt; lets you infer a type of value from a type of pattern.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s particularly useful when validating an API response.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const postPattern = {&#xA;  title: P.string,&#xA;  content: P.string,&#xA;  likeCount: P.number,&#xA;  author: {&#xA;    name: P.string,&#xA;  },&#xA;};&#xA;&#xA;type Post = P.infer&amp;lt;typeof postPattern&amp;gt;;&#xA;&#xA;// posts: Post[]&#xA;const posts = await fetch(someUrl)&#xA;  .then((res) =&amp;gt; res.json())&#xA;  .then((res: unknown): Post[] =&amp;gt;&#xA;    isMatching({ data: P.array(postPattern) }, res) ? res.data : []&#xA;  );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;P.Pattern&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;P.Pattern&amp;lt;T&amp;gt;&lt;/code&gt; is the type of all possible pattern for a generic type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;type User = { name: string; age: number };&#xA;&#xA;const userPattern: Pattern&amp;lt;User&amp;gt; = {&#xA;  name: &#39;Alice&#39;,&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Type inference&lt;/h3&gt; &#xA;&lt;p&gt;TS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.&lt;/p&gt; &#xA;&lt;p&gt;Here are some examples of TS-Pattern&#39;s inference features.&lt;/p&gt; &#xA;&lt;h4&gt;Type narrowing&lt;/h4&gt; &#xA;&lt;p&gt;If you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;type Text = { type: &#39;text&#39;; data: string };&#xA;type Img = { type: &#39;img&#39;; data: { src: string; alt: string } };&#xA;type Video = { type: &#39;video&#39;; data: { src: string; format: &#39;mp4&#39; | &#39;webm&#39; } };&#xA;type Content = Text | Img | Video;&#xA;&#xA;const formatContent = (content: Content): string =&amp;gt;&#xA;  match(content)&#xA;    .with({ type: &#39;text&#39; }, (text /* : Text */) =&amp;gt; &#39;&amp;lt;p&amp;gt;...&amp;lt;/p&amp;gt;&#39;)&#xA;    .with({ type: &#39;img&#39; }, (img /* : Img */) =&amp;gt; &#39;&amp;lt;img ... /&amp;gt;&#39;)&#xA;    .with({ type: &#39;video&#39; }, (video /* : Video */) =&amp;gt; &#39;&amp;lt;video ... /&amp;gt;&#39;)&#xA;    .with(&#xA;      { type: &#39;img&#39; },&#xA;      { type: &#39;video&#39; },&#xA;      (video /* : Img | Video */) =&amp;gt; &#39;img or video&#39;&#xA;    )&#xA;    .with(&#xA;      { type: P.union(&#39;img&#39;, &#39;video&#39;) },&#xA;      (video /* : Img | Video */) =&amp;gt; &#39;img or video&#39;&#xA;    )&#xA;    .exhaustive();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you use &lt;code&gt;P.select&lt;/code&gt;, TS-Pattern will pick up the type of the property you selected, and will inferyour handler&#39;s type accordingly.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const formatContent = (content: Content): string =&amp;gt;&#xA;  match(content)&#xA;    .with(&#xA;      { type: &#39;text&#39;, data: P.select() },&#xA;      (content /* : string */) =&amp;gt; &#39;&amp;lt;p&amp;gt;...&amp;lt;/p&amp;gt;&#39;&#xA;    )&#xA;    .with(&#xA;      { type: &#39;video&#39;, data: { format: P.select() } },&#xA;      (format /* : &#39;mp4&#39; | &#39;webm&#39; */) =&amp;gt; &#39;&amp;lt;video ... /&amp;gt;&#39;&#xA;    )&#xA;    .with(&#xA;      { type: P.union(&#39;img&#39;, &#39;video&#39;), data: P.select() },&#xA;      (data /* : Img[&#39;data&#39;] | Video[&#39;data&#39;] */) =&amp;gt; &#39;img or video&#39;&#xA;    )&#xA;    .exhaustive();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the function given to &lt;code&gt;P.when&lt;/code&gt; is a &lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates&#34;&gt;Type Guard&lt;/a&gt;, TS-Pattern will use the type guard&#39;s return type to narrow the input.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const isString = (x: unknown): x is string =&amp;gt; typeof x === &#39;string&#39;;&#xA;&#xA;const isNumber = (x: unknown): x is number =&amp;gt; typeof x === &#39;number&#39;;&#xA;&#xA;const fn = (input: { id: number | string }) =&amp;gt;&#xA;  match(input)&#xA;    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) =&amp;gt; &#39;yes&#39;)&#xA;    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) =&amp;gt; &#39;yes&#39;)&#xA;    .exhaustive();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Exhaustiveness checking&lt;/h4&gt; &#xA;&lt;p&gt;If your data structure contains several union types, you can pattern-match on several of them with a &lt;strong&gt;single pattern&lt;/strong&gt;. TS-Pattern will keep track of the cases which have been handled and those which haven&#39;t, so you never forget to handle a case.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;type Permission = &#39;editor&#39; | &#39;viewer&#39;;&#xA;type Plan = &#39;basic&#39; | &#39;pro&#39;;&#xA;&#xA;const fn = (org: Plan, user: Permission): string =&amp;gt;&#xA;  match([org, user] as const)&#xA;    .with([&#39;basic&#39;, &#39;viewer&#39;], () =&amp;gt; {})&#xA;    .with([&#39;basic&#39;, &#39;editor&#39;], () =&amp;gt; {})&#xA;    .with([&#39;pro&#39;, &#39;viewer&#39;], () =&amp;gt; {})&#xA;    // Fails with `NonExhaustiveError&amp;lt;[&#39;pro&#39;, &#39;editor&#39;]&amp;gt;`&#xA;    // because the `[&#39;pro&#39;, &#39;editor&#39;]` case isn&#39;t handled.&#xA;    .exhaustive();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Inspirations&lt;/h2&gt; &#xA;&lt;p&gt;This library has been heavily inspired by this great article by Wim Jongeneel: &lt;a href=&#34;https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d&#34;&gt;Pattern Matching in TypeScript with Record and Wildcard Patterns&lt;/a&gt;. It made me realize pattern matching could be implemented in userland and we didn&#39;t have to wait for it to be added to the language itself. I&#39;m really grateful for that 🙏&lt;/p&gt;</summary>
  </entry>
</feed>