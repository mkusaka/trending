<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub TypeScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-14T01:39:24Z</updated>
  <subtitle>Daily Trending of TypeScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>piyushgarg-dev/vercel-clone</title>
    <updated>2024-02-14T01:39:24Z</updated>
    <id>tag:github.com,2024-02-14:/piyushgarg-dev/vercel-clone</id>
    <link href="https://github.com/piyushgarg-dev/vercel-clone" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Vercel Clone From Scratch üöÄ&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Vercel Clone&lt;/h1&gt; &#xA;&lt;p&gt;YouTube Video Link: &lt;a href=&#34;https://youtu.be/0A_JpLYG7hM&#34;&gt;https://youtu.be/0A_JpLYG7hM&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Whiteboard Diagram: &lt;a href=&#34;https://app.eraser.io/workspace/0f8XnDF61iGcatypPqIR?origin=share&#34;&gt;https://app.eraser.io/workspace/0f8XnDF61iGcatypPqIR?origin=share&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Prerequisite&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Node.JS: &lt;a href=&#34;https://youtube.com/playlist?list=PLinedj3B30sDby4Al-i13hQJGQoRQDfPo&amp;amp;si=5gaDmQ_mzuBHvAsg&#34;&gt;Master NodeJS Playlist&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Redis: &lt;a href=&#34;https://youtu.be/Vx2zPMPvmug?si=Z_XT6BMNgkgwnX49&#34;&gt;Redis Crash Course&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Learn Docker: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Part 1: &lt;a href=&#34;https://youtu.be/31k6AtW-b3Y?si=FIPffAKieiBGgo5c&#34;&gt;Docker in One Shot - Part 1&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Part 2: &lt;a href=&#34;https://youtu.be/xPT8mXa-sJg?si=-6z_HkJZXsvrvSpO&#34;&gt;Docker in One Shot - Part 2&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Docker with AWS ECS and ECR: &lt;a href=&#34;https://youtu.be/AiiFbsAlLaI?si=dKrFZFr7fLBXKSab&#34;&gt;Real World Docker Deployments with AWS&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Setup Guide&lt;/h3&gt; &#xA;&lt;p&gt;This Project contains following services and folders:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;api-server&lt;/code&gt;: HTTP API Server for REST API&#39;s&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;build-server&lt;/code&gt;: Docker Image code which clones, builds and pushes the build to S3&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s3-reverse-proxy&lt;/code&gt;: Reverse Proxy the subdomains and domains to s3 bucket static assets&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Local Setup&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run &lt;code&gt;npm install&lt;/code&gt; in all the 3 services i.e. &lt;code&gt;api-server&lt;/code&gt;, &lt;code&gt;build-server&lt;/code&gt; and &lt;code&gt;s3-reverse-proxy&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Docker build the &lt;code&gt;build-server&lt;/code&gt; and push the image to AWS ECR.&lt;/li&gt; &#xA; &lt;li&gt;Setup the &lt;code&gt;api-server&lt;/code&gt; by providing all the required config such as TASK ARN and CLUSTER arn.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;node index.js&lt;/code&gt; in &lt;code&gt;api-server&lt;/code&gt; and &lt;code&gt;s3-reverse-proxy&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;At this point following services would be up and running:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;S.No&lt;/th&gt; &#xA;   &lt;th&gt;Service&lt;/th&gt; &#xA;   &lt;th&gt;PORT&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;api-server&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;:9000&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;socket.io-server&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;:9002&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;s3-reverse-proxy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;:8000&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Demo&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://imgur.com/I6KgmNR&#34;&gt;Watch The Demo Video&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Architecture&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/r7QUXqZ.png&#34; alt=&#34;Vercel Clone Architecture&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>47ng/nuqs</title>
    <updated>2024-02-14T01:39:24Z</updated>
    <id>tag:github.com,2024-02-14:/47ng/nuqs</id>
    <link href="https://github.com/47ng/nuqs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Type-safe search params state manager for Next.js - Like React.useState, but stored in the URL query string.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;useQueryState for Next.js&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/nuqs&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/v/nuqs?color=red&#34; alt=&#34;NPM&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/47ng/nuqs/raw/next/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/47ng/nuqs.svg?color=blue&#34; alt=&#34;MIT License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/47ng/nuqs/actions&#34;&gt;&lt;img src=&#34;https://github.com/47ng/nuqs/workflows/Continuous%20Integration/badge.svg?branch=next&#34; alt=&#34;Continuous Integration&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://depfu.com/github/47ng/nuqs?project_id=22104&#34;&gt;&lt;img src=&#34;https://badges.depfu.com/badges/acad53fa2b09b1e435a19d6d18f29af4/count.svg?sanitize=true&#34; alt=&#34;Depfu&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- [![Coverage Status](https://coveralls.io/repos/github/47ng/nuqs/badge.svg?branch=next)](https://coveralls.io/github/47ng/nuqs?branch=next) --&gt; &#xA;&lt;p&gt;useQueryState hook for Next.js - Like React.useState, but stored in the URL query string&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üîÄ Supports both the &lt;code&gt;app&lt;/code&gt; and &lt;code&gt;pages&lt;/code&gt; routers&lt;/li&gt; &#xA; &lt;li&gt;üßò‚Äç‚ôÄÔ∏è Simple: the URL is the source of truth&lt;/li&gt; &#xA; &lt;li&gt;üï∞ Replace history or &lt;a href=&#34;https://raw.githubusercontent.com/47ng/nuqs/next/#history&#34;&gt;append&lt;/a&gt; to use the Back button to navigate state updates&lt;/li&gt; &#xA; &lt;li&gt;‚ö°Ô∏è Built-in &lt;a href=&#34;https://raw.githubusercontent.com/47ng/nuqs/next/#parsing&#34;&gt;parsers&lt;/a&gt; for common state types (integer, float, boolean, Date, and more)&lt;/li&gt; &#xA; &lt;li&gt;‚ôäÔ∏è Related querystrings with &lt;a href=&#34;https://raw.githubusercontent.com/47ng/nuqs/next/#usequerystates&#34;&gt;&lt;code&gt;useQueryStates&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;üì° &lt;a href=&#34;https://raw.githubusercontent.com/47ng/nuqs/next/#shallow&#34;&gt;Shallow mode&lt;/a&gt; by default for URL query updates, opt-in to notify server components&lt;/li&gt; &#xA; &lt;li&gt;üóÉ &lt;em&gt;&lt;strong&gt;new:&lt;/strong&gt;&lt;/em&gt; &lt;a href=&#34;https://raw.githubusercontent.com/47ng/nuqs/next/#accessing-searchparams-in-server-components&#34;&gt;Server cache&lt;/a&gt; for type-safe searchParams access in nested server components&lt;/li&gt; &#xA; &lt;li&gt;‚åõÔ∏è &lt;em&gt;&lt;strong&gt;new:&lt;/strong&gt;&lt;/em&gt; Support for &lt;a href=&#34;https://raw.githubusercontent.com/47ng/nuqs/next/#transitions&#34;&gt;&lt;code&gt;useTransition&lt;/code&gt;&lt;/a&gt; to get loading states on server updates&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pnpm add nuqs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yarn add nuqs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm install nuqs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: the package is moving to a new name: &lt;code&gt;nuqs&lt;/code&gt; &lt;span&gt;üéâ&lt;/span&gt;&lt;/p&gt; &#xA; &lt;p&gt;The 1.x versions will also be available under &lt;code&gt;next-usequerystate&lt;/code&gt;, but 2.x onwards will only be published under &lt;code&gt;nuqs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Which version should I use?&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Next.js version range&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Supported &lt;code&gt;nuqs&lt;/code&gt; / &lt;code&gt;next-usequerystate&lt;/code&gt; version&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&amp;gt;=14.0.4&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;nuqs@latest&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;14.0.3&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;nuqs@latest&lt;/code&gt;, with the &lt;code&gt;windowHistorySupport&lt;/code&gt; experimental flag, see &lt;a href=&#34;https://github.com/47ng/nuqs/issues/417&#34;&gt;#417&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;14.0.2&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Not compatible, see issue &lt;a href=&#34;https://github.com/47ng/nuqs/issues/388&#34;&gt;#388&lt;/a&gt; and Next.js PR &lt;a href=&#34;https://github.com/vercel/next.js/pull/58297&#34;&gt;#58297&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&amp;gt;= 13.1 &amp;amp;&amp;amp; &amp;lt;= 14.0.1&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;nuqs@latest&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&amp;lt; 13.1&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;next-usequerystate@1.7.3&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;&#39;use client&#39; // app router: only works in client components&#xA;&#xA;import { useQueryState } from &#39;nuqs&#39;&#xA;&#xA;export default () =&amp;gt; {&#xA;  const [name, setName] = useQueryState(&#39;name&#39;)&#xA;  return (&#xA;    &amp;lt;&amp;gt;&#xA;      &amp;lt;h1&amp;gt;Hello, {name || &#39;anonymous visitor&#39;}!&amp;lt;/h1&amp;gt;&#xA;      &amp;lt;input value={name || &#39;&#39;} onChange={e =&amp;gt; setName(e.target.value)} /&amp;gt;&#xA;      &amp;lt;button onClick={() =&amp;gt; setName(null)}&amp;gt;Clear&amp;lt;/button&amp;gt;&#xA;    &amp;lt;/&amp;gt;&#xA;  )&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/47ng/nuqs/next/useQueryState.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;useQueryState&lt;/code&gt; takes one required argument: the key to use in the query string.&lt;/p&gt; &#xA;&lt;p&gt;Like &lt;code&gt;React.useState&lt;/code&gt;, it returns an array with the value present in the query string as a string (or &lt;code&gt;null&lt;/code&gt; if none was found), and a state updater function.&lt;/p&gt; &#xA;&lt;p&gt;Example outputs for our hello world example:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;URL&lt;/th&gt; &#xA;   &lt;th&gt;name value&lt;/th&gt; &#xA;   &lt;th&gt;Notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;null&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;No &lt;code&gt;name&lt;/code&gt; key in URL&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;/?name=&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#39;&#39;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Empty string&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;/?name=foo&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#39;foo&#39;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;/?name=2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#39;2&#39;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Always returns a string by default, see &lt;a href=&#34;https://raw.githubusercontent.com/47ng/nuqs/next/#parsing&#34;&gt;Parsing&lt;/a&gt; below&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Parsing&lt;/h2&gt; &#xA;&lt;p&gt;If your state type is not a string, you must pass a parsing function in the second argument object.&lt;/p&gt; &#xA;&lt;p&gt;We provide parsers for common and more advanced object types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import {&#xA;  parseAsString,&#xA;  parseAsInteger,&#xA;  parseAsFloat,&#xA;  parseAsBoolean,&#xA;  parseAsTimestamp,&#xA;  parseAsIsoDateTime,&#xA;  parseAsArrayOf,&#xA;  parseAsJson,&#xA;  parseAsStringEnum,&#xA;  parseAsStringLiteral,&#xA;  parseAsNumberLiteral&#xA;} from &#39;nuqs&#39;&#xA;&#xA;useQueryState(&#39;tag&#39;) // defaults to string&#xA;useQueryState(&#39;count&#39;, parseAsInteger)&#xA;useQueryState(&#39;brightness&#39;, parseAsFloat)&#xA;useQueryState(&#39;darkMode&#39;, parseAsBoolean)&#xA;useQueryState(&#39;after&#39;, parseAsTimestamp) // state is a Date&#xA;useQueryState(&#39;date&#39;, parseAsIsoDateTime) // state is a Date&#xA;useQueryState(&#39;array&#39;, parseAsArrayOf(parseAsInteger)) // state is number[]&#xA;useQueryState(&#39;json&#39;, parseAsJson&amp;lt;Point&amp;gt;()) // state is a Point&#xA;&#xA;// Enums (string-based only)&#xA;enum Direction {&#xA;  up = &#39;UP&#39;,&#xA;  down = &#39;DOWN&#39;,&#xA;  left = &#39;LEFT&#39;,&#xA;  right = &#39;RIGHT&#39;&#xA;}&#xA;&#xA;const [direction, setDirection] = useQueryState(&#xA;  &#39;direction&#39;,&#xA;  parseAsStringEnum&amp;lt;Direction&amp;gt;(Object.values(Direction)) // pass a list of allowed values&#xA;    .withDefault(Direction.up)&#xA;)&#xA;&#xA;// Literals (string-based only)&#xA;const colors = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;] as const&#xA;&#xA;const [color, setColor] = useQueryState(&#xA;  &#39;color&#39;,&#xA;  parseAsStringLiteral(colors) // pass a readonly list of allowed values&#xA;    .withDefault(&#39;red&#39;)&#xA;)&#xA;&#xA;// Literals (number-based only)&#xA;const diceSides = [1, 2, 3, 4, 5, 6] as const&#xA;&#xA;const [side, setSide] = useQueryState(&#xA;  &#39;side&#39;,&#xA;  parseAsNumberLiteral(diceSides) // pass a readonly list of allowed values&#xA;    .withDefault(4)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may pass a custom set of &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;serialize&lt;/code&gt; functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;import { useQueryState } from &#39;nuqs&#39;&#xA;&#xA;export default () =&amp;gt; {&#xA;  const [hex, setHex] = useQueryState(&#39;hex&#39;, {&#xA;    // TypeScript will automatically infer it&#39;s a number&#xA;    // based on what `parse` returns.&#xA;    parse: (query: string) =&amp;gt; parseInt(query, 16),&#xA;    serialize: value =&amp;gt; value.toString(16)&#xA;  })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using parsers in Server Components&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: see the &lt;a href=&#34;https://raw.githubusercontent.com/47ng/nuqs/next/#accessing-searchparams-in-server-components&#34;&gt;Accessing searchParams in server components&lt;/a&gt; section for a more user-friendly way to achieve type-safety.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If you wish to parse the searchParams in server components, you&#39;ll need to import the parsers from &lt;code&gt;nuqs/server&lt;/code&gt;, which doesn&#39;t include the &lt;code&gt;&#34;use client&#34;&lt;/code&gt; directive.&lt;/p&gt; &#xA;&lt;p&gt;You can then use the &lt;code&gt;parseServerSide&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;import { parseAsInteger } from &#39;nuqs/server&#39;&#xA;&#xA;type PageProps = {&#xA;  searchParams: {&#xA;    counter?: string | string[]&#xA;  }&#xA;}&#xA;&#xA;const counterParser = parseAsInteger.withDefault(1)&#xA;&#xA;export default function ServerPage({ searchParams }: PageProps) {&#xA;  const counter = counterParser.parseServerSide(searchParams.counter)&#xA;  console.log(&#39;Server side counter: %d&#39;, counter)&#xA;  return (&#xA;    ...&#xA;  )&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/47ng/nuqs/next/packages/docs/src/app/(pages)/playground/server-side-parsing/&#34;&gt;server-side parsing demo&lt;/a&gt; for a live example showing how to reuse parser configurations between client and server code.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: parsers &lt;strong&gt;don&#39;t validate&lt;/strong&gt; your data. If you expect positive integers or JSON-encoded objects of a particular shape, you&#39;ll need to feed the result of the parser to a schema validation library, like &lt;a href=&#34;https://zod.dev&#34;&gt;Zod&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Default value&lt;/h2&gt; &#xA;&lt;p&gt;When the query string is not present in the URL, the default behaviour is to return &lt;code&gt;null&lt;/code&gt; as state.&lt;/p&gt; &#xA;&lt;p&gt;It can make state updating and UI rendering tedious. Take this example of a simple counter stored in the URL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;import { useQueryState, parseAsInteger } from &#39;nuqs&#39;&#xA;&#xA;export default () =&amp;gt; {&#xA;  const [count, setCount] = useQueryState(&#39;count&#39;, parseAsInteger)&#xA;  return (&#xA;    &amp;lt;&amp;gt;&#xA;      &amp;lt;pre&amp;gt;count: {count}&amp;lt;/pre&amp;gt;&#xA;      &amp;lt;button onClick={() =&amp;gt; setCount(0)}&amp;gt;Reset&amp;lt;/button&amp;gt;&#xA;      {/* handling null values in setCount is annoying: */}&#xA;      &amp;lt;button onClick={() =&amp;gt; setCount(c =&amp;gt; c ?? 0 + 1)}&amp;gt;+&amp;lt;/button&amp;gt;&#xA;      &amp;lt;button onClick={() =&amp;gt; setCount(c =&amp;gt; c ?? 0 - 1)}&amp;gt;-&amp;lt;/button&amp;gt;&#xA;      &amp;lt;button onClick={() =&amp;gt; setCount(null)}&amp;gt;Clear&amp;lt;/button&amp;gt;&#xA;    &amp;lt;/&amp;gt;&#xA;  )&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can specify a default value to be returned in this case:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const [count, setCount] = useQueryState(&#39;count&#39;, parseAsInteger.withDefault(0))&#xA;&#xA;const increment = () =&amp;gt; setCount(c =&amp;gt; c + 1) // c will never be null&#xA;const decrement = () =&amp;gt; setCount(c =&amp;gt; c - 1) // c will never be null&#xA;const clearCount = () =&amp;gt; setCount(null) // Remove query from the URL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: the default value is internal to React, it will &lt;strong&gt;not&lt;/strong&gt; be written to the URL.&lt;/p&gt; &#xA;&lt;p&gt;Setting the state to &lt;code&gt;null&lt;/code&gt; will remove the key in the query string and set the state to the default value.&lt;/p&gt; &#xA;&lt;h2&gt;Options&lt;/h2&gt; &#xA;&lt;h3&gt;History&lt;/h3&gt; &#xA;&lt;p&gt;By default, state updates are done by replacing the current history entry with the updated query when state changes.&lt;/p&gt; &#xA;&lt;p&gt;You can see this as a sort of &lt;code&gt;git squash&lt;/code&gt;, where all state-changing operations are merged into a single history value.&lt;/p&gt; &#xA;&lt;p&gt;You can also opt-in to push a new history item for each state change, per key, which will let you use the Back button to navigate state updates:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// Default: replace current history with new state&#xA;useQueryState(&#39;foo&#39;, { history: &#39;replace&#39; })&#xA;&#xA;// Append state changes to history:&#xA;useQueryState(&#39;foo&#39;, { history: &#39;push&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any other value for the &lt;code&gt;history&lt;/code&gt; option will fallback to the default.&lt;/p&gt; &#xA;&lt;p&gt;You can also override the history mode when calling the state updater function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const [query, setQuery] = useQueryState(&#39;q&#39;, { history: &#39;push&#39; })&#xA;&#xA;// This overrides the hook declaration setting:&#xA;setQuery(null, { history: &#39;replace&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Shallow&lt;/h3&gt; &#xA;&lt;p&gt;By default, query state updates are done in a &lt;em&gt;client-first&lt;/em&gt; manner: there are no network calls to the server.&lt;/p&gt; &#xA;&lt;p&gt;This is equivalent to the &lt;code&gt;shallow&lt;/code&gt; option of the Next.js pages router set to &lt;code&gt;true&lt;/code&gt;, or going through the experimental &lt;a href=&#34;https://github.com/vercel/next.js/discussions/48110&#34;&gt;&lt;code&gt;windowHistorySupport&lt;/code&gt;&lt;/a&gt; flag in the app router.&lt;/p&gt; &#xA;&lt;p&gt;To opt-in to query updates notifying the server (to re-run &lt;code&gt;getServerSideProps&lt;/code&gt; in the pages router and re-render Server Components on the app router), you can set &lt;code&gt;shallow&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const [state, setState] = useQueryState(&#39;foo&#39;, { shallow: false })&#xA;&#xA;// You can also pass the option on calls to setState:&#xA;setState(&#39;bar&#39;, { shallow: false })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Scroll&lt;/h3&gt; &#xA;&lt;p&gt;The Next.js router scrolls to the top of the page on navigation updates, which may not be desirable when updating the query string with local state.&lt;/p&gt; &#xA;&lt;p&gt;Query state updates won&#39;t scroll to the top of the page by default, but you can opt-in to this behaviour (which was the default up to 1.8.0):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const [state, setState] = useQueryState(&#39;foo&#39;, { scroll: true })&#xA;&#xA;// You can also pass the option on calls to setState:&#xA;setState(&#39;bar&#39;, { scroll: true })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Throttling URL updates&lt;/h3&gt; &#xA;&lt;p&gt;Because of browsers rate-limiting the History API, internal updates to the URL are queued and throttled to a default of 50ms, which seems to satisfy most browsers even when sending high-frequency query updates, like binding to a text input or a slider.&lt;/p&gt; &#xA;&lt;p&gt;Safari&#39;s rate limits are much higher and would require a throttle of around 340ms. If you end up needing a longer time between updates, you can specify it in the options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;useQueryState(&#39;foo&#39;, {&#xA;  // Send updates to the server maximum once every second&#xA;  shallow: false,&#xA;  throttleMs: 1000&#xA;})&#xA;&#xA;// You can also pass the option on calls to setState:&#xA;setState(&#39;bar&#39;, { throttleMs: 1000 })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: the state returned by the hook is always updated instantly, to keep UI responsive. Only changes to the URL, and server requests when using &lt;code&gt;shallow: false&lt;/code&gt;, are throttled.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If multiple hooks set different throttle values on the same event loop tick, the highest value will be used. Also, values lower than 50ms will be ignored, to avoid rate-limiting issues. &lt;a href=&#34;https://francoisbest.com/posts/2023/storing-react-state-in-the-url-with-nextjs#batching--throttling&#34;&gt;Read more&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Transitions&lt;/h3&gt; &#xA;&lt;p&gt;When combined with &lt;code&gt;shallow: false&lt;/code&gt;, you can use the &lt;code&gt;useTransition&lt;/code&gt; hook to get loading states while the server is re-rendering server components with the updated URL.&lt;/p&gt; &#xA;&lt;p&gt;Pass in the &lt;code&gt;startTransition&lt;/code&gt; function from &lt;code&gt;useTransition&lt;/code&gt; to the options to enable this behaviour &lt;em&gt;(this will set &lt;code&gt;shallow: false&lt;/code&gt; automatically for you)&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;&#39;use client&#39;&#xA;&#xA;import React from &#39;react&#39;&#xA;import { useQueryState, parseAsString } from &#39;nuqs&#39;&#xA;&#xA;function ClientComponent({ data }) {&#xA;  // 1. Provide your own useTransition hook:&#xA;  const [isLoading, startTransition] = React.useTransition()&#xA;  const [query, setQuery] = useQueryState(&#xA;    &#39;query&#39;,&#xA;    // 2. Pass the `startTransition` as an option:&#xA;    parseAsString().withOptions({ startTransition })&#xA;  )&#xA;  // 3. `isLoading` will be true while the server is re-rendering&#xA;  // and streaming RSC payloads, when the query is updated via `setQuery`.&#xA;&#xA;  // Indicate loading state&#xA;  if (isLoading) return &amp;lt;div&amp;gt;Loading...&amp;lt;/div&amp;gt;&#xA;&#xA;  // Normal rendering with data&#xA;  return &amp;lt;div&amp;gt;{/*...*/}&amp;lt;/div&amp;gt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuring parsers, default value &amp;amp; options&lt;/h2&gt; &#xA;&lt;p&gt;You can use a builder pattern to facilitate specifying all of those things:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;useQueryState(&#xA;  &#39;counter&#39;,&#xA;  parseAsInteger.withDefault(0).withOptions({&#xA;    history: &#39;push&#39;,&#xA;    shallow: false&#xA;  })&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can get this pattern for your custom parsers too, and compose them with others:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { createParser, parseAsHex } from &#39;nuqs&#39;&#xA;&#xA;// Wrapping your parser/serializer in `createParser`&#xA;// gives it access to the builder pattern &amp;amp; server-side&#xA;// parsing capabilities:&#xA;const hexColorSchema = createParser({&#xA;  parse(query) {&#xA;    if (query.length !== 6) {&#xA;      return null // always return null for invalid inputs&#xA;    }&#xA;    return {&#xA;      // When composing other parsers, they may return null too.&#xA;      r: parseAsHex.parse(query.slice(0, 2)) ?? 0x00,&#xA;      g: parseAsHex.parse(query.slice(2, 4)) ?? 0x00,&#xA;      b: parseAsHex.parse(query.slice(4)) ?? 0x00&#xA;    }&#xA;  },&#xA;  serialize({ r, g, b }) {&#xA;    return (&#xA;      parseAsHex.serialize(r) +&#xA;      parseAsHex.serialize(g) +&#xA;      parseAsHex.serialize(b)&#xA;    )&#xA;  }&#xA;})&#xA;  // Eg: set common options directly&#xA;  .withOptions({ history: &#39;push&#39; })&#xA;&#xA;// Or on usage:&#xA;useQueryState(&#xA;  &#39;tribute&#39;,&#xA;  hexColorSchema.withDefault({&#xA;    r: 0x66,&#xA;    g: 0x33,&#xA;    b: 0x99&#xA;  })&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: see this example running in the &lt;a href=&#34;https://raw.githubusercontent.com/47ng/nuqs/next/packages/docs/src/app/(pages)/playground/hex-colors/page.tsx&#34;&gt;hex-colors demo&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Multiple Queries (batching)&lt;/h2&gt; &#xA;&lt;p&gt;You can call as many state update function as needed in a single event loop tick, and they will be applied to the URL asynchronously:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const MultipleQueriesDemo = () =&amp;gt; {&#xA;  const [lat, setLat] = useQueryState(&#39;lat&#39;, parseAsFloat)&#xA;  const [lng, setLng] = useQueryState(&#39;lng&#39;, parseAsFloat)&#xA;  const randomCoordinates = React.useCallback(() =&amp;gt; {&#xA;    setLat(Math.random() * 180 - 90)&#xA;    setLng(Math.random() * 360 - 180)&#xA;  }, [])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you wish to know when the URL has been updated, and what it contains, you can await the Promise returned by the state updater function, which gives you the updated URLSearchParameters object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const randomCoordinates = React.useCallback(() =&amp;gt; {&#xA;  setLat(42)&#xA;  return setLng(12)&#xA;}, [])&#xA;&#xA;randomCoordinates().then((search: URLSearchParams) =&amp;gt; {&#xA;  search.get(&#39;lat&#39;) // 42&#xA;  search.get(&#39;lng&#39;) // 12, has been queued and batch-updated&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;em&gt;Implementation details (Promise caching)&lt;/em&gt;&lt;/summary&gt; &#xA; &lt;p&gt;The returned Promise is cached until the next flush to the URL occurs, so all calls to a setState (of any hook) in the same event loop tick will return the same Promise reference.&lt;/p&gt; &#xA; &lt;p&gt;Due to throttling of calls to the Web History API, the Promise may be cached for several ticks. Batched updates will be merged and flushed once to the URL. This means not every setState will reflect to the URL, if another one comes overriding it before flush occurs.&lt;/p&gt; &#xA; &lt;p&gt;The returned React state will reflect all set values instantly, to keep UI responsive.&lt;/p&gt; &#xA; &lt;hr&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;&lt;code&gt;useQueryStates&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;For query keys that should always move together, you can use &lt;code&gt;useQueryStates&lt;/code&gt; with an object containing each key&#39;s type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { useQueryStates, parseAsFloat } from &#39;nuqs&#39;&#xA;&#xA;const [coordinates, setCoordinates] = useQueryStates(&#xA;  {&#xA;    lat: parseAsFloat.withDefault(45.18),&#xA;    lng: parseAsFloat.withDefault(5.72)&#xA;  },&#xA;  {&#xA;    history: &#39;push&#39;&#xA;  }&#xA;)&#xA;&#xA;const { lat, lng } = coordinates&#xA;&#xA;// Set all (or a subset of) the keys in one go:&#xA;const search = await setCoordinates({&#xA;  lat: Math.random() * 180 - 90,&#xA;  lng: Math.random() * 360 - 180&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Accessing searchParams in Server Components&lt;/h2&gt; &#xA;&lt;p&gt;If you wish to access the searchParams in a deeply nested Server Component (ie: not in the Page component), you can use &lt;code&gt;createSearchParamsCache&lt;/code&gt; to do so in a type-safe manner.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: parsers &lt;strong&gt;don&#39;t validate&lt;/strong&gt; your data. If you expect positive integers or JSON-encoded objects of a particular shape, you&#39;ll need to feed the result of the parser to a schema validation library, like &lt;a href=&#34;https://zod.dev&#34;&gt;Zod&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;// searchParams.ts&#xA;import {&#xA;  createSearchParamsCache,&#xA;  parseAsInteger,&#xA;  parseAsString&#xA;} from &#39;nuqs/server&#39;&#xA;// Note: import from &#39;‚Ä¶/parsers&#39; to avoid the &#34;use client&#34; directive&#xA;&#xA;export const searchParamsCache = createSearchParamsCache({&#xA;  // List your search param keys and associated parsers here:&#xA;  q: parseAsString.withDefault(&#39;&#39;),&#xA;  maxResults: parseAsInteger.withDefault(10)&#xA;})&#xA;&#xA;// page.tsx&#xA;import { searchParamsCache } from &#39;./searchParams&#39;&#xA;&#xA;export default function Page({&#xA;  searchParams&#xA;}: {&#xA;  searchParams: Record&amp;lt;string, string | string[] | undefined&amp;gt;&#xA;}) {&#xA;  // ‚ö†Ô∏è Don&#39;t forget to call `parse` here.&#xA;  // You can access type-safe values from the returned object:&#xA;  const { q: query } = searchParamsCache.parse(searchParams)&#xA;  return (&#xA;    &amp;lt;div&amp;gt;&#xA;      &amp;lt;h1&amp;gt;Search Results for {query}&amp;lt;/h1&amp;gt;&#xA;      &amp;lt;Results /&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;  )&#xA;}&#xA;&#xA;function Results() {&#xA;  // Access type-safe search params in children server components:&#xA;  const maxResults = searchParamsCache.get(&#39;maxResults&#39;)&#xA;  return &amp;lt;span&amp;gt;Showing up to {maxResults} results&amp;lt;/span&amp;gt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The cache will only be valid for the current page render (see React&#39;s &lt;a href=&#34;https://react.dev/reference/react/cache&#34;&gt;&lt;code&gt;cache&lt;/code&gt;&lt;/a&gt; function).&lt;/p&gt; &#xA;&lt;p&gt;Note: the cache only works for &lt;strong&gt;server components&lt;/strong&gt;, but you may share your parser declaration with &lt;code&gt;useQueryStates&lt;/code&gt; for type-safety in client components:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-tsx&#34;&gt;// searchParams.ts&#xA;import { parseAsFloat, createSearchParamsCache } from &#39;nuqs/server&#39;&#xA;&#xA;export const coordinatesParsers = {&#xA;  lat: parseAsFloat.withDefault(45.18),&#xA;  lng: parseAsFloat.withDefault(5.72)&#xA;}&#xA;export const coordinatesCache = createSearchParamsCache(coordinatesParsers)&#xA;&#xA;// page.tsx&#xA;import { coordinatesCache } from &#39;./searchParams&#39;&#xA;import { Server } from &#39;./server&#39;&#xA;import { Client } from &#39;./client&#39;&#xA;&#xA;export default function Page({ searchParams }) {&#xA;  coordinatesCache.parse(searchParams)&#xA;  return (&#xA;    &amp;lt;&amp;gt;&#xA;      &amp;lt;Server /&amp;gt;&#xA;      &amp;lt;Suspense&amp;gt;&#xA;        &amp;lt;Client /&amp;gt;&#xA;      &amp;lt;/Suspense&amp;gt;&#xA;    &amp;lt;/&amp;gt;&#xA;  )&#xA;}&#xA;&#xA;// server.tsx&#xA;import { coordinatesCache } from &#39;./searchParams&#39;&#xA;&#xA;export function Server() {&#xA;  const { lat, lng } = coordinatesCache.all()&#xA;  // or access keys individually:&#xA;  const lat = coordinatesCache.get(&#39;lat&#39;)&#xA;  const lng = coordinatesCache.get(&#39;lng&#39;)&#xA;  return (&#xA;    &amp;lt;span&amp;gt;&#xA;      Latitude: {lat} - Longitude: {lng}&#xA;    &amp;lt;/span&amp;gt;&#xA;  )&#xA;}&#xA;&#xA;// client.tsx&#xA;// prettier-ignore&#xA;;&#39;use client&#39;&#xA;&#xA;import { useQueryStates } from &#39;nuqs&#39;&#xA;import { coordinatesParsers } from &#39;./searchParams&#39;&#xA;&#xA;export function Client() {&#xA;  const [{ lat, lng }, setCoordinates] = useQueryStates(coordinatesParsers)&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Serializer helper&lt;/h2&gt; &#xA;&lt;p&gt;To populate &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; components with state values, you can use the &lt;code&gt;createSerializer&lt;/code&gt; helper.&lt;/p&gt; &#xA;&lt;p&gt;Pass it an object describing your search params, and it will give you a function to call with values, that generates a query string serialized as the hooks would do.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import {&#xA;  createSerializer,&#xA;  parseAsInteger,&#xA;  parseAsIsoDateTime,&#xA;  parseAsString,&#xA;  parseAsStringLiteral&#xA;} from &#39;nuqs/server&#39;&#xA;&#xA;const searchParams = {&#xA;  search: parseAsString,&#xA;  limit: parseAsInteger,&#xA;  from: parseAsIsoDateTime,&#xA;  to: parseAsIsoDateTime,&#xA;  sortBy: parseAsStringLiteral([&#39;asc&#39;, &#39;desc&#39;] as const)&#xA;}&#xA;&#xA;// Create a serializer function by passing the description of the search params to accept&#xA;const serialize = createSerializer(searchParams)&#xA;&#xA;// Then later, pass it some values (a subset) and render them to a query string&#xA;serialize({&#xA;  search: &#39;foo bar&#39;,&#xA;  limit: 10,&#xA;  from: new Date(&#39;2024-01-01&#39;),&#xA;  // here, we omit `to`, which won&#39;t be added&#xA;  sortBy: null // null values are also not rendered&#xA;})&#xA;// ?search=foo+bar&amp;amp;limit=10&amp;amp;from=2024-01-01T00:00:00.000Z&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Base parameter&lt;/h3&gt; &#xA;&lt;p&gt;The returned &lt;code&gt;serialize&lt;/code&gt; function can take a base parameter over which to append/amend the search params:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;serialize(&#39;/path?baz=qux&#39;, { foo: &#39;bar&#39; }) // /path?baz=qux&amp;amp;foo=bar&#xA;&#xA;const search = new URLSearchParams(&#39;?baz=qux&#39;)&#xA;serialize(search, { foo: &#39;bar&#39; }) // ?baz=qux&amp;amp;foo=bar&#xA;&#xA;const url = new URL(&#39;https://example.com/path?baz=qux&#39;)&#xA;serialize(url, { foo: &#39;bar&#39; }) // https://example.com/path?baz=qux&amp;amp;foo=bar&#xA;&#xA;// Passing null removes existing values&#xA;serialize(&#39;?remove=me&#39;, { foo: &#39;bar&#39;, remove: null }) // ?foo=bar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;Currently, the best way to test the behaviour of your components using &lt;code&gt;useQueryState(s)&lt;/code&gt; is end-to-end testing, with tools like Playwright or Cypress.&lt;/p&gt; &#xA;&lt;p&gt;Running components that use the Next.js router in isolation requires mocking it, which is being &lt;a href=&#34;https://github.com/scottrippey/next-router-mock/pull/103&#34;&gt;worked on&lt;/a&gt; for the app router.&lt;/p&gt; &#xA;&lt;p&gt;See issue #259 for more testing-related discussions.&lt;/p&gt; &#xA;&lt;h2&gt;Debugging&lt;/h2&gt; &#xA;&lt;p&gt;You can enable debug logs in the browser by setting the &lt;code&gt;debug&lt;/code&gt; item in localStorage to &lt;code&gt;nuqs&lt;/code&gt;, and reload the page.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// In your devtools:&#xA;localStorage.setItem(&#39;debug&#39;, &#39;nuqs&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: unlike the &lt;code&gt;debug&lt;/code&gt; package, this will not work with wildcards, but you can combine it: &lt;code&gt;localStorage.setItem(&#39;debug&#39;, &#39;*,nuqs&#39;)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Log lines will be prefixed with &lt;code&gt;[nuqs]&lt;/code&gt; for &lt;code&gt;useQueryState&lt;/code&gt; and &lt;code&gt;[nuq+]&lt;/code&gt; for &lt;code&gt;useQueryStates&lt;/code&gt;, along with other internal debug logs.&lt;/p&gt; &#xA;&lt;p&gt;User timings markers are also recorded, for advanced performance analysis using your browser&#39;s devtools.&lt;/p&gt; &#xA;&lt;p&gt;Providing debug logs when opening an &lt;a href=&#34;https://github.com/47ng/nuqs/issues&#34;&gt;issue&lt;/a&gt; is always appreciated. üôè&lt;/p&gt; &#xA;&lt;h2&gt;Caveats&lt;/h2&gt; &#xA;&lt;p&gt;Because the Next.js &lt;strong&gt;pages router&lt;/strong&gt; is not available in an SSR context, this hook will always return &lt;code&gt;null&lt;/code&gt; (or the default value if supplied) on SSR/SSG.&lt;/p&gt; &#xA;&lt;p&gt;This limitation doesn&#39;t apply to the app router.&lt;/p&gt; &#xA;&lt;h3&gt;SEO&lt;/h3&gt; &#xA;&lt;p&gt;If your page uses query strings for local-only state, you should add a canonical URL to your page, to tell SEO crawlers to ignore the query string and index the page without it.&lt;/p&gt; &#xA;&lt;p&gt;In the app router, this is done via the metadata object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import type { Metadata } from &#39;next&#39;&#xA;&#xA;export const metadata: Metadata = {&#xA;  alternates: {&#xA;    canonical: &#39;/url/path/without/querystring&#39;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If however the query string is defining what content the page is displaying (eg: YouTube&#39;s watch URLs, like &lt;code&gt;https://www.youtube.com/watch?v=dQw4w9WgXcQ&lt;/code&gt;), your canonical URL should contain relevant query strings, and you can still use &lt;code&gt;useQueryState&lt;/code&gt; to read it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// page.tsx&#xA;import type { Metadata, ResolvingMetadata } from &#39;next&#39;&#xA;import { useQueryState } from &#39;nuqs&#39;&#xA;import { parseAsString } from &#39;nuqs/server&#39;&#xA;&#xA;type Props = {&#xA;  searchParams: { [key: string]: string | string[] | undefined }&#xA;}&#xA;&#xA;export async function generateMetadata({&#xA;  searchParams&#xA;}: Props): Promise&amp;lt;Metadata&amp;gt; {&#xA;  const videoId = parseAsString.parseServerSide(searchParams.v)&#xA;  return {&#xA;    alternates: {&#xA;      canonical: `/watch?v=${videoId}`&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Lossy serialization&lt;/h3&gt; &#xA;&lt;p&gt;If your serializer loses precision or doesn&#39;t accurately represent the underlying state value, you will lose this precision when reloading the page or restoring state from the URL (eg: on navigation).&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const geoCoordParser = {&#xA;  parse: parseFloat,&#xA;  serialize: v =&amp;gt; v.toFixed(4) // Loses precision&#xA;}&#xA;&#xA;const [lat, setLat] = useQueryState(&#39;lat&#39;, geoCoordParser)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, setting a latitude of 1.23456789 will render a URL query string of &lt;code&gt;lat=1.2345&lt;/code&gt;, while the internal &lt;code&gt;lat&lt;/code&gt; state will be correctly set to 1.23456789.&lt;/p&gt; &#xA;&lt;p&gt;Upon reloading the page, the state will be incorrectly set to 1.2345.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/47ng/nuqs/raw/next/LICENSE&#34;&gt;MIT&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Made with ‚ù§Ô∏è by &lt;a href=&#34;https://francoisbest.com&#34;&gt;Fran√ßois Best&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Using this package at work ? &lt;a href=&#34;https://github.com/sponsors/franky47&#34;&gt;Sponsor me&lt;/a&gt; to help with support and maintenance.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://repobeats.axiom.co/api/embed/3ee740e4729dce3992bfa8c74645cfebad8ba034.svg?sanitize=true&#34; alt=&#34;Project analytics and stats&#34; title=&#34;Repobeats analytics image&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>nrwl/nx-console</title>
    <updated>2024-02-14T01:39:24Z</updated>
    <id>tag:github.com,2024-02-14:/nrwl/nx-console</id>
    <link href="https://github.com/nrwl/nx-console" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Nx Console is the user interface for Nx &amp; Lerna.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;picture&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://raw.githubusercontent.com/nrwl/nx-console/master/static/nx-console-dark.png&#34;&gt; &#xA;  &lt;img alt=&#34;Nx Console - The UI for Nx &amp;amp; Lerna&#34; src=&#34;https://raw.githubusercontent.com/nrwl/nx-console/master/static/nx-console-light.png&#34; width=&#34;100%&#34;&gt; &#xA; &lt;/picture&gt; &lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;The UI for Nx &amp;amp; Lerna&lt;/h1&gt; &#xA; &lt;p&gt;&lt;strong&gt;Spend less time looking up command line arguments and more time shipping incredible products.&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/nrwl/nx-console/actions/workflows/ci_checks.yml&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/nrwl/nx-console/ci_checks.yml?branch=master&amp;amp;label=CI&amp;amp;logo=github&amp;amp;style=flat-square&#34; alt=&#34;CI Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=nrwl.angular-console&#34;&gt;&lt;img src=&#34;https://img.shields.io/visual-studio-marketplace/v/nrwl.angular-console?style=flat-square&#34; alt=&#34;Visual Studio Marketplace Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/nrwl/nx-console/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/nrwl/nx-console?style=flat-square&#34; alt=&#34;GitHub&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/visual-studio-marketplace/d/nrwl.angular-console?style=flat-square&#34; alt=&#34;Visual Studio Marketplace Downloads&#34;&gt; &lt;a href=&#34;https://code.visualstudio.com&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Visual%20Studio%20Code-%5E1.71.0-blue?style=flat-square&amp;amp;logo=visualstudiocode&#34; alt=&#34;Visual Studio Code Support&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;hr&gt; &#xA;&lt;picture&gt; &#xA; &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://raw.githubusercontent.com/nrwl/nx-console/master/static/nx-console-ui-dark.png&#34;&gt; &#xA; &lt;img alt=&#34;Nx Console - The UI for Nx &amp;amp; Lerna&#34; src=&#34;https://raw.githubusercontent.com/nrwl/nx-console/master/static/nx-console-ui-light.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;/picture&gt; &#xA;&lt;h2&gt;Why Nx Console?&lt;/h2&gt; &#xA;&lt;p&gt;Developers use both command-line tools and user interfaces. They commit in the terminal, but resolve conflicts in Visual Studio Code or WebStorm. They use the right tool for the job.&lt;/p&gt; &#xA;&lt;p&gt;Nx is a command-line tool, which works great when you want to serve an application or generate a simple component. But it falls short once you start doing advanced things.&lt;/p&gt; &#xA;&lt;p&gt;For instance:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Exploring custom generator collections is hard in the terminal, but it&#39;s easy using Nx Console.&lt;/li&gt; &#xA; &lt;li&gt;Using rarely-used flags is challenging. Do you pass absolute or relative paths? You don&#39;t have to remember any flags, names or paths - Nx Console will help you by providing autocompletion and validating your inputs.&lt;/li&gt; &#xA; &lt;li&gt;Context-switching between your IDE and the browser is annoying. With Nx Console, you can view the nx graph right in VSCode!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Nx Console does all that and more!&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;You can install Nx Console in the following places:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=nrwl.angular-console&#34;&gt;Nx Console for Visual Studio Code&lt;/a&gt; from the Visual Studio Marketplace.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/21060-nx-console&#34;&gt;Nx Console for JetBrains&lt;/a&gt; from the JetBrains Marketplace&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Jetbrains WSL support&lt;/h3&gt; &#xA;&lt;p&gt;The Node interpreter under &lt;strong&gt;Languages &amp;amp; Frameworks&lt;/strong&gt; &amp;gt; &lt;strong&gt;Node.js&lt;/strong&gt; needs to be configured to use the Node executable within the WSL distribution. You can read more on the &lt;a href=&#34;https://www.jetbrains.com/help/webstorm/how-to-use-wsl-development-environment-in-product.html#ws_wsl_node_interpreter_configure&#34;&gt;official Jetbrains docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;True UI for Nx &amp;amp; Lerna&lt;/h2&gt; &#xA;&lt;p&gt;Nx Console is the UI for all Nx workspaces. It works for any generator or any architect commands. Nx Console does not have a specific UI for, say, generating a component. Instead, Nx Console does what the command-line version of Nx does - it analyzes the same meta information to create the needed UI. This means that anything you can do with Nx, you can do with Nx Console. After all, Nx Console is the UI for Nx.&lt;/p&gt; &#xA;&lt;h2&gt;Useful for Both Experts and Beginners&lt;/h2&gt; &#xA;&lt;p&gt;Even though we started building Nx Console as a tool for experts, we also aimed to make Nx Console a great tool for developers who are new to development or Nx. You can create projects, interact with your editor, run generators and commands and install extensions without ever touching the terminal or having to install any node packages globally. Also, Nx Console highlights the properties you are likely to use for built-in generators and commands, so if you haven&#39;t used the CLI, you don&#39;t get overwhelmed.&lt;/p&gt; &#xA;&lt;h1&gt;Learn More&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nx.dev/core-features/integrate-with-editors&#34;&gt;Documentation&lt;/a&gt; - Official documentation with video tutorials&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nx.dev&#34;&gt;nx.dev&lt;/a&gt; - Documentation, Guides and Interactive Tutorials on Nx&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://go.nx.dev/community&#34;&gt;Join the community&lt;/a&gt; - Chat about Nx &amp;amp; Nx Console on the official discord server&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nx.app/company&#34;&gt;Learn more about the team at Nx&lt;/a&gt; - The team at Nx led the development of Nx Console, after working with many Enterprise clients.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;Please read the &lt;a href=&#34;https://github.com/nrwl/nx-console/raw/master/CONTRIBUTING.md&#34;&gt;contributing guidelines&lt;/a&gt;. Pick one of the issues from the &lt;a href=&#34;https://github.com/nrwl/nx-console/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22&#34;&gt;good first issue&lt;/a&gt; list to get started.&lt;/p&gt;</summary>
  </entry>
</feed>