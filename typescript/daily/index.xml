<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub TypeScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-29T01:46:44Z</updated>
  <subtitle>Daily Trending of TypeScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>vue-vine/vue-vine</title>
    <updated>2023-05-29T01:46:44Z</updated>
    <id>tag:github.com,2023-05-29:/vue-vine/vue-vine</id>
    <link href="https://github.com/vue-vine/vue-vine" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Another style of writing Vue components.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Vue Vine&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vue-vine/vue-vine/main/README-CN.md&#34;&gt;中文 README&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Another style of writing Vue components.&lt;/p&gt; &#xA;&lt;h2&gt;Why this ?&lt;/h2&gt; &#xA;&lt;p&gt;There are many discussions in community that hopes for a solution that supports writing multiple Vue components in a single file. That&#39;s why &lt;code&gt;Vue Vine&lt;/code&gt; was born.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Vue vine&lt;/code&gt; was designed to provide more flexibility of managing Vue components. It is a parallel style to SFC.&lt;/p&gt; &#xA;&lt;p&gt;Take a quick view:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vue-vine/vue-vine/main/packages/docs/assets/quick-view.png&#34; alt=&#34;Quick view&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Get started&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;warning:&lt;/strong&gt; For now, &lt;code&gt;Vue Vine&lt;/code&gt; is still under heavily development, please don&#39;t use it in production.&lt;/p&gt; &#xA;&lt;p&gt;You can try the demo by following steps:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/vue-vine/vue-vine.git&#xA;cd vue-vine&#xA;pnpm install&#xA;&#xA;# Start watching the plugin&#39;s building&#xA;pnpm run dev&#xA;&#xA;# Start Playground&#39;s Vite dev server&#xA;pnpm run play&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;You can see the demo in &lt;code&gt;http://localhost:3333/&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;You can add URL query &lt;code&gt;?sfc&lt;/code&gt; to switch back to SFC style example.&lt;/li&gt; &#xA; &lt;li&gt;You can inspect the transforming process in &lt;code&gt;http://localhost:3333/__inspect/&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>bluesky-social/feed-generator</title>
    <updated>2023-05-29T01:46:44Z</updated>
    <id>tag:github.com,2023-05-29:/bluesky-social/feed-generator</id>
    <link href="https://github.com/bluesky-social/feed-generator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ATProto Feed Generator&lt;/h1&gt; &#xA;&lt;p&gt;🚧 Work in Progress 🚧&lt;/p&gt; &#xA;&lt;p&gt;We are actively developing Feed Generator integration into the Bluesky Personal Data Server (PDS). Though we are reasonably confident about the general shape and interfaces laid out here, these interfaces and implementation details &lt;em&gt;are&lt;/em&gt; subject to change.&lt;/p&gt; &#xA;&lt;p&gt;In the meantime, we&#39;ve put together this starter kit for devs. It doesn&#39;t do everything, but it should be enough to get you familiar with the system and started building!&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Feed Generators are services that provide custom algorithms to users through the AT Protocol.&lt;/p&gt; &#xA;&lt;p&gt;They work very simply: the server receives a request from a user&#39;s server and returns a list of &lt;a href=&#34;https://atproto.com/specs/at-uri-scheme&#34;&gt;post URIs&lt;/a&gt; with some optional metadata attached. Those posts are then hydrated into full views by the requesting server and sent back to the client. This route is described in the &lt;a href=&#34;https://atproto.com/lexicons/app-bsky-feed#appbskyfeedgetfeedskeleton&#34;&gt;&lt;code&gt;app.bsky.feed.getFeedSkeleton&lt;/code&gt; lexicon&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A Feed Generator service can host one or more algorithms. The service itself is identified by DID, while each algorithm that it hosts is declared by a record in the repo of the account that created it. For instance, feeds offered by Bluesky will likely be declared in &lt;code&gt;@bsky.app&lt;/code&gt;&#39;s repo. Therefore, a given algorithm is identified by the at-uri of the declaration record. This declaration record includes a pointer to the service&#39;s DID along with some profile information for the feed.&lt;/p&gt; &#xA;&lt;p&gt;The general flow of providing a custom algorithm to a user is as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A user requests a feed from their server (PDS) using the at-uri of the declared feed&lt;/li&gt; &#xA; &lt;li&gt;The PDS resolves the at-uri and finds the DID doc of the Feed Generator&lt;/li&gt; &#xA; &lt;li&gt;The PDS sends a &lt;code&gt;getFeedSkeleton&lt;/code&gt; request to the service endpoint declared in the Feed Generator&#39;s DID doc &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This request is authenticated by a JWT signed by the user&#39;s repo signing key&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The Feed Generator returns a skeleton of the feed to the user&#39;s PDS&lt;/li&gt; &#xA; &lt;li&gt;The PDS hydrates the feed (user info, post contents, aggregates, etc.) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;In the future, the PDS will hydrate the feed with the help of an App View, but for now, the PDS handles hydration itself&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The PDS returns the hydrated feed to the user&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For users, this should feel like visiting a page in the app. Once they subscribe to a custom algorithm, it will appear in their home interface as one of their available feeds.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;ve set up this simple server with SQLite to store and query data. Feel free to switch this out for whichever database you prefer.&lt;/p&gt; &#xA;&lt;p&gt;Next, you will need to do two things:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Implement indexing logic in &lt;code&gt;src/subscription.ts&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;This will subscribe to the repo subscription stream on startup, parse events and index them according to your provided logic.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Implement feed generation logic in &lt;code&gt;src/algos&lt;/code&gt;&lt;/p&gt; &lt;p&gt;For inspiration, we&#39;ve provided a very simple feed algorithm (&lt;code&gt;whats-alf&lt;/code&gt;) that returns all posts related to the titular character of the TV show ALF.&lt;/p&gt; &lt;p&gt;You can either edit it or add another algorithm alongside it. The types are in place, and you will just need to return something that satisfies the &lt;code&gt;SkeletonFeedPost[]&lt;/code&gt; type.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;We&#39;ve taken care of setting this server up with a did:web. However, you&#39;re free to switch this out for did:plc if you like - you may want to if you expect this Feed Generator to be long-standing and possibly migrating domains.&lt;/p&gt; &#xA;&lt;h3&gt;Publishing your feed&lt;/h3&gt; &#xA;&lt;p&gt;To publish your feed, go to the script at &lt;code&gt;scripts/publishFeedGen.ts&lt;/code&gt; and fill in the variables at the top. Examples are included, and some are optional. To publish your feed generator, simply run &lt;code&gt;yarn publishFeed&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To update your feed&#39;s display data (name, avatar, description, etc.), just update the relevant variables and re-run the script.&lt;/p&gt; &#xA;&lt;p&gt;After successfully running the script, you should be able to see your feed from within the app, as well as share it by embedding a link in a post (similar to a quote post).&lt;/p&gt; &#xA;&lt;h2&gt;Running the Server&lt;/h2&gt; &#xA;&lt;p&gt;Install dependencies with &lt;code&gt;yarn&lt;/code&gt; and then run the server with &lt;code&gt;yarn start&lt;/code&gt;. This will start the server on port 3000, or what&#39;s defined in &lt;code&gt;.env&lt;/code&gt;. You can then watch the firehose output in the console and access the output of the default custom ALF feed at &lt;a href=&#34;http://localhost:3000/xrpc/app.bsky.feed.getFeedSkeleton?feed=at://did:example:alice/app.bsky.feed.generator/whats-alf&#34;&gt;http://localhost:3000/xrpc/app.bsky.feed.getFeedSkeleton?feed=at://did:example:alice/app.bsky.feed.generator/whats-alf&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Some Details&lt;/h2&gt; &#xA;&lt;h3&gt;Skeleton Metadata&lt;/h3&gt; &#xA;&lt;p&gt;The skeleton that a Feed Generator puts together is, in its simplest form, a list of post URIs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;[&#xA;  {post: &#39;at://did:example:1234/app.bsky.feed.post/1&#39;},&#xA;  {post: &#39;at://did:example:1234/app.bsky.feed.post/2&#39;},&#xA;  {post: &#39;at://did:example:1234/app.bsky.feed.post/3&#39;}&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, we include an additional location to attach some context. Here is the full schema:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;type SkeletonItem = {&#xA;  post: string // post URI&#xA;&#xA;  // optional reason for inclusion in the feed&#xA;  // (generally to be displayed in client)&#xA;  reason?: Reason&#xA;}&#xA;&#xA;// for now, the only defined reason is a repost, but this is open to extension&#xA;type Reason = ReasonRepost&#xA;&#xA;type ReasonRepost = {&#xA;  $type: &#39;app.bsky.feed.defs#skeletonReasonRepost&#39;&#xA;  repost: string // repost URI&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This metadata serves two purposes:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;To aid the PDS in hydrating all relevant post information&lt;/li&gt; &#xA; &lt;li&gt;To give a cue to the client in terms of context to display when rendering a post&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Authentication&lt;/h3&gt; &#xA;&lt;p&gt;If you are creating a generic feed that does not differ for different users, you do not need to check auth. But if a user&#39;s state (such as follows or likes) is taken into account, we &lt;em&gt;strongly&lt;/em&gt; encourage you to validate their auth token.&lt;/p&gt; &#xA;&lt;p&gt;Users are authenticated with a simple JWT signed by the user&#39;s repo signing key.&lt;/p&gt; &#xA;&lt;p&gt;This JWT header/payload takes the format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const header = {&#xA;  type: &#34;JWT&#34;,&#xA;  alg: &#34;ES256K&#34; // (key algorithm) - in this case secp256k1&#xA;}&#xA;const payload = {&#xA;  iss: &#34;did:example:alice&#34;, // (issuer) the requesting user&#39;s DID&#xA;  aud: &#34;did:example:feedGenerator&#34;, // (audience) the DID of the Feed Generator&#xA;  exp: 1683643619 // (expiration) unix timestamp in seconds&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We provide utilities for verifying user JWTs in the &lt;code&gt;@atproto/xrpc-server&lt;/code&gt; package, and you can see them in action in &lt;code&gt;src/auth.ts&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Pagination&lt;/h3&gt; &#xA;&lt;p&gt;You&#39;ll notice that the &lt;code&gt;getFeedSkeleton&lt;/code&gt; method returns a &lt;code&gt;cursor&lt;/code&gt; in its response and takes a &lt;code&gt;cursor&lt;/code&gt; param as input.&lt;/p&gt; &#xA;&lt;p&gt;This cursor is treated as an opaque value and fully at the Feed Generator&#39;s discretion. It is simply passed through the PDS directly to and from the client.&lt;/p&gt; &#xA;&lt;p&gt;We strongly encourage that the cursor be &lt;em&gt;unique per feed item&lt;/em&gt; to prevent unexpected behavior in pagination.&lt;/p&gt; &#xA;&lt;p&gt;We recommend, for instance, a compound cursor with a timestamp + a CID: &lt;code&gt;1683654690921::bafyreia3tbsfxe3cc75xrxyyn6qc42oupi73fxiox76prlyi5bpx7hr72u&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Suggestions for Implementation&lt;/h2&gt; &#xA;&lt;p&gt;How a feed generator fulfills the &lt;code&gt;getFeedSkeleton&lt;/code&gt; request is completely at their discretion. At the simplest end, a Feed Generator could supply a &#34;feed&#34; that only contains some hardcoded posts.&lt;/p&gt; &#xA;&lt;p&gt;For most use cases, we recommend subscribing to the firehose at &lt;code&gt;com.atproto.sync.subscribeRepos&lt;/code&gt;. This websocket will send you every record that is published on the network. Since Feed Generators do not need to provide hydrated posts, you can index as much or as little of the firehose as necessary.&lt;/p&gt; &#xA;&lt;p&gt;Depending on your algorithm, you likely do not need to keep posts around for long. Unless your algorithm is intended to provide &#34;posts you missed&#34; or something similar, you can likely garbage collect any data that is older than 48 hours.&lt;/p&gt; &#xA;&lt;p&gt;Some examples:&lt;/p&gt; &#xA;&lt;h3&gt;Reimplementing What&#39;s Hot&lt;/h3&gt; &#xA;&lt;p&gt;To reimplement &#34;What&#39;s Hot&#34;, you may subscribe to the firehose and filter for all posts and likes (ignoring profiles/reposts/follows/etc.). You would keep a running tally of likes per post and when a PDS requests a feed, you would send the most recent posts that pass some threshold of likes.&lt;/p&gt; &#xA;&lt;h3&gt;A Community Feed&lt;/h3&gt; &#xA;&lt;p&gt;You might create a feed for a given community by compiling a list of DIDs within that community and filtering the firehose for all posts from users within that list.&lt;/p&gt; &#xA;&lt;h3&gt;A Topical Feed&lt;/h3&gt; &#xA;&lt;p&gt;To implement a topical feed, you might filter the algorithm for posts and pass the post text through some filtering mechanism (an LLM, a keyword matcher, etc.) that filters for the topic of your choice.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Chainlit/chainlit</title>
    <updated>2023-05-29T01:46:44Z</updated>
    <id>tag:github.com,2023-05-29:/Chainlit/chainlit</id>
    <link href="https://github.com/Chainlit/chainlit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Build Python LLM apps in minutes ⚡️&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Welcome to Chainlit 👋&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Build Python LLM apps in minutes ⚡️&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Chainlit lets you create ChatGPT-like UIs on top of any Python code in minutes! Some of the key features include intermediary steps visualisation, element management &amp;amp; display (images, text, carousel, etc.) as well as cloud deployment.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/ZThrUxbAYw&#34;&gt;&lt;img src=&#34;https://dcbadge.vercel.app/api/server/ZThrUxbAYw?style=flat&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/chainlit_io&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/url/https/twitter.com/chainlit_io.svg?style=social&amp;amp;label=Follow%20%40chainlit_io&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Chainlit/chainlit/actions/workflows/ci.yaml&#34;&gt;&lt;img src=&#34;https://github.com/Chainlit/chainlit/actions/workflows/ci.yaml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Open a terminal and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pip install chainlit&#xA;$ chainlit hello&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If this opens the &lt;code&gt;hello app&lt;/code&gt; in your browser, you&#39;re all set!&lt;/p&gt; &#xA;&lt;h2&gt;📖 Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://docs.chainlit.io&#34;&gt;here&lt;/a&gt; for full documentation on:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Getting started (installation, simple examples)&lt;/li&gt; &#xA; &lt;li&gt;Examples&lt;/li&gt; &#xA; &lt;li&gt;Reference (full API docs)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;🚀 Quickstart&lt;/h2&gt; &#xA;&lt;h3&gt;🐍 Pure Python&lt;/h3&gt; &#xA;&lt;p&gt;Create a new file &lt;code&gt;demo.py&lt;/code&gt; with the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import chainlit as cl&#xA;&#xA;&#xA;@cl.on_message  # this function will be called every time a user inputs a message in the UI&#xA;def main(message: str):&#xA;    # this is an intermediate step&#xA;    cl.Message(author=&#34;Tool 1&#34;, content=f&#34;Response from tool1&#34;, indent=1).send()&#xA;&#xA;    # send back the final answer&#xA;    cl.Message(content=f&#34;This is the final answer&#34;).send()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now run it!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ chainlit run demo.py -w&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Chainlit/chainlit/main/images/quick-start.png&#34; alt=&#34;Quick Start&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;🔗 With LangChain&lt;/h3&gt; &#xA;&lt;p&gt;Checkout our plug and play &lt;a href=&#34;https://docs.chainlit.io/langchain&#34;&gt;integration&lt;/a&gt; with LangChain!&lt;/p&gt; &#xA;&lt;h2&gt;🛣 Roadmap&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; New UI elements (spreadsheet, video, carousel...)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Create your own UI elements via component framework&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; DAG-based chain-of-thought interface&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Support more LLMs in the prompt playground&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; App deployment&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Tell us what you would like to see added in Chainlit using the Github issues or on &lt;a href=&#34;https://discord.gg/ZThrUxbAYw&#34;&gt;Discord&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;💁 Contributing&lt;/h2&gt; &#xA;&lt;p&gt;As an open-source initiative in a rapidly evolving domain, we welcome contributions, be it through the addition of new features or the improvement of documentation.&lt;/p&gt; &#xA;&lt;p&gt;For detailed information on how to contribute, see &lt;a href=&#34;https://raw.githubusercontent.com/Chainlit/chainlit/main/.github/CONTRIBUTING.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Chainlit is open-source and licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/Chainlit/chainlit/main/LICENSE&#34;&gt;Apache 2.0&lt;/a&gt; license.&lt;/p&gt;</summary>
  </entry>
</feed>