<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub TypeScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-14T01:47:55Z</updated>
  <subtitle>Daily Trending of TypeScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>xiaolai/everyone-can-use-english</title>
    <updated>2024-01-14T01:47:55Z</updated>
    <id>tag:github.com,2024-01-14:/xiaolai/everyone-can-use-english</id>
    <link href="https://github.com/xiaolai/everyone-can-use-english" rel="alternate"></link>
    <summary type="html">&lt;p&gt;人人都能用英语&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;人人都能用英语&lt;/h1&gt; &#xA;&lt;h2&gt;目录&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xiaolai/everyone-can-use-english/main/book/README.md&#34;&gt;简介&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xiaolai/everyone-can-use-english/main/book/chapter1.md&#34;&gt;第一章：起点&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xiaolai/everyone-can-use-english/main/book/chapter2.md&#34;&gt;第二章：口语&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xiaolai/everyone-can-use-english/main/book/chapter3.md&#34;&gt;第三章：语音&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xiaolai/everyone-can-use-english/main/book/chapter4.md&#34;&gt;第四章：朗读&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xiaolai/everyone-can-use-english/main/book/chapter5.md&#34;&gt;第五章：词典&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xiaolai/everyone-can-use-english/main/book/chapter6.md&#34;&gt;第六章：语法&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xiaolai/everyone-can-use-english/main/book/chapter7.md&#34;&gt;第七章：精读&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xiaolai/everyone-can-use-english/main/book/chapter8.md&#34;&gt;第八章：叮嘱&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xiaolai/everyone-can-use-english/main/book/end.md&#34;&gt;后记&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;应用&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xiaolai/everyone-can-use-english/main/enjoy/README.md&#34;&gt;Enjoy App&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;* 开发者&lt;/h2&gt; &#xA;&lt;h3&gt;本地启动&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yarn install&#xA;yarn start:enjoy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;编译&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yarn make:enjoy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;* 普通小白用户&lt;/h2&gt; &#xA;&lt;p&gt;方法一：这是&lt;strong&gt;最直接简单的方法&lt;/strong&gt;是去 &lt;a href=&#34;https://github.com/xiaolai/everyone-can-use-english/tags&#34;&gt;releases 页面&lt;/a&gt;下载相应的安装文件。&lt;/p&gt; &#xA;&lt;p&gt;方法二：如果想要随时&lt;strong&gt;试用更新版本&lt;/strong&gt;的话，请按一下步骤操作。&lt;/p&gt; &#xA;&lt;h3&gt;MacOS 用户&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;打开命令行工具 Terminal&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;安装 Homebrew（请参阅这篇文章：《&lt;a href=&#34;https://github.com/xiaolai/apple-computer-literacy/raw/main/start-from-terminal.md&#34;&gt;从 Terminal 开始…&lt;/a&gt;》）&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;安装 yarn：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install yarn&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;克隆此仓库至本地，而后安装、启动：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~&#xA;mkdir github&#xA;cd github&#xA;git clone https://github.com/xiaolai/everyone-can-use-english&#xA;cd everyone-can-use-english&#xA;yarn install&#xA;yarn start:enjoy&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Windows 用户&lt;/h3&gt; &#xA;&lt;p&gt;系统要求：Windows 10 22H2 以上版本、 &lt;a href=&#34;https://aka.ms/wmf5download&#34;&gt;Windows PowerShell 5.1&lt;/a&gt; 以上版本、互联网网络连接正常。&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;将鼠标移至任务栏的 “Windows 徽标” 上单击右键，选择 “PowerShell”&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;tips 1 ：在最新的 Windows 11 上，你看不到 “PowerShell” 选项，只有 “终端”&lt;/p&gt; &#xA;   &lt;p&gt;tips 2 ：不能用管理员权限运行 PowerShell ，否则会导致 Scoop 安装失败&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;在弹出的 PowerShell 窗口中依次执行运行以下命令，安装Scoop：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# 设置 PowerShell 执行策略&#xA;Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser&#xA;# 下载安装脚本&#xA;irm get.scoop.sh -outfile &#39;install.ps1&#39;&#xA;# 执行安装, --ScoopDir 参数指定 Scoop 安装路径&#xA;.\install.ps1 -ScoopDir &#39;C:\Scoop&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;如果出现下面的错误：&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;&lt;span style=&#34;color:red&#34;&gt;irm : 未能解析此远程名称: &#39;raw.githubusercontent.com&#39;&lt;/span&gt;&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;p&gt;说明你的&lt;strong&gt;网络连接&lt;/strong&gt;有问题，请自行研究解决：&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;安装 Nodejs 和 yarn 以及其他依赖环境 ：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;scoop install nodejs&#xA;scoop install git&#xA;npm install yarn -D&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;克隆此仓库至本地，而后安装 Enjoy APP：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;cd ~&#xA;mkdir github&#xA;cd github&#xA;git clone https://github.com/xiaolai/everyone-can-use-english&#xA;cd everyone-can-use-english&#xA;cd enjoy&#xA;yarn install&#xA;yarn start:enjoy&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;出现 &lt;code&gt;Completed in XXXXXXXXXX&lt;/code&gt; 类似字样说明安装成功！&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;运行 Enjoy APP ，在终端执行下列命令：&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;yarn start:enjoy&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>jito-labs/mev-bot</title>
    <updated>2024-01-14T01:47:55Z</updated>
    <id>tag:github.com,2024-01-14:/jito-labs/mev-bot</id>
    <link href="https://github.com/jito-labs/mev-bot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Jito Backrun Arb Bot&lt;/h1&gt; &#xA;&lt;p&gt;The Jito Backrun Arb Bot is designed to perform backrun arbs on the Solana blockchain, specifically targeting SOL and USDC trades. It utilizes the Jito mempool and bundles to backrun trades, focusing on circular arbitrage strategies. The bot supports multiple platforms including Raydium, Raydium CLMM, Orca Whirlpools, and Orca AMM pools.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Backrunning in the context of decentralized finance (DeFi) is a strategy that takes advantage of the public nature of blockchain transactions. When a large trade is made on a decentralized exchange (DEX), it can cause a temporary imbalance in the price of the traded assets. A backrun is a type of arbitrage where a trader, or in this case a bot, sees this incoming trade and quickly places their own right after it, aiming to profit from the price imbalance.&lt;/p&gt; &#xA;&lt;p&gt;The Jito Backrun Arb Bot implements this strategy in three main steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Identifying trades to backrun&lt;/strong&gt;: The bot monitors the mempool for large incoming trades that could cause a significant price imbalance.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Finding a profitable backrun arbitrage route&lt;/strong&gt;: The bot calculates potential profits from various arbitrage routes that could correct the price imbalance.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Executing the arbitrage transaction&lt;/strong&gt;: The bot places its own trade immediately after the large trade is executed, then completes the arbitrage route to return the market closer to its original balance.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://showme.redstarplugin.com/d/ZeHqaNDh&#34; alt=&#34;Backrun Strategy Diagram&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Detailed Explanation&lt;/h2&gt; &#xA;&lt;h3&gt;Identifying Trades to Backrun&lt;/h3&gt; &#xA;&lt;p&gt;The first step in the backrun strategy is to identify trades that can be backrun. This involves monitoring the mempool, which is a stream of pending transactions. For example, if a trade involving the sale of 250M BONK for 100 USDC on the Raydium exchange is detected, this trade can potentially be backrun.&lt;/p&gt; &#xA;&lt;p&gt;To determine the direction and size of the trade, the bot simulates the transaction and observes the changes in the account balances. If the USDC vault for the BONK-USDC pair on Raydium decreases by $100, it indicates that someone sold BONK for 100 USDC. This means that the backrun will be at most 100 USDC to bring the markets back in balance.&lt;/p&gt; &#xA;&lt;p&gt;During this process, the bot listens to the mempool for all transactions that touch any of the relevant decentralized exchanges (DEXs) using the &lt;code&gt;programSubscribe&lt;/code&gt; function (see &lt;code&gt;mempool.ts&lt;/code&gt;). Many transactions use lookup tables that need to be resolved first before we know whether the transaction includes any of the relevant vaults. The &lt;code&gt;lookup-table-provider.ts&lt;/code&gt; is used for this purpose.&lt;/p&gt; &#xA;&lt;h3&gt;Finding Profitable Backrun Arbitrage&lt;/h3&gt; &#xA;&lt;p&gt;The next step is to find a profitable backrun arbitrage opportunity. This involves considering all possible 2 and 3 hop routes. A hop is a pair, and in this context, it refers to a trade from one asset to another.&lt;/p&gt; &#xA;&lt;p&gt;For example, if the original trade was a sale of BONK for USD on Raydium, the possible routes for backrun arbitrage could be:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Buy BONK for USD on Raydium -&amp;gt; Sell BONK for USDC on another exchange (2 hop)&lt;/li&gt; &#xA; &lt;li&gt;Buy BONK for USD on Raydium -&amp;gt; Sell BONK for SOL on Raydium -&amp;gt; Sell SOL for USDC on another exchange (3 hop)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The bot calculates the potential profit for each route in increments of the original trade size divided by a predefined number of steps (&lt;code&gt;ARB_CALCULATION_NUM_STEPS&lt;/code&gt;). The route with the highest potential profit is selected for the actual backrun.&lt;/p&gt; &#xA;&lt;p&gt;For accurate calculations, the bot needs recent pool data. On startup, the bot subscribes to Geyser for all pool account changes. To perform the actual math, the bot uses Amm objects from the Jupiter SDK. These &#34;calculator&#34; objects are initialized and updated with the pool data from Geyser and can be used to calculate a quote. Each worker thread has its own set of these Amm objects, one for each pool (see &lt;code&gt;markets/amm-calc-worker.ts&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Executing the Arbitrage Transaction&lt;/h3&gt; &#xA;&lt;p&gt;The final step is to execute the arbitrage transaction. To do this without providing capital, the bot uses flashloans from Solend, a decentralized lending platform.&lt;/p&gt; &#xA;&lt;p&gt;The basic structure of the arbitrage transaction is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Borrow SOL or USDC from Solend using a flashloan&lt;/li&gt; &#xA; &lt;li&gt;Execute the arbitrage route using the Jupiter program&lt;/li&gt; &#xA; &lt;li&gt;Repay the flashloan&lt;/li&gt; &#xA; &lt;li&gt;Tip the validator&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The Jupiter program is used because it supports multi-hop swaps, which are necessary for executing the arbitrage route.&lt;/p&gt; &#xA;&lt;p&gt;However, one challenge with executing the transaction is the transaction size. Some hops require a lot of accounts, which can make the transaction too large. To address this, the bot uses lookup tables to reduce the transaction size.&lt;/p&gt; &#xA;&lt;p&gt;However, there&#39;s a constraint with jito bundles: a transaction in a bundle cannot use a lookup table that has been modified in the same bundle. To work around this, the bot caches all lookup tables it encounters in txns from the mempool in the &lt;code&gt;lookup-table-provider.ts&lt;/code&gt; and then selects up to the three lookup tables that decrease the transaction size the most. This solution works well, especially after the bot has been running for a while.&lt;/p&gt; &#xA;&lt;p&gt;Once the transaction is executed, the bot queries the RPC for the backrun transaction after a delay of 30 seconds. The result and other data are then recorded in a CSV file.&lt;/p&gt; &#xA;&lt;h2&gt;How to run&lt;/h2&gt; &#xA;&lt;h3&gt;Pre-requisites&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;block engine api keypair (see &lt;a href=&#34;https://jito-labs.gitbook.io/mev/searcher-resources/getting-started&#34;&gt;https://jito-labs.gitbook.io/mev/searcher-resources/getting-started&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;RPC running &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;jito-solana (because bot uses simulateBundle rpc call)&lt;/li&gt; &#xA;   &lt;li&gt;jito geyser plugin &lt;a href=&#34;https://github.com/jito-foundation/geyser-grpc-plugin&#34;&gt;https://github.com/jito-foundation/geyser-grpc-plugin&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;no rate limit (doing a lot of getAccountInfo on startup and sometimes a lot of simulations)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;keypair of wallet with some sol&lt;/li&gt; &#xA; &lt;li&gt;multicore linux machine, preferably in same region with rpc and block engine&lt;/li&gt; &#xA; &lt;li&gt;16gb of ram for running the bot with 4 worker threads&lt;/li&gt; &#xA; &lt;li&gt;nodejs 16 and yarn installed&lt;/li&gt; &#xA; &lt;li&gt;docker installed (optional)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Run directly&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Copy &lt;code&gt;.env.example&lt;/code&gt; to &lt;code&gt;.env&lt;/code&gt; and fill in the values. &lt;code&gt;AUTH_KEYPAIR_PATH&lt;/code&gt; is your block engine api keypair and &lt;code&gt;PAYER_KEYPAIR_PATH&lt;/code&gt; is your wallet keypair.&lt;/li&gt; &#xA; &lt;li&gt;Run the following commands:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yarn install&#xA;yarn start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Run with docker&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Copy &lt;code&gt;.env.docker.example&lt;/code&gt; to &lt;code&gt;.env.docker&lt;/code&gt; and fill in the values. Leave &lt;code&gt;AUTH_KEYPAIR_PATH&lt;/code&gt; and &lt;code&gt;PAYER_KEYPAIR_PATH&lt;/code&gt; in the .env as they are.&lt;/li&gt; &#xA; &lt;li&gt;Run the following commands:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo docker build . -t mev-bot&#xA;export AUTH_KEYPAIR_PATH=/path/to/your/block/engine/keypair.json&#xA;export PAYER_KEYPAIR_PATH=/path/to/your/wallet/keypair.json&#xA;touch docker.trades.csv&#xA;sudo docker run \&#xA;    -d \&#xA;    -v $AUTH_KEYPAIR_PATH:/usr/src/app/auth.json:ro \&#xA;    -v $PAYER_KEYPAIR_PATH:/usr/src/app/payer.json:ro \&#xA;    -v $PWD/docker.trades.csv:/usr/src/app/trades.csv \&#xA;    --env-file .env.docker.local \&#xA;    --restart=on-failure \&#xA;    mev-bot&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Directory Structure&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;./analyze/&lt;/code&gt; - jupyter notebook for analyzing trades from the csv&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;./update-pool-lists.sh&lt;/code&gt; - script for updating list of all pools&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;./src/bot.ts&lt;/code&gt; - entrypoint for the bot&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;./src/clients/&lt;/code&gt; - clients for rpc, block engine and geyser&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;./src/markets/&lt;/code&gt; - logic for getting all the pools and calculating routes on them&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>sparrow-js/ant-codeAI</title>
    <updated>2024-01-14T01:47:55Z</updated>
    <id>tag:github.com,2024-01-14:/sparrow-js/ant-codeAI</id>
    <link href="https://github.com/sparrow-js/ant-codeAI" rel="alternate"></link>
    <summary type="html">&lt;p&gt;AI generate code&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ant-codeAI&lt;/h1&gt; &#xA;&lt;p&gt;English · &lt;a href=&#34;https://raw.githubusercontent.com/sparrow-js/ant-codeAI/main/README-zh_CN.md&#34;&gt;中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;By using OpenAI and Gemini technologies to generate highly available code, it supports web (React, Vue, Tailwind CSS), native (react native) and other codes. It is generated using GPT-4 Vision. Code is generated by taking screenshots, drawing drafts, and inputting ideas.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sparrow-js/ant-codeAI/assets/59440091/e53fae82-d797-4a52-a1a7-a327bc3917a4&#34;&gt;https://github.com/sparrow-js/ant-codeAI/assets/59440091/e53fae82-d797-4a52-a1a7-a327bc3917a4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Editing support (HTML+Tailwind, react+Tailwind) &lt;img width=&#34;1206&#34; alt=&#34;Editing support (HTML+Tailwind, react+Tailwind)&#34; src=&#34;https://github.com/sparrow-js/ant-codeAI/assets/59440091/9e1be3c2-5fff-40e9-bba0-ddbdad68a586&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;🚀 Try It Out!&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://www.ancodeai.com/&#34;&gt;online&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;You can download it and run it locally.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm run dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;🛠 Setting&lt;/h2&gt; &#xA;&lt;p&gt;Supports OpenAI, Gemini (free), Gemini output is not good&lt;/p&gt; &#xA;&lt;img width=&#34;536&#34; alt=&#34;setting&#34; src=&#34;https://github.com/sparrow-js/ant-codeAI/assets/59440091/f92b0363-a0ce-4b51-887c-bb79b347c2d7&#34;&gt; &#xA;&lt;p&gt;OpenAI：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;OpenAI API Key&lt;/li&gt; &#xA; &lt;li&gt;OpenAI Base URL(proxy url, default：&lt;a href=&#34;https://api.openai.com/v1&#34;&gt;https://api.openai.com/v1&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Mock AI Response(mock AIThe returned data does not directly request AI)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Gemini（free）：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Gemini API key&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Generate&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Original&lt;/th&gt; &#xA;   &lt;th&gt;Generate&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img width=&#34;1090&#34; alt=&#34;截屏2023-12-16 上午12 14 18&#34; src=&#34;https://github.com/sparrow-js/ant-codeAI/assets/59440091/0620753c-9c48-4878-a40f-3d79e40f1230&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img width=&#34;910&#34; alt=&#34;截屏2023-12-16 上午8 41 15&#34; src=&#34;https://github.com/sparrow-js/ant-codeAI/assets/59440091/18fd642c-9f92-4b76-a20d-7a59c6905256&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img width=&#34;1091&#34; alt=&#34;截屏2023-12-17 下午1 38 21&#34; src=&#34;https://github.com/sparrow-js/ant-codeAI/assets/59440091/e973ba23-3dc8-484f-9aed-793271a286e8&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img width=&#34;1055&#34; alt=&#34;截屏2023-12-17 下午1 38 48&#34; src=&#34;https://github.com/sparrow-js/ant-codeAI/assets/59440091/414fd1fd-6288-4e20-9f7e-9d279ab3808c&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;if this project is helpful to you, buy me a coffee.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.buymeacoffee.com/sparrowwhtl&#34;&gt;&lt;img src=&#34;https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png&#34; alt=&#34;&amp;quot;Buy Me A Coffee&amp;quot;&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>