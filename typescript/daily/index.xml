<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub TypeScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-18T01:39:49Z</updated>
  <subtitle>Daily Trending of TypeScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>obsidianmd/obsidian-sample-plugin</title>
    <updated>2022-10-18T01:39:49Z</updated>
    <id>tag:github.com,2022-10-18:/obsidianmd/obsidian-sample-plugin</id>
    <link href="https://github.com/obsidianmd/obsidian-sample-plugin" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Obsidian Sample Plugin&lt;/h1&gt; &#xA;&lt;p&gt;This is a sample plugin for Obsidian (&lt;a href=&#34;https://obsidian.md&#34;&gt;https://obsidian.md&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;This project uses Typescript to provide type checking and documentation. The repo depends on the latest plugin API (obsidian.d.ts) in Typescript Definition format, which contains TSDoc comments describing what it does.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The Obsidian API is still in early alpha and is subject to change at any time!&lt;/p&gt; &#xA;&lt;p&gt;This sample plugin demonstrates some of the basic functionality the plugin API can do.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Changes the default font color to red using &lt;code&gt;styles.css&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Adds a ribbon icon, which shows a Notice when clicked.&lt;/li&gt; &#xA; &lt;li&gt;Adds a command &#34;Open Sample Modal&#34; which opens a Modal.&lt;/li&gt; &#xA; &lt;li&gt;Adds a plugin setting tab to the settings page.&lt;/li&gt; &#xA; &lt;li&gt;Registers a global click event and output &#39;click&#39; to the console.&lt;/li&gt; &#xA; &lt;li&gt;Registers a global interval which logs &#39;setInterval&#39; to the console.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;First time developing plugins?&lt;/h2&gt; &#xA;&lt;p&gt;Quick starting guide for new plugin devs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Check if &lt;a href=&#34;https://obsidian.md/plugins&#34;&gt;someone already developed a plugin for what you want&lt;/a&gt;! There might be an existing plugin similar enough that you can partner up with.&lt;/li&gt; &#xA; &lt;li&gt;Make a copy of this repo as a template with the &#34;Use this template&#34; button (login to GitHub if you don&#39;t see it).&lt;/li&gt; &#xA; &lt;li&gt;Clone your repo to a local development folder. For convenience, you can place this folder in your &lt;code&gt;.obsidian/plugins/your-plugin-name&lt;/code&gt; folder.&lt;/li&gt; &#xA; &lt;li&gt;Install NodeJS, then run &lt;code&gt;npm i&lt;/code&gt; in the command line under your repo folder.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;npm run dev&lt;/code&gt; to compile your plugin from &lt;code&gt;main.ts&lt;/code&gt; to &lt;code&gt;main.js&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Make changes to &lt;code&gt;main.ts&lt;/code&gt; (or create new &lt;code&gt;.ts&lt;/code&gt; files). Those changes should be automatically compiled into &lt;code&gt;main.js&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Reload Obsidian to load the new version of your plugin.&lt;/li&gt; &#xA; &lt;li&gt;Enable plugin in settings window.&lt;/li&gt; &#xA; &lt;li&gt;For updates to the Obsidian API run &lt;code&gt;npm update&lt;/code&gt; in the command line under your repo folder.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Releasing new releases&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update your &lt;code&gt;manifest.json&lt;/code&gt; with your new version number, such as &lt;code&gt;1.0.1&lt;/code&gt;, and the minimum Obsidian version required for your latest release.&lt;/li&gt; &#xA; &lt;li&gt;Update your &lt;code&gt;versions.json&lt;/code&gt; file with &lt;code&gt;&#34;new-plugin-version&#34;: &#34;minimum-obsidian-version&#34;&lt;/code&gt; so older versions of Obsidian can download an older version of your plugin that&#39;s compatible.&lt;/li&gt; &#xA; &lt;li&gt;Create new GitHub release using your new version number as the &#34;Tag version&#34;. Use the exact version number, don&#39;t include a prefix &lt;code&gt;v&lt;/code&gt;. See here for an example: &lt;a href=&#34;https://github.com/obsidianmd/obsidian-sample-plugin/releases&#34;&gt;https://github.com/obsidianmd/obsidian-sample-plugin/releases&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Upload the files &lt;code&gt;manifest.json&lt;/code&gt;, &lt;code&gt;main.js&lt;/code&gt;, &lt;code&gt;styles.css&lt;/code&gt; as binary attachments. Note: The manifest.json file must be in two places, first the root path of your repository and also in the release.&lt;/li&gt; &#xA; &lt;li&gt;Publish the release.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;You can simplify the version bump process by running &lt;code&gt;npm version patch&lt;/code&gt;, &lt;code&gt;npm version minor&lt;/code&gt; or &lt;code&gt;npm version major&lt;/code&gt; after updating &lt;code&gt;minAppVersion&lt;/code&gt; manually in &lt;code&gt;manifest.json&lt;/code&gt;. The command will bump version in &lt;code&gt;manifest.json&lt;/code&gt; and &lt;code&gt;package.json&lt;/code&gt;, and add the entry for the new version to &lt;code&gt;versions.json&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Adding your plugin to the community plugin list&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Check &lt;a href=&#34;https://github.com/obsidianmd/obsidian-releases/raw/master/plugin-review.md&#34;&gt;https://github.com/obsidianmd/obsidian-releases/blob/master/plugin-review.md&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Publish an initial version.&lt;/li&gt; &#xA; &lt;li&gt;Make sure you have a &lt;code&gt;README.md&lt;/code&gt; file in the root of your repo.&lt;/li&gt; &#xA; &lt;li&gt;Make a pull request at &lt;a href=&#34;https://github.com/obsidianmd/obsidian-releases&#34;&gt;https://github.com/obsidianmd/obsidian-releases&lt;/a&gt; to add your plugin.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clone this repo.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;npm i&lt;/code&gt; or &lt;code&gt;yarn&lt;/code&gt; to install dependencies&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;npm run dev&lt;/code&gt; to start compilation in watch mode.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Manually installing the plugin&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Copy over &lt;code&gt;main.js&lt;/code&gt;, &lt;code&gt;styles.css&lt;/code&gt;, &lt;code&gt;manifest.json&lt;/code&gt; to your vault &lt;code&gt;VaultFolder/.obsidian/plugins/your-plugin-id/&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Improve code quality with eslint (optional)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://eslint.org/&#34;&gt;ESLint&lt;/a&gt; is a tool that analyzes your code to quickly find problems. You can run ESLint against your plugin to find common bugs and ways to improve your code.&lt;/li&gt; &#xA; &lt;li&gt;To use eslint with this project, make sure to install eslint from terminal: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;npm install -g eslint&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;To use eslint to analyze this project use this command: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;eslint main.ts&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;eslint will then create a report with suggestions for code improvement by file and line number.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;If your source code is in a folder, such as &lt;code&gt;src&lt;/code&gt;, you can use eslint with this command to analyze all files in that folder: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;eslint .\src\&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;API Documentation&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/obsidianmd/obsidian-api&#34;&gt;https://github.com/obsidianmd/obsidian-api&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>facebook/memlab</title>
    <updated>2022-10-18T01:39:49Z</updated>
    <id>tag:github.com,2022-10-18:/facebook/memlab</id>
    <link href="https://github.com/facebook/memlab" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A framework for finding JavaScript memory leaks and analyzing heap snapshots&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;memlab&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/facebook/memlab/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-blue.svg?sanitize=true&#34; alt=&#34;Licensed under the MIT License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/facebook/memlab/raw/main/CONTRIBUTING.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/PRs%20-welcome-brightgreen.svg?sanitize=true&#34; alt=&#34;PR&#39;s Welcome&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.npmjs.com/package/memlab&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/v/memlab.svg?style=flat&#34; alt=&#34;npm version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;memlab is an E2E testing and analysis framework for finding JavaScript memory leaks and optimization opportunities.&lt;/p&gt; &#xA;&lt;p&gt;Online Resources:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://facebook.github.io/memlab&#34;&gt;Official Website and Demo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://facebook.github.io/memlab/docs/intro&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://engineering.fb.com/2022/09/12/open-source/memlab/&#34;&gt;Meta Engineering Blog Post&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Browser memory leak detection&lt;/strong&gt; - Write test scenario with puppeteer API, memlab auto diffs JS heap snapshots, filters out memory leaks, and aggregates results.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Object-oriented heap traversing API&lt;/strong&gt; - Supports self-defined memory leak detector and programmatically analyzing JS heap snapshots taken from Chromium-based browsers, Node.js, Electron.js, and Hermes&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Memory CLI toolbox&lt;/strong&gt; - Built-in toolbox and APIs for finding memory optimization opportunities (not necessarily memory leaks)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Memory assertions in Node.js&lt;/strong&gt; - Enables unit test or running node.js program to take a heap snapshot of its own state, do self memory checking, or write advanced memory assertions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;CLI Usage&lt;/h2&gt; &#xA;&lt;p&gt;Install the CLI&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install -g memlab&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Find Memory Leaks&lt;/h3&gt; &#xA;&lt;p&gt;To find memory leaks in Google Maps, you can create a &lt;a href=&#34;https://facebook.github.io/memlab/docs/api/interfaces/core_src.IScenario&#34;&gt;scenario file&lt;/a&gt; defining how to interact with the Google Maps, let&#39;s name it &lt;code&gt;test-google-maps.js&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// initial page load url: Google Maps&#xA;function url() {&#xA;  return &#39;https://www.google.com/maps/@37.386427,-122.0428214,11z&#39;;&#xA;}&#xA;&#xA;// action where we want to detect memory leaks: click the Hotels button&#xA;async function action(page) {&#xA;  // puppeteer page API&#xA;  await page.click(&#39;button[aria-label=&#34;Hotels&#34;]&#39;);&#xA;}&#xA;&#xA;// action where we want to go back to the step before: click clear search&#xA;async function back(page) {&#xA;  // puppeteer page API&#xA;  await page.click(&#39;[aria-label=&#34;Clear search&#34;]&#39;);&#xA;}&#xA;&#xA;module.exports = {action, back, url};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now run memlab with the scenario file, memlab will interact with the web page and detect memory leaks with built-in leak detectors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;memlab run --scenario test-google-maps.js&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;memlab will print memory leak results showing one representative retainer trace for each cluster of leaked objects.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Retainer traces&lt;/strong&gt;: This is the result from &lt;a href=&#34;https://facebook.github.io/memlab/docs/guides/guides-find-leaks&#34;&gt;an example website&lt;/a&gt;, the retainer trace is an object reference chain from the GC root to a leaked object. The trace shows why and how a leaked object is still kept alive in memory. Breaking the reference chain means the leaked object will no longer be reachable from the GC root, and therefore can be garbage collected. By following the leak trace one step at a time, you will be able to find a reference that should be set to null (but it wasn&#39;t due to a bug).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;MemLab found 46 leak(s)&#xA;--Similar leaks in this run: 4--&#xA;--Retained size of leaked objects: 8.3MB--&#xA;[Window] (native) @35847 [8.3MB]&#xA;  --20 (element)---&amp;gt;  [InternalNode] (native) @130981728 [8.3MB]&#xA;  --8 (element)---&amp;gt;  [InternalNode] (native) @130980288 [8.3MB]&#xA;  --1 (element)---&amp;gt;  [EventListener] (native) @131009888 [8.3MB]&#xA;  --1 (element)---&amp;gt;  [V8EventListener] (native) @224808192 [8.3MB]&#xA;  --1 (element)---&amp;gt;  [eventHandler] (closure) @168079 [8.3MB]&#xA;  --context (internal)---&amp;gt;  [&amp;lt;function scope&amp;gt;] (object) @181905 [8.3MB]&#xA;  --bigArray (variable)---&amp;gt;  [Array] (object) @182925 [8.3MB]&#xA;  --elements (internal)---&amp;gt;  [(object elements)] (array) @182929 [8.3MB]&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To get readable trace, the web site under test needs to serve non-minified code (or at least minified code with readable variables, function name, and property names on objects).&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can debug the leak by loading the heap snapshot taken by memlab (saved in &lt;code&gt;$(memlab get-default-work-dir)/data/cur&lt;/code&gt;) in Chrome DevTool and search for the leaked object ID (&lt;code&gt;@182929&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;View Retainer Trace Interactively&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;View memory issues detected by memlab based on a single JavaScript heap snapshot taken from Chromium, Hermes, memlab, or any node.js or Electron.js program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;memlab view-heap --snapshot &amp;lt;PATH TO .heapsnapshot FILE&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can optionally specify a specific heap object with the object&#39;s id: &lt;code&gt;--node-id @28173&lt;/code&gt; to pinpoint a specific object.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/facebook/memlab/main/website/static/img/heap-view.png&#34; alt=&#34;heap-view&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Self-defined leak detector&lt;/strong&gt;: If you want to use a self-defined leak detector, add a &lt;code&gt;filterLeak&lt;/code&gt; callback (&lt;a href=&#34;https://facebook.github.io/memlab/docs/api/interfaces/core_src.IScenario/#-optional-beforeleakfilter-initleakfiltercallback&#34;&gt;doc&lt;/a&gt;) in the scenario file. &lt;code&gt;filterLeak&lt;/code&gt; will be called for every unreleased heap object (&lt;code&gt;node&lt;/code&gt;) allocated by the target interaction.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function filterLeak(node, heap) {&#xA;  // ... your leak detector logic&#xA;  // return true to mark the node as a memory leak&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;heap&lt;/code&gt; is the graph representation of the final JavaScript heap snapshot. For more details, view the &lt;a href=&#34;https://facebook.github.io/memlab/docs/api/interfaces/core_src.IHeapSnapshot&#34;&gt;doc site&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Heap Analysis and Investigation&lt;/h3&gt; &#xA;&lt;p&gt;View which object keeps growing in size during interaction in the previous run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;memlab analyze unbound-object&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Analyze pre-fetched V8/hermes &lt;code&gt;.heapsnapshot&lt;/code&gt; files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;memlab analyze unbound-object --snapshot-dir &amp;lt;DIR_OF_SNAPSHOT_FILES&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;memlab analyze&lt;/code&gt; to view all built-in memory analyses. For extension, view the &lt;a href=&#34;https://facebook.github.io/memlab&#34;&gt;doc site&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;View retainer trace of a particular object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;memlab trace --node-id &amp;lt;HEAP_OBJECT_ID&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;memlab help&lt;/code&gt; to view all CLI commands.&lt;/p&gt; &#xA;&lt;h2&gt;APIs&lt;/h2&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;memlab&lt;/code&gt; npm package to start a E2E run in browser and detect memory leaks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const memlab = require(&#39;memlab&#39;);&#xA;&#xA;const scenario = {&#xA;    // initial page load url&#xA;    url: () =&amp;gt; &#39;https://www.google.com/maps/@37.386427,-122.0428214,11z&#39;,&#xA;&#xA;    // action where we want to detect memory leaks&#xA;    action: async (page) =&amp;gt; await page.click(&#39;button[aria-label=&#34;Hotels&#34;]&#39;),&#xA;&#xA;    // action where we want to go back to the step before&#xA;    back: async (page) =&amp;gt; await page.click(&#39;[aria-label=&#34;Clear search&#34;]&#39;),&#xA;}&#xA;memlab.run({scenario});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Memory Assertions&lt;/h2&gt; &#xA;&lt;p&gt;memlab makes it possible to enable a unit test or running node.js program to take a heap snapshot of its own state, and write advanced memory assertions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// save as example.test.ts&#xA;import type {IHeapSnapshot, Nullable} from &#39;@memlab/core&#39;;&#xA;import {config, takeNodeMinimalHeap} from &#39;@memlab/core&#39;;&#xA;&#xA;class TestObject {&#xA;  public arr1 = [1, 2, 3];&#xA;  public arr2 = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;];&#xA;}&#xA;&#xA;test(&#39;memory test with heap assertion&#39;, async () =&amp;gt; {&#xA;  config.muteConsole = true; // no console output&#xA;&#xA;  let obj: Nullable&amp;lt;TestObject&amp;gt; = new TestObject();&#xA;  // get a heap snapshot of the current program state&#xA;  let heap: IHeapSnapshot = await takeNodeMinimalHeap();&#xA;&#xA;  // call some function that may add references to obj&#xA;  rabbitHole(obj)&#xA;&#xA;  expect(heap.hasObjectWithClassName(&#39;TestObject&#39;)).toBe(true);&#xA;  obj = null;&#xA;&#xA;  heap = await takeNodeMinimalHeap();&#xA;  // if rabbitHole does not have any side effect that&#xA;  // adds new references to obj, then obj can be GCed&#xA;  expect(heap.hasObjectWithClassName(&#39;TestObject&#39;)).toBe(false);&#xA;&#xA;}, 30000);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For other APIs check out the &lt;a href=&#34;https://facebook.github.io/memlab/docs/api/interfaces/core_src.IHeapSnapshot#hasobjectwithclassnameclassname&#34;&gt;API documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;Use node version 16 or above. To build on Windows, please use Git Bash.&lt;/p&gt; &#xA;&lt;p&gt;First build the project as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install&#xA;npm run build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then keep this helper script running to ensure that local changes are picked up and compiled automatically during development:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm run dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: To run the memlab cli locally, make sure to prefix the memlab command with npx from within the memlab repo e.g. &lt;code&gt;npx memlab&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Run tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm run test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;memlab is MIT licensed, as found in the &lt;a href=&#34;https://raw.githubusercontent.com/facebook/memlab/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Check our &lt;a href=&#34;https://raw.githubusercontent.com/facebook/memlab/main/CONTRIBUTING.md&#34;&gt;contributing guide&lt;/a&gt; to learn about how to contribute to the project.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;Check our &lt;a href=&#34;https://raw.githubusercontent.com/facebook/memlab/main/CODE_OF_CONDUCT.md&#34;&gt;Code Of Conduct&lt;/a&gt; to learn more about our contributor standards and expectations.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>shresthagrawal/kevlar</title>
    <updated>2022-10-18T01:39:49Z</updated>
    <id>tag:github.com,2022-10-18:/shresthagrawal/kevlar</id>
    <link href="https://github.com/shresthagrawal/kevlar" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Light client-based RPC Proxy for PoS Ethereum&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Kevlar&lt;/h1&gt; &#xA;&lt;p&gt;Kevlar is a CLI tool to run a light client-based RPC Proxy for PoS Ethereum. Kevlar can be used to make your Metamask or any RPC-based wallet completely trustless! Kevlar first syncs to the latest header of the beacon chain and then starts an RPC server. This local RPC server can be added to MetaMask or any other RPC-based wallet. Every RPC call made by the wallet is now verified using Merkle Inclusion proofs to the latest block header. Currently Kevlar supports two kinds of sync methods: the &lt;strong&gt;Light Sync&lt;/strong&gt; based on the light client sync protocol specified by the Ethereum Specification and the &lt;strong&gt;Optimistic Sync&lt;/strong&gt; (which is 100x faster than Light Sync) based on construction from the research paper &lt;a href=&#34;https://arxiv.org/abs/2209.08673&#34;&gt;Proofs of Proof of Stake in Sublinear Complexity&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Start the RPC Proxy&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm i -g @lightclients/kevlar&#xA;kevlar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The PRC is now available at &lt;code&gt;http://localhost:8546&lt;/code&gt;. Add this local network to metamask.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kevlar --help&#xA;Options:&#xA;      --help        Show help                                          [boolean]&#xA;      --version     Show version number                                [boolean]&#xA;  -n, --network     chain id to start the proxy on (1, 5)        [choices: 1, 5]&#xA;  -c, --client      type of the client          [choices: &#34;light&#34;, &#34;optimistic&#34;]&#xA;  -o, --provers     comma separated prover urls&#xA;  -u, --rpc         rpc url to proxy&#xA;  -p, --port        port to start the proxy                             [number]&#xA;  -a, --beacon-api  beacon chain api URL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build Locally&lt;/h3&gt; &#xA;&lt;p&gt;Clone the repo and perform the following commands&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yarn install&#xA;yarn build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Run Server&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp .env.example .env&#xA;yarn start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deploy Server to heroku&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash src/provers/light-optimistic/deploy-heroku.sh &amp;lt;heroku-app-name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deploy to Docker&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -p 8546:8546 --name kevlar shresthagrawal/kevlar&#xA;curl -X POST --header &#34;Content-type: application/json&#34; --data &#39;{&#34;jsonrpc&#34;:&#34;2.0&#34;,&#34;method&#34;:&#34;eth_blockNumber&#34;,&#34;params&#34;:[],&#34;id&#34;:1}&#39; http://localhost:8546/&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>