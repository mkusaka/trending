<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub TypeScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-01T01:49:17Z</updated>
  <subtitle>Daily Trending of TypeScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>t3-oss/t3-env</title>
    <updated>2023-05-01T01:49:17Z</updated>
    <id>tag:github.com,2023-05-01:/t3-oss/t3-env</id>
    <link href="https://github.com/t3-oss/t3-env" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Typesafe Envs made Simple&lt;/h1&gt; &#xA;&lt;p&gt;Deploying your app with invalid environment variables is a hassle. This package helps you to avoid that.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Core package, no framework specific features&#xA;pnpm add @t3-oss/env-core zod&#xA;# or, with options preconfigured for Next.js&#xA;pnpm add @t3-oss/env-nextjs zod&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Currently only supports Zod (which you&#39;ll need to install separately). Bring your own validation library is on the roadmap.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;For full documentation, see &lt;a href=&#34;https://env.t3.gg&#34;&gt;https://env.t3.gg&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This package supports the full power of Zod, meaning you can use &lt;code&gt;transforms&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt; values.&lt;/p&gt; &#xA;&lt;h3&gt;Define your schema&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// src/env.mjs&#xA;import { createEnv } from &#34;@t3-oss/env-nextjs&#34;;&#xA;import { z } from &#34;zod&#34;;&#xA;&#xA;export const env = createEnv({&#xA;  /*&#xA;   * Serverside Environment variables, not available on the client.&#xA;   * Will throw if you access these variables on the client.&#xA;   */&#xA;  server: {&#xA;    DATABASE_URL: z.string().url(),&#xA;    OPEN_AI_API_KEY: z.string().min(1),&#xA;  },&#xA;  /*&#xA;   * Environment variables available on the client (and server).&#xA;   *&#xA;   * 💡 You&#39;ll get typeerrors if these are not prefixed with NEXT_PUBLIC_.&#xA;   */&#xA;  client: {&#xA;    NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: z.string().min(1),&#xA;  },&#xA;  /*&#xA;   * Due to how Next.js bundles environment variables on Edge and Client,&#xA;   * we need to manually destructure them to make sure all are included in bundle.&#xA;   *&#xA;   * 💡 You&#39;ll get typeerrors if not all variables from `server` &amp;amp; `client` are included here.&#xA;   */&#xA;  runtimeEnv: {&#xA;    DATABASE_URL: process.env.DATABASE_URL,&#xA;    OPEN_AI_API_KEY: process.env.OPEN_AI_API_KEY,&#xA;    NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY:&#xA;      process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY,&#xA;  },&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Use said schema in your app with autocompletion and type inference&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// src/app/hello/route.ts&#xA;import { env } from &#34;../env.mjs&#34;;&#xA;&#xA;export const GET = (req: Request) =&amp;gt; {&#xA;  const DATABASE_URL = env.DATABASE_URL;&#xA;  // use it...&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Bring your own validation library - currently only supports Zod.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Validate that all &lt;code&gt;_input&lt;/code&gt; fields are strings to begin with, transforms may be applied on strings.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>pixiv/ChatVRM</title>
    <updated>2023-05-01T01:49:17Z</updated>
    <id>tag:github.com,2023-05-01:/pixiv/ChatVRM</id>
    <link href="https://github.com/pixiv/ChatVRM" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ChatVRM&lt;/h1&gt; &#xA;&lt;p&gt;ChatVRMはブラウザで簡単に3Dキャラクターと会話ができるデモアプリケーションです。&lt;/p&gt; &#xA;&lt;p&gt;VRMファイルをインポートしてキャラクターに合わせた声の調整や、感情表現を含んだ返答文の生成などを行うことができます。&lt;/p&gt; &#xA;&lt;p&gt;ChatVRMの各機能は主に以下の技術を使用しています。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ユーザーの音声の認識 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/API/SpeechRecognition&#34;&gt;Web Speech API(SpeechRecognition)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;返答文の生成 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://platform.openai.com/docs/api-reference/chat&#34;&gt;ChatGPT API&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;読み上げ音声の生成 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;http://koeiromap.rinna.jp/&#34;&gt;Koeiro API&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;3Dキャラクターの表示 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/pixiv/three-vrm&#34;&gt;@pixiv/three-vrm&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;デモ&lt;/h2&gt; &#xA;&lt;p&gt;GitHub Pagesでデモを公開しています。&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pixiv.github.io/ChatVRM&#34;&gt;https://pixiv.github.io/ChatVRM&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;実行&lt;/h2&gt; &#xA;&lt;p&gt;ローカル環境で実行する場合はこのリポジトリをクローンするか、ダウンロードしてください。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git@github.com:pixiv/ChatVRM.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;必要なパッケージをインストールしてください。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;パッケージのインストールが完了した後、以下のコマンドで開発用のWebサーバーを起動します。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm run dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;実行後、以下のURLにアクセスして動作を確認して下さい。&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://localhost:3000&#34;&gt;http://localhost:3000&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;ChatGPT API&lt;/h2&gt; &#xA;&lt;p&gt;ChatVRMでは返答文の生成にChatGPT APIを使用しています。&lt;/p&gt; &#xA;&lt;p&gt;ChatGPT APIの仕様や利用規約については以下のリンクや公式サイトをご確認ください。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://platform.openai.com/docs/api-reference/chat&#34;&gt;https://platform.openai.com/docs/api-reference/chat&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://openai.com/policies/api-data-usage-policies&#34;&gt;https://openai.com/policies/api-data-usage-policies&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Koeiro API&lt;/h2&gt; &#xA;&lt;p&gt;ChatVRMでは返答文の音声読み上げにKoeiro APIを使用しています。&lt;/p&gt; &#xA;&lt;p&gt;Koeiro APIの仕様や利用規約については以下のリンクや公式サイトをご確認ください。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://koeiromap.rinna.jp/&#34;&gt;http://koeiromap.rinna.jp/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>lens-protocol/momoka</title>
    <updated>2023-05-01T01:49:17Z</updated>
    <id>tag:github.com,2023-05-01:/lens-protocol/momoka</id>
    <link href="https://github.com/lens-protocol/momoka" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Open source code showing how you can verify the DA claims are true&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Momoka&lt;/h1&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/lens-protocol/momoka/master/images/logo.png&#34;&gt; &#xA;&lt;h2&gt;Disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;We would like to emphasize that this project is currently in its beta phase and incorporates new, innovative technology. As with any cutting-edge solution, there may be potential challenges or undiscovered issues that could arise during its initial stages. We are committed to continually refining and improving our offering, and we appreciate your understanding and patience as we work diligently to perfect this technology. Please feel free to provide feedback or report any issues, as your input is invaluable in helping us enhance the user experience and overall functionality of our project.&lt;/p&gt; &#xA;&lt;h1&gt;Momoka explorer&lt;/h1&gt; &#xA;&lt;p&gt;You can explore all momoka transactions on the explorer &lt;a href=&#34;https://momoka.lens.xyz&#34;&gt;here&lt;/a&gt;. It is also open-source &lt;a href=&#34;https://github.com/lens-protocol/momoka-explorer&#34;&gt;https://github.com/lens-protocol/momoka-explorer&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/lens-protocol/momoka/master/images/momoka-explorer.jpg&#34;&gt; &#xA;&lt;h1&gt;Momoka Verifier&lt;/h1&gt; &#xA;&lt;p&gt;The Momoka Verifier enables you to operate a trustless verifier node that validates LENS DA publications in real-time. Additionally, it can serve as an indexer, allowing you to stream and index the data yourself. This open-source solution relies exclusively on software that you can run independently, without any dependency on LENS. This ensures that even if LENS were to cease operation, you would retain access to your content, maintain proof of ownership, and continue to utilize it, all thanks to a decentralized data availability storage layer.&lt;/p&gt; &#xA;&lt;p&gt;For information on how to run this software, please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/lens-protocol/momoka/master/#running&#34;&gt;How to run&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h2&gt;What is Momoka technical definition?&lt;/h2&gt; &#xA;&lt;p&gt;Momoka, a term we&#39;ve due to lens brand, refers to an Optimistic L3 - a hybrid by taking best from both - Optimistic Rollups and L3 technologies. We&#39;ve chosen this approach for several reasons:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Optimistic Rollup is a technique that processes transactions off-chain for enhanced scalability and reduced fees. It typically compresses these transactions back to the main chain, but we&#39;ve excluded this final step in our implementation.&lt;/li&gt; &#xA; &lt;li&gt;L3, while having various definitions, generally involves technology built on top of Layer 2 (L2). Despite some considering Polygon a combination of side-chain and L2, we utilize the Polygon EVM chain to enable transaction proofs, improving the user experience (UX/UI) and overall experience for LENS users. This is why we designate it as L3.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We describe Momoka long form name as an &#34;Optimistic Hybrid-settlement L3&#34; because, in most cases, settlement refers to both storage and verification. However, in this instance, the storage layer is provided by the Data Availability (DA) provider, and the settlement, or proof verification, is conducted using the Polygon chain.&lt;/p&gt; &#xA;&lt;p&gt;As we continue to refine this technology, the technical name may evolve, but we wanted to clarify the rationale behind the current terminology.&lt;/p&gt; &#xA;&lt;h2&gt;What is DA?&lt;/h2&gt; &#xA;&lt;p&gt;DA stands for Data Availability. It refers to the concept of storing data in a decentralized availability layer, which is more cost-effective than storing it on an EVM chain. The DA has no latency, meaning the data is produced and queryable instantly, in contrast to IPFS and EVM chains, which always have latency until they are considered complete. We utilize Arweave and Bundlr for this purpose. Arweave is a decentralized, permanent storage network with over 100 nodes in operation (as writing this documentation); it is being increasingly adopted by various NFT projects. Bundlr enhances Arweave&#39;s scalability while providing DA guarantees, enabling the use of EVM wallets to save DA logic and serving as a tool to rapidly push data to Arweave. DA can be used to store actions like posts, comments, mirrors, and more; initially, we are focusing on publications. The goal is to keep the DA layer affordable and scalable while still verifying transactions on Polygon using EVM simulations. DA requires a one-time payment for data storage and is backed by mathematical and hardware history guarantees.&lt;/p&gt; &#xA;&lt;p&gt;Using this software, you can verify that a particular action would have been executed on-chain. The approach involves performing the same signing actions as you would on an EVM chain, but without actually sending the transaction (which consumes gas to store in the EVM state). Instead, you create a DA standard and save it on a DA layer, complete with proofs and all the required information. This enables ANYONE to cross-check the data, providing 100% proof that the action must have been performed by someone capable of creating the transaction signature and submitting it. This can be demonstrated by simulating the transaction. This approach allows LENS to scale while maintaining the core values of &#34;ownership&#34; and &#34;trust&#34; provided by the blockchain.&lt;/p&gt; &#xA;&lt;h2&gt;Why do we need to use DA?&lt;/h2&gt; &#xA;&lt;p&gt;EVM can store state indefinitely, but at a cost; blockchains were designed for trustless transactional systems. EVM is secured by the network and mined into the chain; the data on-chain is immutable and verifiable at any time, ensuring trust. However, storing data on-chain is expensive, and EVM machines can only process a limited number of transactions per block based on maximum gas limits. Polygon is a shared block space; and at the moment has challenges scaling beyond 50-100 TPS. With 2-second block times, some latency is unavoidable, and max gas limits per block make scaling challenging, if not impossible. For context, Twitter experiences peak rates of 25,000 TPS; while LENS may not require this level of capacity yet, scalability is a critical consideration. This is where DA layers come in; they offer a more affordable solution for storing data with a one-time payment, backed by mathematical guarantees and a history of decreasing hardware costs over time. Moreover, these DA layers are decentralized, preserving this aspect of the system. DA enables scalability beyond 25,000 TPS, and even more; if we aim to revolutionize the world of core social ownership, we must be able to scale accordingly.&lt;/p&gt; &#xA;&lt;h2&gt;What are transactions on EVM machines?&lt;/h2&gt; &#xA;&lt;p&gt;A transaction on an EVM machine alters some form of state; it is signed by the wallet&#39;s private key and then transmitted to the network. The network verifies the signature and executes the transaction, which contains logic that can either succeed or revert. If the transaction reverts, it is not included in the new block; if it succeeds, it is incorporated into the new block and confirmed by other miners. Miners are incentivized to perform these confirmations. This process ensures that transactions cannot be &#34;faked,&#34; as they require a valid signature from a trusted key. Furthermore, a transaction can only succeed or revert—nothing more, nothing less. As the EVM progresses block by block and updates the state each time, it raises the question: what if you performed all steps of a transaction, except actually sending it, for actions that don&#39;t involve transferring funds or trustless executions?&lt;/p&gt; &#xA;&lt;h2&gt;How can DA and EVM work together?&lt;/h2&gt; &#xA;&lt;p&gt;LENS is deployed on Polygon, an EVM-based platform. All actions—such as posts, comments, mirrors, follows, and collects are transactions that are built, signed, and sent to be stored on the EVM machine. In the new system, transactions are still built and require a signature from a wallet that would pass the state on-chain, but they are not actually sent. Instead, the transaction signature and typed data are used to create DA metadata, which is then transmitted to a DA layer containing information such as block number, signed typed data, transaction signature, and other crucial details. This data is structured in a way that can be fully verified with just having an archive node.&lt;/p&gt; &#xA;&lt;p&gt;EVM machines function as large state machines. The EVM JSON-RPC methods allow you to simulate transactions using &lt;code&gt;eth_call&lt;/code&gt;, determining the outcome of a transaction without actually sending it. You can specify a block number to run the simulation and use the signed typed data transaction with the typed data. This can be done with every &lt;code&gt;withSig&lt;/code&gt; method on the LENS contracts. With just a Polygon node, anyone can verify that the data on the DA layer is accurate and would have been valid at that point in time. Since the typed data contains expiry times and nonces, it can be proven in a secure manner and can not be submitted by anyone else, edge cases around this are huge reorg ranges which we cover below.&lt;/p&gt; &#xA;&lt;p&gt;The advantage of this approach is that the data is stored on a decentralized layer, meaning that no centralized entity controls the content. Users retain ownership of their publications, and if any part of LENS were to disappear, all the data would remain verifiable, accessible, and usable by anyone. This demonstrates the power of decentralization, ensuring that users&#39; data cannot be taken away from them.&lt;/p&gt; &#xA;&lt;h2&gt;What does this mean?&lt;/h2&gt; &#xA;&lt;p&gt;This approach allows LENS to scale to a lot higher TPS, which is currently unattainable with an EVM chain, while also providing a more cost-effective solution. This can be achieved without compromising the core ownership of the social graph, and the indexing process remains familiar for app developers. Using this system is optional; those who prefer can continue to store everything on Polygon. However, if a publication doesn&#39;t require the power of a trustless execution layer, there&#39;s no need to use the EVM state.&lt;/p&gt; &#xA;&lt;h2&gt;Momoka vs polygon side by side&lt;/h2&gt; &#xA;&lt;p&gt;Here are diagrams that show how a transaction would look like on Polygon versus a transaction using the DA layer. These diagrams are meant to provide a simplified high-level overview of how the transactions work, while more detailed information is provided below with all the necessary technical details.&lt;/p&gt; &#xA;&lt;h3&gt;Polygon&lt;/h3&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/lens-protocol/momoka/master/images/current-polygon-flow.jpg&#34;&gt; &#xA;&lt;h3&gt;Momoka&lt;/h3&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/lens-protocol/momoka/master/images/momoka-flow.jpg&#34;&gt; &#xA;&lt;h2&gt;Comparison&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/lens-protocol/momoka/master/images/tech-comparison.jpg&#34;&gt; &#xA;&lt;p&gt;The reason momoka security is medium and not high is because in theory a submitter could refuse to process transactions from certain users even though validators could do this as well as we only have 1 for now the fix is more. As we increase more submitters this comes down, also the bad submitters could in theory flood the system without any slashing mechanism. This is a problem that will be solved in the future.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;d like to emphasize that while using Momoka, you can enjoy the benefits of finality, scalability, and cost-effectiveness. However, there is a slight tradeoff in terms of security, especially until we have many verifiers and submitters in the network. This is similar to what would happen to Ethereum&#39;s security if it lost all its validators. It&#39;s a tradeoff we&#39;re willing to make for now during our beta phase. We firmly believe that the advantages of the DA outweigh the disadvantages, even though we cannot start fully decentralized. Nevertheless, we&#39;re committed to working towards that goal with momoka.&lt;/p&gt; &#xA;&lt;h2&gt;Hyperscale&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/lens-protocol/momoka/master/images/hyperscale-for-data.jpg&#34;&gt; &#xA;&lt;h2&gt;Momoka Submitters&lt;/h2&gt; &#xA;&lt;p&gt;To maintain trust, submitters must be held accountable for their actions and face potential penalties for misconduct. Initially, the submitter whitelist will consist of a single address owned by LENS. As the approach is proven, the system can be expanded to allow anyone to become a submitter, with incentives for good behavior and penalties for bad actors. If submitters have nothing to lose, they could flood the system with invalid submissions, overwhelming verifiers and causing delays. During the beta phase, LENS will be responsible for correcting any errors, with bug bounties planned for the post-beta period. Ultimately, the goal is to have multiple submitters contributing to the system. It&#39;s important to note that certain errors, such as &lt;code&gt;UNKNOWN&lt;/code&gt;, &lt;code&gt;CAN_NOT_CONNECT_TO_BUNDLR&lt;/code&gt;, &lt;code&gt;BLOCK_CANT_BE_READ_FROM_NODE&lt;/code&gt;, &lt;code&gt;DATA_CANT_BE_READ_FROM_NODE&lt;/code&gt;, and &lt;code&gt;SIMULATION_NODE_COULD_NOT_RUN&lt;/code&gt;, &lt;code&gt;POTENTIAL_REORG&lt;/code&gt; are related to third-party software issues and not considered critical verifier errors. The verifier will retry these errors later to see if they still pass. Over time, the entire system could become decentralized. For now, this beta approach represents the first attempt at scaling using a hybrid module model.&lt;/p&gt; &#xA;&lt;h3&gt;Momoka Submitters&#39; responsibilities&lt;/h3&gt; &#xA;&lt;p&gt;Submitters are responsible for validating, building up DA metadata, and submitting it to Arweave/Bundlr. After generating proofs with the DA submission, the data is uploaded to Arweave via Bundlr, with an instantaneous response. The submitter must provide proofs that anyone can contest. Verifier software listens for DA publications sent from whitelisted submitter addresses and verifies their validity.&lt;/p&gt; &#xA;&lt;h3&gt;Momoka Submitter flow&lt;/h3&gt; &#xA;&lt;p&gt;The flow diagram shows the submitter flows in detail; the first submitter will be within the LENS API to allow for easy integration for all.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/lens-protocol/momoka/master/images/submitter-flow.jpg&#34;&gt; &#xA;&lt;h3&gt;Momoka Future of decentralised submitters&lt;/h3&gt; &#xA;&lt;p&gt;This is a rough look at how this could work in the future in a trustless manner. This is not the final solution but a rough idea of how it could work on a very high-level vision.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/lens-protocol/momoka/master/images/decentralized-submitters.jpg&#34;&gt; &#xA;&lt;h2&gt;Momoka Verifiers&lt;/h2&gt; &#xA;&lt;p&gt;Verifiers are tasked with monitoring DA publications from submitters and confirming their validity. They must follow specific criteria when evaluating incoming publications, with the primary goal of ensuring the submitter is truthful. Anyone can run a verifier using open-source software and a few commands. The verifier utilizes LevelDB for quick storage of passed results. The code has the capability to use a forked archive node with Foundry&#39;s &lt;code&gt;anvil&lt;/code&gt; for local machine execution. However, for optimal speed, it is recommended to use an archive node directly (Alchemy is suggested but not required). All that&#39;s needed to run a verifier is an archive node.&lt;/p&gt; &#xA;&lt;h2&gt;Momoka Current limitations with DA publications&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;DA publications must use the &lt;code&gt;RevertCollectModule&lt;/code&gt; and no &lt;code&gt;ReferenceModule&lt;/code&gt;. This will be addressed in a future release.&lt;/li&gt; &#xA; &lt;li&gt;For now, DA comments can only be added to other DA publications; they cannot be mixed. This limitation will be explored after the v1 launch.&lt;/li&gt; &#xA; &lt;li&gt;DA mirrors can only mirror DA publications, not Polygon publications. This issue will be addressed post-v1 launch.&lt;/li&gt; &#xA; &lt;li&gt;While it&#39;s not possible to prove DA publications on other DA publications on Polygon (as they are not on-chain), it&#39;s still possible to verify the signatures and transactions as valid. However, simulations cannot be executed in this scenario.&lt;/li&gt; &#xA; &lt;li&gt;When verifying a submission, the pointer is checked as well. Only the first pointer is checked, not unlimited pointers, as the other verifications would have been done by the verifier.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Compatibility with signature-free transactions&lt;/h2&gt; &#xA;&lt;p&gt;A top-class UX is essential for LENS users. DA publications work with the dispatcher, which can post, mirror, or comment on users&#39; behalf. If enabled, this will pass state checks. The LENS contract logic states that if the dispatcher signs on behalf of the user, it will result in a valid transaction. Users who don&#39;t want to trust the dispatcher can still sign the typed data with their wallet and submit it through the submitter. This process is similar to the current flow, but the transaction is sent to a submitter instead of a Polygon node.&lt;/p&gt; &#xA;&lt;h2&gt;Gasless transactions&lt;/h2&gt; &#xA;&lt;p&gt;DA operations don&#39;t require gas, making them free to use. The app still needs to upload the contentURI to a resolvable location, the submitter pays for storage of DA metadata on Arweave/Bundlr, which is significantly cheaper than EVM gas prices (up to 1000x cheaper).&lt;/p&gt; &#xA;&lt;h2&gt;Timestamp proofs for picking the block number&lt;/h2&gt; &#xA;&lt;p&gt;You might be concerned that a submitter could deceive about which block to submit on, but that&#39;s where Bundlr timestamp proofs come into play. In addition, each signature has a deadline that corresponds to the timestamp of an already mined block, rendering the signature invalid if sent. Bundlr enables you to request a timestamp proof that returns the current timestamp while storing it, allowing anyone to verify that the time was generated by them. This becomes our source of truth for determining the appropriate block number to use; we should use the block number closest to the timestamp generated by Bundlr. It&#39;s important to note that latency will inevitably occur due to node software, so if it selects a block number and, upon verification, it is one behind, we consider this an acceptable threshold.&lt;/p&gt; &#xA;&lt;h2&gt;Handling reorgs&lt;/h2&gt; &#xA;&lt;p&gt;A reorg on the EVM chain occurs when the blockchain structure changes, often due to a consensus failure or attack. This can lead to previously confirmed transactions becoming unconfirmed, and vice versa. It has significant security implications, making it crucial to be aware of the potential for reorgs and take measures to mitigate their impact. Developers at Polygon and other organizations working on EVM software are striving to reduce the frequency and depth of reorgs, making the issue less concerning. As a general precaution, waiting before considering a transaction final, much like how centralized exchanges operate, is the safest approach - the longer the wait, the lower the risk of a reorg affecting the transaction. In Momoka&#39;s first beta version, users cannot mix DA actions with EVM on-chain actions, which was implemented intentionally to simplify handling reorgs.&lt;/p&gt; &#xA;&lt;p&gt;Currently, the validator doesn&#39;t recheck proofs once they are validated, as its primary objective is to validate as quickly as possible for the initial proof. However, as we start integrating DA actions with EVM on-chain actions, we will need to incorporate reorg handling and enable the verifier to recheck intelligently.&lt;/p&gt; &#xA;&lt;p&gt;For now, any reorg handling or rechecking must be performed outside of the validator software. For example, the LENS API also monitors reorgs and re-validates proofs if a reorg affects any DA actions.&lt;/p&gt; &#xA;&lt;p&gt;If a transaction is part of a reorg and ends up in a different block or not included at all, the proofs should be re-validated using the new blockchain state, ensuring their validity despite the reorg.&lt;/p&gt; &#xA;&lt;p&gt;As we are not mixing and matching actions we remove a lot of the issues but not all, the edge cases that could cause issues are situations where for example someone sets a dispatcher and then straight away performs an DA action that has the dispatcher sign on their behalf, and then a reorg follows. If the transaction which adds the dispatcher to the profile is not resubmitted or is resubmitted at a higher block number, the proofs would fail. In that case, rerunning the proofs would return a &lt;code&gt;POTENTIAL_REORG&lt;/code&gt; error which is not &#34;bad&#34; in terms of a submitter doing wrong as they could not of predicted it, you can handle this then as needed. Once we start integrating the cross actions, we will handle such cases within the validator.&lt;/p&gt; &#xA;&lt;p&gt;A reorg of the blockchain can potentially affect the signing expiry of transactions. In the unlikely scenario of a severe reorg where time goes backwards on a block, it&#39;s conceivable that a transaction could be submitted to the chain that you never intended to. While this is a highly improbable edge case, it&#39;s essential to be aware of the possibility. As we embark on building the on-chain publications and DA publication connection, we&#39;ll delve deeper into these complex topics.&lt;/p&gt; &#xA;&lt;h2&gt;Future of Momoka&lt;/h2&gt; &#xA;&lt;p&gt;As we said above this is very much in BETA and as we learn, shape and grow the solution we envison the architecture will end up looking something like this, with decentralised submitters and verifiers.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/lens-protocol/momoka/master/images/momoka-network.jpg&#34;&gt; &#xA;&lt;h2&gt;DA publication metadata&lt;/h2&gt; &#xA;&lt;p&gt;We will show you a few examples of the &lt;code&gt;DA&lt;/code&gt; metadata and then explain each field.&lt;/p&gt; &#xA;&lt;h3&gt;Post example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{&#xA;  signature:&#xA;    &#39;0x87866d620636f62aa3930d8c48be37dac77f96f30a9e06748491934fef75e7884a193d59fc486da3ea35f991bbd37a04ea4997e47f191d626ad2b601e3cc57a71c&#39;,&#xA;  dataAvailabilityId: &#39;951a2a24-46fd-4306-8c31-46a8318a905e&#39;,&#xA;  type: DAActionTypes.POST_CREATED,&#xA;  timestampProofs: {&#xA;    type: DAProvider.BUNDLR,&#xA;    hashPrefix: &#39;1&#39;,&#xA;    response: {&#xA;      id: &#39;f7_YMkEqiALN9PCtK5LXxFDlc3EEi20-DWl57KxDMbw&#39;,&#xA;      timestamp: 1674736509185,&#xA;      version: &#39;1.0.0&#39;,&#xA;      public:&#xA;        &#39;sq9JbppKLlAKtQwalfX5DagnGMlTirditXk7y4jgoeA7DEM0Z6cVPE5xMQ9kz_T9VppP6BFHtHyZCZODercEVWipzkr36tfQkR5EDGUQyLivdxUzbWgVkzw7D27PJEa4cd1Uy6r18rYLqERgbRvAZph5YJZmpSJk7r3MwnQquuktjvSpfCLFwSxP1w879-ss_JalM9ICzRi38henONio8gll6GV9-omrWwRMZer_15bspCK5txCwpY137nfKwKD5YBAuzxxcj424M7zlSHlsafBwaRwFbf8gHtW03iJER4lR4GxeY0WvnYaB3KDISHQp53a9nlbmiWO5WcHHYsR83OT2eJ0Pl3RWA-_imk_SNwGQTCjmA6tf_UVwL8HzYS2iyuu85b7iYK9ZQoh8nqbNC6qibICE4h9Fe3bN7AgitIe9XzCTOXDfMr4ahjC8kkqJ1z4zNAI6-Leei_Mgd8JtZh2vqFNZhXK0lSadFl_9Oh3AET7tUds2E7s-6zpRPd9oBZu6-kNuHDRJ6TQhZSwJ9ZO5HYsccb_G_1so72aXJymR9ggJgWr4J3bawAYYnqmvmzGklYOlE_5HVnMxf-UxpT7ztdsHbc9QEH6W2bzwxbpjTczEZs3JCCB3c-NewNHsj9PYM3b5tTlTNP9kNAwPZHWpt11t79LuNkNGt9LfOek&#39;,&#xA;      signature:&#xA;        &#39;Requv25_byuhK_k0JPz2tjKLhmqUv1XGt4My88utf8AHpl8awJKPMUQV3LJIQABMXf9ZsM2RZNiPhKEilkefGD-fTqkZZI5ybHooP8hc-lx2mAdM0XfCw-SC-yhdDU3OoOat7bwVy0HvOJm8xc6HpqgdbnTotX3LuPAo_xEV5GxrB5giK1IY8ZBJEsIjZw6okSzEStfmm94zAG44SmtTDXJk0IpeBpQiiZks63quZkPETGR9nfYl9-5D4UjQZHsx1eqV_9Pa4vYMOnTXD5LB8ysi2C576QjJAFICEZtRF2rXyZm1yfWBY8ODrnoZx-RBB5pqAwqrwA4DBI_UBHmbB7lL_3DK4911bZbC03T1KUw5QZn6eWjnoyxIv_UG9B3Bht0UDPIgGXA2tKeUsdrrh2JPAImZIYXEhC5ZWqn-K4TZa586sGwpQVfHFvCuCA-9X6GspXKDqlqbys6sZk70OOhM4827JIs9dw_Hw8rwsPsGIJjP99x2iOnyH8FQynbW8TCnGQcsO7Xevj-1PGnIAsXqQO6E9_NkYAf8LSfsilY63ZhVNPgLnSS2BAR-28SpHW4GjXtN_nVzE1CoLmL3nczMqHTiZ-xalo_enYg0Ydx-ZqHF7cPrB5rQmR_uB_7zPKK5WgStxwVjHRBJ8MLxmW0Sylzf9K6IwwFy50klQHY&#39;,&#xA;      deadlineHeight: 1106524,&#xA;      block: 1106524,&#xA;      validatorSignatures: [],&#xA;    },&#xA;  },&#xA;  chainProofs: {&#xA;    thisPublication: {&#xA;      signature:&#xA;        &#39;0xa3a969bd1ecdf7ca416340b513fd751df446b922809bd05f25509a98223b69594e4d0e5c27ce01111f80dd2df8ffd5f1af75bd6d663f55c4186ef773da2168ac1c&#39;,&#xA;      signedByDelegate: false,&#xA;      signatureDeadline: 1674736509,&#xA;      typedData: {&#xA;        types: {&#xA;          PostWithSig: [&#xA;            {&#xA;              name: &#39;profileId&#39;,&#xA;              type: &#39;uint256&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;contentURI&#39;,&#xA;              type: &#39;string&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;collectModule&#39;,&#xA;              type: &#39;address&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;collectModuleInitData&#39;,&#xA;              type: &#39;bytes&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;referenceModule&#39;,&#xA;              type: &#39;address&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;referenceModuleInitData&#39;,&#xA;              type: &#39;bytes&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;nonce&#39;,&#xA;              type: &#39;uint256&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;deadline&#39;,&#xA;              type: &#39;uint256&#39;,&#xA;            },&#xA;          ],&#xA;        },&#xA;        domain: {&#xA;          name: &#39;Lens Protocol Profiles&#39;,&#xA;          version: &#39;1&#39;,&#xA;          chainId: 80001,&#xA;          verifyingContract: &#39;0x60Ae865ee4C725cd04353b5AAb364553f56ceF82&#39;,&#xA;        },&#xA;        value: {&#xA;          profileId: &#39;0x18&#39;,&#xA;          contentURI: &#39;ar://NKrOBI6zMU4mnptAGYvirARSvBAU-nkCITQ5-LZkEco&#39;,&#xA;          collectModule: &#39;0x5E70fFD2C6D04d65C3abeBa64E93082cfA348dF8&#39;,&#xA;          collectModuleInitData: &#39;0x&#39;,&#xA;          referenceModule: &#39;0x0000000000000000000000000000000000000000&#39;,&#xA;          referenceModuleInitData: &#39;0x&#39;,&#xA;          nonce: 243,&#xA;          deadline: 1674736509,&#xA;        },&#xA;      },&#xA;      blockHash: &#39;0x43f670549e740c8b2b7b56967b8a24a546b734c83e05ba20a515faddddc7c345&#39;,&#xA;      blockNumber: 31429670,&#xA;      blockTimestamp: 1674736509,&#xA;    },&#xA;    pointer: null,&#xA;  },&#xA;  publicationId: &#39;0x18-0x3a-DA-951a2a24&#39;,&#xA;  event: {&#xA;    profileId: &#39;0x18&#39;,&#xA;    pubId: &#39;0x3a&#39;,&#xA;    contentURI: &#39;ar://NKrOBI6zMU4mnptAGYvirARSvBAU-nkCITQ5-LZkEco&#39;,&#xA;    collectModule: &#39;0x5E70fFD2C6D04d65C3abeBa64E93082cfA348dF8&#39;,&#xA;    collectModuleReturnData: &#39;0x&#39;,&#xA;    referenceModule: &#39;0x0000000000000000000000000000000000000000&#39;,&#xA;    referenceModuleReturnData: &#39;0x&#39;,&#xA;    timestamp: 1674736509,&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Comment example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{&#xA;  signature:&#xA;    &#39;0xcd9824d89bd3b237ed1230cf914630d756cae83904d835a1e85d37c11dbfab5e42c1f02042469ab29a3ccbd428c9a64576ad77f5876130b9c2bd49e0a83e9b7c1c&#39;,&#xA;  dataAvailabilityId: &#39;9a0b1d2b-e36e-48fc-87b4-b5f3f509b494&#39;,&#xA;  type: DAActionTypes.COMMENT_CREATED,&#xA;  timestampProofs: {&#xA;    type: DAProvider.BUNDLR,&#xA;    hashPrefix: &#39;1&#39;,&#xA;    response: {&#xA;      id: &#39;xtVsUj5j1T4T86IQlJk2u-KubGD5oKIXOJQlU3KyGR0&#39;,&#xA;      timestamp: 1674747795383,&#xA;      version: &#39;1.0.0&#39;,&#xA;      public:&#xA;        &#39;sq9JbppKLlAKtQwalfX5DagnGMlTirditXk7y4jgoeA7DEM0Z6cVPE5xMQ9kz_T9VppP6BFHtHyZCZODercEVWipzkr36tfQkR5EDGUQyLivdxUzbWgVkzw7D27PJEa4cd1Uy6r18rYLqERgbRvAZph5YJZmpSJk7r3MwnQquuktjvSpfCLFwSxP1w879-ss_JalM9ICzRi38henONio8gll6GV9-omrWwRMZer_15bspCK5txCwpY137nfKwKD5YBAuzxxcj424M7zlSHlsafBwaRwFbf8gHtW03iJER4lR4GxeY0WvnYaB3KDISHQp53a9nlbmiWO5WcHHYsR83OT2eJ0Pl3RWA-_imk_SNwGQTCjmA6tf_UVwL8HzYS2iyuu85b7iYK9ZQoh8nqbNC6qibICE4h9Fe3bN7AgitIe9XzCTOXDfMr4ahjC8kkqJ1z4zNAI6-Leei_Mgd8JtZh2vqFNZhXK0lSadFl_9Oh3AET7tUds2E7s-6zpRPd9oBZu6-kNuHDRJ6TQhZSwJ9ZO5HYsccb_G_1so72aXJymR9ggJgWr4J3bawAYYnqmvmzGklYOlE_5HVnMxf-UxpT7ztdsHbc9QEH6W2bzwxbpjTczEZs3JCCB3c-NewNHsj9PYM3b5tTlTNP9kNAwPZHWpt11t79LuNkNGt9LfOek&#39;,&#xA;      signature:&#xA;        &#39;TZh1F7z14pbuHq7IBlHqnhT4PXEa2dQngiL-iHEXot3-w_ScVLyN9naCeuHvAP4mialS62YPucToy4o1UQlMEtTYS2i6C0rPap32xGi2yDA6AtzURf-xELI33em-mr9QIEuOph34t0yRLn3_Bl0n-AV4jyjVSgHdYjUT0vNZx3TbRkBi_v0PgJHDYkyezP_NrZgTomEe_VZmBgozc0J9zzK6atbIdsPnHYDbY3qzTujJEwogVQa311lNZvVe2ND6MR_0EUyVVW0esin6dyYEIPPCrjlFwMMgaoW4vBbGd1d11cRGopYgNvcX_0EuwAWYGwi8XW_GNGyrk4Df14VnOXAuP4NKd5oia820Be1vqwuAs3ubWX0OQ7CttOgohO9ns7CjYg9DVIwY5-AuJd2wAK6eI09fot-lTNVwtMVBvyxQ4GWaYspMcqkpysOY-5ow0wFp7K4Ad1FI4NO71cbEZQWD8ou08_A5Gd2a6qZF2fb7IJKka0aim26N858faf1nqViZfL-aym-AW60ydNav8inrTxVTMXml61WeG4KwlQXDrdoWkEquLB-1mJ-_519ozgy0QjSbyctp4LjpDpdp-yiJvzfweMFVRIKxarVB9Vvc0NFhyllE8sZud8zLBZ7wo7GG_1wijCJaICo-iD_FK97ZegnhotGLzeDC-KqY2vQ&#39;,&#xA;      deadlineHeight: 1106619,&#xA;      block: 1106619,&#xA;      validatorSignatures: [],&#xA;    },&#xA;  },&#xA;  chainProofs: {&#xA;    thisPublication: {&#xA;      signature:&#xA;        &#39;0x5156c7e636be61a305373df811d8444b7715448e2bde3fe69d388f301270d83d72796c5ef58283c1a9d32b37033a6b567a32addb78aedef0957fbf56956cd2351b&#39;,&#xA;      signedByDelegate: false,&#xA;      signatureDeadline: 1674747793,&#xA;      typedData: {&#xA;        types: {&#xA;          CommentWithSig: [&#xA;            {&#xA;              name: &#39;profileId&#39;,&#xA;              type: &#39;uint256&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;contentURI&#39;,&#xA;              type: &#39;string&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;profileIdPointed&#39;,&#xA;              type: &#39;uint256&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;pubIdPointed&#39;,&#xA;              type: &#39;uint256&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;referenceModuleData&#39;,&#xA;              type: &#39;bytes&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;collectModule&#39;,&#xA;              type: &#39;address&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;collectModuleInitData&#39;,&#xA;              type: &#39;bytes&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;referenceModule&#39;,&#xA;              type: &#39;address&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;referenceModuleInitData&#39;,&#xA;              type: &#39;bytes&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;nonce&#39;,&#xA;              type: &#39;uint256&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;deadline&#39;,&#xA;              type: &#39;uint256&#39;,&#xA;            },&#xA;          ],&#xA;        },&#xA;        domain: {&#xA;          name: &#39;Lens Protocol Profiles&#39;,&#xA;          version: &#39;1&#39;,&#xA;          chainId: 80001,&#xA;          verifyingContract: &#39;0x60Ae865ee4C725cd04353b5AAb364553f56ceF82&#39;,&#xA;        },&#xA;        value: {&#xA;          profileId: &#39;0x18&#39;,&#xA;          profileIdPointed: &#39;0x18&#39;,&#xA;          pubIdPointed: &#39;0x3a&#39;,&#xA;          contentURI: &#39;ar://5JNO_BIyW7sD8crn1PPt3SrCZUKF9t-f8Rs13Zh1w1Q&#39;,&#xA;          referenceModule: &#39;0x0000000000000000000000000000000000000000&#39;,&#xA;          collectModule: &#39;0x5E70fFD2C6D04d65C3abeBa64E93082cfA348dF8&#39;,&#xA;          collectModuleInitData: &#39;0x&#39;,&#xA;          referenceModuleInitData: &#39;0x&#39;,&#xA;          referenceModuleData: &#39;0x&#39;,&#xA;          nonce: 243,&#xA;          deadline: 1674747793,&#xA;        },&#xA;      },&#xA;      blockHash: &#39;0x11b2e5b1b7fa87c3a30d10d6f0416f5cb540c30ac7ae4b1be5058d9b5031e172&#39;,&#xA;      blockNumber: 31434975,&#xA;      blockTimestamp: 1674747793,&#xA;    },&#xA;    pointer: {&#xA;      location: &#39;ar://TEoFkgD0m-LLQkfViuCTKfCLK_xpSxzPUNoMjBLnvlI&#39;,&#xA;      type: DAPublicationPointerType.ON_DA,&#xA;    },&#xA;  },&#xA;  publicationId: &#39;0x18-0x3a-DA-9a0b1d2b&#39;,&#xA;  event: {&#xA;    profileId: &#39;0x18&#39;,&#xA;    pubId: &#39;0x3a&#39;,&#xA;    contentURI: &#39;ar://5JNO_BIyW7sD8crn1PPt3SrCZUKF9t-f8Rs13Zh1w1Q&#39;,&#xA;    profileIdPointed: &#39;0x18&#39;,&#xA;    pubIdPointed: &#39;0x3a&#39;,&#xA;    referenceModuleData: &#39;0x&#39;,&#xA;    collectModule: &#39;0x5E70fFD2C6D04d65C3abeBa64E93082cfA348dF8&#39;,&#xA;    collectModuleReturnData: &#39;0x&#39;,&#xA;    referenceModule: &#39;0x0000000000000000000000000000000000000000&#39;,&#xA;    referenceModuleReturnData: &#39;0x&#39;,&#xA;    timestamp: 1674747793,&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Mirror example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;{&#xA;  signature:&#xA;    &#39;0x1683ef107f09a291ebbe8f4bfc4f628ff9be10f661d0d18048c31a8b1ca981d948ef12c591e5d762e952bc287e57838b031a6451f2b8a58cfc5cedb565c742661b&#39;,&#xA;  dataAvailabilityId: &#39;538ca9c4-682b-41d2-9b8a-52ede43728d7&#39;,&#xA;  type: DAActionTypes.MIRROR_CREATED,&#xA;  timestampProofs: {&#xA;    type: DAProvider.BUNDLR,&#xA;    hashPrefix: &#39;1&#39;,&#xA;    response: {&#xA;      id: &#39;zdkCXuVzawg3KipWCRVK2fo-yIUoj5IMuIYyFPGA55o&#39;,&#xA;      timestamp: 1674748125246,&#xA;      version: &#39;1.0.0&#39;,&#xA;      public:&#xA;        &#39;sq9JbppKLlAKtQwalfX5DagnGMlTirditXk7y4jgoeA7DEM0Z6cVPE5xMQ9kz_T9VppP6BFHtHyZCZODercEVWipzkr36tfQkR5EDGUQyLivdxUzbWgVkzw7D27PJEa4cd1Uy6r18rYLqERgbRvAZph5YJZmpSJk7r3MwnQquuktjvSpfCLFwSxP1w879-ss_JalM9ICzRi38henONio8gll6GV9-omrWwRMZer_15bspCK5txCwpY137nfKwKD5YBAuzxxcj424M7zlSHlsafBwaRwFbf8gHtW03iJER4lR4GxeY0WvnYaB3KDISHQp53a9nlbmiWO5WcHHYsR83OT2eJ0Pl3RWA-_imk_SNwGQTCjmA6tf_UVwL8HzYS2iyuu85b7iYK9ZQoh8nqbNC6qibICE4h9Fe3bN7AgitIe9XzCTOXDfMr4ahjC8kkqJ1z4zNAI6-Leei_Mgd8JtZh2vqFNZhXK0lSadFl_9Oh3AET7tUds2E7s-6zpRPd9oBZu6-kNuHDRJ6TQhZSwJ9ZO5HYsccb_G_1so72aXJymR9ggJgWr4J3bawAYYnqmvmzGklYOlE_5HVnMxf-UxpT7ztdsHbc9QEH6W2bzwxbpjTczEZs3JCCB3c-NewNHsj9PYM3b5tTlTNP9kNAwPZHWpt11t79LuNkNGt9LfOek&#39;,&#xA;      signature:&#xA;        &#39;IJjhzO0D4ioq9Gc0mghnxvOIkrZdmrqkc_UpMkL9R-qulzvkZ_LY4QRQxP-rNAm-ZIoN3Jep9zefjTaRRvU6mhc6hKZaMWC4XvWW_IXl5TZH1eOfq0JENjoRoZ75IdwicJXtc9c7obeNs84hXqlNHJXUoQfC2mEjkqiRpK_Vz43Hxn-3ZkrNvNEM1cpbl5hJU3UP0iCQnJQPiTgiojnhTBgRoIEpLQBFdoF1IRXUH4J4TBCMoX5MzG5PUj_FJkJiYX_SM0iaiDi0y-6-IsvOu1o32UWVgmDa-PbTrd6kGuDdd3Ys4HHyjGbS4NGkbu-coMW7RdkCegowgrXvzDoVxG0pVKoMK7ndOfZJJlud3jonqcDDI0vESSVdt_DDMOjkqdHiyWdVWcDlS0TnToIdwuOgaHDgpoqFjPUd5GwE40QFix6QflbxfcFqleru9eDY4_hufxMYEWK3DiSN6QIe6jQg6-9ZLFvD4Chr_bxL48UkfwDx-Y7EZo5tb6uzwzEqAfXEb5ITyzVrEgo1sXEDKKkkNQ7C5Hq2mryWKRXHUtXkKErI1P_bNRp2GXumO30uwZfpsMcAtFPCsPMnm1j4aqhFjcpVk9HpFPa6DcCuX6U8T3MODbJbNPxFc_Pdt5wcLo6EcLEnnQTIvQEIj_aQvh__rh79d6XHckI1TL-9gAM&#39;,&#xA;      deadlineHeight: 1106621,&#xA;      block: 1106621,&#xA;      validatorSignatures: [],&#xA;    },&#xA;  },&#xA;  chainProofs: {&#xA;    thisPublication: {&#xA;      signature:&#xA;        &#39;0x59cb0d34ef20e93e4073cadec0d05eb8ef9a6af4b55d7ddea099666f83509d193e554c4149856ddb36ac3a4601c7f4e12fc413e016b6d4b314846eb3222b2e9b1b&#39;,&#xA;      signedByDelegate: false,&#xA;      signatureDeadline: 1674748123,&#xA;      typedData: {&#xA;        domain: {&#xA;          name: &#39;Lens Protocol Profiles&#39;,&#xA;          version: &#39;1&#39;,&#xA;          chainId: 80001,&#xA;          verifyingContract: &#39;0x60Ae865ee4C725cd04353b5AAb364553f56ceF82&#39;,&#xA;        },&#xA;        types: {&#xA;          MirrorWithSig: [&#xA;            {&#xA;              name: &#39;profileId&#39;,&#xA;              type: &#39;uint256&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;profileIdPointed&#39;,&#xA;              type: &#39;uint256&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;pubIdPointed&#39;,&#xA;              type: &#39;uint256&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;referenceModuleData&#39;,&#xA;              type: &#39;bytes&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;referenceModule&#39;,&#xA;              type: &#39;address&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;referenceModuleInitData&#39;,&#xA;              type: &#39;bytes&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;nonce&#39;,&#xA;              type: &#39;uint256&#39;,&#xA;            },&#xA;            {&#xA;              name: &#39;deadline&#39;,&#xA;              type: &#39;uint256&#39;,&#xA;            },&#xA;          ],&#xA;        },&#xA;        value: {&#xA;          profileId: &#39;0x18&#39;,&#xA;          profileIdPointed: &#39;0x18&#39;,&#xA;          pubIdPointed: &#39;0x3a&#39;,&#xA;          referenceModuleData: &#39;0x&#39;,&#xA;          referenceModule: &#39;0x0000000000000000000000000000000000000000&#39;,&#xA;          referenceModuleInitData: &#39;0x&#39;,&#xA;          deadline: 1674748123,&#xA;          nonce: 243,&#xA;        },&#xA;      },&#xA;      blockHash: &#39;0x0fb258841acaf93b998028bfc7296b840a80cdc76ffd999d5101bc72cf2daf78&#39;,&#xA;      blockNumber: 31435129,&#xA;      blockTimestamp: 1674748123,&#xA;    },&#xA;    pointer: {&#xA;      location: &#39;ar://ff9CtLecXt1HBFBR-SoRz8tLjPjBo8gxbmy7kmFpJl4&#39;,&#xA;      type: DAPublicationPointerType.ON_DA,&#xA;    },&#xA;  },&#xA;  publicationId: &#39;0x18-0x3a-DA-538ca9c4&#39;,&#xA;  event: {&#xA;    profileId: &#39;0x18&#39;,&#xA;    pubId: &#39;0x3a&#39;,&#xA;    profileIdPointed: &#39;0x18&#39;,&#xA;    pubIdPointed: &#39;0x3a&#39;,&#xA;    referenceModuleData: &#39;0x&#39;,&#xA;    referenceModule: &#39;0x0000000000000000000000000000000000000000&#39;,&#xA;    referenceModuleReturnData: &#39;0x&#39;,&#xA;    timestamp: 1674748123,&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Metadata breakdown&lt;/h3&gt; &#xA;&lt;p&gt;This will explain in json schema terms what a DA publication metadata holds.&lt;/p&gt; &#xA;&lt;h4&gt;POST_CREATED&lt;/h4&gt; &#xA;&lt;p&gt;This is a DA post.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;$schema&#34;: &#34;https://json-schema.org/draft/2020-12/schema&#34;,&#xA;  &#34;$id&#34;: &#34;https://github.com/lens-protocol/data-availability-verifier/blob/master/src/__TESTS__/mocks/post/post-created-delegate-arweave-response.mock.ts#L10&#34;,&#xA;  &#34;title&#34;: &#34;The data availability layer schema&#34;,&#xA;  &#34;description&#34;: &#34;The data availability layer schema&#34;,&#xA;  &#34;type&#34;: &#34;object&#34;,&#xA;  &#34;properties&#34;: {&#xA;    &#34;dataAvailabilityId&#34;: {&#xA;      &#34;description&#34;: &#34;The id of the publication on the data availability layer; it is just a GUID&#34;,&#xA;      &#34;type&#34;: &#34;guid&#34;&#xA;    },&#xA;    &#34;signature&#34;: {&#xA;      &#34;description&#34;: &#34;The signature of the entire payload signed by the submitter&#34;,&#xA;      &#34;type&#34;: &#34;string&#34;&#xA;    },&#xA;    &#34;type&#34;: {&#xA;      &#34;description&#34;: &#34;`POST_CREATED`, `COMMENT_CREATED`, `MIRROR_CREATED` the DA action type which has been submitted&#34;,&#xA;      &#34;type&#34;: &#34;POST_CREATED&#34;,&#xA;    },&#xA;    &#34;timestampProofs&#34;: {&#xA;      &#34;description&#34;: &#34;Details for the timestamp proofs&#34;,&#xA;      &#34;type&#34;: &#34;object&#34;,&#xA;      &#34;properties&#34;: {&#xA;        &#34;type&#34;: {&#xA;          &#34;description&#34;: &#34;`BUNDLR` - who has supplied us with the timestamp proofs&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;hashPrefix&#34;: {&#xA;          &#34;description&#34;: &#34;The timestamp proof hash prefix&#34;,&#xA;          &#34;type&#34;: &#34;number&#34;&#xA;        },&#xA;        &#34;response&#34;: {&#xA;          &#34;description&#34;: &#34;The response from the timestamp proof provider&#34;,&#xA;          &#34;type&#34;: &#34;object&#34;,&#xA;          &#34;properties&#34;: { &#xA;            &#34;id&#34;: {&#xA;              &#34;description&#34;: &#34;The id of the timestamp proof&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;timestamp&#34;: {&#xA;              &#34;description&#34;: &#34;The timestamp date in milliseconds&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            },&#xA;            &#34;version&#34;: {&#xA;              &#34;description&#34;: &#34;The version of the timestamp proof&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;public&#34;: {&#xA;              &#34;description&#34;: &#34;The public key used sign for the timestamp proofs&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;signature&#34;: {&#xA;              &#34;description&#34;: &#34;The signature for the timestamp proofs&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;deadlineHeight&#34;: {&#xA;              &#34;description&#34;: &#34;Internal deadline height for the timestamp proof&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;block&#34;: {&#xA;              &#34;description&#34;: &#34;Internal block for the timestamp proof (this is not an evm block)&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            },&#xA;            &#34;validatorSignatures&#34;: {&#xA;              &#34;description&#34;: &#34;Internal validator signatures for the timestamp proof (this will always be an empty array for now until Bundlr is decentralised)&#34;,&#xA;              &#34;type&#34;: &#34;array&#34;,&#xA;               &#34;items&#34;: {&#xA;                &#34;type&#34;: &#34;string&#34;&#xA;              }&#xA;            }&#xA;           },&#xA;           &#34;required&#34;: [ &#34;id&#34;, &#34;timestamp&#34;, &#34;version&#34;, &#34;public&#34;, &#34;signature&#34;, &#34;deadlineHeight&#34;, &#34;block&#34;, &#34;validatorSignatures&#34; ]&#xA;        }&#xA;      },&#xA;      &#34;required&#34;: [ &#34;type&#34;, &#34;hashPrefix&#34;, &#34;response&#34; ]&#xA;    },&#xA;    &#34;chainProofs&#34;: {&#xA;      &#34;description&#34;: &#34;The proofs&#34;,&#xA;      &#34;type&#34;: &#34;object&#34;,&#xA;      &#34;properties&#34;: {&#xA;        &#34;thisPublication&#34;: {&#xA;          &#34;description&#34;: &#34;The publication being submitted&#34;,&#xA;          &#34;type&#34;: &#34;object&#34;,&#xA;          &#34;properties&#34;: {&#xA;            &#34;signature&#34;: {&#xA;              &#34;description&#34;: &#34;The transaction signature&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;signedByDelegate&#34;: {&#xA;              &#34;description&#34;: &#34;If the signature was signed by a delegate/dispatcher&#34;,&#xA;              &#34;type&#34;: &#34;boolean&#34;&#xA;            },&#xA;            &#34;signatureDeadline&#34;: {&#xA;              &#34;description&#34;: &#34;The deadline of the signature in unix form&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            },&#xA;            &#34;typedData&#34;: {&#xA;              &#34;description&#34;: &#34;The typed data of the transaction; this uses the signed typed data spec&#34;,&#xA;              &#34;type&#34;: &#34;object&#34;,&#xA;              &#34;properties&#34;: {&#xA;                &#34;types&#34;: {&#xA;                  &#34;description&#34;: &#34;The types of the signed typed data&#34;,&#xA;                  &#34;type&#34;: &#34;object&#34;,&#xA;                  &#34;properties&#34;: {&#xA;                    &#34;PostWithSig&#34;: {&#xA;                      &#34;description&#34;: &#34;The properties of the typed data&#34;,&#xA;                      &#34;type&#34;: &#34;array&#34;,&#xA;                      &#34;items&#34;: {&#xA;                        &#34;description&#34;: &#34;The name and type of the property&#34;,&#xA;                        &#34;type&#34;: &#34;object&#34;,&#xA;                        &#34;properties&#34;: {&#xA;                          &#34;name&#34;: {&#xA;                            &#34;description&#34;: &#34;The name of typed data&#34;,&#xA;                            &#34;type&#34;: &#34;string&#34;,&#xA;                          },&#xA;                          &#34;type&#34;: {&#xA;                            &#34;description&#34;: &#34;The type typed data&#34;,&#xA;                            &#34;type&#34;: &#34;string&#34;,&#xA;                          }&#xA;                        },&#xA;                        &#34;required&#34;: [&#34;name&#34;, &#34;type&#34;]&#xA;                      }&#xA;                    },&#xA;                  },&#xA;                  &#34;required&#34;: [&#34;types&#34;]&#xA;                },&#xA;                &#34;domain&#34;: {&#xA;                  &#34;description&#34;: &#34;The domain of the signed typed data&#34;,&#xA;                  &#34;type&#34;: &#34;object&#34;,&#xA;                  &#34;properties&#34;: {&#xA;                    &#34;name&#34;: {&#xA;                      &#34;description&#34;: &#34;The name of the signed typed data&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;version&#34;: {&#xA;                      &#34;description&#34;: &#34;The version of the signed typed data&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;chainId&#34;: {&#xA;                      &#34;description&#34;: &#34;The chain id of the signed typed data&#34;,&#xA;                      &#34;type&#34;: &#34;number&#34;,&#xA;                    },&#xA;                    &#34;verifyingContract&#34;: {&#xA;                      &#34;description&#34;: &#34;The verifying contract&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    }&#xA;                  },&#xA;                  &#34;required&#34;: [&#34;name&#34;, &#34;version&#34;, &#34;chainId&#34;, &#34;verifyingContract&#34;]&#xA;                },&#xA;                &#34;value&#34;: {&#xA;                  &#34;description&#34;: &#34;The value of the signed typed data&#34;,&#xA;                  &#34;type&#34;: &#34;object&#34;,&#xA;                  &#34;properties&#34;: {&#xA;                    &#34;profileId&#34;: {&#xA;                      &#34;description&#34;: &#34;The profile id doing the publication&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;contentURI&#34;: {&#xA;                      &#34;description&#34;: &#34;The content metadata URI&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;collectModule&#34;: {&#xA;                      &#34;description&#34;: &#34;The collect module address - will always be a revert collect module at the moment&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;collectModuleInitData&#34;: {&#xA;                      &#34;description&#34;: &#34;The collect module init data - will always be empty bytes for now&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;referenceModule&#34;: {&#xA;                      &#34;description&#34;: &#34;The reference module will always be address(0) for now&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;referenceModuleInitData&#34;: {&#xA;                      &#34;description&#34;: &#34;The reference module init data will - will always be empty bytes for now&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;nonce&#34;: {&#xA;                      &#34;description&#34;: &#34;The signature nonce&#34;,&#xA;                      &#34;type&#34;: &#34;number&#34;,&#xA;                    },&#xA;                    &#34;deadline&#34;: {&#xA;                      &#34;description&#34;: &#34;The signature deadline in unix form&#34;,&#xA;                      &#34;type&#34;: &#34;number&#34;,&#xA;                    }&#xA;                  },&#xA;                  &#34;required&#34;: [&#34;profileId&#34;, &#34;contentURI&#34;, &#34;collectModule&#34;, &#34;collectModuleInitData&#34;, &#34;referenceModule&#34;, &#34;referenceModuleInitData&#34;, &#34;nonce&#34;, &#34;deadline&#34;]&#xA;                }&#xA;              },&#xA;              &#34;required&#34;: [&#34;types&#34;, &#34;domain&#34;, &#34;value&#34;]&#xA;            },&#xA;            &#34;blockHash&#34;: {&#xA;              &#34;description&#34;: &#34;The block hash the submitter simulated this transaction on&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;blockNumber&#34;: {&#xA;              &#34;description&#34;: &#34;The block number the submitter simulated this transaction on&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            },&#xA;            &#34;blockNumber&#34;: {&#xA;              &#34;description&#34;: &#34;The block unix timestamp of the simulated transaction&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            }&#xA;          },&#xA;          &#34;required&#34;: [&#34;signature&#34;, &#34;signedByDelegate&#34;, &#34;signatureDeadline&#34;, &#34;typedData&#34;, &#34;blockHash&#34;, &#34;blockNumber&#34;, &#34;blockTimestamp&#34;]&#xA;        }&#xA;      },&#xA;       &#34;required&#34;: [ &#34;thisPublication&#34; ]&#xA;    },&#xA;    &#34;publicationId&#34;: {&#xA;      &#34;description&#34;: &#34;The id of the publication, which is built up of the profileId + pubId + `DA` + first eight chars of the dataAvailabilityId (so it will always be unique)&#34;,&#xA;      &#34;type&#34;: &#34;string&#34;&#xA;    },&#xA;    &#34;event&#34;: {&#xA;      &#34;description&#34;: &#34;This is trying to shape what you would get within an `EVM` event so you can easily parse it and understand it. This will always be identical to the EVM event data structure.&#34;,&#xA;      &#34;type&#34;: &#34;object&#34;,&#xA;      &#34;properties&#34;: {&#xA;        &#34;profileId&#34;: {&#xA;          &#34;description&#34;: &#34;The profileId which did the publication&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;pubId&#34;: {&#xA;          &#34;description&#34;: &#34;The pubId for the publication&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;contentURI&#34;: {&#xA;          &#34;description&#34;: &#34;The contentURI aka metadata for the publication&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;collectModule&#34;: {&#xA;          &#34;description&#34;: &#34;The collect module, for now it will always be revert module&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;collectModuleReturnData&#34;: {&#xA;          &#34;description&#34;: &#34;The collect module return data, will always for now be empty byte&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;referenceModule&#34;: {&#xA;          &#34;description&#34;: &#34;The reference module, will always be address(0) for now&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;referenceModuleReturnData&#34;: {&#xA;          &#34;description&#34;: &#34;The reference module return data, will always for now be empty byte&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;timestamp&#34;: {&#xA;          &#34;description&#34;: &#34;The timestamp date in milliseconds&#34;,&#xA;          &#34;type&#34;: &#34;number&#34;&#xA;        }&#xA;      },&#xA;      &#34;required&#34;: [ &#34;profileId&#34;, &#34;pubId&#34;, &#34;contentURI&#34;, &#34;collectModule&#34;, &#34;collectModuleReturnData&#34;, &#34;referenceModule&#34;, &#34;referenceModuleReturnData&#34;, &#34;timestamp&#34; ]&#xA;    }&#xA;  },&#xA;  &#34;required&#34;: [ &#34;dataAvailabilityId&#34;, &#34;type&#34;, &#34;timestampProofs&#34;, &#34;chainProofs&#34;, &#34;publicationId&#34;, &#34;event&#34; ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;COMMENT_CREATED&lt;/h4&gt; &#xA;&lt;p&gt;This is a DA comment. Very similar to DA post minus the &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;typedData&lt;/code&gt; and some &lt;code&gt;events&lt;/code&gt; properties&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;$schema&#34;: &#34;https://json-schema.org/draft/2020-12/schema&#34;,&#xA;  &#34;$id&#34;: &#34;https://github.com/lens-protocol/data-availability-verifier/blob/master/src/__TESTS__/mocks/comment/comment-created-delegate-arweave-response.mock.ts#L14&#34;,&#xA;  &#34;title&#34;: &#34;The data availability layer schema&#34;,&#xA;  &#34;description&#34;: &#34;The data availability layer schema&#34;,&#xA;  &#34;type&#34;: &#34;object&#34;,&#xA;  &#34;properties&#34;: {&#xA;    &#34;dataAvailabilityId&#34;: {&#xA;      &#34;description&#34;: &#34;The id of the publication on the data availability layer; it is just a GUID&#34;,&#xA;      &#34;type&#34;: &#34;guid&#34;&#xA;    },&#xA;    &#34;signature&#34;: {&#xA;      &#34;description&#34;: &#34;The signature of the entire payload signed by the submitter&#34;,&#xA;      &#34;type&#34;: &#34;string&#34;&#xA;    },&#xA;    &#34;type&#34;: {&#xA;      &#34;description&#34;: &#34;`POST_CREATED`, `COMMENT_CREATED`, `MIRROR_CREATED` the DA action type which has been submitted&#34;,&#xA;      &#34;type&#34;: &#34;COMMENT_CREATED&#34;,&#xA;    },&#xA;    &#34;timestampProofs&#34;: {&#xA;      &#34;description&#34;: &#34;Details for the timestamp proofs&#34;,&#xA;      &#34;type&#34;: &#34;object&#34;,&#xA;      &#34;properties&#34;: {&#xA;        &#34;type&#34;: {&#xA;          &#34;description&#34;: &#34;`BUNDLR` - who has supplied us with the timestamp proofs&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;hashPrefix&#34;: {&#xA;          &#34;description&#34;: &#34;The timestamp proof hash prefix&#34;,&#xA;          &#34;type&#34;: &#34;number&#34;&#xA;        },&#xA;        &#34;response&#34;: {&#xA;          &#34;description&#34;: &#34;The response from the timestamp proof provider&#34;,&#xA;          &#34;type&#34;: &#34;object&#34;,&#xA;          &#34;properties&#34;: { &#xA;            &#34;id&#34;: {&#xA;              &#34;description&#34;: &#34;The id of the timestamp proof&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;timestamp&#34;: {&#xA;              &#34;description&#34;: &#34;The timestamp date in milliseconds&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            },&#xA;            &#34;version&#34;: {&#xA;              &#34;description&#34;: &#34;The version of the timestamp proof&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;public&#34;: {&#xA;              &#34;description&#34;: &#34;The public key used sign for the timestamp proofs&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;signature&#34;: {&#xA;              &#34;description&#34;: &#34;The signature for the timestamp proofs&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;deadlineHeight&#34;: {&#xA;              &#34;description&#34;: &#34;Internal deadline height for the timestamp proof&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;block&#34;: {&#xA;              &#34;description&#34;: &#34;Internal block for the timestamp proof (this is not an evm block)&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            },&#xA;            &#34;validatorSignatures&#34;: {&#xA;              &#34;description&#34;: &#34;Internal validator signatures for the timestamp proof (this will always be an empty array for now until Bundlr is decentralised)&#34;,&#xA;              &#34;type&#34;: &#34;array&#34;,&#xA;               &#34;items&#34;: {&#xA;                &#34;type&#34;: &#34;string&#34;&#xA;              }&#xA;            }&#xA;           },&#xA;           &#34;required&#34;: [ &#34;id&#34;, &#34;timestamp&#34;, &#34;version&#34;, &#34;public&#34;, &#34;signature&#34;, &#34;deadlineHeight&#34;, &#34;block&#34;, &#34;validatorSignatures&#34; ]&#xA;        }&#xA;      },&#xA;      &#34;required&#34;: [ &#34;type&#34;, &#34;hashPrefix&#34;, &#34;response&#34; ]&#xA;    },&#xA;    &#34;chainProofs&#34;: {&#xA;      &#34;description&#34;: &#34;The proofs&#34;,&#xA;      &#34;type&#34;: &#34;object&#34;,&#xA;      &#34;properties&#34;: {&#xA;        &#34;thisPublication&#34;: {&#xA;          &#34;description&#34;: &#34;The publication being submitted&#34;,&#xA;          &#34;type&#34;: &#34;object&#34;,&#xA;          &#34;properties&#34;: {&#xA;            &#34;signature&#34;: {&#xA;              &#34;description&#34;: &#34;The transaction signature&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;signedByDelegate&#34;: {&#xA;              &#34;description&#34;: &#34;If the signature was signed by a delegate/dispatcher&#34;,&#xA;              &#34;type&#34;: &#34;boolean&#34;&#xA;            },&#xA;            &#34;signatureDeadline&#34;: {&#xA;              &#34;description&#34;: &#34;The deadline of the signature in unix form&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            },&#xA;            &#34;typedData&#34;: {&#xA;              &#34;description&#34;: &#34;The typed data of the transaction; this uses the signed typed data spec&#34;,&#xA;              &#34;type&#34;: &#34;object&#34;,&#xA;              &#34;properties&#34;: {&#xA;                &#34;types&#34;: {&#xA;                  &#34;description&#34;: &#34;The types of the signed typed data&#34;,&#xA;                  &#34;type&#34;: &#34;object&#34;,&#xA;                  &#34;properties&#34;: {&#xA;                    &#34;CommentWithSig&#34;: {&#xA;                      &#34;description&#34;: &#34;The properties of the typed data&#34;,&#xA;                      &#34;type&#34;: &#34;array&#34;,&#xA;                      &#34;items&#34;: {&#xA;                        &#34;description&#34;: &#34;The name and type of the property&#34;,&#xA;                        &#34;type&#34;: &#34;object&#34;,&#xA;                        &#34;properties&#34;: {&#xA;                          &#34;name&#34;: {&#xA;                            &#34;description&#34;: &#34;The name of typed data&#34;,&#xA;                            &#34;type&#34;: &#34;string&#34;,&#xA;                          },&#xA;                          &#34;type&#34;: {&#xA;                            &#34;description&#34;: &#34;The type typed data&#34;,&#xA;                            &#34;type&#34;: &#34;string&#34;,&#xA;                          }&#xA;                        },&#xA;                        &#34;required&#34;: [&#34;name&#34;, &#34;type&#34;]&#xA;                      }&#xA;                    },&#xA;                  },&#xA;                  &#34;required&#34;: [&#34;types&#34;]&#xA;                },&#xA;                &#34;domain&#34;: {&#xA;                  &#34;description&#34;: &#34;The domain of the signed typed data&#34;,&#xA;                  &#34;type&#34;: &#34;object&#34;,&#xA;                  &#34;properties&#34;: {&#xA;                    &#34;name&#34;: {&#xA;                      &#34;description&#34;: &#34;The name of the signed typed data&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;version&#34;: {&#xA;                      &#34;description&#34;: &#34;The version of the signed typed data&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;chainId&#34;: {&#xA;                      &#34;description&#34;: &#34;The chain id of the signed typed data&#34;,&#xA;                      &#34;type&#34;: &#34;number&#34;,&#xA;                    },&#xA;                    &#34;verifyingContract&#34;: {&#xA;                      &#34;description&#34;: &#34;The verifying contract&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    }&#xA;                  },&#xA;                  &#34;required&#34;: [&#34;name&#34;, &#34;version&#34;, &#34;chainId&#34;, &#34;verifyingContract&#34;]&#xA;                },&#xA;                &#34;value&#34;: {&#xA;                  &#34;description&#34;: &#34;The value of the signed typed data&#34;,&#xA;                  &#34;type&#34;: &#34;object&#34;,&#xA;                  &#34;properties&#34;: {&#xA;                    &#34;profileId&#34;: {&#xA;                      &#34;description&#34;: &#34;The profile id doing the comment&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;profileIdPointed&#34;: {&#xA;                      &#34;description&#34;: &#34;The profile id which the comment is being made on&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;pubIdPointed&#34;: {&#xA;                      &#34;description&#34;: &#34;The publication id which the comment is being made on&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;contentURI&#34;: {&#xA;                      &#34;description&#34;: &#34;The content metadata URI&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;collectModule&#34;: {&#xA;                      &#34;description&#34;: &#34;The collect module address - will always be a revert collect module at the moment&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;collectModuleInitData&#34;: {&#xA;                      &#34;description&#34;: &#34;The collect module init data - will always be empty bytes for now&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;referenceModule&#34;: {&#xA;                      &#34;description&#34;: &#34;The reference module will always be address(0) for now&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;referenceModuleData&#34;: {&#xA;                      &#34;description&#34;: &#34;The reference module data - will always be empty bytes for now&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;referenceModuleInitData&#34;: {&#xA;                      &#34;description&#34;: &#34;The reference module init data - will always be empty bytes for now&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;nonce&#34;: {&#xA;                      &#34;description&#34;: &#34;The signature nonce&#34;,&#xA;                      &#34;type&#34;: &#34;number&#34;,&#xA;                    },&#xA;                    &#34;deadline&#34;: {&#xA;                      &#34;description&#34;: &#34;The signature deadline in unix form&#34;,&#xA;                      &#34;type&#34;: &#34;number&#34;,&#xA;                    }&#xA;                  },&#xA;                  &#34;required&#34;: [&#34;profileId&#34;, &#34;profileIdPointed&#34;, &#34;pubIdPointed&#34;, &#34;contentURI&#34;, &#34;collectModule&#34;, &#34;collectModuleInitData&#34;, &#34;referenceModule&#34;, &#34;referenceModuleInitData&#34;, &#34;referenceModuleData&#34;, &#34;nonce&#34;, &#34;deadline&#34;]&#xA;                }&#xA;              },&#xA;              &#34;required&#34;: [&#34;types&#34;, &#34;domain&#34;, &#34;value&#34;]&#xA;            },&#xA;            &#34;blockHash&#34;: {&#xA;              &#34;description&#34;: &#34;The block hash the submitter simulated this transaction on&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;blockNumber&#34;: {&#xA;              &#34;description&#34;: &#34;The block number the submitter simulated this transaction on&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            },&#xA;            &#34;blockNumber&#34;: {&#xA;              &#34;description&#34;: &#34;The block unix timestamp of the simulated transaction&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            }&#xA;          },&#xA;          &#34;required&#34;: [&#34;signature&#34;, &#34;signedByDelegate&#34;, &#34;signatureDeadline&#34;, &#34;typedData&#34;, &#34;blockHash&#34;, &#34;blockNumber&#34;, &#34;blockTimestamp&#34;]&#xA;        },&#xA;        &#34;pointer&#34;: {&#xA;          &#34;description&#34;: &#34;The pointer this publication is referencing&#34;,&#xA;          &#34;type&#34;: &#34;object&#34;,&#xA;          &#34;properties&#34;: { &#xA;            &#34;location&#34;: {&#xA;              &#34;description&#34;: &#34;The location of the pointer publication proofs on the data availability layer&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;type&#34;: {&#xA;              &#34;description&#34;: &#34;the type of the publication on the data availability layer `ON_DA` or `ON_EVM_CHAIN` - for now you can not do a DA publication on a on-chain publication so will always be `ON_DA`&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            }&#xA;          },&#xA;          &#34;required&#34;: [ &#34;location&#34;, &#34;type&#34; ]&#xA;        }&#xA;      },&#xA;      &#34;required&#34;: [ &#34;thisPublication&#34;, &#34;pointer&#34; ]&#xA;    },&#xA;    &#34;publicationId&#34;: {&#xA;      &#34;description&#34;: &#34;The id of the publication, which is built up of the profileId + pubId + `DA` + first eight chars of the dataAvailabilityId (so it will always be unique)&#34;,&#xA;      &#34;type&#34;: &#34;string&#34;&#xA;    },&#xA;    &#34;event&#34;: {&#xA;      &#34;description&#34;: &#34;This is trying to shape what you would get within an `EVM` event so you can easily parse it and understand it. This will always be identical to the EVM event data structure.&#34;,&#xA;      &#34;type&#34;: &#34;object&#34;,&#xA;      &#34;properties&#34;: {&#xA;        &#34;profileId&#34;: {&#xA;          &#34;description&#34;: &#34;The profileId which did the publication&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;pubId&#34;: {&#xA;          &#34;description&#34;: &#34;The pubId for the publication&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;contentURI&#34;: {&#xA;          &#34;description&#34;: &#34;The contentURI aka metadata for the publication&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;profileIdPointed&#34;: {&#xA;          &#34;description&#34;: &#34;The profile id of the comment is being made on&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;pubIdPointed&#34;: {&#xA;          &#34;description&#34;: &#34;The pub id which the comment is being made on&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;referenceModuleData&#34;: {&#xA;          &#34;description&#34;: &#34;The reference module data - will always be empty hex for now&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;collectModule&#34;: {&#xA;          &#34;description&#34;: &#34;The collect module, for now it will always be revert module&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;collectModuleReturnData&#34;: {&#xA;          &#34;description&#34;: &#34;The collect module return data, will always for now be empty byte&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;referenceModule&#34;: {&#xA;          &#34;description&#34;: &#34;The reference module, will always be address(0) for now&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;referenceModuleReturnData&#34;: {&#xA;          &#34;description&#34;: &#34;The reference module return data, will always for now be empty byte&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;timestamp&#34;: {&#xA;          &#34;description&#34;: &#34;The timestamp date in milliseconds&#34;,&#xA;          &#34;type&#34;: &#34;number&#34;&#xA;        }&#xA;      },&#xA;      &#34;required&#34;: [ &#34;profileId&#34;, &#34;pubId&#34;, &#34;contentURI&#34;, &#34;profileIdPointed&#34;, &#34;pubIdPointed&#34;, &#34;referenceModuleData&#34;, &#34;collectModule&#34;, &#34;collectModuleReturnData&#34;, &#34;referenceModule&#34;, &#34;referenceModuleReturnData&#34;, &#34;timestamp&#34; ]&#xA;    }&#xA;  },&#xA;  &#34;required&#34;: [ &#34;dataAvailabilityId&#34;, &#34;type&#34;, &#34;timestampProofs&#34;, &#34;chainProofs&#34;, &#34;publicationId&#34;, &#34;event&#34; ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;MIRROR_CREATED&lt;/h4&gt; &#xA;&lt;p&gt;This is a DA mirror. Very similar to DA post/comment minus the &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;typedData&lt;/code&gt; and some &lt;code&gt;events&lt;/code&gt; properties&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;$schema&#34;: &#34;https://json-schema.org/draft/2020-12/schema&#34;,&#xA;  &#34;$id&#34;: &#34;https://github.com/lens-protocol/data-availability-verifier/blob/master/src/__TESTS__/mocks/mirror/mirror-created-without-delegate-comment-arweave-response.mock.ts#L13&#34;,&#xA;  &#34;title&#34;: &#34;The data availability layer schema&#34;,&#xA;  &#34;description&#34;: &#34;The data availability layer schema&#34;,&#xA;  &#34;type&#34;: &#34;object&#34;,&#xA;  &#34;properties&#34;: {&#xA;    &#34;dataAvailabilityId&#34;: {&#xA;      &#34;description&#34;: &#34;The id of the publication on the data availability layer; it is just a GUID&#34;,&#xA;      &#34;type&#34;: &#34;guid&#34;&#xA;    },&#xA;    &#34;signature&#34;: {&#xA;      &#34;description&#34;: &#34;The signature of the entire payload signed by the submitter&#34;,&#xA;      &#34;type&#34;: &#34;string&#34;&#xA;    },&#xA;    &#34;type&#34;: {&#xA;      &#34;description&#34;: &#34;`POST_CREATED`, `COMMENT_CREATED`, `MIRROR_CREATED` the DA action type which has been submitted&#34;,&#xA;      &#34;type&#34;: &#34;COMMENT_CREATED&#34;,&#xA;    },&#xA;    &#34;timestampProofs&#34;: {&#xA;      &#34;description&#34;: &#34;Details for the timestamp proofs&#34;,&#xA;      &#34;type&#34;: &#34;object&#34;,&#xA;      &#34;properties&#34;: {&#xA;        &#34;type&#34;: {&#xA;          &#34;description&#34;: &#34;`BUNDLR` - who has supplied us with the timestamp proofs&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;hashPrefix&#34;: {&#xA;          &#34;description&#34;: &#34;The timestamp proof hash prefix&#34;,&#xA;          &#34;type&#34;: &#34;number&#34;&#xA;        },&#xA;        &#34;response&#34;: {&#xA;          &#34;description&#34;: &#34;The response from the timestamp proof provider&#34;,&#xA;          &#34;type&#34;: &#34;object&#34;,&#xA;          &#34;properties&#34;: { &#xA;            &#34;id&#34;: {&#xA;              &#34;description&#34;: &#34;The id of the timestamp proof&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;timestamp&#34;: {&#xA;              &#34;description&#34;: &#34;The timestamp date in milliseconds&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            },&#xA;            &#34;version&#34;: {&#xA;              &#34;description&#34;: &#34;The version of the timestamp proof&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;public&#34;: {&#xA;              &#34;description&#34;: &#34;The public key used sign for the timestamp proofs&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;signature&#34;: {&#xA;              &#34;description&#34;: &#34;The signature for the timestamp proofs&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;deadlineHeight&#34;: {&#xA;              &#34;description&#34;: &#34;Internal deadline height for the timestamp proof&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;block&#34;: {&#xA;              &#34;description&#34;: &#34;Internal block for the timestamp proof (this is not an evm block)&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            },&#xA;            &#34;validatorSignatures&#34;: {&#xA;              &#34;description&#34;: &#34;Internal validator signatures for the timestamp proof (this will always be an empty array for now until Bundlr is decentralised)&#34;,&#xA;              &#34;type&#34;: &#34;array&#34;,&#xA;               &#34;items&#34;: {&#xA;                &#34;type&#34;: &#34;string&#34;&#xA;              }&#xA;            }&#xA;           },&#xA;           &#34;required&#34;: [ &#34;id&#34;, &#34;timestamp&#34;, &#34;version&#34;, &#34;public&#34;, &#34;signature&#34;, &#34;deadlineHeight&#34;, &#34;block&#34;, &#34;validatorSignatures&#34; ]&#xA;        }&#xA;      },&#xA;      &#34;required&#34;: [ &#34;type&#34;, &#34;hashPrefix&#34;, &#34;response&#34; ]&#xA;    },&#xA;    &#34;chainProofs&#34;: {&#xA;      &#34;description&#34;: &#34;The proofs&#34;,&#xA;      &#34;type&#34;: &#34;object&#34;,&#xA;      &#34;properties&#34;: {&#xA;        &#34;thisPublication&#34;: {&#xA;          &#34;description&#34;: &#34;The publication being submitted&#34;,&#xA;          &#34;type&#34;: &#34;object&#34;,&#xA;          &#34;properties&#34;: {&#xA;            &#34;signature&#34;: {&#xA;              &#34;description&#34;: &#34;The transaction signature&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;signedByDelegate&#34;: {&#xA;              &#34;description&#34;: &#34;If the signature was signed by a delegate/dispatcher&#34;,&#xA;              &#34;type&#34;: &#34;boolean&#34;&#xA;            },&#xA;            &#34;signatureDeadline&#34;: {&#xA;              &#34;description&#34;: &#34;The deadline of the signature in unix form&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            },&#xA;            &#34;typedData&#34;: {&#xA;              &#34;description&#34;: &#34;The typed data of the transaction; this uses the signed typed data spec&#34;,&#xA;              &#34;type&#34;: &#34;object&#34;,&#xA;              &#34;properties&#34;: {&#xA;                &#34;types&#34;: {&#xA;                  &#34;description&#34;: &#34;The types of the signed typed data&#34;,&#xA;                  &#34;type&#34;: &#34;object&#34;,&#xA;                  &#34;properties&#34;: {&#xA;                    &#34;MirrorWithSig&#34;: {&#xA;                      &#34;description&#34;: &#34;The properties of the typed data&#34;,&#xA;                      &#34;type&#34;: &#34;array&#34;,&#xA;                      &#34;items&#34;: {&#xA;                        &#34;description&#34;: &#34;The name and type of the property&#34;,&#xA;                        &#34;type&#34;: &#34;object&#34;,&#xA;                        &#34;properties&#34;: {&#xA;                          &#34;name&#34;: {&#xA;                            &#34;description&#34;: &#34;The name of typed data&#34;,&#xA;                            &#34;type&#34;: &#34;string&#34;,&#xA;                          },&#xA;                          &#34;type&#34;: {&#xA;                            &#34;description&#34;: &#34;The type typed data&#34;,&#xA;                            &#34;type&#34;: &#34;string&#34;,&#xA;                          }&#xA;                        },&#xA;                        &#34;required&#34;: [&#34;name&#34;, &#34;type&#34;]&#xA;                      }&#xA;                    },&#xA;                  },&#xA;                  &#34;required&#34;: [&#34;types&#34;]&#xA;                },&#xA;                &#34;domain&#34;: {&#xA;                  &#34;description&#34;: &#34;The domain of the signed typed data&#34;,&#xA;                  &#34;type&#34;: &#34;object&#34;,&#xA;                  &#34;properties&#34;: {&#xA;                    &#34;name&#34;: {&#xA;                      &#34;description&#34;: &#34;The name of the signed typed data&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;version&#34;: {&#xA;                      &#34;description&#34;: &#34;The version of the signed typed data&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;chainId&#34;: {&#xA;                      &#34;description&#34;: &#34;The chain id of the signed typed data&#34;,&#xA;                      &#34;type&#34;: &#34;number&#34;,&#xA;                    },&#xA;                    &#34;verifyingContract&#34;: {&#xA;                      &#34;description&#34;: &#34;The verifying contract&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    }&#xA;                  },&#xA;                  &#34;required&#34;: [&#34;name&#34;, &#34;version&#34;, &#34;chainId&#34;, &#34;verifyingContract&#34;]&#xA;                },&#xA;                &#34;value&#34;: {&#xA;                  &#34;description&#34;: &#34;The value of the signed typed data&#34;,&#xA;                  &#34;type&#34;: &#34;object&#34;,&#xA;                  &#34;properties&#34;: {&#xA;                    &#34;profileId&#34;: {&#xA;                      &#34;description&#34;: &#34;The profile id doing the comment&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;profileIdPointed&#34;: {&#xA;                      &#34;description&#34;: &#34;The profile id which the comment is being made on&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;pubIdPointed&#34;: {&#xA;                      &#34;description&#34;: &#34;The publication id which the comment is being made on&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;referenceModule&#34;: {&#xA;                      &#34;description&#34;: &#34;The reference module will always be address(0) for now&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;referenceModuleData&#34;: {&#xA;                      &#34;description&#34;: &#34;The reference module data - will always be empty bytes for now&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;referenceModuleInitData&#34;: {&#xA;                      &#34;description&#34;: &#34;The reference module init data - will always be empty bytes for now&#34;,&#xA;                      &#34;type&#34;: &#34;string&#34;,&#xA;                    },&#xA;                    &#34;nonce&#34;: {&#xA;                      &#34;description&#34;: &#34;The signature nonce&#34;,&#xA;                      &#34;type&#34;: &#34;number&#34;,&#xA;                    },&#xA;                    &#34;deadline&#34;: {&#xA;                      &#34;description&#34;: &#34;The signature deadline in unix form&#34;,&#xA;                      &#34;type&#34;: &#34;number&#34;,&#xA;                    }&#xA;                  },&#xA;                  &#34;required&#34;: [&#34;profileId&#34;, &#34;profileIdPointed&#34;, &#34;pubIdPointed&#34;, &#34;referenceModule&#34;, &#34;referenceModuleInitData&#34;, &#34;referenceModuleData&#34;, &#34;nonce&#34;, &#34;deadline&#34;]&#xA;                }&#xA;              },&#xA;              &#34;required&#34;: [&#34;types&#34;, &#34;domain&#34;, &#34;value&#34;]&#xA;            },&#xA;            &#34;blockHash&#34;: {&#xA;              &#34;description&#34;: &#34;The block hash the submitter simulated this transaction on&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;blockNumber&#34;: {&#xA;              &#34;description&#34;: &#34;The block number the submitter simulated this transaction on&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            },&#xA;            &#34;blockNumber&#34;: {&#xA;              &#34;description&#34;: &#34;The block unix timestamp of the simulated transaction&#34;,&#xA;              &#34;type&#34;: &#34;number&#34;&#xA;            }&#xA;          },&#xA;          &#34;required&#34;: [&#34;signature&#34;, &#34;signedByDelegate&#34;, &#34;signatureDeadline&#34;, &#34;typedData&#34;, &#34;blockHash&#34;, &#34;blockNumber&#34;, &#34;blockTimestamp&#34;]&#xA;        },&#xA;        &#34;pointer&#34;: {&#xA;          &#34;description&#34;: &#34;The pointer this publication is referencing&#34;,&#xA;          &#34;type&#34;: &#34;object&#34;,&#xA;          &#34;properties&#34;: { &#xA;            &#34;location&#34;: {&#xA;              &#34;description&#34;: &#34;The location of the pointer publication proofs on the data availability layer&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            },&#xA;            &#34;type&#34;: {&#xA;              &#34;description&#34;: &#34;the type of the publication on the data availability layer `ON_DA` or `ON_EVM_CHAIN` - for now you can not do a DA publication on a on-chain publication so will always be `ON_DA`&#34;,&#xA;              &#34;type&#34;: &#34;string&#34;&#xA;            }&#xA;          },&#xA;          &#34;required&#34;: [ &#34;location&#34;, &#34;type&#34; ]&#xA;        }&#xA;      },&#xA;      &#34;required&#34;: [ &#34;thisPublication&#34;, &#34;pointer&#34; ]&#xA;    },&#xA;    &#34;publicationId&#34;: {&#xA;      &#34;description&#34;: &#34;The id of the publication, which is built up of the profileId + pubId + `DA` + first eight chars of the dataAvailabilityId (so it will always be unique)&#34;,&#xA;      &#34;type&#34;: &#34;string&#34;&#xA;    },&#xA;    &#34;event&#34;: {&#xA;      &#34;description&#34;: &#34;This is trying to shape what you would get within an `EVM` event so you can easily parse it and understand it. This will always be identical to the EVM event data structure.&#34;,&#xA;      &#34;type&#34;: &#34;object&#34;,&#xA;      &#34;properties&#34;: {&#xA;        &#34;profileId&#34;: {&#xA;          &#34;description&#34;: &#34;The profileId which did the mirror&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;pubId&#34;: {&#xA;          &#34;description&#34;: &#34;The pubId for the mirror&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;profileIdPointed&#34;: {&#xA;          &#34;description&#34;: &#34;The profile id of the mirror is being made on&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;pubIdPointed&#34;: {&#xA;          &#34;description&#34;: &#34;The pub id which the mirror is being made on&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;referenceModuleData&#34;: {&#xA;          &#34;description&#34;: &#34;The reference module data - will always be empty hex for now&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;referenceModule&#34;: {&#xA;          &#34;description&#34;: &#34;The reference module, will always be address(0) for now&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;referenceModuleReturnData&#34;: {&#xA;          &#34;description&#34;: &#34;The reference module return data, will always for now be empty byte&#34;,&#xA;          &#34;type&#34;: &#34;string&#34;&#xA;        },&#xA;        &#34;timestamp&#34;: {&#xA;          &#34;description&#34;: &#34;The timestamp date in milliseconds&#34;,&#xA;          &#34;type&#34;: &#34;number&#34;&#xA;        }&#xA;      },&#xA;      &#34;required&#34;: [ &#34;profileId&#34;, &#34;pubId&#34;, &#34;profileIdPointed&#34;, &#34;pubIdPointed&#34;, &#34;referenceModuleData&#34;, &#34;referenceModule&#34;, &#34;referenceModuleReturnData&#34;, &#34;timestamp&#34; ]&#xA;    }&#xA;  },&#xA;  &#34;required&#34;: [ &#34;dataAvailabilityId&#34;, &#34;type&#34;, &#34;timestampProofs&#34;, &#34;chainProofs&#34;, &#34;publicationId&#34;, &#34;event&#34; ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Validation checks flows&lt;/h2&gt; &#xA;&lt;p&gt;This is written in sudo &lt;code&gt;node&lt;/code&gt; code to understand the current flow of the validation checks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;async function validateClaim() {&#xA;  // 1. Fetch DA metadata from Bundlr&#xA;  const metadata = await fetchMetadataFromBundlr();&#xA;&#xA;  // 2. Check if `signature` is defined&#xA;  if (!signature) {&#xA;    return MomokaValidatorError.NO_SIGNATURE_SUBMITTER;&#xA;  }&#xA;&#xA;  // 3. Verify `signature` with `metadata`&#xA;  if (!verifySignature(signature, metadata)) {&#xA;    return MomokaValidatorError.INVALID_SIGNATURE_SUBMITTER;&#xA;  }&#xA;&#xA;  // 4. Check timestamp proofs with Bundlr&#xA;  if (!await checkTimestampProofs()) {&#xA;    return MomokaValidatorError.TIMESTAMP_PROOF_INVALID_SIGNATURE;&#xA;  }&#xA;&#xA;  // 5. Check if timestamp proofs submitter is valid&#xA;  if (!isValidTimestampProofsSubmitter()) {&#xA;    return MomokaValidatorError.TIMESTAMP_PROOF_INVALID_SUBMITTER;&#xA;  }&#xA;&#xA;  // 6. Check if event `timestamp` equals `blockTimestamp`&#xA;  if (eventTimestamp !== blockTimestamp) {&#xA;    return MomokaValidatorError.INVALID_EVENT_TIMESTAMP;&#xA;  }&#xA;&#xA;  // 7. Check if block number is closest to timestamp proofs&#xA;  if (!isClosestBlock()) {&#xA;    return MomokaValidatorError.NOT_CLOSEST_BLOCK;&#xA;  }&#xA;&#xA;  // 8. Check if chain signature has already been used&#xA;  if (!chainSignatureAlreadyUsed()) {&#xA;    return MomokaValidatorError.CHAIN_SIGNATURE_ALREADY_USED;&#xA;  }&#xA;&#xA;  // 9. Check if pointer is defined&#xA;  if (isPost() &amp;amp;&amp;amp; pointer) {&#xA;    return MomokaValidatorError.INVALID_POINTER_SET_NOT_NEEDED;&#xA;  } else if (!pointer &amp;amp;&amp;amp; (isMirror() || isComment())) {&#xA;    return MomokaValidatorError.INVALID_POINTER_NOT_SET;&#xA;  }&#xA;&#xA;  // 9.1. Check pointer type (if defined)&#xA;  if (pointer &amp;amp;&amp;amp; !isPointerTypeOnDA()) {&#xA;    return PUBLICATION_NONE_DA;&#xA;  }&#xA;&#xA;  // 10. Verify pointer (if defined) - follow steps from 1&#xA;  const pointerStepError = await verifyPointer();&#xA;  if (pointerStepError) {&#xA;    return pointerStepError;&#xA;  }&#xA;&#xA;  // 11. Check if formatted typed data is valid&#xA;  if (!isValidFormattedTypedData()) {&#xA;    return MomokaValidatorError.INVALID_FORMATTED_TYPED_DATA;&#xA;  }&#xA;&#xA;  // 12a. If `POST`, simulate transaction using eth_call&#xA;  if (isPost()) {&#xA;    const simulationResult = await simulateTransaction();&#xA;    if (simulationResult === &#39;nodeError&#39;) {&#xA;      return MomokaValidatorError.SIMULATION_NODE_COULD_NOT_RUN;&#xA;    } else if (simulationResult === &#39;failed&#39;) {&#xA;      return MomokaValidatorError.SIMULATION_FAILED;&#xA;    }&#xA;  }&#xA;  // 12b. If `COMMENT` or `MIRROR`, perform additional checks&#xA;  else {&#xA;    if (!isValidPublicationNonce()) {&#xA;      return MomokaValidatorError.PUBLICATION_NONCE_INVALID;&#xA;    }&#xA;    if (!isPublicationSignerAllowed()) {&#xA;      return MomokaValidatorError.PUBLICATION_SIGNER_NOT_ALLOWED;&#xA;    }&#xA;  }&#xA;&#xA;  // 13. Cross-check typed data values with `event`&#xA;  if (!isEventMatchingTypedData()) {&#xA;    return MomokaValidatorError.EVENT_MISMATCH;&#xA;  }&#xA;&#xA;  // 14. Check if `publicationId` matches expected ID&#xA;  if (!isPublicationIdMatch()) {&#xA;    // 15. Check if it could of been a potential reorg &#xA;    &#xA;    // if so:&#xA;    return MomokaValidatorError.POTENTIAL_REORG;&#xA;&#xA;    // if not &#xA;    return MomokaValidatorError.GENERATED_PUBLICATION_ID_MISMATCH;&#xA;  }&#xA;&#xA;  // all validated!&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;At this point, you have done all the checks needed, and this is a valid submission! As you see, using signatures and EVM calls, we can verify the data is correct and the submitter is correct without any other third party.&lt;/p&gt; &#xA;&lt;h3&gt;Validation error checks types and messages&lt;/h3&gt; &#xA;&lt;p&gt;The summary in the code should explain what is being checked for and what it would fail out if it doesn&#39;t match. Below is the full list of error cases&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export enum MomokaValidatorError {&#xA;  /**&#xA;   * This means the main signature has not been attached to the payload&#xA;   */&#xA;  NO_SIGNATURE_SUBMITTER = &#39;NO_SIGNATURE_SUBMITTER&#39;,&#xA;&#xA;  /**&#xA;   * This means the main signature has not been signed by the same payload as the data itself&#xA;   */&#xA;  INVALID_SIGNATURE_SUBMITTER = &#39;INVALID_SIGNATURE_SUBMITTER&#39;,&#xA;&#xA;  /**&#xA;   * This means the submitted timestamp proof does not have a valid timestamp proof signature&#xA;   */&#xA;  TIMESTAMP_PROOF_INVALID_SIGNATURE = &#39;TIMESTAMP_PROOF_INVALID_SIGNATURE&#39;,&#xA;&#xA;  /**&#xA;   * This means the type in the timestamp proofs do not match&#xA;   * timestamp proofs are not portable&#xA;   */&#xA;  TIMESTAMP_PROOF_INVALID_TYPE = &#39;TIMESTAMP_PROOF_INVALID_TYPE&#39;,&#xA;&#xA;  /**&#xA;   * This means the da id in the timestamp proofs do not match up&#xA;   * timestamp proofs are not portable&#xA;   */&#xA;  TIMESTAMP_PROOF_INVALID_DA_ID = &#39;TIMESTAMP_PROOF_INVALID_DA_ID&#39;,&#xA;&#xA;  /**&#xA;   * This means the timestamp proof uploaded was not done by a valid submitter&#xA;   */&#xA;  TIMESTAMP_PROOF_NOT_SUBMITTER = &#39;TIMESTAMP_PROOF_NOT_SUBMITTER&#39;,&#xA;&#xA;  /**&#xA;   * We tried to call them 5 times and its errored out - this is not a bad proof but bundlr/arweave are having issues&#xA;   */&#xA;  CAN_NOT_CONNECT_TO_BUNDLR = &#39;CAN_NOT_CONNECT_TO_BUNDLR&#39;,&#xA;&#xA;  /**&#xA;   * The DA tx could not be found or invalid on the bundlr/arweave nodes&#xA;   * can happened if pasted it in wrong&#xA;   */&#xA;  INVALID_TX_ID = &#39;INVALID_TX_ID&#39;,&#xA;&#xA;  /**&#xA;   * This the typed data format is invalid (aka a invalid address type etc)&#xA;   */&#xA;  INVALID_FORMATTED_TYPED_DATA = &#39;INVALID_FORMATTED_TYPED_DATA&#39;,&#xA;&#xA;  /**&#xA;   * This means it can not read the block from the node&#xA;   */&#xA;  BLOCK_CANT_BE_READ_FROM_NODE = &#39;BLOCK_CANT_BE_READ_FROM_NODE&#39;,&#xA;&#xA;  /**&#xA;   * This means it can not read the data from the node&#xA;   */&#xA;  DATA_CANT_BE_READ_FROM_NODE = &#39;DATA_CANT_BE_READ_FROM_NODE&#39;,&#xA;&#xA;  /**&#xA;   * This means the simulation was not able to be ran on the node, this does not mean&#xA;   * that it would fail on chain, it means the nodes may of been down and needs rechecking&#xA;   */&#xA;  SIMULATION_NODE_COULD_NOT_RUN = &#39;SIMULATION_NODE_COULD_NOT_RUN&#39;,&#xA;&#xA;  /**&#xA;   * This means the simulation was not successful and got rejected on-chain&#xA;   * or the result from the simulation did not match the expected result&#xA;   */&#xA;  SIMULATION_FAILED = &#39;SIMULATION_FAILED&#39;,&#xA;&#xA;  /**&#xA;   * This means the event emitted from the simulation does not match the expected event&#xA;   */&#xA;  EVENT_MISMATCH = &#39;EVENT_MISMATCH&#39;,&#xA;&#xA;  /**&#xA;   * This means the event timestamp passed into the emitted event does not match the signature timestamp&#xA;   */&#xA;  INVALID_EVENT_TIMESTAMP = &#39;INVALID_EVENT_TIMESTAMP&#39;,&#xA;&#xA;  /**&#xA;   * This means the deadline set in the typed data is not correct&#xA;   */&#xA;  INVALID_TYPED_DATA_DEADLINE_TIMESTAMP = &#39;INVALID_TYPED_DATA_DEADLINE_TIMESTAMP&#39;,&#xA;&#xA;  /**&#xA;   * This means the generated publication id for the generic id does not match&#xA;   * what it should be&#xA;   */&#xA;  GENERATED_PUBLICATION_ID_MISMATCH = &#39;GENERATED_PUBLICATION_ID_MISMATCH&#39;,&#xA;&#xA;  /**&#xA;   * This means the pointer set in the chain proofs is not required but set anyway&#xA;   */&#xA;  INVALID_POINTER_SET_NOT_NEEDED = &#39;INVALID_POINTER_SET_NOT_NEEDED&#39;,&#xA;&#xA;  /**&#xA;   * This means the pointer has failed verification&#xA;   */&#xA;  POINTER_FAILED_VERIFICATION = &#39;POINTER_FAILED_VERIFICATION&#39;,&#xA;&#xA;  /**&#xA;   * This means the block processed against is not the closest block to the timestamp proofs&#xA;   */&#xA;  NOT_CLOSEST_BLOCK = &#39;NOT_CLOSEST_BLOCK&#39;,&#xA;&#xA;  /**&#xA;   * This means the timestamp proofs are not close enough to the block&#xA;   */&#xA;  BLOCK_TOO_FAR = &#39;NOT_CLOSEST_BLOCK&#39;,&#xA;&#xA;  /**&#xA;   * This means the publication submitted does not have a valid pointer&#xA;   * and a pointer is required&#xA;   */&#xA;  PUBLICATION_NO_POINTER = &#39;PUBLICATION_NO_POINTER&#39;,&#xA;&#xA;  /**&#xA;   * Some publications (comment and mirror) for now can only be on another&#xA;   * DA publication not on evm chain publications&#xA;   */&#xA;  PUBLICATION_NONE_DA = &#39;PUBLICATION_NONE_DA&#39;,&#xA;&#xA;  /**&#xA;   * This means the publication nonce is invalid at the time of submission&#xA;   */&#xA;  PUBLICATION_NONCE_INVALID = &#39;PUBLICATION_NONCE_INVALID&#39;,&#xA;&#xA;  /**&#xA;   * This means the publication submisson was signed by a wallet that is not allowed&#xA;   */&#xA;  PUBLICATION_SIGNER_NOT_ALLOWED = &#39;PUBLICATION_SIGNER_NOT_ALLOWED&#39;,&#xA;&#xA;  /**&#xA;   * This means the evm signature has already been used&#xA;   */&#xA;  CHAIN_SIGNATURE_ALREADY_USED = &#39;CHAIN_SIGNATURE_ALREADY_USED&#39;,&#xA;&#xA;  /**&#xA;   * This means the publication submisson could not pass potentional due to a reorg&#xA;   */&#xA;  POTENTIAL_REORG = &#39;POTENTIAL_REORG&#39;,&#xA;&#xA;  /**&#xA;   * unknown error should not happen but catch all&#xA;   */&#xA;  UNKNOWN = &#39;UNKNOWN&#39;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running&lt;/h2&gt; &#xA;&lt;h3&gt;Key information&lt;/h3&gt; &#xA;&lt;p&gt;To run the verifier, you MUST use an archive node. You can sign up with Alchemy and use one of their free nodes. Non-archive nodes do not retain state information beyond the previous 16-128 blocks. While this may be sufficient for immediate runtime calls after the DA publication is created, it will not work for past transactions beyond the 16-128 block range.&lt;/p&gt; &#xA;&lt;h3&gt;Being as fast as possible - Concurrency&lt;/h3&gt; &#xA;&lt;p&gt;The verifier is designed for optimal speed, with performance determined by its configuration parameters. Achieving 10,000 TPS is not a problem, provided that the hardware and nodes can support these limits. When running the verifier, you have the option to set the CONCURRENCY, which divides the number of requests sent to the NODE_URL simultaneously. Higher concurrency values result in faster performance during resynchronization or when handling a large volume of transactions at once.&lt;/p&gt; &#xA;&lt;p&gt;The default concurrency is 100, which typically requires a paid archive node. If you prefer using a free node, the verifier will be slower, but it will still work effectively. For a free node, you can set the concurrency between 1 and 3. For example, at LENS, we have set the concurrency at 120, which enables our verifier to run very quickly.&lt;/p&gt; &#xA;&lt;h2&gt;Running straight out the box&lt;/h2&gt; &#xA;&lt;p&gt;You can install it globally:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ npm i @lens-protocol/momoka -g&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then you can just run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ momoka --node &#39;YOUR_NODE&#39; --environment=&#39;MUMBAI|POLYGON&#39; --concurrency=20&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;you can also just run with npx:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ npx @lens-protocol/momoka --node &#39;YOUR_NODE&#39; --environment=&#39;MUMBAI|POLYGON&#39; --concurrency=20&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default it will not resync all the data, it just start verifying from this point onwards unless you add the parameter &lt;code&gt;--resync=true&lt;/code&gt; which will start from block 0 and resync all the data.&lt;/p&gt; &#xA;&lt;h3&gt;Parameter meanings&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--node&lt;/code&gt; - this is the URI of the Polygon archive node you wish to connect to, this can be a free node or a paid node, it is recommended to use a paid node for the best performance. you can get up and running with a node using Alchemy, Infura, or any other similar infrastructure provider&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--environment&lt;/code&gt; - this is the environment you wish to run the verifier on, this can be &lt;code&gt;MUMBAI&lt;/code&gt; or &lt;code&gt;POLYGON&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--concurrency&lt;/code&gt; - this is the concurrency you wish to run the verifier on, which was talked in depth above&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--resync&lt;/code&gt; - this is a boolean value, which if set to true will start the verifier from the block 0 and resync all transactions from the past, if set to false it will start verifying from this moment onwards.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installing package&lt;/h2&gt; &#xA;&lt;p&gt;This is a written in node, and this means it can be run on the client as well as a server; it won&#39;t use the DB on the client but can mean you can run proof checks in runtime, which is super powerful. Also, you may which to monitor this on your server to index stuff as it comes in.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ npm i @lens-protocol/momoka&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;b&gt;Do not use if you do not know what you are doing the basic config works for all production apps&lt;/b&gt;&lt;/p&gt; &#xA;&lt;p&gt;Please note if you wish to use a different deployment then &lt;code&gt;PRODUCTION&lt;/code&gt; you will need to make sure you put &lt;code&gt;deployment: STAGING&lt;/code&gt; or &lt;code&gt;deployment: LOCAL&lt;/code&gt; in the &lt;code&gt;EthereumNode&lt;/code&gt; object. This for most will not be the case.&lt;/p&gt; &#xA;&lt;h3&gt;Client usage&lt;/h3&gt; &#xA;&lt;p&gt;The package exposes a separate entry point for the client usage (&lt;code&gt;&#39;@lens-protocol/momoka/client&#39;&lt;/code&gt;) to make sure the bundle size is not affected by any polyfills or other node specific code.&lt;/p&gt; &#xA;&lt;p&gt;Check the &lt;code&gt;playground-browser&lt;/code&gt; folder for a working example of the client usage.&lt;/p&gt; &#xA;&lt;h4&gt;checkDAProof&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;checkDAProof&lt;/code&gt; will return you a failure reason of the enum &lt;code&gt;MomokaValidatorError&lt;/code&gt;, and if successful, you be returned the entire &lt;code&gt;DAStructurePublication&lt;/code&gt;. This is a client specific version of the &lt;code&gt;checkDAProof&lt;/code&gt; function that doesn&#39;t have any caching in place. For the server version, please see the server usage section.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { checkDAProof, EthereumNode, Environment } from &#39;@lens-protocol/momoka/client&#39;;&#xA;&#xA;const ethereumNode: EthereumNode = {&#xA;  environment: Environment.POLYGON,&#xA;  nodeUrl: YOUR_NODE_URL,&#xA;};&#xA;&#xA;const result = await checkDAProof(PROOF_ID, ethereumNode);&#xA;if (result.isSuccess()) {&#xA;    console.log(&#39;proof valid&#39;, result.successResult)&#xA;    return; // all is well!&#xA;}&#xA;&#xA;// it failed!&#xA;console.error(&#39;proof invalid do something&#39;, result.failure)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Server usage&lt;/h3&gt; &#xA;&lt;h4&gt;checkDAProof&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;checkDAProof&lt;/code&gt; will return you a failure reason of the enum &lt;code&gt;MomokaValidatorError&lt;/code&gt;, and if successful, you be returned the entire &lt;code&gt;DAStructurePublication&lt;/code&gt;. This is a server specific version of the &lt;code&gt;checkDAProof&lt;/code&gt; function that has caching in place. For the client version, please see the client usage section.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { checkDAProof, EthereumNode, Environment } from &#39;@lens-protocol/momoka&#39;;&#xA;&#xA;const ethereumNode: EthereumNode = {&#xA;  environment: Environment.POLYGON,&#xA;  nodeUrl: YOUR_NODE_URL,&#xA;};&#xA;&#xA;const result = await checkDAProof(PROOF_ID, ethereumNode);&#xA;if (result.isSuccess()) {&#xA;    console.log(&#39;proof valid&#39;, result.successResult)&#xA;    return; // all is well!&#xA;}&#xA;&#xA;// it failed!&#xA;console.error(&#39;proof invalid do something&#39;, result.failure)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;startDAVerifierNode&lt;/h4&gt; &#xA;&lt;p&gt;This will start watching all the DA items coming in and logging it all out in your terminal. you can install the package and run it on your own server. By default it will not resync all the data, it just start verifying from this point onwards unless you add the parameter which is defined below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { startDAVerifierNode, EthereumNode } from &#39;@lens-protocol/momoka&#39;;&#xA;&#xA;const ethereumNode: EthereumNode = {&#xA;  environment: Environment.POLYGON,&#xA;  nodeUrl: YOUR_NODE_URL,&#xA;};&#xA;&#xA;// you should read up on section &#34;Being as fast as possible - Concurrency&#34;&#xA;const concurrency = 100;&#xA;&#xA;// it run forever and log out to the terminal&#xA;startDAVerifierNode(ethereumNode, concurrency);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;startDAVerifierNode - Stream with proofs verified&lt;/h4&gt; &#xA;&lt;p&gt;If you wish to index the data yourself, you can use the &lt;code&gt;startDAVerifierNode&lt;/code&gt; and stream the data out to your own DB using the &lt;code&gt;StreamCallback&lt;/code&gt;. This will run the verifier node and check the proofs as every new one comes in. By default it will not resync all the data, it just start verifying from this point onwards unless you add the parameter which is defined below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { startDAVerifierNode, StreamResult, EthereumNode } from &#39;@lens-protocol/momoka&#39;;&#xA;&#xA;const stream = (result: StreamResult) =&amp;gt; {&#xA;  console.log(&#39;streamed publication&#39;, result);&#xA;&#xA;  if(result.success) {&#xA;    // success - insert into your db here if you wish&#xA;    console.log(&#39;success&#39;, result.dataAvailabilityResult)&#xA;  } else {&#xA;    // failure reason&#xA;    console.log(&#39;reason&#39;, result.failureReason);&#xA;    // this will expose the submisson if it could be read&#xA;    console.log(&#39;submisson&#39;, result.dataAvailabilityResult)&#xA;  }&#xA;};&#xA;&#xA;const ethereumNode: EthereumNode = {&#xA;  environment: Environment.POLYGON,&#xA;  nodeUrl: YOUR_NODE_URL,&#xA;};&#xA;&#xA;// you should read up on section &#34;Being as fast as possible - Concurrency&#34;&#xA;const concurrency = 100;&#xA;&#xA;// it run forever and log out to the terminal&#xA;startDAVerifierNode(ethereumNode, concurrency, { stream });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Start verifier from block 0&lt;/h4&gt; &#xA;&lt;p&gt;You may wish to start the verifier and recheck from the first ever momoka transaction, You can do this by passing in the &lt;code&gt;resync&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { startDAVerifierNode, StreamResult, EthereumNode } from &#39;@lens-protocol/momoka&#39;;&#xA;&#xA;const ethereumNode: EthereumNode = {&#xA;  environment: Environment.POLYGON,&#xA;  nodeUrl: YOUR_NODE_URL,&#xA;};&#xA;&#xA;// you should read up on section &#34;Being as fast as possible - Concurrency&#34;&#xA;const concurrency = 100;&#xA;&#xA;// it run forever and log out to the terminal&#xA;startDAVerifierNode(ethereumNode, concurrency, { resync: true });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;startDATrustingIndexing&lt;/h4&gt; &#xA;&lt;p&gt;If you just want to get the data as fast as possible and do not wish to verify the proofs, you can use the &lt;code&gt;startDATrustingIndexing&lt;/code&gt; function. This will stream out the data as fast as possible and will not check the proofs, so does not require an archive node.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { startDATrustingIndexing, StreamResult, StartDATrustingIndexingRequest } from &#39;@lens-protocol/momoka&#39;;&#xA;&#xA;const stream = (result: StreamResult) =&amp;gt; {&#xA;  console.log(&#39;streamed publication&#39;, result);&#xA;&#xA;  if(result.success) {&#xA;    // success - insert into your db here if you wish&#xA;    console.log(&#39;success&#39;, result.dataAvailabilityResult)&#xA;  } else {&#xA;    // failure reason&#xA;    console.log(&#39;reason&#39;, result.failureReason);&#xA;    // this will expose the submisson if it could be read&#xA;    console.log(&#39;submisson&#39;, result.dataAvailabilityResult)&#xA;  }&#xA;};&#xA;&#xA;const request: StartDATrustingIndexingRequest = {&#xA;  environment: Environment.POLYGON,&#xA;  stream,&#xA;};&#xA;&#xA;// it run forever and stream data as it comes in&#xA;startDATrustingIndexing(request);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Running from this repo&lt;/h3&gt; &#xA;&lt;h4&gt;Dependencies&lt;/h4&gt; &#xA;&lt;p&gt;This package has a few dependencies that need to be installed, these are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;we use &lt;code&gt;pnpm&lt;/code&gt; for this repo so please have it installed: &lt;a href=&#34;https://pnpm.io/installation&#34;&gt;https://pnpm.io/installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;nvm is also used for node versioning:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you wish to just run it on its own, you can just run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ nvm use&#xA;$ pnpm i&#xA;$ pnpm run start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build its just:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pnpm build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tests&lt;/h3&gt; &#xA;&lt;p&gt;To run the tests:&lt;/p&gt; &#xA;&lt;p&gt;create an &lt;code&gt;.env.test&lt;/code&gt; file with the following (you need to add a mumbai node url)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ETHEREUM_NETWORK=MUMBAI&#xA;NODE_URL=MUMBAI_NODE_URL&#xA;DEPLOYMENT=PRODUCTION&#xA;CONCURRENCY=10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pnpm test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Docker&lt;/h3&gt; &#xA;&lt;p&gt;Please note you need a &lt;code&gt;.env&lt;/code&gt; setup for this to work.&lt;/p&gt; &#xA;&lt;p&gt;To run the docker first build it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker build -t da-service .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run -d -p 3008:3008 da-service&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will return an docker id.&lt;/p&gt; &#xA;&lt;p&gt;Then to listen to the logs you can:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker logs &amp;lt;id&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Any PRs are welcome and we will review them as soon as possible. Please make sure you have tests and they pass.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;h3&gt;Bundlr&lt;/h3&gt; &#xA;&lt;p&gt;A special thank you to &lt;a href=&#34;https://bundlr.network/&#34;&gt;Bundlr&lt;/a&gt; for making this project possible with their cutting-edge technology. We are grateful to their exceptional team for their collaboration and support.&lt;/p&gt; &#xA;&lt;h3&gt;Arweave&lt;/h3&gt; &#xA;&lt;p&gt;We also extend our gratitude to &lt;a href=&#34;https://www.arweave.org/&#34;&gt;Arweave&lt;/a&gt; for providing decentralized storage solutions for our data, contributing to the overall success of the DA project.&lt;/p&gt; &#xA;&lt;h2&gt;Why node?&lt;/h2&gt; &#xA;&lt;p&gt;Our goal was to create a tool that could be verified both on the client and server side, and we found that Node.js was the most suitable option for this purpose. Additionally, we aimed to make it as understandable as possible, and Node.js is renowned for its ease of use and a big languaged used throughout web3 development. As per our roadmap, we plan to migrate a significant portion of this stack to Rust, a more low-level language, to achieve maximum speed once we need it.&lt;/p&gt;</summary>
  </entry>
</feed>