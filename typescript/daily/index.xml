<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub TypeScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-21T01:39:35Z</updated>
  <subtitle>Daily Trending of TypeScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>gothinkster/realworld</title>
    <updated>2022-12-21T01:39:35Z</updated>
    <id>tag:github.com,2022-12-21:/gothinkster/realworld</id>
    <link href="https://github.com/gothinkster/realworld" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&#34;The mother of all demo apps&#34; ‚Äî Exemplary fullstack Medium.com clone powered by React, Angular, Node, Django, and many more üèÖ&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/gothinkster/realworld/main/media/realworld-dual-mode.png&#34; alt=&#34;RealWorld Example Applications&#34;&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34; style=&#34;margin-top: 30px;&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/gothinkster/realworld/main/media/stacks_hr.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://demo.realworld.io/&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/gothinkster/realworld/main/media/conduit_l.png&#34; align=&#34;right&#34; width=&#34;250px&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;See how &lt;em&gt;the exact same&lt;/em&gt; Medium.com clone (called &lt;a href=&#34;https://demo.realworld.io&#34;&gt;Conduit&lt;/a&gt;) is built using different &lt;a href=&#34;https://codebase.show/projects/realworld?category=frontend&#34;&gt;frontends&lt;/a&gt; and &lt;a href=&#34;https://codebase.show/projects/realworld?category=backend&#34;&gt;backends&lt;/a&gt;. Yes, you can mix and match them, because &lt;strong&gt;they all adhere to the same &lt;a href=&#34;https://realworld-docs.netlify.app/docs/specs/backend-specs/introduction&#34;&gt;API spec&lt;/a&gt;&lt;/strong&gt; üòÆüòé&lt;/h3&gt; &#xA;&lt;p&gt;While most &#34;todo&#34; demos provide an excellent cursory glance at a framework&#39;s capabilities, they typically don&#39;t convey the knowledge &amp;amp; perspective required to actually build &lt;em&gt;real&lt;/em&gt; applications with it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;RealWorld&lt;/strong&gt; solves this by allowing you to choose any frontend (React, Angular, &amp;amp; more) and any backend (Node, Django, &amp;amp; more) and see how they power a real-world, beautifully designed full-stack app called &lt;a href=&#34;https://demo.realworld.io&#34;&gt;&lt;strong&gt;Conduit&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Read the &lt;a href=&#34;https://medium.com/@ericsimons/introducing-realworld-6016654d36b5&#34;&gt;full blog post announcing RealWorld on Medium.&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Join us on &lt;a href=&#34;https://github.com/gothinkster/realworld/discussions&#34;&gt;GitHub Discussions!&lt;/a&gt; üéâ&lt;/p&gt; &#xA;&lt;h1&gt;Implementations&lt;/h1&gt; &#xA;&lt;p&gt;Over 100 implementations have been created using various languages, libraries, and frameworks.&lt;/p&gt; &#xA;&lt;p&gt;Explore them on &lt;a href=&#34;https://codebase.show/projects/realworld&#34;&gt;&lt;strong&gt;CodebaseShow&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Create a new implementation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://realworld-docs.netlify.app/docs/implementation-creation/introduction&#34;&gt;&lt;strong&gt;Create a new implementation &amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Or you can &lt;a href=&#34;https://github.com/gothinkster/realworld/discussions/categories/wip-implementations&#34;&gt;view upcoming implementations (WIPs)&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Learn more&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://medium.com/@ericsimons/introducing-realworld-6016654d36b5&#34;&gt;&#34;Introducing RealWorld üôå&#34;&lt;/a&gt; by Eric Simons&lt;/li&gt; &#xA; &lt;li&gt;Every tutorial is built against the same &lt;a href=&#34;https://raw.githubusercontent.com/gothinkster/realworld/main/api/&#34;&gt;API spec&lt;/a&gt; to ensure modularity of every frontend &amp;amp; backend&lt;/li&gt; &#xA; &lt;li&gt;Every frontend utilizes the same handcrafted &lt;a href=&#34;https://github.com/gothinkster/conduit-bootstrap-template&#34;&gt;Bootstrap 4 theme&lt;/a&gt; for identical UI/UX&lt;/li&gt; &#xA; &lt;li&gt;There is a hosted version of the backend API available for public usage, no API keys are required&lt;/li&gt; &#xA; &lt;li&gt;Interested in creating a new RealWorld stack? View our &lt;a href=&#34;https://realworld-docs.netlify.app/docs/implementation-creation/introduction&#34;&gt;starter guide &amp;amp; spec&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Active Maintainers&lt;/h1&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://github.com/geromegrignon&#34;&gt;G√©r√¥me Grignon&lt;/a&gt; - Maintainer&lt;/h4&gt; &#xA;&lt;img align=&#34;left&#34; width=&#34;40&#34; height=&#34;40&#34; src=&#34;https://avatars.githubusercontent.com/u/32737308?v=4&#34;&gt; &#xA;&lt;p&gt;G√©r√¥me is a Software Engineer at Sfeir. He&#39;s an open-source enthusiast.&lt;br&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://github.com/mvila&#34;&gt;Manuel Vila&lt;/a&gt; - Maintainer&lt;/h4&gt; &#xA;&lt;img align=&#34;left&#34; width=&#34;40&#34; height=&#34;40&#34; src=&#34;https://avatars.githubusercontent.com/u/381671?v=40&#34;&gt; &#xA;&lt;p&gt;Manuel is an independent Software Engineer, creator of the &lt;a href=&#34;https://layrjs.com&#34;&gt;Layr framework&lt;/a&gt; and the &lt;a href=&#34;https://codebase.show/&#34;&gt;CodebaseShow website&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://thinkster.io&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/gothinkster/realworld/main/media/end.png&#34; alt=&#34;Brought to you by Thinkster&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>auth0/nextjs-auth0</title>
    <updated>2022-12-21T01:39:35Z</updated>
    <id>tag:github.com,2022-12-21:/auth0/nextjs-auth0</id>
    <link href="https://github.com/auth0/nextjs-auth0" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Next.js SDK for signing in with Auth0&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.auth0.com/website/sdks/banners/nextjs-auth0-banner.png&#34; alt=&#34;nextjs-auth0&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The Auth0 Next.js SDK is a library for implementing user authentication in Next.js applications.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/npm/v/@auth0/nextjs-auth0&#34; alt=&#34;Release&#34;&gt; &lt;a href=&#34;https://github.com/auth0/nextjs-auth0/raw/main/package.json#L147&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/dynamic/json?color=brightgreen&amp;amp;label=coverage&amp;amp;query=jest.coverageThreshold.global.lines&amp;amp;suffix=%25&amp;amp;url=https%3A%2F%2Fraw.githubusercontent.com%2Fauth0%2Fnextjs-auth0%2Fmain%2Fpackage.json&#34; alt=&#34;Coverage&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/npm/dw/@auth0/nextjs-auth0&#34; alt=&#34;Downloads&#34;&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/:license-mit-blue.svg?style=flat&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/circleci/build/github/auth0/nextjs-auth0&#34; alt=&#34;CircleCI&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;üìö &lt;a href=&#34;https://raw.githubusercontent.com/auth0/nextjs-auth0/main/#documentation&#34;&gt;Documentation&lt;/a&gt; - üöÄ &lt;a href=&#34;https://raw.githubusercontent.com/auth0/nextjs-auth0/main/#getting-started&#34;&gt;Getting Started&lt;/a&gt;- üíª &lt;a href=&#34;https://raw.githubusercontent.com/auth0/nextjs-auth0/main/#api-reference&#34;&gt;API Reference&lt;/a&gt; - üí¨ &lt;a href=&#34;https://raw.githubusercontent.com/auth0/nextjs-auth0/main/#feedback&#34;&gt;Feedback&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.com/docs/quickstart/webapp/nextjs&#34;&gt;QuickStart&lt;/a&gt;- our guide for adding Auth0 to your Next.js app.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/auth0/nextjs-auth0/raw/main/FAQ.md&#34;&gt;FAQs&lt;/a&gt; - Frequently asked questions about nextjs-auth0.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/auth0/nextjs-auth0/raw/main/EXAMPLES.md&#34;&gt;Examples&lt;/a&gt; - lots of examples for your different use cases.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/auth0/nextjs-auth0/raw/main/SECURITY.md&#34;&gt;Security&lt;/a&gt; - Some important security notices that you should check.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/auth0/nextjs-auth0/raw/main/ARCHITECTURE.md&#34;&gt;Architecture&lt;/a&gt; - Architectural overview of the SDK.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/auth0/nextjs-auth0/raw/main/TESTING.md&#34;&gt;Testing&lt;/a&gt; - Some help with testing your nextjs-auth0 application.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/auth0/nextjs-auth0/raw/main/examples/README.md&#34;&gt;Deploying&lt;/a&gt; - How we deploy our example app to Vercel.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.com/docs&#34;&gt;Docs Site&lt;/a&gt; - explore our docs site and learn more about Auth0.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Using &lt;a href=&#34;https://npmjs.org&#34;&gt;npm&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install @auth0/nextjs-auth0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This library supports the following tooling versions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Node.js: 12 LTS and newer LTS releases are supported.&lt;/li&gt; &#xA; &lt;li&gt;Next.js: &lt;code&gt;&amp;gt;=10&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Auth0 Configuration&lt;/h3&gt; &#xA;&lt;p&gt;Create a &lt;strong&gt;Regular Web Application&lt;/strong&gt; in the &lt;a href=&#34;https://manage.auth0.com/#/applications&#34;&gt;Auth0 Dashboard&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;If you&#39;re using an existing application&lt;/strong&gt;, verify that you have configured the following settings in your Regular Web Application:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Click on the &#34;Settings&#34; tab of your application&#39;s page.&lt;/li&gt; &#xA;  &lt;li&gt;Scroll down and click on the &#34;Show Advanced Settings&#34; link.&lt;/li&gt; &#xA;  &lt;li&gt;Under &#34;Advanced Settings&#34;, click on the &#34;OAuth&#34; tab.&lt;/li&gt; &#xA;  &lt;li&gt;Ensure that &#34;JsonWebToken Signature Algorithm&#34; is set to &lt;code&gt;RS256&lt;/code&gt; and that &#34;OIDC Conformant&#34; is enabled.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Next, configure the following URLs for your application under the &#34;Application URIs&#34; section of the &#34;Settings&#34; page:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Allowed Callback URLs&lt;/strong&gt;: &lt;code&gt;http://localhost:3000/api/auth/callback&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Allowed Logout URLs&lt;/strong&gt;: &lt;code&gt;http://localhost:3000/&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Take note of the &lt;strong&gt;Client ID&lt;/strong&gt;, &lt;strong&gt;Client Secret&lt;/strong&gt;, and &lt;strong&gt;Domain&lt;/strong&gt; values under the &#34;Basic Information&#34; section. You&#39;ll need these values in the next step.&lt;/p&gt; &#xA;&lt;h3&gt;Basic Setup&lt;/h3&gt; &#xA;&lt;h4&gt;Configure the Application&lt;/h4&gt; &#xA;&lt;p&gt;You need to allow your Next.js application to communicate properly with Auth0. You can do so by creating a &lt;code&gt;.env.local&lt;/code&gt; file under your root project directory that defines the necessary Auth0 configuration values as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# A long, secret value used to encrypt the session cookie&#xA;AUTH0_SECRET=&#39;LONG_RANDOM_VALUE&#39;&#xA;# The base url of your application&#xA;AUTH0_BASE_URL=&#39;http://localhost:3000&#39;&#xA;# The url of your Auth0 tenant domain&#xA;AUTH0_ISSUER_BASE_URL=&#39;https://YOUR_AUTH0_DOMAIN.auth0.com&#39;&#xA;# Your Auth0 application&#39;s Client ID&#xA;AUTH0_CLIENT_ID=&#39;YOUR_AUTH0_CLIENT_ID&#39;&#xA;# Your Auth0 application&#39;s Client Secret&#xA;AUTH0_CLIENT_SECRET=&#39;YOUR_AUTH0_CLIENT_SECRET&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can execute the following command to generate a suitable string for the &lt;code&gt;AUTH0_SECRET&lt;/code&gt; value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;node -e &#34;console.log(crypto.randomBytes(32).toString(&#39;hex&#39;))&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can see a full list of Auth0 configuration options in the &lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/config.html#configuration-properties&#34;&gt;&#34;Configuration properties&#34;&lt;/a&gt; section of the &#34;Module config&#34; document.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;For more details about loading environment variables in Next.js, visit the &lt;a href=&#34;https://nextjs.org/docs/basic-features/environment-variables&#34;&gt;&#34;Environment Variables&#34;&lt;/a&gt; document.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Add the Dynamic API Route&lt;/h4&gt; &#xA;&lt;p&gt;Go to your Next.js application and create a &lt;a href=&#34;https://nextjs.org/docs/api-routes/dynamic-api-routes#optional-catch-all-api-routes&#34;&gt;catch-all, dynamic API route handler&lt;/a&gt; under the &lt;code&gt;/pages/api&lt;/code&gt; directory:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Create an &lt;code&gt;auth&lt;/code&gt; directory under the &lt;code&gt;/pages/api/&lt;/code&gt; directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a &lt;code&gt;[...auth0].js&lt;/code&gt; file under the newly created &lt;code&gt;auth&lt;/code&gt; directory.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The path to your dynamic API route file would be &lt;code&gt;/pages/api/auth/[...auth0].js&lt;/code&gt;. Populate that file as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { handleAuth } from &#39;@auth0/nextjs-auth0&#39;;&#xA;&#xA;export default handleAuth();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Executing &lt;code&gt;handleAuth()&lt;/code&gt; creates the following route handlers under the hood that perform different parts of the authentication flow:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;/api/auth/login&lt;/code&gt;: Your Next.js application redirects users to your identity provider for them to log in (you can optionally pass a &lt;code&gt;returnTo&lt;/code&gt; parameter to return to a custom relative URL after login, for example &lt;code&gt;/api/auth/login?returnTo=/profile&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/api/auth/callback&lt;/code&gt;: Your identity provider redirects users to this route after they successfully log in.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/api/auth/logout&lt;/code&gt;: Your Next.js application logs out the user.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/api/auth/me&lt;/code&gt;: You can fetch user profile information in JSON format.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Add the UserProvider to Custom App&lt;/h4&gt; &#xA;&lt;p&gt;Wrap your &lt;code&gt;pages/_app.js&lt;/code&gt; component with the &lt;code&gt;UserProvider&lt;/code&gt; component:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// pages/_app.js&#xA;import React from &#39;react&#39;;&#xA;import { UserProvider } from &#39;@auth0/nextjs-auth0/client&#39;;&#xA;&#xA;export default function App({ Component, pageProps }) {&#xA;  return (&#xA;    &amp;lt;UserProvider&amp;gt;&#xA;      &amp;lt;Component {...pageProps} /&amp;gt;&#xA;    &amp;lt;/UserProvider&amp;gt;&#xA;  );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Consume Authentication&lt;/h4&gt; &#xA;&lt;p&gt;You can now determine if a user is authenticated by checking that the &lt;code&gt;user&lt;/code&gt; object returned by the &lt;code&gt;useUser()&lt;/code&gt; hook is defined. You can also log in or log out your users from the frontend layer of your Next.js application by redirecting them to the appropriate automatically-generated route:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// pages/index.js&#xA;import { useUser } from &#39;@auth0/nextjs-auth0/client&#39;;&#xA;&#xA;export default function Index() {&#xA;  const { user, error, isLoading } = useUser();&#xA;&#xA;  if (isLoading) return &amp;lt;div&amp;gt;Loading...&amp;lt;/div&amp;gt;;&#xA;  if (error) return &amp;lt;div&amp;gt;{error.message}&amp;lt;/div&amp;gt;;&#xA;&#xA;  if (user) {&#xA;    return (&#xA;      &amp;lt;div&amp;gt;&#xA;        Welcome {user.name}! &amp;lt;a href=&#34;/api/auth/logout&#34;&amp;gt;Logout&amp;lt;/a&amp;gt;&#xA;      &amp;lt;/div&amp;gt;&#xA;    );&#xA;  }&#xA;&#xA;  return &amp;lt;a href=&#34;/api/auth/login&#34;&amp;gt;Login&amp;lt;/a&amp;gt;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Next linting rules might suggest using the &lt;code&gt;Link&lt;/code&gt; component instead of an anchor tag. The &lt;code&gt;Link&lt;/code&gt; component is meant to perform &lt;a href=&#34;https://nextjs.org/docs/api-reference/next/link&#34;&gt;client-side transitions between pages&lt;/a&gt;. As the links point to an API route and not to a page, you should keep them as anchor tags.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;There are two additional ways to check for an authenticated user; one for Next.js pages using &lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/helpers_with_page_auth_required.html#withpageauthrequired&#34;&gt;withPageAuthRequired&lt;/a&gt; and one for Next.js API routes using &lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/helpers_with_api_auth_required.html#withapiauthrequired&#34;&gt;withAPIAuthRequired&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For other comprehensive examples, see the &lt;a href=&#34;https://github.com/auth0/nextjs-auth0/raw/main/EXAMPLES.md&#34;&gt;EXAMPLES.md&lt;/a&gt; document.&lt;/p&gt; &#xA;&lt;h2&gt;API Reference&lt;/h2&gt; &#xA;&lt;h3&gt;Server (for Node.js)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;import * from @auth0/nextjs-auth0&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/config.html&#34;&gt;Configuration Options and Environment variables&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/index.html#initauth0&#34;&gt;initAuth0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/handlers_auth.html&#34;&gt;handleAuth&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/handlers_login.html#handlelogin&#34;&gt;handleLogin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/handlers_callback.html&#34;&gt;handleCallback&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/handlers_logout.html&#34;&gt;handleLogout&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/handlers_profile.html&#34;&gt;handleProfile&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/helpers_with_api_auth_required.html&#34;&gt;withApiAuthRequired&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/helpers_with_page_auth_required.html#withpageauthrequired&#34;&gt;withPageAuthRequired&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/session_get_session.html&#34;&gt;getSession&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/session_update_session.html&#34;&gt;updateSession&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/session_get_access_token.html&#34;&gt;getAccessToken&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Edge (for Middleware and the Edge runtime)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;import * from @auth0/nextjs-auth0/edge&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/config.html&#34;&gt;Configuration Options and Environment variables&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/edge.html#initauth0-1&#34;&gt;initAuth0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/helpers_with_middleware_auth_required.html&#34;&gt;withMiddlewareAuthRequired&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/edge.html#getsession-1&#34;&gt;getSession&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Client (for the Browser)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;import * from @auth0/nextjs-auth0/client&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/client_use_user.html#userprovider&#34;&gt;UserProvider&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/client_use_user.html&#34;&gt;useUser&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/client_with_page_auth_required.html&#34;&gt;withPageAuthRequired&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Testing helpers&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;import * from @auth0/nextjs-auth0/testing&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/helpers_testing.html#generatesessioncookie&#34;&gt;generateSessionCookie&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Visit the auto-generated &lt;a href=&#34;https://auth0.github.io/nextjs-auth0/&#34;&gt;API Docs&lt;/a&gt; for more details&lt;/p&gt; &#xA;&lt;h3&gt;Cookies and Security&lt;/h3&gt; &#xA;&lt;p&gt;All cookies will be set to &lt;code&gt;HttpOnly, SameSite=Lax&lt;/code&gt; and will be set to &lt;code&gt;Secure&lt;/code&gt; if the application&#39;s &lt;code&gt;AUTH0_BASE_URL&lt;/code&gt; is &lt;code&gt;https&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;HttpOnly&lt;/code&gt; setting will make sure that client-side JavaScript is unable to access the cookie to reduce the attack surface of &lt;a href=&#34;https://auth0.com/blog/developers-guide-to-common-vulnerabilities-and-how-to-prevent-them/#Cross-Site-Scripting--XSS-&#34;&gt;XSS attacks&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;SameSite=Lax&lt;/code&gt; setting will help mitigate CSRF attacks. Learn more about SameSite by reading the &lt;a href=&#34;https://auth0.com/blog/browser-behavior-changes-what-developers-need-to-know/&#34;&gt;&#34;Upcoming Browser Behavior Changes: What Developers Need to Know&#34;&lt;/a&gt; blog post.&lt;/p&gt; &#xA;&lt;h3&gt;Caching and Security&lt;/h3&gt; &#xA;&lt;p&gt;Many hosting providers will offer to cache your content at the edge in order to serve data to your users as fast as possible. For example Vercel will &lt;a href=&#34;https://vercel.com/docs/concepts/edge-network/caching&#34;&gt;cache your content on the Vercel Edge Network&lt;/a&gt; for all static content and Serverless Functions if you provide the necessary caching headers on your response.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s generally a bad idea to cache any response that requires authentication, even if the response&#39;s content appears safe to cache there may be other data in the response that isn&#39;t.&lt;/p&gt; &#xA;&lt;p&gt;This SDK offers a rolling session by default, which means that any response that reads the session will have a &lt;code&gt;Set-Cookie&lt;/code&gt; header to update the cookie&#39;s expiry. Vercel and potentially other hosting providers include the &lt;code&gt;Set-Cookie&lt;/code&gt; header in the cached response, so even if you think the response&#39;s content can be cached publicly, the responses &lt;code&gt;Set-Cookie&lt;/code&gt; header cannot.&lt;/p&gt; &#xA;&lt;p&gt;Check your hosting provider&#39;s caching rules, but in general you should &lt;strong&gt;never&lt;/strong&gt; cache responses that either require authentication or even touch the session to check authentication (eg when using &lt;code&gt;withApiAuthRequired&lt;/code&gt;, &lt;code&gt;withPageAuthRequired&lt;/code&gt; or even just &lt;code&gt;getSession&lt;/code&gt; or &lt;code&gt;getAccessToken&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Error Handling and Security&lt;/h3&gt; &#xA;&lt;p&gt;Errors that come from Auth0 in the &lt;code&gt;redirect_uri&lt;/code&gt; callback may contain reflected user input via the OpenID Connect &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;error_description&lt;/code&gt; query parameter. Because of this, we do some &lt;a href=&#34;https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#rule-1-html-encode-before-inserting-untrusted-data-into-html-element-content&#34;&gt;basic escaping&lt;/a&gt; on the &lt;code&gt;message&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;error_description&lt;/code&gt; properties of the &lt;code&gt;IdentityProviderError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;But, if you write your own error handler, you should &lt;strong&gt;not&lt;/strong&gt; render the error &lt;code&gt;message&lt;/code&gt;, or &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;error_description&lt;/code&gt; properties without using a templating engine that will properly escape them for other HTML contexts first.&lt;/p&gt; &#xA;&lt;h3&gt;Base Path and Internationalized Routing&lt;/h3&gt; &#xA;&lt;p&gt;With Next.js you can deploy a Next.js application under a sub-path of a domain using &lt;a href=&#34;https://nextjs.org/docs/api-reference/next.config.js/basepath&#34;&gt;Base Path&lt;/a&gt; and serve internationalized (i18n) routes using &lt;a href=&#34;https://nextjs.org/docs/advanced-features/i18n-routing&#34;&gt;Internationalized Routing&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you use these features the urls of your application will change and so the urls to the nextjs-auth0 routes will change. To accommodate this there are various places in the SDK that you can customise the url.&lt;/p&gt; &#xA;&lt;p&gt;For example, if &lt;code&gt;basePath: &#39;/foo&#39;&lt;/code&gt; you should prepend this to the &lt;code&gt;loginUrl&lt;/code&gt; and &lt;code&gt;profileUrl&lt;/code&gt; specified in your &lt;code&gt;Auth0Provider&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// _app.jsx&#xA;function App({ Component, pageProps }) {&#xA;  return (&#xA;    &amp;lt;UserProvider loginUrl=&#34;/foo/api/auth/login&#34; profileUrl=&#34;/foo/api/auth/me&#34;&amp;gt;&#xA;      &amp;lt;Component {...pageProps} /&amp;gt;&#xA;    &amp;lt;/UserProvider&amp;gt;&#xA;  );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, any links to login or logout should include the &lt;code&gt;basePath&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&#34;/foo/api/auth/login&#34;&amp;gt;Login&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&#xA;&amp;lt;a href=&#34;/foo/api/auth/logout&#34;&amp;gt;Logout&amp;lt;/a&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should configure the &lt;a href=&#34;https://auth0.github.io/nextjs-auth0/interfaces/config.baseconfig.html#baseurl&#34;&gt;baseUrl&lt;/a&gt; (or the &lt;code&gt;AUTH0_BASE_URL&lt;/code&gt; environment variable). For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# .env.local&#xA;AUTH0_BASE_URL=http://localhost:3000/foo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For any pages that are protected with the Server Side &lt;a href=&#34;https://auth0.github.io/nextjs-auth0/modules/helpers_with_page_auth_required.html#withpageauthrequired&#34;&gt;withPageAuthRequired&lt;/a&gt; you should update the &lt;code&gt;returnTo&lt;/code&gt; parameter depending on the &lt;code&gt;basePath&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt; if necessary.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ./pages/my-ssr-page.jsx&#xA;export default MySsrPage = () =&amp;gt; &amp;lt;&amp;gt;&amp;lt;/&amp;gt;;&#xA;&#xA;const getFullReturnTo = (ctx) =&amp;gt; {&#xA;  // TODO: implement getFullReturnTo based on the ctx.resolvedUrl, ctx.locale&#xA;  // and your next.config.js&#39;s basePath and i18n settings.&#xA;  return &#39;/foo/en-US/my-ssr-page&#39;;&#xA;};&#xA;&#xA;export const getServerSideProps = (ctx) =&amp;gt; {&#xA;  const returnTo = getFullReturnTo(ctx.req);&#xA;  return withPageAuthRequired({ returnTo })(ctx);&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Comparison with the Auth0 React SDK&lt;/h3&gt; &#xA;&lt;p&gt;We also provide an Auth0 React SDK, &lt;a href=&#34;https://github.com/auth0/auth0-react&#34;&gt;auth0-react&lt;/a&gt;, which may be suitable for your Next.js application.&lt;/p&gt; &#xA;&lt;p&gt;The SPA security model used by &lt;code&gt;auth0-react&lt;/code&gt; is different from the Web Application security model used by this SDK. In short, this SDK protects pages and API routes with a cookie session (see &lt;a href=&#34;https://raw.githubusercontent.com/auth0/nextjs-auth0/main/#cookies-and-security&#34;&gt;&#34;Cookies and Security&#34;&lt;/a&gt;). A SPA library like &lt;code&gt;auth0-react&lt;/code&gt; will store the user&#39;s ID token and access token directly in the browser and use them to access external APIs directly.&lt;/p&gt; &#xA;&lt;p&gt;You should be aware of the security implications of both models. However, &lt;a href=&#34;https://github.com/auth0/auth0-react&#34;&gt;auth0-react&lt;/a&gt; may be more suitable for your needs if you meet any of the following scenarios:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You are using &lt;a href=&#34;https://nextjs.org/docs/advanced-features/static-html-export&#34;&gt;Static HTML Export&lt;/a&gt; with Next.js.&lt;/li&gt; &#xA; &lt;li&gt;You do not need to access user data during server-side rendering.&lt;/li&gt; &#xA; &lt;li&gt;You want to get the access token and call external API&#39;s directly from the frontend layer rather than using Next.js API routes as a proxy to call external APIs.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Testing&lt;/h3&gt; &#xA;&lt;p&gt;By default, the SDK creates and manages a singleton instance to run for the lifetime of the application. When testing your application, you may need to reset this instance, so its state does not leak between tests.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re using Jest, we recommend using &lt;code&gt;jest.resetModules()&lt;/code&gt; after each test. Alternatively, you can look at &lt;a href=&#34;https://raw.githubusercontent.com/auth0/nextjs-auth0/main/EXAMPLES.md#create-your-own-instance-of-the-sdk&#34;&gt;creating your own instance of the SDK&lt;/a&gt;, so it can be recreated between tests.&lt;/p&gt; &#xA;&lt;p&gt;For end to end tests, have a look at how we use a &lt;a href=&#34;https://raw.githubusercontent.com/auth0/nextjs-auth0/main/scripts/oidc-provider.js&#34;&gt;mock OIDC Provider&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Deploying&lt;/h1&gt; &#xA;&lt;p&gt;For deploying, have a look at &lt;a href=&#34;https://raw.githubusercontent.com/auth0/nextjs-auth0/main/examples/README.md&#34;&gt;how we deploy our example app to Vercel&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We appreciate feedback and contribution to this repo! Before you get started, please read the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/auth0/open-source-template/raw/master/GENERAL-CONTRIBUTING.md&#34;&gt;Auth0&#39;s general contribution guidelines&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/auth0/express-openid-connect/raw/master/CODE-OF-CONDUCT.md&#34;&gt;Auth0&#39;s code of conduct guidelines&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/auth0/nextjs-auth0/main/CONTRIBUTING.md&#34;&gt;This repo&#39;s contribution guide&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Vulnerability Reporting&lt;/h2&gt; &#xA;&lt;p&gt;Please do not report security vulnerabilities on the public GitHub issue tracker. The &lt;a href=&#34;https://auth0.com/responsible-disclosure-policy&#34;&gt;Responsible Disclosure Program&lt;/a&gt; details the procedure for disclosing security issues.&lt;/p&gt; &#xA;&lt;h2&gt;What is Auth0?&lt;/h2&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;picture&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://cdn.auth0.com/website/sdks/logos/auth0_dark_mode.png&#34; width=&#34;150&#34;&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: light)&#34; srcset=&#34;https://cdn.auth0.com/website/sdks/logos/auth0_light_mode.png&#34; width=&#34;150&#34;&gt; &#xA;  &lt;img alt=&#34;Auth0 Logo&#34; src=&#34;https://cdn.auth0.com/website/sdks/logos/auth0_light_mode.png&#34; width=&#34;150&#34;&gt; &#xA; &lt;/picture&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; Auth0 is an easy to implement, adaptable authentication and authorization platform. To learn more checkout &lt;a href=&#34;https://auth0.com/why-auth0&#34;&gt;Why Auth0?&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; This project is licensed under the MIT license. See the &lt;a href=&#34;https://github.com/auth0/express-openid-connect/raw/master/LICENSE&#34;&gt; LICENSE&lt;/a&gt; file for more info. &lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jquense/yup</title>
    <updated>2022-12-21T01:39:35Z</updated>
    <id>tag:github.com,2022-12-21:/jquense/yup</id>
    <link href="https://github.com/jquense/yup" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Dead simple Object schema validation&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Yup&lt;/h1&gt; &#xA;&lt;p&gt;Yup is a schema builder for runtime value parsing and validation. Define a schema, transform a value to match, assert the shape of an existing value, or both. Yup schema are extremely expressive and allow modeling complex, interdependent validations, or value transformation.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;You are viewing docs for the v1.0.0 pre-release of yup, pre-v1 docs are available: &lt;a href=&#34;https://github.com/jquense/yup/tree/pre-v1&#34;&gt;here&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;Killer Features&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Concise yet expressive schema interface, equipped to model simple to complex data models&lt;/li&gt; &#xA; &lt;li&gt;Powerful TypeScript support. Infer static types from schema, or ensure schema correctly implement a type&lt;/li&gt; &#xA; &lt;li&gt;Built-in async validation support. Model server-side and client-side validation equally well&lt;/li&gt; &#xA; &lt;li&gt;Extensible: add your own type-safe methods and schema&lt;/li&gt; &#xA; &lt;li&gt;Rich error details, make debugging a breeze&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Schema are comprised of parsing actions (transforms) as well as assertions (tests) about the input value. Validate an input value to parse it and run the configured set of assertions. Chain together methods to build a schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { object, string, number, date, InferType } from &#39;yup&#39;;&#xA;&#xA;let userSchema = object({&#xA;  name: string().required(),&#xA;  age: number().required().positive().integer(),&#xA;  email: string().email(),&#xA;  website: string().url().nullable(),&#xA;  createdOn: date().default(() =&amp;gt; new Date()),&#xA;});&#xA;&#xA;// parse and assert validity&#xA;const user = await userSchema.validate(await fetchUser());&#xA;&#xA;type User = InferType&amp;lt;typeof userSchema&amp;gt;;&#xA;/* {&#xA;  name: string;&#xA;  age: number;&#xA;  email?: string | undefined&#xA;  website?: string | null | undefined&#xA;  createdOn: Date&#xA;}*/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use a schema to coerce or &#34;cast&#34; an input value into the correct type, and optionally transform that value into more concrete and specific values, without making further assertions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// Attempts to coerce values to the correct type&#xA;const parsedUser = userSchema.cast({&#xA;  name: &#39;jimmy&#39;,&#xA;  age: &#39;24&#39;,&#xA;  createdOn: &#39;2014-09-23T19:25:25Z&#39;,&#xA;});&#xA;// ‚úÖ  { name: &#39;jimmy&#39;, age: 24, createdOn: Date }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Know that your input value is already parsed? You can &#34;strictly&#34; validate an input, and avoid the overhead of running parsing logic.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// ‚ùå  ValidationError &#34;age is not a number&#34;&#xA;const parsedUser = await userSchema.validate(&#xA;  {&#xA;    name: &#39;jimmy&#39;,&#xA;    age: &#39;24&#39;,&#xA;  },&#xA;  { strict: true },&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;!-- The exported functions are factory methods for constructing schema instances, but without the `new` keyword.&#xA;If you need access to the actual schema classes, they are also exported:&#xA;&#xA;```js&#xA;import {&#xA;  BooleanSchema,&#xA;  DateSchema,&#xA;  MixedSchema,&#xA;  NumberSchema,&#xA;  ArraySchema,&#xA;  ObjectSchema,&#xA;  StringSchema,&#xA;} from &#39;yup&#39;;&#xA;``` --&gt; &#xA;&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schema-basics&#34;&gt;Schema basics&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#parsing-transforms&#34;&gt;Parsing: Transforms&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#validation-tests&#34;&gt;Validation: Tests&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#customizing-errors&#34;&gt;Customizing errors&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#composition-and-reuse&#34;&gt;Composition and Reuse&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#typescript-integration&#34;&gt;TypeScript integration&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schema-defaults&#34;&gt;Schema defaults&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#ensuring-a-schema-matches-an-existing-type&#34;&gt;Ensuring a schema matches an existing type&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#extending-built-in-schema-with-new-methods&#34;&gt;Extending built-in schema with new methods&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#typescript-configuration&#34;&gt;TypeScript configuration&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#error-message-customization&#34;&gt;Error message customization&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#localization-and-i18n&#34;&gt;localization and i18n&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#api&#34;&gt;API&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#yup&#34;&gt;&lt;code&gt;yup&lt;/code&gt;&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#reachschema-schema-path-string-value-object-context-object-schema&#34;&gt;&lt;code&gt;reach(schema: Schema, path: string, value?: object, context?: object): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#addmethodschematype-schema-name-string-method--schema-void&#34;&gt;&lt;code&gt;addMethod(schemaType: Schema, name: string, method: ()=&amp;gt; Schema): void&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#refpath-string-options--contextprefix-string--ref&#34;&gt;&lt;code&gt;ref(path: string, options: { contextPrefix: string }): Ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#lazyvalue-any--schema-lazy&#34;&gt;&lt;code&gt;lazy((value: any) =&amp;gt; Schema): Lazy&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#validationerrorerrors-string--arraystring-value-any-path-string&#34;&gt;&lt;code&gt;ValidationError(errors: string | Array&amp;lt;string&amp;gt;, value: any, path: string)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schema&#34;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemaclone-schema&#34;&gt;&lt;code&gt;Schema.clone(): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemalabellabel-string-schema&#34;&gt;&lt;code&gt;Schema.label(label: string): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemametametadata-object-schema&#34;&gt;&lt;code&gt;Schema.meta(metadata: object): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemadescribeoptions-resolveoptions-schemadescription&#34;&gt;&lt;code&gt;Schema.describe(options?: ResolveOptions): SchemaDescription&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemaconcatschema-schema-schema&#34;&gt;&lt;code&gt;Schema.concat(schema: Schema): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemavalidatevalue-any-options-object-promiseinfertypeschema-validationerror&#34;&gt;&lt;code&gt;Schema.validate(value: any, options?: object): Promise&amp;lt;InferType&amp;lt;Schema&amp;gt;, ValidationError&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemavalidatesyncvalue-any-options-object-infertypeschema&#34;&gt;&lt;code&gt;Schema.validateSync(value: any, options?: object): InferType&amp;lt;Schema&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemavalidateatpath-string-value-any-options-object-promiseinfertypeschema-validationerror&#34;&gt;&lt;code&gt;Schema.validateAt(path: string, value: any, options?: object): Promise&amp;lt;InferType&amp;lt;Schema&amp;gt;, ValidationError&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemavalidatesyncatpath-string-value-any-options-object-infertypeschema&#34;&gt;&lt;code&gt;Schema.validateSyncAt(path: string, value: any, options?: object): InferType&amp;lt;Schema&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemaisvalidvalue-any-options-object-promiseboolean&#34;&gt;&lt;code&gt;Schema.isValid(value: any, options?: object): Promise&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemaisvalidsyncvalue-any-options-object-boolean&#34;&gt;&lt;code&gt;Schema.isValidSync(value: any, options?: object): boolean&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemacastvalue-any-options---infertypeschema&#34;&gt;&lt;code&gt;Schema.cast(value: any, options = {}): InferType&amp;lt;Schema&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemaistypevalue-any-value-is-infertypeschema&#34;&gt;&lt;code&gt;Schema.isType(value: any): value is InferType&amp;lt;Schema&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemastrictenabled-boolean--false-schema&#34;&gt;&lt;code&gt;Schema.strict(enabled: boolean = false): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemastripenabled-boolean--true-schema&#34;&gt;&lt;code&gt;Schema.strip(enabled: boolean = true): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemawithmutationbuilder-current-schema--void-void&#34;&gt;&lt;code&gt;Schema.withMutation(builder: (current: Schema) =&amp;gt; void): void&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemadefaultvalue-any-schema&#34;&gt;&lt;code&gt;Schema.default(value: any): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemagetdefaultoptions-object-any&#34;&gt;&lt;code&gt;Schema.getDefault(options?: object): Any&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemanullable-schema&#34;&gt;&lt;code&gt;Schema.nullable(): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemanonnullable-schema&#34;&gt;&lt;code&gt;Schema.nonNullable(): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemadefined-schema&#34;&gt;&lt;code&gt;Schema.defined(): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemaoptional-schema&#34;&gt;&lt;code&gt;Schema.optional(): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemarequiredmessage-string--function-schema&#34;&gt;&lt;code&gt;Schema.required(message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemanotrequired-schema&#34;&gt;&lt;code&gt;Schema.notRequired(): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schematypeerrormessage-string-schema&#34;&gt;&lt;code&gt;Schema.typeError(message: string): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemaoneofarrayofvalues-arrayany-message-string--function-schema-alias-equals&#34;&gt;&lt;code&gt;Schema.oneOf(arrayOfValues: Array&amp;lt;any&amp;gt;, message?: string | function): Schema&lt;/code&gt; Alias: &lt;code&gt;equals&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemanotoneofarrayofvalues-arrayany-message-string--function&#34;&gt;&lt;code&gt;Schema.notOneOf(arrayOfValues: Array&amp;lt;any&amp;gt;, message?: string | function)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schemawhenkeys-string--string-builder-object--values-any-schema--schema-schema&#34;&gt;&lt;code&gt;Schema.when(keys: string | string[], builder: object | (values: any[], schema) =&amp;gt; Schema): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schematestname-string-message-string--function--any-test-function-schema&#34;&gt;&lt;code&gt;Schema.test(name: string, message: string | function | any, test: function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schematestoptions-object-schema&#34;&gt;&lt;code&gt;Schema.test(options: object): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#schematransformcurrentvalue-any-originalvalue-any--any-schema&#34;&gt;&lt;code&gt;Schema.transform((currentValue: any, originalValue: any) =&amp;gt; any): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#mixed&#34;&gt;mixed&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#string&#34;&gt;string&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringrequiredmessage-string--function-schema&#34;&gt;&lt;code&gt;string.required(message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringlengthlimit-number--ref-message-string--function-schema&#34;&gt;&lt;code&gt;string.length(limit: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringminlimit-number--ref-message-string--function-schema&#34;&gt;&lt;code&gt;string.min(limit: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringmaxlimit-number--ref-message-string--function-schema&#34;&gt;&lt;code&gt;string.max(limit: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringmatchesregex-regex-message-string--function-schema&#34;&gt;&lt;code&gt;string.matches(regex: Regex, message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringmatchesregex-regex-options--message-string-excludeemptystring-bool--schema&#34;&gt;&lt;code&gt;string.matches(regex: Regex, options: { message: string, excludeEmptyString: bool }): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringemailmessage-string--function-schema&#34;&gt;&lt;code&gt;string.email(message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringurlmessage-string--function-schema&#34;&gt;&lt;code&gt;string.url(message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringuuidmessage-string--function-schema&#34;&gt;&lt;code&gt;string.uuid(message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringensure-schema&#34;&gt;&lt;code&gt;string.ensure(): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringtrimmessage-string--function-schema&#34;&gt;&lt;code&gt;string.trim(message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringlowercasemessage-string--function-schema&#34;&gt;&lt;code&gt;string.lowercase(message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringuppercasemessage-string--function-schema&#34;&gt;&lt;code&gt;string.uppercase(message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#number&#34;&gt;number&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#numberminlimit-number--ref-message-string--function-schema&#34;&gt;&lt;code&gt;number.min(limit: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#numbermaxlimit-number--ref-message-string--function-schema&#34;&gt;&lt;code&gt;number.max(limit: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#numberlessthanmax-number--ref-message-string--function-schema&#34;&gt;&lt;code&gt;number.lessThan(max: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#numbermorethanmin-number--ref-message-string--function-schema&#34;&gt;&lt;code&gt;number.moreThan(min: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#numberpositivemessage-string--function-schema&#34;&gt;&lt;code&gt;number.positive(message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#numbernegativemessage-string--function-schema&#34;&gt;&lt;code&gt;number.negative(message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#numberintegermessage-string--function-schema&#34;&gt;&lt;code&gt;number.integer(message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#numbertruncate-schema&#34;&gt;&lt;code&gt;number.truncate(): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#numberroundtype-floor--ceil--trunc--round--round-schema&#34;&gt;&lt;code&gt;number.round(type: &#39;floor&#39; | &#39;ceil&#39; | &#39;trunc&#39; | &#39;round&#39; = &#39;round&#39;): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#boolean&#34;&gt;boolean&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#date&#34;&gt;date&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#dateminlimit-date--string--ref-message-string--function-schema&#34;&gt;&lt;code&gt;date.min(limit: Date | string | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#datemaxlimit-date--string--ref-message-string--function-schema&#34;&gt;&lt;code&gt;date.max(limit: Date | string | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#array&#34;&gt;array&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#arrayoftype-schema-this&#34;&gt;&lt;code&gt;array.of(type: Schema): this&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#arrayjson-this&#34;&gt;&lt;code&gt;array.json(): this&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#arraylengthlength-number--ref-message-string--function-this&#34;&gt;&lt;code&gt;array.length(length: number | Ref, message?: string | function): this&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#arrayminlimit-number--ref-message-string--function-this&#34;&gt;&lt;code&gt;array.min(limit: number | Ref, message?: string | function): this&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#arraymaxlimit-number--ref-message-string--function-this&#34;&gt;&lt;code&gt;array.max(limit: number | Ref, message?: string | function): this&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#arrayensure-this&#34;&gt;&lt;code&gt;array.ensure(): this&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#arraycompactrejector-value--boolean-schema&#34;&gt;&lt;code&gt;array.compact(rejector: (value) =&amp;gt; boolean): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#tuple&#34;&gt;tuple&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#object&#34;&gt;object&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#object-schema-defaults&#34;&gt;Object schema defaults&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#objectshapefields-object-nosortedges-arraystring-string-schema&#34;&gt;&lt;code&gt;object.shape(fields: object, noSortEdges?: Array&amp;lt;[string, string]&amp;gt;): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#objectjson-this&#34;&gt;&lt;code&gt;object.json(): this&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#objectconcatschemab-objectschema-objectschema&#34;&gt;&lt;code&gt;object.concat(schemaB: ObjectSchema): ObjectSchema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#objectpickkeys-string-schema&#34;&gt;&lt;code&gt;object.pick(keys: string[]): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#objectomitkeys-string-schema&#34;&gt;&lt;code&gt;object.omit(keys: string[]): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#objectfromfromkey-string-tokey-string-alias-boolean--false-this&#34;&gt;&lt;code&gt;object.from(fromKey: string, toKey: string, alias: boolean = false): this&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#objectnounknownonlyknownkeys-boolean--true-message-string--function-schema&#34;&gt;&lt;code&gt;object.noUnknown(onlyKnownKeys: boolean = true, message?: string | function): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#objectcamelcase-schema&#34;&gt;&lt;code&gt;object.camelCase(): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#objectconstantcase-schema&#34;&gt;&lt;code&gt;object.constantCase(): Schema&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;h2&gt;Schema basics&lt;/h2&gt; &#xA;&lt;p&gt;Schema definitions, are comprised of parsing &#34;transforms&#34; which manipulate inputs into the desired shape and type, &#34;tests&#34;, which make assertions over parsed data. Schema also store a bunch of &#34;metadata&#34;, details about the schema itself, which can be used to improve error messages, build tools that dynamically consume schema, or serialize schema into another format.&lt;/p&gt; &#xA;&lt;p&gt;In order to be maximally flexible yup allows running both parsing and assertions separately to match specific needs&lt;/p&gt; &#xA;&lt;h3&gt;Parsing: Transforms&lt;/h3&gt; &#xA;&lt;p&gt;Each built-in type implements basic type parsing, which comes in handy when parsing serialized data, such as JSON. Additionally types implement type specific transforms that can be enabled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const num = number().cast(&#39;1&#39;); // 1&#xA;&#xA;const obj = object({&#xA;  firstName: string().lowercase().trim(),&#xA;})&#xA;  .camelCase()&#xA;  .cast(&#39;{&#34;first_name&#34;: &#34;jAnE &#34;}&#39;); // { firstName: &#39;jane&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Custom transforms can be added&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const reversedString = string()&#xA;  .transform((currentValue) =&amp;gt; currentValue.split(&#39;&#39;).reverse().join(&#39;&#39;))&#xA;  .cast(&#39;dlrow olleh&#39;); // &#34;hello world&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Transforms form a &#34;pipeline&#34;, where the value of a previous transform is piped into the next one. If the end value is &lt;code&gt;undefined&lt;/code&gt; yup will apply the schema default if it&#39;s configured.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Watch out! values are not guaranteed to be valid types in transform functions. Previous transforms may have failed. For example a number transform may be receive the input value, &lt;code&gt;NaN&lt;/code&gt;, or a number.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Validation: Tests&lt;/h3&gt; &#xA;&lt;p&gt;Yup has robust support for assertions, or &#34;tests&#34;, over input values. Tests assert that inputs conform to some criteria. Tests are distinct from transforms, in that they do not change or alter the input (or its type) and are usually reserved for checks that are hard, if not impossible, to represent in static types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;string()&#xA;  .min(3, &#39;must be at least 3 characters long&#39;)&#xA;  .email(&#39;must be a valid email&#39;)&#xA;  .validate(&#39;no&#39;); // ValidationError&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with transforms, tests can be customized on the fly&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const jamesSchema = string().test(&#xA;  &#39;is-james&#39;,&#xA;  (d) =&amp;gt; `${d.path} is not James`,&#xA;  (value) =&amp;gt; value == null || value === &#39;James&#39;,&#xA;);&#xA;&#xA;jamesSchema.validateSync(&#39;James&#39;); // &#34;James&#34;&#xA;&#xA;jamesSchema.validateSync(&#39;Jane&#39;); // ValidationError &#34;this is not James&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Heads up: unlike transforms, &lt;code&gt;value&lt;/code&gt; in a custom test is guaranteed to be the correct type (in this case an optional string). It still may be &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; depending on your schema in those cases, you may want to return &lt;code&gt;true&lt;/code&gt; for absent values unless your transform makes presence related assertions&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Customizing errors&lt;/h4&gt; &#xA;&lt;p&gt;In the simplest case a test function returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on the whether the check passed. In the case of a failing test, yup will throw a &lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#validationerrorerrors-string--arraystring-value-any-path-string&#34;&gt;&lt;code&gt;ValidationError&lt;/code&gt;&lt;/a&gt; with your (or the default) message for that test. ValidationErrors also contain a bunch of other metadata about the test, including it&#39;s name, what arguments (if any) it was called with, and the path to the failing field in the case of a nested validation.&lt;/p&gt; &#xA;&lt;p&gt;Error messages can also be constructed on the fly to customize how the schema fails.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const order = object({&#xA;  no: number().required().&#xA;  sku: string().test({&#xA;    name: &#39;is-sku&#39;,&#xA;    skipAbsent: true,&#xA;    test(value, ctx) {&#xA;      if (!value.startsWith(&#39;s-&#39;)) {&#xA;        return ctx.createError({ message: &#39;SKU missing correct prefix&#39; })&#xA;      }&#xA;      if (!value.endsWith(&#39;-42a&#39;)) {&#xA;        return ctx.createError({ message: &#39;SKU missing correct suffix&#39; })&#xA;      }&#xA;      if (value.length &amp;lt; 10) {&#xA;        return ctx.createError({ message: &#39;SKU is not the right length&#39; })&#xA;      }&#xA;      return true&#xA;    }&#xA;  })&#xA;})&#xA;&#xA;order.validate({ no: 1234, sku: &#39;s-1a45-14a&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Composition and Reuse&lt;/h3&gt; &#xA;&lt;p&gt;Schema are immutable, each method call returns a new schema object. Reuse and pass them around without fear of mutating another instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const optionalString = string().optional();&#xA;&#xA;const definedString = optionalString.defined();&#xA;&#xA;const value = undefined;&#xA;optionalString.isValid(value); // true&#xA;definedString.isValid(value); // false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;TypeScript integration&lt;/h2&gt; &#xA;&lt;p&gt;Yup schema produce static TypeScript interfaces. Use &lt;code&gt;InferType&lt;/code&gt; to extract that interface:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import * as yup from &#39;yup&#39;;&#xA;&#xA;const personSchema = yup.object({&#xA;  firstName: yup.string().defined(),&#xA;  nickName: yup.string().default(&#39;&#39;).nullable(),&#xA;  sex: yup&#xA;    .mixed()&#xA;    .oneOf([&#39;male&#39;, &#39;female&#39;, &#39;other&#39;] as const)&#xA;    .defined(),&#xA;  email: yup.string().nullable().email(),&#xA;  birthDate: yup.date().nullable().min(new Date(1900, 0, 1)),&#xA;});&#xA;&#xA;interface Person extends yup.InferType&amp;lt;typeof personSchema&amp;gt; {&#xA;  // using interface instead of type generally gives nicer editor feedback&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Schema defaults&lt;/h3&gt; &#xA;&lt;p&gt;A schema&#39;s default is used when casting produces an &lt;code&gt;undefined&lt;/code&gt; output value. Because of this, setting a default affects the output type of the schema, essentially marking it as &#34;defined()&#34;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { string } from &#39;yup&#39;;&#xA;&#xA;const value: string = string().default(&#39;hi&#39;).validate(undefined);&#xA;&#xA;// vs&#xA;&#xA;const value: string | undefined = string().validate(undefined);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Ensuring a schema matches an existing type&lt;/h3&gt; &#xA;&lt;p&gt;In some cases a TypeScript type already exists, and you want to ensure that your schema produces a compatible type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { object, number, string, ObjectSchema } from &#39;yup&#39;;&#xA;&#xA;interface Person {&#xA;  name: string;&#xA;  age?: number;&#xA;  sex: &#39;male&#39; | &#39;female&#39; | &#39;other&#39; | null;&#xA;}&#xA;&#xA;// will raise a compile-time type error if the schema does not produce a valid Person&#xA;const schema: ObjectSchema&amp;lt;Person&amp;gt; = object({&#xA;  name: string().defined(),&#xA;  age: number().optional(),&#xA;  sex: string&amp;lt;&#39;male&#39; | &#39;female&#39; | &#39;other&#39;&amp;gt;().nullable().defined();&#xA;});&#xA;&#xA;// ‚ùå errors:&#xA;// &#34;Type &#39;number | undefined&#39; is not assignable to type &#39;string&#39;.&#34;&#xA;const badSchema: ObjectSchema&amp;lt;Person&amp;gt; = object({&#xA;  name: number(),&#xA;});&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Extending built-in schema with new methods&lt;/h3&gt; &#xA;&lt;p&gt;You can use TypeScript&#39;s interface merging behavior to extend the schema types if needed. Type extensions should go in an &#34;ambient&#34; type definition file such as your &lt;code&gt;globals.d.ts&lt;/code&gt;. Remember to actually extend the yup type in your application code!&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Watch out! merging only works if the type definition is &lt;em&gt;exactly&lt;/em&gt; the same, including generics. Consult the yup source code for each type to ensure you are defining it correctly&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// globals.d.ts&#xA;declare module &#39;yup&#39; {&#xA;  interface StringSchema&amp;lt;TType, TContext, TDefault, TFlags&amp;gt; {&#xA;    append(appendStr: string): this;&#xA;  }&#xA;}&#xA;&#xA;// app.ts&#xA;import { addMethod, string } from &#39;yup&#39;;&#xA;&#xA;addMethod(string, &#39;append&#39;, function append(appendStr: string) {&#xA;  return this.transform((value) =&amp;gt; `${value}${appendStr}`);&#xA;});&#xA;&#xA;string().append(&#39;~~~~&#39;).cast(&#39;hi&#39;); // &#39;hi~~~~&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;TypeScript configuration&lt;/h3&gt; &#xA;&lt;p&gt;You &lt;strong&gt;must&lt;/strong&gt; have the &lt;code&gt;strictNullChecks&lt;/code&gt; compiler option enabled for type inference to work.&lt;/p&gt; &#xA;&lt;p&gt;We also recommend settings &lt;code&gt;strictFunctionTypes&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, for functionally better types. Yes this reduces overall soundness, however TypeScript already disables this check for methods and constructors (note from TS docs):&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;During development of this feature, we discovered a large number of inherently unsafe class hierarchies, including some in the DOM. Because of this, the setting only applies to functions written in function syntax, not to those in method syntax:&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Your mileage will vary, but we&#39;ve found that this check doesn&#39;t prevent many of real bugs, while increasing the amount of onerous explicit type casting in apps.&lt;/p&gt; &#xA;&lt;h2&gt;Error message customization&lt;/h2&gt; &#xA;&lt;p&gt;Default error messages can be customized for when no message is provided with a validation test. If any message is missing in the custom dictionary the error message will default to Yup&#39;s one.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { setLocale } from &#39;yup&#39;;&#xA;&#xA;setLocale({&#xA;  mixed: {&#xA;    default: &#39;N√£o √© v√°lido&#39;,&#xA;  },&#xA;  number: {&#xA;    min: &#39;Deve ser maior que ${min}&#39;,&#xA;  },&#xA;});&#xA;&#xA;// now use Yup schemas AFTER you defined your custom dictionary&#xA;let schema = yup.object().shape({&#xA;  name: yup.string(),&#xA;  age: yup.number().min(18),&#xA;});&#xA;&#xA;try {&#xA;  await schema.validate({ name: &#39;jimmy&#39;, age: 11 });&#xA;} catch (err) {&#xA;  err.name; // =&amp;gt; &#39;ValidationError&#39;&#xA;  err.errors; // =&amp;gt; [&#39;Deve ser maior que 18&#39;]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;localization and i18n&lt;/h3&gt; &#xA;&lt;p&gt;If you need multi-language support, yup has got you covered. The function &lt;code&gt;setLocale&lt;/code&gt; accepts functions that can be used to generate error objects with translation keys and values. These can be fed it into your favorite i18n library.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { setLocale } from &#39;yup&#39;;&#xA;&#xA;setLocale({&#xA;  // use constant translation keys for messages without values&#xA;  mixed: {&#xA;    default: &#39;field_invalid&#39;,&#xA;  },&#xA;  // use functions to generate an error object that includes the value from the schema&#xA;  number: {&#xA;    min: ({ min }) =&amp;gt; ({ key: &#39;field_too_short&#39;, values: { min } }),&#xA;    max: ({ max }) =&amp;gt; ({ key: &#39;field_too_big&#39;, values: { max } }),&#xA;  },&#xA;});&#xA;&#xA;// ...&#xA;&#xA;let schema = yup.object().shape({&#xA;  name: yup.string(),&#xA;  age: yup.number().min(18),&#xA;});&#xA;&#xA;try {&#xA;  await schema.validate({ name: &#39;jimmy&#39;, age: 11 });&#xA;} catch (err) {&#xA;  messages = err.errors.map((err) =&amp;gt; i18next.t(err.key));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;yup&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The module export.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// core schema&#xA;import {&#xA;  mixed,&#xA;  string,&#xA;  number,&#xA;  boolean,&#xA;  bool,&#xA;  date,&#xA;  object,&#xA;  array,&#xA;  ref,&#xA;  lazy,&#xA;} from &#39;yup&#39;;&#xA;&#xA;// Classes&#xA;import {&#xA;  Schema,&#xA;  MixedSchema,&#xA;  StringSchema,&#xA;  NumberSchema,&#xA;  BooleanSchema,&#xA;  DateSchema,&#xA;  ArraySchema,&#xA;  ObjectSchema,&#xA;} from &#39;yup&#39;;&#xA;&#xA;// Types&#xA;import type { InferType, ISchema, AnySchema, AnyObjectSchema } from &#39;yup&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;reach(schema: Schema, path: string, value?: object, context?: object): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;For nested schemas, &lt;code&gt;reach&lt;/code&gt; will retrieve an inner schema based on the provided path.&lt;/p&gt; &#xA;&lt;p&gt;For nested schemas that need to resolve dynamically, you can provide a &lt;code&gt;value&lt;/code&gt; and optionally a &lt;code&gt;context&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { reach } from &#39;yup&#39;;&#xA;&#xA;let schema = object({&#xA;  nested: object({&#xA;    arr: array(object({ num: number().max(4) })),&#xA;  }),&#xA;});&#xA;&#xA;reach(schema, &#39;nested.arr.num&#39;);&#xA;reach(schema, &#39;nested.arr[].num&#39;);&#xA;reach(schema, &#39;nested.arr[1].num&#39;);&#xA;reach(schema, &#39;nested[&#34;arr&#34;][1].num&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;addMethod(schemaType: Schema, name: string, method: ()=&amp;gt; Schema): void&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Adds a new method to the core schema types. A friendlier convenience method for &lt;code&gt;schemaType.prototype[name] = method&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { addMethod, date } from &#39;yup&#39;;&#xA;&#xA;addMethod(date, &#39;format&#39;, function format(formats, parseStrict) {&#xA;  return this.transform((value, originalValue, ctx) =&amp;gt; {&#xA;    if (ctx.isType(value)) return value;&#xA;&#xA;    value = Moment(originalValue, formats, parseStrict);&#xA;&#xA;    return value.isValid() ? value.toDate() : new Date(&#39;&#39;);&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to add a method to ALL schema types, extend the abstract base class: &lt;code&gt;Schema&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { addMethod, Schema } from &#39;yup&#39;;&#xA;&#xA;addMethod(Schema, &#39;myMethod&#39;, ...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;ref(path: string, options: { contextPrefix: string }): Ref&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Creates a reference to another sibling or sibling descendant field. Refs are resolved at &lt;em&gt;validation/cast time&lt;/em&gt; and supported where specified. Refs are evaluated in the proper order so that the ref value is resolved before the field using the ref (be careful of circular dependencies!).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { ref, object, string } from &#39;yup&#39;;&#xA;&#xA;let schema = object({&#xA;  baz: ref(&#39;foo.bar&#39;),&#xA;  foo: object({&#xA;    bar: string(),&#xA;  }),&#xA;  x: ref(&#39;$x&#39;),&#xA;});&#xA;&#xA;schema.cast({ foo: { bar: &#39;boom&#39; } }, { context: { x: 5 } });&#xA;// =&amp;gt; { baz: &#39;boom&#39;,  x: 5, foo: { bar: &#39;boom&#39; } }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;lazy((value: any) =&amp;gt; Schema): Lazy&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Creates a schema that is evaluated at validation/cast time. Useful for creating recursive schema like Trees, for polymorphic fields and arrays.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;CAUTION!&lt;/strong&gt; When defining parent-child recursive object schema, you want to reset the &lt;code&gt;default()&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt; on the child‚Äîotherwise the object will infinitely nest itself when you cast it!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let node = object({&#xA;  id: number(),&#xA;  child: yup.lazy(() =&amp;gt; node.default(undefined)),&#xA;});&#xA;&#xA;let renderable = yup.lazy((value) =&amp;gt; {&#xA;  switch (typeof value) {&#xA;    case &#39;number&#39;:&#xA;      return number();&#xA;    case &#39;string&#39;:&#xA;      return string();&#xA;    default:&#xA;      return mixed();&#xA;  }&#xA;});&#xA;&#xA;let renderables = array().of(renderable);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;ValidationError(errors: string | Array&amp;lt;string&amp;gt;, value: any, path: string)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Thrown on failed validations, with the following properties&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;name&lt;/code&gt;: &#34;ValidationError&#34;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;type&lt;/code&gt;: the specific test type or test &#34;name&#34;, that failed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value&lt;/code&gt;: The field value that was tested;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;params&lt;/code&gt;?: The test inputs, such as max value, regex, etc;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;path&lt;/code&gt;: a string, indicating where there error was thrown. &lt;code&gt;path&lt;/code&gt; is empty at the root level.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;errors&lt;/code&gt;: array of error messages&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;inner&lt;/code&gt;: in the case of aggregate errors, inner is an array of &lt;code&gt;ValidationErrors&lt;/code&gt; throw earlier in the validation chain. When the &lt;code&gt;abortEarly&lt;/code&gt; option is &lt;code&gt;false&lt;/code&gt; this is where you can inspect each error thrown, alternatively, &lt;code&gt;errors&lt;/code&gt; will have all of the messages from each inner error.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Schema&lt;/code&gt; is the abstract base class that all schema type inherit from. It provides a number of base methods and properties to all other schema types.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: unless you are creating a custom schema type, Schema should never be used directly. For unknown/any types use &lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#mixed&#34;&gt;&lt;code&gt;mixed()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.clone(): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Creates a deep copy of the schema. Clone is used internally to return a new schema with every schema state change.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.label(label: string): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Overrides the key name which is used in error messages.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.meta(metadata: object): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Adds to a metadata object, useful for storing data with a schema, that doesn&#39;t belong the cast object itself.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.describe(options?: ResolveOptions): SchemaDescription&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Collects schema details (like meta, labels, and active tests) into a serializable description object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const schema = object({&#xA;  name: string().required(),&#xA;});&#xA;&#xA;const description = schema.describe();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For schema with dynamic components (references, lazy, or conditions), describe requires more context to accurately return the schema description. In these cases provide &lt;code&gt;options&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { ref, object, string, boolean } from &#39;yup&#39;;&#xA;&#xA;let schema = object({&#xA;  isBig: boolean(),&#xA;  count: number().when(&#39;isBig&#39;, {&#xA;    is: true,&#xA;    then: (schema) =&amp;gt; schema.min(5),&#xA;    otherwise: (schema) =&amp;gt; schema.min(0),&#xA;  }),&#xA;});&#xA;&#xA;schema.describe({ value: { isBig: true } });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And below is are the description types, which differ a bit depending on the schema type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;interface SchemaDescription {&#xA;  type: string;&#xA;  label?: string;&#xA;  meta: object | undefined;&#xA;  oneOf: unknown[];&#xA;  notOneOf: unknown[];&#xA;  nullable: boolean;&#xA;  optional: boolean;&#xA;  tests: Array&amp;lt;{ name?: string; params: ExtraParams | undefined }&amp;gt;;&#xA;&#xA;  // Present on object schema descriptions&#xA;  fields: Record&amp;lt;string, SchemaFieldDescription&amp;gt;;&#xA;&#xA;  // Present on array schema descriptions&#xA;  innerType?: SchemaFieldDescription;&#xA;}&#xA;&#xA;type SchemaFieldDescription =&#xA;  | SchemaDescription&#xA;  | SchemaRefDescription&#xA;  | SchemaLazyDescription;&#xA;&#xA;interface SchemaRefDescription {&#xA;  type: &#39;ref&#39;;&#xA;  key: string;&#xA;}&#xA;&#xA;interface SchemaLazyDescription {&#xA;  type: string;&#xA;  label?: string;&#xA;  meta: object | undefined;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.concat(schema: Schema): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Creates a new instance of the schema by combining two schemas. Only schemas of the same type can be concatenated. &lt;code&gt;concat&lt;/code&gt; is not a &#34;merge&#34; function in the sense that all settings from the provided schema, override ones in the base, including type, presence and nullability.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;mixed&amp;lt;string&amp;gt;().defined().concat(mixed&amp;lt;number&amp;gt;().nullable());&#xA;&#xA;// produces the equivalent to:&#xA;&#xA;mixed&amp;lt;number&amp;gt;().defined().nullable();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.validate(value: any, options?: object): Promise&amp;lt;InferType&amp;lt;Schema&amp;gt;, ValidationError&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns the parses and validates an input value, returning the parsed value or throwing an error. This method is &lt;strong&gt;asynchronous&lt;/strong&gt; and returns a Promise object, that is fulfilled with the value, or rejected with a &lt;code&gt;ValidationError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;value = await schema.validate({ name: &#39;jimmy&#39;, age: 24 });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Provide &lt;code&gt;options&lt;/code&gt; to more specifically control the behavior of &lt;code&gt;validate&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;interface Options {&#xA;  // when true, parsing is skipped an the input is validated &#34;as-is&#34;&#xA;  strict: boolean = false;&#xA;  // Throw on the first error or collect and return all&#xA;  abortEarly: boolean = true;&#xA;  // Remove unspecified keys from objects&#xA;  stripUnknown: boolean = false;&#xA;  // when `false` validations will be performed shallowly&#xA;  recursive: boolean = true;&#xA;  // External values that can be provided to validations and conditionals&#xA;  context?: object;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.validateSync(value: any, options?: object): InferType&amp;lt;Schema&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Runs validatations synchronously &lt;em&gt;if possible&lt;/em&gt; and returns the resulting value, or throws a ValidationError. Accepts all the same options as &lt;code&gt;validate&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Synchronous validation only works if there are no configured async tests, e.g tests that return a Promise. For instance this will work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = number().test(&#xA;  &#39;is-42&#39;,&#xA;  &#34;this isn&#39;t the number i want&#34;,&#xA;  (value) =&amp;gt; value != 42,&#xA;);&#xA;&#xA;schema.validateSync(23); // throws ValidationError&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;however this will not:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = number().test(&#39;is-42&#39;, &#34;this isn&#39;t the number i want&#34;, (value) =&amp;gt;&#xA;  Promise.resolve(value != 42),&#xA;);&#xA;&#xA;schema.validateSync(42); // throws Error&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.validateAt(path: string, value: any, options?: object): Promise&amp;lt;InferType&amp;lt;Schema&amp;gt;, ValidationError&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Validate a deeply nested path within the schema. Similar to how &lt;code&gt;reach&lt;/code&gt; works, but uses the resulting schema as the subject for validation.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note! The &lt;code&gt;value&lt;/code&gt; here is the &lt;em&gt;root&lt;/em&gt; value relative to the starting schema, not the value at the nested path.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = object({&#xA;  foo: array().of(&#xA;    object({&#xA;      loose: boolean(),&#xA;      bar: string().when(&#39;loose&#39;, {&#xA;        is: true,&#xA;        otherwise: (schema) =&amp;gt; schema.strict(),&#xA;      }),&#xA;    }),&#xA;  ),&#xA;});&#xA;&#xA;let rootValue = {&#xA;  foo: [{ bar: 1 }, { bar: 1, loose: true }],&#xA;};&#xA;&#xA;await schema.validateAt(&#39;foo[0].bar&#39;, rootValue); // =&amp;gt; ValidationError: must be a string&#xA;&#xA;await schema.validateAt(&#39;foo[1].bar&#39;, rootValue); // =&amp;gt; &#39;1&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.validateSyncAt(path: string, value: any, options?: object): InferType&amp;lt;Schema&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Same as &lt;code&gt;validateAt&lt;/code&gt; but synchronous.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.isValid(value: any, options?: object): Promise&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns &lt;code&gt;true&lt;/code&gt; when the passed in value matches the schema. &lt;code&gt;isValid&lt;/code&gt; is &lt;strong&gt;asynchronous&lt;/strong&gt; and returns a Promise object.&lt;/p&gt; &#xA;&lt;p&gt;Takes the same options as &lt;code&gt;validate()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.isValidSync(value: any, options?: object): boolean&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Synchronously returns &lt;code&gt;true&lt;/code&gt; when the passed in value matches the schema.&lt;/p&gt; &#xA;&lt;p&gt;Takes the same options as &lt;code&gt;validateSync()&lt;/code&gt; and has the same caveats around async tests.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.cast(value: any, options = {}): InferType&amp;lt;Schema&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Attempts to coerce the passed in value to a value that matches the schema. For example: &lt;code&gt;&#39;5&#39;&lt;/code&gt; will cast to &lt;code&gt;5&lt;/code&gt; when using the &lt;code&gt;number()&lt;/code&gt; type. Failed casts generally return &lt;code&gt;null&lt;/code&gt;, but may also return results like &lt;code&gt;NaN&lt;/code&gt; and unexpected strings.&lt;/p&gt; &#xA;&lt;p&gt;Provide &lt;code&gt;options&lt;/code&gt; to more specifically control the behavior of &lt;code&gt;validate&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;interface CastOptions&amp;lt;TContext extends {}&amp;gt; {&#xA;  // Remove undefined properties from objects&#xA;  stripUnknown: boolean = false;&#xA;&#xA;  // Throws a TypeError if casting doesn&#39;t produce a valid type&#xA;  // note that the TS return type is inaccurate when this is `false`, use with caution&#xA;  assert?: boolean = true;&#xA;&#xA;  // External values that used to resolve conditions and references&#xA;  context?: TContext;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.isType(value: any): value is InferType&amp;lt;Schema&amp;gt;&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Runs a type check against the passed in &lt;code&gt;value&lt;/code&gt;. It returns true if it matches, it does not cast the value. When &lt;code&gt;nullable()&lt;/code&gt; is set &lt;code&gt;null&lt;/code&gt; is considered a valid value of the type. You should use &lt;code&gt;isType&lt;/code&gt; for all Schema type checks.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.strict(enabled: boolean = false): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sets the &lt;code&gt;strict&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;. Strict schemas skip coercion and transformation attempts, validating the value &#34;as is&#34;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.strip(enabled: boolean = true): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Marks a schema to be removed from an output object. Only works as a nested schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = object({&#xA;  useThis: number(),&#xA;  notThis: string().strip(),&#xA;});&#xA;&#xA;schema.cast({ notThis: &#39;foo&#39;, useThis: 4 }); // =&amp;gt; { useThis: 4 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Schema with &lt;code&gt;strip&lt;/code&gt; enabled have an inferred type of &lt;code&gt;never&lt;/code&gt;, allowing them to be removed from the overall type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;let schema = object({&#xA;  useThis: number(),&#xA;  notThis: string().strip(),&#xA;});&#xA;&#xA;InferType&amp;lt;typeof schema&amp;gt;; /*&#xA;{&#xA;   useThis?: number | undefined&#xA;}&#xA;*/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.withMutation(builder: (current: Schema) =&amp;gt; void): void&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;First the legally required Rich Hickey quote:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If a tree falls in the woods, does it make a sound?&lt;/p&gt; &#xA; &lt;p&gt;If a pure function mutates some local data in order to produce an immutable return value, is that ok?&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;code&gt;withMutation&lt;/code&gt; allows you to mutate the schema in place, instead of the default behavior which clones before each change. Generally this isn&#39;t necessary since the vast majority of schema changes happen during the initial declaration, and only happen once over the lifetime of the schema, so performance isn&#39;t an issue. However certain mutations &lt;em&gt;do&lt;/em&gt; occur at cast/validation time, (such as conditional schema using &lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#Schemawhenkeys-string--arraystring-builder-object--value-schema-schema-schema&#34;&gt;&lt;code&gt;when()&lt;/code&gt;&lt;/a&gt;), or when instantiating a schema object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;object()&#xA;  .shape({ key: string() })&#xA;  .withMutation((schema) =&amp;gt; {&#xA;    return arrayOfObjectTests.forEach((test) =&amp;gt; {&#xA;      schema.test(test);&#xA;    });&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.default(value: any): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sets a default value to use when the value is &lt;code&gt;undefined&lt;/code&gt;. Defaults are created after transformations are executed, but before validations, to help ensure that safe defaults are specified. The default value will be cloned on each use, which can incur performance penalty for objects and arrays. To avoid this overhead you can also pass a function that returns a new default. Note that &lt;code&gt;null&lt;/code&gt; is considered a separate non-empty value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;yup.string.default(&#39;nothing&#39;);&#xA;&#xA;yup.object.default({ number: 5 }); // object will be cloned every time a default is needed&#xA;&#xA;yup.object.default(() =&amp;gt; ({ number: 5 })); // this is cheaper&#xA;&#xA;yup.date.default(() =&amp;gt; new Date()); // also helpful for defaults that change over time&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.getDefault(options?: object): Any&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Retrieve a previously set default value. &lt;code&gt;getDefault&lt;/code&gt; will resolve any conditions that may alter the default. Optionally pass &lt;code&gt;options&lt;/code&gt; with &lt;code&gt;context&lt;/code&gt; (for more info on &lt;code&gt;context&lt;/code&gt; see &lt;code&gt;Schema.validate&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.nullable(): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Indicates that &lt;code&gt;null&lt;/code&gt; is a valid value for the schema. Without &lt;code&gt;nullable()&lt;/code&gt; &lt;code&gt;null&lt;/code&gt; is treated as a different type and will fail &lt;code&gt;Schema.isType()&lt;/code&gt; checks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const schema = number().nullable();&#xA;&#xA;schema.cast(null); // null&#xA;&#xA;InferType&amp;lt;typeof schema&amp;gt;; // number | null&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.nonNullable(): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The opposite of &lt;code&gt;nullable&lt;/code&gt;, removes &lt;code&gt;null&lt;/code&gt; from valid type values for the schema. &lt;strong&gt;Schema are non nullable by default&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const schema = number().nonNullable();&#xA;&#xA;schema.cast(null); // TypeError&#xA;&#xA;InferType&amp;lt;typeof schema&amp;gt;; // number&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.defined(): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Require a value for the schema. All field values apart from &lt;code&gt;undefined&lt;/code&gt; meet this requirement.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const schema = string().defined();&#xA;&#xA;schema.cast(undefined); // TypeError&#xA;&#xA;InferType&amp;lt;typeof schema&amp;gt;; // string&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.optional(): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The opposite of &lt;code&gt;defined()&lt;/code&gt; allows &lt;code&gt;undefined&lt;/code&gt; values for the given type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const schema = string().optional();&#xA;&#xA;schema.cast(undefined); // undefined&#xA;&#xA;InferType&amp;lt;typeof schema&amp;gt;; // string | undefined&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.required(message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Mark the schema as required, which will not allow &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; as a value. &lt;code&gt;required&lt;/code&gt; negates the effects of calling &lt;code&gt;optional()&lt;/code&gt; and &lt;code&gt;nullable()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Watch out! &lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#stringrequiredmessage-string--function-schema&#34;&gt;&lt;code&gt;string().required&lt;/code&gt;&lt;/a&gt;) works a little different and additionally prevents empty string values (&lt;code&gt;&#39;&#39;&lt;/code&gt;) when required.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.notRequired(): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Mark the schema as not required. This is a shortcut for &lt;code&gt;schema.nullable().optional()&lt;/code&gt;;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.typeError(message: string): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Define an error message for failed type checks. The &lt;code&gt;${value}&lt;/code&gt; and &lt;code&gt;${type}&lt;/code&gt; interpolation can be used in the &lt;code&gt;message&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.oneOf(arrayOfValues: Array&amp;lt;any&amp;gt;, message?: string | function): Schema&lt;/code&gt; Alias: &lt;code&gt;equals&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Only allow values from set of values. Values added are removed from any &lt;code&gt;notOneOf&lt;/code&gt; values if present. The &lt;code&gt;${values}&lt;/code&gt; interpolation can be used in the &lt;code&gt;message&lt;/code&gt; argument. If a ref or refs are provided, the &lt;code&gt;${resolved}&lt;/code&gt; interpolation can be used in the message argument to get the resolved values that were checked at validation time.&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;undefined&lt;/code&gt; does not fail this validator, even when &lt;code&gt;undefined&lt;/code&gt; is not included in &lt;code&gt;arrayOfValues&lt;/code&gt;. If you don&#39;t want &lt;code&gt;undefined&lt;/code&gt; to be a valid value, you can use &lt;code&gt;Schema.required&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = yup.mixed().oneOf([&#39;jimmy&#39;, 42]);&#xA;&#xA;await schema.isValid(42); // =&amp;gt; true&#xA;await schema.isValid(&#39;jimmy&#39;); // =&amp;gt; true&#xA;await schema.isValid(new Date()); // =&amp;gt; false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.notOneOf(arrayOfValues: Array&amp;lt;any&amp;gt;, message?: string | function)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Disallow values from a set of values. Values added are removed from &lt;code&gt;oneOf&lt;/code&gt; values if present. The &lt;code&gt;${values}&lt;/code&gt; interpolation can be used in the &lt;code&gt;message&lt;/code&gt; argument. If a ref or refs are provided, the &lt;code&gt;${resolved}&lt;/code&gt; interpolation can be used in the message argument to get the resolved values that were checked at validation time.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = yup.mixed().notOneOf([&#39;jimmy&#39;, 42]);&#xA;&#xA;await schema.isValid(42); // =&amp;gt; false&#xA;await schema.isValid(new Date()); // =&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.when(keys: string | string[], builder: object | (values: any[], schema) =&amp;gt; Schema): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Adjust the schema based on a sibling or sibling children fields. You can provide an object literal where the key &lt;code&gt;is&lt;/code&gt; is value or a matcher function, &lt;code&gt;then&lt;/code&gt; provides the true schema and/or &lt;code&gt;otherwise&lt;/code&gt; for the failure condition.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;is&lt;/code&gt; conditions are strictly compared (&lt;code&gt;===&lt;/code&gt;) if you want to use a different form of equality you can provide a function like: &lt;code&gt;is: (value) =&amp;gt; value == true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also prefix properties with &lt;code&gt;$&lt;/code&gt; to specify a property that is dependent on &lt;code&gt;context&lt;/code&gt; passed in by &lt;code&gt;validate()&lt;/code&gt; or &lt;code&gt;cast&lt;/code&gt; instead of the input value.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;when&lt;/code&gt; conditions are additive.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = object({&#xA;  isBig: boolean(),&#xA;  count: number()&#xA;    .when(&#39;isBig&#39;, {&#xA;      is: true, // alternatively: (val) =&amp;gt; val == true&#xA;      then: (schema) =&amp;gt; schema.min(5),&#xA;      otherwise: (schema) =&amp;gt; schema.min(0),&#xA;    })&#xA;    .when(&#39;$other&#39;, ([other], schema) =&amp;gt;&#xA;      other === 4 ? schema.max(6) : schema,&#xA;    ),&#xA;});&#xA;&#xA;await schema.validate(value, { context: { other: 4 } });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also specify more than one dependent key, in which case each value will be spread as an argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = object({&#xA;  isSpecial: boolean(),&#xA;  isBig: boolean(),&#xA;  count: number().when([&#39;isBig&#39;, &#39;isSpecial&#39;], {&#xA;    is: true, // alternatively: (isBig, isSpecial) =&amp;gt; isBig &amp;amp;&amp;amp; isSpecial&#xA;    then: (schema) =&amp;gt; schema.min(5),&#xA;    otherwise: (schema) =&amp;gt; schema.min(0),&#xA;  }),&#xA;});&#xA;&#xA;await schema.validate({&#xA;  isBig: true,&#xA;  isSpecial: true,&#xA;  count: 10,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively you can provide a function that returns a schema, called with an array of values for each provided key the current schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = yup.object({&#xA;  isBig: yup.boolean(),&#xA;  count: yup.number().when(&#39;isBig&#39;, ([isBig], schema) =&amp;gt; {&#xA;    return isBig ? schema.min(5) : schema.min(0);&#xA;  }),&#xA;});&#xA;&#xA;await schema.validate({ isBig: false, count: 4 });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.test(name: string, message: string | function | any, test: function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Adds a test function to the validation chain. Tests are run after any object is cast. Many types have some tests built in, but you can create custom ones easily. In order to allow asynchronous custom validations &lt;em&gt;all&lt;/em&gt; (or no) tests are run asynchronously. A consequence of this is that test execution order cannot be guaranteed.&lt;/p&gt; &#xA;&lt;p&gt;All tests must provide a &lt;code&gt;name&lt;/code&gt;, an error &lt;code&gt;message&lt;/code&gt; and a validation function that must return &lt;code&gt;true&lt;/code&gt; when the current &lt;code&gt;value&lt;/code&gt; is valid and &lt;code&gt;false&lt;/code&gt; or a &lt;code&gt;ValidationError&lt;/code&gt; otherwise. To make a test async return a promise that resolves &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; or a &lt;code&gt;ValidationError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For the &lt;code&gt;message&lt;/code&gt; argument you can provide a string which will interpolate certain values if specified using the &lt;code&gt;${param}&lt;/code&gt; syntax. By default all test messages are passed a &lt;code&gt;path&lt;/code&gt; value which is valuable in nested schemas.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;test&lt;/code&gt; function is called with the current &lt;code&gt;value&lt;/code&gt;. For more advanced validations you can use the alternate signature to provide more options (see below):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let jimmySchema = string().test(&#xA;  &#39;is-jimmy&#39;,&#xA;  &#39;${path} is not Jimmy&#39;,&#xA;  (value, context) =&amp;gt; value === &#39;jimmy&#39;,&#xA;);&#xA;&#xA;// or make it async by returning a promise&#xA;let asyncJimmySchema = string()&#xA;  .label(&#39;First name&#39;)&#xA;  .test(&#xA;    &#39;is-jimmy&#39;,&#xA;    ({ label }) =&amp;gt; `${label} is not Jimmy`, // a message can also be a function&#xA;    async (value, testContext) =&amp;gt;&#xA;      (await fetch(&#39;/is-jimmy/&#39; + value)).responseText === &#39;true&#39;,&#xA;  );&#xA;&#xA;await schema.isValid(&#39;jimmy&#39;); // =&amp;gt; true&#xA;await schema.isValid(&#39;john&#39;); // =&amp;gt; false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Test functions are called with a special context value, as the second argument, that exposes some useful metadata and functions. For non arrow functions, the test context is also set as the function &lt;code&gt;this&lt;/code&gt;. Watch out, if you access it via &lt;code&gt;this&lt;/code&gt; it won&#39;t work in an arrow function.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;testContext.path&lt;/code&gt;: the string path of the current validation&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;testContext.schema&lt;/code&gt;: the resolved schema object that the test is running against.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;testContext.options&lt;/code&gt;: the &lt;code&gt;options&lt;/code&gt; object that validate() or isValid() was called with&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;testContext.parent&lt;/code&gt;: in the case of nested schema, this is the value of the parent object&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;testContext.originalValue&lt;/code&gt;: the original value that is being tested&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;testContext.createError(Object: { path: String, message: String, params: Object })&lt;/code&gt;: create and return a validation error. Useful for dynamically setting the &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt;, or more likely, the error &lt;code&gt;message&lt;/code&gt;. If either option is omitted it will use the current path, or default message.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.test(options: object): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Alternative &lt;code&gt;test(..)&lt;/code&gt; signature. &lt;code&gt;options&lt;/code&gt; is an object containing some of the following options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Options = {&#xA;  // unique name identifying the test&#xA;  name: string;&#xA;  // test function, determines schema validity&#xA;  test: (value: any) =&amp;gt; boolean;&#xA;  // the validation error message&#xA;  message: string;&#xA;  // values passed to message for interpolation&#xA;  params: ?object;&#xA;  // mark the test as exclusive, meaning only one test of the same name can be active at once&#xA;  exclusive: boolean = false;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the case of mixing exclusive and non-exclusive tests the following logic is used. If a non-exclusive test is added to a schema with an exclusive test of the same name the exclusive test is removed and further tests of the same name will be stacked.&lt;/p&gt; &#xA;&lt;p&gt;If an exclusive test is added to a schema with non-exclusive tests of the same name the previous tests are removed and further tests of the same name will replace each other.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let max = 64;&#xA;let schema = yup.string().test({&#xA;  name: &#39;max&#39;,&#xA;  exclusive: true,&#xA;  params: { max },&#xA;  message: &#39;${path} must be less than ${max} characters&#39;,&#xA;  test: (value) =&amp;gt; value == null || value.length &amp;lt;= max,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Schema.transform((currentValue: any, originalValue: any) =&amp;gt; any): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Adds a transformation to the transform chain. Transformations are central to the casting process, default transforms for each type coerce values to the specific type (as verified by &lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#Schemaistypevalue-any-boolean&#34;&gt;&lt;code&gt;isType()&lt;/code&gt;&lt;/a&gt;). transforms are run before validations and only applied when the schema is not marked as &lt;code&gt;strict&lt;/code&gt; (the default). Some types have built in transformations.&lt;/p&gt; &#xA;&lt;p&gt;Transformations are useful for arbitrarily altering how the object is cast, &lt;strong&gt;however, you should take care not to mutate the passed in value.&lt;/strong&gt; Transforms are run sequentially so each &lt;code&gt;value&lt;/code&gt; represents the current state of the cast, you can use the &lt;code&gt;originalValue&lt;/code&gt; param if you need to work on the raw initial value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = string().transform((value, originalvalue) =&amp;gt; {&#xA;  return this.isType(value) &amp;amp;&amp;amp; value !== null ? value.toUpperCase() : value;&#xA;});&#xA;&#xA;schema.cast(&#39;jimmy&#39;); // =&amp;gt; &#39;JIMMY&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each types will handle basic coercion of values to the proper type for you, but occasionally you may want to adjust or refine the default behavior. For example, if you wanted to use a different date parsing strategy than the default one you could do that with a transform.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module.exports = function (formats = &#39;MMM dd, yyyy&#39;) {&#xA;  return date().transform((value, originalValue, context) =&amp;gt; {&#xA;    // check to see if the previous transform already parsed the date&#xA;    if (context.isType(value)) return value;&#xA;&#xA;    // the default coercion failed so let&#39;s try it with Moment.js instead&#xA;    value = Moment(originalValue, formats);&#xA;&#xA;    // if it&#39;s valid return the date object, otherwise return an `InvalidDate`&#xA;    return value.isValid() ? value.toDate() : new Date(&#39;&#39;);&#xA;  });&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;mixed&lt;/h3&gt; &#xA;&lt;p&gt;Creates a schema that matches all types, or just the ones you configure. Inherits from &lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#Schema&#34;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;. Mixed types extends &lt;code&gt;{}&lt;/code&gt; by default instead of &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;unknown&lt;/code&gt;. This is because in TypeScript &lt;code&gt;{}&lt;/code&gt; means anything that isn&#39;t &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; which yup treats distinctly.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { mixed, InferType } from &#39;yup&#39;;&#xA;&#xA;let schema = mixed().nullable();&#xA;&#xA;schema.validateSync(&#39;string&#39;); // &#39;string&#39;;&#xA;&#xA;schema.validateSync(1); // 1;&#xA;&#xA;schema.validateSync(new Date()); // Date;&#xA;&#xA;InferType&amp;lt;typeof schema&amp;gt;; // {} | undefined&#xA;&#xA;InferType&amp;lt;typeof schema.nullable().defined()&amp;gt;; // {} | null&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Custom types can be implemented by passing a type &lt;code&gt;check&lt;/code&gt; function. This will also narrow the TypeScript type for the schema.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { mixed, InferType } from &#39;yup&#39;;&#xA;&#xA;let objectIdSchema = yup&#xA;  .mixed((input): input is ObjectId =&amp;gt; input instanceof ObjectId)&#xA;  .transform((value: any, input, ctx) =&amp;gt; {&#xA;    if (ctx.typeCheck(value)) return value;&#xA;    return new ObjectId(value);&#xA;  });&#xA;&#xA;await objectIdSchema.validate(ObjectId(&#39;507f1f77bcf86cd799439011&#39;)); // ObjectId(&#34;507f1f77bcf86cd799439011&#34;)&#xA;&#xA;await objectIdSchema.validate(&#39;507f1f77bcf86cd799439011&#39;); // ObjectId(&#34;507f1f77bcf86cd799439011&#34;)&#xA;&#xA;InferType&amp;lt;typeof objectIdSchema&amp;gt;; // ObjectId&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;string&lt;/h3&gt; &#xA;&lt;p&gt;Define a string schema. Inherits from &lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#Schema&#34;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = yup.string();&#xA;&#xA;await schema.isValid(&#39;hello&#39;); // =&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the &lt;code&gt;cast&lt;/code&gt; logic of &lt;code&gt;string&lt;/code&gt; is to call &lt;code&gt;toString&lt;/code&gt; on the value if it exists.&lt;/p&gt; &#xA;&lt;p&gt;empty values are not coerced (use &lt;code&gt;ensure()&lt;/code&gt; to coerce empty values to empty strings).&lt;/p&gt; &#xA;&lt;p&gt;Failed casts return the input value.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;string.required(message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The same as the &lt;code&gt;mixed()&lt;/code&gt; schema required, &lt;strong&gt;except&lt;/strong&gt; that empty strings are also considered &#39;missing&#39; values.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;string.length(limit: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Set a required length for the string value. The &lt;code&gt;${length}&lt;/code&gt; interpolation can be used in the &lt;code&gt;message&lt;/code&gt; argument&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;string.min(limit: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Set a minimum length limit for the string value. The &lt;code&gt;${min}&lt;/code&gt; interpolation can be used in the &lt;code&gt;message&lt;/code&gt; argument&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;string.max(limit: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Set a maximum length limit for the string value. The &lt;code&gt;${max}&lt;/code&gt; interpolation can be used in the &lt;code&gt;message&lt;/code&gt; argument&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;string.matches(regex: Regex, message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Provide an arbitrary &lt;code&gt;regex&lt;/code&gt; to match the value against.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = string().matches(/(hi|bye)/);&#xA;&#xA;await schema.isValid(&#39;hi&#39;); // =&amp;gt; true&#xA;await schema.isValid(&#39;nope&#39;); // =&amp;gt; false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;string.matches(regex: Regex, options: { message: string, excludeEmptyString: bool }): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;An alternate signature for &lt;code&gt;string.matches&lt;/code&gt; with an options object. &lt;code&gt;excludeEmptyString&lt;/code&gt;, when true, short circuits the regex test when the value is an empty string, making it a easier to avoid matching nothing without complicating the regex.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = string().matches(/(hi|bye)/, { excludeEmptyString: true });&#xA;&#xA;await schema.isValid(&#39;&#39;); // =&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;string.email(message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Validates the value as an email address using the same regex as defined by the HTML spec.&lt;/p&gt; &#xA;&lt;p&gt;WATCH OUT: Validating email addresses is nearly impossible with just code. Different clients and servers accept different things and many diverge from the various specs defining &#34;valid&#34; emails. The ONLY real way to validate an email address is to send a verification email to it and check that the user got it. With that in mind, yup picks a relatively simple regex that does not cover all cases, but aligns with browser input validation behavior since HTML forms are a common use case for yup.&lt;/p&gt; &#xA;&lt;p&gt;If you have more specific needs please override the email method with your own logic or regex:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;yup.addMethod(yup.string, &#39;email&#39;, function validateEmail(message) {&#xA;  return this.matches(myEmailRegex, {&#xA;    message,&#xA;    name: &#39;email&#39;,&#xA;    excludeEmptyString: true,&#xA;  });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;string.url(message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Validates the value as a valid URL via a regex.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;string.uuid(message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Validates the value as a valid UUID via a regex.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;string.ensure(): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Transforms &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; values to an empty string along with setting the &lt;code&gt;default&lt;/code&gt; to an empty string.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;string.trim(message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Transforms string values by removing leading and trailing whitespace. If &lt;code&gt;strict()&lt;/code&gt; is set it will only validate that the value is trimmed.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;string.lowercase(message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Transforms the string value to lowercase. If &lt;code&gt;strict()&lt;/code&gt; is set it will only validate that the value is lowercase.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;string.uppercase(message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Transforms the string value to uppercase. If &lt;code&gt;strict()&lt;/code&gt; is set it will only validate that the value is uppercase.&lt;/p&gt; &#xA;&lt;h3&gt;number&lt;/h3&gt; &#xA;&lt;p&gt;Define a number schema. Inherits from &lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#Schema&#34;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = yup.number();&#xA;&#xA;await schema.isValid(10); // =&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default &lt;code&gt;cast&lt;/code&gt; logic of &lt;code&gt;number&lt;/code&gt; is: &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat&#34;&gt;&lt;code&gt;parseFloat&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Failed casts return &lt;code&gt;NaN&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;number.min(limit: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Set the minimum value allowed. The &lt;code&gt;${min}&lt;/code&gt; interpolation can be used in the &lt;code&gt;message&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;number.max(limit: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Set the maximum value allowed. The &lt;code&gt;${max}&lt;/code&gt; interpolation can be used in the &lt;code&gt;message&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;number.lessThan(max: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Value must be less than &lt;code&gt;max&lt;/code&gt;. The &lt;code&gt;${less}&lt;/code&gt; interpolation can be used in the &lt;code&gt;message&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;number.moreThan(min: number | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Value must be strictly greater than &lt;code&gt;min&lt;/code&gt;. The &lt;code&gt;${more}&lt;/code&gt; interpolation can be used in the &lt;code&gt;message&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;number.positive(message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Value must be a positive number.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;number.negative(message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Value must be a negative number.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;number.integer(message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Validates that a number is an integer.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;number.truncate(): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Transformation that coerces the value to an integer by stripping off the digits to the right of the decimal point.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;number.round(type: &#39;floor&#39; | &#39;ceil&#39; | &#39;trunc&#39; | &#39;round&#39; = &#39;round&#39;): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Adjusts the value via the specified method of &lt;code&gt;Math&lt;/code&gt; (defaults to &#39;round&#39;).&lt;/p&gt; &#xA;&lt;h3&gt;boolean&lt;/h3&gt; &#xA;&lt;p&gt;Define a boolean schema. Inherits from &lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#Schema&#34;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = yup.boolean();&#xA;&#xA;await schema.isValid(true); // =&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;date&lt;/h3&gt; &#xA;&lt;p&gt;Define a Date schema. By default ISO date strings will parse correctly, for more robust parsing options see the extending schema types at the end of the readme. Inherits from &lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#Schema&#34;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = yup.date();&#xA;&#xA;await schema.isValid(new Date()); // =&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default &lt;code&gt;cast&lt;/code&gt; logic of &lt;code&gt;date&lt;/code&gt; is pass the value to the &lt;code&gt;Date&lt;/code&gt; constructor, failing that, it will attempt to parse the date as an ISO date string.&lt;/p&gt; &#xA;&lt;p&gt;Failed casts return an invalid Date.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;date.min(limit: Date | string | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Set the minimum date allowed. When a string is provided it will attempt to cast to a date first and use the result as the limit.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;date.max(limit: Date | string | Ref, message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Set the maximum date allowed, When a string is provided it will attempt to cast to a date first and use the result as the limit.&lt;/p&gt; &#xA;&lt;h3&gt;array&lt;/h3&gt; &#xA;&lt;p&gt;Define an array schema. Arrays can be typed or not, When specifying the element type, &lt;code&gt;cast&lt;/code&gt; and &lt;code&gt;isValid&lt;/code&gt; will apply to the elements as well. Options passed into &lt;code&gt;isValid&lt;/code&gt; are also passed to child schemas.&lt;/p&gt; &#xA;&lt;p&gt;Inherits from &lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#Schema&#34;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = yup.array().of(yup.number().min(2));&#xA;&#xA;await schema.isValid([2, 3]); // =&amp;gt; true&#xA;await schema.isValid([1, -24]); // =&amp;gt; false&#xA;&#xA;schema.cast([&#39;2&#39;, &#39;3&#39;]); // =&amp;gt; [2, 3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also pass a subtype schema to the array constructor as a convenience.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;array().of(yup.number());&#xA;// or&#xA;array(yup.number());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Arrays have no default casting behavior.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;array.of(type: Schema): this&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Specify the schema of array elements. &lt;code&gt;of()&lt;/code&gt; is optional and when omitted the array schema will not validate its contents.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;array.json(): this&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Attempt to parse input string values as JSON using &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse&#34;&gt;&lt;code&gt;JSON.parse&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;array.length(length: number | Ref, message?: string | function): this&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Set a specific length requirement for the array. The &lt;code&gt;${length}&lt;/code&gt; interpolation can be used in the &lt;code&gt;message&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;array.min(limit: number | Ref, message?: string | function): this&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Set a minimum length limit for the array. The &lt;code&gt;${min}&lt;/code&gt; interpolation can be used in the &lt;code&gt;message&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;array.max(limit: number | Ref, message?: string | function): this&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Set a maximum length limit for the array. The &lt;code&gt;${max}&lt;/code&gt; interpolation can be used in the &lt;code&gt;message&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;array.ensure(): this&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Ensures that the value is an array, by setting the default to &lt;code&gt;[]&lt;/code&gt; and transforming &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values to an empty array as well. Any non-empty, non-array value will be wrapped in an array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;array().ensure().cast(null); // =&amp;gt; []&#xA;array().ensure().cast(1); // =&amp;gt; [1]&#xA;array().ensure().cast([1]); // =&amp;gt; [1]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;array.compact(rejector: (value) =&amp;gt; boolean): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Removes falsey values from the array. Providing a rejecter function lets you specify the rejection criteria yourself.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;array().compact().cast([&#39;&#39;, 1, 0, 4, false, null]); // =&amp;gt; [1, 4]&#xA;&#xA;array()&#xA;  .compact(function (v) {&#xA;    return v == null;&#xA;  })&#xA;  .cast([&#39;&#39;, 1, 0, 4, false, null]); // =&amp;gt; [&#39;&#39;, 1, 0, 4, false]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;tuple&lt;/h3&gt; &#xA;&lt;p&gt;Tuples, are fixed length arrays where each item has a distinct type.&lt;/p&gt; &#xA;&lt;p&gt;Inherits from &lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#Schema&#34;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { tuple, string, number, InferType } from &#39;yup&#39;;&#xA;&#xA;let schema = tuple([&#xA;  string().label(&#39;name&#39;),&#xA;  number().label(&#39;age&#39;).positive().integer(),&#xA;]);&#xA;&#xA;await schema.validate([&#39;James&#39;, 3]); // [&#39;James&#39;, 3]&#xA;&#xA;await schema.validate([&#39;James&#39;, -24]); // =&amp;gt; ValidationError: age must be a positive number&#xA;&#xA;InferType&amp;lt;typeof schema&amp;gt; // [string, number] | undefined&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;tuples have no default casting behavior.&lt;/p&gt; &#xA;&lt;h3&gt;object&lt;/h3&gt; &#xA;&lt;p&gt;Define an object schema. Options passed into &lt;code&gt;isValid&lt;/code&gt; are also passed to child schemas. Inherits from &lt;a href=&#34;https://raw.githubusercontent.com/jquense/yup/master/#Schema&#34;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;yup.object({&#xA;  name: string().required(),&#xA;  age: number().required().positive().integer(),&#xA;  email: string().email(),&#xA;  website: string().url(),&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;object schema do not have any default transforms applied.&lt;/p&gt; &#xA;&lt;h4&gt;Object schema defaults&lt;/h4&gt; &#xA;&lt;p&gt;Object schema come with a default value already set, which &#34;builds&#34; out the object shape, a sets any defaults for fields:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const schema = object({&#xA;  name: string().default(&#39;&#39;),&#xA;});&#xA;&#xA;schema.default(); // -&amp;gt; { name: &#39;&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This may be a bit surprising, but is usually helpful since it allows large, nested schema to create default values that fill out the whole shape and not just the root object. There is one gotcha! though. For nested object schema that are optional but include non optional fields may fail in unexpected ways:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const schema = object({&#xA;  id: string().required(),&#xA;  names: object({&#xA;    first: string().required(),&#xA;  }),&#xA;});&#xA;&#xA;schema.isValid({ id: 1 }); // false! names.first is required&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is because yup casts the input object before running validation which will produce:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;{ id: &#39;1&#39;, names: { first: undefined }}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;During the validation phase &lt;code&gt;names&lt;/code&gt; exists, and is validated, finding &lt;code&gt;names.first&lt;/code&gt; missing. If you wish to avoid this behavior do one of the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Set the nested default to undefined: &lt;code&gt;names.default(undefined)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;mark it nullable and default to null: &lt;code&gt;names.nullable().default(null)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;object.shape(fields: object, noSortEdges?: Array&amp;lt;[string, string]&amp;gt;): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Define the keys of the object and the schemas for said keys.&lt;/p&gt; &#xA;&lt;p&gt;Note that you can chain &lt;code&gt;shape&lt;/code&gt; method, which acts like &lt;code&gt;Object.assign&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;object({&#xA;  a: string(),&#xA;  b: number(),&#xA;}).shape({&#xA;  b: string(),&#xA;  c: number(),&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;would be exactly the same as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;object({&#xA;  a: string(),&#xA;  b: string(),&#xA;  c: number(),&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;object.json(): this&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Attempt to parse input string values as JSON using &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse&#34;&gt;&lt;code&gt;JSON.parse&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;object.concat(schemaB: ObjectSchema): ObjectSchema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Creates a object schema, by applying all settings and fields from &lt;code&gt;schemaB&lt;/code&gt; to the base, producing a new schema. The object shape is shallowly merged with common fields from &lt;code&gt;schemaB&lt;/code&gt; taking precedence over the base fields.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;object.pick(keys: string[]): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Create a new schema from a subset of the original&#39;s fields.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const person = object({&#xA;  age: number().default(30).required(),&#xA;  name: string().default(&#39;pat&#39;).required(),&#xA;  color: string().default(&#39;red&#39;).required(),&#xA;});&#xA;&#xA;const nameAndAge = person.pick([&#39;name&#39;, &#39;age&#39;]);&#xA;nameAndAge.getDefault(); // =&amp;gt; { age: 30, name: &#39;pat&#39;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;object.omit(keys: string[]): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Create a new schema with fields omitted.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const person = object({&#xA;  age: number().default(30).required(),&#xA;  name: string().default(&#39;pat&#39;).required(),&#xA;  color: string().default(&#39;red&#39;).required(),&#xA;});&#xA;&#xA;const nameAndAge = person.omit([&#39;color&#39;]);&#xA;nameAndAge.getDefault(); // =&amp;gt; { age: 30, name: &#39;pat&#39;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;object.from(fromKey: string, toKey: string, alias: boolean = false): this&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Transforms the specified key to a new key. If &lt;code&gt;alias&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; then the old key will be left.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let schema = object({&#xA;  myProp: mixed(),&#xA;  Other: mixed(),&#xA;})&#xA;  .from(&#39;prop&#39;, &#39;myProp&#39;)&#xA;  .from(&#39;other&#39;, &#39;Other&#39;, true);&#xA;&#xA;schema.cast({ prop: 5, other: 6 }); // =&amp;gt; { myProp: 5, other: 6, Other: 6 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;object.noUnknown(onlyKnownKeys: boolean = true, message?: string | function): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Validate that the object value only contains keys specified in &lt;code&gt;shape&lt;/code&gt;, pass &lt;code&gt;false&lt;/code&gt; as the first argument to disable the check. Restricting keys to known, also enables &lt;code&gt;stripUnknown&lt;/code&gt; option, when not in strict mode.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;object.camelCase(): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Transforms all object keys to camelCase&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;object.constantCase(): Schema&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Transforms all object keys to CONSTANT_CASE.&lt;/p&gt;</summary>
  </entry>
</feed>