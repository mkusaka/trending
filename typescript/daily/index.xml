<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub TypeScript Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-01T01:40:40Z</updated>
  <subtitle>Daily Trending of TypeScript in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>redis/ioredis</title>
    <updated>2024-03-01T01:40:40Z</updated>
    <id>tag:github.com,2024-03-01:/redis/ioredis</id>
    <link href="https://github.com/redis/ioredis" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üöÄ A robust, performance-focused, and full-featured Redis client for Node.js.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/redis/ioredis&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/redis/ioredis@b5e8c74/logo.svg?sanitize=true&#34; alt=&#34;ioredis&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/redis/ioredis/actions/workflows/release.yml?query=branch%3Amain&#34;&gt;&lt;img src=&#34;https://github.com/redis/ioredis/actions/workflows/release.yml/badge.svg?branch=main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/github/luin/ioredis?branch=main&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/luin/ioredis/badge.svg?branch=main&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://commitizen.github.io/cz-cli/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/commitizen-friendly-brightgreen.svg?sanitize=true&#34; alt=&#34;Commitizen friendly&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/semantic-release/semantic-release&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?sanitize=true&#34; alt=&#34;semantic-release&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/redis&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/697882427875393627.svg?style=social&amp;amp;logo=discord&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.twitch.tv/redisinc&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitch/status/redisinc?style=social&#34; alt=&#34;Twitch&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.youtube.com/redisinc&#34;&gt;&lt;img src=&#34;https://img.shields.io/youtube/channel/views/UCD78lHSwYqMlyetR0_P4Vig?style=social&#34; alt=&#34;YouTube&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/redisinc&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/redisinc?style=social&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A robust, performance-focused and full-featured &lt;a href=&#34;http://redis.io&#34;&gt;Redis&lt;/a&gt; client for &lt;a href=&#34;https://nodejs.org&#34;&gt;Node.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Supports Redis &amp;gt;= 2.6.12. Completely compatible with Redis 7.x.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;p&gt;ioredis is a robust, full-featured Redis client that is used in the world&#39;s biggest online commerce company &lt;a href=&#34;http://www.alibaba.com/&#34;&gt;Alibaba&lt;/a&gt; and many other awesome companies.&lt;/p&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;Full-featured. It supports &lt;a href=&#34;http://redis.io/topics/cluster-tutorial&#34;&gt;Cluster&lt;/a&gt;, &lt;a href=&#34;https://redis.io/docs/reference/sentinel-clients&#34;&gt;Sentinel&lt;/a&gt;, &lt;a href=&#34;https://redis.io/topics/streams-intro&#34;&gt;Streams&lt;/a&gt;, &lt;a href=&#34;http://redis.io/topics/pipelining&#34;&gt;Pipelining&lt;/a&gt;, and of course &lt;a href=&#34;http://redis.io/commands/eval&#34;&gt;Lua scripting&lt;/a&gt;, &lt;a href=&#34;https://redis.io/topics/functions-intro&#34;&gt;Redis Functions&lt;/a&gt;, &lt;a href=&#34;http://redis.io/topics/pubsub&#34;&gt;Pub/Sub&lt;/a&gt; (with the support of binary messages).&lt;/li&gt; &#xA; &lt;li&gt;High performance üöÄ.&lt;/li&gt; &#xA; &lt;li&gt;Delightful API üòÑ. It works with Node callbacks and Native promises.&lt;/li&gt; &#xA; &lt;li&gt;Transformation of command arguments and replies.&lt;/li&gt; &#xA; &lt;li&gt;Transparent key prefixing.&lt;/li&gt; &#xA; &lt;li&gt;Abstraction for Lua scripting, allowing you to &lt;a href=&#34;https://github.com/redis/ioredis#lua-scripting&#34;&gt;define custom commands&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Supports &lt;a href=&#34;https://github.com/redis/ioredis#handle-binary-data&#34;&gt;binary data&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Supports &lt;a href=&#34;https://github.com/redis/ioredis#tls-options&#34;&gt;TLS&lt;/a&gt; üîí.&lt;/li&gt; &#xA; &lt;li&gt;Supports offline queue and ready checking.&lt;/li&gt; &#xA; &lt;li&gt;Supports ES6 types, such as &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Supports GEO commands üìç.&lt;/li&gt; &#xA; &lt;li&gt;Supports Redis ACL.&lt;/li&gt; &#xA; &lt;li&gt;Sophisticated error handling strategy.&lt;/li&gt; &#xA; &lt;li&gt;Supports NAT mapping.&lt;/li&gt; &#xA; &lt;li&gt;Supports autopipelining.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;100% written in TypeScript and official declarations are provided:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;img width=&#34;837&#34; src=&#34;https://raw.githubusercontent.com/redis/ioredis/main/resources/ts-screenshot.png&#34; alt=&#34;TypeScript Screenshot&#34;&gt; &#xA;&lt;h1&gt;Versions&lt;/h1&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Version&lt;/th&gt; &#xA;   &lt;th&gt;Branch&lt;/th&gt; &#xA;   &lt;th&gt;Node.js Version&lt;/th&gt; &#xA;   &lt;th&gt;Redis Version&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5.x.x (latest)&lt;/td&gt; &#xA;   &lt;td&gt;main&lt;/td&gt; &#xA;   &lt;td&gt;&amp;gt;= 12&lt;/td&gt; &#xA;   &lt;td&gt;2.6.12 ~ latest&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;4.x.x&lt;/td&gt; &#xA;   &lt;td&gt;v4&lt;/td&gt; &#xA;   &lt;td&gt;&amp;gt;= 6&lt;/td&gt; &#xA;   &lt;td&gt;2.6.12 ~ 7&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Refer to &lt;a href=&#34;https://raw.githubusercontent.com/redis/ioredis/main/CHANGELOG.md&#34;&gt;CHANGELOG.md&lt;/a&gt; for features and bug fixes introduced in v5.&lt;/p&gt; &#xA;&lt;p&gt;üöÄ &lt;a href=&#34;https://github.com/redis/ioredis/wiki/Upgrading-from-v4-to-v5&#34;&gt;Upgrading from v4 to v5&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Links&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://redis.github.io/ioredis/&#34;&gt;API Documentation&lt;/a&gt; (&lt;a href=&#34;https://redis.github.io/ioredis/classes/Redis.html&#34;&gt;Redis&lt;/a&gt;, &lt;a href=&#34;https://redis.github.io/ioredis/classes/Cluster.html&#34;&gt;Cluster&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/ioredis/main/CHANGELOG.md&#34;&gt;Changelog&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Quick Start&lt;/h1&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm install ioredis&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In a TypeScript project, you may want to add TypeScript declarations for Node.js:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm install --save-dev @types/node&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Basic Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Import ioredis.&#xA;// You can also use `import { Redis } from &#34;ioredis&#34;`&#xA;// if your project is a TypeScript project,&#xA;// Note that `import Redis from &#34;ioredis&#34;` is still supported,&#xA;// but will be deprecated in the next major version.&#xA;const Redis = require(&#34;ioredis&#34;);&#xA;&#xA;// Create a Redis instance.&#xA;// By default, it will connect to localhost:6379.&#xA;// We are going to cover how to specify connection options soon.&#xA;const redis = new Redis();&#xA;&#xA;redis.set(&#34;mykey&#34;, &#34;value&#34;); // Returns a promise which resolves to &#34;OK&#34; when the command succeeds.&#xA;&#xA;// ioredis supports the node.js callback style&#xA;redis.get(&#34;mykey&#34;, (err, result) =&amp;gt; {&#xA;  if (err) {&#xA;    console.error(err);&#xA;  } else {&#xA;    console.log(result); // Prints &#34;value&#34;&#xA;  }&#xA;});&#xA;&#xA;// Or ioredis returns a promise if the last argument isn&#39;t a function&#xA;redis.get(&#34;mykey&#34;).then((result) =&amp;gt; {&#xA;  console.log(result); // Prints &#34;value&#34;&#xA;});&#xA;&#xA;redis.zadd(&#34;sortedSet&#34;, 1, &#34;one&#34;, 2, &#34;dos&#34;, 4, &#34;quatro&#34;, 3, &#34;three&#34;);&#xA;redis.zrange(&#34;sortedSet&#34;, 0, 2, &#34;WITHSCORES&#34;).then((elements) =&amp;gt; {&#xA;  // [&#34;one&#34;, &#34;1&#34;, &#34;dos&#34;, &#34;2&#34;, &#34;three&#34;, &#34;3&#34;] as if the command was `redis&amp;gt; ZRANGE sortedSet 0 2 WITHSCORES`&#xA;  console.log(elements);&#xA;});&#xA;&#xA;// All arguments are passed directly to the redis server,&#xA;// so technically ioredis supports all Redis commands.&#xA;// The format is: redis[SOME_REDIS_COMMAND_IN_LOWERCASE](ARGUMENTS_ARE_JOINED_INTO_COMMAND_STRING)&#xA;// so the following statement is equivalent to the CLI: `redis&amp;gt; SET mykey hello EX 10`&#xA;redis.set(&#34;mykey&#34;, &#34;hello&#34;, &#34;EX&#34;, 10);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the &lt;code&gt;examples/&lt;/code&gt; folder for more examples. For example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/ioredis/main/examples/ttl.js&#34;&gt;TTL&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/ioredis/main/examples/string.js&#34;&gt;Strings&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/ioredis/main/examples/hash.js&#34;&gt;Hashes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/ioredis/main/examples/list.js&#34;&gt;Lists&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/ioredis/main/examples/set.js&#34;&gt;Sets&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/ioredis/main/examples/zset.js&#34;&gt;Sorted Sets&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/ioredis/main/examples/stream.js&#34;&gt;Streams&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/redis/ioredis/main/examples/module.js&#34;&gt;Redis Modules&lt;/a&gt; e.g. RedisJSON&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All Redis commands are supported. See &lt;a href=&#34;https://redis.github.io/ioredis/classes/Redis.html&#34;&gt;the documentation&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;Connect to Redis&lt;/h2&gt; &#xA;&lt;p&gt;When a new &lt;code&gt;Redis&lt;/code&gt; instance is created, a connection to Redis will be created at the same time. You can specify which Redis to connect to by:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;new Redis(); // Connect to 127.0.0.1:6379&#xA;new Redis(6380); // 127.0.0.1:6380&#xA;new Redis(6379, &#34;192.168.1.1&#34;); // 192.168.1.1:6379&#xA;new Redis(&#34;/tmp/redis.sock&#34;);&#xA;new Redis({&#xA;  port: 6379, // Redis port&#xA;  host: &#34;127.0.0.1&#34;, // Redis host&#xA;  username: &#34;default&#34;, // needs Redis &amp;gt;= 6&#xA;  password: &#34;my-top-secret&#34;,&#xA;  db: 0, // Defaults to 0&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also specify connection options as a &lt;a href=&#34;http://www.iana.org/assignments/uri-schemes/prov/redis&#34;&gt;&lt;code&gt;redis://&lt;/code&gt; URL&lt;/a&gt; or &lt;a href=&#34;https://www.iana.org/assignments/uri-schemes/prov/rediss&#34;&gt;&lt;code&gt;rediss://&lt;/code&gt; URL&lt;/a&gt; when using &lt;a href=&#34;https://raw.githubusercontent.com/redis/ioredis/main/#tls-options&#34;&gt;TLS encryption&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Connect to 127.0.0.1:6380, db 4, using password &#34;authpassword&#34;:&#xA;new Redis(&#34;redis://:authpassword@127.0.0.1:6380/4&#34;);&#xA;&#xA;// Username can also be passed via URI.&#xA;new Redis(&#34;redis://username:authpassword@127.0.0.1:6380/4&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://redis.github.io/ioredis/index.html#RedisOptions&#34;&gt;API Documentation&lt;/a&gt; for all available options.&lt;/p&gt; &#xA;&lt;h2&gt;Pub/Sub&lt;/h2&gt; &#xA;&lt;p&gt;Redis provides several commands for developers to implement the &lt;a href=&#34;https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern&#34;&gt;Publish‚Äìsubscribe pattern&lt;/a&gt;. There are two roles in this pattern: publisher and subscriber. Publishers are not programmed to send their messages to specific subscribers. Rather, published messages are characterized into channels, without knowledge of what (if any) subscribers there may be.&lt;/p&gt; &#xA;&lt;p&gt;By leveraging Node.js&#39;s built-in events module, ioredis makes pub/sub very straightforward to use. Below is a simple example that consists of two files, one is publisher.js that publishes messages to a channel, the other is subscriber.js that listens for messages on specific channels.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// publisher.js&#xA;&#xA;const Redis = require(&#34;ioredis&#34;);&#xA;const redis = new Redis();&#xA;&#xA;setInterval(() =&amp;gt; {&#xA;  const message = { foo: Math.random() };&#xA;  // Publish to my-channel-1 or my-channel-2 randomly.&#xA;  const channel = `my-channel-${1 + Math.round(Math.random())}`;&#xA;&#xA;  // Message can be either a string or a buffer&#xA;  redis.publish(channel, JSON.stringify(message));&#xA;  console.log(&#34;Published %s to %s&#34;, message, channel);&#xA;}, 1000);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// subscriber.js&#xA;&#xA;const Redis = require(&#34;ioredis&#34;);&#xA;const redis = new Redis();&#xA;&#xA;redis.subscribe(&#34;my-channel-1&#34;, &#34;my-channel-2&#34;, (err, count) =&amp;gt; {&#xA;  if (err) {&#xA;    // Just like other commands, subscribe() can fail for some reasons,&#xA;    // ex network issues.&#xA;    console.error(&#34;Failed to subscribe: %s&#34;, err.message);&#xA;  } else {&#xA;    // `count` represents the number of channels this client are currently subscribed to.&#xA;    console.log(&#xA;      `Subscribed successfully! This client is currently subscribed to ${count} channels.`&#xA;    );&#xA;  }&#xA;});&#xA;&#xA;redis.on(&#34;message&#34;, (channel, message) =&amp;gt; {&#xA;  console.log(`Received ${message} from ${channel}`);&#xA;});&#xA;&#xA;// There&#39;s also an event called &#39;messageBuffer&#39;, which is the same as &#39;message&#39; except&#xA;// it returns buffers instead of strings.&#xA;// It&#39;s useful when the messages are binary data.&#xA;redis.on(&#34;messageBuffer&#34;, (channel, message) =&amp;gt; {&#xA;  // Both `channel` and `message` are buffers.&#xA;  console.log(channel, message);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s worth noticing that a connection (aka a &lt;code&gt;Redis&lt;/code&gt; instance) can&#39;t play both roles at the same time. More specifically, when a client issues &lt;code&gt;subscribe()&lt;/code&gt; or &lt;code&gt;psubscribe()&lt;/code&gt;, it enters the &#34;subscriber&#34; mode. From that point, only commands that modify the subscription set are valid. Namely, they are: &lt;code&gt;subscribe&lt;/code&gt;, &lt;code&gt;psubscribe&lt;/code&gt;, &lt;code&gt;unsubscribe&lt;/code&gt;, &lt;code&gt;punsubscribe&lt;/code&gt;, &lt;code&gt;ping&lt;/code&gt;, and &lt;code&gt;quit&lt;/code&gt;. When the subscription set is empty (via &lt;code&gt;unsubscribe&lt;/code&gt;/&lt;code&gt;punsubscribe&lt;/code&gt;), the connection is put back into the regular mode.&lt;/p&gt; &#xA;&lt;p&gt;If you want to do pub/sub in the same file/process, you should create a separate connection:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Redis = require(&#34;ioredis&#34;);&#xA;const sub = new Redis();&#xA;const pub = new Redis();&#xA;&#xA;sub.subscribe(/* ... */); // From now, `sub` enters the subscriber mode.&#xA;sub.on(&#34;message&#34; /* ... */);&#xA;&#xA;setInterval(() =&amp;gt; {&#xA;  // `pub` can be used to publish messages, or send other regular commands (e.g. `hgetall`)&#xA;  // because it&#39;s not in the subscriber mode.&#xA;  pub.publish(/* ... */);&#xA;}, 1000);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;PSUBSCRIBE&lt;/code&gt; is also supported in a similar way when you want to subscribe all channels whose name matches a pattern:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis.psubscribe(&#34;pat?ern&#34;, (err, count) =&amp;gt; {});&#xA;&#xA;// Event names are &#34;pmessage&#34;/&#34;pmessageBuffer&#34; instead of &#34;message/messageBuffer&#34;.&#xA;redis.on(&#34;pmessage&#34;, (pattern, channel, message) =&amp;gt; {});&#xA;redis.on(&#34;pmessageBuffer&#34;, (pattern, channel, message) =&amp;gt; {});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Streams&lt;/h2&gt; &#xA;&lt;p&gt;Redis v5 introduces a new data type called streams. It doubles as a communication channel for building streaming architectures and as a log-like data structure for persisting data. With ioredis, the usage can be pretty straightforward. Say we have a producer publishes messages to a stream with &lt;code&gt;redis.xadd(&#34;mystream&#34;, &#34;*&#34;, &#34;randomValue&#34;, Math.random())&lt;/code&gt; (You may find the &lt;a href=&#34;https://redis.io/topics/streams-intro&#34;&gt;official documentation of Streams&lt;/a&gt; as a starter to understand the parameters used), to consume the messages, we&#39;ll have a consumer with the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Redis = require(&#34;ioredis&#34;);&#xA;const redis = new Redis();&#xA;&#xA;const processMessage = (message) =&amp;gt; {&#xA;  console.log(&#34;Id: %s. Data: %O&#34;, message[0], message[1]);&#xA;};&#xA;&#xA;async function listenForMessage(lastId = &#34;$&#34;) {&#xA;  // `results` is an array, each element of which corresponds to a key.&#xA;  // Because we only listen to one key (mystream) here, `results` only contains&#xA;  // a single element. See more: https://redis.io/commands/xread#return-value&#xA;  const results = await redis.xread(&#34;block&#34;, 0, &#34;STREAMS&#34;, &#34;mystream&#34;, lastId);&#xA;  const [key, messages] = results[0]; // `key` equals to &#34;mystream&#34;&#xA;&#xA;  messages.forEach(processMessage);&#xA;&#xA;  // Pass the last id of the results to the next round.&#xA;  await listenForMessage(messages[messages.length - 1][0]);&#xA;}&#xA;&#xA;listenForMessage();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Expiration&lt;/h2&gt; &#xA;&lt;p&gt;Redis can set a timeout to expire your key, after the timeout has expired the key will be automatically deleted. (You can find the &lt;a href=&#34;https://redis.io/commands/expire/&#34;&gt;official Expire documentation&lt;/a&gt; to understand better the different parameters you can use), to set your key to expire in 60 seconds, we will have the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis.set(&#34;key&#34;, &#34;data&#34;, &#34;EX&#34;, 60);&#xA;// Equivalent to redis command &#34;SET key data EX 60&#34;, because on ioredis set method,&#xA;// all arguments are passed directly to the redis server.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Handle Binary Data&lt;/h2&gt; &#xA;&lt;p&gt;Binary data support is out of the box. Pass buffers to send binary data:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis.set(&#34;foo&#34;, Buffer.from([0x62, 0x75, 0x66]));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Every command that returns a &lt;a href=&#34;https://redis.io/docs/reference/protocol-spec/#resp-bulk-strings&#34;&gt;bulk string&lt;/a&gt; has a variant command with a &lt;code&gt;Buffer&lt;/code&gt; suffix. The variant command returns a buffer instead of a UTF-8 string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const result = await redis.getBuffer(&#34;foo&#34;);&#xA;// result is `&amp;lt;Buffer 62 75 66&amp;gt;`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s worth noticing that you don&#39;t need the &lt;code&gt;Buffer&lt;/code&gt; suffix variant in order to &lt;strong&gt;send&lt;/strong&gt; binary data. That means in most case you should just use &lt;code&gt;redis.set()&lt;/code&gt; instead of &lt;code&gt;redis.setBuffer()&lt;/code&gt; unless you want to get the old value with the &lt;code&gt;GET&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const result = await redis.setBuffer(&#34;foo&#34;, &#34;new value&#34;, &#34;GET&#34;);&#xA;// result is `&amp;lt;Buffer 62 75 66&amp;gt;` as `GET` indicates returning the old value.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Pipelining&lt;/h2&gt; &#xA;&lt;p&gt;If you want to send a batch of commands (e.g. &amp;gt; 5), you can use pipelining to queue the commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See &lt;a href=&#34;https://raw.githubusercontent.com/redis/ioredis/main/#benchmarks&#34;&gt;benchmark section&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;redis.pipeline()&lt;/code&gt; creates a &lt;code&gt;Pipeline&lt;/code&gt; instance. You can call any Redis commands on it just like the &lt;code&gt;Redis&lt;/code&gt; instance. The commands are queued in memory and flushed to Redis by calling the &lt;code&gt;exec&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const pipeline = redis.pipeline();&#xA;pipeline.set(&#34;foo&#34;, &#34;bar&#34;);&#xA;pipeline.del(&#34;cc&#34;);&#xA;pipeline.exec((err, results) =&amp;gt; {&#xA;  // `err` is always null, and `results` is an array of responses&#xA;  // corresponding to the sequence of queued commands.&#xA;  // Each response follows the format `[err, result]`.&#xA;});&#xA;&#xA;// You can even chain the commands:&#xA;redis&#xA;  .pipeline()&#xA;  .set(&#34;foo&#34;, &#34;bar&#34;)&#xA;  .del(&#34;cc&#34;)&#xA;  .exec((err, results) =&amp;gt; {});&#xA;&#xA;// `exec` also returns a Promise:&#xA;const promise = redis.pipeline().set(&#34;foo&#34;, &#34;bar&#34;).get(&#34;foo&#34;).exec();&#xA;promise.then((result) =&amp;gt; {&#xA;  // result === [[null, &#39;OK&#39;], [null, &#39;bar&#39;]]&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each chained command can also have a callback, which will be invoked when the command gets a reply:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis&#xA;  .pipeline()&#xA;  .set(&#34;foo&#34;, &#34;bar&#34;)&#xA;  .get(&#34;foo&#34;, (err, result) =&amp;gt; {&#xA;    // result === &#39;bar&#39;&#xA;  })&#xA;  .exec((err, result) =&amp;gt; {&#xA;    // result[1][1] === &#39;bar&#39;&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition to adding commands to the &lt;code&gt;pipeline&lt;/code&gt; queue individually, you can also pass an array of commands and arguments to the constructor:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis&#xA;  .pipeline([&#xA;    [&#34;set&#34;, &#34;foo&#34;, &#34;bar&#34;],&#xA;    [&#34;get&#34;, &#34;foo&#34;],&#xA;  ])&#xA;  .exec(() =&amp;gt; {&#xA;    /* ... */&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;#length&lt;/code&gt; property shows how many commands in the pipeline:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const length = redis.pipeline().set(&#34;foo&#34;, &#34;bar&#34;).get(&#34;foo&#34;).length;&#xA;// length === 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Transaction&lt;/h2&gt; &#xA;&lt;p&gt;Most of the time, the transaction commands &lt;code&gt;multi&lt;/code&gt; &amp;amp; &lt;code&gt;exec&lt;/code&gt; are used together with pipeline. Therefore, when &lt;code&gt;multi&lt;/code&gt; is called, a &lt;code&gt;Pipeline&lt;/code&gt; instance is created automatically by default, so you can use &lt;code&gt;multi&lt;/code&gt; just like &lt;code&gt;pipeline&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis&#xA;  .multi()&#xA;  .set(&#34;foo&#34;, &#34;bar&#34;)&#xA;  .get(&#34;foo&#34;)&#xA;  .exec((err, results) =&amp;gt; {&#xA;    // results === [[null, &#39;OK&#39;], [null, &#39;bar&#39;]]&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If there&#39;s a syntax error in the transaction&#39;s command chain (e.g. wrong number of arguments, wrong command name, etc), then none of the commands would be executed, and an error is returned:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis&#xA;  .multi()&#xA;  .set(&#34;foo&#34;)&#xA;  .set(&#34;foo&#34;, &#34;new value&#34;)&#xA;  .exec((err, results) =&amp;gt; {&#xA;    // err:&#xA;    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]&#xA;    //    name: &#39;ReplyError&#39;,&#xA;    //    message: &#39;EXECABORT Transaction discarded because of previous errors.&#39;,&#xA;    //    command: { name: &#39;exec&#39;, args: [] },&#xA;    //    previousErrors:&#xA;    //     [ { [ReplyError: ERR wrong number of arguments for &#39;set&#39; command]&#xA;    //         name: &#39;ReplyError&#39;,&#xA;    //         message: &#39;ERR wrong number of arguments for \&#39;set\&#39; command&#39;,&#xA;    //         command: [Object] } ] }&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In terms of the interface, &lt;code&gt;multi&lt;/code&gt; differs from &lt;code&gt;pipeline&lt;/code&gt; in that when specifying a callback to each chained command, the queueing state is passed to the callback instead of the result of the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis&#xA;  .multi()&#xA;  .set(&#34;foo&#34;, &#34;bar&#34;, (err, result) =&amp;gt; {&#xA;    // result === &#39;QUEUED&#39;&#xA;  })&#xA;  .exec(/* ... */);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use transaction without pipeline, pass &lt;code&gt;{ pipeline: false }&lt;/code&gt; to &lt;code&gt;multi&lt;/code&gt;, and every command will be sent to Redis immediately without waiting for an &lt;code&gt;exec&lt;/code&gt; invocation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis.multi({ pipeline: false });&#xA;redis.set(&#34;foo&#34;, &#34;bar&#34;);&#xA;redis.get(&#34;foo&#34;);&#xA;redis.exec((err, result) =&amp;gt; {&#xA;  // result === [[null, &#39;OK&#39;], [null, &#39;bar&#39;]]&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The constructor of &lt;code&gt;multi&lt;/code&gt; also accepts a batch of commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis&#xA;  .multi([&#xA;    [&#34;set&#34;, &#34;foo&#34;, &#34;bar&#34;],&#xA;    [&#34;get&#34;, &#34;foo&#34;],&#xA;  ])&#xA;  .exec(() =&amp;gt; {&#xA;    /* ... */&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Inline transactions are supported by pipeline, which means you can group a subset of commands in the pipeline into a transaction:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis&#xA;  .pipeline()&#xA;  .get(&#34;foo&#34;)&#xA;  .multi()&#xA;  .set(&#34;foo&#34;, &#34;bar&#34;)&#xA;  .get(&#34;foo&#34;)&#xA;  .exec()&#xA;  .get(&#34;foo&#34;)&#xA;  .exec();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Lua Scripting&lt;/h2&gt; &#xA;&lt;p&gt;ioredis supports all of the scripting commands such as &lt;code&gt;EVAL&lt;/code&gt;, &lt;code&gt;EVALSHA&lt;/code&gt; and &lt;code&gt;SCRIPT&lt;/code&gt;. However, it&#39;s tedious to use in real world scenarios since developers have to take care of script caching and to detect when to use &lt;code&gt;EVAL&lt;/code&gt; and when to use &lt;code&gt;EVALSHA&lt;/code&gt;. ioredis exposes a &lt;code&gt;defineCommand&lt;/code&gt; method to make scripting much easier to use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const redis = new Redis();&#xA;&#xA;// This will define a command myecho:&#xA;redis.defineCommand(&#34;myecho&#34;, {&#xA;  numberOfKeys: 2,&#xA;  lua: &#34;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&#34;,&#xA;});&#xA;&#xA;// Now `myecho` can be used just like any other ordinary command,&#xA;// and ioredis will try to use `EVALSHA` internally when possible for better performance.&#xA;redis.myecho(&#34;k1&#34;, &#34;k2&#34;, &#34;a1&#34;, &#34;a2&#34;, (err, result) =&amp;gt; {&#xA;  // result === [&#39;k1&#39;, &#39;k2&#39;, &#39;a1&#39;, &#39;a2&#39;]&#xA;});&#xA;&#xA;// `myechoBuffer` is also defined automatically to return buffers instead of strings:&#xA;redis.myechoBuffer(&#34;k1&#34;, &#34;k2&#34;, &#34;a1&#34;, &#34;a2&#34;, (err, result) =&amp;gt; {&#xA;  // result[0] equals to Buffer.from(&#39;k1&#39;);&#xA;});&#xA;&#xA;// And of course it works with pipeline:&#xA;redis.pipeline().set(&#34;foo&#34;, &#34;bar&#34;).myecho(&#34;k1&#34;, &#34;k2&#34;, &#34;a1&#34;, &#34;a2&#34;).exec();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dynamic Keys&lt;/h3&gt; &#xA;&lt;p&gt;If the number of keys can&#39;t be determined when defining a command, you can omit the &lt;code&gt;numberOfKeys&lt;/code&gt; property and pass the number of keys as the first argument when you call the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis.defineCommand(&#34;echoDynamicKeyNumber&#34;, {&#xA;  lua: &#34;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&#34;,&#xA;});&#xA;&#xA;// Now you have to pass the number of keys as the first argument every time&#xA;// you invoke the `echoDynamicKeyNumber` command:&#xA;redis.echoDynamicKeyNumber(2, &#34;k1&#34;, &#34;k2&#34;, &#34;a1&#34;, &#34;a2&#34;, (err, result) =&amp;gt; {&#xA;  // result === [&#39;k1&#39;, &#39;k2&#39;, &#39;a1&#39;, &#39;a2&#39;]&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;As Constructor Options&lt;/h3&gt; &#xA;&lt;p&gt;Besides &lt;code&gt;defineCommand()&lt;/code&gt;, you can also define custom commands with the &lt;code&gt;scripts&lt;/code&gt; constructor option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const redis = new Redis({&#xA;  scripts: {&#xA;    myecho: {&#xA;      numberOfKeys: 2,&#xA;      lua: &#34;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&#34;,&#xA;    },&#xA;  },&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;TypeScript Usages&lt;/h3&gt; &#xA;&lt;p&gt;You can refer to &lt;a href=&#34;https://raw.githubusercontent.com/redis/ioredis/main/examples/typescript/scripts.ts&#34;&gt;the example&lt;/a&gt; for how to declare your custom commands.&lt;/p&gt; &#xA;&lt;h2&gt;Transparent Key Prefixing&lt;/h2&gt; &#xA;&lt;p&gt;This feature allows you to specify a string that will automatically be prepended to all the keys in a command, which makes it easier to manage your key namespaces.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt; This feature won&#39;t apply to commands like &lt;a href=&#34;http://redis.io/commands/KEYS&#34;&gt;KEYS&lt;/a&gt; and &lt;a href=&#34;http://redis.io/commands/scan&#34;&gt;SCAN&lt;/a&gt; that take patterns rather than actual keys(&lt;a href=&#34;https://github.com/redis/ioredis/issues/239&#34;&gt;#239&lt;/a&gt;), and this feature also won&#39;t apply to the replies of commands even if they are key names (&lt;a href=&#34;https://github.com/redis/ioredis/issues/325&#34;&gt;#325&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const fooRedis = new Redis({ keyPrefix: &#34;foo:&#34; });&#xA;fooRedis.set(&#34;bar&#34;, &#34;baz&#34;); // Actually sends SET foo:bar baz&#xA;&#xA;fooRedis.defineCommand(&#34;myecho&#34;, {&#xA;  numberOfKeys: 2,&#xA;  lua: &#34;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&#34;,&#xA;});&#xA;&#xA;// Works well with pipelining/transaction&#xA;fooRedis&#xA;  .pipeline()&#xA;  // Sends SORT foo:list BY foo:weight_*-&amp;gt;fieldname&#xA;  .sort(&#34;list&#34;, &#34;BY&#34;, &#34;weight_*-&amp;gt;fieldname&#34;)&#xA;  // Supports custom commands&#xA;  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2&#xA;  .myecho(&#34;k1&#34;, &#34;k2&#34;, &#34;a1&#34;, &#34;a2&#34;)&#xA;  .exec();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Transforming Arguments &amp;amp; Replies&lt;/h2&gt; &#xA;&lt;p&gt;Most Redis commands take one or more Strings as arguments, and replies are sent back as a single String or an Array of Strings. However, sometimes you may want something different. For instance, it would be more convenient if the &lt;code&gt;HGETALL&lt;/code&gt; command returns a hash (e.g. &lt;code&gt;{ key: val1, key2: v2 }&lt;/code&gt;) rather than an array of key values (e.g. &lt;code&gt;[key1, val1, key2, val2]&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;ioredis has a flexible system for transforming arguments and replies. There are two types of transformers, argument transformer and reply transformer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Redis = require(&#34;ioredis&#34;);&#xA;&#xA;// Here&#39;s the built-in argument transformer converting&#xA;// hmset(&#39;key&#39;, { k1: &#39;v1&#39;, k2: &#39;v2&#39; })&#xA;// or&#xA;// hmset(&#39;key&#39;, new Map([[&#39;k1&#39;, &#39;v1&#39;], [&#39;k2&#39;, &#39;v2&#39;]]))&#xA;// into&#xA;// hmset(&#39;key&#39;, &#39;k1&#39;, &#39;v1&#39;, &#39;k2&#39;, &#39;v2&#39;)&#xA;Redis.Command.setArgumentTransformer(&#34;hmset&#34;, (args) =&amp;gt; {&#xA;  if (args.length === 2) {&#xA;    if (args[1] instanceof Map) {&#xA;      // utils is a internal module of ioredis&#xA;      return [args[0], ...utils.convertMapToArray(args[1])];&#xA;    }&#xA;    if (typeof args[1] === &#34;object&#34; &amp;amp;&amp;amp; args[1] !== null) {&#xA;      return [args[0], ...utils.convertObjectToArray(args[1])];&#xA;    }&#xA;  }&#xA;  return args;&#xA;});&#xA;&#xA;// Here&#39;s the built-in reply transformer converting the HGETALL reply&#xA;// [&#39;k1&#39;, &#39;v1&#39;, &#39;k2&#39;, &#39;v2&#39;]&#xA;// into&#xA;// { k1: &#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39; }&#xA;Redis.Command.setReplyTransformer(&#34;hgetall&#34;, (result) =&amp;gt; {&#xA;  if (Array.isArray(result)) {&#xA;    const obj = {};&#xA;    for (let i = 0; i &amp;lt; result.length; i += 2) {&#xA;      obj[result[i]] = result[i + 1];&#xA;    }&#xA;    return obj;&#xA;  }&#xA;  return result;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are three built-in transformers, two argument transformers for &lt;code&gt;hmset&lt;/code&gt; &amp;amp; &lt;code&gt;mset&lt;/code&gt; and a reply transformer for &lt;code&gt;hgetall&lt;/code&gt;. Transformers for &lt;code&gt;hmset&lt;/code&gt; and &lt;code&gt;hgetall&lt;/code&gt; were mentioned above, and the transformer for &lt;code&gt;mset&lt;/code&gt; is similar to the one for &lt;code&gt;hmset&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis.mset({ k1: &#34;v1&#34;, k2: &#34;v2&#34; });&#xA;redis.get(&#34;k1&#34;, (err, result) =&amp;gt; {&#xA;  // result === &#39;v1&#39;;&#xA;});&#xA;&#xA;redis.mset(&#xA;  new Map([&#xA;    [&#34;k3&#34;, &#34;v3&#34;],&#xA;    [&#34;k4&#34;, &#34;v4&#34;],&#xA;  ])&#xA;);&#xA;redis.get(&#34;k3&#34;, (err, result) =&amp;gt; {&#xA;  // result === &#39;v3&#39;;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Another useful example of a reply transformer is one that changes &lt;code&gt;hgetall&lt;/code&gt; to return array of arrays instead of objects which avoids an unwanted conversation of hash keys to strings when dealing with binary hash keys:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Redis.Command.setReplyTransformer(&#34;hgetall&#34;, (result) =&amp;gt; {&#xA;  const arr = [];&#xA;  for (let i = 0; i &amp;lt; result.length; i += 2) {&#xA;    arr.push([result[i], result[i + 1]]);&#xA;  }&#xA;  return arr;&#xA;});&#xA;redis.hset(&#34;h1&#34;, Buffer.from([0x01]), Buffer.from([0x02]));&#xA;redis.hset(&#34;h1&#34;, Buffer.from([0x03]), Buffer.from([0x04]));&#xA;redis.hgetallBuffer(&#34;h1&#34;, (err, result) =&amp;gt; {&#xA;  // result === [ [ &amp;lt;Buffer 01&amp;gt;, &amp;lt;Buffer 02&amp;gt; ], [ &amp;lt;Buffer 03&amp;gt;, &amp;lt;Buffer 04&amp;gt; ] ];&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Monitor&lt;/h2&gt; &#xA;&lt;p&gt;Redis supports the MONITOR command, which lets you see all commands received by the Redis server across all client connections, including from other client libraries and other computers.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;monitor&lt;/code&gt; method returns a monitor instance. After you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across. The callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.&lt;/p&gt; &#xA;&lt;p&gt;Here is a simple example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redis.monitor((err, monitor) =&amp;gt; {&#xA;  monitor.on(&#34;monitor&#34;, (time, args, source, database) =&amp;gt; {});&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is another example illustrating an &lt;code&gt;async&lt;/code&gt; function and &lt;code&gt;monitor.disconnect()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;async () =&amp;gt; {&#xA;  const monitor = await redis.monitor();&#xA;  monitor.on(&#34;monitor&#34;, console.log);&#xA;  // Any other tasks&#xA;  monitor.disconnect();&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Streamify Scanning&lt;/h2&gt; &#xA;&lt;p&gt;Redis 2.8 added the &lt;code&gt;SCAN&lt;/code&gt; command to incrementally iterate through the keys in the database. It&#39;s different from &lt;code&gt;KEYS&lt;/code&gt; in that &lt;code&gt;SCAN&lt;/code&gt; only returns a small number of elements each call, so it can be used in production without the downside of blocking the server for a long time. However, it requires recording the cursor on the client side each time the &lt;code&gt;SCAN&lt;/code&gt; command is called in order to iterate through all the keys correctly. Since it&#39;s a relatively common use case, ioredis provides a streaming interface for the &lt;code&gt;SCAN&lt;/code&gt; command to make things much easier. A readable stream can be created by calling &lt;code&gt;scanStream&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const redis = new Redis();&#xA;// Create a readable stream (object mode)&#xA;const stream = redis.scanStream();&#xA;stream.on(&#34;data&#34;, (resultKeys) =&amp;gt; {&#xA;  // `resultKeys` is an array of strings representing key names.&#xA;  // Note that resultKeys may contain 0 keys, and that it will sometimes&#xA;  // contain duplicates due to SCAN&#39;s implementation in Redis.&#xA;  for (let i = 0; i &amp;lt; resultKeys.length; i++) {&#xA;    console.log(resultKeys[i]);&#xA;  }&#xA;});&#xA;stream.on(&#34;end&#34;, () =&amp;gt; {&#xA;  console.log(&#34;all keys have been visited&#34;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;scanStream&lt;/code&gt; accepts an option, with which you can specify the &lt;code&gt;MATCH&lt;/code&gt; pattern, the &lt;code&gt;TYPE&lt;/code&gt; filter, and the &lt;code&gt;COUNT&lt;/code&gt; argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const stream = redis.scanStream({&#xA;  // only returns keys following the pattern of `user:*`&#xA;  match: &#34;user:*&#34;,&#xA;  // only return objects that match a given type,&#xA;  // (requires Redis &amp;gt;= 6.0)&#xA;  type: &#34;zset&#34;,&#xA;  // returns approximately 100 elements per call&#xA;  count: 100,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Just like other commands, &lt;code&gt;scanStream&lt;/code&gt; has a binary version &lt;code&gt;scanBufferStream&lt;/code&gt;, which returns an array of buffers. It&#39;s useful when the key names are not utf8 strings.&lt;/p&gt; &#xA;&lt;p&gt;There are also &lt;code&gt;hscanStream&lt;/code&gt;, &lt;code&gt;zscanStream&lt;/code&gt; and &lt;code&gt;sscanStream&lt;/code&gt; to iterate through elements in a hash, zset and set. The interface of each is similar to &lt;code&gt;scanStream&lt;/code&gt; except the first argument is the key name:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const stream = redis.hscanStream(&#34;myhash&#34;, {&#xA;  match: &#34;age:??&#34;,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can learn more from the &lt;a href=&#34;http://redis.io/commands/scan&#34;&gt;Redis documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Useful Tips&lt;/strong&gt; It&#39;s pretty common that doing an async task in the &lt;code&gt;data&lt;/code&gt; handler. We&#39;d like the scanning process to be paused until the async task to be finished. &lt;code&gt;Stream#pause()&lt;/code&gt; and &lt;code&gt;Stream#resume()&lt;/code&gt; do the trick. For example if we want to migrate data in Redis to MySQL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const stream = redis.scanStream();&#xA;stream.on(&#34;data&#34;, (resultKeys) =&amp;gt; {&#xA;  // Pause the stream from scanning more keys until we&#39;ve migrated the current keys.&#xA;  stream.pause();&#xA;&#xA;  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() =&amp;gt; {&#xA;    // Resume the stream here.&#xA;    stream.resume();&#xA;  });&#xA;});&#xA;&#xA;stream.on(&#34;end&#34;, () =&amp;gt; {&#xA;  console.log(&#34;done migration&#34;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Auto-reconnect&lt;/h2&gt; &#xA;&lt;p&gt;By default, ioredis will try to reconnect when the connection to Redis is lost except when the connection is closed manually by &lt;code&gt;redis.disconnect()&lt;/code&gt; or &lt;code&gt;redis.quit()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s very flexible to control how long to wait to reconnect after disconnection using the &lt;code&gt;retryStrategy&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const redis = new Redis({&#xA;  // This is the default value of `retryStrategy`&#xA;  retryStrategy(times) {&#xA;    const delay = Math.min(times * 50, 2000);&#xA;    return delay;&#xA;  },&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;retryStrategy&lt;/code&gt; is a function that will be called when the connection is lost. The argument &lt;code&gt;times&lt;/code&gt; means this is the nth reconnection being made and the return value represents how long (in ms) to wait to reconnect. When the return value isn&#39;t a number, ioredis will stop trying to reconnect, and the connection will be lost forever if the user doesn&#39;t call &lt;code&gt;redis.connect()&lt;/code&gt; manually.&lt;/p&gt; &#xA;&lt;p&gt;When reconnected, the client will auto subscribe to channels that the previous connection subscribed to. This behavior can be disabled by setting the &lt;code&gt;autoResubscribe&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;And if the previous connection has some unfulfilled commands (most likely blocking commands such as &lt;code&gt;brpop&lt;/code&gt; and &lt;code&gt;blpop&lt;/code&gt;), the client will resend them when reconnected. This behavior can be disabled by setting the &lt;code&gt;autoResendUnfulfilledCommands&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won&#39;t wait forever when the connection is down. You can change this behavior by setting &lt;code&gt;maxRetriesPerRequest&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const redis = new Redis({&#xA;  maxRetriesPerRequest: 1,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set maxRetriesPerRequest to &lt;code&gt;null&lt;/code&gt; to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).&lt;/p&gt; &#xA;&lt;h3&gt;Reconnect on Error&lt;/h3&gt; &#xA;&lt;p&gt;Besides auto-reconnect when the connection is closed, ioredis supports reconnecting on certain Redis errors using the &lt;code&gt;reconnectOnError&lt;/code&gt; option. Here&#39;s an example that will reconnect when receiving &lt;code&gt;READONLY&lt;/code&gt; error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const redis = new Redis({&#xA;  reconnectOnError(err) {&#xA;    const targetError = &#34;READONLY&#34;;&#xA;    if (err.message.includes(targetError)) {&#xA;      // Only reconnect when the error contains &#34;READONLY&#34;&#xA;      return true; // or `return 1;`&#xA;    }&#xA;  },&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This feature is useful when using Amazon ElastiCache instances with Auto-failover disabled. On these instances, test your &lt;code&gt;reconnectOnError&lt;/code&gt; handler by manually promoting the replica node to the primary role using the AWS console. The following writes fail with the error &lt;code&gt;READONLY&lt;/code&gt;. Using &lt;code&gt;reconnectOnError&lt;/code&gt;, we can force the connection to reconnect on this error in order to connect to the new master. Furthermore, if the &lt;code&gt;reconnectOnError&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;, ioredis will resend the failed command after reconnecting.&lt;/p&gt; &#xA;&lt;p&gt;On ElastiCache instances with Auto-failover enabled, &lt;code&gt;reconnectOnError&lt;/code&gt; does not execute. Instead of returning a Redis error, AWS closes all connections to the master endpoint until the new primary node is ready. ioredis reconnects via &lt;code&gt;retryStrategy&lt;/code&gt; instead of &lt;code&gt;reconnectOnError&lt;/code&gt; after about a minute. On ElastiCache instances with Auto-failover enabled, test failover events with the &lt;code&gt;Failover primary&lt;/code&gt; option in the AWS console.&lt;/p&gt; &#xA;&lt;h2&gt;Connection Events&lt;/h2&gt; &#xA;&lt;p&gt;The Redis instance will emit some events about the state of the connection to the Redis server.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Event&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;connect&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits when a connection is established to the Redis server.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;ready&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;If &lt;code&gt;enableReadyCheck&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, client will emit &lt;code&gt;ready&lt;/code&gt; when the server reports that it is ready to receive commands (e.g. finish loading data from disk).&lt;br&gt;Otherwise, &lt;code&gt;ready&lt;/code&gt; will be emitted immediately right after the &lt;code&gt;connect&lt;/code&gt; event.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;error&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits when an error occurs while connecting.&lt;br&gt;However, ioredis emits all &lt;code&gt;error&lt;/code&gt; events silently (only emits when there&#39;s at least one listener) so that your application won&#39;t crash if you&#39;re not listening to the &lt;code&gt;error&lt;/code&gt; event.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;close&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits when an established Redis server connection has closed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;reconnecting&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits after &lt;code&gt;close&lt;/code&gt; when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;end&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits after &lt;code&gt;close&lt;/code&gt; when no more reconnections will be made, or the connection is failed to establish.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;wait&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits when &lt;code&gt;lazyConnect&lt;/code&gt; is set and will wait for the first command to be called before connecting.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;You can also check out the &lt;code&gt;Redis#status&lt;/code&gt; property to get the current connection status.&lt;/p&gt; &#xA;&lt;p&gt;Besides the above connection events, there are several other custom events:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Event&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;select&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits when the database changed. The argument is the new db number.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Offline Queue&lt;/h2&gt; &#xA;&lt;p&gt;When a command can&#39;t be processed by Redis (being sent before the &lt;code&gt;ready&lt;/code&gt; event), by default, it&#39;s added to the offline queue and will be executed when it can be processed. You can disable this feature by setting the &lt;code&gt;enableOfflineQueue&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const redis = new Redis({ enableOfflineQueue: false });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;TLS Options&lt;/h2&gt; &#xA;&lt;p&gt;Redis doesn&#39;t support TLS natively, however if the redis server you want to connect to is hosted behind a TLS proxy (e.g. &lt;a href=&#34;https://www.stunnel.org/&#34;&gt;stunnel&lt;/a&gt;) or is offered by a PaaS service that supports TLS connection (e.g. &lt;a href=&#34;https://redis.com/&#34;&gt;Redis.com&lt;/a&gt;), you can set the &lt;code&gt;tls&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const redis = new Redis({&#xA;  host: &#34;localhost&#34;,&#xA;  tls: {&#xA;    // Refer to `tls.connect()` section in&#xA;    // https://nodejs.org/api/tls.html&#xA;    // for all supported options&#xA;    ca: fs.readFileSync(&#34;cert.pem&#34;),&#xA;  },&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, specify the connection through a &lt;a href=&#34;https://www.iana.org/assignments/uri-schemes/prov/rediss&#34;&gt;&lt;code&gt;rediss://&lt;/code&gt; URL&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const redis = new Redis(&#34;rediss://redis.my-service.com&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you do not want to use a connection string, you can also specify an empty &lt;code&gt;tls: {}&lt;/code&gt; object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const redis = new Redis({&#xA;  host: &#34;redis.my-service.com&#34;,&#xA;  tls: {},&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;TLS Profiles&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt; TLS profiles described in this section are going to be deprecated in the next major version. Please provide TLS options explicitly.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To make it easier to configure we provide a few pre-configured TLS profiles that can be specified by setting the &lt;code&gt;tls&lt;/code&gt; option to the profile&#39;s name or specifying a &lt;code&gt;tls.profile&lt;/code&gt; option in case you need to customize some values of the profile.&lt;/p&gt; &#xA;&lt;p&gt;Profiles:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;RedisCloudFixed&lt;/code&gt;: Contains the CA for &lt;a href=&#34;https://redis.com/&#34;&gt;Redis.com&lt;/a&gt; Cloud fixed subscriptions&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RedisCloudFlexible&lt;/code&gt;: Contains the CA for &lt;a href=&#34;https://redis.com/&#34;&gt;Redis.com&lt;/a&gt; Cloud flexible subscriptions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const redis = new Redis({&#xA;  host: &#34;localhost&#34;,&#xA;  tls: &#34;RedisCloudFixed&#34;,&#xA;});&#xA;&#xA;const redisWithClientCertificate = new Redis({&#xA;  host: &#34;localhost&#34;,&#xA;  tls: {&#xA;    profile: &#34;RedisCloudFixed&#34;,&#xA;    key: &#34;123&#34;,&#xA;  },&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Sentinel&lt;/h2&gt; &#xA;&lt;p&gt;ioredis supports Sentinel out of the box. It works transparently as all features that work when you connect to a single node also work when you connect to a sentinel group. Make sure to run Redis &amp;gt;= 2.8.12 if you want to use this feature. Sentinels have a default port of 26379.&lt;/p&gt; &#xA;&lt;p&gt;To connect using Sentinel, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const redis = new Redis({&#xA;  sentinels: [&#xA;    { host: &#34;localhost&#34;, port: 26379 },&#xA;    { host: &#34;localhost&#34;, port: 26380 },&#xA;  ],&#xA;  name: &#34;mymaster&#34;,&#xA;});&#xA;&#xA;redis.set(&#34;foo&#34;, &#34;bar&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The arguments passed to the constructor are different from the ones you use to connect to a single node, where:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;name&lt;/code&gt; identifies a group of Redis instances composed of a master and one or more slaves (&lt;code&gt;mymaster&lt;/code&gt; in the example);&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sentinelPassword&lt;/code&gt; (optional) password for Sentinel instances.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sentinels&lt;/code&gt; are a list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;role&lt;/code&gt; (optional) with a value of &lt;code&gt;slave&lt;/code&gt; will return a random slave from the Sentinel group.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;preferredSlaves&lt;/code&gt; (optional) can be used to prefer a particular slave or set of slaves based on priority. It accepts a function or array.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;enableTLSForSentinelMode&lt;/code&gt; (optional) set to true if connecting to sentinel instances that are encrypted&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;ioredis &lt;strong&gt;guarantees&lt;/strong&gt; that the node you connected to is always a master even after a failover. When a failover happens, instead of trying to reconnect to the failed node (which will be demoted to slave when it&#39;s available again), ioredis will ask sentinels for the new master node and connect to it. All commands sent during the failover are queued and will be executed when the new connection is established so that none of the commands will be lost.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s possible to connect to a slave instead of a master by specifying the option &lt;code&gt;role&lt;/code&gt; with the value of &lt;code&gt;slave&lt;/code&gt; and ioredis will try to connect to a random slave of the specified master, with the guarantee that the connected node is always a slave. If the current node is promoted to master due to a failover, ioredis will disconnect from it and ask the sentinels for another slave node to connect to.&lt;/p&gt; &#xA;&lt;p&gt;If you specify the option &lt;code&gt;preferredSlaves&lt;/code&gt; along with &lt;code&gt;role: &#39;slave&#39;&lt;/code&gt; ioredis will attempt to use this value when selecting the slave from the pool of available slaves. The value of &lt;code&gt;preferredSlaves&lt;/code&gt; should either be a function that accepts an array of available slaves and returns a single result, or an array of slave values priorities by the lowest &lt;code&gt;prio&lt;/code&gt; value first with a default value of &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// available slaves format&#xA;const availableSlaves = [{ ip: &#34;127.0.0.1&#34;, port: &#34;31231&#34;, flags: &#34;slave&#34; }];&#xA;&#xA;// preferredSlaves array format&#xA;let preferredSlaves = [&#xA;  { ip: &#34;127.0.0.1&#34;, port: &#34;31231&#34;, prio: 1 },&#xA;  { ip: &#34;127.0.0.1&#34;, port: &#34;31232&#34;, prio: 2 },&#xA;];&#xA;&#xA;// preferredSlaves function format&#xA;preferredSlaves = function (availableSlaves) {&#xA;  for (let i = 0; i &amp;lt; availableSlaves.length; i++) {&#xA;    const slave = availableSlaves[i];&#xA;    if (slave.ip === &#34;127.0.0.1&#34;) {&#xA;      if (slave.port === &#34;31234&#34;) {&#xA;        return slave;&#xA;      }&#xA;    }&#xA;  }&#xA;  // if no preferred slaves are available a random one is used&#xA;  return false;&#xA;};&#xA;&#xA;const redis = new Redis({&#xA;  sentinels: [&#xA;    { host: &#34;127.0.0.1&#34;, port: 26379 },&#xA;    { host: &#34;127.0.0.1&#34;, port: 26380 },&#xA;  ],&#xA;  name: &#34;mymaster&#34;,&#xA;  role: &#34;slave&#34;,&#xA;  preferredSlaves: preferredSlaves,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Besides the &lt;code&gt;retryStrategy&lt;/code&gt; option, there&#39;s also a &lt;code&gt;sentinelRetryStrategy&lt;/code&gt; in Sentinel mode which will be invoked when all the sentinel nodes are unreachable during connecting. If &lt;code&gt;sentinelRetryStrategy&lt;/code&gt; returns a valid delay time, ioredis will try to reconnect from scratch. The default value of &lt;code&gt;sentinelRetryStrategy&lt;/code&gt; is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function (times) {&#xA;  const delay = Math.min(times * 10, 1000);&#xA;  return delay;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Cluster&lt;/h2&gt; &#xA;&lt;p&gt;Redis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes. You can connect to a Redis Cluster like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Redis = require(&#34;ioredis&#34;);&#xA;&#xA;const cluster = new Redis.Cluster([&#xA;  {&#xA;    port: 6380,&#xA;    host: &#34;127.0.0.1&#34;,&#xA;  },&#xA;  {&#xA;    port: 6381,&#xA;    host: &#34;127.0.0.1&#34;,&#xA;  },&#xA;]);&#xA;&#xA;cluster.set(&#34;foo&#34;, &#34;bar&#34;);&#xA;cluster.get(&#34;foo&#34;, (err, res) =&amp;gt; {&#xA;  // res === &#39;bar&#39;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Cluster&lt;/code&gt; constructor accepts two arguments, where:&lt;/p&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;The first argument is a list of nodes of the cluster you want to connect to. Just like Sentinel, the list does not need to enumerate all your cluster nodes, but a few so that if one is unreachable the client will try the next one, and the client will discover other nodes automatically when at least one node is connected.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The second argument is the options, where:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;clusterRetryStrategy&lt;/code&gt;: When none of the startup nodes are reachable, &lt;code&gt;clusterRetryStrategy&lt;/code&gt; will be invoked. When a number is returned, ioredis will try to reconnect to the startup nodes from scratch after the specified delay (in ms). Otherwise, an error of &#34;None of startup nodes is available&#34; will be returned. The default value of this option is:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function (times) {&#xA;  const delay = Math.min(100 + times * 2, 2000);&#xA;  return delay;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;It&#39;s possible to modify the &lt;code&gt;startupNodes&lt;/code&gt; property in order to switch to another set of nodes here:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function (times) {&#xA;  this.startupNodes = [{ port: 6790, host: &#39;127.0.0.1&#39; }];&#xA;  return Math.min(100 + times * 2, 2000);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;dnsLookup&lt;/code&gt;: Alternative DNS lookup function (&lt;code&gt;dns.lookup()&lt;/code&gt; is used by default). It may be useful to override this in special cases, such as when AWS ElastiCache used with TLS enabled.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;enableOfflineQueue&lt;/code&gt;: Similar to the &lt;code&gt;enableOfflineQueue&lt;/code&gt; option of &lt;code&gt;Redis&lt;/code&gt; class.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;enableReadyCheck&lt;/code&gt;: When enabled, &#34;ready&#34; event will only be emitted when &lt;code&gt;CLUSTER INFO&lt;/code&gt; command reporting the cluster is ready for handling commands. Otherwise, it will be emitted immediately after &#34;connect&#34; is emitted.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;scaleReads&lt;/code&gt;: Config where to send the read queries. See below for more details.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;maxRedirections&lt;/code&gt;: When a cluster related error (e.g. &lt;code&gt;MOVED&lt;/code&gt;, &lt;code&gt;ASK&lt;/code&gt; and &lt;code&gt;CLUSTERDOWN&lt;/code&gt; etc.) is received, the client will redirect the command to another node. This option limits the max redirections allowed when sending a command. The default value is &lt;code&gt;16&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;retryDelayOnFailover&lt;/code&gt;: If the target node is disconnected when sending a command, ioredis will retry after the specified delay. The default value is &lt;code&gt;100&lt;/code&gt;. You should make sure &lt;code&gt;retryDelayOnFailover * maxRedirections &amp;gt; cluster-node-timeout&lt;/code&gt; to insure that no command will fail during a failover.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;retryDelayOnClusterDown&lt;/code&gt;: When a cluster is down, all commands will be rejected with the error of &lt;code&gt;CLUSTERDOWN&lt;/code&gt;. If this option is a number (by default, it is &lt;code&gt;100&lt;/code&gt;), the client will resend the commands after the specified time (in ms).&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;retryDelayOnTryAgain&lt;/code&gt;: If this option is a number (by default, it is &lt;code&gt;100&lt;/code&gt;), the client will resend the commands rejected with &lt;code&gt;TRYAGAIN&lt;/code&gt; error after the specified time (in ms).&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;retryDelayOnMoved&lt;/code&gt;: By default, this value is &lt;code&gt;0&lt;/code&gt; (in ms), which means when a &lt;code&gt;MOVED&lt;/code&gt; error is received, the client will resend the command instantly to the node returned together with the &lt;code&gt;MOVED&lt;/code&gt; error. However, sometimes it takes time for a cluster to become state stabilized after a failover, so adding a delay before resending can prevent a ping pong effect.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;redisOptions&lt;/code&gt;: Default options passed to the constructor of &lt;code&gt;Redis&lt;/code&gt; when connecting to a node.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;slotsRefreshTimeout&lt;/code&gt;: Milliseconds before a timeout occurs while refreshing slots from the cluster (default &lt;code&gt;1000&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;slotsRefreshInterval&lt;/code&gt;: Milliseconds between every automatic slots refresh (by default, it is disabled).&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Read-Write Splitting&lt;/h3&gt; &#xA;&lt;p&gt;A typical redis cluster contains three or more masters and several slaves for each master. It&#39;s possible to scale out redis cluster by sending read queries to slaves and write queries to masters by setting the &lt;code&gt;scaleReads&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;scaleReads&lt;/code&gt; is &#34;master&#34; by default, which means ioredis will never send any queries to slaves. There are other three available options:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&#34;all&#34;: Send write queries to masters and read queries to masters or slaves randomly.&lt;/li&gt; &#xA; &lt;li&gt;&#34;slave&#34;: Send write queries to masters and read queries to slaves.&lt;/li&gt; &#xA; &lt;li&gt;a custom &lt;code&gt;function(nodes, command): node&lt;/code&gt;: Will choose the custom function to select to which node to send read queries (write queries keep being sent to master). The first node in &lt;code&gt;nodes&lt;/code&gt; is always the master serving the relevant slots. If the function returns an array of nodes, a random node of that list will be selected.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const cluster = new Redis.Cluster(&#xA;  [&#xA;    /* nodes */&#xA;  ],&#xA;  {&#xA;    scaleReads: &#34;slave&#34;,&#xA;  }&#xA;);&#xA;cluster.set(&#34;foo&#34;, &#34;bar&#34;); // This query will be sent to one of the masters.&#xA;cluster.get(&#34;foo&#34;, (err, res) =&amp;gt; {&#xA;  // This query will be sent to one of the slaves.&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NB&lt;/strong&gt; In the code snippet above, the &lt;code&gt;res&lt;/code&gt; may not be equal to &#34;bar&#34; because of the lag of replication between the master and slaves.&lt;/p&gt; &#xA;&lt;h3&gt;Running Commands to Multiple Nodes&lt;/h3&gt; &#xA;&lt;p&gt;Every command will be sent to exactly one node. For commands containing keys, (e.g. &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt; and &lt;code&gt;HGETALL&lt;/code&gt;), ioredis sends them to the node that serving the keys, and for other commands not containing keys, (e.g. &lt;code&gt;INFO&lt;/code&gt;, &lt;code&gt;KEYS&lt;/code&gt; and &lt;code&gt;FLUSHDB&lt;/code&gt;), ioredis sends them to a random node.&lt;/p&gt; &#xA;&lt;p&gt;Sometimes you may want to send a command to multiple nodes (masters or slaves) of the cluster, you can get the nodes via &lt;code&gt;Cluster#nodes()&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Cluster#nodes()&lt;/code&gt; accepts a parameter role, which can be &#34;master&#34;, &#34;slave&#34; and &#34;all&#34; (default), and returns an array of &lt;code&gt;Redis&lt;/code&gt; instance. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Send `FLUSHDB` command to all slaves:&#xA;const slaves = cluster.nodes(&#34;slave&#34;);&#xA;Promise.all(slaves.map((node) =&amp;gt; node.flushdb()));&#xA;&#xA;// Get keys of all the masters:&#xA;const masters = cluster.nodes(&#34;master&#34;);&#xA;Promise.all(&#xA;  masters&#xA;    .map((node) =&amp;gt; node.keys())&#xA;    .then((keys) =&amp;gt; {&#xA;      // keys: [[&#39;key1&#39;, &#39;key2&#39;], [&#39;key3&#39;, &#39;key4&#39;]]&#xA;    })&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;NAT Mapping&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes the cluster is hosted within a internal network that can only be accessed via a NAT (Network Address Translation) instance. See &lt;a href=&#34;https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/accessing-elasticache.html&#34;&gt;Accessing ElastiCache from outside AWS&lt;/a&gt; as an example.&lt;/p&gt; &#xA;&lt;p&gt;You can specify nat mapping rules via &lt;code&gt;natMap&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const cluster = new Redis.Cluster(&#xA;  [&#xA;    {&#xA;      host: &#34;203.0.113.73&#34;,&#xA;      port: 30001,&#xA;    },&#xA;  ],&#xA;  {&#xA;    natMap: {&#xA;      &#34;10.0.1.230:30001&#34;: { host: &#34;203.0.113.73&#34;, port: 30001 },&#xA;      &#34;10.0.1.231:30001&#34;: { host: &#34;203.0.113.73&#34;, port: 30002 },&#xA;      &#34;10.0.1.232:30001&#34;: { host: &#34;203.0.113.73&#34;, port: 30003 },&#xA;    },&#xA;  }&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This option is also useful when the cluster is running inside a Docker container.&lt;/p&gt; &#xA;&lt;h3&gt;Transaction and Pipeline in Cluster Mode&lt;/h3&gt; &#xA;&lt;p&gt;Almost all features that are supported by &lt;code&gt;Redis&lt;/code&gt; are also supported by &lt;code&gt;Redis.Cluster&lt;/code&gt;, e.g. custom commands, transaction and pipeline. However there are some differences when using transaction and pipeline in Cluster mode:&lt;/p&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;All keys in a pipeline should belong to slots served by the same node, since ioredis sends all commands in a pipeline to the same node.&lt;/li&gt; &#xA; &lt;li&gt;You can&#39;t use &lt;code&gt;multi&lt;/code&gt; without pipeline (aka &lt;code&gt;cluster.multi({ pipeline: false })&lt;/code&gt;). This is because when you call &lt;code&gt;cluster.multi({ pipeline: false })&lt;/code&gt;, ioredis doesn&#39;t know which node the &lt;code&gt;multi&lt;/code&gt; command should be sent to.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;When any commands in a pipeline receives a &lt;code&gt;MOVED&lt;/code&gt; or &lt;code&gt;ASK&lt;/code&gt; error, ioredis will resend the whole pipeline to the specified node automatically if all of the following conditions are satisfied:&lt;/p&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;All errors received in the pipeline are the same. For example, we won&#39;t resend the pipeline if we got two &lt;code&gt;MOVED&lt;/code&gt; errors pointing to different nodes.&lt;/li&gt; &#xA; &lt;li&gt;All commands executed successfully are readonly commands. This makes sure that resending the pipeline won&#39;t have side effects.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Pub/Sub&lt;/h3&gt; &#xA;&lt;p&gt;Pub/Sub in cluster mode works exactly as the same as in standalone mode. Internally, when a node of the cluster receives a message, it will broadcast the message to the other nodes. ioredis makes sure that each message will only be received once by strictly subscribing one node at the same time.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const nodes = [&#xA;  /* nodes */&#xA;];&#xA;const pub = new Redis.Cluster(nodes);&#xA;const sub = new Redis.Cluster(nodes);&#xA;sub.on(&#34;message&#34;, (channel, message) =&amp;gt; {&#xA;  console.log(channel, message);&#xA;});&#xA;&#xA;sub.subscribe(&#34;news&#34;, () =&amp;gt; {&#xA;  pub.publish(&#34;news&#34;, &#34;highlights&#34;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Events&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Event&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;connect&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits when a connection is established to the Redis server.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;ready&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits when &lt;code&gt;CLUSTER INFO&lt;/code&gt; reporting the cluster is able to receive commands (if &lt;code&gt;enableReadyCheck&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;) or immediately after &lt;code&gt;connect&lt;/code&gt; event (if &lt;code&gt;enableReadyCheck&lt;/code&gt; is false).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;error&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits when an error occurs while connecting with a property of &lt;code&gt;lastNodeError&lt;/code&gt; representing the last node error received. This event is emitted silently (only emitting if there&#39;s at least one listener).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;close&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits when an established Redis server connection has closed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;reconnecting&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits after &lt;code&gt;close&lt;/code&gt; when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;end&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits after &lt;code&gt;close&lt;/code&gt; when no more reconnections will be made.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;+node&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits when a new node is connected.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;-node&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits when a node is disconnected.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;node error&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;emits when an error occurs when connecting to a node. The second argument indicates the address of the node.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Password&lt;/h3&gt; &#xA;&lt;p&gt;Setting the &lt;code&gt;password&lt;/code&gt; option to access password-protected clusters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Redis = require(&#34;ioredis&#34;);&#xA;const cluster = new Redis.Cluster(nodes, {&#xA;  redisOptions: {&#xA;    password: &#34;your-cluster-password&#34;,&#xA;  },&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If some of nodes in the cluster using a different password, you should specify them in the first parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Redis = require(&#34;ioredis&#34;);&#xA;const cluster = new Redis.Cluster(&#xA;  [&#xA;    // Use password &#34;password-for-30001&#34; for 30001&#xA;    { port: 30001, password: &#34;password-for-30001&#34; },&#xA;    // Don&#39;t use password when accessing 30002&#xA;    { port: 30002, password: null },&#xA;    // Other nodes will use &#34;fallback-password&#34;&#xA;  ],&#xA;  {&#xA;    redisOptions: {&#xA;      password: &#34;fallback-password&#34;,&#xA;    },&#xA;  }&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Special Note: Aws Elasticache Clusters with TLS&lt;/h3&gt; &#xA;&lt;p&gt;AWS ElastiCache for Redis (Clustered Mode) supports TLS encryption. If you use this, you may encounter errors with invalid certificates. To resolve this issue, construct the &lt;code&gt;Cluster&lt;/code&gt; with the &lt;code&gt;dnsLookup&lt;/code&gt; option as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const cluster = new Redis.Cluster(&#xA;  [&#xA;    {&#xA;      host: &#34;clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com&#34;,&#xA;      port: 6379,&#xA;    },&#xA;  ],&#xA;  {&#xA;    dnsLookup: (address, callback) =&amp;gt; callback(null, address),&#xA;    redisOptions: {&#xA;      tls: {},&#xA;    },&#xA;  }&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Autopipelining&lt;/h2&gt; &#xA;&lt;p&gt;In standard mode, when you issue multiple commands, ioredis sends them to the server one by one. As described in Redis pipeline documentation, this is a suboptimal use of the network link, especially when such link is not very performant.&lt;/p&gt; &#xA;&lt;p&gt;The TCP and network overhead negatively affects performance. Commands are stuck in the send queue until the previous ones are correctly delivered to the server. This is a problem known as Head-Of-Line blocking (HOL).&lt;/p&gt; &#xA;&lt;p&gt;ioredis supports a feature called ‚Äúauto pipelining‚Äù. It can be enabled by setting the option &lt;code&gt;enableAutoPipelining&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. No other code change is necessary.&lt;/p&gt; &#xA;&lt;p&gt;In auto pipelining mode, all commands issued during an event loop are enqueued in a pipeline automatically managed by ioredis. At the end of the iteration, the pipeline is executed and thus all commands are sent to the server at the same time.&lt;/p&gt; &#xA;&lt;p&gt;This feature can dramatically improve throughput and avoids HOL blocking. In our benchmarks, the improvement was between 35% and 50%.&lt;/p&gt; &#xA;&lt;p&gt;While an automatic pipeline is executing, all new commands will be enqueued in a new pipeline which will be executed as soon as the previous finishes.&lt;/p&gt; &#xA;&lt;p&gt;When using Redis Cluster, one pipeline per node is created. Commands are assigned to pipelines according to which node serves the slot.&lt;/p&gt; &#xA;&lt;p&gt;A pipeline will thus contain commands using different slots but that ultimately are assigned to the same node.&lt;/p&gt; &#xA;&lt;p&gt;Note that the same slot limitation within a single command still holds, as it is a Redis limitation.&lt;/p&gt; &#xA;&lt;h3&gt;Example of Automatic Pipeline Enqueuing&lt;/h3&gt; &#xA;&lt;p&gt;This sample code uses ioredis with automatic pipeline enabled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Redis = require(&#34;./built&#34;);&#xA;const http = require(&#34;http&#34;);&#xA;&#xA;const db = new Redis({ enableAutoPipelining: true });&#xA;&#xA;const server = http.createServer((request, response) =&amp;gt; {&#xA;  const key = new URL(request.url, &#34;https://localhost:3000/&#34;).searchParams.get(&#xA;    &#34;key&#34;&#xA;  );&#xA;&#xA;  db.get(key, (err, value) =&amp;gt; {&#xA;    response.writeHead(200, { &#34;Content-Type&#34;: &#34;text/plain&#34; });&#xA;    response.end(value);&#xA;  });&#xA;});&#xA;&#xA;server.listen(3000);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When Node receives requests, it schedules them to be processed in one or more iterations of the events loop.&lt;/p&gt; &#xA;&lt;p&gt;All commands issued by requests processing during one iteration of the loop will be wrapped in a pipeline automatically created by ioredis.&lt;/p&gt; &#xA;&lt;p&gt;In the example above, the pipeline will have the following contents:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;GET key1&#xA;GET key2&#xA;GET key3&#xA;...&#xA;GET keyN&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When all events in the current loop have been processed, the pipeline is executed and thus all commands are sent to the server at the same time.&lt;/p&gt; &#xA;&lt;p&gt;While waiting for pipeline response from Redis, Node will still be able to process requests. All commands issued by request handler will be enqueued in a new automatically created pipeline. This pipeline will not be sent to the server yet.&lt;/p&gt; &#xA;&lt;p&gt;As soon as a previous automatic pipeline has received all responses from the server, the new pipeline is immediately sent without waiting for the events loop iteration to finish.&lt;/p&gt; &#xA;&lt;p&gt;This approach increases the utilization of the network link, reduces the TCP overhead and idle times and therefore improves throughput.&lt;/p&gt; &#xA;&lt;h3&gt;Benchmarks&lt;/h3&gt; &#xA;&lt;p&gt;Here&#39;s some of the results of our tests for a single node.&lt;/p&gt; &#xA;&lt;p&gt;Each iteration of the test runs 1000 random commands on the server.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;   &lt;th&gt;Samples&lt;/th&gt; &#xA;   &lt;th&gt;Result&lt;/th&gt; &#xA;   &lt;th&gt;Tolerance&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;default&lt;/td&gt; &#xA;   &lt;td&gt;1000&lt;/td&gt; &#xA;   &lt;td&gt;174.62 op/sec&lt;/td&gt; &#xA;   &lt;td&gt;¬± 0.45 %&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;enableAutoPipelining=true&lt;/td&gt; &#xA;   &lt;td&gt;1500&lt;/td&gt; &#xA;   &lt;td&gt;233.33 op/sec&lt;/td&gt; &#xA;   &lt;td&gt;¬± 0.88 %&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;And here&#39;s the same test for a cluster of 3 masters and 3 replicas:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;   &lt;th&gt;Samples&lt;/th&gt; &#xA;   &lt;th&gt;Result&lt;/th&gt; &#xA;   &lt;th&gt;Tolerance&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;default&lt;/td&gt; &#xA;   &lt;td&gt;1000&lt;/td&gt; &#xA;   &lt;td&gt;164.05 op/sec&lt;/td&gt; &#xA;   &lt;td&gt;¬± 0.42 %&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;enableAutoPipelining=true&lt;/td&gt; &#xA;   &lt;td&gt;3000&lt;/td&gt; &#xA;   &lt;td&gt;235.31 op/sec&lt;/td&gt; &#xA;   &lt;td&gt;¬± 0.94 %&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Error Handling&lt;/h1&gt; &#xA;&lt;p&gt;All the errors returned by the Redis server are instances of &lt;code&gt;ReplyError&lt;/code&gt;, which can be accessed via &lt;code&gt;Redis&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Redis = require(&#34;ioredis&#34;);&#xA;const redis = new Redis();&#xA;// This command causes a reply error since the SET command requires two arguments.&#xA;redis.set(&#34;foo&#34;, (err) =&amp;gt; {&#xA;  err instanceof Redis.ReplyError;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is the error stack of the &lt;code&gt;ReplyError&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ReplyError: ERR wrong number of arguments for &#39;set&#39; command&#xA;    at ReplyParser._parseResult (/app/node_modules/ioredis/lib/parsers/javascript.js:60:14)&#xA;    at ReplyParser.execute (/app/node_modules/ioredis/lib/parsers/javascript.js:178:20)&#xA;    at Socket.&amp;lt;anonymous&amp;gt; (/app/node_modules/ioredis/lib/redis/event_handler.js:99:22)&#xA;    at Socket.emit (events.js:97:17)&#xA;    at readableAddChunk (_stream_readable.js:143:16)&#xA;    at Socket.Readable.push (_stream_readable.js:106:10)&#xA;    at TCP.onread (net.js:509:20)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the error stack doesn&#39;t make any sense because the whole stack happens in the ioredis module itself, not in your code. So it&#39;s not easy to find out where the error happens in your code. ioredis provides an option &lt;code&gt;showFriendlyErrorStack&lt;/code&gt; to solve the problem. When you enable &lt;code&gt;showFriendlyErrorStack&lt;/code&gt;, ioredis will optimize the error stack for you:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Redis = require(&#34;ioredis&#34;);&#xA;const redis = new Redis({ showFriendlyErrorStack: true });&#xA;redis.set(&#34;foo&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And the output will be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ReplyError: ERR wrong number of arguments for &#39;set&#39; command&#xA;    at Object.&amp;lt;anonymous&amp;gt; (/app/index.js:3:7)&#xA;    at Module._compile (module.js:446:26)&#xA;    at Object.Module._extensions..js (module.js:464:10)&#xA;    at Module.load (module.js:341:32)&#xA;    at Function.Module._load (module.js:296:12)&#xA;    at Function.Module.runMain (module.js:487:10)&#xA;    at startup (node.js:111:16)&#xA;    at node.js:799:3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This time the stack tells you that the error happens on the third line in your code. Pretty sweet! However, it would decrease the performance significantly to optimize the error stack. So by default, this option is disabled and can only be used for debugging purposes. You &lt;strong&gt;shouldn&#39;t&lt;/strong&gt; use this feature in a production environment.&lt;/p&gt; &#xA;&lt;h1&gt;Running tests&lt;/h1&gt; &#xA;&lt;p&gt;Start a Redis server on 127.0.0.1:6379, and then:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;FLUSH ALL&lt;/code&gt; will be invoked after each test, so make sure there&#39;s no valuable data in it before running tests.&lt;/p&gt; &#xA;&lt;p&gt;If your testing environment does not let you spin up a Redis server &lt;a href=&#34;https://github.com/stipsan/ioredis-mock&#34;&gt;ioredis-mock&lt;/a&gt; is a drop-in replacement you can use in your tests. It aims to behave identically to ioredis connected to a Redis server so that your integration tests is easier to write and of better quality.&lt;/p&gt; &#xA;&lt;h1&gt;Debug&lt;/h1&gt; &#xA;&lt;p&gt;You can set the &lt;code&gt;DEBUG&lt;/code&gt; env to &lt;code&gt;ioredis:*&lt;/code&gt; to print debug info:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ DEBUG=ioredis:* node app.js&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Join in!&lt;/h1&gt; &#xA;&lt;p&gt;I&#39;m happy to receive bug reports, fixes, documentation enhancements, and any other improvements.&lt;/p&gt; &#xA;&lt;p&gt;And since I&#39;m not a native English speaker, if you find any grammar mistakes in the documentation, please also let me know. :)&lt;/p&gt; &#xA;&lt;h1&gt;Contributors&lt;/h1&gt; &#xA;&lt;p&gt;This project exists thanks to all the people who contribute:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/redis/ioredis/graphs/contributors&#34;&gt;&lt;img src=&#34;https://opencollective.com/ioredis/contributors.svg?width=890&amp;amp;showBtn=false&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;MIT&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://app.fossa.io/projects/git%2Bgithub.com%2Fluin%2Fioredis?ref=badge_large&#34;&gt;&lt;img src=&#34;https://app.fossa.io/api/projects/git%2Bgithub.com%2Fluin%2Fioredis.svg?type=large&#34; alt=&#34;FOSSA Status&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>peter-evans/create-pull-request</title>
    <updated>2024-03-01T01:40:40Z</updated>
    <id>tag:github.com,2024-03-01:/peter-evans/create-pull-request</id>
    <link href="https://github.com/peter-evans/create-pull-request" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A GitHub action to create a pull request for changes to your repository in the actions workspace&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;img width=&#34;24&#34; height=&#34;24&#34; src=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/docs/assets/logo.svg?sanitize=true&#34;&gt; Create Pull Request&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/peter-evans/create-pull-request/actions?query=workflow%3ACI&#34;&gt;&lt;img src=&#34;https://github.com/peter-evans/create-pull-request/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/marketplace/actions/create-pull-request&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Marketplace-Create%20Pull%20Request-blue.svg?colorA=24292e&amp;amp;colorB=0366d6&amp;amp;style=flat&amp;amp;longCache=true&amp;amp;logo=github&#34; alt=&#34;GitHub Marketplace&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A GitHub action to create a pull request for changes to your repository in the actions workspace.&lt;/p&gt; &#xA;&lt;p&gt;Changes to a repository in the Actions workspace persist between steps in a workflow. This action is designed to be used in conjunction with other steps that modify or add files to your repository. The changes will be automatically committed to a new branch and a pull request created.&lt;/p&gt; &#xA;&lt;p&gt;Create Pull Request action will:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Check for repository changes in the Actions workspace. This includes: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;untracked (new) files&lt;/li&gt; &#xA;   &lt;li&gt;tracked (modified) files&lt;/li&gt; &#xA;   &lt;li&gt;commits made during the workflow that have not been pushed&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Commit all changes to a new branch, or update an existing pull request branch.&lt;/li&gt; &#xA; &lt;li&gt;Create a pull request to merge the new branch into the base‚Äîthe branch checked out in the workflow.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/docs/concepts-guidelines.md&#34;&gt;Concepts, guidelines and advanced usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/docs/examples.md&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/docs/updating.md&#34;&gt;Updating to v6&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/docs/common-issues.md&#34;&gt;Common issues&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;      - uses: actions/checkout@v4&#xA;&#xA;      # Make changes to pull request here&#xA;&#xA;      - name: Create Pull Request&#xA;        uses: peter-evans/create-pull-request@v6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also pin to a &lt;a href=&#34;https://github.com/peter-evans/create-pull-request/releases&#34;&gt;specific release&lt;/a&gt; version in the format &lt;code&gt;@v6.x.x&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Workflow permissions&lt;/h3&gt; &#xA;&lt;p&gt;For this action to work you must explicitly allow GitHub Actions to create pull requests. This setting can be found in a repository&#39;s settings under Actions &amp;gt; General &amp;gt; Workflow permissions.&lt;/p&gt; &#xA;&lt;p&gt;For repositories belonging to an organization, this setting can be managed by admins in organization settings under Actions &amp;gt; General &amp;gt; Workflow permissions.&lt;/p&gt; &#xA;&lt;h3&gt;Action inputs&lt;/h3&gt; &#xA;&lt;p&gt;All inputs are &lt;strong&gt;optional&lt;/strong&gt;. If not set, sensible defaults will be used.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: If you want pull requests created by this action to trigger an &lt;code&gt;on: push&lt;/code&gt; or &lt;code&gt;on: pull_request&lt;/code&gt; workflow then you cannot use the default &lt;code&gt;GITHUB_TOKEN&lt;/code&gt;. See the &lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/docs/concepts-guidelines.md#triggering-further-workflow-runs&#34;&gt;documentation here&lt;/a&gt; for workarounds.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Default&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;token&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;GITHUB_TOKEN&lt;/code&gt; (permissions &lt;code&gt;contents: write&lt;/code&gt; and &lt;code&gt;pull-requests: write&lt;/code&gt;) or a &lt;code&gt;repo&lt;/code&gt; scoped &lt;a href=&#34;https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token&#34;&gt;Personal Access Token (PAT)&lt;/a&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;GITHUB_TOKEN&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;git-token&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The &lt;a href=&#34;https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token&#34;&gt;Personal Access Token (PAT)&lt;/a&gt; that the action will use for git operations.&lt;/td&gt; &#xA;   &lt;td&gt;Defaults to the value of &lt;code&gt;token&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;path&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Relative path under &lt;code&gt;GITHUB_WORKSPACE&lt;/code&gt; to the repository.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;GITHUB_WORKSPACE&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;add-paths&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A comma or newline-separated list of file paths to commit. Paths should follow git&#39;s &lt;a href=&#34;https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefpathspecapathspec&#34;&gt;pathspec&lt;/a&gt; syntax. If no paths are specified, all new and modified files are added. See &lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/#add-specific-paths&#34;&gt;Add specific paths&lt;/a&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;commit-message&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The message to use when committing changes. See &lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/#commit-message&#34;&gt;commit-message&lt;/a&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;[create-pull-request] automated change&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;committer&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The committer name and email address in the format &lt;code&gt;Display Name &amp;lt;email@address.com&amp;gt;&lt;/code&gt;. Defaults to the GitHub Actions bot user.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;github-actions[bot] &amp;lt;41898282+github-actions[bot]@users.noreply.github.com&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;author&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The author name and email address in the format &lt;code&gt;Display Name &amp;lt;email@address.com&amp;gt;&lt;/code&gt;. Defaults to the user who triggered the workflow run.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;${{ github.actor }} &amp;lt;${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;signoff&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Add &lt;a href=&#34;https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---signoff&#34;&gt;&lt;code&gt;Signed-off-by&lt;/code&gt;&lt;/a&gt; line by the committer at the end of the commit log message.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;branch&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The pull request branch name.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;create-pull-request/patch&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;delete-branch&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Delete the &lt;code&gt;branch&lt;/code&gt; if it doesn&#39;t have an active pull request associated with it. See &lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/#delete-branch&#34;&gt;delete-branch&lt;/a&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;branch-suffix&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The branch suffix type when using the alternative branching strategy. Valid values are &lt;code&gt;random&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt; and &lt;code&gt;short-commit-hash&lt;/code&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/#alternative-strategy---always-create-a-new-pull-request-branch&#34;&gt;Alternative strategy&lt;/a&gt; for details.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;base&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Sets the pull request base branch.&lt;/td&gt; &#xA;   &lt;td&gt;Defaults to the branch checked out in the workflow.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;push-to-fork&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A fork of the checked-out parent repository to which the pull request branch will be pushed. e.g. &lt;code&gt;owner/repo-fork&lt;/code&gt;. The pull request will be created to merge the fork&#39;s branch into the parent&#39;s base. See &lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/docs/concepts-guidelines.md#push-pull-request-branches-to-a-fork&#34;&gt;push pull request branches to a fork&lt;/a&gt; for details.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;title&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The title of the pull request.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Changes by create-pull-request action&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;body&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The body of the pull request.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Automated changes by [create-pull-request](https://github.com/peter-evans/create-pull-request) GitHub action&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;body-path&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The path to a file containing the pull request body. Takes precedence over &lt;code&gt;body&lt;/code&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A comma or newline-separated list of labels.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;assignees&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A comma or newline-separated list of assignees (GitHub usernames).&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;reviewers&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A comma or newline-separated list of reviewers (GitHub usernames) to request a review from.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;team-reviewers&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A comma or newline-separated list of GitHub teams to request a review from. Note that a &lt;code&gt;repo&lt;/code&gt; scoped &lt;a href=&#34;https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token&#34;&gt;PAT&lt;/a&gt;, or equivalent &lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/docs/concepts-guidelines.md#authenticating-with-github-app-generated-tokens&#34;&gt;GitHub App permissions&lt;/a&gt;, are required.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;milestone&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The number of the milestone to associate this pull request with.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;draft&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Create a &lt;a href=&#34;https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests#draft-pull-requests&#34;&gt;draft pull request&lt;/a&gt;. It is not possible to change draft status after creation except through the web interface.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;commit-message&lt;/h4&gt; &#xA;&lt;p&gt;In addition to a message, the &lt;code&gt;commit-message&lt;/code&gt; input can also be used to populate the commit description. Leave a single blank line between the message and description.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;          commit-message: |&#xA;            the first line is the commit message&#xA;&#xA;            the commit description starts&#xA;            after a blank line and can be&#xA;            multiple lines&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;delete-branch&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;delete-branch&lt;/code&gt; feature doesn&#39;t delete branches immediately on merge. (It can&#39;t do that because it would require the merge to somehow trigger the action.) The intention of the feature is that when the action next runs it will delete the &lt;code&gt;branch&lt;/code&gt; if it doesn&#39;t have an active pull request associated with it.&lt;/p&gt; &#xA;&lt;p&gt;If you want branches to be deleted immediately on merge then you should use GitHub&#39;s &lt;code&gt;Automatically delete head branches&lt;/code&gt; feature in your repository settings.&lt;/p&gt; &#xA;&lt;h4&gt;Proxy support&lt;/h4&gt; &#xA;&lt;p&gt;For self-hosted runners behind a corporate proxy set the &lt;code&gt;https_proxy&lt;/code&gt; environment variable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;      - name: Create Pull Request&#xA;        uses: peter-evans/create-pull-request@v6&#xA;        env:&#xA;          https_proxy: http://&amp;lt;proxy_address&amp;gt;:&amp;lt;port&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Action outputs&lt;/h3&gt; &#xA;&lt;p&gt;The following outputs can be used by subsequent workflow steps.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;pull-request-number&lt;/code&gt; - The pull request number.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pull-request-url&lt;/code&gt; - The URL of the pull request.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pull-request-operation&lt;/code&gt; - The pull request operation performed by the action, &lt;code&gt;created&lt;/code&gt;, &lt;code&gt;updated&lt;/code&gt; or &lt;code&gt;closed&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pull-request-head-sha&lt;/code&gt; - The commit SHA of the pull request branch.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Step outputs can be accessed as in the following example. Note that in order to read the step outputs the action step must have an id.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;      - name: Create Pull Request&#xA;        id: cpr&#xA;        uses: peter-evans/create-pull-request@v6&#xA;      - name: Check outputs&#xA;        if: ${{ steps.cpr.outputs.pull-request-number }}&#xA;        run: |&#xA;          echo &#34;Pull Request Number - ${{ steps.cpr.outputs.pull-request-number }}&#34;&#xA;          echo &#34;Pull Request URL - ${{ steps.cpr.outputs.pull-request-url }}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Action behaviour&lt;/h3&gt; &#xA;&lt;p&gt;The default behaviour of the action is to create a pull request that will be continually updated with new changes until it is merged or closed. Changes are committed and pushed to a fixed-name branch, the name of which can be configured with the &lt;code&gt;branch&lt;/code&gt; input. Any subsequent changes will be committed to the &lt;em&gt;same&lt;/em&gt; branch and reflected in the open pull request.&lt;/p&gt; &#xA;&lt;p&gt;How the action behaves:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If there are changes (i.e. a diff exists with the checked-out base branch), the changes will be pushed to a new &lt;code&gt;branch&lt;/code&gt; and a pull request created.&lt;/li&gt; &#xA; &lt;li&gt;If there are no changes (i.e. no diff exists with the checked-out base branch), no pull request will be created and the action exits silently.&lt;/li&gt; &#xA; &lt;li&gt;If a pull request already exists it will be updated if necessary. Local changes in the Actions workspace, or changes on the base branch, can cause an update. If no update is required the action exits silently.&lt;/li&gt; &#xA; &lt;li&gt;If a pull request exists and new changes on the base branch make the pull request unnecessary (i.e. there is no longer a diff between the pull request branch and the base), the pull request is automatically closed. Additionally, if &lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/#delete-branch&#34;&gt;&lt;code&gt;delete-branch&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;true&lt;/code&gt; the &lt;code&gt;branch&lt;/code&gt; will be deleted.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For further details about how the action works and usage guidelines, see &lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/docs/concepts-guidelines.md&#34;&gt;Concepts, guidelines and advanced usage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Alternative strategy - Always create a new pull request branch&lt;/h4&gt; &#xA;&lt;p&gt;For some use cases it may be desirable to always create a new unique branch each time there are changes to be committed. This strategy is &lt;em&gt;not recommended&lt;/em&gt; because if not used carefully it could result in multiple pull requests being created unnecessarily. If in doubt, use the &lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/#action-behaviour&#34;&gt;default strategy&lt;/a&gt; of creating an updating a fixed-name branch.&lt;/p&gt; &#xA;&lt;p&gt;To use this strategy, set input &lt;code&gt;branch-suffix&lt;/code&gt; with one of the following options.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;random&lt;/code&gt; - Commits will be made to a branch suffixed with a random alpha-numeric string. e.g. &lt;code&gt;create-pull-request/patch-6qj97jr&lt;/code&gt;, &lt;code&gt;create-pull-request/patch-5jrjhvd&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;timestamp&lt;/code&gt; - Commits will be made to a branch suffixed by a timestamp. e.g. &lt;code&gt;create-pull-request/patch-1569322532&lt;/code&gt;, &lt;code&gt;create-pull-request/patch-1569322552&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;short-commit-hash&lt;/code&gt; - Commits will be made to a branch suffixed with the short SHA1 commit hash. e.g. &lt;code&gt;create-pull-request/patch-fcdfb59&lt;/code&gt;, &lt;code&gt;create-pull-request/patch-394710b&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Controlling committed files&lt;/h3&gt; &#xA;&lt;p&gt;The action defaults to adding all new and modified files. If there are files that should not be included in the pull request, you can use the following methods to control the committed content.&lt;/p&gt; &#xA;&lt;h4&gt;Remove files&lt;/h4&gt; &#xA;&lt;p&gt;The most straightforward way to handle unwanted files is simply to remove them in a step before the action runs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;      - run: |&#xA;          rm -rf temp-dir&#xA;          rm temp-file.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Ignore files&lt;/h4&gt; &#xA;&lt;p&gt;If there are files or directories you want to ignore you can simply add them to a &lt;code&gt;.gitignore&lt;/code&gt; file at the root of your repository. The action will respect this file.&lt;/p&gt; &#xA;&lt;h4&gt;Add specific paths&lt;/h4&gt; &#xA;&lt;p&gt;You can control which files are committed with the &lt;code&gt;add-paths&lt;/code&gt; input. Paths should follow git&#39;s &lt;a href=&#34;https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefpathspecapathspec&#34;&gt;pathspec&lt;/a&gt; syntax. File changes that do not match one of the paths will be stashed and restored after the action has completed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;      - name: Create Pull Request&#xA;        uses: peter-evans/create-pull-request@v6&#xA;        with:&#xA;          add-paths: |&#xA;            *.java&#xA;            docs/*.md&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Create your own commits&lt;/h4&gt; &#xA;&lt;p&gt;As well as relying on the action to handle uncommitted changes, you can additionally make your own commits before the action runs. Note that the repository must be checked out on a branch with a remote, it won&#39;t work for &lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/docs/concepts-guidelines.md#events-which-checkout-a-commit&#34;&gt;events which checkout a commit&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;    steps:&#xA;      - uses: actions/checkout@v4&#xA;      - name: Create commits&#xA;        run: |&#xA;          git config user.name &#39;Peter Evans&#39;&#xA;          git config user.email &#39;peter-evans@users.noreply.github.com&#39;&#xA;          date +%s &amp;gt; report.txt&#xA;          git commit -am &#34;Modify tracked file during workflow&#34;&#xA;          date +%s &amp;gt; new-report.txt&#xA;          git add -A&#xA;          git commit -m &#34;Add untracked file during workflow&#34;&#xA;      - name: Uncommitted change&#xA;        run: date +%s &amp;gt; report.txt&#xA;      - name: Create Pull Request&#xA;        uses: peter-evans/create-pull-request@v6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Create a project card&lt;/h3&gt; &#xA;&lt;p&gt;To create a project card for the pull request, pass the &lt;code&gt;pull-request-number&lt;/code&gt; step output to &lt;a href=&#34;https://github.com/peter-evans/create-or-update-project-card&#34;&gt;create-or-update-project-card&lt;/a&gt; action.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;      - name: Create Pull Request&#xA;        id: cpr&#xA;        uses: peter-evans/create-pull-request@v6&#xA;&#xA;      - name: Create or Update Project Card&#xA;        if: ${{ steps.cpr.outputs.pull-request-number }}&#xA;        uses: peter-evans/create-or-update-project-card@v2&#xA;        with:&#xA;          project-name: My project&#xA;          column-name: My column&#xA;          issue-number: ${{ steps.cpr.outputs.pull-request-number }}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Auto-merge&lt;/h3&gt; &#xA;&lt;p&gt;Auto-merge can be enabled on a pull request allowing it to be automatically merged once requirements have been satisfied. See &lt;a href=&#34;https://github.com/peter-evans/enable-pull-request-automerge&#34;&gt;enable-pull-request-automerge&lt;/a&gt; action for usage details.&lt;/p&gt; &#xA;&lt;h2&gt;Reference Example&lt;/h2&gt; &#xA;&lt;p&gt;The following workflow sets many of the action&#39;s inputs for reference purposes. Check the &lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/#action-inputs&#34;&gt;defaults&lt;/a&gt; to avoid setting inputs unnecessarily.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/docs/examples.md&#34;&gt;examples&lt;/a&gt; for more realistic use cases.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;jobs:&#xA;  createPullRequest:&#xA;    runs-on: ubuntu-latest&#xA;    steps:&#xA;      - uses: actions/checkout@v4&#xA;&#xA;      - name: Make changes to pull request&#xA;        run: date +%s &amp;gt; report.txt&#xA;&#xA;      - name: Create Pull Request&#xA;        id: cpr&#xA;        uses: peter-evans/create-pull-request@v6&#xA;        with:&#xA;          token: ${{ secrets.PAT }}&#xA;          commit-message: Update report&#xA;          committer: github-actions[bot] &amp;lt;41898282+github-actions[bot]@users.noreply.github.com&amp;gt;&#xA;          author: ${{ github.actor }} &amp;lt;${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com&amp;gt;&#xA;          signoff: false&#xA;          branch: example-patches&#xA;          delete-branch: true&#xA;          title: &#39;[Example] Update report&#39;&#xA;          body: |&#xA;            Update report&#xA;            - Updated with *today&#39;s* date&#xA;            - Auto-generated by [create-pull-request][1]&#xA;&#xA;            [1]: https://github.com/peter-evans/create-pull-request&#xA;          labels: |&#xA;            report&#xA;            automated pr&#xA;          assignees: peter-evans&#xA;          reviewers: peter-evans&#xA;          team-reviewers: |&#xA;            developers&#xA;            qa-team&#xA;          milestone: 1&#xA;          draft: false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An example based on the above reference configuration creates pull requests that look like this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/docs/assets/pull-request-example.png&#34; alt=&#34;Pull Request Example&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/peter-evans/create-pull-request/main/LICENSE&#34;&gt;MIT&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>razorpay/blade</title>
    <updated>2024-03-01T01:40:40Z</updated>
    <id>tag:github.com,2024-03-01:/razorpay/blade</id>
    <link href="https://github.com/razorpay/blade" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Design System that powers Razorpay&lt;/p&gt;&lt;hr&gt;&lt;br&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;picture&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;./branding/blade-original-dark-mode.min.svg&#34;&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: light)&#34; srcset=&#34;./branding/blade-original.min.svg&#34;&gt; &#xA;  &lt;img width=&#34;450px&#34; alt=&#34;Blade Design System Logo&#34; src=&#34;https://raw.githubusercontent.com/razorpay/blade/master/branding/blade-original.min.svg?sanitize=true&#34;&gt; &#xA; &lt;/picture&gt; &lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://npmjs.org/package/@razorpay/blade&#34;&gt;&lt;img alt=&#34;Blade Latest Version&#34; src=&#34;https://img.shields.io/github/package-json/v/razorpay/blade?style=for-the-badge&amp;amp;labelColor=322&amp;amp;logo=npm&amp;amp;label=@razorpay/Blade&amp;amp;color=darkred&amp;amp;filename=packages%2Fblade%2Fpackage.json&#34;&gt;&lt;/a&gt; &amp;nbsp;&lt;a href=&#34;https://blade.razorpay.com/&#34;&gt;&lt;img alt=&#34;Documentation blade.razorpay.com&#34; src=&#34;https://img.shields.io/badge/Documentation-blade.razorpay.com-0648EF?style=for-the-badge&amp;amp;labelColor=0012AD&amp;amp;logo=readthedocs&amp;amp;logoColor=eee&#34;&gt;&lt;/a&gt; &amp;nbsp;&lt;a href=&#34;https://github.com/razorpay/blade/tree/master/CONTRIBUTING.md&#34;&gt;&lt;img alt=&#34;Discord Join Chat&#34; src=&#34;https://img.shields.io/badge/Contributions-Open-333333?style=for-the-badge&amp;amp;logo=github&amp;amp;logoColor=ffffff&amp;amp;labelColor=111111&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1 aria-hidden=&#34;true&#34;&gt;&lt;/h1&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;Blade is the Design System that powers &lt;a href=&#34;https://razorpay.com/&#34;&gt;Razorpay&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;üîó Links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blade.razorpay.com&#34;&gt;Docs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blade.razorpay.com/?path=/docs/guides-installation--docs&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/razorpay/blade-old&#34;&gt;@razorpay/blade-old&lt;/a&gt; (Deprecated, Private)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;‚ú® Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Cross-Platform (Works Natively on &lt;a href=&#34;https://blade.razorpay.com/?path=/docs/guides-installation--page#%EF%B8%8F-installation&#34;&gt;React Web&lt;/a&gt; and &lt;a href=&#34;https://blade.razorpay.com/?path=/docs/guides-installation--page#react-native-projects&#34;&gt;React Native&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blade.razorpay.com/?path=/docs/guides-theming-theme-playground--page&#34;&gt;White Labelling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blade.razorpay.com/?path=/docs/tokens-css-variables--page&#34;&gt;CSS Variables for non-React Projects&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/razorpay/blade/raw/master/rfcs/2022-04-09-accessibility.md#manual-testing&#34;&gt;Accessible&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Documented &lt;a href=&#34;https://github.com/razorpay/blade/tree/docs/make-docs-pretty/rfcs&#34;&gt;RFCs&lt;/a&gt; and &lt;a href=&#34;https://github.com/razorpay/blade/raw/master/packages/blade/src/components/Alert/_decisions/decisions.md&#34;&gt;API Decisions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üìù License&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under the &lt;a href=&#34;https://github.com/razorpay/blade/raw/master/LICENSE.md&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1 aria-hidden=&#34;true&#34;&gt;&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt;Interested in working with us? Checkout our &lt;a href=&#34;https://razorpay.com/jobs&#34;&gt;Jobs Page&lt;/a&gt; for open roles ü§ó&lt;/p&gt;</summary>
  </entry>
</feed>