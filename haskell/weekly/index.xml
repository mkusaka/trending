<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-16T01:43:02Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>chshersh/iris</title>
    <updated>2022-10-16T01:43:02Z</updated>
    <id>tag:github.com,2022-10-16:/chshersh/iris</id>
    <link href="https://github.com/chshersh/iris" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üåà Haskell CLI Framework supporting Command Line Interface Guidelines&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;iris&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/chshersh/iris/actions&#34;&gt;&lt;img src=&#34;https://github.com/chshersh/iris/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;GitHub CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/iris&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/iris.svg?logo=haskell&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/chshersh/iris/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MPL--2.0-blue.svg?sanitize=true&#34; alt=&#34;MPL-2.0 license&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Iris&lt;/strong&gt; is a Haskell framework for building CLI applications that follow &lt;a href=&#34;https://clig.dev/&#34;&gt;Command Line Interface Guidelines&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üåà Iris (/Ààa…™r…™s/) is a Greek goddess associated with communication, messages, the rainbow, and new endeavors.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;picture&gt; &#xA; &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://raw.githubusercontent.com/chshersh/iris/main/images/iris-dark.png&#34;&gt; &#xA; &lt;source media=&#34;(prefers-color-scheme: light)&#34; srcset=&#34;https://raw.githubusercontent.com/chshersh/iris/main/images/iris-light.png&#34;&gt; &#xA; &lt;img alt=&#34;Iris changing her workflow and hair colour depending on the time of day.&#34; src=&#34;https://raw.githubusercontent.com/chshersh/iris/main/images/iris-dark-always.png&#34;&gt; &#xA;&lt;/picture&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ÑπÔ∏è &lt;strong&gt;DISCLAIMER #1:&lt;/strong&gt; Currently, Iris is in experimental phase and mostly for early adopters. It may lack documentation or have significant breaking changes. We appreciate anyone&#39;s help in improving the documentation! At the same time, the maintainers will strive to provide helpful migration guides.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ÑπÔ∏è &lt;strong&gt;DISCLAIMER #2:&lt;/strong&gt; Iris is developed and maintained in free time by volunteers. The development may continue for decades or may stop tomorrow. You can use &lt;a href=&#34;https://github.com/sponsors/chshersh&#34;&gt;GitHub Sponsorship&lt;/a&gt; to support the development of this project.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Goals&lt;/h2&gt; &#xA;&lt;p&gt;Iris development is guided by the following principles:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Support &lt;a href=&#34;https://clig.dev/&#34;&gt;Command Line Interface Guidelines&lt;/a&gt;.&lt;/strong&gt; Features or changes that violate these guidelines are not accepted in the project.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Beginner-friendliess.&lt;/strong&gt; Haskell beginners should be able to build CLI applications with Iris. Hence, the implementation of Iris API that uses less fancy Haskell features are preferred. When the complexity is justified, the cost of introducing this extra complexity should be mitigated by having better documentation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Reasonable batteries-included.&lt;/strong&gt; Iris is not trying to be minimalistic as possible, it strives to provide out-of-the-box solutions for most common problems. But at the same time, we don&#39;t want to impose unnecessary heavy dependencies.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Excellent documentation.&lt;/strong&gt; Iris documentation should be as helpful as possible in using the framework.&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Currently, Iris may lack documentation but there&#39;s an ongoing effort to improve the situation.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;üß± Iris focuses solely on CLI applications. If you&#39;re interested in building TUI app with Haskell, check out &lt;a href=&#34;https://hackage.haskell.org/package/brick&#34;&gt;brick&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;CLI apps built with Iris offer the following features for end users:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Automatic detection of colouring support in the terminal&lt;/li&gt; &#xA; &lt;li&gt;Ability to check required external tools if you need e.g. &lt;code&gt;curl&lt;/code&gt; or &lt;code&gt;git&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Support for standard CLI options out-of-the-box: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;--help&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;--version&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;--numeric-version&lt;/code&gt;: helpful for detecting required tools versions&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;--no-input&lt;/code&gt;: for disabling all interactive features&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Utilities to open files in a browser&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to use?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;iris&lt;/code&gt; is compatible with the following GHC versions - &lt;a href=&#34;https://matrix.hackage.haskell.org/#/package/iris&#34;&gt;supported versions&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;In order to start using &lt;code&gt;iris&lt;/code&gt; in your project, you will need to set it up with these steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Add the dependency on &lt;code&gt;iris&lt;/code&gt; in your project&#39;s &lt;code&gt;.cabal&lt;/code&gt; file. For this, you should modify the &lt;code&gt;build-depends&lt;/code&gt; section according to the below section:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;build-depends:&#xA;  , base ^&amp;gt;= LATEST_SUPPORTED_BASE&#xA;  , iris ^&amp;gt;= LATEST_VERSION&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To use this package, refer to the below example.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE GeneralizedNewtypeDeriving #-}&#xA;&#xA;module Main (main) where&#xA;&#xA;import Control.Monad.IO.Class (MonadIO (..))&#xA;&#xA;import qualified Iris&#xA;&#xA;&#xA;newtype App a = App&#xA;    { unApp :: Iris.CliApp () () a&#xA;    } deriving newtype&#xA;        ( Functor&#xA;        , Applicative&#xA;        , Monad&#xA;        , MonadIO&#xA;        )&#xA;&#xA;appSettings :: Iris.CliEnvSettings () ()&#xA;appSettings = Iris.defaultCliEnvSettings&#xA;    { Iris.cliEnvSettingsHeaderDesc = &#34;Iris usage example&#34;&#xA;    , Iris.cliEnvSettingsProgDesc = &#34;A simple &#39;Hello, world!&#39; utility&#34;&#xA;    }&#xA;&#xA;app :: App ()&#xA;app = liftIO $ putStrLn &#34;Hello, world!&#34;&#xA;&#xA;main :: IO ()&#xA;main = Iris.runCliApp appSettings $ unApp app&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;For contributors&lt;/h2&gt; &#xA;&lt;p&gt;Check &lt;a href=&#34;https://github.com/chshersh/iris/raw/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for contributing guidelines.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;To build the project and run the tests locally, you can use either &lt;code&gt;cabal&lt;/code&gt; or &lt;code&gt;stack&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/chshersh/iris/main/#first-time&#34;&gt;First time&lt;/a&gt; section if you don&#39;t have Haskell development environment locally.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Cabal&lt;/h3&gt; &#xA;&lt;p&gt;Build the project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cabal build all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run all unit tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cabal test --enable-tests --test-show-details=direct&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stack&lt;/h3&gt; &#xA;&lt;p&gt;Build the project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;stack build --test --no-run-tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run all unit tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;stack test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;First time&lt;/h3&gt; &#xA;&lt;p&gt;If this is your first time dealing with Haskell tooling, we recommend using &lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;GHCup&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;During the installation, GHCup will suggest you installing all the necessary tools. If you have GHCup installed but miss some of the tooling for some reason, type the following commands in the terminal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ghcup install ghc 8.10.7&#xA;ghcup set     ghc 8.10.7&#xA;ghcup install cabal 3.6.2.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If you are using Linux or macOS, you may find &lt;code&gt;ghcup tui&lt;/code&gt; command a more attractive option.&lt;/p&gt; &#xA;&lt;/blockquote&gt;</summary>
  </entry>
  <entry>
    <title>divarvel/hammertime</title>
    <updated>2022-10-16T01:43:02Z</updated>
    <id>tag:github.com,2022-10-16:/divarvel/hammertime</id>
    <link href="https://github.com/divarvel/hammertime" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple time tracker&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/divarvel/hammertime&#34;&gt;&lt;img src=&#34;https://travis-ci.org/divarvel/hammertime.png&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;#Hammertime&lt;/p&gt; &#xA;&lt;p&gt;Hammertime is a simple time-tracker.&lt;/p&gt; &#xA;&lt;p&gt;Please notice that hammertime is more a pet project than a real one. Its main goal is to allow me to write some &#34;Real World&#34; haskell.&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;With cabal&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal configure&#xA;cabal build&#xA;cabal install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;###Start tracking a task&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hammertime start project_name task_name [tags*]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Starting a new task automatically closes the previous.&lt;/p&gt; &#xA;&lt;p&gt;###Stop tracking a task&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hammertime stop&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;###Visualize tasks&lt;/p&gt; &#xA;&lt;p&gt;Show current tasks&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hammertime current&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Show all tasks done today&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hammertime report day&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Show all tasks of a particular project done this month&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hammertime report month --project=&amp;lt;project name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Show the time spent on a particular activity, this week&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hammertime report week --activity=&amp;lt;activity name&amp;gt; --type=totaltime&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To see all the available options&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hammertime report --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Polish the existing reports&lt;/li&gt; &#xA; &lt;li&gt;Use a templating engine to ease the creation of reports&lt;/li&gt; &#xA; &lt;li&gt;Create SVG reports&lt;/li&gt; &#xA; &lt;li&gt;Create CSV reports&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>GaloisInc/parameterized-utils</title>
    <updated>2022-10-16T01:43:02Z</updated>
    <id>tag:github.com,2022-10-16:/GaloisInc/parameterized-utils</id>
    <link href="https://github.com/GaloisInc/parameterized-utils" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A set of utilities for using indexed types including containers, equality, and comparison.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Overview&lt;/h1&gt; &#xA;&lt;p&gt;The parameterized-utils module contains a collection of typeclasses and datatypes for working with parameterized types, that is types that have a type argument. One example would be a algebraic data type for expressions, that use a type parameter to describe the type of the expression.&lt;/p&gt; &#xA;&lt;p&gt;This packaged provides collections classes for these parameterized types.&lt;/p&gt; &#xA;&lt;h1&gt;Parameterized Types Motivation&lt;/h1&gt; &#xA;&lt;p&gt;Parameterized types are types with a single type parameter. One use of the type parameter is to embed the type system of an AST into Haskell, in order to have the Haskell compiler provide static guarantees of correctness. The notion of parameterized types in this library is similar to that of the singletons library, but in some ways more flexible but less automated.&lt;/p&gt; &#xA;&lt;h2&gt;A Simple Example&lt;/h2&gt; &#xA;&lt;p&gt;As an example of a parameterized type, consider the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE DataKinds #-}&#xA;{-# LANGUAGE GADTs #-}&#xA;data EmbeddedType = EInt | EBool&#xA;&#xA;data Expr (tp :: EmbeddedType) where&#xA;  IntLit :: Int -&amp;gt; Expr &#39;EInt&#xA;  BoolLit :: Bool -&amp;gt; Expr &#39;EBool&#xA;  Add :: Expr &#39;EInt -&amp;gt; Expr &#39;EInt -&amp;gt; Expr &#39;EInt&#xA;  Lt :: Expr &#39;EInt -&amp;gt; Expr &#39;EInt -&amp;gt; Expr &#39;EBool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;Expr&lt;/code&gt; type is a parameterized type, as it has a single type parameter. The GADT uses the type parameter to embed a simple type system into the language. The datakind &lt;code&gt;EmbeddedType&lt;/code&gt; is used as a type index. GADT use comes with some potential challenges, depending on use case. Creating collections of values of this &lt;code&gt;Expr&lt;/code&gt; type can be slightly tricky due to the type parameter.&lt;/p&gt; &#xA;&lt;p&gt;Attempting to define the value &lt;code&gt;[IntLit 5, BoolLit False]&lt;/code&gt; results in a type error because the two terms in the list have different types: &lt;code&gt;Expr &#39;EInt&lt;/code&gt; and &lt;code&gt;Expr &#39;EBool&lt;/code&gt;, respectively.&lt;/p&gt; &#xA;&lt;p&gt;One option is to existentially quantify away the type parameter. There is a helper type, &lt;code&gt;Some&lt;/code&gt;, defined in Data.Parameterized.Some that does just this: &lt;code&gt;[Some (IntLit 5), Some (BoolLit False)] :: [Some Expr]&lt;/code&gt;. Because &lt;code&gt;Expr&lt;/code&gt; is defined as a GADT, pattern matching on constructors allows us to recover the type parameter.&lt;/p&gt; &#xA;&lt;p&gt;Another option is to use a container designed to accommodate parameterized types, such as &lt;code&gt;List&lt;/code&gt; defined in Data.Parameterized.List. This would look something like &lt;code&gt;(IntLit 5 :&amp;lt; BoolLit False :&amp;lt; Nil) :: List Expr &#39;[EInt, EBool]&lt;/code&gt;. Note that the type-level list reflects the types of the terms, allowing for some powerful indexing and traversal patterns.&lt;/p&gt; &#xA;&lt;h2&gt;An Extended Example&lt;/h2&gt; &#xA;&lt;p&gt;In the previous example, it is possible to recover the type parameters after they have been existentially quantified away by pattern matching. In a more complicated example, that is not always possible:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE DataKinds #-}&#xA;{-# LANGUAGE GADTs #-}&#xA;data EmbeddedType = EInt | EBool&#xA;&#xA;data Expr (tp :: EmbeddedType) where&#xA;  IntLit :: Int -&amp;gt; Expr &#39;EInt&#xA;  BoolLit :: Bool -&amp;gt; Expr &#39;EBool&#xA;  Add :: Expr &#39;EInt -&amp;gt; Expr &#39;EInt -&amp;gt; Expr &#39;EInt&#xA;  Lt :: Expr &#39;EInt -&amp;gt; Expr &#39;EInt -&amp;gt; Expr &#39;EBool&#xA;  IsEq :: Expr tp -&amp;gt; Expr tp -&amp;gt; Expr &#39;EBool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, pattern matching on the &lt;code&gt;IsEq&lt;/code&gt; constructor does &lt;em&gt;not&lt;/em&gt; recover the types of the operands. &lt;code&gt;IsEq&lt;/code&gt; is polymorphic, so the parameters could either be of type &lt;code&gt;EBool&lt;/code&gt; or &lt;code&gt;EInt&lt;/code&gt;, though we do learn that the types of the sub-terms must at least be the same. We could pattern match on those sub-terms individually, but doing so might introduce an unpredictable amount of recursion and significantly complicate the code. One way to solve this issue is to introduce run-time type representatives to allow us to more easily recover types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE DataKinds #-}&#xA;{-# LANGUAGE GADTs #-}&#xA;data EmbeddedType = EInt | EBool&#xA;&#xA;data Repr tp where&#xA;  IntRepr :: Repr &#39;EInt&#xA;  BoolRepr :: Repr &#39;EBool&#xA;&#xA;data Expr (tp :: EmbeddedType) where&#xA;  IntLit :: Int -&amp;gt; Expr &#39;EInt&#xA;  BoolLit :: Bool -&amp;gt; Expr &#39;EBool&#xA;  Add :: Expr &#39;EInt -&amp;gt; Expr &#39;EInt -&amp;gt; Expr &#39;EInt&#xA;  Lt :: Expr &#39;EInt -&amp;gt; Expr &#39;EInt -&amp;gt; Expr &#39;EBool&#xA;  IsEq :: Repr tp -&amp;gt; Expr tp -&amp;gt; Expr tp -&amp;gt; Expr &#39;EBool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The new type, &lt;code&gt;Repr&lt;/code&gt;, is a singleton type that establishes a connection between a run-time value and a type. When we pattern match on &lt;code&gt;IsEq&lt;/code&gt;, we can simply inspect (i.e., pattern match on) the contained &lt;code&gt;Repr&lt;/code&gt; value to determine the types of the sub-terms:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;withBoolExprs :: Expr tp -&amp;gt; a -&amp;gt; ([Expr &#39;EBool] -&amp;gt; a) -&amp;gt; a&#xA;withBoolExprs e def k =&#xA;  case e of&#xA;    BoolLit {} -&amp;gt; k [e]&#xA;    Lt {} -&amp;gt; k [e]&#xA;    IsEq rep e1 e2&#xA;      | Just Refl &amp;lt;- testEquality rep BoolRepr -&amp;gt;&#xA;          -- Because we used a GADT pattern match, we know that tp ~ EBool&#xA;          k [e, e1, e2]&#xA;      | otherwise -&amp;gt; def&#xA;    _ -&amp;gt; def&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Package Structure&lt;/h1&gt; &#xA;&lt;p&gt;This package provides three main types of functionality:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Typeclasses mirroring core Haskell classes, but adapted to parameterized types&lt;/li&gt; &#xA; &lt;li&gt;Data structures suitable for holding values of parameterized types&lt;/li&gt; &#xA; &lt;li&gt;Utilities for working with parameterized types, including tools for proving properties at the type level (dependently-typed programming in Haskell)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Typeclasses&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Classes&lt;/p&gt; &lt;p&gt;This module contains a number of basic classes lifted to parameterized types, including &lt;code&gt;EqF&lt;/code&gt;, &lt;code&gt;OrdF&lt;/code&gt;, &lt;code&gt;ShowF&lt;/code&gt;, and &lt;code&gt;HashableF&lt;/code&gt;. It also re-exports a few types from base that are useful for working with parameterized types, including &lt;code&gt;TestEquality&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The related module Data.Parameterized.TH.GADT provides Template Haskell functions to automatically implement instances of some of these classes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.ClassesC&lt;/p&gt; &lt;p&gt;This module defines classes like Data.Parameterized.Classes, except that the class methods accept an additional parameter for comparing sub-terms.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.TraversableFC&lt;/p&gt; &lt;p&gt;This module generalizes &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt;, and &lt;code&gt;Traversable&lt;/code&gt; to parameterized types. In these operations, type parameters must be preserved.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.TraversableF&lt;/p&gt; &lt;p&gt;This module is like Data.Parameterized.TraversableFC, but intended for types that have a single parametric type parameter, rather than two. The most common use of these functions and classes is with the &lt;code&gt;MapF&lt;/code&gt; type described below.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Data Structures&lt;/h2&gt; &#xA;&lt;p&gt;This package provides data structures that are either lifted to hold parameterized types or otherwise type indexed. The following modules implement data structures:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Context (&lt;code&gt;Assignment (f :: k -&amp;gt; Type) (ctx :: Ctx k)&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;&lt;code&gt;Assignment&lt;/code&gt; is a sequence type that holds values of parameterized types. It is essentially a snoc list (i.e., a list that is extended on the right instead of the left). The &lt;code&gt;Ctx&lt;/code&gt; (Context) type is a type-level snoc list. In the default implementation, indexing is O(log(n)) time and total.&lt;/p&gt; &lt;p&gt;There are technically two implementations of &lt;code&gt;Assignment&lt;/code&gt;: a safe implementation based on a snoc list in pure Haskell and the default implementation based on a balanced binary tree that uses &lt;code&gt;unsafeCoerce&lt;/code&gt; to manipulate type indexes for efficiency. The safe implementation is a proof that the API presented is safe, while the unsafe implementation is efficient enough to use in practice.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.List (&lt;code&gt;List (f :: k -&amp;gt; Type) [k]&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;&lt;code&gt;List&lt;/code&gt; is the plain Haskell list lifted to hold values of parameterized types. Moreover, it uses the data kind lifted list syntax instead of the &lt;code&gt;Ctx&lt;/code&gt; type. Indexing into &lt;code&gt;List&lt;/code&gt; is total but O(n).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Map (&lt;code&gt;MapF (key :: k -&amp;gt; Type) (value :: k -&amp;gt; Type)&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;&lt;code&gt;MapF&lt;/code&gt; an associative map from keys to values where both keys and values are parameterized types. The lookup operation is O(log(n)), and recovers the type parameter of the value during lookup.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.HashTable (&lt;code&gt;HashTable s (key :: k -&amp;gt; Type) (value :: k -&amp;gt; Type)&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;&lt;code&gt;HashTable&lt;/code&gt; is an associative container like &lt;code&gt;MapF&lt;/code&gt;, except is mutable in &lt;code&gt;ST&lt;/code&gt; (or &lt;code&gt;IO&lt;/code&gt; via &lt;code&gt;stToIO&lt;/code&gt;) due to the &lt;code&gt;s&lt;/code&gt; type parameter.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Vector (&lt;code&gt;Vector (n :: Nat) (a :: Type)&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;This module implements a length-indexed vector. Unlike the other data structures in parameterized-utils, the type parameter only describes the length of the vector as a type-level natural; the elements in the vector do not have type indexes.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Additionally:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Pair (&lt;code&gt;data Pair a b = forall tp . Pair (a tp) (b tp)&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;This module provides an existentially-quantified pair where both types in the pair are indexed by the same existentially quantified parameter. Pattern matching on the constructor recovers the equality. This type is primarily used in Data.Parameterized.Map, but is sometimes separately useful.&lt;/p&gt; &lt;p&gt;Note that there is another useful notion of type parameterized pair, which is provided by Data.Functor.Product in base: &lt;code&gt;data Product a b tp = Pair (a tp) (b tp)&lt;/code&gt;. The difference is that the type parameter of &lt;code&gt;Product&lt;/code&gt; is made manifest in the type, and thus is not quantified away.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Utilities&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.NatRepr&lt;/p&gt; &lt;p&gt;This module provides run-time representative values for natural numbers lifted to the type level, as well as some utilities for proving properties over type-level naturals.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Peano&lt;/p&gt; &lt;p&gt;This module provides an implementation of type-level Peano numbers, as well as run-time representative values for them. It also provides some utilities for proving properties over Peano numbers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Fin&lt;/p&gt; &lt;p&gt;&lt;code&gt;Fin n&lt;/code&gt; is a finite type with &lt;code&gt;n&lt;/code&gt; (terminating/non-bottom) inhabitants. It can be used to index into a &lt;code&gt;Vector n&lt;/code&gt; or other size-indexed datatype.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.SymbolRepr&lt;/p&gt; &lt;p&gt;This module provides run-time representative values for strings lifted to the type level (symbols).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.BoolRepr&lt;/p&gt; &lt;p&gt;This module provides run-time representative values for booleans lifted to the type level.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Some&lt;/p&gt; &lt;p&gt;The &lt;code&gt;Some&lt;/code&gt; type is a wrapper that existentially quantifies away the type parameter of a parameterized value. This can be used on any value with a parameterized type, but is most useful when an operation exists to recover the type parameter later (either via pattern matching over a GADT or by consulting a run-time type representative value).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Nonce&lt;/p&gt; &lt;p&gt;&lt;code&gt;Nonce&lt;/code&gt; is a parameterized type backed by a &lt;code&gt;Word64&lt;/code&gt;. Its &lt;code&gt;TestEquality&lt;/code&gt; instance uses &lt;code&gt;unsafeCoerce&lt;/code&gt; to allow the type parameter to be recovered. Similarly to a cryptographic nonce, the &lt;code&gt;Nonce&lt;/code&gt; type is safe as long as no nonce value is reused.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>