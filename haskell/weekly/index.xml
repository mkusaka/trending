<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-25T01:40:43Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>imsut/starthaskell</title>
    <updated>2022-12-25T01:40:43Z</updated>
    <id>tag:github.com,2022-12-25:/imsut/starthaskell</id>
    <link href="https://github.com/imsut/starthaskell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>ghcjs/jsaddle</title>
    <updated>2022-12-25T01:40:43Z</updated>
    <id>tag:github.com,2022-12-25:/ghcjs/jsaddle</id>
    <link href="https://github.com/ghcjs/jsaddle" rel="alternate"></link>
    <summary type="html">&lt;p&gt;JavaScript interface that works with GHCJS or GHC&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;JSaddle&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ghcjs/jsaddle/actions/workflows/Cabal.yml&#34;&gt;&lt;img src=&#34;https://github.com/ghcjs/jsaddle/actions/workflows/Cabal.yml/badge.svg?sanitize=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;JSaddle is an interface for JavaScript that works with GHCJS or GHC. It is used by &lt;a href=&#34;https://github.com/ghcjs/ghcjs-dom&#34;&gt;ghcjs-dom&lt;/a&gt; when compiled with GHC and is compatible with &lt;a href=&#34;https://github.com/ghcjs/ghcjs-dom&#34;&gt;ghcjs-dom&lt;/a&gt; when compiled with GHCJS.&lt;/p&gt; &#xA;&lt;p&gt;You can use JSaddle directly as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Haskell&#34;&gt;module Main ( main ) where&#xA;&#xA;import Control.Monad.IO.Class (MonadIO(..))&#xA;import Control.Concurrent.MVar (takeMVar, putMVar, newEmptyMVar)&#xA;import Control.Lens ((^.))&#xA;import Language.Javascript.JSaddle&#xA;       (jsg, js, js1, jss, fun, valToNumber, syncPoint)&#xA;import Language.Javascript.JSaddle.Warp (run)&#xA;&#xA;main = run 3709 $ do&#xA;    doc &amp;lt;- jsg &#34;document&#34;&#xA;    doc ^. js &#34;body&#34; ^. jss &#34;innerHTML&#34; &#34;&amp;lt;h1&amp;gt;Kia ora (Hi)&amp;lt;/h1&amp;gt;&#34;&#xA;&#xA;    -- Create a haskell function call back for the onclick event&#xA;    doc ^. jss &#34;onclick&#34; (fun $ \ _ _ [e] -&amp;gt; do&#xA;        x &amp;lt;- e ^. js &#34;clientX&#34; &amp;gt;&amp;gt;= valToNumber&#xA;        y &amp;lt;- e ^. js &#34;clientY&#34; &amp;gt;&amp;gt;= valToNumber&#xA;        newParagraph &amp;lt;- doc ^. js1 &#34;createElement&#34; &#34;p&#34;&#xA;        newParagraph ^. js1 &#34;appendChild&#34; (&#xA;            doc ^. js1 &#34;createTextNode&#34; (&#34;Click &#34; ++ show (x, y)))&#xA;        doc ^. js &#34;body&#34; ^. js1 &#34;appendChild&#34; newParagraph&#xA;        return ())&#xA;&#xA;    -- Make an exit button&#xA;    exitMVar &amp;lt;- liftIO newEmptyMVar&#xA;    exit &amp;lt;- doc ^. js1 &#34;createElement&#34; &#34;span&#34;&#xA;    exit ^. js1 &#34;appendChild&#34; (&#xA;        doc ^. js1 &#34;createTextNode&#34; &#34;Click here to exit&#34;)&#xA;    doc ^. js &#34;body&#34; ^. js1 &#34;appendChild&#34; exit&#xA;    exit ^. jss &#34;onclick&#34; (fun $ \ _ _ _ -&amp;gt; liftIO $ putMVar exitMVar ())&#xA;&#xA;    -- Force all all the lazy evaluation to be executed&#xA;    syncPoint&#xA;&#xA;    -- In GHC compiled version the WebSocket connection will end when this&#xA;    -- thread ends.  So we will wait until the user clicks exit.&#xA;    liftIO $ takeMVar exitMVar&#xA;    doc ^. js &#34;body&#34; ^. jss &#34;innerHTML&#34; &#34;&amp;lt;h1&amp;gt;Ka kite ano (See you later)&amp;lt;/h1&amp;gt;&#34;&#xA;    return ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When compiled with GHC this code will run a Warp web server you can connect to at &lt;code&gt;http:\\localhost:3709\&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here is the same program using ghcjs-dom to call JSaddle. As well as better type safety this version uses JS FFI directly (rather than via JSaddle) when compiled with GHCJS:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Haskell&#34;&gt;module Main (&#xA;    main&#xA;) where&#xA;&#xA;import Control.Monad.IO.Class (MonadIO(..))&#xA;import Control.Concurrent.MVar (takeMVar, putMVar, newEmptyMVar)&#xA;&#xA;import GHCJS.DOM (run, syncPoint, currentDocument)&#xA;import GHCJS.DOM.Document (getBody, createElement, createTextNode)&#xA;import GHCJS.DOM.Element (setInnerHTML)&#xA;import GHCJS.DOM.Node (appendChild)&#xA;import GHCJS.DOM.EventM (on, mouseClientXY)&#xA;import qualified GHCJS.DOM.Document as D (click)&#xA;import qualified GHCJS.DOM.Element as E (click)&#xA;&#xA;main = run 3708 $ do&#xA;    Just doc &amp;lt;- currentDocument&#xA;    Just body &amp;lt;- getBody doc&#xA;    setInnerHTML body (Just &#34;&amp;lt;h1&amp;gt;Kia ora (Hi)&amp;lt;/h1&amp;gt;&#34;)&#xA;    on doc D.click $ do&#xA;        (x, y) &amp;lt;- mouseClientXY&#xA;        Just newParagraph &amp;lt;- createElement doc (Just &#34;p&#34;)&#xA;        text &amp;lt;- createTextNode doc $ &#34;Click &#34; ++ show (x, y)&#xA;        appendChild newParagraph text&#xA;        appendChild body (Just newParagraph)&#xA;        return ()&#xA;&#xA;    -- Make an exit button&#xA;    exitMVar &amp;lt;- liftIO newEmptyMVar&#xA;    Just exit &amp;lt;- createElement doc (Just &#34;span&#34;)&#xA;    text &amp;lt;- createTextNode doc &#34;Click here to exit&#34;&#xA;    appendChild exit text&#xA;    appendChild body (Just exit)&#xA;    on exit E.click $ liftIO $ putMVar exitMVar ()&#xA;&#xA;    -- Force all all the lazy evaluation to be executed&#xA;    syncPoint&#xA;&#xA;    -- In GHC compiled version the WebSocket connection will end when this&#xA;    -- thread ends.  So we will wait until the user clicks exit.&#xA;    liftIO $ takeMVar exitMVar&#xA;    setInnerHTML body (Just &#34;&amp;lt;h1&amp;gt;Ka kite ano (See you later)&amp;lt;/h1&amp;gt;&#34;)&#xA;    return ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When compiled with GHC this code will run a Warp web server you can connect to at &lt;code&gt;http:\\localhost:3708\&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How does it work on GHC&lt;/h2&gt; &#xA;&lt;p&gt;There are a number of different JSaddle runners to choose from&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/jsaddle-warp&#34;&gt;jsaddle-warp&lt;/a&gt; - runs JSaddle in a warp server with a web browser connected to it.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/jsaddle-webkit2gtk&#34;&gt;jsaddle-webkit2gtk&lt;/a&gt; - runs JSaddle in a WebKitGTK window.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/jsaddle-wkwebview&#34;&gt;jsaddle-wkwebview&lt;/a&gt; - runs JSaddle in a WKWebView on iOS or macOS.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/jsaddle-clib&#34;&gt;jsaddle-clib&lt;/a&gt; - C interface used to run JSaddle on Android using JNI.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In all of these cases a web control or browser of some sort is used. An &lt;a href=&#34;https://raw.githubusercontent.com/ghcjs/jsaddle/master/jsaddle/src/Language/Javascript/JSaddle/Run/Files.hs#L24&#34;&gt;HTML file&lt;/a&gt; and a &lt;a href=&#34;https://raw.githubusercontent.com/ghcjs/jsaddle/master/jsaddle/src/Language/Javascript/JSaddle/Run/Files.hs#L340&#34;&gt;small JavaScript command interpreter&lt;/a&gt; are loaded into it. Then the native GHC compiled JSaddle code runs. In order to interact with the browser it sends commands to the JavaScript command interpreter. The mechanism for sending the commands differs for the different runners, but they are always combined into batches and encoded in JSON.&lt;/p&gt; &#xA;&lt;p&gt;Haskell callbacks from JavaScript are supported by sending JSON back from the command interpreter. These can be synchronous (blocking the JavaScript thread until the Haskell callback completes) or asynchronous.&lt;/p&gt; &#xA;&lt;h3&gt;Why use a JavaScript command interpreter?&lt;/h3&gt; &#xA;&lt;p&gt;Older versions of JSaddle relied on the WebKit1 interface to WebKitGTK and JavaScriptCore that is only supported in older versions of WebKitGTK. With the newer WebKit2 interface this level of access is only available to WebKit Extensions. The general advice for people migrating from WebKit1 to WebKit2 seems to be to use JavaScript.&lt;/p&gt; &#xA;&lt;p&gt;As a bonus we have been able to support a number of different platforms with the JavaScript command interpreter and it should be easy to support more in the future.&lt;/p&gt; &#xA;&lt;h3&gt;JSVal&lt;/h3&gt; &#xA;&lt;p&gt;When compiling with GHC a &lt;code&gt;JSVal&lt;/code&gt; is represented by a integer key for a JavaScript &lt;code&gt;Map&lt;/code&gt; in &lt;code&gt;jsaddle.js&lt;/code&gt; code. The first five keys &lt;code&gt;[0..4]&lt;/code&gt; are &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt;. This means the Haskell code can quickly create a JSVal with one of these values. Both the Haskell code and &lt;code&gt;jsaddle.js&lt;/code&gt; can allocate new &lt;code&gt;JSVal&lt;/code&gt; keys. The Haskell code allocates negative keys and &lt;code&gt;jsaddle.js&lt;/code&gt; allocates positive keys to avoid clashing.&lt;/p&gt; &#xA;&lt;p&gt;The haskell code will not know the value to go with the key, but it will include it in commands to the server that are sort of &#34;hey call this function and put the result in the map with this key&#34;). This allows for the lazy execution of the JSaddle code.&lt;/p&gt; &#xA;&lt;p&gt;A finalizer is added on the Haskell code and an asynchronous &lt;code&gt;FreeJSVal&lt;/code&gt; command is automatically sent to &lt;code&gt;jsaddle.js&lt;/code&gt; when the JSVal is no longer reachable. The &lt;code&gt;jsaddle.js&lt;/code&gt; code then deletes the key from the Map.&lt;/p&gt; &#xA;&lt;h3&gt;JSStrings&lt;/h3&gt; &#xA;&lt;p&gt;These are haskell &lt;code&gt;Text&lt;/code&gt; type and so reside on the native side of the WebSocket. If you want to avoid transferring large string values over the WebSocket use &lt;code&gt;toJSVal&lt;/code&gt; to convert it to a &lt;code&gt;JSVal&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Lazy Execution&lt;/h3&gt; &#xA;&lt;p&gt;To improve performance commands are sent to &lt;code&gt;jsaddle.js&lt;/code&gt; in batches that contain any number of asynchronous commands followed by one synchronous one. To get the best performance you should avoid synchronous commands, these are:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Synchronous Command&lt;/th&gt; &#xA;   &lt;th&gt;What will trigger it&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;ValueToString&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;converting a &lt;code&gt;JSVal&lt;/code&gt; to a &lt;code&gt;JSString&lt;/code&gt; (&lt;code&gt;Text&lt;/code&gt; when using GHC)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;ValueToBool&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;converting a &lt;code&gt;JSVal&lt;/code&gt; to a &lt;code&gt;Bool&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;ValueToNumber&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;converting a &lt;code&gt;JSVal&lt;/code&gt; to a &lt;code&gt;Double&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;ValueToJSON&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;converting a &lt;code&gt;JSVal&lt;/code&gt; to a &lt;code&gt;JSON&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;DeRefVal&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;converting a &lt;code&gt;JSVal&lt;/code&gt; to a &lt;code&gt;Value&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;IsNull&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;testing to see if a &lt;code&gt;JSVal&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;IsUndefined&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;testing to see if a &lt;code&gt;JSVal&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;InstanceOf&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;testing to see if a &lt;code&gt;JSVal&lt;/code&gt; is an &lt;code&gt;instanceOf&lt;/code&gt; a given type&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;StrictEqual&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;testing too &lt;code&gt;JSVal&lt;/code&gt; values for equality (&lt;code&gt;===&lt;/code&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;PropertyNames&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;getting the list of properties in an JS object&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;So basically if you don&#39;t look inside a &lt;code&gt;JSVal&lt;/code&gt; to find out something the state of the JavaScript context you will not produce any synchronous commands and your code will run fast. As soon as you look at what is in a &lt;code&gt;JSVal&lt;/code&gt; we have to wait for &lt;code&gt;jsaddle.js&lt;/code&gt; to send the results back and your code will block.&lt;/p&gt; &#xA;&lt;p&gt;In some cases you may wish to make sure all the JSaddle commands are executed. You can use the &lt;code&gt;syncPoint&lt;/code&gt; and &lt;code&gt;syncAfter&lt;/code&gt; functions to force all the pending asynchronous commands to be executed.&lt;/p&gt; &#xA;&lt;h2&gt;How does it work on GHCJS&lt;/h2&gt; &#xA;&lt;p&gt;It uses a handful of JS FFI calls to execute JavaScript functions indirectly. This indirection will be small compared to the overhead of the WebSockets approach (used when JSaddle is compiled with GHC), but it will be significant compared to hand crafted JS FFI calls.&lt;/p&gt; &#xA;&lt;p&gt;For the best performance you may want to write both JS FFI and JSaddle wrappers for your JavaScript code. This is the approach taken by &lt;code&gt;ghcjs-dom&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For instance here is &lt;code&gt;getElementById&lt;/code&gt; from the &lt;code&gt;ghcjs-dom-jsffi&lt;/code&gt; (used by &lt;code&gt;ghcjs-dom&lt;/code&gt; when compiled with GHCJS)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Haskell&#34;&gt;foreign import javascript unsafe &#34;$1[\&#34;getElementById\&#34;]($2)&#34;&#xA;        js_getElementById :: Document -&amp;gt; JSString -&amp;gt; IO (Nullable Element)&#xA;&#xA;getElementById ::&#xA;               (MonadIO m, IsDocument self, ToJSString elementId) =&amp;gt;&#xA;                 self -&amp;gt; elementId -&amp;gt; m (Maybe Element)&#xA;getElementById self elementId&#xA;  = liftIO&#xA;      (nullableToMaybe &amp;lt;$&amp;gt;&#xA;         (js_getElementById (toDocument self) (toJSString elementId)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is &lt;code&gt;getElementById&lt;/code&gt; from &lt;code&gt;jsaddle-dom&lt;/code&gt; (used by &lt;code&gt;ghcjs-dom&lt;/code&gt; when compiled with GHC)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Haskell&#34;&gt;getElementById ::&#xA;               (MonadDOM m, IsDocument self, ToJSString elementId) =&amp;gt;&#xA;                 self -&amp;gt; elementId -&amp;gt; m (Maybe Element)&#xA;getElementById self elementId&#xA;  = liftDOM&#xA;      (((toDocument self) ^. jsf &#34;getElementById&#34; [toJSVal elementId])&#xA;         &amp;gt;&amp;gt;= fromJSVal)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Exceptions&lt;/h2&gt; &#xA;&lt;p&gt;JSaddle does not support exceptions well. When compiled with GHCJS an exception will result in termination of the thread at the point the exception is thrown.&lt;/p&gt; &#xA;&lt;p&gt;When using GHC the Haskell executions will probably continue for a while before the exception is received at all by the Haskell code (because the lazy execution of the JS code). The exception will be thrown when the next synchronous command is executed. When it reaches the synchronous command a haskell type JSException will be thrown (this may not be the thread that initiated the command that caused the exception). You can use &lt;code&gt;syncPoint&lt;/code&gt; and &lt;code&gt;syncAfter&lt;/code&gt; to force the exception to be thrown. There are &lt;code&gt;JSM&lt;/code&gt; versions of &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;bracket&lt;/code&gt; that also include a &lt;code&gt;syncPoint&lt;/code&gt; call.&lt;/p&gt; &#xA;&lt;h2&gt;Building with Stack&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;jsaddle-webkit2gtk&lt;/code&gt; runner can be difficult to build with stack. See &lt;a href=&#34;https://github.com/ghcjs/jsaddle/issues/38#issuecomment-331392995&#34;&gt;this issue&lt;/a&gt; if you get stuck.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>maxwellsayles/binary-indexed-tree</title>
    <updated>2022-12-25T01:40:43Z</updated>
    <id>tag:github.com,2022-12-25:/maxwellsayles/binary-indexed-tree</id>
    <link href="https://github.com/maxwellsayles/binary-indexed-tree" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Binary Indexed Trees in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;binary-indexed-tree&lt;/h1&gt; &#xA;&lt;p&gt;Binary Indexed Trees in Haskell&lt;/p&gt;</summary>
  </entry>
</feed>