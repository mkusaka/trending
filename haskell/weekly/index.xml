<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-06T01:52:48Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>runtimeverification/haskell-backend</title>
    <updated>2023-08-06T01:52:48Z</updated>
    <id>tag:github.com,2023-08-06:/runtimeverification/haskell-backend</id>
    <link href="https://github.com/runtimeverification/haskell-backend" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The symbolic execution engine powering the K Framework&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Kore Language&lt;/h1&gt; &#xA;&lt;p&gt;Kore is the &#34;core&#34; part of the K framework.&lt;/p&gt; &#xA;&lt;h2&gt;What is Kore all about?&lt;/h2&gt; &#xA;&lt;p&gt;In short, we need a formal semantics of K. In K, users can define formal syntax and semantics of programming languages as K definitions, and automatically obtain parsers, interpreters, compilers, and various verification tools for their languages. Therefore K is a language-independent framework.&lt;/p&gt; &#xA;&lt;p&gt;Thanks to years of research in matching logic and reachability logic, we know that all K does can be nicely formalized as logic reasoning in matching logic. To give K a formal semantics, we only need to formally specify the underlying matching logic theories with which K does reasoning. In practice, these underlying theories are complex and often infinite, and it is tricky to specify infinite theories without a carefully designed formal specification language. And Kore is such a language.&lt;/p&gt; &#xA;&lt;h2&gt;Structure of this project&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/runtimeverification/haskell-backend/tree/master/docs&#34;&gt;docs&lt;/a&gt; directory contains a collection of documents that describe the mathematical foundation of Kore and a BNF grammar that defines the syntax of Kore language. See &lt;a href=&#34;https://github.com/runtimeverification/haskell-backend/raw/master/docs/introduction.md&#34;&gt;/docs/introduction.md&lt;/a&gt; for an overview of the components of Kore.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;kore&lt;/code&gt; project is an implementation in Haskell of a Kore parser and symbolic execution engine, for use with the &lt;a href=&#34;https://github.com/runtimeverification/k&#34;&gt;K Framework&lt;/a&gt; as a backend.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;Besides &lt;a href=&#34;https://git-scm.com/&#34;&gt;git&lt;/a&gt;, you will need &lt;a href=&#34;https://www.haskellstack.org/&#34;&gt;stack&lt;/a&gt; or &lt;a href=&#34;https://haskell.org/cabal&#34;&gt;cabal&lt;/a&gt; to build &lt;code&gt;kore&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stack build kore&#xA;# or&#xA;cabal build kore&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may pass &lt;code&gt;--fast&lt;/code&gt; to &lt;code&gt;stack build&lt;/code&gt; or &lt;code&gt;-O0&lt;/code&gt; to &lt;code&gt;cabal build&lt;/code&gt; in order to disable compiler optimizations and make build faster at the cost of slower runtime.&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;a href=&#34;https://www.gnu.org/software/make/&#34;&gt;make&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make all # builds all binaries&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Developing&lt;/h2&gt; &#xA;&lt;p&gt;Developers will require all the dependencies listed above, in addition to the requirements and recommendations below.&lt;/p&gt; &#xA;&lt;h3&gt;Required dependencies&lt;/h3&gt; &#xA;&lt;p&gt;For integration testing, we require:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GNU &lt;a href=&#34;https://www.gnu.org/software/make/&#34;&gt;make&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://github.com/runtimeverification/k&#34;&gt;K Framework&lt;/a&gt; frontend (its version should be the one stated in &lt;a href=&#34;https://github.com/runtimeverification/haskell-backend/raw/master/deps/k_release&#34;&gt;/deps/k_release&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Python 3.x with the &lt;a href=&#34;https://github.com/explodinglabs/jsonrpcclient&#34;&gt;&lt;code&gt;jsonrpcclient&lt;/code&gt;&lt;/a&gt; library installed&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can install/have access to K by either:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;using &lt;a href=&#34;https://github.com/runtimeverification/k/releases/latest&#34;&gt;kup&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;using a pre-built binary (see the releases page in the K repository)&lt;/li&gt; &#xA; &lt;li&gt;if you use Nix, see the section below&lt;/li&gt; &#xA; &lt;li&gt;using the &lt;code&gt;Dockerfile&lt;/code&gt; to run the integration tests inside a container&lt;/li&gt; &#xA; &lt;li&gt;or by just building K from source&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Running integration tests with Docker&lt;/h3&gt; &#xA;&lt;p&gt;Use &lt;code&gt;docker.sh&lt;/code&gt; to run commands inside the container:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./docker/build.sh  # run once when dependencies change&#xA;./docker/run.sh make all  # build the backend&#xA;./docker/run.sh make test  # run all tests&#xA;./docker/run.sh make -C test/imp test  # run all tests in test/imp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Recommended dependencies&lt;/h3&gt; &#xA;&lt;p&gt;For setting up a development environment, we recommend:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/direnv/direnv&#34;&gt;direnv&lt;/a&gt; to make the project&#39;s tools available in shells and editors.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;ghcup&lt;/a&gt; or &lt;a href=&#34;https://nixos.org&#34;&gt;Nix&lt;/a&gt; for managing required Haskell tooling&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ndmitchell/hlint&#34;&gt;hlint&lt;/a&gt; for compliance with project guidelines.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Running Haskell Language Server&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;ghcup&lt;/a&gt; provides a straightforward way of installing the language server, if you prefer to use &lt;a href=&#34;https://nixos.org&#34;&gt;Nix&lt;/a&gt; please refer to the relevant resources on how to set up your &lt;a href=&#34;https://nixos.org&#34;&gt;Nix&lt;/a&gt; environment to build the server. &lt;strong&gt;Note&lt;/strong&gt;: HLS has to be built with the project&#39;s GHC version.&lt;/p&gt; &#xA;&lt;p&gt;Prequisite: build the project with either Stack or Cabal.&lt;/p&gt; &#xA;&lt;p&gt;Instructions on integrating with VSCode:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=haskell.haskell&#34;&gt;Haskell extension&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Go to &lt;code&gt;Extension Settings&lt;/code&gt; and pick &lt;code&gt;GHCup&lt;/code&gt; in the &lt;code&gt;Manage HLS&lt;/code&gt; dropdown&lt;/li&gt; &#xA; &lt;li&gt;(Optional) Manually set the GHCup executable path&lt;/li&gt; &#xA; &lt;li&gt;(Extra) Set &lt;code&gt;Formatting Provider&lt;/code&gt; to &lt;code&gt;fourmolu&lt;/code&gt; for correct formatting&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Developing with Nix&lt;/h3&gt; &#xA;&lt;p&gt;To build and run nix based packages at RV, please follow these instructions to set up nix:&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;We are using &lt;a href=&#34;https://nixos.wiki/wiki/Flakes&#34;&gt;nix flakes&lt;/a&gt; in all our repos. What this means at a high level is that some of the commands for building packages look a bit different.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;To set up nix flakes you will need to install &lt;code&gt;nix&lt;/code&gt; 2.4 or higher.If you are on a standard Linux distribution, such as Ubuntu, first &lt;a href=&#34;https://nixos.org/download.html#download-nix&#34;&gt;install nix&lt;/a&gt; and then enable flakes by editing either &lt;code&gt;~/.config/nix/nix.conf&lt;/code&gt; or &lt;code&gt;/etc/nix/nix.conf&lt;/code&gt; and adding:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;experimental-features = nix-command flakes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that if this is your first time using &lt;a href=&#34;https://nixos.org&#34;&gt;Nix&lt;/a&gt; you will have to manually create one of the &lt;code&gt;.conf&lt;/code&gt; files.&lt;/p&gt; &#xA;&lt;p&gt;This is needed to expose the Nix 2.0 CLI and flakes support that are hidden behind feature-flags. (If you are on a different system like nixOS, see instructions for enabling flakes here: &lt;a href=&#34;https://nixos.wiki/wiki/Flakes&#34;&gt;https://nixos.wiki/wiki/Flakes&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;By default, Nix will build any project and its transitive dependencies from source, which can take a very long time. We therefore need to set up some binary caches to speed up the build process. First, install cachix&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nix profile install github:cachix/cachix/v1.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and then add the &lt;code&gt;k-framework&lt;/code&gt; cachix cache&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cachix use k-framework&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, we need to set up the cache for our haskell infrastructure, by adding the following sections to &lt;code&gt;/etc/nix/nix.conf&lt;/code&gt; or, if you are a trusted user, &lt;code&gt;~/.config/nix/nix.conf&lt;/code&gt; (if you don&#39;t know what a &#34;trusted user&#34; is, you probably want to do the former):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;trusted-public-keys = ... hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=&#xA;substituters = ... https://cache.iog.io&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;i.e. if the file was originally&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;substituters = https://cache.nixos.org&#xA;trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;it will now read&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;substituters = https://cache.nixos.org https://cache.iog.io&#xA;trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure that the file wasn&#39;t overwritten, if it was add the &lt;code&gt;experimental-features&lt;/code&gt; again.&lt;/p&gt; &#xA;&lt;h3&gt;Formatting&lt;/h3&gt; &#xA;&lt;p&gt;The CI requires all Haskell files to be formatted via &lt;a href=&#34;https://hackage.haskell.org/package/fourmolu&#34;&gt;fourmolu&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If using VSCode, please refer to the language server section above. If not, the easiest way to do this locally is to run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nix run .#format&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will format all the haskell files in the given folder and all sub-folders. You can &lt;code&gt;cd&lt;/code&gt; into a particular subfolder and run the command there, or if you only want to format a specific file, you can provide it as an argument to the above command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nix run .#format Foo.hs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Nix dev shell&lt;/h3&gt; &#xA;&lt;p&gt;We provide a development nix shell with a suitable development environment and a binary cache at &lt;a href=&#34;https://runtimeverification.cachix.org/&#34;&gt;runtimeverification.cachix.org&lt;/a&gt;. The development can be launched via &lt;code&gt;nix develop&lt;/code&gt; and then calling &lt;code&gt;stack build/test/etc&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Upgrading dependencies&lt;/h3&gt; &#xA;&lt;p&gt;When one of the package description files (&lt;code&gt;kore.cabal&lt;/code&gt;, &lt;code&gt;kore-rpc-types.cabal&lt;/code&gt;) changes, or when upgrading to a newer &lt;code&gt;stack&lt;/code&gt; resolver, the dependencies need to be consolidated to avoid accidental breakage from incompatible up-stream updates. We use a &lt;code&gt;cabal.project.freeze&lt;/code&gt; file to pin the dependencies to what the current &lt;code&gt;stack&lt;/code&gt; resolver is using.&lt;/p&gt; &#xA;&lt;p&gt;The script &lt;a href=&#34;https://github.com/runtimeverification/haskell-backend/tree/master/scripts/freeze-cabal-to-stack-resolver.sh&#34;&gt;&lt;code&gt;scripts/freeze-cabal-to-stack-resolver.sh&lt;/code&gt;&lt;/a&gt; should do most of that work (the existing &lt;code&gt;freeze&lt;/code&gt; file must be removed before running it), and &lt;a href=&#34;https://github.com/runtimeverification/haskell-backend/tree/master/scripts/check-cabal-stack-sync.sh&#34;&gt;&lt;code&gt;scripts/check-cabal-stack-sync.sh&lt;/code&gt;&lt;/a&gt; checks the result. Some manual adjustments will still be necessary for the &lt;code&gt;nix&lt;/code&gt; builds in CI and locally to work.&lt;/p&gt; &#xA;&lt;p&gt;In addition, any GHC or resolver upgrades must double-check the &lt;code&gt;compiler-nix-name&lt;/code&gt; and &lt;code&gt;index-state&lt;/code&gt; values in the &lt;a href=&#34;https://github.com/runtimeverification/haskell-backend/raw/master/flake.nix#L41-L42&#34;&gt;&lt;code&gt;flake.nix&lt;/code&gt;&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;h3&gt;Integration tests&lt;/h3&gt; &#xA;&lt;p&gt;Haskell-backend provides an integration shell for running integration tests, which compile the K framework (of a specified version) against your current version of haskell backend and brings K into scope of your current shell.&lt;/p&gt; &#xA;&lt;p&gt;The integration shell is part of the &lt;code&gt;k&lt;/code&gt; repository, but invoked from the local tree, adding additional tools (see &lt;a href=&#34;https://github.com/runtimeverification/haskell-backend/raw/master/nix/integration-shell.nix&#34;&gt;&lt;code&gt;nix/integration-shell.nix&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://github.com/runtimeverification/k/raw/master/flake.nix#L180&#34;&gt;&lt;code&gt;../k/flake.nix&lt;/code&gt;&lt;/a&gt;). Its &lt;code&gt;haskell-backend&lt;/code&gt; dependency must be overridden to use the &lt;code&gt;haskell-backend&lt;/code&gt; dependency from the current checked-out tree, and the &lt;code&gt;k&lt;/code&gt; version will usually be the one from &lt;code&gt;deps/k_release&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To use this nix shell, execute&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;me@somewhere:haskell-backend$ nix develop \&#xA;    github:runtimeverification/k/v$(cat deps/k_release)#kore-integration-tests \&#xA;    --override-input haskell-backend . --update-input haskell-backend&#xA;...&#xA;...(nix output)&#xA;integration-shell:me@somewhere:haskell-backend$&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(This will take some time the first time you run it for a specific K framework version...)&lt;br&gt; A specific commit or version tag of the K framework github repository can be used instead of &lt;code&gt;$(cat deps/k_release)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Running this command will add all of the K binaries like &lt;code&gt;kompile&lt;/code&gt; or &lt;code&gt;kast&lt;/code&gt; into the &lt;code&gt;PATH&lt;/code&gt; of your current shell. This is not permanent and will only persist in your current shell window until you exit the active nix shell).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;integration-shell:me@somewhere:haskell-backend$ make -C test/issue-3344 test&#xA;...&#xA;...(make output)&#xA;integration-shell:me@somewhere:haskell-backend$ exit&#xA;me@somewhere:haskell-backend$ &#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>xuebo/xset</title>
    <updated>2023-08-06T01:52:48Z</updated>
    <id>tag:github.com,2023-08-06:/xuebo/xset</id>
    <link href="https://github.com/xuebo/xset" rel="alternate"></link>
    <summary type="html">&lt;p&gt;home&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;A&lt;/h1&gt;</summary>
  </entry>
  <entry>
    <title>YoshikuniJujo/wxturtle</title>
    <updated>2023-08-06T01:52:48Z</updated>
    <id>tag:github.com,2023-08-06:/YoshikuniJujo/wxturtle</id>
    <link href="https://github.com/YoshikuniJujo/wxturtle" rel="alternate"></link>
    <summary type="html">&lt;p&gt;library for program like LOGO&#39;s turtle with using wxHaskell&lt;/p&gt;&lt;hr&gt;&lt;p&gt;You can run turtle in wxHaskell.&lt;/p&gt; &#xA;&lt;p&gt;Install this package by cabal.&lt;/p&gt;</summary>
  </entry>
</feed>