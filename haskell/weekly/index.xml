<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-27T01:55:52Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jameysharp/corrode</title>
    <updated>2023-08-27T01:55:52Z</updated>
    <id>tag:github.com,2023-08-27:/jameysharp/corrode</id>
    <link href="https://github.com/jameysharp/corrode" rel="alternate"></link>
    <summary type="html">&lt;p&gt;C to Rust translator&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Corrode: Automatic semantics-preserving translation from C to Rust&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/jameysharp/corrode&#34;&gt;&lt;img src=&#34;https://travis-ci.org/jameysharp/corrode.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This program reads a C source file and prints an equivalent module in Rust syntax. It&#39;s intended for partial automation of migrating legacy code that was implemented in C. This tool does not fully automate the job because its output is only as safe as the input was; you should clean up the output afterward to use Rust features and idioms where appropriate.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;As of now, there are no pre-built binaries available, so you need to build the project yourself, but don&#39;t let that scare you away; clone the project, &lt;code&gt;cd&lt;/code&gt; into it and follow along :)&lt;/p&gt; &#xA;&lt;h3&gt;Windows&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re using Windows, start by running &lt;code&gt;fixGitSymlinksForWindows.bat&lt;/code&gt; as admin (this is necessary for Git to create symlinks).&lt;/p&gt; &#xA;&lt;h3&gt;Cabal&lt;/h3&gt; &#xA;&lt;p&gt;Ensure that you have GHC and the &lt;code&gt;cabal-install&lt;/code&gt; tool installed by following the &lt;a href=&#34;https://www.haskell.org/downloads#minimal&#34;&gt;directions on haskell.org&lt;/a&gt;. You&#39;ll also need to have the &lt;code&gt;happy&lt;/code&gt; and &lt;code&gt;alex&lt;/code&gt; tools available in order to build &lt;code&gt;corrode&lt;/code&gt;: you can install them with the &lt;code&gt;cabal-install&lt;/code&gt; tool, as well. Once you have installed the &lt;code&gt;cabal-install&lt;/code&gt; tool, you can build &lt;code&gt;corrode&lt;/code&gt; by navigating to the &lt;code&gt;corrode&lt;/code&gt; directory, installing the &lt;code&gt;happy&lt;/code&gt; and &lt;code&gt;alex&lt;/code&gt; tools, and then building and installing the &lt;code&gt;corrode&lt;/code&gt; package:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal install happy&#xA;cabal install alex&#xA;cabal install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This puts the &lt;code&gt;corrode&lt;/code&gt; executable in &lt;code&gt;~/.cabal/bin&lt;/code&gt;, so ensure that that location is in your &lt;code&gt;$PATH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Alternate instructions: Stack&lt;/h3&gt; &#xA;&lt;p&gt;Alternately, you can use the &lt;a href=&#34;http://haskellstack.org&#34;&gt;Haskell Stack&lt;/a&gt; tool for Haskell development. If you don&#39;t have it, head over to their website and follow the instructions for installing it on your machine.&lt;/p&gt; &#xA;&lt;p&gt;Install the Glasgow Haskell Compiler using &lt;code&gt;stack setup&lt;/code&gt;. You can skip this step if you already have a version of GHC installed on your system. You can then build and install &lt;code&gt;corrode&lt;/code&gt; by navigating to the &lt;code&gt;corrode&lt;/code&gt; directory and running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;stack install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Stack will build and install &lt;code&gt;corrode&lt;/code&gt; to &lt;code&gt;~/.local/bin&lt;/code&gt;. For ease of use, make sure that directory is in your &lt;code&gt;$PATH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To experiment with the project itself, you can build it using&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;stack build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then run the executable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;stack exec -- corrode -Wall filename.c -I/usr/local/include -lm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;There are two ways to use Corrode. You can simply generate a &lt;code&gt;.rs&lt;/code&gt; file from the C source, or you can do this &lt;em&gt;and&lt;/em&gt; compile in one step.&lt;/p&gt; &#xA;&lt;h3&gt;Generating Rust source&lt;/h3&gt; &#xA;&lt;p&gt;You can now run &lt;code&gt;corrode&lt;/code&gt;, giving it any options that &lt;code&gt;gcc&lt;/code&gt; would accept.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;corrode -Wall filename.c -I/usr/local/include -lm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It will only use the options that are relevant to the C pre-processor, like &lt;code&gt;-I&lt;/code&gt; or &lt;code&gt;-D&lt;/code&gt;, but since it accepts and ignores any other options, you can usually get going just by changing &lt;code&gt;gcc&lt;/code&gt; to &lt;code&gt;corrode&lt;/code&gt; in the &lt;code&gt;gcc&lt;/code&gt; invocation you&#39;ve been using.&lt;/p&gt; &#xA;&lt;p&gt;Unlike a real C compiler, Corrode does not produce an object file or executable! Instead, if you ask it to process &lt;code&gt;filename.c&lt;/code&gt;, it generates equivalent Rust source code in &lt;code&gt;filename.rs&lt;/code&gt;. If you &lt;em&gt;do&lt;/em&gt; want object code, there is a script to help with that.&lt;/p&gt; &#xA;&lt;h3&gt;Codegen with compilation&lt;/h3&gt; &#xA;&lt;p&gt;You can either invoke &lt;code&gt;rustc&lt;/code&gt; on Corrode&#39;s output yourself (or import it into a Rust project), or use the &lt;code&gt;scripts/corrode-cc&lt;/code&gt; tool in place of &lt;code&gt;gcc&lt;/code&gt; to compile and link. In many build systems, such as &lt;code&gt;make&lt;/code&gt;, you can simply set &lt;code&gt;CC=corrode-cc&lt;/code&gt; without modification.&lt;/p&gt; &#xA;&lt;h2&gt;Design principles&lt;/h2&gt; &#xA;&lt;p&gt;The overarching goal of Corrode is to preserve the original properties of the source program as much as possible: behavior, ABI compatibility, and maintainability. We expect the output of Corrode to be used to replace the original C, not just as an intermediate step in a compiler toolchain.&lt;/p&gt; &#xA;&lt;p&gt;Corrode aims to produce Rust source code which behaves exactly the same way that the original C source behaved, if the input is free of undefined and implementation-defined behavior. In the presence of undefined behavior, we&#39;ve tried to pick a behavior that isn&#39;t too surprising. For example, if a signed addition might overflow (which is undefined behavior in C), Corrode just translates it to Rust&#39;s &lt;code&gt;+&lt;/code&gt; operator, which panics on overflow in debug builds.&lt;/p&gt; &#xA;&lt;p&gt;The compiled Rust source in turn will be ABI-compatible with the original C. If you compile Corrode-generated Rust to a &lt;code&gt;.o&lt;/code&gt; file, you can link to it exactly as if it were generated from the original C. Every function that Corrode generates with be annotated with the &lt;code&gt;extern &#34;C&#34;&lt;/code&gt; modifier.&lt;/p&gt; &#xA;&lt;p&gt;At the same time, Corrode should produce code which is recognizably structured like the original, so that the output is as maintainable as the original. Every statement and every expression should be represented in the outputâ€”in the same order, where possible. If a programmer went to the trouble to put something in, we usually want it in the translated output; if it&#39;s not necessary, we can let the Rust compiler warn about it.&lt;/p&gt; &#xA;&lt;p&gt;If either behavior or ABI is not preserved, we consider that a bug in Corrode. However, it is not always possible to preserve the structure of the original code, so we do the best that we can.&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;So far, Corrode has primarily been tested by generating random C programs using &lt;a href=&#34;https://github.com/csmith-project/csmith&#34;&gt;csmith&lt;/a&gt;, fixing Corrode until it can handle all syntax used in that particular program, and verifying that the resulting Rust module compiles without errors.&lt;/p&gt; &#xA;&lt;p&gt;Verifying that the translated output is equivalent to the input is not trivial. One approach I think is worth trying is to use the Galois &lt;a href=&#34;http://saw.galois.com/&#34;&gt;Software Analysis Workbench&lt;/a&gt; to prove that the LLVM bitcode generated from &lt;code&gt;clang&lt;/code&gt; on a C source file is equivalent to the LLVM bitcode generated from &lt;code&gt;rustc&lt;/code&gt; on a Rust source file from Corrode. SAW uses a symbolic simulator over LLVM bitcode to extract logical formulas representing the behavior of each function, and then uses an SMT solver to prove equivalence between pairs of formulas. Generating large numbers of random C programs using csmith and then proving the translation results equivalent for each one should give pretty good confidence in the implementation.&lt;/p&gt; &#xA;&lt;p&gt;Because the project is still in its early phases, it is not yet possible to translate most real C programs or libraries. But if you have one you particularly want to try out, I&#39;d love to get pull requests implementing more of C!&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If this seems cool and you&#39;d like to help complete it, welcome! There are quite a few fundamental pieces of the C standard which are not yet implemented. I&#39;d love to chat with you if you&#39;re not quite sure how to get started! You can e-mail me at &lt;a href=&#34;mailto:jamey@minilop.net&#34;&gt;mailto:jamey@minilop.net&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;What Corrode is not&lt;/h2&gt; &#xA;&lt;p&gt;A Rust module that exactly captures the semantics of a C source file is a Rust module that doesn&#39;t look very much like Rust. ;-) I would like to build a companion tool which rewrites parts of a valid Rust program in ways that have the same result but make use of Rust idioms. I think it should be separate from this tool because I expect it to be useful for other folks, not just users of Corrode. I propose to call that program &#34;idiomatic&#34;, and I think it should be written in Rust using the Rust AST from &lt;a href=&#34;https://github.com/serde-rs/syntex&#34;&gt;&lt;code&gt;syntex_syntax&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>kolmodin/binary-arrow</title>
    <updated>2023-08-27T01:55:52Z</updated>
    <id>tag:github.com,2023-08-27:/kolmodin/binary-arrow</id>
    <link href="https://github.com/kolmodin/binary-arrow" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Efficient, pure binary decoding using Arrows and ByteStrings in Haskell.&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>cardano-foundation/fine-types</title>
    <updated>2023-08-27T01:55:52Z</updated>
    <id>tag:github.com,2023-08-27:/cardano-foundation/fine-types</id>
    <link href="https://github.com/cardano-foundation/fine-types" rel="alternate"></link>
    <summary type="html">&lt;p&gt;FineTypes is an interface description language (IDL) focussing on types&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;FineTypes&lt;/h1&gt; &#xA;&lt;p&gt;ðŸš§ WORK IN PROGRESS ðŸš§&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;FineTypes is an interface description language (IDL) focussing on types. You can use it to specify data types that are interoperable between different programming languages.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;TxOut = Addr Ã— Value Ã— (Datum âŠŽ DataHash)? Ã— Script?;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;FineTypes allows you to&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Define data types concisely using mathematical notation.&lt;/li&gt; &#xA; &lt;li&gt;Map between data types using algebraic transformations, such as &lt;code&gt;(A + B) Ã— C = (A Ã— C) + (B Ã— C)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Export type definitions to different programming languages, currently: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Haskell&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Export type definitions to different data schemas, currently &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;OpenAPI: Schema Objects&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;FineTypes was originally conceived to be able to specify all types in the &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/releases/latest/&#34;&gt;Cardano ledger specification&lt;/a&gt; in a way that is both machine readable and visually matches the PDF document.&lt;/p&gt; &#xA;&lt;h2&gt;Contents&lt;/h2&gt; &#xA;&lt;p&gt;This repository contains&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;fine-types&lt;/code&gt; Haskell package and executable.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;cardano-ledger-types&lt;/code&gt; package containing a reference specification of the types from the &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/releases/latest/&#34;&gt;Cardano ledger specification&lt;/a&gt; in different eras (Shelley, â€¦, Babbage).&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>