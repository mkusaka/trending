<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-14T01:56:52Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>maralorn/nix-output-monitor</title>
    <updated>2024-01-14T01:56:52Z</updated>
    <id>tag:github.com,2024-01-14:/maralorn/nix-output-monitor</id>
    <link href="https://github.com/maralorn/nix-output-monitor" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Pipe your nix-build output through the nix-output-monitor a.k.a nom to get additional information while building.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;nix-output-monitor&lt;/h1&gt; &#xA;&lt;p&gt;Pipe your nix-build output through the nix-output-monitor (aka nom) to get additional information while building.&lt;/p&gt; &#xA;&lt;p&gt;While your build runs, nom will draw something like this at the bottom of your build log:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/maralorn/nix-output-monitor/main/example-screenshot.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;(note that to reduce clutter nom only shows timers over 1s build or download time.)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://repology.org/project/nix-output-monitor/versions&#34;&gt;&lt;img src=&#34;https://repology.org/badge/vertical-allrepos/nix-output-monitor.svg?sanitize=true&#34; alt=&#34;Packaging status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;This was an experimental fun project, which proved to be useful to quite a lot of people. The purpose of it is to write something fun and useful in Haskell. You are free and very welcome to contribute feedback, issues or PRs. I do not commit to maintain this project over a long time period but it doesn’t look like I am stopping anytime soon.&lt;/p&gt; &#xA;&lt;p&gt;By now, nom is quite fully featured with support for nix v1 commands (e.g. &lt;code&gt;nix-build&lt;/code&gt;) and nix v2 command (e.g. &lt;code&gt;nix build&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Issues and pull requests are welcome at &lt;a href=&#34;https://github.com/maralorn/nix-output-monitor&#34;&gt;https://github.com/maralorn/nix-output-monitor&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Starting from version 2.1.0, nom uses &lt;a href=&#34;https://semver&#34;&gt;SemVer&lt;/a&gt;. The versioning applies to the behavior of the executable. There are no stability guarantees for the library component in the cabal project.&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;If your question is not answered in this README you can ask it in &lt;a href=&#34;https://matrix.to/#/#nix-output-monitor:maralorn.de&#34;&gt;#nix-output-monitor:maralorn.de&lt;/a&gt; on matrix or open an issue on github.&lt;/p&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;nixpkgs: nom is in nixpkgs. Just install &lt;code&gt;pkgs.nix-output-monitor&lt;/code&gt; in the usual way. You might want to install it from nixos-unstable to get the newest version.&lt;/li&gt; &#xA; &lt;li&gt;cabal: Install &lt;code&gt;cabal-install&lt;/code&gt; and run &lt;code&gt;cabal install&lt;/code&gt; in the checked out repo.&lt;/li&gt; &#xA; &lt;li&gt;nix: or use &lt;code&gt;nix build&lt;/code&gt; or &lt;code&gt;nix-env&lt;/code&gt; or include the flake output of this repo in your nixos config.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Running&lt;/h2&gt; &#xA;&lt;h3&gt;The Easy Way&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; The displayed build tree might be incomplete with new-style commands like &lt;code&gt;nix build&lt;/code&gt; for nix versions &amp;lt;2.10.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;nom&lt;/code&gt; binary (starting from version 2.0) behaves as a &lt;code&gt;nix&lt;/code&gt; drop in, with much more colorful output, but &lt;strong&gt;only&lt;/strong&gt; for the following commands:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;nom build &amp;lt;args&amp;gt;&lt;/code&gt;: Behaves like &lt;code&gt;nix build &amp;lt;args&amp;gt;&lt;/code&gt;.&lt;br&gt; &lt;code&gt;nom shell &amp;lt;args&amp;gt;&lt;/code&gt;: Behaves like &lt;code&gt;nix shell &amp;lt;args&amp;gt;&lt;/code&gt;.&lt;br&gt; &lt;code&gt;nom develop &amp;lt;args&amp;gt;&lt;/code&gt;: Behaves like &lt;code&gt;nix develop &amp;lt;args&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The latter two commands work by calling &lt;code&gt;nix shell&lt;/code&gt; or &lt;code&gt;nix develop&lt;/code&gt; twice, the first time with overridden &lt;code&gt;--run exit&lt;/code&gt; and monitoring the output, the second time passing output through to the user. This will incur a performance cost by doubling eval time.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore when called via the corresponding provided symlinks, nom is also a drop-in for the following commands:&lt;br&gt; &lt;code&gt;nom-build &amp;lt;args&amp;gt;&lt;/code&gt;: Behaves like &lt;code&gt;nix-build &amp;lt;args&amp;gt;&lt;/code&gt;.&lt;br&gt; &lt;code&gt;nom-shell &amp;lt;args&amp;gt;&lt;/code&gt;: Behaves like &lt;code&gt;nix-shell &amp;lt;args&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;All aliases internally use the json-based approach (see next section) and propagate error codes. If you want nom support for other nix commands please open an issue.&lt;/p&gt; &#xA;&lt;h3&gt;The Flexible Way&lt;/h3&gt; &#xA;&lt;h4&gt;JSON based&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;nix-build --log-format internal-json -v |&amp;amp; nom --json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; Don‘t forget to redirect stderr. That&#39;s what the &lt;code&gt;&amp;amp;&lt;/code&gt;, does.&lt;/p&gt; &#xA;&lt;h4&gt;Human readable log parsing&lt;/h4&gt; &#xA;&lt;p&gt;It his highly recommended to always append &lt;code&gt;--log-format internal-json -v&lt;/code&gt; (or use the above mentioned aliases.) and call &lt;code&gt;nom&lt;/code&gt; with &lt;code&gt;--json&lt;/code&gt;. That will give you much more informative output.&lt;/p&gt; &#xA;&lt;p&gt;If you are in a situation, where you can‘t use the json based nix output you can still use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;nix-build |&amp;amp; nom&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; Don‘t forget to redirect stderr. That&#39;s what the &lt;code&gt;&amp;amp;&lt;/code&gt;, does.&lt;/p&gt; &#xA;&lt;p&gt;This has the advantage to also work with other commands like &lt;code&gt;nixos-rebuild&lt;/code&gt; or &lt;code&gt;home-manager&lt;/code&gt;, where it is not trivial to pass in the &lt;code&gt;--log-format internal-json -v&lt;/code&gt; flag. nom will pass everything it reads through, if it does not understand it. This makes it ideal to attach it to scripts which output more then just &lt;code&gt;nix&lt;/code&gt; output.&lt;/p&gt; &#xA;&lt;h3&gt;Preserving Colored Text&lt;/h3&gt; &#xA;&lt;p&gt;Colored text will work as expected in json-mode.&lt;/p&gt; &#xA;&lt;p&gt;In human-readable log mode you can preserve the color of the redirected text by using the &lt;code&gt;unbuffer&lt;/code&gt; command from the &lt;code&gt;expect&lt;/code&gt; package.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;unbuffer nix-build |&amp;amp; nom&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Explanation&lt;/h2&gt; &#xA;&lt;h3&gt;Legend&lt;/h3&gt; &#xA;&lt;p&gt;Nom tries to convey information via symbols and colors&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;⏵&lt;/code&gt;, yellow: running builds&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;✔&lt;/code&gt;, green: completed builds&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;⏳︎︎︎&lt;/code&gt;, blue: planned builds&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;⚠&lt;/code&gt;, red: failed builds&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;↓ ⏵&lt;/code&gt;, yellow: running downloads&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;↑ ⏵&lt;/code&gt;, yellow: running uploads&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;↓ ✔&lt;/code&gt;, green: completed downloads&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;↑ ✔&lt;/code&gt;, green: completed uploads&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;↓ ⏳︎︎︎&lt;/code&gt;, blue: waiting downloads&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;∅&lt;/code&gt;: a moving average over past builds of this derivation&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;⏱︎&lt;/code&gt;: running time&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;∑&lt;/code&gt;: a summary over all packages and hosts&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you can‘t see all icons you maybe need another terminal font. I recommend any font from &lt;code&gt;pkgs.nerdfonts&lt;/code&gt; e.g. &lt;code&gt;&#34;JetBrainsMono Nerd Font&#34;&lt;/code&gt;. Also different terminals might work differently well. I recommend: &lt;code&gt;pkgs.foot&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How to Read the Dependency Graph&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Every entry in the nom tree stands for one derivation.&lt;/li&gt; &#xA; &lt;li&gt;Children of a node are direct dependencies.&lt;/li&gt; &#xA; &lt;li&gt;nom will try to show you the most relevant part of the dependency tree, roughly aiming to fill a third of your terminal&lt;/li&gt; &#xA; &lt;li&gt;No build will be printed twice in the tree, it will only be shown for the lower most dependency.&lt;/li&gt; &#xA; &lt;li&gt;nom will do it’s best to print all running or failed builds, downloads and uploads, but it does not print every direct child of a node.&lt;/li&gt; &#xA; &lt;li&gt;Use the colors from above to read the summary&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example Runs&lt;/h2&gt; &#xA;&lt;p&gt;An example remote build: &lt;a href=&#34;https://asciinema.org/a/KwCh38ujQ9wusHw8kyW4KCMZo&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/KwCh38ujQ9wusHw8kyW4KCMZo.svg?sanitize=true&#34; alt=&#34;asciicast&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;An example with a lot of downloads: &lt;a href=&#34;https://asciinema.org/a/7hJXH2iFLEkKxG1lL25lspqNn&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/7hJXH2iFLEkKxG1lL25lspqNn.svg?sanitize=true&#34; alt=&#34;asciicast&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Implementation&lt;/h2&gt; &#xA;&lt;p&gt;Right now nom uses four sources of information:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The parsed nix-build output (json or human-readable)&lt;/li&gt; &#xA; &lt;li&gt;it checks if build results exist in the nix-store (only in human-readable mode)&lt;/li&gt; &#xA; &lt;li&gt;it queries &lt;code&gt;.drv&lt;/code&gt; files for information about the &lt;code&gt;out&lt;/code&gt; output path.&lt;/li&gt; &#xA; &lt;li&gt;It caches build times in &lt;code&gt;$XDG_CACHE_HOME/nix-output-monitor/build-reports.csv&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This will fail in unexpected and expected ways.&lt;/li&gt; &#xA; &lt;li&gt;Luckily I don‘t think this program screws up anything more than your terminal.&lt;/li&gt; &#xA; &lt;li&gt;remote builds will sometimes be shown as running even when they are actually still waiting for uploads or downloads. This is how nix reports it.&lt;/li&gt; &#xA; &lt;li&gt;Terminal clearing and reprinting is brittle. It might fail with your terminal or terminal width. But at this point I‘ve invested some effort to make it usable.&lt;/li&gt; &#xA; &lt;li&gt;This program also makes assumptions like your nix-store is at &#34;/nix/store&#34;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;For human-readable log parsing mode:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;nix-output-monitor receives most it&#39;s information from parsing nix-build output. The parser might be to strict or to loose for use cases I didn‘t think of. Then &lt;strong&gt;the numbers displayed will be off&lt;/strong&gt;!&lt;/li&gt; &#xA; &lt;li&gt;nix-build does not show info when a download or upload is finished, so we currently cannot differentiate between started and completed downloads.&lt;/li&gt; &#xA; &lt;li&gt;For completed build detection we assume that every derivation has an output called &#34;out&#34;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>mlabs-haskell/fake-plutus-core</title>
    <updated>2024-01-14T01:56:52Z</updated>
    <id>tag:github.com,2024-01-14:/mlabs-haskell/fake-plutus-core</id>
    <link href="https://github.com/mlabs-haskell/fake-plutus-core" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;code&gt;fake-plutus-core&lt;/code&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;What is this thing?&lt;/h2&gt; &#xA;&lt;h2&gt;What are the goals of this project?&lt;/h2&gt; &#xA;&lt;h2&gt;What does this run on?&lt;/h2&gt; &#xA;&lt;h2&gt;What can I do with this?&lt;/h2&gt;</summary>
  </entry>
</feed>