<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-05T01:52:48Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>serialhex/Language---Up-Goer-5</title>
    <updated>2023-11-05T01:52:48Z</updated>
    <id>tag:github.com,2023-11-05:/serialhex/Language---Up-Goer-5</id>
    <link href="https://github.com/serialhex/Language---Up-Goer-5" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Up Goer 5 Sublime Text Word Set Add-On!!!&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Up Goer 5 Sublime Text Word Set Add-On!!!&lt;/h1&gt; &#xA;&lt;p&gt;...or really any word set&lt;/p&gt; &#xA;&lt;p&gt;this idea was taken from &lt;a href=&#34;http://splasho.com/upgoer5/&#34;&gt;The Up Goer 5 Text Editor&lt;/a&gt; (which should really be called &#34;The Up Goer 5 Word Writer&#34; or some such...) All this is, is a small word set that will show you if what you are writing is not one of the ten hundred most often used words. The only problem is that you can yourself add words to the word set by pressing the right side push thing and pick &#34;Ignore&#34;. There is no way I can stop this from happening, so be watching what you do!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Simspace/simformat</title>
    <updated>2023-11-05T01:52:48Z</updated>
    <id>tag:github.com,2023-11-05:/Simspace/simformat</id>
    <link href="https://github.com/Simspace/simformat" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Formats haskell import lists&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SimFormat&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.com/simspace/simformat&#34;&gt;&lt;img src=&#34;https://travis-ci.com/simspace/simformat.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Formats Haskell import lists.&lt;/p&gt; &#xA;&lt;p&gt;It produces import lists that look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Range.Shared.Types&#xA;  ( ExternalRef(..), Imports(Imports), SomeExternalRef(SomeExternalRef), SpecEntity(..)&#xA;  , SpecRef(SpecRefExternal, SpecRefLocal), ExternalEntities, IsSpecEntity, ResolvedSpec&#xA;  , SpecEntities, VmRepetitionGroup, VmRgTag, importsConfigModuleDefs, importsOperatingSystems&#xA;  , importsVmTemplates, specEntitiesConfigModuleDefs, specEntitiesOperatingSystems&#xA;  , specEntitiesVmTemplates, specEntity, specificationEntities&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;simformat&lt;/code&gt; formats an entire git repository using a &lt;code&gt;.simformatrc&lt;/code&gt; config file in the repo root to identify files to include. To bypass this behavior you can call it with &lt;code&gt;simformat &amp;lt;file&amp;gt;&lt;/code&gt; which will format the file regardless of whether it&#39;s in the configuration. It should always succeed: if it cannot find any import blocks, it will simply pass the text on unchanged. You can always run &lt;code&gt;simformat --help&lt;/code&gt; for more command-line options.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ stack install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Emacs&lt;/h3&gt; &#xA;&lt;p&gt;From within Emacs, assuming you have the &lt;code&gt;haskell-mode&lt;/code&gt; and &lt;code&gt;stylish-haskell&lt;/code&gt; packages installed and working, &lt;code&gt;(setq haskell-mode-stylish-haskell-path &#34;simformat -e&#34;)&lt;/code&gt; and &lt;code&gt;(setq haskell-stylish-on-save t)&lt;/code&gt; should automatically reformat your import list on every save.&lt;/p&gt; &#xA;&lt;p&gt;If you prefer not to run code on save, you can use &lt;code&gt;shell-command-on-region&lt;/code&gt; with a region active and the prefix argument set, i.e. &lt;code&gt;C-u M-| simformat&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Vim&lt;/h3&gt; &#xA;&lt;p&gt;If you use &lt;a href=&#34;https://github.com/jose-elias-alvarez/null-ls.nvim/&#34;&gt;&lt;code&gt;null-ls.nvim&lt;/code&gt;&lt;/a&gt; an excellent plugin for integrating external tools for formatting / diagnostics in a way compatible with neovim&#39;s builtin LSP you can use this snippet to register a source that will format Haskell files using &lt;code&gt;simformat&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-viml&#34;&gt;lua &amp;lt;&amp;lt; EOF&#xA;local null_ls = require(&#39;null-ls&#39;)&#xA;local simformat = {&#xA;  name = &#39;simformat&#39;,&#xA;  method = null_ls.methods.FORMATTING,&#xA;  filetypes = {&#39;haskell&#39;},&#xA;  generator = require(&#39;null-ls.helpers&#39;).formatter_factory {&#xA;    command = &#39;simformat&#39;,&#xA;    args = {&#39;-e&#39;},&#xA;    to_stdin = true,&#xA;  },&#xA;}&#xA;null_ls.register(simformat)&#xA;EOF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One possible vim solution is to add this to your &lt;code&gt;.vimrc&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;function! s:RunSimformat()&#xA;  if &amp;amp;filetype == &#39;haskell&#39;&#xA;    let cmd = &#39;simformat -e&#39;&#xA;    let stdin = join(getline(1, &#39;$&#39;), &#34;\n&#34;)&#xA;    let output = system(cmd, stdin)&#xA;    if v:shell_error != 0&#xA;      echom output&#xA;    else&#xA;      call s:OverwriteBuffer(output)&#xA;    endif&#xA;  endif&#xA;endfunction&#xA;&#xA;function! s:OverwriteBuffer(output)&#xA;  if &amp;amp;modifiable&#xA;    let l:curw=winsaveview()&#xA;    try | silent undojoin | catch | endtry&#xA;    let splitted = split(a:output, &#39;\n&#39;)&#xA;    if line(&#39;$&#39;) &amp;gt; len(splitted)&#xA;      execute len(splitted) .&#39;,$delete&#39;&#xA;    endif&#xA;    call setline(1, splitted)&#xA;    call winrestview(l:curw)&#xA;  else&#xA;    echom &#34;Cannot write to non-modifiable buffer&#34;&#xA;  endif&#xA;endfunction&#xA;&#xA;augroup Simformat&#xA;  autocmd!&#xA;  autocmd BufWritePre * call &amp;lt;SID&amp;gt;RunSimformat()&#xA;augroup END&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To format without running on save, run &lt;code&gt;:!simformat&lt;/code&gt; (to format all files that are children of the &lt;code&gt;pwd&lt;/code&gt;) or run &lt;code&gt;:%!simformat -e&lt;/code&gt; (to format just the current file).&lt;/p&gt; &#xA;&lt;h3&gt;VSCode&lt;/h3&gt; &#xA;&lt;p&gt;Add this to &lt;code&gt;~/Library/Application Support/Code/User/settings.json&lt;/code&gt; once you have installed the &lt;a href=&#34;https://github.com/pucelle/vscode-run-on-save&#34;&gt;Run on Save&lt;/a&gt; extension.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;    &#34;runOnSave.statusMessageTimeout&#34;: 3000,&#xA;    &#34;runOnSave.commands&#34;: [&#xA;        {&#xA;            &#34;match&#34;: &#34;.*\\.hs$&#34;,&#xA;            &#34;notMatch&#34;: &#34;[\\\\\\/]_[^\\\\\\/]*\\.hs$&#34;,&#xA;            &#34;command&#34;: &#34;simformat ${file}&#34;,&#xA;            &#34;runIn&#34;: &#34;backend&#34;,&#xA;            &#34;runningStatusMessage&#34;: &#34;Formatting ${fileBasename}&#34;,&#xA;            &#34;finishStatusMessage&#34;: &#34;${fileBasename} formatted&#34;&#xA;        }&#xA;    ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;.simformatrc example&lt;/h2&gt; &#xA;&lt;p&gt;The config file, &lt;code&gt;.simformatrc&lt;/code&gt;, is expected to live in the directory where the &lt;code&gt;simformat&lt;/code&gt; executable is being run. It&#39;s a YAML file containing two keys: &lt;code&gt;files&lt;/code&gt; and &lt;code&gt;whitelist&lt;/code&gt;, each with a list of filepaths. If &lt;code&gt;.simformatrc&lt;/code&gt; is not present, it will interpret &lt;code&gt;files&lt;/code&gt; to be all files, and &lt;code&gt;whitelist&lt;/code&gt; to be empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;files:&#xA;  - foo&#xA;whitelist:&#xA;  - foo/bar&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>mbg/icfp</title>
    <updated>2023-11-05T01:52:48Z</updated>
    <id>tag:github.com,2023-11-05:/mbg/icfp</id>
    <link href="https://github.com/mbg/icfp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;icfp&lt;/h1&gt; &#xA;&lt;h1&gt;Non-standard packages&lt;/h1&gt; &#xA;&lt;p&gt;haskell-platform&lt;/p&gt; &#xA;&lt;h1&gt;Cabal packages&lt;/h1&gt; &#xA;&lt;p&gt;pqueue&lt;/p&gt;</summary>
  </entry>
</feed>