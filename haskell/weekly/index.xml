<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-07T01:55:24Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jekor/redo</title>
    <updated>2024-04-07T01:55:24Z</updated>
    <id>tag:github.com,2024-04-07:/jekor/redo</id>
    <link href="https://github.com/jekor/redo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;djb&#39;s redo implementation in Haskell (for Haskell from Scratch video series)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Redo: A Simple Way to (Re)build Targets from Sources&lt;/h1&gt; &#xA;&lt;p&gt;Redo allows you to rebuild files from source files when they&#39;ve changed. It&#39;s simpler than other build systems such as Make or SCons and more generic than language-specific build systems such as Cabal or Apache Ant.&lt;/p&gt; &#xA;&lt;p&gt;Redo gains its power and simplicity by leveraging other tools (in the Unix tradition). Build scripts for redo are simply shell scripts that follow a few conventions.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;To build a target file, invoke redo with one or more target arguments.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;redo&lt;/code&gt; &lt;em&gt;target&lt;/em&gt; [&lt;em&gt;target&lt;/em&gt;...]&lt;/p&gt; &#xA;&lt;p&gt;There are no command-line options. Unlike Make, there is no default target for when you invoke &lt;code&gt;redo&lt;/code&gt; with no arguments (it will just return silently after doing no work).&lt;/p&gt; &#xA;&lt;h2&gt;What You Can Use Redo for&lt;/h2&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;redo&lt;/code&gt; any time you want to automatically build some file(s) from some other file(s). For example:&lt;/p&gt; &#xA;&lt;h3&gt;Compiling Source Code&lt;/h3&gt; &#xA;&lt;h4&gt;Compiling a .c File into a .o File&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;redo-ifchange $2.c&#xA;redo-ifchange $(./cc -MM $2.c | tr -d &#39;\n\\&#39; | cut -d&#39;:&#39; -f2)&#xA;./cc -c $2.c -o $3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Converting Markup into Documents&lt;/h3&gt; &#xA;&lt;h4&gt;Generating an HTML Document from a Markdown Document&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;redo-ifchange $2.markdown&#xA;pandoc $2.markdown&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Advantages Over Make&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;More flexibility thanks to .do scripts being full shell scripts.&lt;/li&gt; &#xA; &lt;li&gt;No need to learn Make&#39;s syntax or programming constructs.&lt;/li&gt; &#xA; &lt;li&gt;No need to worry about incompatibilities between different versions of Make.&lt;/li&gt; &#xA; &lt;li&gt;Better detection of actual changes through checksums instead of timestamps.&lt;/li&gt; &#xA; &lt;li&gt;Modularity without a speed penalty since redo is recursive by design.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;No supported method of building multiple targets with a single .do script.&lt;/li&gt; &#xA; &lt;li&gt;No built-in method to depend on environment variables or the contents of directories changing.&lt;/li&gt; &#xA; &lt;li&gt;The need to distribute a redo implementation if you&#39;re distributing a source archive.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that you can find a minimal implementation of redo written in bourne shell &lt;a href=&#34;https://github.com/apenwarr/redo/raw/master/minimal/do&#34;&gt;here&lt;/a&gt;. It&#39;s called &#34;do&#34; since it doesn&#39;t track changes to dependencies and always fully rebuilds the target(s), but it should be suitable for distributing with your source archive.&lt;/p&gt; &#xA;&lt;h2&gt;How to Use Redo in Your Project&lt;/h2&gt; &#xA;&lt;h3&gt;.do Scripts&lt;/h3&gt; &#xA;&lt;p&gt;Redo builds a target file by looking for a corresponding .do script. For example, you might want to build the file &lt;code&gt;index.html&lt;/code&gt; from &lt;code&gt;index.markdown&lt;/code&gt;. When you invoke &lt;code&gt;redo index.html&lt;/code&gt;, redo will first look for a script named &lt;code&gt;index.html.do&lt;/code&gt;. If it fails to find that, it will then look for &lt;code&gt;default.html.do&lt;/code&gt;. If it finds a .do script, it will invoke it with 3 arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;$1&lt;/code&gt;: unused (&lt;code&gt;0&lt;/code&gt;) for backwards compatibility with older redo implementations&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$2&lt;/code&gt;: the base name of the target (e.g. &lt;code&gt;index&lt;/code&gt; for the target &lt;code&gt;index.html&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$3&lt;/code&gt;: the temporary file that you should output the resulting target file contents to&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Your script is not required to use any of these arguments, although you will usually want to use &lt;code&gt;$2&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Scripts are executed by &lt;code&gt;sh&lt;/code&gt; which you should assume is a standard Bourne Shell.&lt;/p&gt; &#xA;&lt;h3&gt;Atomic Output&lt;/h3&gt; &#xA;&lt;p&gt;Anything output to standard output will automatically be appended to the temporary output file (&lt;code&gt;$3&lt;/code&gt;). The &lt;code&gt;$3&lt;/code&gt; argument is provided for programs that don&#39;t output to standard output or don&#39;t provide an option to do so (such as compilers that need to rewind file pointers, etc.).&lt;/p&gt; &#xA;&lt;p&gt;A temporary file is used (rather than outputting directly to the target file) to ensure that the target file only appears if it has been fully and correctly rebuilt (instead of partially rebuilt due to some interruption).&lt;/p&gt; &#xA;&lt;p&gt;For example, if you wanted to convert &lt;code&gt;index.markdown&lt;/code&gt; to &lt;code&gt;index.html&lt;/code&gt; using pandoc, in your &lt;code&gt;index.html.do&lt;/code&gt; file, instead of writing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pandoc -o index.html index.markdown&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;you should write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pandoc -o $3 index.markdown&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or, you could take advantage of the fact that pandoc outputs to stdout by default and write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pandoc index.markdown&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and generalizing further with the &lt;code&gt;$2&lt;/code&gt; argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pandoc $2.markdown&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;To specify that a target file depends on 1 or more source files, use the command &lt;code&gt;redo-ifchange&lt;/code&gt; inside of your .do script. For example, to specify that &lt;code&gt;index.html&lt;/code&gt; depends on the file &lt;code&gt;index.markdown&lt;/code&gt;, in the &lt;code&gt;index.html.do&lt;/code&gt; script you would write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;redo-ifchange index.markdown&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or more flexibly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;redo-ifchange $2.markdown&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Redo will track the checksums of any dependencies specified this way and only build the target file if at least 1 of its dependencies has changed or the target file is missing.&lt;/p&gt; &#xA;&lt;h3&gt;Recursion&lt;/h3&gt; &#xA;&lt;p&gt;Redo is able to track dependencies recursively. For example, if you were not creating &lt;code&gt;index.markdown&lt;/code&gt; directly but instead compiling it from some chapter files (such as &lt;code&gt;chapters/intro.markdown&lt;/code&gt;, &lt;code&gt;chapters/body.markdown&lt;/code&gt;, and &lt;code&gt;chapters/appendix.markdown&lt;/code&gt;), you could create a new &lt;code&gt;index.markdown.do&lt;/code&gt; file without making any changes to your &lt;code&gt;index.html.do&lt;/code&gt; (or &lt;code&gt;default.html.do&lt;/code&gt; file). Your new &lt;code&gt;index.markdown.do&lt;/code&gt; file could look something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;redo-ifchange chapters/*.markdown&#xA;cat chapters/*.markdown &amp;gt; $3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that since &lt;code&gt;redo-ifchange&lt;/code&gt; is simply a command that will be executed by the shell, we can use &lt;code&gt;*&lt;/code&gt; for filename globbing.&lt;/p&gt; &#xA;&lt;p&gt;Redo will know when checking whether to rebuild &lt;code&gt;index.html&lt;/code&gt; that it should also check that the dependencies of &lt;code&gt;index.markdown&lt;/code&gt; are up-to-date as well.&lt;/p&gt; &#xA;&lt;p&gt;Similarly, if you later wanted to build one of the chapter files from some other files, you just need to add an appropriate .do script (e.g. &lt;code&gt;chapters/body.markdown.do&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Defaults&lt;/h3&gt; &#xA;&lt;p&gt;Redo supports writing generic .do scripts based on file extensions. For example, if you had multiple Markdown files that you wanted to convert to HTML files, rather than write multiple .do scripts, you could instead take your existing &lt;code&gt;index.html.do&lt;/code&gt; and rename it to &lt;code&gt;default.html.do&lt;/code&gt;. Then, assuming that you&#39;d written your .do script to take advantage of the &lt;code&gt;$2&lt;/code&gt; argument, i.e.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;redo-ifchange $2.markdown&#xA;pandoc $2.markdown&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;default.html.do&lt;/code&gt; will be run by redo to build any target ending in &lt;code&gt;.html&lt;/code&gt; (assuming that a more specific .do script doesn&#39;t exist).&lt;/p&gt; &#xA;&lt;h2&gt;Stability&lt;/h2&gt; &#xA;&lt;p&gt;I consider redo to be stable but not feature complete.&lt;/p&gt; &#xA;&lt;p&gt;Redo is used to build itself. However, it is not a very complicated program.&lt;/p&gt; &#xA;&lt;p&gt;Most of redis&#39;s build system (~200 lines of Make) was converted to .do scripts as a test of redo&#39;s suitability.&lt;/p&gt; &#xA;&lt;p&gt;Redo has only been tested on FreeBSD and Linux.&lt;/p&gt; &#xA;&lt;h2&gt;Implementation Details&lt;/h2&gt; &#xA;&lt;p&gt;Redo is written in Haskell. It was written &#34;on-camera&#34; by Chris Forno (jekor) as part of a tutorial video series on real-world Haskell development. You can find the videos on &lt;a href=&#34;http://www.youtube.com/watch?v=zZ_nI9E9g0I&amp;amp;list=PLxj9UAX4Em-Ij4TKwKvo-SLp-Zbv-hB4B&#34;&gt;YouTube&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;D. J. Bernstein conceived the idea behind redo and wrote some initial documentation at &lt;a href=&#34;http://cr.yp.to/redo.html&#34;&gt;http://cr.yp.to/redo.html&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alan Grosskurth wrote a thesis &#34;Purely top-down software building&#34; that includes an analysis and implementation of redo.&lt;/p&gt; &#xA;&lt;p&gt;Mitchell Rosen, Göktuğ Kayaalp, and Rotten194 contributed suggestions on the tutorial videos during the process of writing the program. Many other viewers provided silent code review.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>AccelerateHS/accelerate-fft</title>
    <updated>2024-04-07T01:55:24Z</updated>
    <id>tag:github.com,2024-04-07:/AccelerateHS/accelerate-fft</id>
    <link href="https://github.com/AccelerateHS/accelerate-fft" rel="alternate"></link>
    <summary type="html">&lt;p&gt;FFT library for Haskell based on the embedded array language Accelerate&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img width=&#34;450&#34; src=&#34;https://github.com/AccelerateHS/accelerate/raw/master/images/accelerate-logo-text-v.png?raw=true&#34; alt=&#34;henlo, my name is Theia&#34;&gt; &#xA; &lt;h1&gt;FFT components for the Accelerate language&lt;/h1&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/tmcdonell/accelerate-fft/actions&#34;&gt;&lt;img src=&#34;https://github.com/tmcdonell/accelerate-fft/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;GitHub CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/AccelerateHS/Lobby&#34;&gt;&lt;img src=&#34;https://img.shields.io/gitter/room/nwjs/nw.js.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://stackage.org/lts/package/accelerate-fft&#34;&gt;&lt;img src=&#34;https://stackage.org/package/accelerate-fft/badge/lts&#34; alt=&#34;Stackage LTS&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stackage.org/nightly/package/accelerate-fft&#34;&gt;&lt;img src=&#34;https://stackage.org/package/accelerate-fft/badge/nightly&#34; alt=&#34;Stackage Nightly&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/accelerate-fft&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/accelerate-fft.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;FFT library for the embedded array language Accelerate. For details on Accelerate, refer to the &lt;a href=&#34;https://github.com/AccelerateHS/accelerate&#34;&gt;main repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The following build flags control whether optimised implementations are used. Note that enabling these (which is the default) will require the corresponding Accelerate backend as a dependency:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;llvm-ptx&lt;/code&gt;: For NVIDIA GPUs&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;llvm-cpu&lt;/code&gt;: For multicore CPUs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Contributions and bug reports are welcome!&lt;br&gt; Please feel free to contact me through GitHub or &lt;a href=&#34;https://gitter.im/AccelerateHS/Lobby&#34;&gt;gitter.im&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Course/HaskDB</title>
    <updated>2024-04-07T01:55:24Z</updated>
    <id>tag:github.com,2024-04-07:/Course/HaskDB</id>
    <link href="https://github.com/Course/HaskDB" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>