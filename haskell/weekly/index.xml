<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-02T01:43:04Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>digital-asset/contingent-claims</title>
    <updated>2022-10-02T01:43:04Z</updated>
    <id>tag:github.com,2022-10-02:/digital-asset/contingent-claims</id>
    <link href="https://github.com/digital-asset/contingent-claims" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/digital-asset/daml/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache%202.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/digital-asset/contingent-claims&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/digital-asset/contingent-claims.svg?style=shield&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Copyright Â© 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All Rights Reserved. SPDX-License-Identifier: Apache-2.0&lt;/p&gt; &#xA;&lt;h1&gt;Contingent Claims&lt;/h1&gt; &#xA;&lt;p&gt;This is a library for modeling contingent claims, i.e. derivatives, written in the smart contract language &lt;a href=&#34;https://www.digitalasset.com/developers&#34;&gt;Daml&lt;/a&gt;. Briefly, a derivative is represented by a tree of &lt;code&gt;Claim&lt;/code&gt;s, which describe future cashflows between two parties as well as the conditions under which these cashflows occur.&lt;/p&gt; &#xA;&lt;p&gt;The library offers life-cycling capabilities, as well as a valuation semantics that maps a claim to a mathematical expression that can be used for no-arbitrage pricing.&lt;/p&gt; &#xA;&lt;p&gt;The implementation closely follows the model outlined in the papers &lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/contingent-claims/master/#1&#34;&gt;[1]&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/contingent-claims/master/#2&#34;&gt;[2]&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To get started, we recommend reading through the &lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/contingent-claims/master/docs/QUICKSTART.md&#34;&gt;quickstart&lt;/a&gt; document.&lt;/p&gt; &#xA;&lt;p&gt;Examples of how to create and lifecycle contracts can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/contingent-claims/master/test/daml/Test/FinancialContract.daml&#34;&gt;test directory&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How to use this library&lt;/h2&gt; &#xA;&lt;p&gt;To use the library in your Daml project, it is sufficient to download the latest &lt;code&gt;*.dar&lt;/code&gt; file from the &lt;a href=&#34;https://github.com/digital-asset/contingent-claims/releases/&#34;&gt;releases page&lt;/a&gt; and add it as a dependency to your project.&lt;/p&gt; &#xA;&lt;h2&gt;Releases&lt;/h2&gt; &#xA;&lt;p&gt;Releases adhere to the &#39;semantic versioning&#39; specification. Breaking changes across major versions are documented in &lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/contingent-claims/master/docs/UPGRADING.md&#34;&gt;Upgrading.md&lt;/a&gt;. The steps required to release this library are documented in &lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/contingent-claims/master/docs/RELEASE.MD&#34;&gt;RELEASE.MD&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building the code&lt;/h2&gt; &#xA;&lt;p&gt;In order to build the code from source, follow these instructions.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone the repository&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Make sure the &lt;a href=&#34;https://docs.daml.com/getting-started/installation.html&#34;&gt;Daml SDK&lt;/a&gt; is installed on your machine&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fetch the &lt;code&gt;*.dar&lt;/code&gt; file for the latest version of the &lt;a href=&#34;https://github.com/digital-asset/daml-ctl/releases&#34;&gt;daml-ctl&lt;/a&gt; library and copy it to the &lt;code&gt;lib/&lt;/code&gt; folder in the repository&#39;s root&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can then build a release version (no tests in the &lt;code&gt;*.dar&lt;/code&gt;) by running &lt;code&gt;daml build&lt;/code&gt; in the root directory, or a dev version that includes tests from the &lt;code&gt;test&lt;/code&gt; directory.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;We also provide an unsupported &lt;code&gt;Makefile&lt;/code&gt; with targets for said tasks.&lt;/p&gt; &#xA;&lt;h3&gt;Running the tests&lt;/h3&gt; &#xA;&lt;p&gt;Navigate to the &lt;code&gt;test&lt;/code&gt; directory and run &lt;code&gt;daml test&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;API documentation&lt;/h3&gt; &#xA;&lt;p&gt;API documentation for the latest release is available online &lt;a href=&#34;https://digital-asset.github.io/contingent-claims/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also build this locally using the SDK command &lt;code&gt;daml damlc docs&lt;/code&gt; from the root directory. There is also an unsupported &lt;code&gt;make doc&lt;/code&gt; target.&lt;/p&gt; &#xA;&lt;h2&gt;Contribution Policy&lt;/h2&gt; &#xA;&lt;p&gt;If you wish to contribute to this project, please contact us first via Github. In future, we do plan to accept external contributions, contingent on the Digital Asset CLA.&lt;/p&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a id=&#34;1&#34;&gt;[1]&lt;/a&gt; Jones, S. Peyton, Jean-Marc Eber, and Julian Seward. &#34;Composing contracts: an adventure in financial engineering.&#34; ACM SIG-PLAN Notices 35.9 (2000): 280-292.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;2&#34;&gt;[2]&lt;/a&gt; Jones, SL Peyton, and J. M. Eber. &#34;How to write a financial contract&#34;, volume &#34;Fun Of Programming&#34; of &#34;Cornerstones of Computing.&#34; (2005).&lt;/p&gt; &#xA;&lt;p&gt;The papers can be downloaded from &lt;a href=&#34;https://www.microsoft.com/en-us/research/publication/composing-contracts-an-adventure-in-financial-engineering/&#34;&gt;Microsoft Research&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>input-output-hk/quickcheck-dynamic</title>
    <updated>2022-10-02T01:43:04Z</updated>
    <id>tag:github.com,2022-10-02:/input-output-hk/quickcheck-dynamic</id>
    <link href="https://github.com/input-output-hk/quickcheck-dynamic" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A library for stateful property-based testing&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;quickcheck-dynamic&lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://github.com/input-output-hk/quickcheck-dynamic/actions&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/input-output-hk/hydra-poc/CI&#34;&gt;&lt;/a&gt;&amp;nbsp; &#xA; &lt;a href=&#34;https://hackage.haskell.org/package/quickcheck-dynamic/&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/quickcheck-dynamic&#34;&gt;&lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;A library for testing stateful programs using &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;QuickCheck&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Dynamic_logic_(modal_logic)&#34;&gt;dynamic logic&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This repository hosts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The core &lt;a href=&#34;https://raw.githubusercontent.com/input-output-hk/quickcheck-dynamic/main/quickcheck-dynamic&#34;&gt;quickcheck-dynamic&lt;/a&gt; library providing tools for quickchecking stateful models,&lt;/li&gt; &#xA; &lt;li&gt;Example of integrating &lt;a href=&#34;https://github.com/input-output-hk/io-sim&#34;&gt;io-sim&lt;/a&gt;&#39;s Haskell runtime simulator and &lt;em&gt;quickcheck-dynamic&lt;/em&gt; to model and test complex multi-threaded application.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The original stateful testing approach is described in John Hughes&#39; research paper: &lt;a href=&#34;https://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf&#34;&gt;https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quviq-testing.pdf &lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://github.com/input-output-hk/quickcheck-dynamic/tree/main/quickcheck-io-sim-compat&#34;&gt;Registry example&lt;/a&gt; is a common case study that&#39;s been explored in two papers: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://publications.lib.chalmers.se/records/fulltext/232552/local_232552.pdf&#34;&gt;How well are your requirements tested?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;and &lt;a href=&#34;https://mengwangoxf.github.io/Papers/Erlang18.pdf&#34;&gt;Understanding Formal Specifications through Good Examples&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The dynamic logic addition allows you to specify that after a generated test sequence, the system is able to reach a specific required state. In other words, you can specify that some &#34;good&#34; state is reachable from any possible state.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following talks provide concrete examples on how this approach is used to test smart contracts in Plutus:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;John Hughes high level talk on how to test Plutus smart contracts using this library: &lt;a href=&#34;https://youtu.be/V9_14jjJiuQ&#34;&gt;https://youtu.be/V9_14jjJiuQ&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;55 minutes in to this lecture an example of using the state machine formalism: &lt;a href=&#34;https://www.youtube.com/watch?v=zW3D2iM5uVg&amp;amp;t=3300&#34;&gt;https://www.youtube.com/watch?v=zW3D2iM5uVg&amp;amp;t=3300&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Edsko de Vries wrote a &lt;a href=&#34;https://well-typed.com/blog/2022/09/lockstep-with-quickcheck-dynamic/&#34;&gt;nice blog post&lt;/a&gt; to compare &lt;code&gt;quickcheck-dynamic&lt;/code&gt; with &lt;a href=&#34;https://hackage.haskell.org/package/quickcheck-state-machine&#34;&gt;quickcheck-state-machine&lt;/a&gt;, another library to write model-based tests on top of QuickCheck. This blog post introduces &lt;a href=&#34;https://github.com/well-typed/quickcheck-lockstep&#34;&gt;quickcheck-lockstep&lt;/a&gt; which provides &lt;em&gt;lockstep-style&lt;/em&gt; testing on top of quickcheck-dynamic.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;h3&gt;Without nix&lt;/h3&gt; &#xA;&lt;p&gt;This package uses &lt;a href=&#34;https://www.haskell.org/cabal/&#34;&gt;Cabal&lt;/a&gt;-based build. To build from source:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ensure both &lt;code&gt;ghc&lt;/code&gt; and &lt;code&gt;cabal&lt;/code&gt; executables are in your &lt;code&gt;PATH&lt;/code&gt;. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;ghcup&lt;/a&gt; is a great way to manage Haskell toolchain.&lt;/li&gt; &#xA;   &lt;li&gt;quickcheck-dynamic currently requires a GHC version &amp;gt; 8.10&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Run &lt;pre&gt;&lt;code&gt;cabal update &amp;amp;&amp;amp; cabal build all&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;To run tests: &lt;pre&gt;&lt;code&gt;cabal test all&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;With nix&lt;/h3&gt; &#xA;&lt;p&gt;This repository comes with some &lt;a href=&#34;https://nixos.org&#34;&gt;nix&lt;/a&gt; files which might or might not help hacking on quickcheck-dynamic simpler. Before you start using nix, please make sure you&#39;ve configured haskell.nix caching as per &lt;a href=&#34;https://input-output-hk.github.io/haskell.nix/tutorials/getting-started.html#setting-up-the-binary-cache&#34;&gt;those instructions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Building with nix should be as simple as: &lt;pre&gt;&lt;code&gt;nix-build -A quickcheck-dynamic.components.library&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;To enter a shell providing basic development tool: &lt;pre&gt;&lt;code&gt;nix-shell&#xA;&lt;/code&gt;&lt;/pre&gt; This can automated using &lt;a href=&#34;https://direnv.net/&#34;&gt;direnv&lt;/a&gt;: &lt;pre&gt;&lt;code&gt;direnv allow&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Then go back to &lt;a href=&#34;https://raw.githubusercontent.com/input-output-hk/quickcheck-dynamic/main/#without-nix&#34;&gt;Without nix&lt;/a&gt; instructions&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>input-output-hk/Win32-network</title>
    <updated>2022-10-02T01:43:04Z</updated>
    <id>tag:github.com,2022-10-02:/input-output-hk/Win32-network</id>
    <link href="https://github.com/input-output-hk/Win32-network" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Networking library for Windows&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Asynchronous IO for Windows&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;Win32-network&lt;/code&gt; provides interface for asynchronous (overlapped) IO on Windows via implemented IO manager. It supports:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;File&lt;/code&gt; api&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NamedPipes&lt;/code&gt; api&lt;/li&gt; &#xA; &lt;li&gt;Berkeley sockets api on Windows via &lt;code&gt;winsock2&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;NamedPipes&lt;/code&gt; provide a good alternative for the lack of Unix Sockets on Windows, and there are ways of providing abstraction for both, though this is not present in this package.&lt;/p&gt; &#xA;&lt;p&gt;An application which is using this package should use &lt;code&gt;-threaded&lt;/code&gt; option, as the io manager thread runs a blocking ffi call (e.g. &lt;a href=&#34;https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus&#34;&gt;GetQueuedCompletionStatus&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Haddocks&lt;/h2&gt; &#xA;&lt;p&gt;Haddocks are available via &lt;a href=&#34;https://input-output-hk.github.io/Win32-network&#34;&gt;github-pages&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;GHC Native IO Manager&lt;/h2&gt; &#xA;&lt;p&gt;A recent version of GHC has a native io-manager on Windows. Part of this library will become obsolete once the &lt;a href=&#34;https://hackage.haskell.org/package/network&#34;&gt;network&lt;/a&gt; will use it.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgement&lt;/h2&gt; &#xA;&lt;p&gt;The initial version of this library was based on &lt;a href=&#34;https://hackage.haskell.org/package/winio&#34;&gt;winio&lt;/a&gt; by Felix Martini.&lt;/p&gt;</summary>
  </entry>
</feed>