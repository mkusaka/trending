<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-09T01:42:59Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>erebe/wstunnel</title>
    <updated>2022-10-09T01:42:59Z</updated>
    <id>tag:github.com,2022-10-09:/erebe/wstunnel</id>
    <link href="https://github.com/erebe/wstunnel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Tunneling over websocket protocol - Static binary available&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/erebe/wstunnel/raw/master/logo_wstunnel.png&#34; alt=&#34;wstunnel logo&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;Most of the time when you are using a public network, you are behind some kind of firewall or proxy. One of their purpose is to constrain you to only use certain kind of protocols. Nowadays, the most widespread protocol is http and is de facto allowed by third party equipment.&lt;/p&gt; &#xA;&lt;p&gt;This tool understands this fact and uses the websocket protocol which is compatible with http in order to bypass firewalls and proxies. Wstunnel allows you to tunnel what ever traffic you want.&lt;/p&gt; &#xA;&lt;p&gt;My inspiration came from &lt;a href=&#34;https://www.npmjs.com/package/wstunnel&#34;&gt;this project&lt;/a&gt; but as I don&#39;t want to install npm and nodejs to use this tool, I remade it in Haskell and improved it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;What to expect:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Good error messages and debug informations&lt;/li&gt; &#xA; &lt;li&gt;Static tunneling (TCP and UDP)&lt;/li&gt; &#xA; &lt;li&gt;Dynamic tunneling (socks5 proxy)&lt;/li&gt; &#xA; &lt;li&gt;Support for http proxy (when behind one)&lt;/li&gt; &#xA; &lt;li&gt;Support for tls/https server (with embedded self signed certificate, see comment in the example section)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Standalone binary for linux x86_64&lt;/strong&gt; (so just cp it where you want)&lt;/li&gt; &#xA; &lt;li&gt;Standalone archive for windows&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;P.S: Please do not pay attention to Main.hs because as I hate to write command line code this file is crappy&lt;/p&gt; &#xA;&lt;h2&gt;Command line&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Use the websockets protocol to tunnel {TCP,UDP} traffic&#xA;wsTunnelClient &amp;lt;---&amp;gt; wsTunnelServer &amp;lt;---&amp;gt; RemoteHost&#xA;Use secure connection (wss://) to bypass proxies&#xA;&#xA;wstunnel [OPTIONS] ws[s]://wstunnelServer[:port]&#xA;&#xA;Client options:&#xA;  -L --localToRemote=[BIND:]PORT:HOST:PORT      Listen on local and forwards&#xA;                                                traffic from remote. Can be&#xA;                                                used multiple time&#xA;  -D --dynamicToRemote=[BIND:]PORT              Listen on local and&#xA;                                                dynamically (with socks5 proxy)&#xA;                                                forwards traffic from remote&#xA;  -u --udp                                      forward UDP traffic instead&#xA;                                                of TCP&#xA;     --udpTimeoutSec=INT                        When using udp forwarding,&#xA;                                                timeout in seconds after when&#xA;                                                the tunnel connection is&#xA;                                                closed. Default 30sec, -1 means&#xA;                                                no timeout&#xA;  -p --httpProxy=USER:PASS@HOST:PORT            If set, will use this proxy&#xA;                                                to connect to the server&#xA;     --soMark=int                               (linux only) Mark network&#xA;                                                packet with SO_MARK sockoption&#xA;                                                with the specified value. You&#xA;                                                need to use {root, sudo,&#xA;                                                capabilities} to run wstunnel&#xA;                                                when using this option&#xA;     --upgradePathPrefix=String                 Use a specific prefix that&#xA;                                                will show up in the http path&#xA;                                                in the upgrade request. Useful&#xA;                                                if you need to route requests&#xA;                                                server side but don&#39;t have&#xA;                                                vhosts&#xA;     --hostHeader=String                        If set, add the custom string&#xA;                                                as host http header&#xA;     --tlsSNI=String                            If set, use custom string in&#xA;                                                the SNI during TLS handshake&#xA;     --websocketPingFrequencySec=int            do a hearthbeat ping every x&#xA;                                                seconds to maintain websocket&#xA;                                                connection&#xA;     --upgradeCredentials=USER[:PASS]           Credentials for the Basic&#xA;                                                HTTP authorization type sent&#xA;                                                with the upgrade request.&#xA;  -H --customHeaders=&#34;HeaderName: HeaderValue&#34;  Send custom headers in the&#xA;                                                upgrade request. Can be used&#xA;                                                multiple time&#xA;  -h --help                                     Display help message&#xA;  -V --version                                  Print version information&#xA;Server options:&#xA;     --server                                   Start a server that will&#xA;                                                forward traffic for you&#xA;  -r --restrictTo=HOST:PORT                     Accept traffic to be&#xA;                                                forwarded only to this service&#xA;Common options:&#xA;  -v --verbose                                  Print debug information&#xA;  -q --quiet                                    Print only errors&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Simplest one&lt;/h3&gt; &#xA;&lt;p&gt;On your remote host, start the wstunnel&#39;s server by typing this command in your terminal&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wstunnel --server ws://0.0.0.0:8080&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create a websocket server listening on any interface on port 8080. On the client side use this command to forward traffic through the websocket tunnel&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wstunnel -D 8888 ws://myRemoteHost:8080&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This command will create a sock5 server listening on port 8888 of a loopback interface and will forward traffic.&lt;/p&gt; &#xA;&lt;p&gt;With firefox you can setup a proxy using this tunnel, by setting in networking preferences 127.0.0.1:8888 and selecting socks5 proxy&lt;/p&gt; &#xA;&lt;p&gt;or with curl&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -x socks5h://127.0.0.1:8888 http://google.com/&#xA;#Please note h after the 5, it is to avoid curl resolving DNS name locally&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;As proxy command for SSH&lt;/h3&gt; &#xA;&lt;p&gt;You can specify &lt;code&gt;stdio&lt;/code&gt; as source port on the client side if you wish to use wstunnel as part of a proxy command for ssh&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ssh -o ProxyCommand=&#34;wstunnel -L stdio:%h:%p ws://localhost:8080&#34; my-server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;When behind a corporate proxy&lt;/h3&gt; &#xA;&lt;p&gt;An other useful example is when you want to bypass an http proxy (a corporate proxy for example) The most reliable way to do it is to use wstunnel as described below&lt;/p&gt; &#xA;&lt;p&gt;Start your wstunnel server with tls activated&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;wstunnel --server wss://0.0.0.0:443 -r 127.0.0.1:22&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The server will listen on any interface using port 443 (https) and restrict traffic to be forwarded only to the ssh daemon.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Be aware that the server will use self signed certificate with weak cryptographic algorithm. It was made in order to add the least possible overhead while still being compliant with tls.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Do not rely on wstunnel to protect your privacy, as it only forwards traffic that is already secure by design (ex: https)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now on the client side start the client with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;wstunnel -L 9999:127.0.0.1:22 -p mycorporateproxy:8080 wss://myRemoteHost:443&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It will start a tcp server on port 9999 that will contact the corporate proxy, negotiate a tls connection with the remote host and forward traffic to the ssh daemon on the remote host.&lt;/p&gt; &#xA;&lt;p&gt;You may now access your server from your local machine on ssh by using&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ssh -p 9999 login@127.0.0.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Wireguard and wstunnel&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://kirill888.github.io/notes/wireguard-via-websocket/&#34;&gt;https://kirill888.github.io/notes/wireguard-via-websocket/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to Build&lt;/h2&gt; &#xA;&lt;p&gt;Install the stack tool &lt;a href=&#34;https://docs.haskellstack.org/en/stable/README/&#34;&gt;https://docs.haskellstack.org/en/stable/README/&lt;/a&gt; or if you are a believer&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl -sSL https://get.haskellstack.org/ | sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and run those commands at the root of the project&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;stack init&#xA;stack install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Add sock5 proxy&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Add better logging&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Add better error handling&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Add httpProxy authentification&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add Reverse tunnel&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Add more tests for socks5 proxy&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>input-output-hk/ekg-forward</title>
    <updated>2022-10-09T01:42:59Z</updated>
    <id>tag:github.com,2022-10-09:/input-output-hk/ekg-forward</id>
    <link href="https://github.com/input-output-hk/ekg-forward" rel="alternate"></link>
    <summary type="html">&lt;p&gt;EKG forwarding library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ekg-forward&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/input-output-hk/ekg-forward/actions&#34;&gt;&lt;img src=&#34;https://github.com/input-output-hk/ekg-forward/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;GitHub CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What Is It&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;ekg-forward&lt;/code&gt; is a library allowing to forward &lt;a href=&#34;https://hackage.haskell.org/package/ekg-core&#34;&gt;EKG system metrics&lt;/a&gt; from one process to another one.&lt;/p&gt; &#xA;&lt;h2&gt;Main Use Case&lt;/h2&gt; &#xA;&lt;p&gt;You have one Haskell application that collects its EKG system metrics (both predefined and custom) and another Haskell application that needs to receive those metrics. You can think of the first application as a Forwarder and the second one as an Acceptor.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;There is &lt;code&gt;ekg&lt;/code&gt; &lt;a href=&#34;https://hackage.haskell.org/package/ekg&#34;&gt;package&lt;/a&gt; that already lets you remotely monitor a running Haskell process over HTTP. But there are three main differences between &lt;code&gt;ekg&lt;/code&gt; and &lt;code&gt;ekg-forward&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;ekg&lt;/code&gt; provides HTTP server for monitoring, &lt;code&gt;ekg-forward&lt;/code&gt; is a lightweight library without HTTP and REST API.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ekg-forward&lt;/code&gt; is based on Haskell typed protocol, which provides type-level guarantees of correctness.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ekg-forward&lt;/code&gt;&#39;s network layer uses &lt;code&gt;ouroboros-network-framework&lt;/code&gt; &lt;a href=&#34;https://github.com/input-output-hk/ouroboros-network/&#34;&gt;package&lt;/a&gt; which supports both network sockets and local pipes for connection.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;How To Use It&lt;/h2&gt; &#xA;&lt;p&gt;You can find demo programs in the &lt;code&gt;demo&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;Please note that &lt;strong&gt;not all&lt;/strong&gt; EKG metrics are supported in the current release:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/ekg-core-0.1.1.7/docs/System-Metrics-Gauge.html&#34;&gt;Gauge&lt;/a&gt; - supported&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/ekg-core-0.1.1.7/docs/System-Metrics-Label.html&#34;&gt;Label&lt;/a&gt; - supported&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/ekg-core-0.1.1.7/docs/System-Metrics-Counter.html&#34;&gt;Counter&lt;/a&gt; - supported&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/ekg-core-0.1.1.7/docs/System-Metrics-Distribution.html&#34;&gt;Distribution&lt;/a&gt; - does &lt;strong&gt;not&lt;/strong&gt; supported&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>haskell-beginners-2022/exercises</title>
    <updated>2022-10-09T01:42:59Z</updated>
    <id>tag:github.com,2022-10-09:/haskell-beginners-2022/exercises</id>
    <link href="https://github.com/haskell-beginners-2022/exercises" rel="alternate"></link>
    <summary type="html">&lt;p&gt;💻 Exercises for the Haskell Beginners 2022 course&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;exercises&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/haskell-beginners-2022/exercises/actions&#34;&gt;&lt;img src=&#34;https://github.com/haskell-beginners-2022/exercises/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;GitHub CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/exercises&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/exercises.svg?logo=haskell&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/haskell-beginners-2022/exercises/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MPL--2.0-blue.svg?sanitize=true&#34; alt=&#34;MPL-2.0 license&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Exercises for the Haskell Beginners 2022 course. The course itself can be found here:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/haskell-beginners-2022/course-plan&#34;&gt;Haskell Beginners 2022 Course&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This repository contains a complete Haskell project. The project comprises four Haskell files (modules) in the &lt;code&gt;src/&lt;/code&gt; directory. Each module provides exercises for an individual lecture and has the corresponding name (e.g. &lt;code&gt;Lecture1.hs&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Working with the course&lt;/h2&gt; &#xA;&lt;p&gt;This section contains instructions about setting up the development environment and preparing the exercises repository.&lt;/p&gt; &#xA;&lt;h3&gt;First time&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://docs.github.com/en/free-pro-team@latest/github/getting-started-with-github/fork-a-repo&#34;&gt;Fork the &lt;code&gt;exercises&lt;/code&gt; repository&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Enable GitHub Actions for your forked repository.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Visit: &lt;code&gt;https://github.com/&amp;lt;YOUR_GITHUB_USERNAME&amp;gt;/exercises/actions&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone your forked repository.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Enter the &lt;code&gt;exercises&lt;/code&gt; directory and add the original repository as a &lt;code&gt;course&lt;/code&gt; remote.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git remote add course https://github.com/haskell-beginners-2022/exercises&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You can verify that everything is done correctly by running the &lt;code&gt;git remote -v&lt;/code&gt; command. The output of this command will look similar to the below:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;course https://github.com/haskell-beginners-2022/exercises (fetch)&#xA;course https://github.com/haskell-beginners-2022/exercises (push)&#xA;origin git@github.com:chshersh/exercises.git (fetch)&#xA;origin git@github.com:chshersh/exercises.git (push)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Asking for feedback&lt;/h3&gt; &#xA;&lt;p&gt;Implement your solutions in a separate branch (not &lt;code&gt;main&lt;/code&gt;). You can run the following command to create a new branch and switch to it at the same time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git checkout -b lecture-1-solutions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you have finished implementing exercises for a particular lecture, create a Pull Request to &lt;strong&gt;your fork&lt;/strong&gt;. The repository already contains PR template with the prefilled text and mentions all current mentors of the course.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;ℹ️&lt;strong&gt;NOTE:&lt;/strong&gt; Open Pull Request to &lt;strong&gt;your fork&lt;/strong&gt; and not this repository. We can&#39;t merge solutions to this repo. But if you open PRs to your repository, you can eventually merge all the solutions and enjoy green all-passing CI 🍏&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To open a PR to your fork, you need to change &lt;em&gt;base repository&lt;/em&gt; to your own repository, as shown on the screenshot below:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/4276606/147921946-e9b84424-e76f-4f7a-8976-e33564ae1532.png&#34; alt=&#34;PR to fork example&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;After you change, the PR view will change accordingly:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/4276606/147922107-78f80f23-e98c-47f8-8cb3-d20a8b2f771d.png&#34; alt=&#34;Final PR to fork&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Updating your fork&lt;/h3&gt; &#xA;&lt;p&gt;The course content (exercises, tests, configuration, etc.) might change after you forked the course. To get the latest updates, follow the below instructions:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Switch to your &lt;code&gt;main&lt;/code&gt; branch locally and make sure it&#39;s in sync with the latest version of your fork on GitHub.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git checkout main&#xA;git pull --rebase --prune&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fetch all the course changes and save them locally.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git fetch course main&#xA;git rebase course/main&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;NOTE: This stage may require you to resolve conflicts.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Push local changes to your own fork.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git push origin main --force&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Installing Haskell&lt;/h2&gt; &#xA;&lt;p&gt;Follow the below instructions to configure the Haskell development environment.&lt;/p&gt; &#xA;&lt;h3&gt;Haskell Toolchain&lt;/h3&gt; &#xA;&lt;p&gt;To develop in Haskell, you need to install &lt;code&gt;ghcup&lt;/code&gt;, &lt;code&gt;ghc&lt;/code&gt; and &lt;code&gt;cabal&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install &lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;ghcup&lt;/a&gt; and follow &lt;code&gt;ghcup&lt;/code&gt; instructions for successful installation (remember to restart your terminal afterwards to avoid an &lt;code&gt;unknown ghcup command&lt;/code&gt; error on the next step).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the recommended version of the Haskell compiler — GHC — and the &lt;a href=&#34;https://www.haskell.org/cabal/&#34;&gt;Cabal&lt;/a&gt; build tool. After you install &lt;code&gt;ghcup&lt;/code&gt;, it is easy to install the rest with a few commands from your terminal, if these tools are not yet installed.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ghcup install ghc 8.10.7&#xA;ghcup set ghc 8.10.7&#xA;ghcup install cabal 3.6.2.0&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You can verify that everything is installed correctly by running the following commands:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ghc --version&#xA;The Glorious Glasgow Haskell Compilation System, version 8.10.7&#xA;$ cabal --version&#xA;cabal-install version 3.6.2.0&#xA;compiled using version 3.6.2.0 of the Cabal library&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run &lt;code&gt;cabal update&lt;/code&gt; to fetch the latest info about Haskell packages.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Haskell IDE&lt;/h3&gt; &#xA;&lt;p&gt;If you don&#39;t have any IDE preferences, we recommend installing &lt;a href=&#34;https://code.visualstudio.com/download&#34;&gt;Visual Studio Code&lt;/a&gt; with the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=haskell.haskell&#34;&gt;Haskell plugin&lt;/a&gt;. The mentioned plugin would give you everything required to immediately start coding with Haskell.&lt;/p&gt; &#xA;&lt;h3&gt;Gitpod&lt;/h3&gt; &#xA;&lt;p&gt;Instead of configuring a local setup, you can also use &lt;a href=&#34;https://www.gitpod.io/&#34;&gt;Gitpod&lt;/a&gt;, a VSCode-based Web IDE.&lt;/p&gt; &#xA;&lt;p&gt;Click the button below. A workspace with Haskell environment will be created.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitpod.io/#https://github.com/haskell-beginners-2022/exercises&#34;&gt;&lt;img src=&#34;https://gitpod.io/button/open-in-gitpod.svg?sanitize=true&#34; alt=&#34;Open in Gitpod&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To use it on your forked repo, edit the &#39;Open in Gitpod&#39; button url to &lt;code&gt;https://gitpod.io/#https://github.com/&amp;lt;my-github-username&amp;gt;/exercises&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to build and test?&lt;/h2&gt; &#xA;&lt;p&gt;There&#39;re two ways to build this project: using either &lt;code&gt;cabal&lt;/code&gt; or &lt;code&gt;stack&lt;/code&gt; build tools. Using &lt;code&gt;cabal&lt;/code&gt; is the recommended way. However, if it doesn&#39;t work, you may want to use &lt;code&gt;stack&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Cabal&lt;/h3&gt; &#xA;&lt;p&gt;To compile the entire project, run the following command from your terminal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run tests for a specific lecture only (e.g. the first one), use the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make test-lecture1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also run tests only for a single function. For example, to run tests for the &lt;code&gt;strSum&lt;/code&gt; function, execute the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cabal run exercises-test --enable-tests -- -m &#34;strSum&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stack&lt;/h3&gt; &#xA;&lt;p&gt;Use the &lt;a href=&#34;https://docs.haskellstack.org/en/stable/install_and_upgrade/&#34;&gt;official &lt;code&gt;stack&lt;/code&gt; installation instructions&lt;/a&gt; to install &lt;code&gt;stack&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To build the project with &lt;code&gt;stack&lt;/code&gt;, run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;stack build --test --no-run-tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run tests for the first lecture, run the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;stack test :doctest-lecture1&#xA;stack test :exercises-test --test-arguments=&#39;-m &#34;Lecture 1&#34;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And to tests a specific function, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;stack test :exercises-test --test-arguments=&#39;-m &#34;strSum&#34;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Acknowledgement&lt;/h2&gt; &#xA;&lt;p&gt;This course is inspired by &lt;a href=&#34;https://github.com/kowainik/learn4haskell&#34;&gt;Learn4Haskell&lt;/a&gt; authored by &lt;a href=&#34;https://github.com/vrom911&#34;&gt;@vrom911&lt;/a&gt; and &lt;a href=&#34;https://github.com/chshersh&#34;&gt;@chshersh&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>