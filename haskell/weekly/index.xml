<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-16T01:56:28Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>marcosh/crem</title>
    <updated>2023-04-16T01:56:28Z</updated>
    <id>tag:github.com,2023-04-16:/marcosh/crem</id>
    <link href="https://github.com/marcosh/crem" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Compositional Representable Executable Machines&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;https://github.com/tweag/crem&#34;&gt;crem&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tweag/crem/main/logo/crem-transparent.png&#34; width=&#34;200&#34;&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/tweag/crem/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI status&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;crem&lt;/code&gt; stands for &lt;strong&gt;c&lt;/strong&gt;ompositional &lt;strong&gt;r&lt;/strong&gt;epresentable &lt;strong&gt;e&lt;/strong&gt;xecutable &lt;strong&gt;m&lt;/strong&gt;achines.&lt;/p&gt; &#xA;&lt;p&gt;It allows defining state machines (Mealy machines in fact), composing them to build bigger machines out of smaller ones and then running them and drawing their flow and their state space.&lt;/p&gt; &#xA;&lt;h2&gt;What can you do with &lt;code&gt;crem&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;Defining state machines&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;crem&lt;/code&gt; allows you to define state machines so that you can enforce which state transitions are actually allowed by your machine.&lt;/p&gt; &#xA;&lt;p&gt;If you try to implement a machine by running a transition which is not allowed, you will get a compilation error.&lt;/p&gt; &#xA;&lt;p&gt;More details on how to define a machine at &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/docs/how-to-create-a-machine.md&#34;&gt;How to create a machine&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Composing state machines&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;crem&lt;/code&gt; allows you to compose machines together to build more complex ones, proving a compositional language to implement state machines.&lt;/p&gt; &#xA;&lt;p&gt;More details on how to compose machines at &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/docs/how-to-compose-machines.md&#34;&gt;How to compose machines&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Rendering a state machine&lt;/h3&gt; &#xA;&lt;p&gt;Thanks to the information on the allowed transitions &lt;code&gt;crem&lt;/code&gt; collects when you define a machine, it is able to produce a graphical representation of the flow and the state space of your machine.&lt;/p&gt; &#xA;&lt;p&gt;One example of such an output is&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://mermaid.ink/svg/pako:eNqlVF1PwjAU_SvkPmkyCGCBbQ8mCvqkxkj0wSwhzXad1a4lXUdAsv9u9-HcCMgMfepOz73n3PbubsGXAYILsaYaZ4yGikbd1dATHbNysEPDUGGY7bYFnK0KXDzIGdX0BZXG9b7zqeQcfY3Bc4yqJfVOUjFDTRmPb5mK9eGQJ_SRrTCYKgyYvk4U0iQTORJWKV1x_renenmdbvfyxMqa1EMJ29ffLvGpt7TfzyH3R--0hZ1_5E7rzbqUnPmbeqcWyOLsvMH-bepMqOAUJ2WGhn5DQckPY4VJ0VCp0MWciZDjYwXs8bqjXlHrOpEvhU91XaSEdmupOcrSlSywIEIVURaY3ztP4oF-xwg9cM02oOrTA0-khpcsA6N4Y95CKnDfKI_RAppoOd8IH1ytEvwhlSOiYi2peJWy8Q3uFtbgkv6oN7ZtZ0xscjEZWbABdziY9IjjODaZkMFw0HdIasFXHt_vGQrmFu6LkZRPpvQbS36R_g&#34; alt=&#34;risk manager flow&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;More details on how to render a machine at &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/docs/how-to-render-a-machine.md&#34;&gt;How to render a machine&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Running a machine&lt;/h3&gt; &#xA;&lt;p&gt;Last but not the least, you can also execute a machine, providing inputs to it and receiving the emitted outputs.&lt;/p&gt; &#xA;&lt;p&gt;More details on how to run a machine at &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/docs/how-to-run-a-machine.md&#34;&gt;How to run a machine&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Want to know more?&lt;/h3&gt; &#xA;&lt;p&gt;Further documentation can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/docs&#34;&gt;docs&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/examples&#34;&gt;examples&lt;/a&gt; folder contains a lot of examples, from simple machines to complex ones describing entire workflows.&lt;/p&gt; &#xA;&lt;p&gt;I would recommend to check:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/examples/Crem/Example/TwoSwitchesGate.lhs&#34;&gt;TwoSwitchesGate.lhs&lt;/a&gt; if you want to see all the code which is needed to use the library with a quite detailed explanation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/examples/Crem/Example/RiskManager/&#34;&gt;RiskManager&lt;/a&gt; if you want to see how to use &lt;code&gt;crem&lt;/code&gt; to &lt;a href=&#34;http://marcosh.github.io/post/2021/10/27/ddd-state-machines.html&#34;&gt;model your domain using state machines&lt;/a&gt; following the ideas coming from Domain Driven Design.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/examples/Crem/Example/Uno.hs&#34;&gt;Uno.hs&lt;/a&gt; if you want to see how to structure a card game like &lt;a href=&#34;https://en.wikipedia.org/wiki/Uno_(card_game)&#34;&gt;Uno&lt;/a&gt;, with an implementation ported from &lt;a href=&#34;https://github.com/thinkbeforecoding/UnoCore/raw/solution/Uno/Game.fs&#34;&gt;UnoCore&lt;/a&gt; by &lt;a href=&#34;https://functional.cafe/@thinkb4coding@mastodon.social&#34;&gt;@thinkb4coding@mastodon.social&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Be sure to check out also the &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/spec&#34;&gt;spec&lt;/a&gt; folder, where all the tests of the application are included, to see in practice what you can do with &lt;code&gt;crem&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;This is a Haskell Cabal project that uses Nix for development. Nix is optional but recommended.&lt;/p&gt; &#xA;&lt;h3&gt;environment&lt;/h3&gt; &#xA;&lt;p&gt;A Nix shell is available with all the required tools. To enter the shell, issue&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# default GHC&#xA;nix develop&#xA;&#xA;# custom GHC&#xA;nix develop .#ghc90&#xA;nix develop .#ghc92&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, without flakes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# default GHC&#xA;nix-shell&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;GHC version&lt;/h3&gt; &#xA;&lt;p&gt;The project has a default GHC version that is specified in the flake. At the moment that version is 9.0, because the HLS plugin Wingman &lt;a href=&#34;https://github.com/haskell/haskell-language-server/issues/2971&#34;&gt;currently only builds up to this version&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is also possible to use other GHC versions to build the project and enter development shells. This allows us to easily test multiple versions.&lt;/p&gt; &#xA;&lt;h3&gt;Building&lt;/h3&gt; &#xA;&lt;p&gt;In a development shell, you can simply build the project with Cabal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cabal build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This provides us fast incremental builds, ease of debugging, etc.&lt;/p&gt; &#xA;&lt;p&gt;Inside the development shell, you can also use the commands&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# just build the project&#xA;build-watch&#xA;&#xA;# execute also the tests&#xA;test-watch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Haddock documentation&lt;/h3&gt; &#xA;&lt;p&gt;You can generate and see the [Haddock] documentation by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cabal haddock --open&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Code formatting&lt;/h3&gt; &#xA;&lt;p&gt;Code is formatted using &lt;a href=&#34;https://github.com/fourmolu/fourmolu&#34;&gt;fourmolu&lt;/a&gt; version 0.10.1.0.&lt;/p&gt; &#xA;&lt;h3&gt;Cabal flags&lt;/h3&gt; &#xA;&lt;p&gt;We have a &lt;code&gt;cabal&lt;/code&gt; flag called &lt;code&gt;errors&lt;/code&gt; which allows enabling &lt;code&gt;-Werror&lt;/code&gt;. It has a default of &lt;code&gt;False&lt;/code&gt;, so that warning are not turned into errors.&lt;/p&gt; &#xA;&lt;p&gt;In development and CI we use the flag &lt;code&gt;-f errors&lt;/code&gt; so that we can avoid any warning in the library code.&lt;/p&gt; &#xA;&lt;h3&gt;Changelog&lt;/h3&gt; &#xA;&lt;p&gt;All changes are tracked in the &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/CHANGELOG.md&#34;&gt;&lt;code&gt;Changelog&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Project setup&lt;/h2&gt; &#xA;&lt;p&gt;You can find more details on the project setup on &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/Setup.md&#34;&gt;Setup.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Known limitations&lt;/h2&gt; &#xA;&lt;p&gt;The project is still in its early stage and not everything is crafted to perfection.&lt;/p&gt; &#xA;&lt;p&gt;Some known limitations to the current state of the project are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;crem&lt;/code&gt; has not been tested on huge state machines. Compilation times might grow very rapidly.&lt;/li&gt; &#xA; &lt;li&gt;the topologies which &lt;code&gt;crem&lt;/code&gt; allows you to define need to be finite, and not particularly big, either. For example, it is not feasible to use &lt;code&gt;Int&lt;/code&gt; as the type of vertices for a topology.&lt;/li&gt; &#xA; &lt;li&gt;in its current state, the &lt;code&gt;StateMachine&lt;/code&gt; type is not extensible. It has a predefined set of constructors, but maybe there are more which make sense and are not present yet.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Moreover, for current bugs and feature requests, you can check the &lt;a href=&#34;https://github.com/tweag/crem/issues&#34;&gt;open issues&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/marcosh/crem/main/logo/tweag.png&#34; alt=&#34;tweag logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The initial development of &lt;code&gt;crem&lt;/code&gt; was funded by &lt;a href=&#34;https://www.tweag.io/&#34;&gt;Tweag&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributions&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are extremely welcome. If you have any idea on how to improve the library, its code or its documentation, feel free to open an &lt;a href=&#34;https://github.com/tweag/crem/issues&#34;&gt;issue&lt;/a&gt;, create a &lt;a href=&#34;https://github.com/tweag/crem/pulls&#34;&gt;pull request&lt;/a&gt;, or just contact directly one of the maintainers.&lt;/p&gt; &#xA;&lt;h2&gt;Logo&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;crem&lt;/code&gt; logo was kindly generated by &lt;a href=&#34;https://www.craiyon.com/&#34;&gt;craiyon&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;p&gt;If you want to know a bit more of &lt;code&gt;crem&lt;/code&gt; and some ideas behind it, here are some additional resources you can check out:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://marcosh.github.io/post/2021/10/27/ddd-state-machines.html&#34;&gt;Domain modelling with state machines&lt;/a&gt;, the first blog post where I started considering using composable state machines for DDD-like architectures.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=cvbOG1I6wrU&#34;&gt;Composable Haskell state machines with &lt;code&gt;crem&lt;/code&gt;&lt;/a&gt;, if you prefer a video introducing &lt;code&gt;crem&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackmd.io/@CJO5VbycTsyzjGBytbwezQ/rkJliIjRj#/&#34;&gt;State machines with &lt;code&gt;crem&lt;/code&gt;&lt;/a&gt; the slide deck used for the above presentation.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>input-output-hk/quickcheck-contractmodel</title>
    <updated>2023-04-16T01:56:28Z</updated>
    <id>tag:github.com,2023-04-16:/input-output-hk/quickcheck-contractmodel</id>
    <link href="https://github.com/input-output-hk/quickcheck-contractmodel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Adversary testing of your plutus contract&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Contract Model&lt;/h1&gt; &#xA;&lt;p&gt;This repository provides an interface to &lt;a href=&#34;https://github.com/input-output-hk/quickcheck-dynamic/&#34;&gt;quickcheck-dynamic&lt;/a&gt; for developers of Plutus scripts. The main purpose of this repository is to offer an alternative to testing Plutus scripts with quickcheck via the &lt;a href=&#34;https://github.com/input-output-hk/plutus-apps/&#34;&gt;plutus-apps&lt;/a&gt; repository. If you use the plutus-apps repository for development of your scripts, we refer to the &lt;a href=&#34;https://plutus-apps.readthedocs.io/en/latest/plutus/tutorials/contract-models.html&#34;&gt;tutorials&lt;/a&gt;. You do not need this repository, it is a dependency of plutus-apps.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;TODO: we need some form of &#34;how to get started&#34; thing that details the work you need to do here. This requires having some base emulator that people can use...&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Automatic test case generation&lt;/h2&gt; &#xA;&lt;p&gt;This repository provides you with the means to automatically generate test cases for your Cardano smart contracts. To do this it uses a model of the contract that you provide as an instance of the &lt;code&gt;ContactModel&lt;/code&gt; class. This model describes for each action of your contract (e.g. contract endpoint or functionality) what the behaviour of that action is on an abstracted contract and blockchain state. It is very similar to the models provided in this &lt;a href=&#34;https://plutus-apps.readthedocs.io/en/latest/plutus/tutorials/contract-models.html&#34;&gt;tutorial&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to be independent of plutus-apps, use your own way and languages designing Plutus scripts, then this repository offers an emulator-generic interface for testing Cardano contracts on top of quickcheck-dynamic. There are standard properties that quickcheck tests for. The models provide automatic shrinking of failing test cases, such that your debug effort is minimized.&lt;/p&gt; &#xA;&lt;h2&gt;Actions and Transactions&lt;/h2&gt; &#xA;&lt;p&gt;The contract model describes the actions users can perform with your contract. Many of these actions will result in the generation of a transaction that is then posted to the blockchain. However, you can also add actions to the model to wait a certain number of blocks or to put funds or tokens into a wallet not involving the plutus script under test. The actions described in the model have to be connected to the world in which you write your contract via the interface of a &lt;code&gt;perform&lt;/code&gt; function via the &lt;code&gt;RunModel&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;p&gt;The way to think about it is like a phase separation between the abstract world of actions acting on a model, like &lt;code&gt;Pay&lt;/code&gt; and &lt;code&gt;Redeem&lt;/code&gt;, whereas you build your transactions via some code that comes up with the actual transaction that you have written as part of your contract API. If that API is Haskell, then the effort to write the &lt;code&gt;perform&lt;/code&gt; function is rather limited. However, if you have written it in a different language, you need to bridge between Haskell and that language.&lt;/p&gt; &#xA;&lt;p&gt;You have to provide an interface between the abstract operations in the contract model and the off-chain code in your project that creates the actual transactions.&lt;/p&gt; &#xA;&lt;h2&gt;Blockchain Emulation&lt;/h2&gt; &#xA;&lt;p&gt;In order to test your contract, the transactions you create are posted to a blockchain emulator. You can use any emulator you fancy as long as it is Cardano.API compatible. You could even use a testnet, but be aware that this can be very slow if you run hundreds of transactions in your tests. The API you need to implement talking to your emulator of choice is documented in &lt;a href=&#34;https://raw.githubusercontent.com/input-output-hk/quickcheck-contractmodel/master/EmulatorAPI.md&#34;&gt;EmulatorAPI.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Coverage data&lt;/h2&gt; &#xA;&lt;p&gt;When quickcheck runs your property, it collect on-chain coverage data (see &lt;a href=&#34;https://plutus-apps.readthedocs.io/en/latest/plutus/tutorials/contract-models.html#measuring-coverage-of-on-chain-code&#34;&gt;this&lt;/a&gt;). That is, it collects statistics which part of the validators are used during testing, but most importantly, which validator parts are never used during testing. If certain parts of the validator are never triggered during testing, then testing may not be through enough.&lt;/p&gt; &#xA;&lt;p&gt;We use the standard plutus compiler to insert coverage tags in the on-chain code. If you do not use the plutus compiler and still want to collect on-chain validator coverage information, you’ll need to add those in a different way.&lt;/p&gt; &#xA;&lt;h2&gt;Standard properties&lt;/h2&gt; &#xA;&lt;p&gt;There are standard properties for checking that your contract cannot get in a state in which funds are locked and nobody can get those funds out. You can re-use those properties. You can add your own additional unit tests, if so required.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;TODO: Something about double satisfaction and threat models later&lt;/em&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>bvssvni/haskell-groups</title>
    <updated>2023-04-16T01:56:28Z</updated>
    <id>tag:github.com,2023-04-16:/bvssvni/haskell-groups</id>
    <link href="https://github.com/bvssvni/haskell-groups" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Group oriented programming in Haskell.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;haskell-groups&lt;/h1&gt; &#xA;&lt;p&gt;Group oriented programming in Haskell.&lt;br&gt; BSD license.&lt;br&gt; For version log, view the individual files.&lt;/p&gt; &#xA;&lt;p&gt;To use this library, install &lt;img src=&#34;http://www.haskell.org/platform/&#34; alt=&#34;Haskell Platform&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What Is Haskell?&lt;/h2&gt; &#xA;&lt;p&gt;Haskell is a functional or &#39;expression&#39; programming language.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://www.haskell.org/haskellwiki/Haskell&#34; alt=&#34;Visit Haskell.org&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What Is Group Oriented Programming?&lt;/h2&gt; &#xA;&lt;p&gt;A group is a structure where the value does not change when any member of it swap their locations.&lt;br&gt; For example &#34;All people in this house&#34; has a consistent meaning as group,&lt;br&gt; but only if no people enter or leave the house.&lt;/p&gt; &#xA;&lt;p&gt;A group follow Boolean algebra, two groups can be combined into new ones with &#39;And&#39;, &#39;Or&#39; and &#39;Except&#39;.&lt;br&gt; There is a way of representing groups, that in many cases is faster than lists:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[0,4, 8,12]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The example above means &#34;items from index 0 to 3 and 8 to 11.&lt;br&gt; The odd indices tells when the group turns to &#34;false&#34;.&lt;br&gt; This representation allows one to have very large groups in little memory.&lt;/p&gt; &#xA;&lt;p&gt;Groups behave as a &#34;filter&#34; or &#34;multi-select&#34; of objects.&lt;br&gt; They are useful for optimizing local operations on large amount of data with low entropy.&lt;/p&gt;</summary>
  </entry>
</feed>