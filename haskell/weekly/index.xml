<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-20T01:48:33Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>runtimeverification/hs-backend-booster</title>
    <updated>2023-08-20T01:48:33Z</updated>
    <id>tag:github.com,2023-08-20:/runtimeverification/hs-backend-booster</id>
    <link href="https://github.com/runtimeverification/hs-backend-booster" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Accelerates K Framework&#39;s Haskell backend&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Haskell Backend Booster&lt;/h1&gt; &#xA;&lt;p&gt;A simpler and faster version of &lt;a href=&#34;https://raw.githubusercontent.com/runtimeverification/hs-backend-booster/haskell-backend&#34;&gt;K-Framework&#39;s haskell-backend&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A simple rewrite engine that focuses on the K configuration as the main term&lt;/li&gt; &#xA; &lt;li&gt;Aims to solve &lt;em&gt;easy and common&lt;/em&gt; rewrites quickly, rather than &lt;em&gt;all&lt;/em&gt; rewrites completely&lt;/li&gt; &#xA; &lt;li&gt;Reverts to the standard backend for complex unification and term simplification&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Kompiling a K definition and running the RPC server&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;kore-rpc-booster&lt;/code&gt; binary takes a &lt;code&gt;kore&lt;/code&gt; file definition, parses and internalises it and then launches an RPC server, which executes requests agains this definition. It additionally accepts a path to a dynamic library compiled by the LLVM backend, which is used for simplification of bool sorted terms. In order to build the kore definition and the shared library out of a K definition, first call&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;kompile --llvm-kompile-type c my_defintion.k&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and then launch the server via&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;kore-rpc-booster ./my_defintion-kompiled/definition.kore --module MY-DEFINITION --llvm-backend-library ./my_defintion-kompiled/interpreter&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;h3&gt;Package structure&lt;/h3&gt; &#xA;&lt;p&gt;At the moment, all code lives in a single package. This might change in the future as the software grows in terms of features.&lt;/p&gt; &#xA;&lt;h3&gt;Building&lt;/h3&gt; &#xA;&lt;p&gt;The software can be built with &lt;code&gt;stack&lt;/code&gt; or &lt;code&gt;cabal&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ stack build&#xA;  # or&#xA;$ cabal build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Prerequisites: &lt;code&gt;stack&lt;/code&gt; or &lt;code&gt;cabal&lt;/code&gt;, &lt;code&gt;ghc-9.2.7&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Stackage resolver: &lt;code&gt;lts-20.20&lt;/code&gt; (&lt;code&gt;ghc-9.2.7&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Nix&lt;/h3&gt; &#xA;&lt;p&gt;There are several things you can do, to make the development via nix as seamless as possible.&lt;/p&gt; &#xA;&lt;h4&gt;Nix shell&lt;/h4&gt; &#xA;&lt;p&gt;To open the nix shell you will need nix version 2.4 or newer. Then use either &lt;code&gt;nix develop&lt;/code&gt; (if you have flakes enabled) or use the old style &lt;code&gt;nix-shell&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;p&gt;If you want to open a shell for a different version of ghc (currently supporting &lt;code&gt;ghc927&lt;/code&gt;), use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix develop .#ghc927&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix-shell --argstr ghc ghc927&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can open a dev shell which contains cabal with all the required libraries compiled with profiling via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nix develop .#ghc925-prof&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Nix-direnv&lt;/h4&gt; &#xA;&lt;p&gt;Using a version of direnv that works with nix (&lt;a href=&#34;https://github.com/nix-community/nix-direnv&#34;&gt;https://github.com/nix-community/nix-direnv&lt;/a&gt;) allows seamless loading and unloading of the nix shell, which adds all the required packages such as &lt;code&gt;cabal&lt;/code&gt;, &lt;code&gt;hpack&lt;/code&gt;, &lt;code&gt;fourmolu&lt;/code&gt;, etc. Use the above link to install &lt;code&gt;nix-direnv&lt;/code&gt;, making sure to hook direnv into whichever shell you are using (&lt;a href=&#34;https://direnv.net/docs/hook.html&#34;&gt;https://direnv.net/docs/hook.html&lt;/a&gt;). You can use the default nix shell (currently GHC version 9.2.7) by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#34;use nix&#34; &amp;gt; .envrc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use a different version of GHC for your shell, e.g. &lt;code&gt;ghc927&lt;/code&gt;, use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#34;use flake .#ghc927&#34; &amp;gt; .envrc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, run &lt;code&gt;direnv allow&lt;/code&gt; inside the repo folder to load up the nix shell.&lt;/p&gt; &#xA;&lt;p&gt;Note that only &lt;code&gt;cabal&lt;/code&gt; currently works within the nix shell and since it does not support the HPack &lt;code&gt;package.yaml&lt;/code&gt; file format, any changes to this file will require running &lt;code&gt;hpack&lt;/code&gt; before they are picked up by cabal.&lt;/p&gt; &#xA;&lt;h3&gt;scripts/update-haskell-backend.sh&lt;/h3&gt; &#xA;&lt;p&gt;To bump the version of the haskell-backend consistently within the project (i.e. in nix, cabal.project and stack.yaml) call&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nix run .#update-haskell-backend&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;you can optionally pass a commit hash above if you don&#39;t want master.&lt;/p&gt; &#xA;&lt;h3&gt;HLS in VSCode&lt;/h3&gt; &#xA;&lt;p&gt;To get HLS working in VSCode, install these two extensions:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=arrterian.nix-env-selector&#34;&gt;https://marketplace.visualstudio.com/items?itemName=arrterian.nix-env-selector&lt;/a&gt; &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=haskell.haskell&#34;&gt;https://marketplace.visualstudio.com/items?itemName=haskell.haskell&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;nix-env-selector&lt;/code&gt; extension may prompt for the workspace to be re-loaded. Once re-loaded, HLS should start working. In case you need to use a specific version of ghc for this extension, modify the &lt;code&gt;.vscode/settings.json&lt;/code&gt; file here:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &#34;nixEnvSelector.args&#34;: &#34;--argstr ghc ghc927&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Eventlog tracing&lt;/h2&gt; &#xA;&lt;p&gt;Besides compiling the backend with profiling mode, we can also enable a targeted profiling mode by emitting useful debug events into the eventlog. So far we can emit/trace the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;LLVM backend API calls - using &lt;code&gt;--trace llvm-calls +RTS -l-au&lt;/code&gt; we can collect all the LLVM backend API calls the server performs during execution. Running the obtained eventlog through &lt;code&gt;eventlog-parser&lt;/code&gt; will produce an &lt;code&gt;llvm_calls.c&lt;/code&gt; file of the form:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;kore_symbol* sym_m5952705877914568462 = kore_symbol_new(&#34;LblnotBool&#39;Unds&#39;&#34;);&#xA;kore_pattern* pat_m7294887483024610198 = kore_composite_pattern_from_symbol(sym_m5952705877914568462);&#xA;kore_symbol* sym_2859997003983430356 = kore_symbol_new(&#34;LblSet&#39;Coln&#39;in&#34;);&#xA;kore_pattern* pat_7796859658648783000 = kore_composite_pattern_from_symbol(sym_2859997003983430356);&#xA;kore_symbol* sym_m6495506210664726973 = kore_symbol_new(&#34;inj&#34;);&#xA;kore_sort* sort_m1174205405547972024 = kore_composite_sort_new(&#34;SortId&#34;);&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Timing information in IO - using &lt;code&gt;--trace timing +RTS -lsu&lt;/code&gt; we can instrument code with &lt;code&gt;Trace.timeIO &#34;foo&#34; ...&lt;/code&gt; calls which will measure time spent in &lt;code&gt;...&lt;/code&gt; and attach the label &lt;code&gt;foo&lt;/code&gt; to this region in the speedscope profile. &lt;code&gt;eventlog-parser&lt;/code&gt; will produce a JSON file of these calls viewable in the speedscope app.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>markandrus/Matrix-Decomposition</title>
    <updated>2023-08-20T01:48:33Z</updated>
    <id>tag:github.com,2023-08-20:/markandrus/Matrix-Decomposition</id>
    <link href="https://github.com/markandrus/Matrix-Decomposition" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Matrix Decomposition&lt;/h1&gt; &#xA;&lt;p&gt;This source repository contains my solutions to Homework 6, consisting of the three programs&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;main&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tests&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsa&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;code&gt;sample-output.txt&lt;/code&gt; shows the kind of output you should expect from running &lt;code&gt;./main -v -P -S -R -T&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;All three programs are written in Haskell and rely on GHC and a number of Cabal packages.&lt;/p&gt; &#xA;&lt;p&gt;The included &lt;code&gt;Makefile&lt;/code&gt; handles compilation, and the three binaries may be built with &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Package Requirements&lt;/h3&gt; &#xA;&lt;p&gt;If &lt;code&gt;make&lt;/code&gt; fails, it is probably because you are missing a cabal package. These programs rely on &lt;a href=&#34;https://github.com/AlbertoRuiz/hmatrix&#34;&gt;HMatrix&lt;/a&gt;, which can be installed with the included &lt;code&gt;setup.sh&lt;/code&gt; script, or with the command &lt;code&gt;cabal install hmatrix&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CSV&lt;/li&gt; &#xA; &lt;li&gt;HMatrix&lt;/li&gt; &#xA; &lt;li&gt;QuickCheck&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Eigendecomposition and Singular Value Decomposition (SVD)&lt;/h2&gt; &#xA;&lt;p&gt;Parts 1 and 2 of Homework 6 require implementation of &lt;a href=&#34;http://en.wikipedia.org/wiki/Eigendecomposition&#34;&gt;Eigendecomposition&lt;/a&gt; and &lt;a href=&#34;http://en.wikipedia.org/wiki/Singular_Value_Decomposition&#34;&gt;SVD&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;My implementation of eigendecomposition uses the Power Method (&lt;a href=&#34;http://en.wikipedia.org/wiki/Power_iteration&#34;&gt;power iteration&lt;/a&gt; and &lt;a href=&#34;http://www.miislita.com/information-retrieval-tutorial/matrix-tutorial-3-eigenvalues-eigenvectors.html&#34;&gt;deflation&lt;/a&gt;) to compute &lt;code&gt;A = V \Lambda V^T&lt;/code&gt; for a real-valued matrix &lt;code&gt;A&lt;/code&gt;. See &lt;code&gt;PowerMethod.hs&lt;/code&gt; for a detailed comments.&lt;/p&gt; &#xA;&lt;p&gt;My SVD implementation also relies on eigendecomposition to compute &lt;code&gt;A = U S V^T&lt;/code&gt;. See &lt;code&gt;SVD.hs&lt;/code&gt; for detailed comments.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./main -h&#xA;main&#xA;&#x9;-d INT     --decimal-places=INT  Number of decimal places to display&#xA;&#x9;-e DOUBLE  --epsilon=DOUBLE      Precision parameter&#xA;&#x9;-P         --power-method        Compute the eigen-vectors and values of the 2D matrix&#xA;&#x9;-S         --svd                 Compute the singular value decomposition of the 2D matrix&#xA;&#x9;-R         --recombine           Compute the Frobenius norm of the difference between the 2D matrix and its reconstructions&#xA;&#x9;-T         --test-truncation     Compute the Frobenius norms of the differences between the 2D matrix and its reconstructions from truncated singular values&#xA;&#x9;-v         --verbose             Enable verbose messages&#xA;&#x9;-h         --help                Show help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Executing &lt;code&gt;./main -v -P -S -R -T path/to/A.txt&lt;/code&gt;, where &lt;code&gt;A.txt&lt;/code&gt; is a 2D ASCII representation of the real-valued matrix &lt;code&gt;A&lt;/code&gt;, will generate a report demonstrating&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Eigenvector decomposition of the input matrix, &lt;code&gt;A&lt;/code&gt;, including (enabled with &lt;code&gt;-P&lt;/code&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Reconstruction of &lt;code&gt;A&#39;&lt;/code&gt; from &lt;code&gt;V \Lambda V^T&lt;/code&gt; (enabled with &lt;code&gt;-R&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;The Frobenius norm of the difference between the input matrix and its reconstruction (enabled with &lt;code&gt;-R&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Singular value decomposition of the input matrix, &lt;code&gt;A&lt;/code&gt;, including (enabled with &lt;code&gt;-S&lt;/code&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Reconstruction of &lt;code&gt;A&#39;&lt;/code&gt; from &lt;code&gt;U S V^T&lt;/code&gt; (enabled with &lt;code&gt;-R&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;The Frobenius norm of the difference between the input matrix and its reconstruction (enabled with &lt;code&gt;-R&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The Frobenius norm of a 10 by 20 random matrix minus its recomposition, &lt;code&gt;U S_i V^T&lt;/code&gt;--where &lt;code&gt;S_i&lt;/code&gt; is a diagonal matrix with all but the first &lt;code&gt;i&lt;/code&gt; singular values truncated (enabled with &lt;code&gt;-T&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Results from Truncating Singular Values&lt;/h3&gt; &#xA;&lt;p&gt;The following table shows the Frobenius norms of the differences (&lt;code&gt;d&lt;/code&gt;) between the 2D matrix and its reconstructions from &lt;code&gt;i&lt;/code&gt; singular values&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;code&gt;i&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;code&gt;d&lt;/code&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;3.793e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;3.249e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;2.869e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;2.484e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;   &lt;td&gt;2.106e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;6&lt;/td&gt; &#xA;   &lt;td&gt;1.651e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;7&lt;/td&gt; &#xA;   &lt;td&gt;1.196e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;8&lt;/td&gt; &#xA;   &lt;td&gt;9.026e-1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;9&lt;/td&gt; &#xA;   &lt;td&gt;5.626e-1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;10&lt;/td&gt; &#xA;   &lt;td&gt;5.920e-4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Tests&lt;/h2&gt; &#xA;&lt;p&gt;I offer a set of QuickCheck tests to verify against HMatrix&#39;s own implementation of &lt;code&gt;eigSH&lt;/code&gt; that my &lt;code&gt;powerMethod&lt;/code&gt; works:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./tests&#xA;ident/isSymmetric        : +++ OK, passed 100 tests.&#xA;multByIdent/id           : +++ OK, passed 100 tests.&#xA;powMeth/eigVals_ex1      : +++ OK, passed 100 tests.&#xA;powMeth/eigVals_ex2      : +++ OK, passed 100 tests.&#xA;powMeth/eigVals_ex3      : +++ OK, passed 100 tests.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Examples 1 through 3 in &lt;code&gt;Tests.hs&lt;/code&gt; confirm that&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The the N eigenvalues of an N by N identity matrix are all 1&lt;/li&gt; &#xA; &lt;li&gt;That the eigenvalues computed for a small, 2 by 2 matrix match those expected (within &lt;code&gt;epsilon&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;That the eigenvalues computed by &lt;code&gt;powerMethod&lt;/code&gt; for an arbitrary square matrix match those computed by &lt;code&gt;eigSH&lt;/code&gt; (within &lt;code&gt;epsilon&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>np/csv-nptools</title>
    <updated>2023-08-20T01:48:33Z</updated>
    <id>tag:github.com,2023-08-20:/np/csv-nptools</id>
    <link href="https://github.com/np/csv-nptools" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A collection of CSV tools&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>