<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-14T02:12:28Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Simspace/avaleryar</title>
    <updated>2022-08-14T02:12:28Z</updated>
    <id>tag:github.com,2022-08-14:/Simspace/avaleryar</id>
    <link href="https://github.com/Simspace/avaleryar" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A logical authorization system&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Avaleryar&lt;/h1&gt; &#xA;&lt;p&gt;An implementation of &lt;a href=&#34;http://okmij.org/ftp/papers/Soutei.pdf&#34; title=&#34;Soutei Paper&#34;&gt;Soutei&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Not yet fit for human consumption.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;It&#39;s easier to ask forgiveness than it is to get permission. --Rear Admiral Grace Murray Hopper&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Avaleryar is an implementation of &lt;a href=&#34;http://okmij.org/ftp/papers/Soutei.pdf&#34; title=&#34;Soutei Paper&#34;&gt;Pimlott and Kiselyov&#39;s Soutei&lt;/a&gt; trust-management system, comprising&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A &lt;a href=&#34;https://en.wikipedia.org/wiki/Datalog&#34;&gt;Datalog&lt;/a&gt;-like rule language for describing authorization policies (including the evaluator, parser, and a pretty-printer).&lt;/li&gt; &#xA; &lt;li&gt;Convenient library support for extending the policy language with application-specific predicates.&lt;/li&gt; &#xA; &lt;li&gt;A REPL for exploring and debugging policies.&lt;/li&gt; &#xA; &lt;li&gt;An integrated unit-testing system. (NB: It&#39;s pretty bad; we intend to improve it someday).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We have more improvements planned for the future, which you can read about &lt;a href=&#34;https://raw.githubusercontent.com/Simspace/avaleryar/master/#planned-improvements&#34;&gt;below&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;A Quick Example&lt;/h2&gt; &#xA;&lt;p&gt;Soutei is an extremely flexible system, capable of expressing various styles of authorization policies (RBAC, ABAC, other acronyms that end in -BAC). For this introductory example, we&#39;ll write a simple policy for a hypothetical blogging platform. When a user attempts to take an action, the platform will consult the policy to advise it whether or not to allow the operation to proceed. Here&#39;s an informal version of our policy, in English:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Anyone may read a post that&#39;s been published&lt;/li&gt; &#xA; &lt;li&gt;Anyone who is allowed to edit a post may read it&lt;/li&gt; &#xA; &lt;li&gt;The author of a post may edit and publish it&lt;/li&gt; &#xA; &lt;li&gt;The owner of a blog may create new posts&lt;/li&gt; &#xA; &lt;li&gt;A user may leave a comment on a post if they&#39;re permitted to read it, and are friends with the post&#39;s author.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;;; Anyone may read a post that&#39;s been published&#xA;may(read) :-&#xA;  application says status(published).&#xA;  &#xA;;; Anyone who is allowed to edit a post may read it&#xA;may(read) :-&#xA;  may(edit).&#xA;&#xA;;; The author of a post may edit it...&#xA;may(edit) :-&#xA;  application says user(?user),&#xA;  application says author(?user).&#xA;&#xA;;; ...and publish it&#xA;may(publish) :-&#xA;  application says user(?user),&#xA;  application says author(?user).&#xA;&#xA;;; The owner of a blog may create new posts&#xA;may(create) :-&#xA;  application says user(?user),&#xA;  application says blog-owner(?user).&#xA;&#xA;;; A user may leave a comment on a post if they&#39;re permitted to read it, and are friends with the&#xA;;; post&#39;s author.&#xA;may(comment) :-&#xA;  may(read),&#xA;  application says user(?user),&#xA;  application says author(?author),&#xA;  ?author says friend(?user).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What we have is a collection of &lt;em&gt;rules&lt;/em&gt; describing the circumstances under which a particular action should be permitted. When our blog application wants to know whether a request is authorized, it will ask Soutei. Soutei will then try to prove that the rules permit the access somehow, and let the application know if it succeeded. We&#39;ll discuss this syntax in detail below. Briefly, though, you can decode, say, the third rule (the author of a post may edit and publish it) like this: &#34;&lt;code&gt;edit&lt;/code&gt; is permitted when the application tells us there&#39;s a user (denoted by the &lt;em&gt;variable&lt;/em&gt; &lt;code&gt;?user&lt;/code&gt;) associated with the request, and the application tells us that that user is identically the author of the post&#34;. Observe that &lt;code&gt;:-&lt;/code&gt; (which I&#39;ll pronounce &#34;when&#34;) is like an implication in logic. The second rule (if you&#39;re allowed to edit you&#39;re allowed to read) is just saying that &lt;code&gt;edit&lt;/code&gt; implies &lt;code&gt;read&lt;/code&gt; (or, since the implication goes right-to-left, perhaps &#34;&lt;code&gt;read&lt;/code&gt; is implied by &lt;code&gt;edit&lt;/code&gt;&#34; would be better).&lt;/p&gt; &#xA;&lt;p&gt;Don&#39;t worry if this is still confusing. The example demonstrates several different features of the system. Nonetheless, I hope you agree it&#39;s a relatively compact and clean description of a not-completely-trivial authorization policy.&lt;/p&gt; &#xA;&lt;h2&gt;Using Soutei for Authorization&lt;/h2&gt; &#xA;&lt;p&gt;Architecturally, Soutei provides support for implementing a so-called &#34;policy decision point&#34;. Its job is to advise an application on whether it should permit a request by determining if it complies with its security policy. It does &lt;em&gt;not&lt;/em&gt; provide policy &lt;em&gt;enforcement&lt;/em&gt;. This is to say, you ask whether to allow access, and you get an answer, but it&#39;s still up to you to send the 403 back to the client if that answer was &#34;no&#34;.&lt;/p&gt; &#xA;&lt;p&gt;To make use of the policy engine, you formulate a query and send it along. For instance, when implementing the commenting system for your blog platform, you might ask Soutei &lt;code&gt;may(comment)&lt;/code&gt; (this is concrete syntax, in practice you&#39;ll assemble the query using library functions). Of course, whether commenting is permitted depends on information that Soutei doesn&#39;t have. In our example, that&#39;s at least the identity of the commenting user and the author of the post, and probably some more information necessary to deduce the ability to read the post. Soutei only knows about the rules you&#39;ve given it, so where do these extra facts about this particular commenting operation come from? The application provides them as a parameter to the query. So in our example, the application might ask &#34;is commenting permitted? (and by the way, the post has been published, the current user is &lt;code&gt;bob&lt;/code&gt;, the author of the post is &lt;code&gt;alice&lt;/code&gt;, and &lt;code&gt;alice&lt;/code&gt; says &lt;code&gt;bob&lt;/code&gt; is her friend, in case that helps you make your decision)&#34;.&lt;/p&gt; &#xA;&lt;p&gt;This may be a rather different style of access control than you&#39;re used to, and it requires a bit of a shift in perspective.&lt;/p&gt; &#xA;&lt;p&gt;TODO: Say more here.&lt;/p&gt; &#xA;&lt;h2&gt;Syntax and Semantics&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s a rule about activities:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;can(?activity) :-&#xA;  want-to(?activity).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It says that an activity is permitted (&lt;code&gt;can(?activity)&lt;/code&gt;) when we want to do that activity (&lt;code&gt;want-to(?activity)&lt;/code&gt;). We can see several features of the syntax in this small example. Rules have two parts (a &lt;strong&gt;head&lt;/strong&gt; and a &lt;strong&gt;body&lt;/strong&gt;), separated by the symbol &lt;code&gt;:-&lt;/code&gt; (which I tend to pronounce &#34;when&#34;), and terminated with a period. The head of the rule is &lt;code&gt;can(?activity)&lt;/code&gt;, and the body of the rule is &lt;code&gt;want-to(?activity)&lt;/code&gt;. They use a function-call like notation (called a &lt;strong&gt;literal&lt;/strong&gt;) to describe logical &lt;strong&gt;predicates&lt;/strong&gt; (i.e., &lt;code&gt;can&lt;/code&gt; and &lt;code&gt;want-to&lt;/code&gt;). Predicates are usually denoted with their arity, so rather than writing &lt;code&gt;can&lt;/code&gt;, we&#39;d write &lt;code&gt;can/1&lt;/code&gt;. If we had a predicate describing friendship between two people (&lt;code&gt;friend(alice, bob)&lt;/code&gt;), we&#39;d refer to it as &lt;code&gt;friend/2&lt;/code&gt;. We can also see that &lt;strong&gt;variables&lt;/strong&gt; are written with a prefix question-mark (&lt;code&gt;?activity&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;If this rule were our entire policy, it would never permit us to do anything, because it has no way to establish what we &lt;code&gt;want-to/1&lt;/code&gt; do. In general, determining our psyche&#39;s innermost desires can be complicated, and we could write a bunch of complicated rules to define &lt;code&gt;want-to/1&lt;/code&gt;. But let&#39;s just assume we&#39;re blessed with unusual self awareness, and add a special kind of rule, called a &lt;strong&gt;fact&lt;/strong&gt;, that will express our yearning:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;can(?activity) :-&#xA;  want-to(?activity).&#xA;  &#xA;;; we can dance if we want to&#xA;want-to(dance).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can see that a fact is a rule without a body. We can also see that comments are introduced with semicolons and extend to the end of the line. This policy will now permit a query of the form &lt;code&gt;can(dance)&lt;/code&gt;. Let&#39;s look at how that deduction works. We ask Soutei &lt;code&gt;can(dance)&lt;/code&gt;, and it reasons: &#34;I can prove &lt;code&gt;can(dance)&lt;/code&gt; if, when &lt;code&gt;?activity&lt;/code&gt; is &lt;code&gt;dance&lt;/code&gt;, I can prove &lt;code&gt;want-to(dance)&lt;/code&gt;. Oh! and I can prove &lt;code&gt;want-to(dance)&lt;/code&gt; because I know that for fact!&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Notice that &lt;code&gt;dance&lt;/code&gt; isn&#39;t a variable, it&#39;s just a symbol. We could have written &lt;code&gt;want-to(&#34;dance&#34;)&lt;/code&gt;, using double-quotes to delimit the string, but it&#39;s unnecessary (and un-idiomatic) when the string doesn&#39;t contain spaces or commas.&lt;/p&gt; &#xA;&lt;p&gt;Now suppose we want to say that we can dance if we want to, act if we want to, but sing under any circumstances? (This whole example will probably make more sense with a bit more &lt;a href=&#34;https://www.youtube.com/watch?v=AjPau5QYtYs&#34;&gt;context&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;can(?activity) :-&#xA;  want-to(?activity).&#xA;&#xA;can(sing).&#xA;&#xA;;; we can dance if we want to&#xA;want-to(dance).&#xA;&#xA;;; we can act if we want to&#xA;want-to(act).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What &lt;code&gt;can/1&lt;/code&gt; we do now? Well, we &lt;code&gt;can(dance)&lt;/code&gt;, we &lt;code&gt;can(dance)&lt;/code&gt;, we &lt;code&gt;can(sing)&lt;/code&gt;, and we &lt;code&gt;can(act)&lt;/code&gt;. This shows that we&#39;re able to express different ways to conclude that an action is permitted by writing multiple rules for the same predicate (remember that facts are rules without bodies). Rule bodies aren&#39;t limited to a single literal. Let&#39;s add an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;can(?activity) :-&#xA;  want-to(?activity).&#xA;&#xA;can(sing).&#xA;&#xA;;; we can dance if we want to&#xA;want-to(dance).&#xA;&#xA;;; we can act if we want to&#xA;want-to(act).&#xA;&#xA;;; we only want to go when the night is young, and so am I&#xA;want-to(go) :-&#xA;  time-of(night, young),&#xA;  age-of(me, young).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We require every predicate in the body of a rule to succeed in order for the rule to succeed. So &lt;code&gt;want-to(go)&lt;/code&gt; needs both &lt;code&gt;time-of(night, young)&lt;/code&gt; and &lt;code&gt;age-of(me, young)&lt;/code&gt; to be proven in order for this rule to prove that &lt;code&gt;want-to(go)&lt;/code&gt;. Of course, what we have so far isn&#39;t enough to prove &lt;code&gt;can(go)&lt;/code&gt; yet, because &lt;code&gt;age-of/2&lt;/code&gt; and &lt;code&gt;time-of/2&lt;/code&gt; aren&#39;t actually defined anywhere. This isn&#39;t considered an error; it simply means that an attempt to prove &lt;code&gt;want-to(go)&lt;/code&gt; will fail. (As a reminder, there&#39;s no special meaning attached to &lt;code&gt;night&lt;/code&gt;, &lt;code&gt;young&lt;/code&gt; or &lt;code&gt;me&lt;/code&gt;---they&#39;re just symbols I&#39;m using to demonstrate the syntax).&lt;/p&gt; &#xA;&lt;p&gt;It may be occurring to you by now that these rules don&#39;t actually depend on anything---the assertion we&#39;re developing (a collection of rules like this is called an &lt;strong&gt;assertion&lt;/strong&gt;---an assertion is kind of like a module or a namespace) will always prove exactly the same things. A rule may consult predicates in &lt;em&gt;other&lt;/em&gt; assertions than the one in which it&#39;s written. Let&#39;s hypothesize two new assertions, &lt;code&gt;clock&lt;/code&gt; and &lt;code&gt;bio&lt;/code&gt;, that contain chronological and biographical rules, respectively:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;can(?activity) :-&#xA;  want-to(?activity).&#xA;&#xA;can(sing).&#xA;&#xA;;; we can dance if we want to&#xA;want-to(dance).&#xA;&#xA;;; we can act if we want to&#xA;want-to(act).&#xA;&#xA;;; we only want to go when the night is young, and so am and I&#xA;want-to(go) :-&#xA;  clock says time-of(night, young),&#xA;  bio says age-of(me, young).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;ve changed the body of our &lt;code&gt;want-to(go)&lt;/code&gt; rule by adding &lt;code&gt;clock says time-of(night, young)&lt;/code&gt; and &lt;code&gt;bio says age-of(me, young)&lt;/code&gt;. This tells Soutei to try and resolve &lt;code&gt;time-of/2&lt;/code&gt; in the assertion named &lt;code&gt;clock&lt;/code&gt; and &lt;code&gt;age-of/2&lt;/code&gt; in the assertion named &lt;code&gt;bio&lt;/code&gt;. By &#34;resolve a predicate in an assertion&#34;, I mean that Soutei will load all the rules in that assertion, and continue trying to satisfy the predicate using the rules in &lt;em&gt;that&lt;/em&gt; assertion. Of course, if any rule in this new assertion has a body literal of the form &lt;code&gt;assertion says pred(...)&lt;/code&gt;, then Soutei will load the rules in &lt;code&gt;assertion&lt;/code&gt; and resolve &lt;code&gt;pred&lt;/code&gt; there.&lt;/p&gt; &#xA;&lt;p&gt;Other than a short discussion about variable binding and another on so-called &#34;native predicates&#34;, we&#39;ve now looked (albeit briefly) at the entirety of the semantics of the language. I point that out because in order to continue our Safety Dance, we&#39;ll need to introduce a convention that &lt;code&gt;avaleryar&lt;/code&gt; (following the original paper) imposes: the &lt;code&gt;application&lt;/code&gt; assertion. Semantically, the &lt;code&gt;application&lt;/code&gt; assertion is no different than any other. However, when &lt;code&gt;avaleryar&lt;/code&gt; runs a query, it accepts a collection of facts as, effectively, parameters that are made available to our rules through the &lt;code&gt;application&lt;/code&gt; assertion. (NB: I&#39;m doing my best to distinguish Soutei-the-language from &lt;code&gt;avaleryar&lt;/code&gt;-the-implementation-of-Soutei-the-language, I hope this isn&#39;t too confusing). So to demonstrate, let&#39;s write a needlessly complicated rule determining whether the dancing we can do is, properly a Safety Dance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;can(?activity) :-&#xA;  want-to(?activity).&#xA;&#xA;can(sing).&#xA;&#xA;;; we can dance if we want to&#xA;want-to(dance).&#xA;&#xA;;; we can act if we want to&#xA;want-to(act).&#xA;&#xA;;; we only want to go when the night is young, and so am and I&#xA;want-to(go) :-&#xA;  clock says time-of(night, young),&#xA;  bio says age-of(me, young).&#xA;&#xA;;; we can overextend the efficacy a questionable pop-culture reference&#xA;safety(?activity) :-&#xA;  can(?activity),&#xA;  application says out-of(control, everything),&#xA;  application says doing-it(from, pole),&#xA;  application says doing-it(to, pole),&#xA;  application says looking-at(hands, ?somebody),&#xA;  ?somebody says taking(the-chance).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This (completely inane, it&#39;s getting pretty late as I write this---the examples section below won&#39;t be this silly) new rule uses a bunch of information provided by the application querying for authorization advice (&lt;code&gt;application says ...&lt;/code&gt;) in addition to some locally written rules (&lt;code&gt;can(?activity)&lt;/code&gt;). It also uses an assertion &lt;em&gt;determined by the query&lt;/em&gt; (&lt;code&gt;?somebody says taking(the-chance)&lt;/code&gt;) to ultimately establish that indeed, &lt;code&gt;safety(dance)&lt;/code&gt;. The ability to dynamically choose different assertions in which to reason is a powerfully expressive feature of Soutei.&lt;/p&gt; &#xA;&lt;p&gt;TODO: unification and native predicates.&lt;/p&gt; &#xA;&lt;p&gt;TODO: why encoding &#34;&#39;Cause your friends don&#39;t dance, and if they don&#39;t dance, then they&#39;re no friends of mine&#34; isn&#39;t (naively) possible.&lt;/p&gt; &#xA;&lt;p&gt;TODO: mode checking.&lt;/p&gt; &#xA;&lt;p&gt;TODO: monotonicity.&lt;/p&gt; &#xA;&lt;h2&gt;Examples and Advice&lt;/h2&gt; &#xA;&lt;h3&gt;Example: Unix File Permissions&lt;/h3&gt; &#xA;&lt;p&gt;Here is a simplified version of file permissions on Unix. We assume that the application will tell us what the file is, that there&#39;s an assertion named after the file that knows what permissions are set on it, who owns it, and which group it&#39;s associated with, as well as that each group has an assertion named after it that can tell us whether a user is a member of that group. For example, we might have an assertion for some file that looked like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;;; assertion for /path/to/some/file&#xA;&#xA;owner(mary).&#xA;group(wheel).&#xA;perm(user, read).&#xA;perm(user, write).&#xA;perm(user, execute).&#xA;perm(group, read).&#xA;perm(group, execute).&#xA;perm(other, read).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This would represent a file owned by &lt;code&gt;mary&lt;/code&gt;, with group &lt;code&gt;wheel&lt;/code&gt;, with permissions &lt;code&gt;754&lt;/code&gt; (as in, &lt;code&gt;chmod 754 /path/to/some/file&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;;; allow ?access when the user is the owner and ?access is enabled for them.&#xA;;; NB: The word &#34;user&#34; appears with three different meanings in this rule.  The application fact&#xA;;; &#39;user/1&#39;, which indicates the user accessing the file, the variable &#39;?user&#39;, which has that&#xA;;; user bound to it, and the symbol &#39;user&#39; in &#39;perm(user, ?access)&#39;, which refers to user&#xA;;; permissions on a file in the sense of &#39;chmod u+x $FILE&#39;.&#xA;may(?access) :-&#xA;  application says file(?file),&#xA;  application says user(?user),&#xA;  ?file says owner(?user),&#xA;  ?file says perm(user, ?access).&#xA;&#xA;;; allow ?access when it&#39;s enabled on the file, the file is associated with a group ?group,&#xA;;; and the user is a member of ?group.&#xA;may(?access) :-&#xA;  application says file(?file),&#xA;  application says user(?user),&#xA;  ?file says group(?group),&#xA;  ?group says member(?user),&#xA;  ?file says perm(group, ?access).&#xA;  &#xA;;; allow ?access if it&#39;s enabled for all users (&#34;other&#34; permissions)&#xA;may(?access) :-&#xA;  application says file(?file),&#xA;  ?file says perm(other, ?access).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unix permissions are more sophisticated than this---for instance, if you have &lt;code&gt;read&lt;/code&gt; access to a directory, you are permitted to see the &lt;em&gt;names&lt;/em&gt; of the files in that directory, but not other metadata (roughly, you&#39;re allowed to see the output of &lt;code&gt;ls&lt;/code&gt;, but not &lt;code&gt;ls -l&lt;/code&gt;) unless you also have &lt;code&gt;execute&lt;/code&gt; permission on the directory as well. A more nuanced version of this policy would need to know what metadata is being sought by the application, and probably require some native predicates to compute the directory part of a file path.&lt;/p&gt; &#xA;&lt;h3&gt;Example: Role-Based Access Control (RBAC)&lt;/h3&gt; &#xA;&lt;p&gt;In RBAC, we have a discrete set of primitive &lt;em&gt;permissions&lt;/em&gt;, a collection of named &lt;em&gt;roles&lt;/em&gt; each of which is a subset of the permissions, and an assignment of users to (possibly multiple) roles. To determine if a user is permitted to take some action, we check that the user has been assigned some role that contains the appropriate permission.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;;; permissions&#xA;&#xA;perm(manage-users).&#xA;perm(manage-computers).&#xA;perm(access-lab).&#xA;perm(run-experiment).&#xA;perm(create-experiment).&#xA;perm(approve-experiment).&#xA;&#xA;;; roles&#xA;&#xA;; grad students get to do all the work&#xA;role(grad-student, access-lab).&#xA;role(grad-student, run-experiment).&#xA;&#xA;; professors have at least the permissions of grad students, plus they can&#xA;; create experiments.&#xA;role(professor, ?perm) :-&#xA;  role(grad-student, ?perm).&#xA;role(professor, create-experiment).&#xA;&#xA;; poison control should probably be allowed into the lab, just in case&#xA;role(poison-control, access-lab).&#xA;&#xA;; the IT department needs to access the lab to manage its computers&#xA;role(it-support, access-lab).&#xA;role(it-support, manage-computers).&#xA;&#xA;; the dean has nothing to do with the science, but they still sign the&#xA;; checks and assign personel&#xA;role(dean, approve-experiment).&#xA;role(dean, manage-users).&#xA;&#xA;;; users&#xA;&#xA;has-role(bill, grad-student).&#xA;has-role(clara, professor).&#xA;has-role(dmitri, grad-student).&#xA;has-role(dmitri, poison-control). ; dmitri is a volunteer EMT&#xA;has-role(emily, it-support).&#xA;has-role(fabian, dean).&#xA;&#xA;;; RBAC&#xA;&#xA;may(?perm) :-&#xA;  application says user(?user),&#xA;  has-role(?user, ?role),&#xA;  role(?role, ?perm).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example: Access Control Lists (ACLs)&lt;/h3&gt; &#xA;&lt;h3&gt;Advice: Don&#39;t use ACLs&lt;/h3&gt; &#xA;&lt;h2&gt;Using Avaleryar&lt;/h2&gt; &#xA;&lt;p&gt;TODO: tutorial module.&lt;/p&gt; &#xA;&lt;h2&gt;Glossary&lt;/h2&gt; &#xA;&lt;h2&gt;Planned Improvements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;An interactive debugger&lt;/li&gt; &#xA; &lt;li&gt;A better persistence story (to make dynamic rule submission usable)&lt;/li&gt; &#xA; &lt;li&gt;Assertion signatures (enabling the use of variables for native assertions)&lt;/li&gt; &#xA; &lt;li&gt;Some kind of &lt;a href=&#34;https://en.wikipedia.org/wiki/Abductive_logic_programming&#34;&gt;abduction&lt;/a&gt; (to offer explanations of query failure)&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>benwbooth/cleo</title>
    <updated>2022-08-14T02:12:28Z</updated>
    <id>tag:github.com,2022-08-14:/benwbooth/cleo</id>
    <link href="https://github.com/benwbooth/cleo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Beginnings of a parser for a new functional language&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Beginnings of a parser for a new functional language&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Simspace/on-error</title>
    <updated>2022-08-14T02:12:28Z</updated>
    <id>tag:github.com,2022-08-14:/Simspace/on-error</id>
    <link href="https://github.com/Simspace/on-error" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Clearly-delineated error-handling&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;on-error: clearly-delineated error-handling&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.com/simspace/on-error&#34;&gt;&lt;img src=&#34;https://travis-ci.com/simspace/on-error.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Error-handling code is messy, but if we want to provide good error messages, we should still take the time to do it right. &lt;code&gt;on-error&lt;/code&gt; provides a naming convention which clearly distinguishes error-handling code from the rest of the code, thereby allowing developers to only pay attention to the error-handling code when they want to do so.&lt;/p&gt; &#xA;&lt;p&gt;The naming convention is as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;on[Condition]ThrowError&lt;/code&gt; functions detect errors&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[transform]Error&lt;/code&gt; functions transform errors&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;onError[Action]&lt;/code&gt; functions handle errors&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Furthermore, those functions are designed to be composed using &lt;code&gt;(.)&lt;/code&gt; into a clearly-delineated block of error-handling code. Here is an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;countDogs :: Response Int&#xA;countDogs = onErrorCatch sendErrorStatus&#xA;          . onNothingThrowError 500&#xA;       =&amp;lt;&amp;lt;$ liftIO&#xA;          $ fetchCount &#34;http://example.com/dogs/count&#34;&#xA;&#xA;fetchCount :: Text -&amp;gt; IO (Maybe Int)&#xA;sendErrorStatus :: Int -&amp;gt; Response a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Everything before the &lt;code&gt;(=&amp;lt;&amp;lt;$)&lt;/code&gt; (which is just a low-precedence version of &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;) is error-handling code, and everything after it is normal code. Once our brains have learned to recognize those error-handling blocks as such, we can take a brief look at the above definition and quickly home in to the important part: &lt;code&gt;countDogs&lt;/code&gt; calls &lt;code&gt;fetchCount&lt;/code&gt; at a specific URL, while the rest of the code embeds this &lt;code&gt;IO&lt;/code&gt; computation into a &lt;code&gt;Response&lt;/code&gt; computation, and deals with the error cases somehow. This is often a good enough level of understanding, but if later on we do need to understand the error-handling code, we can take a closer look and determine that the &lt;code&gt;Nothing&lt;/code&gt; case is handled by calling &lt;code&gt;sendErrorStatus 500&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Without &lt;code&gt;on-error&lt;/code&gt;, the implementation of &lt;code&gt;countDogs&lt;/code&gt; might look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;countDogs&#39; :: Response Int&#xA;countDogs&#39; = do&#xA;  r &amp;lt;- liftIO $ fetchCount &#34;http://example.com/dogs/count&#34;&#xA;  case r of&#xA;    Nothing -&amp;gt; sendErrorStatus 500&#xA;    Just count -&amp;gt; pure count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;countDogs&#39;&#39; :: Response Int&#xA;countDogs&#39;&#39; = join&#xA;            . fmap (maybe (sendErrorStatus 500) pure)&#xA;            . liftIO&#xA;            $ fetchCount &#34;http://example.com/dogs/count&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;countDogs&#39;&lt;/code&gt; is quite clear, but you only realize that the second part of the function only performs error-handling after you have already read and understood that part. &lt;code&gt;countDogs&#39;&#39;&lt;/code&gt; uses a different style in which the core &lt;code&gt;fetchCount&lt;/code&gt; computation is gradually transformed into a &lt;code&gt;Response&lt;/code&gt; computation, but again, it&#39;s unclear whether some of those transformations affect the happy path or just the error cases until after you&#39;ve read and understood those transformations.&lt;/p&gt; &#xA;&lt;h2&gt;Detecting errors&lt;/h2&gt; &#xA;&lt;p&gt;Functions which can fail do so in one of three ways:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;By returning a special value such as &lt;code&gt;Nothing&lt;/code&gt; or &lt;code&gt;Either&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;By signaling failure using some monadic effect, such &lt;code&gt;ExceptT.throwE&lt;/code&gt;, &lt;code&gt;MonadError.throwError&lt;/code&gt;, or &lt;code&gt;MonadFail.fail&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;By throwing an exception.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;In each case, we want to detect the error condition and to convert it to a value of some type &lt;code&gt;e&lt;/code&gt; representing the errors which we know can happen within the current code. If you only plan to log the error or to display it to the user, &lt;code&gt;Text&lt;/code&gt; is a good enough representation, but if you plan to handle some of those errors later on, &lt;code&gt;SomeException&lt;/code&gt; and &lt;code&gt;Text&lt;/code&gt; are terrible representations because they don&#39;t give your callers any information about the set of error cases they might want to handle. If you want to do error-&lt;em&gt;handling&lt;/em&gt;, not just error-displaying, a sum type would be a better choice for &lt;code&gt;e&lt;/code&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/Simspace/on-error/master/#handling-errors&#34;&gt;Handling errors&lt;/a&gt; for some concrete suggestions.&lt;/p&gt; &#xA;&lt;p&gt;In any case, here&#39;s how to obtain an &lt;code&gt;e&lt;/code&gt; in all three cases.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;For &lt;code&gt;Nothing&lt;/code&gt;, use &lt;code&gt;onNothingThrowError&lt;/code&gt; with a value of type &lt;code&gt;e&lt;/code&gt; to be thrown if the value is &lt;code&gt;Nothing&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;For &lt;code&gt;Left x&lt;/code&gt;, use &lt;code&gt;onLeftThrowError&lt;/code&gt;. It uses &lt;code&gt;x&lt;/code&gt; as the error, which you can then convert to an &lt;code&gt;e&lt;/code&gt; using &lt;code&gt;mapError&lt;/code&gt;. For other, less common values, define a custom &lt;code&gt;on[Condition]ThrowError&lt;/code&gt; function in order to avoid polluting your non-error-handling code with error-handling concerns such as converting to &lt;code&gt;Maybe&lt;/code&gt; or &lt;code&gt;Either&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For &lt;code&gt;ExceptT.throwE&lt;/code&gt; and &lt;code&gt;MonadError.throwError&lt;/code&gt;, there is nothing to do, because &lt;code&gt;Control.Monad.Trans.OnError&lt;/code&gt; already uses &lt;code&gt;ExceptT&lt;/code&gt; to propagate the error upwards. The &lt;code&gt;Control.Monad.OnError&lt;/code&gt; API is slightly different in that regard, see the &lt;a href=&#34;https://raw.githubusercontent.com/Simspace/on-error/master/#propagating-and-transforming-errors&#34;&gt;Propagating and transforming errors&lt;/a&gt; section for details.&lt;/p&gt; &lt;p&gt;For &lt;code&gt;MonadFail.fail&lt;/code&gt;, the behaviour depends on the monad. Due to a design wart, calling &lt;code&gt;fail&lt;/code&gt; often throws an exception, even for error-tracking monads such as &lt;code&gt;Either&lt;/code&gt; and &lt;code&gt;ExceptT&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For exceptions, try to catch them as close to their source as possible and to rethrow them as errors using one of the two other methods. Be careful to only catch the exceptions you know about; blindly catching all exceptions and propagating them up as a &lt;code&gt;SomeException&lt;/code&gt; or a &lt;code&gt;Text&lt;/code&gt; will not improve the quality of your error handling, it will only decrease it since your callers won&#39;t know what to handle and it will be much more difficult to make sure the generated error messages are valid english sentences. It is better to let unknown exceptions propagate upwards as exceptions, not errors, and to handle exceptions generically at the top-level of your program. Because of asynchronous exceptions, all the code you write has to be exception-safe anyway.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Propagating and transforming errors&lt;/h2&gt; &#xA;&lt;p&gt;Once an error is detected, the computation stops and the error gets propagated up the stack until it gets handled. &lt;code&gt;on-error&lt;/code&gt;&#39;s two modules provide two alternate ways of doing that:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;Control.Monad.Trans.OnError&lt;/code&gt; is based on &lt;code&gt;transformers&lt;/code&gt;, in which case &lt;code&gt;ExceptT&lt;/code&gt; should be the outermost transformer.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Control.Monad.OnError&lt;/code&gt; is based on &lt;code&gt;mtl&lt;/code&gt;, in which case the computation should be polymorphic in &lt;code&gt;m&lt;/code&gt; and have a &lt;code&gt;MonadError e m&lt;/code&gt; constaint.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Learning &lt;code&gt;Control.Monad.Trans.OnError&lt;/code&gt; first is recommended, because its type signatures are more intuitive. The type signatures of the &lt;code&gt;Control.Monad.OnError&lt;/code&gt; module are a bit misleading because they often ask for an &lt;code&gt;ExceptT&lt;/code&gt; computation when a computation which is polymorphic in &lt;code&gt;m&lt;/code&gt; would be a better choice. For example, the type of &lt;code&gt;Control.Monad.OnError.mapError&lt;/code&gt; is&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mapError :: MonadError e&#39; m =&amp;gt; (e -&amp;gt; e&#39;) -&amp;gt; ExceptT e m a -&amp;gt; m a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And so we might be tempted to give it an &lt;code&gt;ExceptT e m a&lt;/code&gt; computation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;countHumans :: forall m. (MonadError Text m, MonadIO m) =&amp;gt; m Int&#xA;countHumans = mapError (&#34;while counting humans: &#34; &amp;lt;&amp;gt;) body&#xA;  where&#xA;    body :: ExceptT Text m Int&#xA;    body = do&#xA;      liftIO $ putStrLn &#34;counting humans...&#34;&#xA;      throwE &#34;humans are not pets&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This typechecks, but using such a concrete monad stack doesn&#39;t fit well with the &lt;code&gt;mtl&lt;/code&gt; style for which &lt;code&gt;Control.Monad.OnError&lt;/code&gt; is designed. It would be better to use a polymorphic monad stack:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;countHumans :: forall m. (MonadError Text m, MonadIO m) =&amp;gt; m Int&#xA;countHumans = mapError (&#34;while counting humans: &#34; &amp;lt;&amp;gt;) body&#xA;  where&#xA;    body :: forall n. (MonadError Text n, MonadIO n) =&amp;gt; n Int&#xA;    body = do&#xA;      liftIO $ putStrLn &#34;counting humans...&#34;&#xA;      throwError &#34;humans are not pets&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This typechecks as well, since &lt;code&gt;n&lt;/code&gt; automatically gets specialized to &lt;code&gt;ExceptT Text m&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The reason &lt;code&gt;mapError&lt;/code&gt; specializes the &lt;code&gt;n&lt;/code&gt; of its input computation in this way is that changing the type of the error being propagated is not an effectful action in any monad, it is instead a translation from an &lt;code&gt;ExceptT e&lt;/code&gt; computation to an &lt;code&gt;ExceptT e&#39;&lt;/code&gt; computation. By specializing &lt;code&gt;n a&lt;/code&gt; to &lt;code&gt;ExceptT e m a&lt;/code&gt;, we can strip off the &lt;code&gt;ExceptT e&lt;/code&gt; layer to obtain an &lt;code&gt;m (Either e a)&lt;/code&gt;, at which point we can convert the &lt;code&gt;e&lt;/code&gt; to an &lt;code&gt;e&#39;&lt;/code&gt; and rethrow it using &lt;code&gt;m&lt;/code&gt;&#39;s &lt;code&gt;MonadError&lt;/code&gt; instance. This means that &lt;code&gt;m&lt;/code&gt; will itself be instantiated to a monad stack containing an &lt;code&gt;ExceptT e&#39;&lt;/code&gt; at some point, and so if the &lt;code&gt;n a&lt;/code&gt; computation was using a concrete monad stack, it would look something like &lt;code&gt;ExceptT e (ExceptT e&#39; IO) a&lt;/code&gt;. This is a pretty unusual and unintuitive monad stack, which is another reason to prefer writing it as a computation which is polymorphic in &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Handling errors&lt;/h2&gt; &#xA;&lt;p&gt;While you can use the &lt;code&gt;onError[Action]&lt;/code&gt; functions to handle the errors in whichever way you please, here are some concrete recommendations.&lt;/p&gt; &#xA;&lt;p&gt;For a function which looks up a key in a &lt;code&gt;Map&lt;/code&gt;, it makes sense to return a &lt;code&gt;Maybe&lt;/code&gt; to denote the fact that the key was not found. The &lt;code&gt;Nothing&lt;/code&gt; case isn&#39;t necessarily an error case; perhaps the caller wants to insert a new value at that key, and the &lt;code&gt;Nothing&lt;/code&gt; case is actually the success case because there isn&#39;t an existing, conflicting value at that key.&lt;/p&gt; &#xA;&lt;p&gt;So when we are very close to the source of the &#34;error&#34;, it&#39;s not yet clear whether that error is problematic or not, because we do not yet have enough context. So we propagate the information upwards, in the hope that the caller has more context.&lt;/p&gt; &#xA;&lt;p&gt;If we are manipulating a graph represented as a &lt;code&gt;Map&lt;/code&gt; from node to neighbours, we know that our invariant is that all the neighbour nodes must be present in the &lt;code&gt;Map&lt;/code&gt;. So if we attempt to perform a lookup and we receive a &lt;code&gt;Nothing&lt;/code&gt;, we know that we have a bug somewhere which accidentally breaks the invariant. There is nothing the caller can do about this, the only solution is to abort and to inform the programmer that a bug needs to be fixed. Since there is nothing the caller can do, it is not useful to tell it that this particular error case could happen, and so for bugs, I don&#39;t recommend propagating the error up using &lt;code&gt;on-error&lt;/code&gt;, instead I recommend failing with an exception, for example using &lt;code&gt;error &#34;invariant violated: neighbour not in Map&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Keeping track of such invariants in order to know when to convert unlikely errors into exceptions which will hopefully never be thrown is an important part of error-handling, because it allows you to reduce the number of error cases you are propagating up. Otherwise, as we go up the stack, functions have more and more sub-calls beneath them, and so more and more error cases would accumulate, and handling all those cases would become unmanageable. I recommend trying to keep the number of error cases small at all levels.&lt;/p&gt; &#xA;&lt;p&gt;At the top-level, the caller is the user. For them, a sum type describing all the possible error cases is less useful; what they need is a clear error message. So once we have enough context to know that an error cannot be handled by the code and will have to be displayed to the user, I recommend converting the value representing the error to &lt;code&gt;Text&lt;/code&gt;, and to propagate that error message upwards. With judicious uses of &lt;code&gt;annotateError&lt;/code&gt;, this error message can be annotated with some contextual information clarifying where the error has occurred.&lt;/p&gt; &#xA;&lt;p&gt;For example, if the user provides a pair of keys so we can perform some lookup in a nested &lt;code&gt;Map&lt;/code&gt; of &lt;code&gt;Map&lt;/code&gt;s, we&#39;ll have to tell the user which key wasn&#39;t found and in which &lt;code&gt;Map&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;lookupM :: MonadError Text m&#xA;        =&amp;gt; Int -&amp;gt; Map Int a -&amp;gt; m a&#xA;lookupM k = onNothingThrowError (&#34;key &#34; &amp;lt;&amp;gt; showt k &amp;lt;&amp;gt; &#34; not found&#34;)&#xA;          . Map.lookup k&#xA;&#xA;nestedLookupM :: MonadError Text m&#xA;              =&amp;gt; (Int, Int) -&amp;gt; Map Int (Map Int a) -&amp;gt; m a&#xA;nestedLookupM (k1, k2) mm = do&#xA;  m &amp;lt;- annotateError &#34;outer map&#34; $ lookupM k1 mm&#xA;  a &amp;lt;- annotateError &#34;inner map&#34; $ lookupM k2 m&#xA;  pure a&#xA;&#xA;-- |&#xA;-- &amp;gt;&amp;gt;&amp;gt; nestedLookupM (3,4) nestedMap :: Either Text Int&#xA;-- Left &#34;outer map: key 3 not found&#34;&#xA;-- &amp;gt;&amp;gt;&amp;gt; nestedLookupM (1,4) nestedMap :: Either Text Int&#xA;-- Left &#34;inner map: key 4 not found&#34;&#xA;nestedMap :: Map Int (Map Int Int)&#xA;nestedMap = Map.fromList [(1, Map.fromList [(2, 42)])]&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>