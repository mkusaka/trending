<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-09T01:53:53Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>wireapp/wire-server</title>
    <updated>2023-04-09T01:53:53Z</updated>
    <id>tag:github.com,2023-04-09:/wireapp/wire-server</id>
    <link href="https://github.com/wireapp/wire-server" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸ‡ªðŸ‡º Wire back-end services&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Wireâ„¢&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://wire.com/jobs/&#34;&gt;&lt;img src=&#34;https://github.com/wireapp/wire/raw/master/assets/header-small.png?raw=true&#34; alt=&#34;Wire logo&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This repository is part of the source code of Wire. You can find more information at &lt;a href=&#34;https://wire.com&#34;&gt;wire.com&lt;/a&gt; or by contacting &lt;a href=&#34;mailto:opensource@wire.com&#34;&gt;opensource@wire.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can find the published source code at &lt;a href=&#34;https://github.com/wireapp/wire&#34;&gt;github.com/wireapp/wire&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For licensing information, see the attached LICENSE file and the list of third-party licenses at &lt;a href=&#34;https://wire.com/legal/licenses/&#34;&gt;wire.com/legal/licenses/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;No license is granted to the Wire trademark and its associated logos, all of which will continue to be owned exclusively by Wire Swiss GmbH. Any use of the Wire trademark and/or its associated logos is expressly prohibited without the express prior written consent of Wire Swiss GmbH.&lt;/p&gt; &#xA;&lt;h2&gt;Wire server&lt;/h2&gt; &#xA;&lt;p&gt;This repository contains the source code for the Wire server. It contains all libraries and services necessary to run Wire.&lt;/p&gt; &#xA;&lt;p&gt;For documentation on how to self host your own Wire-Server see &lt;a href=&#34;https://raw.githubusercontent.com/wireapp/wire-server/develop/#how-to-install-and-run-wire-server&#34;&gt;this section&lt;/a&gt;. Federation is on our long term roadmap.&lt;/p&gt; &#xA;&lt;p&gt;See more in &#34;&lt;a href=&#34;https://medium.com/@wireapp/open-sourcing-wire-server-code-ef7866a731d5&#34;&gt;Open sourcing Wire server code&lt;/a&gt;&#34;.&lt;/p&gt; &#xA;&lt;h2&gt;Contents of this repository&lt;/h2&gt; &#xA;&lt;p&gt;This repository contains the following source code:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;services&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;nginz&lt;/strong&gt;: Public API Reverse Proxy (Nginx with custom libzauth module)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;galley&lt;/strong&gt;: Conversations and Teams&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;brig&lt;/strong&gt;: Accounts&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;gundeck&lt;/strong&gt;: Push Notification Hub&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;cannon&lt;/strong&gt;: WebSocket Push Notifications&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;cargohold&lt;/strong&gt;: Asset (image, file, ...) Storage&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;proxy&lt;/strong&gt;: 3rd Party API Integration&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;restund&lt;/strong&gt;: STUN/TURN server for use in Audio/Video calls&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;spar&lt;/strong&gt;: Single-Sign-On (SSO)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;tools&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;api-simulations&lt;/strong&gt;: Run automated smoke and load tests&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;db/&lt;/strong&gt;: Migration tools (e.g. when new tables are added)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;stern/&lt;/strong&gt;: Backoffice tool (basic &lt;a href=&#34;https://swagger.io/&#34;&gt;Swagger&lt;/a&gt; based interface)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;libs&lt;/strong&gt;: Shared libraries&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It also contains&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;build&lt;/strong&gt;: Build scripts and Dockerfiles for some platforms&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;deploy&lt;/strong&gt;: (Work-in-progress) - how to run wire-server in an ephemeral, in-memory demo mode&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;doc&lt;/strong&gt;: Documentation&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;hack&lt;/strong&gt;: scripts and configuration for kuberentes helm chart development/releases mainly used by CI&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;charts&lt;/strong&gt;: Kubernetes Helm charts. The charts are mirroed to S3 and can be used with &lt;code&gt;helm repo add wire https://s3-eu-west-1.amazonaws.com/public.wire.com/charts&lt;/code&gt;. See the &lt;a href=&#34;https://docs.wire.com&#34;&gt;Administrator&#39;s Guide&lt;/a&gt; for more info.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Architecture Overview&lt;/h2&gt; &#xA;&lt;p&gt;The following diagram gives a high-level outline of the (deployment) architecture of the components that make up a Wire Server as well as the main internal and external dependencies between components.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wireapp/wire-server/develop/docs/src/developer/developer/architecture/wire-arch-2.png&#34; alt=&#34;wire-arch&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Communication between internal components is currently not guarded by dedicated authentication or encryption and is assumed to be confined to a private network.&lt;/p&gt; &#xA;&lt;h2&gt;Development setup&lt;/h2&gt; &#xA;&lt;h3&gt;How to build &lt;code&gt;wire-server&lt;/code&gt; binaries&lt;/h3&gt; &#xA;&lt;p&gt;There are two options:&lt;/p&gt; &#xA;&lt;h4&gt;1. Use docker&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;If you don&#39;t wish to build all docker images from scratch (e.g. the &lt;code&gt;ubuntu20-builder&lt;/code&gt; takes a very long time), ready-built images can be downloaded from &lt;a href=&#34;https://quay.io/organization/wire&#34;&gt;here&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you wish to build your own docker images, you need &lt;a href=&#34;https://www.docker.com/&#34;&gt;docker version &amp;gt;= 17.05&lt;/a&gt; and &lt;a href=&#34;https://www.gnu.org/software/make/&#34;&gt;&lt;code&gt;make&lt;/code&gt;&lt;/a&gt;. Then,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# optionally:&#xA;# make docker-builder # if you don&#39;t run this, it pulls the ubuntu20-builder image from quay.io&#xA;make docker-deps docker-intermediate docker-services&#xA;&#xA;# subsequent times, after changing code, if you wish to re-create docker images, it&#39;s sufficient to&#xA;make docker-intermediate docker-services&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will, eventually, have built a range of docker images. Make sure to &lt;a href=&#34;https://github.com/wireapp/wire-server/issues/562&#34;&gt;give Docker enough RAM&lt;/a&gt;; if you see &lt;code&gt;make: *** [builder] Error 137&lt;/code&gt;, it might be a sign that the build ran out of memory. You can also mix and match â€“ e.g. pull the &lt;a href=&#34;https://quay.io/repository/wire/ubuntu20-builder?tab=tags&#34;&gt;&lt;code&gt;ubuntu20-builder&lt;/code&gt;&lt;/a&gt; image and build the rest locally.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;code&gt;Makefile&lt;/code&gt;s and &lt;code&gt;Dockerfile&lt;/code&gt;s, as well as &lt;a href=&#34;https://raw.githubusercontent.com/wireapp/wire-server/develop/build/ubuntu/README.md&#34;&gt;build/ubuntu/README.md&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h4&gt;2. Use nix-provided build environment&lt;/h4&gt; &#xA;&lt;p&gt;This is suitable only for local development and testing. See &lt;a href=&#34;https://raw.githubusercontent.com/wireapp/wire-server/develop/docs/src/developer/developer/building.md&#34;&gt;build instructions&lt;/a&gt; in the developer documentation.&lt;/p&gt; &#xA;&lt;h2&gt;How to install and run &lt;code&gt;wire-server&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;You have two options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Option 1. (recommended) Install wire-server on kubernetes using the configuration and instructions provided in &lt;a href=&#34;https://github.com/wireapp/wire-server-deploy&#34;&gt;wire-server-deploy&lt;/a&gt;. This is the best option to run it on a server and recommended if you want to self-host wire-server.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Option 2. Compile everything in this repo, then you can use the &lt;code&gt;services/start-services-only.sh&lt;/code&gt;. This option is intended as a way to try out wire-server on your local development machine and not suited for production.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>phulin/symbolic-trace</title>
    <updated>2023-04-09T01:53:53Z</updated>
    <id>tag:github.com,2023-04-09:/phulin/symbolic-trace</id>
    <link href="https://github.com/phulin/symbolic-trace" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Symbolic execution of LLVM IR traces for program understanding.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;RESET&lt;/h1&gt; &#xA;&lt;p&gt;Reverse Engineering through Symbolic Execution of Traces: Symbolic execution of LLVM IR traces for program understanding.&lt;/p&gt; &#xA;&lt;p&gt;To evaluate a trace, first run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal configure&#xA;cabal build --ghc-options=&#34;-rtsopts&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, to run a program, grab a trace&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dist/build/Eval/Eval -q &amp;lt;qemu_build_dir&amp;gt; &amp;lt;program&amp;gt; &amp;lt;program-args&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The qemu_build_dir should be the build directory, such as ~/qemu/x86_64-linux-user.&lt;/p&gt; &#xA;&lt;p&gt;For a trace in whole-system mode, you need to gather the trace manually. First, make a PANDA record/replay recording of the execution you want to look at. Next, use Volatility or a similar tool to find the CR3 you&#39;re looking for, and then run a command like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;echo &#34;begin_replay &amp;lt;recording&amp;gt;&#34; | ~/qemu/i386-softmmu/qemu-system-i386 -panda-plugin ~/qemu/i386-softmmu/panda_plugins/panda_llvm_trace.so -panda-arg llvm_trace:cr3=0xDEADBEEF -monitor stdio ~/win7.1.qcows2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;followed by&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dist/build/Eval/Eval&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can do &lt;code&gt;Eval --help&lt;/code&gt; to see a list of command line options. By default, PANDA stores trace information in &lt;code&gt;/tmp&lt;/code&gt;; if you want to change this, use &lt;code&gt;Eval -d&lt;/code&gt; and &lt;code&gt;qemu -panda-arg llvm_trace:base=/other/dir&lt;/code&gt;. Eval will also probably run out stack space; increase that by adding the arguments &lt;code&gt;+RTS -K1G -RTS&lt;/code&gt;, where the 1G specifies 1 GB of stack space.&lt;/p&gt; &#xA;&lt;p&gt;This will start a server that accepts JSON requests for symbolic execution data from the RESET IDA plugin (github.com/phulin/RESETPlugin)&lt;/p&gt; &#xA;&lt;h1&gt;Files&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;types/&lt;/code&gt;: Definitions of basic types. This is in a separate Cabal package due to GHC bug #3333 - you can&#39;t have Template Haskell code in a package that links to C++ code. We use TH for the JSON parsing; aeson provides a nice auto-serialization interface.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AppList.hs&lt;/code&gt;: Definition of a linked list type which is optimized for appending; we use this instead of normal List for pretty much everything.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Memlog.hs&lt;/code&gt;: Functions for parsing and processing the Panda dynamic log&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Instances.hs&lt;/code&gt;: Miscellanous instances of Show, mostly for debugging&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Options.hs&lt;/code&gt;: Definition and parsing of command-line arguments.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Pretty.hs&lt;/code&gt;: The Pretty class for pretty-printing; probably could be done in a much nicer way&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Expr.hs&lt;/code&gt;: Operations for working with our expression format&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Eval.hs&lt;/code&gt;: Main functions - meat of the symbolic evaluation engine&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Main.hs&lt;/code&gt;: Server code and command-line argument processing, etc&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>joar/hs-hitchhiker</title>
    <updated>2023-04-09T01:53:53Z</updated>
    <id>tag:github.com,2023-04-09:/joar/hs-hitchhiker</id>
    <link href="https://github.com/joar/hs-hitchhiker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Working copy for my progress on http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>