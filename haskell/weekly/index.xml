<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-05T08:39:28Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>abi/core-lang</title>
    <updated>2023-02-05T08:39:28Z</updated>
    <id>tag:github.com,2023-02-05:/abi/core-lang</id>
    <link href="https://github.com/abi/core-lang" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell implementation of Core Language described in the Implementing Functional Languages book&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>Roguelazer/sedc</title>
    <updated>2023-02-05T08:39:28Z</updated>
    <id>tag:github.com,2023-02-05:/Roguelazer/sedc</id>
    <link href="https://github.com/Roguelazer/sedc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A compiler for sed&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;sedc - an optimizing sed compiler&lt;/h1&gt; &#xA;&lt;p&gt;I don&#39;t know if you realize this, but &lt;strong&gt;sed&lt;/strong&gt; is capable of much more than just pipelines containing only &lt;code&gt;s///&lt;/code&gt; operations. I suspect that it might be possible to make it Turing-complete (even though it&#39;s just single-pass).&lt;/p&gt; &#xA;&lt;p&gt;I&#39;ve been enjoying using some of its more esoteric features, and one day I realized that the X86 instruction &lt;code&gt;XLAT&lt;/code&gt; is a reasonable simulacrum of the &lt;code&gt;y///&lt;/code&gt; operator. Thus this project was born. I&#39;ve never written a compiler in Haskell before, so I decided to do this project in Haskell rather than my more comfortable SML or Ocaml.&lt;/p&gt; &#xA;&lt;p&gt;Much of the structure of this project is based on my &lt;a href=&#34;https://www.cs.hmc.edu/twiki/bin/view/CS132Spring2009&#34;&gt;Compilers class&lt;/a&gt; with the always-awesome &lt;a href=&#34;http://www.cs.hmc.edu/~stone/&#34;&gt;Professor Stone&lt;/a&gt;. I obviously won&#39;t be taking any code whole-hog from there, especially since it&#39;s in a different language and was sourcing a much more complicated language. But the ideas come from that class.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This work is available under the ISC (OpenBSD) license. The full contents of this license are checked in as &lt;code&gt;license.txt&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Project status&lt;/h2&gt; &#xA;&lt;p&gt;I just started this project, so it hasn&#39;t come very far. The parser is going to be tricky, since regular expressions are pretty complicated in and of itself. After that, there&#39;ll be writing an efficient regexp engine (it&#39;d be cheating to use somebody else&#39;s).&lt;/p&gt; &#xA;&lt;p&gt;Oh, and all of the other steps of the compilation process.&lt;/p&gt; &#xA;&lt;p&gt;Cheers,&lt;/p&gt; &#xA;&lt;p&gt;James Brown &lt;a href=&#34;mailto:roguelazer@roguelazer.com&#34;&gt;roguelazer@roguelazer.com&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>qnikst/iochan-conduit</title>
    <updated>2023-02-05T08:39:28Z</updated>
    <id>tag:github.com,2023-02-05:/qnikst/iochan-conduit</id>
    <link href="https://github.com/qnikst/iochan-conduit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;IO concurrent promitives for conduit&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Library for making conduit message passing via Control.Concurrent primitives, it can be faster than using STM in some cases, but do not allow all functionality that STM chans has.&lt;/p&gt; &#xA;&lt;p&gt;3 basic primitives will be provided:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;simple Chan as InfiniteChan&lt;/li&gt; &#xA; &lt;li&gt;wrapper over Chan as EndedChan&lt;/li&gt; &#xA; &lt;li&gt;bounded Chan as BChan&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>