<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-23T01:46:10Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>elm/compiler</title>
    <updated>2022-10-23T01:46:10Z</updated>
    <id>tag:github.com,2022-10-23:/elm/compiler</id>
    <link href="https://github.com/elm/compiler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Compiler for Elm, a functional language for reliable webapps.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Elm&lt;/h1&gt; &#xA;&lt;p&gt;A delightful language for reliable webapps.&lt;/p&gt; &#xA;&lt;p&gt;Check out the &lt;a href=&#34;http://elm-lang.org/&#34;&gt;Home Page&lt;/a&gt;, &lt;a href=&#34;http://elm-lang.org/try&#34;&gt;Try Online&lt;/a&gt;, or &lt;a href=&#34;http://guide.elm-lang.org/&#34;&gt;The Official Guide&lt;/a&gt;&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;‚ú® &lt;a href=&#34;https://guide.elm-lang.org/install/elm.html&#34;&gt;Install&lt;/a&gt; ‚ú®&lt;/p&gt; &#xA;&lt;p&gt;For multiple versions, previous versions, and uninstallation, see the instructions &lt;a href=&#34;https://github.com/elm/compiler/raw/master/installers/README.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Help&lt;/h2&gt; &#xA;&lt;p&gt;If you are stuck, ask around on &lt;a href=&#34;http://elmlang.herokuapp.com/&#34;&gt;the Elm slack channel&lt;/a&gt;. Folks are friendly and happy to help with questions!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>input-output-hk/hydra-poc</title>
    <updated>2022-10-23T01:46:10Z</updated>
    <id>tag:github.com,2022-10-23:/input-output-hk/hydra-poc</id>
    <link href="https://github.com/input-output-hk/hydra-poc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Proof of concept for the Hydra Head protocol üë∑&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;p align=&#34;center&#34;&gt;Hydra Head - Proof of Concept (POC)&lt;/p&gt;&lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;A home to our colorful experiments and prototypes.&lt;/p&gt; &#xA; &lt;a href=&#34;https://github.com/input-output-hk/hydra-poc/actions&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/input-output-hk/hydra-poc/CI?label=Tests&amp;amp;style=for-the-badge&#34;&gt;&lt;/a&gt; &#xA; &lt;a href=&#34;https://github.com/input-output-hk/hydra-poc/pkgs/container/hydra-node&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/input-output-hk/hydra-poc/Docker?label=Docker&amp;amp;style=for-the-badge&#34;&gt;&lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;&lt;span&gt;üåÑ&lt;/span&gt; Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Hydra is the layer-two scalability solution for Cardano, which aims to increase the speed of transactions (low latency, high throughput) and minimize transaction cost.&lt;/p&gt; &#xA;&lt;p&gt;This repository contains the proof-of-concept implementation for the Hydra &lt;a href=&#34;https://eprint.iacr.org/2020/299.pdf&#34;&gt;Head protocol&lt;/a&gt;. It is a developer preview that we&#39;ve put together, marching towards a production ready solution. It outlines the basic architecture of a &lt;code&gt;hydra-node&lt;/code&gt;, which runs a simplified (coordinated) Hydra Head protocol, connects to other hydra-nodes, interfaces the Cardano blockchain and provides an API to clients such as the included terminal user interface &lt;code&gt;hydra-tui&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;span&gt;‚ö†&lt;/span&gt; &lt;span&gt;‚ö†&lt;/span&gt; &lt;span&gt;‚ö†&lt;/span&gt;&lt;/p&gt; &#xA; &lt;p&gt;This is still prototypical and exploratory work shared here for your interest.&lt;/p&gt; &#xA; &lt;p&gt;It is NOT ready for production (yet).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;&lt;span&gt;üöÄ&lt;/span&gt; Getting started&lt;/h2&gt; &#xA;&lt;p&gt;The quickest way to get a &lt;code&gt;hydra-node&lt;/code&gt; running is to use our &lt;a href=&#34;https://github.com/orgs/input-output-hk/packages?repo_name=hydra-poc&#34;&gt;docker images&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker pull ghcr.io/input-output-hk/hydra-node:0.7.0&#xA;docker run --rm ghcr.io/input-output-hk/hydra-node --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More information (including a demo) available on &lt;a href=&#34;https://hydra.family/head-protocol/docs/getting-started&#34;&gt;user manual üìñ&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;üåà&lt;/span&gt; Features&lt;/h2&gt; &#xA;&lt;p&gt;Proof of concept:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Coordinated Hydra Head protocol&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Single Head per hydra-node&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Network statically configured, direct TCP connections&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; WebSocket, message-based API Server&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Terminal user interface client&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Cardano-node integration via Direct connection&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Running on testnet&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Persisted Head state&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Later:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Audited and mainnet ready&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Multiple Heads per hydra-node, managed via API&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Support for external wallets (e.g. hardware wallets)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Optimistic Head closure and incremental de-/commit protocol extension&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Relay-capable, mesh network&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;span&gt;ü§ù&lt;/span&gt; Contributing&lt;/h2&gt; &#xA;&lt;p&gt;The best way to contribute right now is to provide feedback. Give the &lt;a href=&#34;https://raw.githubusercontent.com/input-output-hk/hydra-poc/master/demo&#34;&gt;demo&lt;/a&gt; a test drive and have a look at our &lt;a href=&#34;https://hydra.family/head-protocol&#34;&gt;documentation&lt;/a&gt;. Should you have any questions, ideas or issues, we would like to hear from you:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;#ask-hydra on the IOG &lt;a href=&#34;https://discord.gg/Qq5vNTg9PT&#34;&gt;Discord server&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;create a Github &lt;a href=&#34;https://github.com/input-output-hk/hydra-poc/discussions&#34;&gt;Discussion&lt;/a&gt; or &lt;a href=&#34;https://github.com/input-output-hk/hydra-poc/issues/new&#34;&gt;Issue&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;or ask on Cardano &lt;a href=&#34;https://cardano.stackexchange.com/&#34;&gt;StackExchange&lt;/a&gt; using the &lt;code&gt;hydra&lt;/code&gt; tag&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When contributing to this project and interacting with others, please follow our &lt;a href=&#34;https://raw.githubusercontent.com/input-output-hk/hydra-poc/master/CONTRIBUTING.md&#34;&gt;Contributing Guidelines&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/input-output-hk/hydra-poc/master/CODE-OF-CONDUCT.md&#34;&gt;Code of Conduct&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p align=&#34;center&#34;&gt; Thanks for visiting and enjoy &lt;span&gt;‚ù§Ô∏è&lt;/span&gt;! &lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ucsd-progsys/liquid-fixpoint</title>
    <updated>2022-10-23T01:46:10Z</updated>
    <id>tag:github.com,2022-10-23:/ucsd-progsys/liquid-fixpoint</id>
    <link href="https://github.com/ucsd-progsys/liquid-fixpoint" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Horn Clause Constraint Solving for Liquid Types&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Liquid Fixpoint&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/liquid-fixpoint&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/liquid-fixpoint.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://packdeps.haskellers.com/feed?needle=liquid-fixpoint&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage-deps/v/liquid-fixpoint.svg?sanitize=true&#34; alt=&#34;Hackage-Deps&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/ucsd-progsys/liquid-fixpoint&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/ucsd-progsys/liquid-fixpoint.svg?style=svg&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ucsd-progsys/liquid-fixpoint/actions/workflows/hlint.yml&#34;&gt;&lt;img src=&#34;https://github.com/ucsd-progsys/liquid-fixpoint/actions/workflows/hlint.yml/badge.svg?sanitize=true&#34; alt=&#34;hlint&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ucsd-progsys/liquid-fixpoint/actions/workflows/cabal.yml&#34;&gt;&lt;img src=&#34;https://github.com/ucsd-progsys/liquid-fixpoint/actions/workflows/cabal.yml/badge.svg?sanitize=true&#34; alt=&#34;cabal&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ucsd-progsys/liquid-fixpoint/actions/workflows/stack.yml&#34;&gt;&lt;img src=&#34;https://github.com/ucsd-progsys/liquid-fixpoint/actions/workflows/stack.yml/badge.svg?sanitize=true&#34; alt=&#34;stack&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This package implements a Horn-Clause/Logical Implication constraint solver used for various Liquid Types. The solver uses SMTLIB2 to implement an algorithm similar to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://users.soe.ucsc.edu/~cormac/papers/fme01.pdf&#34;&gt;Houdini&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://swt.informatik.uni-freiburg.de/berit/papers/boolean-and-cartesian-....pdf&#34;&gt;Cartesian predicate abstraction&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;In addition to the .cabal dependencies you require an SMTLIB2 compatible solver binary:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Z3Prover/z3&#34;&gt;Z3&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cvc4.github.io/&#34;&gt;CVC4&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://mathsat.fbk.eu/download.html&#34;&gt;MathSat&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If on Windows, please make sure to place the binary and any associated DLLs somewhere in your path.&lt;/p&gt; &#xA;&lt;h2&gt;How To Build and Install&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/ucsd-progsys/liquid-fixpoint.git&#xA;$ cd liquid-fixpoint&#xA;$ stack install # alternatively, use `cabal install`.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Test with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ stack test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ stack exec fixpoint -- tests/pos/adt.fq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using SMTLIB-based SMT Solvers&lt;/h2&gt; &#xA;&lt;p&gt;You can use one of several SMTLIB2 compliant solvers, by:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;fixpoint --solver=z3 path/to/file.hs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Currently, we support&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;* Z3&#xA;* CVC4&#xA;* MathSat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&#34;Horn&#34; Format&lt;/h2&gt; &#xA;&lt;p&gt;See the examples in &lt;code&gt;tests/horn/{pos, neg}&lt;/code&gt; eg&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ucsd-progsys/liquid-fixpoint/develop/tests/horn/pos/ple_sum.smt2&#34;&gt;sum&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ucsd-progsys/liquid-fixpoint/develop/tests/horn/pos/ple_list00.smt2&#34;&gt;list00&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ucsd-progsys/liquid-fixpoint/develop/tests/horn/neg/ple_list03.smt2&#34;&gt;list03&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For how to write VCs &#34;by hand&#34;.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://arxiv.org/abs/2010.07763&#34;&gt;this tutorial&lt;/a&gt; with &lt;a href=&#34;https://github.com/ranjitjhala/sprite-lang&#34;&gt;accompanying code&lt;/a&gt; for an example of how to generate Horn queries.&lt;/p&gt; &#xA;&lt;p&gt;The main datatypes are described in &lt;a href=&#34;https://raw.githubusercontent.com/ucsd-progsys/liquid-fixpoint/develop/src/Language/Fixpoint/Horn/Types.hs&#34;&gt;src/Language/Fixpoint/Horn/Types.hs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Configuration Management&lt;/h2&gt; &#xA;&lt;p&gt;It is very important that the version of Liquid Fixpoint be maintained properly.&lt;/p&gt; &#xA;&lt;p&gt;Suppose that the current version of Liquid Haskell is &lt;code&gt;A.B.C.D&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;After a release to hackage is made, if any of the components &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, or &lt;code&gt;D&lt;/code&gt; are missing, they shall be added and set to &lt;code&gt;0&lt;/code&gt;. Then the &lt;code&gt;D&lt;/code&gt; component of Liquid Fixpoint shall be incremented by &lt;code&gt;1&lt;/code&gt;. The version of Liquid Fixpoint is now &lt;code&gt;A.B.C.(D + 1)&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The first time a new function or type is exported from Liquid Fixpoint, if any of the components &lt;code&gt;B&lt;/code&gt;, or &lt;code&gt;C&lt;/code&gt; are missing, they shall be added and set to &lt;code&gt;0&lt;/code&gt;. Then the &lt;code&gt;C&lt;/code&gt; component shall be incremented by &lt;code&gt;1&lt;/code&gt;, and the &lt;code&gt;D&lt;/code&gt; component shall stripped. The version of Liquid Fixpoint is now &lt;code&gt;A.B.(C + 1)&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The first time the signature of an exported function or type is changed, or an exported function or type is removed (this includes functions or types that Liquid Fixpoint re-exports from its own dependencies), if the &lt;code&gt;B&lt;/code&gt; component is missing, it shall be added and set to &lt;code&gt;0&lt;/code&gt;. Then the &lt;code&gt;B&lt;/code&gt; component shall be incremented by &lt;code&gt;1&lt;/code&gt;, and the &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; components shall be stripped. The version of Liquid Fixpoint is now &lt;code&gt;A.(B + 1)&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;code&gt;A&lt;/code&gt; component shall be updated at the sole discretion of the project owners.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is recommended to use the &lt;a href=&#34;https://hackage.haskell.org/package/bumper&#34;&gt;Bumper&lt;/a&gt; utility to manage the versioning of Liquid Fixpoint. Bumper will automatically do the correct update to the cabal file. Additionally, it will update any packages that you have the source for that depend on Liquid Fixpoint.&lt;/p&gt; &#xA;&lt;p&gt;To update Liquid Fixpoint and Liquid Haskell, first clone Liquid Haskell and Liquid Fixpoint to a common location:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/ucsd-progsys/liquidhaskell.git&#xA;git clone https://github.com/ucsd-progsys/liquid-fixpoint.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To increment the &lt;code&gt;D&lt;/code&gt; component of Liquid Fixpoint:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./path/to/bumper -3 liquid-fixpoint&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will update the &lt;code&gt;D&lt;/code&gt; component of Liquid Fixpoint. If necessary, this will update the &lt;code&gt;Build-Depends&lt;/code&gt; of Liquid Haskell. If the &lt;code&gt;Build-Depends&lt;/code&gt; was updated, Liquid Haskell&#39;s &lt;code&gt;D&lt;/code&gt; component will be incremented.&lt;/p&gt; &#xA;&lt;p&gt;To increment the &lt;code&gt;C&lt;/code&gt; component of Liquid Fixpoint, and strip the &lt;code&gt;D&lt;/code&gt; component:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./path/to/bumper --minor liquid-fixpoint&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As before, this will update Liquid Fixpoint and, if necessary, Liquid Haskell.&lt;/p&gt; &#xA;&lt;p&gt;To increment the &lt;code&gt;B&lt;/code&gt; component of Liquid Fixpoint, and strip the &lt;code&gt;D&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; components:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./path/to/bumper --major liquid-fixpoint&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As before, this will update Liquid Fixpoint and, if necessary, Liquid Haskell&lt;/p&gt; &#xA;&lt;h2&gt;SMTLIB2 Interface&lt;/h2&gt; &#xA;&lt;p&gt;There is a new SMTLIB2 interface directly from Haskell:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Language.Fixpoint.SmtLib2&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;code&gt;tests/smt2/{Smt.hs, foo.smt2}&lt;/code&gt; for an example of how to use it.&lt;/p&gt; &#xA;&lt;h3&gt;Command Line for SMT2 interface&lt;/h3&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;.smt2&lt;/code&gt; interface from the command-line as follows:&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;--stdin&lt;/code&gt; to read files from &lt;code&gt;stdin&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ more tests/horn/pos/test01.smt2 | fixpoint --stdin&#xA;&#xA;Liquid-Fixpoint Copyright 2013-21 Regents of the University of California.&#xA;All Rights Reserved.&#xA;&#xA;Working 166% [===============================================================]&#xA;Safe ( 2  constraints checked)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;-q&lt;/code&gt; to disable all output (banner, progress bar etc.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ more tests/horn/pos/test01.smt2 | fixpoint -q --stdin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;--json&lt;/code&gt; to get the output as a JSON object (rendered to &lt;code&gt;stdout&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ more tests/horn/pos/abs02-re.smt2 | stack exec -- fixpoint -q --json --stdin&#xA;{&#34;contents&#34;:{&#34;numIter&#34;:3,&#34;numCstr&#34;:3,&#34;numChck&#34;:3,&#34;numBrkt&#34;:3,&#34;numVald&#34;:3},&#34;tag&#34;:&#34;Safe&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Options&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;--higherorder&lt;/code&gt; allows higher order binders into the environment&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--extsolver&lt;/code&gt; runs the &lt;strong&gt;deprecated&lt;/strong&gt; external solver.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--parts&lt;/code&gt; Partitions an &lt;code&gt;FInfo&lt;/code&gt; into a &lt;code&gt;[FInfo]&lt;/code&gt; and emits a bunch of files. So:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ fixpoint -n -p path/to/foo.fq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will now emit files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;path/to/.liquid/foo.1.fq&#xA;path/to/.liquid/foo.2.fq&#xA;. . .&#xA;path/to/.liquid/foo.k.fq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and also a dot file with the constraint dependency graph:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;path/to/.liquid/foo.fq.dot&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;FInfo Invariants&lt;/h2&gt; &#xA;&lt;h3&gt;Binders&lt;/h3&gt; &#xA;&lt;p&gt;This is the field&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;     , bs       :: !BindEnv         -- ^ Bind  |-&amp;gt; (Symbol, SortedReft)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or in the .fq files as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bind 1 x : ...&#xA;bind 2 y : ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Each &lt;code&gt;BindId&lt;/code&gt; must be a distinct &lt;code&gt;Int&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;Each &lt;code&gt;BindId&lt;/code&gt; that appears in a constraint environment i.e. inside &lt;em&gt;any&lt;/em&gt; &lt;code&gt;IBindEnv&lt;/code&gt; must appear inside the &lt;code&gt;bs&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Environments&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Each constraint&#39;s environment is a set of &lt;code&gt;BindId&lt;/code&gt; which must be defined in the &lt;code&gt;bindInfo&lt;/code&gt;. Furthermore&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Each constraint should not have &lt;em&gt;duplicate&lt;/em&gt; names in its environment, that is if you have two binders&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;  bind 1 x : ...&#xA;  bind 12 x : ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then a single &lt;code&gt;IBindEnv&lt;/code&gt; should only mention &lt;em&gt;at most&lt;/em&gt; one of &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;12&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;There is also a &#34;tree-shape&#34; property that its a bit hard to describe ... TODO&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;LHS&lt;/h3&gt; &#xA;&lt;p&gt;Each &lt;code&gt;slhs&lt;/code&gt; of a constraint is a &lt;code&gt;SortedReft&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Each &lt;code&gt;SortredReft&lt;/code&gt; is basically a &lt;code&gt;Reft&lt;/code&gt; -- a logical predicate. The important bit is that a &lt;code&gt;KVar&lt;/code&gt; i.e. terms of the formalized&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;     $k1[x1:=y1][x2:=y2]...[xn:=yn]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That is represented in the &lt;code&gt;Expr&lt;/code&gt; type as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  | PKVar  !KVar !Subst&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;must appear &lt;em&gt;only&lt;/em&gt; at the &lt;strong&gt;top-level&lt;/strong&gt; that is not under &lt;em&gt;any&lt;/em&gt; other operators, i.e. not as a sub-&lt;code&gt;Expr&lt;/code&gt; of other expressions.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This is basically a predicate that needs to be &#34;well sorted&#34; with respect to the &lt;code&gt;BindId&lt;/code&gt;, intuitively&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;    x:int, y:int |- x + y : int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is well sorted. but&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    x:int  |- x + y : int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is not, and&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    x:int, y: list |- x + y : int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is not. The exact definition is formalized in &lt;code&gt;Language.Fixpoint.SortCheck&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;RHS&lt;/h3&gt; &#xA;&lt;p&gt;Similarly each &lt;code&gt;rhs&lt;/code&gt; of a &lt;code&gt;SubC&lt;/code&gt; must either be a single &lt;code&gt;$k[...]&lt;/code&gt; or an plain &lt;code&gt;$k&lt;/code&gt;-free &lt;code&gt;Expr&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Global vs. Distinct Literals&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;     , gLits    :: !(SEnv Sort)               -- ^ Global Constant symbols&#xA;     , dLits    :: !(SEnv Sort)       &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;em&gt;global&lt;/em&gt; literals &lt;code&gt;gLits&lt;/code&gt; are symbols that are in scope &lt;em&gt;everywhere&lt;/em&gt; i.e. need not be separately defined in individual environments. These include things like&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;uninterpreted &lt;em&gt;measure&lt;/em&gt; functions &lt;code&gt;len&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;uninterpreted &lt;em&gt;data constructor&lt;/em&gt; literals &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;False&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Suppose you have an enumerated type like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;data Day = Sun | Mon | Tue | Wed | ... | Sat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can model the above values in fixpoint as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;constant lit#Sun : Day&#xA;constant lit#Mon : Day&#xA;constant lit#Tue : Day&#xA;constant lit#Wed : Day&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;em&gt;distinct&lt;/em&gt; literals are a subset of the above where we want to tell the SMT solver that the values are &lt;em&gt;distinct&lt;/em&gt; i.e. &lt;strong&gt;not equal&lt;/strong&gt; to each other, for example, you can &lt;strong&gt;additionally&lt;/strong&gt; specify this as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;distinct lit#Sun : Day&#xA;distinct lit#Mon : Day&#xA;distinct lit#Tue : Day&#xA;distinct lit#Wed : Day&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above two are represented programmatically by generating suitable &lt;code&gt;Symbol&lt;/code&gt; values (for the literals see &lt;code&gt;litSymbol&lt;/code&gt;) and &lt;code&gt;Sort&lt;/code&gt; values as &lt;code&gt;FTC FTycon&lt;/code&gt; and then making an &lt;code&gt;SEnv&lt;/code&gt; from the &lt;code&gt;[(Symbol, Sort)]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Sorts&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;What&#39;s the difference between an FTC and an FObj?&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;In early versions of fixpoint, there was support for three sorts for expressions (&lt;code&gt;Expr&lt;/code&gt;) that were sent to the SMT solver:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&#34;other&#34;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The &lt;code&gt;FObj&lt;/code&gt; sort was introduced to represent essentially &lt;em&gt;all&lt;/em&gt; non-int and non-bool values (e.g. tuples, lists, trees, pointers...)&lt;/p&gt; &#xA;&lt;p&gt;However, we later realized that it is valuable to keep &lt;em&gt;more&lt;/em&gt; precise information for &lt;code&gt;Expr&lt;/code&gt;s and so we introduced the &lt;code&gt;FTC&lt;/code&gt; (fixpoint type constructor), which lets us represent the above respectively as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;FTC &#34;String&#34; []&lt;/code&gt; -- in Haskell &lt;code&gt;String&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FTC &#34;Tuple&#34; [FInt, Bool]&lt;/code&gt; -- in Haskell &lt;code&gt;(Int, Bool)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FTC &#34;List&#34; [FTC &#34;List&#34; [FInt]]&lt;/code&gt; -- in Haskell &lt;code&gt;[[Int]]&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;There is a comment that says FObj&#39;s are uninterpretted types; so probably a type the SMT solver doesn&#39;t know about? Does that then make FTC types that the SMT solver does know about (bools, ints, lists, sets, etc.)?&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The SMT solver knows about &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; (also &lt;code&gt;bitvector&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;) but &lt;em&gt;all&lt;/em&gt; other types are &lt;em&gt;currently&lt;/em&gt; represented as plain &lt;code&gt;Int&lt;/code&gt; inside the SMT solver. However, we &lt;em&gt;will be&lt;/em&gt; changing this to make use of SMT support for ADTs ...&lt;/p&gt; &#xA;&lt;p&gt;To sum up: the &lt;code&gt;FObj&lt;/code&gt; is there for historical reasons; it has been subsumed by &lt;code&gt;FTC&lt;/code&gt; which is what I recomend you use. However &lt;code&gt;FObj&lt;/code&gt; is there if you want a simple &#34;unitype&#34; / &#34;any&#34; type for terms that are not &#34;interpreted&#34;.&lt;/p&gt; &#xA;&lt;h2&gt;Qualifier Patterns&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Œª&amp;gt; doParse&#39; (qualParamP sortP) &#34;&#34; &#34;z as (mon . $1) : int&#34;&#xA;QP {qpSym = &#34;z&#34;, qpPat = PatPrefix &#34;mon&#34; 1, qpSort = FInt}&#xA;Œª&amp;gt; doParse&#39; (qualParamP sortP) &#34;&#34; &#34;z as ($1 . mon) : int&#34;&#xA;QP {qpSym = &#34;z&#34;, qpPat = PatSuffix 1 &#34;mon&#34;, qpSort = FInt}&#xA;Œª&amp;gt; doParse&#39; (qualParamP sortP) &#34;&#34; &#34;z as mon : int&#34;&#xA;QP {qpSym = &#34;z&#34;, qpPat = PatExact &#34;mon&#34;, qpSort = FInt}&#xA;Œª&amp;gt; doParse&#39; (qualParamP sortP) &#34;&#34; &#34;z : int&#34;&#xA;QP {qpSym = &#34;z&#34;, qpPat = PatNone, qpSort = FInt}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>