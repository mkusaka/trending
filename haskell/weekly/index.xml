<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-03-23T01:42:37Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>goldfirere/th-desugar</title>
    <updated>2025-03-23T01:42:37Z</updated>
    <id>tag:github.com,2025-03-23:/goldfirere/th-desugar</id>
    <link href="https://github.com/goldfirere/th-desugar" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Desugars Template Haskell abstract syntax to a simpler format without changing semantics&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;code&gt;th-desugar&lt;/code&gt; Package&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://hackage.haskell.org/package/th-desugar&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/th-desugar.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/goldfirere/th-desugar/actions?query=workflow%3AHaskell-CI&#34;&gt;&lt;img src=&#34;https://github.com/goldfirere/th-desugar/workflows/Haskell-CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This package provides the &lt;code&gt;Language.Haskell.TH.Desugar&lt;/code&gt; module, which desugars Template Haskell&#39;s rich encoding of Haskell syntax into a simpler encoding. This desugaring discards surface syntax information (such as the use of infix operators) but retains the original meaning of the TH code. The intended use of this package is as a preprocessor for more advanced code manipulation tools. Note that the input to any of the &lt;code&gt;ds...&lt;/code&gt; functions should be produced from a TH quote, using the syntax &lt;code&gt;[| ... |]&lt;/code&gt;. If the input to these functions is a hand-coded TH syntax tree, the results may be unpredictable. In particular, it is likely that promoted datatypes will not work as expected.&lt;/p&gt; &#xA;&lt;p&gt;One explicit goal of this package is to reduce the burden of supporting multiple GHC / TH versions. Thus, the desugared language is the same across all GHC versions, and any inconsistencies are handled internally.&lt;/p&gt; &#xA;&lt;p&gt;The package was designed for use with the &lt;code&gt;singletons&lt;/code&gt; package, so some design decisions are based on that use case, when more than one design choice was possible.&lt;/p&gt; &#xA;&lt;p&gt;I will try to keep this package up-to-date with respect to changes in GHC. The minimum supported version of GHC is 8.0, which was chosen to avoid various Template Haskell bugs in older GHC versions that affect how this library desugars code. If this choice negatively impacts you, please submit a bug report.&lt;/p&gt; &#xA;&lt;h2&gt;Known limitations&lt;/h2&gt; &#xA;&lt;h2&gt;Desugaring depends on language extensions of use sites&lt;/h2&gt; &#xA;&lt;p&gt;Suppose you quote some Template Haskell declarations in module &lt;code&gt;A&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;{-# LANGUAGE ... #-}&#xA;module A where&#xA;&#xA;decs :: Q [Dec]&#xA;decs = [d| ... |]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And later desugar the declarations with &lt;code&gt;th-desugar&lt;/code&gt; in module &lt;code&gt;B&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;{-# LANGUAGE ... #-}&#xA;module B where&#xA;&#xA;import A (decs)&#xA;import Language.Haskell.TH.Desugar (dsDecs)&#xA;&#xA;$(do desugaredDecs &amp;lt;- dsDecs decs&#xA;     ...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are some situations where &lt;code&gt;th-desugar&lt;/code&gt;&#39;s desugaring depends on which language extensions are enabled, such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;MonadFailDesugaring&lt;/code&gt; (for desugaring partial pattern matches in &lt;code&gt;do&lt;/code&gt; notation)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NoFieldSelectors&lt;/code&gt; (for determining if a record field can be reified as a field selector with &lt;code&gt;lookupValueNameWithLocals&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Somewhat counterintuitively, &lt;code&gt;th-desugar&lt;/code&gt; will consult the language extensions in module &lt;code&gt;B&lt;/code&gt; (the site where the &lt;code&gt;decs&lt;/code&gt; are used) for this process, not module &lt;code&gt;A&lt;/code&gt; (where the &lt;code&gt;decs&lt;/code&gt; were defined). This is really a Template Haskell limitation, since Template Haskell does not offer any way to reify which language extensions were enabled at the time the declarations were defined. As a result, &lt;code&gt;th-desugar&lt;/code&gt; can only check for language extensions at use sites.&lt;/p&gt; &#xA;&lt;h2&gt;Limited support for kind inference&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;th-desugar&lt;/code&gt; sometimes has to construct types for certain Haskell entities. For instance, &lt;code&gt;th-desugar&lt;/code&gt; desugars all Haskell98-style constructors to use GADT syntax, so the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data T (a :: k) = MkT (Proxy a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be desugared to something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data T (a :: k) where&#xA;  MkT :: forall k (a :: k). Proxy a -&amp;gt; T (a :: k)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that &lt;code&gt;k&lt;/code&gt; is explicitly quantified in the type of &lt;code&gt;MkT&lt;/code&gt;. This is due to an additional pass that &lt;code&gt;th-desugar&lt;/code&gt; performs over the type variable binders of &lt;code&gt;T&lt;/code&gt; to extract all implicitly quantified variables and make them explicit. This makes the desugared types forwards-compatible with a &lt;a href=&#34;https://github.com/goldfirere/ghc-proposals/raw/bbefbee6fc0cddb10bbacc85f79e66c2706ce13f/proposals/0000-no-kind-vars.rst&#34;&gt;future version of GHC&lt;/a&gt; that requires all kind variables in a top-level &lt;code&gt;forall&lt;/code&gt; to be explicitly quantified.&lt;/p&gt; &#xA;&lt;p&gt;This process of extracting all implicitly quantified kind variables is not perfect, however. There are some obscure programs that will cause &lt;code&gt;th-desugar&lt;/code&gt; to produce type variable binders that are ill scoped. Here is one example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data P k (a :: k)&#xA;data Foo (a :: Proxy j) (b :: k) c = MkFoo c (P k j)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you squint hard at &lt;code&gt;MkFoo&lt;/code&gt;, you&#39;ll notice that &lt;code&gt;j :: k&lt;/code&gt;. However, this relationship is not expressed &lt;em&gt;syntactically&lt;/em&gt;, which means that &lt;code&gt;th-desugar&lt;/code&gt; will not be aware of it. Therefore, &lt;code&gt;th-desugar&lt;/code&gt; will desugar &lt;code&gt;Foo&lt;/code&gt; to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Foo (a :: Proxy j) (b :: k) c where&#xA;  MkFoo :: forall j k (a :: Proxy j) (b :: k) c.&#xA;           c -&amp;gt; P k j -&amp;gt; Foo (a :: Proxy j) (b :: k) c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is incorrect since &lt;code&gt;k&lt;/code&gt; must come before &lt;code&gt;j&lt;/code&gt; in order to be well scoped. There is a workaround to this issue, however: add more explicit kind information. If you had instead written this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Foo (a :: Proxy (j :: k)) (b :: k) c = MkFoo c (P k j)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then the fact that &lt;code&gt;j :: k&lt;/code&gt; is expressed directly in the AST, so &lt;code&gt;th-desugar&lt;/code&gt; is able to pick up on it and pick &lt;code&gt;forall k j (a :: Proxy j) (b :: k) c. &amp;lt;...&amp;gt;&lt;/code&gt; as the telescope for the type of &lt;code&gt;MkFoo&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The following constructs are known to be susceptible to this issue:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Desugared Haskell98-style constructors&lt;/li&gt; &#xA; &lt;li&gt;Locally reified class methods&lt;/li&gt; &#xA; &lt;li&gt;Locally reified record selectors&lt;/li&gt; &#xA; &lt;li&gt;Locally reified data constructors&lt;/li&gt; &#xA; &lt;li&gt;Locally reified type family instances (on GHC 8.8 and later, in which the Template Haskell AST supports explicit &lt;code&gt;foralls&lt;/code&gt; in type family equations)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Limited support for linear types&lt;/h2&gt; &#xA;&lt;p&gt;Currently, the &lt;code&gt;th-desugar&lt;/code&gt; AST deliberately makes it impossible to represent linear types, and desugaring a linear function arrow will simply turn into a normal function arrow &lt;code&gt;(-&amp;gt;)&lt;/code&gt;. This choice is partly motivated by issues in the way that linear types interact with Template Haskell, which sometimes make it impossible to tell whether a reified function type is linear or not. See, for instance, &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/-/issues/18378&#34;&gt;GHC#18378&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations of support for desugaring guards&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;th-desugar&lt;/code&gt; supports guards in the sense that it will desugar guards to equivalent code that instead uses &lt;code&gt;case&lt;/code&gt; expressions. For example, this code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;f (x, y)&#xA;  | x == &#34;hello&#34; = x&#xA;  | otherwise = y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will be desugared to this code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;f arg =&#xA;  case arg of&#xA;    (x, y) -&amp;gt;&#xA;      case x2 == &#34;hello&#34; of&#xA;        True  -&amp;gt; x&#xA;        False -&amp;gt; y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This has the advantage that it saves users from needing to care about the complexities of guards. It does have some drawbacks, however, which we describe below.&lt;/p&gt; &#xA;&lt;h3&gt;Desugaring guards can result in quadratic code size&lt;/h3&gt; &#xA;&lt;p&gt;If you desugar this program involving guards:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;data T = A Int | B Int | C Int&#xA;&#xA;f :: T -&amp;gt; T -&amp;gt; Maybe Int&#xA;f (A x1) (A x2)&#xA;  | x1 == x2&#xA;  = Just x1&#xA;f (B x1) (B x2)&#xA;  | x1 == x2&#xA;  = Just x1&#xA;f (C x1) (C x2)&#xA;  | x1 == x2&#xA;  = Just x1&#xA;f _ _ = Nothing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will end up with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;f :: T -&amp;gt; T -&amp;gt; Maybe Int&#xA;f arg1 arg2 =&#xA;  case (# arg1, arg2 #) of&#xA;    (# A x1, A x2 #) -&amp;gt;&#xA;      case x1 == x2 of&#xA;        True -&amp;gt;&#xA;          Just x1&#xA;        False -&amp;gt;&#xA;          case (# arg1, arg2 #) of&#xA;            (# B y1, B y2 #) -&amp;gt;&#xA;              case y1 == y2 of&#xA;                True -&amp;gt;&#xA;                  Just y1&#xA;                False -&amp;gt;&#xA;                  case (# arg1, arg2 #) of&#xA;                    (# C z1, C z2 #) -&amp;gt;&#xA;                      case z1 == z2 of&#xA;                        True -&amp;gt;&#xA;                          Just z1&#xA;                        False -&amp;gt;&#xA;                          case (# arg1, arg2 #) of&#xA;                            (# _, _ #) -&amp;gt;&#xA;                              Nothing&#xA;                    (# _, _ #) -&amp;gt;&#xA;                      Nothing&#xA;            (# C y1, C y2 #) -&amp;gt;&#xA;              case y1 == y2 of&#xA;                True -&amp;gt;&#xA;                  Just y1&#xA;                False -&amp;gt;&#xA;                  case (# arg1, arg2 #) of&#xA;                    (# _, _ #) -&amp;gt;&#xA;                      Nothing&#xA;            (# _, _ #) -&amp;gt;&#xA;              Nothing&#xA;    (# B x1, B x2 #) -&amp;gt;&#xA;      case x1 == x2 of&#xA;        True -&amp;gt;&#xA;          Just x1&#xA;        False -&amp;gt;&#xA;          case (# arg1, arg2 #) of&#xA;            (# C y1, C y2 #) -&amp;gt;&#xA;              case y1 == y2 of&#xA;                True -&amp;gt;&#xA;                  Just y1&#xA;                False -&amp;gt;&#xA;                  case (# arg1, arg2 #) of&#xA;                    (# _, _ #) -&amp;gt;&#xA;                      Nothing&#xA;            (# _, _ #) -&amp;gt;&#xA;              Nothing&#xA;    (# C x1, C x2 #) -&amp;gt;&#xA;      case x1 == x2 of&#xA;        True -&amp;gt;&#xA;          Just x1&#xA;        False -&amp;gt;&#xA;          case (# arg1, arg2 #) of&#xA;            (# _, _ #) -&amp;gt;&#xA;              Nothing&#xA;    (# _, _ #) -&amp;gt;&#xA;      Nothing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That is signficantly more code. In the worst case, the algorithm that &lt;code&gt;th-desugar&lt;/code&gt; uses for desugaring guards can lead to a quadratic increase in code size. One way to avoid this is avoid having incomplete guards that fall through to later clauses. That is, if you rewrite the original code to this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;f :: T -&amp;gt; T -&amp;gt; Maybe Int&#xA;f (A x1) (A x2)&#xA;  | x1 == x2&#xA;  = Just x1&#xA;  | otherwise&#xA;  = Nothing&#xA;f (B x1) (B x2)&#xA;  | x1 == x2&#xA;  = Just x1&#xA;  | otherwise&#xA;  = Nothing&#xA;f (C x1) (C x2)&#xA;  | x1 == x2&#xA;  = Just x1&#xA;  | otherwise&#xA;  = Nothing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then &lt;code&gt;th-desugar&lt;/code&gt; will desugar it to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;f :: T -&amp;gt; T -&amp;gt; Maybe Int&#xA;f arg1 arg2 =&#xA;  case (# arg1, arg2 #) of&#xA;    (# A x1, A x2 #) -&amp;gt;&#xA;      case x1 == x2 of&#xA;        True -&amp;gt;&#xA;          Just x1&#xA;        False -&amp;gt;&#xA;          Nothing&#xA;    (# B x1, B x2 #) -&amp;gt;&#xA;      case x1 == x2 of&#xA;        True -&amp;gt;&#xA;          Just x1&#xA;        False -&amp;gt;&#xA;          Nothing&#xA;    (# C x1, C x2 #) -&amp;gt;&#xA;      case x1 == x2 of&#xA;        True -&amp;gt;&#xA;          Just x1&#xA;        False -&amp;gt;&#xA;          Nothing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code, while still more verbose than the original, uses a constant amount of extra code per clause.&lt;/p&gt; &#xA;&lt;h3&gt;Desugaring guards can produce more warnings than the original code&lt;/h3&gt; &#xA;&lt;p&gt;The approach that &lt;code&gt;th-desugar&lt;/code&gt; uses to desugar guards can result in code that produces GHC compiler warnings (if &lt;code&gt;-fenable-th-splice-warnings&lt;/code&gt; is enabled) where the original code does not. For example, consider the example from above:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;data T = A Int | B Int | C Int&#xA;&#xA;f :: T -&amp;gt; T -&amp;gt; Maybe Int&#xA;f (A x1) (A x2)&#xA;  | x1 == x2&#xA;  = Just x1&#xA;f (B x1) (B x2)&#xA;  | x1 == x2&#xA;  = Just x1&#xA;f (C x1) (C x2)&#xA;  | x1 == x2&#xA;  = Just x1&#xA;f _ _ = Nothing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code compiles without any GHC warnings. If you desugar this code using &lt;code&gt;th-desugar&lt;/code&gt;, however, it will produce these warnings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;warning: [-Woverlapping-patterns]&#xA;    Pattern match is redundant&#xA;    In a case alternative: (# B y1, B y2 #) -&amp;gt; ...&#xA;   |&#xA;   |             (# B y1, B y2 #) -&amp;gt;&#xA;   |             ^^^^^^^^^^^^^^^^^^^...&#xA;&#xA;warning: [-Woverlapping-patterns]&#xA;    Pattern match is redundant&#xA;    In a case alternative: (# C y1, C y2 #) -&amp;gt; ...&#xA;   |&#xA;   |             (# C y1, C y2 #) -&amp;gt;&#xA;   |             ^^^^^^^^^^^^^^^^^^^...&#xA;&#xA;warning: [-Woverlapping-patterns]&#xA;    Pattern match is redundant&#xA;    In a case alternative: (# C y1, C y2 #) -&amp;gt; ...&#xA;   |&#xA;   |             (# C y1, C y2 #) -&amp;gt;&#xA;   |             ^^^^^^^^^^^^^^^^^^^...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;GHC is correct here: these matches are wholly redundant. &lt;code&gt;th-desugar&lt;/code&gt; could potentially recognize this and perform a more sophisticated analysis to detect and remove such matches when desugaring guards, but it currently doesn&#39;t do such an analysis.&lt;/p&gt; &#xA;&lt;h2&gt;No support for view patterns&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;th-desugar&lt;/code&gt; does not support desugaring view patterns. An alternative to using view patterns in the patterns of a function is to use pattern guards. Currently, there is not a viable workaround for using view patterns in pattern synonym definitions—see &lt;a href=&#34;https://github.com/goldfirere/th-desugar/issues/174&#34;&gt;this &lt;code&gt;th-desugar&lt;/code&gt; issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;No support for or-patterns&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;th-desugar&lt;/code&gt; does not support desugaring &lt;a href=&#34;https://github.com/ghc-proposals/ghc-proposals/raw/c9401f037cb22d1661931b2ec621925101052997/proposals/0522-or-patterns.rst&#34;&gt;or-patterns&lt;/a&gt;. See &lt;a href=&#34;https://github.com/goldfirere/th-desugar/issues/232&#34;&gt;this &lt;code&gt;th-desugar&lt;/code&gt; issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;No support for &lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;th-desugar&lt;/code&gt; does not take the &lt;code&gt;ApplicativeDo&lt;/code&gt; extension into account when desugaring &lt;code&gt;do&lt;/code&gt; notation. For example, if you desugar this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;{-# LANGUAGE ApplicativeDo #-}&#xA;&#xA;f x y = do&#xA;  x&#39; &amp;lt;- x&#xA;  y&#39; &amp;lt;- y&#xA;  return (x&#39; ++ y&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then &lt;code&gt;th-desugar&lt;/code&gt; will translate the uses of &lt;code&gt;&amp;lt;-&lt;/code&gt; in the &lt;code&gt;do&lt;/code&gt; block to uses of &lt;code&gt;Monad&lt;/code&gt; operations (e.g., &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt;) rather than &lt;code&gt;Applicative&lt;/code&gt; operations (e.g., &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt;). See &lt;a href=&#34;https://github.com/goldfirere/th-desugar/issues/138&#34;&gt;this &lt;code&gt;th-desugar&lt;/code&gt; issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;No support for &lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;th-desugar&lt;/code&gt; does not support the &lt;code&gt;RecursiveDo&lt;/code&gt; extension at all, so it cannot desugar any uses of &lt;code&gt;mdo&lt;/code&gt; expressions or &lt;code&gt;rec&lt;/code&gt; statements.&lt;/p&gt; &#xA;&lt;h2&gt;No support for unresolved infix operators&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;th-desugar&lt;/code&gt; does not support desugaring unresolved infix operators, such as &lt;code&gt;UInfixE&lt;/code&gt;. You are unlikely to encounter this limitation when dealing with Template Haskell quotes, since quoted infix operators will translate to uses of &lt;code&gt;InfixE&lt;/code&gt; rather than &lt;code&gt;UInfixE&lt;/code&gt;. Rather, this limitation would only be encountered if you manually construct a Template Haskell &lt;code&gt;Exp&lt;/code&gt; using &lt;code&gt;UInfixE&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>