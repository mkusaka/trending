<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-07-27T01:43:16Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mtolly/onyx</title>
    <updated>2025-07-27T01:43:16Z</updated>
    <id>tag:github.com,2025-07-27:/mtolly/onyx</id>
    <link href="https://github.com/mtolly/onyx" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Toolkit for converting and building songs for Rock Band, Guitar Hero, Clone Hero, and other similar rhythm games&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Onyx Music Game Toolkit&lt;/h1&gt; &#xA;&lt;p&gt;I transcribe songs for use in Harmonix&#39;s &lt;em&gt;Rock Band 3&lt;/em&gt; and other similar rhythm games. Along the way, I&#39;ve written a helpful program to streamline the build process, and do all sorts of useful conversions and transformations.&lt;/p&gt; &#xA;&lt;p&gt;Download from the &lt;a href=&#34;https://github.com/mtolly/onyx/releases&#34;&gt;releases page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mtolly/onyx/master/haskell/screenshot.png&#34; alt=&#34;Screenshot of Onyx&#39;s song preview tool&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Onyxite&#39;s Custom Songs&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains the &#34;source&#34; for charts which (once finished) are available from &lt;a href=&#34;http://customscreators.com/index.php?/topic/14398-onyxites-customs/&#34;&gt;my thread on the Customs Creators forum&lt;/a&gt;, or from &lt;a href=&#34;https://onyxite.org/customs/&#34;&gt;my own website&lt;/a&gt; (work in progress).&lt;/p&gt; &#xA;&lt;h2&gt;Licensing&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://creativecommons.org/licenses/by-sa/4.0/&#34;&gt;&lt;img src=&#34;https://i.creativecommons.org/l/by-sa/4.0/88x31.png&#34; alt=&#34;Creative Commons License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.gnu.org/licenses/gpl.html&#34;&gt;&lt;img src=&#34;https://www.gnu.org/graphics/gplv3-88x31.png&#34; alt=&#34;GNU GPL License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The Onyx software is free software via the &lt;a href=&#34;https://www.gnu.org/licenses/gpl.html&#34;&gt;GNU GPL v3&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;My transcriptions (&lt;em&gt;not&lt;/em&gt; the compositions) are freely licensed under &lt;a href=&#34;http://creativecommons.org/licenses/by-sa/4.0/&#34;&gt;Creative Commons Attribution-ShareAlike&lt;/a&gt;. All compositions are the property of the original artists.&lt;/p&gt; &#xA;&lt;p&gt;In addition to my own charts, this repository contains work by several other authors, including: Harmonix, &lt;a href=&#34;https://www.youtube.com/user/SHGrinnz&#34;&gt;Grinnz&lt;/a&gt;, &lt;a href=&#34;http://pksage.com/ccc/IPS/index.php?/topic/13775-mazegeeks-customs-1117-tarkus-by-emerson-lake-palmer/&#34;&gt;mazegeek999&lt;/a&gt;, &lt;a href=&#34;http://www.fretsonfire.net/forums/viewtopic.php?f=5&amp;amp;t=45301&#34;&gt;TheLieInKing&lt;/a&gt;, and more. (Credited in individual song READMEs.) Other authors&#39; work hosted here is &lt;em&gt;not&lt;/em&gt; necessarily licensed in the same way; please contact them if you want permission to redistribute or repackage charts.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>haskell/vector</title>
    <updated>2025-07-27T01:43:16Z</updated>
    <id>tag:github.com,2025-07-27:/haskell/vector</id>
    <link href="https://github.com/haskell/vector" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An efficient implementation of Int-indexed arrays (both mutable and immutable), with a powerful loop optimisation framework .&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The &lt;code&gt;vector&lt;/code&gt; package &lt;a href=&#34;https://github.com/haskell/vector/actions?query=branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/haskell/vector/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Vector is a collection of efficient &lt;code&gt;Int&lt;/code&gt;-indexed array implementations: &lt;a href=&#34;https://raw.githubusercontent.com/haskell/vector/master/#vectors-available-in-the-package&#34;&gt;boxed, unboxed, storable, and primitive vectors&lt;/a&gt; (all can be mutable or immutable). The package features a generic API, polymorphic in vector type, and implements &lt;a href=&#34;https://raw.githubusercontent.com/haskell/vector/master/#stream-fusion&#34;&gt;&lt;em&gt;stream fusion&lt;/em&gt;&lt;/a&gt;, a powerful optimisation framework that can help eliminate intermediate data structures.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;!-- no toc --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/vector/master/#tutorial&#34;&gt;Tutorial&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/vector/master/#vector-vs-array&#34;&gt;Vector vs Array&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/vector/master/#vectors-available-in-the-package&#34;&gt;Vectors Available in the Package&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/vector/master/#stream-fusion&#34;&gt;Stream Fusion&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Tutorial&lt;/h2&gt; &#xA;&lt;p&gt;A beginner-friendly tutorial for vectors can be found on &lt;a href=&#34;https://mmhaskell.com/data-structures/vector&#34;&gt;MMHaskell&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you have already started your adventure with vectors, the tutorial on &lt;a href=&#34;https://wiki.haskell.org/Numeric_Haskell:_A_Vector_Tutorial&#34;&gt;Haskell Wiki&lt;/a&gt; covers more ground.&lt;/p&gt; &#xA;&lt;h2&gt;Vector vs Array&lt;/h2&gt; &#xA;&lt;p&gt;Arrays are data structures that can store a multitude of elements and allow immediate access to every one of them. However, they are often seen as legacy constructs that are rarely used in modern Haskell. Even though Haskell has a built-in &lt;a href=&#34;https://hackage.haskell.org/package/array-0.5.7.0&#34;&gt;Data.Array module&lt;/a&gt;, arrays might be a bit overwhelming to use due to their complex API. Conversely, vectors incorporate the array’s &lt;em&gt;O(1)&lt;/em&gt; access to elements with a much friendlier API of lists. Since they allow for framework optimisation via loop fusion, vectors emphasise efficiency and keep a rich interface. Unless you’re confident with arrays, it’s well-advised to use vectors when looking for a similar functionality.&lt;/p&gt; &#xA;&lt;h2&gt;Vectors Available in the Package&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lazy boxed vectors&lt;/strong&gt; (&lt;code&gt;Data.Vector&lt;/code&gt;) store each of their elements as a pointer to a heap-allocated value. Because of indirection, lazy boxed vectors are slower in comparison to unboxed vectors.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Strict boxed vectors&lt;/strong&gt; (&lt;code&gt;Data.Vector.Strict&lt;/code&gt;) contain elements that are &lt;a href=&#34;https://tech.fpcomplete.com/haskell/tutorial/all-about-strictness/&#34;&gt;strictly evaluated&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Unboxed vectors&lt;/strong&gt; (&lt;code&gt;Data.Vector.Unboxed&lt;/code&gt;) determine an array&#39;s representation from its elements&#39; type. For example, vector of primitive types (e.g. &lt;code&gt;Int&lt;/code&gt;) will be backed by primitive array while vector of product types by structure of arrays. They are quite efficient due to the unboxed representation they use.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Storable vectors&lt;/strong&gt; (&lt;code&gt;Data.Vector.Storable&lt;/code&gt;) are backed by pinned memory, i.e., they cannot be moved by the garbage collector. Their primary use case is C FFI.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Primitive vectors&lt;/strong&gt; (&lt;code&gt;Data.Vector.Primitive&lt;/code&gt;) are backed by simple byte array and can store only data types that are represented in memory as a sequence of bytes without a pointer, i.e., they belong to the &lt;code&gt;Prim&lt;/code&gt; type class, e.g., &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, etc. It&#39;s advised to use unboxed vectors if you&#39;re looking for the performance of primitive vectors, but more versality.&lt;/p&gt; &#xA;&lt;h2&gt;Stream Fusion&lt;/h2&gt; &#xA;&lt;p&gt;An optimisation framework used by vectors, stream fusion is a technique that merges several functions into one and prevents creation of intermediate data structures. For example, the expression &lt;code&gt;sum . filter g . map f&lt;/code&gt; won&#39;t allocate temporary vectors if compiled with optimisations.&lt;/p&gt;</summary>
  </entry>
</feed>