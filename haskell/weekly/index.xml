<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-13T01:45:58Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Quid2/flat</title>
    <updated>2022-11-13T01:45:58Z</updated>
    <id>tag:github.com,2022-11-13:/Quid2/flat</id>
    <link href="https://github.com/Quid2/flat" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Principled and efficient binary serialization&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/Quid2/flat/actions/workflows/haskell-ci.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://hackage.haskell.org/package/flat&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/flat.svg?sanitize=true&#34; alt=&#34;Hackage version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://stackage.org/lts/package/flat&#34;&gt;&lt;img src=&#34;http://stackage.org/package/flat/badge/lts-16&#34; alt=&#34;Stackage LTS 16&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stackage.org/lts/package/flat&#34;&gt;&lt;img src=&#34;http://stackage.org/package/flat/badge/lts-18&#34; alt=&#34;Stackage LTS 18&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stackage.org/lts/package/flat&#34;&gt;&lt;img src=&#34;http://stackage.org/package/flat/badge/lts-19&#34; alt=&#34;Stackage LTS 19&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stackage.org/nightly/package/flat&#34;&gt;&lt;img src=&#34;http://stackage.org/package/flat/badge/nightly&#34; alt=&#34;Stackage Nightly&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Haskell implementation of &lt;a href=&#34;http://quid2.org/docs/Flat.pdf&#34;&gt;Flat&lt;/a&gt;, a principled, portable and compact binary data format (&lt;a href=&#34;http://quid2.org&#34;&gt;specs&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;How To Use It For Fun and Profit&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Flat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Direction = North | South | Center | East | West deriving (Show,Generic,Flat)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;strong&gt;flat&lt;/strong&gt; to encode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;flat [North,South]&#xA;-&amp;gt; &#34;\149&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and &lt;strong&gt;unflat&lt;/strong&gt; to decode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;unflat (flat [North,South]) :: Decoded [Direction]&#xA;-&amp;gt; Right [ North , South ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And thanks to Flat&#39;s bit-encoding, this list fits in 1 byte (rather than the 5 bytes that would be required by a traditional byte encoding):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;flatBits [North,South]&#xA;-&amp;gt; &#34;10010101&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Performance&lt;/h3&gt; &#xA;&lt;p&gt;For some hard data, see this &lt;a href=&#34;https://github.com/haskell-perf/serialization&#34;&gt;comparison of the major haskell serialisation libraries&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Briefly:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Size: &lt;code&gt;flat&lt;/code&gt; produces significantly smaller binaries than all other libraries (3/4 times usually)&lt;/li&gt; &#xA; &lt;li&gt;Serialization time: &lt;code&gt;store&lt;/code&gt;, &lt;code&gt;persist&lt;/code&gt; and &lt;code&gt;flat&lt;/code&gt; are faster&lt;/li&gt; &#xA; &lt;li&gt;Deserialization time: &lt;code&gt;store&lt;/code&gt;, &lt;code&gt;flat&lt;/code&gt;, &lt;code&gt;persist&lt;/code&gt; and &lt;code&gt;cereal&lt;/code&gt; are faster&lt;/li&gt; &#xA; &lt;li&gt;Transfer time (serialisation time + transport time on the network + deserialisation at the receiving end): &lt;code&gt;flat&lt;/code&gt; is usually faster for all but the highest network speeds&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Documentation&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://hackage.haskell.org/package/flat/docs/Flat-Tutorial.html&#34;&gt;Tutorial&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://hackage.haskell.org/package/flat&#34;&gt;Hackage Package and Docs&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://quid2.org/docs/Flat.pdf&#34;&gt;Flat Format Specification&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Get the latest stable version from &lt;a href=&#34;https://hackage.haskell.org/package/flat&#34;&gt;hackage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Compatibility&lt;/h3&gt; &#xA;&lt;p&gt;Tested with:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.haskell.org/ghc/&#34;&gt;GHC&lt;/a&gt; 7.10.3 to 9.4.3 (x64)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/ghcjs/ghcjs&#34;&gt;GHCJS&lt;/a&gt; version 8.6.0.1 (GHC 8.6.2)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Known Bugs and Infelicities&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Data types with more than 512 constructors are currently unsupported (but support could be easily added if necessary)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Longish compilation times&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;To improve performance, &lt;code&gt;flat&lt;/code&gt; relies on extensive inlining. This unfortunately leads to longer compilation times.&lt;/p&gt; &lt;p&gt;If you have many data types or very large ones, you might want to:&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt; &lt;p&gt;During development, turn optimisations off (&lt;code&gt;stack --fast&lt;/code&gt; or &lt;code&gt;-O0&lt;/code&gt; in the cabal file).&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;Keep your serialisation code in separate modules.&lt;/p&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;See also the &lt;a href=&#34;https://github.com/Quid2/flat/issues&#34;&gt;full list of open issues&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Ports for other languages&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt; and &lt;a href=&#34;https://github.com/Quid2/ts&#34;&gt;TypeScript-JavaScript&lt;/a&gt; ports are under development.&lt;/p&gt; &#xA;&lt;p&gt;Get in touch if you would like to help porting &lt;code&gt;flat&lt;/code&gt; to other languages.&lt;/p&gt; &#xA;&lt;h3&gt;Acknowledgements&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;flat&lt;/code&gt; reuses ideas and readapts code from various packages, mainly: &lt;code&gt;store&lt;/code&gt;, &lt;code&gt;binary-bits&lt;/code&gt; and &lt;code&gt;binary&lt;/code&gt; and includes bug fixes from a number of contributors.&lt;/p&gt; &#xA;&lt;h3&gt;Other Stuff You Might Like&lt;/h3&gt; &#xA;&lt;p&gt;To decode &lt;code&gt;flat&lt;/code&gt; encoded data you need to know the type of the serialised data.&lt;/p&gt; &#xA;&lt;p&gt;This is ok for applications that do not require long-term storage and that do not operate in open distributed systems.&lt;/p&gt; &#xA;&lt;p&gt;For those who do, you might want to supplement &lt;code&gt;flat&lt;/code&gt; with &lt;a href=&#34;https://github.com/Quid2/zm&#34;&gt;ZM - Language independent, reproducible, absolute types&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>gurglien/functional-programming</title>
    <updated>2022-11-13T01:45:58Z</updated>
    <id>tag:github.com,2022-11-13:/gurglien/functional-programming</id>
    <link href="https://github.com/gurglien/functional-programming" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>diagrams/diagrams-core</title>
    <updated>2022-11-13T01:45:58Z</updated>
    <id>tag:github.com,2022-11-13:/diagrams/diagrams-core</id>
    <link href="https://github.com/diagrams/diagrams-core" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Core types and utilities&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;http://travis-ci.org/diagrams/diagrams-core&#34;&gt;&lt;img src=&#34;https://travis-ci.org/diagrams/diagrams-core.png?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The core modules defining the basic data structures and algorithms for &lt;a href=&#34;http://projects.haskell.org/diagrams&#34;&gt;diagrams&lt;/a&gt;, a Haskell embedded domain-specific language for compositional, declarative drawing.&lt;/p&gt;</summary>
  </entry>
</feed>