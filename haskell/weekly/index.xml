<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-24T01:51:49Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>marvinborner/birb</title>
    <updated>2023-09-24T01:51:49Z</updated>
    <id>tag:github.com,2023-09-24:/marvinborner/birb</id>
    <link href="https://github.com/marvinborner/birb" rel="alternate"></link>
    <summary type="html">&lt;p&gt;🐦 Programming language that only consists of bird emojis&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Birb&lt;/h1&gt; &#xA;&lt;p&gt;Birb is an &lt;em&gt;advanced&lt;/em&gt; programming language that only consists of bird emojis 🐣. Each emoji gets substituted by a &lt;a href=&#34;https://www.angelfire.com/tx4/cus/combinator/birds.html&#34;&gt;&lt;em&gt;combinator bird&lt;/em&gt;&lt;/a&gt; of pure lambda calculus.&lt;/p&gt; &#xA;&lt;h2&gt;Birbs&lt;/h2&gt; &#xA;&lt;p&gt;Unfortunately, the Unicode standard does not yet have many (single-character) birds. These are the ones currently mapped/supported:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;emoji&lt;/th&gt; &#xA;   &lt;th&gt;animal&lt;/th&gt; &#xA;   &lt;th&gt;combinator&lt;/th&gt; &#xA;   &lt;th&gt;term&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🦉&lt;/td&gt; &#xA;   &lt;td&gt;owl&lt;/td&gt; &#xA;   &lt;td&gt;owl&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda ab.b(ab)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🦅&lt;/td&gt; &#xA;   &lt;td&gt;eagle&lt;/td&gt; &#xA;   &lt;td&gt;eagle&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda abcde.ab(cde)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🪽&lt;/td&gt; &#xA;   &lt;td&gt;wing&lt;/td&gt; &#xA;   &lt;td&gt;phoenix&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda abcd.a(bd)(cd)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🕊️&lt;/td&gt; &#xA;   &lt;td&gt;dove&lt;/td&gt; &#xA;   &lt;td&gt;dove&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda abcd.ab(cd)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🦜&lt;/td&gt; &#xA;   &lt;td&gt;parrot&lt;/td&gt; &#xA;   &lt;td&gt;mockingbird&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda a.aa$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🦆&lt;/td&gt; &#xA;   &lt;td&gt;duck&lt;/td&gt; &#xA;   &lt;td&gt;quacky&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda abc.c(ba)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🐤&lt;/td&gt; &#xA;   &lt;td&gt;touring chick&lt;/td&gt; &#xA;   &lt;td&gt;turing&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda ab.b(aab)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🐥&lt;/td&gt; &#xA;   &lt;td&gt;kool chick&lt;/td&gt; &#xA;   &lt;td&gt;kestrel&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda ab.a$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🐣&lt;/td&gt; &#xA;   &lt;td&gt;hatching chick&lt;/td&gt; &#xA;   &lt;td&gt;quirky&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda abc.c(ab)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🐦&lt;/td&gt; &#xA;   &lt;td&gt;simple bird&lt;/td&gt; &#xA;   &lt;td&gt;identity&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda a.a$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🦚&lt;/td&gt; &#xA;   &lt;td&gt;peacock&lt;/td&gt; &#xA;   &lt;td&gt;queer&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda abc.b(ac)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🦤&lt;/td&gt; &#xA;   &lt;td&gt;dodo&lt;/td&gt; &#xA;   &lt;td&gt;sage&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda ab.a(bb)\lambda ab.a(bb)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🐧&lt;/td&gt; &#xA;   &lt;td&gt;penguin&lt;/td&gt; &#xA;   &lt;td&gt;blackbird&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda abc.a(bc)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🦢&lt;/td&gt; &#xA;   &lt;td&gt;swan&lt;/td&gt; &#xA;   &lt;td&gt;substitution&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda abc.ac(bc)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;🦩&lt;/td&gt; &#xA;   &lt;td&gt;flamingo&lt;/td&gt; &#xA;   &lt;td&gt;cardinal&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda abc.acb$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Lonely/unmatched birbs: 🐔🦃🐓🪿&lt;/p&gt; &#xA;&lt;h1&gt;Syntax&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;[birb]+&lt;/code&gt;: Birb&lt;/li&gt; &#xA; &lt;li&gt;everything else: Comment&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Syntax errors are impossible as long as you use at least one birb.&lt;/p&gt; &#xA;&lt;h1&gt;Semantics&lt;/h1&gt; &#xA;&lt;p&gt;Birbs stagger as they walk: they are reduced in alternating associative order, starting with left associativity at birb index $\lfloor\frac{\texttt{len}}{2}\rfloor$:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;🐦🐦 -&amp;gt; (🐦🐦)&#xA;🐦🐦🐦 -&amp;gt; ((🐦🐦)🐦)&#xA;🐦🐦🐦🐦 -&amp;gt; (🐦((🐦🐦)🐦))&#xA;🐦🐦🐦🐦🐦 -&amp;gt; ((🐦((🐦🐦)🐦))🐦)&#xA;🐦🐦🐦🐦🐦🐦 -&amp;gt; (🐦((🐦((🐦🐦)🐦))🐦))&#xA;🐦🐦🐦🐦🐦🐦🐦 -&amp;gt; ((🐦((🐦((🐦🐦)🐦))🐦))🐦)&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;p&gt;You can find more examples (with comments) in the &lt;code&gt;samples/&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Relationships&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;🪽🐦 $\rightsquigarrow$ 🦢&lt;/li&gt; &#xA; &lt;li&gt;🦢🐦 $\rightsquigarrow$ 🦉&lt;/li&gt; &#xA; &lt;li&gt;🦉🐦 $\rightsquigarrow$ 🦜&lt;/li&gt; &#xA; &lt;li&gt;🕊️🐦 $\rightsquigarrow$ 🐧&lt;/li&gt; &#xA; &lt;li&gt;🐧🐧 $\rightsquigarrow$ 🕊️&lt;/li&gt; &#xA; &lt;li&gt;🦩🐧 $\rightsquigarrow$ 🦚&lt;/li&gt; &#xA; &lt;li&gt;🦩🦚 $\rightsquigarrow$ 🐧&lt;/li&gt; &#xA; &lt;li&gt;🦩🦆 $\rightsquigarrow$ 🐣&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;One can only imagine what happens if two parrots talk to each other: 🦜🦜 $\rightsquigarrow$ 💥. The same happens with 🐤🐤; they just can’t stop waddling!&lt;/p&gt; &#xA;&lt;h2&gt;Arithmetic&lt;/h2&gt; &#xA;&lt;p&gt;For this example I use the Church numerals. Zero would then be encoded as 🐥🐦. The successor function can be written as 🦢🐧:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;🐦🐧🐦🦢🐧🐥🐦 $\rightsquigarrow\lambda\lambda(10)$ – (Church numeral 1)&lt;/li&gt; &#xA; &lt;li&gt;🐦🐧🐦🐧🕊️🦢🐧🦢🐧🐥🐦 $\rightsquigarrow\lambda\lambda(1(10))$ – (Church numeral 2)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Similarly, one can very obviously translate the Church addition function to 🪽🐧. Now, to calculate $1+2$ based on their increments from zero:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;🐦🐦🕊️🐧🕊️🐧🐦🐧🕊️🐧🕊️🪽🐧🦢🐧🦢🐧🐥🐦🦢🐧🐥🐦 $\rightsquigarrow\lambda\lambda(1(1(10)))$ – (Church numeral 3)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also: 🐧 is $a\cdot b$, 🦜 is $n^n$ and 🦚🐦 $a^b$.&lt;/p&gt; &#xA;&lt;p&gt;Note that there exist many alternative ways to do arithmetic. Try writing the functions above with other birbs!&lt;/p&gt; &#xA;&lt;h2&gt;Containers&lt;/h2&gt; &#xA;&lt;p&gt;You can create a pair $\langle X,Y\rangle$ using &lt;code&gt;🦩🦩🦩YX&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Typically, one would now construct a list using repeated application of pairs (Boehm-Berarducci/Church encoding). However, due to the reversed application and alternating associativity, the Mogensen-Scott encoding is more suitable:&lt;/p&gt; &#xA;&lt;p&gt;List $\langle X_1,X_2,\dots,X_n\rangle$: &lt;code&gt;[🦩]ⁿ🦩X2X1...XN&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Busy &lt;del&gt;beavers&lt;/del&gt; birbs&lt;/h2&gt; &#xA;&lt;p&gt;Contestants:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;The touring eagle&lt;/em&gt;: &lt;code&gt;[🐦]ⁿ[🦅🐤]ⁿ&lt;/code&gt; ($n=3$: 9 birbs, ~20M BLC bits)&lt;/li&gt; &#xA; &lt;li&gt;better? PR!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Transpiler&lt;/h1&gt; &#xA;&lt;p&gt;I created a lambda calculus to Birb transpiler. It works by converting binary lambda calculus to SKI combinators, which then get converted to Jot and back to SKI combinators. The resulting SKI combinators then get converted to Birbs.&lt;/p&gt; &#xA;&lt;p&gt;The reason I convert to Jot first is that Birbs semantics don’t allow trivial transpilation from arbitrary SKI expressions. With Jot however, applications with non-associative expressions like &lt;code&gt;((s k) (k s))&lt;/code&gt; are impossible, as only a single non-associative application exists (the innermost/deepest expression).&lt;/p&gt; &#xA;&lt;p&gt;With all these conversions, the resulting transpiled Birb code is big, ugly and slow. There should be a way to optimize the transpilation process, but it’s probably a bit more complicated.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://docs.haskellstack.org/en/stable/install_and_upgrade/&#34;&gt;Haskell’s stack&lt;/a&gt;. Then,&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;stack run -- reduce file.birb&lt;/code&gt; or &lt;code&gt;stack run -- reduce &amp;lt;(echo 🐧🐧)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;stack run -- transpile &amp;lt;(echo 01000110100000011100111001110011100111010)&lt;/code&gt; to generate a birb program that calculates $5^5$&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;stack install&lt;/code&gt; so you can enjoy &lt;code&gt;birb&lt;/code&gt; from anywhere&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If the output cannot be translated to birbs, the raw lambda calculus term (with De Bruijn indices) is printed. For the examples above I sometimes manually converted the term back to birbs.&lt;/p&gt; &#xA;&lt;h1&gt;Turing-completeness&lt;/h1&gt; &#xA;&lt;p&gt;Birb is Turing complete, since one can construct any term of the &lt;a href=&#34;https://esolangs.org/wiki/Jot&#34;&gt;Jot&lt;/a&gt; variant of Iota. A Jot term &lt;code&gt;((X s) k)&lt;/code&gt; is equivalent to &lt;code&gt;🐦🐦X🦢🐥&lt;/code&gt;. Similarly, &lt;code&gt;(s (k X))&lt;/code&gt; is equivalent to &lt;code&gt;🐦🦆X🐥🦢&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;The idea of the language was originally proposed in 2021 by @SCKelement on &lt;a href=&#34;https://esolangs.org/wiki/Birb&#34;&gt;Esolang&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>joeyadams/haskell-stm-delay</title>
    <updated>2023-09-24T01:51:49Z</updated>
    <id>tag:github.com,2023-09-24:/joeyadams/haskell-stm-delay</id>
    <link href="https://github.com/joeyadams/haskell-stm-delay" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Updatable one-shot timer polled with STM (Haskell)&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>DKISTDC/level2</title>
    <updated>2023-09-24T01:51:49Z</updated>
    <id>tag:github.com,2023-09-24:/DKISTDC/level2</id>
    <link href="https://github.com/DKISTDC/level2" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Level 2 Data Processing&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Level 2 Inversion&lt;/h1&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/DKISTDC/level2/main/DEVELOPMENT.md&#34;&gt;DEVELOPMENT.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Questions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; (Tony) We need local persistence but a new DB may increase the workload for Tony. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;adding fields to existing tables creates an unwanted dependency and slows dev&lt;/li&gt; &#xA;   &lt;li&gt;same physical postgres instance with different tables? (Prefix?)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Who chooses which OP to process next? &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;do we mark A as &#34;work on this next?&#34;&lt;/li&gt; &#xA;   &lt;li&gt;or does Han scan available work and choose?&lt;/li&gt; &#xA;   &lt;li&gt;who gets yelled at if something doesn&#39;t get done?&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Answers&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Han wants to work on OPs, not datasets. How do we know when an OP is complete? &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;OPs do not exist at the metadata level yet&lt;/li&gt; &#xA;   &lt;li&gt;Wait a certain number of days for all datasets to appear before assuming it is ready.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; How does L2 data become available to the system? &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;L2 will store OP metadata related to inversions&lt;/li&gt; &#xA;   &lt;li&gt;Metadata store will aggregate this information and introduce an OP schema&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Service Graph&lt;/h2&gt; &#xA;&lt;p&gt;Arrow indicate the direction of dependency. If A -&amp;gt; B, then A is aware of B and calls it or interacts with it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;&#xA;    L2[Level 2]&#xA;    State[(Internal State)]&#xA;    Meta[Metadata Store]&#xA;    Globus[GLOBUS]&#xA;    Sci[Science / CU Blanca]&#xA;&#xA;    subgraph Level 2&#xA;      L2&#xA;      L2 --&amp;gt; State&#xA;      State&#xA;      Sci --&amp;gt; |OPs| L2&#xA;      Sci --&amp;gt; |ready event| L2&#xA;    end&#xA;&#xA;    Meta --&amp;gt; |OPs| L2&#xA;    Portal --&amp;gt; Meta&#xA;    L2 --&amp;gt; |datasets| Meta&#xA;    Meta --&amp;gt; Globus&#xA;    Sci --&amp;gt; |dataset files| Globus&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Deployable Containers&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;L2 Service&lt;/li&gt; &#xA; &lt;li&gt;State Postgres DB - New or existing instance, but L2 accesses unique tables&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Process&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR;&#xA;    Scan[[Scan]]&#xA;    Qualify[[Qualify]]&#xA;    Preprocess[[Preprocess]]&#xA;    Invert[[Invert]]&#xA;    Publish[[Publish]]&#xA;&#xA;    Scan --&amp;gt; Qualify&#xA;    Qualify --&amp;gt; Preprocess&#xA;    Preprocess --&amp;gt; Invert&#xA;    subgraph Science&#xA;      Invert&#xA;    end&#xA;    Invert --&amp;gt; Publish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Scan&lt;/em&gt; - Check the entire metadata store for OP candidates and add to the database if they don&#39;t exist. Update if necessary&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DKISTDC/level2/main/docs/Invertibility.md&#34;&gt;&lt;em&gt;Qualify&lt;/em&gt;&lt;/a&gt; - Check criteria for invertibility and record if OPs are invertible or not&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Preprocess&lt;/em&gt; - Preprocess data if necessary, saving intermediate files if needed (unknown)&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Invert&lt;/em&gt; - Han&#39;s Science Team manually inverts the OP&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Publish&lt;/em&gt; - Make L2 data available to metadata store / portal&lt;/p&gt; &#xA;&lt;h2&gt;Inversion States&lt;/h2&gt; &#xA;&lt;p&gt;Observing Programs are identified, then pass through the following states. The graph below illustrates a successful flow, but any processing step may fail, putting the OP into an Error state.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;stateDiagram-v2&#xA;    dis: Discovered&#xA;    inv: Invertible&#xA;    no: Not Invertible&#xA;    pre: Preprocessed&#xA;    work: Working&#xA;    done: Inverted&#xA;    pub: Published&#xA;    err: Error&#xA;&#xA;    dis --&amp;gt; inv&#xA;    dis --&amp;gt; no&#xA;    inv --&amp;gt; pre&#xA;    pre --&amp;gt; work&#xA;    work --&amp;gt; done: Science&#xA;    done --&amp;gt; pub&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We record this history of all states, and only add information rather than mutating the record&lt;/p&gt; &#xA;&lt;h2&gt;Definitions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Observing Program&lt;/strong&gt; - a group of datasets related to a single observation with a measurement in mind, which is a smaller division of a proposal&lt;/p&gt;</summary>
  </entry>
</feed>