<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-03T01:50:04Z</updated>
  <subtitle>Weekly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mlabs-haskell/lambda-buffers</title>
    <updated>2023-12-03T01:50:04Z</updated>
    <id>tag:github.com,2023-12-03:/mlabs-haskell/lambda-buffers</id>
    <link href="https://github.com/mlabs-haskell/lambda-buffers" rel="alternate"></link>
    <summary type="html">&lt;p&gt;LambdaBuffers toolkit for sharing types and their semantics between different languages&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Lambda Buffers&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mlabs-haskell/lambda-buffers/main/docs/images/lambda-buffers-banner.png&#34; alt=&#34;LambdaBuffers banner&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;LambdaBuffers&lt;/em&gt; is a schema language (similar to ProtoBuffers, ADL, ASN.1, JSON Schema, etc.) and associated code generation toolkit. The goal of this project is to provide developers tools to define algebraic data types in a language-agnostic format such that shared data types can be declared in one place while maintaining compatibility across a plethora of supported languages.&lt;/p&gt; &#xA;&lt;p&gt;Users may refer to the &lt;a href=&#34;https://raw.githubusercontent.com/mlabs-haskell/lambda-buffers/main/docs/comparison-matrix.md&#34;&gt;comparison matrix&lt;/a&gt; for an in-depth comparison of LambdaBuffers&#39; features against the feature-set of other popular schema-languages.&lt;/p&gt; &#xA;&lt;p&gt;At a glance, you may wish to choose LambdaBuffers instead of one of its competitors if your project requires:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Parameterized Data Types&lt;/em&gt; (aka. type functions): Unlike ProtoBuffers or JSON Schema, LambdaBuffers allows users to define algebraic data types which take type variable arguments. If your project&#39;s domain is most accurately represented by parameterized data types, LamdaBuffers may be a good choice for your needs.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Opaque Types&lt;/em&gt;: Almost every competing schema language provides users a fixed set of builtin or primitive types, which are handled in a special manner by the code generation and cannot be extended. LambdaBuffers, by contrast, allows users to add their own builtin types and extend the existing code generation framework to handle those builtins in a manner intended by the users. There are no &lt;em&gt;special&lt;/em&gt; primitive types in LambdaBuffers; a user-defined primitive type is defined in exactly the same way (i.e. as an &lt;code&gt;opaque&lt;/code&gt; type) as a LambdaBuffers &#34;builtin&#34;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Typeclass Support&lt;/em&gt;: While nearly every schema language supports generating type definitions in supported target languages, to our knowledge no schema language supports generating commonly used functions that operate on those types. Unlike other schema languages, LambdaBuffers supports code generation for &lt;em&gt;typeclass instances&lt;/em&gt; (or the equivalent in languages that lack support for typeclasses) to reduce the amount of boilerplate required to productively make use of the generated types. While LambdaBuffers is still a work-in-progress, we expect that, upon completion, an extensive test suite will provide a high degree of assurance that the instances/methods generated by the LamdaBuffers code generator behave identically.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Visit &lt;a href=&#34;https://mlabs-haskell.github.io/lambda-buffers&#34;&gt;LambdaBuffers Github Pages&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;This project was graciously funded by the Cardano Treasury in &lt;a href=&#34;https://cardano.ideascale.com/c/idea/421376&#34;&gt;Catalyst Fund 9&lt;/a&gt; and &lt;a href=&#34;https://cardano.ideascale.com/c/idea/105975&#34;&gt;Catalyst Fund 10&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Authors:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bladyjoker&#34;&gt;Drazen Popovic&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cstml&#34;&gt;Vlad Posmangiu Luchian&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/gnumonik&#34;&gt;Sean Hunter&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Contributors:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/GeorgeFlerovsky&#34;&gt;George Flerovsky&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/aciceri&#34;&gt;Andrea Ciceri&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://juliachatain.com&#34;&gt;Julia Chatain&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/saizan&#34;&gt;Andrea Vezzosi&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/MangoIV&#34;&gt;Magnus Viernickel&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/TotallyNotChase&#34;&gt;Rajdeep Chase Maity&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rmgaray&#34;&gt;Ramiro Garay&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>t0rrant/xmonad-config</title>
    <updated>2023-12-03T01:50:04Z</updated>
    <id>tag:github.com,2023-12-03:/t0rrant/xmonad-config</id>
    <link href="https://github.com/t0rrant/xmonad-config" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Common base to replicate in all of my machines.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;xmonad-config&lt;/h1&gt; &#xA;&lt;p&gt;Common base to replicate in all of my machines.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>TristanAllwood/lazyCrossCheck</title>
    <updated>2023-12-03T01:50:04Z</updated>
    <id>tag:github.com,2023-12-03:/TristanAllwood/lazyCrossCheck</id>
    <link href="https://github.com/TristanAllwood/lazyCrossCheck" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Model vs Student Haskell exercise crosschecking library (prototype)&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;LazyCrossCheck&lt;/h2&gt; &#xA;&lt;p&gt;A small, work in progress cross-checking library, for use in programming exercises to check student solutions against a model answer.&lt;/p&gt; &#xA;&lt;p&gt;Based on the ideas drawn out of Irulan[1], which was inspired by SmallCheck/LazySmallCheck[2].&lt;/p&gt; &#xA;&lt;p&gt;Have a look at Tester.hs for an example of usage. Sample output:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;runghc Tester.hs&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;version (Just undefined): student&#39;s answer is more general. student answer = 2 model answers: version (Just 1) = 1 version (Just 2) = 2 version (Just 3) = 3&lt;/p&gt; &#xA;&lt;p&gt;[1] &lt;a href=&#34;http://www.doc.ic.ac.uk/~tora/irulan/&#34;&gt;http://www.doc.ic.ac.uk/~tora/irulan/&lt;/a&gt; [2] &lt;a href=&#34;http://www.cs.york.ac.uk/fp/smallcheck/&#34;&gt;http://www.cs.york.ac.uk/fp/smallcheck/&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>