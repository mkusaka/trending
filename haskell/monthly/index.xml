<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-01T01:58:43Z</updated>
  <subtitle>Monthly Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>haskell/haskell-language-server</title>
    <updated>2022-10-01T01:58:43Z</updated>
    <id>tag:github.com,2022-10-01:/haskell/haskell-language-server</id>
    <link href="https://github.com/haskell/haskell-language-server" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Official haskell ide support via language server (LSP). Successor of ghcide &amp; haskell-ide-engine.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;haskell-language-server&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/haskell/haskell-language-server/master/docs/logos/logo-256.png&#34; alt=&#34;haskell-language-server&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/haskell/haskell-language-server/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/haskell/haskell-language-server.svg?sanitize=true&#34; alt=&#34;Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/haskell-language-server&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/haskell-language-server.svg?logo=haskell&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/haskell/haskell-language-server/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-Apache2-green.svg?dummy&#34; alt=&#34;License Apache 2.0&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/haskell/haskell-language-server/&#34;&gt;&lt;img src=&#34;https://img.shields.io/circleci/project/github/haskell/haskell-language-server/master.svg?sanitize=true&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/haskell/haskell-language-server/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/haskell/haskell-language-server/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;GitHub Testing Workflow&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/haskell/haskell-language-server/actions/workflows/nix.yml&#34;&gt;&lt;img src=&#34;https://github.com/haskell/haskell-language-server/actions/workflows/nix.yml/badge.svg?sanitize=true&#34; alt=&#34;GitHub Nix Workflow&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://web.libera.chat/?channels=#haskell-language-server&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/chat-on%20libera-brightgreen.svg?sanitize=true&#34; alt=&#34;ircchat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.codetriage.com/haskell/haskell-language-server&#34;&gt;&lt;img src=&#34;https://www.codetriage.com/haskell/haskell-language-server/badges/users.svg?sanitize=true&#34; alt=&#34;codetriage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The official Haskell language server (LSP) implementation. Consult the &lt;a href=&#34;https://haskell-language-server.readthedocs.io/en/latest/&#34;&gt;project documentation&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://haskell-language-server.readthedocs.io/en/latest/features.html&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://haskell-language-server.readthedocs.io/en/latest/installation.html&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://haskell-language-server.readthedocs.io/en/latest/supported-versions.html&#34;&gt;Supported GHC Versions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://haskell-language-server.readthedocs.io/en/latest/configuration.html&#34;&gt;Configuration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://haskell-language-server.readthedocs.io/en/latest/troubleshooting.html&#34;&gt;Troubleshooting&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://haskell-language-server.readthedocs.io/en/latest/contributing/index.html&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>input-output-hk/ouroboros-network</title>
    <updated>2022-10-01T01:58:43Z</updated>
    <id>tag:github.com,2022-10-01:/input-output-hk/ouroboros-network</id>
    <link href="https://github.com/input-output-hk/ouroboros-network" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An implementation of the Ouroboros family of consensus algorithms, with its networking support&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ouroboros-Network&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;io-sim&lt;/code&gt; - &lt;code&gt;IOSim&lt;/code&gt; simulator monad which supports asynchronous exceptions, &lt;code&gt;STM&lt;/code&gt; transactions and &lt;code&gt;async&lt;/code&gt; interface, timers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;io-classes&lt;/code&gt; - type classes, all of them have instance for both &lt;code&gt;IOSim&lt;/code&gt; and &lt;code&gt;IO&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;typed-protocols&lt;/code&gt; - session type framework with support of &lt;a href=&#34;https://en.wikipedia.org/wiki/Protocol_pipelining&#34;&gt;protocol pipelining&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;See 45min Haskell eXchange 2019 &lt;a href=&#34;https://skillsmatter.com/skillscasts/14633-45-minute-talk-by-duncan-coutts&#34;&gt;talk&lt;/a&gt; by @dcoutts.&lt;/li&gt; &#xA;   &lt;li&gt;See three 50min Monadic Party 2019 workshop talks by @coot: &lt;a href=&#34;https://www.youtube.com/watch?v=j8gza2L61nM&#34;&gt;Part 1&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/watch?v=oV6KSl1srL8&#34;&gt;Part 2&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/watch?v=nOIQCRPwmPA&#34;&gt;Part 3&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ouroboros-network&lt;/code&gt;- ouroboros network package which implements protocols which to run ouroboros family of protocols, multiplexing layer.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://github.com/input-output-hk/cardano-byron-proxy&#34;&gt;&lt;code&gt;byron-proxy&lt;/code&gt;&lt;/a&gt; is a network protocol proxy between Byron and Shelley. It now lives in a separate repository.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Ouroboros-Network Documentation&lt;/h2&gt; &#xA;&lt;p&gt;We have two documents which describe various levels of the networking layer of the Cardano Shelley implementation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://hydra.iohk.io/job/Cardano/ouroboros-network/native.network-docs.x86_64-linux/latest/download/1&#34;&gt;Introduction to the design of Data Diffusion and Networking of Cardano Shelley&lt;/a&gt;&lt;/p&gt; &lt;p&gt;This document explains the technical requirements and key constraints for the networking layer of the &lt;em&gt;Cardano Shelley&lt;/em&gt; implementation of &lt;em&gt;Ouroboros Praos&lt;/em&gt;. This is a design document.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://hydra.iohk.io/job/Cardano/ouroboros-network/native.network-docs.x86_64-linux/latest/download/2&#34;&gt;The Shelley Networking Protocol&lt;/a&gt;&lt;/p&gt; &lt;p&gt;This document is a technical specification of the networking protocol. It includes serialisation formats, necessary details of multiplexer and technical specifications of mini-protocols used by either &lt;em&gt;node-to-node&lt;/em&gt; and &lt;em&gt;node-to-client&lt;/em&gt; flavours of the protocol.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://input-output-hk.github.io/ouroboros-network/&#34;&gt;Haddock documentation&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://docs.cardano.org/en/latest/&#34;&gt;Official Cardano Documentation&lt;/a&gt;&lt;/p&gt; &lt;p&gt;Specifically the section &#34;Explore Cardano&#34; is helpful, since it talks about the &lt;a href=&#34;https://docs.cardano.org/explore-cardano/cardano-architecture&#34;&gt;Cardano Architecture&lt;/a&gt;, &lt;a href=&#34;https://docs.cardano.org/explore-cardano/cardano-design-rationale&#34;&gt;Cardano Design Rationale&lt;/a&gt;, the &lt;a href=&#34;https://docs.cardano.org/explore-cardano/cardano-network/about-the-cardano-network&#34;&gt;Cardano Network&lt;/a&gt;, etc. Although the Cardano documentation is less detailed, it is a good place to start and refresh some more basic concepts about Cardano.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Ouroboros-Network API&lt;/h2&gt; &#xA;&lt;p&gt;The API consists of three layers:&lt;/p&gt; &#xA;&lt;p&gt;• mini-protocol api&#39;s, which are GADTs for each mini-protocol under &lt;code&gt;Ouroboros.Network.Protocol&lt;/code&gt;; this hides heavy type machinery of session types. One only needs the typed &lt;code&gt;Peer&lt;/code&gt; type when one is using &lt;code&gt;runPeer&lt;/code&gt; or &lt;code&gt;runPeerPipelined&lt;/code&gt; function and each protocol exposes a function to create it (e.g. &lt;code&gt;Ouroboros.Network.Protocol.ChainSync.Client.chainSyncClientPeer&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;p&gt;• callback &lt;code&gt;ptcl -&amp;gt; channel -&amp;gt; m ()&lt;/code&gt; where &lt;code&gt;ptcl&lt;/code&gt; is enumeration for each mini-protocol, this is either &lt;code&gt;NodeToNodeProtocols&lt;/code&gt; or &lt;code&gt;NodeToClientProtocols&lt;/code&gt;. The callback is wrapped in &lt;code&gt;OuroborosApplication&lt;/code&gt; GADT which allows to differentiate the initiator / responder (or client / server) callbacks.&lt;/p&gt; &#xA;&lt;p&gt;• versioning which is a map from version numbers to the above callbacks and version data (the tricky part here is that version data type can be different between different versions; there is a simple way of building this map using a semigroup). You can use &lt;code&gt;simpleSingletonVersion&lt;/code&gt; if your application does not depend on negotiated version data. However, &lt;code&gt;Ouroboros.Network.NodeToNode&lt;/code&gt; and &lt;code&gt;Ouroboros.Network.NodeToClient&lt;/code&gt; expose &lt;code&gt;V1&lt;/code&gt; api which hides versioning from the caller.&lt;/p&gt; &#xA;&lt;h2&gt;Demo applications&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/input-output-hk/ouroboros-network/wiki/Ouroboros-Network-Demo&#34;&gt;demo-chain-sync&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/input-output-hk/ouroboros-network/wiki/cardano-ping&#34;&gt;cardano-ping&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/input-output-hk/ouroboros-network/raw/master/network-mux/demo/mux-demo.hs&#34;&gt;mux-demo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/input-output-hk/ouroboros-network/raw/master/ouroboros-network-framework/demo/ping-pong.hs&#34;&gt;demo-ping-pong&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/input-output-hk/ouroboros-network/raw/master/Win32-network/demo/named-pipe-demo.hs&#34;&gt;named-pipe-demo&lt;/a&gt; (Windows only)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/input-output-hk/ouroboros-network/raw/master/ntp-client/demo/Main.hs&#34;&gt;demo-ntp-client&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Instructions&lt;/summary&gt; To run a demo type: &#xA; &lt;pre&gt;&lt;code&gt;cabal run &amp;lt;DEMO_NAME&amp;gt; --&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;After &lt;code&gt;--&lt;/code&gt; you will need to pass arguments, when a demo is run without arguments it will specify what arguments it needs.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h1&gt;Ouroboros-Consensus&lt;/h1&gt; &#xA;&lt;p&gt;Consensus layer of the family Ouroboros blockchain protocols.&lt;/p&gt; &#xA;&lt;h2&gt;Ouroboros-Consensus Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;ouroboros-consensus/docs&lt;/code&gt; folder contains documentation about the consensus layer. Start with the &lt;a href=&#34;https://github.com/input-output-hk/ouroboros-network/raw/master/ouroboros-consensus/README.md&#34;&gt;README.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://hydra.iohk.io/job/Cardano/ouroboros-network/native.consensus-docs.x86_64-linux/latest/download/1&#34;&gt;The Cardano Consensus and Storage Layer&lt;/a&gt;&lt;/p&gt; &lt;p&gt;This technical report explains the design of the consensus and storage layer.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Formatting&lt;/h2&gt; &#xA;&lt;p&gt;The consensus team uses &lt;code&gt;stylish-haskell&lt;/code&gt; &amp;gt;= 0.11.0.0 to format its code. This is enforced by CI.&lt;/p&gt; &#xA;&lt;p&gt;Either enable editor integration or call the script used by CI itself:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./scripts/ci/check-stylish.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using Nix, you can use the following command, which will build and use the right version of &lt;code&gt;stylish-haskell&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix-shell --run ./scripts/ci/check-stylish.sh&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>Simspace/avaleryar</title>
    <updated>2022-10-01T01:58:43Z</updated>
    <id>tag:github.com,2022-10-01:/Simspace/avaleryar</id>
    <link href="https://github.com/Simspace/avaleryar" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A logical authorization system&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Avaleryar&lt;/h1&gt; &#xA;&lt;p&gt;An implementation of &lt;a href=&#34;http://okmij.org/ftp/papers/Soutei.pdf&#34; title=&#34;Soutei Paper&#34;&gt;Soutei&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Not yet fit for human consumption.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;It&#39;s easier to ask forgiveness than it is to get permission. --Rear Admiral Grace Murray Hopper&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Avaleryar is an implementation of &lt;a href=&#34;http://okmij.org/ftp/papers/Soutei.pdf&#34; title=&#34;Soutei Paper&#34;&gt;Pimlott and Kiselyov&#39;s Soutei&lt;/a&gt; trust-management system, comprising&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A &lt;a href=&#34;https://en.wikipedia.org/wiki/Datalog&#34;&gt;Datalog&lt;/a&gt;-like rule language for describing authorization policies (including the evaluator, parser, and a pretty-printer).&lt;/li&gt; &#xA; &lt;li&gt;Convenient library support for extending the policy language with application-specific predicates.&lt;/li&gt; &#xA; &lt;li&gt;A REPL for exploring and debugging policies.&lt;/li&gt; &#xA; &lt;li&gt;An integrated unit-testing system. (NB: It&#39;s pretty bad; we intend to improve it someday).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We have more improvements planned for the future, which you can read about &lt;a href=&#34;https://raw.githubusercontent.com/Simspace/avaleryar/master/#planned-improvements&#34;&gt;below&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;A Quick Example&lt;/h2&gt; &#xA;&lt;p&gt;Soutei is an extremely flexible system, capable of expressing various styles of authorization policies (RBAC, ABAC, other acronyms that end in -BAC). For this introductory example, we&#39;ll write a simple policy for a hypothetical blogging platform. When a user attempts to take an action, the platform will consult the policy to advise it whether or not to allow the operation to proceed. Here&#39;s an informal version of our policy, in English:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Anyone may read a post that&#39;s been published&lt;/li&gt; &#xA; &lt;li&gt;Anyone who is allowed to edit a post may read it&lt;/li&gt; &#xA; &lt;li&gt;The author of a post may edit and publish it&lt;/li&gt; &#xA; &lt;li&gt;The owner of a blog may create new posts&lt;/li&gt; &#xA; &lt;li&gt;A user may leave a comment on a post if they&#39;re permitted to read it, and are friends with the post&#39;s author.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;;; Anyone may read a post that&#39;s been published&#xA;may(read) :-&#xA;  application says status(published).&#xA;  &#xA;;; Anyone who is allowed to edit a post may read it&#xA;may(read) :-&#xA;  may(edit).&#xA;&#xA;;; The author of a post may edit it...&#xA;may(edit) :-&#xA;  application says user(?user),&#xA;  application says author(?user).&#xA;&#xA;;; ...and publish it&#xA;may(publish) :-&#xA;  application says user(?user),&#xA;  application says author(?user).&#xA;&#xA;;; The owner of a blog may create new posts&#xA;may(create) :-&#xA;  application says user(?user),&#xA;  application says blog-owner(?user).&#xA;&#xA;;; A user may leave a comment on a post if they&#39;re permitted to read it, and are friends with the&#xA;;; post&#39;s author.&#xA;may(comment) :-&#xA;  may(read),&#xA;  application says user(?user),&#xA;  application says author(?author),&#xA;  ?author says friend(?user).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What we have is a collection of &lt;em&gt;rules&lt;/em&gt; describing the circumstances under which a particular action should be permitted. When our blog application wants to know whether a request is authorized, it will ask Soutei. Soutei will then try to prove that the rules permit the access somehow, and let the application know if it succeeded. We&#39;ll discuss this syntax in detail below. Briefly, though, you can decode, say, the third rule (the author of a post may edit and publish it) like this: &#34;&lt;code&gt;edit&lt;/code&gt; is permitted when the application tells us there&#39;s a user (denoted by the &lt;em&gt;variable&lt;/em&gt; &lt;code&gt;?user&lt;/code&gt;) associated with the request, and the application tells us that that user is identically the author of the post&#34;. Observe that &lt;code&gt;:-&lt;/code&gt; (which I&#39;ll pronounce &#34;when&#34;) is like an implication in logic. The second rule (if you&#39;re allowed to edit you&#39;re allowed to read) is just saying that &lt;code&gt;edit&lt;/code&gt; implies &lt;code&gt;read&lt;/code&gt; (or, since the implication goes right-to-left, perhaps &#34;&lt;code&gt;read&lt;/code&gt; is implied by &lt;code&gt;edit&lt;/code&gt;&#34; would be better).&lt;/p&gt; &#xA;&lt;p&gt;Don&#39;t worry if this is still confusing. The example demonstrates several different features of the system. Nonetheless, I hope you agree it&#39;s a relatively compact and clean description of a not-completely-trivial authorization policy.&lt;/p&gt; &#xA;&lt;h2&gt;Using Soutei for Authorization&lt;/h2&gt; &#xA;&lt;p&gt;Architecturally, Soutei provides support for implementing a so-called &#34;policy decision point&#34;. Its job is to advise an application on whether it should permit a request by determining if it complies with its security policy. It does &lt;em&gt;not&lt;/em&gt; provide policy &lt;em&gt;enforcement&lt;/em&gt;. This is to say, you ask whether to allow access, and you get an answer, but it&#39;s still up to you to send the 403 back to the client if that answer was &#34;no&#34;.&lt;/p&gt; &#xA;&lt;p&gt;To make use of the policy engine, you formulate a query and send it along. For instance, when implementing the commenting system for your blog platform, you might ask Soutei &lt;code&gt;may(comment)&lt;/code&gt; (this is concrete syntax, in practice you&#39;ll assemble the query using library functions). Of course, whether commenting is permitted depends on information that Soutei doesn&#39;t have. In our example, that&#39;s at least the identity of the commenting user and the author of the post, and probably some more information necessary to deduce the ability to read the post. Soutei only knows about the rules you&#39;ve given it, so where do these extra facts about this particular commenting operation come from? The application provides them as a parameter to the query. So in our example, the application might ask &#34;is commenting permitted? (and by the way, the post has been published, the current user is &lt;code&gt;bob&lt;/code&gt;, the author of the post is &lt;code&gt;alice&lt;/code&gt;, and &lt;code&gt;alice&lt;/code&gt; says &lt;code&gt;bob&lt;/code&gt; is her friend, in case that helps you make your decision)&#34;.&lt;/p&gt; &#xA;&lt;p&gt;This may be a rather different style of access control than you&#39;re used to, and it requires a bit of a shift in perspective.&lt;/p&gt; &#xA;&lt;p&gt;TODO: Say more here.&lt;/p&gt; &#xA;&lt;h2&gt;Syntax and Semantics&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s a rule about activities:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;can(?activity) :-&#xA;  want-to(?activity).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It says that an activity is permitted (&lt;code&gt;can(?activity)&lt;/code&gt;) when we want to do that activity (&lt;code&gt;want-to(?activity)&lt;/code&gt;). We can see several features of the syntax in this small example. Rules have two parts (a &lt;strong&gt;head&lt;/strong&gt; and a &lt;strong&gt;body&lt;/strong&gt;), separated by the symbol &lt;code&gt;:-&lt;/code&gt; (which I tend to pronounce &#34;when&#34;), and terminated with a period. The head of the rule is &lt;code&gt;can(?activity)&lt;/code&gt;, and the body of the rule is &lt;code&gt;want-to(?activity)&lt;/code&gt;. They use a function-call like notation (called a &lt;strong&gt;literal&lt;/strong&gt;) to describe logical &lt;strong&gt;predicates&lt;/strong&gt; (i.e., &lt;code&gt;can&lt;/code&gt; and &lt;code&gt;want-to&lt;/code&gt;). Predicates are usually denoted with their arity, so rather than writing &lt;code&gt;can&lt;/code&gt;, we&#39;d write &lt;code&gt;can/1&lt;/code&gt;. If we had a predicate describing friendship between two people (&lt;code&gt;friend(alice, bob)&lt;/code&gt;), we&#39;d refer to it as &lt;code&gt;friend/2&lt;/code&gt;. We can also see that &lt;strong&gt;variables&lt;/strong&gt; are written with a prefix question-mark (&lt;code&gt;?activity&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;If this rule were our entire policy, it would never permit us to do anything, because it has no way to establish what we &lt;code&gt;want-to/1&lt;/code&gt; do. In general, determining our psyche&#39;s innermost desires can be complicated, and we could write a bunch of complicated rules to define &lt;code&gt;want-to/1&lt;/code&gt;. But let&#39;s just assume we&#39;re blessed with unusual self awareness, and add a special kind of rule, called a &lt;strong&gt;fact&lt;/strong&gt;, that will express our yearning:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;can(?activity) :-&#xA;  want-to(?activity).&#xA;  &#xA;;; we can dance if we want to&#xA;want-to(dance).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can see that a fact is a rule without a body. We can also see that comments are introduced with semicolons and extend to the end of the line. This policy will now permit a query of the form &lt;code&gt;can(dance)&lt;/code&gt;. Let&#39;s look at how that deduction works. We ask Soutei &lt;code&gt;can(dance)&lt;/code&gt;, and it reasons: &#34;I can prove &lt;code&gt;can(dance)&lt;/code&gt; if, when &lt;code&gt;?activity&lt;/code&gt; is &lt;code&gt;dance&lt;/code&gt;, I can prove &lt;code&gt;want-to(dance)&lt;/code&gt;. Oh! and I can prove &lt;code&gt;want-to(dance)&lt;/code&gt; because I know that for fact!&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Notice that &lt;code&gt;dance&lt;/code&gt; isn&#39;t a variable, it&#39;s just a symbol. We could have written &lt;code&gt;want-to(&#34;dance&#34;)&lt;/code&gt;, using double-quotes to delimit the string, but it&#39;s unnecessary (and un-idiomatic) when the string doesn&#39;t contain spaces or commas.&lt;/p&gt; &#xA;&lt;p&gt;Now suppose we want to say that we can dance if we want to, act if we want to, but sing under any circumstances? (This whole example will probably make more sense with a bit more &lt;a href=&#34;https://www.youtube.com/watch?v=AjPau5QYtYs&#34;&gt;context&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;can(?activity) :-&#xA;  want-to(?activity).&#xA;&#xA;can(sing).&#xA;&#xA;;; we can dance if we want to&#xA;want-to(dance).&#xA;&#xA;;; we can act if we want to&#xA;want-to(act).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What &lt;code&gt;can/1&lt;/code&gt; we do now? Well, we &lt;code&gt;can(dance)&lt;/code&gt;, we &lt;code&gt;can(dance)&lt;/code&gt;, we &lt;code&gt;can(sing)&lt;/code&gt;, and we &lt;code&gt;can(act)&lt;/code&gt;. This shows that we&#39;re able to express different ways to conclude that an action is permitted by writing multiple rules for the same predicate (remember that facts are rules without bodies). Rule bodies aren&#39;t limited to a single literal. Let&#39;s add an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;can(?activity) :-&#xA;  want-to(?activity).&#xA;&#xA;can(sing).&#xA;&#xA;;; we can dance if we want to&#xA;want-to(dance).&#xA;&#xA;;; we can act if we want to&#xA;want-to(act).&#xA;&#xA;;; we only want to go when the night is young, and so am I&#xA;want-to(go) :-&#xA;  time-of(night, young),&#xA;  age-of(me, young).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We require every predicate in the body of a rule to succeed in order for the rule to succeed. So &lt;code&gt;want-to(go)&lt;/code&gt; needs both &lt;code&gt;time-of(night, young)&lt;/code&gt; and &lt;code&gt;age-of(me, young)&lt;/code&gt; to be proven in order for this rule to prove that &lt;code&gt;want-to(go)&lt;/code&gt;. Of course, what we have so far isn&#39;t enough to prove &lt;code&gt;can(go)&lt;/code&gt; yet, because &lt;code&gt;age-of/2&lt;/code&gt; and &lt;code&gt;time-of/2&lt;/code&gt; aren&#39;t actually defined anywhere. This isn&#39;t considered an error; it simply means that an attempt to prove &lt;code&gt;want-to(go)&lt;/code&gt; will fail. (As a reminder, there&#39;s no special meaning attached to &lt;code&gt;night&lt;/code&gt;, &lt;code&gt;young&lt;/code&gt; or &lt;code&gt;me&lt;/code&gt;---they&#39;re just symbols I&#39;m using to demonstrate the syntax).&lt;/p&gt; &#xA;&lt;p&gt;It may be occurring to you by now that these rules don&#39;t actually depend on anything---the assertion we&#39;re developing (a collection of rules like this is called an &lt;strong&gt;assertion&lt;/strong&gt;---an assertion is kind of like a module or a namespace) will always prove exactly the same things. A rule may consult predicates in &lt;em&gt;other&lt;/em&gt; assertions than the one in which it&#39;s written. Let&#39;s hypothesize two new assertions, &lt;code&gt;clock&lt;/code&gt; and &lt;code&gt;bio&lt;/code&gt;, that contain chronological and biographical rules, respectively:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;can(?activity) :-&#xA;  want-to(?activity).&#xA;&#xA;can(sing).&#xA;&#xA;;; we can dance if we want to&#xA;want-to(dance).&#xA;&#xA;;; we can act if we want to&#xA;want-to(act).&#xA;&#xA;;; we only want to go when the night is young, and so am and I&#xA;want-to(go) :-&#xA;  clock says time-of(night, young),&#xA;  bio says age-of(me, young).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;ve changed the body of our &lt;code&gt;want-to(go)&lt;/code&gt; rule by adding &lt;code&gt;clock says time-of(night, young)&lt;/code&gt; and &lt;code&gt;bio says age-of(me, young)&lt;/code&gt;. This tells Soutei to try and resolve &lt;code&gt;time-of/2&lt;/code&gt; in the assertion named &lt;code&gt;clock&lt;/code&gt; and &lt;code&gt;age-of/2&lt;/code&gt; in the assertion named &lt;code&gt;bio&lt;/code&gt;. By &#34;resolve a predicate in an assertion&#34;, I mean that Soutei will load all the rules in that assertion, and continue trying to satisfy the predicate using the rules in &lt;em&gt;that&lt;/em&gt; assertion. Of course, if any rule in this new assertion has a body literal of the form &lt;code&gt;assertion says pred(...)&lt;/code&gt;, then Soutei will load the rules in &lt;code&gt;assertion&lt;/code&gt; and resolve &lt;code&gt;pred&lt;/code&gt; there.&lt;/p&gt; &#xA;&lt;p&gt;Other than a short discussion about variable binding and another on so-called &#34;native predicates&#34;, we&#39;ve now looked (albeit briefly) at the entirety of the semantics of the language. I point that out because in order to continue our Safety Dance, we&#39;ll need to introduce a convention that &lt;code&gt;avaleryar&lt;/code&gt; (following the original paper) imposes: the &lt;code&gt;application&lt;/code&gt; assertion. Semantically, the &lt;code&gt;application&lt;/code&gt; assertion is no different than any other. However, when &lt;code&gt;avaleryar&lt;/code&gt; runs a query, it accepts a collection of facts as, effectively, parameters that are made available to our rules through the &lt;code&gt;application&lt;/code&gt; assertion. (NB: I&#39;m doing my best to distinguish Soutei-the-language from &lt;code&gt;avaleryar&lt;/code&gt;-the-implementation-of-Soutei-the-language, I hope this isn&#39;t too confusing). So to demonstrate, let&#39;s write a needlessly complicated rule determining whether the dancing we can do is, properly a Safety Dance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;can(?activity) :-&#xA;  want-to(?activity).&#xA;&#xA;can(sing).&#xA;&#xA;;; we can dance if we want to&#xA;want-to(dance).&#xA;&#xA;;; we can act if we want to&#xA;want-to(act).&#xA;&#xA;;; we only want to go when the night is young, and so am and I&#xA;want-to(go) :-&#xA;  clock says time-of(night, young),&#xA;  bio says age-of(me, young).&#xA;&#xA;;; we can overextend the efficacy a questionable pop-culture reference&#xA;safety(?activity) :-&#xA;  can(?activity),&#xA;  application says out-of(control, everything),&#xA;  application says doing-it(from, pole),&#xA;  application says doing-it(to, pole),&#xA;  application says looking-at(hands, ?somebody),&#xA;  ?somebody says taking(the-chance).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This (completely inane, it&#39;s getting pretty late as I write this---the examples section below won&#39;t be this silly) new rule uses a bunch of information provided by the application querying for authorization advice (&lt;code&gt;application says ...&lt;/code&gt;) in addition to some locally written rules (&lt;code&gt;can(?activity)&lt;/code&gt;). It also uses an assertion &lt;em&gt;determined by the query&lt;/em&gt; (&lt;code&gt;?somebody says taking(the-chance)&lt;/code&gt;) to ultimately establish that indeed, &lt;code&gt;safety(dance)&lt;/code&gt;. The ability to dynamically choose different assertions in which to reason is a powerfully expressive feature of Soutei.&lt;/p&gt; &#xA;&lt;p&gt;TODO: unification and native predicates.&lt;/p&gt; &#xA;&lt;p&gt;TODO: why encoding &#34;&#39;Cause your friends don&#39;t dance, and if they don&#39;t dance, then they&#39;re no friends of mine&#34; isn&#39;t (naively) possible.&lt;/p&gt; &#xA;&lt;p&gt;TODO: mode checking.&lt;/p&gt; &#xA;&lt;p&gt;TODO: monotonicity.&lt;/p&gt; &#xA;&lt;h2&gt;Examples and Advice&lt;/h2&gt; &#xA;&lt;h3&gt;Example: Unix File Permissions&lt;/h3&gt; &#xA;&lt;p&gt;Here is a simplified version of file permissions on Unix. We assume that the application will tell us what the file is, that there&#39;s an assertion named after the file that knows what permissions are set on it, who owns it, and which group it&#39;s associated with, as well as that each group has an assertion named after it that can tell us whether a user is a member of that group. For example, we might have an assertion for some file that looked like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;;; assertion for /path/to/some/file&#xA;&#xA;owner(mary).&#xA;group(wheel).&#xA;perm(user, read).&#xA;perm(user, write).&#xA;perm(user, execute).&#xA;perm(group, read).&#xA;perm(group, execute).&#xA;perm(other, read).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This would represent a file owned by &lt;code&gt;mary&lt;/code&gt;, with group &lt;code&gt;wheel&lt;/code&gt;, with permissions &lt;code&gt;754&lt;/code&gt; (as in, &lt;code&gt;chmod 754 /path/to/some/file&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;;; allow ?access when the user is the owner and ?access is enabled for them.&#xA;;; NB: The word &#34;user&#34; appears with three different meanings in this rule.  The application fact&#xA;;; &#39;user/1&#39;, which indicates the user accessing the file, the variable &#39;?user&#39;, which has that&#xA;;; user bound to it, and the symbol &#39;user&#39; in &#39;perm(user, ?access)&#39;, which refers to user&#xA;;; permissions on a file in the sense of &#39;chmod u+x $FILE&#39;.&#xA;may(?access) :-&#xA;  application says file(?file),&#xA;  application says user(?user),&#xA;  ?file says owner(?user),&#xA;  ?file says perm(user, ?access).&#xA;&#xA;;; allow ?access when it&#39;s enabled on the file, the file is associated with a group ?group,&#xA;;; and the user is a member of ?group.&#xA;may(?access) :-&#xA;  application says file(?file),&#xA;  application says user(?user),&#xA;  ?file says group(?group),&#xA;  ?group says member(?user),&#xA;  ?file says perm(group, ?access).&#xA;  &#xA;;; allow ?access if it&#39;s enabled for all users (&#34;other&#34; permissions)&#xA;may(?access) :-&#xA;  application says file(?file),&#xA;  ?file says perm(other, ?access).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unix permissions are more sophisticated than this---for instance, if you have &lt;code&gt;read&lt;/code&gt; access to a directory, you are permitted to see the &lt;em&gt;names&lt;/em&gt; of the files in that directory, but not other metadata (roughly, you&#39;re allowed to see the output of &lt;code&gt;ls&lt;/code&gt;, but not &lt;code&gt;ls -l&lt;/code&gt;) unless you also have &lt;code&gt;execute&lt;/code&gt; permission on the directory as well. A more nuanced version of this policy would need to know what metadata is being sought by the application, and probably require some native predicates to compute the directory part of a file path.&lt;/p&gt; &#xA;&lt;h3&gt;Example: Role-Based Access Control (RBAC)&lt;/h3&gt; &#xA;&lt;p&gt;In RBAC, we have a discrete set of primitive &lt;em&gt;permissions&lt;/em&gt;, a collection of named &lt;em&gt;roles&lt;/em&gt; each of which is a subset of the permissions, and an assignment of users to (possibly multiple) roles. To determine if a user is permitted to take some action, we check that the user has been assigned some role that contains the appropriate permission.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-prolog&#34;&gt;;; permissions&#xA;&#xA;perm(manage-users).&#xA;perm(manage-computers).&#xA;perm(access-lab).&#xA;perm(run-experiment).&#xA;perm(create-experiment).&#xA;perm(approve-experiment).&#xA;&#xA;;; roles&#xA;&#xA;; grad students get to do all the work&#xA;role(grad-student, access-lab).&#xA;role(grad-student, run-experiment).&#xA;&#xA;; professors have at least the permissions of grad students, plus they can&#xA;; create experiments.&#xA;role(professor, ?perm) :-&#xA;  role(grad-student, ?perm).&#xA;role(professor, create-experiment).&#xA;&#xA;; poison control should probably be allowed into the lab, just in case&#xA;role(poison-control, access-lab).&#xA;&#xA;; the IT department needs to access the lab to manage its computers&#xA;role(it-support, access-lab).&#xA;role(it-support, manage-computers).&#xA;&#xA;; the dean has nothing to do with the science, but they still sign the&#xA;; checks and assign personel&#xA;role(dean, approve-experiment).&#xA;role(dean, manage-users).&#xA;&#xA;;; users&#xA;&#xA;has-role(bill, grad-student).&#xA;has-role(clara, professor).&#xA;has-role(dmitri, grad-student).&#xA;has-role(dmitri, poison-control). ; dmitri is a volunteer EMT&#xA;has-role(emily, it-support).&#xA;has-role(fabian, dean).&#xA;&#xA;;; RBAC&#xA;&#xA;may(?perm) :-&#xA;  application says user(?user),&#xA;  has-role(?user, ?role),&#xA;  role(?role, ?perm).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example: Access Control Lists (ACLs)&lt;/h3&gt; &#xA;&lt;h3&gt;Advice: Don&#39;t use ACLs&lt;/h3&gt; &#xA;&lt;h2&gt;Using Avaleryar&lt;/h2&gt; &#xA;&lt;p&gt;TODO: tutorial module.&lt;/p&gt; &#xA;&lt;h2&gt;Glossary&lt;/h2&gt; &#xA;&lt;h2&gt;Planned Improvements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;An interactive debugger&lt;/li&gt; &#xA; &lt;li&gt;A better persistence story (to make dynamic rule submission usable)&lt;/li&gt; &#xA; &lt;li&gt;Assertion signatures (enabling the use of variables for native assertions)&lt;/li&gt; &#xA; &lt;li&gt;Some kind of &lt;a href=&#34;https://en.wikipedia.org/wiki/Abductive_logic_programming&#34;&gt;abduction&lt;/a&gt; (to offer explanations of query failure)&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>