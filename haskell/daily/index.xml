<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-10T01:34:43Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>clausecker/BWInf2011</title>
    <updated>2023-05-10T01:34:43Z</updated>
    <id>tag:github.com,2023-05-10:/clausecker/BWInf2011</id>
    <link href="https://github.com/clausecker/BWInf2011" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Unsere Lösungen der Aufgaben des 30. BWInf – Team Färöer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Lösungen der 1. Runde des 30. BWInf&lt;/h1&gt; &#xA;&lt;p&gt;Dies sind die Lösungen zur ersten Runde des 30. Bundeswettbewerbes Informatik (2011) von&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Alexandra Piloth&lt;/li&gt; &#xA; &lt;li&gt;Robert Clausecker&lt;/li&gt; &#xA; &lt;li&gt;Tobias Bucher&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Diese Lösungen wurden hier platziert, um anderen zu zeigen, wie man diese Aufgaben potenziell lösen kann. Wir übernehmen keine Garantie für die Funktionsfähigkeit der Lösungen. Jeder kann diese Lösungen unter den Bedingungen der WTFPL, Version 2 verwenden.&lt;/p&gt; &#xA;&lt;h2&gt;Hinweise zur Compilierung&lt;/h2&gt; &#xA;&lt;p&gt;Zur Compilierung der Lösungsprogramme und Dokumentation sind zumindest folgende Werkzeuge notwendig. Es kann sein, dass ich Dinge übersehen habe:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;XeLaTeX mit Linux Libertine, getestet wurde TeXlive 2009&lt;/li&gt; &#xA; &lt;li&gt;GHC Version 7 oder höher&lt;/li&gt; &#xA; &lt;li&gt;Ein C-Compiler&lt;/li&gt; &#xA; &lt;li&gt;Make&lt;/li&gt; &#xA; &lt;li&gt;Pygmentize&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Die Aufgaben 2 und 5 enthalten Makefiles zur Vereinfachung der Kompilierung. Ein Aufruf &lt;code&gt;make&lt;/code&gt; im Verzeichnis Aufgabe2 baut das Programm sowie die Dokumentation. Es sind zudem noch die Ziele &lt;code&gt;doc&lt;/code&gt;, &lt;code&gt;build&lt;/code&gt; und &lt;code&gt;clean&lt;/code&gt; verfügbar. Im Odner Aufgabe5 stehen hingegen nur die Ziele &lt;code&gt;all&lt;/code&gt; und &lt;code&gt;clean&lt;/code&gt; zur Verfügung. In beiden Fällen wird am Ende eine Ausführbare Datei mit dem Namen Aufgabe2 bzw. Aufgab5 aufzufinden sein.&lt;/p&gt; &#xA;&lt;p&gt;Für die Aufgabe 1 ist kein Makefile enthalten, ein zweimaliger Aufruf von &lt;code&gt;xelatex Lösung.pdf&lt;/code&gt; sollte zum Bauen der Lösung ausreichen.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jongisli/ap-ass1-maze</title>
    <updated>2023-05-10T01:34:43Z</updated>
    <id>tag:github.com,2023-05-10:/jongisli/ap-ass1-maze</id>
    <link href="https://github.com/jongisli/ap-ass1-maze" rel="alternate"></link>
    <summary type="html">&lt;p&gt;maze&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Gummi og Jon&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>danr/stm-promise</title>
    <updated>2023-05-10T01:34:43Z</updated>
    <id>tag:github.com,2023-05-10:/danr/stm-promise</id>
    <link href="https://github.com/danr/stm-promise" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple STM promise-like thingys&lt;/p&gt;&lt;hr&gt;&lt;h3&gt;STM Promises&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/danr/stm-promise&#34;&gt;&lt;img src=&#34;https://travis-ci.org/danr/stm-promise.png?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;An example&lt;/h1&gt; &#xA;&lt;p&gt;Running the theorem prover eprover in parallel:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;import Prelude hiding (mapM)&#xA;import Data.Traversable&#xA;&#xA;import Data.List&#xA;import Data.Maybe&#xA;&#xA;import Control.Concurrent.STM.Promise&#xA;import Control.Concurrent.STM.Promise.Process&#xA;import Control.Concurrent.STM.Promise.Tree&#xA;import Control.Concurrent.STM.Promise.Workers&#xA;&#xA;{- | A tree for this file structure:&#xA;   ├── mul-commutative&#xA;   │&amp;nbsp;&amp;nbsp; ├── induction_x_0.tptp&#xA;   │&amp;nbsp;&amp;nbsp; ├── induction_x_1.tptp&#xA;   │&amp;nbsp;&amp;nbsp; ├── induction_x_y_0.tptp&#xA;   │&amp;nbsp;&amp;nbsp; ├── induction_x_y_1.tptp&#xA;   │&amp;nbsp;&amp;nbsp; ├── induction_x_y_2.tptp&#xA;   │&amp;nbsp;&amp;nbsp; ├── induction_x_y_3.tptp&#xA;   │&amp;nbsp;&amp;nbsp; ├── induction_y_0.tptp&#xA;   │&amp;nbsp;&amp;nbsp; ├── induction_y_1.tptp&#xA;   │&amp;nbsp;&amp;nbsp; └── no_induction_0.tptp&#xA;   └── plus-commutative&#xA;    &amp;nbsp;&amp;nbsp; ├── induction_x_0.tptp&#xA;    &amp;nbsp;&amp;nbsp; ├── induction_x_1.tptp&#xA;    &amp;nbsp;&amp;nbsp; ├── induction_x_y_0.tptp&#xA;    &amp;nbsp;&amp;nbsp; ├── induction_x_y_1.tptp&#xA;    &amp;nbsp;&amp;nbsp; ├── induction_x_y_2.tptp&#xA;    &amp;nbsp;&amp;nbsp; ├── induction_x_y_3.tptp&#xA;    &amp;nbsp;&amp;nbsp; ├── induction_y_0.tptp&#xA;    &amp;nbsp;&amp;nbsp; ├── induction_y_1.tptp&#xA;    &amp;nbsp;&amp;nbsp; └── no_induction_0.tptp&#xA;-}&#xA;file_tree :: Tree FilePath&#xA;file_tree = fmap (++ &#34;.tptp&#34;) $ tryAll&#xA;   [ fmap (&#34;mul-commutative/&#34; ++) $ requireAny&#xA;     [ fmap (&#34;induction_x_&#34; ++) $ requireAll $ map Leaf [&#34;0&#34;,&#34;1&#34;]&#xA;     , fmap (&#34;induction_y_&#34; ++) $ requireAll $ map Leaf [&#34;0&#34;,&#34;1&#34;]&#xA;     , fmap (&#34;induction_x_y_&#34; ++) $ requireAll $ map Leaf [&#34;0&#34;,&#34;1&#34;,&#34;2&#34;,&#34;3&#34;]&#xA;     , Leaf &#34;no_induction_0&#34;&#xA;     ]&#xA;   , fmap (&#34;plus-commutative/&#34; ++) $ requireAny&#xA;     [ fmap (&#34;induction_x_&#34; ++) $ requireAll $ map Leaf [&#34;0&#34;,&#34;1&#34;]&#xA;     , fmap (&#34;induction_y_&#34; ++) $ requireAll $ map Leaf [&#34;0&#34;,&#34;1&#34;]&#xA;     , fmap (&#34;induction_x_y_&#34; ++) $ requireAll $ map Leaf [&#34;0&#34;,&#34;1&#34;,&#34;2&#34;,&#34;3&#34;]&#xA;     , Leaf &#34;no_induction_0&#34;&#xA;     ]&#xA;   ]&#xA;&#xA;success :: ProcessResult -&amp;gt; Bool&#xA;success r = excode r == ExitSuccess &amp;amp;&amp;amp; any (`isInfixOf` stdout r) ok&#xA;  where&#xA;    ok = [&#34;Theorem&#34;,&#34;Unsatisfiable&#34;]&#xA;&#xA;eproverPromise :: FilePath -&amp;gt; IO (Promise [(FilePath,Bool)])&#xA;eproverPromise file = do&#xA;    let args = [&#34;-xAuto&#34;,&#34;-tAuto&#34;,&#39;-&#39;:&#34;-tptp3-format&#34;,&#34;-s&#34;]&#xA;    promise &amp;lt;- processPromise &#34;eprover&#34; (file : args) &#34;&#34;&#xA;    let chres :: ProcessResult -&amp;gt; [(FilePath,Bool)]&#xA;        chres r = [ (file,success r) ]&#xA;    return $ fmap chres promise&#xA;&#xA;main :: IO ()&#xA;main = do&#xA;    promise_tree &amp;lt;- mapM eproverPromise file_tree&#xA;&#xA;    let timeout      = 1000 * 1000 -- microseconds&#xA;        processes    = 2&#xA;&#xA;    workers (Just timeout) processes (interleave promise_tree)&#xA;&#xA;    res &amp;lt;- evalTree (any (not . snd)) promise_tree&#xA;&#xA;    putStrLn &#34;Results: &#34;&#xA;&#xA;    mapM_ print res&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result of this run is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Results:&#xA;(&#34;plus-commutative/induction_x_y_0.tptp&#34;,True)&#xA;(&#34;plus-commutative/induction_x_y_1.tptp&#34;,True)&#xA;(&#34;plus-commutative/induction_x_y_2.tptp&#34;,True)&#xA;(&#34;plus-commutative/induction_x_y_3.tptp&#34;,True)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This means that four out of four obligations for commutativity of plus succeeded when doing induction on both x and y.&lt;/p&gt;</summary>
  </entry>
</feed>