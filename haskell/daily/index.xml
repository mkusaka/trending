<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-18T01:45:25Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>haskell-effectful/effectful</title>
    <updated>2022-07-18T01:45:25Z</updated>
    <id>tag:github.com,2022-07-18:/haskell-effectful/effectful</id>
    <link href="https://github.com/haskell-effectful/effectful" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An easy to use, fast extensible effects library with seamless integration with the existing Haskell ecosystem.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;effectful&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/haskell-effectful/effectful/actions?query=branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/haskell-effectful/effectful/workflows/Haskell-CI/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/effectful&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/effectful.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://packdeps.haskellers.com/feed?needle=andrzej@rybczak.net&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage-deps/v/effectful.svg?sanitize=true&#34; alt=&#34;Dependencies&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.stackage.org/lts/package/effectful&#34;&gt;&lt;img src=&#34;https://www.stackage.org/package/effectful/badge/lts&#34; alt=&#34;Stackage LTS&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.stackage.org/nightly/package/effectful&#34;&gt;&lt;img src=&#34;https://www.stackage.org/package/effectful/badge/nightly&#34; alt=&#34;Stackage Nightly&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;https://user-images.githubusercontent.com/387658/127747903-f728437f-2ee4-47b8-9f0c-5102fd44c8e4.png&#34; width=&#34;128&#34;&gt; &#xA;&lt;p&gt;An easy to use, fast extensible effects library with seamless integration with the existing Haskell ecosystem.&lt;/p&gt; &#xA;&lt;p&gt;Main features:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Very fast (&lt;a href=&#34;https://github.com/haskell-effectful/effectful/tree/master/benchmarks/README.md&#34;&gt;benchmarks&lt;/a&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Easy to use API (comparable with usage of the &lt;a href=&#34;https://hackage.haskell.org/package/unliftio-core/docs/Control-Monad-IO-Unlift.html#t:MonadUnliftIO&#34;&gt;MonadUnliftIO&lt;/a&gt; class).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Correct semantics in presence of runtime exceptions (no more discarded state updates).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Seamless integration with the existing ecosystem (&lt;code&gt;exceptions&lt;/code&gt;, &lt;code&gt;monad-control&lt;/code&gt;, &lt;code&gt;unliftio-core&lt;/code&gt;, &lt;code&gt;resourcet&lt;/code&gt; etc.).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Support for thread local and shared state (e.g. &lt;code&gt;StateT&lt;/code&gt; provides a thread local state, while &lt;code&gt;MVar&lt;/code&gt; holds a shared state, both approaches have their merits).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Support for statically (implementation determined at compile time) and dynamically (implementation determined at run time) dispatched effects.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;Do we really need yet another library for handling effects? There&#39;s &lt;a href=&#34;https://hackage.haskell.org/package/freer-simple&#34;&gt;freer-simple&lt;/a&gt;, &lt;a href=&#34;https://hackage.haskell.org/package/fused-effects&#34;&gt;fused-effects&lt;/a&gt;, &lt;a href=&#34;https://hackage.haskell.org/package/polysemy&#34;&gt;polysemy&lt;/a&gt;, &lt;a href=&#34;https://github.com/hasura/eff&#34;&gt;eff&lt;/a&gt; and probably a few more.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, of all of them only &lt;code&gt;eff&lt;/code&gt; is a promising proposition because of reasonable performance characteristics (see the talk &lt;a href=&#34;https://www.youtube.com/watch?v=0jI-AlWEwYI&#34;&gt;Effects for Less&lt;/a&gt; for more information) and potential for good interoperability with the existing ecosystem.&lt;/p&gt; &#xA;&lt;p&gt;The second point is arguably the most important, because it allows focusing on things that matter instead of reinventing all kinds of wheels, hence being a necessary condition for broader adoption of the library.&lt;/p&gt; &#xA;&lt;p&gt;However, &lt;code&gt;eff&lt;/code&gt; uses delimited continuations underneath, which:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Are not yet supported by GHC (though &lt;a href=&#34;https://github.com/ghc-proposals/ghc-proposals/pull/313&#34;&gt;the proposal&lt;/a&gt; for including support for them has been accepted).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Are quite hard to understand.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Make the library &#34;too powerful&#34; in a sense as it faces &lt;a href=&#34;https://github.com/hasura/eff/issues/13&#34;&gt;a&lt;/a&gt; &lt;a href=&#34;https://github.com/hasura/eff/issues/7&#34;&gt;few&lt;/a&gt; &lt;a href=&#34;https://github.com/hasura/eff/issues/12&#34;&gt;issues&lt;/a&gt; with no clear path towards their resolution.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;What about &lt;code&gt;mtl&lt;/code&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;It&#39;s true that its &#34;effects as classes&#34; approach is widely known and used often.&lt;/p&gt; &#xA;&lt;p&gt;However:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;mtl&lt;/code&gt; style effects are &lt;a href=&#34;https://github.com/haskell-effectful/effectful/tree/master/benchmarks/README.md&#34;&gt;slow&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The majority of popular monad transformers (except &lt;code&gt;ReaderT&lt;/code&gt;) used for effect implementations are rife with &lt;a href=&#34;https://github.com/haskell-effectful/effectful/tree/master/transformers.md&#34;&gt;subtle issues&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These are problematic enough that the &lt;a href=&#34;https://www.fpcomplete.com/blog/2017/06/readert-design-pattern/&#34;&gt;ReaderT design pattern&lt;/a&gt; was invented. Its fundamentals are solid, but it&#39;s not an effect system.&lt;/p&gt; &#xA;&lt;p&gt;A solution? Use the &lt;code&gt;ReaderT&lt;/code&gt; pattern as a base and build around it to make an extensible effects library! This is where &lt;code&gt;effectful&lt;/code&gt; comes in. The &lt;code&gt;Eff&lt;/code&gt; monad it uses is essentially a &lt;code&gt;ReaderT&lt;/code&gt; over &lt;code&gt;IO&lt;/code&gt; on steroids, allowing us to extend its environment with data types representing effects.&lt;/p&gt; &#xA;&lt;p&gt;This concept is quite simple, so:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;It&#39;s reasonably easy to understand what is going on under the hood.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;code&gt;Eff&lt;/code&gt; monad being a reader allows for seamless interoperability with ubiquitous classes such as &lt;code&gt;MonadBaseControl&lt;/code&gt; and &lt;code&gt;MonadUnliftIO&lt;/code&gt; and solves &lt;a href=&#34;https://github.com/haskell-effectful/effectful/tree/master/transformers.md&#34;&gt;issues&lt;/a&gt; of monad transformers mentioned above.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;What is more, the &lt;code&gt;Eff&lt;/code&gt; monad is concrete, so GHC has many possibilities for optimization, which results in a very fast code at a default optimization level. There is no need to mark every function &lt;code&gt;INLINE&lt;/code&gt; or enable additional optimization passes, it just works.&lt;/p&gt; &#xA;&lt;h3&gt;Any downsides?&lt;/h3&gt; &#xA;&lt;p&gt;As always, there&#39;s no free lunch. The &lt;code&gt;Eff&lt;/code&gt; monad doesn&#39;t support &lt;code&gt;NonDet&lt;/code&gt; nor &lt;code&gt;Coroutine&lt;/code&gt; effects. However, the &lt;code&gt;NonDet&lt;/code&gt; effect in existing libraries is &lt;a href=&#34;https://github.com/lexi-lambda/eff/raw/8c4df4bf54faf22456354be18095b14825be5e85/notes/semantics-zoo.md&#34;&gt;broken&lt;/a&gt; and none of the ones with support for higher order effects provide the &lt;code&gt;Coroutine&lt;/code&gt; effect, so arguably it&#39;s not a big loss.&lt;/p&gt; &#xA;&lt;p&gt;If you need such capability in your application, there are well established libraries such as &lt;a href=&#34;https://hackage.haskell.org/package/conduit&#34;&gt;conduit&lt;/a&gt; or &lt;a href=&#34;https://hackage.haskell.org/package/list-t&#34;&gt;list-t&lt;/a&gt; that can be used with &lt;code&gt;effectful&lt;/code&gt; without any issues.&lt;/p&gt; &#xA;&lt;h3&gt;Summary&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;effectful&lt;/code&gt; is an extensible effects library that aims to replace &#34;boring&#34; transformer stacks (which consist of a dozen of newtype&#39;d &lt;code&gt;ExceptT&lt;/code&gt;, &lt;code&gt;ReaderT&lt;/code&gt;, &lt;code&gt;StateT&lt;/code&gt; and &lt;code&gt;WriterT&lt;/code&gt; transformers) and their derivatives by providing equivalent effects with improved semantics, performance and usability (it also makes it easy to reuse them for your own effects). It doesn&#39;t try to make monad transformers obsolete, so you&#39;re free to use it with &lt;code&gt;ConduitT&lt;/code&gt;, &lt;code&gt;ContT&lt;/code&gt;, &lt;code&gt;ListT&lt;/code&gt; etc. when necessary.&lt;/p&gt; &#xA;&lt;h2&gt;Package structure&lt;/h2&gt; &#xA;&lt;p&gt;The effect system is split among several libraries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/effectful-core&#34;&gt;&lt;code&gt;effectful-core&lt;/code&gt;&lt;/a&gt; library contains the core of the effect system along with the basic effects. It aims for a small dependency footprint and provides building blocks for more advanced effects.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/effectful-plugin&#34;&gt;&lt;code&gt;effectful-plugin&lt;/code&gt;&lt;/a&gt; library provides an optional GHC plugin for improving disambiguation of effects (see &lt;a href=&#34;https://github.com/haskell-effectful/effectful/raw/master/effectful-plugin/README.md&#34;&gt;here&lt;/a&gt; for more information).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/effectful-th&#34;&gt;&lt;code&gt;effectful-th&lt;/code&gt;&lt;/a&gt; library provides utilities for generating bits of effect-related boilerplate via Template Haskell.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/effectful&#34;&gt;&lt;code&gt;effectful&lt;/code&gt;&lt;/a&gt; library re-exports public modules of &lt;code&gt;effectful-core&lt;/code&gt; and additionally provides most features of the &lt;code&gt;unliftio&lt;/code&gt; library divided into appropriate effects.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;code&gt;Filesystem&lt;/code&gt; effect with two handlers, one that runs in &lt;code&gt;IO&lt;/code&gt; and another that uses an in-memory virtual file system can be found &lt;a href=&#34;https://github.com/haskell-effectful/effectful/raw/master/effectful/examples/FileSystem.hs&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;p&gt;Resources that inspired the rise of this library and had a lot of impact on its design.&lt;/p&gt; &#xA;&lt;p&gt;Talks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=0jI-AlWEwYI&#34;&gt;Effects for Less&lt;/a&gt; by Alexis King.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=KZIN9f9rI34&#34;&gt;Monad Transformer State&lt;/a&gt; by Michael Snoyman.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Blog posts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.fpcomplete.com/blog/2017/06/readert-design-pattern/&#34;&gt;ReaderT design pattern&lt;/a&gt; by Michael Snoyman.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell/&#34;&gt;Exceptions Best Practices&lt;/a&gt; by Michael Snoyman.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;div&gt;&#xA; Icons made by &#xA; &lt;a href=&#34;https://www.freepik.com&#34; title=&#34;Freepik&#34;&gt;Freepik&lt;/a&gt; from &#xA; &lt;a href=&#34;https://www.flaticon.com/&#34; title=&#34;Flaticon&#34;&gt;www.flaticon.com&lt;/a&gt;&#xA;&lt;/div&gt;</summary>
  </entry>
  <entry>
    <title>cgohla/pureshell</title>
    <updated>2022-07-18T01:45:25Z</updated>
    <id>tag:github.com,2022-07-18:/cgohla/pureshell</id>
    <link href="https://github.com/cgohla/pureshell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Bash backend for PureScript&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PureShell&lt;/h1&gt; &#xA;&lt;p&gt;Compile &lt;a href=&#34;https://www.purescript.org&#34;&gt;PureScript&lt;/a&gt; to shell scripts.&lt;/p&gt; &#xA;&lt;p&gt;The PureScript compiler fortunately makes it easy to write alternative backends, of which &lt;a href=&#34;https://github.com/purescript/documentation/raw/master/ecosystem/Alternate-backends.md&#34;&gt;there are several&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Code Overview&lt;/h1&gt; &#xA;&lt;p&gt;Most modules are under the &lt;code&gt;Language.PureShell&lt;/code&gt; hierarchy. We have several intermediate languages, these are in order:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CoreFn&lt;/code&gt;: This is our input language and is defined by the &lt;a href=&#34;https://github.com/purescript/purescript/tree/master/src/Language/PureScript/CoreFn&#34;&gt;PureScript compiler&lt;/a&gt;. It is a form of untyped lambda calculus.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Combinatory&lt;/code&gt;: Mostly mirrors CoreFn, but in abstractions all free variables have to be bound simultaneously.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Procedural&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Bash&lt;/code&gt;: The output language&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For each of these we have at least the following three modules, namely&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;IR&lt;/code&gt;: AST type definitions&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CodeGen&lt;/code&gt;: helpers&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Lower&lt;/code&gt;: high level functions for mapping to the next lower stage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(This structure is heavily inspired by &lt;a href=&#34;https://luctielen.com/posts/how-to-lower-an-ir/&#34;&gt;&lt;em&gt;How to lower an IR?&lt;/em&gt;&lt;/a&gt;.)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ximarx/fondamenti-informatica</title>
    <updated>2022-07-18T01:45:25Z</updated>
    <id>tag:github.com,2022-07-18:/ximarx/fondamenti-informatica</id>
    <link href="https://github.com/ximarx/fondamenti-informatica" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Strutture dati e esercizi in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;fondamenti-informatica&lt;/h1&gt; &#xA;&lt;p&gt;Strutture dati e esercizi in Haskell&lt;/p&gt;</summary>
  </entry>
</feed>