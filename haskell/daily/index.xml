<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-13T01:37:10Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mongodb/bson-haskell</title>
    <updated>2023-01-13T01:37:10Z</updated>
    <id>tag:github.com,2023-01-13:/mongodb/bson-haskell</id>
    <link href="https://github.com/mongodb/bson-haskell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell representation and serialization of BSON documents (version 1.0) as defined at bsonspec.org&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;End of Life Notice&lt;/h1&gt; &#xA;&lt;p&gt;The MongoDB bson-haskell library is now officially end-of-life (EOL). No further development, bugfixes, enhancements, documentation changes or maintenance will be provided by this project and pull requests will no longer be accepted.&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;Haskell library for the BSON encoding. Used in MongoDB. BSON documents are JSON-like objects with a standard binary encoding. A BSON Document is serialized to a standard binary encoding defined at &lt;a href=&#34;http://bsonspec.org&#34;&gt;http://bsonspec.org&lt;/a&gt;. This implements version 1 of that spec.&lt;/p&gt; &#xA;&lt;p&gt;A BSON Document is an untyped (dynamically type-checked) record. I.e. it is a list of name-value pairs, where a Value is a single sum type with constructors for basic types (Bool, Int, Float, String, and Time), compound types (List, and (embedded) Document), and special types (Binary, Javascript, ObjectId, RegEx, and a few others).&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>stevana/property-based-testing-stateful-systems-tutorial</title>
    <updated>2023-01-13T01:37:10Z</updated>
    <id>tag:github.com,2023-01-13:/stevana/property-based-testing-stateful-systems-tutorial</id>
    <link href="https://github.com/stevana/property-based-testing-stateful-systems-tutorial" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A tutorial about how to apply property-based testing to stateful systems.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Property-based testing stateful systems: a tutorial&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/stevana/property-based-testing-stateful-systems-tutorial/actions&#34;&gt;&lt;img src=&#34;https://github.com/stevana/property-based-testing-stateful-systems-tutorial/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;GitHub CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/property-based-testing-stateful-systems-tutorial&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/property-based-testing-stateful-systems-tutorial.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Property-based testing (PBT), i.e. generating random inputs and checking some property of the output, of pure programs is an established practice by now. It&#39;s taught in introductory university classes and it&#39;s part of test suites in industry.&lt;/p&gt; &#xA;&lt;p&gt;Most real world programs are not pure though, they are stateful. While it&#39;s often possible to structure your program in such a way that the impure stuff is done in &lt;code&gt;main&lt;/code&gt;, e.g. read the contents of a file, and then passed on to a pure function, e.g. a parser, it&#39;s not always possible. Consider a long-running program that interacts with the filesystem and with other programs over the network, e.g. some kind of web service or a distributed database. It&#39;s difficult to split such a program up into doing a little bit of impure stuff at the start, then hand it over to a pure function (which we can apply PBT on).&lt;/p&gt; &#xA;&lt;p&gt;Given this it&#39;s perhaps a bit surprising that there are relatively few resources about applying PBT to stateful systems. This repository is an attempt to close that gap and try to make PBT stateful systems more common.&lt;/p&gt; &#xA;&lt;p&gt;The goals we&#39;d like to achieve are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Show how to test stateful (i.e. impure/monadic) programs using property-based testing;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Show how we can do concurrent testing to help uncover problems such as race conditions;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Show how we can build bigger systems in a modular way by applying the property-based testing equivalent of integration and contract tests;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Show how to use fault injection and so called simulation testing to &#34;end-to-end&#34; test distributed systems;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Introduce the reader to related work and open problems in the area along the way.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In the interest of brevity, we assume that the reader already has:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Enough familiarity with Haskell to be able to read simple programs, for example if you can follow along in the &lt;em&gt;Learn You a Haskell for Great Good!&lt;/em&gt; &lt;a href=&#34;http://learnyouahaskell.com/chapters&#34;&gt;tutorial&lt;/a&gt;, then you should be fine;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Some experience with property-based testing of non-stateful (i.e. pure) programs. For example as explained in the official QuickCheck &lt;a href=&#34;http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html&#34;&gt;manual&lt;/a&gt; or in the following &lt;a href=&#34;https://begriffs.com/posts/2017-01-14-design-use-quickcheck.html&#34;&gt;tutorial&lt;/a&gt;;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Basic knowledge of state machines (i.e. &lt;a href=&#34;https://en.wikipedia.org/wiki/Mealy_machine&#34;&gt;Mealy&lt;/a&gt; / &lt;a href=&#34;https://en.wikipedia.org/wiki/Moore_machine&#34;&gt;Moore machines&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Finite-state_transducer&#34;&gt;transducers&lt;/a&gt;).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Other than that this tutorial is striving to be as self-contained as possibly as well as accessible to non-Haskell programmers.&lt;/p&gt; &#xA;&lt;h2&gt;Structure&lt;/h2&gt; &#xA;&lt;p&gt;The tutorial is split up into five parts (so far), and each part has the following structure:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Motivation: explains why we are doing what we are about to do;&lt;/li&gt; &#xA; &lt;li&gt;Plan: how we will do it;&lt;/li&gt; &#xA; &lt;li&gt;Code: a concrete implementation of the idea (in case you get stuck when trying to implement it yourself);&lt;/li&gt; &#xA; &lt;li&gt;Discussion: common questions or objections;&lt;/li&gt; &#xA; &lt;li&gt;Exercises: things the authors were to lazy to do, but they know how to;&lt;/li&gt; &#xA; &lt;li&gt;Problems: things the authors don&#39;t know how to do (yet);&lt;/li&gt; &#xA; &lt;li&gt;See also: links to further reading about the topic or related topics;&lt;/li&gt; &#xA; &lt;li&gt;Summary: the most important take away.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The parts build upon each other. We start by modelling and testing a simple counter using a state machine in part 1, we then reuse the same state machine model to test the counter for thread-safety using linearisability in part 2. In part 3 we will implement a queue and a web service that uses said queue, the state machine model for the queue and the real implementation of the queue will be contract tested to ensure that the model is faithful to the implementation, subsequently while testing the web service we will use the model in place of the real queue. In part 4 we introduce fault injection to the queue allowing us to test how the web service performs when its dependency fails. Finally, in part 5, we combine all the above ideas in what, sometimes is called simulation testing, to test a distributed system that uses replicated state machines.&lt;/p&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stevana/property-based-testing-stateful-systems-tutorial/main/docs/Part01SMTesting.md#readme&#34;&gt;State machine testing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Concurrent state machine testing with linearisability&lt;/li&gt; &#xA; &lt;li&gt;Integration tests against state machine fakes and consumer-driven contract tests for the fakes&lt;/li&gt; &#xA; &lt;li&gt;Fault-injection&lt;/li&gt; &#xA; &lt;li&gt;Simulation testing&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;This repository contains literate Haskell code in &lt;code&gt;src&lt;/code&gt;. If you want to interact with it, install &lt;a href=&#34;https://www.haskell.org/ghcup/install/&#34;&gt;&lt;code&gt;ghcup&lt;/code&gt;&lt;/a&gt; and then type &lt;code&gt;cabal repl&lt;/code&gt;. Alternatively, if you are using the &lt;a href=&#34;https://nixos.org/download.html&#34;&gt;&lt;code&gt;nix&lt;/code&gt;&lt;/a&gt; package manager, then running &lt;code&gt;nix-shell&lt;/code&gt; in the root directory should give you the right &lt;code&gt;ghc&lt;/code&gt; version and all other dependencies you might need.&lt;/p&gt; &#xA;&lt;p&gt;The literate code is transformed into markdown using &lt;a href=&#34;https://pandoc.org/&#34;&gt;&lt;code&gt;pandoc&lt;/code&gt;&lt;/a&gt; in &lt;a href=&#34;https://raw.githubusercontent.com/stevana/property-based-testing-stateful-systems-tutorial/main/tools/generate_markdown.sh&#34;&gt;&lt;code&gt;tools/generate_markdown.sh&lt;/code&gt;&lt;/a&gt; and the markdown is put inside the &lt;a href=&#34;https://raw.githubusercontent.com/stevana/property-based-testing-stateful-systems-tutorial/main/docs&#34;&gt;&lt;code&gt;docs&lt;/code&gt;&lt;/a&gt; directory for easier browsing.&lt;/p&gt; &#xA;&lt;p&gt;The following is a link to the &lt;a href=&#34;https://raw.githubusercontent.com/stevana/property-based-testing-stateful-systems-tutorial/main/docs/Part01SMTesting.md#readme&#34;&gt;first part&lt;/a&gt; of the generate markdown, at the end it will link to the second part and so on. Or you can use the table of contents above or the &lt;code&gt;docs&lt;/code&gt; directory to jump to desired part straight away.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Any feedback, suggestions for improvement or questions are most welcome via the issue tracker!&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/stevana/property-based-testing-stateful-systems-tutorial/main/.github/CONTRIBUTING.md&#34;&gt;&lt;code&gt;CONTRIBUTING.md&lt;/code&gt;&lt;/a&gt; file for more detailed guidelines regarding contributing.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/stevana/property-based-testing-stateful-systems-tutorial/main/LICENSE&#34;&gt;&lt;code&gt;LICENSE&lt;/code&gt;&lt;/a&gt; file.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>dalkire/scripts</title>
    <updated>2023-01-13T01:37:10Z</updated>
    <id>tag:github.com,2023-01-13:/dalkire/scripts</id>
    <link href="https://github.com/dalkire/scripts" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A set of miscellaneous scripts&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;scripts&lt;/h1&gt; &#xA;&lt;p&gt;A set of miscellaneous scripts&lt;/p&gt;</summary>
  </entry>
</feed>