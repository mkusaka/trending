<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-20T01:27:45Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tfausak/cabal-gild</title>
    <updated>2024-02-20T01:27:45Z</updated>
    <id>tag:github.com,2024-02-20:/tfausak/cabal-gild</id>
    <link href="https://github.com/tfausak/cabal-gild" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸ‘‘ Format Haskell package descriptions.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Gild&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tfausak/cabal-gild/actions/workflows/workflow.yaml&#34;&gt;&lt;img src=&#34;https://github.com/tfausak/cabal-gild/actions/workflows/workflow.yaml/badge.svg?sanitize=true&#34; alt=&#34;Workflow&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/cabal-gild&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/cabal-gild&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.stackage.org/package/cabal-gild&#34;&gt;&lt;img src=&#34;https://www.stackage.org/package/cabal-gild/badge/nightly?label=stackage&#34; alt=&#34;Stackage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Gild is an opinionated command line utility that formats Haskell package descriptions, which are also known as &lt;code&gt;*.cabal&lt;/code&gt; files. Gild can also be used to automatically discover &lt;code&gt;exposed-modules&lt;/code&gt;; see &lt;a href=&#34;https://raw.githubusercontent.com/tfausak/cabal-gild/main/#pragmas&#34;&gt;the pragmas section&lt;/a&gt; for more about that.&lt;/p&gt; &#xA;&lt;p&gt;To run Gild in CI, consider using &lt;a href=&#34;https://github.com/tfausak/cabal-gild-setup-action&#34;&gt;cabal-gild-setup-action&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Gild started as a fork of &lt;a href=&#34;https://github.com/phadej/cabal-fmt&#34;&gt;phadej/cabal-fmt&lt;/a&gt;, but is now totally separate. For a brief summary of the differences between Gild and &lt;code&gt;cabal-fmt&lt;/code&gt;, read &lt;a href=&#34;https://taylor.fausak.me/2024/02/17/gild/&#34;&gt;the announcement post&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Summary&lt;/h2&gt; &#xA;&lt;p&gt;Given a package description like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cabal&#34;&gt;CABAL-VERSION : 3.0&#xA;name          : example&#xA;version       : 0.0.0.0&#xA;&#xA;library&#xA;  build-depends: mtl&amp;gt;=2.3, base&#xA;  ghc-options:-Wall&#xA;  if impl(ghc&amp;gt;=9.8)&#xA;    ghc-options: -Wmissing-role-annotations&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Gild will produce output like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cabal&#34;&gt;cabal-version: 3.0&#xA;name: example&#xA;version: 0.0.0.0&#xA;&#xA;library&#xA;  build-depends:&#xA;    base,&#xA;    mtl &amp;gt;=2.3,&#xA;&#xA;  ghc-options: -Wall&#xA;&#xA;  if impl(ghc &amp;gt;= 9.8)&#xA;    ghc-options: -Wmissing-role-annotations&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/tfausak/cabal-gild/main/#installation&#34;&gt;the installation section&lt;/a&gt; for how to get Gild and &lt;a href=&#34;https://raw.githubusercontent.com/tfausak/cabal-gild/main/#usage&#34;&gt;the usage section&lt;/a&gt; for how to use it.&lt;/p&gt; &#xA;&lt;h2&gt;Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;There should be no configuration options. As long as the output format is reasonable, the specifics should not matter too much. This means the amount of indentation cannot be changed, for example.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The output should be diff friendly. This means things generally go on their own line, trailing commas are used when possible, and elements are sorted where it makes sense.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The output should be semantically the same as the input. This means no normalization or canonicalization. For example, separate &lt;code&gt;build-depends&lt;/code&gt; fields are not merged together.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;It should be possible to format other files that use the same format as package descriptions. This means &lt;code&gt;cabal.project&lt;/code&gt; files can be formatted as well.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The focus should be mostly on formatting. There should be no effort made to validate input or provide any checks or lints. However some quality of life features, like automatic module discovery, are desireable.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Formatting should be as regular as possible. Special cases for particular fields or sections should be avoided unless it improves quality of life. For example, interpreting the &lt;code&gt;build-depends&lt;/code&gt; field to pretty print it is okay.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The command line utility should be fast enough to run on every save. It should not need network access.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Go to &lt;a href=&#34;https://github.com/tfausak/cabal-gild/releases/latest&#34;&gt;the latest release page&lt;/a&gt; and download the binary for your platform.&lt;/p&gt; &#xA;&lt;h3&gt;From Source&lt;/h3&gt; &#xA;&lt;p&gt;In general you should prefer downloading the appropriate binary for you platform. However it is possible to build Gild from source. It supports Linux, macOS, and Windows along with the three most recent versions of GHC. Any other configurations are unsupported.&lt;/p&gt; &#xA;&lt;p&gt;With Cabal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cabal install cabal-gild&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With Stack:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ stack install cabal-gild&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Gild is a command line utility named &lt;code&gt;cabal-gild&lt;/code&gt;. By default it reads from standard input (STDIN) and writes to standard output (STDOUT). Its behavior can be modified with command line options, which are described below.&lt;/p&gt; &#xA;&lt;h3&gt;Options&lt;/h3&gt; &#xA;&lt;p&gt;Run &lt;code&gt;cabal-gild --help&lt;/code&gt; to see the options that Gild supports. They are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--help&lt;/code&gt;: Prints the help message to STDOUT then exits successfully.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--version&lt;/code&gt;: Prints the version number to STDOUT then exits successfully.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--input=FILE&lt;/code&gt;: Uses &lt;code&gt;FILE&lt;/code&gt; as the input. If this is &lt;code&gt;-&lt;/code&gt; (which is the default), then the input will be read from STDIN.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--mode=MODE&lt;/code&gt;: Sets the mode to &lt;code&gt;MODE&lt;/code&gt;, which must be either &lt;code&gt;format&lt;/code&gt; (the default) or &lt;code&gt;check&lt;/code&gt;. When the mode is &lt;code&gt;format&lt;/code&gt;, Gild will output the formatted package description. When the mode is &lt;code&gt;check&lt;/code&gt;, Gild will exit successfully if the input is already formatted, otherwise it will exit unsuccessfully.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--output=FILE&lt;/code&gt;: Uses &lt;code&gt;FILE&lt;/code&gt; as the output. If this is &lt;code&gt;-&lt;/code&gt; (which is the default), then the output will be written to STDOUT. To modify a file in place, use the same file as both input and output. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cabal-gild --input p.cabal --output p.cabal&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This option is ignored when the mode is &lt;code&gt;check&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--stdin=FILE&lt;/code&gt;: When reading input from STDIN, use &lt;code&gt;FILE&lt;/code&gt; as the effective input file. This is useful when a file&#39;s contents are already available, like in an editor. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cabal-gild --stdin p.cabal &amp;lt; p.cabal&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This option is ignored when the input is not &lt;code&gt;-&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Pragmas&lt;/h3&gt; &#xA;&lt;p&gt;Gild supports special comments in package descriptions that act as pragmas. Each pragma starts with &lt;code&gt;-- cabal-gild:&lt;/code&gt;. Pragmas must be the last comment before a field.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-- cabal-gild: discover DIRECTORY [DIRECTORY ...]&lt;/code&gt;: This pragma will discover any Haskell files in any of the given directories and use those to populate the list of modules or signatures. For example, given this input:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cabal&#34;&gt;library&#xA;  -- cabal-gild: discover source/library&#xA;  exposed-modules: ...&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Assuming there is a single Haskell file at &lt;code&gt;source/library/M.hs&lt;/code&gt;, Gild will produce this output:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cabal&#34;&gt;library&#xA;  -- cabal-gild: discover source/library&#xA;  exposed-modules: M&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This pragma only works with the &lt;code&gt;exposed-modules&lt;/code&gt;, &lt;code&gt;other-modules&lt;/code&gt;, and &lt;code&gt;signatures&lt;/code&gt; fields. It will be ignored on all other fields.&lt;/p&gt; &lt;p&gt;Any existing modules or signatures in the list will be ignored. The entire field (including comments) will be replaced. This means adding, removing, and renaming modules or signatures should be handled automatically.&lt;/p&gt; &lt;p&gt;This pragma searches for files with any of the following extensions: &lt;code&gt;*.chs&lt;/code&gt;, &lt;code&gt;*.cpphs&lt;/code&gt;, &lt;code&gt;*.gc&lt;/code&gt;, &lt;code&gt;*.hs&lt;/code&gt;, &lt;code&gt;*.hsc&lt;/code&gt;, &lt;code&gt;*.hsig&lt;/code&gt;, &lt;code&gt;*.lhs&lt;/code&gt;, &lt;code&gt;*.lhsig&lt;/code&gt;, &lt;code&gt;*.ly&lt;/code&gt;, &lt;code&gt;*.x&lt;/code&gt;, or &lt;code&gt;*.y&lt;/code&gt;,&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>