<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-15T01:36:20Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tweag/servant-template</title>
    <updated>2023-01-15T01:36:20Z</updated>
    <id>tag:github.com,2023-01-15:/tweag/servant-template</id>
    <link href="https://github.com/tweag/servant-template" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A modern template for a Servant&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/tweag/servant-template/actions/workflows/ci.yaml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;servant-template&lt;/h1&gt; &#xA;&lt;p&gt;A modern template for a &lt;a href=&#34;https://haskell-servant.github.io/&#34;&gt;Servant&lt;/a&gt; application.&lt;/p&gt; &#xA;&lt;h2&gt;Scope&lt;/h2&gt; &#xA;&lt;p&gt;The project aims to provide a template for a Servant project featuring:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;database interaction with &lt;a href=&#34;https://hackage.haskell.org/package/rel8&#34;&gt;rel8&lt;/a&gt;;&lt;/li&gt; &#xA; &lt;li&gt;JWT authentication with &lt;a href=&#34;https://hackage.haskell.org/package/servant-auth&#34;&gt;servant-auth&lt;/a&gt;;&lt;/li&gt; &#xA; &lt;li&gt;logging with &lt;a href=&#34;https://hackage.haskell.org/package/co-log-core&#34;&gt;co-log-core&lt;/a&gt;;&lt;/li&gt; &#xA; &lt;li&gt;TOML configuration using &lt;a href=&#34;https://hackage.haskell.org/package/tomland&#34;&gt;tomland&lt;/a&gt;;&lt;/li&gt; &#xA; &lt;li&gt;first class records in Servant API using &lt;a href=&#34;https://hackage.haskell.org/package/servant-0.19/changelog&#34;&gt;NamedRecords&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;The application&lt;/h2&gt; &#xA;&lt;p&gt;The application allows users to categorify contents by tags. Any content can have many tags and any tag could be used for several contents.&lt;/p&gt; &#xA;&lt;p&gt;It allows also to retrieve contents by a set of tags.&lt;/p&gt; &#xA;&lt;h3&gt;Architecture&lt;/h3&gt; &#xA;&lt;p&gt;A more in depth description of the architecture of the application can be found in &lt;a href=&#34;https://raw.githubusercontent.com/tweag/servant-template/main/ARCHITECTURE.md&#34;&gt;ARCHITECTURE.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;Configuration of the application is managed using &lt;a href=&#34;https://toml.io&#34;&gt;TOML&lt;/a&gt;. The application requires a configuration file with the following format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[database]&#xA;  host     = &#34;localhost&#34;&#xA;  port     = 5432&#xA;  dbname   = &#34;tagger-db&#34;&#xA;  user     = &#34;tagger-user&#34;&#xA;  password = &#34;tagger-pwd&#34;&#xA;&#xA;[api]&#xA;  port = 8080&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the file is located in &lt;code&gt;config.toml&lt;/code&gt;, but the path is actually configurable with the &lt;code&gt;config&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;h3&gt;Authentication&lt;/h3&gt; &#xA;&lt;p&gt;The main endpoints of the application are protected by JWT authentication. To access them you first need to get an authorization token for a user.&lt;/p&gt; &#xA;&lt;p&gt;To get it you first need to register a user by calling the &lt;code&gt;register&lt;/code&gt; endpoint.&lt;/p&gt; &#xA;&lt;p&gt;Next, you can obtain a token by calling the &lt;code&gt;login&lt;/code&gt; endpoint with the same data provided to the register endpoint.&lt;/p&gt; &#xA;&lt;p&gt;Eventually, you should pass your token in the &lt;code&gt;Authorization&lt;/code&gt; header for the relevant endpoints to access them.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;The project is setup to be built with &lt;a href=&#34;https://docs.haskellstack.org/en/stable/README/&#34;&gt;Stack&lt;/a&gt;, though it is also possible to build via &lt;a href=&#34;https://nixos.org/&#34;&gt;Nix&lt;/a&gt;. Convenience scripts are provided (under the &lt;code&gt;bin/&lt;/code&gt; directory) to manage the lifecycle of the application. These scripts try to use Nix if it is available, and fall back to using Stack directly otherwise. The scripts are completely optional, and direct invocations of stack commands (e.g. &lt;code&gt;stack build&lt;/code&gt;, &lt;code&gt;stack test&lt;/code&gt;, etc.) is also valid.&lt;/p&gt; &#xA;&lt;p&gt;In summary, there are three equally valid ways of interacting with the project depending on your setup:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using the higher-level convenience scripts (&lt;code&gt;bin/api/serve&lt;/code&gt;, &lt;code&gt;bin/frontend/build&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Through the nix-shell (using &lt;code&gt;nix-shell --run &#39;stack&#39;&lt;/code&gt; and &lt;code&gt;nix-shell --run &#39;elm make ...&#39;&lt;/code&gt; and letting &lt;code&gt;nix&lt;/code&gt; take care of making the dependencies available)&lt;/li&gt; &#xA; &lt;li&gt;Directly (using your environment&#39;s &lt;code&gt;stack&lt;/code&gt; and &lt;code&gt;elm&lt;/code&gt; commands)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;span&gt;‚Ñπ&lt;/span&gt; If &lt;code&gt;direnv&lt;/code&gt; is installed, it is also possible to use it with &lt;code&gt;nix&lt;/code&gt;. The provided &lt;code&gt;.envrc&lt;/code&gt; file is already configured to use &lt;code&gt;nix&lt;/code&gt; and only needs to be enabled by issuing &lt;code&gt;direnv allow&lt;/code&gt; in the project root once.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Setup&lt;/h3&gt; &#xA;&lt;p&gt;There are a few ways to setup the project and its dependencies, outlined below.&lt;/p&gt; &#xA;&lt;h4&gt;With nix&lt;/h4&gt; &#xA;&lt;p&gt;Setting up the runtime dependencies for development, such as the database, is taken care of by the &lt;code&gt;bin/setup&lt;/code&gt; script. This calls individual components&#39; setup scripts such as &lt;code&gt;bin/db/setup&lt;/code&gt; under the hood, if you prefer to call it directly without using &lt;code&gt;nix&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Without nix&lt;/h4&gt; &#xA;&lt;p&gt;Alternatively, there is a setup script in &lt;code&gt;bin/db/setup&lt;/code&gt; that will create a database, user and load the schema required for a working development environment. This script assumes the existence of few packages (&lt;code&gt;toml2json&lt;/code&gt;, &lt;code&gt;jq&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, etc.).&lt;/p&gt; &#xA;&lt;h4&gt;With docker&lt;/h4&gt; &#xA;&lt;p&gt;In the root of the project you can find a &lt;code&gt;docker-compose.yml&lt;/code&gt; file which provides a Postgresql database and a web interface to it, exposed on port &lt;code&gt;8081&lt;/code&gt;. You can initialise the schema of the database by running the &lt;code&gt;schema.sql&lt;/code&gt; which is also provided.&lt;/p&gt; &#xA;&lt;h3&gt;Building the API&lt;/h3&gt; &#xA;&lt;p&gt;To build the API, run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# With convenience script&#xA;bin/api/build&#xA;&#xA;# With nix&#xA;nix-shell --run &#39;stack build&#39;&#xA;&#xA;# With stack&#xA;stack build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;span&gt;‚Ñπ&lt;/span&gt; The convenience script forwards options/flags to &lt;code&gt;stack build&lt;/code&gt;, so it could be run as &lt;code&gt;bin/api/build --file-watch&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;span&gt;‚ö†&lt;/span&gt; Note for non-nix users: the build requires the presence of the &lt;code&gt;pg_config&lt;/code&gt; executable which is made available by installing Postgresql. Nix would take care of this automatically.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Serving the API for development&lt;/h3&gt; &#xA;&lt;p&gt;You can launch the web server using&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# With convenience script (with hot-reloading enabled)&#xA;bin/api/serve&#xA;&#xA;# With nix&#xA;nix-shell --run &#39;stack exec servant-template-exe&#39;&#xA;&#xA;# With stack (without hot-reloading)&#xA;stack exec servant-template-exe&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Running the API tests&lt;/h3&gt; &#xA;&lt;p&gt;To run the tests, run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# With convenience script&#xA;bin/api/test&#xA;&#xA;# With nix&#xA;nix-shell --run &#39;stack test&#39;&#xA;&#xA;# With Stack&#xA;stack test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which will expose the service on port defined in configuration.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;span&gt;‚ö†&lt;/span&gt; Note for non-nix users: serving the API with hot-reloading requires the presence of the &lt;code&gt;watchexec&lt;/code&gt; utility which is made available by the nix shell. Install it manually if you wish to use this script.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The executable accepts two options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--config&lt;/code&gt;, which allows to customize the path of the configuration file&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--jwk&lt;/code&gt;, which allows to customize the path of the file where the JWK is stored&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Formatting&lt;/h3&gt; &#xA;&lt;p&gt;The Haskell files are formatted using &lt;code&gt;ormolu&lt;/code&gt;. The Elm source code is formatted using &lt;code&gt;elm-format&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There is a script to format all files in the codebase (Elm and Haskell) under &lt;code&gt;bin/format&lt;/code&gt;. Individual projects can be formatted separately with &lt;code&gt;bin/api/format&lt;/code&gt; and &lt;code&gt;bin/frontend/format&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;You can generate the documentation of the project using&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# With convenience script&#xA;bin/api/docs&#xA;&#xA;# With nix&#xA;nix-shell --run &#39;stack haddock&#39;&#xA;&#xA;# With Stack&#xA;stack haddock&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;OpenApi documentation&lt;/h3&gt; &#xA;&lt;p&gt;You can access the OpenAPI documentation just by visiting the &lt;code&gt;docs&lt;/code&gt; endpoint (by default &lt;a href=&#34;http://localhost:8080/docs&#34;&gt;http://localhost:8080/docs&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;h2&gt;Frontend&lt;/h2&gt; &#xA;&lt;p&gt;This repository contains also a client &lt;a href=&#34;https://elm-lang.org/&#34;&gt;Elm&lt;/a&gt; application to interact in a human-friendly way with the Tagger api.&lt;/p&gt; &#xA;&lt;p&gt;You can find more details in &lt;a href=&#34;https://raw.githubusercontent.com/tweag/servant-template/main/elm/README.md&#34;&gt;elm/README.md&lt;/a&gt;, but there are convenience commands:&lt;/p&gt; &#xA;&lt;h3&gt;Building the project&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# With convenience script&#xA;bin/frontend/build&#xA;&#xA;# With nix&#xA;nix-shell --run &#39;cd elm; elm make src/Main.elm&#39;&#xA;&#xA;# With npm&#xA;cd elm; npx elm make src/Main.elm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Serve project for development&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# With convenience script&#xA;bin/frontend/serve&#xA;&#xA;# With nix&#xA;nix-shell --run &#39;cd elm; elm-live src/Main.elm&#39;&#xA;&#xA;# With npm&#xA;cd elm; npx elm-live src/Main.elm&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>reubenharry/haskell-docs</title>
    <updated>2023-01-15T01:36:20Z</updated>
    <id>tag:github.com,2023-01-15:/reubenharry/haskell-docs</id>
    <link href="https://github.com/reubenharry/haskell-docs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;strong&gt;Under &lt;span&gt;üöß&lt;/span&gt; !!&lt;/strong&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;Introduction to Haskell&lt;/h1&gt; &#xA;&lt;p&gt;This is the github repository for &lt;a href=&#34;https://haskell-docs.netlify.app/&#34;&gt;an introductory guide to learning Haskell&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re interested in making contribution to the guide, see &lt;a href=&#34;https://raw.githubusercontent.com/reubenharry/haskell-docs/main/Contributing.md&#34;&gt;here&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Goals&lt;/h2&gt; &#xA;&lt;p&gt;The goal for this project is that it serves as a go-to resource for newcomers who have programming experience in a language like Python. It should contain all the information needed to write basic Haskell (roughly the content of &#34;Learn You a Haskell&#34;), but in the style of a reference guide.&lt;/p&gt; &#xA;&lt;p&gt;With that in mind, it should be:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;free and online&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;maintainable&lt;/strong&gt;: mostly just markdown, easy for anyone to update via a PR&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;commentable&lt;/strong&gt;: easy for a reader to provide feedback where they don&#39;t understand&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ergonomic&lt;/strong&gt;: pleasing to look at and use, good search, easy navigation&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;friendly&lt;/strong&gt;: clear usage examples of code, FAQs and gotchas, pointers to other resources, unambiguous set up instructions for Haskell, contains an example project with best practices&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;concise but not too concise&lt;/strong&gt;: avoids long prose where possible&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;Mkdocs Material&lt;/code&gt; is a great platform for these goals. It&#39;s very easy to maintain (click Edit icon on any page to submit PR), is designed to look nice and display information well (info boxes, code comments, tabs and search for navigation), and it can be connected to Google Analytics to allow users to write feedback where they get stuck.&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s wrong with existing resources?&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;   &lt;th&gt;Wiki&lt;/th&gt; &#xA;   &lt;th&gt;LYAH&lt;/th&gt; &#xA;   &lt;th&gt;RWH&lt;/th&gt; &#xA;   &lt;th&gt;LHBG&lt;/th&gt; &#xA;   &lt;th&gt;These Docs&lt;/th&gt; &#xA;   &lt;th&gt;Various Books&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Free&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Community editable&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;üìå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Beginner friendy&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Up-to-date&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Looks nice&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Supports comments&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úÖ&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;There are many great resources, but:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;many are out of date and are hard to update&lt;/li&gt; &#xA; &lt;li&gt;many are not free&lt;/li&gt; &#xA; &lt;li&gt;many are not online&lt;/li&gt; &#xA; &lt;li&gt;most are long-form books or lecture notes, not a concise &#34;cheatsheet&#34;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Of these, the first is the most important: making an &lt;em&gt;OK&lt;/em&gt; intro guide to Haskell that is very easy for many people to continuously improve, edit and maintain, and which is easy to collect user feedback about, seems preferable to making a really good intro guide which will never be edited, improved or maintained.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>juretta/spy</title>
    <updated>2023-01-15T01:36:20Z</updated>
    <id>tag:github.com,2023-01-15:/juretta/spy</id>
    <link href="https://github.com/juretta/spy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Spy is a compact file system watcher for Mac OS X, Linux and Windows&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Spy&lt;/h1&gt; &#xA;&lt;p&gt;Spy is a compact file system watcher for Mac OS X and Linux (Note: Should work on Windows but is currently untested).&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;Spy expects a single argument, the directory or a single file to watch. Spy currently supports two different modes: watch and run mode.&lt;/p&gt; &#xA;&lt;h2&gt;Watch mode&lt;/h2&gt; &#xA;&lt;p&gt;In output mode Spy will print the path to a modified file to STDOUT (followed by a newline) whenever a file modification (new file added, file modified, file deleted) occurs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$&amp;gt; spy watch .&#xA;path/to/modified/file&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because watch is the default mode you can omit the &lt;code&gt;watch&lt;/code&gt; command if you want:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$&amp;gt; spy .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s possible to watch a single file (this obviously only shows changes to that particular file):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$&amp;gt; spy /path/to/file&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default format is the full path to the modified file followed by a newline. To make it easier to parse the output, the &lt;code&gt;--format=json&lt;/code&gt; changes the output to be printed formatted as a JSON object (again followed by a newline).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$&amp;gt; spy watch --format=json .&#xA;{&#34;path&#34;:&#34;/path/to/modified.file&#34;,&#34;flag&#34;:&#34;Added&#34;,&#34;time&#34;:&#34;2012-12-20 11:26:56.859456 UTC&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Flag is one of &#34;Added&#34;, &#34;Modified&#34;, &#34;Removed&#34;.&lt;/p&gt; &#xA;&lt;p&gt;For directories the following options apply:&lt;/p&gt; &#xA;&lt;p&gt;An optional second argument can be used to filter the files in the given directory using a glob pattern:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$&amp;gt; spy watch /path/to/directory &#34;*.md&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Run mode&lt;/h2&gt; &#xA;&lt;p&gt;In run mode Spy will execute a given command whenever a file modification occurs without printing modifications to stdout. The command will be executed with the path to the modified file as the last argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$&amp;gt; spy run &#34;./run-build.sh&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the example above the shell script &lt;code&gt;run-build.sh&lt;/code&gt; would be executed with the path to the modified file as the first argument.&lt;/p&gt; &#xA;&lt;p&gt;If the command to be executed does not expect any (additional) arguments the &lt;code&gt;--notify-only&lt;/code&gt; flag can be used. This will cause spy to execute the command without passing the path as an argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$&amp;gt; spy run --notify-only &#34;rake test&#34; .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To compile Spy for example use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$&amp;gt; spy run -n &#34;cabal build&#34; src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;h2&gt;Binary distribution&lt;/h2&gt; &#xA;&lt;p&gt;The binary distribution contains a 64bit binary compiled for Mac OS X or Linux.&lt;/p&gt; &#xA;&lt;p&gt;Download the tarball from &lt;a href=&#34;https://bitbucket.org/ssaasen/spy/downloads&#34;&gt;https://bitbucket.org/ssaasen/spy/downloads&lt;/a&gt; and run &#34;make install&#34; to copy the binary and the man page into the correct target directories:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$&amp;gt; curl -OL https://bitbucket.org/ssaasen/spy/downloads/spy-PLATFORM-ARCH-VERSION.tar.gz&#xA;$&amp;gt; tar xfz spy-PLATFORM-ARCH-VERSION.tar.gz&#xA;$&amp;gt; cd spy&#xA;$&amp;gt; make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The user manual should now be available via &lt;code&gt;man spy&lt;/code&gt; and the &lt;code&gt;spy&lt;/code&gt; executable should be on your &lt;code&gt;$PATH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Source distribution&lt;/h2&gt; &#xA;&lt;p&gt;You need the Haskell platform installed and cabal-install available on your $PATH.&lt;/p&gt; &#xA;&lt;p&gt;To install spy from hackage simply run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$&amp;gt; cabal install spy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Done!&lt;/p&gt; &#xA;&lt;p&gt;To install spy from git you need the Haskell platform installed and cabal-install available on your $PATH:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$&amp;gt; git@bitbucket.org:ssaasen/spy.git&#xA;$&amp;gt; cd spy&#xA;$&amp;gt; cabal install --only-dependencies&#xA;$&amp;gt; cabal configure&#xA;$&amp;gt; cabal build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create the spy binary in the ./dist/build/spy directory.&lt;/p&gt; &#xA;&lt;p&gt;To copy the spy binary to the cabal bin directory (which should be available on your PATH) use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$&amp;gt; cabal copy&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>