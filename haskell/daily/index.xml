<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-28T01:34:34Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>lsmor/snake-fury</title>
    <updated>2022-10-28T01:34:34Z</updated>
    <id>tag:github.com,2022-10-28:/lsmor/snake-fury</id>
    <link href="https://github.com/lsmor/snake-fury" rel="alternate"></link>
    <summary type="html">&lt;p&gt;a challenge for Haskell beginners&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;snake-fury&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#snake-fury&#34;&gt;snake-fury&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#introduction&#34;&gt;Introduction&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#note-about-not-using-monads&#34;&gt;note about not using monads&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#start-coding-building-a-mvp&#34;&gt;Start coding. Building a MVP&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#on-using-vscode&#34;&gt;On using vscode&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#refactors&#34;&gt;Refactors&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#solution-branches&#34;&gt;Solution branches&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#building-and-running&#34;&gt;Building and Running&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#architecture&#34;&gt;Architecture&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#set-up-a-development-environment&#34;&gt;Set up a development environment&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#contributions&#34;&gt;Contributions&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitpod.io/#https://github.com/lsmor/snake-fury&#34;&gt;&lt;img src=&#34;https://gitpod.io/button/open-in-gitpod.svg?sanitize=true&#34; alt=&#34;Open in Gitpod&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Welcome to snake-fury&lt;/strong&gt;: the Haskell challenge for beginners. This challenge aims to provide a learning path for people willing to learn Haskell further than basic recursion exercises by implementing the snake game in Haskell. Snake-fury&#39;s pedagogical approach is based on two legs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;snake-fury isn&#39;t a tutorial but a challenge.&lt;/li&gt; &#xA; &lt;li&gt;snake-fury is focused on learning by refactoring, not by example.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The first leg means that you&#39;ll be asked to implement some functions/algorithms. It is expected that the challenger will be unable to implement them without some research on Hackage&#39;s documentation, blogs, youtube videos, etc. There will be guidelines to help the challenger. Nevertheless, an important skill when learning Haskell is to be able to search, read and understand the documentation that is (often, but not always) more complex and less accessible than other programming languages.&lt;/p&gt; &#xA;&lt;p&gt;The second leg is even more interesting. Haskell is notoriously known for its difficulty and the popularization of the holy triad: Functor - Applicative - Monad. There are plenty of tutorials showing examples and hundreds of thousands of lines trying to make them accessible and newcomer-friendly... But with all due respect, It seems they all fail to explain: &#34;Why monads? Why not other less mathematical abstraction? Why not classic OOP patterns?&#34;. The approach given by snake-fury is to make the same application twice... it sounds crazy, but the idea goes like this: You&#39;ll implement a &#34;pure&#34; version of the snake game: No monads, no functors, no abstractions [&lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#note-about-not-using-monads&#34;&gt;see below&lt;/a&gt;]. Then you will refactor the core application logic using the state and reader monads. Then you&#39;ll be asked to abstract your code and to use &lt;code&gt;mtl&lt;/code&gt; classes to make your code less dependent on the concrete implementation.&lt;/p&gt; &#xA;&lt;p&gt;Below there is a dramatization of Haskell&#39;s learning curve. This challenge aims to be a helpful companion from the newby slope to the temple of oblivion... but be aware, nothing will save you from the temptation of abandon. Hopefully, you&#39;ll be able to climb up to the temple and spread the lambdas&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/assets/Haskell_learning_curve.png&#34; alt=&#34;dramatization of Haskell&#39;s learning curve&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;note about not using monads&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;By that I mean, not using do notation nor functor/applicative/monads combinators like &lt;code&gt;liftA2&lt;/code&gt;, &lt;code&gt;fmap&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, etc... Obviously, The IO and the asynchronous part of the code are provided and the challenger is not expected to solve it.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Start coding. Building a MVP&lt;/h2&gt; &#xA;&lt;p&gt;Be sure you have a haskell developement environment &lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#set-up-a-development-environment&#34;&gt;up and running&lt;/a&gt;. If you don&#39;t want to install Haskell&#39;s toolchain yourself, you can use gitpod to quickly jump into an online environment.&lt;/p&gt; &#xA;&lt;p&gt;Clone the code and move to &lt;code&gt;snake-fury-exercise&lt;/code&gt; branch&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/lsmor/snake-fury.git&#xA;git checkout snake-fury-exercise&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I&#39;d recommend to create a branch for your solution (ex: &lt;code&gt;git checkout -b my-solution&lt;/code&gt;) but you can use &lt;code&gt;snake-fury-exercise&lt;/code&gt;. You should see this folder structure (among other files)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;app&#xA; |- Main.hs            # Here is the entrypoint of your application. This is implemented for you&#xA;src&#xA; |- EventQueue.hs      # Here is the EventQueue. This is implemented for you&#xA; |- GameState.hs       # here will go the logic of the game. You have to complete this file&#xA; |- RenderState.hs     # here will go the data structure for rendering the game. You have to complete this file&#xA; |- Initialization.hs  # some utility functions. You don&#39;t need to touch this file.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Open files &lt;code&gt;src/GameState.hs&lt;/code&gt; and &lt;code&gt;src/RenderState.hs&lt;/code&gt;. You&#39;ll find the exercises statements as comments.&lt;/p&gt; &#xA;&lt;p&gt;Each file correspond to each component in the system (and some utilities to keep code simpler). Be sure you read the about the &lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#architecture&#34;&gt;architecture&lt;/a&gt; to understand why the code is splitted this way. Notice that you&#39;ll need to implement as many auxiliar functions as you need to make it work. If you feel stuck you can check the &lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#solution-branches&#34;&gt;solution&lt;/a&gt; I&#39;ve implemented. It is totally fine if you implement a different one.&lt;/p&gt; &#xA;&lt;p&gt;Once you fill &lt;code&gt;GameState.hs&lt;/code&gt; and &lt;code&gt;RenderState.hs&lt;/code&gt; you should be able to run the snake game in a terminal with the following command &lt;code&gt;cabal run snake-fury -- height width fps&lt;/code&gt;. Use arrow keys to move the snake.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/assets/snake-mvp.gif&#34; alt=&#34;example of running&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;On using vscode&lt;/h3&gt; &#xA;&lt;p&gt;If you have configured well your vscode you should be able to run in-comment examples. If you can&#39;t, something has gone wrong. Be sure you&#39;ve followed the &lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#set-up-a-development-environment&#34;&gt;instructions&lt;/a&gt;. Below there is an example of what you should see.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/assets/example-inline-test.gif&#34; alt=&#34;example of in-comment test&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Refactors&lt;/h2&gt; &#xA;&lt;p&gt;You&#39;ve built a minimum viable product. Now it is time to improve it!. In the &lt;code&gt;exercises&lt;/code&gt; folder you have intructions for refactoring. Follow them one by one as enumerated. One of the ideas is you feel the power of the type system when refactoring. Also you&#39;ll be dealing with poor design choices implemented in the mpv part.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;refactor-1&lt;/strong&gt;: you will move from you mvp to a full snake game with all the functionality: like a score counter and increasing speed. Also, you&#39;ll deal with performance issue the mvp has.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;refactor-2&lt;/strong&gt;: you will refactor the logic of the game to use the state monad. Hopefully you&#39;ll find code much easier to read.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;refactor-3&lt;/strong&gt;: you will refactor the logic of the game to use the reader + state monad stack. Also, as an optional but recommended exercise, you can learn about the IO monad&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;refactor-4&lt;/strong&gt;: You will refactor the code to use &lt;code&gt;mtl&lt;/code&gt; like constraints. Now code looks a little bit abstract but it is easy to read and follow&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;refactor-5&lt;/strong&gt;: Finally, you&#39;ll refactor the code to be fully abstracted over the monad stack you use. You will create you own type classes expressing exactly the actions you want to execute.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Solution branches&lt;/h2&gt; &#xA;&lt;p&gt;You have multiple solutions branches, one for each refactor step and one for the mvp. Below you have the relation of branches and refactors. You can run &lt;code&gt;git branch -l&lt;/code&gt; to see the list of all branches.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;solution-mvp&lt;/code&gt; branch corresponds to the solution of the first exercise&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;solution-refactor-1&lt;/code&gt; branch corresponds to the solution of the first refactor in &lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/exercises/refactor-1.md&#34;&gt;exercises/refactor-1&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;solution-refactor-2.1&lt;/code&gt; branch corresponds to the solution of the second refactor, step 1 in &lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/exercises/refactor-2.md#step-1-apply-changes-locally&#34;&gt;exercises/refactor-2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;solution-refactor-2.2&lt;/code&gt; branch corresponds to the solution of the second refactor, step 2 in &lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/exercises/refactor-2.md#step-2-did-you-spot-the-pattern-thats-a-monad&#34;&gt;exercises/refactor-2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;solution-refactor-3&lt;/code&gt; branch corresponds to the solution of the third refactor in &lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/exercises/refactor-3.md&#34;&gt;exercises/refactor-3&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;solution-refactor-4.1&lt;/code&gt; branch corresponds to the solution of the fourth refactor, step 1 in &lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/exercises/refactor-4.md#step-1-mtl-constraints&#34;&gt;exercises/refactor-4&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;solution-refactor-4.2&lt;/code&gt; branch corresponds to the solution of the fourth refactor, step 2 in &lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/exercises/refactor-4.md#step-2-glue-together-renderstate-and-gamestate&#34;&gt;exercises/refactor-4&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;solution-refactor-5&lt;/code&gt; branch corresponds to the solution of the fifth refactor in &lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/exercises/refactor-5.md&#34;&gt;exercises/refactor-5&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;My solution might be different than yours, and that is totally fine.&lt;/p&gt; &#xA;&lt;h2&gt;Building and Running&lt;/h2&gt; &#xA;&lt;p&gt;This project is prepare for both &lt;code&gt;cabal&lt;/code&gt; and &lt;code&gt;stack&lt;/code&gt;. At the moment the only major difference between this tools is the building plan. If you are a newcommer, you&#39;ll find &lt;code&gt;stack&lt;/code&gt; slightly easier to use, but cabal is also fairly easy. Even if you are using &lt;code&gt;stack&lt;/code&gt; this repository wont allow it to install &lt;code&gt;ghc&lt;/code&gt;, you need to have it installed in your &lt;code&gt;PATH&lt;/code&gt;. Check &lt;a href=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/#set-up-a-development-environment&#34;&gt;this&lt;/a&gt; section for more information.&lt;/p&gt; &#xA;&lt;p&gt;Notice the &lt;code&gt;main&lt;/code&gt; branch is experimental and can change (even into a non-compilable code), so don&#39;t use it to build the project. For stable branches, use &lt;code&gt;solution-xxx&lt;/code&gt;. To run the executable, you have to build first with either &lt;code&gt;cabal&lt;/code&gt; or &lt;code&gt;stack&lt;/code&gt; using.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout solution-xxx&#xA;&#xA;# cabal users&#xA;cabal build&#xA;&#xA;# stack users&#xA;stack build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run it, you have to pass the height, width and fps (consider playing in a range from 5 to 15 fps)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# cabal users. 7 fps is a normal speed for snake game&#xA;cabal run snake-fury -- 10 10 7&#xA;&#xA;# stack users. 7 fps is a normal speed for snake game&#xA;stack run snake-fury -- 10 10 7&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;note: At the moment the &lt;code&gt;main&lt;/code&gt; branch doesn&#39;t use frames per second but microseconds as input parameter. Hence &lt;code&gt;cabal run snake-fury -- 10 10 100000&lt;/code&gt; will run at 10 fps. In the exercise branch, the input parameter is correct. So if you want to build from &lt;code&gt;main&lt;/code&gt; be aware of this change&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Architecture&lt;/h2&gt; &#xA;&lt;p&gt;The general architecture of the software is the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;There are three major components: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;An Event Queue: It keeps a queue of the following events to happen in the game based on the user keyboard input&lt;/li&gt; &#xA;   &lt;li&gt;A Game State: Is the logic state. It keeps track on the snake body, the current apple, the direction of movement, etc...&lt;/li&gt; &#xA;   &lt;li&gt;A Render State: Is the game board. Instead of building up the board from the GameState, we keep an array in memory and modify it as convenient&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Each compoment send a message to the next one in the following order: (user keyboard) -&amp;gt; EventQueue -&amp;gt; GameState -&amp;gt; RenderState -&amp;gt; (render device)&lt;/li&gt; &#xA; &lt;li&gt;we have two threads. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The sencondary thread is continuously reading from users keyboard and pushing the key strokes into an asynchronous EventQueue&lt;/li&gt; &#xA;   &lt;li&gt;The main thread reads at steady time from the EventQueue, and based on what the user has pressed, it runs the game logic and prints the board in the console&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Notice that two threads are necessary, since user could press keys faster than the game updates (fps). For example let say we run a frame each second and a half (normal speed in the snake game.), then a user is likely to press keys faster than that. If the key strokes are catch only when a frame is about to be render, then many stroke will be lost.&lt;/p&gt; &#xA;&lt;p&gt;The following diagram helps to visualize&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lsmor/snake-fury/main/assets/snake_architecture.png&#34; alt=&#34;Overview of the architecture&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Set up a development environment&lt;/h2&gt; &#xA;&lt;p&gt;I strongly recommend to use &lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;ghcup&lt;/a&gt; to manage your Haskell toolchain. And vscode as your editor. A local development environment can be setted up in three steps. &lt;a href=&#34;https://gist.github.com/lsmor/bb632565cd96be9da589b6e91f80f9ba&#34;&gt;Check this guide&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributions&lt;/h2&gt; &#xA;&lt;p&gt;If you find something poorly explained or too difficult to follow. Feel free to open an issue.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tweag/haskell-training</title>
    <updated>2022-10-28T01:34:34Z</updated>
    <id>tag:github.com,2022-10-28:/tweag/haskell-training</id>
    <link href="https://github.com/tweag/haskell-training" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Material for Haskell training&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tweag/haskell-training/main/images/tweag.png&#34; alt=&#34;Tweag logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;haskell-training&lt;/h1&gt; &#xA;&lt;p&gt;Material for a Haskell training course&lt;/p&gt; &#xA;&lt;h2&gt;Haskell at work&lt;/h2&gt; &#xA;&lt;p&gt;The course proposes a practical approach to Haskell, a statically typed purely functional programming language. The course develops around the creation and evolution of a concrete project, highlighting where Haskell can help us to create a safe and maintainable application. It will contain the necessary theory and a lot of practice.&lt;/p&gt; &#xA;&lt;p&gt;The course will introduce some more advanced concepts (e.g. type-level programming with Servant) but it would focus mostly on the day-to-day aspects of the language, which allow a programmer to become productive sooner.&lt;/p&gt; &#xA;&lt;p&gt;Everything will be developed with the good practices of software engineering in mind.&lt;/p&gt; &#xA;&lt;h3&gt;Principles&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;create a practical application which resembles what people could do at work;&lt;/li&gt; &#xA; &lt;li&gt;try not to over-abstract before it is needed;&lt;/li&gt; &#xA; &lt;li&gt;introduce concepts only when they solve an issue (see &lt;a href=&#34;https://mkremins.github.io/blog/doors-headaches-intellectual-need/&#34;&gt;https://mkremins.github.io/blog/doors-headaches-intellectual-need/&lt;/a&gt;);&lt;/li&gt; &#xA; &lt;li&gt;introduce concepts one by one;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Objectives&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;give the participants the feeling of how it is to work with Haskell&lt;/li&gt; &#xA; &lt;li&gt;teach them the basics of Haskell development and how to solve practical problems&lt;/li&gt; &#xA; &lt;li&gt;teach correct and precise data modelling using types&lt;/li&gt; &#xA; &lt;li&gt;show them the best features of Haskell&lt;/li&gt; &#xA; &lt;li&gt;provide directions on how to develop a real-world project&lt;/li&gt; &#xA; &lt;li&gt;discuss shortcomings/limitations of the language&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Target&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;professional developers&lt;/li&gt; &#xA; &lt;li&gt;already experienced with some other programming language&lt;/li&gt; &#xA; &lt;li&gt;possibly willing to use Haskell or FP concepts at work&lt;/li&gt; &#xA; &lt;li&gt;interested in why Haskell is a good language for the industry&lt;/li&gt; &#xA; &lt;li&gt;interested also in the practicalities&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Buyers&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;single developers who want to get a practical approach to Haskell&lt;/li&gt; &#xA; &lt;li&gt;companies interested in starting using Haskell&lt;/li&gt; &#xA; &lt;li&gt;companies using Haskell wanting to train their junior developers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a bit of software engineering experience &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;knowledge of what is required for a production system&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;already felt the pains of mutation and side effects management&lt;/li&gt; &#xA; &lt;li&gt;some experience in other languages with basic FP concepts such as immutability and higher-order functions&lt;/li&gt; &#xA; &lt;li&gt;basic Haskell syntax&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Project&lt;/h3&gt; &#xA;&lt;p&gt;The course will unroll developing a simplified clone of a questionnaire app like Google Forms or Typeform.&lt;/p&gt; &#xA;&lt;p&gt;It adapts well to the principles we stated above since:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;it is extremely practical and concrete&lt;/li&gt; &#xA; &lt;li&gt;allows to be modelled in simple way which still highlights the usage of algebraic data types&lt;/li&gt; &#xA; &lt;li&gt;requires user interaction&lt;/li&gt; &#xA; &lt;li&gt;requires persistence&lt;/li&gt; &#xA; &lt;li&gt;requires definition of a web API&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Outline&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Chapter 1: Basic domain definition and terminal interaction &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Haskell syntax and basic terminology&lt;/li&gt; &#xA;   &lt;li&gt;the value of types and purity&lt;/li&gt; &#xA;   &lt;li&gt;IO and side-effects&lt;/li&gt; &#xA;   &lt;li&gt;Chapter 2: Domain refinement and exposing a web API with Servant &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;defining a domain model guided by types&lt;/li&gt; &#xA;     &lt;li&gt;defining a web API specification using types&lt;/li&gt; &#xA;     &lt;li&gt;how to isolate the domain layer from persistence&lt;/li&gt; &#xA;     &lt;li&gt;functors and applicatives&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Chapter 3: Adding persistence with PostgreSQL &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;describing a database schema in Haskell&lt;/li&gt; &#xA;     &lt;li&gt;writing composable queries&lt;/li&gt; &#xA;     &lt;li&gt;monads and monad transformers&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Chapter 4: Testing and tooling &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;the easiness of writing unit tests&lt;/li&gt; &#xA;     &lt;li&gt;property based testing&lt;/li&gt; &#xA;     &lt;li&gt;doctests&lt;/li&gt; &#xA;     &lt;li&gt;mocks&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Bonus chapter: Advanced type safety (to solve a concrete modelling problem) &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;GADTs&lt;/li&gt; &#xA;     &lt;li&gt;RankNTypes&lt;/li&gt; &#xA;     &lt;li&gt;Existential types&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Length&lt;/h3&gt; &#xA;&lt;p&gt;The basic version of the course, without the bonus chapters, should take around two days, split in four chapters of ~ 4 hours each.&lt;/p&gt; &#xA;&lt;p&gt;It could be enlarged to 3 days (6 chapters of ~ 4 hours each) adding the two bonus chapters&lt;/p&gt;</summary>
  </entry>
</feed>