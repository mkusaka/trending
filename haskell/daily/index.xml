<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-14T01:35:15Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>channable/icepeak</title>
    <updated>2023-03-14T01:35:15Z</updated>
    <id>tag:github.com,2023-03-14:/channable/icepeak</id>
    <link href="https://github.com/channable/icepeak" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Icepeak is a fast JSON document store with push notification support.&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/channable/icepeak&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/channable/icepeak/master/docs/icepeak.png&#34; alt=&#34;Icepeak&#34; width=&#34;256&#34;&gt;&lt;/a&gt; &lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://channable.semaphoreci.com/projects/icepeak&#34;&gt;&lt;img src=&#34;https://channable.semaphoreci.com/badges/icepeak/branches/master.svg?style=shields&amp;amp;key=a0e7e842-7ce9-4c10-aea6-3c7dce768470&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Icepeak is a fast JSON document store with push notification support.&lt;/p&gt; &#xA;&lt;p&gt;Icepeak has an HTTP API that can be used to both read and write data. It also has a websocket interface that clients can use to get push updates about data that changed.&lt;/p&gt; &#xA;&lt;p&gt;Clients can subscribe to specific paths in the JSON document like e.g. &lt;code&gt;/users/123/status&lt;/code&gt; via the websocket-based API and they will get a push update whenever any of the JSON data below this path changes.&lt;/p&gt; &#xA;&lt;p&gt;If a client subscribes to the document root &lt;code&gt;/&lt;/code&gt; they will receive &lt;em&gt;all&lt;/em&gt; updates.&lt;/p&gt; &#xA;&lt;p&gt;Icepeak supports JWT-based authorization. JWT claims can be used to restrict the prefixes in the JSON document that a client can read or write. See &lt;a href=&#34;https://raw.githubusercontent.com/channable/icepeak/master/#jwt-authorization&#34;&gt;JWT Authorization&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/channable/icepeak/master/server/integration-tests/read_after_write_test.py&#34;&gt;read_after_write_test.py&lt;/a&gt; for a simple example that PUTs some data via the HTTP API and then retrieves it again over a websocket connection.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/channable/icepeak/master/server/integration-tests/listener.html&#34;&gt;listener.html&lt;/a&gt; for a Javascript-based example of a websocket listener.&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;Icepeak has been used in production by Channable since October 2017. It has been performing very well and there are no known issues at this point. Note, that our use case is for non-critical data in a small database.&lt;/p&gt; &#xA;&lt;p&gt;While Icepeak has been working flawlessly, we still consider it beta-quality at this point, since it has not been widely tested by other people and use cases.&lt;/p&gt; &#xA;&lt;p&gt;We would love to hear from other users!&lt;/p&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;p&gt;Icepeak was started during a Channable Hackathon on 23 July 2017. After 24h we had a first workable version with an in-memory JSON store, handling of websocket connections and an HTTP API. Over the next few months the prototype was built out into a production-ready application with a persistent backend, JWT-based authentication, prometheus-based metrics and a Haskell client library.&lt;/p&gt; &#xA;&lt;h2&gt;Building and running Icepeak&lt;/h2&gt; &#xA;&lt;p&gt;Cd into &lt;code&gt;/server&lt;/code&gt;. Build with &lt;code&gt;stack build&lt;/code&gt;. Run the tests with &lt;code&gt;stack test&lt;/code&gt;. And run &lt;code&gt;icepeak&lt;/code&gt; itself with &lt;code&gt;stack exec icepeak&lt;/code&gt;. Install with &lt;code&gt;stack install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Integration tests are in &lt;code&gt;/server/integration-tests&lt;/code&gt;. They are stand-alone scripts that can be executed directly, e.g. &lt;code&gt;./read_after_write_test.py&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Running with the new low-latency garbage collector for GHC 8.10&lt;/h3&gt; &#xA;&lt;p&gt;If you compiled icepeak with GHC 8.10 (or newer) then you can use the new low-latency garbage collector by passing the following runtime flags to icepeak:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;icepeak +RTS -xn&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Building the Haskell client library&lt;/h2&gt; &#xA;&lt;p&gt;Cd into &lt;code&gt;/client-haskell&lt;/code&gt;. Build with &lt;code&gt;stack build&lt;/code&gt;. Run the tests with &lt;code&gt;stack test&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Run &lt;code&gt;stack haddock --no-haddock-deps&lt;/code&gt; to generate the Haskell API documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Usage:&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: icepeak [--data-file DATA_FILE] [--enable-jwt-auth]&#xA;               [--jwt-secret JWT_SECRET]&#xA;&#xA;Available options:&#xA;  -h,--help                Show this help text&#xA;  --data-file DATA_FILE    File where data is persisted to. Default:&#xA;                           icepeak.json&#xA;  --enable-jwt-auth        Enable authorization using JSON Web Tokens.&#xA;  --jwt-secret JWT_SECRET  Secret used for JWT verification, defaults to the&#xA;                           value of the JWT_SECRET environment variable if&#xA;                           present. If no secret is passed, JWT tokens are not&#xA;                           checked for validity.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;JWT Authorization&lt;/h2&gt; &#xA;&lt;p&gt;Optionally, requests can be required to contain a &lt;a href=&#34;https://tools.ietf.org/html/rfc7519&#34;&gt;JSON Web Token&lt;/a&gt; with an &lt;code&gt;icepeak&lt;/code&gt; claim describing the set of permissions of that client. JWT authorization can be enabled with the &lt;code&gt;--enable-jwt-auth&lt;/code&gt; command line option. A token can be specified in an &lt;code&gt;Authorization: Bearer &amp;lt;token&amp;gt;&lt;/code&gt; header or an &lt;code&gt;access_token=&amp;lt;token&amp;gt;&lt;/code&gt; query string parameter, the former taking precedence over the latter.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, a secret is may be passed to the application via &lt;code&gt;--jwt-secret&lt;/code&gt; or the &lt;code&gt;JWT_SECRET&lt;/code&gt; environment variable, the former taking precedence over the latter. This secret is used to verify the HS256 signature of incoming tokens. A supplied token is only considered valid if it&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;has a valid signature,&lt;/li&gt; &#xA; &lt;li&gt;has not expired and&lt;/li&gt; &#xA; &lt;li&gt;has been issued before it is used.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If no secret is supplied, icepeak assumes that the tokens it receives have been checked by a proxy that did all the verification. In that case, only the &lt;code&gt;icepeak&lt;/code&gt; claim is extracted and parsed, but no verification takes place.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;icepeak&lt;/code&gt; claim has the following JSON schema:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;type&#34;: &#34;object&#34;,&#xA;  &#34;required&#34;: [&#34;version&#34;],&#xA;  &#34;properties&#34;: {&#xA;    &#34;version&#34;: {&#34;enum&#34;: [1]},&#xA;    &#34;whitelist&#34;: {&#xA;      &#34;type&#34;: &#34;array&#34;,&#xA;      &#34;items&#34;: {&#xA;        &#34;type&#34;: &#34;object&#34;,&#xA;        &#34;required&#34;: [&#34;prefix&#34;, &#34;modes&#34;],&#xA;        &#34;properties&#34;: {&#xA;          &#34;prefix&#34;: {&#34;type&#34;: &#34;array&#34;, &#34;items&#34;: {&#34;type&#34;: &#34;string&#34;}},&#xA;          &#34;modes&#34;: {&#34;type&#34;: &#34;array&#34;, &#34;items&#34;: {&#34;enum&#34;: [&#34;read&#34;, &#34;write&#34;]}}&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example JWT token claim set:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;icepeak&#34;: {&#xA;    &#34;version&#34;: 1,&#xA;    &#34;whitelist&#34;: [&#xA;      {&#34;prefix&#34;: [&#34;foo&#34;], &#34;modes&#34;: [&#34;read&#34;]},&#xA;      {&#34;prefix&#34;: [&#34;bar&#34;, &#34;1&#34;], &#34;modes&#34;: [&#34;read&#34;, &#34;write&#34;]}&#xA;    ]&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A request with this claim set may only:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Read paths that have &lt;code&gt;/foo&lt;/code&gt; as a prefix.&lt;/li&gt; &#xA; &lt;li&gt;Update paths that have &lt;code&gt;/bar/1&lt;/code&gt; as a prefix. Any other request will result in a &lt;em&gt;401 Unauthorized&lt;/em&gt; response.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Generally, a claim contains a list of permissions which apply to the listed path itself and all sub-paths. A request is considered valid if there is at least one entry in the whitelist that allows it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;GET&lt;/code&gt; requests on the REST API and websocket connections require the &lt;code&gt;read&lt;/code&gt; permission for the given path, &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; requests require the &lt;code&gt;write&lt;/code&gt; permission.&lt;/p&gt; &#xA;&lt;h2&gt;Generating Tokens&lt;/h2&gt; &#xA;&lt;p&gt;JSON Web Tokens with the &lt;code&gt;icepeak&lt;/code&gt; claim can be generated using the included &lt;code&gt;icepeak-token-gen&lt;/code&gt; executable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: icepeak-token-gen [-s|--jwt-secret JWT_SECRET]&#xA;                         [-e|--expires EXPIRES_SECONDS] [-p|--path PATH:MODES]&#xA;&#xA;Available options:&#xA;  -h,--help                Show this help text&#xA;  -s,--jwt-secret JWT_SECRET&#xA;                           Secret used for signing the JWT, defaults to the&#xA;                           value of the JWT_SECRET environment variable if&#xA;                           present. If no secret is passed, JWT tokens are not&#xA;                           signed.&#xA;  -e,--expires EXPIRES_SECONDS&#xA;                           Generate a token that expires in EXPIRES_SECONDS&#xA;                           seconds from now.&#xA;  -p,--path PATH:MODES     Adds the PATH to the whitelist, allowing the access&#xA;                           modes MODES. MODES can be &#39;r&#39; (read), &#39;w&#39; (write) or&#xA;                           &#39;rw&#39; (read/write). This option may be used more than&#xA;                           once.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Connecting a client&lt;/h2&gt; &#xA;&lt;p&gt;The websocket connection can be interactively tested with ipython. First install the &lt;code&gt;websocket-client&lt;/code&gt; library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install websocket-client&#xA;ipython&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then create a websocket and receive the the current value at &lt;code&gt;foo&lt;/code&gt;, and updates when it is modified:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import websocket&#xA;conn = websocket.create_connection(&#34;ws://localhost:3000/foo&#34;)&#xA;while True:&#xA;    result = conn.recv()&#xA;    print result&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Metrics&lt;/h2&gt; &#xA;&lt;p&gt;Icepeak can provide usage metrics to Prometheus with the &lt;code&gt;--metrics HOST:PORT&lt;/code&gt; command line option.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;HOST&lt;/code&gt; denotes the hostname the metrics endpoint is listening on. It can either be a specific hostname or IP address, or one of the special values supported by &lt;a href=&#34;https://raw.githubusercontent.com/channable/icepeak/master/Network.Wai.Handler.Warp.HostPreference&#34;&gt;https://hackage.haskell.org/package/warp-3.2.13/docs/Network-Wai-Handler-Warp.html#t:HostPreference&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;PORT&lt;/code&gt; denotes the port number the metrics endpoint is listening on.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Tests&lt;/h2&gt; &#xA;&lt;p&gt;There are both unit and integration tests.&lt;/p&gt; &#xA;&lt;p&gt;The unit tests for the server can be found in &lt;code&gt;server/tests&lt;/code&gt;. They can be run with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd server&#xA;stack test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The integration tests can be found in &lt;code&gt;server/integration-tests&lt;/code&gt;. Currently, there are integration tests written in Bash, Python and Haskell.&lt;/p&gt; &#xA;&lt;p&gt;Each file is an executable script that can be run directly (even the Haskell ones). For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd server/integration-tests&#xA;./generate_test_token.hs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The tests in Python require the &lt;code&gt;json&lt;/code&gt;, &lt;code&gt;requests&lt;/code&gt;, and &lt;code&gt;websocket&lt;/code&gt; packages to be installed. They can be installed in a virtual environment with &lt;code&gt;pip install &amp;lt;name&amp;gt;&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>