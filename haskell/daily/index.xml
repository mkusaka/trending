<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-16T01:34:11Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>adambaker/euler</title>
    <updated>2022-11-16T01:34:11Z</updated>
    <id>tag:github.com,2022-11-16:/adambaker/euler</id>
    <link href="https://github.com/adambaker/euler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Project euler&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>goldfirere/singletons</title>
    <updated>2022-11-16T01:34:11Z</updated>
    <id>tag:github.com,2022-11-16:/goldfirere/singletons</id>
    <link href="https://github.com/goldfirere/singletons" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fake dependent types in Haskell using singletons&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;singletons&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/goldfirere/singletons/actions?query=workflow%3AHaskell-CI&#34;&gt;&lt;img src=&#34;https://github.com/goldfirere/singletons/workflows/Haskell-CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is the README file for the &lt;code&gt;singletons&lt;/code&gt;, &lt;code&gt;singletons-th&lt;/code&gt;, and &lt;code&gt;singletons-base&lt;/code&gt; libraries. This file contains documentation for the definitions and functions in these libraries.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;singletons&lt;/code&gt; libraries were written by Richard Eisenberg (&lt;a href=&#34;mailto:rae@cs.brynmawr.edu&#34;&gt;rae@cs.brynmawr.edu&lt;/a&gt;) and with significant contributions by Jan Stolarek (&lt;a href=&#34;mailto:jan.stolarek@p.lodz.pl&#34;&gt;jan.stolarek@p.lodz.pl&lt;/a&gt;) and Ryan Scott (&lt;a href=&#34;mailto:ryan.gl.scott@gmail.com&#34;&gt;ryan.gl.scott@gmail.com&lt;/a&gt;). There are two papers that describe the libraries. Original one, &lt;em&gt;Dependently typed programming with singletons&lt;/em&gt;, is available &lt;a href=&#34;https://richarde.dev/papers/2012/singletons/paper.pdf&#34;&gt;here&lt;/a&gt; and will be referenced in this documentation as the &#34;singletons paper&#34;. A follow-up paper, &lt;em&gt;Promoting Functions to Type Families in Haskell&lt;/em&gt;, is available &lt;a href=&#34;https://richarde.dev/papers/2014/promotion/promotion.pdf&#34;&gt;here&lt;/a&gt; and will be referenced in this documentation as the &#34;promotion paper&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Ryan Scott (&lt;a href=&#34;mailto:ryan.gl.scott@gmail.com&#34;&gt;ryan.gl.scott@gmail.com&lt;/a&gt;) is the active maintainer.&lt;/p&gt; &#xA;&lt;h2&gt;Purpose of the libraries&lt;/h2&gt; &#xA;&lt;p&gt;Broadly speaking, the &lt;code&gt;singletons&lt;/code&gt; libraries define an ecosystem of &lt;em&gt;singleton types&lt;/em&gt;, which allow programmers to use dependently typed techniques to enforce rich constraints among the types in their programs. To that end, the three libraries serve the following roles:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;singletons&lt;/code&gt; library is a small, foundational library that defines basic singleton-related types and definitions.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;singletons-th&lt;/code&gt; library defines Template Haskell functionality that allows &lt;em&gt;promotion&lt;/em&gt; of term-level functions to type-level equivalents and &lt;em&gt;singling&lt;/em&gt; functions to dependently typed equivalents.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;singletons-base&lt;/code&gt; library uses &lt;code&gt;singletons-th&lt;/code&gt; to define promoted and singled functions from the &lt;code&gt;base&lt;/code&gt; library, including the &lt;code&gt;Prelude&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Besides the functionality of the libraries themselves, &lt;code&gt;singletons&lt;/code&gt; differs from &lt;code&gt;singletons-th&lt;/code&gt; and &lt;code&gt;singletons-base&lt;/code&gt; by aiming to be compatible with a wider range of GHC versions. See the &#34;Compatibility&#34; section for further details.&lt;/p&gt; &#xA;&lt;p&gt;Some other introductions to the ideas in these libraries include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The singletons paper and promotion papers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.jle.im/entry/introduction-to-singletons-1.html&#34;&gt;This blog series&lt;/a&gt;, authored by Justin Le, which offers a tutorial for these libraries that assumes no knowledge of dependent types.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;singletons&lt;/code&gt;, &lt;code&gt;singletons-th&lt;/code&gt;, and &lt;code&gt;singletons-base&lt;/code&gt; have different support windows for requirements on the compiler version needed to build each library:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;singletons&lt;/code&gt; is a minimal library, and as such, it has a relatively wide support window. &lt;code&gt;singletons&lt;/code&gt; must be built with one of the following compilers:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;GHC 8.0 or greater&lt;/li&gt; &#xA;   &lt;li&gt;GHCJS&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;singletons-th&lt;/code&gt; and &lt;code&gt;singletons-base&lt;/code&gt; require use of many bleeding-edge GHC language extensions, even more so than &lt;code&gt;singletons&lt;/code&gt; itself. As such, it is difficult to maintain support for multiple GHC versions in any given release of either library, so they only support the latest major GHC version (currently GHC 9.4).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Any code that uses the singleton-generation functionality from &lt;code&gt;singletons-th&lt;/code&gt; or &lt;code&gt;singletons-base&lt;/code&gt; needs to enable a long list of GHC extensions. This list includes, but is not necessarily limited to, the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ExistentialQuantification&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;InstanceSigs&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NoCUSKs&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NoNamedWildCards&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NoStarIsType&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;StandaloneKindSignatures&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TemplateHaskell&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some notes on the use of &lt;code&gt;No*&lt;/code&gt; extensions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;NoNamedWildCards&lt;/code&gt; is needed since &lt;code&gt;singletons-th&lt;/code&gt; will single code like &lt;code&gt;f _x = ...&lt;/code&gt; to &lt;code&gt;sF (_sx :: Sing _x) = ...&lt;/code&gt;, which crucially relies on the &lt;code&gt;_x&lt;/code&gt; in &lt;code&gt;Sing _x&lt;/code&gt; being treated as a type variable, not a wildcard.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NoStarIsType&lt;/code&gt; is needed to use the &lt;code&gt;*&lt;/code&gt; type family from the &lt;code&gt;PNum&lt;/code&gt; class because with &lt;code&gt;StarIsType&lt;/code&gt; enabled, GHC thinks &lt;code&gt;*&lt;/code&gt; is a synonym for &lt;code&gt;Type&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You may also want to consider toggling various warning flags:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-Wno-redundant-constraints&lt;/code&gt;. The code that &lt;code&gt;singletons&lt;/code&gt; generates uses redundant constraints, and there seems to be no way, without a large library redesign, to avoid this.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-fenable-th-splice-warnings&lt;/code&gt;. By default, GHC does not run pattern-match coverage checker warnings on code inside of Template Haskell quotes. This is an extremely common thing to do in &lt;code&gt;singletons-th&lt;/code&gt;, so you may consider opting in to these warnings.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Modules for singleton types&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Data.Singletons&lt;/code&gt; (from &lt;code&gt;singletons&lt;/code&gt;) exports all the basic singletons definitions. Import this module if you are not using Template Haskell and wish only to define your own singletons.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Data.Singletons.Decide&lt;/code&gt; (from &lt;code&gt;singletons&lt;/code&gt;) exports type classes for propositional equality. See the &#34;Equality classes&#34; section for more information.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Data.Singletons.TH&lt;/code&gt; (from &lt;code&gt;singletons-th&lt;/code&gt;) exports all the definitions needed to use the Template Haskell code to generate new singletons. &lt;code&gt;Data.Singletons.Base.TH&lt;/code&gt; (from &lt;code&gt;singletons-base&lt;/code&gt;) re-exports &lt;code&gt;Data.Singletons.TH&lt;/code&gt; plus any promoted or singled definitions that are likely to appear in TH-generated code. For instance, singling a &lt;code&gt;deriving Eq&lt;/code&gt; clause will make use of &lt;code&gt;SEq&lt;/code&gt;, the singled &lt;code&gt;Eq&lt;/code&gt; class, so &lt;code&gt;Data.Singletons.TH&lt;/code&gt; re-exports &lt;code&gt;SEq&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Prelude.Singletons&lt;/code&gt; (from &lt;code&gt;singletons-base&lt;/code&gt;) re-exports &lt;code&gt;Data.Singletons&lt;/code&gt; along with singleton definitions for various &lt;code&gt;Prelude&lt;/code&gt; types. This module provides promoted and singled equivalents of functions from the real &lt;code&gt;Prelude&lt;/code&gt;. Note that not all functions from original &lt;code&gt;Prelude&lt;/code&gt; could be promoted or singled.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;singletons-base&lt;/code&gt; library provides promoted and singled equivalents of definitions found in several commonly used &lt;code&gt;base&lt;/code&gt; library modules, including (but not limited to) &lt;code&gt;Data.Bool&lt;/code&gt;, &lt;code&gt;Data.Maybe&lt;/code&gt;, &lt;code&gt;Data.Either&lt;/code&gt;, &lt;code&gt;Data.List&lt;/code&gt;, &lt;code&gt;Data.Tuple&lt;/code&gt;, and &lt;code&gt;Data.Void&lt;/code&gt;. We also provide promoted and singled versions of common type classes, including (but not limited to) &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, and &lt;code&gt;Bounded&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;GHC.TypeLits.Singletons&lt;/code&gt; (from &lt;code&gt;singletons-base&lt;/code&gt;) exports definitions for working with &lt;code&gt;GHC.TypeLits&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Functions to generate singletons&lt;/h2&gt; &#xA;&lt;p&gt;The top-level functions used to generate promoted or singled definitions are documented in the &lt;code&gt;Data.Singletons.TH&lt;/code&gt; module in &lt;code&gt;singletons-th&lt;/code&gt;. The most common case is just calling the &lt;code&gt;singletons&lt;/code&gt; function, which I&#39;ll describe here:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;singletons :: Q [Dec] -&amp;gt; Q [Dec]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This function generates singletons from the definitions given. Because singleton generation requires promotion, this also promotes all of the definitions given to the type level.&lt;/p&gt; &#xA;&lt;p&gt;Usage example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;$(singletons [d|&#xA;  data Nat = Zero | Succ Nat&#xA;  pred :: Nat -&amp;gt; Nat&#xA;  pred Zero = Zero&#xA;  pred (Succ n) = n&#xA;  |])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Definitions used to support singletons&lt;/h2&gt; &#xA;&lt;p&gt;This section contains a brief overview of some of the most important types from &lt;code&gt;Data.Singletons&lt;/code&gt; (from &lt;code&gt;singletons&lt;/code&gt;). Please refer to the singletons paper for a more in-depth explanation of these definitions. Many of the definitions were developed in tandem with Iavor Diatchki.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Sing :: k -&amp;gt; Type&#xA;type family Sing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The type family of singleton types. A new instance of this type family is generated for every new singleton type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type SingI :: forall {k}. k -&amp;gt; Constraint&#xA;class SingI a where&#xA;  sing :: Sing a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A class used to pass singleton values implicitly. The &lt;code&gt;sing&lt;/code&gt; method produces an explicit singleton value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type SomeSing :: Type -&amp;gt; Type&#xA;data SomeSing k where&#xA;  SomeSing :: Sing (a :: k) -&amp;gt; SomeSing k&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;SomeSing&lt;/code&gt; type wraps up an &lt;em&gt;existentially-quantified&lt;/em&gt; singleton. Note that the type parameter &lt;code&gt;a&lt;/code&gt; does not appear in the &lt;code&gt;SomeSing&lt;/code&gt; type. Thus, this type can be used when you have a singleton, but you don&#39;t know at compile time what it will be. &lt;code&gt;SomeSing Thing&lt;/code&gt; is isomorphic to &lt;code&gt;Thing&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type SingKind :: Type -&amp;gt; Constraint&#xA;class SingKind k where&#xA;  type Demote k :: *&#xA;  fromSing :: Sing (a :: k) -&amp;gt; Demote k&#xA;  toSing   :: Demote k -&amp;gt; SomeSing k&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This class is used to convert a singleton value back to a value in the original, unrefined ADT. The &lt;code&gt;fromSing&lt;/code&gt; method converts, say, a singleton &lt;code&gt;Nat&lt;/code&gt; back to an ordinary &lt;code&gt;Nat&lt;/code&gt;. The &lt;code&gt;toSing&lt;/code&gt; method produces an existentially-quantified singleton, wrapped up in a &lt;code&gt;SomeSing&lt;/code&gt;. The &lt;code&gt;Demote&lt;/code&gt; associated kind-indexed type family maps the kind &lt;code&gt;Nat&lt;/code&gt; back to the type &lt;code&gt;Nat&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type SingInstance :: k -&amp;gt; Type&#xA;data SingInstance a where&#xA;  SingInstance :: SingI a =&amp;gt; SingInstance a&#xA;singInstance :: Sing a -&amp;gt; SingInstance a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sometimes you have an explicit singleton (a &lt;code&gt;Sing&lt;/code&gt;) where you need an implicit one (a dictionary for &lt;code&gt;SingI&lt;/code&gt;). The &lt;code&gt;SingInstance&lt;/code&gt; type simply wraps a &lt;code&gt;SingI&lt;/code&gt; dictionary, and the &lt;code&gt;singInstance&lt;/code&gt; function produces this dictionary from an explicit singleton. The &lt;code&gt;singInstance&lt;/code&gt; function runs in constant time, using a little magic.&lt;/p&gt; &#xA;&lt;p&gt;In addition to &lt;code&gt;SingI&lt;/code&gt;, there are also higher-order versions named &lt;code&gt;SingI1&lt;/code&gt; and &lt;code&gt;SingI2&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type SingI1 :: forall {k1 k2}. (k1 -&amp;gt; k2) -&amp;gt; Constraint&#xA;class (forall x. SingI x =&amp;gt; SingI (f x)) =&amp;gt; SingI1 f where&#xA;  liftSing :: Sing x -&amp;gt; Sing (f x)&#xA;&#xA;type SingI2 :: forall {k1 k2 k3}. (k1 -&amp;gt; k2 -&amp;gt; k3) -&amp;gt; Constraint&#xA;class (forall x y. (SingI x, SingI y) =&amp;gt; SingI (f x y)) =&amp;gt; SingI2 f where&#xA;  liftSing2 :: Sing x -&amp;gt; Sing y -&amp;gt; Sing (f x y)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Equality classes&lt;/h2&gt; &#xA;&lt;p&gt;There are two different notions of equality applicable to singletons: Boolean equality and propositional equality.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Boolean equality is implemented in the type family &lt;code&gt;(==)&lt;/code&gt; (in the &lt;code&gt;PEq&lt;/code&gt; class) and the &lt;code&gt;(%==&lt;/code&gt;) method (in the &lt;code&gt;SEq&lt;/code&gt; class). See the &lt;code&gt;Data.Eq.Singletons&lt;/code&gt; module from &lt;code&gt;singletons-base&lt;/code&gt; for more information.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Propositional equality is implemented through the constraint &lt;code&gt;(~)&lt;/code&gt;, the type &lt;code&gt;(:~:)&lt;/code&gt;, and the class &lt;code&gt;SDecide&lt;/code&gt;. See modules &lt;code&gt;Data.Type.Equality&lt;/code&gt; and &lt;code&gt;Data.Singletons.Decide&lt;/code&gt; from &lt;code&gt;singletons&lt;/code&gt; for more information.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Which one do you need? That depends on your application. Boolean equality has the advantage that your program can take action when two types do &lt;em&gt;not&lt;/em&gt; equal, while propositional equality has the advantage that GHC can use the equality of types during type inference.&lt;/p&gt; &#xA;&lt;p&gt;Instances of &lt;code&gt;SEq&lt;/code&gt;, &lt;code&gt;SDecide&lt;/code&gt;, &lt;code&gt;TestEquality&lt;/code&gt;, and &lt;code&gt;TestCoercion&lt;/code&gt; are generated when &lt;code&gt;singletons&lt;/code&gt; is called on a datatype that has &lt;code&gt;deriving Eq&lt;/code&gt;. You can also generate these instances directly through functions exported from &lt;code&gt;Data.Singletons.TH&lt;/code&gt; (from &lt;code&gt;singletons-th&lt;/code&gt;) and &lt;code&gt;Data.Singletons.Base.TH&lt;/code&gt; (from &lt;code&gt;singletons-base&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;Show&lt;/code&gt; classes&lt;/h2&gt; &#xA;&lt;p&gt;Promoted and singled versions of the &lt;code&gt;Show&lt;/code&gt; class (&lt;code&gt;PShow&lt;/code&gt; and &lt;code&gt;SShow&lt;/code&gt;, respectively) are provided in the &lt;code&gt;Text.Show.Singletons&lt;/code&gt; module from &lt;code&gt;singletons-base&lt;/code&gt;. In addition, there is a &lt;code&gt;ShowSing&lt;/code&gt; constraint synonym provided in the &lt;code&gt;Data.Singletons.ShowSing&lt;/code&gt; module from &lt;code&gt;singletons&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type ShowSing :: Type -&amp;gt; Constraint&#xA;type ShowSing k = (forall z. Show (Sing (z :: k)) -- Approximately&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This facilitates the ability to write &lt;code&gt;Show&lt;/code&gt; instances for &lt;code&gt;Sing&lt;/code&gt; instances.&lt;/p&gt; &#xA;&lt;p&gt;What distinguishes all of these &lt;code&gt;Show&lt;/code&gt;s? Let&#39;s use the &lt;code&gt;False&lt;/code&gt; constructor as an example. If you used the &lt;code&gt;PShow Bool&lt;/code&gt; instance, then the output of calling &lt;code&gt;Show_&lt;/code&gt; on &lt;code&gt;False&lt;/code&gt; is &lt;code&gt;&#34;False&#34;&lt;/code&gt;, much like the value-level &lt;code&gt;Show Bool&lt;/code&gt; instance (similarly for the &lt;code&gt;SShow Bool&lt;/code&gt; instance). However, the &lt;code&gt;Show (Sing (z :: Bool))&lt;/code&gt; instance (i.e., &lt;code&gt;ShowSing Bool&lt;/code&gt;) is intended for printing the value of the &lt;em&gt;singleton&lt;/em&gt; constructor &lt;code&gt;SFalse&lt;/code&gt;, so calling &lt;code&gt;show SFalse&lt;/code&gt; yields &lt;code&gt;&#34;SFalse&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Instance of &lt;code&gt;PShow&lt;/code&gt;, &lt;code&gt;SShow&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt; (for the singleton type) are generated when &lt;code&gt;singletons&lt;/code&gt; is called on a datatype that has &lt;code&gt;deriving Show&lt;/code&gt;. You can also generate these instances directly through functions exported from &lt;code&gt;Data.Singletons.TH&lt;/code&gt; (from &lt;code&gt;singletons-th&lt;/code&gt;) and &lt;code&gt;Data.Singletons.Base.TH&lt;/code&gt; (from &lt;code&gt;singletons-base&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Errors&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;singletons-base&lt;/code&gt; library provides two different ways to handle errors:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;code&gt;Error&lt;/code&gt; type family, from &lt;code&gt;GHC.TypeLits.Singletons&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Error :: a -&amp;gt; k&#xA;type family Error str where {}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This is simply an empty, closed type family, which means that it will fail to reduce regardless of its input. The typical use case is giving it a &lt;code&gt;Symbol&lt;/code&gt; as an argument, so that something akin to &lt;code&gt;Error &#34;This is an error message&#34;&lt;/code&gt; appears in error messages.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;code&gt;TypeError&lt;/code&gt; type family, from &lt;code&gt;Data.Singletons.Base.TypeError&lt;/code&gt;. This is a drop-in replacement for &lt;code&gt;TypeError&lt;/code&gt; from &lt;code&gt;GHC.TypeLits&lt;/code&gt; which can be used at both the type level and the value level (via the &lt;code&gt;typeError&lt;/code&gt; function).&lt;/p&gt; &lt;p&gt;Unlike &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;TypeError&lt;/code&gt; will result in an actual compile-time error message, which may be more desirable depending on the use case.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Pre-defined singletons&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;singletons-base&lt;/code&gt; library defines a number of singleton types and functions by default. These include (but are not limited to):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Maybe&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Either&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;tuples up to length 7&lt;/li&gt; &#xA; &lt;li&gt;lists&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These are all available through &lt;code&gt;Prelude.Singletons&lt;/code&gt;. Functions that operate on these singletons are available from modules such as &lt;code&gt;Data.Singletons.Bool&lt;/code&gt; and &lt;code&gt;Data.Singletons.Maybe&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Promoting functions&lt;/h2&gt; &#xA;&lt;p&gt;Function promotion allows to generate type-level equivalents of term-level definitions. Almost all Haskell source constructs are supported -- see the &#34;Haskell constructs supported by &lt;code&gt;singletons-th&lt;/code&gt;&#34; section of this README for a full list.&lt;/p&gt; &#xA;&lt;p&gt;Promoted definitions are usually generated by calling the &lt;code&gt;promote&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;$(promote [d|&#xA;  data Nat = Zero | Succ Nat&#xA;  pred :: Nat -&amp;gt; Nat&#xA;  pred Zero = Zero&#xA;  pred (Succ n) = n&#xA;  |])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Every promoted function and data constructor definition comes with a set of so-called &lt;em&gt;defunctionalization symbols&lt;/em&gt;. These are required to represent partial application at the type level. For more information, refer to the &#34;Promotion and partial application&#34; section below.&lt;/p&gt; &#xA;&lt;p&gt;Users also have access to &lt;code&gt;Prelude.Singletons&lt;/code&gt; and related modules (e.g., &lt;code&gt;Data.Bool.Singletons&lt;/code&gt;, &lt;code&gt;Data.Either.Singletons&lt;/code&gt;, &lt;code&gt;Data.List.Singletons&lt;/code&gt;, &lt;code&gt;Data.Maybe.Singletons&lt;/code&gt;, &lt;code&gt;Data.Tuple.Singletons&lt;/code&gt;, etc.) in &lt;code&gt;singletons-base&lt;/code&gt;. These provide promoted versions of function found in GHC&#39;s &lt;code&gt;base&lt;/code&gt; library.&lt;/p&gt; &#xA;&lt;p&gt;Note that GHC resolves variable names in Template Haskell quotes. You cannot then use an undefined identifier in a quote, making idioms like this not work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type family Foo a where ...&#xA;$(promote [d| ... foo x ... |])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, &lt;code&gt;foo&lt;/code&gt; would be out of scope.&lt;/p&gt; &#xA;&lt;p&gt;Refer to the promotion paper for more details on function promotion.&lt;/p&gt; &#xA;&lt;h2&gt;Promotion and partial application&lt;/h2&gt; &#xA;&lt;p&gt;Promoting higher-order functions proves to be surprisingly tricky. Consider this example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;$(promote [d|&#xA;  map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&#xA;  map _ []     = []&#xA;  map f (x:xs) = f x : map f xs&#xA;  |])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A naïve attempt to promote &lt;code&gt;map&lt;/code&gt; would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;type Map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&#xA;type family Map f xs where&#xA;  Map _ &#39;[]    = &#39;[]&#xA;  Map f (x:xs) = f x : Map f xs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While this compiles, it is much less useful than we would like. In particular, common idioms like &lt;code&gt;Map Id xs&lt;/code&gt; will not typecheck, since GHC requires that all invocations of type families be fully saturated. That is, the use of &lt;code&gt;Id&lt;/code&gt; in &lt;code&gt;Map Id xs&lt;/code&gt; is rejected since it is not applied to one argument, which the number of arguments that &lt;code&gt;Id&lt;/code&gt; was defined with. For more information on this point, refer to the promotion paper.&lt;/p&gt; &#xA;&lt;p&gt;Not having the ability to partially apply functions at the type level is rather painful, so we do the next best thing: we &lt;em&gt;defunctionalize&lt;/em&gt; all promoted functions so that we can emulate partial application. For example, if one were to promote the &lt;code&gt;id&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;$(promote [d|&#xA;  id :: a -&amp;gt; a&#xA;  id x = x&#xA;  |]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then in addition to generating the promoted &lt;code&gt;Id&lt;/code&gt; type family, two defunctionalization symbols will be generated:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;type IdSym0 :: a ~&amp;gt; a&#xA;data IdSym0 x&#xA;&#xA;type IdSym1 :: a -&amp;gt; a&#xA;type family IdSym1 x where&#xA;  IdSym1 x = Id x&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In general, a function that accepts N arguments generates N+1 defunctionalization symbols when promoted.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;IdSym1&lt;/code&gt; is a &lt;em&gt;fully saturated&lt;/em&gt; defunctionalization symbol and is usually only needed when generating code through the Template Haskell machinery. &lt;code&gt;IdSym0&lt;/code&gt; is more interesting: it has the kind &lt;code&gt;a ~&amp;gt; a&lt;/code&gt;, which has a special arrow type &lt;code&gt;(~&amp;gt;)&lt;/code&gt;. Defunctionalization symbols using the &lt;code&gt;(~&amp;gt;)&lt;/code&gt; kind are type-level constants that can be &#34;applied&#34; using a special &lt;code&gt;Apply&lt;/code&gt; type family:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;type Apply :: (a ~&amp;gt; b) -&amp;gt; a -&amp;gt; b&#xA;type family Apply f x&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Every defunctionalization symbol comes with a corresponding &lt;code&gt;Apply&lt;/code&gt; instance (except for fully saturated defunctionalization symbols). For instance, here is the &lt;code&gt;Apply&lt;/code&gt; instance for &lt;code&gt;IdSym0&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;type instance Apply IdSym0 x = Id x&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;(~&amp;gt;)&lt;/code&gt; kind is used when promoting higher-order functions so that partially applied arguments can be passed to them. For instance, here is our final attempt at promoting &lt;code&gt;map&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;type Map :: (a ~&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&#xA;type family Map f xs where&#xA;  Map _ &#39;[]    = &#39;[]&#xA;  Map f (x:xs) = Apply f x : Map f xs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now &lt;code&gt;map id xs&lt;/code&gt; can be promoted to &lt;code&gt;Map IdSym0 xs&lt;/code&gt;, which typechecks without issue.&lt;/p&gt; &#xA;&lt;h2&gt;Defunctionalizing existing type families&lt;/h2&gt; &#xA;&lt;p&gt;The most common way to defunctionalize functions is by promoting them with the Template Haskell machinery. One can also defunctionalize existing type families, however, by using &lt;code&gt;genDefunSymbols&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;type MyTypeFamily :: Nat -&amp;gt; Bool&#xA;type family MyTypeFamily n&#xA;&#xA;$(genDefunSymbols [&#39;&#39;MyTypeFamily])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can be especially useful if &lt;code&gt;MyTypeFamily&lt;/code&gt; needs to be implemented by hand. Be aware of the following design limitations of &lt;code&gt;genDefunSymbols&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;genDefunSymbols&lt;/code&gt; only works for type-level declarations. Namely, it only works when given the names of type classes, type families, type synonyms, or data types. Attempting to pass the name of a term level function, class method, data constructor, or record selector will throw an error.&lt;/li&gt; &#xA; &lt;li&gt;Passing the name of a data type to &lt;code&gt;genDefunSymbols&lt;/code&gt; will cause its data constructors to be defunctionalized but &lt;em&gt;not&lt;/em&gt; its record selectors.&lt;/li&gt; &#xA; &lt;li&gt;Passing the name of a type class to &lt;code&gt;genDefunSymbols&lt;/code&gt; will cause the class itself to be defunctionalized, but /not/ its associated type families or methods.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that the limitations above reflect the current design of &lt;code&gt;genDefunSymbols&lt;/code&gt;. As a result, they are subject to change in the future.&lt;/p&gt; &#xA;&lt;h2&gt;Defunctionalization and visible dependent quantification&lt;/h2&gt; &#xA;&lt;p&gt;Unlike most other parts of &lt;code&gt;singletons-th&lt;/code&gt;, which disallow visible dependent quantification (VDQ), &lt;code&gt;genDefunSymbols&lt;/code&gt; has limited support for VDQ. Consider this example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;type MyProxy :: forall (k :: Type) -&amp;gt; k -&amp;gt; Type&#xA;type family MyProxy k (a :: k) :: Type where&#xA;  MyProxy k (a :: k) = Proxy a&#xA;&#xA;$(genDefunSymbols [&#39;&#39;MyProxy])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will generate the following defunctionalization symbols:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;type MyProxySym0 ::              Type  ~&amp;gt; k ~&amp;gt; Type&#xA;type MyProxySym1 :: forall (k :: Type) -&amp;gt; k ~&amp;gt; Type&#xA;type MyProxySym2 :: forall (k :: Type) -&amp;gt; k -&amp;gt; Type&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;MyProxySym0&lt;/code&gt; is a bit more general than it ought to be, since there is no dependency between the first kind (&lt;code&gt;Type&lt;/code&gt;) and the second kind (&lt;code&gt;k&lt;/code&gt;). But this would require the ability to write something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;type MyProxySym0 :: forall (k :: Type) ~&amp;gt; k ~&amp;gt; Type&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This currently isn&#39;t possible. So for the time being, the kind of &lt;code&gt;MyProxySym0&lt;/code&gt; will be slightly more general, which means that under rare circumstances, you may have to provide extra type signatures if you write code which exploits the dependency in &lt;code&gt;MyProxy&lt;/code&gt;&#39;s kind.&lt;/p&gt; &#xA;&lt;h2&gt;Classes and instances&lt;/h2&gt; &#xA;&lt;p&gt;This is best understood by example. Let&#39;s look at a stripped down &lt;code&gt;Ord&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class Eq a =&amp;gt; Ord a where&#xA;  compare :: a -&amp;gt; a -&amp;gt; Ordering&#xA;  (&amp;lt;)     :: a -&amp;gt; a -&amp;gt; Bool&#xA;  x &amp;lt; y = case x `compare` y of&#xA;            LT -&amp;gt; True&#xA;&#x9;    EQ -&amp;gt; False&#xA;&#x9;    GT -&amp;gt; False&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This class gets promoted to a &#34;kind class&#34; thus:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class PEq a =&amp;gt; POrd a where&#xA;  type Compare (x :: a) (y :: a) :: Ordering&#xA;  type (&amp;lt;)     (x :: a) (y :: a) :: Bool&#xA;  type x &amp;lt; y = ... -- promoting `case` is yucky.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that default method definitions become default associated type family instances. This works out quite nicely.&lt;/p&gt; &#xA;&lt;p&gt;We also get this singleton class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class SEq a =&amp;gt; SOrd a where&#xA;  sCompare :: forall (x :: a) (y :: a). Sing x -&amp;gt; Sing y -&amp;gt; Sing (Compare x y)&#xA;  (%&amp;lt;)     :: forall (x :: a) (y :: a). Sing x -&amp;gt; Sing y -&amp;gt; Sing (x &amp;lt; y)&#xA;&#xA;  default (%&amp;lt;) :: forall (x :: a) (y :: a).&#xA;                  ((x &amp;lt; y) ~ {- RHS from (&amp;lt;) above -})&#xA;&#x9;&#x9;=&amp;gt; Sing x -&amp;gt; Sing y -&amp;gt; Sing (x &amp;lt; y)&#xA;  x %&amp;lt; y = ...  -- this is a bit yucky too&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that a singled class needs to use &lt;code&gt;default&lt;/code&gt; signatures, because type-checking the default body requires that the default associated type family instance was used in the promoted class. The extra equality constraint on the default signature asserts this fact to the type checker.&lt;/p&gt; &#xA;&lt;p&gt;Instances work roughly similarly.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance Ord Bool where&#xA;  compare False False = EQ&#xA;  compare False True  = LT&#xA;  compare True  False = GT&#xA;  compare True  True  = EQ&#xA;&#xA;instance POrd Bool where&#xA;  type Compare &#39;False &#39;False = &#39;EQ&#xA;  type Compare &#39;False &#39;True  = &#39;LT&#xA;  type Compare &#39;True  &#39;False = &#39;GT&#xA;  type Compare &#39;True  &#39;True  = &#39;EQ&#xA;&#xA;instance SOrd Bool where&#xA;  sCompare :: forall (x :: a) (y :: a). Sing x -&amp;gt; Sing y -&amp;gt; Sing (Compare x y)&#xA;  sCompare SFalse SFalse = SEQ&#xA;  sCompare SFalse STrue  = SLT&#xA;  sCompare STrue  SFalse = SGT&#xA;  sCompare STrue  STrue  = SEQ&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The only interesting bit here is the instance signature. It&#39;s not necessary in such a simple scenario, but more complicated functions need to refer to scoped type variables, which the instance signature can bring into scope. The defaults all just work.&lt;/p&gt; &#xA;&lt;h2&gt;On names&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;singletons-th&lt;/code&gt; library has to produce new names for the new constructs it generates. Here are some examples showing how this is done:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;original datatype: &lt;code&gt;Nat&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted kind: &lt;code&gt;Nat&lt;/code&gt;&lt;/p&gt; &lt;p&gt;singleton type: &lt;code&gt;SNat&lt;/code&gt; (which is really a synonym for &lt;code&gt;Sing&lt;/code&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;original datatype: &lt;code&gt;/\&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted kind: &lt;code&gt;/\&lt;/code&gt;&lt;/p&gt; &lt;p&gt;singleton type: &lt;code&gt;%/\&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;original constructor: &lt;code&gt;Succ&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted type: &lt;code&gt;&#39;Succ&lt;/code&gt; (you can use &lt;code&gt;Succ&lt;/code&gt; when unambiguous)&lt;/p&gt; &lt;p&gt;singleton constructor: &lt;code&gt;SSucc&lt;/code&gt;&lt;/p&gt; &lt;p&gt;symbols: &lt;code&gt;SuccSym0&lt;/code&gt;, &lt;code&gt;SuccSym1&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;original constructor: &lt;code&gt;:+:&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted type: &lt;code&gt;&#39;:+:&lt;/code&gt;&lt;/p&gt; &lt;p&gt;singleton constructor: &lt;code&gt;:%+:&lt;/code&gt;&lt;/p&gt; &lt;p&gt;symbols: &lt;code&gt;:+:@#@$&lt;/code&gt;, &lt;code&gt;:+:@#@$$&lt;/code&gt;, &lt;code&gt;:+:@#@$$$&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;original value: &lt;code&gt;pred&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted type: &lt;code&gt;Pred&lt;/code&gt;&lt;/p&gt; &lt;p&gt;singleton value: &lt;code&gt;sPred&lt;/code&gt;&lt;/p&gt; &lt;p&gt;symbols: &lt;code&gt;PredSym0&lt;/code&gt;, &lt;code&gt;PredSym1&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;original value: &lt;code&gt;+&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted type: &lt;code&gt;+&lt;/code&gt;&lt;/p&gt; &lt;p&gt;singleton value: &lt;code&gt;%+&lt;/code&gt;&lt;/p&gt; &lt;p&gt;symbols: &lt;code&gt;+@#@$&lt;/code&gt;, &lt;code&gt;+@#@$$&lt;/code&gt;, &lt;code&gt;+@#@$$$&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;original class: &lt;code&gt;Num&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted class: &lt;code&gt;PNum&lt;/code&gt;&lt;/p&gt; &lt;p&gt;singleton class: &lt;code&gt;SNum&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;original class: &lt;code&gt;~&amp;gt;&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted class: &lt;code&gt;#~&amp;gt;&lt;/code&gt;&lt;/p&gt; &lt;p&gt;singleton class: &lt;code&gt;%~&amp;gt;&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Special names&lt;/h2&gt; &#xA;&lt;p&gt;There are some special cases, listed below (with asterisks* denoting special treatment):&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;original datatype: &lt;code&gt;[]&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted kind: &lt;code&gt;[]&lt;/code&gt;&lt;/p&gt; &lt;p&gt;singleton type*: &lt;code&gt;SList&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;original constructor: &lt;code&gt;[]&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted type: &lt;code&gt;&#39;[]&lt;/code&gt;&lt;/p&gt; &lt;p&gt;singleton constructor*: &lt;code&gt;SNil&lt;/code&gt;&lt;/p&gt; &lt;p&gt;symbols*: &lt;code&gt;NilSym0&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;original constructor: &lt;code&gt;:&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted type: &lt;code&gt;&#39;:&lt;/code&gt;&lt;/p&gt; &lt;p&gt;singleton constructor*: &lt;code&gt;SCons&lt;/code&gt;&lt;/p&gt; &lt;p&gt;symbols: &lt;code&gt;:@#@$&lt;/code&gt;, &lt;code&gt;:@#@$$&lt;/code&gt;, &lt;code&gt;:@#@$$$&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;original datatype: &lt;code&gt;(,)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted kind: &lt;code&gt;(,)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;singleton type*: &lt;code&gt;STuple2&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;original constructor: &lt;code&gt;(,)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted type: &lt;code&gt;&#39;(,)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;singleton constructor*: &lt;code&gt;STuple2&lt;/code&gt;&lt;/p&gt; &lt;p&gt;symbols*: &lt;code&gt;Tuple2Sym0&lt;/code&gt;, &lt;code&gt;Tuple2Sym1&lt;/code&gt;, &lt;code&gt;Tuple2Sym2&lt;/code&gt;&lt;/p&gt; &lt;p&gt;All tuples (including the 0-tuple, unit) are treated similarly. Furthermore, due to the lack of levity polymorphism at the kind level (see &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/issues/14180&#34;&gt;GHC#14180&lt;/a&gt;), unboxed tuple data types and data constructors are promoted and singled as if they were boxed tuples. For example, the &lt;code&gt;(#,#)&lt;/code&gt; data constructor is promoted to &lt;code&gt;(,)&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;original value: &lt;code&gt;___foo&lt;/code&gt;&lt;/p&gt; &lt;p&gt;promoted type*: &lt;code&gt;US___foo&lt;/code&gt; (&#34;&lt;code&gt;US&lt;/code&gt;&#34; stands for &#34;underscore&#34;)&lt;/p&gt; &lt;p&gt;singleton value*: &lt;code&gt;___sfoo&lt;/code&gt;&lt;/p&gt; &lt;p&gt;symbols*: &lt;code&gt;US___fooSym0&lt;/code&gt;&lt;/p&gt; &lt;p&gt;All functions that begin with leading underscores are treated similarly.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Any data type constructor &lt;code&gt;Rep&lt;/code&gt; (regardless of where or how &lt;code&gt;Rep&lt;/code&gt; is defined) is promoted to &lt;code&gt;Type&lt;/code&gt;. This is needed to make &lt;code&gt;Data.Singletons.TH.CustomStar&lt;/code&gt; work.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If desired, you can pick your own naming conventions by using the &lt;code&gt;Data.Singletons.TH.Options&lt;/code&gt; module in &lt;code&gt;singletons-th&lt;/code&gt;. Here is an example of how this module can be used to prefix a singled data constructor with &lt;code&gt;MyS&lt;/code&gt; instead of &lt;code&gt;S&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;import Data.Singletons.TH&#xA;import Data.Singletons.TH.Options&#xA;import Language.Haskell.TH (Name, mkName, nameBase)&#xA;&#xA;$(let myPrefix :: Name -&amp;gt; Name&#xA;      myPrefix name = mkName (&#34;MyS&#34; ++ nameBase name) in&#xA;&#xA;      withOptions defaultOptions{singledDataConName = myPrefix} $&#xA;      singletons [d| data T = MkT |])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Haskell constructs supported by &lt;code&gt;singletons-th&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;h2&gt;Full support&lt;/h2&gt; &#xA;&lt;p&gt;The following constructs are fully supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;variables&lt;/li&gt; &#xA; &lt;li&gt;tuples&lt;/li&gt; &#xA; &lt;li&gt;constructors&lt;/li&gt; &#xA; &lt;li&gt;if statements&lt;/li&gt; &#xA; &lt;li&gt;infix expressions and types&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;_&lt;/code&gt; patterns&lt;/li&gt; &#xA; &lt;li&gt;aliased patterns&lt;/li&gt; &#xA; &lt;li&gt;lists (including list comprehensions)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;do&lt;/code&gt;-notation&lt;/li&gt; &#xA; &lt;li&gt;sections&lt;/li&gt; &#xA; &lt;li&gt;undefined&lt;/li&gt; &#xA; &lt;li&gt;error&lt;/li&gt; &#xA; &lt;li&gt;class constraints (though these sometimes fail with &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;lambda&lt;/code&gt;, and &lt;code&gt;case&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;literal expressions (for &lt;code&gt;Natural&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, and &lt;code&gt;Char&lt;/code&gt;), including overloaded number literals&lt;/li&gt; &#xA; &lt;li&gt;datatypes that store &lt;code&gt;Natural&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;unboxed tuples (which are treated as normal tuples)&lt;/li&gt; &#xA; &lt;li&gt;pattern guards&lt;/li&gt; &#xA; &lt;li&gt;case&lt;/li&gt; &#xA; &lt;li&gt;let&lt;/li&gt; &#xA; &lt;li&gt;lambda expressions&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;!&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; patterns (silently but successfully ignored during promotion)&lt;/li&gt; &#xA; &lt;li&gt;class and instance declarations&lt;/li&gt; &#xA; &lt;li&gt;signatures (e.g., &lt;code&gt;(x :: Maybe a)&lt;/code&gt;) in expressions&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;InstanceSigs&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Partial support&lt;/h2&gt; &#xA;&lt;p&gt;The following constructs are partially supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;deriving&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;finite arithmetic sequences&lt;/li&gt; &#xA; &lt;li&gt;records&lt;/li&gt; &#xA; &lt;li&gt;signatures (e.g., &lt;code&gt;(x :: Maybe a)&lt;/code&gt;) in patterns&lt;/li&gt; &#xA; &lt;li&gt;functional dependencies&lt;/li&gt; &#xA; &lt;li&gt;type families&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;wildcard types&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the following sections for more details.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;deriving&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;singletons-th&lt;/code&gt; is slightly more conservative with respect to &lt;code&gt;deriving&lt;/code&gt; than GHC is. The only classes that &lt;code&gt;singletons-th&lt;/code&gt; can derive without an explicit deriving strategy are the following stock classes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Show&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Bounded&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Functor&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Foldable&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Traversable&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To do anything more exotic, one must explicitly indicate one&#39;s intentions by using the &lt;code&gt;DerivingStrategies&lt;/code&gt; extension. &lt;code&gt;singletons-th&lt;/code&gt; fully supports the &lt;code&gt;anyclass&lt;/code&gt; strategy as well as the &lt;code&gt;stock&lt;/code&gt; strategy (at least, for the classes listed above). &lt;code&gt;singletons-th&lt;/code&gt; does not support the &lt;code&gt;newtype&lt;/code&gt; or &lt;code&gt;via&lt;/code&gt; strategies, as there is no equivalent of &lt;code&gt;coerce&lt;/code&gt; at the type level.&lt;/p&gt; &#xA;&lt;h3&gt;Finite arithmetic sequences&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;singletons-th&lt;/code&gt; has partial support for arithmetic sequences (which desugar to methods from the &lt;code&gt;Enum&lt;/code&gt; class under the hood). &lt;em&gt;Finite&lt;/em&gt; sequences (e.g., [0..42]) are fully supported. However, &lt;em&gt;infinite&lt;/em&gt; sequences (e.g., [0..]), which desugar to calls to &lt;code&gt;enumFromTo&lt;/code&gt; or &lt;code&gt;enumFromThenTo&lt;/code&gt;, are not supported, as these would require using infinite lists at the type level.&lt;/p&gt; &#xA;&lt;h3&gt;Records&lt;/h3&gt; &#xA;&lt;p&gt;Record selectors are promoted to top-level functions, as there is no record syntax at the type level. Record selectors are also singled to top-level functions because embedding records directly into singleton data constructors can result in surprising behavior (see &lt;a href=&#34;https://github.com/goldfirere/singletons/issues/364&#34;&gt;this bug report&lt;/a&gt; for more details on this point). TH-generated code is not affected by this limitation since &lt;code&gt;singletons-th&lt;/code&gt; desugars away most uses of record syntax. On the other hand, it is not possible to write out code like &lt;code&gt;SIdentity { sRunIdentity = SIdentity STrue }&lt;/code&gt; by hand.&lt;/p&gt; &#xA;&lt;p&gt;Another caveat is that GHC allows defining so-called &#34;naughty&#34; record selectors that mention existential type variables that do not appear in the constructor&#39;s return type. Naughty record selectors can be used in pattern matching, but they cannot be used as top-level functions. Here is one example of a naughty record selector:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;data Some :: (Type -&amp;gt; Type) -&amp;gt; Type where&#xA;  MkSome :: { getSome :: f a } -&amp;gt; Some f&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because &lt;code&gt;singletons-th&lt;/code&gt; promotes all records to top-level functions, however, attempting to promote &lt;code&gt;getSome&lt;/code&gt; will result in an invalid definition. (It may typecheck, but it will not behave like you would expect.) Theoretically, &lt;code&gt;singletons-th&lt;/code&gt; could refrain from promoting naughty record selectors, but this would require detecting which type variables in a data constructor are existentially quantified. This is very challenging in general, so we stick to the dumb-but-predictable approach of always promoting record selectors, regardless of whether they are naughty or not.&lt;/p&gt; &#xA;&lt;h3&gt;Signatures in patterns&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;singletons-th&lt;/code&gt; can promote basic pattern signatures, such as in the following examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;f :: forall a. a -&amp;gt; a&#xA;f (x :: a) = (x :: a)&#xA;&#xA;g :: forall a. a -&amp;gt; a&#xA;g (x :: b) = (x :: b) -- b is the same as a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What does /not/ work are more advanced uses of pattern signatures that take advantage of the fact that type variables in pattern signatures can alias other types. Here are some examples of functions that one cannot promote:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;h :: a -&amp;gt; a -&amp;gt; a&#xA;h (x :: a) (_ :: b) = x&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This typechecks by virtue of the fact that &lt;code&gt;b&lt;/code&gt; aliases &lt;code&gt;a&lt;/code&gt;. However, the same trick does not work when &lt;code&gt;h&lt;/code&gt; is promoted to a type family, as a type family would consider &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be distinct type variables.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;i :: Bool -&amp;gt; Bool&#xA;i (x :: a) = x&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This typechecks by virtue of the fact that &lt;code&gt;a&lt;/code&gt; aliases &lt;code&gt;Bool&lt;/code&gt;. Again, this would not work at the type level, as a type family would consider &lt;code&gt;a&lt;/code&gt; to be a separate type from &lt;code&gt;Bool&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Functional dependencies&lt;/h3&gt; &#xA;&lt;p&gt;Inference dependent on functional dependencies is unpredictably bad. The problem is that a use of an associated type family tied to a class with fundeps doesn&#39;t provoke the fundep to kick in. This is GHC&#39;s problem, in the end.&lt;/p&gt; &#xA;&lt;h3&gt;Type families&lt;/h3&gt; &#xA;&lt;p&gt;Promoting functions with types that contain type families is likely to fail due to &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/issues/12564&#34;&gt;GHC#12564&lt;/a&gt;. Note that promoting type family &lt;em&gt;declarations&lt;/em&gt; is fine (and often desired, since that produces defunctionalization symbols for them).&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Currently, &lt;code&gt;singletons-th&lt;/code&gt; will only promote or single code that uses &lt;code&gt;TypeApplications&lt;/code&gt; syntax in one specific situation: when type applications are used in data constructor patterns, such as in the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;foo :: Maybe a -&amp;gt; [a]&#xA;foo (Just @a x)  = [x :: a]&#xA;foo (Nothing @a) = [] :: [a]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For all other forms of &lt;code&gt;TypeApplications&lt;/code&gt;, &lt;code&gt;singletons-th&lt;/code&gt; will simply drop any visible type applications. For example, &lt;code&gt;id @Bool True&lt;/code&gt; will be promoted to &lt;code&gt;Id True&lt;/code&gt; and singled to &lt;code&gt;sId STrue&lt;/code&gt;. See &lt;a href=&#34;https://github.com/goldfirere/singletons/issues/378&#34;&gt;#378&lt;/a&gt; for a discussion of how &lt;code&gt;singletons-th&lt;/code&gt; may support &lt;code&gt;TypeApplications&lt;/code&gt; in more places in the future.&lt;/p&gt; &#xA;&lt;p&gt;On the other hand, &lt;code&gt;singletons-th&lt;/code&gt; does make an effort to preserve the order of type variables when promoting and singling certain constructors. These include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Kind signatures of promoted top-level functions&lt;/li&gt; &#xA; &lt;li&gt;Type signatures of singled top-level functions&lt;/li&gt; &#xA; &lt;li&gt;Kind signatures of singled data type declarations&lt;/li&gt; &#xA; &lt;li&gt;Type signatures of singled data constructors&lt;/li&gt; &#xA; &lt;li&gt;Kind signatures of singled class declarations&lt;/li&gt; &#xA; &lt;li&gt;Type signatures of singled class methods&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example, consider this type signature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;const2 :: forall b a. a -&amp;gt; b -&amp;gt; a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The promoted version of &lt;code&gt;const&lt;/code&gt; will have the following kind signature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Const2 :: forall b a. a -&amp;gt; b -&amp;gt; a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The singled version of &lt;code&gt;const2&lt;/code&gt; will have the following type signature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sConst2 :: forall b a (x :: a) (y :: a). Sing x -&amp;gt; Sing y -&amp;gt; Sing (Const x y)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Therefore, writing &lt;code&gt;const2 @T1 @T2&lt;/code&gt; works just as well as writing &lt;code&gt;Const2 @T1 @T2&lt;/code&gt; or &lt;code&gt;sConst2 @T1 @T2&lt;/code&gt;, since the signatures for &lt;code&gt;const2&lt;/code&gt;, &lt;code&gt;Const2&lt;/code&gt;, and &lt;code&gt;sConst2&lt;/code&gt; all begin with &lt;code&gt;forall b a.&lt;/code&gt;, in that order. Again, it is worth emphasizing that the TH machinery does not support promoting or singling &lt;code&gt;const2 @T1 @T2&lt;/code&gt; directly, but you can write the type applications by hand if you so choose.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;singletons-th&lt;/code&gt; also has limited support for preserving the order of type variables for the following constructs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Kind signatures of defunctionalization symbols. The order of type variables is only guaranteed to be preserved if:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;The thing being defunctionalized has a standalone type (or kind) signature.&lt;/li&gt; &#xA;   &lt;li&gt;The type (or kind) signature of the thing being defunctionalized is a vanilla type. (See the &#34;Rank-n types&#34; section above for what &#34;vanilla&#34; means.)&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;p&gt;If either of these conditions do not hold, &lt;code&gt;singletons-th&lt;/code&gt; will fall back to a slightly different approach to generating defunctionalization symbols that does &lt;em&gt;not&lt;/em&gt; guarantee the order of type variables. As an example, consider the following example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data T (x :: a) :: forall b. b -&amp;gt; Type&#xA;$(genDefunSymbols [&#39;&#39;T])&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The kind of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;forall a. a -&amp;gt; forall b. b -&amp;gt; Type&lt;/code&gt;, which is not vanilla. Currently, &lt;code&gt;singletons-th&lt;/code&gt; will generate the following defunctionalization symbols for &lt;code&gt;T&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data TSym0 :: a ~&amp;gt; b ~&amp;gt; Type&#xA;data TSym1 (x :: a) :: b ~&amp;gt; Type&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In both symbols, the kind starts with &lt;code&gt;forall a b.&lt;/code&gt; rather than quantifying the &lt;code&gt;b&lt;/code&gt; after the visible argument of kind &lt;code&gt;a&lt;/code&gt;. These symbols can still be useful even with this flaw, so &lt;code&gt;singletons-th&lt;/code&gt; permits generating them regardless. Be aware of this drawback if you try doing something similar yourself!&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Kind signatures of promoted class methods. The order of type variables will often &#34;just work&#34; by happy coincidence, but there are some situations where this does not happen. Consider the following class:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class C (b :: Type) where&#xA;  m :: forall a. a -&amp;gt; b -&amp;gt; a&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The full type of &lt;code&gt;m&lt;/code&gt; is &lt;code&gt;forall b. C b =&amp;gt; forall a. a -&amp;gt; b -&amp;gt; a&lt;/code&gt;, which binds &lt;code&gt;b&lt;/code&gt; before &lt;code&gt;a&lt;/code&gt;. This order is preserved when singling &lt;code&gt;m&lt;/code&gt;, but &lt;em&gt;not&lt;/em&gt; when promoting &lt;code&gt;m&lt;/code&gt;. This is because the &lt;code&gt;C&lt;/code&gt; class is promoted as follows:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class PC (b :: Type) where&#xA;  type M (x :: a) (y :: b) :: a&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Due to the way GHC kind-checks associated type families, the kind of &lt;code&gt;M&lt;/code&gt; is &lt;code&gt;forall a b. a -&amp;gt; b -&amp;gt; a&lt;/code&gt;, which binds &lt;code&gt;b&lt;/code&gt; &lt;em&gt;after&lt;/em&gt; &lt;code&gt;a&lt;/code&gt;. Moreover, the &lt;code&gt;StandaloneKindSignatures&lt;/code&gt; extension does not provide a way to explicitly declare the full kind of an associated type family, so this limitation is not easy to work around.&lt;/p&gt; &lt;p&gt;The defunctionalization symbols for &lt;code&gt;M&lt;/code&gt; will also follow a similar order of type variables:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type MSym0 :: forall a b. a ~&amp;gt; b ~&amp;gt; a&#xA;type MSym1 :: forall a b. a -&amp;gt; b ~&amp;gt; a&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Wildcard types&lt;/h3&gt; &#xA;&lt;p&gt;Currently, &lt;code&gt;singletons-th&lt;/code&gt; can only handle promoting or singling wildcard types if they appear within type applications in data constructor patterns, such as in the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;bar :: Maybe () -&amp;gt; Bool&#xA;bar (Nothing @_) = False&#xA;bar (Just ())    = True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;singletons-th&lt;/code&gt; will error if trying to promote or single a wildcard type in any other context. Ultimately, this is due to a GHC restriction, as GHC itself will forbid using wildcards in most kind-level contexts. For example, GHC will permit &lt;code&gt;f :: _&lt;/code&gt; but reject &lt;code&gt;type F :: _&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Support for promotion, but not singling&lt;/h2&gt; &#xA;&lt;p&gt;The following constructs are supported for promotion but not singleton generation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;data constructors with contexts&lt;/li&gt; &#xA; &lt;li&gt;overlapping patterns&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;instances of poly-kinded type classes&lt;/li&gt; &#xA; &lt;li&gt;literal patterns&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the following sections for more details.&lt;/p&gt; &#xA;&lt;h3&gt;Data constructors with contexts&lt;/h3&gt; &#xA;&lt;p&gt;For example, the following datatype does not single:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data T a where&#xA;  MkT :: Show a =&amp;gt; a -&amp;gt; T a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Constructors like these do not interact well with the current design of the &lt;code&gt;SingKind&lt;/code&gt; class. But see &lt;a href=&#34;https://github.com/goldfirere/singletons/issues/150&#34;&gt;this bug report&lt;/a&gt;, which proposes a redesign for &lt;code&gt;SingKind&lt;/code&gt; (in a future version of GHC with certain bugfixes) which could permit constructors with equality constraints.&lt;/p&gt; &#xA;&lt;h3&gt;Overlapping patterns&lt;/h3&gt; &#xA;&lt;p&gt;Overlapping patterns pose a challenge for singling. Consider this implementation of &lt;code&gt;isNothing&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;isNothing :: Maybe a -&amp;gt; Bool&#xA;isNothing Nothing = True&#xA;isNothing _       = False&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we single this in a naïve way, we would end up with something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;sIsNothing :: forall a (m :: Maybe a). Sing m -&amp;gt; Sing (IsNothing m)&#xA;sIsNothing SNothing = STrue&#xA;sIsNothing _        = SFalse&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This won&#39;t typecheck, however. The issue is that due to the way GADT pattern matches are typechecked in GHC, the second equation of &lt;code&gt;sIsNothing&lt;/code&gt; has no way of knowing that &lt;code&gt;m&lt;/code&gt; should be equal to &lt;code&gt;Just&lt;/code&gt;, even though the first equation already matched &lt;code&gt;m&lt;/code&gt; against &lt;code&gt;Nothing&lt;/code&gt;. As a result, &lt;code&gt;IsNothing m&lt;/code&gt; will not reduce in the second equation, which means that the &lt;code&gt;SFalse&lt;/code&gt;, the right-hand side, will not typecheck.&lt;/p&gt; &#xA;&lt;p&gt;Often times, one can work around the issue by &#34;match flattening&#34; the definition. Match flattening works by removing problematic wildcard patterns in favor of enumerating all possible constructors of the data type being matched against. Here are the match-flattened versions of &lt;code&gt;isNothing&lt;/code&gt; and &lt;code&gt;sIsNothing&lt;/code&gt;, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;isNothing :: Maybe a -&amp;gt; Bool&#xA;isNothing Nothing  = True&#xA;isNothing (Just _) = False&#xA;&#xA;sIsNothing :: forall a (m :: Maybe a). Sing m -&amp;gt; Sing (IsNothing m)&#xA;sIsNothing SNothing  = STrue&#xA;sIsNothing (SJust _) = SFalse&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now each equation matches on a data constructor of &lt;code&gt;Maybe&lt;/code&gt;, so all is well. Note that the wildcard pattern inside of &lt;code&gt;Just _&lt;/code&gt; is fine. The only time a wildcard pattern is problematic is when it prevents a type family in the type signature from reducing (e.g., &lt;code&gt;IsNothing&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Be warned that match flattening is not a perfect workaround. If you have a function with n arguments that need to be flattened, then the flattened version will have approximately n² equations. Nevertheless, it is the only workaround available at the moment.&lt;/p&gt; &#xA;&lt;p&gt;Note that overlapping patterns are sometimes not obvious. For example, the &lt;code&gt;filter&lt;/code&gt; function does not single due to overlapping patterns:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;filter :: (a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; [a]&#xA;filter _pred []    = []&#xA;filter pred (x:xs)&#xA;  | pred x         = x : filter pred xs&#xA;  | otherwise      = filter pred xs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Overlap is caused by &lt;code&gt;otherwise&lt;/code&gt; catch-all guard, which is always true and thus overlaps with &lt;code&gt;pred x&lt;/code&gt; guard. This can be workaround by either replacing the guards with an &lt;code&gt;if pred x then ... else ...&lt;/code&gt; expression or a &lt;code&gt;case pred x of { True -&amp;gt; ...; False -&amp;gt; ...}&lt;/code&gt; expression.&lt;/p&gt; &#xA;&lt;p&gt;Another non-obvious source of overlapping patterns comes from partial pattern matches in &lt;code&gt;do&lt;/code&gt;-notation. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;f :: [()]&#xA;f = do&#xA;  Just () &amp;lt;- [Nothing]&#xA;  return ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This has overlap because the partial pattern match desugars to the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;f :: [()]&#xA;f = case [Nothing] of&#xA;      Just () -&amp;gt; return ()&#xA;      _ -&amp;gt; fail &#34;Partial pattern match in do notation&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, it is more evident that the catch-all pattern &lt;code&gt;_&lt;/code&gt; overlaps with the one above it. Again, this can be worked around by rewriting the partial pattern match to an explicit &lt;code&gt;case&lt;/code&gt; expression that matches on both &lt;code&gt;Just&lt;/code&gt; and &lt;code&gt;Nothing&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Singling GADTs is likely to fail due to the generated &lt;code&gt;SingKind&lt;/code&gt; instances not typechecking. (See &lt;a href=&#34;https://github.com/goldfirere/singletons/issues/150&#34;&gt;#150&lt;/a&gt;). However, one can often work around the issue by suppressing the generation of &lt;code&gt;SingKind&lt;/code&gt; instances by using custom &lt;code&gt;Options&lt;/code&gt;. See the &lt;code&gt;T150&lt;/code&gt; test case for an example.&lt;/p&gt; &#xA;&lt;h3&gt;Instances of poly-kinded type classes&lt;/h3&gt; &#xA;&lt;p&gt;Singling instances of poly-kinded type classes is likely to fail due to &lt;a href=&#34;https://github.com/goldfirere/singletons/issues/358&#34;&gt;#358&lt;/a&gt;. However, one can often work around the issue by using &lt;code&gt;InstanceSigs&lt;/code&gt;. For instance, the following code will not single:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class C (f :: k -&amp;gt; Type) where&#xA;  method :: f a&#xA;&#xA;instance C [] where&#xA;  method = []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Adding a type signature for &lt;code&gt;method&lt;/code&gt; in the &lt;code&gt;C []&lt;/code&gt; is sufficient to work around the issue, though:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance C [] where&#xA;  method :: [a]&#xA;  method = []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Literal patterns&lt;/h3&gt; &#xA;&lt;p&gt;Patterns which match on numeric, string, or character literals cannot be singled. Using this code as an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;isZero :: Natural -&amp;gt; Bool&#xA;isZero 0 = True&#xA;isZero _ = False&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Due to the way that the singled version of &lt;code&gt;Natural&lt;/code&gt; works, this code would need to be singled into something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;sIsZero :: forall (n :: Natural). Sing n -&amp;gt; Sing (IsZero n)&#xA;sIsZero sn =&#xA;  case sameNat sn (SNat @0) of&#xA;    Just Refl -&amp;gt; STrue&#xA;    Nothing   -&amp;gt; SFalse&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This runs into the same issues with overlapping patterns discussed earlier. Unfortunately, there is not a good workaround this time. It is impossible to match-flatten &lt;code&gt;isZero&lt;/code&gt; since there are infinitely many &lt;code&gt;Natural&lt;/code&gt; patterns.&lt;/p&gt; &#xA;&lt;p&gt;If you &lt;em&gt;really&lt;/em&gt; want to make something like this work, one can write &lt;code&gt;unsafeCoerce SFalse&lt;/code&gt; to force it to typecheck. The &lt;code&gt;singletons-base&lt;/code&gt; library itself uses this trick in certain places when it has no other alternatives. See the source code for the &lt;code&gt;SEq Natural&lt;/code&gt; instance for inspiration. &lt;code&gt;singletons-th&lt;/code&gt; will not generate such code for you, however, so if you want to reach for &lt;code&gt;unsafeCoerce&lt;/code&gt;, you are on your own.&lt;/p&gt; &#xA;&lt;h2&gt;Support for singling, but not promotion&lt;/h2&gt; &#xA;&lt;p&gt;The following constructs are supported for singleton generation but not promotion:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;bang patterns&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the following sections for more details.&lt;/p&gt; &#xA;&lt;h3&gt;Bang patterns&lt;/h3&gt; &#xA;&lt;p&gt;Bang patterns (e.g., &lt;code&gt;f !x = (x, x)&lt;/code&gt;) cannot be translated to a type-level setting as type families lack an equivalent of bang patterns. As a result, &lt;code&gt;singletons-th&lt;/code&gt; will ignore any bang patterns and will simply promote the underyling pattern instead.&lt;/p&gt; &#xA;&lt;h2&gt;Little to no support&lt;/h2&gt; &#xA;&lt;p&gt;The following constructs are either unsupported or almost never work:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;scoped type variables&lt;/li&gt; &#xA; &lt;li&gt;datatypes that store arrows or &lt;code&gt;Symbol&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;rank-n types&lt;/li&gt; &#xA; &lt;li&gt;promoting &lt;code&gt;TypeRep&lt;/code&gt;s&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Irrefutable patterns&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{-# UNPACK #-}&lt;/code&gt; pragmas&lt;/li&gt; &#xA; &lt;li&gt;partial application of the &lt;code&gt;(-&amp;gt;)&lt;/code&gt; type&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the following sections for more details.&lt;/p&gt; &#xA;&lt;h3&gt;Scoped type variables&lt;/h3&gt; &#xA;&lt;p&gt;Promoting functions that rely on the behavior of &lt;code&gt;ScopedTypeVariables&lt;/code&gt; is very tricky—see &lt;a href=&#34;https://github.com/goldfirere/singletons/issues/433&#34;&gt;this GitHub issue&lt;/a&gt; for an extended discussion on the topic. This is not to say that promoting functions that rely on &lt;code&gt;ScopedTypeVariables&lt;/code&gt; is guaranteed to fail, but it is rather fragile. To demonstrate how fragile this is, note that the following function will promote successfully:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;f :: forall a. a -&amp;gt; a&#xA;f x = id x :: a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But this one will not:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;g :: forall a. a -&amp;gt; a&#xA;g x = id (x :: a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are usually workarounds one can use instead of &lt;code&gt;ScopedTypeVariables&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Use pattern signatures:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;g :: forall a. a -&amp;gt; a&#xA;g (x :: a) = id (x :: a)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Use local definitions:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;g :: forall a. a -&amp;gt; a&#xA;g x = id&#39; a&#xA;  where&#xA;    id&#39; :: a -&amp;gt; a&#xA;    id&#39; x = x&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Arrows, &lt;code&gt;Symbol&lt;/code&gt;, and literals&lt;/h3&gt; &#xA;&lt;p&gt;As described in the promotion paper, automatic promotion of datatypes that store arrows is currently impossible. So if you have a declaration such as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;$(promote [d|&#xA;  data Foo = Bar (Bool -&amp;gt; Maybe Bool)&#xA;  |])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;you will quickly run into errors.&lt;/p&gt; &#xA;&lt;p&gt;Literals are problematic because we rely on GHC&#39;s built-in support, which currently is limited. Functions that operate on strings will not work because type level strings are no longer considered lists of characters. Functions working over strings can be promoted by rewriting them to use &lt;code&gt;Symbol&lt;/code&gt;. Since &lt;code&gt;Symbol&lt;/code&gt; does not exist at the term level, it will only be possible to use the promoted definition, but not the original, term-level one.&lt;/p&gt; &#xA;&lt;p&gt;For now, one way to work around this issue is to define two variants of a data type: one for use at the value level, and one for use at the type level. The example below demonstrates this workaround in the context of a data type that has a &lt;code&gt;Symbol&lt;/code&gt; field:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;import Data.Kind&#xA;import Data.Singletons.TH&#xA;import Data.Singletons.TH.Options&#xA;import Data.Text (Text)&#xA;import GHC.TypeLits.Singletons&#xA;import Language.Haskell.TH (Name)&#xA;&#xA;-- Term-level&#xA;newtype Message = MkMessage Text&#xA;-- Type-level&#xA;newtype PMessage = PMkMessage Symbol&#xA;&#xA;$(let customPromote :: Name -&amp;gt; Name&#xA;      customPromote n&#xA;        | n == &#39;&#39;Message  = &#39;&#39;PMessage&#xA;        | n == &#39;MkMessage = &#39;PMkMessage&#xA;        | n == &#39;&#39;Text     = &#39;&#39;Symbol&#xA;        | otherwise       = promotedDataTypeOrConName defaultOptions n&#xA;&#xA;      customDefun :: Name -&amp;gt; Int -&amp;gt; Name&#xA;      customDefun n sat = defunctionalizedName defaultOptions (customPromote n) sat in&#xA;&#xA;  withOptions defaultOptions{ promotedDataTypeOrConName = customPromote&#xA;                            , defunctionalizedName      = customDefun&#xA;                            } $ do&#xA;    decs1 &amp;lt;- genSingletons [&#39;&#39;Message]&#xA;    decs2 &amp;lt;- singletons [d|&#xA;               hello :: Message&#xA;               hello = MkMessage &#34;hello&#34;&#xA;               |]&#xA;    return $ decs1 ++ decs2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is breakdown of what each part of this code is doing:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Message&lt;/code&gt; defines a data type with a field of type &lt;code&gt;Text&lt;/code&gt; (from &lt;code&gt;Data.Text&lt;/code&gt;). &lt;code&gt;PMessage&lt;/code&gt; is what we wish to be the promoted counterpart to &lt;code&gt;Message&lt;/code&gt;. The &#34;&lt;code&gt;P&lt;/code&gt;&#34; in &lt;code&gt;PMessage&lt;/code&gt; stands for &#34;promoted&#34;, but this is naming convention is not strictly enforced; you may name your types however you choose.&lt;/p&gt; &lt;p&gt;&lt;code&gt;PMessage&lt;/code&gt; is identical to &lt;code&gt;Message&lt;/code&gt; modulo names and the use of &lt;code&gt;Symbol&lt;/code&gt; instead of &lt;code&gt;Text&lt;/code&gt;. The choice of &lt;code&gt;Symbol&lt;/code&gt; is intentional, since &lt;code&gt;Demote Symbol = Text&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;customPromote&lt;/code&gt; defines a mapping from Template Haskell &lt;code&gt;Name&lt;/code&gt;s to their promoted &lt;code&gt;Name&lt;/code&gt; equivalents. We define special cases for the three special types in our program: &lt;code&gt;Message&lt;/code&gt; (which will promote to &lt;code&gt;PMessage&lt;/code&gt;), &lt;code&gt;MkMessage&lt;/code&gt; (which will promote to &lt;code&gt;PMkMessage&lt;/code&gt;), and &lt;code&gt;Text&lt;/code&gt; (which will promote to &lt;code&gt;Symbol&lt;/code&gt;). All other names will go through the default &lt;code&gt;promotedDataTypeOrConName&lt;/code&gt; hook (from &lt;code&gt;Data.Singletons.TH.Options&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;customDefun&lt;/code&gt; is like &lt;code&gt;customPromote&lt;/code&gt;, but it handles defunctionalization symbols in particular (see the &#34;Promotion and partial application&#34; section). This is needed to ensure that partial applications of &lt;code&gt;MkMessage&lt;/code&gt; are promoted to &lt;code&gt;PMkMessageSym0&lt;/code&gt; rather than &lt;code&gt;MkMessageSym0&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;We use &lt;code&gt;customPromote&lt;/code&gt; and &lt;code&gt;customDefun&lt;/code&gt; to override the &lt;code&gt;defaultOptions&lt;/code&gt; for the Template Haskell machinery. This will ensure that everything in the last argument to &lt;code&gt;withOptions&lt;/code&gt; will recognize the names &lt;code&gt;Message&lt;/code&gt;, &lt;code&gt;MkMessage&lt;/code&gt;, and &lt;code&gt;Symbol&lt;/code&gt;, promoting them according to our custom rules.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;genSingletons [&#39;&#39;Message]&lt;/code&gt; generates a &lt;code&gt;Sing&lt;/code&gt; instance for &lt;code&gt;PMessage&lt;/code&gt;, defunctionalization symbols for &lt;code&gt;PMkMessage&lt;/code&gt;, etc. These are needed for the next part of the code.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Finally, the &lt;code&gt;hello&lt;/code&gt; function is promoted and singled using the Template Haskell machinery. Note that the literal &lt;code&gt;&#34;hello&#34;&lt;/code&gt; works as both &lt;code&gt;Text&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; a &lt;code&gt;Symbol&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Besides &lt;code&gt;Text&lt;/code&gt;/&lt;code&gt;Symbol&lt;/code&gt;, another common use case for this technique is higher-order functions, e.g.,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;-- Term-level&#xA;newtype Function a b = MkFunction (a -&amp;gt; b)&#xA;-- Type-level&#xA;newtype PFunction a b = PMkFunction (a ~&amp;gt; b)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rank-n types&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;singletons-th&lt;/code&gt; does not support type signatures that have higher-rank types. More precisely, the only types that can be promoted or singled are &lt;em&gt;vanilla&lt;/em&gt; types, where a vanilla function type is a type that:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Only uses a &lt;code&gt;forall&lt;/code&gt; at the top level, if used at all. That is to say, it does not contain any nested or higher-rank &lt;code&gt;forall&lt;/code&gt;s.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Only uses a context (e.g., &lt;code&gt;c =&amp;gt; ...&lt;/code&gt;) at the top level, if used at all, and only after the top-level &lt;code&gt;forall&lt;/code&gt; if one is present. That is to say, it does not contain any nested or higher-rank contexts.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Contains no visible dependent quantification.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Promoting &lt;code&gt;TypeRep&lt;/code&gt;s&lt;/h3&gt; &#xA;&lt;p&gt;The built-in Haskell promotion mechanism does not yet have a full story around the kind &lt;code&gt;*&lt;/code&gt; (the kind of types that have values). Ideally, promoting some form of &lt;code&gt;TypeRep&lt;/code&gt; would yield &lt;code&gt;*&lt;/code&gt;, but the implementation of &lt;code&gt;TypeRep&lt;/code&gt; would have to be updated for this to really work out. In the meantime, users who wish to experiment with this feature have two options:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;The module &lt;code&gt;Data.Singletons.Base.TypeRepTYPE&lt;/code&gt; (from &lt;code&gt;singletons-base&lt;/code&gt;) has all the definitions possible for making &lt;code&gt;*&lt;/code&gt; the promoted version of &lt;code&gt;TypeRep&lt;/code&gt;, as &lt;code&gt;TypeRep&lt;/code&gt; is currently implemented. The singleton associated with &lt;code&gt;TypeRep&lt;/code&gt; has one constructor:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type instance Sing @(TYPE rep) = TypeRep&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;(Recall that &lt;code&gt;type * = TYPE LiftedRep&lt;/code&gt;.) Note that any datatypes that store &lt;code&gt;TypeRep&lt;/code&gt;s will not generally work as expected; the built-in promotion mechanism will not promote &lt;code&gt;TypeRep&lt;/code&gt; to &lt;code&gt;*&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The module &lt;code&gt;Data.Singletons.TH.CustomStar&lt;/code&gt; (from &lt;code&gt;singletons-th&lt;/code&gt;) allows the programmer to define a subset of types with which to work. See the Haddock documentation for the function &lt;code&gt;singletonStar&lt;/code&gt; for more info.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Irrefutable patterns&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;singletons-th&lt;/code&gt; will ignore irrefutable patterns (e.g., &lt;code&gt;f ~(x, y) = (y, x)&lt;/code&gt;) and will simply promote or single the underlying patterns instead. &lt;code&gt;singletons-th&lt;/code&gt; cannot promote irrefutable patterns for the same reason it cannot promote bang patterns: there is no equivalent syntax for type families. Moreover, &lt;code&gt;singletons-th&lt;/code&gt; cannot single irrefutable patterns since singled data constructors are implemented as GADTs, as irrefutably matching on a GADT constructor will not bring the underlying type information into scope. Since essentially all singled code relies on using GADT type information in this way, it cannot reasonably be combined with irrefutable patterns, which prevent this key feature of GADT pattern matching.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;{-# UNPACK #-}&lt;/code&gt; pragmas&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;singletons-th&lt;/code&gt; will ignore &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; pragmas on the fields of a data constructor (e.g., &lt;code&gt;data T = MkT {-# UNPACK #-} !()&lt;/code&gt;). This is because singled data types represent their argument types using existential type variables, and any data constructor that explicitly uses existential quantification cannot be unpacked. See &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/-/issues/10016&#34;&gt;GHC#10016&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Partial application of the &lt;code&gt;(-&amp;gt;)&lt;/code&gt; type&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;singletons-th&lt;/code&gt; can only promote &lt;code&gt;(-&amp;gt;)&lt;/code&gt; when it is applied to exactly two arguments. Attempting to promote &lt;code&gt;(-&amp;gt;)&lt;/code&gt; to zero or one argument will result in an error. As a consequence, it is impossible to promote instances like the &lt;code&gt;Functor ((-&amp;gt;) r)&lt;/code&gt; instance, so &lt;code&gt;singletons-base&lt;/code&gt; does not provide them.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>upenn-cis5520/empty-project</title>
    <updated>2022-11-16T01:34:11Z</updated>
    <id>tag:github.com,2022-11-16:/upenn-cis5520/empty-project</id>
    <link href="https://github.com/upenn-cis5520/empty-project" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;project-cis5520&lt;/h1&gt; &#xA;&lt;p&gt;This is an &#34;Empty project&#34; for Haskell. It is configured in the same way as the lecture demo and homework assignments for CIS 5520, but contains no code. Feel free to use this project for experimentation!&lt;/p&gt; &#xA;&lt;p&gt;If you want to change the name of this project, look for all occurrences of &lt;code&gt;project-cis5520&lt;/code&gt; in the &lt;code&gt;project-cis5520.cabal&lt;/code&gt; file. (And change the name of the file to match!)&lt;/p&gt; &#xA;&lt;h2&gt;Module organization&lt;/h2&gt; &#xA;&lt;p&gt;Haskell packages typically divide their source code into three separate places:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The bulk of your code should be developed as a reusable library in modules in the &lt;code&gt;src&lt;/code&gt; directory. We&#39;ve created &lt;a href=&#34;https://raw.githubusercontent.com/upenn-cis5520/empty-project/main/src/Lib.hs&#34;&gt;Lib.hs&lt;/a&gt; for you to get started. You can add additional modules here.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The entry point for your executable is in &lt;a href=&#34;https://raw.githubusercontent.com/upenn-cis5520/empty-project/main/app/Main.hs&#34;&gt;Main.hs&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;All of your test cases should be in &lt;a href=&#34;https://raw.githubusercontent.com/upenn-cis5520/empty-project/main/test/Spec.hs&#34;&gt;the test directory&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building, running, and testing&lt;/h2&gt; &#xA;&lt;p&gt;This project compiles with &lt;code&gt;stack build&lt;/code&gt;. You can run the main executable with &lt;code&gt;stack run&lt;/code&gt;. You can run the tests with &lt;code&gt;stack test&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Finally, you can start a REPL with &lt;code&gt;stack ghci&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Importing additional libraries&lt;/h2&gt; &#xA;&lt;p&gt;This project is designed to run with stackage: you can easily use any library in &lt;a href=&#34;https://www.stackage.org/lts-19.19&#34;&gt;https://www.stackage.org/lts-19.19&lt;/a&gt; by adding an entry to the &lt;code&gt;build-depends&lt;/code&gt; list of the &lt;code&gt;common-stanza&lt;/code&gt; in the cabal file. If you want to use a library that is not on stackage, you&#39;ll need to update the common-stanza &lt;em&gt;and&lt;/em&gt; add information to &lt;code&gt;stack.yaml&lt;/code&gt; about where to find that library.&lt;/p&gt;</summary>
  </entry>
</feed>