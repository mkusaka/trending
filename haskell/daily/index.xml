<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-03T01:38:52Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>svenssonjoel/MonadObsidian</title>
    <updated>2023-07-03T01:38:52Z</updated>
    <id>tag:github.com,2023-07-03:/svenssonjoel/MonadObsidian</id>
    <link href="https://github.com/svenssonjoel/MonadObsidian" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Embedded DSL for GPU kernel implementation&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;MonadObsidian &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Embedded DSL for implementation of GPU Kernels&lt;/li&gt; &#xA;   &lt;li&gt;Generates CUDA kernels&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>ekmett/lens</title>
    <updated>2023-07-03T01:38:52Z</updated>
    <id>tag:github.com,2023-07-03:/ekmett/lens</id>
    <link href="https://github.com/ekmett/lens" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lenses, Folds, and Traversals - Join us on web.libera.chat #haskell-lens&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Lens: Lenses, Folds, and Traversals&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/lens&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/lens.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ekmett/lens/actions?query=workflow%3AHaskell-CI&#34;&gt;&lt;img src=&#34;https://github.com/ekmett/lens/workflows/Haskell-CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://packdeps.haskellers.com/reverse/lens&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage-deps/v/lens.svg?sanitize=true&#34; alt=&#34;Hackage Deps&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This package provides families of &lt;a href=&#34;https://github.com/ekmett/lens/raw/master/src/Control/Lens/Type.hs&#34;&gt;lenses&lt;/a&gt;, &lt;a href=&#34;https://github.com/ekmett/lens/raw/master/src/Control/Lens/Iso.hs&#34;&gt;isomorphisms&lt;/a&gt;, &lt;a href=&#34;https://github.com/ekmett/lens/raw/master/src/Control/Lens/Fold.hs&#34;&gt;folds&lt;/a&gt;, &lt;a href=&#34;https://github.com/ekmett/lens/raw/master/src/Control/Lens/Traversal.hs&#34;&gt;traversals&lt;/a&gt;, &lt;a href=&#34;https://github.com/ekmett/lens/raw/master/src/Control/Lens/Getter.hs&#34;&gt;getters&lt;/a&gt; and &lt;a href=&#34;https://github.com/ekmett/lens/raw/master/src/Control/Lens/Setter.hs&#34;&gt;setters&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you are looking for where to get started, &lt;a href=&#34;http://youtu.be/cefnmjtAolY?hd=1&#34;&gt;a crash course video&lt;/a&gt; on how &lt;code&gt;lens&lt;/code&gt; was constructed and how to use the basics is available on youtube. It is best watched in high definition to see the slides, but the &lt;a href=&#34;http://comonad.com/haskell/Lenses-Folds-and-Traversals-NYC.pdf&#34;&gt;slides&lt;/a&gt; are also available if you want to use them to follow along.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/ekmett/lens/wiki/FAQ&#34;&gt;FAQ&lt;/a&gt;, which provides links to a large number of different resources for learning about lenses and an overview of the &lt;a href=&#34;https://github.com/ekmett/lens/wiki/Derivation&#34;&gt;derivation&lt;/a&gt; of these types can be found on the &lt;a href=&#34;https://github.com/ekmett/lens/wiki&#34;&gt;Lens Wiki&lt;/a&gt; along with a brief &lt;a href=&#34;https://github.com/ekmett/lens/wiki/Overview&#34;&gt;overview&lt;/a&gt; and some &lt;a href=&#34;https://github.com/ekmett/lens/wiki/Examples&#34;&gt;examples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Documentation is available through &lt;a href=&#34;http://ekmett.github.com/lens/frames.html&#34;&gt;github&lt;/a&gt; (for HEAD) or &lt;a href=&#34;http://hackage.haskell.org/package/lens&#34;&gt;hackage&lt;/a&gt; for the current and preceding releases.&lt;/p&gt; &#xA;&lt;h2&gt;Field Guide&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://creately.com/diagram/h5nyo9ne1/QZ9UBOtw4AJWtmAKYK3wT8Mm1HM%3D&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wiki/ekmett/lens/images/Hierarchy.png&#34; alt=&#34;Lens Hierarchy&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;(See &lt;a href=&#34;https://github.com/ekmett/lens/wiki/Examples&#34;&gt;&lt;code&gt;wiki/Examples&lt;/code&gt;&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;First, import &lt;code&gt;Control.Lens&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; import Control.Lens&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, you can read from lenses&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; (&#34;hello&#34;,&#34;world&#34;)^._2&#xA;&#34;world&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and you can write to lenses.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; set _2 42 (&#34;hello&#34;,&#34;world&#34;)&#xA;(&#34;hello&#34;,42)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Composing lenses for reading (or writing) goes in the order an imperative programmer would expect, and just uses &lt;code&gt;(.)&lt;/code&gt; from the &lt;code&gt;Prelude&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; (&#34;hello&#34;,(&#34;world&#34;,&#34;!!!&#34;))^._2._1&#xA;&#34;world&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; set (_2._1) 42 (&#34;hello&#34;,(&#34;world&#34;,&#34;!!!&#34;))&#xA;(&#34;hello&#34;,(42,&#34;!!!&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can make a &lt;code&gt;Getter&lt;/code&gt; out of a pure function with &lt;code&gt;to&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; &#34;hello&#34;^.to length&#xA;5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can easily compose a &lt;code&gt;Getter&lt;/code&gt; with a &lt;code&gt;Lens&lt;/code&gt; just using &lt;code&gt;(.)&lt;/code&gt;. No explicit coercion is necessary.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; (&#34;hello&#34;,(&#34;world&#34;,&#34;!!!&#34;))^._2._2.to length&#xA;3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As we saw above, you can write to lenses and these writes can change the type of the container. &lt;code&gt;(.~)&lt;/code&gt; is an infix alias for &lt;code&gt;set&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; _1 .~ &#34;hello&#34; $ ((),&#34;world&#34;)&#xA;(&#34;hello&#34;,&#34;world&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Conversely &lt;code&gt;view&lt;/code&gt;, can be used as a prefix alias for &lt;code&gt;(^.)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; view _2 (10,20)&#xA;20&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a large number of other lens variants provided by the library, in particular a &lt;code&gt;Traversal&lt;/code&gt; generalizes &lt;code&gt;traverse&lt;/code&gt; from &lt;code&gt;Data.Traversable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ll come back to those later, but continuing with just lenses:&lt;/p&gt; &#xA;&lt;p&gt;You can let the library automatically derive lenses for fields of your data type&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Foo a = Foo { _bar :: Int, _baz :: Int, _quux :: a }&#xA;makeLenses &#39;&#39;Foo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will automatically generate the following lenses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;bar, baz :: Lens&#39; (Foo a) Int&#xA;quux :: Lens (Foo a) (Foo b) a b&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;Lens&lt;/code&gt; takes 4 parameters because it can change the types of the whole when you change the type of the part.&lt;/p&gt; &#xA;&lt;p&gt;Often you won&#39;t need this flexibility, a &lt;code&gt;Lens&#39;&lt;/code&gt; takes 2 parameters, and can be used directly as a &lt;code&gt;Lens&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also write to setters that target multiple parts of a structure, or their composition with other lenses or setters. The canonical example of a setter is &#39;mapped&#39;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mapped :: Functor f =&amp;gt; Setter (f a) (f b) a b&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;over&lt;/code&gt; is then analogous to &lt;code&gt;fmap&lt;/code&gt;, but parameterized on the Setter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; fmap succ [1,2,3]&#xA;[2,3,4]&#xA;ghci&amp;gt; over mapped succ [1,2,3]&#xA;[2,3,4]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The benefit is that you can use any &lt;code&gt;Lens&lt;/code&gt; as a &lt;code&gt;Setter&lt;/code&gt;, and the composition of setters with other setters or lenses using &lt;code&gt;(.)&lt;/code&gt; yields a &lt;code&gt;Setter&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; over (mapped._2) succ [(1,2),(3,4)]&#xA;[(1,3),(3,5)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;(%~)&lt;/code&gt; is an infix alias for &#39;over&#39;, and the precedence lets you avoid swimming in parentheses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; _1.mapped._2.mapped %~ succ $ ([(42, &#34;hello&#34;)],&#34;world&#34;)&#xA;([(42, &#34;ifmmp&#34;)],&#34;world&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a number of combinators that resemble the &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, etc. operators from C/C++ for working with the monad transformers.&lt;/p&gt; &#xA;&lt;p&gt;There are &lt;code&gt;+~&lt;/code&gt;, &lt;code&gt;*~&lt;/code&gt;, etc. analogues to those combinators that work functionally, returning the modified version of the structure.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; both *~ 2 $ (1,2)&#xA;(2,4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are combinators for manipulating the current state in a state monad as well&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;fresh :: MonadState Int m =&amp;gt; m Int&#xA;fresh = id &amp;lt;+= 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Anything you know how to do with a &lt;code&gt;Foldable&lt;/code&gt; container, you can do with a &lt;code&gt;Fold&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; :m + Data.Char Data.Text.Lens&#xA;ghci&amp;gt; allOf (folded.text) isLower [&#34;hello&#34;^.packed, &#34;goodbye&#34;^.packed]&#xA;True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use this for generic programming. Combinators are included that are based on Neil Mitchell&#39;s &lt;code&gt;uniplate&lt;/code&gt;, but which have been generalized to work on or as lenses, folds, and traversals.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; :m + Data.Data.Lens&#xA;ghci&amp;gt; anyOf biplate (==&#34;world&#34;) (&#34;hello&#34;,(),[(2::Int,&#34;world&#34;)])&#xA;True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As alluded to above, anything you know how to do with a &lt;code&gt;Traversable&lt;/code&gt; you can do with a &lt;code&gt;Traversal&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; mapMOf (traverse._2) (\xs -&amp;gt; length xs &amp;lt;$ putStrLn xs) [(42,&#34;hello&#34;),(56,&#34;world&#34;)]&#xA;&#34;hello&#34;&#xA;&#34;world&#34;&#xA;[(42,5),(56,5)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Moreover, many of the lenses supplied are actually isomorphisms, that means you can use them directly as a lens or getter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; let hello = &#34;hello&#34;^.packed&#xA;&#34;hello&#34;&#xA;ghci&amp;gt; :t hello&#xA;hello :: Text&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but you can also flip them around and use them as a lens the other way with &lt;code&gt;from&lt;/code&gt;!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; hello^.from packed.to length&#xA;5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can automatically derive isomorphisms for your own newtypes with &lt;code&gt;makePrisms&lt;/code&gt;. e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype Neither a b = Neither { _nor :: Either a b } deriving (Show)&#xA;makePrisms &#39;&#39;Neither&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will automatically derive&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;_Neither :: Iso (Neither a b) (Neither c d) (Either a b) (Either c d)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;such that&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;_Neither.from _Neither = id&#xA;from _Neither._Neither = id&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can use &lt;code&gt;makeLenses&lt;/code&gt; to automatically derive isomorphisms for your own newtypes. e.g..&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;makeLenses &#39;&#39;Neither&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will automatically derive&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;nor :: Iso (Either a b) (Either c d) (Neither a b) (Neither c d)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which behaves identically to &lt;code&gt;_Neither&lt;/code&gt; above.&lt;/p&gt; &#xA;&lt;p&gt;There is also a fully operational, but simple game of &lt;a href=&#34;https://github.com/ekmett/lens/raw/master/examples/Pong.hs&#34;&gt;Pong&lt;/a&gt; in the &lt;a href=&#34;https://github.com/ekmett/lens/raw/master/examples/&#34;&gt;examples/&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;p&gt;There are also a couple of hundred examples distributed throughout the haddock documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Contact Information&lt;/h2&gt; &#xA;&lt;p&gt;Contributions and bug reports are welcome!&lt;/p&gt; &#xA;&lt;p&gt;Please feel free to contact me through GitHub or on the &lt;a href=&#34;https://web.libera.chat/#haskell-lens&#34;&gt;#haskell-lens&lt;/a&gt; or &lt;a href=&#34;https://web.libera.chat/#haskell&#34;&gt;#haskell&lt;/a&gt; IRC channel on Libera Chat.&lt;/p&gt; &#xA;&lt;p&gt;-Edward Kmett&lt;/p&gt;</summary>
  </entry>
</feed>