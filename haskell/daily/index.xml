<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-15T01:40:59Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ners/dosh</title>
    <updated>2023-06-15T01:40:59Z</updated>
    <id>tag:github.com,2023-06-15:/ners/dosh</id>
    <link href="https://github.com/ners/dosh" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The power of Haskell in your terminal!&lt;/p&gt;&lt;hr&gt;&lt;img align=&#34;left&#34; width=&#34;80&#34; height=&#34;80&#34; src=&#34;https://raw.githubusercontent.com/ners/dosh/main/assets/dosh-minimal.svg?sanitize=true&#34; alt=&#34;dosh logo&#34;&gt; &#xA;&lt;h1&gt;dosh&lt;/h1&gt; &#xA;&lt;p&gt;The power of &lt;del&gt;capitalism&lt;/del&gt; Haskell in your terminal!&lt;/p&gt; &#xA;&lt;h2&gt;What have we got here?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;dosh&lt;/code&gt; is a Haskell Read-Eval-Print Loop, or REPL for short. While other REPLs for Haskell exist, this one aims to be good enough to replace Bash as a daily driver.&lt;/p&gt; &#xA;&lt;p&gt;We offer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;syntax highlighting&lt;/li&gt; &#xA; &lt;li&gt;advanced history interaction&lt;/li&gt; &#xA; &lt;li&gt;LSP-powered autocompletion and error detection&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Really? &lt;em&gt;Haskell&lt;/em&gt; as a daily driver?&lt;/h2&gt; &#xA;&lt;p&gt;Why not? Haskell is an advanced functional programming language with an excellent blend of power and elegance that scales well as commands grow nontrivial.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;This is the Unix philosophy: Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;— &lt;cite&gt;Doug McIlroy&lt;/cite&gt;&lt;/p&gt; &#xA;&lt;p&gt;Aside from executing programs, an essential operation of the shell is to manipulate text streams that pass between programs. Many programs output structured data, which Bash is &lt;a href=&#34;https://stackoverflow.com/a/45201229&#34;&gt;notoriously bad at handling&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There are many alternatives to Bash, but they are all fundamentally boring shells. They tend to invent new domain specific languages which ultimately offer no real value as a programming language.&lt;/p&gt; &#xA;&lt;p&gt;Instead of inventing a new shell language that can do slighty more than Bash, why not go the other way around and make an existing language usable as a shell? And what language is more suitable than one that was quite literally invented as a testbed for novel uses such as this?&lt;/p&gt; &#xA;&lt;h2&gt;Why is it named &lt;code&gt;dosh&lt;/code&gt;?&lt;/h2&gt; &#xA;&lt;p&gt;Because our REPL has special handling of Haskell&#39;s &lt;a href=&#34;https://en.wikibooks.org/wiki/Haskell/do_notation&#34;&gt;&lt;code&gt;do&lt;/code&gt; notation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In Haskell, the keyword &lt;code&gt;do&lt;/code&gt; introduces a block of commands that evaluate sequentially and can depend on each other. When the user enters a &lt;code&gt;do&lt;/code&gt; block in &lt;code&gt;dosh&lt;/code&gt;, the prompt changes to &lt;code&gt;do$&lt;/code&gt;, which is also where the logo comes from.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;ve also been advised to avoid overt references to Haskell in the name (e.g. &lt;code&gt;hashell&lt;/code&gt;, &lt;code&gt;shellmonad&lt;/code&gt;), as those might spook people.&lt;/p&gt; &#xA;&lt;h2&gt;Prior art&lt;/h2&gt; &#xA;&lt;p&gt;This is not a novel idea, as evidenced by the abundance of Haskell libaries that provide shell primitives. The only novelty of this project is a snazzy REPL around them.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/turtle&#34;&gt;turtle: Shell programming, Haskell-style&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/shh&#34;&gt;shh: Simple shell scripting from Haskell&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/shelly&#34;&gt;shelly: shell-like (systems) programming in Haskell&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/litxio/ptghci&#34;&gt;ptGHCi&lt;/a&gt; is a high-powered REPL for Haskell, inspired by IPython&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://las.rs/blog/haskell-as-shell.html&#34;&gt;Using Haskell as my shell&lt;/a&gt; (2021) by Las Safin&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.haskellforall.com/2015/01/use-haskell-for-shell-scripting.html&#34;&gt;Use Haskell for shell scripting&lt;/a&gt; (2015) by Gabriella Gonzalez&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>damianfral/ghcaniuse</title>
    <updated>2023-06-15T01:40:59Z</updated>
    <id>tag:github.com,2023-06-15:/damianfral/ghcaniuse</id>
    <link href="https://github.com/damianfral/ghcaniuse" rel="alternate"></link>
    <summary type="html">&lt;p&gt;GHC language extensions table&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GHCanIUse&lt;/h1&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;GHCanIUse is a tool that generates an HTML page with a table of supported language extensions for different versions of GHC (Glasgow Haskell Compiler). It helps Haskell developers explore the language extensions available in various GHC versions and provides quick access to the corresponding documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;xdg-open $(nix build --print-out-paths)/index.html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How It Works&lt;/h2&gt; &#xA;&lt;p&gt;GHCanIUse leverages Nix to fetch specific GHC versions. By using the GHC &lt;code&gt;--supported-languages&lt;/code&gt; flag, it retrieves the list of supported language extensions for each GHC version.&lt;/p&gt; &#xA;&lt;p&gt;After obtaining the supported language extensions, GHCanIUse scrapes the web user guide for each GHC version to extract the documentation links associated with the language extensions.&lt;/p&gt; &#xA;&lt;p&gt;The gathered information is then used to generate an HTML page that presents a table with the supported language extensions for each GHC version. The table includes links to the corresponding documentation pages.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>CoolBassist/Final-year-project</title>
    <updated>2023-06-15T01:40:59Z</updated>
    <id>tag:github.com,2023-06-15:/CoolBassist/Final-year-project</id>
    <link href="https://github.com/CoolBassist/Final-year-project" rel="alternate"></link>
    <summary type="html">&lt;p&gt;My final year project, where I designed and simulated an 8-bit CPU, with an assembler and compiler.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Final-year-project&lt;/h1&gt; &#xA;&lt;p&gt;My final year project, where I designed and simulated an 8-bit CPU, with an assembler and compiler. I have also added an emulator for my CPU, but this was not part of my final year project.&lt;/p&gt; &#xA;&lt;p&gt;The below excerpts are taken from my report.&lt;/p&gt; &#xA;&lt;h2&gt;Abstract&lt;/h2&gt; &#xA;&lt;p&gt;A central processing unit (CPU) is the heart of a computer, it allows all the other components to function in unison to execute a program in memory. CPU’s have been rapidly improving for the last several decades due to breakthroughs in technology, but with this they have become complicated. Keeping this in mind, I aim to design an entire toolchain, from the compiler to the CPU with enough functionality that it can run interesting programs, but also keep it simple enough that it is reasonable for a single person to understand the entire process. In this project I have designed an 8 bit central processing unit (CPU), with all the functionality that is required to be considered Turing complete. It features an 8 bit data word, with a 16 bit address space. Alongside the CPU, I have also designed and implemented a toolchain to compile a high-level language I designed, called JWhile, this includes a compiler which takes a JWhile source program, and compiles it into my assembly language, which can be ran with my assembler that translates the assembly code into the machine code of the system, with common features such as mnemonics and labels.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/CoolBassist/Final-year-project/main/Images/Shape%20of%20Toolchain.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;CPU&lt;/h2&gt; &#xA;&lt;p&gt;The original SAP-1 is an interesting project and a great resource for learning the basics of the functionality of a CPU, however it is not very useful. There are no jump instructions, you cannot load immediate values, you cannot store values back into the memory, etc, all of which are useful features to have when writing a program. I aim to implement these features to produce the ability to create interesting programs, as well as to allow user input, and interesting output. Each component of the CPU itself uses building blocks to achieve its functionality. These building blocks are built into the Digital software purely for convenience for the end user, it is possible to reproduce the functionality of these building blocks from simple logic gates such as AND, OR, and NOT, or using off the shelf IC chips such as Malvino proposed (Lee, 2007).&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/CoolBassist/Final-year-project/main/Images/CPU%20diagram.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Assembler&lt;/h2&gt; &#xA;&lt;p&gt;An assembler is a piece of software that translates assembly code to the machine language of a system. It is used because writing machine language programs can be tedious, and error prone. One of the biggest problems with writing machine language programs is keeping track of jump 27 4.2 Assembly Grammar destinations, if code is inserted, or deleted, from before a jump instruction, the jump destination has to be updated for the new destination. When the code gets suitable large keeping track of what addresses need to be updated can quickly lead to hard to track down bugs. Assembly languages use labels to solve this issue, where a label is not strictly translated into machine language instructions, but instead is turned into a memory address by the assembler (Leventhal, 1979), so the programmer does not need to be concerned with the address of the jump destination, but rather only the location within the code.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/CoolBassist/Final-year-project/main/Images/Assembly%20Table.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Compiler&lt;/h2&gt; &#xA;&lt;p&gt;An assembly language is one where the instructions match one-to-one with the generated assembly. A high level language is one where this is not the case. There is generally a pattern to the source code, and the generated assembly, however there is not such a strict correspondence with each other. High level languages are generally easier to write programs in, and it is easier to understand the semantics of a problem being solved by a program by reading the high level source code, as opposed to reading the equivalent program in assembly. There are many different paradigms of high level languages, depending on the paradigm, a program that solves the same problem can look very different. C-style languages are typically imperative languages, where a program is a series of commands. While there are languages that adhere to the functional paradigm, where a program is based on applying and composing functions, typically “pure&#34; functions (where the function does not have any side effects). It is also important to note that a language can have many paradigms built into it, for example Java is mainly an OOP (Object Orientated Programming) language, however it is possible to write functional style programs in it, and is also an imperative language. The high-level language is called JWhile, and is based on the imperative paradigm, mainly inspired by C. This means it has the typical control flow statements, such as ‘while’, ‘if’, etc, and uses curly braces to indicate scope and blocks. The only datatype in my language are unsigned integers, however one-dimensional arrays can also be defined.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/CoolBassist/Final-year-project/main/Images/SourcecodeToTree.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;</summary>
  </entry>
</feed>