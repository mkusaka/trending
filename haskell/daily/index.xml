<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-06-19T01:30:52Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>GaloisInc/semmc</title>
    <updated>2024-06-19T01:30:52Z</updated>
    <id>tag:github.com,2024-06-19:/GaloisInc/semmc</id>
    <link href="https://github.com/GaloisInc/semmc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Stratified synthesis for learning machine code instruction semantics&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Overview&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains implementations of, and tools supporting, the Semantics of Machine Code (SemMC).&lt;/p&gt; &#xA;&lt;p&gt;Beyond machine code semantics, two different approaches to synthesis are implemented. The first is &lt;em&gt;stratified synthesis&lt;/em&gt; (based on a 2016 paper [PLDI16]&lt;em&gt;), which learns the semantics of machine code instructions from a manually-specified base set and concrete executions on the hardware of the target architecture. The second is a search-based synthesis of machine code programs from semantics using a technique called Counter-Example Guided Inductive Synthesis (CEGIS) [TR1814]&lt;/em&gt;, [OOPSLA16]_. The input to the search-based synthesis is a formula describing a transformation of machine state, while the output is a machine code program.&lt;/p&gt; &#xA;&lt;h2&gt;Repository Layout&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;semmc&lt;/em&gt; is the core library that implements some shared data types, including representations of machine code semantics at different levels of abstraction. It also implements stratified synthesis and search-based synthesis in an architecture-independent manner.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;semmc-coverage&lt;/em&gt; is a tools to measure instruction set coverage in our architecture-specific backends.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;semmc-fuzzer&lt;/em&gt; is a concrete fuzzer to compare our semantics against real hardware.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;semmc-ppc&lt;/em&gt; is the instantiation of semmc for the PowerPC architecture; it supports both 32 and 64 bit PowerPC.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;semmc-arm&lt;/em&gt; is the instantiation of semmc for the AArch32 architecture; it supports both ARM and Thumb encodings.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;semmc-toy&lt;/em&gt; is a simple demonstration architecture that shows what is required of an implementation, and is useful for testing synthesis.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;tools&lt;/em&gt; contains a C program called the &lt;em&gt;remote-runner&lt;/em&gt;, which can be used to execute machine code on remote machines (used for running concrete test cases on remote hardware e.g., and ARM or PowerPC machine).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Semantics Background&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;em&gt;semmc&lt;/em&gt; library is designed to learn semantics for machine code instructions. Its output, for each Instruction Set Architecture (ISA), is a directory of files where each file contains a formula corresponding to the semantics for an opcode in the ISA. For example, the &lt;code&gt;ADDI.sem&lt;/code&gt; file contains the semantics for the add immediate instruction in PowerPC.&lt;/p&gt; &#xA;&lt;p&gt;There are functions in &lt;em&gt;semmc&lt;/em&gt; for dealing with this representation. Formulas are loaded into a data type called &lt;code&gt;ParameterizedFormula&lt;/code&gt;, which contains formula fragments based on the &lt;code&gt;ExprBuilder&lt;/code&gt; representation of &lt;em&gt;crucible&lt;/em&gt;. This can be thought of as a convenient representation of SMT formulas.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;The dependencies of the project that are not on Hackage are specified using git submodules. To build the code with a modern version of &lt;code&gt;cabal&lt;/code&gt; (assuming you are in the root of the repository)::&lt;/p&gt; &#xA;&lt;p&gt;$ git submodule update --init $ ln -s cabal.project.newbuild cabal.project $ cabal new-configure $ cabal new-build semmc-ppc&lt;/p&gt; &#xA;&lt;h1&gt;Status&lt;/h1&gt; &#xA;&lt;p&gt;This codebase is a work in progress. PowerPC support (both 32 and 64 bit) is reasonably robust. Support for ARM (AArch32) is on-going. Eventually, we will add support for x86_64, MIPS, and RISC-V.&lt;/p&gt; &#xA;&lt;h1&gt;Notes on Freeze Files&lt;/h1&gt; &#xA;&lt;p&gt;We use the &lt;code&gt;cabal.GHC-*.config&lt;/code&gt; files to constrain dependency versions in CI. We recommand using the following command for best results before building locally::&lt;/p&gt; &#xA;&lt;p&gt;ln -s cabal.GHC-&#xA; &lt;ver&gt;&#xA;  .config cabal.project.freeze&#xA; &lt;/ver&gt;&lt;/p&gt; &#xA;&lt;p&gt;These configuration files were generated using &lt;code&gt;cabal freeze --enable-tests --enable-benchmarks&lt;/code&gt;. Note that at present, these configuration files assume a Unix-like operating system, as we do not currently test Windows on CI. If you would like to use these configuration files on Windows, you will need to make some manual changes to remove certain packages and flags::&lt;/p&gt; &#xA;&lt;p&gt;regex-posix tasty +unix unix unix-compat&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;This code is made available under the BSD3 license and without any support.&lt;/p&gt; &#xA;&lt;h1&gt;References&lt;/h1&gt; &#xA;&lt;p&gt;.. [PLDI16] &lt;a href=&#34;https://cs.stanford.edu/people/eschkufz/docs/pldi_16.pdf&#34;&gt;https://cs.stanford.edu/people/eschkufz/docs/pldi_16.pdf&lt;/a&gt; .. [TR1814] &lt;a href=&#34;http://research.cs.wisc.edu/wpis/papers/tr1814.pdf&#34;&gt;http://research.cs.wisc.edu/wpis/papers/tr1814.pdf&lt;/a&gt; .. [OOPSLA16] &lt;a href=&#34;http://pages.cs.wisc.edu/~venk/papers/oopsla16b.pdf&#34;&gt;http://pages.cs.wisc.edu/~venk/papers/oopsla16b.pdf&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>