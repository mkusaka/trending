<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-06T01:30:04Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>geniusyield/smart-order-router</title>
    <updated>2023-10-06T01:30:04Z</updated>
    <id>tag:github.com,2023-10-06:/geniusyield/smart-order-router</id>
    <link href="https://github.com/geniusyield/smart-order-router" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Open-source Smart Order Router framework to connect liquidity from the Genius Yield DEX&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;Smart Order Router&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://www.haskell.org/&#34;&gt; &lt;img alt=&#34;GitHub top language&#34; src=&#34;https://img.shields.io/github/languages/top/geniusyield/smart-order-router&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/geniusyield/smart-order-router/commits/main&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/commit-activity/m/geniusyield/smart-order-router?style=flat-square&amp;amp;label=Commit%20Activity&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/geniusyield/smart-order-router/raw/main/LICENSE&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/license/geniusyield/smart-order-router?style=flat-square&amp;amp;label=Licence&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/CONTRIBUTING.md&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://twitter.com/GeniusyieldO&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/-%40GeniusYieldO-F3F1EF?style=flat-square&amp;amp;logo=twitter&amp;amp;logoColor=1D9BF0&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://discord.gg/TNHf4fs626&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/-Discord-414EEC?style=flat-square&amp;amp;logo=discord&amp;amp;logoColor=white&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üéì &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/#crash-course-geniusyield-dex-orders--sor&#34;&gt;Crash Course&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;üöÄ &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/#building-and-running&#34;&gt;Building and running&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;üß† &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/#strategies&#34;&gt;Strategies&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;üõ†Ô∏è &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/#troubleshooting&#34;&gt;Troubleshooting&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;‚öñÔ∏è &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;SORs are off-chain bots that execute a routing algorithm that scans the blockchain for open limit orders, matches them based on their trigger conditions, and submits new transactions back to the ledger to perform the swap state transitions. Each Smart Swap encodes trigger conditions that the SOR must fulfill to execute the swap. The SOR continuously scans and analyzes the current state of the limit orders and relies on the configured matching strategy to best execute a customer‚Äôs order based on price.&lt;/p&gt; &#xA;&lt;p&gt;Specifically, the bot periodically builds a multi-asset order book consisting of one order book for each token pair listed in its configuration. Each order book contains only sell and buy orders for the same pair of tokens. The bot runs the selected strategy over the multi-asset order book to obtain a list of matches. The matches are then translated into transactions that will be signed and submitted by the bot.&lt;/p&gt; &#xA;&lt;h2&gt;Crash Course GeniusYield DEX Orders &amp;lt;&amp;gt; SOR&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s start with a concrete and short overview of the GY DEX Orders, so the context of the SOR for using, modifying, and improving with new custom strategies is properly established. A complete description can be found in the &lt;a href=&#34;https://www.geniusyield.co/whitepaper.pdf?lng=en&#34;&gt;GY whitepaper&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Given a pair of tokens, an order will contain the number of tokens it offers, the price of one unit of those offered, and the minimal amount we are forced to buy from the order. Besides that, the order will have some life timeline and, of course, a notion of ownership related to the one that created it. For example, we could create an order offering of &lt;code&gt;10 tokenA&lt;/code&gt;, with a unit price of &lt;code&gt;2 tokenB&lt;/code&gt;, that is, we expect to receive &lt;code&gt;2 tokenB&lt;/code&gt; per &lt;code&gt;1 tokenA&lt;/code&gt;. Also, we want the minimal amount to be bought be &lt;code&gt;5 tokenA&lt;/code&gt;. Clearly, the owners of this order will be us and it&#39;s important to mention that all this information is &lt;strong&gt;mandatory&lt;/strong&gt;, but we can avoid setting the life timeline, meaning the order will always be available. Once we create an order, the offered tokens will be locked on the order.&lt;/p&gt; &#xA;&lt;p&gt;Given an order, two interesting &#34;actions&#34; can be performed over it. The owner can cancel it and get back the locked tokens. Or anyone can &lt;em&gt;fill&lt;/em&gt; it, filling an order is just paying the correct amount of tokens the owner of the order expects to receive related to the amount of tokens we want to buy from that order. Following the previous example, anyone could fill that order by buying from it &lt;code&gt;6 tokenA&lt;/code&gt; and paying the owner &lt;code&gt;12 tokenB&lt;/code&gt;. But, it isn&#39;t possible to buy, for instance, &lt;code&gt;3 tokenA&lt;/code&gt; from the order because the minimal amount was setup to &lt;code&gt;5&lt;/code&gt;, except the amount of offered tokens is less than that.&lt;/p&gt; &#xA;&lt;p&gt;One important thing to mention that is transparent for any end user, is that there are two kinds of fills: &lt;em&gt;complete&lt;/em&gt; and &lt;em&gt;partial&lt;/em&gt;. A complete fill will buy all the offered tokens from the order, and for the partial fill, we need to specify the amount we want to buy from the order. For us, that will be running and probably improving this implementation is relevant because, as we will see in a moment, we can design different matching strategies using these two different fills.&lt;/p&gt; &#xA;&lt;p&gt;Up to this point, we quickly covered the key actions that can be performed over the orders. There shouldn&#39;t be any surprise if we mention that each action is performed by a transaction.&lt;/p&gt; &#xA;&lt;p&gt;Now, let&#39;s suppose, besides the previous order, we have another one offering of &lt;code&gt;20 tokenB&lt;/code&gt;, with a unit price of &lt;code&gt;0.4 tokenA&lt;/code&gt;. We could earn some tokens by ‚Äúcombining‚Äù the two orders and take advantage of the price difference. Following the example, given we bought &lt;code&gt;6 tokenA&lt;/code&gt; using &lt;code&gt;12 tokenB&lt;/code&gt;, we now can use these &lt;code&gt;6 tokenA&lt;/code&gt; to buy back &lt;code&gt;15 tokenB&lt;/code&gt; from this other order, earning &lt;code&gt;3 tokenB&lt;/code&gt;. These two fills can be combined into a single transaction, in fact, we could combine more than two orders.&lt;/p&gt; &#xA;&lt;p&gt;The SOR has the ability to build these transactions matching orders programmatically, that is, combining orders into a single transaction. Which orders the SOR will match is determined by the strategy that must be configured in advance. To reason about any strategy, we need to classify orders into sell or buy. It&#39;s possible for an order to be a buy or sell, depending on the token used to earn the difference between the orders. In the previous example, we earned in &lt;code&gt;tokenB&lt;/code&gt;, but we could have earned in &lt;code&gt;tokenA&lt;/code&gt;. So, given a token pair, we will specify which token is the commodity and which is the currency, which will establish if a given order is a sell order or a buy order: If the order offers commodity, then it will be classified as a sell order. On the other hand, if the order involves buying the commodity with currency (that is offers currency), it will be considered a buy order.&lt;/p&gt; &#xA;&lt;p&gt;Using the previous example we could have two cases:&lt;/p&gt; &#xA;&lt;table align=&#34;center&#34;&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt;&#xA;   &lt;th&gt; Commodity A | Currency B &lt;/th&gt;&#xA;   &lt;th&gt; Commodity B | Currency A &lt;/th&gt;&#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt;&#xA;   &lt;td&gt; &#xA;    &lt;table&gt; &#xA;     &lt;thead&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;th align=&#34;center&#34;&gt;Amount&lt;/th&gt; &#xA;       &lt;th align=&#34;center&#34;&gt;Price&lt;/th&gt; &#xA;       &lt;th align=&#34;center&#34;&gt;Type&lt;/th&gt; &#xA;      &lt;/tr&gt; &#xA;     &lt;/thead&gt; &#xA;     &lt;tbody&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;td align=&#34;center&#34;&gt;&lt;code&gt;10 tokenA&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td align=&#34;center&#34;&gt;&lt;code&gt;2 tokenB&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td align=&#34;center&#34;&gt;Sell&lt;/td&gt; &#xA;      &lt;/tr&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;td align=&#34;center&#34;&gt;&lt;code&gt;8 tokenA&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td align=&#34;center&#34;&gt;&lt;code&gt;2.5 tokenB&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td align=&#34;center&#34;&gt;Buy&lt;/td&gt; &#xA;      &lt;/tr&gt; &#xA;     &lt;/tbody&gt; &#xA;    &lt;/table&gt; &lt;/td&gt;&#xA;   &lt;td&gt; &#xA;    &lt;table&gt; &#xA;     &lt;thead&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;th align=&#34;center&#34;&gt;Amount&lt;/th&gt; &#xA;       &lt;th align=&#34;center&#34;&gt;Price&lt;/th&gt; &#xA;       &lt;th align=&#34;center&#34;&gt;Type&lt;/th&gt; &#xA;      &lt;/tr&gt; &#xA;     &lt;/thead&gt; &#xA;     &lt;tbody&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;td align=&#34;center&#34;&gt;&lt;code&gt;20 tokenB&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td align=&#34;center&#34;&gt;&lt;code&gt;0.4 tokenA&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td align=&#34;center&#34;&gt;Sell&lt;/td&gt; &#xA;      &lt;/tr&gt; &#xA;      &lt;tr&gt; &#xA;       &lt;td align=&#34;center&#34;&gt;&lt;code&gt;20 tokenB&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td align=&#34;center&#34;&gt;&lt;code&gt;0.5 tokenA&lt;/code&gt;&lt;/td&gt; &#xA;       &lt;td align=&#34;center&#34;&gt;Buy&lt;/td&gt; &#xA;      &lt;/tr&gt; &#xA;     &lt;/tbody&gt; &#xA;    &lt;/table&gt; &lt;/td&gt;&#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;If we want our earnings to be in &lt;code&gt;tokenB&lt;/code&gt;, then the commodity must be &lt;code&gt;tokenA&lt;/code&gt;. We can buy from the sell order, &lt;code&gt;6 tokenA&lt;/code&gt; using &lt;code&gt;12 tokenB&lt;/code&gt;, then using these &lt;code&gt;6 tokenA&lt;/code&gt; we buy back &lt;code&gt;15 tokenB&lt;/code&gt; from the buy order, earning &lt;code&gt;3 tokenB&lt;/code&gt;. However, if we want our earnings to be in &lt;code&gt;tokenA&lt;/code&gt;, then the commodity must be &lt;code&gt;tokenB&lt;/code&gt;. So we can buy from the sell order, &lt;code&gt;18 tokenB&lt;/code&gt; using &lt;code&gt;7 tokenA&lt;/code&gt;, then using these &lt;code&gt;18 tokenB&lt;/code&gt; we buy back &lt;code&gt;9 tokenA&lt;/code&gt; from the buy order, earning &lt;code&gt;2 tokenA&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building and running&lt;/h2&gt; &#xA;&lt;h3&gt;Docker&lt;/h3&gt; &#xA;&lt;p&gt;&lt;span&gt;üöß&lt;/span&gt; Coming Soon &lt;span&gt;üöß&lt;/span&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Local build&lt;/h3&gt; &#xA;&lt;p&gt;First, you need to setup the necessary tooling to work with &lt;a href=&#34;https://github.com/input-output-hk/haskell.nix&#34;&gt;haskell.nix&lt;/a&gt;. A complete guide and troubleshooting of how to install and configure &lt;code&gt;nix&lt;/code&gt; can be found on one of the officials IOG repositories: &lt;a href=&#34;https://github.com/input-output-hk/plutus-apps/raw/main/CONTRIBUTING.adoc#installing-and-setting-up-nix&#34;&gt;plutus-apps&lt;/a&gt;. Once we completed the previous steps we can simply run &lt;code&gt;nix develop&lt;/code&gt;, and it will drop you into a shell with all the necessary tools. Once inside the environment, you can build the order bot with &lt;code&gt;cabal build all&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Orderbot Config&lt;/h3&gt; &#xA;&lt;p&gt;To run the order bot, it is necessary to setup the provider and specify the bot options. There is one option for a completely local provider and two remote ones.&lt;/p&gt; &#xA;&lt;h4&gt;Local Provider&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/CardanoSolutions/kupo&#34;&gt;Kupo&lt;/a&gt; can be used as a local provider. For this it is necessary to provide a path to a cardano node socket file and the Kupo url in the &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/config-files/atlas-config-kupo.json&#34;&gt;atlas-config-kupo.json&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;h4&gt;Remote Providers&lt;/h4&gt; &#xA;&lt;p&gt;There are two possible remote providers: &lt;code&gt;Maestro&lt;/code&gt; or &lt;code&gt;Blockfrost&lt;/code&gt;. In order to function properly, each provider requires a specific &lt;code&gt;API-TOKEN&lt;/code&gt; or &lt;code&gt;API-KEY&lt;/code&gt; (that should be created on each official site). These must be entered into the appropriate provider configuration file, either &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/config-files/atlas-config-maestro.json&#34;&gt;atlas-config-maestro.json&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/config-files/atlas-config-blockfrost.json&#34;&gt;atlas-config-blockfrost.json&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You must also configure the &lt;code&gt;networkId&lt;/code&gt; to specify which Blockchain to use. Inside any of those configuration files, we can also configure the logging mechanisms, we can specify the log severity level with &lt;code&gt;Debug&lt;/code&gt;, &lt;code&gt;Info&lt;/code&gt;, &lt;code&gt;Warning&lt;/code&gt;, but also the sinking of the information by choosing between a console log or a file. Besides different levels of verbosity. We even can have multiple logs, for instance on the example below we are logging some &lt;code&gt;Info&lt;/code&gt; level info into de console, and some &lt;code&gt;Debug&lt;/code&gt; level info into the &lt;code&gt;Debug.log&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&#34;logging&#34;: [ { &#34;type&#34;: { &#34;tag&#34;: &#34;stderr&#34; }, &#34;severity&#34;: &#34;Info&#34;, &#34;verbosity&#34;: &#34;V2&#34; }&#xA;           , { &#34;type&#34;: { &#34;tag&#34;: &#34;gySource&#34;, &#34;source&#34; : &#34;Debug.logs&#34; }, &#34;severity&#34;: &#34;Debug&#34;, &#34;verbosity&#34;: &#34;V2&#34; }&#xA;           ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition, to configure the &lt;strong&gt;bot&lt;/strong&gt;, it is necessary to edit the &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/config-files/bot-config.json&#34;&gt;bot-config.json&lt;/a&gt; file. The complete bot configuration looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &#34;signingKeyFP&#34;: &#34;bot.skey&#34;&#xA;, &#34;collateral&#34;: &#34;5b4fd2daa591e971b24e338275cc3c0710acadb6544a95930164c2c5c68a3a6c#0&#34;&#xA;&#xA;, &#34;nftMintingPolicyFP&#34;: &#34;compiled-scripts/minting-policy&#34;&#xA;, &#34;orderValidatorFP&#34;: &#34;compiled-scripts/partial-order&#34;&#xA;, &#34;validatorRefs&#34;:&#xA;  { &#34;refAddr&#34;: &#34;addr_test1wpgexmeunzsykesf42d4eqet5yvzeap6trjnflxqtkcf66g0kpnxt&#34;&#xA;  , &#34;refNftAC&#34;: &#34;fae686ea8f21d567841d703dea4d4221c2af071a6f2b433ff07c0af2.e6a295bb83d06f53fcf91151f54acec0a63fbd6f0d924206d5d012e6da3b72af&#34;&#xA;  , &#34;refNftUtxoRef&#34;: &#34;39f987a6beb9cc4c45bba149a21c28068f640f3593f15f8157f0b6022b431977#0&#34;&#xA;  , &#34;scriptRef&#34;: &#34;39f987a6beb9cc4c45bba149a21c28068f640f3593f15f8157f0b6022b431977#1&#34;&#xA;  , &#34;nftPolicyRef&#34;: &#34;39f987a6beb9cc4c45bba149a21c28068f640f3593f15f8157f0b6022b431977#0&#34;&#xA;  }&#xA;&#xA;, &#34;strategy&#34;: &#34;OneSellToManyBuy&#34;&#xA;, &#34;scanDelay&#34;: 40000000&#xA;, &#34;maxOrderMatches&#34;: 5&#xA;, &#34;maxTxsPerIteration&#34; : 5&#xA;, &#34;randomizeMatchesFound&#34;: true&#xA;&#xA;, &#34;scanTokens&#34; :&#xA;  [&#xA;    { &#34;commodityAsset&#34; : &#34;c6e65ba7878b2f8ea0ad39287d3e2fd256dc5c4160fc19bdf4c4d87e.7447454e53&#34;&#xA;    , &#34;currencyAsset&#34; : &#34;lovelace&#34;&#xA;    }&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;signingKeyFP&lt;/code&gt;, we need to specify the bot signing key, that must be placed on a file.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;collateral&lt;/code&gt;, an optional field to specify the collateral for the bot. If not present, Atlas will choose a suitable UTxO as collateral.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nftMintingPolicyFP&lt;/code&gt; and &lt;code&gt;orderValidatorFP&lt;/code&gt;, the filepath where the minting policy and validator are stored.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;validatorsRefs&#34;&lt;/code&gt;, contains the information necessary for the validator. Contains 3 mandatory fields and 2 optional ones. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;&#34;refAddr&#34;&lt;/code&gt;, address where the reference NFT is placed.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;&#34;refNftAc&#34;&lt;/code&gt;, assetClass of the reference NFT is placed.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;&#34;refNftUtxoRef&#34;&lt;/code&gt;, UTxO reference where the reference NFT is placed.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;&#34;scriptRef&#34;&lt;/code&gt;, an optional parameter for the script reference. This UTxO has to have the partial order validator as a script ref.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;&#34;nftPolicyRef&#34;&lt;/code&gt;, an optional parameter for the script reference of the partial orders NFT. This UTxO has to have the partial order NFT minting policy as a script ref.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;strategy&lt;/code&gt;, currently the SOR supports one possible strategy: OneSellToManyBuy.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;scanDelay&lt;/code&gt;, the duration of time we wait before re-initiating a complete iteration for the bot.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;maxOrderMatches&lt;/code&gt;, is the maximum amount of orders to be matched into a single transaction. 8 orders is near the limit that will fit into a transaction.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;maxTxsPerIteration&lt;/code&gt;, is the maximum amount of transactions that the bot will build, sign and submit in each iteration.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;randomizeMatchesFound&lt;/code&gt;, a boolean that dictates whether the bot chooses the tx to submit at random (to decrease collisions), or not (to maximize profit)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;scanTokens&lt;/code&gt;, the list of token pairs to be scanned. Each element in the list specifies which token in the pair is the &lt;code&gt;commodityAsset&lt;/code&gt; and which is the &lt;code&gt;currencyAsset&lt;/code&gt;. The bot will arbitrage the orders to get tokens of the &lt;code&gt;currencyAsset&lt;/code&gt;. Each token must be written with the format policyId.hexTokenName. For convenience, scanning ADAs can be done by writing lovelace or the empty string. The multi-asset order book is built using this list.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Creating Signing Key&lt;/h4&gt; &#xA;&lt;p&gt;Another important and necessary setup to make is the creation of the bot wallet. If you already have a wallet signing key to use, you just need to put the signing key in a file and properly configure &lt;code&gt;signingKeyFP&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to create a new wallet, you can create everything using the &lt;code&gt;cardano-cli&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cardano-cli address key-gen \&#xA;&#x9;--verification-key-file bot.vkey \&#xA;&#x9;--signing-key-file bot.skey&#xA;&#xA;cardano-cli address build \&#xA;    --payment-verification-key-file bot.vkey \&#xA;    --testnet-magic 1 \&#xA;    --out-file bot.preprod.addr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create the files &lt;code&gt;bot.skey&lt;/code&gt;, &lt;code&gt;bot.vkey&lt;/code&gt;, and &lt;code&gt;bot.preprod.addr&lt;/code&gt;: the private signing key, the verification key, and the wallet address on the preprod testnet. You can claim some &lt;strong&gt;preprod&lt;/strong&gt; lovelaces using the &lt;a href=&#34;https://docs.cardano.org/cardano-testnet/tools/faucet/&#34;&gt;faucet&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s &lt;strong&gt;recomended&lt;/strong&gt; to create and setup a &lt;code&gt;collateral&lt;/code&gt;. A UTxO with 5 ADAs will do the work. But as we mentioned the &lt;code&gt;collateral&lt;/code&gt; config field is optional.&lt;/p&gt; &#xA;&lt;h4&gt;Deployed Contract&lt;/h4&gt; &#xA;&lt;p&gt;The SOR has the ability to use reference scripts on the filling transactions to help minimize the fees. To do that, we need to use the official contract information that is completely placed on the blockchain. That is the validator and minting policy.&lt;/p&gt; &#xA;&lt;h5&gt;Preprod&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&#34;validatorRefs&#34;:&#xA;  { &#34;refAddr&#34;: &#34;addr_test1wpgexmeunzsykesf42d4eqet5yvzeap6trjnflxqtkcf66g0kpnxt&#34;&#xA;  , &#34;refNftAC&#34;: &#34;fae686ea8f21d567841d703dea4d4221c2af071a6f2b433ff07c0af2.e6a295bb83d06f53fcf91151f54acec0a63fbd6f0d924206d5d012e6da3b72af&#34;&#xA;  , &#34;refNftUtxoRef&#34;: &#34;39f987a6beb9cc4c45bba149a21c28068f640f3593f15f8157f0b6022b431977#0&#34;&#xA;  , &#34;scriptRef&#34;: &#34;39f987a6beb9cc4c45bba149a21c28068f640f3593f15f8157f0b6022b431977#1&#34;&#xA;  , &#34;nftPolicyRef&#34;: &#34;39f987a6beb9cc4c45bba149a21c28068f640f3593f15f8157f0b6022b431977#0&#34;&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Mainnet&lt;/h5&gt; &#xA;&lt;p&gt;&lt;span&gt;üöß&lt;/span&gt; Coming Soon &lt;span&gt;üöß&lt;/span&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&#34;validatorRefs&#34;:&#xA;  { &#34;refAddr&#34;: &#34;&#34;&#xA;  , &#34;refNftAC&#34;: &#34;&#34;&#xA;  , &#34;refNftUtxoRef&#34;: &#34;&#34;&#xA;  , &#34;scriptRef&#34;: &#34;&#34;&#xA;  , &#34;nftPolicyRef&#34;: &#34;&#34;&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Running&lt;/h4&gt; &#xA;&lt;p&gt;Once we compiled and configured the order bot, you can execute using the &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/Makefile&#34;&gt;Makefile&lt;/a&gt;: &lt;code&gt;make orderbot-maestro&lt;/code&gt;, &lt;code&gt;make orderbot-blockfrost&lt;/code&gt; or &lt;code&gt;make orderbot-kupo&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Testing&lt;/h4&gt; &#xA;&lt;p&gt;The SOR is equipped with a test suite that employs QuickCheck to perform property-based testing. By implementing certain properties, we are able to verify various important aspects of the strategies, like for example, given a matching between sell and buy orders there is always a &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-orderbot/test/Tests/Prop/Strategies.hs#L167-L177&#34;&gt;positive earning&lt;/a&gt;. Among others that can be found on &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-orderbot/test/Tests/Prop/Strategies.hs&#34;&gt;Tests.Prop.Strategies&lt;/a&gt; module.&lt;/p&gt; &#xA;&lt;p&gt;For running the tests we can just simply execute &lt;code&gt;make orderbot-tests&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Design&lt;/h2&gt; &#xA;&lt;p&gt;The SOR is organized into 5 main folders:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/compiled-scripts&#34;&gt;&lt;code&gt;compiled-scripts&lt;/code&gt;&lt;/a&gt;, contains the compiled validator and minting policy of the DEX.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-dex-api&#34;&gt;&lt;code&gt;geniusyield-dex-api&lt;/code&gt;&lt;/a&gt;, defines the DEX interface to query and build transactions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-orderbot-framework&#34;&gt;&lt;code&gt;geniusyield-orderbot-framework&lt;/code&gt;&lt;/a&gt;, implement the main abstract tools for the SOR.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-orderbot&#34;&gt;&lt;code&gt;geniusyield-orderbot&lt;/code&gt;&lt;/a&gt;, the executable is implemented here, together with the strategies.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/impl&#34;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt;, specific implementations of the orderbook and data-provider.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Backpack&lt;/h3&gt; &#xA;&lt;p&gt;This is an order matching bot implementation that is meant to be modular and polymorphic. It uses backpack to support this goal. Backpack is surprisingly flexible, supporting signature merging and signature thinning. This may be especially relevant for modular orderbot implementations. &lt;a href=&#34;https://github.com/danidiaz/really-small-backpack-example/tree/master/lesson4-signature-thinning&#34;&gt;Signature thinning&lt;/a&gt; is when an indefinite library depends on a signature but only demands a subset of said signature, allowing an implementation that only implements said subset of the interface to be used merrily with the library.&lt;/p&gt; &#xA;&lt;p&gt;Solid resource for learning backpack: &lt;a href=&#34;https://github.com/danidiaz/really-small-backpack-example&#34;&gt;GitHub - danidiaz/really-small-backpack-example: A really small example of the Backpack module system for Haskell&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Strategies&lt;/h2&gt; &#xA;&lt;p&gt;On the &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-orderbot/src/Strategies.hs&#34;&gt;&lt;code&gt;Strategies&lt;/code&gt;&lt;/a&gt; module, you can find all the strategies implemented by the SOR. Currently, there is only one called &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-orderbot/src/Strategies.hs#L36C20-L36C36&#34;&gt;&lt;code&gt;OneSellToManyBuy&lt;/code&gt;&lt;/a&gt;, which basically takes the best sell order (the one with the lowest price) and searches for many buy orders (starting from the one with the highest price), ideally buying the total amount of offered tokens, or until it reaches the maxOrderMatches.&lt;/p&gt; &#xA;&lt;h3&gt;Adding a new strategy&lt;/h3&gt; &#xA;&lt;p&gt;In this Haskell implementation, a strategy is simply a function with type &lt;code&gt;OrderAssetPair -&amp;gt; OrderBook -&amp;gt; [MatchResult]&lt;/code&gt;. This function returns a list of matching results from a pair of tokens and an order book, which consists of both sell and buy orders. Each matching result represents a transaction, which involves a specific set of sell and buy orders.&lt;/p&gt; &#xA;&lt;p&gt;We can start with the most bureaucratic part of adding a new strategy. We need to define the name of the new strategy, so let&#39;s say we want to implement the &#34;dual&#34; strategy to the one that is already there. We want to implement then one strategy that given the best buy order, searches for many sell orders. We add then a new constructor &lt;code&gt;OneBuyToManySell&lt;/code&gt; to the type BotStrategy&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data BotStrategy = OneSellToManyBuy&#xA;                 | OneBuyToManySell&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We must adjust some straightforward instances with the new constructor: &lt;code&gt;FromJSON&lt;/code&gt; and &lt;code&gt;Var&lt;/code&gt;. As is the case with &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-orderbot/src/Strategies.hs#L56-L59&#34;&gt;&lt;code&gt;mkIndependentStrategy&lt;/code&gt;&lt;/a&gt;, adding a new particular case for &lt;code&gt;OneBuyToManySell&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mkIndependentStrategy :: BotStrategy -&amp;gt; Natural -&amp;gt; IndependentStrategy&#xA;mkIndependentStrategy bs maxOrders _ bk =&#xA;    case bs of&#xA;      OneSellToManyBuy -&amp;gt; oneSellToManyBuy maxOrders bk&#xA;      OneBuyToManySell -&amp;gt; oneBuyToManySell maxOrders bk&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once we get to this point, we can focus on the implementation of the new function. In fact, we can start with a very silly implementation that doesn&#39;t find any matching with the goal of compiling everything.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;oneBuyToManySell :: Natural -&amp;gt; OrderBook -&amp;gt; [MatchResult]&#xA;oneBuyToManySell _ _ = []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Even more! We can go to the &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-orderbot/test/Main.hs&#34;&gt;Main&lt;/a&gt; testing module, and add the new constructor &lt;code&gt;OneBuyToManySell&lt;/code&gt; to &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-orderbot/test/Main.hs#L25C9-L25C29&#34;&gt;&#34;Strategies tests&#34; list&lt;/a&gt; and it will be enough to start testing our strategy by running the tests.&lt;/p&gt; &#xA;&lt;p&gt;Finishing the implementation of &lt;code&gt;oneBuyToManySell&lt;/code&gt; is left as an exercise.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Hint&lt;/summary&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;Checking &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-orderbot/src/Strategies.hs#L95-L132&#34;&gt;&lt;code&gt;multiFill&lt;/code&gt;&lt;/a&gt;, can help to realize that it&#39;s enough to use &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-orderbot/src/Strategies.hs#L82-L92&#34;&gt;&lt;code&gt;oneSellToManyBuy&lt;/code&gt;&lt;/a&gt; as inspiration and &#34;flip&#34; something.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Questions: Choosing between one strategy or the other will always enforce some matching strategy, so will it be possible to merge the two strategies into a single one? Or it will be better to run two different SOR instances?&lt;/p&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;h3&gt;Providers&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;geniusyield-orderbot-exe: MspvApiError &#34;SystemStart&#34; (MaestroApiKeyMissing &#34;Invalid authentication credentials&#34;)&lt;/code&gt;, you need to setup the corresponding Maestro token into &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/config-files/atlas-config-maestro.json&#34;&gt;atlas-config-maestro.json&lt;/a&gt; file.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;geniusyield-orderbot-exe: BlpvApiError &#34;LedgerGenesis&#34; (BlockfrostTokenMissing &#34;Invalid project token.&#34;)&lt;/code&gt; you need to setup the corresponding Blockfrost token into &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/config-files/atlas-config-blockfrost.json&#34;&gt;atlas-config-blockfrost.json&lt;/a&gt; file.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Cardano&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;BadInputsUTxO&lt;/code&gt; in the exception that is raised during tx submission, not creation/balancing, usually indicates contention. An order you are trying to match is being matched by another transaction.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ExUnitsTooBigUTxO&lt;/code&gt; in the exception means you are trying to match too many orders simultaneously, making the transaction size cross the limit.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;BalancingErrorInsufficientFunds&lt;/code&gt; in the exception indicates there are not enough of one or many tokens to construct the transaction. If you see ADA in the value that is printed afterward, it means your bot is out of ADA. More often, however, this error will be raised if your matching strategy does not return proper order matches and there aren&#39;t enough tokens in the transaction bucket to pay an order.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;GYTxMonadException &#34;partiallyFillPartialOrder: amount x must be smaller than offered amount x&lt;/code&gt;, you are trying to partially fill an order, but the partial fill amount is the max volume of the order. Use &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-orderbot-framework/src/GeniusYield/OrderBot/MatchingStrategy.hs#L98C17-L98C29&#34;&gt;&lt;code&gt;CompleteFill&lt;/code&gt;&lt;/a&gt; instead. See &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/geniusyield-orderbot-framework/src/GeniusYield/OrderBot/MatchingStrategy.hs#L98&#34;&gt;GeniusYield.OrderBot.MatchingStrategy&lt;/a&gt; for more information.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Cabal &amp;lt;&amp;gt; Haskell&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;HLS will not work in signature modules, nor will it work in modules importing a signature module.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Cabal mixins can be flaky sometimes. If you&#39;re sure you&#39;re using mixins properly but still getting &#34;Module X does not require Y&#34;, try cleaning the geniusyield-orderbot build and rebuilding from scratch.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/smart-order-router/main/LICENSE&#34;&gt;Apache-2.0&lt;/a&gt; ¬© &lt;a href=&#34;https://www.geniusyield.co&#34;&gt;GYELD GMBH&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>bobzhangwz/ubuntu-setup</title>
    <updated>2023-10-06T01:30:04Z</updated>
    <id>tag:github.com,2023-10-06:/bobzhangwz/ubuntu-setup</id>
    <link href="https://github.com/bobzhangwz/ubuntu-setup" rel="alternate"></link>
    <summary type="html">&lt;p&gt;my own linux setup&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Adobe Systems Incorporated Flash Player 11 for Linux Version 11.2.202.297 2012&lt;/p&gt; &#xA;&lt;p&gt;Adobe recommends that all users upgrade to the latest version of Adobe Flash Player for the most recent features, bug fixes, and security fixes. For more information on the new features in Flash Player 9, please visit &lt;a href=&#34;http://www.adobe.com/products/flashplayer/&#34;&gt;http://www.adobe.com/products/flashplayer/&lt;/a&gt;. For more information on system requirements, fixed issues, and known issues, see the release notes at &lt;a href=&#34;http://www.adobe.com/go/flashplayer_releasenotes&#34;&gt;http://www.adobe.com/go/flashplayer_releasenotes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To confirm which version of Flash Player you have currently installed, see &lt;a href=&#34;http://www.adobe.com/software/flash/about/&#34;&gt;http://www.adobe.com/software/flash/about/&lt;/a&gt;. Users should only install Players that have been downloaded from trusted sources, such as &lt;a href=&#34;http://www.adobe.com/&#34;&gt;http://www.adobe.com/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Your use of this player is governed by the Adobe End User License Agreement found at &lt;a href=&#34;http://www.adobe.com/products/eulas/players/flash/&#34;&gt;http://www.adobe.com/products/eulas/players/flash/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Privacy&lt;/h2&gt; &#xA;&lt;p&gt;Adobe is committed to preserving the privacy of end users. For more information on configuring Client-side privacy visit the Settings Manager Documentation: &lt;a href=&#34;http://www.adobe.com/go/flashplayerhelp&#34;&gt;http://www.adobe.com/go/flashplayerhelp&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation instructions&lt;/h2&gt; &#xA;&lt;p&gt;Installing using the plugin tar.gz: o Unpack the plugin tar.gz and copy the files to the appropriate location.&lt;br&gt; o Save the plugin tar.gz locally and note the location the file was saved to. o Launch terminal and change directories to the location the file was saved to. o Unpack the tar.gz file. Once unpacked you will see the following: + libflashplayer.so + /usr o Identify the location of the browser plugins directory, based on your Linux distribution and Firefox version o Copy libflashplayer.so to the appropriate browser plugins directory. At the prompt type: + cp libflashlayer.so &#xA; &lt;browserpluginslocation&gt;&#xA;   o Copy the Flash Player Local Settings configurations files to the /usr directory. At the prompt type: + sudo cp -r usr/* /usr&#xA; &lt;/browserpluginslocation&gt;&lt;/p&gt; &#xA;&lt;p&gt;Installing the plugin using RPM: o As root, enter in terminal: + # rpm -Uvh &amp;lt;rpm_package_file&amp;gt; + Click Enter key and follow prompts&lt;/p&gt; &#xA;&lt;p&gt;Installing the standalone player: o Unpack the tar.gz file o To execute the standalone player, + Double-click, or + Enter in terminal: ./flashplayer&lt;/p&gt; &#xA;&lt;h2&gt;Uninstallation instructions&lt;/h2&gt; &#xA;&lt;p&gt;Manual uninstallation (for users who installed the plugin via Install script): o Delete libflashplayer.so binary and flashplayer.xpt file in directory /home/&#xA; &lt;user&gt;&#xA;  /.mozilla/plugins/&#xA; &lt;/user&gt;&lt;/p&gt; &#xA;&lt;p&gt;RPM uninstallation: o As root, enter in terminal: + # rpm -e flash-plugin + Click Enter key and follow prompts&lt;/p&gt; &#xA;&lt;h2&gt;Technical Issues and Reporting Bugs&lt;/h2&gt; &#xA;&lt;p&gt;The Adobe Flash Player Support Center at &lt;a href=&#34;http://www.adobe.com/support/flashplayer/&#34;&gt;http://www.adobe.com/support/flashplayer/&lt;/a&gt; is a free online resource for support and troubleshooting information. Bug reports may be submitted at &lt;a href=&#34;http://www.adobe.com/go/wish&#34;&gt;http://www.adobe.com/go/wish&lt;/a&gt;. To allow us to investigate reported bugs, please include the following information:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Platform and version&lt;/li&gt; &#xA; &lt;li&gt;Browser version&lt;/li&gt; &#xA; &lt;li&gt;Reproducible steps including a URL to the web site where the problem was encountered.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If we need further information about a bug, you will be contacted. An automated reply will be sent to assure you that we have received your bug report. Due to the volume of mail received, we are not able to individually respond to each report.&lt;/p&gt; &#xA;&lt;p&gt;Use the following commands to generate dependency lists for Flash Player or the Local Setting Manager:&lt;/p&gt; &#xA;&lt;p&gt;Flash Player: ldd &#xA; &lt;browserpluginslocation&gt;&#xA;  /libflashplayer.so&#xA; &lt;/browserpluginslocation&gt;&lt;/p&gt; &#xA;&lt;p&gt;Gnome Local Setting Manager: ldd /usr/lib/kcm_adobe_flash_player.so (for 32-bit systems) ldd /usr/lib64/kcm_adobe_flash_player.so (for 64-bit systems)&lt;/p&gt; &#xA;&lt;p&gt;KDE Local Settings Manager: ldd /usr/bin/flash-player-properties&lt;/p&gt; &#xA;&lt;h2&gt;Legal&lt;/h2&gt; &#xA;&lt;p&gt;Adobe(R) Flash(R) Player. Copyright (C) 1996 - 2011 Adobe Systems Incorporated. All Rights Reserved. Adobe and Flash are either trademarks or registered trademarks in the United States and/or other countries.&lt;/p&gt;</summary>
  </entry>
</feed>