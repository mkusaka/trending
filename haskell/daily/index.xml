<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-19T01:30:38Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jameshaydon/lawvere</title>
    <updated>2023-09-19T01:30:38Z</updated>
    <id>tag:github.com,2023-09-19:/jameshaydon/lawvere</id>
    <link href="https://github.com/jameshaydon/lawvere" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A categorical programming language with effects&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/jameshaydon/lawvere/actions&#34;&gt;&lt;img src=&#34;https://github.com/jameshaydon/lawvere/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;Lawvere&lt;/h1&gt; &#xA; &lt;p&gt;A categorical programming language with effects&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jameshaydon/lawvere/master/#buildinstallation&#34;&gt;Install&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/jameshaydon/lawvere/master/#tutorial&#34;&gt;Tutorial&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/jameshaydon/lawvere/master/#editor-support&#34;&gt;Editor support&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/jameshaydon/lawvere/master/#development&#34;&gt;Development&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;em&gt;Very work-in-progress&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;pre&gt;&lt;code&gt;(.playerA .points - .playerB .points)&#xA;{ leader = (&amp;gt; 0) [ true = &#34;A&#34;, false = &#34;B&#34;],&#xA;  delta  = abs show }&#xA;&#34;Player {.leader} is winning by {.delta} points!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compile to any category that has structures corresponding to the programming features you use (&lt;a href=&#34;https://ncatlab.org/nlab/show/cartesian+closed+category&#34;&gt;cartesian closed&lt;/a&gt;, &lt;a href=&#34;https://ncatlab.org/nlab/show/distributive+category&#34;&gt;distributive&lt;/a&gt;, etc.).&lt;/li&gt; &#xA; &lt;li&gt;Comes with is an evaluator in Haskell, a &lt;a href=&#34;https://raw.githubusercontent.com/jameshaydon/lawvere/master/#compiling-to-javascript&#34;&gt;compiler to JavaScript&lt;/a&gt;, and a &#34;bytecode&#34; compiler to a &lt;a href=&#34;https://raw.githubusercontent.com/jameshaydon/lawvere/master/#the-categorical-abstract-machine&#34;&gt;categorical abstract machine&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Effect system based on free effect categories.&lt;/li&gt; &#xA; &lt;li&gt;Point-free functional programming (no lambdas); a categorical take on concatenative programming.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The Lawvere language (and the executable &lt;code&gt;bill&lt;/code&gt;) is named after &lt;a href=&#34;https://en.wikipedia.org/wiki/William_Lawvere&#34;&gt;William Lawvere&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Tutorial&lt;/h2&gt; &#xA;&lt;h3&gt;REPL&lt;/h3&gt; &#xA;&lt;p&gt;Once &lt;a href=&#34;https://raw.githubusercontent.com/jameshaydon/lawvere/master/#buildinstallation&#34;&gt;installed&lt;/a&gt;, start a Lawvere REPL (Read-Eval-Print-Loop) with &lt;code&gt;bill -i&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bill -i&#xA;--------------&#xA;Lawvere v0.0.0&#xA;--------------&#xA;&amp;gt; 40 + 2&#xA;42&#xA;&amp;gt; &#34;hello&#34;&#xA;&#34;hello&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Or &lt;code&gt;cabal run bill -- -i&lt;/code&gt; or &lt;code&gt;stack exec bill -- -i&lt;/code&gt; if &lt;code&gt;bill&lt;/code&gt; isn&#39;t install.)&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;bill&lt;/code&gt; can also be given a file: &lt;code&gt;bill -i example.law&lt;/code&gt;. By omitting the &lt;code&gt;-i&lt;/code&gt; flag, the &lt;code&gt;main&lt;/code&gt; arrow is executed directly and the REPL is not started. In the REPL, &lt;code&gt;:r&lt;/code&gt; will reload the loaded file, and &lt;code&gt;:q&lt;/code&gt; will terminate the session. This README file is a literate Lawvere script, so you can load it and try out the examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bill -i README.md&#xA;Check OK!&#xA;&amp;gt; answer + 1&#xA;43&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Basic types&lt;/h3&gt; &#xA;&lt;p&gt;Values of basic types are written as in other programming languages, e.g. &lt;code&gt;42&lt;/code&gt; and &lt;code&gt;&#34;hello world&#34;&lt;/code&gt;. But in Lawvere, everything is an arrow (Lawvere&#39;s equivalent of a function), so that these actually denote constant arrows. For example, &lt;code&gt;42&lt;/code&gt; denotes the arrow which is constantly 42:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar answer : {} --&amp;gt; Int = 42&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above code defines an arrow using the &lt;code&gt;ar&lt;/code&gt; keyword. The arrow has source &lt;code&gt;{}&lt;/code&gt; (which is the syntax for the unit type) and target &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When the REPL accepts an input, it actually executes it (with the Haskell evaluator) on the unit input. So for example inputting &lt;code&gt;incr&lt;/code&gt; (which expects an &lt;code&gt;Int&lt;/code&gt;) will result in an error.&lt;/p&gt; &#xA;&lt;p&gt;Lawvere also has support for basic arithmetic and comparisons. These are operations on arrows, for example &lt;code&gt;f + g&lt;/code&gt; forms the pointwise addition of arrows &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Composition&lt;/h3&gt; &#xA;&lt;p&gt;The main way to build up larger programs from smaller ones is by using &lt;em&gt;composition&lt;/em&gt;. The syntax for this is very lightweight - it&#39;s simply whitespace! That is, &lt;code&gt;f g&lt;/code&gt; denotes the composition of &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;. If you are coming from Haskell, note that this does &lt;em&gt;not&lt;/em&gt; correspond to &lt;code&gt;.&lt;/code&gt;, but to &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, that is, &lt;code&gt;f&lt;/code&gt; comes first, then &lt;code&gt;g&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;(If you know Forth composition and literals as constant functions will feel familiar.)&lt;/p&gt; &#xA;&lt;p&gt;To illustrate this we can use the built-in arrow &lt;code&gt;incr&lt;/code&gt;, which increments an integer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar plus3 : Int --&amp;gt; Int = incr incr incr&#xA;&#xA;ar fourtyFive : {} --&amp;gt; Int = 42 plus3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will output &lt;code&gt;45&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To run this, create a file with the above contents and use &lt;code&gt;bill&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bill -i test.law&#xA;--------------&#xA;Lawvere v0.0.0&#xA;--------------&#xA;checking..&#xA;Check OK!&#xA;&amp;gt; fourtyFive&#xA;45&#xA;&amp;gt; fourtyFive plus3 incr&#xA;49&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; The checker is a work-in-progress and is far from complete.&lt;/p&gt; &#xA;&lt;p&gt;The identity arrow is called &lt;code&gt;identity&lt;/code&gt;, but you can also write it with nothing at all (or whitespace). So the mathematical function [x ↦ x * x + 1] can be written &lt;code&gt;identity * identity + 1&lt;/code&gt;, or simply &lt;code&gt;* + 1&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar squarePlusOne : Int --&amp;gt; Int = identity * identity + 1&#xA;&#xA;ar squarePlusOne&#39; : Int --&amp;gt; Int = * + 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bill -i test.law&#xA;&amp;gt; 2 squarePlusOne&#39;&#xA;5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Products&lt;/h3&gt; &#xA;&lt;p&gt;Datatypes in &lt;code&gt;lawvere&lt;/code&gt; are called &lt;em&gt;objects&lt;/em&gt; (since they correspond to objects in category theory -- as arrows, as you might have guessed, correspond to morphisms). We define a new object &lt;code&gt;Point&lt;/code&gt; with the keyword &lt;code&gt;ob&lt;/code&gt;. If the object is a product type (or &#39;struct&#39;, or &#39;record&#39;), specify it using braces:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ob Base Point = { x: Float, y: Float }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The arrow which projects out the &lt;code&gt;x&lt;/code&gt; component from &lt;code&gt;Point&lt;/code&gt; is written &lt;code&gt;.x&lt;/code&gt;. (Think of the &lt;code&gt;foo.x&lt;/code&gt; notation that is usual in other programming languages, except without anything preceding the dot.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bill -i&#xA;&amp;gt; { user = { name = &#34;Mina&#34;, age = 2 }, req = { format = &#34;json&#34; } } .user .name&#xA;&#34;Mina&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To create arrow &lt;em&gt;to&lt;/em&gt; a product, we specify, again using braces, arrows to each component of the product (in categorical terms, a &lt;a href=&#34;https://ncatlab.org/nlab/show/limit#definition_in_terms_of_universal_cones&#34;&gt;&lt;em&gt;cone&lt;/em&gt;&lt;/a&gt;) . For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar somePoint : {} --&amp;gt; Point =&#xA;  { x = 2.3, y = 4.6 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This works because &lt;code&gt;2.3&lt;/code&gt; and &lt;code&gt;4.6&lt;/code&gt; are arrows of type &lt;code&gt;{} --&amp;gt; Float&lt;/code&gt;, and the braces syntax uses arrows which all have the same source.&lt;/p&gt; &#xA;&lt;p&gt;In general, arrows of type &lt;code&gt;X --&amp;gt; { a: A, b: B, c: C, ... }&lt;/code&gt; can be written as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{ a = f, b = g, ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;if &lt;code&gt;f : X --&amp;gt; A&lt;/code&gt;, &lt;code&gt;g : X --&amp;gt; B&lt;/code&gt;, &lt;code&gt;h : X --&amp;gt; C&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a fuller example of using products:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ob Base Point = { x: Float, y: Float }&#xA;&#xA;ar linFun : Point --&amp;gt; Float = 2.0 * .x + 3.0 * .y&#xA;&#xA;ar someNum : {} --&amp;gt; Float =&#xA;  { x = 2.3, y = 4.6 } linFun&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;someNum&lt;/code&gt; is then &lt;code&gt;18.4&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The empty product object (in categorical terms, the terminal object) is written as &lt;code&gt;{}&lt;/code&gt;, and the unique arrow to it is also &lt;code&gt;{}&lt;/code&gt;. If there is any ambiguity (which occurs when defining functors) then you can use &lt;code&gt;{:}&lt;/code&gt; and &lt;code&gt;{=}&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By using parentheses instead of braces, the components are positional rather than named. In this case the projections are &lt;code&gt;.1&lt;/code&gt;, &lt;code&gt;.2&lt;/code&gt;, etc. Using a positional product for &lt;code&gt;Point&lt;/code&gt; the previous program would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ob Base PointPos = (Float, Float)&#xA;&#xA;ar linFunPos : PointPos --&amp;gt; Float = 2.0 * .1 + 3.0 * .2&#xA;&#xA;ar someNumPos : {} --&amp;gt; Float =&#xA;  (2.3, 4.6) linFunPos&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;String interpolation&lt;/h3&gt; &#xA;&lt;p&gt;A string can contain interpolated expressions. For example, &lt;code&gt;&#34;Name: {f}, Age: {g}&#34;&lt;/code&gt; denotes an arrow &lt;code&gt;A --&amp;gt; String&lt;/code&gt; as long as both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; are also morphisms &lt;code&gt;A --&amp;gt; String&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar james : {} --&amp;gt; String =&#xA;  { name= &#34;James&#34;, hobby= &#34;playing Go&#34; } &#34;{.name} likes {.hobby}.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will result in &lt;code&gt;&#34;James likes playing Go.&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Sums&lt;/h3&gt; &#xA;&lt;p&gt;We can define sum types too. For instance, booleans:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ob Base Bool = [ true: {}, false: {} ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using square brackets we define a sum type with two summands, &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;, each with &lt;code&gt;{}&lt;/code&gt; as payload.&lt;/p&gt; &#xA;&lt;p&gt;Sum types come equipped with constructors (injection). The constructor into the component with name &lt;code&gt;foo&lt;/code&gt; is denoted &lt;code&gt;foo.&lt;/code&gt;, simply mirroring the notation for projections.&lt;/p&gt; &#xA;&lt;p&gt;In order to define some simple boolean functions, we&#39;ll need to learn how to map &lt;em&gt;from&lt;/em&gt; sums. This is like pattern matching, specifying an arrow for each summand (and thus, in categorical language, a cocone). This is similar to cones, except using square brackets instead of braces. To illustrate this let&#39;s define the negation function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar not : Bool --&amp;gt; Bool&#xA;  = [ true  = false.,&#xA;      false = true. ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In words, we split the arrow into two cases. In the first case (on the &lt;code&gt;true&lt;/code&gt; component) we use &lt;code&gt;false.&lt;/code&gt; constructor, on the other component we use &lt;code&gt;true.&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In general, to specify an arrow:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[ a: A, b: B, c: C, ... ] --&amp;gt; X&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;one uses a cocone&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[ a = f, b = g, c = h, ... ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &lt;code&gt;f : A --&amp;gt; X&lt;/code&gt;, &lt;code&gt;g : B --&amp;gt; X&lt;/code&gt;, &lt;code&gt;h : C --&amp;gt; X&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;h3&gt;Distribution&lt;/h3&gt; &#xA;&lt;p&gt;Continuing with boolean functions, let&#39;s try to define the &lt;code&gt;and&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ar and : {x: Bool, y: Bool} --&amp;gt; Bool = ?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is an arrow &lt;em&gt;to&lt;/em&gt; a sum (&lt;code&gt;Bool&lt;/code&gt;), so we can&#39;t use a cocone, and &lt;em&gt;from&lt;/em&gt; a product (&lt;code&gt;{x : Bool, y: Bool }&lt;/code&gt;), so we can&#39;t use a cone---are we stuck? Intuitively we want to inspect one of the two arguments &lt;code&gt;(x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;) in order to continue. For this we will use the &lt;em&gt;distributor&lt;/em&gt; &lt;code&gt;@x&lt;/code&gt;. To understand what this does, first let&#39;s re-write &lt;code&gt;{x : Bool, y : Bool}&lt;/code&gt; by expanding the definition of &lt;code&gt;Bool&lt;/code&gt; at the &lt;code&gt;x&lt;/code&gt; summand:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{ x: [ true: {}, false: {}], y: Bool }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The type of &lt;code&gt;@x&lt;/code&gt; is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@x : { x: [ true: {}, false: {}], y: Bool } --&amp;gt; [ true: { x: {}, y: Bool}, false: { x: {}, y: Bool } ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The morphism &lt;code&gt;@x&lt;/code&gt; transforms the product into a sum; a sum with the same summand names as the sum in the component it targets. So in this case we end up with a sum with summands &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;, and the &lt;code&gt;x&lt;/code&gt; component contains the unwrapped payload for the original sum at &lt;code&gt;x&lt;/code&gt; (in this case they are both &lt;code&gt;{}&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Using this we can define &lt;code&gt;and&lt;/code&gt; as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar and : {x : Bool, y : Bool} --&amp;gt; Bool =&#xA;  @x [ true  = .y,&#xA;       false = {} false. ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In words: &#34;Perform a case analysis on &lt;code&gt;x&lt;/code&gt;, if &lt;code&gt;x&lt;/code&gt; is true, then return &lt;code&gt;y&lt;/code&gt;, otherwise return &lt;code&gt;false&lt;/code&gt;&#34;. Note the similarity with the equivalent Elm program (Haskell doesn&#39;t have anonymous records, making the comparison less clear), even though Lawvere has no variables or λs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elm&#34;&gt;and : { x : Bool, y : Bool } -&amp;gt; Bool&#xA;and input =&#xA;  case input.x of&#xA;    True  -&amp;gt; input.y&#xA;    False -&amp;gt; False&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Summing over a list&lt;/h3&gt; &#xA;&lt;p&gt;In this example we&#39;ll sum up a list of values.&lt;/p&gt; &#xA;&lt;p&gt;First we&#39;ll define lists of &lt;code&gt;Int&lt;/code&gt;s (we&#39;ll learn how to define the list &lt;em&gt;functor&lt;/em&gt; later, which means we don&#39;t need to define a new object for each possible object of elements):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ob Base ListI =&#xA;  [ empty: {},&#xA;    cons:  { head: Int, tail: ListI }&#xA;  ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An example list can be built up by composing morphisms together:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar aFewPrimes : {} --&amp;gt; ListI =&#xA;  empty.&#xA;  { head = 2, tail = } cons.&#xA;  { head = 3, tail = } cons.&#xA;  { head = 5, tail = } cons.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that in &lt;code&gt;{ head = 2, tail = }&lt;/code&gt;, the arrow being used at the &lt;code&gt;tail&lt;/code&gt; component is the identity. This could also be written &lt;code&gt;{ head = 2, tail = identity}&lt;/code&gt;. Another thing to note is that the &lt;code&gt;2&lt;/code&gt; being used here doesn&#39;t have source &lt;code&gt;{}&lt;/code&gt;, indeed all integer literals actually have type &lt;code&gt;forall a. a --&amp;gt; Int&lt;/code&gt; (and similarly for other scalars). This saves one from having to write &lt;code&gt;{} 2&lt;/code&gt;. Like Haskell, Lawvere has some syntactic sugar for list-building:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar morePrimes : {} --&amp;gt; ListI =&#xA;  #(2, 3, 5, 7, 11)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can sum over a list using a cocone:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar sum : ListI --&amp;gt; Int =&#xA;  [ empty = 0,&#xA;    cons  = .head + .tail sum ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In words: If the list is &lt;code&gt;empty&lt;/code&gt;, then return &lt;code&gt;0&lt;/code&gt;. Otherwise take the &lt;code&gt;head&lt;/code&gt;, and the &lt;code&gt;sum&lt;/code&gt; of the &lt;code&gt;.tail&lt;/code&gt;, and &lt;code&gt;+&lt;/code&gt; them together.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; morePrimes sum&#xA;28&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Effects&lt;/h3&gt; &#xA;&lt;p&gt;(Very WIP)&lt;/p&gt; &#xA;&lt;p&gt;Lawvere is is a pure language but allows programming with effects using free &lt;a href=&#34;https://ncatlab.org/nlab/show/Freyd+category&#34;&gt;Freyd categories&lt;/a&gt;, much like Haskell is pure but allows programming with effects using monads or arrows. In fact Freyd categories and arrows are very similar, e.g. see &lt;a href=&#34;http://homepages.inf.ed.ac.uk/cheunen/publications/2008/arrows/arrows.pdf&#34;&gt;Categorical semantics for arrows&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;I/O&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;IO&lt;/code&gt; effect is built-in. Here is an example of a morphism which performs I/O:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar Base[IO] hello : {} --&amp;gt; String =&#xA;  ~&#34;What is your name?&#34; putLine&#xA;  getLine&#xA;  ~&#34;Hello {}&#34; putLine&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run this, one must use the &lt;code&gt;io&lt;/code&gt; functor:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar InputOutput helloIO : {} --&amp;gt; {} =&#xA;  io(hello)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will print &lt;code&gt;What is your name&lt;/code&gt;, wait for the user to input their name, and then greet them.&lt;/p&gt; &#xA;&lt;p&gt;Cones (&lt;code&gt;{..}&lt;/code&gt;) are not permitted in effectful morphisms, but one can still perform effects at a single component. Here is a program which asks for 2 pieces of user input:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;// Turn a question into an answer.&#xA;ar Base[IO] ask : String --&amp;gt; String =&#xA;  putLine getLine&#xA;&#xA;// Ask some questions and then print a greeting.&#xA;ar Base[IO] greet : {} --&amp;gt; {} =&#xA;  ~{name = &#34;What is your name?&#34;, hobby = &#34;What is your favourite hobby?&#34;}&#xA;  !name(ask)&#xA;  !hobby(ask)&#xA;  ~&#34;Hello {.name}, I like {.hobby} too!&#34; putLine&#xA;&#xA;ar InputOutput greetIO : {} --&amp;gt; {} =&#xA;  io(greet)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Effectful programming will be explained more in the next section. In practice the main points are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Cones (&lt;code&gt;{..}&lt;/code&gt;) are not permitted.&lt;/li&gt; &#xA; &lt;li&gt;Pure computations must be lifted with &lt;code&gt;~&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;To run an effect at a single component of a product, use &lt;code&gt;!label(..)&lt;/code&gt; syntax.&lt;/li&gt; &#xA; &lt;li&gt;To run effects you need to map to the &lt;code&gt;InputOutput&lt;/code&gt; category with &lt;code&gt;io&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;State&lt;/h4&gt; &#xA;&lt;p&gt;In this example we&#39;ll define two sorts of effects: integer state and throwing a string error. See &lt;a href=&#34;https://raw.githubusercontent.com/jameshaydon/lawvere/master/examples/partial-state.law&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;effect IntState over Base {&#xA;  get : {} --&amp;gt; Int,&#xA;  put : Int --&amp;gt; {}&#xA;}&#xA;&#xA;effect Err over Base {&#xA;  err : String --&amp;gt; []&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This defines a theory &lt;code&gt;IntState&lt;/code&gt; for extending the &lt;code&gt;Base&lt;/code&gt; category with two distinguished morphisms for state manipulation: &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt;. Similarly &lt;code&gt;Err&lt;/code&gt; is a theory with a distinguished morphism &lt;code&gt;err : String -&amp;gt; []&lt;/code&gt;. Note that &lt;code&gt;[]&lt;/code&gt; is the empty sum, i.e. the initial object of &lt;code&gt;Base&lt;/code&gt;. Therefore &lt;code&gt;err&lt;/code&gt; can be used to map from &lt;code&gt;String&lt;/code&gt; to &lt;em&gt;any&lt;/em&gt; object, by composing with &lt;code&gt;[]&lt;/code&gt;, the empty cocone.&lt;/p&gt; &#xA;&lt;p&gt;We can then define morphisms in this abstract extension of &lt;code&gt;Base&lt;/code&gt;. The following morphism increments the state while returning the original value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar Base[IntState] next : {} --&amp;gt; Int =&#xA;  get ~{ current = , next = incr} !next(put) ~.current&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are two new pieces of syntax:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;~&lt;/code&gt; denotes the canonical injection into the effect-category. So this can be used for lifting any pure morphism. This performs the same role as the &lt;a href=&#34;https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Arrow.html#v:arr&#34;&gt;&lt;code&gt;arr&lt;/code&gt;&lt;/a&gt; method of the &lt;a href=&#34;https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Arrow.html#t:Arrow&#34;&gt;&lt;code&gt;Arrow&lt;/code&gt;&lt;/a&gt; type class in Haskell.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;!label(..)&lt;/code&gt; (where &lt;code&gt;label&lt;/code&gt; can be any component name). Effect categories do not (necessarily) have products, so using the cone syntax is prohibited. The sequencing of effects is specified by using the categorical composition. The effect-category has the same objects as the pure category it extends however, and an effectful morphisms can be performed at one component of a product of the base category. If &lt;code&gt;f : A --&amp;gt; B&#39;&lt;/code&gt; is an effectful morphism and &lt;code&gt;{a : A, b : B, c : C}&lt;/code&gt; is a product in the pure category, then &lt;code&gt;!b(f) : {a : A, b : B, c : C} --&amp;gt; {a : A, b : B&#39;, c : C}&lt;/code&gt; is another effectful morphism. In other words, &lt;code&gt;!b(f)&lt;/code&gt; means &#34;perform effect &lt;code&gt;f&lt;/code&gt; at component &lt;code&gt;b&lt;/code&gt;&#34;. This performs the same role as &lt;a href=&#34;https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Arrow.html#v:first&#34;&gt;&lt;code&gt;first&lt;/code&gt;&lt;/a&gt; in &lt;a href=&#34;https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Arrow.html#t:Arrow&#34;&gt;&lt;code&gt;Arrow&lt;/code&gt;&lt;/a&gt; except for any component.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;So &lt;code&gt;next&lt;/code&gt; works as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;get&lt;/code&gt; the current state,&lt;/li&gt; &#xA; &lt;li&gt;Create two versions of the current state (the one we want to return, and the one we want to &lt;code&gt;put&lt;/code&gt;) using the pure morphism &lt;code&gt;{current = , next = incr}&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;Do a &lt;code&gt;put&lt;/code&gt; on the &lt;code&gt;next&lt;/code&gt; component,&lt;/li&gt; &#xA; &lt;li&gt;Project out (purely) the &lt;code&gt;current&lt;/code&gt; component.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For testing the error effect, we&#39;ll make a version which throws an error if the next number is greater than 3:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar Base[IntState, Err] nextSub3 : {} --&amp;gt; Int =&#xA;  next ~( { sub3 = &amp;lt; 3, ok = } @sub3 )&#xA;  [ true  = ~.ok,&#xA;    false = ~&#34;Was not under 3!&#34; err []]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next we&#39;ll specify how to map this function over a list. We can&#39;t reuse the &lt;code&gt;list&lt;/code&gt; functor because that doesn&#39;t specify how to sequence the effects: should the effect be performed first on the head or the tail of the list?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar Base[IntState, Err] mapNextSub3 : list({}) --&amp;gt; list(Int) =&#xA;    [ empty = ~empty.,&#xA;      cons  = !head(nextSub3) !tail(mapNextSub3) ~cons. ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We explicitly sequence the effects, using composition, on first the head and then the tail of the list.&lt;/p&gt; &#xA;&lt;p&gt;The effect-category is still abstract, to actually use the above we must define an effect-category over base and interpret the effects:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;category ErrIntState {&#xA;  ob             = ob Base,&#xA;  ar A --&amp;gt; B     = ar Base :&#xA;                   { state: Int, value: A } --&amp;gt;&#xA;                   [ err: String, suc: { state: Int, value: B } ],&#xA;  identity       = suc.,&#xA;  f g            = f [ err = err., suc = g ],&#xA;  SumOb(idx)     = SumOb(idx),&#xA;  sumInj(label)  = { state, value = .value sumInj(label) } suc.,&#xA;  sumUni(cocone) = @value sumUni(cocone)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This defines a new category with the same objects as &lt;code&gt;Base&lt;/code&gt;, but with a different composition, identity and sum. Next we make this into an effect category over &lt;code&gt;Base&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;effect_category pureErrIntState ErrIntState over Base {&#xA;  ~f      = { state, value = .value f } suc.,&#xA;  side(f) =&#xA;    { runeff = { state = .state,&#xA;                 value = .value .eff } f,&#xA;      onside = .value .pur }&#xA;    @runeff&#xA;    [ err = .runeff err.,&#xA;      suc = { state = .runeff .state,&#xA;              value = { eff = .runeff .value,&#xA;                        pur = .onside } } suc. ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is done by defining the canoncial injection &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;side&lt;/code&gt;, the &lt;em&gt;action&lt;/em&gt; of the effect-category at product components. This is done by interpreting &lt;code&gt;!eff{..}&lt;/code&gt;, lifting some effectful morphism &lt;code&gt;A --&amp;gt; B&lt;/code&gt; into a product &lt;code&gt;{ pur: P, eff: A } --&amp;gt; { pur: P, eff: B }&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Then we provide interpretations for the effects we want to use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;interpret IntState in ErrIntState&#xA;  { get = { state = .state, value = .state} suc.,&#xA;    put = { state = .value, value = {}    } suc.&#xA;  }&#xA;&#xA;interpret Err in ErrIntState&#xA;  { err = .value err. }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, we can execute this effect:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lawvere&#34;&gt;ar Base main : {} --&amp;gt; Int =&#xA;  { state = 0,                 // initialise the state to 0&#xA;    value = #({}, {}, {}) }    // we&#39;ll map over a list of size 3&#xA;  pureErrIntState(mapNextSub3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This returns the list &lt;code&gt;#(0, 1, 2)&lt;/code&gt;, but if one increases the size of the length of the list to 4, then it will instead throw an error.&lt;/p&gt; &#xA;&lt;p&gt;Checkout the &lt;a href=&#34;https://raw.githubusercontent.com/jameshaydon/lawvere/master/examples/partial-state.law&#34;&gt;full example&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;The Categorical Abstract Machine&lt;/h3&gt; &#xA;&lt;p&gt;Lawvere has a compiler to a &lt;a href=&#34;https://www.sciencedirect.com/science/article/pii/0167642387900207&#34;&gt;Categorical Abstract Machine&lt;/a&gt;. Again not all features are supported yet.&lt;/p&gt; &#xA;&lt;p&gt;Compiling the &lt;code&gt;sum&lt;/code&gt; function above (called on an empty list) produces:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bill --target vmcode examples/sum.law&#xA;#main:&#xA;  empty.&#xA;  call #sum&#xA;#sum:&#xA;  cocone empty:#sum_0 cons:#sum_1&#xA;#sum_0:&#xA;  scal 0&#xA;#sum_1:&#xA;  push&#xA;  scal 1&#xA;  push_cone&#xA;  pop&#xA;  push&#xA;  .tail&#xA;  call #sum&#xA;  push_cone&#xA;  pop&#xA;  end_cone 1 2&#xA;  prim plus&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And you can execute the code on the virtual machine with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bill --target vm examples/sum.law&#xA;--------------&#xA;Lawvere v0.0.0&#xA;--------------&#xA;Checking..&#xA;Check OK!&#xA;Running on categorical machine..&#xA;Result: 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compiling to JavaScript&lt;/h3&gt; &#xA;&lt;p&gt;To compile to JavaScript, use the &lt;code&gt;--target js&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bill --target js test.law&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will output a JavaScript program that logs the output. You can pipe this directly to &lt;code&gt;node&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bill --target js test.law | node&#xA;45&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The JavaScript compiler isn&#39;t well maintained and will just error out on the anything but the most basic language features.&lt;/p&gt; &#xA;&lt;h2&gt;Build/Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can build the project with stack or nix.&lt;/p&gt; &#xA;&lt;h3&gt;Stack&lt;/h3&gt; &#xA;&lt;p&gt;First install stack (&lt;code&gt;curl -sSL https://get.haskellstack.org/ | sh &lt;/code&gt;) and then use &lt;code&gt;stack build&lt;/code&gt;. To install the &lt;code&gt;bill&lt;/code&gt; executable (to &lt;code&gt;~/.local/bin&lt;/code&gt;) run &lt;code&gt;stack install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;On linux you may also need to install &lt;code&gt;tinfo&lt;/code&gt;, e.g. &lt;code&gt;sudo apt-get install libtinfo-dev&lt;/code&gt; on Ubuntu.&lt;/p&gt; &#xA;&lt;h3&gt;Nix&lt;/h3&gt; &#xA;&lt;p&gt;Make sure you have &lt;a href=&#34;https://nixos.org/&#34;&gt;nix&lt;/a&gt; and optionally &lt;a href=&#34;https://direnv.net/&#34;&gt;direnv&lt;/a&gt; installed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Optional:&lt;/em&gt; (but faster) install cachix (&lt;code&gt;nix-env -iA cachix -f https://cachix.org/api/v1/install&lt;/code&gt;) and use the &lt;code&gt;lawvere&lt;/code&gt; cache: &lt;code&gt;cachix use lawvere&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To build project dependencies and tooling the first time enter a nix shell either using direnv (recommended):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ echo &#34;use nix&#34; &amp;gt; .envrc&#xA;$ direnv allow&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or manually:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ nix-shell&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once in the nix shell, to build a release and run it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ nix-build nix/release.nix&#xA;$ result/bin/bill &amp;lt;file&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Editor support&lt;/h2&gt; &#xA;&lt;p&gt;For the moment there is only an &lt;a href=&#34;https://raw.githubusercontent.com/jameshaydon/lawvere/master/tools/emacs&#34;&gt;emacs mode&lt;/a&gt;. The syntax looks much better if you use a font with programming ligatures, e.g. &lt;a href=&#34;https://github.com/tonsky/FiraCode&#34;&gt;FiraCode&lt;/a&gt; or &lt;a href=&#34;https://github.com/tonsky/FiraCode#alternatives&#34;&gt;alternatives&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;To update the nix derivation when project dependencies change:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ hpack&#xA;$ cabal2nix . &amp;gt; nix/packages/lawvere.nix&#xA;$ direnv reload&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Cabal is also available in the nix shell so you can build with it as well if you like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Implement more general diagrams and limits/colimits thereof.&lt;/li&gt; &#xA; &lt;li&gt;Make example showing extensible data programming, e.g. let-desugaring as a cartesian retract.&lt;/li&gt; &#xA; &lt;li&gt;Defining via sketches more pure categories, finitely presentable caregories, etc.&lt;/li&gt; &#xA; &lt;li&gt;Make a small (but not just a few lines) &#34;real program&#34;.&lt;/li&gt; &#xA; &lt;li&gt;Allow one to define morphisms via curry/uncurry.&lt;/li&gt; &#xA; &lt;li&gt;Think about if diagrams (which are used for e.g. (co)limits) can be represented as functors directly (from discrete categories).&lt;/li&gt; &#xA; &lt;li&gt;Type checker is not complete; it really needs row variables to be implemented properly.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>