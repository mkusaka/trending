<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-24T02:17:26Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>vincenthz/hs-packer</title>
    <updated>2023-11-24T02:17:26Z</updated>
    <id>tag:github.com,2023-11-24:/vincenthz/hs-packer</id>
    <link href="https://github.com/vincenthz/hs-packer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fast serialization in haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Packer: fast strict serialization in haskell&lt;/h1&gt; &#xA;&lt;p&gt;Packer is originally an experiment when benchmarking other serialization solution, namely cereal and binary. It turns out that the experiment yields interesting result performance-wise, and also allowed different use cases.&lt;/p&gt; &#xA;&lt;p&gt;Packer provides a way to de-serialize and serialize data, from/to bytestring. The usage is very similar to binary and cereal runPut/runGet, except that it doesn&#39;t allow incremental feeding.&lt;/p&gt; &#xA;&lt;h2&gt;Holes&lt;/h2&gt; &#xA;&lt;p&gt;The interface allows to create holes during the packing; this is useful to have a more C like API where some fields are computed a-posteriori:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;putF = do&#xA;    crc32  &amp;lt;- putHoleWord32LE&#xA;    crcVal &amp;lt;- foldM (\acc w -&amp;gt; putWord32LE w &amp;gt;&amp;gt; addCRC acc w) 0 [1,2,3]&#xA;    fillHole crc32 crcVal&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>