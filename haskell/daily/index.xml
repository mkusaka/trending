<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-09T01:42:35Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mlabs-haskell/plutus-simple-model</title>
    <updated>2022-07-09T01:42:35Z</updated>
    <id>tag:github.com,2022-07-09:/mlabs-haskell/plutus-simple-model</id>
    <link href="https://github.com/mlabs-haskell/plutus-simple-model" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Unit testing with resource estimation for Plutus&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Plutus simple model&lt;/h1&gt; &#xA;&lt;p&gt;Unit test library for Plutus with estimation of resource usage.&lt;/p&gt; &#xA;&lt;p&gt;Library defines simple mock model of Blockchain to unit test plutus contracts and estimate usage of resources. What are the benefits for this framework? It&#39;s:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;easy to use&lt;/li&gt; &#xA; &lt;li&gt;easy to think about&lt;/li&gt; &#xA; &lt;li&gt;fast&lt;/li&gt; &#xA; &lt;li&gt;can estimate usage of resources with real functions used on Cardano node.&lt;/li&gt; &#xA; &lt;li&gt;pure&lt;/li&gt; &#xA; &lt;li&gt;good for unit testing of on-chain code&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Install&lt;/h3&gt; &#xA;&lt;p&gt;To add library to your project add it with niv:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;niv add mlabs-haskell/plutus-simple-model -r &amp;lt;library-commit-hash&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And add it to &lt;code&gt;cabal.project&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-- library for unit tests of Plutus scripts                                                                                       &#xA;source-repository-package&#xA;   type: git                                                                                                                         &#xA;   location: https://github.com/mlabs-haskell/plutus-simple-model&#xA;   tag: &amp;lt;same-library-commit-hash-as-for-niv&amp;gt;                                                                              &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Quick start guide&lt;/h3&gt; &#xA;&lt;p&gt;We can create simple blockchain data structure and update within context of State monad. Update happens as a pure function and along TX-confirmation we have useful stats to estimate usage of resources.&lt;/p&gt; &#xA;&lt;p&gt;To create blockchain we first need to specify blockchain config (&lt;code&gt;BchConfig&lt;/code&gt;). Config is specified by protocol parameters (&lt;code&gt;ProtocolParameters&lt;/code&gt;) and era history (&lt;code&gt;EraHistory CardanoMode&lt;/code&gt;). They are cardano config data types. To avoid gory details it&#39;s safe to use predefined config and load it with function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;readDefaultBchConfig :: IO BchConfig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It reads config from files stored in the directory &lt;code&gt;data&lt;/code&gt;. It&#39;s the only non-pure function that we have to use.&lt;/p&gt; &#xA;&lt;p&gt;Once we have config available we can create initial state for blockchain with function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;initBch :: BchConfig -&amp;gt; Value -&amp;gt; Blockchain&#xA;initBch config adminValue = ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It creates blockchain that has only one UTXO that belongs to the admin user. The value is how many coins we are going to give to the admin. Admin can distribute values to test users from admin&#39;s reserves.&lt;/p&gt; &#xA;&lt;p&gt;The rest of the code happens within &lt;code&gt;Run&lt;/code&gt; monad which is a thin wrapper on State over Blockchain under the hood. We have scenarios of script usages as actions in the &lt;code&gt;Run&lt;/code&gt; monad. When we are done we can get the result:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;runBch :: Run a -&amp;gt; Blockchain -&amp;gt; (a, Blockchain)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It just runs the state updates.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s create test users:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- alocate 3 users with 1000 lovelaces each&#xA;setupUsers :: Run [PubKeyHash]&#xA;setupUsers = replicateM 3 $ newUser $ adaValue 1000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can create new user and send values from admin to the user with the function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newUser :: Value -&amp;gt; Run PubKeyHash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Users are identified by their pub key hashes. Note that admin should have the value that we want to share with new user. Otherwise we will get run-time exception.&lt;/p&gt; &#xA;&lt;p&gt;Users can send values to each other with function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sendValue :: PubKeyHash -&amp;gt; Value -&amp;gt; PubKeyHash -&amp;gt; Run ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s share some values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;simpleSpend :: Run Bool&#xA;simpleSpend = do&#xA;  users &amp;lt;- setupUsers                -- create 3 users and assign each 1000 lovelaces&#xA;  let [u1, u2, u3] = users           -- give names for users&#xA;  sendValue u1 (adaValue 100) u2     -- send 100 from user 1 to user 2&#xA;  sendValue u2 (adaValue 100) u3     -- send 100 from user 2 to user 3&#xA;  isOk &amp;lt;- noErrors                   -- check that all TXs were accepted without errors&#xA;  vals &amp;lt;- mapM valueAt users         -- read user values&#xA;  pure $ and                         -- check test predicate&#xA;    [ isOk&#xA;     , vals == fmap adaValue [900, 1000, 1100]&#xA;    ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This example shows how we can create simple tests with library. We create three users and exchange the values between the users. In the test we check that there are no errors (all TXs were accepted to blockchain) and that users have expected values.&lt;/p&gt; &#xA;&lt;p&gt;To check for TX errors we use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;noErrors :: Run Bool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Blockchain logs all failed transactions to te list &lt;code&gt;bchFails&lt;/code&gt;. We check that this list is empty.&lt;/p&gt; &#xA;&lt;p&gt;To read total value for the user we use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;valueAt :: HasAddress addr =&amp;gt; addr -&amp;gt; Run Value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Complete working example of user exchange can be found at test suites (see &lt;code&gt;Suites.Plutus.Model.User&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;h3&gt;Creation of transactions&lt;/h3&gt; &#xA;&lt;p&gt;So now we know how to send values to users. Let&#39;s learn how to work with scripts.&lt;/p&gt; &#xA;&lt;p&gt;When we use function &lt;code&gt;sendValue&lt;/code&gt; it creates TX and submits it to blockchain. TX defines which UTXOs are used as inputs and what UTXOs we want to produce as outputs. As a result (when TX is successful) we destroy input UTXOs and create output UTXOs.&lt;/p&gt; &#xA;&lt;p&gt;UTXO can belong to the user (protected by the private PubKey) and can belong to the script (protected by the contract). The function &lt;code&gt;spendValue&lt;/code&gt; creates TX that uses sender&#39;s UTXO as input and signs it with sender&#39;s pub key and creates receiver&#39;s UTXO as output sealed by receiver&#39;s pub key hash.&lt;/p&gt; &#xA;&lt;p&gt;To post TXs to blockchain we have function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sendTx :: Tx -&amp;gt; Run (Either FailReason Stats)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It takes extended Plutus Tx and tries to submit it. If it fails it returns the reason of failure. If it succeeds it returns statistics of TX execution. It includes TX size if stored on Cardano and execution units (execution steps and memory usage). Execution statistics is important to know that our transaction is suitable for Cardano network. Cardano has certain limits that we should enforce on our TXs.&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;Tx&lt;/code&gt; is not a Plutus TX type. It contains Plutus &lt;code&gt;Tx&lt;/code&gt; and extra info that we may need to specify withdrawals of rewards and staking credentials. We need to use the custom type because staking/credentials is not supported by Plutus TX out of the box.&lt;/p&gt; &#xA;&lt;p&gt;Note that comparing to EmulatorTrace we don&#39;t need to use waitNSlots to force TX submission. It&#39;s submitted right away and slot counter is updated. If we want to submit block of TXs we can use the function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sendBlock :: [Tx] -&amp;gt; Run (Either FailReason [Stats])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function &lt;code&gt;sendTx&lt;/code&gt; just submits a block with single TX in it. It&#39;s ok for most of the cases but if we need to test acceptance of several TXs in the block we can use &lt;code&gt;sendBlock&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There is a common pattern for testing to form single TX, sign it with a key and send to network. If we don&#39;t need to look at the stats we can use function. If it fails it logs the error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;submitTx :: PubKeyHash -&amp;gt; Tx -&amp;gt; Run ()&#xA;submitTx pkh tx = void $ sendTx =&amp;lt;&amp;lt; signTx pkh tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s create Tx and submit it.&lt;/p&gt; &#xA;&lt;h2&gt;Typed validators&lt;/h2&gt; &#xA;&lt;p&gt;You might be familiar with the notion of &lt;code&gt;TypedValdiator&lt;/code&gt; from the library &lt;code&gt;plutus-ledger&lt;/code&gt; which comes from the repo &lt;code&gt;plutus-apps&lt;/code&gt;. In practice &lt;code&gt;plutus-apps&lt;/code&gt; is heavy-weight and often becomes obsolete. To mitigate it&#39;s shortcomings in this library we stay at the plutus level. We work with types that are supported by &lt;code&gt;plutus-ledger-api&lt;/code&gt; and don&#39;t use higher-level types from &lt;code&gt;plutus-ledger&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Nonetheless it&#39;s great to have type-safety and watch out for which datums and redeemers are applied to specific validators. For that the library &lt;code&gt;plutus-simple-model&lt;/code&gt; uses lightweight wrappers to enforce types for datums and redeemers based on scripts. They are defined in the module &lt;code&gt;Plutus.Test.Model.Validator&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There are three types of typed valdiators:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;typed validators for scripts:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype TypedValidator datum redeemer = TypedValdiator Validator&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;typed minting policies:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype TypedPolicy redeemer = TypedPolicy MintingPolicy&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;typed stake validators:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype StakeValidator redeemer = TypedStake StakeValdiator&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We use trick with phantom types to attach type info to the underlying script. Also we have type class that can extract the type info:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class IsValidator script where&#xA;  type DatumType    script :: Type&#xA;  type RedeemerType script :: Type&#xA;  toValidator :: script -&amp;gt; Validator&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In &lt;code&gt;plutus-ledger&lt;/code&gt; we created a special tag for example &lt;code&gt;Game&lt;/code&gt; and we instanciated similiar type class called &lt;code&gt;ValidatorTypes&lt;/code&gt; to specify datum and redeemer tpyes.&lt;/p&gt; &#xA;&lt;p&gt;In &lt;code&gt;plutus-simple-model&lt;/code&gt; we have instances of type class &lt;code&gt;IsValidator&lt;/code&gt; for all typed scripts: &lt;code&gt;TypedValidator&lt;/code&gt;, &lt;code&gt;TypedPolciy&lt;/code&gt; and &lt;code&gt;TypedStake&lt;/code&gt;. Instead of defining a type tag we just use it as type synonym for:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Game = TypedValidator GameDatum GameRedeemer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can create validator with plutus or plutarch and wrap it to &lt;code&gt;TypedValidator&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;gameScript :: Game&#xA;gameScript = TypedValidator $ mkValidatorScript $$(PlutusTx.compile [|| gameContract ||])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We have alias &lt;code&gt;mkTypedValidator&lt;/code&gt; which combines wrappers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;gameScript = mkTypedValidator $$(PlutusTx.compile [|| gameContract ||])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Based on this &lt;code&gt;gameContract&lt;/code&gt; should have type &lt;code&gt;BuiltinData -&amp;gt; BuiltinData -&amp;gt; BuiltinData -&amp;gt; ()&lt;/code&gt;. But in plutus development we used to write typed valdiators and then wrap them &lt;code&gt;mkTypedValidator&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For plutus development there is function to make script defined in type-safe way to work on raw builtin data:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;toBuiltinValidator :: (UnsafeFromData datum, UnsafeFromData redeemer) &#xA;  =&amp;gt; (datum -&amp;gt; redeemer -&amp;gt; ScriptContext -&amp;gt; Bool)&#xA;  -&amp;gt; (BuiltinData -&amp;gt; BuiltinData -&amp;gt; BuiltinData -&amp;gt; ()) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So in plutus development we can define validator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;gameContract :: GameDatum -&amp;gt; GameRedeemer -&amp;gt; ScriptContext -&amp;gt; Bool&#xA;gameContract = ...&#xA;&#xA;gameScript :: Game&#xA;gameScript = TypedValidator $ &#xA;  mkValidatorScript $$(PlutusTx.compile [|| toBuiltinValidator gameContract ||])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similiar functions are defined for minting policies and stake valdiators:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mkTypedPolicy :: CompiledCode (BuiltinData -&amp;gt; BuiltinData -&amp;gt; ()) -&amp;gt; TypedPolicy redeemer&#xA;mkTypedStake  :: CompiledCode (BuiltinData -&amp;gt; BuiltinData -&amp;gt; ()) -&amp;gt; TypedStake redeemer&#xA;&#xA;toBuiltinPolicy :: (UnsafeFromData redeemer)&#xA;  =&amp;gt; (redeemer -&amp;gt; ScriptContext -&amp;gt; Bool) -&amp;gt; (BuiltinData -&amp;gt; BuiltinData -&amp;gt; ())&#xA;&#xA;toBuiltinStake :: (UnsafeFromData redeemer)&#xA;  =&amp;gt; (redeemer -&amp;gt; ScriptContext -&amp;gt; Bool) -&amp;gt; (BuiltinData -&amp;gt; BuiltinData -&amp;gt; ())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example of typed validator&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s define a game of hash guessing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype GameDatum = GuessHash Plutus.BuiltinByteString&#xA;  deriving (Eq)&#xA;&#xA;newtype GameAct = Guess Plutus.BuiltinByteString&#xA;&#xA;PlutusTx.unstableMakeIsData &#39;&#39;GameDatum&#xA;PlutusTx.unstableMakeIsData &#39;&#39;GameAct```&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We have some secret bytestring that is hashed with SHA256 and result of hashing is open to everybody. If user can guess the origin user can take the value of the UTXO.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s define a contract for this logic:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;gameContract :: GameDatum -&amp;gt; GameAct -&amp;gt; ScriptContext -&amp;gt; Bool&#xA;gameContract (GuessHash h) (Guess answer) _ =&#xA;  Plutus.sha2_256 answer Plutus.== h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s compile the script and create &lt;code&gt;TypedValdiator&lt;/code&gt; for testing with our library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Plutus.Test.Model (toBuiltinValidator, TypedValidator, mkTypedValidator)&#xA;&#xA;type Game = TypedValidator GameDatum GameAct&#xA;&#xA;-- | The GeroGov validator script instance&#xA;gameScript :: Game&#xA;gameScript = mkTypedValidator $$(PlutusTx.compile [|| toBuiltinValidator gameContract ||])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We have to define it in separate module than the types definition otherwise GHC complains on mixing compilation with QuasiQuotes with derivation of &lt;code&gt;UnsafeData&lt;/code&gt; instances with template haskell.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s it! This is our contract that we are going to test.&lt;/p&gt; &#xA;&lt;h2&gt;Testing hash game script&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s initialise the game. For that we spend a prize to the UTXO guarded by game validator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;initGame :: PubKeyHash -&amp;gt; Value -&amp;gt; BuiltinByteString -&amp;gt; Run ()&#xA;initGame pkh prize answer = do                   -- arguments: user, value for the prize, answer for puzzle&#xA;  sp &amp;lt;- spend pkh prize                          -- read users UTXO that we should spend&#xA;  tx &amp;lt;- signTx pkh $ initGameTx sp prize answer  -- create TX and sign it with user&#39;s secret key&#xA;  void $ sendTx tx                               -- post TX to blockchain&#xA;&#xA;-- pure function ot create TX&#xA;initGameTx :: UserSpend -&amp;gt; Value -&amp;gt; BuiltinByteString -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;also we can write it with &lt;code&gt;submitTx&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;initGame :: PubKeyHash -&amp;gt; Value -&amp;gt; BuiltinByteString -&amp;gt; Run ()&#xA;initGame pkh prize answer = do               -- arguments: user, value for the prize, answer for puzzle&#xA;  sp &amp;lt;- spend pkh prize                      -- read users UTXO that we should spend&#xA;  submitTx pkh $ initGameTx sp prize answer  -- create TX and sign it with user&#39;s secret key and post TX to blockchain&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s discuss the function bit by bit. To create TX we need to first determine the inputs. Input is set of UTXO&#39;s that we&#39;d like to spend. For that we use function&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;spend :: PubKeyHash -&amp;gt; Value -&amp;gt; Run UserSpend&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a given user and value it returns a value of &lt;code&gt;UserSpend&lt;/code&gt; which holds a set of input UTXOs that cover the value that we want to spend, and also it has change to spend back to user. In the UTXO model we can not split the input. If it&#39;s bigger than we need we have to destroy it and create one UTXO that is given to someone else and another one that is spent back to user. We can think about the latter UTXO as a change.&lt;/p&gt; &#xA;&lt;p&gt;Note that it is going to produce run-time exception if there are not enough funds to spend. To avoid run-time errors there is safer variant called &lt;code&gt;spend&#39;&lt;/code&gt;. Also, we can use safer alternative &lt;code&gt;withSpend&lt;/code&gt;. It logs an error if user has no funds to spend and continues execution which can be helpful in some test cases:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;withSpend :: PubKeyHash -&amp;gt; Value -&amp;gt; (UserSpend -&amp;gt; Run ()) -&amp;gt; Run ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When we know what inputs to spend we need to make a TX. We do it with function &lt;code&gt;initGameTx&lt;/code&gt;. We will discuss it soon. After that we should sign TX with the key of the sender. We use function &lt;code&gt;signTx&lt;/code&gt; for that. As the last step we post TX and hope that it will execute fine (&lt;code&gt;sendTx&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s discuss how to create TX:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;initGameTx :: UserSpend -&amp;gt; Value -&amp;gt; BuiltinByteString -&amp;gt; Tx&#xA;initGameTx usp val answer =&#xA;  mconcat&#xA;    [ userSpend usp&#xA;    , payToScript gameScript (GuessHash $ Plutus.sha2_256 answer) val&#xA;    ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We create transaction by accumulation of monoidal parts. As Plutus Tx is monoid it&#39;s convenient to assemble it from tiny parts. For our task there are just two parts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;for inputs and outputs of user spend&lt;/li&gt; &#xA; &lt;li&gt;pay prize to the script and form right datum for it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We use function to make right part for spending the user inputs and sending change back to user:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;userSpend :: UserSpend -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To pay to script we use function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;payToScript :: IsValidator script =&amp;gt; script -&amp;gt; DatumType script -&amp;gt; Value -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So it uses validator, datum for it (of proper type) and value to protect with the contract. As simple as that. Our type &lt;code&gt;Game&lt;/code&gt; is &lt;code&gt;TypedValidator GameDatum GameRedeemer&lt;/code&gt; and for typed valdiator first tpye argument corresponds to &lt;code&gt;DatumType&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s create another Tx to post solution to the puzzle. It seems to be more involved but don&#39;t be scary. We will take it bit by bit:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;guess :: PubKeyHash -&amp;gt; BuiltinByteString -&amp;gt; Run Bool&#xA;guess pkh answer = do&#xA;  utxos &amp;lt;- utxoAt gameScript             -- get game script UTXO&#xA;  let [(gameRef, gameOut)] = utxos       --   we know there is only one game UTXO&#xA;  mDat &amp;lt;- datumAt @GameDatum gameRef     -- read game&#39;s datum&#xA;  case mDat of                           -- if there is a datum&#xA;    Just dat -&amp;gt; do                       -- let&#39;s create TX and sign it&#xA;      tx &amp;lt;- signTx pkh $ guessTx pkh gameRef (txOutValue gameOut) dat answer&#xA;      isRight &amp;lt;$&amp;gt; sendTx tx              -- let&#39;s send TX to blockchain and find out weather it&#39;s ok.&#xA;    Nothing -&amp;gt; pure False&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This function is a bit bigger because now we want to spend not only our funds but also the fund of the script. For that we look up the script UTXO (&lt;code&gt;utxoAt&lt;/code&gt;) and look up its datum (&lt;code&gt;datumAt&lt;/code&gt;) and when it all succeeds we can form the right TX, sign it with our key and post it to blockchain.&lt;/p&gt; &#xA;&lt;p&gt;Functions that query blockchain are often defined on addresses or &lt;code&gt;TxOutRef&lt;/code&gt;&#39;s:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;utxoAt  :: HasAddress addr =&amp;gt; addr -&amp;gt; Run [(TxOutRef, TxOut)]&#xA;datumAt :: TxOutRef -&amp;gt; Run (Maybe a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Our &lt;code&gt;gameScript&lt;/code&gt; has instance of &lt;code&gt;HasAddress&lt;/code&gt;. It is an address of underlying script. We should query the datum separately because &lt;code&gt;TxOut&lt;/code&gt; contains only hash of it. Let&#39;s look at the pure function that creates TX. Again we assemble TX from monoidal parts:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;guessTx :: PubKeyHash -&amp;gt; TxOutRef -&amp;gt; Value -&amp;gt; GameDatum -&amp;gt; BuiltinByteString -&amp;gt; Tx&#xA;guessTx pkh gameRef gameVal dat answer =&#xA;  mconcat&#xA;    [ spendScript gameScript gameRef (Guess answer) dat&#xA;    , payToPubKey pkh gameVal&#xA;    ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We do two things:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;spend script with right datum and redeemer&lt;/li&gt; &#xA; &lt;li&gt;pay the prize back to us&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To spend script we use function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;spendScript :: IsValidator script &#xA;  =&amp;gt; script -&amp;gt; TxOutRef -&amp;gt; RedeemerType script -&amp;gt; DatumType script -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We provide validator definition, reference to the UTXO of the script, and its redeemer and datum type.&lt;/p&gt; &#xA;&lt;p&gt;The next thing is that we want to take the prize. For that we create output that holds the prize and protected by our own pub key. We do it with the function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;payToPubKey :: PubKeyHash -&amp;gt; Value -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to work with time&lt;/h3&gt; &#xA;&lt;p&gt;Note that every time we submit block successfully one slot passes. By default, one slot lasts for 1 second. Sometimes we want to check for TX that should happen in the future or after some time passes.&lt;/p&gt; &#xA;&lt;p&gt;For that we can use functions to make blockchain move forward:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;waitNSlots :: Slot -&amp;gt; Run ()&#xA;wait       :: POSIXTime -&amp;gt; Run ()&#xA;waitUntil  :: POSIXTime -&amp;gt; Run ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;waitNSlots&lt;/code&gt; waits in slots while &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;waitUntil&lt;/code&gt; wait in &lt;code&gt;POSIXTime&lt;/code&gt; (counted in milliseconds). Also we can query current time with functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;currentSlot :: Run Slot&#xA;currentTime :: Run POSIXTime&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, we always start at the beginning of UNIX epoch. Start of blockchain is set to 0 posix millis. Closely related is function &lt;code&gt;validateIn&lt;/code&gt;. It sets the valid range for TX:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;validateIn :: POSIXTimeRange -&amp;gt; Tx -&amp;gt; Run Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result is wrapped in the Run-monad because we convert &lt;code&gt;POSIXTime&lt;/code&gt; to &lt;code&gt;Slot&lt;/code&gt;&#39;s under the hood and conversion depends on blockchain config.&lt;/p&gt; &#xA;&lt;p&gt;Note that if current time of blockchain is not included in the Tx it will be rejected. So we can not submit TX that is going to be valid in the future. We rely on property that all TXs are validated right away. It means that current time should be included in valid range for TX. By default, it&#39;s &lt;code&gt;always&lt;/code&gt;, it means &#34;any time&#34; and should work.&lt;/p&gt; &#xA;&lt;p&gt;Also note that because Plutus uses &lt;code&gt;POSIXTime&lt;/code&gt; while the Cardano network uses Slots, the inherent difference in precision between Slot and &lt;code&gt;POSIXTime&lt;/code&gt; may cause unexpected validation failures. For example, if we try to build a transaction using the &lt;code&gt;POSIXTimeRange&lt;/code&gt; &lt;code&gt;(1100,3400)&lt;/code&gt;, it will be converted to &lt;code&gt;SlotRange&lt;/code&gt; &lt;code&gt;(1,4)&lt;/code&gt; to go through the Cardano network, and when it is converted back to Plutus, the POSIXRange will have been extended to cover the whole slot range, becoming &lt;code&gt;(1000,4000)&lt;/code&gt; and maybe trespassing the allowed limits set by the validator.&lt;/p&gt; &#xA;&lt;p&gt;POSIXTime is counted in milliseconds. To count in human-readable format we have convenient functions: &lt;code&gt;days&lt;/code&gt;, &lt;code&gt;hours&lt;/code&gt;, &lt;code&gt;minutes&lt;/code&gt;, &lt;code&gt;seconds&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;wait $ hours 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it. you can find complete example at the test suite (see &lt;code&gt;Suites.Plutus.Model.Script.Test.Game&lt;/code&gt;). There are other useful function to dicuss. Look up the docs for the &lt;code&gt;Blockchain&lt;/code&gt; and &lt;code&gt;Contract&lt;/code&gt; modules.&lt;/p&gt; &#xA;&lt;h3&gt;How to use custom coins&lt;/h3&gt; &#xA;&lt;p&gt;Often we need to use some custom coins to test the task. To create new coin we usually need to create the minting policy script for it and setup rules to mint the coins.&lt;/p&gt; &#xA;&lt;p&gt;To make this task easy there are &#34;fake&#34; coins provided by the library. To create fake coin we can use functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;testCoin :: FakeCoin&#xA;testCoin = FakeCoin &#34;test-coin-A&#34;&#xA;&#xA;fakeValue :: FakeCoin -&amp;gt; Integer -&amp;gt; Value&#xA;fakeCoin  :: FakeCoin -&amp;gt; AssetClass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With those functions we can assign some fake coins to admin user on start up of the blockchain:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;testValue = fakeValue testCoin&#xA;bch = initBch config (adaValue 1000_000 &amp;lt;&amp;gt; testValue 1000)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the blockchain code we can give those fake coins to users when we create them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;u1 &amp;lt;- newUser (adaValue 100 &amp;lt;&amp;gt; testValue 10)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that when we send custom value from one user to another we also have to send some minimal ada value. In Cardano every UTXO should have some ada in it. EmulatorTrace hides those details but in this test framework it&#39;s exposed to the user.&lt;/p&gt; &#xA;&lt;p&gt;So to send 5 test coins from one user to another add some ada to it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sendValue user1 (adaValue 1 &amp;lt;&amp;gt; testValue 5) user2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Log custom errors&lt;/h3&gt; &#xA;&lt;p&gt;We can log our own errors with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;logError :: String -&amp;gt; Run ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Errors are saved to log of errors. This way we can report our own errors based on conditions. If values are wrong or certain NFT was not created etc.&lt;/p&gt; &#xA;&lt;p&gt;Also, we can log information with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;logInfo :: String -&amp;gt; Run ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It saves information to the log. the log of errors is unaffected. We can read log messages with function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;getLog :: Blockchain -&amp;gt; Log BchEvent&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where BchEvent is one of the events:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data BchEvent&#xA;  = BchTx TxStat           -- ^ Sucessful TXs&#xA;  | BchInfo String         -- ^ Info messages&#xA;  | BchFail FailReason     -- ^ Errors&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How to skip messages from the logs&lt;/h4&gt; &#xA;&lt;p&gt;All TXs are logged, sometimes we do auxiliary TX that are irrelevant for testing, and we want to skip the logging of them. For this case we can use function&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;noLog :: Run a -&amp;gt; Run a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It executes an action and during execution it omits all logging of TXs and info level messages. But errors are logged. If we want more fine-grain control we can use &lt;code&gt;noLogTx&lt;/code&gt; and &lt;code&gt;noLogInfo&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Logging blockchain state&lt;/h4&gt; &#xA;&lt;p&gt;The ability to observe what&#39;s going on in the blockchain is a great way to understand things. To log balances use &lt;code&gt;logBchState&lt;/code&gt; action, which saves current state as a log entry. To show log use &lt;code&gt;testNoErrorsTrace&lt;/code&gt; helper (see below).&lt;/p&gt; &#xA;&lt;h3&gt;How to check balances&lt;/h3&gt; &#xA;&lt;p&gt;There are useful functions to check not absolute balances but balance transitions. We have type &lt;code&gt;BalanceDiff&lt;/code&gt; and we can construct it with function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;owns  :: HasAddress addr =&amp;gt; addr -&amp;gt; Value -&amp;gt; BalanceDiff&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It states that address gained so many coins. We have useful function to check the move of values from one address to another&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;gives :: (HasAddress addrFrom, HasAddress addrTo) =&amp;gt; addrFrom -&amp;gt; Value -&amp;gt; addrTo -&amp;gt; BalanceDiff&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The type &lt;code&gt;BalanceDiff&lt;/code&gt; is a monoid. So we can stack several transitions with &lt;code&gt;mappend&lt;/code&gt; and &lt;code&gt;mconcat&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To check the balances we use function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;checkBalance :: BalanceDiff -&amp;gt; Run a -&amp;gt; Run a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It queries balances before application of an action and after application of the action and reports any errors. If balances does not match to expected difference.&lt;/p&gt; &#xA;&lt;p&gt;For example, we can check that sendValue indeed transfers value from one user to another:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;checkBalance (gives u1 val u2) $ sendValue u1 val u2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we want to check that user or script preserved the value we can set it up with &lt;code&gt;(owns user mempty)&lt;/code&gt;. Because TypedValidator has instanced of the HasAddress we can also check payments to/from scripts:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;checkBalance (gives pkh prize gameScript) $ do { ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sometimes we need to check balances based on result of the action. For that we have generic function &lt;code&gt;checkBalanceBy&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;checkBalanceBy :: (a -&amp;gt; BalanceDiff) -&amp;gt; Run a -&amp;gt; Run a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See more examples at tests for &lt;code&gt;Game&lt;/code&gt; and &lt;code&gt;Counter&lt;/code&gt; scripts.&lt;/p&gt; &#xA;&lt;h3&gt;How to use in unit tests&lt;/h3&gt; &#xA;&lt;p&gt;For convenience there is a function &lt;code&gt;testNoErrors&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;testNoErrors :: Value -&amp;gt; BchConfig -&amp;gt; String -&amp;gt; Run a -&amp;gt; TestTree&#xA;testNoErrors totalBchFunds bchConfig testMessage script = ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It checks that given script runs without errors. Note that if we want to use custom checks on run-time values we can query checks inside the script and log errors with &lt;code&gt;logError&lt;/code&gt;. By default, it also checks for resource usage constraints.&lt;/p&gt; &#xA;&lt;p&gt;A more verbatim alternative is &lt;code&gt;testNoErrorsTrace&lt;/code&gt; which is the same, but prints out the blockchain log on both failures and successes. The output might be rather excessive, so use it judiciously. Probably it&#39;s worth using one of these functions depending on the runtime &#34;dump log&#34; parameter value (if you use &lt;code&gt;tasty&lt;/code&gt; you might want to use an &lt;code&gt;Ingredient&lt;/code&gt; to implement this).&lt;/p&gt; &#xA;&lt;p&gt;If we want to check only logic but not resource usage we can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;skipLimits :: BchConfig -&amp;gt; BchConfig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, there is function &lt;code&gt;warnLimits&lt;/code&gt; that logs errors of resources usage but does not fail TX for submission. So if logic is correct script will run but errors of resources will be logged to error log.&lt;/p&gt; &#xA;&lt;h3&gt;How to write negative tests&lt;/h3&gt; &#xA;&lt;p&gt;Often we need to check for errors also. We have to be sure that some TX fails. Maybe this TX is malicious one, and we have to be sure that it can not pass. For that we have useful function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mustFail :: Run a -&amp;gt; Run a&#xA;mustFail action = ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It saves the current state of blockchain and tries to run the &lt;code&gt;action&lt;/code&gt; and if the action succeeds it logs an error but if action fails it does not log error and retrieves the stored previous blockchain state.&lt;/p&gt; &#xA;&lt;p&gt;This way we can ensure that some scenario fails, and we can proceed the execution of blockchain actions.&lt;/p&gt; &#xA;&lt;h3&gt;How to fail with custom conditions&lt;/h3&gt; &#xA;&lt;p&gt;We can also fail on custom conditions with function &lt;code&gt;logError&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;unless checkCondition $ logError &#34;Some invariant violated&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to check TX resource usage&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes we write too much code in the validators, and it starts to exceed execution limits. TXs like this can not be executed on chain. To watch out for that we have special function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;testLimits ::&#xA;   Value&#xA;   -&amp;gt; BchConfig&#xA;   -&amp;gt; String&#xA;   -&amp;gt; (Log TxStat -&amp;gt; Log TxStat)&#xA;   -&amp;gt; Run a&#xA;   -&amp;gt; TestTree&#xA;testLimits totalBchFunds bchConfig testMessage logFilter script&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s break apart what it does. It runs blockchain with limit check config set to @WarnLimits@. This way we proceed to execute TX on blockchain even if TX exceeds the limits, but we save the error every time it happens. When script was run if resource usage errors are encountered they are logged to the user in easy to read way.&lt;/p&gt; &#xA;&lt;p&gt;To see the logs even on successful run we can add fake error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(script &amp;gt;&amp;gt; logError &#34;Show stats&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The results are shown in the percentage to the mainnet limit. We need to care that all of them are below 100%. Also note that we&#39;d better have some headroom and keep it not close to 100% because number of inputs in TX is unpredictable. we can aggregate input values for the scripts from many UTXOs. So we&#39;d better have the free room available for extra UTXOs.&lt;/p&gt; &#xA;&lt;p&gt;Filter of the log can be useful to filter out some non-related events. for example setup of the blockchain users. We typically cn use it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;good &#34;Reward scripts&#34; (filterSlot (&amp;gt; 4)) (Rewards.simpleRewardTestBy 1)&#xA;  where&#xA;    good = testLimits initFunds cfg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s good to implement complete set of unit tests first and then add limits tests. So that every transformation to optimise on resources is checked by ordinary unit tests. On unit tests we can skip limit checks with &lt;code&gt;skipLimits :: BchConfig -&amp;gt; BchConfig&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Box - a typed TxOut&lt;/h3&gt; &#xA;&lt;p&gt;Often when we work with scripts we need to read &lt;code&gt;TxOut&lt;/code&gt; to get datum hash to read the datum next and after that we specify how datum is updated on TX.&lt;/p&gt; &#xA;&lt;p&gt;Enter the Box - typed &lt;code&gt;TxOut&lt;/code&gt;. The &lt;code&gt;Box&lt;/code&gt; is &lt;code&gt;TxOut&lt;/code&gt; augmented with typed datum. We can read Box for the script with the function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;boxAt :: (IsValidator script) =&amp;gt; script -&amp;gt; Run [TxBox script]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It reads the typed box. We can use it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;gameBox &amp;lt;- head &amp;lt;$&amp;gt; boxAt @Game gameScript&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sometimes it&#39;s useful to read the box by NFT, since often scripts are identified by unque NFTs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;nftAt :: (IsValidator script) =&amp;gt; script -&amp;gt; Run (TxBox script)&#xA;nftAt tv = ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So let&#39;s look at the box:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Typed txOut that contains decoded datum&#xA;data TxBox a = TxBox&#xA;  { txBoxRef   :: TxOutRef    -- ^ tx out reference&#xA;  , txBoxOut   :: TxOut       -- ^ tx out&#xA;  , txBoxDatum :: DatumType a -- ^ datum&#xA;  }&#xA;&#xA;txBoxValue :: TxBox a -&amp;gt; Value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It has everything that &lt;code&gt;TxOut&lt;/code&gt; has, but also we have our typed datum. There are functions that provide typical script usage.&lt;/p&gt; &#xA;&lt;p&gt;We can just spend boxes as scripts:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;spendBox :: (IsValidator v) =&amp;gt; &#xA;  v -&amp;gt; RedeemerType v -&amp;gt; TxBox v -&amp;gt; Tx&#xA;spendBox tv redeemer box&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The most generic function is &lt;code&gt;modifyBox&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;modifyBox :: (IsValidator v) &#xA;  =&amp;gt; v -&amp;gt; TxBox v -&amp;gt; RedeemerType v &#xA;  -&amp;gt; (DatumType v -&amp;gt; DatumType v) &#xA;  -&amp;gt; (Value -&amp;gt; Value) &#xA;  -&amp;gt; Tx&#xA;modifyBox tv box redeemer updateDatum updateValue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It specifies how we update the box datum and value. Also, often we use boxes as oracles:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;readOnlyBox :: (IsValidator v)&#xA;  =&amp;gt; v -&amp;gt; TxBox v -&amp;gt; RedeemerType v -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It keeps the datum and value the same.&lt;/p&gt; &#xA;&lt;h3&gt;How to pay to the addresses with staking credentials&lt;/h3&gt; &#xA;&lt;p&gt;We can append the information on staking credential to anything that is convertible to &lt;code&gt;Address&lt;/code&gt; by &lt;code&gt;HasAddress&lt;/code&gt; type class with constructor &lt;code&gt;AppendStaking&lt;/code&gt;. Also, we have utility functions &lt;code&gt;appendStakingPubKey&lt;/code&gt; and &lt;code&gt;appendStakingScript&lt;/code&gt; which append &lt;code&gt;PubKeyHash&lt;/code&gt; and &lt;code&gt;ValidatorHash&lt;/code&gt; as staking credential.&lt;/p&gt; &#xA;&lt;p&gt;For example, we can append it to the &lt;code&gt;TypeValidator&lt;/code&gt; of the script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;payToScript (appendStakingPubKey stakingKey typedValidator) datum value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s why we use not &lt;code&gt;TypedValidator&lt;/code&gt; in the payToScript and similiar functions. It turns out that if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;IsValidator&lt;/code&gt; and &lt;code&gt;HasAddress&lt;/code&gt; then &lt;code&gt;AppendStaking v&lt;/code&gt; is also &lt;code&gt;IsValidator&lt;/code&gt; and &lt;code&gt;HasAddress&lt;/code&gt; and correct datum and redeemer types are set up.&lt;/p&gt; &#xA;&lt;p&gt;So we can use the same functions with scritps that have some staking info attached to them. Let&#39;s recall the type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;payToScript :: (IsValidator v) =&amp;gt; v -&amp;gt; DatumType v -&amp;gt; Value -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The same function exists to pay to pub key hash:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;payToPubKey :: HasAddress pubKeyHash =&amp;gt; pubKeyHash -&amp;gt; Value -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Certificates and withdrawals of the rewards&lt;/h3&gt; &#xA;&lt;p&gt;In cardano staking pools are driving force behind confirmation of transactions. For the work pool owners receive fees. The fees get distributed among staking credentials that delegate to pool.&lt;/p&gt; &#xA;&lt;p&gt;So we have staking pool operator (SPO) who is chosen for this round to confirm TX. And for this work SPO gets the fees. Fees are collected to the addresses that are called staking credentials. Users can delegate staking credential to the pool owner (SPO).&lt;/p&gt; &#xA;&lt;p&gt;So far we have ignored the fees, but in real scenario every transaction should contain fees. To pay fee in the transaction we can use function. The fees are fairly distributed among all staking credentials that belong to the pool:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- Pay fee for TX confirmation. The fees are payed in ADA (Lovelace)&#xA;payFee :: Value -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How reward distribution works&lt;/h4&gt; &#xA;&lt;p&gt;For each round of TX confirmation there is a pool called &lt;strong&gt;leader&lt;/strong&gt; that confirms TX. For that the pool receives fees and fairly distributes them among stake credentials that delegate to that pool.&lt;/p&gt; &#xA;&lt;p&gt;For this testing framework we go over a list of pools one by one and on each TX-confirmation we choose the next pool. All staking credentials delegated to the pool receive equal amount of fees. When blockchain initialised we have a single pool id and stake credential that belongs to the admin (user who owns all funds on genesis TX).&lt;/p&gt; &#xA;&lt;p&gt;So to test some Stake validator we need to register it in the blockchain and delegate it to admin&#39;s pool. We can get the pool of the admin by calling &lt;code&gt;(head &amp;lt;$&amp;gt; getPools)&lt;/code&gt;. This gives the pool identifier of the only pool that is registered. After that we create TX that registers taking credential and delegates it to admin&#39;s pool. We can provide enough fees for that TX to check the stake validator properties.&lt;/p&gt; &#xA;&lt;p&gt;As an example we can use the test-case in the module &lt;code&gt;Suites.Plutus.Model.Script.Test.Staking&lt;/code&gt;. It implements a basic stake validator and checks that it works (see the directory &lt;code&gt;test&lt;/code&gt; for this repo).&lt;/p&gt; &#xA;&lt;h4&gt;Certificates&lt;/h4&gt; &#xA;&lt;p&gt;To work with pools and staking credentials we use certificates (&lt;code&gt;DCert&lt;/code&gt; in Plutus). We have functions that trigger actions with pools and staking credentials:&lt;/p&gt; &#xA;&lt;p&gt;First we need to register staking credential by pub key hash (rewards belong to certain key) or by the script. For the script there is guarding logic that regulates spending of rewards for staking credential. For the key we require that TX is signed by the given key to spend the reward.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;registerStakeKey    :: PubKeyHash -&amp;gt; Tx&#xA;&#xA;registerStakeScript :: IsValidator (TypedStake redeemer) =&amp;gt;&#xA;  TypedStake redeemer -&amp;gt; redeemer -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also we can deregistrate the staking credential:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;deregisterStakeKey    :: PubKeyHash -&amp;gt; Tx&#xA;&#xA;deregisterStakeScript :: IsValidator (TypedStake redeemer) =&amp;gt; &#xA;  TypedStake redeemer -&amp;gt; redeemer -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A staking credential can get rewards only over a pool. To associate it with pool we use the function delegate:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;delegateStakeKey    :: PubKeyHash -&amp;gt; PoolId -&amp;gt; Tx&#xA;&#xA;delegateStakeScript :: IsValidator (TypedStake redeemer) =&amp;gt; &#xA;  TypedStake redeemer -&amp;gt; redeemer -&amp;gt; PoolId -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The type &lt;code&gt;PoolId&lt;/code&gt; is just a &lt;code&gt;newtype&lt;/code&gt; wrapper for &lt;code&gt;PubKeyHash&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype PoolId = PoolId { unPoolId :: PubKeyHash }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As blockchain starts we have only one pool and staking credential associated with it. It is guarded by admin&#39;s pub key hash.&lt;/p&gt; &#xA;&lt;p&gt;We can register or deregister (retire) pools with functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;registerPool :: PoolId -&amp;gt; Tx&#xA;retirePool   :: PoolId -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alas above functions do not work (need to fix conversion to VrfKey) at the moment. Use direct insertion/removal of pools with &lt;code&gt;insertPool&lt;/code&gt; and &lt;code&gt;deletePool&lt;/code&gt; to manage stake pools:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertPool :: PoolId -&amp;gt; Run ()&#xA;deletePool :: PoolId -&amp;gt; Run ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For staking validators each of those functions is going to trigger validation with purpose &lt;code&gt;Certifying DCert&lt;/code&gt;. Where &lt;code&gt;DCert&lt;/code&gt; can be one of the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data DCert&#xA;  = DCertDelegRegKey StakingCredential     -- register stake&#xA;  | DCertDelegDeRegKey StakingCredential   -- deregister stake&#xA;  | DCertDelegDelegate                     -- delegate stake to pool&#xA;      StakingCredential&#xA;      -- ^ delegator&#xA;      PubKeyHash&#xA;      -- ^ delegatee&#xA;  | -- | A digest of the PoolParams&#xA;    DCertPoolRegister                     -- register pool&#xA;      PubKeyHash&#xA;      -- ^ poolId&#xA;      PubKeyHash&#xA;      -- ^ pool VFR&#xA;  | -- | The retiremant certificate and the Epoch N&#xA;    DCertPoolRetire PubKeyHash Integer   -- retire the pool &#xA;                                         -- NB: Should be Word64 but we only have Integer on-chain&#xA;  | -- | A really terse Digest&#xA;    DCertGenesis                         -- not supported for testing yet&#xA;  | -- | Another really terse Digest&#xA;    DCertMir                             -- not supported for testing yet&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Query staking credentials and pools&lt;/h4&gt; &#xA;&lt;p&gt;We can collect various stats during execution on how many coins we have for rewards and where staking credential belongs to.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- get all pools&#xA;getPools :: Run [PoolId]&#xA;&#xA;-- get staking credential by pool&#xA;stakesAt :: PoolId -&amp;gt; Run [StakingCredential]&#xA;&#xA;-- get rewards for a StakingCredential, PubKeyHash and StakeValidator or TypedStake&#xA;rewardAt :: HasStakingCredential cred =&amp;gt; cred -&amp;gt; Run Integer&#xA;&#xA;-- query if pool is registered&#xA;hasPool :: PoolId -&amp;gt; Run Bool&#xA;&#xA;-- query if staking credential is registered&#xA;hasStake :: HasStakingCredential cred =&amp;gt; cred -&amp;gt; Run Bool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Utility functions to create staking credentials&lt;/h4&gt; &#xA;&lt;p&gt;We can create staking credential out of pub key hash or stake validator with function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;toStakingCredential :: HasStakingCredential a =&amp;gt; a -&amp;gt; StakingCredential&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Withdrawals of the rewards&lt;/h4&gt; &#xA;&lt;p&gt;When staking credential has some rewards we can withdraw it and send to some address. To do it we need to spend all rewards, so we need to provide exact amount that is stored in the rewards of the staking credential at the time of TX confirmation.&lt;/p&gt; &#xA;&lt;p&gt;We can query the current amount with function &lt;code&gt;rewardAt&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- get rewards for a StakingCredential&#xA;rewardAt :: StakingCredential -&amp;gt; Run Integer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To get rewards we need to include in transaction this part:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;withdrawStakeKey    :: PubKeyHash -&amp;gt; Integer -&amp;gt; Tx&#xA;&#xA;withdrawStakeScript :: (IsValidator script) =&amp;gt; &#xA;  TypedStake script -&amp;gt; RedeemerType script -&amp;gt; Integer -&amp;gt; Tx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with certificates we can withdraw by pub key hash (needs to be signed by that key) and also by validator.&lt;/p&gt; &#xA;&lt;p&gt;To test withdraws we need to have rewards. We can easily generate rewards by making transactions that contain fees granted with &lt;code&gt;payFee&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;h2&gt;Ledger reexports&lt;/h2&gt; &#xA;&lt;p&gt;As plutus-ledger is not available with removing plutus-apps dependency. We still provide some useful functionality from it. It&#39;s placed under &lt;code&gt;Plutus.Test.Model.Ledger&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Ledger.Ada&lt;/code&gt; - &lt;code&gt;Ada&lt;/code&gt; type wrapper and functions for it&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Ledger.Scripts&lt;/code&gt; - useful functions to calculate hashes&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>nmattia/niv</title>
    <updated>2022-07-09T01:42:35Z</updated>
    <id>tag:github.com,2022-07-09:/nmattia/niv</id>
    <link href="https://github.com/nmattia/niv" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Easy dependency management for Nix projects&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;niv&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/nmattia/niv/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/nmattia/niv/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;Test&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://niv.nmattia.com&#34;&gt;&lt;img src=&#34;https://api.netlify.com/api/v1/badges/48532eaa-259f-4ca2-aadf-67f7c6b957fd/deploy-status&#34; alt=&#34;Netlify Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Painless dependencies for &lt;a href=&#34;https://nixos.org/nix/&#34;&gt;Nix&lt;/a&gt; projects. Read more in the &lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#getting-started&#34;&gt;Getting started&lt;/a&gt; section below.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://niv.nmattia.com/niv.svg?sanitize=true&#34;&gt; &lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#install&#34;&gt;Install&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#build&#34;&gt;Build&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#usage&#34;&gt;Usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#frequently-asked-questions&#34;&gt;FAQ&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;niv&lt;/code&gt; is available in &lt;a href=&#34;https://github.com/NixOS/nixpkgs&#34;&gt;&lt;code&gt;nixpkgs&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;niv&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ nix-env -iA nixpkgs.niv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, run the following command to install the development version:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ nix-env -iA niv -f https://github.com/nmattia/niv/tarball/master \&#xA;    --substituters https://niv.cachix.org \&#xA;    --trusted-public-keys niv.cachix.org-1:X32PCg2e/zAm3/uD1ScqW2z/K0LtDyNV7RdaxIuLgQM=&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;Inside the provided nix shell:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ repl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the test suite with this command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./script/test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;niv&lt;/code&gt; simplifies &lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#add&#34;&gt;adding&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#update&#34;&gt;updating&lt;/a&gt; dependencies in Nix projects. It uses a single file, &lt;code&gt;nix/sources.json&lt;/code&gt;, where it stores the data necessary for fetching and updating the packages.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#add&#34;&gt;Add&lt;/a&gt;: inserts a package in &lt;code&gt;nix/sources.json&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#update&#34;&gt;Update&lt;/a&gt;: updates one or all packages in &lt;code&gt;nix/sources.json&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#drop&#34;&gt;Drop&lt;/a&gt;: deletes a package from &lt;code&gt;nix/sources.json&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;niv&lt;/code&gt; has some utility functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#init&#34;&gt;Init&lt;/a&gt;: bootstraps a Nix project, in particular creates a &lt;code&gt;nix/sources.json&lt;/code&gt; file containing &lt;code&gt;niv&lt;/code&gt; and &lt;code&gt;nixpkgs&lt;/code&gt; as well as a &lt;code&gt;nix/sources.nix&lt;/code&gt; file that returns the sources as a Nix object.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#show&#34;&gt;Show&lt;/a&gt;: shows the packages&#39; information.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#modify&#34;&gt;Modify&lt;/a&gt;: modifies attributes &lt;em&gt;without&lt;/em&gt; performing an update.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;The following environment variables are read by &lt;code&gt;niv&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Note&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GITHUB_TOKEN or NIV_GITHUB_TOKEN&lt;/td&gt; &#xA;   &lt;td&gt;When set, the value is used to authenticate GitHub API requests.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GITHUB_HOST or NIV_GITHUB_HOST&lt;/td&gt; &#xA;   &lt;td&gt;The GitHub host to use when fetching packages. Port may be appended here.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GITHUB_API_HOST or NIV_GITHUB_API_HOST&lt;/td&gt; &#xA;   &lt;td&gt;The host used when performing GitHub API requests. Use &lt;code&gt;GITHUB_API_PORT&lt;/code&gt; for specifying the port.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GITHUB_API_PORT or NIV_GITHUB_API_PORT&lt;/td&gt; &#xA;   &lt;td&gt;The port used when performing GitHub API requests. Defaults to &lt;code&gt;443&lt;/code&gt; for secure requests. Defaults to &lt;code&gt;80&lt;/code&gt; for insecure requests. See also: &lt;code&gt;GITHUB_INSECURE&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NIV_GITHUB_INSECURE&lt;/td&gt; &#xA;   &lt;td&gt;When set to anything but the empty string, requests are performed over &lt;code&gt;http&lt;/code&gt; instead of &lt;code&gt;https&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NIV_GITHUB_PATH&lt;/td&gt; &#xA;   &lt;td&gt;The base path used when performing GitHub API requests.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The next two sections cover &lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#getting-started&#34;&gt;common use cases&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#commands&#34;&gt;full command description&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Getting started&lt;/h3&gt; &#xA;&lt;p&gt;This section covers common use cases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#bootstrapping-a-nix-project&#34;&gt;Bootstrapping a Nix project&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#tracking-a-nixpkgs-branch&#34;&gt;Tracking a different nixpkgs branch&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#importing-packages-from-github&#34;&gt;Importing packages from GitHub&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#using-custom-urls&#34;&gt;Fetching packages from custom URLs&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Bootstrapping a Nix project&lt;/h4&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;init&lt;/code&gt; command when starting a new Nix project or when porting an existing Nix project to niv:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ niv init&#xA;...&#xA;$ tree&#xA;.&#xA; nix&#xA; &amp;nbsp;&amp;nbsp;  sources.json&#xA; &amp;nbsp;&amp;nbsp;  sources.nix&#xA;&#xA;1 directory, 2 files&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The file &lt;code&gt;nix/sources.json&lt;/code&gt; is the file used by niv to store versions and is initialized with nixpkgs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;nixpkgs&#34;: {&#xA;        &#34;branch&#34;: &#34;release-21.05&#34;,&#xA;        &#34;description&#34;: &#34;Nix Packages collection&#34;,&#xA;        &#34;homepage&#34;: &#34;&#34;,&#xA;        &#34;owner&#34;: &#34;NixOS&#34;,&#xA;        &#34;repo&#34;: &#34;nixpkgs&#34;,&#xA;        &#34;rev&#34;: &#34;5f244caea76105b63d826911b2a1563d33ff1cdc&#34;,&#xA;        &#34;sha256&#34;: &#34;1xlgynfw9svy7nvh9nkxsxdzncv9hg99gbvbwv3gmrhmzc3sar75&#34;,&#xA;        &#34;type&#34;: &#34;tarball&#34;,&#xA;        &#34;url&#34;: &#34;https://github.com/NixOS/nixpkgs/archive/5f244caea76105b63d826911b2a1563d33ff1cdc.tar.gz&#34;,&#xA;        &#34;url_template&#34;: &#34;https://github.com/&amp;lt;owner&amp;gt;/&amp;lt;repo&amp;gt;/archive/&amp;lt;rev&amp;gt;.tar.gz&#34;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To use this dependency, &lt;code&gt;import&lt;/code&gt; the file &lt;code&gt;nix/sources.nix&lt;/code&gt;, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{ sources ? import ./sources.nix }:     # import the sources&#xA;import sources.nixpkgs                  # and use them again!&#xA;  { overlays = [] ; config = {}; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information about importing sources to your nix files, check the &lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#Frequently-asked-questions&#34;&gt;frequently asked questions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Tracking a nixpkgs branch&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;init&lt;/code&gt; command sets the &lt;code&gt;nix/sources.json&lt;/code&gt; to the content of the file &lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/data/nixpkgs.json&#34;&gt;data/nixpkgs.json&lt;/a&gt;. Currently, you would be tracking the &lt;code&gt;release-21.05&lt;/code&gt; branch. Run the following command to update it to the last commit of the configured branch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ niv update nixpkgs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To change the branch being tracked run this command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ niv update nixpkgs -b master     # equivalent to --branch master&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Importing packages from GitHub&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;add&lt;/code&gt; command will infer information about the package being added, when possible. This works very well for GitHub repositories. Run this command to add &lt;a href=&#34;https://stedolan.github.io/jq/&#34;&gt;jq&lt;/a&gt; to your project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ niv add stedolan/jq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following data was added in &lt;code&gt;nix/sources.json&lt;/code&gt; for &lt;code&gt;jq&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;homepage&#34;: &#34;http://stedolan.github.io/jq/&#34;,&#xA;  &#34;url&#34;: &#34;https://github.com/stedolan/jq/archive/9fa2e51099c55af56e3e541dc4b399f11de74abe.tar.gz&#34;,&#xA;  &#34;owner&#34;: &#34;stedolan&#34;,&#xA;  &#34;branch&#34;: &#34;master&#34;,&#xA;  &#34;url_template&#34;: &#34;https://github.com/&amp;lt;owner&amp;gt;/&amp;lt;repo&amp;gt;/archive/&amp;lt;rev&amp;gt;.tar.gz&#34;,&#xA;  &#34;repo&#34;: &#34;jq&#34;,&#xA;  &#34;sha256&#34;: &#34;0819rvk8057qgcqvgn7fpldvly2pfdw9fxcjrlqa8gr59p8a1cic&#34;,&#xA;  &#34;description&#34;: &#34;Command-line JSON processor&#34;,&#xA;  &#34;rev&#34;: &#34;9fa2e51099c55af56e3e541dc4b399f11de74abe&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Using custom URLs&lt;/h4&gt; &#xA;&lt;p&gt;It is possible to use niv to fetch packages from custom URLs. Run this command to add the Haskell compiler &lt;a href=&#34;https://www.haskell.org/ghc/&#34;&gt;GHC&lt;/a&gt; to your &lt;code&gt;nix/sources.json&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ niv add ghc   \&#xA;    -v 8.4.3    \&#xA;    -t &#39;https://downloads.haskell.org/~ghc/&amp;lt;version&amp;gt;/ghc-&amp;lt;version&amp;gt;-i386-deb8-linux.tar.xz&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The option &lt;code&gt;-v&lt;/code&gt; sets the &#34;version&#34; attribute to &lt;code&gt;8.4.3&lt;/code&gt;. The option &lt;code&gt;-t&lt;/code&gt; sets a template that can be reused by niv when fetching a new URL (see the documentation for &lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#add&#34;&gt;add&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#update&#34;&gt;update&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The type of the dependency is guessed from the provided URL template, if &lt;code&gt;-T&lt;/code&gt; is not specified.&lt;/p&gt; &#xA;&lt;p&gt;For updating the version of GHC used run this command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ niv update ghc -v 8.6.2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Commands&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;niv - dependency manager for Nix projects&#xA;&#xA;version: 0.2.21&#xA;&#xA;Usage: niv [-s|--sources-file FILE] [--no-colors] COMMAND&#xA;&#xA;Available options:&#xA;  -s,--sources-file FILE   Use FILE instead of nix/sources.json&#xA;  --no-colors              Don&#39;t use colors in output&#xA;  -h,--help                Show this help text&#xA;  --version                Print version&#xA;&#xA;Available commands:&#xA;  init                     Initialize a Nix project. Existing files won&#39;t be&#xA;                           modified.&#xA;  add                      Add a GitHub dependency&#xA;  show                     &#xA;  update                   Update dependencies&#xA;  modify                   Modify dependency attributes without performing an&#xA;                           update&#xA;  drop                     Drop dependency&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Add&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;Examples:&#xA;&#xA;  niv add stedolan/jq&#xA;  niv add NixOS/nixpkgs -n nixpkgs -b nixpkgs-unstable&#xA;  niv add my-package -v alpha-0.1 -t http://example.com/archive/&amp;lt;version&amp;gt;.zip&#xA;&#xA;Usage: niv add PACKAGE [-n|--name NAME] &#xA;                 [(-a|--attribute KEY=VAL) | (-s|--string-attribute KEY=VAL) | &#xA;                   (-b|--branch BRANCH) | (-o|--owner OWNER) | (-r|--rev REV) | &#xA;                   (-v|--version VERSION) | (-t|--template URL) | &#xA;                   (-T|--type TYPE)]&#xA;  Add a GitHub dependency&#xA;&#xA;Available options:&#xA;  -n,--name NAME           Set the package name to &amp;lt;NAME&amp;gt;&#xA;  -a,--attribute KEY=VAL   Set the package spec attribute &amp;lt;KEY&amp;gt; to &amp;lt;VAL&amp;gt;, where&#xA;                           &amp;lt;VAL&amp;gt; may be JSON.&#xA;  -s,--string-attribute KEY=VAL&#xA;                           Set the package spec attribute &amp;lt;KEY&amp;gt; to &amp;lt;VAL&amp;gt;.&#xA;  -b,--branch BRANCH       Equivalent to --attribute branch=&amp;lt;BRANCH&amp;gt;&#xA;  -o,--owner OWNER         Equivalent to --attribute owner=&amp;lt;OWNER&amp;gt;&#xA;  -r,--rev REV             Equivalent to --attribute rev=&amp;lt;REV&amp;gt;&#xA;  -v,--version VERSION     Equivalent to --attribute version=&amp;lt;VERSION&amp;gt;&#xA;  -t,--template URL        Used during &#39;update&#39; when building URL. Occurrences&#xA;                           of &amp;lt;foo&amp;gt; are replaced with attribute &#39;foo&#39;.&#xA;  -T,--type TYPE           The type of the URL target. The value can be either&#xA;                           &#39;file&#39; or &#39;tarball&#39;. If not set, the value is&#xA;                           inferred from the suffix of the URL.&#xA;  -h,--help                Show this help text&#xA;&#xA;Experimental commands:&#xA;  git                      Add a git dependency. Experimental.&#xA;  github                   Add a GitHub dependency&#xA;  local                    Add a local dependency. Experimental.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Update&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;Examples:&#xA;  &#xA;  niv update                     # update all packages&#xA;  niv update nixpkgs             # update nixpkgs&#xA;  niv update my-package -v beta-0.2 # update my-package to version &#34;beta-0.2&#34;&#xA;&#xA;Usage: niv update [PACKAGE &#xA;                    [(-a|--attribute KEY=VAL) | &#xA;                      (-s|--string-attribute KEY=VAL) | (-b|--branch BRANCH) | &#xA;                      (-o|--owner OWNER) | (-r|--rev REV) | &#xA;                      (-v|--version VERSION) | (-t|--template URL) | &#xA;                      (-T|--type TYPE)]]&#xA;  Update dependencies&#xA;&#xA;Available options:&#xA;  -a,--attribute KEY=VAL   Set the package spec attribute &amp;lt;KEY&amp;gt; to &amp;lt;VAL&amp;gt;, where&#xA;                           &amp;lt;VAL&amp;gt; may be JSON.&#xA;  -s,--string-attribute KEY=VAL&#xA;                           Set the package spec attribute &amp;lt;KEY&amp;gt; to &amp;lt;VAL&amp;gt;.&#xA;  -b,--branch BRANCH       Equivalent to --attribute branch=&amp;lt;BRANCH&amp;gt;&#xA;  -o,--owner OWNER         Equivalent to --attribute owner=&amp;lt;OWNER&amp;gt;&#xA;  -r,--rev REV             Equivalent to --attribute rev=&amp;lt;REV&amp;gt;&#xA;  -v,--version VERSION     Equivalent to --attribute version=&amp;lt;VERSION&amp;gt;&#xA;  -t,--template URL        Used during &#39;update&#39; when building URL. Occurrences&#xA;                           of &amp;lt;foo&amp;gt; are replaced with attribute &#39;foo&#39;.&#xA;  -T,--type TYPE           The type of the URL target. The value can be either&#xA;                           &#39;file&#39; or &#39;tarball&#39;. If not set, the value is&#xA;                           inferred from the suffix of the URL.&#xA;  -h,--help                Show this help text&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Modify&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;Examples:&#xA;&#xA;  niv modify nixpkgs -v beta-0.2&#xA;  niv modify nixpkgs -a branch=nixpkgs-unstable&#xA;&#xA;Usage: niv modify PACKAGE [-n|--name NAME] &#xA;                  [(-a|--attribute KEY=VAL) | (-s|--string-attribute KEY=VAL) | &#xA;                    (-b|--branch BRANCH) | (-o|--owner OWNER) | (-r|--rev REV) |&#xA;                    (-v|--version VERSION) | (-t|--template URL) | &#xA;                    (-T|--type TYPE)]&#xA;  Modify dependency attributes without performing an update&#xA;&#xA;Available options:&#xA;  -n,--name NAME           Set the package name to &amp;lt;NAME&amp;gt;&#xA;  -a,--attribute KEY=VAL   Set the package spec attribute &amp;lt;KEY&amp;gt; to &amp;lt;VAL&amp;gt;, where&#xA;                           &amp;lt;VAL&amp;gt; may be JSON.&#xA;  -s,--string-attribute KEY=VAL&#xA;                           Set the package spec attribute &amp;lt;KEY&amp;gt; to &amp;lt;VAL&amp;gt;.&#xA;  -b,--branch BRANCH       Equivalent to --attribute branch=&amp;lt;BRANCH&amp;gt;&#xA;  -o,--owner OWNER         Equivalent to --attribute owner=&amp;lt;OWNER&amp;gt;&#xA;  -r,--rev REV             Equivalent to --attribute rev=&amp;lt;REV&amp;gt;&#xA;  -v,--version VERSION     Equivalent to --attribute version=&amp;lt;VERSION&amp;gt;&#xA;  -t,--template URL        Used during &#39;update&#39; when building URL. Occurrences&#xA;                           of &amp;lt;foo&amp;gt; are replaced with attribute &#39;foo&#39;.&#xA;  -T,--type TYPE           The type of the URL target. The value can be either&#xA;                           &#39;file&#39; or &#39;tarball&#39;. If not set, the value is&#xA;                           inferred from the suffix of the URL.&#xA;  -h,--help                Show this help text&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Drop&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;Examples:&#xA;&#xA;  niv drop jq&#xA;  niv drop my-package version&#xA;&#xA;Usage: niv drop PACKAGE [ATTRIBUTE]&#xA;  Drop dependency&#xA;&#xA;Available options:&#xA;  -h,--help                Show this help text&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Init&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: niv init [--fast | --latest | --nixpkgs OWNER/REPO&#xA;                  (-b|--nixpkgs-branch ARG) |&#xA;                  --no-nixpkgs]&#xA;  Initialize a Nix project. Existing files won&#39;t be modified.&#xA;&#xA;Available options:&#xA;  --fast                   Use the latest nixpkgs cached at&#xA;                           &#39;https://github.com/nmattia/niv/blob/master/data/nixpkgs.json&#39;.&#xA;                           This is the default.&#xA;  --latest                 Pull the latest unstable nixpkgs from NixOS/nixpkgs.&#xA;  --nixpkgs OWNER/REPO     Use a custom nixpkgs repository from GitHub.&#xA;  -b,--nixpkgs-branch ARG  The nixpkgs branch when using --nixpkgs ....&#xA;  --no-nixpkgs             Don&#39;t add a nixpkgs entry to sources.json.&#xA;  -h,--help                Show this help text&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;show&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: niv show [PACKAGE]&#xA;&#xA;Available options:&#xA;  -h,--help                Show this help text&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Frequently Asked Questions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#can-i-use-private-github-repositories&#34;&gt;Can I use private GitHub repositories?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#how-do-i-import-and-use-the-content-of-a-source&#34;&gt;How do I import and use the content of a source?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#how-do-i-import-a-subpath-of-a-source&#34;&gt;How do I import a subpath of a source?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#how-do-i-import-nixos-modules&#34;&gt;How do I import NixOS modules&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nmattia/niv/master/#can-i-use-local-packages&#34;&gt;Can I use local packages?&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Can I use private GitHub repositories?&lt;/h3&gt; &#xA;&lt;p&gt;Yes. There are two ways:&lt;/p&gt; &#xA;&lt;h4&gt;1. Use the git protocol&lt;/h4&gt; &#xA;&lt;p&gt;When using the git protocol, your public SSH keypair is used to authenticate you:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ niv add git git@github.com:my_user/my_private_repo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;2. Use the netrc file&lt;/h5&gt; &#xA;&lt;p&gt;in order to &lt;code&gt;niv add&lt;/code&gt; a private github repo you&#39;ll need to:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;create a .netrc file with the following content&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;machine github.com&#xA;  login YOUR_GITHUB_USER_NAME&#xA;  password YOUR_GITHUB_TOKEN&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;add the path to the above file to &lt;code&gt;/etc/nix/nix.conf&lt;/code&gt;:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;netrc-file = /PATH/TO/.netrc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;set &lt;code&gt;GITHUB_TOKEN&lt;/code&gt; env var when calling &lt;code&gt;niv add&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;GITHUB_TOKEN=$YOUR_GITHUB_TOKEN niv add ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How do I import and use the content of a source?&lt;/h3&gt; &#xA;&lt;p&gt;The way to import a source depend mainly on the content targetted by this source. A source could be a file, a repository with no knowledge of nix or a repository already in the nix ecosystem.&lt;/p&gt; &#xA;&lt;h4&gt;1. Direct import of a nix based source&lt;/h4&gt; &#xA;&lt;p&gt;In the case of a nix based source, you&#39;ll often find a &lt;code&gt;default.nix&lt;/code&gt; at the root. Let&#39;s take this repository as example. We can add it to our &lt;code&gt;sources.json&lt;/code&gt; with the following command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ niv add nmattia/niv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can now import niv to use it a nix expression, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{ sources ? import nix/sources.nix }:&#xA;let niv = import sources.niv {};&#xA;in { inherit niv; } # A glorious expression using the reference to niv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;2. Import of a nix based source via an overlay&lt;/h4&gt; &#xA;&lt;p&gt;Rather than use the resulting derivation directly, you can add it to your custom nixpkgs via the overlay system.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{ sources ? import nix/sources.nix}:&#xA;let overlay = _: pkgs: {&#xA;      niv = (import sources.niv {}).niv;&#xA;    };&#xA;    nixpkgs = import sources.nixpkgs { overlays = [ overlay ]; config = {}; };&#xA;in { inherit (nixpkgs) niv; } # A glorious expression where nixpkgs.niv is referenced&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;3. Reference to the source&#39;s files in the nix store&lt;/h4&gt; &#xA;&lt;p&gt;You can also reference a simple file, a folder or a repo without nix knowledge with niv. In these cases, you can use the source in your nix expression without importing it.&lt;/p&gt; &#xA;&lt;p&gt;The following exemple will compile gnu hello while using this technique to retrieve the source. First, we need to add the new source.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ niv add hello-src -v 2.10 -t &#39;https://ftp.gnu.org/gnu/hello/hello-&amp;lt;version&amp;gt;.tar.gz&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, we can use it inside a nix expression.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{ sources ? import nix/sources.nix }:&#xA;let hello_src = sources.hello-src;&#xA;    nixpkgs =  import sources.nixpkgs {};&#xA;in nixpkgs.stdenv.mkDerivation {&#xA;    pname = &#34;hello&#34;;&#xA;    version = &#34;custom&#34;;&#xA;    src = hello_src;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;&lt;/span&gt; If you have problems, consider using the outPath of the source (e.g. &lt;code&gt;sources.hello-src.outPath&lt;/code&gt;) instead of the source directly. See &lt;a href=&#34;https://github.com/nmattia/niv/issues/325&#34;&gt;this issue&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h3&gt;How do I import a subpath of a source?&lt;/h3&gt; &#xA;&lt;p&gt;In order to use the directory &lt;code&gt;dir&lt;/code&gt; of a &lt;code&gt;my-package&lt;/code&gt;, use the following pattern:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;let&#xA;  sources = import ./nix/sources.nix;&#xA;in sources.my-package + &#34;/dir&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in this example, &lt;code&gt;sources.my-package&lt;/code&gt; becomes &lt;code&gt;my-package&lt;/code&gt;&#39;s root directory, and &lt;code&gt;+ &#34;/dir&#34;&lt;/code&gt; appends the subdirectory.&lt;/p&gt; &#xA;&lt;h3&gt;How do I import NixOS modules?&lt;/h3&gt; &#xA;&lt;p&gt;After the package containing the modules has been &lt;code&gt;niv add&lt;/code&gt;ed, importing the modules is straightforward:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;let&#xA;  sources = import ./nix/sources.nix;&#xA;in {&#xA;  imports = [ (sources.package + &#34;/path/to/module&#34;) ];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Can I use local packages?&lt;/h3&gt; &#xA;&lt;p&gt;If you need to use a local path as a source -- especially convenient when modifying dependencies -- &lt;code&gt;niv&lt;/code&gt; allows you to override the &lt;code&gt;sources.json&lt;/code&gt; via environment variables. To override a source &lt;code&gt;foo&lt;/code&gt; with a local path &lt;code&gt;./bar/baz&lt;/code&gt;, set the environment variable &lt;code&gt;NIV_OVERRIDE_foo&lt;/code&gt; to &lt;code&gt;./bar/baz&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Generally, if the environment variable &lt;code&gt;NIV_OVERRIDE_&amp;lt;name&amp;gt;&lt;/code&gt; is set &lt;em&gt;and&lt;/em&gt; you have a source named &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; then &lt;code&gt;niv&lt;/code&gt; will use the value of &lt;code&gt;NIV_OVERRIDE_&amp;lt;name&amp;gt;&lt;/code&gt; as the &lt;code&gt;outPath&lt;/code&gt; of that source. All non-alphanumeric characters in the source name are escaped to the character &lt;code&gt;_&lt;/code&gt;; i.e. to override the package &lt;code&gt;my package-foo&lt;/code&gt; you need to set the environment variable &lt;code&gt;NIV_OVERRIDE_my_package_foo&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>input-output-hk/cardano-prelude</title>
    <updated>2022-07-09T01:42:35Z</updated>
    <id>tag:github.com,2022-07-09:/input-output-hk/cardano-prelude</id>
    <link href="https://github.com/input-output-hk/cardano-prelude" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A protolude-based custom prelude for the Cardano project&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>