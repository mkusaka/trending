<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-02T01:37:12Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>egison/egison</title>
    <updated>2023-05-02T01:37:12Z</updated>
    <id>tag:github.com,2023-05-02:/egison/egison</id>
    <link href="https://github.com/egison/egison" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Egison Programming Language&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Egison Programming Language&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/egison/egison&#34;&gt;&lt;img src=&#34;https://travis-ci.org/egison/egison.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Egison is a functional programming language featuring its expressive pattern-matching facility. Egison allows users to define efficient and expressive pattern-matching methods for arbitrary user-defined data types including non-free data types such as lists, multisets, sets, trees, graphs, and mathematical expressions. This is the repository of the interpreter of Egison.&lt;/p&gt; &#xA;&lt;p&gt;For more information, visit &lt;a target=&#34;_blank&#34; href=&#34;https://www.egison.org&#34;&gt;our website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Refereed Papers&lt;/h2&gt; &#xA;&lt;h3&gt;Pattern Matching&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Satoshi Egi, Yuichi Nishiwaki: &lt;a href=&#34;https://arxiv.org/abs/1808.10603&#34;&gt;Non-linear Pattern Matching with Backtracking for Non-free Data Types&lt;/a&gt; (APLAS 2018)&lt;/li&gt; &#xA; &lt;li&gt;Satoshi Egi, Yuichi Nishiwaki: &lt;a href=&#34;https://doi.org/10.22152/programming-journal.org/2020/4/7&#34;&gt;Functional Programming in Pattern-Match-Oriented Programming Style&lt;/a&gt; (&#xA;  &lt;programming&gt;&#xA;    2020)&#xA;  &lt;/programming&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Tensor Index Notation&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Satoshi Egi: &lt;a href=&#34;https://arxiv.org/abs/1702.06343&#34;&gt;Scalar and Tensor Parameters for Importing Tensor Index Notation including Einstein Summation Notation&lt;/a&gt; (Scheme Workshop 2017)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Non-Linear Pattern Matching for Non-Free Data Types&lt;/h2&gt; &#xA;&lt;p&gt;We can use non-linear pattern matching for non-free data types in Egison. A non-free data type is a data type whose data have no canonical form, or a standard way to represent that object. For example, multisets are non-free data types because a multiset {a,b,b} has two other syntastically different representations: {b,a,b} and {b,b,a}. Expressive pattern matching for these data types enables us to write elegant programs.&lt;/p&gt; &#xA;&lt;h3&gt;Twin Primes&lt;/h3&gt; &#xA;&lt;p&gt;We can use pattern matching for enumeration. The following code enumerates all twin primes from the infinite list of prime numbers with pattern matching!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;def twinPrimes :=&#xA;  matchAll primes as list integer with&#xA;  | _ ++ $p :: #(p + 2) :: _ -&amp;gt; (p, p + 2)&#xA;&#xA;take 8 twinPrimes&#xA;-- [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Poker Hands&lt;/h3&gt; &#xA;&lt;p&gt;The following code is a program that determines poker-hands written in Egison. All hands are expressed in a single pattern.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;def poker cs :=&#xA;  match cs as multiset card with&#xA;  | card $s $n :: card #s #(n-1) :: card #s #(n-2) :: card #s #(n-3) :: card #s #(n-4) :: _&#xA;    -&amp;gt; &#34;Straight flush&#34;&#xA;  | card _ $n :: card _ #n :: card _ #n :: card _ #n :: _ :: []&#xA;    -&amp;gt; &#34;Four of a kind&#34;&#xA;  | card _ $m :: card _ #m :: card _ #m :: card _ $n :: card _ #n :: []&#xA;    -&amp;gt; &#34;Full house&#34;&#xA;  | card $s _ :: card #s _ :: card #s _ :: card #s _ :: card #s _ :: []&#xA;    -&amp;gt; &#34;Flush&#34;&#xA;  | card _ $n :: card _ #(n-1) :: card _ #(n-2) :: card _ #(n-3) :: card _ #(n-4) :: []&#xA;    -&amp;gt; &#34;Straight&#34;&#xA;  | card _ $n :: card _ #n :: card _ #n :: _ :: _ :: []&#xA;    -&amp;gt; &#34;Three of a kind&#34;&#xA;  | card _ $m :: card _ #m :: card _ $n :: card _ #n :: _ :: []&#xA;    -&amp;gt; &#34;Two pair&#34;&#xA;  | card _ $n :: card _ #n :: _ :: _ :: _ :: []&#xA;    -&amp;gt; &#34;One pair&#34;&#xA;  | _ :: _ :: _ :: _ :: _ :: [] -&amp;gt; &#34;Nothing&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Graphs&lt;/h3&gt; &#xA;&lt;p&gt;We can pattern-match against graphs. We can write a program to solve the travelling salesman problem in a single pattern-matching expression.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;def graph := multiset (string, multiset (string, integer))&#xA;&#xA;def graphData :=&#xA;  [(&#34;Berlin&#34;, [(&#34;New York&#34;, 14), (&#34;London&#34;, 2), (&#34;Tokyo&#34;, 14), (&#34;Vancouver&#34;, 13)]),&#xA;   (&#34;New York&#34;, [(&#34;Berlin&#34;, 14), (&#34;London&#34;, 12), (&#34;Tokyo&#34;, 18), (&#34;Vancouver&#34;, 6)]),&#xA;   (&#34;London&#34;, [(&#34;Berlin&#34;, 2), (&#34;New York&#34;, 12), (&#34;Tokyo&#34;, 15), (&#34;Vancouver&#34;, 10)]),&#xA;   (&#34;Tokyo&#34;, [(&#34;Berlin&#34;, 14), (&#34;New York&#34;, 18), (&#34;London&#34;, 15), (&#34;Vancouver&#34;, 12)]),&#xA;   (&#34;Vancouver&#34;, [(&#34;Berlin&#34;, 13), (&#34;New York&#34;, 6), (&#34;London&#34;, 10), (&#34;Tokyo&#34;, 12)])]&#xA;&#xA;def trips :=&#xA;  let n := length graphData in&#xA;    matchAll graphData as graph with&#xA;    | (#&#34;Berlin&#34;, (($s_1,$p_1) : _)) ::&#xA;        loop $i (2, n - 1)&#xA;          ((#s_(i - 1), ($s_i, $p_i) :: _) :: ...)&#xA;          ((#s_(n - 1), (#&#34;Berlin&#34; &amp;amp; $s_n, $p_n) :: _) :: [])&#xA;    -&amp;gt; sum (map (\i -&amp;gt; p_i) [1..n]), map (\i -&amp;gt; s_i) [1..n]&#xA;&#xA;car (sortBy (\(_, x), (_, y) -&amp;gt; compare x y)) trips)&#xA;-- ([&#34;London&#34;, &#34;New York&#34;, &#34;Vancouver&#34;, &#34;Tokyo&#34;,&#34; Berlin&#34;], 46)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Egison as a Computer Algebra System&lt;/h2&gt; &#xA;&lt;p&gt;As an application of Egison pattern matching, we have implemented a computer algebra system on Egison. The most part of this computer algebra system is written in Egison and extensible using Egison.&lt;/p&gt; &#xA;&lt;h3&gt;Symbolic Algebra&lt;/h3&gt; &#xA;&lt;p&gt;Egison treats unbound variables as symbols.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; x&#xA;x&#xA;&amp;gt; (x + y)^2&#xA;x^2 + 2 * x * y + y^2&#xA;&amp;gt; (x + y)^4&#xA;x^4 + 4 * x^3 * y + 6 * x^2 * y^2 + 4 * x * y^3 + y^4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can handle algebraic numbers, too.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/egison/egison/raw/master/lib/math/algebra/root.egi&#34;&gt;Definition of &lt;code&gt;sqrt&lt;/code&gt; in &lt;code&gt;root.egi&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; sqrt x&#xA;sqrt x&#xA;&amp;gt; sqrt 2&#xA;sqrt 2&#xA;&amp;gt; x + sqrt y&#xA;x + sqrt y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Complex Numbers&lt;/h3&gt; &#xA;&lt;p&gt;The symbol &lt;code&gt;i&lt;/code&gt; is defined to rewrite &lt;code&gt;i^2&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt; in Egison library.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/egison/egison/raw/master/lib/math/normalize.egi&#34;&gt;Rewriting rule for &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;normalize.egi&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; i * i&#xA;-1&#xA;&amp;gt; (1 + i) * (1 + i)&#xA;2 * i&#xA;&amp;gt; (x + y * i) * (x + y * i)&#xA;x^2 + 2 * x * y * i - y^2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Square Root&lt;/h3&gt; &#xA;&lt;p&gt;The rewriting rule for &lt;code&gt;sqrt&lt;/code&gt; is also defined in Egison library.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/egison/egison/raw/master/lib/math/normalize.egi&#34;&gt;Rewriting rule for &lt;code&gt;sqrt&lt;/code&gt; in &lt;code&gt;normalize.egi&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; sqrt 2 * sqrt 2&#xA;2&#xA;&amp;gt; sqrt 6 * sqrt 10&#xA;2 * sqrt 15&#xA;&amp;gt; sqrt (x * y) * sqrt (2 * x)&#xA;x * sqrt 2 * sqrt y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;The 5th Roots of Unity&lt;/h3&gt; &#xA;&lt;p&gt;The following is a sample to calculate the 5th roots of unity.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/egison/egison/raw/master/lib/math/algebra/equations.egi&#34;&gt;Definition of &lt;code&gt;q-f&#39;&lt;/code&gt; in &lt;code&gt;equations.egi&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; qF&#39; 1 1 (-1)&#xA;((-1 + sqrt 5) / 2, (-1 - sqrt 5) / 2)&#xA;&amp;gt; def t := fst (qF&#39; 1 1 (-1))&#xA;&amp;gt; qF&#39; 1 (-t) 1&#xA;((-1 + sqrt 5 + sqrt 2 * sqrt (-5 - sqrt 5)) / 4, (-1 + sqrt 5 - sqrt 2 * sqrt (-5 - sqrt 5)) / 4)&#xA;&amp;gt; def z := fst (qF&#39; 1 (-t) 1)&#xA;&amp;gt; z&#xA;(-1 + sqrt 5 + sqrt 2 * sqrt (-5 - sqrt 5)) / 4&#xA;&amp;gt; z ^ 5&#xA;1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Differentiation&lt;/h3&gt; &#xA;&lt;p&gt;We can implement differentiation easily in Egison.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/egison/egison/raw/master/lib/math/analysis/derivative.egi&#34;&gt;Definition of &lt;code&gt;d/d&lt;/code&gt; in &lt;code&gt;derivative.egi&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; d/d (x ^ 3) x&#xA;3 * x^2&#xA;&amp;gt; d/d (e ^ (i * x)) x&#xA;exp (x * i) * i&#xA;&amp;gt; d/d (d/d (log x) x) x&#xA;-1 / x^2&#xA;&amp;gt; d/d (cos x * sin x) x&#xA;-2 * (sin x)^2 + 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Taylor Expansion&lt;/h3&gt; &#xA;&lt;p&gt;The following sample executes Taylor expansion on Egison. We verify &lt;a href=&#34;https://en.wikipedia.org/wiki/Euler%27s_formula&#34;&gt;Euler&#39;s formula&lt;/a&gt; in the following sample.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/egison/egison/raw/master/lib/math/analysis/derivative.egi&#34;&gt;Definition of &lt;code&gt;taylor-expansion&lt;/code&gt; in &lt;code&gt;derivative.egi&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; take 8 (taylorExpansion (exp (i * x)) x 0)&#xA;[1, x * i, - x^2 / 2, - x^3 * i / 6, x^4 / 24, x^5 * i / 120, - x^6 / 720, - x^7 * i / 5040]&#xA;&amp;gt; take 8 (taylorExpansion (cos x) x 0)&#xA;[1, 0, - x^2 / 2, 0, x^4 / 24, 0, - x^6 / 720, 0]&#xA;&amp;gt; take 8 (taylorExpansion (i * sin x) x 0)&#xA;[0, x * i, 0, - x^3 * i / 6, 0, x^5 * i / 120, 0, - x^7 * i / 5040]&#xA;&amp;gt; take 8 (map2 (+) (taylorExpansion (cos x) x 0) (taylorExpansion (i * sin x) x 0))&#xA;[1, x * i, - x^2 / 2, - x^3 * i / 6, x^4 / 24, x^5 * i / 120, - x^6 / 720, - x^7 * i / 5040]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tensor Index Notation&lt;/h3&gt; &#xA;&lt;p&gt;Egison supports tesnsor index notation. We can use &lt;a href=&#34;https://en.wikipedia.org/wiki/Einstein_notation&#34;&gt;Einstein notation&lt;/a&gt; to express arithmetic operations between tensors.&lt;/p&gt; &#xA;&lt;p&gt;The method for importing tensor index notation into programming is discussed in &lt;a href=&#34;https://arxiv.org/abs/1702.06343&#34;&gt;Egison tensor paper&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The following sample is from &lt;a href=&#34;https://www.egison.org/math/riemann-curvature-tensor-of-S2.html&#34;&gt;Riemann Curvature Tensor of S2 - Egison Mathematics Notebook&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;-- Parameters&#xA;def x := [| θ, φ |]&#xA;&#xA;def X := [| r * (sin θ) * (cos φ) -- x&#xA;      , r * (sin θ) * (sin φ) -- y&#xA;      , r * (cos θ)           -- z&#xA;      |]&#xA;&#xA;def e_i_j := (∂/∂ X_j x~i)&#xA;&#xA;-- Metric tensors&#xA;def g_i_j := generateTensor (\x y -&amp;gt; V.* e_x_# e_y_#) [2, 2]&#xA;def g~i~j := M.inverse g_#_#&#xA;&#xA;g_#_# -- [| [| r^2, 0 |], [| 0, r^2 * (sin θ)^2 |] |]_#_#&#xA;g~#~# -- [| [| 1 / r^2, 0 |], [| 0, 1 / (r^2 * (sin θ)^2) |] |]~#~#&#xA;&#xA;-- Christoffel symbols&#xA;def Γ_i_j_k := (1 / 2) * (∂/∂ g_i_k x~j + ∂/∂ g_i_j x~k - ∂/∂ g_j_k x~i)&#xA;&#xA;Γ_1_#_# -- [| [| 0, 0 |], [| 0, -1 * r^2 * (sin θ) * (cos θ) |] |]_#_#&#xA;Γ_2_#_# -- [| [| 0, r^2 * (sin θ) * (cos θ) |], [| r^2 * (sin θ) * (cos θ), 0 |] |]_#_#&#xA;&#xA;def Γ~i_j_k := withSymbols [m]&#xA;  g~i~m . Γ_m_j_k&#xA;&#xA;Γ~1_#_# -- [| [| 0, 0 |], [| 0, -1 * (sin θ) * (cos θ) |] |]_#_#&#xA;Γ~2_#_# -- [| [| 0, (cos θ) / (sin θ) |], [| (cos θ) / (sin θ), 0 |] |]_#_#&#xA;&#xA;-- Riemann curvature&#xA;def R~i_j_k_l := withSymbols [m]&#xA;  ∂/∂ Γ~i_j_l x~k - ∂/∂ Γ~i_j_k x~l + Γ~m_j_l . Γ~i_m_k - Γ~m_j_k . Γ~i_m_l&#xA;&#xA;R~#_#_1_1 -- [| [| 0, 0 |], [| 0, 0 |] |]~#_#&#xA;R~#_#_1_2 -- [| [| 0, (sin θ)^2 |], [| -1, 0 |] |]~#_#&#xA;R~#_#_2_1 -- [| [| 0, -1 * (sin θ)^2 |], [| 1, 0 |] |]~#_#&#xA;R~#_#_2_2 -- [| [| 0, 0 |], [| 0, 0 |] |]~#_#&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Differential Forms&lt;/h3&gt; &#xA;&lt;p&gt;By designing the index completion rules for omitted indices, we can use the above notation to express a calculation handling the differential forms.&lt;/p&gt; &#xA;&lt;p&gt;The following sample is from &lt;a href=&#34;https://www.egison.org/math/curvature-form.html&#34;&gt;Curvature Form - Egison Mathematics Notebook&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;-- Parameters and metric tensor&#xA;def x := [| θ, φ |]&#xA;&#xA;def g_i_j := [| [| r^2, 0 |], [| 0, r^2 * (sin θ)^2 |] |]_i_j&#xA;def g~i~j := [| [| 1 / r^2, 0 |], [| 0, 1 / (r^2 * (sin θ)^2) |] |]~i~j&#xA;&#xA;-- Christoffel symbols&#xA;def Γ_j_l_k := (1 / 2) * (∂/∂ g_j_l x~k + ∂/∂ g_j_k x~l - ∂/∂ g_k_l x~j)&#xA;&#xA;def Γ~i_k_l := withSymbols [j] g~i~j . Γ_j_l_k&#xA;&#xA;-- Exterior derivative&#xA;def d %t := !(flip ∂/∂) x t&#xA;&#xA;-- Wedge product&#xA;infixl expression 7 ∧&#xA;&#xA;def (∧) %x %y := x !. y&#xA;&#xA;-- Connection form&#xA;def ω~i_j := Γ~i_j_#&#xA;&#xA;-- Curvature form&#xA;def Ω~i_j := withSymbols [k]&#xA;  antisymmetrize (d ω~i_j + ω~i_k ∧ ω~k_j)&#xA;&#xA;Ω~#_#_1_1 -- [| [| 0, 0 |], [| 0, 0 |] |]~#_#&#xA;Ω~#_#_1_2 -- [| [| 0, (sin θ)^2  / 2|], [| -1 / 2, 0 |] |]~#_#&#xA;Ω~#_#_2_1 -- [| [| 0, -1 * (sin θ)^2 / 2 |], [| 1 / 2, 0 |] |]~#_#&#xA;Ω~#_#_2_2 -- [| [| 0, 0 |], [| 0, 0 |] |]~#_#&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Egison Mathematics Notebook&lt;/h3&gt; &#xA;&lt;p&gt;Here are more samples.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.egison.org/math/&#34;&gt;Egison Mathematics Notebook&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Comparison with Related Work&lt;/h2&gt; &#xA;&lt;p&gt;There are &lt;a target=&#34;_blank&#34; href=&#34;https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns#Relatedwork&#34;&gt;a lot of existing work&lt;/a&gt; for pattern matching.&lt;/p&gt; &#xA;&lt;p&gt;The advantage of Egison is that it fulfills the following two requirements at the same time.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Efficient backtracking algorithm for non-linear pattern matching.&lt;/li&gt; &#xA; &lt;li&gt;Extensibility of patterns.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Additionally, it fulfills the following requirements.&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Polymorphism of patterns.&lt;/li&gt; &#xA; &lt;li&gt;Pattern matching with infinitely many results.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Check out &lt;a target=&#34;_blank&#34; href=&#34;https://arxiv.org/abs/1808.10603&#34;&gt;our paper&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://egison.readthedocs.io/en/latest/reference/install.html&#34;&gt;Installation guide&lt;/a&gt; is available on our website.&lt;/p&gt; &#xA;&lt;p&gt;If you are a beginner of Egison, it would be better to install &lt;a target=&#34;_blank&#34; href=&#34;https://github.com/egison/egison-tutorial&#34;&gt;&lt;code&gt;egison-tutorial&lt;/code&gt;&lt;/a&gt; as well.&lt;/p&gt; &#xA;&lt;p&gt;We also have &lt;a href=&#34;http://console.egison.org&#34;&gt;online interpreter&lt;/a&gt; and &lt;a href=&#34;http://try.egison.org/&#34;&gt;online tutorial&lt;/a&gt;. Enjoy!&lt;/p&gt; &#xA;&lt;h2&gt;Notes for Developers&lt;/h2&gt; &#xA;&lt;p&gt;You can build Egison as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ stack init&#xA;$ stack build --fast&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For testing, see &lt;a href=&#34;https://raw.githubusercontent.com/egison/egison/master/test/README.md&#34;&gt;test/README.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;We have &lt;a target=&#34;_blank&#34; href=&#34;https://www.egison.org/community.html&#34;&gt;a mailing list&lt;/a&gt;. Please join us!&lt;/p&gt; &#xA;&lt;p&gt;We are on &lt;a target=&#34;_blank&#34; href=&#34;https://twitter.com/Egison_Lang&#34;&gt;Twitter&lt;/a&gt;. Please follow us.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Egison is released under the &lt;a href=&#34;https://github.com/egison/egison/raw/master/LICENSE&#34;&gt;MIT license&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We used &lt;a href=&#34;http://justinethier.github.io/husk-scheme/&#34;&gt;husk-scheme&lt;/a&gt; by Justin Ethier as reference to implement the base part of the previous version of the interpreter.&lt;/p&gt; &#xA;&lt;h2&gt;Sponsors&lt;/h2&gt; &#xA;&lt;p&gt;Egison is sponsored by &lt;a href=&#34;http://global.rakuten.com/corp/&#34;&gt;Rakuten, Inc.&lt;/a&gt; and &lt;a href=&#34;http://rit.rakuten.co.jp/&#34;&gt;Rakuten Institute of Technology&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>vehicle-lang/vehicle</title>
    <updated>2023-05-02T01:37:12Z</updated>
    <id>tag:github.com,2023-05-02:/vehicle-lang/vehicle</id>
    <link href="https://github.com/vehicle-lang/vehicle" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A toolkit for enforcing logical specifications on neural networks&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/vehicle-lang/vehicle/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/vehicle-lang/vehicle/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;ci&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://vehicle-lang.readthedocs.io/en/latest/&#34;&gt;&lt;img src=&#34;https://readthedocs.org/projects/vehicle-lang/badge/?version=latest&#34; alt=&#34;readthedocs status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://results.pre-commit.ci/latest/github/vehicle-lang/vehicle/dev&#34;&gt;&lt;img src=&#34;https://results.pre-commit.ci/badge/github/vehicle-lang/vehicle/dev.svg?sanitize=true&#34; alt=&#34;pre-commit.ci status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Vehicle&lt;/h1&gt; &#xA;&lt;p&gt;Vehicle is a system for embedding logical specifications into neural networks. At its heart is the Vehicle specification language, a high-level, functional language for writing mathematically-precise specifications for your networks. For example, the following simple specification says that a network&#39;s output should be monotonically increasing with respect to its third input.&lt;/p&gt; &#xA;&lt;!-- This must be a direct link, because the same README is used on PyPI --&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/vehicle-lang/vehicle/raw/4d985c962eab317fd00fbf07da5846374e6b0b35/docs-source/example-spec.png&#34; alt=&#34;Example specification&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;These specifications can then automatically be compiled down to loss functions to be used when training your network. After training, the same specification can be compiled down to low-level neural network verifiers such as Marabou which either prove that the specification holds or produce a counter-example. Such a proof is far better than simply testing, as you can prove that the specification holds for &lt;em&gt;all&lt;/em&gt; inputs. Verified specifications can also be exported to interactive theorem provers (ITPs) such as Agda. This in turn allows for the formal verification of larger software systems that use neural networks as subcomponents. The generated ITP code is tightly linked to the actual deployed network, so changes to the network will result in errors when checking the larger proof.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Vehicle is a work in progress. No stable version is yet available and breaking changes will occur frequently so use at your own risk. While verification mode and exporting to ITPs is functional, training mode is still under active development.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://vehicle-lang.readthedocs.io/en/latest/&#34;&gt;User manual&lt;/a&gt; - currently a work in progress.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.macs.hw.ac.uk/~ek19/vehicle.pdf&#34;&gt;Workshop paper (FOMLAS&#39;22) motivating the Vehicle design&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://laiv.uk/wp-content/uploads/2022/12/vehicle.pdf&#34;&gt;Vehicle&#39;s Type Checker (in CPP&#39;23)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Each of the following examples comes with an explanatory README file:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/vehicle-lang/vehicle/raw/dev/examples/acasXu/&#34;&gt;ACAS Xu&lt;/a&gt; - The complete specification of the ACAS Xu collision avoidance system from the &lt;a href=&#34;https://arxiv.org/abs/1702.01135&#34;&gt;Reluplex paper&lt;/a&gt; in a single file.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/vehicle-lang/vehicle/raw/dev/examples/windController/&#34;&gt;Car controller&lt;/a&gt; - A neural network controller that is formally proven to always keep a simple model of a car on the road in the face of noisy sensor data and an unpredictable cross-wind.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/vehicle-lang/vehicle/raw/dev/examples/mnist-robustness/&#34;&gt;MNIST robustness&lt;/a&gt; - A classifier for the MNIST dataset that is proven to be robust around the images in the dataset.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition to the above, further examples of specifications can be found in the &lt;a href=&#34;https://github.com/vehicle-lang/vehicle/tree/dev/test/specs&#34;&gt;test suite&lt;/a&gt; and the corresponding output of the Vehicle compiler can be found &lt;a href=&#34;https://github.com/vehicle-lang/vehicle/tree/dev/test/Test/Compile/Golden&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;If you are interested in adding support for a particular format/verifier/ITP then open an issue on the &lt;a href=&#34;https://github.com/wenkokke/vehicle/issues&#34;&gt;Issue Tracker&lt;/a&gt; to discuss it with us.&lt;/p&gt; &#xA;&lt;h4&gt;Neural network formats&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://onnx.ai/&#34;&gt;ONNX&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Dataset formats&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://yann.lecun.com/exdb/mnist/&#34;&gt;IDX&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Verifier backends&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/NeuralNetworkVerification/Marabou&#34;&gt;Marabou&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Interactive Theorem Prover backends&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://agda.readthedocs.io/&#34;&gt;Agda&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>nstott/GradeLevel</title>
    <updated>2023-05-02T01:37:12Z</updated>
    <id>tag:github.com,2023-05-02:/nstott/GradeLevel</id>
    <link href="https://github.com/nstott/GradeLevel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;haskell syllable counter&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Measure the grade level of text through the Coleman-Liau index, and the Flesch-Kincaid algorithms&lt;/p&gt; &#xA;&lt;p&gt;see&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Coleman-Liau_Index&#34;&gt;http://en.wikipedia.org/wiki/Coleman-Liau_Index&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Flesch%E2%80%93Kincaid_readability_test&#34;&gt;http://en.wikipedia.org/wiki/Flesch%E2%80%93Kincaid_readability_test&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;functions are exported from NLP.ReadingLevel,&lt;/p&gt; &#xA;&lt;p&gt;fleschReadingEase :: String -&amp;gt; Float&lt;/p&gt; &#xA;&lt;p&gt;fleschKincaidGradeLevel :: String -&amp;gt; Float&lt;/p&gt; &#xA;&lt;p&gt;colemanLiauIndex :: String -&amp;gt; Float&lt;/p&gt; &#xA;&lt;p&gt;there are also convenience functions totalWords, totalSentences there.&lt;/p&gt; &#xA;&lt;p&gt;NLP.Syllables just tries to count the number of syllables in a word, which is more complicated thenit should be&lt;/p&gt; &#xA;&lt;p&gt;only thought about using this for english, not sure on the linguistic rules of other languages, there will be nuances there I haven&#39;t adressed here&lt;/p&gt;</summary>
  </entry>
</feed>