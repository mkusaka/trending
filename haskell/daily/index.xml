<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-08T01:37:08Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cachix/stamina.hs</title>
    <updated>2023-07-08T01:37:08Z</updated>
    <id>tag:github.com,2023-07-08:/cachix/stamina.hs</id>
    <link href="https://github.com/cachix/stamina.hs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Retrying for humans using Haskell.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Stamina&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.repostatus.org/#concept&#34;&gt;&lt;img src=&#34;https://www.repostatus.org/badges/latest/concept.svg?sanitize=true&#34; alt=&#34;Project Status: Concept â€“ Minimal or no implementation has been done yet, or the repository is only intended to be a limited example, demo, or proof-of-concept.&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/stamina&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/stamina.svg?style=flat&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/cachix/stamina.hs/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI status&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A retry Haskell library for humans:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Exponential backoff&lt;/strong&gt; with &lt;strong&gt;jitter&lt;/strong&gt; between retries.&lt;/li&gt; &#xA; &lt;li&gt;Limit the &lt;strong&gt;attempts&lt;/strong&gt; of retries and &lt;strong&gt;total&lt;/strong&gt; time.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Stamina.HTTP&lt;/code&gt; for retrying retriable &lt;code&gt;Network.HTTP.Client&lt;/code&gt; exceptions.&lt;/li&gt; &#xA; &lt;li&gt;Introspectable retry state for logging using &lt;code&gt;RetryStatus&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Control.Exception (Exception, Handler)&#xA;import Control.Monad.IO.Class (MonadIO)&#xA;import Data.Time.Clock (DiffTime)&#xA;&#xA;defaults :: RetrySettings&#xA;&#xA;data RetryStatus = RetryStatus&#xA;  { attempts :: Int,&#xA;    delay :: DiffTime,&#xA;    totalDelay :: DiffTime&#xA;  }&#xA;&#xA;-- Retry on all sync exceptions&#xA;retry :: MonadIO m &#xA;      =&amp;gt; RetrySettings &#xA;      -&amp;gt; (RetryStatus -&amp;gt; m a)&#xA;      -&amp;gt; m a&#xA;&#xA;-- Retry on specific exceptions&#xA;retryOnExceptions :: (Exception e, MonadIO m) &#xA;                  =&amp;gt; RetrySettings &#xA;                  -&amp;gt; [Handler RetryAction] &#xA;                  -&amp;gt; (RetryStatus -&amp;gt; m a)&#xA;                  -&amp;gt; m a&#xA;&#xA;data RetryAction = Skip | Retry | RetryAfter Int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&#xA;import qualified Stamina&#xA;&#xA;main :: IO ()&#xA;main = do&#xA;    Stamina.retry Stamina.defaults $ \retryStatus -&amp;gt; do&#xA;        ... monadic logic that raises exceptions&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install &lt;a href=&#34;https://devenv.sh/getting-started/&#34;&gt;devenv.sh&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;devenv shell&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;stack build&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Heavily inspired by &lt;a href=&#34;https://stamina.hynek.me/en/stable/tutorial.html#retries&#34;&gt;stamina for Python&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Soostone/retry&#34;&gt;retry&lt;/a&gt; as case study for what needs to be supported.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>dwhitney/esl</title>
    <updated>2023-07-08T01:37:08Z</updated>
    <id>tag:github.com,2023-07-08:/dwhitney/esl</id>
    <link href="https://github.com/dwhitney/esl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Elements of Statistical Learning in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. Linear Methods for Regression&lt;/h2&gt; &#xA;&lt;h3&gt;3.2 Linear Regression Models and Least Squares&lt;/h3&gt;</summary>
  </entry>
  <entry>
    <title>Blaisorblade/Haskell-Adaptive</title>
    <updated>2023-07-08T01:37:08Z</updated>
    <id>tag:github.com,2023-07-08:/Blaisorblade/Haskell-Adaptive</id>
    <link href="https://github.com/Blaisorblade/Haskell-Adaptive" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell library for incremental computing. Fork of http://hackage.haskell.org/package/Adaptive-0.22&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Adaptive version 0.23 2013-01-26&lt;/h1&gt; &#xA;&lt;p&gt;This is a minor update to Adaptive version 0.22 to make it work with recent versions of GHC. Any problems with the result is my fault.&lt;/p&gt; &#xA;&lt;p&gt;Paolo G. Giarrusso, &lt;a href=&#34;mailto:p.giarrusso@gmail.com&#34;&gt;p.giarrusso@gmail.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Adaptive version 0.22 2008-07-14&lt;/h1&gt; &#xA;&lt;p&gt;This is a minor update to Adaptive version 0.21 to make it work with recent versions of GHC and Hugs. Adaptive is now cabalized, and any problems with the packaging is my fault, not Magnus.&lt;/p&gt; &#xA;&lt;p&gt;Peter A. Jonsson, &lt;a href=&#34;mailto:pj@csee.ltu.se&#34;&gt;pj@csee.ltu.se&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Adaptive version 0.21 2005-07-09&lt;/h1&gt; &#xA;&lt;p&gt;This is a Haskell (plus some extensions) implementation of a library for incremental computing. It closely follows the implementation in the nice POPL 2002 paper &#34;Adaptive Functional Programming&#34;, by Umut Acar, Guy Blelloch and Bob Harper. As of writing, their paper can be found at&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  http://ttic.uchicago.edu/~umut/papers/popl02.html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, this Haskell library provides a monadic interface, which doesn&#39;t need the &#34;write&#34; operation or the &#34;destination&#34; type. In addition, the monadic types enforce correct usage, which means that a modifiable variable must be defined before it can be used. This is achieved within Haskell&#39;s type system plus some popular extensions (multi-parameter classes and functional dependencies).&lt;/p&gt; &#xA;&lt;p&gt;The library is parameterised over any monad that has references (such as IO and ST). This means that it should be possible to put it on top of e.g. many GUI monads too.&lt;/p&gt; &#xA;&lt;p&gt;There is a small demo program of a classical incremental computation problem: a spreadsheet. Try it by typing&lt;/p&gt; &#xA;&lt;p&gt;runhugs -98 spreadsheet.hs&lt;/p&gt; &#xA;&lt;p&gt;and type, say&lt;/p&gt; &#xA;&lt;p&gt;c0 &#xA; &lt;return&gt;&#xA;   Cell c1 &#xA;  &lt;return&gt;&#xA;    c1 &#xA;   &lt;return&gt;&#xA;     Const 42 &#xA;    &lt;return&gt;&#xA;     .&#xA;    &lt;/return&gt;&#xA;   &lt;/return&gt;&#xA;  &lt;/return&gt;&#xA; &lt;/return&gt;&lt;/p&gt; &#xA;&lt;p&gt;This has been tested with the Hugs September 2006 version.&lt;/p&gt; &#xA;&lt;p&gt;Feedback is welcome!&lt;/p&gt; &#xA;&lt;p&gt;Magnus Carlsson, &lt;a href=&#34;mailto:magnus@galois.com&#34;&gt;magnus@galois.com&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>