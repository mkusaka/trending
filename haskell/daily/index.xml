<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-23T01:33:42Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>norm2782/shake-bin</title>
    <updated>2022-09-23T01:33:42Z</updated>
    <id>tag:github.com,2022-09-23:/norm2782/shake-bin</id>
    <link href="https://github.com/norm2782/shake-bin" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Shake-bin: Shake a la Make!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>BurntSushi/erd</title>
    <updated>2022-09-23T01:33:42Z</updated>
    <id>tag:github.com,2022-09-23:/BurntSushi/erd</id>
    <link href="https://github.com/BurntSushi/erd" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Translates a plain text description of a relational database schema to a graphical entity-relationship diagram.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/BurntSushi/erd&#34;&gt;&lt;img src=&#34;https://travis-ci.org/BurntSushi/erd.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/hackage/v/erd.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This utility takes a plain text description of entities, their attributes and the relationships between entities and produces a visual diagram modeling the description. The visualization is produced by using Dot with GraphViz. There are limited options for specifying color and font information. Also, &lt;code&gt;erd&lt;/code&gt; can output graphs in a variety of formats, including but not limited to: pdf, svg, eps, png, jpg, plain text and dot.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example of the output produced by &lt;code&gt;erd&lt;/code&gt; (click on it for a larger PNG version):&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BurntSushi/erd/master/examples/nfldb.png&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BurntSushi/erd/master/examples/nfldb.png&#34; alt=&#34;ER diagram for nfldb&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/BurntSushi/erd/raw/master/examples/nfldb.er&#34;&gt;corresponding &lt;code&gt;er&lt;/code&gt; file is in the &lt;code&gt;examples&lt;/code&gt; directory&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;erd&lt;/code&gt; requires &lt;a href=&#34;http://www.graphviz.org/download/&#34;&gt;GraphViz&lt;/a&gt;, and one of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://docs.haskellstack.org/en/stable/README/&#34;&gt;Stack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.haskell.org/platform/&#34;&gt;Haskell Platform&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All of these are available for Windows, Mac and Linux.&lt;/p&gt; &#xA;&lt;h4&gt;MacPorts&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;erd&lt;/code&gt; is available in MacPorts as a one-shot install (GraphViz will be set up correctly for you):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;port install erd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Docker&lt;/h4&gt; &#xA;&lt;p&gt;An example command to use &lt;em&gt;erd&lt;/em&gt; in a &lt;em&gt;docker&lt;/em&gt; container, once this repository is successfully cloned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;erdtag=&#34;0.2.1.0&#34;; cd erd &amp;amp;&amp;amp; docker build -t erd:$erdtag . &amp;amp;&amp;amp; docker run -it erd:$erdtag &#34;--help&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;you shall specify your &lt;em&gt;erdtag&lt;/em&gt;, that will help identifying the docker image to be created;&lt;/li&gt; &#xA; &lt;li&gt;instead of using &lt;code&gt;--help&lt;/code&gt; invoke &lt;em&gt;erd&lt;/em&gt; the way you need to i.e.: &lt;pre&gt;&lt;code&gt;docker run -i erd:$erdtag &#34;--dot-entity&#34; &amp;lt; examples/nfldb.er &amp;gt; out.pdf&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Stack&lt;/h4&gt; &#xA;&lt;p&gt;Install the &lt;a href=&#34;http://docs.haskellstack.org/en/stable/README/&#34;&gt;Stack&lt;/a&gt; build tool, and build from source:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone git://github.com/BurntSushi/erd&#xA;cd erd&#xA;stack install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;stack install&lt;/code&gt; will put the binary into Stack&#39;s standard binary installation path. Unless you&#39;ve overridden it, that&#39;s &lt;code&gt;~/.local/bin&lt;/code&gt; on Unix and OS X, &lt;code&gt;%APPDATA%\local\bin&lt;/code&gt; on Windows.&lt;/p&gt; &#xA;&lt;h4&gt;Haskell Platform&lt;/h4&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;NB OSX users&lt;/em&gt;: for text formatting of keys (bold and italics) you may need to reinstall &lt;code&gt;graphviz&lt;/code&gt; with &lt;code&gt;pango&lt;/code&gt; support:&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code&gt;# OSX only&#xA;brew install graphviz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitlab.com/graphviz/graphviz/issues/1636&#34;&gt;The issue 1636&lt;/a&gt; explains what needs to be performed in details to find out whether &lt;em&gt;pango&lt;/em&gt; support is enabled and how to make it happen in case it wasn&#39;t.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://hackage.haskell.org/package/erd&#34;&gt;erd is on hackage&lt;/a&gt;, so you can install it with cabal (which is included with the Haskell platform):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal new-install erd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can clone this repository and build from source:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone git://github.com/BurntSushi/erd&#xA;cd erd&#xA;cabal new-configure&#xA;cabal new-build&#xA;# binary is now under ./dist-newstyle/build/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Usage information is available with &lt;code&gt;erd --help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Building statically linked executable&lt;/h3&gt; &#xA;&lt;p&gt;In case one wishes to have a statically linked &lt;code&gt;erd&lt;/code&gt; as a result, this is possible to have by executing &lt;code&gt;build-static_by-nix.sh&lt;/code&gt;: which requires the &lt;a href=&#34;https://nixos.org/nix/&#34;&gt;nix&lt;/a&gt; package manager to be installed on the building machine. NixOS itself is not a requirement.&lt;/p&gt; &#xA;&lt;h3&gt;Quick example&lt;/h3&gt; &#xA;&lt;p&gt;Before describing the ER file, let&#39;s try making an ER diagram from a small example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl &#39;https://raw.githubusercontent.com/BurntSushi/erd/master/examples/simple.er&#39; &amp;gt; simple.er&#xA;$ cat simple.er&#xA;# Entities are declared in &#39;[&#39; ... &#39;]&#39;. All attributes after the entity header&#xA;# up until the end of the file (or the next entity declaration) correspond&#xA;# to this entity.&#xA;[Person]&#xA;*name&#xA;height&#xA;weight&#xA;`birth date`&#xA;+birth_place_id&#xA;&#xA;[`Birth Place`]&#xA;*id&#xA;`birth city`&#xA;&#39;birth state&#39;&#xA;&#34;birth country&#34;&#xA;&#xA;# Each relationship must be between exactly two entities, which need not&#xA;# be distinct. Each entity in the relationship has exactly one of four&#xA;# possible cardinalities:&#xA;#&#xA;# Cardinality    Syntax&#xA;# 0 or 1         ?&#xA;# exactly 1      1&#xA;# 0 or more      *&#xA;# 1 or more      +&#xA;Person *--1 `Birth Place`&#xA;$ erd -i simple.er -o simple.pdf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The PDF should now contain a graph that looks like this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BurntSushi/erd/master/examples/simple.png&#34; alt=&#34;Simple erd example graph&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Available command-line options&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Short&lt;/th&gt; &#xA;   &lt;th&gt;Long&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-c[FILE]&lt;/td&gt; &#xA;   &lt;td&gt;--config[=FILE]&lt;/td&gt; &#xA;   &lt;td&gt;Configuration file.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-i FILE&lt;/td&gt; &#xA;   &lt;td&gt;--input=FILE&lt;/td&gt; &#xA;   &lt;td&gt;When set, input will be read from the given file. Otherwise, stdin will be used.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-o FILE&lt;/td&gt; &#xA;   &lt;td&gt;--output=FILE&lt;/td&gt; &#xA;   &lt;td&gt;When set, output will be written to the given file. Otherwise, stdout will be used. If given and if --fmt is omitted, then the format will be guessed from the file extension.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-f FMT&lt;/td&gt; &#xA;   &lt;td&gt;--fmt=FMT&lt;/td&gt; &#xA;   &lt;td&gt;Force the output format to one of: bmp, dot, eps, gif, jpg, pdf, plain, png, ps, ps2, svg, tiff.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-e EDGE&lt;/td&gt; &#xA;   &lt;td&gt;--edge=EDGE&lt;/td&gt; &#xA;   &lt;td&gt;Select one type of edge: compound, noedge, ortho, poly, spline.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-d&lt;/td&gt; &#xA;   &lt;td&gt;--dot-entity&lt;/td&gt; &#xA;   &lt;td&gt;When set, output will consist of regular dot tables instead of HTML tables. Formatting will be disabled.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-p PATTERN&lt;/td&gt; &#xA;   &lt;td&gt;--edge-pattern=PATTERN&lt;/td&gt; &#xA;   &lt;td&gt;Select one of the edge patterns: dashed, dotted, solid.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-n NOTATION&lt;/td&gt; &#xA;   &lt;td&gt;--notation=NOTATION&lt;/td&gt; &#xA;   &lt;td&gt;Select a notation style for cardinalities of relations: ie, uml.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-h&lt;/td&gt; &#xA;   &lt;td&gt;--help&lt;/td&gt; &#xA;   &lt;td&gt;Show this usage message.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Formatting defined in configuration file&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;erd&lt;/code&gt; may be invoked using the &lt;em&gt;-c&lt;/em&gt; or &lt;em&gt;--config&lt;/em&gt; argument&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;without a provided configuration file it will try to read the file &lt;em&gt;~/.erd.yaml&lt;/em&gt; which is the path of the configuration file to store formatting settings of any resulted graph. In case the file &lt;em&gt;~/.erd.yaml&lt;/em&gt; does not exists &lt;code&gt;erd&lt;/code&gt; will print the default content of this file to stdout which you can inspect and/or redirect appropriately, e.g.: &lt;code&gt;erd -c -i ./examples/nfldb.er -o ./nfldb.pdf 1 &amp;gt; ~/.erd.yaml&lt;/code&gt; .&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;with a provided configuration file erd will use that instead of &lt;em&gt;~/.erd.yaml&lt;/em&gt;. For instance: &lt;code&gt;erd -c./myconfig.yaml -i ./examples/nfldb.er -o ./nfldb.pdf&lt;/code&gt; .&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The configuration file in commented sections do contain the supported formatting options, so you can use one of the listed ones.&lt;/p&gt; &#xA;&lt;p&gt;The default content of the configuration file would be only shown when &lt;em&gt;~/.erd.yaml&lt;/em&gt; does not exist.&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;er&lt;/code&gt; file format&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;er&lt;/code&gt; format allows one to describe a relational schema in terms of its entities (tables), attributes (columns) and relationships between entities (0 or 1, exactly 1, 0 or more and 1 or more).&lt;/p&gt; &#xA;&lt;p&gt;Entities are declared inside &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;. For example, this declares the entity &lt;code&gt;Person&lt;/code&gt; with no attributes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[Person]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Attributes for an entity are then listed after its corresponding entity&#39;s declaration. Each attribute should be on its own line. The following adds the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; attributes to the &lt;code&gt;Person&lt;/code&gt; entity:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[Person]&#xA;name&#xA;height&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Entity names and attributes may contain spaces and mostly any character, except ASCII control characters like carriage return and line feed, if quoted with backticks, simple quotes or double quotes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[`Birth Place`]&#xA;*id&#xA;`birth city`&#xA;&#39;birth state&#39;&#xA;&#34;birth country&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any number of attributes may be declared as a primary key for its entity by prefixing the attribute with a &lt;code&gt;*&lt;/code&gt;. Similarly, an attribute may be declared as a foreign key by prefixing the attribute with a &lt;code&gt;+&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[Person]&#xA;*name&#xA;+birth_place_id&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An attribute may be &lt;em&gt;both&lt;/em&gt; a primary key and a foreign key by prefixing the name with a &lt;code&gt;*&lt;/code&gt; and a &lt;code&gt;+&lt;/code&gt; in any order. Note that primary keys are underlined while foreign keys are italicized.&lt;/p&gt; &#xA;&lt;p&gt;Relationships can also be declared &lt;em&gt;anywhere in an ER file&lt;/em&gt;. Every relationship includes exactly two entities (the two entities may be the same, for self-relationships). Each entity in a relationship &lt;strong&gt;must&lt;/strong&gt; have exactly one of four cardinalities:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Cardinality    Syntax&#xA;0 or 1         ?&#xA;exactly 1      1&#xA;0 or more      *&#xA;1 or more      +&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So for example, the following defines a relationship between &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;Birth Place&lt;/code&gt; that reads &#34;every person has exactly one birth place&#34;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Person *--1 `Birth Place`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And here&#39;s another example that can be read as, &#34;every platinum album has one or more artists, but not every artist has a platinum album&#34;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Artist +--? PlatinumAlbums&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fonts, colors, labels, ...&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;er&lt;/code&gt; format also has limited support for customizing the appearance of your ER diagram. For example, the following will show the entity with a background color of &lt;code&gt;#ececfc&lt;/code&gt; and a font size of &lt;code&gt;20&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[Person] {bgcolor: &#34;#ececfc&#34;, size: &#34;20&#34;}&#xA;name&#xA;height&#xA;weight&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which looks like:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/BurntSushi/erd/master/examples/bgcolor.png&#34; alt=&#34;example of changing background color&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can specify the background color of every entity with a special directive at the top of the file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;entity {bgcolor: &#34;#ececfc&#34;, size: &#34;20&#34;}&#xA;&#xA;[Person]&#xA;name&#xA;height&#xA;weight&#xA;&#xA;[`Birth Place`]&#xA;place&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are three other directives: &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;relationship&lt;/code&gt;. The &lt;code&gt;title&lt;/code&gt; directive allows one to specify a title for the graph and provide options for formatting it. The &lt;code&gt;header&lt;/code&gt; directive allows one to customize the formatting of every entity header. And similarly for &lt;code&gt;relationship&lt;/code&gt;. Note that global options are overwritten by local options.&lt;/p&gt; &#xA;&lt;p&gt;Note that directives &lt;strong&gt;must come before anything else in an ER file&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example depicting the first schema shown at the top of this README (note that this is auto-generated by &lt;a href=&#34;https://github.com/BurntSushi/nfldb/raw/master/scripts/nfldb-write-erd&#34;&gt;nfldb-write-erd&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;title {label: &#34;nfldb Entity-Relationship diagram (condensed)&#34;, size: &#34;20&#34;}&#xA;&#xA;# Entities&#xA;&#xA;[player] {bgcolor: &#34;#d0e0d0&#34;}&#xA;  *player_id {label: &#34;varchar, not null&#34;}&#xA;  full_name {label: &#34;varchar, null&#34;}&#xA;  team {label: &#34;varchar, not null&#34;}&#xA;  position {label: &#34;player_pos, not null&#34;}&#xA;  status {label: &#34;player_status, not null&#34;}&#xA;&#xA;[team] {bgcolor: &#34;#d0e0d0&#34;}&#xA;  *team_id {label: &#34;varchar, not null&#34;}&#xA;  city {label: &#34;varchar, not null&#34;}&#xA;  name {label: &#34;varchar, not null&#34;}&#xA;&#xA;[game] {bgcolor: &#34;#ececfc&#34;}&#xA;  *gsis_id {label: &#34;gameid, not null&#34;}&#xA;  start_time {label: &#34;utctime, not null&#34;}&#xA;  week {label: &#34;usmallint, not null&#34;}&#xA;  season_year {label: &#34;usmallint, not null&#34;}&#xA;  season_type {label: &#34;season_phase, not null&#34;}&#xA;  finished {label: &#34;boolean, not null&#34;}&#xA;  home_team {label: &#34;varchar, not null&#34;}&#xA;  home_score {label: &#34;usmallint, not null&#34;}&#xA;  away_team {label: &#34;varchar, not null&#34;}&#xA;  away_score {label: &#34;usmallint, not null&#34;}&#xA;&#xA;[drive] {bgcolor: &#34;#ececfc&#34;}&#xA;  *+gsis_id {label: &#34;gameid, not null&#34;}&#xA;  *drive_id {label: &#34;usmallint, not null&#34;}&#xA;  start_field {label: &#34;field_pos, null&#34;}&#xA;  start_time {label: &#34;game_time, not null&#34;}&#xA;  end_field {label: &#34;field_pos, null&#34;}&#xA;  end_time {label: &#34;game_time, not null&#34;}&#xA;  pos_team {label: &#34;varchar, not null&#34;}&#xA;  pos_time {label: &#34;pos_period, null&#34;}&#xA;&#xA;[play] {bgcolor: &#34;#ececfc&#34;}&#xA;  *+gsis_id {label: &#34;gameid, not null&#34;}&#xA;  *+drive_id {label: &#34;usmallint, not null&#34;}&#xA;  *play_id {label: &#34;usmallint, not null&#34;}&#xA;  time {label: &#34;game_time, not null&#34;}&#xA;  pos_team {label: &#34;varchar, not null&#34;}&#xA;  yardline {label: &#34;field_pos, null&#34;}&#xA;  down {label: &#34;smallint, null&#34;}&#xA;  yards_to_go {label: &#34;smallint, null&#34;}&#xA;&#xA;[play_player] {bgcolor: &#34;#ececfc&#34;}&#xA;  *+gsis_id {label: &#34;gameid, not null&#34;}&#xA;  *+drive_id {label: &#34;usmallint, not null&#34;}&#xA;  *+play_id {label: &#34;usmallint, not null&#34;}&#xA;  *+player_id {label: &#34;varchar, not null&#34;}&#xA;  team {label: &#34;varchar, not null&#34;}&#xA;&#xA;[meta] {bgcolor: &#34;#fcecec&#34;}&#xA;  version {label: &#34;smallint, null&#34;}&#xA;  season_type {label: &#34;season_phase, null&#34;}&#xA;  season_year {label: &#34;usmallint, null&#34;}&#xA;  week {label: &#34;usmallint, null&#34;}&#xA;&#xA;# Relationships&#xA;&#xA;player      *--1 team&#xA;game        *--1 team {label: &#34;home&#34;}&#xA;game        *--1 team {label: &#34;away&#34;}&#xA;drive       *--1 team&#xA;play        *--1 team&#xA;play_player *--1 team&#xA;&#xA;game        1--* drive&#xA;game        1--* play&#xA;game        1--* play_player&#xA;&#xA;drive       1--* play&#xA;drive       1--* play_player&#xA;&#xA;play        1--* play_player&#xA;&#xA;player      1--* play_player&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;All formatting options&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;erd&lt;/code&gt; only exposes a subset of formatting options made available by GraphViz. I&#39;m not entirely opposed to expanding this list if there&#39;s a compelling reason to do so, but I&#39;d prefer to keep it small and simple.&lt;/p&gt; &#xA;&lt;p&gt;Note that not all options are applicable on all items. For example, a title cannot have a background color (it will just be ignored by GraphViz).&lt;/p&gt; &#xA;&lt;p&gt;Colors can be specified in hexadecimal notation prefixed with a &lt;code&gt;#&lt;/code&gt;, e.g., &lt;code&gt;#3366ff&lt;/code&gt; or they may be &lt;a href=&#34;http://hackage.haskell.org/package/graphviz-2999.8.0.0/docs/Data-GraphViz-Attributes-Colors.html#t:X11Color&#34;&gt;written as their English names&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;label&lt;/strong&gt; A plain text string used to label the item. For entity names and attributes, a label is shown next to the name in square brackets. For relationships, a label is drawn near the center of the edge. For the special &lt;code&gt;title&lt;/code&gt; directive, the label corresponds to the graph title.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;color&lt;/strong&gt; Specifies the font color. Valid everywhere.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;bgcolor&lt;/strong&gt; Specifies the background color. Only valid for entities and attributes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;size&lt;/strong&gt; Specifies the font size. Valid everywhere.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;font&lt;/strong&gt; Specifies the font. Valid everywhere. See &lt;a href=&#34;http://www.graphviz.org/doc/info/attrs.html#d:fontname&#34;&gt;this&lt;/a&gt; for information about fonts in GraphViz. TL;DR: Stick with one of the following: &lt;code&gt;Times-Roman&lt;/code&gt;, &lt;code&gt;Helvetica&lt;/code&gt; or &lt;code&gt;Courier&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;border-color&lt;/strong&gt; Border color. Only works for entities or attributes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;border&lt;/strong&gt; Border size in pixels. Only works for entities and attributes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Formatting options are always specified as key-value pairs in curly braces, where the opening curly brace starts on the same line as the entity/attribute/relationship/directive. The option name precedes a colon and the option value comes after the colon in double quotes (even for integer values). The value is then proceded by either a comma or an ending curly brace. Also note that trailing commas are allowed and that options may be specified over more than one line. For example, the following is a valid &lt;code&gt;er&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[Person]&#xA;  name {&#xA;    label: &#34;string&#34;,&#xA;    color: &#34;#3366ff&#34;, # i like bright blue&#xA;  }&#xA;  weight {&#xA;    label: &#34;int&#34;,}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Philosophy&lt;/h3&gt; &#xA;&lt;p&gt;I don&#39;t intend for &lt;code&gt;erd&lt;/code&gt; to have a large feature set with a lot of options for customizing the appearance of ER diagrams. &lt;code&gt;erd&lt;/code&gt; should produce diagrams that are &#34;good enough&#34; from simple plain text descriptions without a lot of complexity. &lt;code&gt;erd&lt;/code&gt; will implicitly trust GraphViz to &#34;do the right thing&#34; without a lot of fiddling with its options.&lt;/p&gt; &#xA;&lt;p&gt;If you have more exotic needs, then I suggest that either &lt;code&gt;erd&lt;/code&gt; is not the right tool, &lt;em&gt;or&lt;/em&gt; you could use &lt;code&gt;erd&lt;/code&gt; to output an &lt;code&gt;er&lt;/code&gt; file as a &lt;code&gt;dot&lt;/code&gt; file. You can then customize it further manually or using some other tool.&lt;/p&gt; &#xA;&lt;p&gt;You can output a &lt;code&gt;dot&lt;/code&gt; file using the &lt;code&gt;--fmt&lt;/code&gt; option or by simply using it as a file extension:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;erd -i something.er -o something.dot&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Similar software&lt;/h3&gt; &#xA;&lt;p&gt;The format of the &lt;code&gt;er&lt;/code&gt; file is inspired by the file format used by the project &lt;a href=&#34;https://github.com/slopjong/Erwiz&#34;&gt;erwiz&lt;/a&gt; (which looks abandoned). The &lt;code&gt;er&lt;/code&gt; format is a bit more lightweight, but its general structure is similar.&lt;/p&gt; &#xA;&lt;p&gt;Similar software that translates a plain text description of a relational schema to a graphical visualization (the list may be incomplete and some of the listed projects are no longer maintained):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;C# &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/frolic06/erd-dotnet&#34;&gt;erd-dotnet&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Go &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/kaishuu0123/erd-go/&#34;&gt;erd-go&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/unok/erdm&#34;&gt;erdm&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/k-kawa/erd&#34;&gt;erd&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Java &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/slopjong/Erwiz&#34;&gt;erwiz&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/plantuml/plantuml&#34;&gt;PlantUML&lt;/a&gt;&#39;s &lt;a href=&#34;https://plantuml.com/ie-diagram&#34;&gt;ERD syntax&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;JavaScript &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/dosaki/t2erd&#34;&gt;t2erd&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/mermaid-js/mermaid&#34;&gt;mermaid&lt;/a&gt;&#39;s &lt;a href=&#34;https://mermaid-js.github.io/mermaid/#/entityRelationshipDiagram&#34;&gt;ERD syntax&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Python &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/ehne/ERDot&#34;&gt;ERDot&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Ruby &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/japgolly/text_to_diagram&#34;&gt;text_to_diagram&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Rust &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/davechallis/erd-rs&#34;&gt;erd-rs&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Propertiary, web-based tools: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://dbdiagram.io/d&#34;&gt;dbdiagram.io&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://app.quickdatabasediagrams.com/#/&#34;&gt;quickdatabasediagrams.com&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Text editor support&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/flniu/er.vim&#34;&gt;Vim syntax file&lt;/a&gt; for the &lt;code&gt;er&lt;/code&gt; file format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kaishuu0123/vscode-erd&#34;&gt;Visual Studio Code ERD preview&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mikkel-ol/vsc-er-syntax-highlighting&#34;&gt;Visual Studio Code syntax highlighting&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>monadicsystems/okapi</title>
    <updated>2022-09-23T01:33:42Z</updated>
    <id>tag:github.com,2022-09-23:/monadicsystems/okapi</id>
    <link href="https://github.com/monadicsystems/okapi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A web microframework for Haskell based on monadic parsing&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Okapi&lt;/h1&gt; &#xA;&lt;p&gt;A micro web framework based on monadic parsing. Official documentation &lt;a href=&#34;https://www.okapi.wiki/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Okapi&lt;/strong&gt; is a micro web framework for Haskell. In contrast to other web frameworks in the Haskell ecosystem, Okapi is primarily concerned with being easy to understand and use, instead of extreme type safety.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example of a simple web server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE OverloadedStrings #-}&#xA;{-# LANGUAGE TypeApplications #-}&#xA;&#xA;import Data.Text&#xA;import Okapi&#xA;&#xA;main :: IO ()&#xA;main = run greet&#xA;&#xA;greet = do&#xA;  methodGET&#xA;  pathParam @Text `is` &#34;greet&#34;&#xA;  name &amp;lt;- pathParam&#xA;  pathEnd&#xA;  return $ setPlaintext (&#34;Hello &#34; &amp;lt;&amp;gt; name &amp;lt;&amp;gt; &#34;! I&#39;m Okapi.&#34;) $ ok&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running this code will start a server on &lt;a href=&#34;http://localhost:3000.org&#34;&gt;localhost:3000&lt;/a&gt;. If you go to &lt;a href=&#34;&#34;&gt;http://localhost:3000/greeting/Bob&lt;/a&gt; the server will respond with&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Hello Bob! I&#39;m Okapi.&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;in plain text format.&lt;/p&gt; &#xA;&lt;p&gt;Okapi provides &lt;a href=&#34;https://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf&#34;&gt;monadic parsers&lt;/a&gt; for extracting data from HTTP requests. Since they are monads, parsers can be used with all &lt;code&gt;Applicative&lt;/code&gt;, &lt;code&gt;Alternative&lt;/code&gt;, and &lt;code&gt;Monad&lt;/code&gt; typeclass methods, plus other Haskell idioms like &lt;a href=&#34;https://hackage.haskell.org/package/parser-combinators&#34;&gt;parser combinators&lt;/a&gt;. Because of this, parsers are very modular and can be easily composed with one another to fit your specific needs.&lt;/p&gt; &#xA;&lt;p&gt;With Okapi, and the rest of the Haskell ecosystem, you can create anything from simple website servers to complex APIs for web apps. All you need to get started is basic knowledge about the structure of HTTP requests and an idea of how monadic parsing works.&lt;/p&gt;</summary>
  </entry>
</feed>