<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-12T01:37:00Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>twesterhout/halide-haskell</title>
    <updated>2023-06-12T01:37:00Z</updated>
    <id>tag:github.com,2023-06-12:/twesterhout/halide-haskell</id>
    <link href="https://github.com/twesterhout/halide-haskell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell bindings to Halide&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt; halide-haskell &lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/twesterhout/halide-haskell/master/assets/construction_1f6a7.png&#34; width=&#34;32&#34;&gt;This project is still under heavy development and might not be production-ready&lt;img src=&#34;https://raw.githubusercontent.com/twesterhout/halide-haskell/master/assets/construction_1f6a7.png&#34; width=&#34;32&#34;&gt;&lt;br&gt; We encourage experimenting with it and reporting any issues you run into via &lt;a href=&#34;https://github.com/twesterhout/halide-haskell/issues&#34;&gt;Github issues&lt;/a&gt;.&lt;/p&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/twesterhout/halide-haskell/tree/master/tutorials&#34;&gt;&lt;strong&gt;Tutorials&lt;/strong&gt;&lt;/a&gt; | &lt;a href=&#34;https://hackage.haskell.org/package/halide-haskell-0.0.1.0&#34;&gt;&lt;strong&gt;Documentation&lt;/strong&gt;&lt;/a&gt; | &lt;a href=&#34;https://github.com/twesterhout/halide-haskell-examples&#34;&gt;&lt;strong&gt;Showcases&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twesterhout/halide-haskell/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/twesterhout/halide-haskell.svg?style=flat-square&#34; alt=&#34;license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/twesterhout/halide-haskell/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/twesterhout/halide-haskell/ci.yml?style=flat-square&#34; alt=&#34;build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/halide-haskell&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/halide-haskell?style=flat-square&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;p&gt;&lt;a href=&#34;https://halide-lang.org/&#34;&gt;Halide&lt;/a&gt; is a programming language designed to make it easier to write high-performance image and array processing code on modern machines. Rather than being a standalone programming language, Halide is embedded in C++. This means you write C++ code that builds an in-memory representation of a Halide pipeline using Halide&#39;s C++ API. You can then compile this representation to an object file, or JIT-compile it and run it in the same process.&lt;/p&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h4 align=&#34;center&#34;&gt; This package provides Haskell bindings that allow to write Halide embedded in Haskell without C++ üòã. &lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twesterhout/halide-haskell/master/#-example-usage&#34;&gt;Example usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twesterhout/halide-haskell/master/#-installing&#34;&gt;Installing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twesterhout/halide-haskell/master/#-motivation&#34;&gt;Motivation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twesterhout/halide-haskell/master/#-contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üöÄ Example usage&lt;/h2&gt; &#xA;&lt;p&gt;As a simple example, here&#39;s how you could implement array addition with halide-haskell:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE AllowAmbiguousTypes, DataKinds, OverloadedStrings, ViewPatterns #-}&#xA;import Language.Halide&#xA;&#xA;-- The algorithm&#xA;mkArrayPlus = compile $ \(buffer &#34;a&#34; -&amp;gt; a) (buffer &#34;b&#34; -&amp;gt; b) -&amp;gt; do&#xA;  -- Create an index variable&#xA;  i &amp;lt;- mkVar &#34;i&#34;&#xA;  -- Define the resulting function. We call it &#34;out&#34;.&#xA;  -- In pseudocode it&#39;s equivalent to the following: out[i] = a[i] + b[i]&#xA;  out &amp;lt;- define &#34;out&#34; i $ a ! i + b ! i&#xA;  -- Perform a fancy optimization and use SIMD: we split the loop over i into&#xA;  -- an inner and an outer loop and then vectorize the inner loop&#xA;  inner &amp;lt;- mkVar &#34;inner&#34;&#xA;  split TailAuto i (i, inner) 4 out &amp;gt;&amp;gt;= vectorize inner&#xA;&#xA;-- Example usage of our Halide pipeline&#xA;main :: IO ()&#xA;main = do&#xA;  let a, b :: [Float]&#xA;      a = [1, 2, 3, 4, 5]&#xA;      b = [6, 7, 8, 9, 10]&#xA;  -- Compile the code&#xA;  arrayPlus &amp;lt;- mkArrayPlus&#xA;  -- We tell Halide to treat our list as a one-dimensional buffer&#xA;  withHalideBuffer @1 @Float a $ \a&#39; -&amp;gt;&#xA;    withHalideBuffer b $ \b&#39; -&amp;gt;&#xA;      -- allocate a temporary buffer for the output&#xA;      allocaCpuBuffer [length a] $ \out&#39; -&amp;gt; do&#xA;        -- execute the kernel -- it is a normal function call!&#xA;        arrayPlus a&#39; b&#39; out&#39;&#xA;        -- print the result&#xA;        print =&amp;lt;&amp;lt; peekToList out&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more examples, have a look at the &lt;a href=&#34;https://github.com/twesterhout/halide-haskell/tree/master/tutorials&#34;&gt;tutorials&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;üíª Installing&lt;/h2&gt; &#xA;&lt;p&gt;The library is avaiable on Hackage, so you can just add &lt;code&gt;halide-haskell&lt;/code&gt; to the &lt;code&gt;build-depends&lt;/code&gt; field in your Cabal file. However, halide-haskell depends on Halide, so you need to make sure it&#39;s available.&lt;/p&gt; &#xA;&lt;h3&gt;‚ùÑÔ∏è Nix&lt;/h3&gt; &#xA;&lt;p&gt;No need to do anything üòÉ, Nix will make Halide avaiable automatically.&lt;/p&gt; &#xA;&lt;p&gt;If you just want to hack on the library, after &lt;code&gt;git clone&lt;/code&gt;ing, type&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nix build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and to run an example, try&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nix run&#xA;nix run .#ghc928-intel-ocl.halide-haskell # for Intel OpenCL support&#xA;nix run .#ghc928-cuda.halide-haskell      # for CUDA support&#xA;nix run .#ghc945.halide-haskell           # to build with GHC 9.4.5 instead&#xA;nix run .#ghc945.halide-tutorial01        # to run the first tutorial&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;non-Nix&lt;/h3&gt; &#xA;&lt;p&gt;This set up is not tested in CI... but&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download a pre-built Halide for your system from &lt;a href=&#34;https://github.com/halide/Halide/releases/&#34;&gt;their releases page&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Pass &lt;code&gt;--extra-include-dirs&lt;/code&gt; and &lt;code&gt;--extra-lib-dirs&lt;/code&gt; options to Cabal on the command line or add them to your &lt;code&gt;cabal.project.local&lt;/code&gt; file.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;ü§© Motivation&lt;/h2&gt; &#xA;&lt;p&gt;The availability of Deep Learning frameworks such as &lt;a href=&#34;https://pytorch.org/&#34;&gt;PyTorch&lt;/a&gt; or &lt;a href=&#34;https://github.com/google/jax&#34;&gt;JAX&lt;/a&gt; has revolutionized array processing, independently of whether one works on Machine Learning tasks or other numerical algorithms. The ecosystem in Haskell has been catching up as well, and there are now multiple good array libraries (&lt;a href=&#34;https://github.com/haskell-numerics/hmatrix&#34;&gt;hmatrix&lt;/a&gt;, &lt;a href=&#34;https://github.com/lehins/massiv&#34;&gt;massiv&lt;/a&gt;, &lt;a href=&#34;https://www.acceleratehs.org/&#34;&gt;Accelerate&lt;/a&gt;, &lt;a href=&#34;https://github.com/arrayfire/arrayfire-haskell&#34;&gt;arrayfire-haskell&lt;/a&gt;, &lt;a href=&#34;https://github.com/hasktorch/hasktorch&#34;&gt;Hasktorch&lt;/a&gt;, are all high-quality libraries). To accommodate multiple domains, such libraries have to support hundreds if not thousands of operations (e.g. there are more than 3.5 thousand of so called &lt;a href=&#34;https://github.com/pytorch/pytorch/raw/6a09847c42bf7d33ba0aea5b083eebd846661ce1/aten/src/ATen/native/native_functions.yaml&#34;&gt;‚Äúnative‚Äù functions in PyTorch&lt;/a&gt;), and this count does not include specializations for different device and data types).&lt;/p&gt; &#xA;&lt;p&gt;To overcome this difficulty, we propose to build a common extension mechanism for Haskell array libraries. The mechanism is based on embedding the &lt;a href=&#34;https://halide-lang.org/&#34;&gt;Halide&lt;/a&gt; language into Haskell that allows to just-in-time (JIT) compile computational kernels for various hardware.&lt;/p&gt; &#xA;&lt;h3&gt;ü§® Why not Accelerate?&lt;/h3&gt; &#xA;&lt;p&gt;One might wonder, why write another package instead of relying on &lt;a href=&#34;https://www.acceleratehs.org/&#34;&gt;Accelerate&lt;/a&gt; for the JIT compilation of the kernels. Accelerate is a Haskell eDSL (embedded Domain Specific Language) for collective operations on dense multi-dimensional arrays. It relies on &lt;a href=&#34;https://llvm.org/&#34;&gt;LLVM&lt;/a&gt; to JIT compile the computational kernels for the target architecture including multicore CPUs and GPUs. Users have to rely on Accelerate to generate high-performance kernels and have no way to force some low-level optimizations. For example, &lt;a href=&#34;https://doi.org/10.1145/2887747.2804313&#34;&gt;Trevor L. McDonell et al.&lt;/a&gt; explain that the reason why hand-written &lt;a href=&#34;https://www.nvidia.com/en-gb/geforce/technologies/cuda/&#34;&gt;CUDA&lt;/a&gt; implementation of the &lt;a href=&#34;https://en.wikipedia.org/wiki/N-body_problem&#34;&gt;N-body problem&lt;/a&gt; outperforms Accelerate is the use of on-chip shared memory. Another example would be the matrix-matrix product where achieving maximal performance requires writing no fewer than six nested loops instead of the naive three (&lt;a href=&#34;https://doi.org/10.1145/1356052.1356053&#34;&gt;ACM Trans. Math. Softw. 34, 3, Article 12 (May 2008)&lt;/a&gt;). Accelerate has no way of knowing that such optimizations have to be applied and cannot perform them automatically, and this is precisely the gap that we are trying to fill by embedding Halide into Haskell.&lt;/p&gt; &#xA;&lt;p&gt;Halide is a C++ eDSL for high-performance image and array processing. Its core idea is to decouple the &lt;em&gt;algorithm&lt;/em&gt; (i.e. what is computed) from the &lt;em&gt;schedule&lt;/em&gt; (i.e. where and when it is computed). The eDSL allows to quickly prototype and test the algorithm and then move on to the optimization. Optimizations such as fusion, tiling, parallelism and vectorization can be freely explored without the risk of breaking the original algorithm definition. Schedulers can also be generated automatically by &lt;a href=&#34;https://halide-lang.org/papers/autoscheduler2019.html&#34;&gt;advanced optimization algorithms&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Halide provides a lower level interface than Accelerate and thus does not aim to replace it. Instead, Halide can be used to extend Accelerate, and later on one might even think about using Halide as a backend for Accelerate.&lt;/p&gt; &#xA;&lt;h2&gt;üî® Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Currently, the best way to get started is to use Nix:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nix develop&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will drop you into a shell with all the necessary tools to build the code such that you can do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cabal build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cabal test&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>ethereum/act</title>
    <updated>2023-06-12T01:37:00Z</updated>
    <id>tag:github.com,2023-06-12:/ethereum/act</id>
    <link href="https://github.com/ethereum/act" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Smart contract specification language&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Act&lt;/h1&gt; &#xA;&lt;p&gt;This project is an effort by several groups working on formal methods for Ethereum smart contracts, aiming at creating a simple but effective language to write formal specification. It extends on the previous &lt;a href=&#34;https://github.com/dapphub/klab/raw/master/acts.md&#34;&gt;Act&lt;/a&gt; project.&lt;/p&gt; &#xA;&lt;p&gt;Some general features it hopes to achieve are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simple structure and logic.&lt;/li&gt; &#xA; &lt;li&gt;Support writing properties on a high level (closer to Solidity/Vyper) as well as on the machine level.&lt;/li&gt; &#xA; &lt;li&gt;Cross-tool communication: Different tools might be able to generate different knowledge and use the specification language to exchange information.&lt;/li&gt; &#xA; &lt;li&gt;No attachment to a particular logic. If a tool wishes to support certain expressions, extensions can be written.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;More in depth documentation can be found in &lt;a href=&#34;https://ethereum.github.io/act/&#34;&gt;The Act Book&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Building&lt;/h1&gt; &#xA;&lt;p&gt;With nix:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nix build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Developing&lt;/h1&gt; &#xA;&lt;p&gt;Enter a nix-shell to get the dependencies of the project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nix develop&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;you can then use &lt;code&gt;cabal&lt;/code&gt; as normal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd src&#xA;cabal build # build&#xA;cabal repl  # enter a repl instance&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to execute the unit tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make test # run all tests&#xA;cd src &amp;amp;&amp;amp; cabal v2-test # run haskell tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To update the project dependencies run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nix flake update&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>