<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-15T01:33:36Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>upenn-cis5520/11-transformers</title>
    <updated>2022-11-15T01:33:36Z</updated>
    <id>tag:github.com,2022-11-15:/upenn-cis5520/11-transformers</id>
    <link href="https://github.com/upenn-cis5520/11-transformers" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>co-log/co-log</title>
    <updated>2022-11-15T01:33:36Z</updated>
    <id>tag:github.com,2022-11-15:/co-log/co-log</id>
    <link href="https://github.com/co-log/co-log" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸ““ Flexible and configurable modern #Haskell logging framework&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;co-log&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/8126674/80955687-92f21a80-8df7-11ea-90d3-422dafdc8391.png&#34; alt=&#34;Co-logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kowainik/co-log/actions&#34;&gt;&lt;img src=&#34;https://github.com/kowainik/co-log/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;GitHub CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/kowainik/co-log/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MPL--2.0-blue.svg?sanitize=true&#34; alt=&#34;MPL-2.0 license&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;co-log&lt;/code&gt; is a composable and configurable logging framework. It combines all the benefits of Haskell idioms to provide a reasonable and convenient interface. Although the library design uses some advanced concepts in its core, we are striving to provide beginner-friendly API. The library also provides the complete documentation with a lot of beginner-friendly examples, explanations and tutorials to guide users. The combination of a pragmatic approach to logging and fundamental Haskell abstractions allows us to create a highly composable and configurable logging framework.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re interested in how different Haskell typeclasses are used to implement core functions of &lt;code&gt;co-log&lt;/code&gt;, you can read the following blog post which goes into detail about the internal implementation specifics:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kowainik.github.io/posts/2018-09-25-co-log&#34;&gt;co-log: Composable Contravariant Combinatorial Comonadic Configurable Convenient Logging&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Co-Log Family&lt;/h2&gt; &#xA;&lt;p&gt;Co-Log is a family of repositories for a composable and configurable logging framework &lt;code&gt;co-log&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here is the list of currently available repositories and libraries that you can check out:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/co-log/co-log-core&#34;&gt;&lt;code&gt;co-log-core&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;lightweight package with basic data types and general idea which depends only on &lt;code&gt;base&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://hackage.haskell.org/package/co-log-core&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/co-log-core.svg?logo=haskell&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/co-log/co-log&#34;&gt;&lt;code&gt;co-log&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;taggless final implementation of logging library based on &lt;code&gt;co-log-core&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://hackage.haskell.org/package/co-log&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/co-log.svg?logo=haskell&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/co-log/co-log-polysemy&#34;&gt;&lt;code&gt;co-log-polysemy&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;implementation of logging library based on &lt;code&gt;co-log-core&lt;/code&gt; and the &lt;a href=&#34;http://hackage.haskell.org/package/polysemy&#34;&gt;&lt;code&gt;polysemy&lt;/code&gt;&lt;/a&gt; extensible effects library.&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://hackage.haskell.org/package/co-log-polysemy&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/co-log-polysemy.svg?logo=haskell&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/co-log/co-log-benchmarks&#34;&gt;&lt;code&gt;co-log-benchmarks&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;benchmarks of the &lt;code&gt;co-log&lt;/code&gt; library&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;&lt;code&gt;co-log&lt;/code&gt; library&lt;/h2&gt; &#xA;&lt;p&gt;Logging library based on &lt;a href=&#34;https://github.com/co-log/co-log-core&#34;&gt;&lt;code&gt;co-log-core&lt;/code&gt;&lt;/a&gt; package. Provides ready-to-go implementation of logging. This README contains &lt;em&gt;How to&lt;/em&gt; tutorial on using this library. This tutorial explains step by step how to integrate &lt;code&gt;co-log&lt;/code&gt; into small basic project, specifically how to replace &lt;code&gt;putStrLn&lt;/code&gt; used for logging with library provided logging.&lt;/p&gt; &#xA;&lt;p&gt;All code below can be compiled and run with the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cabal build&#xA;$ cabal exec readme&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Preamble: imports and language extensions&lt;/h2&gt; &#xA;&lt;p&gt;Since this is a literate haskell file, we need to specify all our language extensions and imports up front.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE FlexibleContexts  #-}&#xA;{-# LANGUAGE OverloadedStrings #-}&#xA;&#xA;import Control.Monad.IO.Class (MonadIO, liftIO)&#xA;&#xA;import Colog (Message, WithLog, cmap, fmtMessage, logDebug, logInfo, logTextStdout, logWarning,&#xA;              usingLoggerT)&#xA;&#xA;import qualified Data.Text as Text&#xA;import qualified Data.Text.IO as TextIO&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Simple IO function example&lt;/h2&gt; &#xA;&lt;p&gt;Consider the following function that reads lines from &lt;code&gt;stdin&lt;/code&gt; and outputs different feedback depending on the line size.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;processLinesBasic :: IO ()&#xA;processLinesBasic = do&#xA;    line &amp;lt;- TextIO.getLine&#xA;    case Text.length line of&#xA;        0 -&amp;gt; do&#xA;            -- here goes logging&#xA;            TextIO.putStrLn &#34;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Empty input&#34;&#xA;            processLinesBasic&#xA;        n -&amp;gt; do&#xA;            TextIO.putStrLn &#34;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Correct input&#34;&#xA;            TextIO.putStrLn $ &#34;Line length: &#34; &amp;lt;&amp;gt; Text.pack (show n)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code mixes application logic with logging of the steps. It&#39;s convenient to have logging to observe behavior of the application. But &lt;code&gt;putStrLn&lt;/code&gt; is very simple and primitive way to log things.&lt;/p&gt; &#xA;&lt;h2&gt;Using &lt;code&gt;co-log&lt;/code&gt; library&lt;/h2&gt; &#xA;&lt;p&gt;In order to use &lt;code&gt;co-log&lt;/code&gt; library, we need to refactor &lt;code&gt;processLinesBasic&lt;/code&gt; function in the following way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;processLinesLog :: (WithLog env Message m, MonadIO m) =&amp;gt; m ()&#xA;processLinesLog = do&#xA;    line &amp;lt;- liftIO TextIO.getLine&#xA;    case Text.length line of&#xA;        0 -&amp;gt; do&#xA;            -- here goes logging&#xA;            logWarning &#34;Empty input&#34;&#xA;            processLinesLog&#xA;        n -&amp;gt; do&#xA;            logDebug &#34;Correct line&#34;&#xA;            logInfo $ &#34;Line length: &#34; &amp;lt;&amp;gt; Text.pack (show n)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s summarize required changes:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Make type more polymorphic: &lt;code&gt;(WithLog env Message m, MonadIO m) =&amp;gt; m ()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;liftIO&lt;/code&gt; to all &lt;code&gt;IO&lt;/code&gt; functions.&lt;/li&gt; &#xA; &lt;li&gt;Replace &lt;code&gt;putStrLn&lt;/code&gt; with proper &lt;code&gt;log*&lt;/code&gt; function.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Running actions&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s run both functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;main :: IO ()&#xA;main = do&#xA;    processLinesBasic&#xA;&#xA;    let action = cmap fmtMessage logTextStdout&#xA;    usingLoggerT action processLinesLog&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And here is how output looks like:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/4276606/45623973-8bafb900-babb-11e8-9e20-4369a5a8e5ff.png&#34; alt=&#34;screenshot from 2018-09-17 20-52-01&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;More Tutorials&lt;/h2&gt; &#xA;&lt;p&gt;To provide a more user-friendly introduction to the library, we&#39;ve created the tutorial series which introduces the main concepts behind &lt;code&gt;co-log&lt;/code&gt; smoothly:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/co-log/co-log/raw/main/tutorials/1-intro/Intro.md&#34;&gt;Intro: Using &lt;code&gt;LogAction&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/co-log/co-log/raw/main/tutorials/2-custom/Custom.md&#34;&gt;Using custom monad that stores &lt;code&gt;LogAction&lt;/code&gt; inside its environment&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;co-log&lt;/code&gt; also cares about concurrent logging. For this purpose we have the &lt;code&gt;concurrent-playground&lt;/code&gt; executable where we experiment with different multithreading scenarios to test the library&#39;s behavior. You can find it here:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/co-log/co-log/main/tutorials/Concurrent.hs&#34;&gt;tutorials/Concurrent.hs&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>apskii/ungadtagger</title>
    <updated>2022-11-15T01:33:36Z</updated>
    <id>tag:github.com,2022-11-15:/apskii/ungadtagger</id>
    <link href="https://github.com/apskii/ungadtagger" rel="alternate"></link>
    <summary type="html">&lt;p&gt;UnGADTagger encapsulates abstraction-from-GADT-tag workflow by utilizing existentials, rank2-types and kind polymorphism.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;UnGADTagger&lt;/h2&gt; &#xA;&lt;p&gt;This package encapsulates abstraction-from-gadt-tag workflow by utilizing existentials, rank2-types and kind polymorphism.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;{-# LANGUAGE GADTs, DataKinds, KindSignatures, LambdaCase #-}&#xA;&#xA;import Data.GADT.Untagged&#xA;&#xA;data Tag = A | B&#xA;&#xA;data Gadt :: Tag -&amp;gt; * where&#xA;  ConA :: String   -&amp;gt; Gadt A&#xA;  ConB :: [Gadt A] -&amp;gt; Gadt B&#xA;  ConC :: Integer  -&amp;gt; Gadt B&#xA;&#xA;foo :: something -&amp;gt; [Untagged Gadt] -&amp;gt; String&#xA;foo _ = quux&#xA;  where&#xA;    quux  = concat . map baz&#xA;    baz x = match x $ \case&#xA;      ConA s  -&amp;gt; s&#xA;      ConB xs -&amp;gt; quux (map untag xs)&#xA;      ConC i  -&amp;gt; show i&#xA;&#xA;test = foo &#34;some cfg for e.g.&#34; (xs ++ ys)&#xA;  where&#xA;    xs = map untag [ConA &#34;A1..&#34;, ConA &#34;A2..&#34;]&#xA;    ys = map untag [ConB [ConA &#34;A3..&#34;], ConC 456]&#xA;&#xA;-- &amp;gt; &#34;A1..A2..A3..456&#34;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>