<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-11T01:43:02Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>input-output-hk/io-sim</title>
    <updated>2022-07-11T01:43:02Z</updated>
    <id>tag:github.com,2022-07-11:/input-output-hk/io-sim</id>
    <link href="https://github.com/input-output-hk/io-sim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;io-sim&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;IOSim&lt;/code&gt; is an simulator monad which supports:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;asynchronous exceptions&lt;/li&gt; &#xA; &lt;li&gt;simulated time&lt;/li&gt; &#xA; &lt;li&gt;timeout API&lt;/li&gt; &#xA; &lt;li&gt;software transaction memory (STM)&lt;/li&gt; &#xA; &lt;li&gt;concurrency: both low level &lt;code&gt;forkIO&lt;/code&gt; as well as &lt;code&gt;async&lt;/code&gt; style&lt;/li&gt; &#xA; &lt;li&gt;strict STM&lt;/li&gt; &#xA; &lt;li&gt;access to lazy ST&lt;/li&gt; &#xA; &lt;li&gt;schedule discovery (see &lt;a href=&#34;https://raw.githubusercontent.com/input-output-hk/io-sim/main/io-sim/how-to-use-IOSimPOR.md&#34;&gt;IOSimPOR&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;eventlog&lt;/li&gt; &#xA; &lt;li&gt;dynamic tracing&lt;/li&gt; &#xA; &lt;li&gt;tracing committed changes to &lt;code&gt;TVar&lt;/code&gt;, &lt;code&gt;TMVar&lt;/code&gt;s, etc.&lt;/li&gt; &#xA; &lt;li&gt;labelling of threads, &lt;code&gt;TVar&lt;/code&gt;&#39;s, etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;io-classes&lt;/code&gt; provides an interface, which allows to write code which can be run in both real &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;IOSim&lt;/code&gt;. It is a drop-in replacement for &lt;code&gt;IO&lt;/code&gt;, and supports interfaces commonly known from &lt;code&gt;base&lt;/code&gt;, &lt;code&gt;exceptions&lt;/code&gt;, &lt;code&gt;stm&lt;/code&gt;, &lt;code&gt;async&lt;/code&gt; or &lt;code&gt;time&lt;/code&gt; packages.&lt;/p&gt; &#xA;&lt;p&gt;One of the principles of &lt;code&gt;io-classes&lt;/code&gt; was to stay as close to &lt;code&gt;IO&lt;/code&gt; as possible, thus most of the &lt;code&gt;IO&lt;/code&gt; instances are directly referring to &lt;code&gt;base&lt;/code&gt; or &lt;code&gt;async&lt;/code&gt; api. However we made some differences, which are reported below.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;io-classes&lt;/code&gt; supports a novel hierarchy for error handling monads as well more familiar &lt;code&gt;exception&lt;/code&gt; style. The new hierarchy provides &lt;code&gt;bracket&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt; functions in the &lt;code&gt;MonadThrow&lt;/code&gt; class, while &lt;code&gt;catch&lt;/code&gt; style operators are provided by a super-class &lt;code&gt;MonadCatch&lt;/code&gt;. Both &lt;code&gt;bracket&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt; are the most common functions used to write code with robust exception handling, exposing them through the more basic &lt;code&gt;MonadThrow&lt;/code&gt; class informs the reader / reviewer that no tricky error handling is done in that section of the code base.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;IOSim&lt;/code&gt; exposes a detailed trace, which can be enhanced by labelling threads, or mutable variables, tracing &lt;code&gt;Dynamic&lt;/code&gt; values (which can be recovered from the trace) or simple &lt;code&gt;String&lt;/code&gt; based tracing. Although its agnostic with respect to the logging framework, it worked of us particularly well using &lt;a href=&#34;https://hackage.haskell.org/package/contra-tracer&#34;&gt;contra-tracer&lt;/a&gt;. It has been used to develop, test and debug a complex, highly-concurrent, distributed system (&lt;a href=&#34;https://github.com/input-output-hk/ouroboros-network&#34;&gt;ouroboros-network&lt;/a&gt;), in particular&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;write network simulations, to verify a complex networking stack;&lt;/li&gt; &#xA; &lt;li&gt;write disk IO simulations, to verify a database implementation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Supporting material&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=e74TE0b4xEM&amp;amp;t=13662s&#34;&gt;Philipp Kant (@kantp) at Bobconf 2022&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Packages&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;io-sim&lt;/code&gt;: provides two simulator interpreters: &lt;code&gt;IOSim&lt;/code&gt; and &lt;code&gt;IOSimPOR&lt;/code&gt; - an enhanced &lt;code&gt;IOSim&lt;/code&gt; version with schedule discovery capabilities.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;io-classes&lt;/code&gt;: class bases interface, which allows to to abstract over the monad&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;strict-stm&lt;/code&gt;: strict STM operations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Differences from &lt;code&gt;base&lt;/code&gt;, &lt;code&gt;async&lt;/code&gt; or &lt;code&gt;exceptions&lt;/code&gt; packages&lt;/h2&gt; &#xA;&lt;h3&gt;Major differences&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;threadDelay&lt;/code&gt; is using &lt;code&gt;DiffTime&lt;/code&gt; (which is measured in &lt;em&gt;seconds&lt;/em&gt; rather than &lt;em&gt;microseconds&lt;/em&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;regiterDelay&lt;/code&gt; is using &lt;code&gt;DiffTime&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;timeout&lt;/code&gt; is using &lt;code&gt;DiffTime&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;getMonotonicTime&lt;/code&gt; returns &lt;code&gt;Time&lt;/code&gt; (a newtype wrapper around &lt;code&gt;DiffTime&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Minor differences&lt;/h3&gt; &#xA;&lt;p&gt;Some of the types have more general kind signatures, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;type Async :: (Type -&amp;gt; Type) -&amp;gt; Type -&amp;gt; Type&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first type of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; describes the monad which could be instantiated to &lt;code&gt;IO&lt;/code&gt;, &lt;code&gt;IOSim&lt;/code&gt; or some other monad stack build with monad transformers. The same applies to many other types, e.g. &lt;code&gt;TVar&lt;/code&gt;, &lt;code&gt;TMVar&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The following types although similar to the originals are not the same as the ones that come from &lt;code&gt;base&lt;/code&gt;, &lt;code&gt;async&lt;/code&gt;, or &lt;code&gt;excpetions&lt;/code&gt; packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Handler&lt;/code&gt; (origin: &lt;code&gt;base&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MaskingState&lt;/code&gt; (origin: &lt;code&gt;base&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Concurrently&lt;/code&gt; (origin: &lt;code&gt;async&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ExceptionInLinkedThread&lt;/code&gt; (origin: &lt;code&gt;async&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ExitCase&lt;/code&gt; (origin: &lt;code&gt;exceptions&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Issues&lt;/h3&gt; &#xA;&lt;p&gt;New issues should be reported in this repository, we still have a list of issues opened in the &lt;code&gt;ouroboros-network&lt;/code&gt; repository:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/input-output-hk/ouroboros-network/issues?q=is%3Aopen+is%3Aissue+label%3Aio-sim&#34;&gt;io-sim issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/input-output-hk/ouroboros-network/issues?q=is%3Aopen+is%3Aissue+label%3Aio-sim&#34;&gt;io-classes issues&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>