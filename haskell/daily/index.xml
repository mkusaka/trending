<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-11T01:30:48Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Zelenya/elephants</title>
    <updated>2023-10-11T01:30:48Z</updated>
    <id>tag:github.com,2023-10-11:/Zelenya/elephants</id>
    <link href="https://github.com/Zelenya/elephants" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;How to use PostgreSQL with Haskell. Elephantine Library Review 2023&lt;/h1&gt; &#xA;&lt;p&gt;As of October 2023, there are around a dozen mature PostgreSQL libraries, all levels of abstractions, from low-level queries to the type level. More than enough for anybody.&amp;nbsp;&lt;em&gt;(Shout out to everyone who says Haskell has no libraries.)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Which one to use? Let‚Äôs see. Foreach library, we‚Äôll talk about features and basics like writing queries, complexity, pitfalls, (everyone‚Äôs favorite topic) errors, and so on.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;We assume you are familiar with the fundamentals of SQL and PostgreSQL.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Mise en place&lt;/h2&gt; &#xA;&lt;p&gt;Before integrating with the database, let‚Äôs discuss the data and the setup.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;If you want to follow allow at home, the &lt;a href=&#34;https://github.com/Zelenya/elephants&#34;&gt;repository&lt;/a&gt; contains all the imports and data types ‚Äî we omit most of them from the tutorial for simplicity.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Data&lt;/h3&gt; &#xA;&lt;p&gt;Let‚Äôs imagine that we‚Äôre building a (tiny) warehouse management system:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Warehouse&lt;/strong&gt; has multiple &lt;strong&gt;products&lt;/strong&gt;, some quantity of each.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Product&lt;/strong&gt; has a label and a description.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Product&lt;/strong&gt; can belong to &lt;strong&gt;categories&lt;/strong&gt; (&lt;em&gt;many-to-many&lt;/em&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Category&lt;/strong&gt; has a label.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;scripts/create_tables.sql&lt;/code&gt; contains all the definitions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE product (&#xA;    id SERIAL PRIMARY KEY,&#xA;    label TEXT NOT NULL,&#xA;    description TEXT,&#xA;    UNIQUE (label)&#xA;);&#xA;&#xA;CREATE TABLE category (&#xA;    id SERIAL PRIMARY KEY,&#xA;    label TEXT NOT NULL,&#xA;    UNIQUE (label)&#xA;);&#xA;&#xA;CREATE TABLE product_category (&#xA;    category_id INT NOT NULL,&#xA;    product_id INT NOT NULL,&#xA;    PRIMARY KEY (category_id, product_id),&#xA;    FOREIGN KEY (product_id) REFERENCES product(id),&#xA;    FOREIGN KEY (category_id) REFERENCES category(id)&#xA;);&#xA;&#xA;CREATE TABLE warehouse (&#xA;    id SERIAL PRIMARY KEY, &#xA;    product_id INT NOT NULL,&#xA;    quantity INT NOT NULL,&#xA;    created TIMESTAMP,&#xA;    modified TIMESTAMP,&#xA;    FOREIGN KEY (product_id) REFERENCES product(id)&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/Zelenya/elephants/assets/11508062/92f8e097-a5c5-427f-b848-76d6edc23e7b&#34; alt=&#34;schema&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Postgres server&lt;/h3&gt; &#xA;&lt;p&gt;Here are a few things you need to know to play along at home.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üêò&amp;nbsp;If you don‚Äôt care, don‚Äôt like docker, or already have an easily-accessible postgres server, feel free to skip this section.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;First, install docker.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;docker compose up&lt;/code&gt; (&lt;code&gt;docker-compose up&lt;/code&gt; on older versions) starts &lt;a href=&#34;https://hub.docker.com/_/postgres&#34;&gt;PostgreSQL&lt;/a&gt; (see &lt;code&gt;docker-compose.yml&lt;/code&gt;) and initializes the databases and tables (using the &lt;code&gt;scripts/create_tables.sql&lt;/code&gt;). It mounts the data to the &lt;code&gt;postgres-data/&lt;/code&gt; (in case you need to wipe it or something).&lt;/p&gt; &#xA;&lt;p&gt;Some of the hardcoded things that the code relies on:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-docker&#34;&gt;environment:&#xA;  - POSTGRES_DB=warehouse&#xA;  - POSTGRES_USER=postgres&#xA;  - POSTGRES_PASSWORD=password&#xA;ports:&#xA;  - 5432:5432&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;These hardcoded values are also hardcoded in the code in &lt;code&gt;Hardcoded.hs&lt;/code&gt; (for laziness reasons)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;You can connect to the container and run arbitrary queries using &lt;code&gt;psql&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker exec -it elephants-postgres-1 psql -U postgres -d warehouse&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;code&gt;elephants-postgres-1&lt;/code&gt; is a container name, which might be different for you; check with &lt;code&gt;docker ps&lt;/code&gt; to get the correct container id (or name). We also pass a couple of flags: &lt;code&gt;-U postgres&lt;/code&gt; for the user name and &lt;code&gt;-d warehouse&lt;/code&gt; for the database name.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;docker compose down&lt;/code&gt; to stop and remove the containers.&lt;/p&gt; &#xA;&lt;h3&gt;Project Overview&lt;/h3&gt; &#xA;&lt;p&gt;If you have &lt;code&gt;stack&lt;/code&gt; &lt;a href=&#34;https://www.haskell.org/ghcup/install/#how-to-install&#34;&gt;installed&lt;/a&gt;, &lt;code&gt;stack build&lt;/code&gt; to build and &lt;code&gt;stack run&lt;/code&gt; to run.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;We use &lt;a href=&#34;https://www.stackage.org/lts-21.7&#34;&gt;lts-21.7&lt;/a&gt; (ghc-9.4.5), published on 2023-08-14.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;ü§∑&amp;nbsp;To build the backend, you might need the&amp;nbsp;&lt;code&gt;libpq&lt;/code&gt;&amp;nbsp;development libraries installed (e.g., &lt;code&gt;libpq-dev&lt;/code&gt;&amp;nbsp;on Debian-based distributions).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Extensions overview&lt;/h3&gt; &#xA;&lt;p&gt;Note that most of the libraries rely on using various extensions. Here is a quick overview of the most important ones.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Used to simplify the construction of query&amp;nbsp;values ‚Äî we can use literal strings, like &lt;code&gt;&#34;SELECT * FROM user&#34;&lt;/code&gt;, instead of manually constructing the whole type; for example, &lt;code&gt;Query . toByteString . stringUtf8 $ &#34;SELECT * FROM user&#34;&lt;/code&gt; (see &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#t:Query&#34;&gt;Query&lt;/a&gt; in &lt;code&gt;postgresql-simple&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;code&gt;TemplateHaskell&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Template Haskell (TH) is fairly useful for generating boilerplate code. Some libraries provide the TH machinery to derive typeclass instances and/or generate custom type-safe data types at the compile time.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt; and &lt;code&gt;DeriveGeneric&lt;/code&gt; enable alternative ways to get free typeclass instances.&lt;/p&gt; &#xA;&lt;p&gt;We‚Äôll use &lt;code&gt;DerivingStrategies&lt;/code&gt; to make the derivation explicit, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Category = Category {label :: Text}&#xA;  deriving (Show, Generic)           -- Derive Generic instance,&#xA;  deriving anyclass (ToRow, FromRow) -- used for these instances&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Some libraries (e.g., &lt;code&gt;postgresql-simple&lt;/code&gt;) provide quasi quoters for less tedious sql construction in Haskell code. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[sql| select label from product |]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Only one postgres library requires it. But it‚Äôs a stylistic choice ‚Äî we use this extension because we have multiple data types with a &lt;code&gt;label&lt;/code&gt; field.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;code&gt;OverloadedRecordDot&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;To access record fields as well as specific columns of the tables (for example, &lt;code&gt;product.label&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Note that the project uses &lt;a href=&#34;https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/control.html#extension-GHC2021&#34;&gt;&lt;code&gt;GHC2021&lt;/code&gt;&lt;/a&gt;, which includes &lt;a href=&#34;https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/generics.html#extension-DeriveGeneric&#34;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/type_applications.html#extension-TypeApplications&#34;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;, and many other extensions required for some libraries to work. Also, for the tutorial&#39;s sake, we‚Äôll use the included &lt;code&gt;ScopedTypeVariables&lt;/code&gt; to demonstrate some intermediate types.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;postgresql-simple&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Let‚Äôs start simple. &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple&#34;&gt;postgresql-simple&lt;/a&gt; describes itself as &lt;em&gt;‚ÄúMid-Level PostgreSQL client library‚Äú&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In other words, we‚Äôll write raw sql queries, and the library will deal with security and stuff.&lt;/p&gt; &#xA;&lt;p&gt;To get started, we add &lt;code&gt;postgresql-simple&lt;/code&gt; to dependencies. We‚Äôre using &lt;code&gt;v0.7.0.0&lt;/code&gt; published in 2023.&lt;/p&gt; &#xA;&lt;h3&gt;How to connect to a database&lt;/h3&gt; &#xA;&lt;p&gt;We use &lt;code&gt;connect&lt;/code&gt; to acquire a connection. It accepts &lt;code&gt;ConnectInfo&lt;/code&gt;, which we can get by using &lt;code&gt;defaultConnectInfo&lt;/code&gt; and overriding some defaults.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;getConnection :: IO Connection&#xA;getConnection =&#xA;  connect $&#xA;    defaultConnectInfo&#xA;      { connectHost = Hardcoded.host&#xA;      , connectDatabase = Hardcoded.database&#xA;      , connectUser = Hardcoded.user&#xA;      , connectPassword = Hardcoded.password&#xA;      }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Eventually, we have to &lt;code&gt;close connection&lt;/code&gt;. But you will probably not need to do it manually because you can use &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#v:withConnect&#34;&gt;&lt;code&gt;withConnect&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Exception.html#v:bracket&#34;&gt;&lt;code&gt;bracket&lt;/code&gt;&lt;/a&gt;, or (better) a &lt;strong&gt;connection pool&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The library doesn‚Äôt support pools, but you can use the &lt;a href=&#34;https://hackage.haskell.org/package/resource-pool&#34;&gt;resource-pool&lt;/a&gt;&amp;nbsp;package (or something similar).&lt;/p&gt; &#xA;&lt;h3&gt;How to modify data&lt;/h3&gt; &#xA;&lt;p&gt;We use &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#v:execute&#34;&gt;&lt;code&gt;execute&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#v:execute_&#34;&gt;&lt;code&gt;execute_&lt;/code&gt;&lt;/a&gt; to insert, update, and delete data.&lt;/p&gt; &#xA;&lt;p&gt;The version with the &lt;code&gt;_&lt;/code&gt; suffix is simpler ‚Äî it doesn‚Äôt perform any query substitutions. We can use it with hardcoded values or with straightforward queries such as truncating the tables:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;cleanUp :: Connection -&amp;gt; IO ()&#xA;cleanUp connection =&#xA;  void $ execute_ connection &#34;truncate warehouse, product_category, product, category&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both &lt;em&gt;execute&lt;/em&gt; functions return the number of affected rows, which isn‚Äôt relevant in case of truncate (it‚Äôs &lt;code&gt;0&lt;/code&gt;) and safe to ignore (&lt;a href=&#34;https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Monad.html#v:void&#34;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/a&gt; ignores the result of evaluation).&lt;/p&gt; &#xA;&lt;p&gt;We can use &lt;code&gt;execute&lt;/code&gt; to make a proper insert and pass some values for substitutions. The simplest way is to pass a tuple:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insert1 &amp;lt;-&#xA;  execute&#xA;    connection&#xA;    &#34;insert into product (label, description) values (?, ?)&#34;&#xA;    (&#34;Wood Screw Kit 1&#34; :: Text, &#34;245-pieces&#34; :: Text)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sometimes, we must be explicit about types; for example, in cases like this, when we use string literals with &lt;code&gt;OverloadedStrings&lt;/code&gt; or numeric literals (like &lt;code&gt;245&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Because there is no tuple of 1, the library provides a custom type &lt;code&gt;Only&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insert2 &amp;lt;-&#xA;  execute&#xA;    connection&#xA;    &#34;insert into product (label) values (?)&#34;&#xA;    (Only &#34;Wood Screw Kit 2&#34; :: Only Text)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, we can use lists for any number of values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insert3 &amp;lt;-&#xA;  execute&#xA;    connection&#xA;    &#34;insert into product (label) values (?)&#34;&#xA;    [&#34;Wood Screw Kit 3&#34; :: Text]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But preferable, we use dedicated types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;execute&#xA;  connection&#xA;  &#34;insert into product (label, description) values (?, ?)&#34;&#xA;  (BasicProduct &#34;Wood Screw Kit 4&#34; (Just &#34;245-pieces&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A record can be turned into a list of substitutions via the &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#t:ToRow&#34;&gt;&lt;code&gt;ToRow&lt;/code&gt;&lt;/a&gt; typeclass, which is derivable&amp;nbsp;using GHC generics:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data BasicProduct = BasicProduct {label :: Text, description :: Maybe Text}&#xA;  deriving (Show, Generic)&#xA;  deriving anyclass (ToRow, FromRow)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we want to modify multiple rows, we can use &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#v:executeMany&#34;&gt;&lt;code&gt;executeMany&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insert5 &amp;lt;-&#xA; executeMany&#xA;   connection&#xA;   insert into category (label) values (?)&#34;&#xA;   [Category &#34;Screws&#34;, Category &#34;Wood Screws&#34;, Category &#34;Concrete Screws&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to query data&lt;/h3&gt; &#xA;&lt;p&gt;The execute functions can‚Äôt return any results (other than the number of affected rows), so we have to use the query functions.&lt;/p&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;execute_&lt;/code&gt;, &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#v:query_&#34;&gt;&lt;code&gt;query_&lt;/code&gt;&lt;/a&gt; takes a query with no substitutes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query1 :: [(Int64, Text, Maybe Text)] &amp;lt;-&#xA;  query_ connection &#34;select id, label, description from product&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we must be explicit about return types ‚Äî the library can‚Äôt guess what we want. In this case, we expect an id of type &lt;code&gt;Int64&lt;/code&gt; that corresponds to &lt;code&gt;Serial&lt;/code&gt;, required &lt;code&gt;Text&lt;/code&gt; label, and optional description.&lt;/p&gt; &#xA;&lt;p&gt;We can specify a record return type if we derive &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#t:FromRow&#34;&gt;&lt;code&gt;FromRow&lt;/code&gt;&lt;/a&gt; (recall &lt;code&gt;ToRow&lt;/code&gt; from the previous section). For example, let‚Äôs get a &lt;code&gt;BasicProduct&lt;/code&gt; list by label using &lt;code&gt;query&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query2 :: [BasicProduct] &amp;lt;-&#xA;  query &#xA;    connection &#xA;    &#34;select label, description from product where label = ? &#34;&#xA;    (Only &#34;Wood Screw Kit 2&#34; :: Only Text)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we want to use the in-clause, the library provides a dedicated wrapper:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query3 :: [BasicProduct] &amp;lt;-&#xA;  query connection &#34;select label, description from product where label in ?&#34; $&#xA;    Only (In [&#34;Wood Screw Kit 2&#34; :: Text, &#34;Wood Screw Kit 3&#34;])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to use transactions&lt;/h3&gt; &#xA;&lt;p&gt;Imagine we want to atomically insert a new listing: product, category, and quantity. This touches multiple tables and requires a transaction. Additionally, because we have a many-to-many relationship, we must first insert the product and category and then use their new ids to create a mapping.&lt;/p&gt; &#xA;&lt;p&gt;We can use &lt;code&gt;returning&lt;/code&gt; to get &lt;code&gt;id&lt;/code&gt;s of created rows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;productIds :: [Only Int64] &amp;lt;-&#xA;  query&#xA;    connection&#xA;    &#34;insert into product (label, description) values (?, ?) returning id&#34;&#xA;    (BasicProduct &#34;Drywall Screws Set&#34; (Just &#34;8000pcs&#34;))&#xA;&#xA;categoryIds :: [Only Int64] &amp;lt;-&#xA;  query&#xA;    connection&#xA;    &#34;insert into category (label) values (?) returning id&#34;&#xA;    (Category &#34;Drywall Screws&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we must use &lt;code&gt;query&lt;/code&gt; and not &lt;code&gt;execute&lt;/code&gt; because these queries return results.&lt;/p&gt; &#xA;&lt;p&gt;We can use &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#v:withTransaction&#34;&gt;&lt;code&gt;withTransaction&lt;/code&gt;&lt;/a&gt; to wrap multiple queries in a transaction:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;withTransaction connection $ do&#xA;  productIds :: [Only Int64] &amp;lt;- query ...&#xA;  categoryIds :: [Only Int64] &amp;lt;- query ...&#xA;&#xA;  void $ case (productIds, categoryIds) of&#xA;    ([Only productId], [Only categoryId]) -&amp;gt; do&#xA;      _ &amp;lt;-&#xA;        execute&#xA;          connection&#xA;          &#34;insert into warehouse (product_id, quantity, created, modified) values (?, ?, now(), now())&#34;&#xA;          (productId, 10 :: Int)&#xA;&#xA;      execute&#xA;        connection&#xA;        &#34;insert into product_category (category_id, product_id) values (?, ?)&#34;&#xA;        (categoryId, productId)&#xA;    _ -&amp;gt; &#xA;      throwIO $ userError &#34;Failed to insert product/category&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any error will rollback the transaction (and the exception will be rethrown). In this example, we throw an explicit error if we don‚Äôt get the expected ids for some reason.&lt;/p&gt; &#xA;&lt;p&gt;Note that in case of a &lt;strong&gt;sql error&lt;/strong&gt;, the exception will not only rollback the transaction but, if uncaught, will propagate further (killing everything on its way and potentially crashing the whole app). So, we should (at least) wrap transactions in the exception handler(s); we‚Äôll see how to do this later.&lt;/p&gt; &#xA;&lt;p&gt;When you need to, you can also use granular transaction functions: &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#v:begin&#34;&gt;begin&lt;/a&gt;, &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#v:commit&#34;&gt;commit&lt;/a&gt;, and &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#v:rollback&#34;&gt;rollback&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How to query using joins&lt;/h3&gt; &#xA;&lt;p&gt;To read all these tables at once, we need to query using a few joins. The library provides a quasi-quoter that makes writing big queries easier ‚Äî we can format the query and not worry about whitespaces:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;result :: [Listing] &amp;lt;-&#xA;  query&#xA;    connection&#xA;    [sql|&#xA;      select&#xA;        w.quantity,&#xA;        p.label,&#xA;        p.description,&#xA;        c.label&#xA;      from warehouse as w&#xA;      inner join product as p on w.product_id = p.id&#xA;      left outer join product_category as pc on p.id = pc.product_id&#xA;      left outer join category as c on c.id = pc.category_id&#xA;      where w.quantity &amp;gt; (?)|]&#xA;    [3 :: Int]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Errors&lt;/h3&gt; &#xA;&lt;p&gt;In &lt;code&gt;postgresql-simple&lt;/code&gt;, all the programmer errors (in sql or library usage) are (runtime) exceptions.&lt;/p&gt; &#xA;&lt;p&gt;If the query string is not formatted correctly, we get &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#t:FormatError&#34;&gt;&lt;code&gt;FormatError&lt;/code&gt;&lt;/a&gt;. For instance, if we have a mismatching number of substitutions (&lt;code&gt;?&lt;/code&gt; and actual values):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;execute&#xA;  connection&#xA;  &#34;INSERT INTO category (label) VALUES (?)&#34;&#xA;  (&#34;One&#34; :: Text, &#34;Two&#34; :: Text)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;FormatError {fmtMessage = &#34;1 single &#39;?&#39; characters, but 2 parameters&#34;, fmtQuery = &#34;INSERT INTO category (label) VALUES (?)&#34;, fmtParams = [&#34;One&#34;,&#34;Two&#34;]}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Similarly, on the return side, if the number of columns doesn‚Äôt match the number of elements in the result type (in a list, a tuple, or a record), we get &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#t:ResultError&#34;&gt;&lt;code&gt;ResultError&lt;/code&gt;&lt;/a&gt;. The most likely variants are &lt;code&gt;Incompatible&lt;/code&gt; and &lt;code&gt;UnexpectedNull&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If we forget to wrap a nullable type on the Haskell side, we get &lt;code&gt;UnexpectedNull&lt;/code&gt;. For instance, if we try to get &lt;code&gt;description&lt;/code&gt; (which is nullable) as &lt;code&gt;Text&lt;/code&gt; and not &lt;code&gt;Maybe Text&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;let result :: IO [(Text, Text)] = query_ connection &#34;select label, description from product&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;UnexpectedNull {errSQLType = &#34;text&#34;, errSQLTableOid = Just (Oid 16386), errSQLField = &#34;description&#34;, errHaskellType = &#34;Text&#34;, errMessage = &#34;&#34;}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If we mistype the types, we get &lt;code&gt;Incompatible&lt;/code&gt;. For instance, if we try to parse just &lt;code&gt;id&lt;/code&gt; into &lt;code&gt;BasicProduct&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;let result :: IO [BasicProduct] = query_ connection &#34;select id from product&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;Incompatible {errSQLType = &#34;int4&#34;, errSQLTableOid = Just (Oid 16386), errSQLField = &#34;id&#34;, errHaskellType = &#34;Text&#34;, errMessage = &#34;types incompatible&#34;}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;On top of that, if we misuse the library ‚Äî by mistaking &lt;code&gt;query&lt;/code&gt; for &lt;code&gt;execute&lt;/code&gt; or vice verse ‚Äî we get &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#t:QueryError&#34;&gt;&lt;code&gt;QueryError&lt;/code&gt;&lt;/a&gt;. For example, if we use &lt;code&gt;execute&lt;/code&gt; with &lt;em&gt;insert&lt;/em&gt; query that has &lt;em&gt;returning&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;execute_&#xA;  connection&#xA;  &#34;INSERT INTO category (label) VALUES (Screws) returning id&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;QueryError {qeMessage = &#34;execute resulted in Col 1-column result&#34;, qeQuery = &#34;INSERT INTO category (label) VALUES (&#39;Deck Screws&#39;) returning id&#34;}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;And last but not least, any sql errors from postgres, will come back as &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html#t:SqlError&#34;&gt;&lt;code&gt;SqlError&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;let result :: IO [BasicProduct] = query_ connection &#34;select I have no idea what I&#39;m doing&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;Wrong sql: SqlError {sqlState = &#34;42601&#34;, sqlExecStatus = FatalError, sqlErrorMsg = &#34;syntax error at or near \&#34;no\&#34;&#34;, sqlErrorDetail = &#34;&#34;, sqlErrorHint = &#34;&#34;}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The errors are pretty good but still not the most descriptive ‚Äî if you try to write big queries, you have to concentrate on projecting the error information to the query.&lt;/p&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;The docs are also simple; the library covers all the primary blocks, describes the functions, and provides some examples. Outside, a few blog posts cover similar things, mainly targeting beginners.&lt;/p&gt; &#xA;&lt;p&gt;And you don‚Äôt need more than that ‚Äî if you know how to write one simple query, you know how to write them all.&lt;/p&gt; &#xA;&lt;h3&gt;Migrations&lt;/h3&gt; &#xA;&lt;p&gt;The library has a companion package, &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-migration&#34;&gt;&lt;code&gt;postgresql-migration&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üóÇÔ∏è This is a fork of the archived &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple-migration&#34;&gt;&lt;code&gt;postgresql-simple-migration&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;In summary&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/postgresql-simple&#34;&gt;postgresql-simple&lt;/a&gt; is a library for all levels and a great option if you love writing sql by hand and don‚Äôt need reusability.&lt;/p&gt; &#xA;&lt;p&gt;It doesn‚Äôt parse or validate the queries, so we must pay attention to what we write: sql queries, haskell types (type-safety is our responsibility), the order of parameters, and so on.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;hasql&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;The next ‚Äúobvious‚Äù step is to add more type-safety.&lt;/p&gt; &#xA;&lt;p&gt;According to the readme, &lt;em&gt;&lt;a href=&#34;https://github.com/nikita-volkov/hasql&#34;&gt;Hasql&lt;/a&gt; ‚Äúis a highly efficient PostgreSQL driver for Haskell with a typesafe yet flexible mapping API; it is production-ready, actively maintained, and the API is pretty stable. It&#39;s used by many companies and most notably by the&amp;nbsp;&lt;a href=&#34;https://postgrest.org/&#34;&gt;Postgrest&lt;/a&gt;&amp;nbsp;project.‚Äú&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Hasql is an &lt;a href=&#34;https://github.com/nikita-volkov/hasql#ecosystem&#34;&gt;ecosystem&lt;/a&gt; of libraries. To keep it simple, let‚Äôs limit ourselves to core &lt;code&gt;hasql&lt;/code&gt;, &lt;a href=&#34;https://github.com/nikita-volkov/hasql-transaction&#34;&gt;&lt;code&gt;hasql-transaction&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://github.com/nikita-volkov/hasql-th&#34;&gt;&lt;code&gt;hasql-th&lt;/code&gt;&lt;/a&gt;. We‚Äôre using &lt;code&gt;hasql&lt;/code&gt; &lt;code&gt;1.6.3.2&lt;/code&gt; published in 2023.&lt;/p&gt; &#xA;&lt;p&gt;We‚Äôll also use &lt;a href=&#34;https://hackage.haskell.org/package/contravariant-extras&#34;&gt;contravariant-extras&lt;/a&gt;, &lt;a href=&#34;https://hackage.haskell.org/package/vector&#34;&gt;vector&lt;/a&gt;, &lt;a href=&#34;https://hackage.haskell.org/package/profunctors&#34;&gt;profunctors&lt;/a&gt;, and &lt;a href=&#34;https://hackage.haskell.org/package/tuple&#34;&gt;tuple&lt;/a&gt; packages to make a few things tidier (this isn‚Äôt required; it‚Äôs all copy-paste anyway).&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;(It‚Äôs not very important, but) We assume you‚Äôve seen the part on &lt;code&gt;postgresql-simple&lt;/code&gt;, which covers the same topics but at a slower pace.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;How to connect to a database&lt;/h3&gt; &#xA;&lt;p&gt;First, we get a connection:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Right connection &amp;lt;- getConnection&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;getConnection :: IO (Either ConnectionError Connection)&#xA;getConnection =&#xA;  acquire $ settings Hardcoded.host Hardcoded.portNumber Hardcoded.user Hardcoded.password Hardcoded.database&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note the &lt;code&gt;Either&lt;/code&gt;. But for now, let‚Äôs just pattern-match and not worry about possible errors‚Ä¶&lt;/p&gt; &#xA;&lt;p&gt;In reality/production, we should probably use &lt;a href=&#34;https://hackage.haskell.org/package/hasql-pool&#34;&gt;&lt;code&gt;hasql-pool&lt;/code&gt;&lt;/a&gt; to work with a pool of connections.&lt;/p&gt; &#xA;&lt;h3&gt;How to modify data&lt;/h3&gt; &#xA;&lt;p&gt;Let‚Äôs see the leading players through the clean-up query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;cleanUp :: Connection -&amp;gt; IO (Either QueryError ())&#xA;cleanUp connection = run cleanUpSession connection&#xA; where&#xA;  cleanUpSession :: Session ()&#xA;  cleanUpSession = statement () cleanUpStatement&#xA;&#xA;  cleanUpStatement :: Statement () ()&#xA;  cleanUpStatement = Statement rawSql E.noParams D.noResult True&#xA;&#xA;  rawSql = &#34;truncate warehouse, product_category, product, category&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Session&lt;/code&gt; is a batch of actions to be executed in the context of a connection (a query).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Statement&lt;/code&gt; is a specification of a strictly single-statement query, which can be parameterized and prepared (how to make a query).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Statement&lt;/code&gt; consists of SQL template, params encoder, result decoder, and a flag that determines whether it‚Äôs prepared.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;statement&lt;/code&gt;&amp;nbsp;creates a&amp;nbsp;&lt;code&gt;Session&lt;/code&gt;&amp;nbsp;from a&amp;nbsp;&lt;code&gt;Statement&lt;/code&gt;&amp;nbsp;and input parameters.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;run&lt;/code&gt; executes a bunch of commands (statements) on the provided connection.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;Remember that you can see the complete code in the &lt;a href=&#34;https://github.com/Zelenya/elephants&#34;&gt;repo&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We have a simple query with no parameters and no result ‚Äî we don‚Äôt need to encode or decode anything. That‚Äôs what &lt;code&gt;E.noParams D.noResult&lt;/code&gt; for. If we want to pass parameters, we need to supply a decoder.&lt;/p&gt; &#xA;&lt;p&gt;The first option, is tuples of primitive types and manually written decoders:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertProductSql = &#34;insert into product (label, description) values ($1, $2)&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertProduct1 :: Statement (Text, Maybe Text) Int64&#xA;insertProduct1 = Statement insertProductSql rawParams D.rowsAffected True&#xA;&#xA;rawParams =&#xA;  (fst &amp;gt;$&amp;lt; E.param (E.nonNullable E.text))&#xA;    &amp;lt;&amp;gt; (snd &amp;gt;$&amp;lt; E.param (E.nullable E.text))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;statement (&#34;Wood Screw Kit 1&#34;, Just &#34;245-pieces&#34;) insertProduct1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;rawParams&lt;/code&gt; is the encoder for our parameters. We use &lt;a href=&#34;https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor-Contravariant.html#v:contramap&#34;&gt;&lt;code&gt;contramap&lt;/code&gt;&lt;/a&gt; operator (&lt;code&gt;&amp;gt;$&amp;lt;&lt;/code&gt;) and append (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) to compose multiple parameters. &lt;code&gt;D.rowsAffected&lt;/code&gt; is the decoder for the result when we want to return the number of affected rows.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;Instead of&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/base-4.16.3.0/docs/Data-Tuple.html#v:fst&#34;&gt;&lt;code&gt;fst&lt;/code&gt;&lt;/a&gt;&amp;nbsp;and&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/base-4.16.3.0/docs/Data-Tuple.html#v:snd&#34;&gt;&lt;code&gt;snd&lt;/code&gt;&lt;/a&gt;, you can use&amp;nbsp;the &lt;code&gt;contrazip&lt;/code&gt;&amp;nbsp;family of functions from the &lt;code&gt;contravariant-extras&lt;/code&gt; package to reduce boilerplate.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Another option, is using records:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertProduct2 :: Statement BasicProduct Int64&#xA;insertProduct2 = Statement insertProductSql basicProductParams D.rowsAffected True&#xA;&#xA;basicProductParams :: E.Params BasicProduct&#xA;basicProductParams =&#xA;  ((.label) &amp;gt;$&amp;lt; E.param (E.nonNullable E.text))&#xA;    &amp;lt;&amp;gt; ((.description) &amp;gt;$&amp;lt; E.param (E.nullable E.text))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;statement (BasicProduct &#34;Wood Screw Kit 2&#34; Nothing) insertProduct2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we want to modify multiple rows, we have to use the postgres &lt;code&gt;unnest&lt;/code&gt;&amp;nbsp;function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertManyCategories :: Statement (Vector Category) Int64&#xA;insertManyCategories = Statement insertManyCategoriesSql categoryParams D.rowsAffected True&#xA;&#xA;insertManyCategoriesSql = &#34;insert into category (label) select * from unnest ($1)&#34;&#xA;&#xA;categoryParams :: E.Params (Vector Category)&#xA;categoryParams =&#xA;  E.param&#xA;    $ E.nonNullable&#xA;    $ E.array&#xA;    $ E.dimension List.foldl&#39;&#xA;    $ categoryArray&#xA;&#xA;categoryArray :: E.Array Category&#xA;categoryArray = (.label) &amp;gt;$&amp;lt; (E.element $ E.nonNullable E.text)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;categoryParams&lt;/code&gt; is an encoder that allows us to pass a vector of categories to insert.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;let categories = [Category &#34;Screws&#34;, Category &#34;Wood Screws&#34;, Category &#34;Concrete Screws&#34;]&#xA;statement (fromList categories) insertManyCategories&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note that &lt;code&gt;unnest&lt;/code&gt; is more efficient than executing a single-row insert statement multiple times.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;How to query data&lt;/h3&gt; &#xA;&lt;p&gt;Querying data is similar:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;session1 :: Session [(Int64, Text, Maybe Text)]&#xA;session1 =&#xA;  statement ()&#xA;    $ Statement&#xA;      &#34;select id, label, description from product&#34;&#xA;      E.noParams&#xA;      decoder1&#xA;      True&#xA;&#xA;decoder1 =&#xA;  D.rowList&#xA;    $ (,,)&#xA;    &amp;lt;$&amp;gt; D.column (D.nonNullable D.int8)&#xA;    &amp;lt;*&amp;gt; D.column (D.nonNullable D.text)&#xA;    &amp;lt;*&amp;gt; D.column (D.nullable D.text)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We need to provide a decoder for the result (to specify how each row results maps into the expected type). If this sounds tedious, we can ask Template Haskell to do the work for us:&lt;/p&gt; &#xA;&lt;p&gt;In this case, we use &lt;code&gt;singletonStatement&lt;/code&gt; that expects one result. There are other variants that we‚Äôll see later.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;session2 :: Session (Text, Maybe Text)&#xA;session2 = statement () statement2&#xA;&#xA;statement2 :: Statement () (Text, Maybe Text)&#xA;statement2 =&#xA;  [singletonStatement|&#xA;    select label :: text, description :: text? from product limit 1&#xA;  |]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We write the query and specify the types, &lt;code&gt;hasql-th&lt;/code&gt; handles the codecs for us.&lt;/p&gt; &#xA;&lt;p&gt;But we still need to handle the conversions if we use custom types instead of tuples. The result of the statement has a &lt;code&gt;Profunctor&lt;/code&gt; instance, which allows us to modify (input) parameters and (output) results. In other words, we use &lt;code&gt;lmap&lt;/code&gt; to map parameters, &lt;code&gt;rmap&lt;/code&gt; ‚Äî result, and &lt;code&gt;dimap&lt;/code&gt; ‚Äî both. For example, let‚Äôs return &lt;code&gt;BasicProduct&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;session3 :: Session (Maybe BasicProduct)&#xA;session3 = statement &#34;Wood Screw Kit 2&#34; statement3&#xA;&#xA;statement3 :: Statement Text (Maybe BasicProduct)&#xA;statement3 =&#xA;  rmap&#xA;    (fmap (uncurryN BasicProduct))&#xA;    [maybeStatement|&#xA;      select label :: text, description :: text?&#xA;      from product&#xA;      where label = $1 :: text&#xA;    |]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;üí°&amp;nbsp;&lt;code&gt;(fmap (uncurryN BasicProduct))&lt;/code&gt; is a concise way to write the following (using &lt;code&gt;tuples&lt;/code&gt; package):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(\result -&amp;gt; fmap (\(a, b) -&amp;gt; (BasicProduct a b)) result)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;code&gt;hasql&lt;/code&gt; doesn‚Äôt have &#34;special support&#34; for an array as a parameter for the&amp;nbsp;&lt;code&gt;IN&lt;/code&gt;&amp;nbsp;operator, we should use &lt;a href=&#34;https://hackage.haskell.org/package/hasql-1.6.3.2/docs/Hasql-Statement.html#g:3&#34;&gt;Any&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;session4 :: Session (Vector BasicProduct)&#xA;session4 = statement (fromList [&#34;Wood Screw Kit 1&#34;, &#34;Wood Screw Kit 2&#34;]) statement4&#xA;&#xA;statement4 :: Statement (Vector Text) (Vector BasicProduct)&#xA;statement4 =&#xA;  rmap&#xA;    (fmap (uncurryN BasicProduct))&#xA;    [vectorStatement|&#xA;      select label :: text, description :: text?&#xA;      from product&#xA;      where label = ANY($1 :: text[])&#xA;    |]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to use transactions&lt;/h3&gt; &#xA;&lt;p&gt;We can use &lt;code&gt;returning&lt;/code&gt; to get &lt;code&gt;id&lt;/code&gt;s of created rows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertProduct :: Statement (Text, Maybe Text) Int64&#xA;insertProduct =&#xA;  [singletonStatement|&#xA;    insert into product (label, description) values ($1 :: text, $2 :: text?) returning id :: int8&#xA;  |]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To wrap multiple queries in a transaction, we can use &lt;code&gt;hasql-transaction&lt;/code&gt;. First, we compose the statements:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertAll :: FullProduct -&amp;gt; Transaction Int64&#xA;insertAll listing = do&#xA;  productId &amp;lt;- Transaction.statement (listing.label, listing.description) insertProduct&#xA;  categoryId &amp;lt;- Transaction.statement listing.category insertCategory&#xA;  _ &amp;lt;- Transaction.statement (productId) insertListing&#xA;  ids &amp;lt;- Transaction.statement (productId, categoryId) insertMapping&#xA;  pure ids&#xA;&#xA;insertProduct :: Statement (Text, Maybe Text) Int64&#xA;&#xA;insertCategory :: Statement Text Int64&#xA;&#xA;insertListing :: Statement Int64 ()&#xA;&#xA;insertMapping :: Statement (Int64, Int64) Int64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then we run the transaction using the relevant isolation level and mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertWithTransaction :: Connection -&amp;gt; IO ()&#xA;insertWithTransaction connection = do&#xA;  let listing = FullProduct &#34;Drywall Screws Set&#34; (Just &#34;8000pcs&#34;) &#34;Drywall Screws&#34;&#xA;  mapping &amp;lt;- run (transaction Serializable Write $ insertAll listing) connection&#xA;  putStrLn $ &#34;Insert with transaction: &#34; &amp;lt;&amp;gt; show mapping&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to query using joins&lt;/h3&gt; &#xA;&lt;p&gt;We can query these tables using a few joins. There should be nothing unexpected here:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;listings :: Statement Int32 (Vector Listing)&#xA;listings =&#xA;  rmap&#xA;    (fmap (uncurryN Listing))&#xA;    [vectorStatement|&#xA;    select&#xA;        w.quantity :: int,&#xA;        p.label :: text,&#xA;        p.description :: text?,&#xA;        c.label :: text?&#xA;      from warehouse as w&#xA;      inner join product as p on w.product_id = p.id&#xA;      left outer join product_category as pc on p.id = pc.product_id&#xA;      left outer join category as c on c.id = pc.category_id&#xA;      where w.quantity &amp;gt; $1 :: int4&#xA;  |]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Errors&lt;/h3&gt; &#xA;&lt;p&gt;We‚Äôve been neglecting this until now, but all error reporting is explicit and is presented using &lt;code&gt;Either&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;üí°&amp;nbsp;Just a reminder, &lt;strong&gt;don‚Äôt ignore errors&lt;/strong&gt;. And don‚Äôt pattern match only on &lt;code&gt;Right&lt;/code&gt;, or you will end up with this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;user error (Pattern match failure in &#39;do&#39; block at ...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;The other good thing is that the &lt;code&gt;hasql-th&lt;/code&gt; parser is pretty good at error reporting and catching typos at compile time (and most of the time, it‚Äôs more explicit than postgres‚Äô &lt;code&gt;syntax error at or near&lt;/code&gt;). This won‚Äôt compile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[singletonStatement|&#xA;    select I have no idea what I&#39;m doing&#xA;|]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The library doesn‚Äôt accept (doesn‚Äôt compile) if you forget to specify one of the types. For instance, if we omit type of &lt;code&gt;label&lt;/code&gt;, we get a somewhat generic error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[singletonStatement|&#xA;    select label, description :: text? from product&#xA;|]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;Result expression is missing a typecast&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This ensures that most input and result type (including nullability) mismatches are caught in the compile time. For example, if we forget an input type and return a wrong result type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;statement :: Statement () (Text, Int32)&#xA;statement =&#xA;  [singletonStatement|&#xA;    select label :: text, description :: text?&#xA;--                                       ^^^^^ &#xA;--  Couldn&#39;t match type ‚ÄòInt32‚Äô with ‚ÄòMaybe Text‚Äô&#xA;    from product where label = $1 :: text&#xA;--                                   ^^^^&#xA;--  Couldn&#39;t match type ‚ÄòText‚Äô with ‚Äò()‚Äô&#xA;  |]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, we‚Äôre not safe from programming errors. We should use correct statement functions not to get a runtime error. For example, if we use &lt;code&gt;singletonStatement&lt;/code&gt; for statements that might not return a result (instead of &lt;code&gt;maybeStatement&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;do&#xA;  failure &amp;lt;- run (statement () failsBecauseNoResults) connection&#xA;  putStrLn $ &#34;Wrong statement function: &#34; &amp;lt;&amp;gt; show failure&#xA; where&#xA;  failsBecauseNoResults :: Statement () (Text)&#xA;  failsBecauseNoResults =&#xA;    [singletonStatement|&#xA;        select label :: text from product where 1 = 0&#xA;    |]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;Wrong statement function: Left (QueryError &#34;SELECT label :: text FROM product WHERE 1 = 0&#34; [] (ResultError (UnexpectedAmountOfRows 0)))&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Or if we use &lt;code&gt;singletonStatement&lt;/code&gt; with &lt;code&gt;()&lt;/code&gt; result (instead of &lt;code&gt;resultlessStatement&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;do&#xA;  failure &amp;lt;- run (statement () failsBecauseResultless) connection&#xA;  putStrLn $ &#34;Wrong statement function: &#34; &amp;lt;&amp;gt; show failure&#xA; where&#xA;  failsBecauseResultless :: Statement () ()&#xA;  failsBecauseResultless =&#xA;    [singletonStatement|&#xA;      insert into product (label) values (&#39;this insert fails&#39;)&#xA;    |]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;Wrong statement function: Left (QueryError &#34;INSERT INTO product (label) VALUES (&#39;this insert fails&#39;)&#34; [] (ResultError (UnexpectedResult &#34;Unexpected result status: CommandOk&#34;)))&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;In case of runtime sql error, for instance, if we violate a constraint, we get a similar error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;inserProduct :: Statement Text ()&#xA;inserProduct =&#xA;  [singletonStatement|&#xA;    insert into product (label) values ($1 :: text)&#xA;  |]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;run (statement &#34;Duplicate screw&#34; inserProduct) connection&#xA;  &amp;gt;&amp;gt; run (statement &#34;Duplicate screw&#34; inserProduct) connection&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;Wrong statement function (Left): QueryError &#34;INSERT INTO product (label) VALUES (&#39;Duplicate&#39;)&#34; [] (ResultError (ServerError &#34;23505&#34; &#34;duplicate key value violates unique constraint \&#34;product_label_key\&#34;&#34; (Just &#34;Key (label)=(Duplicate screw) already exists.&#34;) Nothing Nothing))&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;Core readme has a good overview and example. The library has simple docs, a couple of tutorials, and talks from the author.&lt;/p&gt; &#xA;&lt;h3&gt;Migrations&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tvh/hasql-migration&#34;&gt;hasql-migrations&lt;/a&gt; tool is a port of &lt;code&gt;postgresql-simple-migration&lt;/code&gt; for use with &lt;code&gt;hasql&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;In summary&lt;/h3&gt; &#xA;&lt;p&gt;Overall, &lt;code&gt;hasql&lt;/code&gt; is a great choice for writing raw sql queries with more type safety and compile-time syntax checks. The&amp;nbsp;ecosystem comes with other whistles like connection pools and transactions.&lt;/p&gt; &#xA;&lt;p&gt;The TemplateHaskell module and compile-time checks are optional ‚Äî if you want, you can deal with the encoders and decoders yourself.&lt;/p&gt; &#xA;&lt;p&gt;The library requires basic/intermediate knowledge of Haskell and ecosystems. To be comfortable and productive, you must be familiar with vectors, contravariant functors, etc. Other than that, the library is relatively straightforward.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;persistent&lt;/code&gt; + &lt;code&gt;esqueleto&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;If that was not enough, it‚Äôs time to move to the type level.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;According to the readme, &lt;em&gt;‚Äù&lt;a href=&#34;https://github.com/yesodweb/persistent&#34;&gt;Persistent&#39;s&lt;/a&gt; goal is to catch every possible error at compile-time, and it comes close to that.&lt;/em&gt; It is also &lt;em&gt;designed to be adaptable to any datastore‚Äù&lt;/em&gt;. As a result, &lt;em&gt;‚Äùa major limitation for SQL databases is that the persistent library does not directly provide joins‚Äù&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, we can use&amp;nbsp;&lt;a href=&#34;http://hackage.haskell.org/package/esqueleto&#34;&gt;Esqueleto&lt;/a&gt;&amp;nbsp;(&lt;em&gt;‚Äùa bare bones, type-safe EDSL for SQL queries‚Äù&lt;/em&gt;) with Persistent&#39;s serialization to write type-safe SQL queries. It‚Äôs unlikely that you want to use Persistent by itself with SQL, so let‚Äôs use and review them together.&lt;/p&gt; &#xA;&lt;p&gt;We‚Äôre using &lt;a href=&#34;https://hackage.haskell.org/package/persistent&#34;&gt;&lt;code&gt;persistent&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;2.14.5.1&lt;/code&gt;), &lt;a href=&#34;https://hackage.haskell.org/package/persistent-postgresql&#34;&gt;&lt;code&gt;persistent-postgresql&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;2.13.5.2&lt;/code&gt;), and &lt;a href=&#34;https://hackage.haskell.org/package/esqueleto&#34;&gt;&lt;code&gt;esqueleto&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;3.5.10.1&lt;/code&gt;), all published in 2023. Additionally, we‚Äôll use the &lt;strong&gt;experimental&lt;/strong&gt; style, which will become the new &#34;default&#34; in &lt;code&gt;esqueleto-4.0.0.0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We‚Äôll also use &lt;code&gt;mtl&lt;/code&gt;, &lt;code&gt;monad-logger&lt;/code&gt;, &lt;code&gt;unliftio-core&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, and &lt;code&gt;exceptions&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The libraries require additional extensions: &lt;code&gt;DataKinds&lt;/code&gt;, &lt;code&gt;GADTs&lt;/code&gt;, &lt;code&gt;TypeFamilies&lt;/code&gt;, and &lt;code&gt;UndecidableInstances&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;(It‚Äôs not very important, but) We assume you‚Äôve seen the part on &lt;code&gt;postgresql-simple&lt;/code&gt;, which covers the same topics but at a slower pace.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;How to connect to a database&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Database.Persist.Postgresql&lt;/code&gt; provides various ways to connect to postgres with and without a connection pool.&lt;/p&gt; &#xA;&lt;p&gt;First, we need a&amp;nbsp;&lt;code&gt;libpq&lt;/code&gt;&amp;nbsp;connection string, which looks like this &lt;code&gt;&#34;host=localhost port=5432 user=postgres dbname=warehouse password=password&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We create the pool and run actions on it using &lt;code&gt;withPostgresqlPool&lt;/code&gt; and passing the connection string, number of connections, and action(s) to be executed. We use &lt;code&gt;liftSqlPersistMPool&lt;/code&gt; to run an action/transaction on a pool. And ‚Äúfinally‚Äù, use &lt;code&gt;runNoLoggingT&lt;/code&gt; (&lt;code&gt;runStdoutLoggingT&lt;/code&gt;, or alternative) to run with appropriate logging.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;runNoLoggingT $ P.withPostgresqlPool Hardcoded.connectionString 3 $ \pool -&amp;gt; do&#xA;    le runWithPool = flip liftSqlPersistMPool pool&#xA;    runWithPool transaction1&#xA;    runWithPool transaction2&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;We can use &lt;code&gt;runStdoutLoggingT&lt;/code&gt;&amp;nbsp;to see what sql queries get executed.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;How to define tables&lt;/h3&gt; &#xA;&lt;p&gt;Persistent takes care of creating and matching Haskell datatypes and &lt;code&gt;PersistEntity&lt;/code&gt; instances; we need to declare the entities by passing them to &lt;code&gt;mkPersist&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mkPersist&#xA;  sqlSettings&#xA;  [persistLowerCase|&#xA;  Product&#xA;    label Text&#xA;    description Text Maybe&#xA;    UniqueLabel label&#xA;    deriving Eq Show&#xA;  Category&#xA;    label Text&#xA;    UniqueCategory label&#xA;    deriving Eq Show&#xA;  ProductCategory&#xA;    productId ProductId&#xA;    categoryId CategoryId&#xA;    Primary productId categoryId&#xA;    deriving Eq Show&#xA;  Warehouse&#xA;    productId ProductId&#xA;    quantity Int&#xA;    created UTCTime default=CURRENT_TIME&#xA;    modified UTCTime default=CURRENT_TIME&#xA;    deriving Eq Show&#xA;|]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;persistLowerCase&lt;/code&gt; states that &lt;code&gt;SomeTable&lt;/code&gt; corresponds to the SQL table &lt;code&gt;some_table&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How to modify data&lt;/h3&gt; &#xA;&lt;p&gt;Even though it‚Äôs not encouraged, we can always execute raw sql; for example, we can truncate tables with &lt;a href=&#34;https://hackage.haskell.org/package/esqueleto-3.5.10.3/docs/Database-Esqueleto-Experimental.html#v:rawExecute&#34;&gt;&lt;code&gt;rawExecute&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;cleanUp :: (MonadIO m) =&amp;gt; SqlPersistT m ()&#xA;cleanUp = rawExecute &#34;truncate warehouse, product_category, product, category&#34; []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What‚Äôs &lt;code&gt;SqlPersistT m ()&lt;/code&gt;? Let‚Äôs say it‚Äôs something that can be executed with &lt;code&gt;runWithPool&lt;/code&gt; and returns &lt;code&gt;()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;üí°&amp;nbsp;Note that we can also use &lt;code&gt;deleteWhere&lt;/code&gt; to delete all the records from a table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;deleteWhere ([] :: [Filter Product]))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Because we‚Äôve done all the groundwork, we use records right away (no tuples):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertStuff :: (MonadIO m) =&amp;gt; SqlPersistT m ()&#xA;insertStuff = do&#xA;  newId &amp;lt;- insert $ Product &#34;Wood Screw Kit 1&#34; (Just &#34;245-pieces&#34;)&#xA;  liftIO $ putStrLn $ &#34;Insert 1: &#34; &amp;lt;&amp;gt; show newId&#xA;&#xA;  newIds &amp;lt;- insertMany [Category &#34;Screws&#34;, Category &#34;Wood Screws&#34;, Category &#34;Concrete Screws&#34;]&#xA;  liftIO $ putStrLn $ &#34;Insert 2: &#34; &amp;lt;&amp;gt; show newIds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That‚Äôs it! Persistent is concise when it comes to inserts. Note that &lt;code&gt;insert&lt;/code&gt; returns the id, and &lt;code&gt;insertMany&lt;/code&gt; returns multiple ids.&lt;/p&gt; &#xA;&lt;p&gt;We can use &lt;code&gt;liftIO&lt;/code&gt; to execute &lt;code&gt;IO&lt;/code&gt; operations like printing ‚Äúinside‚Äù &lt;code&gt;SqlPersistT&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How to query data&lt;/h3&gt; &#xA;&lt;p&gt;This is the part where &lt;code&gt;esqueleto&lt;/code&gt; comes in.&lt;/p&gt; &#xA;&lt;p&gt;The first query takes a label and returns a list of product entities:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query1 :: Text -&amp;gt; SqlPersistT m [Entity Product]&#xA;query1 label = select $ do&#xA;  aProduct &amp;lt;- from $ table @Product&#xA;  where_ (aProduct.label ==. val label)&#xA;  pure aProduct&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It returns an&amp;nbsp;&lt;code&gt;Entity&lt;/code&gt;&amp;nbsp;instead of a value ‚Äî an&amp;nbsp;&lt;code&gt;Entity&lt;/code&gt;&amp;nbsp;combines a database id and a value.&lt;/p&gt; &#xA;&lt;p&gt;This is an experimental syntax that mimics sql. We use the &lt;code&gt;TypeApplications&lt;/code&gt; extensions to make the table explicit, &lt;code&gt;OverloadedRecordDot&lt;/code&gt; to select the field/column value, the &lt;code&gt;==.&lt;/code&gt; operator to check for equality, and &lt;code&gt;val&lt;/code&gt; to ‚Äúlift‚Äù haskell value into ‚Äúsql query land‚Äù.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí° Note that there are other alternatives for field projections (instead of &lt;code&gt;OverloadedRecordDot&lt;/code&gt;), such as the &lt;code&gt;(^.)&lt;/code&gt; operator and &lt;code&gt;OverloadedLabels&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We can select multiple labels using &lt;code&gt;in_&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query2 :: [Text] -&amp;gt; SqlPersistT m [Entity Product]&#xA;query2 lables = select $ do&#xA;  aProduct &amp;lt;- from $ table @Product&#xA;  where_ $ aProduct.label `in_` valList lables&#xA;  pure aProduct&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to use transactions&lt;/h3&gt; &#xA;&lt;p&gt;We‚Äôve been kind-of using transactions all this time. Everything inside a &lt;strong&gt;single call&lt;/strong&gt; to&amp;nbsp;&lt;code&gt;liftSqlPersistMPool&lt;/code&gt; (and other versions, with and without pooling)&amp;nbsp;runs in a &lt;strong&gt;single transaction&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertWithTransaction :: (MonadIO m, MonadCatch m) =&amp;gt; SqlPersistT m ()&#xA;insertWithTransaction = handle (\(SomeException _) -&amp;gt; pure ()) $ do&#xA;  productId &amp;lt;- insert $ Product &#34;Drywall Screws Set&#34; (Just &#34;8000pcs&#34;)&#xA;  categoryId &amp;lt;- insert $ Category &#34;Drywall Screws&#34;&#xA;  time &amp;lt;- liftIO getCurrentTime&#xA;  _ &amp;lt;- insert_ $ Warehouse productId 10 time time&#xA;  _ &amp;lt;- insert_ $ ProductCategory productId categoryId&#xA;  liftIO $ putStrLn $ &#34;Insert with transaction&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This time, we handle exceptions (any &lt;code&gt;SomeException&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí° We generally want to split the queries into transactions and catch exceptions on each transaction. We dive deeper into error handling in the errors section.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;How to query using joins&lt;/h3&gt; &#xA;&lt;p&gt;And this is the part where experimental syntax comes in handy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query quantity = select $ do&#xA;  (warehouse :&amp;amp; aProduct :&amp;amp; _ :&amp;amp; category) &amp;lt;-&#xA;    from&#xA;      $ table @Warehouse&#xA;      `innerJoin` table @Product&#xA;      `on` do \(w :&amp;amp; p) -&amp;gt; w.productId ==. p.id&#xA;      `LeftOuterJoin` table @ProductCategory&#xA;      `on` do \(_ :&amp;amp; p :&amp;amp; pc) -&amp;gt; just p.id ==. pc.productId&#xA;      `LeftOuterJoin` table @Category&#xA;      `on` do \(_ :&amp;amp; _ :&amp;amp; pc :&amp;amp; c) -&amp;gt; pc.categoryId ==. c.id&#xA;  where_ (warehouse.quantity &amp;gt;. val quantity)&#xA;  pure $ (warehouse.quantity, aProduct.label, aProduct.description, category.label)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/esqueleto-3.5.10.3/docs/Database-Esqueleto-Experimental.html#v:on&#34;&gt;&lt;code&gt;on&lt;/code&gt;&lt;/a&gt;&amp;nbsp;clauses are attached directly to the relevant join. The&amp;nbsp;&lt;code&gt;ON&lt;/code&gt;&amp;nbsp;clause lambda has all the available tables ‚Äî only the tables we have already joined into are in scope.&lt;/p&gt; &#xA;&lt;p&gt;We use the&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/esqueleto-3.5.10.3/docs/Database-Esqueleto-Experimental.html#t::-38-&#34;&gt;&lt;code&gt;:&amp;amp;&lt;/code&gt;&lt;/a&gt;&amp;nbsp;operator to pattern match against the joined tables. We use&amp;nbsp;&lt;code&gt;_&lt;/code&gt;&amp;nbsp;placeholder to ignore the previous references to the table.&lt;/p&gt; &#xA;&lt;p&gt;This generates this query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT &#xA;  &#34;warehouse&#34;.&#34;quantity&#34;, &#xA;  &#34;product&#34;.&#34;label&#34;, &#xA;  &#34;product&#34;.&#34;description&#34;, &#xA;  &#34;category&#34;.&#34;label&#34; &#xA;FROM &#xA;  &#34;warehouse&#34; &#xA;  INNER JOIN &#34;product&#34; ON &#34;warehouse&#34;.&#34;product_id&#34; = &#34;product&#34;.&#34;id&#34; &#xA;  LEFT OUTER JOIN &#34;product_category&#34; ON &#34;product&#34;.&#34;id&#34; = &#34;product_category&#34;.&#34;product_id&#34; &#xA;  LEFT OUTER JOIN &#34;category&#34; ON &#34;product_category&#34;.&#34;category_id&#34; = &#34;category&#34;.&#34;id&#34; &#xA;WHERE &#xA;  &#34;warehouse&#34;.&#34;quantity&#34; &amp;gt; ?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Errors&lt;/h3&gt; &#xA;&lt;p&gt;It‚Äôs possible to write type-checked&amp;nbsp;queries that fail at runtime, but most typical sql errors are caught as compile-time errors.&lt;/p&gt; &#xA;&lt;p&gt;Sometimes, mistakes in queries will result in error messages that refer to library internals (for example, you might see &lt;code&gt;PersistUniqueRead backend0&lt;/code&gt;, &lt;code&gt;Database.Esqueleto.Internal.Internal.SqlExpr&lt;/code&gt;, &lt;code&gt;PersistRecordBackend backend val&lt;/code&gt;, &lt;code&gt;‚ÄòBaseBackend backend0‚Äô&lt;/code&gt;, &lt;code&gt;‚ÄòSqlBackend‚Äô&lt;/code&gt;). This takes some time to get used to. Help the type inference, and it will help you.&lt;/p&gt; &#xA;&lt;p&gt;Nobody is safe from runtime sql errors. For example, if we violate the uniqueness constraint, we get an exception that we need to deal with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;errors :: (MonadIO m, MonadCatch m) =&amp;gt; SqlPersistT m ()&#xA;errors = do&#xA;  let duplicateScrew = Product &#34;Duplicate screw&#34; Nothing&#xA;  void $ insert duplicateScrew&#xA;  (void $ insert duplicateScrew)&#xA;    `catch` (\(SomeException err) -&amp;gt; liftIO $ putStrLn $ &#34;Caught SQL Error: &#34; &amp;lt;&amp;gt; displayException err)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;Caught SQL Error: SqlError {sqlState = &#34;23505&#34;, sqlExecStatus = FatalError, sqlErrorMsg = &#34;duplicate key value violates unique constraint \&#34;product_label_key\&#34;&#34;, sqlErrorDetail = &#34;Key (label)=(Duplicate screw) already exists.&#34;, sqlErrorHint = &#34;&#34;}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Note that we use the&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/exceptions&#34;&gt;exceptions&lt;/a&gt;&amp;nbsp;package to handle exceptions. (We don‚Äôt use the exceptions from&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/base-4.16.3.0/docs/Control-Exception.html&#34;&gt;Control.Exception&lt;/a&gt; as we did in &lt;code&gt;postgresql-simple&lt;/code&gt; because we don‚Äôt want to be limited to &lt;code&gt;IO&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;persistent&lt;/code&gt; is well documented as part of the &lt;a href=&#34;https://www.yesodweb.com/book/persistent&#34;&gt;yesod book&lt;/a&gt;, and &lt;code&gt;esqueleto&lt;/code&gt; has good readme and docs. The catch is that you have to keep an eye on multiple packages simultaneously.&lt;/p&gt; &#xA;&lt;p&gt;On top of that, (currently) &lt;code&gt;esqueleto&lt;/code&gt; supports legacy and experimental syntax, and you have to be aware that some tutorials and examples use less safe legacy syntax (or a mix of both) ‚Äî the good news is that the compiler will warn you if you‚Äôre on the wrong path.&lt;/p&gt; &#xA;&lt;h3&gt;Migrations&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;persistent&lt;/code&gt; can automatically create&amp;nbsp;tables and do migrations. However, the &lt;a href=&#34;https://www.yesodweb.com/book/persistent#persistent_migrations&#34;&gt;book&lt;/a&gt; discourages that:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;‚ÄúUsing automated database migrations is only recommended in development environments. Allowing your application to modify your database schema in a production environment is&amp;nbsp;very strongly discouraged.‚Äù&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;In summary&lt;/h3&gt; &#xA;&lt;p&gt;You should consider &lt;code&gt;persistent&lt;/code&gt; with &lt;code&gt;esqueleto&lt;/code&gt; if you mainly have a lot of simple queries, are tired of writing raw sql, but want moderately more type-safe and composable sql.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;persistent&lt;/code&gt; is a (very) generalized library, meaning you should be comfortable using abstractions. And you should be familiar with &lt;code&gt;mtl&lt;/code&gt;, &lt;code&gt;monad-logger&lt;/code&gt;, lifting/unlifting IO, and so on.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;‚ÄúMost kinds of errors committed when writing SQL are caught as compile-time errors ‚Äî although it is possible to write type-checked&amp;nbsp;&lt;code&gt;esqueleto&lt;/code&gt;&amp;nbsp;queries that fail at runtime‚Äù&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;If you look around, some tutorials and comparisons might say that &lt;code&gt;esqueleto&lt;/code&gt; joins might lead to to runtime errors. Don‚Äôt worry ‚Äî this refers to legacy syntax ‚Äî use new/experimental syntax.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;beam&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Tired of sql and Template Haskell?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://haskell-beam.github.io/beam/&#34;&gt;Beam&lt;/a&gt; ‚Äú&lt;em&gt;is a highly-general library for accessing any kind of database with Haskell‚Äù.&lt;/em&gt; Beam makes extensive use of GHC&#39;s Generics mechanism ‚Äî no Template Haskell.&lt;/p&gt; &#xA;&lt;p&gt;First, install &lt;a href=&#34;https://hackage.haskell.org/package/beam-core&#34;&gt;&lt;code&gt;beam-core&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;0.10.1.0&lt;/code&gt; released in 2023) and &lt;a href=&#34;https://hackage.haskell.org/package/beam-postgres&#34;&gt;&lt;code&gt;beam-postgres&lt;/code&gt;&lt;/a&gt;(&lt;code&gt;0.5.3.1&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;A few additional extensions: &lt;code&gt;GADTs&lt;/code&gt; and &lt;code&gt;TypeFamilies&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;beam-postgres&lt;/code&gt; is built on top of&amp;nbsp;&lt;code&gt;postgresql-simple&lt;/code&gt;, which is used for connection management, transaction support, serialization, and deserialization.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;We assume that you‚Äôve seen the part on &lt;code&gt;postgresql-simple&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;How to connect to a database&lt;/h3&gt; &#xA;&lt;p&gt;We use &lt;code&gt;postgresql-simple&lt;/code&gt; straight away. Reminder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;connectionInfo :: ConnectInfo&#xA;connectionInfo =&#xA;  defaultConnectInfo&#xA;    { connectHost = Hardcoded.host&#xA;    , connectDatabase = Hardcoded.database&#xA;    , connectUser = Hardcoded.user&#xA;    , connectPassword = Hardcoded.password&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Simple.withConnect connectionInfo $ \connection -&amp;gt; do&#xA;    doFoo connection&#xA;    doBar connection&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to define tables&lt;/h3&gt; &#xA;&lt;p&gt;Let‚Äôs look at the definition of the &lt;strong&gt;product&lt;/strong&gt; table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data ProductT f = Product&#xA;  { id :: Columnar f Int64&#xA;  , label :: Columnar f Text&#xA;  , description :: Columnar f (Maybe Text)&#xA;  }&#xA;  deriving (Generic)&#xA;  deriving anyclass (Beamable)&#xA;&#xA;type Product = ProductT Identity&#xA;deriving instance Show Product&#xA;&#xA;instance Table ProductT where&#xA;  data PrimaryKey ProductT f = ProductId (Columnar f Int64)&#xA;    deriving (Generic)&#xA;    deriving anyclass (Beamable)&#xA;  primaryKey = ProductId . (.id)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;ProductT&lt;/code&gt; is a beam table. All beam tables must implement the&amp;nbsp;&lt;code&gt;Beamable&lt;/code&gt;&amp;nbsp;typeclass (derived via generics) and the&amp;nbsp;&lt;code&gt;Table&lt;/code&gt;&amp;nbsp;typeclass. The &lt;code&gt;Table&lt;/code&gt; instance declares the type of primary keys for the table and a function that extracts them. We can use &lt;code&gt;Product&lt;/code&gt; to construct values of type &lt;code&gt;Product&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;For details, see &lt;a href=&#34;https://haskell-beam.github.io/beam/tutorials/tutorial1/&#34;&gt;beam tutorial&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;All the other tables look quite similar; see the &lt;a href=&#34;https://github.com/Zelenya/elephants&#34;&gt;repo&lt;/a&gt; for the rest of the boilerplate. One interesting bit is foreign keys / referencing other primary keys; for example, &lt;code&gt;product_id&lt;/code&gt; and &lt;code&gt;category_id&lt;/code&gt; in the mapping table look like are defined as &lt;code&gt;PrimaryKey ProductT f&lt;/code&gt; (not &lt;code&gt;Columnar f Int64&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data ProductCategoryT f = ProductCategory&#xA;  { product_id :: PrimaryKey ProductT f&#xA;  , category_id :: PrimaryKey CategoryT f&#xA;  }&#xA;  deriving (Generic)&#xA;  deriving anyclass (Beamable)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After declaring all the tables, we describe our database:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data WarehouseDb f = WarehouseDb&#xA;  { product :: f (TableEntity ProductT)&#xA;  , category :: f (TableEntity CategoryT)&#xA;  , product_category :: f (TableEntity ProductCategoryT)&#xA;  , warehouse :: f (TableEntity WarehouseT)&#xA;  }&#xA;  deriving (Generic)&#xA;  deriving anyclass (Database Postgres)&#xA;&#xA;warehouseDb :: DatabaseSettings Postgres WarehouseDb&#xA;warehouseDb =&#xA;  defaultDbSettings&#xA;    `withDbModification` dbModification&#xA;      { product_category =&#xA;          modifyTableFields&#xA;            tableModification&#xA;              { category_id = CategoryId (fieldNamed &#34;category_id&#34;)&#xA;              , product_id = ProductId (fieldNamed &#34;product_id&#34;)&#xA;              }&#xA;      , warehouse =&#xA;          modifyTableFields @WarehouseT&#xA;            tableModification&#xA;              { product_id = ProductId (fieldNamed &#34;product_id&#34;)&#xA;              }&#xA;      }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;WarehouseDb&lt;/code&gt; needs to define all the tables and an instance of &lt;code&gt;Database _&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;Note that you don‚Äôt need to hardcode &lt;code&gt;Postgres&lt;/code&gt; and can keep the database more generic.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If you don‚Äôt have an existing database, you might get away with only &lt;code&gt;defaultDbSettings&lt;/code&gt; as &lt;code&gt;DatabaseSettings&lt;/code&gt;. Beam can guess a lot about the tables if we follow their conventions. But we need to override a few generated table fields in our case.&lt;/p&gt; &#xA;&lt;p&gt;Remember that we have a couple of foreign keys? Beam adds a suffix &lt;code&gt;__id&lt;/code&gt; to these, meaning if we have a record field &lt;code&gt;product_id&lt;/code&gt;, generated queries will try to use the column &lt;code&gt;product_id__id&lt;/code&gt;. So, we must override these in the &lt;em&gt;product_category&lt;/em&gt;* mapping and &lt;strong&gt;warehouse&lt;/strong&gt; tables.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;See &lt;a href=&#34;https://haskell-beam.github.io/beam/user-guide/models/#defaults&#34;&gt;beam defaults&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;How to modify data&lt;/h3&gt; &#xA;&lt;p&gt;For raw queries, we can use &lt;code&gt;postgresql-simple&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;cleanUp :: Connection -&amp;gt; IO ()&#xA;cleanUp connection =&#xA;  void $ Simple.execute_ connection &#34;truncate warehouse, product_category, product, category&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let‚Äôs insert some products:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insert1 :: Connection -&amp;gt; IO ()&#xA;insert1 connection =&#xA;  runBeamPostgres connection&#xA;    $ runInsert&#xA;    $ insert (warehouseDb.product)&#xA;    $ insertValues&#xA;      [ Product 1 &#34;Wood Screw Kit 1&#34; (Just &#34;245-pieces&#34;)&#xA;      , Product 2 &#34;Wood Screw Kit 2&#34; Nothing&#xA;      ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We construct the statement using &lt;code&gt;insert&lt;/code&gt;, which accepts a table and values. We use&amp;nbsp;&lt;code&gt;insertValues&lt;/code&gt; to supply concrete values (including ids). &lt;code&gt;runInsert&lt;/code&gt; runs the statement (in&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/beam-core-0.10.1.0/docs/Database-Beam-Backend-SQL.html#t:MonadBeam&#34;&gt;&lt;code&gt;MonadBeam&lt;/code&gt;&lt;/a&gt;), which &lt;code&gt;runBeamPostgres&lt;/code&gt; executes using the given connection.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;Note that we can use &lt;code&gt;runBeamPostgresDebug putStrLn&lt;/code&gt; instead of &lt;code&gt;runBeamPostgres&lt;/code&gt; to see what sql queries get executed.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;code&gt;runInsert&lt;/code&gt; doesn‚Äôt return anything (no affected rows, no ids, nothing). When we want some confirmation back, we can use &lt;a href=&#34;https://hackage.haskell.org/package/beam-core-0.10.1.0/docs/Database-Beam-Backend-SQL-BeamExtensions.html#v:runInsertReturningList&#34;&gt;&lt;code&gt;runInsertReturningList&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insert2 :: Connection -&amp;gt; IO ()&#xA;insert2 connection = do&#xA;  result :: [Category] &amp;lt;-&#xA;    runBeamPostgres connection&#xA;      $ runInsertReturningList&#xA;      $ insert (warehouseDb.category)&#xA;      $ insertExpressions&#xA;        [ Category default_ &#34;Screws&#34;&#xA;        , Category default_ &#34;Wood Screws&#34;&#xA;        , Category default_ &#34;Concrete Screws&#34;&#xA;        ]&#xA;&#xA;  putStrLn $ &#34;Inserted categories: &#34; &amp;lt;&amp;gt; show result&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can use&amp;nbsp;&lt;code&gt;insertExpressions&lt;/code&gt;&amp;nbsp;function to insert arbitrary sql expressions. In this case, we pass &lt;code&gt;default_&lt;/code&gt; to ask the database to give us default ids.&lt;/p&gt; &#xA;&lt;h3&gt;How to query data&lt;/h3&gt; &#xA;&lt;p&gt;Instead of talking about &lt;code&gt;Q&lt;/code&gt; monads and &lt;code&gt;MonadBeam&lt;/code&gt;, let‚Äôs look at the examples. First, query all the products:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query1 :: (MonadBeam Postgres m) =&amp;gt; m [Product]&#xA;query1 = do&#xA;  let allProducts = all_ (warehouseDb.product)&#xA;  runSelectReturningList $ select allProducts&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;runBeamPostgres connection query&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Important bits:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;build a query;&lt;/li&gt; &#xA; &lt;li&gt;pass it into &lt;code&gt;select&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;run it in &lt;code&gt;MonadBeam&lt;/code&gt; (using &lt;code&gt;runSelectReturningList&lt;/code&gt;, &lt;code&gt;runSelectReturningOne&lt;/code&gt;, etc);&lt;/li&gt; &#xA; &lt;li&gt;execute using &lt;code&gt;runBeamPostgres connection&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example, to build a query, we can use &lt;code&gt;all_&lt;/code&gt; to introduce all entries of a table together with &lt;code&gt;guard_&lt;/code&gt; to filter the results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query2 label = runSelectReturningList $ select $ do&#xA;  aProduct &amp;lt;- all_ warehouseDb.product&#xA;  guard_ (aProduct.label ==. val_ label)&#xA;  pure (aProduct.label, aProduct.description)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;filter_&lt;/code&gt; is built on top of &lt;code&gt;guard_&lt;/code&gt; and allows us to use the &lt;code&gt;in_&lt;/code&gt; clause:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query3 labels =&#xA;  runSelectReturningList&#xA;    $ select&#xA;    $ filter_ (\p -&amp;gt; p.label `in_` predicate)&#xA;    $ all_ warehouseDb.product&#xA; where&#xA;  predicate = val_ &amp;lt;$&amp;gt; labels&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we use &lt;code&gt;val_&lt;/code&gt; to ‚Äúlift‚Äù haskell values into ‚Äúsql query land‚Äù.&lt;/p&gt; &#xA;&lt;h3&gt;How to use transactions&lt;/h3&gt; &#xA;&lt;p&gt;We use &lt;code&gt;postgresql-simple&lt;/code&gt; for transactions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertWithTransaction :: Connection -&amp;gt; IO ()&#xA;insertWithTransaction connection = Simple.withTransaction connection $ do&#xA;  [newProduct] :: [Product] &amp;lt;-&#xA;    runBeamPostgres connection&#xA;      $ runInsertReturningList&#xA;      $ insert (warehouseDb.product)&#xA;      $ insertExpressions [Product default_ &#34;Drywall Screws Set&#34; (just_ &#34;8000pcs&#34;)]&#xA;&#xA;  [newCategory] &amp;lt;-&#xA;    runBeamPostgres connection&#xA;      $ runInsertReturningList&#xA;      $ insert (warehouseDb.category)&#xA;      $ insertExpressions [Category default_ &#34;Drywall Screws&#34;]&#xA;&#xA;  runBeamPostgresDebug putStrLn connection&#xA;    $ runInsert&#xA;    $ insert (warehouseDb.product_category)&#xA;    $ insertValues [ProductCategory (pk newProduct) (pk newCategory)]&#xA;&#xA;  runBeamPostgres connection&#xA;    $ runInsert&#xA;    $ insert (warehouseDb.warehouse)&#xA;    $ insertExpressions [Warehouse default_ (val_ (pk newProduct)) 10 currentTimestamp_ currentTimestamp_]&#xA;&#xA;  putStrLn $ &#34;Insert with transaction&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use &lt;code&gt;currentTimestamp_&lt;/code&gt; to ask the database for the current time and &lt;code&gt;pk&lt;/code&gt; to get the entity&#39;s primary key. For example, we pass &lt;code&gt;pk newProduct&lt;/code&gt; into the &lt;code&gt;ProductCategory&lt;/code&gt; mapping.&lt;/p&gt; &#xA;&lt;h3&gt;How to query using joins&lt;/h3&gt; &#xA;&lt;p&gt;There are various ways to get data from multiple tables using Beam.&lt;/p&gt; &#xA;&lt;p&gt;For example, we can use &lt;code&gt;related_&lt;/code&gt; to get all entries of the given table referenced by the given primary key and &lt;code&gt;leftJoin_&lt;/code&gt; to introduce a table using a left join:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query1 quantity = runBeamPostgres connection&#xA;  $ runSelectReturningList&#xA;  $ select&#xA;  $ do&#xA;    warehouse &amp;lt;- all_ warehouseDb.warehouse&#xA;    aProduct &amp;lt;- related_ warehouseDb.product warehouse.product_id&#xA;    mapping &amp;lt;-&#xA;      leftJoin_&#xA;        (all_ warehouseDb.product_category)&#xA;        (\pc -&amp;gt; pc.product_id ==. primaryKey aProduct)&#xA;    category &amp;lt;-&#xA;      leftJoin_&#xA;        (all_ warehouseDb.category)&#xA;        (\c -&amp;gt; just_ (primaryKey c) ==. mapping.category_id)&#xA;    guard_ (warehouse.quantity &amp;gt;. quantity)&#xA;    pure (warehouse.quantity, aProduct.label, aProduct.description, category.label)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates the following query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;SELECT &#xA;  &#34;t0&#34;.&#34;quantity&#34; AS &#34;res0&#34;, &#xA;  &#34;t1&#34;.&#34;label&#34; AS &#34;res1&#34;, &#xA;  &#34;t1&#34;.&#34;description&#34; AS &#34;res2&#34;, &#xA;  &#34;t3&#34;.&#34;label&#34; AS &#34;res3&#34; &#xA;FROM &#xA;  &#34;warehouse&#34; AS &#34;t0&#34; &#xA;  INNER JOIN &#34;product&#34; AS &#34;t1&#34; ON (&#34;t0&#34;.&#34;product_id&#34;) = (&#34;t1&#34;.&#34;id&#34;) &#xA;  LEFT JOIN &#34;product_category&#34; AS &#34;t2&#34; ON (&#34;t2&#34;.&#34;product_id&#34;) = (&#34;t1&#34;.&#34;id&#34;) &#xA;  LEFT JOIN &#34;category&#34; AS &#34;t3&#34; ON (&#34;t3&#34;.&#34;id&#34;) IS NOT DISTINCT &#xA;FROM &#xA;  (&#34;t2&#34;.&#34;category_id&#34;) &#xA;WHERE &#xA;  (&#34;t0&#34;.&#34;quantity&#34;) &amp;gt; (3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also use the&amp;nbsp;&lt;a href=&#34;https://haskell-beam.github.io/beam/user-guide/queries/relationships/#many-to-many&#34;&gt;&lt;code&gt;manyToMany_&lt;/code&gt;&lt;/a&gt;&amp;nbsp;construct to fetch sides of a many-to-many relationship.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;productCategoryRelationship :: ManyToMany Postgres WarehouseDb ProductT CategoryT&#xA;productCategoryRelationship =&#xA;  manyToMany_ (warehouseDb.product_category) (.product_id) (.category_id)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query2 quantity = runBeamPostgres connection&#xA;  $ runSelectReturningList&#xA;  $ select&#xA;  $ do&#xA;    warehouse &amp;lt;- all_ warehouseDb.warehouse&#xA;    products &amp;lt;- related_ warehouseDb.product warehouse.product_id&#xA;    categories &amp;lt;- all_ warehouseDb.category&#xA;    (aProduct, category) &amp;lt;- productCategoryRelationship (pure products) (pure categories)&#xA;    guard_ (warehouse.quantity &amp;gt;. quantity)&#xA;    pure (warehouse.quantity, aProduct.label, aProduct.description, category.label)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates the following query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;SELECT &#xA;  &#34;t0&#34;.&#34;quantity&#34; AS &#34;res0&#34;, &#xA;  &#34;t1&#34;.&#34;label&#34; AS &#34;res1&#34;, &#xA;  &#34;t1&#34;.&#34;description&#34; AS &#34;res2&#34;, &#xA;  &#34;t2&#34;.&#34;label&#34; AS &#34;res3&#34; &#xA;FROM &#xA;  &#34;warehouse&#34; AS &#34;t0&#34; &#xA;  INNER JOIN &#34;product&#34; AS &#34;t1&#34; ON (&#34;t0&#34;.&#34;product_id&#34;) = (&#34;t1&#34;.&#34;id&#34;) &#xA;  CROSS JOIN &#34;category&#34; AS &#34;t2&#34; &#xA;  INNER JOIN &#34;product_category&#34; AS &#34;t3&#34; ON (&#xA;    (&#34;t3&#34;.&#34;product_id&#34;) = (&#34;t1&#34;.&#34;id&#34;)&#xA;  ) &#xA;  AND (&#xA;    (&#34;t3&#34;.&#34;category_id&#34;) = (&#34;t2&#34;.&#34;id&#34;)&#xA;  ) &#xA;WHERE &#xA;  (&#34;t0&#34;.&#34;quantity&#34;) &amp;gt; (3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Errors&lt;/h3&gt; &#xA;&lt;p&gt;It‚Äôs not possible to write an invalid sql query, but this comes at a cost ‚Äî compile-time errors.&lt;/p&gt; &#xA;&lt;p&gt;For example, once we forgot to pass a parameter, and this resulted in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Couldn&#39;t match expected type: Q Postgres&#xA;                                    WarehouseDb&#xA;                                    QBaseScope&#xA;                                    a0&#xA;                with actual type: Q Postgres&#xA;                                    WarehouseDb&#xA;                                    s0&#xA;                                    (ProductT (QExpr Postgres s0))&#xA;                                  -&amp;gt; Q Postgres WarehouseDb s0 (CategoryT (QExpr Postgres s0))&#xA;                                  -&amp;gt; Q Postgres&#xA;                                       WarehouseDb&#xA;                                       s0&#xA;                                       (ProductT (QExpr Postgres s0),&#xA;                                       CategoryT (QExpr Postgres s0))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Runtime sql errors are still there, re-exported from &lt;code&gt;postgresql-simple&lt;/code&gt;. Review the relevant error section if you need a reminder.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;errors :: Connection -&amp;gt; IO ()&#xA;errors connection = do&#xA;  insertDuplicateScrew&#xA;  insertDuplicateScrew&#xA;    `catch` (\err@SqlError{} -&amp;gt; putStrLn $ &#34;Caught SQL Error: &#34; &amp;lt;&amp;gt; displayException err)&#xA; where&#xA;  insertDuplicateScrew =&#xA;    runBeamPostgres connection&#xA;      $ runInsert&#xA;      $ insert (warehouseDb.product)&#xA;      $ insertExpressions [Product default_ &#34;Duplicate screw&#34; nothing_]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;Caught SQL Error: SqlError {sqlState = &#34;23505&#34;, sqlExecStatus = FatalError, sqlErrorMsg = &#34;duplicate key value violates unique constraint \&#34;product_label_key\&#34;&#34;, sqlErrorDetail = &#34;Key (label)=(Duplicate screw) already exists.&#34;, sqlErrorHint = &#34;&#34;}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;Beam has you covered ‚Äî it comes with an overview, quick-start guide, tutorial, user guide, and hackage docs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Spoiler alert: Beam is likely the best-documented library reviewed in this tutorial.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Migrations&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;beam-migrate&lt;/code&gt;&amp;nbsp;package provides a migrations framework.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;‚ÄúThe&amp;nbsp;&lt;code&gt;beam-migrate&lt;/code&gt;&amp;nbsp;tool can generate a beam schema from a pre-existing database, manage migrations for several production databases, automatically generate migrations between two schemas, and much more.‚Äù&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;In summary&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;beam&lt;/code&gt; states that if the query compiles, it will generate proper code. Beam uses the GHC Haskell type system and nothing else ‚Äî no Template Haskell. You don‚Äôt have to write raw sql or sql like code. After defining some boilerplate, you write and compose queries in a straightforward Haskell style and get valid SQL.&lt;/p&gt; &#xA;&lt;p&gt;Regarding complexity, let the types do the talking:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt; manyToMany_&#xA;  :: ( Database be db, Table joinThrough&#xA;     , Table left, Table right&#xA;     , Sql92SelectSanityCheck syntax&#xA;     , IsSql92SelectSyntax syntax&#xA;     , SqlEq (QExpr (Sql92SelectExpressionSyntax syntax) s) (PrimaryKey left (QExpr (Sql92SelectExpressionSyntax syntax) s))&#xA;     , SqlEq (QExpr (Sql92SelectExpressionSyntax syntax) s) (PrimaryKey right (QExpr (Sql92SelectExpressionSyntax syntax) s)) )&#xA;  =&amp;gt; DatabaseEntity be db (TableEntity joinThrough)&#xA;  -&amp;gt; (joinThrough (QExpr (Sql92SelectExpressionSyntax syntax) s) -&amp;gt; PrimaryKey left (QExpr (Sql92SelectExpressionSyntax syntax) s))&#xA;  -&amp;gt; (joinThrough (QExpr (Sql92SelectExpressionSyntax syntax) s) -&amp;gt; PrimaryKey right (QExpr (Sql92SelectExpressionSyntax syntax) s))&#xA;  -&amp;gt; Q syntax db s (left (QExpr (Sql92SelectExpressionSyntax syntax) s)) -&amp;gt; Q syntax db s (right (QExpr (Sql92SelectExpressionSyntax syntax) s))&#xA;  -&amp;gt; Q syntax db s (left (QExpr (Sql92SelectExpressionSyntax syntax) s), right (QExpr (Sql92SelectExpressionSyntax syntax) s))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;squeal&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Okay, what if we did something quite similar but quite different?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/squeal-postgresql&#34;&gt;Squeal&lt;/a&gt; &lt;em&gt;‚Äúis a type-safe embedding of PostgreSQL in Haskell‚Äù&lt;/em&gt;, which means &lt;em&gt;‚Äúthat Squeal embeds both SQL terms and SQL types into Haskell at the term and type levels respectively. This leads to a very high level of type-safety‚Äù.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://hackage.haskell.org/package/squeal-postgresql&#34;&gt;&lt;code&gt;squeal-postgresql&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;0.9.1.3&lt;/code&gt; released in 2023) and &lt;a href=&#34;https://hackage.haskell.org/package/generics-sop&#34;&gt;&lt;code&gt;generics-sop&lt;/code&gt;&lt;/a&gt;, which the library uses for generic encodings of Haskell tuples and records.&lt;/p&gt; &#xA;&lt;p&gt;Enable: &lt;code&gt;DataKinds&lt;/code&gt;, &lt;code&gt;GADTs&lt;/code&gt;, and &lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;(It‚Äôs not very important, but) We assume you‚Äôve seen the part on postgresql-simple, which covers the same topics but at a slower pace.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;How to connect to a database&lt;/h3&gt; &#xA;&lt;p&gt;We pass &lt;code&gt;libpq&lt;/code&gt;&amp;nbsp;connection string (e.g., &lt;code&gt;&#34;host=localhost port=5432 user=postgres dbname=warehouse password=password&#34;&lt;/code&gt;) to &lt;code&gt;withConnection&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;withConnection Hardcoded.connectionString $ &#xA;  doFoo &#xA;    &amp;amp; pqThen doBar&#xA;    &amp;amp; pqThen doBaz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also create a connection pool using&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/squeal-postgresql-0.9.1.3/docs/Squeal-PostgreSQL-Session-Pool.html#v:createConnectionPool&#34;&gt;&lt;code&gt;createConnectionPool&lt;/code&gt;&lt;/a&gt;&amp;nbsp;and use the pool with&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/squeal-postgresql-0.9.1.3/docs/Squeal-PostgreSQL-Session-Pool.html#v:usingConnectionPool&#34;&gt;&lt;code&gt;usingConnectionPool&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How to define tables&lt;/h3&gt; &#xA;&lt;p&gt;First, we define table columns and constraints:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type ProductColumns =&#xA;  &#39;[ &#34;id&#34; ::: &#39;Def :=&amp;gt; &#39;NotNull &#39;PGint4&#xA;   , &#34;label&#34; ::: &#39;NoDef :=&amp;gt; &#39;NotNull &#39;PGtext&#xA;   , &#34;description&#34; ::: &#39;NoDef :=&amp;gt; &#39;Null &#39;PGtext&#xA;   ]&#xA;&#xA;type ProductConstraints = &#39;[&#34;pk_product&#34; ::: &#39;PrimaryKey &#39;[&#34;id&#34;]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;&#39;Def&lt;/code&gt; means that &lt;code&gt;DEFAULT&lt;/code&gt;&amp;nbsp;is available for inserts and updates, &lt;code&gt;&#39;NoDef&lt;/code&gt; ‚Äî unavailable. We specify nullability with &lt;code&gt;&#39;NotNull&lt;/code&gt; and &lt;code&gt;&#39;Null&lt;/code&gt; and the primary key with &lt;code&gt;&#39;PrimaryKey&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We use the &lt;code&gt;:::&lt;/code&gt; type operators to pair a&amp;nbsp;&lt;code&gt;Symbol&lt;/code&gt;&amp;nbsp;with schema types, constraints, column types, etc. We use &lt;code&gt;:=&amp;gt;&lt;/code&gt;&amp;nbsp;to specify&amp;nbsp;constraints as well as optionality.&lt;/p&gt; &#xA;&lt;p&gt;All the other tables look pretty similar (with additional &lt;code&gt;&#39;ForeignKey&lt;/code&gt; constraints here and there); see the &lt;a href=&#34;https://github.com/Zelenya/elephants&#34;&gt;repo&lt;/a&gt; for the rest of the boilerplate.&lt;/p&gt; &#xA;&lt;p&gt;Then, we define a schema:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Schema =&#xA;  &#39;[ &#34;product&#34; ::: &#39;Table (ProductConstraints :=&amp;gt; ProductColumns)&#xA;   , &#34;category&#34; ::: &#39;Table (CategoryConstraints :=&amp;gt; CategoryColumns)&#xA;   , &#34;product_category&#34; ::: &#39;Table (ProductCategoryConstraints :=&amp;gt; ProductCategoryColumns)&#xA;   , &#34;warehouse&#34; ::: &#39;Table (WarehouseConstraints :=&amp;gt; WarehouseColumns)&#xA;   ]&#xA;&#xA;type DB = Public Schema&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use generics to convert between Haskell and PostgreSQL values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import qualified Generics.SOP as SOP&#xA;import qualified GHC.Generics as GHC&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data BasicProduct = BasicProduct {label :: Text, description :: Maybe Text}&#xA;  deriving stock (Show, GHC.Generic)&#xA;  deriving anyclass (SOP.Generic, SOP.HasDatatypeInfo)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;SOP.Generic&lt;/code&gt;&amp;nbsp;and&amp;nbsp;&lt;code&gt;SOP.HasDatatypeInfo&lt;/code&gt;&amp;nbsp;instances allow us to encode and decode&amp;nbsp;&lt;code&gt;BasicProduct&lt;/code&gt;s.&lt;/p&gt; &#xA;&lt;h3&gt;How to modify data&lt;/h3&gt; &#xA;&lt;p&gt;We can execute raw statements:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;cleanUp :: PQ DB DB IO ()&#xA;cleanUp =&#xA;  execute_ teardown&#xA; where&#xA;  teardown :: Statement db () ()&#xA;  teardown = manipulation $ UnsafeManipulation &#34;truncate warehouse, product_category, product, category&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Manipulation&lt;/code&gt; represents&amp;nbsp;update, insert, and delete statements.&lt;/p&gt; &#xA;&lt;p&gt;We can specify the schema changes by using&amp;nbsp;concrete &lt;code&gt;PQ&lt;/code&gt;; when the schema doesn&#39;t change, we can use&amp;nbsp;&lt;code&gt;MonadPQ&lt;/code&gt;&amp;nbsp;constraint (e.g., &lt;code&gt;cleanUp :: (MonadPQ DB m) =&amp;gt; m ())&lt;/code&gt;. In the end, we‚Äôll turn either into &lt;code&gt;IO&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;withConnection Hardcoded.connectionString&#xA;  $ cleanUp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let‚Äôs insert a product:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertProduct :: Statement DB BasicProduct ()&#xA;insertProduct =&#xA;  manipulation&#xA;    $ insertInto_&#xA;      #product&#xA;      (Values_ (Default `as` #id :* Set (param @1) `as` #label :* Set (param @2) `as` #description))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/squeal-postgresql-0.9.1.3/docs/Squeal-PostgreSQL-Session-Statement.html#t:Statement&#34;&gt;&lt;code&gt;Statement&lt;/code&gt;&lt;/a&gt;&amp;nbsp;is either a&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/squeal-postgresql-0.9.1.3/docs/Squeal-PostgreSQL-Statement.html#v:Manipulation&#34;&gt;&lt;code&gt;Manipulation&lt;/code&gt;&lt;/a&gt;&amp;nbsp;or a&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/squeal-postgresql-0.9.1.3/docs/Squeal-PostgreSQL-Session-Statement.html#v:Query&#34;&gt;&lt;code&gt;Query&lt;/code&gt;&lt;/a&gt;&amp;nbsp;that can be run in a&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/squeal-postgresql-0.9.1.3/docs/Squeal-PostgreSQL-Session-Monad.html#v:MonadPQ&#34;&gt;&lt;code&gt;MonadPQ&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We use &lt;code&gt;manipulation&lt;/code&gt; and &lt;code&gt;insertInto_&lt;/code&gt; to construct an insert. We pass a table and what to insert. &lt;code&gt;Values_&lt;/code&gt; describes a single &lt;a href=&#34;https://hackage.haskell.org/package/squeal-postgresql-0.9.1.3/docs/Squeal-PostgreSQL-Type-List.html#t:NP&#34;&gt;n-ary product&lt;/a&gt;, where we must match all the columns. We can use &lt;code&gt;Default&lt;/code&gt; value for id and set the rest using relevant parameters.&lt;/p&gt; &#xA;&lt;p&gt;And then, we use &lt;a href=&#34;https://hackage.haskell.org/package/squeal-postgresql-0.9.1.3/docs/Squeal-PostgreSQL-Session-Monad.html#v:executePrepared_&#34;&gt;&lt;code&gt;executePrepared_&lt;/code&gt;&lt;/a&gt;&amp;nbsp;to run a statement that returns nothing. The function prepares the statement and runs it on each element.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertStuff :: (MonadPQ DB m) =&amp;gt; m ()&#xA;insertStuff = do&#xA;  executePrepared_&#xA;    insertProduct&#xA;    [ BasicProduct &#34;Wood Screw Kit 1&#34; (Just &#34;245-pieces&#34;)&#xA;    , BasicProduct &#34;Wood Screw Kit 2&#34; Nothing&#xA;    ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;insertInto_&lt;/code&gt; is a specialized version of &lt;code&gt;insertInto&lt;/code&gt; with&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/squeal-postgresql-0.9.1.3/docs/Squeal-PostgreSQL-Manipulation-Insert.html#v:OnConflictDoRaise&#34;&gt;&lt;code&gt;OnConflictDoRaise&lt;/code&gt;&lt;/a&gt;&amp;nbsp;(what to do in case of conflict) and no&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/squeal-postgresql-0.9.1.3/docs/Squeal-PostgreSQL-Manipulation.html#t:ReturningClause&#34;&gt;&lt;code&gt;ReturningClause&lt;/code&gt;&lt;/a&gt; (what to return). &lt;code&gt;ReturningClause&lt;/code&gt; returns a value based on each row; for example, we can use it to return the created &lt;code&gt;id&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertCategory :: Statement DB Category (Only Int32)&#xA;insertCategory =&#xA;  manipulation&#xA;    $ insertInto&#xA;      #category&#xA;      (Values_ (Default `as` #id :* Set (param @1) `as` #label))&#xA;      OnConflictDoRaise&#xA;      (Returning_ (#id `as` #fromOnly))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we have to use &lt;code&gt;Only&lt;/code&gt; and &lt;code&gt;#fromOnly&lt;/code&gt;, because we can‚Äôt use primitive types (because they don‚Äôt have named labels that the library relies on).&lt;/p&gt; &#xA;&lt;p&gt;This time we have to use &lt;code&gt;executePrepared&lt;/code&gt;, which returns a list of results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertStuff :: (MonadPQ DB m, MonadIO m) =&amp;gt; m ()&#xA;insertStuff = do&#xA;  result :: [Result (Only Int32)] &amp;lt;-&#xA;    executePrepared insertCategory [Category &#34;Screws&#34;, Category &#34;Wood Screws&#34;, Category &#34;Concrete Screws&#34;]&#xA;  rows &amp;lt;- traverse getRows result&#xA;  liftIO $ putStrLn $ &#34;Inserted categories: &#34; &amp;lt;&amp;gt; show rows&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use &lt;code&gt;getRows&lt;/code&gt; to get all rows from a &lt;code&gt;Result&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How to query data&lt;/h3&gt; &#xA;&lt;p&gt;To retrieve data, we also write &lt;code&gt;Statement&lt;/code&gt;s, this time using &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;select_&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query1 :: Statement DB () BasicProduct&#xA;query1 =&#xA;  query&#xA;    $ select_&#xA;      (#product ! #label :* #product ! #description)&#xA;      (from (table #product))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The query returns all the products from the table.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;Note that we can use &lt;code&gt;printSQL&lt;/code&gt; to print statements and see what sql queries get executed.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;üí°&amp;nbsp;We &lt;strong&gt;can‚Äôt&lt;/strong&gt; return tuples or primitive types because they don&#39;t have named fields. You must define a new datatype and derive Squeal typeclasses to return something new.&lt;/p&gt; &#xA;&lt;p&gt;If you try using tuples, you get an error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;The type `(Text, Text)&#39; is not a record type.&#xA;It has no labelled fields.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;And then we &lt;code&gt;execute&lt;/code&gt; the query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertStuff :: (MonadPQ DB m, MonadIO m) =&amp;gt; m ()&#xA;insertStuff = do&#xA;  result1 &amp;lt;- execute query1&#xA;  rows1 &amp;lt;- getRows result1&#xA;  liftIO $ putStrLn $ &#34;Query 1: &#34; &amp;lt;&amp;gt; show rows1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can select specific fields and narrow down the results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query2 :: Statement DB (Only Text) BasicProduct&#xA;query2 =&#xA;  query&#xA;    $ select_&#xA;      (#product ! #label :* #product ! #description)&#xA;      (from (table #product) &amp;amp; where_ (#product ! #label .== (param @1)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use &lt;code&gt;where_&lt;/code&gt; to filter the rows and &lt;code&gt;.==&lt;/code&gt; to compare for equality.&lt;/p&gt; &#xA;&lt;p&gt;This time, we use &lt;code&gt;executeParams&lt;/code&gt; to pass the parameters into the statement:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;queryData :: PQ DB DB IO ()&#xA;queryData = do&#xA;  result2 &amp;lt;- executeParams query2 (Only &#34;Wood Screw Kit 1&#34;) &amp;gt;&amp;gt;= getRows&#xA;  liftIO $ putStrLn $ &#34;Query 2: &#34; &amp;lt;&amp;gt; show result2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also use &lt;code&gt;in_&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query3 labels =&#xA;  query&#xA;    $ select_&#xA;      (#product ! #label :* #product ! #description)&#xA;      (from (table #product) &amp;amp; where_ (#product ! #label `in_` labels))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;do&#xA;  (result3 :: [BasicProduct]) &amp;lt;- execute (query3 [&#34;Wood Screw Kit 2&#34;, &#34;Wood Screw Kit 3&#34;]) &amp;gt;&amp;gt;= getRows&#xA;  liftIO $ putStrLn $ &#34;Query 3: &#34; &amp;lt;&amp;gt; show result3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to use transactions&lt;/h3&gt; &#xA;&lt;p&gt;We can wrap computation in &lt;code&gt;transactionally_&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertWithTransaction :: PQ DB DB IO ()&#xA;insertWithTransaction =&#xA;  transactionally_&#xA;    ( do&#xA;        result1 &amp;lt;- executePrepared insertProduct [BasicProduct &#34;Drywall Screws Set&#34; (Just &#34;8000pcs&#34;)]&#xA;        productIds &amp;lt;- join &amp;lt;$&amp;gt; traverse getRows result1&#xA;&#xA;        result2 &amp;lt;- executePrepared insertCategory [Category &#34;Drywall Screws&#34;]&#xA;        categoryIds &amp;lt;- join &amp;lt;$&amp;gt; traverse getRows result2&#xA;&#xA;        case (productIds, categoryIds) of&#xA;          ([Only productId], [Only categoryId]) -&amp;gt; do&#xA;            executePrepared_ insertProductCategory [(productId, categoryId)]&#xA;            executePrepared_ insertListing [(productId, 10)]&#xA;          _ -&amp;gt;&#xA;            throwM $ userError &#34;Failed to insert product/category&#34;&#xA;    )&#xA;    &amp;gt;&amp;gt; liftIO (putStrLn $ &#34;Insert with transaction&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case of exception, it rollbacks the transaction and rethrows the exception.&lt;/p&gt; &#xA;&lt;h3&gt;How to query using joins&lt;/h3&gt; &#xA;&lt;p&gt;We use &lt;code&gt;innerJoin&lt;/code&gt; and &lt;code&gt;leftOuterJoin&lt;/code&gt; to join the tables:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query1 :: Statement DB (Only Int32) Listing&#xA;query1 =&#xA;  query&#xA;    $ select_&#xA;      (#w ! #quantity `as` #quantity :* #p ! #label `as` #label :* #p ! #description `as` #description :* #c ! #label `as` #category)&#xA;      ( from&#xA;          ( table (#warehouse `as` #w)&#xA;              &amp;amp; innerJoin&#xA;                (table (#product `as` #p))&#xA;                (#w ! #product_id .== #p ! #id)&#xA;              &amp;amp; leftOuterJoin&#xA;                (table (#product_category `as` #pc))&#xA;                (#pc ! #product_id .== #p ! #id)&#xA;              &amp;amp; leftOuterJoin&#xA;                (table (#category `as` #c))&#xA;                (#c ! #id .== #pc ! #category_id)&#xA;          )&#xA;          &amp;amp; where_ (#w ! #quantity .&amp;gt; (param @1))&#xA;      )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT &#34;w&#34;.&#34;quantity&#34;    AS &#34;quantity&#34;,&#xA;       &#34;p&#34;.&#34;label&#34;       AS &#34;label&#34;,&#xA;       &#34;p&#34;.&#34;description&#34; AS &#34;description&#34;,&#xA;       &#34;c&#34;.&#34;label&#34;       AS &#34;category&#34;&#xA;FROM   &#34;warehouse&#34; AS &#34;w&#34;&#xA;       inner join &#34;product&#34; AS &#34;p&#34;&#xA;               ON ( &#34;w&#34;.&#34;product_id&#34; = &#34;p&#34;.&#34;id&#34; )&#xA;       left outer join &#34;product_category&#34; AS &#34;pc&#34;&#xA;                    ON ( &#34;pc&#34;.&#34;product_id&#34; = &#34;p&#34;.&#34;id&#34; )&#xA;       left outer join &#34;category&#34; AS &#34;c&#34;&#xA;                    ON ( &#34;c&#34;.&#34;id&#34; = &#34;pc&#34;.&#34;category_id&#34; )&#xA;WHERE  ( &#34;w&#34;.&#34;quantity&#34; &amp;gt; ( $1 :: int4 ) )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Errors&lt;/h3&gt; &#xA;&lt;p&gt;If you forget or mistype anything, most of the time, the error messages are rarely simple.&lt;/p&gt; &#xA;&lt;p&gt;Sometimes, they overwhelm:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;_ :: NP&#xA;(Aliased&#xA;(Optional&#xA;(Expression&#xA;&#39;Ungrouped&#xA;&#39;[]&#xA;&#39;[]&#xA;&#39;[&#34;public&#34;&#xA;::: &#39;[&#34;product&#34; ::: &#39;Table (ProductConstraints :=&amp;gt; ProductColumns),&#xA;&#34;category&#34; ::: &#39;Table (CategoryConstraints :=&amp;gt; CategoryColumns),&#xA;&#34;product_category&#34;&#xA;::: &#39;Table (ProductCategoryConstraints :=&amp;gt; ProductCategoryColumns),&#xA;&#34;warehouse&#34;&#xA;::: &#39;Table (WarehouseConstraints :=&amp;gt; WarehouseColumns)]]&#xA;&#39;[ &#39;NotNull &#39;PGtext, &#39;Null &#39;PGtext]&#xA;from0)))&#xA;&#39;[&#34;description&#34; ::: (&#39;NoDef :=&amp;gt; &#39;Null &#39;PGtext)]&#xA;Where: ‚Äòfrom0‚Äô is an ambiguous type variable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sometimes, they leak:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Couldn&#39;t match type: TupleOf (TupleCodeOf Text (SOP.Code Text))&#xA;               with: null10 &#39;PGtext : xs0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Ambiguous type variable ‚Äòy0‚Äô arising from a use of ‚Äòmanipulation‚Äô&#xA;prevents the constraint ‚Äò(SOP.Generic y0)‚Äô from being solved.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Couldn&#39;t match type: &#39;[&#34;description&#34;&#xA;::: (&#39;NoDef :=&amp;gt; &#39;Null &#39;PGtext)]&#xA;with: &#39;[]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sometimes, they &lt;strong&gt;really&lt;/strong&gt; leak:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Couldn&#39;t match type: records-sop-0.1.1.1:Generics.SOP.Record.ExtractTypesFromRecordCode&#xA;                       (records-sop-0.1.1.1:Generics.SOP.Record.ToRecordCode_Datatype&#xA;                          y (SOP.DatatypeInfoOf y) (SOP.Code y))&#xA;                with: records-sop-0.1.1.1:Generics.SOP.Record.GetSingleton&#xA;                       (SOP.Code y)&#xA;  arising from a use of ‚Äòmanipulation‚Äô&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But when it comes to runtime SQL errors, the library provides a convenient &lt;code&gt;SquealException&lt;/code&gt; for exceptions that Squeal can throw and a nice API for working with them built on top of &lt;code&gt;exceptions&lt;/code&gt;. For example, we can use &lt;code&gt;catchSqueal&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;errors :: PQ DB DB IO ()&#xA;errors = do&#xA;  insertDuplicateScrew&#xA;  insertDuplicateScrew&#xA;    `catchSqueal` (\err -&amp;gt; liftIO $ putStrLn $ &#34;Caught Squeal/SQL Error: &#34; &amp;lt;&amp;gt; displayException err)&#xA; where&#xA;  insertDuplicateScrew = executePrepared_ insertProduct [BasicProduct &#34;Duplicate screw&#34; Nothing]&#xA;  insertProduct =&#xA;    manipulation&#xA;      $ insertInto_&#xA;        #product&#xA;        (Values_ (Default `as` #id :* Set (param @1) `as` #label :* Set (param @2) `as` #description))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;The library comes with a quickstart and &lt;a href=&#34;https://github.com/morphismtech/squeal/raw/dev/squeal-core-concepts-handbook.md&#34;&gt;Core Concepts Handbook&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Migrations&lt;/h3&gt; &#xA;&lt;p&gt;The library has a&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/squeal-postgresql-0.9.1.3/docs/Squeal-PostgreSQL-Session-Migration.html#t:Migration&#34;&gt;&lt;code&gt;Migration&lt;/code&gt;&lt;/a&gt;&amp;nbsp;module to change the database schema over time. They support linear, pure or impure, one-way or rewindable migrations.&lt;/p&gt; &#xA;&lt;h3&gt;In summary&lt;/h3&gt; &#xA;&lt;p&gt;Squeal is another type-safe postgres library not suitable for beginners. You should be comfortable working on the type level, reading generic-related errors, etc. The library uses generic encodings (&lt;a href=&#34;https://hackage.haskell.org/package/generics-sop&#34;&gt;&lt;code&gt;generics-sop&lt;/code&gt;&lt;/a&gt;) of records/tuples, which keep getting into the error messages.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;opaleye&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Okay, what if we did something quite similar but quite different?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Opaleye is &lt;em&gt;‚Äúan SQL-generating DSL targeting PostgreSQL. Allows Postgres queries to be written within Haskell in a typesafe and composable fashion‚Äù&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://hackage.haskell.org/package/opaleye&#34;&gt;&lt;code&gt;opaleye&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;0.10.1.0&lt;/code&gt; released in 2023) and &lt;code&gt;product-profunctors&lt;/code&gt;, which the library uses under the hood.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;opaleye&lt;/code&gt; is built on top of&amp;nbsp;&lt;code&gt;postgresql-simple&lt;/code&gt;, which is used for connection management, transaction support, serialization, and deserialization.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;We assume you‚Äôve seen the part on &lt;code&gt;postgresql-simple&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;How to connect to a database&lt;/h3&gt; &#xA;&lt;p&gt;We use &lt;code&gt;postgresql-simple&lt;/code&gt; straight away. Reminder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;connectionInfo :: ConnectInfo&#xA;connectionInfo =&#xA;  defaultConnectInfo&#xA;    { connectHost = Hardcoded.host&#xA;    , connectDatabase = Hardcoded.database&#xA;    , connectUser = Hardcoded.user&#xA;    , connectPassword = Hardcoded.password&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Simple.withConnect connectionInfo $ \connection -&amp;gt; do&#xA;    doFoo connection&#xA;    doBar connection&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to define tables&lt;/h3&gt; &#xA;&lt;p&gt;We define a table using the &lt;code&gt;table&lt;/code&gt; function ‚Äî specify the table name and the type of fields.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;warehouseTable ::&#xA;  Table&#xA;    (Maybe (Field SqlInt4), ProductIdField, Field SqlInt4, Maybe (Field SqlTimestamp), Maybe (Field SqlTimestamp))&#xA;    (Field SqlInt4, ProductIdField, Field SqlInt4, Field SqlTimestamp, Field SqlTimestamp)&#xA;warehouseTable =&#xA;  table &#34;warehouse&#34;&#xA;    $ p5&#xA;      ( tableField &#34;id&#34;&#xA;      , pProductId (ProductId (tableField &#34;product_id&#34;))&#xA;      , tableField &#34;quantity&#34;&#xA;      , tableField &#34;created&#34;&#xA;      , tableField &#34;modified&#34;&#xA;      )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Table&lt;/code&gt;&amp;nbsp;takes &lt;strong&gt;write fields&lt;/strong&gt; and &lt;strong&gt;view fields&lt;/strong&gt;; for example, the first parameter (&lt;code&gt;id&lt;/code&gt;) is auto-generated, so it‚Äôs optional on write (so we specify &lt;code&gt;Maybe (Field SqlInt4))&lt;/code&gt; but always there on view/read (so we specify &lt;code&gt;Field SqlInt4&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;p5&lt;/code&gt; is a tiny glue function from &lt;code&gt;product-profunctors&lt;/code&gt;; the number corresponds to the tuple arity (number of columns). &lt;em&gt;We don‚Äôt need to know more than that.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;tableField&lt;/code&gt; infers a required or an optional field depending on the write type.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;(We‚Äôll cover &lt;code&gt;ProductId&lt;/code&gt; a bit later)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;We can also use records instead of tuples; for example, for product:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Product&#39; a b c = Product {pId :: a, pLabel :: b, pDescription :: c}&#xA;type Product = Product&#39; ProductId Text (Maybe Text)&#xA;deriving instance Show Product&#xA;&#xA;type ProductFieldWrite = Product&#39; (ProductId&#39; (Maybe (Field SqlInt4))) (Field SqlText) (FieldNullable SqlText)&#xA;type ProductField = Product&#39; (ProductIdField) (Field SqlText) (FieldNullable SqlText)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note that we prefix field names because we‚Äôll have some derivable code that can‚Äôt handle duplicate record fields.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Product&#39;&lt;/code&gt; is polymorphic in all its fields. We‚Äôll use &lt;code&gt;Product&lt;/code&gt; in ‚Äúnormal‚Äù code and &lt;code&gt;ProductField&lt;/code&gt; when interacting with a database. Because &lt;strong&gt;id&lt;/strong&gt; is optional on write, we distinguish between &lt;code&gt;ProductFieldWrite&lt;/code&gt; and &lt;code&gt;ProductField&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We indicate nullable fields with &lt;code&gt;FieldNullable&lt;/code&gt;, which will be converted into &lt;code&gt;Maybe&lt;/code&gt; when executed.&lt;/p&gt; &#xA;&lt;p&gt;We need some typeclass instances, which we can get with Template Haskell:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;$(makeAdaptorAndInstance &#34;pProduct&#34; &#39;&#39;Product&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;üí°&amp;nbsp;If you‚Äôd rather write these by hand, see &lt;a href=&#34;https://hackage.haskell.org/package/product-profunctors/docs/Data-Profunctor-Product-TH.html&#34;&gt;Data.Profunctor.Product.TH&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;And then, we define the table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;productTable :: Table ProductFieldWrite ProductField&#xA;productTable =&#xA;  table &#34;product&#34;&#xA;    $ pProduct&#xA;      Product&#xA;        { pId = pProductId $ ProductId $ tableField &#34;id&#34;&#xA;        , pLabel = tableField &#34;label&#34;&#xA;        , pDescription = tableField &#34;description&#34;&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that instead of &lt;code&gt;pN&lt;/code&gt;, we use &lt;code&gt;pProduct&lt;/code&gt;, which we just generated with TH.&lt;/p&gt; &#xA;&lt;p&gt;The library‚Äôs basic tutorial suggests using newtypes for ids. For example, we use one for the product id:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype ProductId&#39; a = ProductId a&#xA;$(makeAdaptorAndInstance &#34;pProductId&#34; &#39;&#39;ProductId&#39;)&#xA;type ProductId = ProductId&#39; Int&#xA;deriving instance Show ProductId&#xA;&#xA;type ProductIdField = ProductId&#39; (Field SqlInt4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;See the &lt;a href=&#34;https://github.com/Zelenya/elephants&#34;&gt;repo&lt;/a&gt; for the rest of the boilerplate.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;How to modify data&lt;/h3&gt; &#xA;&lt;p&gt;For raw queries, we can use &lt;code&gt;postgresql-simple&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;cleanUp :: Connection -&amp;gt; IO ()&#xA;cleanUp connection =&#xA;  void $ Simple.execute_ connection &#34;truncate warehouse, product_category, product, category&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Otherwise, we create an insert by using &lt;code&gt;Insert&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insert1 :: Insert [ProductId]&#xA;insert1 =&#xA;  Insert&#xA;    { iTable = productTable&#xA;    , iRows =&#xA;        [ Product (ProductId Nothing) &#34;Wood Screw Kit 1&#34; (maybeToNullable Nothing)&#xA;        , Product (ProductId Nothing) &#34;Wood Screw Kit 2&#34; (maybeToNullable (Just &#34;245-pieces&#34;))&#xA;        ]&#xA;    , iReturning = rReturning (\(p :: ProductField) -&amp;gt; p.pId)&#xA;    , iOnConflict = Nothing&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We specify the tables, rows to be inserted, conflict-handling strategy, and what to return. In this case, we return product id using &lt;code&gt;rReturning&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;And then we run the insert with &lt;code&gt;runInsert&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertStuff :: Connection -&amp;gt; IO ()&#xA;insertStuff connection = do&#xA;  result1 &amp;lt;- runInsert connection insert1&#xA;  putStrLn $ &#34;Inserted products: &#34; &amp;lt;&amp;gt; show result1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we want to return the number of affected rows, we can use &lt;code&gt;rCount&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insert2 :: Insert Int64&#xA;insert2 =&#xA;  Insert&#xA;    { iTable = categoryTable&#xA;    , iRows = [Category (CategoryId 1) &#34;Screws&#34;, Category (CategoryId 2) &#34;Wood Screws&#34;, Category (CategoryId 3) &#34;Concrete Screws&#34;]&#xA;    , iReturning = rCount&#xA;    , iOnConflict = Nothing&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to query data&lt;/h3&gt; &#xA;&lt;p&gt;The basic select is simple:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;selectProduct :: Select ProductField&#xA;selectProduct = selectTable productTable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;Note that we can use &lt;code&gt;showSql&lt;/code&gt; to print &lt;code&gt;Select&lt;/code&gt; and see what sql queries get executed.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We run a select with &lt;code&gt;runSelect&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;queryData :: Connection -&amp;gt; IO ()&#xA;queryData connection = do&#xA;  result1 :: [Product] &amp;lt;- runSelect connection selectProduct&#xA;  putStrLn $ &#34;Query 1: &#34; &amp;lt;&amp;gt; show result1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;runSelect&lt;/code&gt; ‚Äú&lt;em&gt;converts a &#34;record&#34; of Opaleye fields to a list of &#34;records&#34; of Haskell values.‚Äù&lt;/em&gt; We must specify the return type (&lt;code&gt;[Product]&lt;/code&gt;) to help type inference.&lt;/p&gt; &#xA;&lt;p&gt;We can select specific fields and narrow down the results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;select2 :: Select (Field SqlText, FieldNullable SqlText)&#xA;select2 = do&#xA;  (Product _ aLabel description) &amp;lt;- selectProduct&#xA;  where_ (aLabel .== &#34;Wood Screw Kit 2&#34;)&#xA;  pure (aLabel, description)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;result2 :: [(Text, Maybe Text)] &amp;lt;- runSelect connection select2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use &lt;code&gt;where_&lt;/code&gt; to filter the rows and &lt;code&gt;.==&lt;/code&gt; to compare for equality. We can also use &lt;code&gt;in_&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;select3 :: Select (Field SqlText)&#xA;select3 = do&#xA;  p &amp;lt;- selectProduct&#xA;  where_ $ in_ [&#34;Wood Screw Kit 2&#34;, &#34;Wood Screw Kit 3&#34;] p.pLabel&#xA;  pure (p.pLabel)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;result3 :: [Text] &amp;lt;- runSelect connection select3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to use transactions&lt;/h3&gt; &#xA;&lt;p&gt;We use &lt;code&gt;postgresql-simple&lt;/code&gt; for transactions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertWithTransaction :: Connection -&amp;gt; IO ()&#xA;insertWithTransaction connection = Simple.withTransaction connection $ do&#xA;  [newProduct] :: [ProductId] &amp;lt;-&#xA;    runInsert connection&#xA;      $ Insert&#xA;        { iTable = productTable&#xA;        , iRows = [Product (ProductId Nothing) &#34;Drywall Screws Set&#34; (maybeToNullable $ Just &#34;8000pcs&#34;)]&#xA;        , iReturning = rReturning (\(p :: ProductField) -&amp;gt; p.pId)&#xA;        , iOnConflict = Nothing&#xA;        }&#xA;&#xA;  [newCategory] :: [CategoryId] &amp;lt;-&#xA;    runInsert connection&#xA;      $ Insert&#xA;        { iTable = categoryTable&#xA;        , iRows = [Category (CategoryId 123) &#34;Drywall Screws&#34;]&#xA;        , iReturning = rReturning (.cId)&#xA;        , iOnConflict = Nothing&#xA;        }&#xA;&#xA;  void&#xA;    $ runInsert connection&#xA;    $ Insert&#xA;      { iTable = productCategoryTable&#xA;      , iRows = [Mapping (toFields newProduct) (toFields newCategory)]&#xA;      , iReturning = rCount&#xA;      , iOnConflict = Nothing&#xA;      }&#xA;&#xA;  void&#xA;    $ runInsert connection&#xA;    $ Insert&#xA;      { iTable = warehouseTable&#xA;      , iRows = [(Nothing, (toFields newProduct), 10, Nothing, Nothing)]&#xA;      , iReturning = rCount&#xA;      , iOnConflict = Nothing&#xA;      }&#xA;&#xA;  putStrLn $ &#34;Insert with transaction&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to query using joins&lt;/h3&gt; &#xA;&lt;p&gt;Opaleye provides a couple of APIs for joins. They recommend using&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/opaleye-0.10.0.0/docs/Opaleye-Operators.html#v:where_&#34;&gt;&lt;code&gt;where_&lt;/code&gt;&lt;/a&gt;&amp;nbsp;directly for inner joins and &lt;a href=&#34;https://hackage.haskell.org/package/opaleye-0.10.0.0/docs/Opaleye-Join.html#v:optional&#34;&gt;&lt;code&gt;optional&lt;/code&gt;&lt;/a&gt; for left/right joins. Which gives us something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;join :: Select (Field SqlInt4, Field SqlText, FieldNullable SqlText, MaybeFields (Field SqlText))&#xA;join = do&#xA;  (_, wProductId, quantity, _, _) &amp;lt;- selectTable warehouseTable&#xA;  p &amp;lt;- selectTable productTable&#xA;  mpc &amp;lt;- optional $ do&#xA;    pc &amp;lt;- selectTable productCategoryTable&#xA;    where_ $ pc.productId .=== p.pId&#xA;    pure pc&#xA;  mc &amp;lt;- optional $ do&#xA;    c &amp;lt;- selectTable categoryTable&#xA;    where_ $ isJustAnd mpc $ \pc -&amp;gt; c.cId .=== pc.categoryId&#xA;    pure c&#xA;&#xA;  where_ $ wProductId .=== p.pId&#xA;  where_ $ quantity .&amp;gt; 3&#xA;&#xA;  let category = cLabel &amp;lt;$&amp;gt; mc&#xA;  pure (quantity, p.pLabel, p.pDescription, category)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí° Note that we use &lt;code&gt;isJustAnd&lt;/code&gt; that will be added to Opaleye in the future.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;isJustAnd :: MaybeFields a -&amp;gt; (a -&amp;gt; Field SqlBool) -&amp;gt; Field SqlBool&#xA;isJustAnd ma cond = matchMaybe ma $ \case&#xA;  Nothing -&amp;gt; sqlBool False&#xA;  Just a -&amp;gt; cond a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Which generates:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;SELECT&#xA;&#34;quantity2_1&#34; as &#34;result1_7&#34;,&#xA;&#34;label1_2&#34; as &#34;result2_7&#34;,&#xA;&#34;description2_2&#34; as &#34;result3_7&#34;,&#xA;NOT ((&#34;rebind0_6&#34;) IS NULL) as &#34;result4_7&#34;,&#xA;&#34;label1_5&#34; as &#34;result5_7&#34;&#xA;FROM (SELECT&#xA;      *&#xA;      FROM (SELECT *&#xA;            FROM&#xA;            (SELECT *&#xA;             FROM&#xA;             (SELECT&#xA;              *&#xA;              FROM (SELECT&#xA;                    &#34;id&#34; as &#34;id0_1&#34;,&#xA;                    &#34;product_id&#34; as &#34;product_id1_1&#34;,&#xA;                    &#34;quantity&#34; as &#34;quantity2_1&#34;,&#xA;                    &#34;created&#34; as &#34;created3_1&#34;,&#xA;                    &#34;modified&#34; as &#34;modified4_1&#34;&#xA;                    FROM &#34;warehouse&#34; as &#34;T1&#34;) as &#34;T1&#34;,&#xA;                   LATERAL&#xA;                   (SELECT&#xA;                    &#34;id&#34; as &#34;id0_2&#34;,&#xA;                    &#34;label&#34; as &#34;label1_2&#34;,&#xA;                    &#34;description&#34; as &#34;description2_2&#34;&#xA;                    FROM &#34;product&#34; as &#34;T1&#34;) as &#34;T2&#34;) as &#34;T1&#34;&#xA;             LEFT OUTER JOIN&#xA;             LATERAL&#xA;             (SELECT&#xA;              TRUE as &#34;rebind0_4&#34;,&#xA;              *&#xA;              FROM (SELECT&#xA;                    *&#xA;                    FROM (SELECT&#xA;                          &#34;product_id&#34; as &#34;product_id0_3&#34;,&#xA;                          &#34;category_id&#34; as &#34;category_id1_3&#34;&#xA;                          FROM &#34;product_category&#34; as &#34;T1&#34;) as &#34;T1&#34;&#xA;                    WHERE ((&#34;product_id0_3&#34;) = (&#34;id0_2&#34;))) as &#34;T1&#34;) as &#34;T2&#34;&#xA;             ON&#xA;             TRUE) as &#34;T1&#34;&#xA;            LEFT OUTER JOIN&#xA;            LATERAL&#xA;            (SELECT&#xA;             TRUE as &#34;rebind0_6&#34;,&#xA;             *&#xA;             FROM (SELECT&#xA;                   *&#xA;                   FROM (SELECT&#xA;                         &#34;id&#34; as &#34;id0_5&#34;,&#xA;                         &#34;label&#34; as &#34;label1_5&#34;&#xA;                         FROM &#34;category&#34; as &#34;T1&#34;) as &#34;T1&#34;&#xA;                   WHERE (CASE WHEN NOT ((&#34;rebind0_4&#34;) IS NULL) THEN (&#34;id0_5&#34;) = (&#34;category_id1_3&#34;) ELSE CAST(FALSE AS boolean) END)) as &#34;T1&#34;) as &#34;T2&#34;&#xA;            ON&#xA;            TRUE) as &#34;T1&#34;&#xA;      WHERE ((&#34;quantity2_1&#34;) &amp;gt; (CAST(3 AS integer))) AND ((&#34;product_id1_1&#34;) = (&#34;id0_2&#34;))) as &#34;T1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Errors&lt;/h3&gt; &#xA;&lt;p&gt;Once again, type-safety and query validation equal compilation errors.&lt;/p&gt; &#xA;&lt;p&gt;But because there isn‚Äôt much ‚Äútype-level magic‚Äù, we only need to occasionally help the compiler with type inference. And it‚Äôs mainly about input and return types ‚Äî not intermediate/internal library structures. For example, &lt;code&gt;[Product]&lt;/code&gt; in this snippet:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;result :: [Product] &amp;lt;- runSelect connection selectProduct&#xA; where&#xA;  selectProduct = selectTable productTable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sometimes, if you don‚Äôt specify enough types, profunctors show up:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Ambiguous type variable ‚Äòhaskells0‚Äô arising from a use of ‚ÄòrunSelect‚Äô&#xA;prevents the constraint ‚Äò(Default&#xA;                            FromFields fields0 Product)‚Äô from being solved.&#xA;Probable fix: use a type annotation to specify what ‚Äòhaskells0‚Äô should be.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Runtime sql errors are again from &lt;code&gt;postgresql-simple&lt;/code&gt;. Review the relevant error section if you need a reminder.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;errors :: Connection -&amp;gt; IO ()&#xA;errors connection = do&#xA;  insertDuplicateScrew&#xA;  insertDuplicateScrew&#xA;    `catch` (\err@SqlError{} -&amp;gt; putStrLn $ &#34;Caught SQL Error: &#34; &amp;lt;&amp;gt; displayException err)&#xA; where&#xA;  insertDuplicateScrew =&#xA;    void&#xA;      $ runInsert connection&#xA;      $ Insert&#xA;        { iTable = productTable&#xA;        , iRows = [Product (ProductId Nothing) &#34;Duplicate screw&#34; (maybeToNullable Nothing)]&#xA;        , iReturning = rCount&#xA;        , iOnConflict = Nothing&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;There are a couple of basic tutorials in the repo and some external ones.&lt;/p&gt; &#xA;&lt;p&gt;One thing to remember: sometimes, the library provides multiple ways of doing things (for example, left joins using &lt;code&gt;optional&lt;/code&gt; vs. deprecated &lt;code&gt;leftJoin&lt;/code&gt; or monadic vs. arrow syntax), and documentation/tutorials can do it one way or even deprecated way.&lt;/p&gt; &#xA;&lt;h3&gt;Migrations&lt;/h3&gt; &#xA;&lt;p&gt;Opaleye assumes a database already exists ‚Äî no support for migrations or creating tables and databases.&lt;/p&gt; &#xA;&lt;h3&gt;In summary&lt;/h3&gt; &#xA;&lt;p&gt;Opaleye allows us to define tables and write type-safe postgres queries using Haskell code.&lt;/p&gt; &#xA;&lt;p&gt;The library uses &lt;code&gt;product-profunctors&lt;/code&gt; and typeclasses. Both only come up in copy-pasteable boilerplate and when you under-specify the return types. No deep knowledge is required.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;rel8&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Okay, what if we did something quite similar but quite different?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Rel8 ‚Äú&lt;em&gt;is a Haskell library for interacting with PostgreSQL databases‚Äù&lt;/em&gt;, which aims to be concise, inferrable, and familiar.&lt;/p&gt; &#xA;&lt;p&gt;For the database connection, instead of &lt;code&gt;postgresql-simple&lt;/code&gt;, &lt;code&gt;rel8&lt;/code&gt; uses Hasql.&lt;/p&gt; &#xA;&lt;p&gt;Install &lt;code&gt;rel8&lt;/code&gt; (&lt;code&gt;1.4.1.0&lt;/code&gt; released in 2023), &lt;code&gt;hasql&lt;/code&gt;, and &lt;code&gt;hasql-transaction&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We bring back the &lt;code&gt;TypeFamilies&lt;/code&gt; extension and (in case you haven‚Äôt already) &lt;code&gt;DuplicateRecordFields&lt;/code&gt;. The latter is required to disambiguate the record fields when working with inserts, updates, and deletes‚Ä¶&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;We assume you‚Äôve seen the parts on &lt;code&gt;postgresql-simple&lt;/code&gt;, &lt;code&gt;hasql&lt;/code&gt;, and &lt;code&gt;opaleye&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;How to connect to a database&lt;/h3&gt; &#xA;&lt;p&gt;We use Hasql. Reminder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Right connection &amp;lt;- getConnection&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;getConnection :: IO (Either ConnectionError Connection)&#xA;getConnection =&#xA;  acquire $ settings Hardcoded.host Hardcoded.portNumber Hardcoded.user Hardcoded.password Hardcoded.database&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to define tables&lt;/h3&gt; &#xA;&lt;p&gt;First, we describe the structural mapping of the tables. Take for instance &lt;code&gt;Product&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype ProductId = ProductId Int64&#xA;  deriving newtype (DBEq, DBType, Eq, Show)&#xA;&#xA;data Product f = Product&#xA;  { id :: Column f ProductId&#xA;  , label :: Column f Text&#xA;  , description :: Column f (Maybe Text)&#xA;  }&#xA;  deriving (Generic)&#xA;  deriving anyclass (Rel8able)&#xA;&#xA;deriving stock instance (f ~ Result) =&amp;gt; Show (Product f)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We define fields with &amp;nbsp;&lt;code&gt;Column&lt;/code&gt; and derive the &lt;code&gt;Rel8able&lt;/code&gt; instance. We also declare a newtype for product id with a few instances.&lt;/p&gt; &#xA;&lt;p&gt;Imagine that the last line is just &lt;code&gt;deriving (Show)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Then, we describe a&amp;nbsp;&lt;code&gt;TableSchema&lt;/code&gt;&amp;nbsp;for each table. The relevant table looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;productSchema :: TableSchema (Product Name)&#xA;productSchema =&#xA;  TableSchema&#xA;    { name = &#34;product&#34;&#xA;    , schema = Nothing&#xA;    , columns =&#xA;        Product&#xA;          { id = &#34;id&#34;&#xA;          , label = &#34;label&#34;&#xA;          , description = &#34;description&#34;&#xA;          }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that defining columns looks repetitive ‚Äî we can use some generics machinery to get that information from the &lt;code&gt;Rel8able&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;productSchema :: TableSchema (Product Name)&#xA;productSchema =&#xA;  TableSchema&#xA;    { name = &#34;product&#34;&#xA;    , schema = Nothing&#xA;    , columns = namesFromLabels @(Product Name)&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;&lt;code&gt;namesFromLabels&lt;/code&gt; generates a table schema where every column name corresponds precisely to the field&#39;s name. Alternatively, we can use &lt;code&gt;namesFromLabelsWith&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/Zelenya/elephants&#34;&gt;repo&lt;/a&gt; for the rest of the boilerplate.&lt;/p&gt; &#xA;&lt;h3&gt;How to modify data&lt;/h3&gt; &#xA;&lt;p&gt;For raw queries, we can use Hasql:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;cleanUp :: Connection -&amp;gt; IO (Either QueryError ())&#xA;cleanUp connection = run cleanUpSession connection&#xA; where&#xA;  cleanUpSession = statement () $ Statement rawSql E.noParams D.noResult True&#xA;  rawSql = &#34;truncate warehouse, product_category, product, category&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Otherwise, we create &lt;code&gt;Insert&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insert1 :: Statement () [ProductId]&#xA;insert1 =&#xA;  insert&#xA;    $ Insert&#xA;      { into = productSchema&#xA;      , rows =&#xA;          values&#xA;            [ Product unsafeDefault &#34;Wood Screw Kit 1&#34; null&#xA;            , Product unsafeDefault &#34;Wood Screw Kit 2&#34; (lit $ Just &#34;245-pieces&#34;)&#xA;            ]&#xA;      , returning = Projection (.id)&#xA;      , onConflict = Abort&#xA;      }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We‚Äôve seen this in Opaleye‚Äôs insert: the table, rows to insert, conflict-handling strategy, and what to return.&lt;/p&gt; &#xA;&lt;p&gt;We use &lt;code&gt;unsafeDefault&lt;/code&gt; for sql&amp;nbsp;&lt;code&gt;DEFAULT&lt;/code&gt;, &lt;a href=&#34;https://hackage.haskell.org/package/rel8-1.4.1.0/docs/Rel8.html#v:lit&#34;&gt;&lt;code&gt;lit&lt;/code&gt;&lt;/a&gt; to turn Haskell values into expressions, and &lt;a href=&#34;https://hackage.haskell.org/package/rel8-1.4.1.0/docs/Rel8.html#v:values&#34;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; to construct a query out of the given rows.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;üí°&amp;nbsp;Note that &lt;a href=&#34;https://hackage.haskell.org/package/rel8-1.4.1.0/docs/Rel8.html#v:unsafeDefault&#34;&gt;&lt;code&gt;unsafeDefault&lt;/code&gt;&lt;/a&gt; is named unsafe for a reason; see the docs.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;And run this like any other Hasql statement:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;result1 &amp;lt;- run (statement () insert1) connection&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we want to return the number of affected rows, we can use &lt;code&gt;NumberOfRowsAffected&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Insert&#xA;  { into = categorySchema&#xA;  , rows =&#xA;      values&#xA;        [ Category unsafeDefault &#34;Screws&#34;&#xA;        , Category unsafeDefault &#34;Wood Screws&#34;&#xA;        , Category unsafeDefault &#34;Concrete Screws&#34;&#xA;        ]&#xA;  , returning = NumberOfRowsAffected&#xA;  , onConflict = Abort&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to query data&lt;/h3&gt; &#xA;&lt;p&gt;We build select&amp;nbsp;statements using &lt;code&gt;Query&lt;/code&gt;. We select all rows from a table using &lt;code&gt;each&lt;/code&gt; and turn (run) the query into &lt;code&gt;Statement&lt;/code&gt; using &lt;code&gt;select&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;select1 :: Statement () [Product Result]&#xA;select1 = select $ each productSchema&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;Note that we can use &lt;code&gt;showQuery&lt;/code&gt; to print sql queries that will be executed.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;And once again we run the statement:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;result1 &amp;lt;- run (statement () select1) connection&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can select specific fields and narrow down the results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;select2 :: Statement () [(Text, Maybe Text)]&#xA;select2 = select $ do&#xA;  p &amp;lt;- each productSchema&#xA;  where_ $ p.label ==. &#34;Wood Screw Kit 2&#34;&#xA;  pure (p.label, p.description)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use &lt;code&gt;where_&lt;/code&gt; to filter the rows and &lt;code&gt;==.&lt;/code&gt; to compare for equality. We can also use &lt;code&gt;in_&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;select3 :: Statement () [Text]&#xA;select3 = select $ do&#xA;  p &amp;lt;- each productSchema&#xA;  where_ $ p.label `in_` [&#34;Wood Screw Kit 2&#34;, &#34;Wood Screw Kit 3&#34;]&#xA;  pure p.label&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note that the order of parameters is different from Opaleye.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;How to use transactions&lt;/h3&gt; &#xA;&lt;p&gt;We use Hasql for transactions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertWithTransaction :: Connection -&amp;gt; IO ()&#xA;insertWithTransaction connection = do&#xA;  result &amp;lt;- run (transaction Serializable Write insertAll) connection&#xA;  putStrLn $ &#34;Insert with transaction: &#34; &amp;lt;&amp;gt; show result&#xA; where&#xA;  insertAll = do&#xA;    productIds &amp;lt;-&#xA;      Transaction.statement ()&#xA;        $ insert&#xA;        $ Insert&#xA;          { into = productSchema&#xA;          , rows = values [Product unsafeDefault &#34;Drywall Screws Set&#34; (lit $ Just &#34;8000pcs&#34;)]&#xA;          , returning = Projection (.id)&#xA;          , onConflict = Abort&#xA;          }&#xA;&#xA;    -- insert category&#xA;    -- insert mapping&#xA;    -- insert warehouse listing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to query using joins&lt;/h3&gt; &#xA;&lt;p&gt;Rel8 doesn‚Äôt have a specific join operation ‚Äî we use&amp;nbsp;&lt;code&gt;where_&lt;/code&gt; (or &lt;code&gt;filter&lt;/code&gt;)&amp;nbsp;to filter the results and &lt;code&gt;optional&lt;/code&gt; to do what outer joins do.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;queryWithJoins :: Connection -&amp;gt; IO ()&#xA;queryWithJoins connection = do&#xA;  result1 &amp;lt;- run (statement () join) connection&#xA;  putStrLn $ &#34;Query with join: &#34; &amp;lt;&amp;gt; show result1&#xA; where&#xA;  join :: Statement () [(Int32, Text, Maybe Text, Maybe Text)]&#xA;  join = select joinQuery&#xA;&#xA;  joinQuery = do&#xA;    w &amp;lt;- each warehouseSchema&#xA;    p &amp;lt;- productsInWarehouse w&#xA;    pc &amp;lt;- optional $ mappingsForProduct p&#xA;    c &amp;lt;- traverseMaybeTable categoriesForMapping pc&#xA;    where_ $ w.quantity &amp;gt;. 3&#xA;    let category = maybeTable null (nullify . (.label)) c&#xA;    pure (w.quantity, p.label, p.description, category)&#xA;&#xA;  productsInWarehouse :: Warehouse Expr -&amp;gt; Query (Product Expr)&#xA;  productsInWarehouse w =&#xA;    each productSchema &amp;gt;&amp;gt;= filter (\p -&amp;gt; p.id ==. w.product_id)&#xA;&#xA;  mappingsForProduct :: Product Expr -&amp;gt; Query (ProductCategory Expr)&#xA;  mappingsForProduct p = do&#xA;    each productCategorySchema &amp;gt;&amp;gt;= filter (\pc -&amp;gt; pc.product_id ==. p.id)&#xA;&#xA;  categoriesForMapping :: ProductCategory Expr -&amp;gt; Query (Category Expr)&#xA;  categoriesForMapping pc =&#xA;    each categorySchema &amp;gt;&amp;gt;= filter (\c -&amp;gt; c.id ==. pc.category_id)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We extract ‚Äúeach join‚Äù into a specialized function to make the code cleaner (according to the Rel8 tutorials). We use &lt;code&gt;optional&lt;/code&gt; and &lt;code&gt;traverseMaybeTable&lt;/code&gt; to account for the partiality of queries. &lt;code&gt;MaybeTable&lt;/code&gt; results from an outer join, which we unwrap with &lt;code&gt;maybeTable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;filter&lt;/code&gt; is an alternative way to write&amp;nbsp;&lt;code&gt;where&lt;/code&gt;&amp;nbsp;clauses.&lt;/p&gt; &#xA;&lt;p&gt;The generated query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;SELECT&#xA;CAST(&#34;quantity2_1&#34; AS int4) as &#34;_1&#34;,&#xA;CAST(&#34;label1_3&#34; AS text) as &#34;_2&#34;,&#xA;CAST(&#34;description2_3&#34; AS text) as &#34;_3&#34;,&#xA;CAST(CASE WHEN (&#34;rebind0_8&#34;) IS NULL THEN CAST(NULL AS text) ELSE &#34;label1_12&#34; END AS text) as &#34;_4&#34;&#xA;FROM (SELECT&#xA;      *&#xA;      FROM (SELECT *&#xA;            FROM&#xA;            (SELECT *&#xA;             FROM&#xA;             (SELECT&#xA;              *&#xA;              FROM (SELECT&#xA;                    &#34;id&#34; as &#34;id0_1&#34;,&#xA;                    &#34;product_id&#34; as &#34;product_id1_1&#34;,&#xA;                    &#34;quantity&#34; as &#34;quantity2_1&#34;,&#xA;                    &#34;created&#34; as &#34;created3_1&#34;,&#xA;                    &#34;modified&#34; as &#34;modified4_1&#34;&#xA;                    FROM &#34;warehouse&#34; as &#34;T1&#34;) as &#34;T1&#34;,&#xA;                   LATERAL&#xA;                   (SELECT&#xA;                    &#34;id&#34; as &#34;id0_3&#34;,&#xA;                    &#34;label&#34; as &#34;label1_3&#34;,&#xA;                    &#34;description&#34; as &#34;description2_3&#34;&#xA;                    FROM &#34;product&#34; as &#34;T1&#34;) as &#34;T2&#34;&#xA;              WHERE ((&#34;id0_3&#34;) = (&#34;product_id1_1&#34;))) as &#34;T1&#34;&#xA;             LEFT OUTER JOIN&#xA;             LATERAL&#xA;             (SELECT&#xA;              TRUE as &#34;rebind0_8&#34;,&#xA;              *&#xA;              FROM (SELECT&#xA;                    *&#xA;                    FROM (SELECT&#xA;                          &#34;product_id&#34; as &#34;product_id0_6&#34;,&#xA;                          &#34;category_id&#34; as &#34;category_id1_6&#34;&#xA;                          FROM &#34;product_category&#34; as &#34;T1&#34;) as &#34;T1&#34;&#xA;                    WHERE ((&#34;product_id0_6&#34;) = (&#34;id0_3&#34;))) as &#34;T1&#34;) as &#34;T2&#34;&#xA;             ON&#xA;             TRUE) as &#34;T1&#34;&#xA;            LEFT OUTER JOIN&#xA;            LATERAL&#xA;            (SELECT&#xA;             TRUE as &#34;rebind0_14&#34;,&#xA;             *&#xA;             FROM (SELECT&#xA;                   *&#xA;                   FROM (SELECT&#xA;                         0) as &#34;T1&#34;,&#xA;                        LATERAL&#xA;                        (SELECT&#xA;                         &#34;id&#34; as &#34;id0_12&#34;,&#xA;                         &#34;label&#34; as &#34;label1_12&#34;&#xA;                         FROM &#34;category&#34; as &#34;T1&#34;) as &#34;T2&#34;&#xA;                   WHERE ((&#34;id0_12&#34;) = (&#34;category_id1_6&#34;)) AND ((&#34;rebind0_8&#34;) IS NOT NULL)) as &#34;T1&#34;) as &#34;T2&#34;&#xA;            ON&#xA;            TRUE) as &#34;T1&#34;&#xA;      WHERE ((&#34;quantity2_1&#34;) &amp;gt; (CAST(3 AS int4))) AND ((((&#34;rebind0_14&#34;) IS NULL) AND ((&#34;rebind0_8&#34;) IS NULL)) OR (((&#34;rebind0_14&#34;) = (&#34;rebind0_8&#34;)) AND (COALESCE((&#34;rebind0_14&#34;) = (&#34;rebind0_8&#34;),FALSE))))) as &#34;T1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which looks similar to the relevant Opaleye query in the previous section.&lt;/p&gt; &#xA;&lt;h3&gt;Errors&lt;/h3&gt; &#xA;&lt;p&gt;On top of type-safety, according to the docs, &lt;em&gt;‚ÄúRel8 aims to have excellent and predictable type inference‚Äù&lt;/em&gt;. And they deliver ‚Äî type inference rarely needs any guidance, and the compilation errors are pretty good.&lt;/p&gt; &#xA;&lt;p&gt;Although it‚Äôs possible to introduce runtime errors using unsafe operations like unsafeDefault, the name is explicit, well documented, and has proper alternatives.&lt;/p&gt; &#xA;&lt;p&gt;Runtime errors come from Hasql ‚Äî all error-reporting is explicit and is presented using &lt;code&gt;Either&lt;/code&gt;. As a reminder, violating the constraint returns a familiar error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;errors :: Connection -&amp;gt; IO ()&#xA;errors connection = do&#xA;  Left failure &amp;lt;-&#xA;    run insertDuplicateScrew connection&#xA;      &amp;gt;&amp;gt; run insertDuplicateScrew connection&#xA;  putStrLn $ &#34;Constraint violation (Left): &#34; &amp;lt;&amp;gt; show failure&#xA; where&#xA;  insertDuplicateScrew =&#xA;    statement ()&#xA;      $ insert&#xA;      $ Insert&#xA;        { into = productSchema&#xA;        , rows = values [Product unsafeDefault &#34;Duplicate screw&#34; null]&#xA;        , returning = NumberOfRowsAffected&#xA;        , onConflict = Abort&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;Constraint violation (Left): QueryError &#34;INSERT INTO \&#34;product\&#34; (\&#34;id\&#34;,\n \&#34;label\&#34;,\n \&#34;description\&#34;)\nVALUES\n(DEFAULT,CAST(E&#39;Duplicate screw&#39; AS text),CAST(NULL AS text))&#34; [] (ResultError (ServerError &#34;23505&#34; &#34;duplicate key value violates unique constraint \&#34;product_label_key\&#34;&#34; (Just &#34;Key (label)=(Duplicate screw) already exists.&#34;) Nothing Nothing))&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;Rel8 has the Getting Started tutorial, the Concepts documentation, the cookbook, and good API docs. This would have been one of the best coverages, but unfortunately, some basic snippets (like running selects or constructing inserts) aren‚Äôt valid anymore.&lt;/p&gt; &#xA;&lt;p&gt;Also, you have to keep in mind &lt;code&gt;hasql&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Migrations&lt;/h3&gt; &#xA;&lt;p&gt;Rel8 assumes a database already exists ‚Äî no support for migrations or creating tables and databases.&lt;/p&gt; &#xA;&lt;h3&gt;In summary&lt;/h3&gt; &#xA;&lt;p&gt;Rel8 also allows us to write type-safe postgres queries using &lt;em&gt;concise&lt;/em&gt;, &lt;em&gt;inferrable&lt;/em&gt;, and &lt;em&gt;familiar&lt;/em&gt; Haskell code. It builds on top of &lt;code&gt;opaleye&lt;/code&gt; and &lt;code&gt;hasql&lt;/code&gt;, and you must be somewhat familiar with the latter.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;selda&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Okay, what if we did something quite similar but quite different?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://selda.link/&#34;&gt;Selda&lt;/a&gt; &lt;em&gt;‚Äúis a Haskell library for interacting with SQL-based relational databases‚Äù&lt;/em&gt; (PostgreSQL or SQLite). &lt;em&gt;‚ÄúThe library was inspired by&amp;nbsp;&lt;a href=&#34;https://en.wikipedia.org/wiki/Language_Integrated_Query&#34;&gt;LINQ&lt;/a&gt;&amp;nbsp;and&amp;nbsp;&lt;a href=&#34;http://hackage.haskell.org/package/opaleye&#34;&gt;Opaleye&lt;/a&gt;.‚Äù&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Install &lt;code&gt;selda&lt;/code&gt; (&lt;code&gt;0.5.2.0&lt;/code&gt; released in 2022) and &lt;code&gt;selda-postgresql&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Enable &lt;code&gt;OverloadedLabels&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How to connect to a database&lt;/h3&gt; &#xA;&lt;p&gt;Create connection info:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;connectionInfo :: PGConnectInfo&#xA;connectionInfo =&#xA;  PGConnectInfo&#xA;    { pgHost = Hardcoded.host&#xA;    , pgPort = Hardcoded.portNumber&#xA;    , pgDatabase = Hardcoded.database&#xA;    , pgUsername = Just Hardcoded.user&#xA;    , pgPassword = Just Hardcoded.password&#xA;    , pgSchema = Nothing&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And use it with &lt;code&gt;withPostgreSQL&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;withPostgreSQL connectionInfo $ do&#xA;  doFoo&#xA;  doBar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to define tables&lt;/h3&gt; &#xA;&lt;p&gt;First, we declare normal types and derive &lt;code&gt;SqlRow&lt;/code&gt;, for example, for product:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Product = Product&#xA;  { id :: ID Product&#xA;  , label :: Text&#xA;  , description :: Maybe Text&#xA;  }&#xA;  deriving (Generic, Show)&#xA;  deriving anyclass (SqlRow)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, we use table to declare a table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;productTable :: Table Product&#xA;productTable = table &#34;product&#34; [#id :- autoPrimary]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We specify constraints by linking&amp;nbsp;selectors&amp;nbsp;of the table to the definitions. We use &lt;code&gt;autoPrimary&lt;/code&gt; for auto-incrementing&amp;nbsp;primary keys, &lt;code&gt;primary&lt;/code&gt; for regular primary keys, and &lt;code&gt;foreignKey&lt;/code&gt; for foreign keys:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mappingTable :: Table ProductCategory&#xA;mappingTable =&#xA;  table&#xA;    &#34;product_category&#34;&#xA;    [ #product_id :- foreignKey productTable #id&#xA;    , #category_id :- foreignKey categoryTable #id&#xA;    ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;See the &lt;a href=&#34;https://github.com/Zelenya/elephants&#34;&gt;repo&lt;/a&gt; for the rest of the boilerplate.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;How to modify data&lt;/h3&gt; &#xA;&lt;p&gt;We can use &lt;code&gt;rawStm&lt;/code&gt; from &lt;code&gt;Database.Selda.Unsafe&lt;/code&gt; to execute raw queries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cleanUp :: SeldaM PG ()&#xA;cleanUp =&#xA;  rawStm &#34;truncate warehouse, product_category, product, category&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/selda-0.5.2.0/docs/Database-Selda.html#t:SeldaM&#34;&gt;&lt;code&gt;SeldaM&lt;/code&gt;&lt;/a&gt;&amp;nbsp;is an alias for&amp;nbsp;&lt;code&gt;SeldaT IO&lt;/code&gt;, &lt;code&gt;SeldaT&lt;/code&gt; is a Selda computation ‚Äî a concrete implementation (of &lt;code&gt;MonadSelda&lt;/code&gt;) with Selda SQL capabilities.&lt;/p&gt; &#xA;&lt;p&gt;At the end we‚Äôll turn it into &lt;code&gt;IO&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;withPostgreSQL connectionInfo $ do&#xA;  cleanUp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To insert data, we can use &lt;code&gt;insert_&lt;/code&gt; that doesn‚Äôt return anything, &lt;code&gt;insert&lt;/code&gt; that returns the number of inserted rows, and &lt;code&gt;insertWithPK&lt;/code&gt; that returns the primary key of the last inserted row.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertStuff :: SeldaM PG ()&#xA;insertStuff = do&#xA;  productId &amp;lt;-&#xA;    insertWithPK&#xA;      productTable&#xA;      [ Product def &#34;Wood Screw Kit 1&#34; (Just &#34;245-pieces&#34;)&#xA;      , Product def &#34;Wood Screw Kit 2&#34; Nothing&#xA;      ]&#xA;  liftIO $ putStrLn $ &#34;Inserted product with id: &#34; &amp;lt;&amp;gt; show productId&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;  rows &amp;lt;-&#xA;    insert&#xA;      categoryTable&#xA;      [Category def &#34;Screws&#34;, Category def &#34;Wood Screws&#34;, Category def &#34;Concrete Screws&#34;]&#xA;  liftIO $ putStrLn $ &#34;Inserted categories: &#34; &amp;lt;&amp;gt; show rows&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use &lt;code&gt;def&lt;/code&gt;&amp;nbsp;when we want to use the&amp;nbsp;default&amp;nbsp;value, which is the case with ids.&lt;/p&gt; &#xA;&lt;h3&gt;How to query data&lt;/h3&gt; &#xA;&lt;p&gt;We can get all the rows from the given table using &lt;code&gt;select&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;  selectProduct :: Query t (Row t Product)&#xA;  selectProduct = select productTable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí°&amp;nbsp;Note that we can use &lt;code&gt;compile&lt;/code&gt; from &lt;code&gt;Database.Selda.Debug&lt;/code&gt; to print sql queries that will be executed.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;And execute the query with &lt;code&gt;query&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;queryData :: SeldaT PG IO ()&#xA;queryData = do&#xA;  result1 &amp;lt;- query selectProduct&#xA;  liftIO $ putStrLn $ &#34;Query 1: &#34; &amp;lt;&amp;gt; show result1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;ü§∑&amp;nbsp;Somehow, here, Selda didn‚Äôt want to read/parse back the ids it just inserted:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;elephants-exe: [SELDA BUG] fromSql: RowID column with non-int value: SqlInt32...&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If we change the type from &lt;code&gt;ID Foo&lt;/code&gt; to &lt;code&gt;Int32&lt;/code&gt;, the select works, but then insert with auto-incremental primary keys and other functionality doesn‚Äôt ü§∑&amp;nbsp;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;So let‚Äôs ignore this for now because other queries work fine.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;We can select specific fields and narrow down the results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;select2 :: Query t (Col t Text :*: Col t (Maybe Text))&#xA;select2 = do&#xA;  p &amp;lt;- selectProduct&#xA;  restrict (p ! #label .== &#34;Wood Screw Kit 2&#34;)&#xA;  pure (p ! #label :*: p ! #description)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Query&lt;/code&gt; is parameterized over a&amp;nbsp;scope parameter&amp;nbsp;&lt;code&gt;t&lt;/code&gt;, ensuring that queries are always well-scoped, but we don‚Äôt have to worry about it now.&lt;/p&gt; &#xA;&lt;p&gt;We use &lt;code&gt;!&lt;/code&gt; with selectors to extract a column, &lt;code&gt;restrict&lt;/code&gt; to filter the rows, and &lt;code&gt;.==&lt;/code&gt; to compare for equality. A result is an&amp;nbsp;inductive tuple&amp;nbsp;‚Äî one or more values separated by the&amp;nbsp;&lt;code&gt;:*:&lt;/code&gt;&amp;nbsp;data constructor.&lt;/p&gt; &#xA;&lt;p&gt;We can also use &lt;code&gt;isIn&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;select3 = do&#xA;  p &amp;lt;- selectProduct&#xA;  restrict (p ! #label `isIn` [&#34;Wood Screw Kit 2&#34;, &#34;Wood Screw Kit 3&#34;])&#xA;  pure (p ! #label)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to use transactions&lt;/h3&gt; &#xA;&lt;p&gt;We use &lt;code&gt;transaction&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insertWithTransaction :: SeldaT PG IO ()&#xA;insertWithTransaction = transaction $ do&#xA;  productId &amp;lt;- insertWithPK productTable [Product def &#34;Drywall Screws Set&#34; (Just &#34;8000pcs&#34;)]&#xA;  categoryId &amp;lt;- insertWithPK categoryTable [Category def &#34;Drywall Screws&#34;]&#xA;  insert_ mappingTable [ProductCategory productId categoryId]&#xA;  insert_ warehouseTable [Warehouse def productId 10 def def]&#xA;  liftIO $ putStrLn $ &#34;Insert with transaction&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to query using joins&lt;/h3&gt; &#xA;&lt;p&gt;We use &lt;code&gt;restrict&lt;/code&gt; and &lt;code&gt;leftJoin&lt;/code&gt; to query with joins:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;join :: Query s (Col s Int32 :*: (Col s Text :*: (Col s (Maybe Text) :*: Col s (Coalesce (Maybe Text)))))&#xA;join = do&#xA;  w &amp;lt;- select warehouseTable&#xA;  p &amp;lt;- select productTable&#xA;  restrict (w ! #product_id .== p ! #id)&#xA;&#xA;  pc &amp;lt;- leftJoin (\pc -&amp;gt; pc ! #product_id .== p ! #id) (select mappingTable)&#xA;  c &amp;lt;- leftJoin (\c -&amp;gt; just (c ! #id) .== pc ? #category_id) (select categoryTable)&#xA;&#xA;  pure (w ! #quantity :*: p ! #label :*: p ! #description :*: c ? #label)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use &lt;code&gt;?&lt;/code&gt; to extract a column from the nullable row.&lt;/p&gt; &#xA;&lt;p&gt;The generated query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;SELECT &#xA;  &#34;quantity_2&#34;, &#xA;  &#34;label_6&#34;, &#xA;  &#34;description_7&#34;, &#xA;  &#34;label_13_15&#34; &#xA;FROM &#xA;  (&#xA;    SELECT &#xA;      &#34;id_12_14&#34;, &#xA;      &#34;label_13_15&#34;, &#xA;      &#34;category_id_9_11&#34;, &#xA;      &#34;label_6&#34;, &#xA;      &#34;description_7&#34;, &#xA;      &#34;quantity_2&#34; &#xA;    FROM &#xA;      (&#xA;        SELECT &#xA;          &#34;product_id_8_10&#34;, &#xA;          &#34;category_id_9_11&#34;, &#xA;          &#34;id_5&#34;, &#xA;          &#34;label_6&#34;, &#xA;          &#34;description_7&#34;, &#xA;          &#34;quantity_2&#34; &#xA;        FROM &#xA;          (&#xA;            SELECT &#xA;              &#34;id_5&#34;, &#xA;              &#34;label_6&#34;, &#xA;              &#34;description_7&#34;, &#xA;              &#34;product_id_1&#34;, &#xA;              &#34;quantity_2&#34; &#xA;            FROM &#xA;              (&#xA;                SELECT &#xA;                  &#34;product_id&#34; AS &#34;product_id_1&#34;, &#xA;                  &#34;quantity&#34; AS &#34;quantity_2&#34; &#xA;                FROM &#xA;                  &#34;warehouse&#34;&#xA;              ) AS q0, &#xA;              (&#xA;                SELECT &#xA;                  &#34;id&#34; AS &#34;id_5&#34;, &#xA;                  &#34;label&#34; AS &#34;label_6&#34;, &#xA;                  &#34;description&#34; AS &#34;description_7&#34; &#xA;                FROM &#xA;                  &#34;product&#34;&#xA;              ) AS q1 &#xA;            WHERE &#xA;              (&#34;product_id_1&#34; = &#34;id_5&#34;)&#xA;          ) AS q3 &#xA;          LEFT JOIN (&#xA;            SELECT &#xA;              &#34;product_id_8&#34; AS &#34;product_id_8_10&#34;, &#xA;              &#34;category_id_9&#34; AS &#34;category_id_9_11&#34; &#xA;            FROM &#xA;              (&#xA;                SELECT &#xA;                  &#34;product_id&#34; AS &#34;product_id_8&#34;, &#xA;                  &#34;category_id&#34; AS &#34;category_id_9&#34; &#xA;                FROM &#xA;                  &#34;product_category&#34;&#xA;              ) AS q2&#xA;          ) AS q4 ON &#34;product_id_8_10&#34; = &#34;id_5&#34;&#xA;      ) AS q6 &#xA;      LEFT JOIN (&#xA;        SELECT &#xA;          &#34;id_12&#34; AS &#34;id_12_14&#34;, &#xA;          &#34;label_13&#34; AS &#34;label_13_15&#34; &#xA;        FROM &#xA;          (&#xA;            SELECT &#xA;              &#34;id&#34; AS &#34;id_12&#34;, &#xA;              &#34;label&#34; AS &#34;label_13&#34; &#xA;            FROM &#xA;              &#34;product&#34;&#xA;          ) AS q5&#xA;      ) AS q7 ON (&#xA;        Cast(&#34;id_12_14&#34; AS INT)&#xA;      ) = &#34;category_id_9_11&#34;&#xA;  ) AS q8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Errors&lt;/h3&gt; &#xA;&lt;p&gt;From Selda‚Äôs tutorial: &lt;em&gt;‚ÄúWhile the types keep queries nice and safe, Haskell&#39;s type errors can be a bit daunting even under the best circumstances.‚Äù&lt;/em&gt; In practice, type inference rarely needed guidance, and the compilation errors were relatively clear.&lt;/p&gt; &#xA;&lt;p&gt;The only problem we‚Äôve encountered was the mismatch of &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;SqlInt32&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;All Selda functions may throw&amp;nbsp;&lt;a href=&#34;https://hackage.haskell.org/package/selda-0.5.2.0/docs/Database-Selda.html#t:SeldaError&#34;&gt;&lt;code&gt;SeldaError&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;errors :: SeldaM PG ()&#xA;errors = do&#xA;  insertDuplicateScrew&#xA;  insertDuplicateScrew&#xA;    `catch` (\(err :: SeldaError) -&amp;gt; liftIO $ putStrLn $ &#34;Caught Selda Error: &#34; &amp;lt;&amp;gt; displayException err)&#xA; where&#xA;  insertDuplicateScrew = insert_ productTable [Product def &#34;Duplicate screw&#34; Nothing]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;elephants-exe: SqlError &#34;error executing query INSERT INTO \&#34;product_category\&#34; (\&#34;product_id\&#34;, \&#34;category_id\&#34;) VALUES ($1, $2)&#39;: ERROR: insert or update on table \&#34;product_category\&#34; violates foreign key constraint \&#34;product_category_category_id_fkey\&#34;\nDETAIL: Key (category_id)=(748) is not present in table \&#34;category\&#34;.\n&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;p&gt;Selda comes with a simple overview and example. There is also a &lt;a href=&#34;https://selda.link/tutorial/&#34;&gt;tutorial&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Migrations&lt;/h3&gt; &#xA;&lt;p&gt;The library has a &lt;a href=&#34;https://hackage.haskell.org/package/selda-0.5.2.0/docs/Database-Selda-Migrations.html&#34;&gt;&lt;code&gt;Migrations&lt;/code&gt;&lt;/a&gt; module for upgrading a table from one schema to another.&lt;/p&gt; &#xA;&lt;h3&gt;In summary&lt;/h3&gt; &#xA;&lt;p&gt;Selda allows us to write type-safe queries in a &lt;em&gt;linear&lt;/em&gt;, &lt;em&gt;natural&lt;/em&gt; style.&lt;/p&gt; &#xA;&lt;p&gt;Depending on your experience and situation, you can use SeldaM straight, or you may need to get familiar with mtl, exceptions, lifting/unlifting IO, etc.&lt;/p&gt; &#xA;&lt;h2&gt;Honorable mentions&lt;/h2&gt; &#xA;&lt;p&gt;At some point, I ran out of steam and didn‚Äôt have the energy to make these things work.&lt;/p&gt; &#xA;&lt;p&gt;I didn‚Äôt manage to connect to the database using &lt;a href=&#34;https://hackage.haskell.org/package/postgresql-typed&#34;&gt;postgresql-typed&lt;/a&gt;. And I didn‚Äôt manage to build &lt;a href=&#34;http://khibino.github.io/haskell-relational-record/&#34;&gt;Haskell Relational Record&lt;/a&gt; and &lt;a href=&#34;https://hackage.haskell.org/package/groundhog&#34;&gt;groundhog&lt;/a&gt; with &lt;code&gt;ghc 9.4.5&lt;/code&gt;. Neither had releases this year. Also, there are &lt;a href=&#34;https://github.com/hdbc/hdbc&#34;&gt;hdbc&lt;/a&gt; and &lt;a href=&#34;https://github.com/haskellari/postgresql-libpq&#34;&gt;postgresql-libpq&lt;/a&gt; (you might have noticed the &lt;code&gt;libpq&lt;/code&gt; connection string we used here and there).&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;All of these sound fun. But we had enough for now. Maybe we‚Äôll revisit and extend it later.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Okay, so which PostgreSQL library should I use with Haskell?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;I can‚Äôt tell you which library to use. I don‚Äôt know myself.&amp;nbsp;But I can tell you the questions you (and your team) should consider:&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Do you want to write raw sql queries? or query builder? or use some sort of ORM? Do you want to learn a new DSL?&lt;/li&gt; &#xA; &lt;li&gt;How type-safe do you want to be? How readable/optimizable the generated queries should be?&lt;/li&gt; &#xA; &lt;li&gt;Do you need bells and whistles, like built-in connection pools or migrations?&lt;/li&gt; &#xA; &lt;li&gt;How comfortable are you with Haskell and type-level? Is this something you can afford?&lt;/li&gt; &#xA; &lt;li&gt;Do you need to be database agnostic?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also, this is just the tip of the iceberg; we haven‚Äôt discussed specific features, performance, compilation speed‚Ä¶ And spoiler alert: generics, template haskell, and type-families don‚Äôt come for free.&lt;/p&gt; &#xA;&lt;p&gt;We aren‚Äôt really at the point where people care to compare the performance. But you don‚Äôt know unless you measure. Feel free to explore and get some community karma.&lt;/p&gt; &#xA;&lt;p&gt;Another excellent contribution opportunity is documentation and tutorials, especially if you have a favorite library and want to convince others to consider it.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Wait, is it actually bad that we have so many libraries?&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>vrthra/markdown-ieee-pdf</title>
    <updated>2023-10-11T01:30:48Z</updated>
    <id>tag:github.com,2023-10-11:/vrthra/markdown-ieee-pdf</id>
    <link href="https://github.com/vrthra/markdown-ieee-pdf" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A skeletal project to convert a paper written in markdown format to IEEE style paper submission in pdf.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;README&lt;/h1&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;This repository contains materials to generate a paper in pdf in ieee standard.&lt;/p&gt; &#xA;&lt;h2&gt;Layout&lt;/h2&gt; &#xA;&lt;h3&gt;src&lt;/h3&gt; &#xA;&lt;p&gt;This directory contains the source code in &lt;a href=&#34;http://johnmacfarlane.net/pandoc/&#34;&gt;pandoc&lt;/a&gt; markdown wiki format.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;src/paper.md The paper itself in markdown.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;src/read.md The references used in the paper.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;src/meta The meta information such as title, author etc.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;src/req The ieee format specific files for generating pdf from pandoc markdown.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;build&lt;/h3&gt; &#xA;&lt;p&gt;This directory contains the generated pdf output.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;p&gt;You will need pandoc to process the files. If pdf generation is intented, pandoc internally uses latex to generate the pdf files.&lt;/p&gt; &#xA;&lt;p&gt;If you are on ubuntu, these can be accomplished with&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;sudo apt-get install pandoc&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;sudo apt-get install texlive-full&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Generate&lt;/h3&gt; &#xA;&lt;p&gt;Run &#34;make&#34; from the top directory to generate build/ieee_jrnl.pdf&lt;/p&gt; &#xA;&lt;h3&gt;Settings&lt;/h3&gt; &#xA;&lt;p&gt;Ensure that these are run in your terminal.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;git config --global diff.tool vimdiff git config --global difftool.prompt false git config --global alias.d difftool&lt;/p&gt; &#xA;&lt;/blockquote&gt;</summary>
  </entry>
  <entry>
    <title>tydar/yahmdp</title>
    <updated>2023-10-11T01:30:48Z</updated>
    <id>tag:github.com,2023-10-11:/tydar/yahmdp</id>
    <link href="https://github.com/tydar/yahmdp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Yet Another Haskell Markdown Parser&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Yet Another Haskell Markdown Parser&lt;/h1&gt; &#xA;&lt;p&gt;And not a very good one. Deviates from the specification in some ways, some features are not implemented. I&#39;ll document these shortcomings more extensively soon.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;showProcessed $ parseMarkdown &#34;test string&#34;&lt;/p&gt; &#xA;&lt;p&gt;Actual input/output hopefully coming soon.&lt;/p&gt; &#xA;&lt;h1&gt;Shortcomings&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;No links or images yet.&lt;/li&gt; &#xA; &lt;li&gt;No nested lists, or block-type Markdown in lists.&lt;/li&gt; &#xA; &lt;li&gt;Unordered lists can only begin with a +, no - or *.&lt;/li&gt; &#xA; &lt;li&gt;No escaping of characters, only limited encoding.&lt;/li&gt; &#xA; &lt;li&gt;May not give the correct parse every time. I don&#39;t have a test suite yet, so.&lt;/li&gt; &#xA; &lt;li&gt;Probably a lot of other things I haven&#39;t seen because I haven&#39;t tested extextensively. But I did it. I wrote a Markdown parser-ish using only ReadP combinators. That was a bad idea.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>