<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-01T01:36:22Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>geniusyield/market-maker</title>
    <updated>2024-01-01T01:36:22Z</updated>
    <id>tag:github.com,2024-01-01:/geniusyield/market-maker</id>
    <link href="https://github.com/geniusyield/market-maker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Market maker for the Genius Yield DEX&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Market maker bot&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;⚠️ Warning&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;Market making is a risky activity and running this bot can lead to loss of funds.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Market maker bot for &lt;a href=&#34;https://www.geniusyield.co/&#34;&gt;GeniusYield&lt;/a&gt; DEX which implements &lt;em&gt;fixed spread versus market price strategy&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Fixed spread vs market price strategy&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;ⓘ Order classification and price&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;We call non-ada token as &lt;em&gt;commodity&lt;/em&gt; and ada as &lt;em&gt;currency&lt;/em&gt;. Order offering currency in exchange of commodity is called as &lt;em&gt;buy order&lt;/em&gt; whereas order offering commodity in exchange of currency is called as &lt;em&gt;sell order&lt;/em&gt;.&lt;/p&gt; &#xA; &lt;p&gt;&lt;em&gt;Price&lt;/em&gt; is described in display unit[^1] of currency token per display unit of commodity token.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Given a market price &lt;code&gt;M&lt;/code&gt; and a variable &lt;code&gt;δ&lt;/code&gt; defined as &lt;em&gt;spread&lt;/em&gt;, bot would place following orders where exact number and volume is determined by configuration:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Buy orders at price: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;M * (1 - δ)&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;M * (1 - δ - δ / 2)&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;M * (1 - δ - δ / 2 - δ / 2)&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;And so on, where &lt;code&gt;n&lt;/code&gt;th buy order&#39;s price is given by &lt;code&gt;M * (1 - δ - (n - 1) * δ / 2)&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Sell orders at price: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;M * (1 + δ)&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;M * (1 + δ + δ / 2)&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;M * (1 + δ + δ / 2 + δ / 2)&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;And so on, where &lt;code&gt;n&lt;/code&gt;th sell order&#39;s price is given by &lt;code&gt;M * (1 + δ + (n - 1) * δ / 2)&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If market price has drifted way higher (&lt;em&gt;&#34;way higher&#34;&lt;/em&gt; as directed by configuration) than the price at which buy orders were placed, buy orders would be canceled. Likewise, if price has drifted way lower than the price at which sell orders were placed, they would be canceled.&lt;/p&gt; &#xA;&lt;h2&gt;Running the market maker bot&lt;/h2&gt; &#xA;&lt;p&gt;First, you need to setup the necessary tooling to work with &lt;a href=&#34;https://github.com/input-output-hk/haskell.nix&#34;&gt;haskell.nix&lt;/a&gt;, then simply run &lt;code&gt;nix develop&lt;/code&gt;, and it will drop you into a shell with all the necessary tools. Once inside the environment, you can build the order bot with &lt;code&gt;cabal build all&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;ⓘ&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;Nix is not necessary if your environment already has the right set of dependencies. One may look at the &lt;a href=&#34;https://github.com/geniusyield/atlas/raw/main/.github/workflows/haskell.yml&#34;&gt;CI file&lt;/a&gt; for our transaction building tool, which current project also relies on, to see dependencies used.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Then the bot can be ran with following command: &lt;code&gt;cabal run geniusyield-market-maker-exe -- Run my-atlas-config.json my-maker-bot-config.json&lt;/code&gt; where &lt;code&gt;my-atlas-config.json&lt;/code&gt; is the configuration for &lt;a href=&#34;https://github.com/geniusyield/atlas&#34;&gt;Atlas&lt;/a&gt; and &lt;code&gt;my-maker-bot-config.json&lt;/code&gt; is the configuration of our market maker bot.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/market-maker/main/atlas-config-maestro.json&#34;&gt;&lt;code&gt;atlas-config-maestro.json&lt;/code&gt;&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/market-maker/main/atlas-config-kupo.json&#34;&gt;&lt;code&gt;atlas-config-kupo.json&lt;/code&gt;&lt;/a&gt; as an example of Atlas configuration using &lt;a href=&#34;https://www.gomaestro.org/&#34;&gt;Maestro&lt;/a&gt; provider &amp;amp; local node with &lt;a href=&#34;https://github.com/CardanoSolutions/kupo&#34;&gt;Kupo&lt;/a&gt; respectively.&lt;/p&gt; &#xA;&lt;h3&gt;Bot configuration&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;ⓘ&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/market-maker/main/sample-preprod-maker-bot-config-gens.json&#34;&gt;&lt;code&gt;sample-preprod-maker-bot-config-gens.json&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/geniusyield/market-maker/main/sample-mainnet-maker-bot-config-gens.json&#34;&gt;&lt;code&gt;sample-mainnet-maker-bot-config-gens.json&lt;/code&gt;&lt;/a&gt; for sample Preprod and Mainnet market maker bot configuration respectively.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;mbc_user&#34;: {&#xA;    &#34;ur_s_key_path&#34;: &#34;path-to-skey&#34;,&#xA;    &#34;ur_coll&#34;: &#34;tx-id#tx-ix&#34;&#xA;  },&#xA;  &#34;mbc_fp_nft_policy&#34;: &#34;compiled-scripts/minting-policy&#34;,&#xA;  &#34;mbc_fp_order_validator&#34;: &#34;compiled-scripts/partial-order&#34;,&#xA;  &#34;mbc_po_config_addr&#34;: &#34;addr_test1wrgvy8fermjrruaf7fnndtmpuw4xx4cnvfqjp5zqu8kscfcvh32qk&#34;,&#xA;  &#34;mbc_po_refs&#34;: {&#xA;    &#34;por_ref_nft&#34;: &#34;fae686ea8f21d567841d703dea4d4221c2af071a6f2b433ff07c0af2.8309f9861928a55d37e84f6594b878941edce5e351f7904c2c63b559bde45c5c&#34;,&#xA;    &#34;por_val_ref&#34;: &#34;be6f8dc16d4e8d5aad566ff6b5ffefdda574817a60d503e2a0ea95f773175050#2&#34;,&#xA;    &#34;por_mint_ref&#34;: &#34;be6f8dc16d4e8d5aad566ff6b5ffefdda574817a60d503e2a0ea95f773175050#1&#34;&#xA;  },&#xA;  &#34;mbc_delay&#34;: 120000000,&#xA;  &#34;mbc_price_config&#34;: {&#xA;    &#34;pc_api_key&#34;: &#34;&amp;lt;&amp;lt;MAESTRO_TOKEN&amp;gt;&amp;gt;&#34;,&#xA;    &#34;pc_network_id&#34;: &#34;mainnet&#34;,&#xA;    &#34;pc_dex&#34;: &#34;genius-yield&#34;,&#xA;    &#34;pc_override&#34;: {&#xA;      &#34;mpo_commodity_token&#34;: &#34;c6e65ba7878b2f8ea0ad39287d3e2fd256dc5c4160fc19bdf4c4d87e.7447454e53&#34;,&#xA;      &#34;mpo_pair&#34;: &#34;ADA-GENS&#34;,&#xA;      &#34;mpo_commodity_is_first&#34;: false&#xA;    }&#xA;  },&#xA;  &#34;mbc_strategy_config&#34;: {&#xA;    &#34;sc_spread&#34;: {&#xA;      &#34;numerator&#34;: 1,&#xA;      &#34;denominator&#34;: 100&#xA;    },&#xA;    &#34;sc_token_volume&#34;: {&#xA;      &#34;tv_sell_min_vol&#34;: 1000000000,&#xA;      &#34;tv_buy_min_vol&#34;: 2000000000,&#xA;      &#34;tv_sell_budget&#34;: 3500000000,&#xA;      &#34;tv_buy_budget&#34;: 6600000000,&#xA;      &#34;tv_sell_vol_threshold&#34;: 10000000000,&#xA;      &#34;tv_buy_vol_threshold&#34;: 20000000000&#xA;    },&#xA;    &#34;sc_price_check_product&#34;: 9,&#xA;    &#34;sc_cancel_threshold_product&#34;: 4&#xA;  },&#xA;  &#34;mbc_token&#34;: {&#xA;    &#34;stAc&#34;: &#34;c6e65ba7878b2f8ea0ad39287d3e2fd256dc5c4160fc19bdf4c4d87e.7447454e53&#34;,&#xA;    &#34;stPrecision&#34;: 6&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;mbc_user&lt;/code&gt; describes individual bot, it specifies &lt;code&gt;ur_s_key_path&lt;/code&gt; which is the path to signing key file and &lt;code&gt;ur_coll&lt;/code&gt; which is the UTxO reserved as collateral.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fields &lt;code&gt;mbc_fp_nft_policy&lt;/code&gt;, &lt;code&gt;mbc_fp_order_validator&lt;/code&gt;, &lt;code&gt;mbc_po_config_addr&lt;/code&gt; and &lt;code&gt;mbc_po_refs&lt;/code&gt; relate to DEX smart contracts and can be left as it is.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;mbc_delay&lt;/code&gt; - Bot in single iteration tries to determine which orders need to be placed and which are needed to be cancelled. Once determined, it tries building the transactions and proceeds with submitting them, completing this single iteration. &lt;code&gt;mbc_delay&lt;/code&gt; determines time in microseconds that bot must wait before proceeding with next iteration.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;mbc_price_config&lt;/code&gt; gives the configuration on how to get market price using &lt;a href=&#34;https://docs.gomaestro.org/DefiMarketAPI/mkt-dex-ohlc&#34;&gt;https://docs.gomaestro.org/DefiMarketAPI/mkt-dex-ohlc&lt;/a&gt; Maestro endpoint, for a token.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;pc_api_key&lt;/code&gt; is the Maestro API key.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;pc_network_id&lt;/code&gt; determines Cardano network which is mentioned for in API calls. It should always be kept &lt;code&gt;mainnet&lt;/code&gt; as of now.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;pc_dex&lt;/code&gt; determines DEX from which market price is queried for. Currently &lt;code&gt;minswap&lt;/code&gt; &amp;amp; &lt;code&gt;genius-yield&lt;/code&gt; are supported.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;pc_override&lt;/code&gt; is optional and is needed in case one is not running bot on Mainnet. Since tokens on test network aren&#39;t actively traded, their price is not returned for by Maestro endpoint. To still get mainnet price for them, one can override the token given by &lt;code&gt;mpo_commodity_token&lt;/code&gt; to pair with commodity token as described by &lt;code&gt;mpo_pair&lt;/code&gt; &amp;amp; &lt;code&gt;mpo_commodity_is_first&lt;/code&gt; respectively. In the above configuration, we are overriding the testnet GENS asset class &lt;code&gt;c6e65ba7878b2f8ea0ad39287d3e2fd256dc5c4160fc19bdf4c4d87e.7447454e53&lt;/code&gt;, for the mainnet token pair &lt;code&gt;ADA-GENS&lt;/code&gt;, and GENS is the second token in the pair so &lt;code&gt;mpo_commodity_is_first&lt;/code&gt; is set to &lt;strong&gt;false&lt;/strong&gt;. If the pair instead was &lt;code&gt;GENS-ADA&lt;/code&gt; then &lt;code&gt;mpo_commodity_is_first&lt;/code&gt; should be set to &lt;strong&gt;true&lt;/strong&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;mbc_strategy_config&lt;/code&gt; determines parameters for strategy:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;sc_spread&lt;/code&gt; - Ratio representing &lt;code&gt;δ&lt;/code&gt; as described before.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;sc_cancel_threshold_product&lt;/code&gt; - If the price in buy order is less than &lt;code&gt;(1 - sc_cancel_threshold_product * δ) * M&lt;/code&gt;, then it is canceled. Likewise if the price in sell order is greater than &lt;code&gt;(1 + sc_cancel_threshold_product * δ) * M&lt;/code&gt; then it is canceled.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;sc_token_volume&lt;/code&gt; specifies following: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;tv_sell_min_vol&lt;/code&gt; - Amount of commodity tokens (in lowest possible denomination) that order must at least offer.&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;tv_buy_min_vol&lt;/code&gt; - Amount of currency tokens (in lovelaces) that order must at least offer.&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;tv_sell_budget&lt;/code&gt; - Total amount of commodity tokens that bot can cumulatively offer in the orders. In every iteration, bot determines the number of commodity tokens locked in the orders and subtracts it from &lt;code&gt;tv_sell_budget&lt;/code&gt; field, let&#39;s call the obtained number &lt;code&gt;asb&lt;/code&gt; (short for &lt;em&gt;available sell budget&lt;/em&gt;) then it determines number of sell orders placed to be &lt;code&gt;⌊asb / tv_sell_min_vol⌋ = ns&lt;/code&gt; where &lt;code&gt;ns&lt;/code&gt; is short of number of sell orders. Now bot would place &lt;code&gt;ns&lt;/code&gt; sell orders, each having offer amount as &lt;code&gt;⌊asb / ns⌋&lt;/code&gt;.&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;tv_buy_budget&lt;/code&gt; - Total amount of currency tokens that bot can cumulatively offer in the orders. It governs bot symmetric to &lt;code&gt;tv_sell_budget&lt;/code&gt;.&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;tv_sell_vol_threshold&lt;/code&gt; - this is related to &lt;code&gt;sc_price_check_product&lt;/code&gt;. Bot would build an order book from all the orders for the given pair in GeniusYield DEX. It will sum the offered commodity tokens for sell orders which have price less than &lt;code&gt;M * (1 + sc_price_check_product * δ)&lt;/code&gt; to get &lt;code&gt;SV&lt;/code&gt; (short for sell volume) and sum the asked commodity tokens for buy orders which have price greater than &lt;code&gt;M * (1 + sc_price_check_product * δ)&lt;/code&gt; to get &lt;code&gt;BV&#39;&lt;/code&gt; (short for buy volume in commodity token). We&#39;ll multiply &lt;code&gt;BV&#39;&lt;/code&gt; with &lt;code&gt;M&lt;/code&gt; to get &lt;code&gt;BV&lt;/code&gt; to represent buy volume in currency token. Now, bot would not place a new sell order, if &lt;code&gt;tv_sell_vol_threshold&lt;/code&gt; is less than or equal to &lt;code&gt;SV&lt;/code&gt;. Idea is that if there is enough liquidity than bot need not place orders. Symmetrically, bot would not place new buy orders only if &lt;code&gt;tv_buy_vol_threshold&lt;/code&gt; is less than or equal to &lt;code&gt;BV&lt;/code&gt;.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Canceling all the orders&lt;/h2&gt; &#xA;&lt;p&gt;If you want to cancel orders placed by the simulator you can run &lt;code&gt;cabal run geniusyield-market-maker-exe -- Cancel my-atlas-config.json my-maker-bot-config.json&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Known Issues&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When bot tries to place multiple orders in a single iteration, it might happen that we pick same UTxO against different transaction skeletons (due to a &lt;a href=&#34;https://github.com/geniusyield/dex-contracts-api/raw/cf360d6c1db8185b646a34ed8f6bb330c23774bb/src/GeniusYield/Api/Dex/PartialOrder.hs#L489-L498&#34;&gt;quirk&lt;/a&gt; where place order operation specifies UTxO to be spent in skeleton itself), leading to successful building of only some of the transaction skeletons and thus only few of the orders might be successfully placed even though bot might very well have the required funds to place all. Now bot can place remaining ones in next iteration but as of now, these next orders are placed starting with initial spread difference from market price leading to a situation where bot might have multiple orders at the same price.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;[^1]: &lt;em&gt;Display unit&lt;/em&gt; is one to which decimals are added as directed under &lt;a href=&#34;https://github.com/cardano-foundation/cardano-token-registry&#34;&gt;&lt;code&gt;cardano-token-registry&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>google/proto-lens</title>
    <updated>2024-01-01T01:36:22Z</updated>
    <id>tag:github.com,2024-01-01:/google/proto-lens</id>
    <link href="https://github.com/google/proto-lens" rel="alternate"></link>
    <summary type="html">&lt;p&gt;API for protocol buffers using modern Haskell language and library patterns.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;proto-lens&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/google/proto-lens&#34;&gt;&lt;img src=&#34;https://travis-ci.org/google/proto-lens.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The proto-lens library provides an API for protocol buffers using modern Haskell language and library patterns. Specifically, it provides:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Composable field accessors via lenses&lt;/li&gt; &#xA; &lt;li&gt;Simple field name resolution/overloading via type-level literals&lt;/li&gt; &#xA; &lt;li&gt;Type-safe reflection and encoding/decoding of messages via GADTs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is not an official Google product.&lt;/p&gt; &#xA;&lt;h1&gt;Tutorial&lt;/h1&gt; &#xA;&lt;p&gt;You can find tutorial documentation in the &lt;a href=&#34;https://raw.githubusercontent.com/google/proto-lens/master/proto-lens-tutorial&#34;&gt;proto-lens-tutorial&lt;/a&gt; subdir.&lt;/p&gt; &#xA;&lt;p&gt;There is also a &lt;a href=&#34;https://raw.githubusercontent.com/google/proto-lens/master/docs/types.md&#34;&gt;reference document&lt;/a&gt; showing the protobuf scalar type -&amp;gt; haskell type mappings used by the generated lenses.&lt;/p&gt; &#xA;&lt;h1&gt;Instructions&lt;/h1&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;First, install the &#34;protoc&#34; binary somewhere in your PATH. You can get it by following &lt;a href=&#34;https://raw.githubusercontent.com/google/proto-lens/master/docs/installing-protoc.md&#34;&gt;these instructions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This project requires at least &lt;code&gt;protoc&lt;/code&gt; version 3.12.0.&lt;/p&gt; &#xA;&lt;h2&gt;Building from HEAD&lt;/h2&gt; &#xA;&lt;p&gt;To build and test this repository from HEAD, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git submodule update --init --recursive&#xA;stack test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: building this repository requires &lt;code&gt;stack-2.3.1&lt;/code&gt; or newer.&lt;/p&gt; &#xA;&lt;h2&gt;Using in a Cabal or Stack package&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;proto-lens&lt;/code&gt; is available on Hackage and Stackage. Cabal and Stack projects can use it to auto-generate Haskell source files from the original protocol buffer specifications (&lt;code&gt;.proto&lt;/code&gt; files).&lt;/p&gt; &#xA;&lt;p&gt;Note: if using Stack, these instructions require &lt;code&gt;v1.4.0&lt;/code&gt; or newer.&lt;/p&gt; &#xA;&lt;p&gt;First, edit the &lt;code&gt;.cabal&lt;/code&gt; file of your project to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Specify &lt;code&gt;build-type: Custom&lt;/code&gt;, and add a &lt;code&gt;custom-setup&lt;/code&gt; clause that depends on &lt;code&gt;proto-lens-setup&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;build-tool-depends: proto-lens-protoc:proto-lens-protoc&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;List the .proto files in &lt;code&gt;extra-source-files&lt;/code&gt;. Note that the field belongs at the top level of the &lt;code&gt;.cabal&lt;/code&gt; file, rather than once per library/executable/etc.&lt;/li&gt; &#xA; &lt;li&gt;List the generated modules (e.g. &lt;code&gt;Proto.Foo.Bar&lt;/code&gt;) in &lt;code&gt;exposed-modules&lt;/code&gt; or &lt;code&gt;other-modules&lt;/code&gt; of the rule(s) that use them (e.g. the library or executables).&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;proto-lens-runtime&lt;/code&gt; to the build-depends of those rules.&lt;/li&gt; &#xA; &lt;li&gt;Add a &lt;code&gt;custom-setup&lt;/code&gt; clause to your .cabal file.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example, in &lt;code&gt;foo-bar-proto.cabal&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;...&#xA;build-type: Custom&#xA;extra-source-files: src/foo/bar.proto&#xA;...&#xA;custom-setup&#xA;  setup-depends: base, Cabal, proto-lens-setup&#xA;  build-tool-depends: proto-lens-protoc:proto-lens-protoc&#xA;&#xA;library&#xA;    exposed-modules: Proto.Foo.Bar, Proto.Foo.Bar_Fields&#xA;    autogen-modules: Proto.Foo.Bar, Proto.Foo.Bar_Fields&#xA;    build-depends: proto-lens-runtime, ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(&lt;strong&gt;Note:&lt;/strong&gt; if you do not have &lt;code&gt;proto-lens-{runtime/setup}&lt;/code&gt;, you are probably using a version earlier than &lt;code&gt;0.4&lt;/code&gt; and should replace those packages with &lt;code&gt;proto-lens-protoc&lt;/code&gt;.)&lt;/p&gt; &#xA;&lt;p&gt;Next, write a &lt;code&gt;Setup.hs&lt;/code&gt; file that uses &lt;code&gt;Data.ProtoLens.Setup&lt;/code&gt; and specifies the directory containing the &lt;code&gt;.proto&lt;/code&gt; files. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;import Data.ProtoLens.Setup&#xA;&#xA;main = defaultMainGeneratingProtos &#34;src&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, when you run &lt;code&gt;cabal build&lt;/code&gt; or &lt;code&gt;stack build&lt;/code&gt;, Cabal will generate a Haskell file from each .proto file, and use it as part of building the library/executable/etc.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;code&gt;proto-lens-tests&lt;/code&gt; package for some more detailed examples.&lt;/p&gt; &#xA;&lt;h2&gt;Manually running the protocol compiler&lt;/h2&gt; &#xA;&lt;p&gt;Suppose you have a file &lt;code&gt;foo.proto&lt;/code&gt;. Then to generate bindings, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;protoc --plugin=protoc-gen-haskell=`which proto-lens-protoc` \&#xA;    --haskell_out=. foo.proto&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will generate a file &lt;code&gt;Proto/Foo.hs&lt;/code&gt; which contains Haskell definitions corresponding to the messages and fields in the protocol buffer file.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;--haskell_out&lt;/code&gt; to control the location of the output file.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;--proto_path&lt;/code&gt; to specify the location of input &lt;code&gt;.proto&lt;/code&gt; files. For example, suppose we have the files &lt;code&gt;src/project/{foo,bar}.proto&lt;/code&gt;, and &lt;code&gt;bar.proto&lt;/code&gt; has the line&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;import &#34;project/foo.proto&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;protoc --plugin=protoc-gen-haskell=`which proto-lens-protoc` \&#xA;    --haskell_out=. \&#xA;    --proto_path=src \&#xA;    src/project/foo.proto src/project/bar.proto&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will generate the haskell files &lt;code&gt;Proto/Project/{Foo,Bar}.hs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Current differences from the standard&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Extensions (proto2-only) are not supported.&lt;/li&gt; &#xA; &lt;li&gt;Unknown proto2 enum values cause a decoding error, instead of being preserved round-trip.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Troubleshooting&lt;/h1&gt; &#xA;&lt;h2&gt;Rebuilding&lt;/h2&gt; &#xA;&lt;p&gt;Due to &lt;a href=&#34;https://github.com/commercialhaskell/stack/issues/1891&#34;&gt;stack issue #1891&lt;/a&gt;, if you only change the .proto files then stack won&#39;t rebuild the package (that is, it won&#39;t regenerate the &lt;code&gt;Proto.*&lt;/code&gt; modules).&lt;/p&gt; &#xA;&lt;h2&gt;Loading into &lt;code&gt;ghci&lt;/code&gt; with Stack&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;stack ghci&lt;/code&gt; can get confused when trying to directly load a package that generates &lt;code&gt;Proto.*&lt;/code&gt; modules (for example: &lt;code&gt;stack ghci &amp;lt;proto-package&amp;gt;&lt;/code&gt;). To work around this issue, run instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;stack exec ghci --package &amp;lt;proto-package&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then manually import the generated modules within ghci, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Prelude&amp;gt; import Proto.Foo.Bar&#xA;Prelude Proto.Foo.Bar&amp;gt;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternately, you can make those modules available at the same time as another local package, by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;stack ghci &amp;lt;another-package&amp;gt; --package &amp;lt;proto-package&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Linking errors&lt;/h2&gt; &#xA;&lt;p&gt;Due to the limitations of how we can specify the dependencies of Setup files, stack may try to link them against the &lt;code&gt;terminfo&lt;/code&gt; package. You may get an error from &lt;code&gt;stack build&lt;/code&gt; similar to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/usr/bin/ld: cannot find -ltinfo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On a Debian based system (like Ubuntu), the remedy is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install libncurses5-dev&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>