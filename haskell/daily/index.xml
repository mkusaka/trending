<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-31T01:34:47Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>matthewbauer/ghc-nix</title>
    <updated>2022-10-31T01:34:47Z</updated>
    <id>tag:github.com,2022-10-31:/matthewbauer/ghc-nix</id>
    <link href="https://github.com/matthewbauer/ghc-nix" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Exploring the options for incremental Haskell builds using Nix&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;code&gt;ghc-nix&lt;/code&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/uXdKz7iOeohpwRAgd14i4VAUp?autoplay=1&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/uXdKz7iOeohpwRAgd14i4VAUp.svg?sanitize=true&#34; alt=&#34;demo&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ghc-nix&lt;/code&gt; is an attempt to augment GHC with the ability to use Nix as a caching layer. This has the potential to dramatically speed up &#34;pure Nix&#34; builds by being able to re-use build artefacts for files that haven&#39;t changed. It also has the potential to speed up developers collaborating on work, by allowing them to pull down pre-built artefacts from a shared build server, rather than building locally.&lt;/p&gt; &#xA;&lt;h1&gt;What&#39;s the Plan?&lt;/h1&gt; &#xA;&lt;p&gt;When you do &lt;code&gt;cabal build&lt;/code&gt;, Cabal calls out to GHC with a single &lt;code&gt;exec&lt;/code&gt; call, primarily to &lt;code&gt;ghc --make&lt;/code&gt;. GHC actually has a build system built in, and GHC will form a dependency graph and start doing minimal recompilation where possible. However, this is only useful if you have some kind of reusable directory to keep the cache artefacts - and that doesn&#39;t exist on build machines like Hydra.&lt;/p&gt; &#xA;&lt;p&gt;The plan then is to &lt;em&gt;replace&lt;/em&gt; &lt;code&gt;ghc --make&lt;/code&gt; with something that can use the Nix store. &lt;code&gt;cabal build&lt;/code&gt; has the &lt;code&gt;-w&lt;/code&gt; option to give it another compiler, but it will still call that executable with the same arguments. If we can impersonate GHC, then we can get the caching we desire - that&#39;s what this project does.&lt;/p&gt; &#xA;&lt;p&gt;When &lt;code&gt;ghc-nix&lt;/code&gt; is called with &lt;code&gt;--make&lt;/code&gt;, we use the GHC API to form a dependency graph, as &lt;code&gt;ghc --make&lt;/code&gt; would. However, rather than just doing the build, instead we transform this dependency graph into a series of Nix expressions, each of which will build a single &lt;code&gt;.hs&lt;/code&gt; source file into &lt;code&gt;.o&lt;/code&gt; and &lt;code&gt;.hi&lt;/code&gt; files. Finally, we aggregate all the build artefacts and place the files where they need to go for Cabal to continue with the next phase (linking).&lt;/p&gt; &#xA;&lt;p&gt;However, just doing Nix builds is not enough, we need one more experimental Nix feature to get something useful - content-addressable store paths. Usually, the objects in a Nix store are hashed based on all of the dependencies that are required to produce the store path. This ultimately comes down to an exact hash of all the source code. However, this means that if you make object-file-preserving changes, you still end up recompiling everything downstream. For example, a single comment change causes all dependents to rebuild, even though they can&#39;t observe a change.&lt;/p&gt; &#xA;&lt;p&gt;Once we&#39;ve built the &lt;code&gt;.o&lt;/code&gt; and &lt;code&gt;.hi&lt;/code&gt; files, we rewrite the resulting store path to one who&#39;s hash is based on the contents of these files, and not the the files that built them. This cuts the connection between an object file and its source code, allowing early cut off.&lt;/p&gt; &#xA;&lt;p&gt;This is supported as an experimental Nix feature - &lt;code&gt;nix make-content-addressable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Trying this Out&lt;/h1&gt; &#xA;&lt;p&gt;This project is still in very early days, so it&#39;s not too easy to use... yet. Maybe you can help here! To try &lt;code&gt;ghc-nix&lt;/code&gt; out you will need:&lt;/p&gt; &#xA;&lt;h2&gt;Nix changes&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;A version of Nix that is at least &lt;code&gt;4511f09b490fad4ce0dcfbcd7c4fd83b11e7df46&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;nix-command&lt;/code&gt; and &lt;code&gt;ca-references&lt;/code&gt; enabled as experimental features.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Heres&#39;s a snippet of my &lt;code&gt;configuration.nix&lt;/code&gt; that should get you this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;{&#xA;  systemFeatures =&#xA;    [ &#34;benchmark&#34; &#34;big-parallel&#34; &#34;kvm&#34; &#34;nixos-test&#34; &#34;recursive-nix&#34; &#34;nix-command&#34; &#34;ca-references&#34; ];&#xA;&#xA;  extraOptions =&#xA;    &#39;&#39;&#xA;    experimental-features = recursive-nix nix-command ca-references&#xA;    &#39;&#39;;&#xA;&#xA;  package =&#xA;    let&#xA;      src =&#xA;        pkgs.fetchFromGitHub&#xA;          { owner =&#xA;              &#34;NixOS&#34;;&#xA;&#xA;            repo =&#xA;              &#34;nix&#34;;&#xA;&#xA;            rev =&#xA;              &#34;9f7b4d068cc106e5d902dc6f52bf46d4a057fd00&#34;;&#xA;&#xA;            sha256 =&#xA;              &#34;187pfanj0g49ng5smfi8rwkq1l3r43mf85yv390h0ars050fxfik&#34;;&#xA;          };&#xA;&#xA;    in&#xA;    ( import &#34;${src}/release.nix&#34; { nix = src; officialRelease = true; } ).build.x86_64-linux;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building &lt;code&gt;ghc-nix&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;ghc-nix&lt;/code&gt; is built like a normal Haskell project, but you will have to actually use &lt;code&gt;cabal install&lt;/code&gt; to have this work. I do this, in the &lt;code&gt;ghc-nix&lt;/code&gt; directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cabal install --installdir=./bin --overwrite-policy=always&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using &lt;code&gt;ghc-nix&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;You can now finally use &lt;code&gt;ghc-nix&lt;/code&gt; by going to a Cabal project and running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cabal build -w /path/to/ghc-nix/bin/ghc-nix&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will need a working &lt;code&gt;ghc&lt;/code&gt; on your &lt;code&gt;PATH&lt;/code&gt;, too (this will hopefully change in the future).&lt;/p&gt; &#xA;&lt;p&gt;If you get problems with packages not being found and you&#39;re using Nix, you might need to run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shsh&#34;&gt;NIX_GHC=$(type -p ghc)&#xA;eval $(grep export &#34;$NIX_GHC&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>