<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-03T01:36:14Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>upenn-cis5520/01-basics</title>
    <updated>2022-09-03T01:36:14Z</updated>
    <id>tag:github.com,2022-09-03:/upenn-cis5520/01-basics</id>
    <link href="https://github.com/upenn-cis5520/01-basics" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;The description of these modules and in-class exercises will be posted on the &lt;a href=&#34;https://www.seas.upenn.edu/~cis5520/current/schedule.html&#34;&gt;CIS 5520 website&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>bishboria/rpncalculator</title>
    <updated>2022-09-03T01:36:14Z</updated>
    <id>tag:github.com,2022-09-03:/bishboria/rpncalculator</id>
    <link href="https://github.com/bishboria/rpncalculator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An rpn calculator in Haskell&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>ethereum/hevm</title>
    <updated>2022-09-03T01:36:14Z</updated>
    <id>tag:github.com,2022-09-03:/ethereum/hevm</id>
    <link href="https://github.com/ethereum/hevm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;hevm&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;code&gt;hevm&lt;/code&gt; project is an implementation of the Ethereum virtual machine (EVM) made specifically for symbolic execution, unit testing and debugging of smart contracts. The &lt;code&gt;hevm&lt;/code&gt; command line program can symbolically execute smart contracts, run unit tests, interactively debug contracts while showing the Solidity source, or run arbitrary EVM code. Computations can be performed using local state set up in a &lt;code&gt;dapp&lt;/code&gt; testing harness, or fetched on demand from live networks using &lt;code&gt;rpc&lt;/code&gt; calls.&lt;/p&gt; &#xA;&lt;p&gt;It was originally developed as part of the &lt;a href=&#34;https://github.com/dapphub/dapptools/&#34;&gt;dapptools&lt;/a&gt; project, and was forked to this repo by the formal methods team at the Ethereum Foundation in August 2022.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;Note: some &lt;code&gt;hevm&lt;/code&gt; commands (&lt;code&gt;dapp-test&lt;/code&gt;) assume the use of the &lt;code&gt;ds-test&lt;/code&gt; framework for Solidity unit tests and the &lt;a href=&#34;https://github.com/dapphub/dapptools/tree/master/src/dapp&#34;&gt;&lt;code&gt;dapp&lt;/code&gt; tool suite&lt;/a&gt;, while others (&lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;symbolic&lt;/code&gt;, ...) are available as standalone commands.&lt;/p&gt; &#xA;&lt;h3&gt;Commands&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;hevm -- Ethereum evaluator&#xA;&#xA;Usage: hevm [&amp;lt;options&amp;gt;] &amp;lt;command&amp;gt;&#xA;   or: hevm &amp;lt;command&amp;gt; --help&#xA;&#xA;Commands:&#xA;&#xA;  symbolic        Execute symbolically, exploring all possible execution paths&#xA;  exec            Execute a given program with specified env &amp;amp; calldata&#xA;  equivalence     Prove equivalence between two programs using symbolic execution&#xA;  dapp-test       Run unit tests&#xA;&#xA;  bc-test         Run an Ethereum Blockchain/GeneralState test&#xA;  merkle-test     Run a merkle test file and ensure the root matches&#xA;  compliance      Run Blockchain compliance report&#xA;&#xA;  emacs           Emacs console&#xA;  version         Show hevm version&#xA;  flatten         Concat all dependencies for a given source file&#xA;  rlp             Decode a RLP encoded bytestring&#xA;  strip-metadata  Remove metadata from contract code bytestring&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Interactive debugger key bindings&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Esc&lt;/code&gt;: exit debugger&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a&lt;/code&gt;: step to start&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;e&lt;/code&gt;: step to end&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;n&lt;/code&gt;: step forwards by one instruction&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;p&lt;/code&gt;: step backwards by one instruction&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;0&lt;/code&gt;: choose the branch which does not jump&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;1&lt;/code&gt;: choose the branch which does jump&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;N&lt;/code&gt;: step to the next source position&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;P&lt;/code&gt;: step previous source position&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;C-n&lt;/code&gt;: step to the next source position and don&#39;t enter &lt;code&gt;CALL&lt;/code&gt; or &lt;code&gt;CREATE&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;C-p&lt;/code&gt;: step previous source position without entering&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;m&lt;/code&gt;: toggle memory view&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Down&lt;/code&gt; : step to next entry in the callstack / Scroll memory pane\n&#34; &amp;lt;&amp;gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Up&lt;/code&gt; : step to previous entry in the callstack / Scroll memory pane\n&#34; &amp;lt;&amp;gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;h&lt;/code&gt;: show key-binding help&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;hevm symbolic&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Usage: hevm symbolic [--code TEXT] [--calldata TEXT] [--address ADDR]&#xA;                     [--caller ADDR] [--origin ADDR] [--coinbase ADDR]&#xA;                     [--value W256] [--nonce W256] [--gas W256] [--number W256]&#xA;                     [--timestamp W256] [--gaslimit W256] [--gasprice W256]&#xA;                     [--create] [--maxcodesize W256] [--difficulty W256]&#xA;                     [--chainid W256] [--rpc TEXT] [--block W256]&#xA;                     [--state STRING] [--cache STRING] [--json-file STRING]&#xA;                     [--dapp-root STRING] [--storage-model STORAGEMODEL]&#xA;                     [--sig TEXT] [--arg STRING]... [--debug] [--get-models]&#xA;                     [--show-tree] [--smttimeout INTEGER]&#xA;                     [--max-iterations INTEGER] [--solver TEXT] [--smtdebug]&#xA;                     [--assertions [WORD256]] [--ask-smt-iterations INTEGER]&#xA;&#xA;Available options:&#xA;  -h,--help                Show this help text&#xA;  --code TEXT              Program bytecode&#xA;  --calldata TEXT          Tx: calldata&#xA;  --address ADDR           Tx: address&#xA;  --caller ADDR            Tx: caller&#xA;  --origin ADDR            Tx: origin&#xA;  --coinbase ADDR          Block: coinbase&#xA;  --value W256             Tx: Eth amount&#xA;  --nonce W256             Nonce of origin&#xA;  --gas W256               Tx: gas amount&#xA;  --number W256            Block: number&#xA;  --timestamp W256         Block: timestamp&#xA;  --gaslimit W256          Tx: gas limit&#xA;  --gasprice W256          Tx: gas price&#xA;  --create                 Tx: creation&#xA;  --maxcodesize W256       Block: max code size&#xA;  --difficulty W256        Block: difficulty&#xA;  --chainid W256           Env: chainId&#xA;  --rpc TEXT               Fetch state from a remote node&#xA;  --block W256             Block state is be fetched from&#xA;  --state STRING           Path to state repository&#xA;  --cache STRING           Path to rpc cache repository&#xA;  --json-file STRING       Filename or path to dapp build output (default:&#xA;                           out/*.solc.json)&#xA;  --dapp-root STRING       Path to dapp project root directory (default: . )&#xA;  --storage-model STORAGEMODEL&#xA;                           Select storage model: ConcreteS, SymbolicS (default)&#xA;                           or InitialS&#xA;  --sig TEXT               Signature of types to decode / encode&#xA;  --arg STRING             Values to encode&#xA;  --debug                  Run interactively&#xA;  --get-models             Print example testcase for each execution path&#xA;  --show-tree              Print branches explored in tree view&#xA;  --smttimeout INTEGER     Timeout given to SMT solver in milliseconds (default:&#xA;                           60000)&#xA;  --max-iterations INTEGER Number of times we may revisit a particular branching&#xA;                           point&#xA;  --solver TEXT            Used SMT solver: z3 (default) or cvc4&#xA;  --smtdebug               Print smt queries sent to the solver&#xA;  --assertions [WORD256]   Comma seperated list of solc panic codes to check for&#xA;                           (default: everything except arithmetic overflow)&#xA;  --ask-smt-iterations INTEGER&#xA;                           Number of times we may revisit a particular branching&#xA;                           point before we consult the smt solver to check&#xA;                           reachability (default: 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run a symbolic execution against the given parameters, searching for assertion violations.&lt;/p&gt; &#xA;&lt;p&gt;Counterexamples will be returned for any reachable assertion violations. Where an assertion violation is defined as either an execution of the invalid opcode (&lt;code&gt;0xfe&lt;/code&gt;), or a revert with a message of the form &lt;code&gt;abi.encodeWithSelector(&#39;Panic(uint256)&#39;, errCode)&lt;/code&gt; with &lt;code&gt;errCode&lt;/code&gt; being one of the predefined solc assertion codes defined &lt;a href=&#34;https://docs.soliditylang.org/en/latest/control-structures.html#panic-via-assert-and-error-via-require&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By default hevm ignores assertion violations that result from arithmetic overflow (&lt;code&gt;Panic(0x11)&lt;/code&gt;), although this behaviour can be customised via the &lt;code&gt;--assertions&lt;/code&gt; flag. For example, the following will return counterexmaples for arithmetic overflow (&lt;code&gt;0x11&lt;/code&gt;) and user defined assertions (&lt;code&gt;0x01&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hevm symbolic --code $CODE --assertions &#39;[0x01, 0x11]&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;--debug&lt;/code&gt; enters an interactive debugger where the user can navigate the full execution space.&lt;/p&gt; &#xA;&lt;p&gt;The default value for &lt;code&gt;calldata&lt;/code&gt; and &lt;code&gt;caller&lt;/code&gt; are symbolic values, but can be specialized to concrete functions with their corresponding flags.&lt;/p&gt; &#xA;&lt;p&gt;One can also specialize specific arguments to a function signature, while leaving others abstract. If &lt;code&gt;--sig&lt;/code&gt; is given, calldata is assumed to be of the form suggested by the function signature. With this flag, specific arguments can be instantiated to concrete values via the &lt;code&gt;--arg&lt;/code&gt; flag.&lt;/p&gt; &#xA;&lt;p&gt;This is best illustrated through a few examples:&lt;/p&gt; &#xA;&lt;p&gt;Calldata specialized to the bytestring &lt;code&gt;0xa9059cbb&lt;/code&gt; followed by 64 symbolic bytes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;hevm symbolic --sig &#34;transfer(address,uint256)&#34; --code $(&amp;lt;dstoken.bin-runtime)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Calldata specialized to the bytestring &lt;code&gt;0xa9059cbb0000000000000000000000007cfa93148b0b13d88c1dce8880bd4e175fb0dedf&lt;/code&gt; followed by 32 symbolic bytes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;hevm symbolic --sig &#34;transfer(address,uint256)&#34; --arg 0x7cFA93148B0B13d88c1DcE8880bd4e175fb0DeDF --code $(&amp;lt;dstoken.bin-runtime)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Calldata specialized to the bytestring &lt;code&gt;0xa9059cbb&lt;/code&gt; followed by 32 symbolic bytes, followed by the bytestring &lt;code&gt;0000000000000000000000000000000000000000000000000000000000000000&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;hevm symbolic --sig &#34;transfer(address,uint256)&#34; --arg &#34;&amp;lt;symbolic&amp;gt;&#34; --arg 0 --code $(&amp;lt;dstoken.bin-runtime)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the &lt;code&gt;--get-models&lt;/code&gt; flag is given, example input values will be returned for each possible execution path. This can be useful for automatic test case generation.&lt;/p&gt; &#xA;&lt;p&gt;The default timeout for SMT queries is no timeout. If your program is taking longer than a couple of minutes to run, you can experiment with configuring the timeout to somewhere around 10s by doing &lt;code&gt;--smttimeout 10000&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Storage can take one of three forms, defaulting to &lt;code&gt;SymbolicS&lt;/code&gt; unless &lt;code&gt;--create&lt;/code&gt; is provided, in which case it defaults to &lt;code&gt;InitialS&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;SymbolicS&lt;/code&gt;: The default value of SLOAD is a symbolic value without further constraints. SLOAD and SSTORE can operate on symbolic locations.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;InitialS&lt;/code&gt;: The default value of SLOAD is zero. SLOAD and SSTORE can operate on symbolic locations.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ConcreteS&lt;/code&gt;: Storage defaults to zero or fetched from an rpc node if &lt;code&gt;--rpc&lt;/code&gt; is provided. SLOAD or SSTOREs on symbolic locations will result in a runtime error.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;hevm&lt;/code&gt; uses an eager approach for symbolic execution, meaning that it will first attempt to explore all branches in the program (without querying the smt solver to check if they are reachable or not). Once the full execution tree has been explored, the postcondition is checked against all leaves, and the solver is invoked to check reachability for branches where a postcondition violation could occur. While our tests have shown this approach to be significantly faster, when applied without limits it would always result in infitie exploration of code involving loops, so after some predefined number of iterations (controlled by the &lt;code&gt;--ask-smt-iterations&lt;/code&gt; flag), the solver will be invoked to check whether a given loop branch is reachable. In cases where the number of loop iterations is known in advance, you may be able to speed up execution by setting this flag to an appropriate value.&lt;/p&gt; &#xA;&lt;p&gt;Minimum required flags:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--code&lt;/code&gt; or (&lt;code&gt;--rpc&lt;/code&gt; and &lt;code&gt;--address&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;hevm exec&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Run an EVM computation using specified parameters, using an interactive debugger when &lt;code&gt;--debug&lt;/code&gt; flag is given.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Usage: hevm exec [--code TEXT] [--calldata TEXT] [--address ADDR]&#xA;                 [--caller ADDR] [--origin ADDR] [--coinbase ADDR]&#xA;                 [--value W256] [--nonce W256] [--gas W256]&#xA;                 [--number W256] [--timestamp W256] [--gaslimit W256]&#xA;                 [--gasprice W256] [--create] [--maxcodesize W256]&#xA;                 [--difficulty W256] [--debug] [--state STRING] [--rpc TEXT]&#xA;                 [--block W256] [--json-file STRING]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Minimum required flags:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--code&lt;/code&gt; or (&lt;code&gt;--rpc&lt;/code&gt; and &lt;code&gt;--address&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;If the execution returns an output, it will be written to stdout.&lt;/p&gt; &#xA;&lt;p&gt;Exit code indicates whether the execution was successful or errored/reverted.&lt;/p&gt; &#xA;&lt;p&gt;Simple example usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;hevm exec --code 0x647175696e6550383480393834f3 --gas 0xff&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Debug a mainnet transaction (older transactions require archive node):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export ETH_RPC_URL=https://mainnet.infura.io/v3/YOUR_API_KEY_HERE&#xA;export TXHASH=0xd2235b9554e51e8ff5b3de62039d5ab6e591164b593d892e42b2ffe0e3e4e426&#xA;hevm exec --caller $(seth tx $TXHASH from) --address $(seth tx $TXHASH to) --calldata $(seth tx $TXHASH input) --rpc $ETH_RPC_URL --block $(($(seth tx $TXHASH blockNumber)-1)) --gas $(seth tx $TXHASH gas) --debug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;--state&lt;/code&gt; is provided, hevm will load and save state to the directory provided. Git is used as a storage model, with each hevm run creating a new commit. The directory provided must be a non empty git repository. After a run you can see the state diff by simply looking at the commit (for example &lt;code&gt;git show HEAD&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir mystate&#xA;cd mystate &amp;amp;&amp;amp; git init &amp;amp;&amp;amp; git commit --allow-empty -m &#34;init&#34; &amp;amp;&amp;amp; cd ..&#xA;hevm exec --code 0x600160015500 --state mystate --gas 0xffffff&#xA;cd mystate &amp;amp;&amp;amp; git show HEAD&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;hevm equivalence&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Usage: hevm equivalence --code-a TEXT --code-b TEXT [--sig TEXT]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Symbolically execute both the code given in &lt;code&gt;--code-a&lt;/code&gt; and &lt;code&gt;--code-b&lt;/code&gt; and try to prove equivalence between their outputs and storages.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;--sig&lt;/code&gt; is given, calldata is assumed to take the form of the function given. If left out, calldata is a fully abstract buffer of at most 256 bytes.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;hevm dapp-test&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: hevm dapp-test [--json-file STRING] [--dapp-root STRING] [--debug]&#xA;                      [--fuzz-runs INT] [--replay (TEXT,BYTESTRING)] [--depth INT]&#xA;                      [--rpc TEXT] [--verbose INT] [--coverage] [--state STRING]&#xA;                      [--match STRING] [--smttimeout INT] [--max-iterations INT]&#xA;                      [--solver STRING] [--cache STRING] [--cov-match STRING]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run any ds-test testing functions. Run under the hood whenever &lt;code&gt;dapp test&lt;/code&gt; or &lt;code&gt;dapp debug&lt;/code&gt; is called. Testing functions prefixed with &lt;code&gt;test&lt;/code&gt; will be executed concretely. If concrete test functions have been given arguments, they will be randomly instantiated and run &lt;code&gt;--fuzz-runs&lt;/code&gt; number of times. If testing functions are prefixed with &lt;code&gt;prove&lt;/code&gt; they will be symbolically executed. In &lt;code&gt;--debug&lt;/code&gt; mode, property based tests will not be available unless given specific arguments using &lt;code&gt;--replay&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;smttimeout&lt;/code&gt;, &lt;code&gt;max-iterations&lt;/code&gt; and &lt;code&gt;solver&lt;/code&gt; options have the same semantics as in &lt;code&gt;hevm symbolic&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Environment Variables&lt;/h3&gt; &#xA;&lt;p&gt;These environment variables can be used to control block parameters:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Variable&lt;/th&gt; &#xA;   &lt;th&gt;Default&lt;/th&gt; &#xA;   &lt;th&gt;Synopsis&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DAPP_TEST_ADDRESS&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The address to deploy the test contract to&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DAPP_TEST_CALLER&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;0x00a329c0648769a73afac7f9381e08fb43dbea72&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The address to set &lt;code&gt;msg.sender&lt;/code&gt; to when calling into the test contract&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DAPP_TEST_ORIGIN&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;0x00a329c0648769a73afac7f9381e08fb43dbea72&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The address to set &lt;code&gt;tx.orgin&lt;/code&gt; to when calling into the test contract&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DAPP_TEST_GAS_CREATE&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;0xffffffffffff&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The gas to provide when creating the testing contract&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DAPP_TEST_GAS_CALL&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;0xffffffffffff&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The gas to provide to each call made to the testing contract&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DAPP_TEST_BALANCE&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;0xffffffffffffffffffffffff&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The balance to provide to &lt;code&gt;DAPP_TEST_ADDRESS&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DAPP_TEST_COINBASE&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;0x0000000000000000000000000000000000000000&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The coinbase address. Will be set to the coinbase for the block at &lt;code&gt;DAPP_TEST_NUMBER&lt;/code&gt; if rpc is enabled&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DAPP_TEST_NUMBER&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The block number. Will be set to the latest block if rpc is enabled&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DAPP_TEST_TIMESTAMP&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The block timestamp. Will be set to the timestamp for the block at &lt;code&gt;DAPP_TEST_NUMBER&lt;/code&gt; if rpc is enabled&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DAPP_TEST_GAS_LIMIT&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The block gas limit to use&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DAPP_TEST_GAS_PRICE&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The gas price to use&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;DAPP_TEST_DIFFICULTY&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The block difficulty. Will be set to the difficulty for the the block at &lt;code&gt;DAPP_TEST_NUMBER&lt;/code&gt; if rpc is enabled&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;h3&gt;Nix&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;hevm&lt;/code&gt; is distributed as part of the &lt;a href=&#34;https://github.com/dapphub/dapptools&#34;&gt;Dapp tools&lt;/a&gt; suite.&lt;/p&gt; &#xA;&lt;h3&gt;Building with Stack or Cabal&lt;/h3&gt; &#xA;&lt;p&gt;If you can&#39;t or won&#39;t use Nix, the easiest way especially if you don&#39;t have GHC (the Haskell compiler) installed already, is to use &lt;a href=&#34;https://docs.haskellstack.org/en/stable/README/&#34;&gt;Stack&lt;/a&gt;, which can take care of installing GHC for you. These commands should work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ curl -sSL https://get.haskellstack.org/ | sh&#xA;$ git clone https://github.com/dapphub/dapptools.git&#xA;$ cd dapptools/src/hevm &amp;amp;&amp;amp; stack setup &amp;amp;&amp;amp; stack install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, hevm is in Hackage so you can execute &lt;code&gt;stack install hevm&lt;/code&gt; to get it up and running.&lt;/p&gt; &#xA;&lt;p&gt;If you prefer to use your own installation of GHC and the basic Haskell package manager, Cabal, simply run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/dapphub/dapptools.git&#xA;$ cd dapptools/src/hevm &amp;amp;&amp;amp; cabal v2-update &amp;amp;&amp;amp; cabal v2-configure &amp;amp;&amp;amp; cabal v2-install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you are on macOS when building with Stack, you will first need to install the &lt;a href=&#34;https://github.com/bitcoin-core/secp256k1&#34;&gt;secp256k1&lt;/a&gt; and &lt;a href=&#34;https://github.com/scipr-lab/libff&#34;&gt;libff&lt;/a&gt; libraries. These commands should be enough:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ brew install automake&#xA;$ git clone https://github.com/bitcoin-core/secp256k1.git&#xA;$ cd secp256k1&#xA;$ ./autogen.sh&#xA;$ ./configure --enable-module-recovery # for generating secp256k1_recovery.h&#xA;$ make&#xA;$ sudo make install&#xA;$ cd .. &amp;amp;&amp;amp; rm -rf secp256k1 # optional (cleanup)&#xA;&#xA;$ brew install openssl&#xA;$ git clone https://github.com/scipr-lab/libff --recursive&#xA;$ cd libff&#xA;$ export LDFLAGS=-L/usr/local/opt/openssl/lib&#xA;$ export CPPFLAGS=-I/usr/local/opt/openssl/include&#xA;$ export CXXFLAGS=-I/usr/local/opt/openssl/include&#xA;$ ARGS=&#34;-DWITH_PROCPS=OFF -DOPENSSL_INCLUDE_DIR=/usr/local/opt/openssl/include/openssl -DCURVE=ALT_BN128&#34;&#xA;$ sed -i &#39;&#39; &#39;s/STATIC/SHARED/&#39; libff/CMakeLists.txt&#xA;$ sed -i &#39;&#39; &#39;s/STATIC/SHARED/&#39; depends/CMakeLists.txt&#xA;$ mkdir build&#xA;$ cd build&#xA;$ CXXFLAGS=&#34;-fPIC $CXXFLAGS&#34; OPENSSL_ROOT_DIR=/usr/local/opt/openssl cmake $ARGS ..&#xA;$ make &amp;amp;&amp;amp; sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Cheat codes&lt;/h3&gt; &#xA;&lt;p&gt;Since Hevm is an EVM implementation mainly dedicated to testing and exploration, it features a set of &lt;code&gt;cheat codes&lt;/code&gt; which can manipulate the environment in which the execution is run.&lt;/p&gt; &#xA;&lt;p&gt;These can be accessed by calling into a contract (typically called &lt;code&gt;Hevm&lt;/code&gt;) at address &lt;code&gt;0x7109709ECfa91a80626fF3989D68f67F5b1DD12D&lt;/code&gt;, which implements the following methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;function warp(uint x) public&lt;/code&gt; Sets the block timestamp to &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;function roll(uint x) public&lt;/code&gt; Sets the block number to &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;function store(address c, bytes32 loc, bytes32 val) public&lt;/code&gt; Sets the slot &lt;code&gt;loc&lt;/code&gt; of contract &lt;code&gt;c&lt;/code&gt; to &lt;code&gt;val&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;function load(address c, bytes32 loc) public returns (bytes32 val)&lt;/code&gt; Reads the slot &lt;code&gt;loc&lt;/code&gt; of contract &lt;code&gt;c&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;function sign(uint sk, bytes32 digest) public returns (uint8 v, bytes32 r, bytes32 s)&lt;/code&gt; Signs the &lt;code&gt;digest&lt;/code&gt; using the private key &lt;code&gt;sk&lt;/code&gt;. Note that signatures produced via &lt;code&gt;hevm.sign&lt;/code&gt; will leak the private key.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;function addr(uint sk) public returns (address addr)&lt;/code&gt; Derives an ethereum address from the private key &lt;code&gt;sk&lt;/code&gt;. Note that &lt;code&gt;hevm.addr(0)&lt;/code&gt; will fail with &lt;code&gt;BadCheatCode&lt;/code&gt; as &lt;code&gt;0&lt;/code&gt; is an invalid ECDSA private key.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;function ffi(string[] calldata) external returns (bytes memory)&lt;/code&gt; Executes the arguments as a command in the system shell and returns stdout. Expects abi encoded values to be returned from the shell or an error will be thrown. Note that this cheatcode means test authors can execute arbitrary code on user machines as part of a call to &lt;code&gt;dapp test&lt;/code&gt;, for this reason all calls to &lt;code&gt;ffi&lt;/code&gt; will fail unless the &lt;code&gt;--ffi&lt;/code&gt; flag is passed.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>