<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-18T01:30:55Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bgamari/optimization</title>
    <updated>2023-10-18T01:30:55Z</updated>
    <id>tag:github.com,2023-10-18:/bgamari/optimization</id>
    <link href="https://github.com/bgamari/optimization" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Some numerical optimization methods implemented in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;optimization&lt;/h1&gt; &#xA;&lt;p&gt;These are a set of implementations of various numerical optimization methods in Haskell. Note that these implementations were originally written as part of a class project; while at one point they worked no attention has been given to numerical stability or the many other potential difficulties of implementing robust numerical methods. That being said, they should serve to succinctly illustrate a number of optimization techniques from the modern optimization literature.&lt;/p&gt; &#xA;&lt;p&gt;Those seeking a high-level overview of some of these methods are referred to Stephen Wright&#39;s excellent &lt;a href=&#34;http://videolectures.net/nips2010_wright_oaml/&#34;&gt;tutorial&lt;/a&gt; from NIPS 2010. A deeper introduction can be found in Boyd and Vandenberghe&#39;s &lt;em&gt;Convex Optimization&lt;/em&gt; which available freely online.&lt;/p&gt; &#xA;&lt;h2&gt;Contact Information&lt;/h2&gt; &#xA;&lt;p&gt;Contributions and bug reports are welcome!&lt;/p&gt; &#xA;&lt;p&gt;Please feel free to contact me through github or on the #haskell IRC channel on irc.freenode.net.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ben Gamari&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>meyersh/haskell-coreutils</title>
    <updated>2023-10-18T01:30:55Z</updated>
    <id>tag:github.com,2023-10-18:/meyersh/haskell-coreutils</id>
    <link href="https://github.com/meyersh/haskell-coreutils" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An implementation of the UNIX Coreutils in Haskell language&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;A trivial effort to implement the UNIX coreutils in Haskell.&lt;/h1&gt; &#xA;&lt;p&gt;To teach myself the Haskell programming language, I&#39;m trying to re-create the UNIX SYSV coreutils (cp, cat, echo, etc).&lt;/p&gt; &#xA;&lt;p&gt;This repository is the result of that effort.&lt;/p&gt; &#xA;&lt;h1&gt;From the Man Pages&lt;/h1&gt; &#xA;&lt;p&gt;PDF: &lt;a href=&#34;http://www.sco.com/developers/devspecs/vol2.pdf&#34;&gt;http://www.sco.com/developers/devspecs/vol2.pdf&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;cat&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;cat ( BU_CMD )&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;NAME&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; – concatenate and print ﬁles&lt;/p&gt; &#xA;&lt;h3&gt;SYNOPSIS&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cat [ - s u v ] [ﬁle . . . ]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;DESCRIPTION&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; reads each ﬁlein sequence and writes it on the standard output. Thus&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cat file&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;prints the contents of &lt;code&gt;file&lt;/code&gt; on your terminal, and&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cat file1 file2 &amp;gt; file3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;concatenates &lt;code&gt;file1&lt;/code&gt; and &lt;code&gt;file2&lt;/code&gt;, and writes the results in &lt;code&gt;file3&lt;/code&gt;. If no input ﬁle is given, or if the argument - is encountered, &lt;code&gt;cat&lt;/code&gt; reads from the standard input. &lt;code&gt;cat&lt;/code&gt; processes supplementary code set characters according to the locale speciﬁed in the &lt;code&gt;LC_CTYPE&lt;/code&gt; environment variable [see &lt;code&gt;LANG&lt;/code&gt; on &lt;code&gt;envvar(BA_ENV)&lt;/code&gt;].&lt;/p&gt; &#xA;&lt;p&gt;The following options apply to &lt;code&gt;cat&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-u&lt;/code&gt; The output is not buffered. (The default is buffered output.)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-s&lt;/code&gt; &lt;code&gt;cat&lt;/code&gt; is silent about non-existent ﬁles.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-v&lt;/code&gt; Causes non-printing characters (with the exception of tabs, new-lines, and form-feeds) to be printed visibly. ASCII control characters (octal 000 – 037) are printed as ˆ n, where n is the corresponding ASCII character in the range octal 100 – 137 (@, A, B, C, . . ., X, Y, Z, [, , ], ˆ, and _); the DEL character (octal 0177) is printed ˆ ?. Other non-printable characters are printed as M - x, where x is the ASCII character speciﬁed by the low-order seven bits. All supplementary code set characters are considered to be printable.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Errors&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; returns the following values: &lt;code&gt;0&lt;/code&gt; If all input ﬁles were output successfully. &lt;code&gt;&amp;gt; 0&lt;/code&gt; If an error occurred while accessing one or more input ﬁles.&lt;/p&gt; &#xA;&lt;h2&gt;echo&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;echo ( BU_CMD )&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;NAME&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;echo&lt;/code&gt; – echo arguments&lt;/p&gt; &#xA;&lt;h3&gt;SYNOPSIS&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;echo [arg] . . .&#xA;echo [arg]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;DESCRIPTION&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;echo&lt;/code&gt; writes its arguments separated by blanks and terminated by a new-line on the standard output. It processes supplementary code set characters according to the locale speciﬁed in the &lt;code&gt;LC_CTYPE&lt;/code&gt; environment variable [see &lt;code&gt;LANG&lt;/code&gt; on &lt;code&gt;envvar(BA_ENV)&lt;/code&gt;]. The &lt;code&gt;/usr/bin/sh&lt;/code&gt; version understands the following C-like escape conventions; beware of conﬂicts with the shell’s use of :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;\b&lt;/code&gt; backespace&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;\c&lt;/code&gt; print line without new-line&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;\f&lt;/code&gt; form-feed&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;\n&lt;/code&gt; new-line&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;\r&lt;/code&gt; carriage return&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;\t&lt;/code&gt; tab&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;\v&lt;/code&gt; vertical tab&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;\\&lt;/code&gt; backslash&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;\0n&lt;/code&gt; where n is the 1-, 2-, or 3-digit octal encoding of an 8-bit character. Each byte of multibyte characters should be preceded by backslash ().&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-n&lt;/code&gt; do not add the newline to the output.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;echo&lt;/code&gt; is useful for producing diagnostics in command ﬁles, for sending known data into a pipe, and for displaying the contents of environment variables.&lt;/p&gt;</summary>
  </entry>
</feed>