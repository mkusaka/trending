<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-09T01:35:13Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>anton-k/mig</title>
    <updated>2023-08-09T01:35:13Z</updated>
    <id>tag:github.com,2023-08-09:/anton-k/mig</id>
    <link href="https://github.com/anton-k/mig" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lightweight and composable servers for Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Mig - library to write composable and lightweight servers&lt;/h1&gt; &#xA;&lt;p&gt;The Mig is a library to build lightweight composable servers. The main strength is ability to build servers from parts and flexible DSL which features only small amount of functions.&lt;/p&gt; &#xA;&lt;p&gt;I like &lt;a href=&#34;https://hackage.haskell.org/package/scotty&#34;&gt;scotty&lt;/a&gt; for being very simple and &lt;a href=&#34;https://hackage.haskell.org/package/servant-server&#34;&gt;servant&lt;/a&gt; for being composable, type-safe and how functions are used as handlers which provides decoupling of Web-handlers from application logic. But sometimes scotty feels too imperative and lacks servant&#39;s composability. And servant with type-level magic and huge errors can feel to complicated. So I wanted to create something in the middle. Something composable and simple at the same time. The name &lt;code&gt;mig&lt;/code&gt; (pronounced as meeg) is a russian word for &#34;instant moment&#34;.&lt;/p&gt; &#xA;&lt;h2&gt;How to install&lt;/h2&gt; &#xA;&lt;p&gt;We can install from &lt;a href=&#34;https://hackage.haskell.org/package/mig&#34;&gt;hackage&lt;/a&gt; to use with cabal or use this snippet to depend on latest source in stack. Put it in &lt;code&gt;stack.yaml&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;extra-deps:&#xA;- git: https://github.com/anton-k/mig&#xA;  commit: &amp;lt;latest-commit&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Quick start guide&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s create something cool with the library.&lt;/p&gt; &#xA;&lt;h3&gt;Hello world server&lt;/h3&gt; &#xA;&lt;p&gt;As a starting point let&#39;s look at hello-world server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module Main where&#xA;&#xA;import Mig&#xA;import Data.Text (Text)&#xA;&#xA;main :: IO ()&#xA;main = runServer 8080 server&#xA;&#xA;server :: Server IO&#xA;server =&#xA;  &#34;api&#34; /. &#34;v1&#34; /. &#34;hello&#34; /. hello&#xA;&#xA;hello :: Get Json IO Text&#xA;hello = pure &#34;Hello World&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The main type is &lt;code&gt;Server&lt;/code&gt;. We can think about it as function from request to response which sometimes can produce no output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype Server m = Server (Req -&amp;gt; m (Maybe Resp))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is parametrised by the underlying monad. So far library supports only three types of monads:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;IO&lt;/code&gt;-monad&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ReaderT&lt;/code&gt; over &lt;code&gt;IO&lt;/code&gt; with possible newtype-wrappers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ReaderT env (ExceptT err) IO&lt;/code&gt; - reader with &lt;code&gt;ExceptT&lt;/code&gt; over &lt;code&gt;IO&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also we can create our custom monads as newtype wrappers over those monads and be able to use it with library. To do that we need to derive &lt;code&gt;HasServer&lt;/code&gt; instance. It can be done with deriving strategies (see &lt;code&gt;examples/Counter.hs&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;To run server we can use functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Runs server on port&#xA;runServer :: Int -&amp;gt; Server IO -&amp;gt; IO ()&#xA;runServer port server = ...&#xA;&#xA;-- | Convert to WAI application&#xA;toApplication :: ServerConfig -&amp;gt; Server IO -&amp;gt; Wai.Application&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The HTTP-method is specified with newtype wrapper &lt;code&gt;Get&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype Get ty m a = Get (m a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It has phantom-argument for type of the response. In this example we return &lt;code&gt;Text&lt;/code&gt; as response body with 200 ok status. It seems that we need two typed to specify result &lt;code&gt;ty&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Beside &lt;code&gt;Text&lt;/code&gt; we also can return &lt;code&gt;Json&lt;/code&gt;, &lt;code&gt;Html&lt;/code&gt;, raw &lt;code&gt;ByteString&lt;/code&gt; as response. But we have several ways to render handler result to response body. For example we can convert Int as Text and also as JSON. To distinguish between them we use phantom type for the type of response body.&lt;/p&gt; &#xA;&lt;h3&gt;Using monoid for route branches&lt;/h3&gt; &#xA;&lt;p&gt;The server has Monoid instance. With it we can build servers from several routes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;server :: Server IO&#xA;server =&#xA;  &#34;api&#34; /. &#34;v1&#34; /.&#xA;     mconcat&#xA;       [ &#34;hello&#34; /. handle &#34;hello&#34;&#xA;       , &#34;bye&#34; /. handle &#34;bye&#34;&#xA;       ]&#xA;&#xA;handle :: Text -&amp;gt; Get Text IO Text&#xA;handle prefix = Get $ pure $ prefix &amp;lt;&amp;gt; &#34; world&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note how branching by path is done with &lt;code&gt;Monoid&lt;/code&gt; method &lt;code&gt;mconcat&lt;/code&gt;. We use &lt;code&gt;Get&lt;/code&gt; inside the function &lt;code&gt;handle&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Query parameters&lt;/h3&gt; &#xA;&lt;p&gt;We can turn a &#34;world&#34; into parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;server :: Server IO&#xA;server =&#xA;  &#34;api&#34; /. &#34;v1&#34; /.&#xA;     mconcat&#xA;       [ &#34;hello&#34; /. handle &#34;hello&#34;&#xA;       , &#34;bye&#34; /. handle &#34;bye&#34;&#xA;       ]&#xA;&#xA;handle :: Text -&amp;gt; Query &#34;who&#34; Text -&amp;gt; Get Text IO Text&#xA;handle prefix (Query name) = Get $ pure $ prefix &amp;lt;&amp;gt; &#34; &#34; &amp;lt;&amp;gt; name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By changing the signature of the function we have requested required query parameter called &lt;code&gt;&#34;who&#34;&lt;/code&gt;. We use type-level string literals to encode name of the parameter. It is provided with url: &lt;code&gt;api/v1/hello?who=john&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If we use &lt;code&gt;Optional&lt;/code&gt; instead of &lt;code&gt;Query&lt;/code&gt; parameter becomes optional and value is wrapped in &lt;code&gt;Maybe&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Capture URI-parts&lt;/h3&gt; &#xA;&lt;p&gt;In the example we can note the duplication of path name &lt;code&gt;&#34;hello/bye&#34;&lt;/code&gt; and that we pass the same constants to our function &lt;code&gt;handle&lt;/code&gt;. We can capture that part of URI as argument with &lt;code&gt;Capture&lt;/code&gt; argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;server :: Server IO&#xA;server =&#xA;  &#34;api&#34; /. &#34;v1&#34; /. handle&#xA;&#xA;handle :: Capture Text -&amp;gt; Query &#34;who&#34; Text -&amp;gt; Get Text IO Text&#xA;handle (Capture prefix) (Query name) = Get $ pure $ prefix &amp;lt;&amp;gt; &#34; &#34; &amp;lt;&amp;gt; name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This example is equivalent to previous one. Only we capture part of the URI as text and use it in the message. Also with capture we can append all sorts of prefixes.&lt;/p&gt; &#xA;&lt;h3&gt;Route arguments&lt;/h3&gt; &#xA;&lt;p&gt;The cool part of it is that handle function can have any amount of input arguments wrapped in special newtypes and it will be decoded to proper server route.&lt;/p&gt; &#xA;&lt;p&gt;We have newtypes for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Query &#34;name&#34; type&lt;/code&gt; - required query parameter (&lt;code&gt;FromHttpApiData&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Optional &#34;name&#34; type&lt;/code&gt; - optional query parameter (&lt;code&gt;FromHttpApiData&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Capture type&lt;/code&gt; - capture part of the URI between slashes &lt;code&gt;/&lt;/code&gt;. (&lt;code&gt;FromHttpApiData&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Body type&lt;/code&gt; - input JSON body (&lt;code&gt;FromJSON&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RawBody&lt;/code&gt; - input body as raw lazy bytestring (is &lt;code&gt;ByteString&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FormBody&lt;/code&gt; - input URL-encoded form (it often comes from HTML-forms) (&lt;code&gt;FromForm&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Header &#34;name&#34; ty&lt;/code&gt; - access header by name (&lt;code&gt;FromHttpApiData&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PathInfo&lt;/code&gt; - access path info relative to the server (is &lt;code&gt;[Text]&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Class at in the parens is which class is used for convertion. Often we can derive the instance of that class with newtype-deriving or with Generic-deriving. We can change the number of arguments because the function &lt;code&gt;(/.)&lt;/code&gt; is overloaded by second argument and it can accept anything convertible to &lt;code&gt;Server&lt;/code&gt; or an instance of the class &lt;code&gt;ToServer&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Route outputs&lt;/h3&gt; &#xA;&lt;p&gt;Also &lt;code&gt;newtype&lt;/code&gt; wrappers can control behavior of the output. We already saw &lt;code&gt;Get&lt;/code&gt;-wrapper. It encodes Http-method. Also we can use &lt;code&gt;Post&lt;/code&gt;, &lt;code&gt;Put&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;p&gt;We have output wrappers for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;http-methods: &lt;code&gt;Get&lt;/code&gt;, &lt;code&gt;Post&lt;/code&gt;, &lt;code&gt;Put&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt;, etc.&lt;/li&gt; &#xA; &lt;li&gt;append headers: &lt;code&gt;AddHeaders a&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;change response status: &lt;code&gt;SetStatus a&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;return error: &lt;code&gt;Either (Error ty) a&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We can nest wrappers to apply several behaviors. For example we can update header, possible return error and return Post-method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;handle :: Query &#34;foo&#34; Int -&amp;gt; Post Json IO (Either (Error Text) (AddHeaders FooResponse))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here &lt;code&gt;FooResponse&lt;/code&gt; should have &lt;code&gt;ToJSON&lt;/code&gt; instance. Possible implementation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data FooResponse = FooResponse&#xA;  { code :: Int&#xA;  , message :: Text&#xA;  }&#xA;  deriving (Generic, ToJSON)&#xA;&#xA;handle (Query code) = Post $ do&#xA;  message &amp;lt;- readMessageBycode code&#xA;  pure $ Right $ AddHeaders headers $ FooResponse code message&#xA;  where&#xA;    headers = [&#34;Trace-Code&#34;, Nothing]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Errors&lt;/h3&gt; &#xA;&lt;p&gt;The errors can be returned from route with &lt;code&gt;(Either (Error ty))&lt;/code&gt; output wrapper. We signify to the user that our route returns errors. The &lt;code&gt;Error&lt;/code&gt; type contains status and details for the error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Error a = Error&#xA;  { status :: Status&#xA;    -- error status&#xA;  , body :: a&#xA;    -- message or error details&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;ToServer&lt;/code&gt; instance takes care about proper conversion of the error value to the same response type as the main happy route branch.&lt;/p&gt; &#xA;&lt;h2&gt;Specific servers&lt;/h2&gt; &#xA;&lt;p&gt;If we write server of specific type. For example if we write JSON API with IO-based server we can import specific route newtype-wrappers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Mig.Json.IO&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It will simplify the signatures of the functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;handle :: Body FooRequest -&amp;gt; Post FooResponse&#xA;handle (Body req) = Post $ do&#xA;  resp &amp;lt;- readResp req&#xA;  pure resp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As &lt;code&gt;Post&lt;/code&gt; becomes specified to &lt;code&gt;Json&lt;/code&gt; and &lt;code&gt;IO&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype Post a = Post (IO a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are similar modules for &lt;code&gt;Html&lt;/code&gt;. If your server is not &lt;code&gt;IO&lt;/code&gt;-based Use import of &lt;code&gt;Mig.Json&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Reader based servers&lt;/h2&gt; &#xA;&lt;p&gt;There is very popular pattern of writing servers with monad &lt;code&gt;ReaderT ServerContext IO&lt;/code&gt;. The server context can contain shared context of the server and mutable stated wrapped in &lt;code&gt;TVar&lt;/code&gt;&#39;s or IO-based interfaces. We can access the context inside handler and shared for all routes.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;mig&lt;/code&gt; has support for Reader-pattern like monads. Let&#39;s build a simple counter server as example. User can see current value with &lt;code&gt;get&lt;/code&gt; and add to the internal counter with method &lt;code&gt;put&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s define application monad first&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype App a = App (ReaderT Env IO a)&#xA;  deriving newtype (Functor, Applicative, Monad, MonadReader Env, MonadIO, HasServer)&#xA;&#xA;data Env = Env&#xA;  { current :: IORef Int&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note the deriving of &lt;code&gt;HasServer&lt;/code&gt;. It is defined for reader over IO. With it we can convert the &lt;code&gt;Server App&lt;/code&gt; to &lt;code&gt;IO&lt;/code&gt;-based server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;renderServer :: Server App -&amp;gt; Env -&amp;gt; IO (Server IO)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So we can define our handlers with App-monad and render to &lt;code&gt;IO&lt;/code&gt; to convert it to WAI-application and run as server.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s define the server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;counter :: Server App&#xA;counter = do&#xA;  &#34;counter&#34; /. &#34;api&#34; /.&#xA;    mconcat&#xA;      [ &#34;get&#34; /. handleGet&#xA;      , &#34;put&#34; /. handlePut&#xA;      ]&#xA;&#xA;handleGet :: Get Text App Int&#xA;handelGet = -- todo&#xA;&#xA;handlePut :: Capture Int -&amp;gt; Post Text App ()&#xA;handlePut (Capture val) = -- todo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can render the server and run it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;main :: IO ()&#xA;main = do&#xA;  env &amp;lt;- initEnv&#xA;  server &amp;lt;- renderServer counter env&#xA;  runServer 8085 server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s define the missing parts:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;initEnv :: IO Env&#xA;initEnv = Env &amp;lt;$&amp;gt; newIORef 0&#xA;&#xA;handleGet :: Get Text App Int&#xA;handleGet = Get $ do&#xA;  ref &amp;lt;- asks (.current)&#xA;  liftIO $ readIORef ref&#xA;&#xA;handlePut :: Capture Int -&amp;gt; Get Json App ()&#xA;handlePut (Capture val) = Get $ do&#xA;  ref &amp;lt;- asks (.current)&#xA;  liftIO $ atomicModifyIORef&#39; ref (\cur -&amp;gt; (cur + val, ()))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So we have studied how we can use custom Reader-based monads. The trick is to derive &lt;code&gt;HasServer&lt;/code&gt; on newtype wrapper and use method &lt;code&gt;renderServer&lt;/code&gt; to convert to &lt;code&gt;IO&lt;/code&gt;-based server.&lt;/p&gt; &#xA;&lt;p&gt;PS: this is an open question. Is it possible to create a function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;hoistServer :: (Monad m, Monad n) =&amp;gt; (forall a . m a -&amp;gt; n a) -&amp;gt; Server m -&amp;gt; Server n&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As it is defined in the servant. With it we would be able to use any monad. But I&#39;m not sure how to achieve that. Help is appreciated, as it will make library even better! I guess it can be done with &lt;code&gt;MonadBaseControl&lt;/code&gt; and if we turn the WAI function to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;toApplication :: MonadBaseControl m =&amp;gt; Server m -&amp;gt; m Wai.Application&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;We have walked through the whole library. As a summary of it&#39;s functions: we can&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;compose servers with path operator &lt;code&gt;(/.)&lt;/code&gt; and monoid instance.&lt;/li&gt; &#xA; &lt;li&gt;define handlers as functions with various input and output newtype-wrappers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I hope that you like the concept and will enjoy the library. See the directory &lt;a href=&#34;https://github.com/anton-k/mig/tree/main/examples&#34;&gt;&lt;code&gt;examples&lt;/code&gt;&lt;/a&gt; for more examples. We can run the examples with stack by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; make run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in this repo. Change the Makefile to try different examples.&lt;/p&gt; &#xA;&lt;p&gt;Also there are repos that show how to use library with most common Haskell patterns to create web-servers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/anton-k/handle-pattern-mig-app&#34;&gt;Handle pattern&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/anton-k/reader-pattern-mig-app&#34;&gt;Reader patten&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is a very first sketch of the library. I guess it can become even better. The feedback is appreciated.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ezyang/latency</title>
    <updated>2023-08-09T01:35:13Z</updated>
    <id>tag:github.com,2023-08-09:/ezyang/latency</id>
    <link href="https://github.com/ezyang/latency" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Some latency benchmarks&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>armlesshobo/ivy</title>
    <updated>2023-08-09T01:35:13Z</updated>
    <id>tag:github.com,2023-08-09:/armlesshobo/ivy</id>
    <link href="https://github.com/armlesshobo/ivy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ivy - a simple image viewer written in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ivy&lt;/h1&gt; &#xA;&lt;p&gt;A simple image viewer written in Haskell&lt;/p&gt; &#xA;&lt;p&gt;The goal of this project is to create a simple, fast, image viewer that just does one thing: shows an image. The program is designed to be run from the command line and display the image in a simple interface, allowing for scrolling/zooming of the image if it is too big for the window. The inspiration comes from working with a tiling window manager where a lot of things were done via a terminal. Opening an image in something like xv is just overkill if the only thing you want to do is simply view the image (I mean, who wants all those extras there anyway? Am I right?)&lt;/p&gt; &#xA;&lt;h1&gt;Building &amp;amp; Installation&lt;/h1&gt; &#xA;&lt;p&gt;To build:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;$ cabal configure&lt;/li&gt; &#xA; &lt;li&gt;$ cabal build&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To install:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;$ cabal install&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To run:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;$ ivy &amp;lt;image name&amp;gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Contact&lt;/h1&gt; &#xA;&lt;p&gt;Author: Lance Clark &amp;lt;&lt;a href=&#34;mailto:haYnguy@gmail.com&#34;&gt;haYnguy@gmail.com&lt;/a&gt;&amp;gt;&lt;/p&gt;</summary>
  </entry>
</feed>