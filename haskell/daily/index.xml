<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-28T01:36:53Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nammayatri/shared-kernel</title>
    <updated>2023-02-28T01:36:53Z</updated>
    <id>tag:github.com,2023-02-28:/nammayatri/shared-kernel</id>
    <link href="https://github.com/nammayatri/shared-kernel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>nammayatri/beckn-gateway</title>
    <updated>2023-02-28T01:36:53Z</updated>
    <id>tag:github.com,2023-02-28:/nammayatri/beckn-gateway</id>
    <link href="https://github.com/nammayatri/beckn-gateway" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>alfreb/church1936</title>
    <updated>2023-02-28T01:36:53Z</updated>
    <id>tag:github.com,2023-02-28:/alfreb/church1936</id>
    <link href="https://github.com/alfreb/church1936" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lambda calculus implemented directly from Alonzo Church&#39;s 1936 paper&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;church1936&lt;/h1&gt; &#xA;&lt;p&gt;Lambda calculus implemented directly from Alonzo Church&#39;s 1936 paper â€œAn Unsolvable Problem of Elementary Number Theory.â€ &lt;em&gt;American Journal of Mathematics&lt;/em&gt;, vol. 58, no. 2, 1936, pp. 345â€“63. JSTOR, &lt;a href=&#34;https://doi.org/10.2307/2371045&#34;&gt;https://doi.org/10.2307/2371045&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/alfreb/church1936/actions/workflows/haskell.yml&#34;&gt;&lt;img src=&#34;https://github.com/alfreb/church1936/actions/workflows/haskell.yml/badge.svg?sanitize=true&#34; alt=&#34;Haskell CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Build and run unit tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Generate the documentation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal haddock&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Build and run the example program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal run church1936&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The example program prints the following (with some formatting added here for github readability):&lt;/p&gt; &#xA;&lt;h2&gt;A TL;DR of Church&#39;s paper&lt;/h2&gt; &#xA;&lt;p&gt;First the symbols of the lanugage of lambda calculus are introduced:&lt;br&gt; &lt;code&gt;{}()ğº,[]&lt;/code&gt;&lt;br&gt; &lt;br&gt; Then the variables are introduced as a, b, c ... and so on. We&#39;re told that this is an enumerably infinite set of symbols, but he really only provides the first 3, so we have to improvise beyond z. We did this by implementing Enum for variables as follows: &lt;br&gt; &lt;code&gt;x, y, z, aâ‚, bâ‚, câ‚, dâ‚, eâ‚, fâ‚, gâ‚&lt;/code&gt;&lt;br&gt; ... and then &lt;br&gt; &lt;code&gt;xâ‚, yâ‚, zâ‚, aâ‚‚, bâ‚‚, câ‚‚, dâ‚‚, eâ‚‚, fâ‚‚, gâ‚‚&lt;/code&gt; &lt;br&gt; &lt;br&gt; Any sequence of symbols defined above is a &lt;em&gt;formula&lt;/em&gt; in the paper so technically &lt;code&gt;}(&lt;/code&gt; and &lt;code&gt;{oâ‚[&lt;/code&gt; are formulas, but only the well-formed ones are interesting, which Church defines by induction together with &lt;em&gt;free&lt;/em&gt; and &lt;em&gt;bound&lt;/em&gt; variables.&lt;br&gt; &lt;br&gt; &#34;A variable &lt;em&gt;x&lt;/em&gt; standing alone is a well-formed formula and the occurence of &lt;em&gt;x&lt;/em&gt; in it is an occurence of &lt;em&gt;x&lt;/em&gt; as a free variable in it&#34;&lt;br&gt; &lt;br&gt; Let&#39;s verify. x is a well formed formula: True The &lt;code&gt;Variable&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; is free in the &lt;code&gt;Formula&lt;/code&gt; &lt;code&gt;Var (V &#34;x&#34;)&lt;/code&gt;: True &lt;br&gt; Further, if the formulas &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; are well-formed, &lt;code&gt;{F}(X)&lt;/code&gt; is too. This is one confirmed example: &lt;code&gt;{f}({f}(f))&lt;/code&gt;&lt;br&gt; &lt;br&gt; Now for the lambda: if &lt;code&gt;M&lt;/code&gt; is well formed and &lt;code&gt;x&lt;/code&gt; is free in &lt;code&gt;M&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is bound in &lt;code&gt;ğºx[M]&lt;/code&gt;. So ğº has one job: to bind variables. Here&#39;s one confirmed example of an &lt;code&gt;M&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt; as free:&lt;br&gt; &lt;code&gt;x(x(x(y)))&lt;/code&gt;&lt;br&gt; &lt;br&gt; Attaching ğºx we get a well-formed formula with x now bound:&lt;br&gt; &lt;code&gt;ğºx . x(x(x(y)))&lt;/code&gt;&lt;br&gt; &lt;br&gt; Church now defines the numerals as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1 â†’ ğºab . a(b)&#xA;2 â†’ ğºab . a(a(b))&#xA;3 â†’ ğºab . a(a(a(b)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The successor function is not defined in this paper, but was defined in Church 33 as follows:&lt;br&gt; &lt;code&gt;ğºcab . a(c(a,b))&lt;/code&gt;&lt;br&gt; &lt;br&gt; We can apply the successor function to 2 like so:&lt;br&gt; &lt;code&gt;{ğºcab . a(c(a,b))}(ğºab . a(a(b)))&lt;/code&gt;&lt;br&gt; &lt;br&gt; The full form of this expression is really this:&lt;br&gt; &lt;code&gt;{ğºc[ğºa[ğºb[{a}({{c}(a)}(b))]]]}(ğºa[ğºb[{a}({a}(b))]])&lt;/code&gt;&lt;br&gt; &lt;br&gt; Thankfully, Church provided a nice set of abbreviation rules to save us from the sea of brackets. You can turn them on or off. &lt;br&gt; Applying Operation II (reduction) repeatedly we eventually get &#34;normal form&#34;, where no further reduction is possible.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ğºab . a({ğºab . a(a(b))}(a,b))&#xA;ğºab . a({ğºc . a(a(c))}(b))&#xA;ğºab . a(a(a(b)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The successor of 2 is 3. Yay!&lt;br&gt; &lt;br&gt; Addition can now be implemented in terms of successor:&lt;br&gt; &lt;code&gt;ğºmn . n(ğºcab . a(c(a,b)),m)&lt;/code&gt;&lt;br&gt; &lt;br&gt; But for multiplication the plot thickens; Church messed up! (see the documentation for details). Rosser helped fix this, as noted in Kleene 35, with this nice baby:&lt;br&gt; &lt;code&gt;ğºabx . a(b(x))&lt;/code&gt;&lt;br&gt; &lt;br&gt; And to top it off they point out that the numerals themselves are exponentiation functions. 2(3) is 3^2 and 3(2) = 2^3. Reversing the parameters we get it in the order we&#39;re used to:&lt;br&gt; &lt;code&gt;ğºab . b(a)&lt;/code&gt;&lt;br&gt; &lt;br&gt; Notice how this is exactly the same as the number 1, with the variables in reversed order:&lt;br&gt; &lt;code&gt;ğºab . a(b)&lt;/code&gt;&lt;br&gt; &lt;br&gt; Let&#39;s end here, with proving that 2 + 2 = 4:&lt;br&gt; &lt;code&gt;{ğºpofx . p(f,o(f,x))}(ğºab . a(a(b)),ğºab . a(a(b)))&lt;/code&gt;&lt;br&gt; &lt;br&gt; reduces to &lt;br&gt; &lt;code&gt;ğºfx . f(f(f(f(x))))&lt;/code&gt;&lt;br&gt; &lt;br&gt; Pretty neat!&lt;/p&gt; &#xA;&lt;h2&gt;The point of the paper&lt;/h2&gt; &#xA;&lt;p&gt;Note that the objective of Church&#39;s paper was not to make a computer, it was to prove that GÃ¶del&#39;s incompleteness theorem has implications for even simple statements in elementary number theory. More on that later!&lt;/p&gt;</summary>
  </entry>
</feed>