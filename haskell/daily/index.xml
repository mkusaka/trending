<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-22T01:35:41Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>stevana/bits-and-bobs</title>
    <updated>2023-01-22T01:35:41Z</updated>
    <id>tag:github.com,2023-01-22:/stevana/bits-and-bobs</id>
    <link href="https://github.com/stevana/bits-and-bobs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Bit-level codec library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;bits-and-bobs&lt;/h1&gt; &#xA;&lt;p&gt;A Haskell library for working with binary data, inspired by Erlang&#39;s bit syntax.&lt;/p&gt; &#xA;&lt;h3&gt;Motivation&lt;/h3&gt; &#xA;&lt;p&gt;Erlang has a feature called bit syntax which allows the user to encode and decode data at the bit-level. Here&#39;s an example, where we encode three integers into two bytes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;1&amp;gt;​ Red = 2.&#xA;2&#xA;2&amp;gt;​ Green = 61.&#xA;61&#xA;3&amp;gt;​ Blue = 20.&#xA;20&#xA;4&amp;gt;​ Mem = &amp;lt;&amp;lt;Red:5, Green:6, Blue:5&amp;gt;&amp;gt;.&#xA;&amp;lt;&amp;lt;23,180&amp;gt;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Normally, even the smallest integer takes up one byte (e.g. &lt;code&gt;char&lt;/code&gt; in C or &lt;code&gt;Int8&lt;/code&gt; in Haskell) but Erlang&#39;s bit syntax lets us encode, e.g., &lt;code&gt;Red&lt;/code&gt; using only 5 bits (rather than the default 8 bits) and thus we can fit all three integers in $5 + 6 + 5 = 16$ bits or two bytes.&lt;/p&gt; &#xA;&lt;p&gt;We can also pattern match at the bit-level using sizes to get our integers back:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;5&amp;gt;​ &amp;lt;&amp;lt;R1:5, G1:6, B1:5&amp;gt;&amp;gt; = Mem.&#xA;&amp;lt;&amp;lt;23,180&amp;gt;&amp;gt;&#xA;6&amp;gt;​ R1.&#xA;2&#xA;7&amp;gt;​ G1.&#xA;61&#xA;8&amp;gt;​ B1.&#xA;20&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For larger integer types, e.g. &lt;code&gt;0x12345678 :: Int32&lt;/code&gt;, we can also specify the byte order or &lt;a href=&#34;https://en.wikipedia.org/wiki/Endianness&#34;&gt;endianness&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;1&amp;gt;​ {&amp;lt;&amp;lt;16#12345678:32/big&amp;gt;&amp;gt;,&amp;lt;&amp;lt;16#12345678:32/little&amp;gt;&amp;gt;,&#xA;​&amp;lt;&amp;lt;16#12345678:32/native&amp;gt;&amp;gt;,&amp;lt;&amp;lt;16#12345678:32&amp;gt;&amp;gt;}.&#xA;{&amp;lt;&amp;lt;18,52,86,120&amp;gt;&amp;gt;,&amp;lt;&amp;lt;120,86,52,18&amp;gt;&amp;gt;,&#xA;&amp;lt;&amp;lt;120,86,52,18&amp;gt;&amp;gt;,&amp;lt;&amp;lt;18,52,86,120&amp;gt;&amp;gt;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a slightly larger example, here&#39;s pattern-matching on an IP datagram of IP protocol version 4:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;-define​(IP_VERSION, 4).&#xA;​-define​(IP_MIN_HDR_LEN, 5).&#xA;&#xA;...&#xA;DgramSize = ​byte_size​(Dgram),&#xA;​case​ Dgram ​of&#xA;  &amp;lt;&amp;lt;?IP_VERSION:4, HLen:4, SrvcType:8, TotLen:16,&#xA;    ID:16, Flags:3, FragOff:13,&#xA;    TTL:8, Proto:8, HdrChkSum:16,&#xA;    SrcIP:32,&#xA;    DestIP:32, RestDgram/binary&amp;gt;&amp;gt; ​when​ HLen &amp;gt;= 5, 4*HLen =&amp;lt; DgramSize -&amp;gt;&#xA;        OptsLen = 4*(HLen - ?IP_MIN_HDR_LEN),&#xA;        &amp;lt;&amp;lt;Opts:OptsLen/binary,Data/binary&amp;gt;&amp;gt; = RestDgram,&#xA;        ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note how we can match on the header length, &lt;code&gt;HLen&lt;/code&gt;, and later use the value of that match as the size when pattern matching on later values.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;This library lets you do similar things to Erlang&#39;s bit syntax, but in a more clunky way.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import BitsAndBobs&#xA;&#xA;let&#xA;  pattern0    = sized word32 5 ::: sized word32 6 ::: sized word32 5 ::: Nil&#xA;  bytestring0 = byteString [2 :. sized word32 5, 61 :. sized word32 6, 20 :. sized word32 5]&#xA;bitMatch pattern0 bytestring0&#xA;  -- =&amp;gt; (2,(61,(20,())))&#xA;&#xA;let&#xA;  pattern1    = word8 :&amp;gt;&amp;gt;= \sz -&amp;gt; sized bytes sz ::: bytes ::: Nil&#xA;  bytestring1 = byteString [5 :. word8, &#34;hello, rest&#34; :. bytes]&#xA;bitMatch pattern1 bytestring1&#xA;  -- =&amp;gt; (5,(&#34;hello&#34;,(&#34;, rest&#34;,())))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How it works&lt;/h3&gt; &#xA;&lt;p&gt;The high-level idea when encoding a bunch of, possibly sized, values into a &lt;code&gt;ByteString&lt;/code&gt; is as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;For each value convert the value into a list of booleans (or bits);&lt;/li&gt; &#xA; &lt;li&gt;If the value is sized then only take that many bits, otherwise if it isn&#39;t sized use the default value, e.g. &lt;code&gt;Int8&lt;/code&gt; = 8 bits, &lt;code&gt;Float&lt;/code&gt; = 32 bits, etc;&lt;/li&gt; &#xA; &lt;li&gt;Concatenate the lists of booleans for each value into a single list of booleans;&lt;/li&gt; &#xA; &lt;li&gt;Split the list in groups of 8 bits;&lt;/li&gt; &#xA; &lt;li&gt;Convert each 8 bits into a byte (&lt;code&gt;Word8&lt;/code&gt;);&lt;/li&gt; &#xA; &lt;li&gt;Create a &lt;code&gt;ByteString&lt;/code&gt; from list of &lt;code&gt;Word8&lt;/code&gt;s.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For decoding or pattern-matching a, possibly sized, pattern against a &lt;code&gt;ByteString&lt;/code&gt; the idea is:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Convert &lt;code&gt;ByteString&lt;/code&gt; into list of booleans (or bits);&lt;/li&gt; &#xA; &lt;li&gt;For each pattern take its size many bits from the list;&lt;/li&gt; &#xA; &lt;li&gt;Convert the bits into the value type of the pattern;&lt;/li&gt; &#xA; &lt;li&gt;Continue matching the remaining patterns against the remaining bits.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;code&gt;Float&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt;s get converted into &lt;code&gt;Word32&lt;/code&gt; and &lt;code&gt;Word64&lt;/code&gt; respectively before converted into bits, and &lt;code&gt;Int&lt;/code&gt;egers are encoding using &lt;a href=&#34;https://en.wikipedia.org/wiki/Variable-length_quantity#Zigzag_encoding&#34;&gt;zigzag&lt;/a&gt; encoding.&lt;/p&gt; &#xA;&lt;h3&gt;Contributing&lt;/h3&gt; &#xA;&lt;p&gt;There&#39;s a bunch of small things, that I know, are missing from Erlang:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for more types: &lt;code&gt;Word16&lt;/code&gt;, &lt;code&gt;Word64&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;BitString&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;Error checking, e.g. user provided size cannot be bigger than the size of the type, or not enough bits to make a match;&lt;/li&gt; &#xA; &lt;li&gt;Underscore patterns;&lt;/li&gt; &#xA; &lt;li&gt;Unit type specifier.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A couple of things that could make it more convenient to use:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Return ADT instead of tuples when matching, perhaps using &lt;code&gt;Monad&lt;/code&gt; or &lt;code&gt;Arrow&lt;/code&gt; interface?&lt;/li&gt; &#xA; &lt;li&gt;Generic encode/decode?&lt;/li&gt; &#xA; &lt;li&gt;Quasi quoting?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There&#39;s a couple of things that can be optimised as well:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Apparently &lt;code&gt;Data.Vector.Unboxed Bool&lt;/code&gt; isn&#39;t as tightly packed as they could be, see &lt;code&gt;bitvec&lt;/code&gt; package;&lt;/li&gt; &#xA; &lt;li&gt;Must be better way to go from bits to, say, &lt;code&gt;Word8&lt;/code&gt; by e.g. by casting? Probably relies on, the above point that, the bits being packed right first.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And a couple of chores:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;haddock&lt;/code&gt; perhaps with &lt;code&gt;doctest&lt;/code&gt;?&lt;/li&gt; &#xA; &lt;li&gt;CI&lt;/li&gt; &#xA; &lt;li&gt;Test suite &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Move existing tests;&lt;/li&gt; &#xA;   &lt;li&gt;Add property &lt;code&gt;forall seg. segToMatch seg == bitMatch (segToPattern seg) (byteString seg)&lt;/code&gt;?&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;But the thing that really interests me is the question: how can we go beyond what Erlang can do and make it even easier to work with binary data?&lt;/p&gt; &#xA;&lt;p&gt;For example, the current interface makes it possible to decode binary data into Haskell types, which can then be manipulated, and finally encoded back to binary. But what if I merely want to update some binary in-place without reading it all in and writing it all back out?&lt;/p&gt; &#xA;&lt;p&gt;For example consider some on disk data structure, e.g. a B-tree. Or imagine a concurrent lock-free queue implemented on top of an byte array, where we want to atomically increment and fetch some position counter and then based on that write the data at the right offset into the array.&lt;/p&gt; &#xA;&lt;p&gt;How can we do zero-copy/zero-parse stuff? E.g. lets say we have a pre-allocated byte array/pointer to &lt;code&gt;Word8&lt;/code&gt; buffer, we could then use &lt;a href=&#34;https://hackage.haskell.org/package/network-3.1.2.7/docs/Network-Socket.html#v:recvBufFrom&#34;&gt;&lt;code&gt;recvBufFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt; :: Socket -&amp;gt; Ptr a -&amp;gt; Int -&amp;gt; IO (Int, SockAddr)&lt;/code&gt; to receive network traffic from a socket into that buffer and thus avoiding copying and therefore allocating memory. Imagine we use some protocol where we can inspect the first few bits to find out which type of message it is, and based on the message type we know at what offsets its fields are, could we then project those fields by merely casting (i.e. avoid parsing)?&lt;/p&gt; &#xA;&lt;p&gt;Another question would be if we can encode and pattern-match modulo (column) compression?&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m not sure if this repo is a good starting point for trying to answer these questions, perhaps a completely different approach is required but it helped me understand Erlang&#39;s approach and limitations a bit better at least.&lt;/p&gt; &#xA;&lt;p&gt;If any of the above interests you, feel free to get in touch.&lt;/p&gt; &#xA;&lt;h3&gt;See also&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax&#34;&gt;https://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax&lt;/a&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.erlang.org/doc/programming_examples/bit_syntax.html&#34;&gt;https://www.erlang.org/doc/programming_examples/bit_syntax.html&lt;/a&gt;;&lt;/li&gt; &#xA; &lt;li&gt;Joe Armstrong&#39;s PhD &lt;a href=&#34;http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A9492&amp;amp;dswid=-1166&#34;&gt;thesis&lt;/a&gt; (2003), p. 60;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/binary-bits&#34;&gt;https://hackage.haskell.org/package/binary-bits&lt;/a&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/axman6/BitParser&#34;&gt;https://github.com/axman6/BitParser&lt;/a&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/squaremo/bitsyntax-js&#34;&gt;https://github.com/squaremo/bitsyntax-js&lt;/a&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://capnproto.org/&#34;&gt;https://capnproto.org/&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/stevana/bits-and-bobs/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cs340ppp/lectures</title>
    <updated>2023-01-22T01:35:41Z</updated>
    <id>tag:github.com,2023-01-22:/cs340ppp/lectures</id>
    <link href="https://github.com/cs340ppp/lectures" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CS 340 lecture notes&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;CS 340 Lecture Repository&lt;/h2&gt; &#xA;&lt;p&gt;This repository contains lecture notes and sample code for CS 340: Patterns and Paradigms of Programming. Notes reside in numbered files in &#34;src&#34;, and are mostly made up of literate Haskell files with intermingled English and code.&lt;/p&gt; &#xA;&lt;p&gt;I will likely be making changes to these files throughout the semester, so please be sure to pull the most recent changes before attending lecture. To avoid merge issues, I recommend you create a separate branch for your own additions and modifications so that you can always pull my changes into a pristine local branch.&lt;/p&gt; &#xA;&lt;p&gt;-- Michael Lee &lt;a href=&#34;mailto:lee@iit.edu&#34;&gt;lee@iit.edu&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>