<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-06-10T01:31:53Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>turion/rhine</title>
    <updated>2024-06-10T01:31:53Z</updated>
    <id>tag:github.com,2024-06-10:/turion/rhine</id>
    <link href="https://github.com/turion/rhine" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell Functional Reactive Programming framework with type-level clocks&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;README&lt;/h1&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/turion/rhine/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/turion/rhine/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/rhine&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/rhine.svg?sanitize=true&#34; alt=&#34;Version on Hackage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Rhine is a library for synchronous and asynchronous Functional Reactive Programming (FRP). It separates the aspects of clocking, scheduling and resampling from each other, and ensures clock-safety on the type level.&lt;/p&gt; &#xA;&lt;h2&gt;Recent breakage?&lt;/h2&gt; &#xA;&lt;p&gt;Confused because some examples from the article don&#39;t work anymore? Rhine went through a few bigger API simplifications and changes. If this broke your code, have a look at &lt;a href=&#34;https://raw.githubusercontent.com/turion/rhine/master/versions.md&#34;&gt;the versions readme&lt;/a&gt; to fix it.&lt;/p&gt; &#xA;&lt;h2&gt;Concept&lt;/h2&gt; &#xA;&lt;p&gt;Complex reactive programs often process data at different rates. For example, games, GUIs and media applications may output audio and video signals, or receive user input at unpredictable times. Coordinating these different rates is a hard problem in general. If not enough care is taken, buffer underruns and overflows, space and time leaks, accidental synchronisation of independent sub-systems, and concurrency issues, such as deadlocks, may all occur.&lt;/p&gt; &#xA;&lt;p&gt;Rhine tackles these problems by annotating the signal processing components with clocks, which hold the information when data will be input, processed and output. Different components of the signal network will become active at different times, or work at different rates. If components running under different clocks need to communicate, it has to be decided when each component becomes active (&#34;scheduling&#34;), and how data is transferred between the different rates (&#34;resampling&#34;). Rhine separates all these aspects from each other, and from the individual signal processing of each subsystem. It offers a flexible API to all of them and implements several reusable standard solutions. In the places where these aspects need to intertwine, typing constraints on clocks come into effect, enforcing clock safety.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;A typical example, which can be run as &lt;code&gt;cd rhine-examples/ &amp;amp;&amp;amp; cabal run Demonstration&lt;/code&gt;, (or using nix flakes with &lt;code&gt;nix develop&lt;/code&gt; followed &lt;code&gt;cabal run Demonstration&lt;/code&gt;), would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;  -- | Create a simple message containing the time stamp since initialisation,&#xA;  --   for each tick of the clock.&#xA;  --   Since &#39;createMessage&#39; works for arbitrary clocks (and doesn&#39;t need further input data),&#xA;  --   it is a &#39;Behaviour&#39;.&#xA;  --   @time@ is the &#39;TimeDomain&#39; of any clock used to sample,&#xA;  --   and it needs to be constrained in order for time differences&#xA;  --   to have a &#39;Show&#39; instance.&#xA;  createMessage&#xA;    :: (Monad m, Show (Diff time))&#xA;    =&amp;gt; String&#xA;    -&amp;gt; Behaviour m time String&#xA;  createMessage str&#xA;    =   timeInfoOf sinceInit &amp;gt;-&amp;gt; arr show&#xA;    &amp;gt;-&amp;gt; arr ((&#34;Clock &#34; ++ str ++ &#34; has ticked at: &#34;) ++)&#xA;&#xA;  -- | Output a message /every second/ (= every 1000 milliseconds).&#xA;  --   Let us assume we want to assure that &#39;printEverySecond&#39;&#xA;  --   is only called every second,&#xA;  --   then we constrain its type signature with the clock @Millisecond 1000@.&#xA;  printEverySecond :: Show a =&amp;gt; ClSF IO (Millisecond 1000) a ()&#xA;  printEverySecond = arrMCl print&#xA;&#xA;  -- | Specialise &#39;createMessage&#39; to a specific clock.&#xA;  ms500 :: ClSF IO (Millisecond 500) () String&#xA;  ms500 = createMessage &#34;500 MS&#34;&#xA;&#xA;&#xA;  ms1200 :: ClSF IO (Millisecond 1200) () String&#xA;  ms1200 = createMessage &#34;1200 MS&#34;&#xA;&#xA;  -- | Create messages every 500 ms and every 1200 ms,&#xA;  --   collecting all of them in a list,&#xA;  --   which is output every second.&#xA;  main :: IO ()&#xA;  main = flow $&#xA;    ms500 @@ waitClock            --  a Rhine = a ClSF in the context of a Clock&#xA;    |@|                           --  compose 2 Rhines in parallel&#xA;    ms1200 @@ waitClock           --  a Rhine at a different clock&#xA;    &amp;gt;-- collect --&amp;gt;               --  buffer results from both Rhines into a list&#xA;    printEverySecond @@ waitClock --  the final Rhine&#xA;&#xA;  -- | Uncomment the following for a type error (the clocks don&#39;t match):&#xA;&#xA;  -- typeError = ms500 &amp;gt;&amp;gt;&amp;gt; printEverySecond&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;This repository&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;rhine/&lt;/code&gt;: The main library, which is also mirrored on hackage.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rhine-gloss/&lt;/code&gt;: A wrapper library to &lt;a href=&#34;https://hackage.haskell.org/package/gloss&#34;&gt;&lt;code&gt;gloss&lt;/code&gt;&lt;/a&gt;, a functional OpenGL library.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rhine-bayes/&lt;/code&gt;: A library for stochastic processes and online machine learning, using &lt;a href=&#34;https://hackage.haskell.org/package/monad-bayes&#34;&gt;&lt;code&gt;monad-bayes&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rhine-terminal/&lt;/code&gt;: A wrapper library to &lt;a href=&#34;https://hackage.haskell.org/package/terminal&#34;&gt;&lt;code&gt;terminal&lt;/code&gt;&lt;/a&gt;, a library to write terminal applications.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rhine-examples/&lt;/code&gt;: Different examples as a starting point to learn Rhine.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Learn Rhine&lt;/h2&gt; &#xA;&lt;p&gt;The recommended way to start is the &lt;a href=&#34;https://github.com/turion/rhine-koans/&#34;&gt;https://github.com/turion/rhine-koans/&lt;/a&gt; tutorial. It leads you through basic and advanced Rhine concepts by solving many self-contained puzzles.&lt;/p&gt; &#xA;&lt;p&gt;For a quick reference of the most important functions, operators, and concepts, see the &lt;a href=&#34;https://github.com/turion/rhine/raw/master/CHEATSHEET.md&#34;&gt;cheatsheet&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Documentation resources&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.tweag.io/blog/2023-10-12-rhine-bayes/&#34;&gt;https://www.tweag.io/blog/2023-10-12-rhine-bayes/&lt;/a&gt;: A blog post about how to do machine learning with Rhine.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/turion/rhine/tree/master/rhine-examples/src&#34;&gt;https://github.com/turion/rhine/tree/master/rhine-examples/src&lt;/a&gt;: Many self-contained examples showcasing typical Rhine concepts in an idiomatic style.&lt;/li&gt; &#xA; &lt;li&gt;The research article &lt;a href=&#34;https://www.manuelbaerenz.de/files/Rhine.pdf&#34;&gt;Rhine: FRP with Type-Level Clocks&lt;/a&gt; is not quite up to date with the most recent changes, but gives a good overview behind the concepts and design ideas.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/rhine&#34;&gt;&lt;code&gt;hackage&lt;/code&gt;&lt;/a&gt;: Reference documentation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.stackage.org/package/rhine&#34;&gt;&lt;code&gt;stackage&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/turion/rhine-tutorial&#34;&gt;https://github.com/turion/rhine-tutorial&lt;/a&gt;: Presentation and tutorial app&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/turion/sonnendemo&#34;&gt;https://github.com/turion/sonnendemo&lt;/a&gt;: Demo application&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Why does my blocking code, e.g. &lt;code&gt;arrMCl readLn&lt;/code&gt;, behave &lt;a href=&#34;https://github.com/turion/rhine/issues/153&#34;&gt;erratically&lt;/a&gt;?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/rhine/docs/FRP-Rhine-Clock.html&#34;&gt;&lt;code&gt;Clock&lt;/code&gt;&lt;/a&gt;s must be the only things that block a thread, not &lt;a href=&#34;https://hackage.haskell.org/package/rhine/docs/FRP-Rhine-ClSF-Core.html#t:ClSF&#34;&gt;&lt;code&gt;ClSF&lt;/code&gt;&lt;/a&gt;s. So for example, you can fix:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;arrMCl readLn&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;by using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;tagS &amp;gt;&amp;gt;&amp;gt; arr read :: ClSF IO StdinClock () Int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/rhine/docs/FRP-Rhine.html#v:tagS&#34;&gt;&lt;code&gt;tagS&lt;/code&gt;&lt;/a&gt; contains the string that the &lt;a href=&#34;https://hackage.haskell.org/package/rhine/docs/FRP-Rhine.html#t:StdinClock&#34;&gt;&lt;code&gt;StdinClock&lt;/code&gt;&lt;/a&gt; grabbed from &lt;code&gt;stdin&lt;/code&gt;, and only the clock has been allowed to block the thread!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Can a sampling schedule dynamically change, e.g. depend on a signal?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Yes, for instance you could implement a distance-dependent &lt;a href=&#34;https://github.com/turion/rhine/issues/152&#34;&gt;collision detector&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;How to handle slow computations, i.e. computations that take longer than the sample rate?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Several &lt;a href=&#34;https://github.com/turion/rhine/issues/151&#34;&gt;strategies exist&lt;/a&gt; and it depends on your use case. For &lt;a href=&#34;https://hackage.haskell.org/package/rhine/docs/FRP-Rhine-Clock-FixedStep.html#t:FixedStep&#34;&gt;&lt;code&gt;FixedStep&lt;/code&gt;&lt;/a&gt; clocks, it won&#39;t matter since the execution of the program isn&#39;t tied to a realtime clock. For &lt;a href=&#34;https://hackage.haskell.org/package/rhine/docs/FRP-Rhine-ClSF-Core.html#t:ClSF&#34;&gt;&lt;code&gt;ClSF&lt;/code&gt;&lt;/a&gt;s running on &lt;code&gt;UTCTime&lt;/code&gt; clocks, you can execute the slow code in a separate thread and coordinate merging the results back into the signal network.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/turion/rhine/master/Contributing.md&#34;&gt;&lt;code&gt;Contributing.md&lt;/code&gt;&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Rhine usually follows up-to-date GHC versions.&lt;/li&gt; &#xA; &lt;li&gt;Contributions are welcome! There are always a few issues labelled &lt;code&gt;help needed&lt;/code&gt;, in case you&#39;re looking for an easy way to get started.&lt;/li&gt; &#xA; &lt;li&gt;Rhine is a beginner-friendly Haskell project! Even if you&#39;re new to Haskell and FRP, you can contribute. This is a good place to start contributing to open-source projects. Have a look at issues labelled &lt;code&gt;good first issue&lt;/code&gt;. If you have questions, don&#39;t hesitate to ask on Github.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Related projects&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/turion/rhine-tutorial&#34;&gt;https://github.com/turion/rhine-tutorial&lt;/a&gt;: Presentation and tutorial app&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fphh/rhine-ghcjs/&#34;&gt;https://github.com/fphh/rhine-ghcjs/&lt;/a&gt;: A little browser game written with Rhine and &lt;code&gt;react-hs&lt;/code&gt;, compiles with &lt;code&gt;GHCJS&lt;/code&gt; to JavaScript.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/turion/sonnendemo&#34;&gt;https://github.com/turion/sonnendemo&lt;/a&gt;: An interactive simulation with a GUI version and a console version, using &lt;code&gt;rhine-gloss&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>