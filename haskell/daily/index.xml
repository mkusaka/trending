<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-19T01:34:04Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tittoassini/notebook</title>
    <updated>2022-11-19T01:34:04Z</updated>
    <id>tag:github.com,2022-11-19:/tittoassini/notebook</id>
    <link href="https://github.com/tittoassini/notebook" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rough and Ready Haskell Notebooks with HLS and VS Code&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Transform your old and tired Haskell source files into shining Notebooks&lt;/h1&gt; &#xA;&lt;p&gt;Have you ever suffered from Notebook envy?&lt;/p&gt; &#xA;&lt;p&gt;Have you ever felt a pang of jealousy about Python programmers and their cool data science Jupyter notebooks?&lt;/p&gt; &#xA;&lt;p&gt;The most complete antidote to this particular form of existential angst is installing Haskell&#39;s own &lt;a href=&#34;https://hackage.haskell.org/package/ihaskell&#34;&gt;Jupyter backend&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;But if, like many Haskell developers these days, you use the &lt;a href=&#34;https://github.com/haskell/haskell-language-server&#34;&gt;Haskell Language Server&lt;/a&gt; and &lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;VS Code&lt;/a&gt;, you can immediately transform any Haskell source file into a rough and ready notebook without any additional configuration and without the need to run another bulky server.&lt;/p&gt; &#xA;&lt;h1&gt;Demo&lt;/h1&gt; &#xA;&lt;p&gt;Check out this &lt;a href=&#34;https://raw.githubusercontent.com/tittoassini/notebook/main/src/Notebook.hs&#34;&gt;example&lt;/a&gt; of generating and displaying:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;mathematical formulas&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;images&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;all kinds of charts and graphs&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/diagrams&#34;&gt;diagrams&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;data tables&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tittoassini/notebook/main/notebook.gif&#34; alt=&#34;Demo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Video captured using &lt;a href=&#34;https://www.cockos.com/licecap/&#34;&gt;LICECap&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Now You Do It&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the VS Code extension &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=zhaouv.vscode-markdown-everywhere&#34;&gt;Markdown Everywhere&lt;/a&gt;. This will instruct VS Code to display Markdown/HTML code embedded in Haskell comments.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Optional: Install a &lt;a href=&#34;https://mermaid-js.github.io/mermaid&#34;&gt;Mermaid&lt;/a&gt; VS Code extension like &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=bierner.markdown-mermaid&#34;&gt;Markdown Mermaid&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Generate Markdown/HTML code in Haskell comments using HLS&#39;s built-in &lt;a href=&#34;https://github.com/haskell/haskell-language-server/raw/master/plugins/hls-eval-plugin/README.md&#34;&gt;eval plugin&lt;/a&gt;. Check out &lt;a href=&#34;https://raw.githubusercontent.com/tittoassini/notebook/main/src/Notebook.hs&#34;&gt;src/Notebook.hs&lt;/a&gt; for examples and tips.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;⌘K V&lt;/strong&gt; in the Haskell source file to open the sideline Markdown preview.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Run the Example File Locally&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/tittoassini/notebook.git&#xA;cd notebook;stack build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: compilation will take a long time as the examples use a variety of large packages (&lt;a href=&#34;https://hackage.haskell.org/package/pandoc&#34;&gt;pandoc&lt;/a&gt;, &lt;a href=&#34;https://hackage.haskell.org/package/diagrams&#34;&gt;diagrams&lt;/a&gt;, etc.).&lt;/p&gt; &#xA;&lt;p&gt;Open &lt;a href=&#34;https://raw.githubusercontent.com/tittoassini/notebook/main/src/Notebook.hs&#34;&gt;src/Notebook.hs&lt;/a&gt; in VS Code and &lt;strong&gt;⌘K V&lt;/strong&gt; to open the Markdown preview.&lt;/p&gt; &#xA;&lt;h1&gt;What? No VS Code?&lt;/h1&gt; &#xA;&lt;p&gt;If your editor supports HLS but does not have a way of displaying the generated markdown/html, you might run a separate process that checks for any changed Haskell source file and automatically process and displays it.&lt;/p&gt; &#xA;&lt;p&gt;Install &lt;code&gt;pandoc&lt;/code&gt; and &lt;code&gt;mermaid-filter&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install -g mermaid-filter&#xA;&#xA;stack install pandoc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The basic &lt;code&gt;pandoc&lt;/code&gt; invocation to, for example, convert &lt;code&gt;src\Notebook.hs&lt;/code&gt; to &lt;code&gt;html\Notebook.html&lt;/code&gt; is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pandoc -s  --from markdown_mmd  --highlight-style kate -t html -F mermaid-filter --metadata title=Notebook  -o html/Notebook.html src/Notebook.hs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result it very similar to what we see in VS Code:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tittoassini/notebook/main/notebook-pandoc.gif&#34; alt=&#34;Demo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Video captured using &lt;a href=&#34;https://www.cockos.com/licecap/&#34;&gt;LICECap&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To run &lt;code&gt;pandoc&lt;/code&gt; automatically when a source file changes there are many options.&lt;/p&gt; &#xA;&lt;p&gt;If you are working with a single file, you might just use &lt;code&gt;stack&lt;/code&gt;&#39;s built-in file watcher:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;stack build --file-watch --exec &#34;pandoc -s  --from markdown_mmd  --highlight-style kate -t html -F mermaid-filter --metadata title=Notebook  -o html/Notebook.html src/Notebook.hs&#34; &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For multiple files, you will need a more sophisticated file watching utility like &lt;a href=&#34;https://www.npmjs.com/package/chokidar-cli&#34;&gt;chokidar&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install -g chokidar-cli&#xA;&#xA;chokidar &#34;**/*.hs&#34; -c &#34;if [ &#39;{event}&#39; = &#39;change&#39; ]; then pandoc -s  --from markdown_mmd --highlight-style kate -t html -F mermaid-filter --metadata title={path}  -o {path}.html {path}; fi;&#34; &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create/update an &lt;code&gt;.hs.html&lt;/code&gt; file every time an &lt;code&gt;.hs&lt;/code&gt; file is modified.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tcsavage/rumex</title>
    <updated>2022-11-19T01:34:04Z</updated>
    <id>tag:github.com,2022-11-19:/tcsavage/rumex</id>
    <link href="https://github.com/tcsavage/rumex" rel="alternate"></link>
    <summary type="html">&lt;p&gt;bRainfUck iMproved EXtended - An extended version of the RUM Brainfuck variant, implemented in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;RUMEX&lt;/h1&gt; &#xA;&lt;p&gt;bRainfUck iMproved EXtended - An extended version of the RUM Brainfuck variant implemented in Haskell.&lt;/p&gt; &#xA;&lt;p&gt;This project serves as both an educational tool - for leraning about lexers, parsers, interpreters and compilers - and as a fun toy language to play with.&lt;/p&gt; &#xA;&lt;p&gt;RUMEX is a modified implementation of the RUM Brainfuck variant. Where as RUM is a superset of Brainfuck, RUMEX is not. This is because RUMEX uses explicit comment delimiters, as opposed to Brainfuck&#39;s &#34;anything that isn&#39;t code is ignored&#34; approach. This is primarily to permit comments to contain characters which would otherwise be considered code, but it has the added advantage of improving clarity as well.&lt;/p&gt; &#xA;&lt;h2&gt;Commands&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Standard Brainfuck&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;+&lt;/code&gt; - Increment current cell&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-&lt;/code&gt; - Decreement current cell&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; - Move pointer left&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; - Move pointer right&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.&lt;/code&gt; - Write current value to console as ASCII&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;,&lt;/code&gt; - Read character from input and store ASCII value&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[&lt;/code&gt; - Jump to matching &lt;code&gt;]&lt;/code&gt; if current value is zero&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;]&lt;/code&gt; - Jump to matching &lt;code&gt;[&lt;/code&gt; if current value is non-zero&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;RUM&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;nOp&lt;/code&gt; - Repeat &lt;code&gt;Op&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; times&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;string&#34;&lt;/code&gt; - Append string to the input&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(commands)&lt;/code&gt; - Create a stored procedure containing &lt;code&gt;commands&lt;/code&gt;, with an ID equal to the current value on the tape&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:&lt;/code&gt; - Invoke stored procedure with the ID equal to the current value on the tape&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;RUMEX&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;#&lt;/code&gt; - Write current value to console as a number&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;{* ... *}&lt;/code&gt; - Explicit comment blocks&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>