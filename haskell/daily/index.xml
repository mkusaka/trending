<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-28T01:42:48Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sweirich/pi-forall</title>
    <updated>2022-06-28T01:42:48Z</updated>
    <id>tag:github.com,2022-06-28:/sweirich/pi-forall</id>
    <link href="https://github.com/sweirich/pi-forall" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A demo implementation of a simple dependently-typed language&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;pi-forall language&lt;/h2&gt; &#xA;&lt;p&gt;This language implementation is designed to accompany four lectures at OPLSS during Summer 2022. Notes for these lectures are included in the distribution:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sweirich/pi-forall/2022/doc/oplss.pdf&#34;&gt;oplss.pdf&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(The documentation &lt;a href=&#34;https://raw.githubusercontent.com/sweirich/pi-forall/2022/doc/README.md&#34;&gt;README.md&lt;/a&gt; includes details about how the notes are typeset.)&lt;/p&gt; &#xA;&lt;p&gt;These lecture notes correspond to an increasingly expressive demo implementation of dependently-typed lambda calculus. Each of the following subdirectories is self-contained (and all are generated from the same source, located in the &lt;a href=&#34;https://raw.githubusercontent.com/sweirich/pi-forall/2022/main/&#34;&gt;main/&lt;/a&gt; directory).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sweirich/pi-forall/2022/version1/&#34;&gt;version1/&lt;/a&gt;: Basic language implementation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sweirich/pi-forall/2022/version2/&#34;&gt;version2/&lt;/a&gt;: Basic language extended with nontrivial definitional equality&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sweirich/pi-forall/2022/version3/&#34;&gt;version3/&lt;/a&gt;: Above, extended with irrelevant arguments&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sweirich/pi-forall/2022/full/&#34;&gt;full/&lt;/a&gt;: Full language with datatypes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The implementation &lt;a href=&#34;https://raw.githubusercontent.com/sweirich/pi-forall/2022/main/README.md&#34;&gt;README.md&lt;/a&gt; includes instructions about how to compile and work with these implementations.&lt;/p&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;p&gt;This is a revised version of lecture notes originally presented at OPLSS during 2014 and 2013.&lt;/p&gt; &#xA;&lt;p&gt;Videos from the 2014 lectures are also available from the &lt;a href=&#34;https://www.cs.uoregon.edu/research/summerschool/summer14/curriculum.html&#34;&gt;OPLSS website&lt;/a&gt;. If you want to watch these videos, you should look at the 2014 branch of this repository.&lt;/p&gt; &#xA;&lt;p&gt;An abridged version of these lectures was also given at the Compose Conference, January 2015. Notes from this version are also available.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sweirich/pi-forall/2022/old/compose.md&#34;&gt;compose.md&lt;/a&gt;: Overview of pi-forall implementation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;-- Stephanie Weirich&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>lambdageek/unbound-generics</title>
    <updated>2022-06-28T01:42:48Z</updated>
    <id>tag:github.com,2022-06-28:/lambdageek/unbound-generics</id>
    <link href="https://github.com/lambdageek/unbound-generics" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Specify variable binding in syntax trees using GHC.Generics (reimplementation of Unbound)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;unbound-generics&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/lambdageek/unbound-generics?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Join%20Chat.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/lambdageek/unbound-generics&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/CRfu93W&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/732650960471720076?logo=discord&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/unbound-generics&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/unbound-generics.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/lambdageek/unbound-generics/actions?query=workflow%3ACI+branch%3Amain&#34;&gt;&lt;img src=&#34;https://github.com/lambdageek/unbound-generics/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- [![Build Status](https://travis-ci.org/lambdageek/unbound-generics.svg)](https://travis-ci.org/lambdageek/unbound-generics) --&gt; &#xA;&lt;p&gt;Support for programming with names and binders using GHC Generics.&lt;/p&gt; &#xA;&lt;h2&gt;Summary&lt;/h2&gt; &#xA;&lt;p&gt;Specify the binding structure of your data type with an expressive set of type combinators, and &lt;code&gt;unbound-generics&lt;/code&gt; handles the rest! Automatically derives alpha-equivalence, free variable calculation, capture-avoiding substitution, and more. See &lt;a href=&#34;https://raw.githubusercontent.com/lambdageek/unbound-generics/main/src/Unbound/Generics/LocallyNameless.hs&#34;&gt;&lt;code&gt;Unbound.Generics.LocallyNameless&lt;/code&gt;&lt;/a&gt; to get started.&lt;/p&gt; &#xA;&lt;p&gt;This is a reimplementation of (parts of) &lt;a href=&#34;http://hackage.haskell.org/package/unbound&#34;&gt;unbound&lt;/a&gt; but using &lt;a href=&#34;http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.1/GHC-Generics.html&#34;&gt;GHC generics&lt;/a&gt; instead of &lt;a href=&#34;https://hackage.haskell.org/package/RepLib&#34;&gt;RepLib&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Some examples are in the &lt;code&gt;examples/&lt;/code&gt; directory in the source. And also at &lt;a href=&#34;https://lambdageek.github.io/unbound-generics&#34;&gt;unbound-generics on GitHub Pages&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Example: Untyped lambda calculus interpreter&lt;/h3&gt; &#xA;&lt;p&gt;Here is how you would implement call by value evaluation for the untyped lambda calculus:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE DeriveDataTypeable, DeriveGeneric, MultiParamTypeClasses #-}&#xA;module UntypedLambdaCalc where&#xA;import Unbound.Generics.LocallyNameless&#xA;import GHC.Generics (Generic)&#xA;import Data.Typeable (Typeable)&#xA;&#xA;-- | Variables stand for expressions&#xA;type Var = Name Expr&#xA;&#xA;-- | Expressions&#xA;data Expr = V Var                -- ^ variables&#xA;          | Lam (Bind Var Expr) -- ^ lambdas bind a variable within a body expression&#xA;          | App Expr Expr       -- ^ application&#xA;          deriving (Show, Generic, Typeable)&#xA;&#xA;-- Automatically construct alpha equivalence, free variable computation and binding operations.&#xA;instance Alpha Expr&#xA;&#xA;-- semi-automatically implement capture avoiding substitution of expressions for expressions&#xA;instance Subst Expr Expr where&#xA;  -- `isvar` identifies the variable case in your AST.&#xA;  isvar (V x) = Just (SubstName x)&#xA;  isvar _     = Nothing&#xA;&#xA;-- evaluation takes an expression and returns a value while using a source of fresh names&#xA;eval :: Expr -&amp;gt; FreshM Expr&#xA;eval (V x) = fail $ &#34;unbound variable &#34; ++ show x&#xA;eval e@(Lam {}) = return e&#xA;eval (App e1 e2) = do&#xA;  v1 &amp;lt;- eval e1&#xA;  v2 &amp;lt;- eval e2&#xA;  case v1 of&#xA;   (Lam bnd) -&amp;gt; do&#xA;     -- open the lambda by picking a fresh name for the bound variable x in body&#xA;     (x, body) &amp;lt;- unbind bnd&#xA;     let body&#39; = subst x v2 body&#xA;     eval body&#39;&#xA;   _ -&amp;gt; fail &#34;application of non-lambda&#34;&#xA;&#xA;example :: Expr&#xA;example =&#xA;  let x = s2n &#34;x&#34;&#xA;      y = s2n &#34;y&#34;&#xA;      e = Lam $ bind x (Lam $ bind y (App (V y) (V x)))&#xA;  in runFreshM $ eval (App (App e e) e)&#xA;  &#xA;-- &amp;gt;&amp;gt;&amp;gt; example&#xA;-- Lam (&amp;lt;y&amp;gt; App (V 0@0) (Lam (&amp;lt;x&amp;gt; Lam (&amp;lt;y&amp;gt; App (V 0@0) (V 1@0)))))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Differences from &lt;code&gt;unbound&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;For the most part, I tried to keep the same methods with the same signatures. However there are a few differences.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;fv :: Alpha t =&amp;gt; Fold t (Name n)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The &lt;code&gt;fv&lt;/code&gt; method returns a &lt;code&gt;Fold&lt;/code&gt; (in the sense of the &lt;a href=&#34;http://hackage.haskell.org/package/lens&#34;&gt;lens&lt;/a&gt; library), rather than an &lt;code&gt;Unbound.Util.Collection&lt;/code&gt; instance. That means you will generally have to write &lt;code&gt;toListOf fv t&lt;/code&gt; or some other summary operation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Utility methods in the &lt;code&gt;Alpha&lt;/code&gt; class have different types.&lt;/p&gt; &lt;p&gt;You should only notice this if you&#39;re implementing an instance of &lt;code&gt;Alpha&lt;/code&gt; by hand (rather than by using the default generic instance).&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;&lt;code&gt;isPat :: Alpha t =&amp;gt; t -&amp;gt; DisjointSet AnyName&lt;/code&gt; The original &lt;code&gt;unbound&lt;/code&gt; returned a &lt;code&gt;Maybe [AnyName]&lt;/code&gt; here with the same interpretation as &lt;code&gt;DisjointSet&lt;/code&gt;: &lt;code&gt;Nothing&lt;/code&gt; means an inconsistency was encountered, or &lt;code&gt;Just&lt;/code&gt; the free variables of the pattern.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;isTerm :: Alpha t =&amp;gt; t -&amp;gt; All&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;open :: Alpha t =&amp;gt; AlphaCtx -&amp;gt; NthPatFind -&amp;gt; t -&amp;gt; t&lt;/code&gt;, &lt;code&gt;close :: Alpha t =&amp;gt; AlphaCtx -&amp;gt; NamePatFind -&amp;gt; t -&amp;gt; t&lt;/code&gt; where &lt;code&gt;NthPatFind&lt;/code&gt; and &lt;code&gt;NamePatFind&lt;/code&gt; are newtypes&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;embed :: IsEmbed e =&amp;gt; Embedded e -&amp;gt; e&lt;/code&gt; and &lt;code&gt;unembed :: IsEmbed e =&amp;gt; e -&amp;gt; Embedded e&lt;/code&gt;&lt;/p&gt; &lt;p&gt;The typeclass &lt;code&gt;IsEmbed&lt;/code&gt; has an &lt;code&gt;Iso&lt;/code&gt; (again in the sense of the &lt;code&gt;lens&lt;/code&gt; library) as a method instead of the above pair of methods.&lt;/p&gt; &lt;p&gt;Again, you should only notice this if you&#39;re implementing your own types that are instances of &lt;code&gt;IsEmbed&lt;/code&gt;. The easiest thing to do is to use implement &lt;code&gt;embedded = iso yourEmbed yourUnembed&lt;/code&gt; where &lt;code&gt;iso&lt;/code&gt; comes from &lt;code&gt;lens&lt;/code&gt;. (Although you can also implement it in terms of &lt;code&gt;dimap&lt;/code&gt; if you don&#39;t want to depend on lens)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>input-output-hk/hedgehog-extras</title>
    <updated>2022-06-28T01:42:48Z</updated>
    <id>tag:github.com,2022-06-28:/input-output-hk/hedgehog-extras</id>
    <link href="https://github.com/input-output-hk/hedgehog-extras" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>