<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-06T01:29:33Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sudowork/arch-dotfiles</title>
    <updated>2023-09-06T01:29:33Z</updated>
    <id>tag:github.com,2023-09-06:/sudowork/arch-dotfiles</id>
    <link href="https://github.com/sudowork/arch-dotfiles" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Dotfiles for my arch system&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>JoshuaOSHickman/ThaiCubePuzzleSolution</title>
    <updated>2023-09-06T01:29:33Z</updated>
    <id>tag:github.com,2023-09-06:/JoshuaOSHickman/ThaiCubePuzzleSolution</id>
    <link href="https://github.com/JoshuaOSHickman/ThaiCubePuzzleSolution" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A 3x3x3 cube created by a string of rotatable connected blocks&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ThaiCubePuzzleSolution&lt;/h1&gt; &#xA;&lt;p&gt;A 3x3x3 cube created by a string of rotatable connected blocks.&lt;/p&gt; &#xA;&lt;h1&gt;The Solution Story&lt;/h1&gt; &#xA;&lt;p&gt;So, I see this wooden 3x3x3 cube on a shelf at work. I make a comment about it looking like a silly easy version of the rubik&#39;s cube. Because, you know, it has two colors. The guy sitting next to it laughs, grabs it, unravels the blocks, and tosses it over.&lt;/p&gt; &#xA;&lt;p&gt;So I try and solve this for maybe 20 minutes before heading out for the day, and I can&#39;t get it. So I realize I can have an unambiguous record of the shape by making the blocks go only up and to the right, and writing down the length of each row. So I do that, and go home.&lt;/p&gt; &#xA;&lt;p&gt;I take this, think about how the puzzle works, encode it into COMPRUDER-SPEAK (in this case Haskell, for the List monad, which I am using for search/non-determinism/backtracking). I get the solution, map it out in my head to sanity check it, and go to sleep. At this point, it&#39;s maybe 3am, because it&#39;s Friday and I&#39;m farting around on the internet and watching videos while I code. As a side note, Haskell seems to allow me to do the smartest, cleanest stuff while tired. I &lt;em&gt;totally&lt;/em&gt; lost track of what I was doing once or twice, but the compiler put me back on track no problem. I cannot overstate how useful and interesting that is.&lt;/p&gt; &#xA;&lt;p&gt;Anyhow, after trying to explain this to some people, I realized they needed the pictures, so I started googling around. Turns out googling for &#34;block cube puzzle 27&#34; shows that the wider internets calls this the Snake Cube Puzzle.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>alpmestan/kmeans-vector</title>
    <updated>2023-09-06T01:29:33Z</updated>
    <id>tag:github.com,2023-09-06:/alpmestan/kmeans-vector</id>
    <link href="https://github.com/alpmestan/kmeans-vector" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Data.Vector based implementation of the kmeans clustering algorithm&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;k-means clustering algorithm in Haskell&lt;/h1&gt; &#xA;&lt;p&gt;kmeans-vector is a Haskell library for performing the k-means clustering algorithm. It is based on the very efficient &#39;vector&#39; library.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://travis-ci.org/alpmestan/kmeans-vector&#34;&gt;&lt;img src=&#34;https://secure.travis-ci.org/alpmestan/kmeans-vector.png?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can find examples in the &lt;code&gt;examples/&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;Feel free to contribute, may it be features, performance improvements, etc.&lt;/p&gt; &#xA;&lt;h2&gt;Performances (0.3 version)&lt;/h2&gt; &#xA;&lt;p&gt;The library has completely been rewritten and beats the 0.2 or the &lt;code&gt;kmeans-par&lt;/code&gt; package hands down. I also plan to work on an implementation of the &lt;em&gt;Streaming k-means&lt;/em&gt; technique soon, but that&#39;ll be for the next version.&lt;/p&gt; &#xA;&lt;p&gt;Note that this version also features some improvements in the usability.&lt;/p&gt; &#xA;&lt;h2&gt;Performances (0.2 version)&lt;/h2&gt; &#xA;&lt;p&gt;In addition to contributing a feature, Ville Tirronen also claimed to make the library about 50% faster, which was confirmed after running the algorithm on a dataset I had lying around.&lt;/p&gt; &#xA;&lt;h2&gt;Performances (0.1 version)&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;kmeans-vector&lt;/em&gt; is much faster than the existing &lt;a href=&#34;http://hackage.haskell.org/package/kmeans&#34;&gt;kmeans&lt;/a&gt; package. For example, the kmeans package performs k-means on 10000 2D points with k=5 in 21.099s while kmeans-vector does the same in 6.605s. For 50000 3D points, with k=5 still, kmeans-vector performs in 47.853s while I Ctrl+C&#39;d the kmeans version after 6 minutes and a half.&lt;/p&gt; &#xA;&lt;h2&gt;Authors&lt;/h2&gt; &#xA;&lt;p&gt;This library is written and maintained by Alp Mestanogullari, &lt;a href=&#34;mailto:alpmestan@gmail.com&#34;&gt;alpmestan@gmail.com&lt;/a&gt;. Ville Tirronen contributed code to the 0.2 version.&lt;/p&gt;</summary>
  </entry>
</feed>