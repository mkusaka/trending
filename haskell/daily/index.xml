<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-18T01:30:01Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>parsonsmatt/hotel-california</title>
    <updated>2023-09-18T01:30:01Z</updated>
    <id>tag:github.com,2023-09-18:/parsonsmatt/hotel-california</id>
    <link href="https://github.com/parsonsmatt/hotel-california" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A tool for OpenTelemetry tracing on the command line&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;hotel-california&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;hotel-california&lt;/code&gt; is inspired by &lt;a href=&#34;https://github.com/Pondidum/Trace/&#34;&gt;&lt;code&gt;Trace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://github.com/equinix-labs/otel-cli&#34;&gt;&lt;code&gt;otel-cli&lt;/code&gt;&lt;/a&gt;, a pair of utilities for tracing shell scripts. We needed something like this in order to instrument local builds, so we could understand how much time people are spending waiting on builds, tests, etc.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;The binary name is &lt;code&gt;hotel&lt;/code&gt;. Currently, the only supported command is &lt;code&gt;exec&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ hotel exec --help&#xA;Usage: hotel exec [-s|--span-name SPAN_NAME]&#xA;                  (COMMAND [ARGUMENT]... | --shell SCRIPT)&#xA;&#xA;  Execute the given command with tracing enabled&#xA;&#xA;Available options:&#xA;  -h,--help                Show this help text&#xA;  -s,--span-name SPAN_NAME The name of the span that the program reports. By&#xA;                           default, this is the script you pass in.&#xA;  --shell SCRIPT           Run an arbitrary shell script instead of running an&#xA;                           executable command&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Currently, the program only looks in environment variables for configuration.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;OTEL_EXPORTER_OTLP_ENDPOINT&lt;/code&gt; (with a default to &lt;code&gt;localhost:4317&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;OTEL_SERVICE_NAME&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;OTEL_EXPORTER_OTLP_HEADERS&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;OTEL_RESOURCE_ATTRIBUTES&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;and probably others, see &lt;a href=&#34;https://hackage.haskell.org/package/hs-opentelemetry-sdk&#34;&gt;&lt;code&gt;hs-opentelemetry-sdk&lt;/code&gt;&lt;/a&gt; for more information&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Background/FAQ&lt;/h1&gt; &#xA;&lt;h2&gt;Lol what&#39;s up with the name&lt;/h2&gt; &#xA;&lt;p&gt;Well &lt;code&gt;otel-cli&lt;/code&gt; is a great name for the tool. But this is a Haskell implementation, so I need an &lt;code&gt;h&lt;/code&gt; in there somewhere. &lt;code&gt;hotel-cli&lt;/code&gt; sounds good. But wait... &lt;code&gt;cli&lt;/code&gt; ... what else could I do with that? Ahah!&lt;/p&gt; &#xA;&lt;p&gt;Sorry&lt;/p&gt; &#xA;&lt;h2&gt;Difference from &lt;code&gt;Trace&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;Trace&lt;/code&gt; tool has the following basic workflow:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ TRACE_PARENT=$(trace start &#34;build&#34;)&#xA;$ make build&#xA;$ trace finish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you call &lt;code&gt;trace start &#34;trace-name&#34;&lt;/code&gt;, it generates a &lt;code&gt;TraceId&lt;/code&gt; and &lt;code&gt;SpanId&lt;/code&gt; and records that to a file in the temporary directory. The filename carries the trace ID and span ID. The file contains the name of the trace, the start time, and any other metadata you provide.&lt;/p&gt; &#xA;&lt;p&gt;When you call &lt;code&gt;trace finish&lt;/code&gt;, the tool looks for the &lt;code&gt;TRACE_PARENT&lt;/code&gt; environment variable. It then looks in the &lt;code&gt;$TMP/traces/state&lt;/code&gt; directory for a file that matches the &lt;code&gt;TRACE_PARENT&lt;/code&gt;. It loads the file, creates a &lt;code&gt;Span&lt;/code&gt; with the timestamp given in the file, and then calls &lt;code&gt;span.End&lt;/code&gt;. The tool then makes a network request to report this data.&lt;/p&gt; &#xA;&lt;h3&gt;The Problems&lt;/h3&gt; &#xA;&lt;h4&gt;Performance&lt;/h4&gt; &#xA;&lt;p&gt;The tool allows you to start groups and run commands that will make individual spans, allowing you to understand the overall trace. &lt;code&gt;trace group start&lt;/code&gt; is similar to &lt;code&gt;trace start&lt;/code&gt; - it creates a new Span ID, attaches it to the parent span, and writes that to the temporary directory. &lt;code&gt;trace task&lt;/code&gt; does something a bit more idiomatic - it creates a &lt;code&gt;Span&lt;/code&gt;, runs the command you provide, and then does &lt;code&gt;Span.end&lt;/code&gt;. &lt;code&gt;trace group finish&lt;/code&gt; is similar to &lt;code&gt;trace finish&lt;/code&gt; - it loads the parent span information for the group, creates a &lt;code&gt;Span&lt;/code&gt;, and calls &lt;code&gt;span.End&lt;/code&gt; with the timestamps loaded from the group.&lt;/p&gt; &#xA;&lt;p&gt;The toy example I did is here:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ TRACE_PARENT=$(trace start &#34;why&#34;); \&#xA;  GROUP=$(trace group start &#34;why-1&#34;); \&#xA;  trace task &#34;$GROUP&#34; -- go build; \&#xA;  trace group finish &#34;$GROUP&#34;; \&#xA;  trace finish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;According to Honeycomb, this spends 170ms doing &lt;code&gt;go build&lt;/code&gt;, and then incurs another 650ms to complete the entire process - the &lt;code&gt;why-1&lt;/code&gt; group takes roughly 370ms extra, and then the final &lt;code&gt;trace finish&lt;/code&gt; call adds another 300ms.&lt;/p&gt; &#xA;&lt;p&gt;This performance hit may not be substantial for the apparent intention of the tool - instrumenting CI builds - but it is going to be a problem for &lt;em&gt;my&lt;/em&gt; intention with the tool - instrumenting local developer workflows. 300ms is significant, but not terrible if incurred once. However, incurring that for each step we want to record? That&#39;s a problem.&lt;/p&gt; &#xA;&lt;p&gt;The out-of-the-box solution is to use an OpenTelemetry collector that is local to the machine, and can report the spans periodically, in the background. This is an extra deployment step, so it&#39;d be nice to avoid that, if possible.&lt;/p&gt; &#xA;&lt;h4&gt;Nesting&lt;/h4&gt; &#xA;&lt;p&gt;The API requires you to work in this manner:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ TRACE_PARENT=$(trace start &#34;my-trace&#34;)&#xA;$ OUTER_GROUP=$(trace group start &#34;neat&#34;)&#xA;$ INNER_GROUP=$(trace group start &#34;neat&#34; &#34;$OUTER_GROUP&#34;)&#xA;$ trace task &#34;$INNER_GROUP&#34; -- make build&#xA;$ trace group finish &#34;$INNER_GROUP&#34;&#xA;$ trace group finish &#34;$OUTER_GROUP&#34;&#xA;$ trace finish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So any time you do &lt;code&gt;trace start&lt;/code&gt;, you create an identifier for a parent span. But any time you do &lt;code&gt;trace group finish&lt;/code&gt;, you look up the relevant parent span ID and then actually &lt;em&gt;create&lt;/em&gt; a &lt;em&gt;child span&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This makes it difficult to create a span, and just &#34;know&#34; if you&#39;re in a root or not. You would need this in order to provide a composable interface: shell scripts calling other shell scripts which can all record spans.&lt;/p&gt; &#xA;&lt;h2&gt;Difference from &lt;code&gt;otel-cli&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Well, &lt;code&gt;otel-cli&lt;/code&gt; solves most of the above problems. The main entry point is &lt;code&gt;otel-cli exec&lt;/code&gt;, which runs a command for you, and reports a span for it. You can nest &lt;code&gt;otel-cli exec&lt;/code&gt; calls arbitrarily, which works nicely. However, it too had some issues, with the most challenging being a bug around signals. I simply couldn&#39;t figure out the behavior around signals in Golang, and all available internet advice wasn&#39;t exactly helpful. I decided then to spike out this tool.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cchuahuico/schell</title>
    <updated>2023-09-18T01:30:01Z</updated>
    <id>tag:github.com,2023-09-18:/cchuahuico/schell</id>
    <link href="https://github.com/cchuahuico/schell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Scheme interpreter written in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;schell&lt;/h1&gt; &#xA;&lt;p&gt;schell is an interpreter written in Haskell for a subset of the Scheme programming language. Special forms implemented include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;variable reference&lt;/li&gt; &#xA; &lt;li&gt;constant literal&lt;/li&gt; &#xA; &lt;li&gt;quotation&lt;/li&gt; &#xA; &lt;li&gt;conditional&lt;/li&gt; &#xA; &lt;li&gt;assignment&lt;/li&gt; &#xA; &lt;li&gt;definition&lt;/li&gt; &#xA; &lt;li&gt;let syntactic sugar&lt;/li&gt; &#xA; &lt;li&gt;procedure application&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;p&gt;Here is a Y Combinator for the factorial function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(define Y&#xA; (lambda (X)&#xA;  ((lambda (procedure)&#xA;     (X (lambda (arg) ((procedure procedure) arg))))&#xA;   (lambda (procedure)&#xA;     (X (lambda (arg) ((procedure procedure) arg)))))))&#xA;&#xA;(define F*&#xA; (lambda (func-arg)&#xA;  (lambda (n)&#xA;    (if (= n 0)&#xA;        1&#xA;        (* n (func-arg (- n 1)))))))&#xA;        &#xA;(define fact (Y F*))&#xA;(fact 10) ; 3628800&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An example of a closure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(define (make-counter)&#xA;  (let ((count 0))&#xA;    (lambda ()&#xA;      (set! count (+ count 1))&#xA;      count)))&#xA;&#xA;(define c (make-counter))&#xA;&#xA;(c) ; 1&#xA;(c) ; 2&#xA;(c) ; 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;There are two main ways to use the interpreter.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Invoking the executable directly from the shell will start the REPL&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;schell&amp;gt;&#xA;schell&amp;gt; (define var 5)&#xA;#&amp;lt;void&amp;gt;&#xA;schell&amp;gt; var&#xA;5&#xA;schell&amp;gt; :l /home/username/testfile.scm&#xA;#t&#xA;#&amp;lt;procedure&amp;gt;&#xA;&#34;hello&#34;&#xA;schell&amp;gt; :q&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Interpret a file passed as an argument to the executable&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;./schell /home/username/testfile.scm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;#t&#xA;#&amp;lt;procedure&amp;gt;&#xA;&#34;hello&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Build&lt;/h1&gt; &#xA;&lt;p&gt;To build the interpreter, run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal clean&#xA;cabal configure&#xA;cabal build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The executable can be found in &lt;code&gt;{PROJECTROOT}/dist/schell/schell&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Test&lt;/h1&gt; &#xA;&lt;p&gt;To run the tests, execute &lt;code&gt;./runtests.sh&lt;/code&gt;&lt;/p&gt;</summary>
  </entry>
</feed>