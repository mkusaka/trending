<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-23T01:30:20Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>qnikst/strictput</title>
    <updated>2023-12-23T01:30:20Z</updated>
    <id>tag:github.com,2023-12-23:/qnikst/strictput</id>
    <link href="https://github.com/qnikst/strictput" rel="alternate"></link>
    <summary type="html">&lt;p&gt;strict put serialization&lt;/p&gt;&lt;hr&gt;&lt;p&gt;This project is a StrictPut realiazation that may be usefull for serializing data structures to strict bytestring with known upper bound. This package uses highly unsafe methods that use no length check and operate raw pointers, but it can lead to performance growth.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>chrisdone/hell</title>
    <updated>2023-12-23T01:30:20Z</updated>
    <id>tag:github.com,2023-12-23:/chrisdone/hell</id>
    <link href="https://github.com/chrisdone/hell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell-based shell scripting language&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;hell&lt;/h1&gt; &#xA;&lt;p&gt;Welcome to Hell &lt;span&gt;ðŸ˜ˆ&lt;/span&gt;&lt;/p&gt; &#xA;&lt;!-- markdown-toc start - Don&#39;t edit this section. Run M-x markdown-toc-refresh-toc --&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chrisdone/hell/main/#hell&#34;&gt;hell&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chrisdone/hell/main/#description&#34;&gt;Description&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chrisdone/hell/main/#informal-description&#34;&gt;Informal description&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chrisdone/hell/main/#design-philosophy&#34;&gt;Design philosophy&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chrisdone/hell/main/#more-formal-description&#34;&gt;More formal description&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chrisdone/hell/main/#instructions&#34;&gt;Instructions&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chrisdone/hell/main/#running&#34;&gt;Running&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chrisdone/hell/main/#building&#34;&gt;Building&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chrisdone/hell/main/#performance&#34;&gt;Performance&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- markdown-toc end --&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;Hell is an interpreted, statically-typed, shell scripting language based on Haskell.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s a WIP.&lt;/p&gt; &#xA;&lt;h3&gt;Informal description&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;code&gt;examples/&lt;/code&gt; for a list of example scripts.&lt;/p&gt; &#xA;&lt;p&gt;Example program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;main = do&#xA;  Text.putStrLn &#34;Please enter your name and hit ENTER:&#34;&#xA;  name :: Text &amp;lt;- Text.getLine&#xA;  Text.putStrLn &#34;Thanks, your name is: &#34;&#xA;  Text.putStrLn name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Supports:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;UTF-8 and binary file I/O&lt;/li&gt; &#xA; &lt;li&gt;UTF-8 text operations (via &lt;code&gt;text&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Stdout/stderr/stdin I/O&lt;/li&gt; &#xA; &lt;li&gt;Directory, arguments, environment variables&lt;/li&gt; &#xA; &lt;li&gt;Concurrency (via &lt;code&gt;async&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Recursion (via &lt;code&gt;fix&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Running processes (via &lt;code&gt;typed-process&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Design philosophy&lt;/h3&gt; &#xA;&lt;p&gt;Turtle, Shelly, shell-conduit and Shh are &#34;do shell scripting in Haskell&#34;, but lack something. GHC is a large dependency to require for running scripts, and the Haskell ecosystem is not capable of the stability required. Scripts written in them are brittle and clunky.&lt;/p&gt; &#xA;&lt;p&gt;My definition of a shell scripting language:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A small interpreted language capable of launching processes&lt;/li&gt; &#xA; &lt;li&gt;No abstraction or re-use capabilities from other files/modules/packages&lt;/li&gt; &#xA; &lt;li&gt;Small, portable binary&lt;/li&gt; &#xA; &lt;li&gt;Stable, does not change in backwards-incompatible ways&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Hell can satisfy these criteria.&lt;/p&gt; &#xA;&lt;p&gt;The other point of view that I&#39;ve arrived at is that quotation like that of Bash and so on was never a good idea. I explored a Haskell that is quoted by default, such as &lt;code&gt;ls $(echo x)&lt;/code&gt;, and realised that this way leads to madness. What you write in a REPL and what you write in a script file &lt;em&gt;can&lt;/em&gt; be different.&lt;/p&gt; &#xA;&lt;p&gt;The other design decisions are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use existing Haskell naming convention, don&#39;t rename things for the sake of it. Even if the names Haskell chose aren&#39;t great, or are long.&lt;/li&gt; &#xA; &lt;li&gt;Lean on and re-use concepts in the host system, even if they&#39;re flawed. Haskell&#39;s standard libraries get a lot of things right, and some things wrong. But stick to the intuitions that already are there where possible.&lt;/li&gt; &#xA; &lt;li&gt;Don&#39;t break common shell understanding. Current directory and environment variables are process-wide, even if one would prefer otherwise. If you want &#34;local&#34; directories, carry a path around.&lt;/li&gt; &#xA; &lt;li&gt;Use established API patterns that already work. (In particular this applies to the process launching API, which &#34;script in Haskell&#34; always tend to re-invent. I&#39;m just re-using the API of typed-process.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Names mirror their equivalent Haskell names (typically the package). &lt;code&gt;Data.Text&lt;/code&gt; is &lt;code&gt;Text.*&lt;/code&gt;, &lt;code&gt;Control.Concurrent.Async&lt;/code&gt; is &lt;code&gt;async&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;p&gt;One exception to this rule is avoiding &lt;code&gt;type String&lt;/code&gt;. Sorry, it&#39;s hard to justify when &lt;code&gt;Text&lt;/code&gt; is established.&lt;/p&gt; &#xA;&lt;p&gt;Also, avoiding operators, because operators are a bit harder to deal with combined with type applications.&lt;/p&gt; &#xA;&lt;p&gt;There is only one monad, &lt;code&gt;IO&lt;/code&gt;. So all monadic actions are specialised upon it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;mapM&lt;/code&gt;/&lt;code&gt;forM&lt;/code&gt; are specialised on lists (like Haskell 98), and live under the &lt;code&gt;IO.&lt;/code&gt; namespace. In future, there could be &lt;code&gt;Maybe.mapM&lt;/code&gt;, etc. It&#39;s also possible to have &lt;code&gt;traverse @IO @[]&lt;/code&gt; type of thing, but that seems unnecessarily verbose. List is mostly fine, especially for scripting purposes.&lt;/p&gt; &#xA;&lt;h3&gt;More formal description&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The language is a simply-typed lambda calculus, with Haskell syntax.&lt;/li&gt; &#xA; &lt;li&gt;Some primitives that can be polymorphic (but require immediately applied type applications).&lt;/li&gt; &#xA; &lt;li&gt;Polymorphic primitives such as &lt;code&gt;id&lt;/code&gt; require passing the type of the argument as &lt;code&gt;id @Int 123&lt;/code&gt;. You cannot define polymorphic lambdas of your own. It&#39;s not full System-F.&lt;/li&gt; &#xA; &lt;li&gt;Recursion is not supported. Use &lt;code&gt;Function.fix&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Supports type-classes (&lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt; and &lt;code&gt;Show&lt;/code&gt; only), but the type must still be explicitly supplied. You can&#39;t define classes, or data types, of your own.&lt;/li&gt; &#xA; &lt;li&gt;The types and functions available lean directly on the host language (Haskell) and are either directly lifted, or a simplified layer over the original things.&lt;/li&gt; &#xA; &lt;li&gt;There is presently no type inference (but I will add it). All parameters of lambdas, or do-notation let bindings, must have their type declared via a pattern signature: &lt;code&gt;\(x :: Int) -&amp;gt; x&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Globals of any kind must be fully qualified (&lt;code&gt;Main.foo&lt;/code&gt; and &lt;code&gt;Text.putstrLn&lt;/code&gt;), including the current module.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Instructions&lt;/h2&gt; &#xA;&lt;h3&gt;Running&lt;/h3&gt; &#xA;&lt;p&gt;Presently the &lt;code&gt;hell&lt;/code&gt; binary type-checks and interprets immediately a program in &lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ hell examples/01-hello-world.hell&#xA;Hello, World!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/chrisdone/hell/releases&#34;&gt;https://github.com/chrisdone/hell/releases&lt;/a&gt; for a statically-linked amd64 Linux binary.&lt;/p&gt; &#xA;&lt;h3&gt;Building&lt;/h3&gt; &#xA;&lt;p&gt;Build statically for Linux in a musl distribution:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;stack build --ghc-options=&#34;-static -optl-static&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;I did a quick &lt;code&gt;fib&lt;/code&gt; test and it does fine compared with &lt;code&gt;runhaskell&lt;/code&gt;. There might be some undue strictness or something; I haven&#39;t looked deeply into it. What&#39;s important is that it&#39;s not dog slow, and it isn&#39;t.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Data.Function&#xA;import Data.Bool&#xA;main = print $ fib (30::Int)&#xA;&#xA;fib :: Int -&amp;gt; Int&#xA;fib = fix (\fib i -&amp;gt;&#xA;    bool&#xA;        (bool&#xA;           ( (fib (subtract 1 i))&#xA;            + (fib (subtract 2 i)))&#xA;          1&#xA;          (i == 1))&#xA;        0&#xA;        (i == 0)&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;main = do&#xA;  Text.putStrLn (Int.show (Main.fib 30))&#xA;&#xA;fib =&#xA;  Function.fix @(Int -&amp;gt; Int)&#xA;    (\(fib :: Int -&amp;gt; Int) -&amp;gt; \(i :: Int) -&amp;gt;&#xA;      Bool.bool @Int&#xA;        (Bool.bool @Int&#xA;           (Int.plus (fib (Int.subtract 1 i))&#xA;                     (fib (Int.subtract 2 i)))&#xA;           1&#xA;           (Int.eq i 1))&#xA;        0&#xA;        (Int.eq i 0)&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ GHCRTS=&#39;-s&#39; runhaskell test.hs&#xA;832040&#xA;     962,232,208 bytes allocated in the heap&#xA;      30,899,272 bytes copied during GC&#xA;       9,916,872 bytes maximum residency (4 sample(s))&#xA;         187,960 bytes maximum slop&#xA;              24 MiB total memory in use (0 MB lost due to fragmentation)&#xA;&#xA;                                     Tot time (elapsed)  Avg pause  Max pause&#xA;  Gen  0       109 colls,     0 par    0.022s   0.022s     0.0002s    0.0037s&#xA;  Gen  1         4 colls,     0 par    0.067s   0.067s     0.0168s    0.0216s&#xA;&#xA;  TASKS: 5 (1 bound, 4 peak workers (4 total), using -N1)&#xA;&#xA;  SPARKS: 0 (0 converted, 0 overflowed, 0 dud, 0 GC&#39;d, 0 fizzled)&#xA;&#xA;  INIT    time    0.001s  (  0.001s elapsed)&#xA;  MUT     time    3.758s  (  3.804s elapsed)&#xA;  GC      time    0.089s  (  0.089s elapsed)&#xA;  EXIT    time    0.001s  (  0.007s elapsed)&#xA;  Total   time    3.849s  (  3.900s elapsed)&#xA;&#xA;  Alloc rate    256,067,353 bytes per MUT second&#xA;&#xA;  Productivity  97.6% of total user, 97.5% of total elapsed&#xA;&#xA;$ stack run -- examples/12-fib.hell +RTS -s&#xA;832040&#xA;   1,892,556,080 bytes allocated in the heap&#xA;       1,588,368 bytes copied during GC&#xA;         150,208 bytes maximum residency (2 sample(s))&#xA;          87,360 bytes maximum slop&#xA;              41 MiB total memory in use (0 MB lost due to fragmentation)&#xA;&#xA;                                     Tot time (elapsed)  Avg pause  Max pause&#xA;  Gen  0       451 colls,   451 par    0.299s   0.158s     0.0004s    0.0006s&#xA;  Gen  1         2 colls,     1 par    0.001s   0.001s     0.0004s    0.0006s&#xA;&#xA;  Parallel GC work balance: 4.14% (serial 0%, perfect 100%)&#xA;&#xA;  TASKS: 18 (1 bound, 17 peak workers (17 total), using -N8)&#xA;&#xA;  SPARKS: 0 (0 converted, 0 overflowed, 0 dud, 0 GC&#39;d, 0 fizzled)&#xA;&#xA;  INIT    time    0.004s  (  0.002s elapsed)&#xA;  MUT     time    1.971s  (  1.588s elapsed)&#xA;  GC      time    0.300s  (  0.159s elapsed)&#xA;  EXIT    time    0.002s  (  0.001s elapsed)&#xA;  Total   time    2.278s  (  1.750s elapsed)&#xA;&#xA;  Alloc rate    960,062,184 bytes per MUT second&#xA;&#xA;  Productivity  86.5% of total user, 90.8% of total elapsed&#xA;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>