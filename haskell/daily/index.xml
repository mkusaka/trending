<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-31T01:32:41Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>plow-technologies/inferno</title>
    <updated>2022-12-31T01:32:41Z</updated>
    <id>tag:github.com,2022-12-31:/plow-technologies/inferno</id>
    <link href="https://github.com/plow-technologies/inferno" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A statically-typed functional scripting language&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/plow-technologies/inferno/main/misc/inferno.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2 align=&#34;center&#34;&gt;Infer, no?&lt;/h2&gt; &#xA;&lt;hr&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;This is the parser, type inference engine, and version control for a new functional scripting language.&lt;/p&gt; &#xA;&lt;p&gt;Specifically, the project comprises of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Parser for the new functional language&lt;/li&gt; &#xA; &lt;li&gt;Type checker/inference&lt;/li&gt; &#xA; &lt;li&gt;Evaluator&lt;/li&gt; &#xA; &lt;li&gt;Basic prelude&lt;/li&gt; &#xA; &lt;li&gt;A version control server to manage script histories and versions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Dev Setup&lt;/h2&gt; &#xA;&lt;p&gt;We currently only offer a Nix-based build system for building and developing &lt;code&gt;inferno&lt;/code&gt; packages. You can build the project components directly with Nix or enter a Nix-based development environment to build or work on the project with Cabal.&lt;/p&gt; &#xA;&lt;h3&gt;Nix prerequisites&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install Nix v2.8 or greater&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you don&#39;t have Nix installed, follow the directions &lt;a href=&#34;https://nixos.org/download.html&#34;&gt;here&lt;/a&gt;. This repository uses flakes, an up-and-coming Nix feature, and we recommend installing v2.8 or greater for the best compatibility.&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Enable required flakes settings&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Certain features that flakes require are still marked as experimental and must be explicitly enabled.&lt;/p&gt; &#xA;&lt;p&gt;On non-NixOS systems, edit &lt;code&gt;~/.config/nix/nix.conf&lt;/code&gt; or &lt;code&gt;/etc/nix/nix.conf&lt;/code&gt; and add the following lines:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;experimental-features = nix-command flakes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On NixOS, you can add the same line to &lt;code&gt;nix.extraOptions&lt;/code&gt; in your system configuration.&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Set up IOG&#39;s binary caches&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This project uses IOG&#39;s &lt;code&gt;haskell.nix&lt;/code&gt;; IOG provides binary caches which must be used in order to build this project. When you first run a &lt;code&gt;nix&lt;/code&gt; command in this repository, you will be prompted to allow certain configuration values to be set:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ nix develop&#xA;do you want to allow configuration setting &#39;extra-substituters&#39; to be set to &#39;https://cache.iog.io&#39; (y/N)? y&#xA;do you want to permanently mark this value as trusted (y/N)? y&#xA;do you want to allow configuration setting &#39;extra-trusted-public-keys&#39; to be set to &#39;hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=&#39; (y/N)? y&#xA;do you want to permanently mark this value as trusted (y/N)? y&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Accepting these prompts will set the required configuration values for you. Marking them as trusted will ensure that they are used for future &lt;code&gt;nix&lt;/code&gt; invocations in this repository.&lt;/p&gt; &#xA;&lt;p&gt;If you would prefer to configure the binary caches manually, you can do so by following the instructions &lt;a href=&#34;https://input-output-hk.github.io/haskell.nix/tutorials/getting-started.html#setting-up-the-binary-cache&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt;: If you do not enable the binary caches, you &lt;em&gt;will&lt;/em&gt; build GHC from source several times! If you find yourself building GHC despite having set the required configuration values (or allowed the flake to do so for you), something has gone wrong:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you set the cache values manually, make sure that you restarted the Nix daemon on non-NixOS systems&lt;/li&gt; &#xA; &lt;li&gt;If you accepted the prompts from the flake, you may not have permissions to set these values. Either set them manually in your system-wide configuration or continue reading below&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt;: If you are on NixOS or otherwise using a multi-user Nix install, you &lt;strong&gt;must&lt;/strong&gt; be a trusted user to set substituters. If you are not a trusted user, enabling the options prompted by the flake will have no effect (non-trusted users are disallowed from doing this).&lt;/p&gt; &#xA;&lt;p&gt;On non-NixOS systems, add the following to the system-wide configuration (&lt;code&gt;/etc/nix/nix.conf&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;trusted-users = &amp;lt;username&amp;gt; root&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use a group name by prefixing it with &lt;code&gt;@&lt;/code&gt;, e.g. to add all members of the &lt;code&gt;wheel&lt;/code&gt; group:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;trusted-users = @wheel root&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On NixOS, add the user/group name to the list under &lt;a href=&#34;https://search.nixos.org/options?show=nix.settings.trusted-users&#34;&gt;&lt;code&gt;nix.settings.trusted-users&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you do not wish to add yourself as a trusted user, you will need to configure the binary caches &lt;a href=&#34;https://input-output-hk.github.io/haskell.nix/tutorials/getting-started.html#setting-up-the-binary-cache&#34;&gt;manually&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Even after configuring IOG&#39;s binary caches, you will still need to build a large number of Haskell libraries as IOG does not cache these. Even if you are building dozens of Haskell libraries, this is not unusual.&lt;/p&gt; &#xA;&lt;h3&gt;Building or working on the project&lt;/h3&gt; &#xA;&lt;p&gt;Once you have completed the steps above, you can use the &lt;code&gt;nix&lt;/code&gt; command to build or work on the project.&lt;/p&gt; &#xA;&lt;h4&gt;Building/running components&lt;/h4&gt; &#xA;&lt;h5&gt;Executables&lt;/h5&gt; &#xA;&lt;p&gt;Use &lt;code&gt;nix build .#&amp;lt;PACKAGE&amp;gt;&lt;/code&gt; to build project components or executables. For example, to build &lt;code&gt;vscode-inferno-syntax-highlighting&lt;/code&gt;, run the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ nix build .#vscode-inferno-syntax-highlighting&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create a symlink in &lt;code&gt;$PWD/result&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ls -H ./result&#xA;inferno.monarch.json  vscode-inferno-syntax-highlighting-0.0.1.vsix&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;nix build&lt;/code&gt; by itself will build all components and run all tests.&lt;/p&gt; &#xA;&lt;h5&gt;Tests&lt;/h5&gt; &#xA;&lt;p&gt;To run tests for a particular project component, you can use &lt;code&gt;nix build -L .#checks.&amp;lt;SYSTEM&amp;gt;.&amp;lt;TEST&amp;gt;&lt;/code&gt; where &lt;code&gt;&amp;lt;SYSTEM&amp;gt;&lt;/code&gt; corresponds to your platform and OS (e.g. &lt;code&gt;x86_64-linux&lt;/code&gt;). All project tests are part of the &lt;code&gt;checks&lt;/code&gt; flake output.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ nix build -L .#checks.x86_64-linux.inferno-core:test:inferno-tests&#xA;inferno-core-test-inferno-tests&amp;gt; unpacking sources&#xA;inferno-core-test-inferno-tests&amp;gt; source root is inferno-src-root-inferno-core-test-inferno-tests-root&#xA;inferno-core-test-inferno-tests&amp;gt; patching sources&#xA;inferno-core-test-inferno-tests&amp;gt; configuring&#xA;inferno-core-test-inferno-tests&amp;gt; Configure flags:&#xA;# etc...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Do note that &lt;code&gt;nix flake check&lt;/code&gt;, a command which runs all &lt;code&gt;checks&lt;/code&gt; among other things, will not work; see &lt;a href=&#34;https://github.com/NixOS/nix/issues/4265&#34;&gt;here&lt;/a&gt; for more information.)&lt;/p&gt; &#xA;&lt;p&gt;To run &lt;em&gt;all&lt;/em&gt; tests and build all packages, build &lt;code&gt;packages.&amp;lt;SYSTEM&amp;gt;.default&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ nix build -L&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Running apps&lt;/h5&gt; &#xA;&lt;p&gt;To run an application directly via Nix, use &lt;code&gt;nix run .#&amp;lt;APP&amp;gt;&lt;/code&gt;, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ nix run .#inferno-lsp-server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is equivalent to the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ nix build .#inferno-lsp-server&#xA;$ ./result/bin/inferno-lsp-server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Entering a development environment&lt;/h4&gt; &#xA;&lt;p&gt;To enter a development environment suitable for working on the &lt;code&gt;inferno&lt;/code&gt; project itself, use &lt;code&gt;nix develop&lt;/code&gt;. &lt;code&gt;cabal&lt;/code&gt;, &lt;code&gt;haskell-language-server&lt;/code&gt;, and other development tools will be available in the shell.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ nix develop&#xA;$ cabal repl inferno-core&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Do note that building with Cabal directly outside of this Nix environment (that is, by installing the package set directly with a version of Cabal installed on your system) &lt;em&gt;will not work&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Formatting all sources&lt;/h4&gt; &#xA;&lt;p&gt;To format all of the Nix and Haskell sources, run &lt;code&gt;nix fmt&lt;/code&gt;. &lt;strong&gt;Note&lt;/strong&gt;: this command assumes that certain executables are available on the &lt;code&gt;PATH&lt;/code&gt;; please enter the development environment with &lt;code&gt;nix develop&lt;/code&gt; before trying to run the formatter.&lt;/p&gt; &#xA;&lt;p&gt;To run a formatting check that will fail if any files are not formatted, run &lt;code&gt;nix build -L .#check.&amp;lt;SYSTEM&amp;gt;.formatting&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Golden Files&lt;/h2&gt; &#xA;&lt;p&gt;The golden files for the exported frontend types currently live in &lt;code&gt;inferno-core/golden&lt;/code&gt;. This will likely change as all the exported types should ideally be defined in &lt;code&gt;inferno-types&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;From raw string to evaluated expression&lt;/h2&gt; &#xA;&lt;p&gt;The way we store and evaluate expressions in Inferno is now fairly involved and spanns several modules. Below is a high-level overview of how we go from a raw string to a fully evaluated expression:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;┌──────────────┐                   ┌──────────────────────┐&#xA;│              │                   │  Pinned modules      │&#xA;│  Raw string  │     ┌─────────────┤                      │&#xA;│              │     │             │  available in scope  │&#xA;└───────┬──────┘     │             └──┬───────┬────────┬──┘&#xA;        │            │                │       │        │&#xA;        ▼            ▼                │       │        │&#xA;┌─────────────────────────────┐       │       │        │&#xA;│  Parse (using fixity        │       │       │        │&#xA;│                             │       │       │        │&#xA;│  information from modules)  │       │       │        │&#xA;└────────────────────┬────────┘       │       │        │&#xA;                     │                │       │        │&#xA;                     ▼                ▼       │        │&#xA;                ┌──────────────────────────┐  │        │&#xA;                │  Pin all free variables  │  │        │&#xA;                │                          │  │        │&#xA;                │  and enums               │  │        │&#xA;                └─────────────────┬────────┘  │        │&#xA;                                  │           │        │&#xA;                                  ▼           ▼        │&#xA;                              ┌────────────────────┐   │&#xA;                              │  Typecheck pinned  │   │&#xA;                              │                    │   │&#xA;                              │  expression        │   │&#xA;                              └──────────┬─────────┘   │&#xA;                                         │             │&#xA;                                         ▼             ▼&#xA;                                       ┌───────────────────┐&#xA;                                       │  Evaluate pinned  │&#xA;                                       │                   │&#xA;                                       │  expression       │&#xA;                                       └───────────────────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parsing&lt;/h3&gt; &#xA;&lt;p&gt;The first step is parsing a raw string to an &lt;code&gt;Expr () SourcePos&lt;/code&gt; which is the type of an inferno AST. The first parameter &lt;code&gt;()&lt;/code&gt; will later be used for attaching a hash to every free variable inside the expression, as well as any operator or enum. The second parameter &lt;code&gt;SourcePos&lt;/code&gt; is used by the UI to display type information/completion hints and attaching parsing/typecheching error messages to the specific location.&lt;/p&gt; &#xA;&lt;p&gt;Internally, parsing is actually split into two steps, namely, we first parse the AST and comments separately and then use the &lt;code&gt;insertCommentsIntoExpr&lt;/code&gt; function to attach comments to the nearest logical block within the AST (this is not always optimal)&lt;/p&gt; &#xA;&lt;p&gt;When parsing, we can encounter blocks such as &lt;code&gt;open Foo in ...&lt;/code&gt;. When this happens, the parser looks up &lt;code&gt;Foo&lt;/code&gt; in it&#39;s environment and uses the &lt;code&gt;OpsTable&lt;/code&gt; for &lt;code&gt;Foo&lt;/code&gt; to bring any infix operators defined within &lt;code&gt;Foo&lt;/code&gt; into scope.&lt;/p&gt; &#xA;&lt;h3&gt;Pinning&lt;/h3&gt; &#xA;&lt;p&gt;To simplify the evaluation and certain operations on expressions stored in inferno&#39;s version control, an additional step between parsing and type-inferrence was introduced. The &lt;code&gt;pinExpr&lt;/code&gt; function is now used to resolve any free variables (i.e. ones not bound by a &lt;code&gt;fun&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;) to a hash. This hash is either stored in the version control for expressions which are kept under version control or it&#39;s a hash of one of the internal functions built into the prelude/builtin modules.&lt;/p&gt; &#xA;&lt;p&gt;Having this explicit step means the inference and evaluation are somewhat simplified, since we don&#39;t need to elaborately build the typechecking/evaluation environments, given the hashes (should be) are unique. Therefore, we can simply merge all the environments of the required modules into one without worrying about name shadowing/etc.&lt;/p&gt; &#xA;&lt;p&gt;However, the main advantage of this approach comes from the fact that we can keep track of all the direct dependencies of any expression directly in its AST. This greatly simplifies the evaluation of an AST already in the store, as this simply comprises of:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;computing the closure of the given expression, by recursively fetching all its direct dependencies from the VC store and in turn fetching their dependencies, until we hit the builtin prelude functions which are built into the evaluator.&lt;/li&gt; &#xA; &lt;li&gt;putting all the collected expressions into the evaluation env/context&lt;/li&gt; &#xA; &lt;li&gt;evaluating the expression&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Typechecking&lt;/h3&gt; &#xA;&lt;p&gt;Pretty stnadard, we simply collect all the hashes and the associated types for the modules in scope and then proceed with typechecking&lt;/p&gt; &#xA;&lt;h3&gt;Evaluation&lt;/h3&gt; &#xA;&lt;p&gt;As discusssed in the pinning section, evaluation is done on a fully typechecked and pinned &lt;code&gt;Expr&lt;/code&gt;ession.&lt;/p&gt;</summary>
  </entry>
</feed>