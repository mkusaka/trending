<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-04T01:28:58Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>JonasHoefer/poset-type-theory</title>
    <updated>2024-03-04T01:28:58Z</updated>
    <id>tag:github.com,2024-03-04:/JonasHoefer/poset-type-theory</id>
    <link href="https://github.com/JonasHoefer/poset-type-theory" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Experimental implementation of a Cubical Type Theory modeled by presheaves over posets&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Poset Type Theory&lt;/h1&gt; &#xA;&lt;p&gt;Experimental Haskell implementation of a version of cubical type theory with a model in presheaves over finite, non-empty posets. Some additional information can be found in the file located in &lt;a href=&#34;https://github.com/JonasHoefer/poset-type-theory/tree/main/doc&#34; title=&#34;Poset Type Theory â€” Documentation&#34;&gt;&lt;code&gt;./doc&lt;/code&gt;&lt;/a&gt;, a PDF version of which can be found &lt;a href=&#34;https://jonashoefer.github.io/poset-type-theory/poset.pdf&#34; title=&#34;Documentation PDF&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;The project is built using &lt;a href=&#34;https://www.haskell.org/cabal/&#34; title=&#34;Common Architecture for Building Applications and Libraries&#34;&gt;cabal&lt;/a&gt;. To install the type checker and evaluator, clone the repository and run &lt;code&gt;cabal install --overwrite-policy=alway&lt;/code&gt;. This will install an executable called &lt;code&gt;postt&lt;/code&gt; in &lt;code&gt;~/.cabal/bin/&lt;/code&gt; (and potentially remove old versions).&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;To see all options use &lt;code&gt;postt --help&lt;/code&gt;. To type check all definitions in a file, and evaluate the last one use &lt;code&gt;postt eval &amp;lt;path&amp;gt;&lt;/code&gt;. To start a read-eval-print-loop (repl) use &lt;code&gt;postt repl&lt;/code&gt;. In the repl, use &lt;code&gt;:help&lt;/code&gt; to see all available commands.&lt;/p&gt; &#xA;&lt;h2&gt;Versions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.haskell.org/ghc/&#34; title=&#34;The Glasgow Haskell Compiler&#34;&gt;ghc 9.4.8&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.haskell.org/cabal/&#34; title=&#34;Common Architecture for Building Applications and Libraries&#34;&gt;cabal 3.10.2.1&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>AndrasKovacs/flatparse</title>
    <updated>2024-03-04T01:28:58Z</updated>
    <id>tag:github.com,2024-03-04:/AndrasKovacs/flatparse</id>
    <link href="https://github.com/AndrasKovacs/flatparse" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fast parsing from bytestrings&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;flatparse&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/flatparse&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/flatparse.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/AndrasKovacs/flatparse/actions/workflows/haskell.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;flatparse&lt;/code&gt; is a high-performance parsing library, supporting parsing for &lt;strong&gt;programming languages&lt;/strong&gt;, &lt;strong&gt;human-readable data&lt;/strong&gt; and &lt;strong&gt;machine-readable data&lt;/strong&gt;. The &#34;flat&#34; in the name refers to the &lt;code&gt;ByteString&lt;/code&gt; parsing input, which has pinned contiguous data, and also to the library internals, which avoids indirections and heap allocations whenever possible. &lt;code&gt;flatparse&lt;/code&gt; is generally &lt;strong&gt;lower-level&lt;/strong&gt; than &lt;code&gt;parsec&lt;/code&gt;-style libraries, but it is possible to build higher-level features (such as source spans, hints, indentation parsing) on top of it, without making any compromises in performance.&lt;/p&gt; &#xA;&lt;h3&gt;LLVM&lt;/h3&gt; &#xA;&lt;p&gt;It is advised to build with &lt;a href=&#34;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/codegens.html#llvm-code-generator-fllvm&#34;&gt;&lt;code&gt;-fllvm&lt;/code&gt; option&lt;/a&gt; when using this package, since that can result in significant speedups (20-40% from what I&#39;ve seen). Additionally, you can enable &lt;code&gt;-fllvm&lt;/code&gt; for &lt;code&gt;flatparse&lt;/code&gt; specifically by enabling the &lt;code&gt;llvm&lt;/code&gt; package flag. However, this has minor impact, since almost all parser code will be typically inlined into modules outside &lt;code&gt;flatparse&lt;/code&gt;, and compiled there.&lt;/p&gt; &#xA;&lt;h2&gt;Features and non-features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Excellent performance&lt;/strong&gt;. On microbenchmarks, &lt;code&gt;flatparse&lt;/code&gt; is around 10 times faster than &lt;code&gt;attoparsec&lt;/code&gt; or &lt;code&gt;megaparsec&lt;/code&gt;. On larger examples with heavier use of source positions and spans and/or indentation parsing, the performance difference grows to 20-30 times. Compile times and executable sizes are also significantly better with &lt;code&gt;flatparse&lt;/code&gt; than with &lt;code&gt;megaparsec&lt;/code&gt; or &lt;code&gt;attoparsec&lt;/code&gt;. &lt;code&gt;flatparse&lt;/code&gt; internals make liberal use of unboxed tuples and GHC primops. As a result, pure validators (parsers returning &lt;code&gt;()&lt;/code&gt;) in &lt;code&gt;flatparse&lt;/code&gt; are not difficult to implement with zero heap allocation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;No incremental parsing&lt;/strong&gt;, and &lt;strong&gt;only strict &lt;code&gt;ByteString&lt;/code&gt;&lt;/strong&gt; is supported as input. However, it can be still useful to convert from &lt;code&gt;Text&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt; or other types to &lt;code&gt;ByteString&lt;/code&gt;, and then use &lt;code&gt;flatparse&lt;/code&gt; for parsing, since &lt;code&gt;flatparse&lt;/code&gt; performance usually more than makes up for the conversion costs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Only little-endian 64 bit systems are currently supported as the host machine&lt;/strong&gt;. This may change in the future. Getting good performance requires architecture-specific optimizations; I&#39;ve only considered the most common setting at this point. However, &lt;code&gt;flatparse&lt;/code&gt; does include primitive integer parsers with specific endianness.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Support for fast source location handling, indentation parsing and informative error messages&lt;/strong&gt;. &lt;code&gt;flatparse&lt;/code&gt; provides a low-level interface to these. Batteries are &lt;em&gt;not included&lt;/em&gt;, but it should be possible for users to build custom solutions, which are more sophisticated, but still as fast as possible. In my experience, the included batteries in other libraries often come with major unavoidable overheads, and often we still have to extend existing machinery in order to scale to production features.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;strong&gt;backtracking model&lt;/strong&gt; of &lt;code&gt;flatparse&lt;/code&gt; is different to parsec libraries, and is more close to the &lt;a href=&#34;https://github.com/Geal/nom&#34;&gt;nom&lt;/a&gt; library in Rust. The idea is that &lt;em&gt;parser failure&lt;/em&gt; is distinguished from &lt;em&gt;parsing error&lt;/em&gt;. The former is used for control flow, and we can backtrack from it. The latter is used for unrecoverable errors, and by default it&#39;s propagated to the top. &lt;code&gt;flatparse&lt;/code&gt; does not track whether parsers have consumed inputs. In my experience, what we really care about is the failure/error distinction, and in &lt;code&gt;parsec&lt;/code&gt; or &lt;code&gt;megaparsec&lt;/code&gt; the consumed/non-consumed separation is often muddled and discarded in larger parser implementations. By default, basic &lt;code&gt;flatparse&lt;/code&gt; parsers can fail but can not throw errors, with the exception of the specifically error-throwing operations. Hence, &lt;code&gt;flatparse&lt;/code&gt; users have to be mindful about grammar, and explicitly insert errors where it is known that the input can&#39;t be valid.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;flatparse&lt;/code&gt; comes in two flavors: &lt;a href=&#34;https://hackage.haskell.org/package/flatparse/docs/FlatParse-Basic.html&#34;&gt;&lt;code&gt;FlatParse.Basic&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://hackage.haskell.org/package/flatparse/docs/FlatParse-Stateful.html&#34;&gt;&lt;code&gt;FlatParse.Stateful&lt;/code&gt;&lt;/a&gt;. Both support a custom error type. Also, both come in three modes, where we can respectively run &lt;code&gt;IO&lt;/code&gt; actions, &lt;code&gt;ST&lt;/code&gt; actions, or no side effects. The modes are selected by a state token type parameter on the parser types.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/flatparse/docs/FlatParse-Basic.html&#34;&gt;&lt;code&gt;FlatParse.Basic&lt;/code&gt;&lt;/a&gt; only supports the above features. If you don&#39;t need indentation parsing, this is sufficient.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/flatparse/docs/FlatParse-Stateful.html&#34;&gt;&lt;code&gt;FlatParse.Stateful&lt;/code&gt;&lt;/a&gt; additionally supports a built-in &lt;code&gt;Int&lt;/code&gt; worth of internal state and an additional custom reader environment. This can support a wide range of indentation parsing features. There is a slight overhead in performance and code size compared to &lt;code&gt;Basic&lt;/code&gt;. However, in small parsers and microbenchmarks the difference between &lt;code&gt;Basic&lt;/code&gt; and &lt;code&gt;Stateful&lt;/code&gt; is often reduced to near zero by GHC and/or LLVM optimization.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Tutorial&lt;/h2&gt; &#xA;&lt;p&gt;Informative tutorials are work in progress. See &lt;a href=&#34;https://raw.githubusercontent.com/AndrasKovacs/flatparse/main/src/FlatParse/Examples&#34;&gt;&lt;code&gt;src/FlatParse/Examples&lt;/code&gt;&lt;/a&gt; for a lexer/parser example with acceptably good error messages.&lt;/p&gt; &#xA;&lt;h2&gt;Contribution&lt;/h2&gt; &#xA;&lt;p&gt;Pull requests are welcome. I&#39;m fairly quick to add PR authors as collaborators.&lt;/p&gt; &#xA;&lt;h2&gt;Some benchmarks&lt;/h2&gt; &#xA;&lt;p&gt;Execution times below. See source code in &lt;a href=&#34;https://raw.githubusercontent.com/AndrasKovacs/flatparse/main/bench&#34;&gt;bench&lt;/a&gt;. Compiled with GHC 9.4.4 &lt;code&gt;-O2 -fllvm&lt;/code&gt;. Executed on Intel 1165G7 CPU at 28W power draw. Uses &lt;code&gt;nightly-2023-02-06&lt;/code&gt; Stackage snapshot for the involved packages.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;benchmark&lt;/th&gt; &#xA;   &lt;th&gt;runtime&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;sexp/fpbasic&lt;/td&gt; &#xA;   &lt;td&gt;1.93 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;sexp/fpstateful&lt;/td&gt; &#xA;   &lt;td&gt;2.00 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;sexp/attoparsec&lt;/td&gt; &#xA;   &lt;td&gt;21.82 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;sexp/megaparsec&lt;/td&gt; &#xA;   &lt;td&gt;59.60 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;sexp/parsec&lt;/td&gt; &#xA;   &lt;td&gt;79.81 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;long keyword/fpbasic&lt;/td&gt; &#xA;   &lt;td&gt;0.1 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;long keyword/fpstateful&lt;/td&gt; &#xA;   &lt;td&gt;0.1 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;long keyword/attoparsec&lt;/td&gt; &#xA;   &lt;td&gt;2.43 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;long keyword/megaparsec&lt;/td&gt; &#xA;   &lt;td&gt;5.2 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;long keyword/parsec&lt;/td&gt; &#xA;   &lt;td&gt;10.02 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;numeral csv/fpbasic&lt;/td&gt; &#xA;   &lt;td&gt;0.72 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;numeral csv/fpstateful&lt;/td&gt; &#xA;   &lt;td&gt;0.56 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;numeral csv/attoparsec&lt;/td&gt; &#xA;   &lt;td&gt;10.52 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;numeral csv/megaparsec&lt;/td&gt; &#xA;   &lt;td&gt;19.77 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;numeral csv/parsec&lt;/td&gt; &#xA;   &lt;td&gt;26.46 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Object file sizes for each module containing the &lt;code&gt;s-exp&lt;/code&gt;, &lt;code&gt;long keyword&lt;/code&gt; and &lt;code&gt;numeral csv&lt;/code&gt; benchmarks.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;library&lt;/th&gt; &#xA;   &lt;th&gt;object file size (bytes)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;fpbasic&lt;/td&gt; &#xA;   &lt;td&gt;20656&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;fpstateful&lt;/td&gt; &#xA;   &lt;td&gt;26664&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;attoparsec&lt;/td&gt; &#xA;   &lt;td&gt;69384&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;megaparsec&lt;/td&gt; &#xA;   &lt;td&gt;226232&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;parsec&lt;/td&gt; &#xA;   &lt;td&gt;117696&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
</feed>