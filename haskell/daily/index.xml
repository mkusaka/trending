<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-19T01:42:52Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sgraf812/foldr-build</title>
    <updated>2022-06-19T01:42:52Z</updated>
    <id>tag:github.com,2022-06-19:/sgraf812/foldr-build</id>
    <link href="https://github.com/sgraf812/foldr-build" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A foldr/build fusion library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Foldr-build&lt;/h1&gt; &#xA;&lt;p&gt;Long-term goal: Deprecation of list fusion by exposing the underlying foldr/build streaming library (with functions such as &lt;a href=&#34;https://hackage.haskell.org/package/base-4.16.1.0/docs/src/GHC-Base.html#mapFB&#34;&gt;&lt;code&gt;mapFB&lt;/code&gt;&lt;/a&gt;) in &lt;code&gt;base&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Why would we do that?&lt;/h2&gt; &#xA;&lt;p&gt;People rely on list fusion in their programs. I think they shouldn&#39;t, because it&#39;s pretty brittle across modules.&lt;/p&gt; &#xA;&lt;p&gt;Consider&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;main = print $ sum [0..2022::Int]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you look at the simplified Core (&lt;code&gt;-O -ddump-simpl&lt;/code&gt;), you&#39;ll see that the list pipeline &lt;code&gt;sum [0..2022::Int]&lt;/code&gt; optimises to a tight non-allocating loop &lt;code&gt;Int# -&amp;gt; Int#&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Rec {&#xA;-- RHS size: {terms: 23, types: 14, coercions: 0, joins: 0/0}&#xA;Main.$wgo9 [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]&#xA;  :: GHC.Prim.Int# -&amp;gt; GHC.Prim.Int# -&amp;gt; String&#xA;[GblId, Arity=2, Str=&amp;lt;S,1*U&amp;gt;&amp;lt;L,U&amp;gt;, Unf=OtherCon []]&#xA;Main.$wgo9&#xA;  = \ (w_s2AZ :: GHC.Prim.Int#) (ww_s2B3 :: GHC.Prim.Int#) -&amp;gt;&#xA;      case w_s2AZ of wild_X1E {&#xA;        __DEFAULT -&amp;gt;&#xA;          Main.$wgo9&#xA;            (GHC.Prim.+# wild_X1E 1#) (GHC.Prim.+# ww_s2B3 wild_X1E);&#xA;        2022# -&amp;gt;&#xA;          case GHC.Show.$witos&#xA;                 (GHC.Prim.+# ww_s2B3 2022#) (GHC.Types.[] @Char)&#xA;          of&#xA;          { (# ww2_a1Uu, ww3_a1Uv #) -&amp;gt;&#xA;          GHC.Types.: @Char ww2_a1Uu ww3_a1Uv&#xA;          }&#xA;      }&#xA;end Rec }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Great!&lt;/p&gt; &#xA;&lt;p&gt;Here is a pretty easy ways to break it: Put the producer in a different module.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;module Producer where&#xA;&#xA;source :: [Int]&#xA;source = [0..2022]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;import Producer&#xA;&#xA;main = print $ sum source&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now GHC hesitates to fuse the consumer &lt;code&gt;sum&lt;/code&gt; with the producer &lt;code&gt;source&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Rec {&#xA;-- RHS size: {terms: 22, types: 21, coercions: 0, joins: 0/0}&#xA;Main.$wgo1 [InlPrag=NOUSERINLINE[2], Occ=LoopBreaker]&#xA;  :: [Int] -&amp;gt; GHC.Prim.Int# -&amp;gt; String&#xA;[GblId, Arity=2, Str=&amp;lt;S,1*U&amp;gt;&amp;lt;L,U&amp;gt;, Unf=OtherCon []]&#xA;Main.$wgo1&#xA;  = \ (w_s2FN :: [Int]) (ww_s2FR :: GHC.Prim.Int#) -&amp;gt;&#xA;      case w_s2FN of {&#xA;        [] -&amp;gt;&#xA;          case GHC.Show.$witos ww_s2FR (GHC.Types.[] @Char) of&#xA;          { (# ww2_a1YJ, ww3_a1YK #) -&amp;gt;&#xA;          GHC.Types.: @Char ww2_a1YJ ww3_a1YK&#xA;          };&#xA;        : y_a1XI ys_a1XJ -&amp;gt;&#xA;          case y_a1XI of { GHC.Types.I# y1_a1Xx -&amp;gt;&#xA;          Main.$wgo1 ys_a1XJ (GHC.Prim.+# ww_s2FR y1_a1Xx)&#xA;          }&#xA;      }&#xA;end Rec }&#xA;...&#xA;Main.main2 = Main.$wgo1 source 0#&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Why is that?&lt;/strong&gt; It&#39;s because list fusion relies on intricate interplay of rewriting list expressions (in &#34;Phase 2&#34; of the Simplifier) to so-called &lt;em&gt;fusion helpers&lt;/em&gt; operating on a church encoding (like &lt;code&gt;mapFB&lt;/code&gt;) that enables fusion, and then converting the residual helpers back to list literals (in &#34;Phase 1&#34;). See the &lt;code&gt;Note [The rules for map]&lt;/code&gt; for the example of &lt;a href=&#34;https://hackage.haskell.org/package/base-4.16.1.0/docs/src/GHC-Base.html#mapFB&#34;&gt;&lt;code&gt;mapFB&lt;/code&gt;&lt;/a&gt;. By the time the unfolding (that we&#39;ll try to inline in the consumer module) is finalised, &lt;em&gt;we&#39;ll already have wirtten back to lists&lt;/em&gt;! There&#39;s no way to get the fusion-builder back, and thus we don&#39;t get to fuse in the consumer module.&lt;/p&gt; &#xA;&lt;h2&gt;What to do about it?&lt;/h2&gt; &#xA;&lt;p&gt;Simple: expose an API based purely on fusion helpers (combinators such as &lt;code&gt;mapFB&lt;/code&gt; working on the church encoding) for the performance-aware user. Provide explicit conversion functions to and from lists, perhaps through the &lt;code&gt;IsList&lt;/code&gt; type class. Also come up with a better name than &lt;code&gt;FoldrBuild&lt;/code&gt; or fusion helper; perhaps &lt;code&gt;Push&lt;/code&gt; (kudos to Andras Kovacz). Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;module Data.Stream.Push where&#xA;&#xA;newtype Stream a = Stream { unStream :: forall r. (a -&amp;gt; r -&amp;gt; r) -&amp;gt; r -&amp;gt; r }&#xA;&#xA;sumS :: Stream Int -&amp;gt; Int&#xA;sumS (Stream s) = s (+) 0&#xA;&#xA;enumFromToS :: Int -&amp;gt; Int -&amp;gt; Stream Int&#xA;enumFromToS from to = Stream (\k z -&amp;gt; foldr k z [from..to])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;module Producer where&#xA;&#xA;import Data.Stream.Push&#xA;&#xA;source :: Stream Int&#xA;source = enumFromToS 0 2022&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;module Main where&#xA;&#xA;import Data.Stream.Push&#xA;import Producer&#xA;&#xA;main = print $ sumS source&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and this optimises to the tight loop again!&lt;/p&gt; &#xA;&lt;p&gt;LET&#39;S DO THIS&lt;/p&gt; &#xA;&lt;h1&gt;FAQ&lt;/h1&gt; &#xA;&lt;h2&gt;Why not use INLINE pragmas? #1&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Using {-# INLINE source #-} does bring back the fusion-builder. And foldr/build fusion relies on inlining anyway; code similar to the second example could still fail to fuse if the source function would be too large to be automatically marked as inlinable. To be sure that fusion always happens you&#39;d need to add an INLINE pragma to all functions that could potentially fuse.&lt;/p&gt; &#xA; &lt;p&gt;So what is really the problem that this package addresses? When is it better than adding INLINE pragmas to every fusible function?&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Yes, foldr/build fusion relies on inlining. But as always, I want to let GHC churn away on my program without programmer intervention and omit INLINE pragmas unless I absolutely need them. With our current RULE-based approach, that simply doesn&#39;t work across modules, independent of the size of the list consumer/producer, because the default unfolding that we export is the RHS &lt;em&gt;after&lt;/em&gt; optimisation, when RULEs can no longer fire. For example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;module A where&#xA;&#xA;myMap :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&#xA;myMap f xs = build (\k z -&amp;gt; foldr (f . k) z xs)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;myMap&lt;/code&gt; may look like a good list producer/consumer. And it has a reasonably small RHS that the programmer might think &#34;GHC will be able to inline it at use sites&#34;. And clients might &lt;em&gt;think&lt;/em&gt; that &lt;code&gt;myMap&lt;/code&gt; will properly fuse in their modules.&lt;/p&gt; &#xA;&lt;p&gt;But that assumption is wrong! &lt;code&gt;myMap&lt;/code&gt; will never fuse across modules. Its unfolding has a local recursive &lt;code&gt;go&lt;/code&gt; function (I think). Nothing there will fuse, even if you inline it. This is a big problem!&lt;/p&gt; &#xA;&lt;p&gt;In the past I&#39;ve seen numerous non-fusing list functions inside base. This is the most recent example: &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/-/issues/21344&#34;&gt;https://gitlab.haskell.org/ghc/ghc/-/issues/21344&lt;/a&gt; In general, just have a look at the GHC issues labeled with fusion: &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/-/issues/?label_name%5B%5D=fusion&#34;&gt;https://gitlab.haskell.org/ghc/ghc/-/issues/?label_name%5B%5D=fusion&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you grep GHC&#39;s &lt;code&gt;git log&lt;/code&gt; for mentions of &lt;code&gt;fusion&lt;/code&gt; is also quite illuminating. One rather recent commit was &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/-/commit/e6585ca168ba55ca81a3e6c&#34;&gt;https://gitlab.haskell.org/ghc/ghc/-/commit/e6585ca168ba55ca81a3e6c&lt;/a&gt;. The commit claims to fix list fusion for &lt;code&gt;filterOut&lt;/code&gt; by defining &lt;code&gt;filterOut p = filter (not . p)&lt;/code&gt;, but it lacks an INLINE pragma! So I&#39;m not even sure if we fixed fusion here, because by the time &lt;code&gt;filterOut&lt;/code&gt;&#39;s unfolding is exported, &lt;code&gt;filter&lt;/code&gt; might well have been inlined or rewritten so that it &lt;em&gt;won&#39;t&lt;/em&gt; actually float anymore. (It might not because &lt;code&gt;filter&lt;/code&gt; isn&#39;t saturated, so it fuses &lt;em&gt;by coincidence&lt;/em&gt;. Haven&#39;t checked.)&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m not trying to bash the commit author here, I&#39;m just saying that it&#39;s a very real problem for competent programmers to forget to attach an INLINE, simply because we don&#39;t have all the intricacies of list fusion paged into our brains at all times.&lt;/p&gt; &#xA;&lt;p&gt;Why is lack of fusion in &lt;code&gt;filterOut&lt;/code&gt; so problematic? Because it means it destroys fusion for &lt;em&gt;all callees&lt;/em&gt;! Non-fusibility is infective, which means that even if some other data structure combinator makes use of &lt;code&gt;filterOut&lt;/code&gt; (perhaps one of GHC&#39;s &lt;code&gt;UniqFM&lt;/code&gt;s) and does everything correctly, including an INLINE pragma for its combinator, then fusion is still broken!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/ghc-lib-parser-9.2.3.20220527/docs/src/GHC.Types.Var.Env.html#mkVarEnv&#34;&gt;&lt;code&gt;mkVarEnv&lt;/code&gt;&lt;/a&gt; is a good example here. I don&#39;t think it fuses! But that&#39;s not due to the definition of &lt;code&gt;mkVarEnv&lt;/code&gt;, which is trivial (thus will be pre-inlined unconditionally), it&#39;s due to &lt;code&gt;listToUFM&lt;/code&gt; not fusing, because it&#39;s not marked as &lt;code&gt;INLINE&lt;/code&gt; and has a non-trivial RHS that calls &lt;code&gt;foldl&#39;&lt;/code&gt;. It &lt;em&gt;could&lt;/em&gt; fuse, but it lacks an INLINE pragma to do so. Note that the RHS isn&#39;t particularly large and would no doubt be inlined, but the unfolding isn&#39;t useful to do fusion.&lt;/p&gt; &#xA;&lt;p&gt;By contrast, none of these issues apply to pure foldr/build streams, because they simply rely on beta reduction and the inliner with a RHS that had been optimised to an arbitrary degree, not on &#34;capture my RHS before phase 1 if you want to inline me to get fusion&#34;&lt;/p&gt; &#xA;&lt;p&gt;Was this convincing? Would you like to see some of these arguments in the README? Which one?&lt;/p&gt; &#xA;&lt;p&gt;Perhaps I should write a blog post about the issue.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>dataartisan/trees-algebra-haskell</title>
    <updated>2022-06-19T01:42:52Z</updated>
    <id>tag:github.com,2022-06-19:/dataartisan/trees-algebra-haskell</id>
    <link href="https://github.com/dataartisan/trees-algebra-haskell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;This example is based on chapter six of Richard Bird&#39;s Introduction to Functional Programming using Haskell (2nd ed.) and section two of Erik Meijer&#39;s banana paper.&lt;/p&gt; &#xA;&lt;p&gt;Please see the nat-algebra-haskell example for more information.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>GaloisInc/saw-script</title>
    <updated>2022-06-19T01:42:52Z</updated>
    <id>tag:github.com,2022-06-19:/GaloisInc/saw-script</id>
    <link href="https://github.com/GaloisInc/saw-script" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The SAW scripting language.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/GaloisInc/saw-script/actions?query=event%3Aschedule&#34;&gt;&lt;img src=&#34;https://github.com/GaloisInc/saw-script/workflows/Nightly%20Builds/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;SAWScript&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains the code for SAWScript, the scripting language that forms the primary user interface to the Software Analysis Workbench (SAW). It provides the ability to reason about formal models describing the denotation of programs written in languages such as C, Java, and Cryptol.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://saw.galois.com/tutorial.html&#34;&gt;SAWScript tutorial&lt;/a&gt; gives an introduction to using the SAWScript interpreter. A longer &lt;a href=&#34;https://github.com/GaloisInc/saw-script/raw/master/doc/manual/manual.md&#34;&gt;manual&lt;/a&gt; describes the breadth of SAWScript&#39;s features.&lt;/p&gt; &#xA;&lt;h2&gt;Precompiled Binaries&lt;/h2&gt; &#xA;&lt;p&gt;Precompiled SAWScript binaries for a variety of platforms are available on the &lt;a href=&#34;https://github.com/GaloisInc/saw-script/releases&#34;&gt;releases page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Z3&lt;/h2&gt; &#xA;&lt;p&gt;SAW can use many theorem provers, but because of its use of Cryptol it always needs to have Microsoft Research&#39;s &lt;a href=&#34;https://github.com/Z3Prover/z3&#34;&gt;Z3 SMT solver&lt;/a&gt; installed. You can download Z3 binaries for a variety of platforms from their &lt;a href=&#34;https://github.com/Z3Prover/z3/releases&#34;&gt;releases page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We currently recommend Z3 4.8.10. If you plan to use path satisfiability checking, you&#39;ll also need Yices version 2.6.1 or newer.&lt;/p&gt; &#xA;&lt;p&gt;After installation, make sure that &lt;code&gt;z3&lt;/code&gt; (or &lt;code&gt;z3.exe&lt;/code&gt; on Windows) is on your PATH.&lt;/p&gt; &#xA;&lt;h2&gt;Manual Installation&lt;/h2&gt; &#xA;&lt;p&gt;To build SAWScript and related utilities from source:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Ensure that you have the &lt;code&gt;cabal&lt;/code&gt; and &lt;code&gt;ghc&lt;/code&gt; executables in your &lt;code&gt;PATH&lt;/code&gt;. If you don&#39;t already have them, we recommend using &lt;code&gt;ghcup&lt;/code&gt; to install them: &lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;https://www.haskell.org/ghcup/&lt;/a&gt;. We recommend Cabal 3.4 or newer, and GHC 8.8, 8.10, or 9.0.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ensure that you have the C libraries and header files for &lt;code&gt;terminfo&lt;/code&gt;, which generally comes as part of &lt;code&gt;ncurses&lt;/code&gt; on most platforms. On Fedora, it is part of the &lt;code&gt;ncurses-compat-libs&lt;/code&gt; package. You will also need the C headers for &lt;code&gt;zlib&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ensure that you have the programs &lt;code&gt;javac&lt;/code&gt; and &lt;code&gt;z3&lt;/code&gt; on your &lt;code&gt;PATH&lt;/code&gt;. Z3 binaries are available at &lt;a href=&#34;https://github.com/Z3Prover/z3/releases&#34;&gt;https://github.com/Z3Prover/z3/releases&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Optionally, put in place dependency version freeze files:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;ln -s cabal.&amp;lt;ghc version&amp;gt;.config cabal.project.freeze&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build SAWScript by running&lt;/p&gt; &lt;pre&gt;&lt;code&gt;./build.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The SAWScript executables will be available in the &lt;code&gt;bin&lt;/code&gt; directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Optionally, run ./stage.sh to create a binary tarball.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Notes on LLVM&lt;/h2&gt; &#xA;&lt;p&gt;SAW can analyze LLVM programs (usually derived from C, but potentially for other languages). The only tool strictly required for this is a compiler that can generate LLVM bitcode, such as &lt;code&gt;clang&lt;/code&gt;. However, having the full LLVM tool suite available can be useful. We have tested SAW with LLVM and &lt;code&gt;clang&lt;/code&gt; versions from 3.5 to 12.0, as well as the version of &lt;code&gt;clang&lt;/code&gt; bundled with Apple Xcode. We welcome bug reports on any failure to parse bitcode from LLVM versions in that range.&lt;/p&gt; &#xA;&lt;p&gt;Note that successful parsing doesn&#39;t necessarily mean that verification will be possible for all language constructs. There are various instructions that are not supported during verification. However, any failure during &lt;code&gt;llvm_load_module&lt;/code&gt; should be considered a bug.&lt;/p&gt; &#xA;&lt;h2&gt;Notes on Windows&lt;/h2&gt; &#xA;&lt;p&gt;If you have trouble loading the SAW REPL on Windows, try invoking it with the &lt;code&gt;--no-color&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;h2&gt;Related Packages&lt;/h2&gt; &#xA;&lt;p&gt;Many dependencies are automatically downloaded into &lt;code&gt;deps/&lt;/code&gt; when you build using &lt;code&gt;build.sh&lt;/code&gt;; see &lt;a href=&#34;https://raw.githubusercontent.com/GaloisInc/saw-script/master/#manual-installation&#34;&gt;Manual Installation&lt;/a&gt; above. Key automatically downloaded dependencies include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;deps/crucible/&lt;/code&gt;: &lt;a href=&#34;https://github.com/GaloisInc/crucible&#34;&gt;Crucible symbolic execution engine&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;deps/cryptol/&lt;/code&gt;: &lt;a href=&#34;https://github.com/GaloisInc/cryptol&#34;&gt;Cryptol&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;For SAW developers&lt;/h2&gt; &#xA;&lt;p&gt;Presently, the &lt;code&gt;saw-script&lt;/code&gt; main executable cannot be loaded into GHCi due to a linker issue. However, the rest of the library can be manipulated in GHCi, with a little convincing.&lt;/p&gt; &#xA;&lt;p&gt;If you are using &lt;code&gt;cabal&lt;/code&gt; to build, select the &lt;code&gt;saw-script&lt;/code&gt; target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal new-repl saw-script&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to use interactive tools like &lt;code&gt;intero&lt;/code&gt;, you need to configure them with this target. You can configure &lt;code&gt;intero-mode&lt;/code&gt; in Emacs to use the &lt;code&gt;saw-script&lt;/code&gt; library target by setting the variable &lt;code&gt;intero-targets&lt;/code&gt; to the string &lt;code&gt;&#34;saw-script:lib&#34;&lt;/code&gt;. To make this setting persistent for all files in this project, place the following snippet in the file &lt;code&gt;src/.dir-locals.el&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;((haskell-mode&#xA;  (intero-targets &#34;saw-script:lib&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Notes on Freeze Files&lt;/h2&gt; &#xA;&lt;p&gt;We use the &lt;code&gt;cabal.GHC-*.config&lt;/code&gt; files to constrain dependency versions in CI, and recommend using the following command for best results before building locally:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ln -s cabal.GHC-&amp;lt;VER&amp;gt;.config cabal.project.freeze&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These configuration files were generated using &lt;code&gt;cabal freeze&lt;/code&gt;, but with some manual changes to allow cross-platfom builds, since Unix-like systems and Windows systems end up with different package dependencies. Specifically, we remove lines for the following packages or flags:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryptol-saw-core&#xA;regex-posix&#xA;saw-remote-api&#xA;saw-script&#xA;tasty +unix&#xA;unix&#xA;unix-compat&#xA;unix-time&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;Much of the work on SAW has been funded by, and lots of design input was provided by the team at the &lt;a href=&#34;https://www.nsa.gov/Research/NSA-Mission-Oriented-Research/LAC/&#34;&gt;NSA&#39;s Laboratory for Advanced Cybersecurity Research&lt;/a&gt;, including Brad Martin, Frank Taylor, and Sean Weaver.&lt;/p&gt; &#xA;&lt;p&gt;Portions of SAW are also based upon work supported by the Office of Naval Research under Contract No. N68335-17-C-0452. Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the Office of Naval Research.&lt;/p&gt;</summary>
  </entry>
</feed>