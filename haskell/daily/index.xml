<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-17T01:35:45Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>marcosh/crem</title>
    <updated>2023-04-17T01:35:45Z</updated>
    <id>tag:github.com,2023-04-17:/marcosh/crem</id>
    <link href="https://github.com/marcosh/crem" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Compositional Representable Executable Machines&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;https://github.com/tweag/crem&#34;&gt;crem&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tweag/crem/main/logo/crem-transparent.png&#34; width=&#34;200&#34;&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/tweag/crem/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI status&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;crem&lt;/code&gt; stands for &lt;strong&gt;c&lt;/strong&gt;ompositional &lt;strong&gt;r&lt;/strong&gt;epresentable &lt;strong&gt;e&lt;/strong&gt;xecutable &lt;strong&gt;m&lt;/strong&gt;achines.&lt;/p&gt; &#xA;&lt;p&gt;It allows defining state machines (Mealy machines in fact), composing them to build bigger machines out of smaller ones and then running them and drawing their flow and their state space.&lt;/p&gt; &#xA;&lt;h2&gt;What can you do with &lt;code&gt;crem&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;Defining state machines&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;crem&lt;/code&gt; allows you to define state machines so that you can enforce which state transitions are actually allowed by your machine.&lt;/p&gt; &#xA;&lt;p&gt;If you try to implement a machine by running a transition which is not allowed, you will get a compilation error.&lt;/p&gt; &#xA;&lt;p&gt;More details on how to define a machine at &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/docs/how-to-create-a-machine.md&#34;&gt;How to create a machine&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Composing state machines&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;crem&lt;/code&gt; allows you to compose machines together to build more complex ones, proving a compositional language to implement state machines.&lt;/p&gt; &#xA;&lt;p&gt;More details on how to compose machines at &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/docs/how-to-compose-machines.md&#34;&gt;How to compose machines&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Rendering a state machine&lt;/h3&gt; &#xA;&lt;p&gt;Thanks to the information on the allowed transitions &lt;code&gt;crem&lt;/code&gt; collects when you define a machine, it is able to produce a graphical representation of the flow and the state space of your machine.&lt;/p&gt; &#xA;&lt;p&gt;One example of such an output is&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://mermaid.ink/svg/pako:eNqlVF1PwjAU_SvkPmkyCGCBbQ8mCvqkxkj0wSwhzXad1a4lXUdAsv9u9-HcCMgMfepOz73n3PbubsGXAYILsaYaZ4yGikbd1dATHbNysEPDUGGY7bYFnK0KXDzIGdX0BZXG9b7zqeQcfY3Bc4yqJfVOUjFDTRmPb5mK9eGQJ_SRrTCYKgyYvk4U0iQTORJWKV1x_renenmdbvfyxMqa1EMJ29ffLvGpt7TfzyH3R--0hZ1_5E7rzbqUnPmbeqcWyOLsvMH-bepMqOAUJ2WGhn5DQckPY4VJ0VCp0MWciZDjYwXs8bqjXlHrOpEvhU91XaSEdmupOcrSlSywIEIVURaY3ztP4oF-xwg9cM02oOrTA0-khpcsA6N4Y95CKnDfKI_RAppoOd8IH1ytEvwhlSOiYi2peJWy8Q3uFtbgkv6oN7ZtZ0xscjEZWbABdziY9IjjODaZkMFw0HdIasFXHt_vGQrmFu6LkZRPpvQbS36R_g&#34; alt=&#34;risk manager flow&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;More details on how to render a machine at &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/docs/how-to-render-a-machine.md&#34;&gt;How to render a machine&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Running a machine&lt;/h3&gt; &#xA;&lt;p&gt;Last but not the least, you can also execute a machine, providing inputs to it and receiving the emitted outputs.&lt;/p&gt; &#xA;&lt;p&gt;More details on how to run a machine at &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/docs/how-to-run-a-machine.md&#34;&gt;How to run a machine&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Want to know more?&lt;/h3&gt; &#xA;&lt;p&gt;Further documentation can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/docs&#34;&gt;docs&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/examples&#34;&gt;examples&lt;/a&gt; folder contains a lot of examples, from simple machines to complex ones describing entire workflows.&lt;/p&gt; &#xA;&lt;p&gt;I would recommend to check:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/examples/Crem/Example/TwoSwitchesGate.lhs&#34;&gt;TwoSwitchesGate.lhs&lt;/a&gt; if you want to see all the code which is needed to use the library with a quite detailed explanation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/examples/Crem/Example/RiskManager/&#34;&gt;RiskManager&lt;/a&gt; if you want to see how to use &lt;code&gt;crem&lt;/code&gt; to &lt;a href=&#34;http://marcosh.github.io/post/2021/10/27/ddd-state-machines.html&#34;&gt;model your domain using state machines&lt;/a&gt; following the ideas coming from Domain Driven Design.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/examples/Crem/Example/Uno.hs&#34;&gt;Uno.hs&lt;/a&gt; if you want to see how to structure a card game like &lt;a href=&#34;https://en.wikipedia.org/wiki/Uno_(card_game)&#34;&gt;Uno&lt;/a&gt;, with an implementation ported from &lt;a href=&#34;https://github.com/thinkbeforecoding/UnoCore/raw/solution/Uno/Game.fs&#34;&gt;UnoCore&lt;/a&gt; by &lt;a href=&#34;https://functional.cafe/@thinkb4coding@mastodon.social&#34;&gt;@thinkb4coding@mastodon.social&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Be sure to check out also the &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/spec&#34;&gt;spec&lt;/a&gt; folder, where all the tests of the application are included, to see in practice what you can do with &lt;code&gt;crem&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;This is a Haskell Cabal project that uses Nix for development. Nix is optional but recommended.&lt;/p&gt; &#xA;&lt;h3&gt;environment&lt;/h3&gt; &#xA;&lt;p&gt;A Nix shell is available with all the required tools. To enter the shell, issue&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# default GHC&#xA;nix develop&#xA;&#xA;# custom GHC&#xA;nix develop .#ghc90&#xA;nix develop .#ghc92&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, without flakes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# default GHC&#xA;nix-shell&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;GHC version&lt;/h3&gt; &#xA;&lt;p&gt;The project has a default GHC version that is specified in the flake. At the moment that version is 9.0, because the HLS plugin Wingman &lt;a href=&#34;https://github.com/haskell/haskell-language-server/issues/2971&#34;&gt;currently only builds up to this version&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is also possible to use other GHC versions to build the project and enter development shells. This allows us to easily test multiple versions.&lt;/p&gt; &#xA;&lt;h3&gt;Building&lt;/h3&gt; &#xA;&lt;p&gt;In a development shell, you can simply build the project with Cabal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cabal build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This provides us fast incremental builds, ease of debugging, etc.&lt;/p&gt; &#xA;&lt;p&gt;Inside the development shell, you can also use the commands&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# just build the project&#xA;build-watch&#xA;&#xA;# execute also the tests&#xA;test-watch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Haddock documentation&lt;/h3&gt; &#xA;&lt;p&gt;You can generate and see the [Haddock] documentation by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cabal haddock --open&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Code formatting&lt;/h3&gt; &#xA;&lt;p&gt;Code is formatted using &lt;a href=&#34;https://github.com/fourmolu/fourmolu&#34;&gt;fourmolu&lt;/a&gt; version 0.10.1.0.&lt;/p&gt; &#xA;&lt;h3&gt;Cabal flags&lt;/h3&gt; &#xA;&lt;p&gt;We have a &lt;code&gt;cabal&lt;/code&gt; flag called &lt;code&gt;errors&lt;/code&gt; which allows enabling &lt;code&gt;-Werror&lt;/code&gt;. It has a default of &lt;code&gt;False&lt;/code&gt;, so that warning are not turned into errors.&lt;/p&gt; &#xA;&lt;p&gt;In development and CI we use the flag &lt;code&gt;-f errors&lt;/code&gt; so that we can avoid any warning in the library code.&lt;/p&gt; &#xA;&lt;h3&gt;Changelog&lt;/h3&gt; &#xA;&lt;p&gt;All changes are tracked in the &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/CHANGELOG.md&#34;&gt;&lt;code&gt;Changelog&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Project setup&lt;/h2&gt; &#xA;&lt;p&gt;You can find more details on the project setup on &lt;a href=&#34;https://raw.githubusercontent.com/marcosh/crem/main/Setup.md&#34;&gt;Setup.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Known limitations&lt;/h2&gt; &#xA;&lt;p&gt;The project is still in its early stage and not everything is crafted to perfection.&lt;/p&gt; &#xA;&lt;p&gt;Some known limitations to the current state of the project are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;crem&lt;/code&gt; has not been tested on huge state machines. Compilation times might grow very rapidly.&lt;/li&gt; &#xA; &lt;li&gt;the topologies which &lt;code&gt;crem&lt;/code&gt; allows you to define need to be finite, and not particularly big, either. For example, it is not feasible to use &lt;code&gt;Int&lt;/code&gt; as the type of vertices for a topology.&lt;/li&gt; &#xA; &lt;li&gt;in its current state, the &lt;code&gt;StateMachine&lt;/code&gt; type is not extensible. It has a predefined set of constructors, but maybe there are more which make sense and are not present yet.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Moreover, for current bugs and feature requests, you can check the &lt;a href=&#34;https://github.com/tweag/crem/issues&#34;&gt;open issues&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/marcosh/crem/main/logo/tweag.png&#34; alt=&#34;tweag logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The initial development of &lt;code&gt;crem&lt;/code&gt; was funded by &lt;a href=&#34;https://www.tweag.io/&#34;&gt;Tweag&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributions&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are extremely welcome. If you have any idea on how to improve the library, its code or its documentation, feel free to open an &lt;a href=&#34;https://github.com/tweag/crem/issues&#34;&gt;issue&lt;/a&gt;, create a &lt;a href=&#34;https://github.com/tweag/crem/pulls&#34;&gt;pull request&lt;/a&gt;, or just contact directly one of the maintainers.&lt;/p&gt; &#xA;&lt;h2&gt;Logo&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;crem&lt;/code&gt; logo was kindly generated by &lt;a href=&#34;https://www.craiyon.com/&#34;&gt;craiyon&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;p&gt;If you want to know a bit more of &lt;code&gt;crem&lt;/code&gt; and some ideas behind it, here are some additional resources you can check out:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://marcosh.github.io/post/2021/10/27/ddd-state-machines.html&#34;&gt;Domain modelling with state machines&lt;/a&gt;, the first blog post where I started considering using composable state machines for DDD-like architectures.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=cvbOG1I6wrU&#34;&gt;Composable Haskell state machines with &lt;code&gt;crem&lt;/code&gt;&lt;/a&gt;, if you prefer a video introducing &lt;code&gt;crem&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackmd.io/@CJO5VbycTsyzjGBytbwezQ/rkJliIjRj#/&#34;&gt;State machines with &lt;code&gt;crem&lt;/code&gt;&lt;/a&gt; the slide deck used for the above presentation.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>