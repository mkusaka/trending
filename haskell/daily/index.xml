<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-29T01:29:41Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hansonkd/Crackle-Server</title>
    <updated>2024-02-29T01:29:41Z</updated>
    <id>tag:github.com,2024-02-29:/hansonkd/Crackle-Server</id>
    <link href="https://github.com/hansonkd/Crackle-Server" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Snap without lenses&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#Crackle Web Server&lt;/p&gt; &#xA;&lt;h2&gt;Purpose&lt;/h2&gt; &#xA;&lt;p&gt;The purpose of this webserver is to be based on snap but with a different &#34;plugin&#34; system. Snap&#39;s current plugin system is based snaplets. These snaplets are lensed based. This means when you write your application you have to create new lenses and then create a class instance if you wish to add automatic context to your application.&lt;/p&gt; &#xA;&lt;p&gt;For example... look at the generic application with basic snaplets added:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;data App = App&#xA;    { _heist       :: Snaplet (Heist App)&#xA;    , _foo         :: Snaplet Foo&#xA;    , _bar         :: Snaplet Bar&#xA;    , _companyName :: IORef B.ByteString&#xA;    }&#xA;&#xA;makeLenses &#39;&#39;App&#xA;&#xA;instance HasHeist App where&#xA;    heistLens = subSnaplet heist&#xA;    &#xA;appInit :: SnapletInit App App&#xA;appInit = makeSnaplet &#34;myapp&#34; &#34;My example application&#34; Nothing $ do&#xA;    hs &amp;lt;- nestSnaplet &#34;heist&#34; heist $ heistInit &#34;templates&#34;&#xA;    fs &amp;lt;- nestSnaplet &#34;foo&#34; foo $ fooInit&#xA;    bs &amp;lt;- nestSnaplet &#34;&#34; bar $ nameSnaplet &#34;newname&#34; $ barInit foo&#xA;    addRoutes [ (&#34;/hello&#34;, writeText &#34;hello world&#34;)&#xA;              , (&#34;/fooname&#34;, with foo namePage)&#xA;              , (&#34;/barname&#34;, with bar namePage)&#xA;              , (&#34;/company&#34;, companyHandler)&#xA;              ]&#xA;    wrapSite (&amp;lt;|&amp;gt; heistServe)&#xA;    ref &amp;lt;- liftIO $ newIORef &#34;fooCorp&#34;&#xA;    return $ App hs fs bs ref&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we referenced each snaplet twice in order to build our application. We also had to create an instance of HasHeist for App. If you nested this snaplet in another snaplet, you would have to define another instance of HasHeist for your parent snaplet. However, wouldn&#39;t it be nice to build an application like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;myApplication = (HeistShard :$: FooShard :$: BarShard)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it. No declaring new instances or manually nesting plugins. Now instead of using a lens to access the plugin, we just use a function that is predifined by the plugin.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;getHeist :: HasShard a HeistShard =&amp;gt; a -&amp;gt; HeistShard&#xA;..&#xA;getHeist myApplicaiton :: HeistShard&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Not only that, but our new groups of plugins are also plugins themselves. Due to our data structure, if we nest plugins we will not have to define new instances.&lt;/p&gt; &#xA;&lt;h2&gt;Examining main.hs&lt;/h2&gt; &#xA;&lt;p&gt;We start out by creating new datatypes for our plugin objects&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;data MainServer = MainServer | MainServerInit&#xA;    deriving (Show)&#xA;&#xA;data SubServer = SubServer | SubServerInit&#xA;    deriving (Show)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We want to make it convient for people to access SubServer (incase we ever want to put any information in it). So, we simply inherit from the class HasShard.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class HasShard a SubServer =&amp;gt; HasSubServer a where&#xA;    getSubServer :: a -&amp;gt; SubServer&#xA;&#xA;instance HasShard a SubServer =&amp;gt; HasSubServer a where&#xA;    getSubServer = getShard&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also make commands that we can run from the command line with our application&#39;s context. Note: This is in an IO monad and not a Snap Monad. So you do not have access to request objects and response objects&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;printConfigCommand :: (Show a, HasBase a, HasSubServer a) =&amp;gt; Command a&#xA;printConfigCommand = Command {&#xA;        name    = &#34;run&#34;,&#xA;        help    = Nothing,&#xA;        options = [],&#xA;        command = (\optDict -&amp;gt; do&#xA;                subserve &amp;lt;- asks getSubServer&#xA;                liftIO $ print subserve&#xA;            )&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We create a shard with an option URL prefix the routes, commands, and its configuration function&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;instance (Show b, HasBase b, HasSubServer b) =&amp;gt; Shard MainServer b where&#xA;    urlPrefix _   = Just &#34;/m&#34;&#xA;    routes    _   = [packView IndexView]&#xA;    commands  _   = [printConfigCommand]&#xA;    runConfig _ _ = MainServer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In Crackle, views are class instances.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;data IndexView = IndexView&#xA;instance HasSubServer b =&amp;gt; ShardView IndexView b where&#xA;    url        _ = &#34;/c&#34;&#xA;    runRequest _ = do&#xA;            appState &amp;lt;- asks getSubServer&#xA;            liftIO $ print $ appState&#xA;            writeBS &#34;HelloWorld!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create our second Shard&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;instance Shard SubServer b where&#xA;    urlPrefix _   = Nothing&#xA;    routes    _   = []&#xA;    commands  _   = []&#xA;    runConfig _ _ = SubServer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Glue together the rest of our application:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;myApplication :: (BaseApplication :$: (MainServer :$: SubServer) )&#xA;myApplication =  (BaseApplicationInit :$: (MainServerInit :$: SubServerInit))&#xA;&#xA;myConfig :: CrackleConfig&#xA;myConfig = M.fromList [(&#34;SOMECONFIG&#34;, &#34;OTHERCONFIG&#34;)]&#xA;&#xA;main :: IO ()&#xA;main = do&#xA;    let (app, commands) = initApplication myConfig myApplication &#xA;    (_, s) &amp;lt;- runCrackle (runCommands $ commands) app&#xA;    return ()&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>jerometerry/haskell</title>
    <updated>2024-02-29T01:29:41Z</updated>
    <id>tag:github.com,2024-02-29:/jerometerry/haskell</id>
    <link href="https://github.com/jerometerry/haskell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Sandbox for toying with Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;haskell&lt;/h1&gt; &#xA;&lt;p&gt;Sandbox for toying with Haskell&lt;/p&gt;</summary>
  </entry>
</feed>