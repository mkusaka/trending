<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-26T01:43:38Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>composewell/streamly</title>
    <updated>2022-06-26T01:43:38Z</updated>
    <id>tag:github.com,2022-06-26:/composewell/streamly</id>
    <link href="https://github.com/composewell/streamly" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Dataflow programming and declarative concurrency&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt;: Idiomatic Haskell with the Performance of C&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/composewell/streamly&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/composewell/gitter.svg?sanitize=true&#34; alt=&#34;Gitter chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/streamly&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/streamly.svg?style=flat&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Streamly is a Haskell library that provides the building blocks to build safe, scalable, modular and high performance software. Streamly offers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The type safety of Haskell.&lt;/li&gt; &#xA; &lt;li&gt;The performance of C programs.&lt;/li&gt; &#xA; &lt;li&gt;Powerful abstractions for structuring your code.&lt;/li&gt; &#xA; &lt;li&gt;Idiomatic functional programming.&lt;/li&gt; &#xA; &lt;li&gt;Declarative concurrency for the seamless use of multiprocessing hardware.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;About This Document&lt;/h2&gt; &#xA;&lt;p&gt;This guide introduces programming with &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt; using a few practical examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We will start with a simple program that &lt;a href=&#34;https://raw.githubusercontent.com/composewell/streamly/master/#modular-word-counting&#34;&gt;counts the number of words in a text&lt;/a&gt;. We will then transform this program into a &lt;a href=&#34;https://raw.githubusercontent.com/composewell/streamly/master/#concurrent-word-counting&#34;&gt;concurrent&lt;/a&gt; program that can efficiently use multiprocessing hardware.&lt;/li&gt; &#xA; &lt;li&gt;Next, we will create a &lt;a href=&#34;https://raw.githubusercontent.com/composewell/streamly/master/#a-concurrent-network-server&#34;&gt;concurrent network server&lt;/a&gt;. We then show how to write a network server that &lt;a href=&#34;https://raw.githubusercontent.com/composewell/streamly/master/#merging-incoming-streams&#34;&gt;merges multiple streams&lt;/a&gt; concurrently.&lt;/li&gt; &#xA; &lt;li&gt;Our third example shows how to list a directory tree concurrently, by reading &lt;a href=&#34;https://raw.githubusercontent.com/composewell/streamly/master/#listing-directories-recursivelyconcurrently&#34;&gt;multiple directories in parallel&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Finally, we will look at how to &lt;a href=&#34;https://raw.githubusercontent.com/composewell/streamly/master/#rate-limiting&#34;&gt;rate limit&lt;/a&gt; stream processing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The guide then looks at how Streamly achieves its &lt;a href=&#34;https://raw.githubusercontent.com/composewell/streamly/master/#performance&#34;&gt;performance&lt;/a&gt;. It &lt;a href=&#34;https://raw.githubusercontent.com/composewell/streamly/master/#notes&#34;&gt;concludes&lt;/a&gt; with a brief discussion about Streamly&#39;s design philosophy, and with suggestions for further reading.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Installing Streamly&lt;/h3&gt; &#xA;&lt;p&gt;If you wish to follow along with this guide, you will need to have &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt; installed.&lt;/p&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://raw.githubusercontent.com/composewell/streamly/master/docs/User/Tutorials/getting-started.md&#34;&gt;Getting Started With The Streamly Package&lt;/a&gt; guide for instructions on how to install &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you wish to run benchmarks, please be sure to build your application using the instructions in the &lt;a href=&#34;https://raw.githubusercontent.com/composewell/streamly/master/docs/User/HowTo/Compiling.md&#34;&gt;Build Guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;An overview of the types used in these examples&lt;/h3&gt; &#xA;&lt;p&gt;As an expository device, we have indicated the types at the intermediate stages of stream computations as comments in the examples below. The meaning of these types are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A &lt;code&gt;SerialT IO a&lt;/code&gt; is a serial stream of values of type &lt;code&gt;a&lt;/code&gt; in the IO Monad.&lt;/li&gt; &#xA; &lt;li&gt;An &lt;code&gt;AsyncT IO a&lt;/code&gt; is a concurrent (asynchronous) stream of values of type &lt;code&gt;a&lt;/code&gt; in the IO Monad.&lt;/li&gt; &#xA; &lt;li&gt;An &lt;code&gt;Unfold IO a b&lt;/code&gt; is a representation of a function that converts a seed value of type &lt;code&gt;a&lt;/code&gt; into a stream of values of type &lt;code&gt;b&lt;/code&gt; in the IO Monad.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;Fold IO a b&lt;/code&gt; is a representation of a function that converts a stream of type &lt;code&gt;a&lt;/code&gt; to a final accumulator of type &lt;code&gt;b&lt;/code&gt; in the IO Monad.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;A Note on Module Naming&lt;/h3&gt; &#xA;&lt;p&gt;Some of the examples below use modules from the &lt;code&gt;Internal&lt;/code&gt; Streamly package hierarchy. These are not really internal to the library. We classify &lt;code&gt;Streamly&lt;/code&gt; modules into two categories:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Released modules and APIs&lt;/em&gt;: These modules and APIs are stable. Significant changes to these modules and APIs will cause Streamly&#39;s version number to change according to the package versioning policy.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Pre-release modules and APIs&lt;/em&gt;: These modules and APIs have not been formally released yet. They may change in the near future, and such changes will not necessarily be reflected in Streamly&#39;s package version number. As yet unreleased modules and APIs reside in the &lt;code&gt;Internal&lt;/code&gt; namespace.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please use a minor release upper bound to adhere to the Haskell PVP when using the pre-release (internal) modules.&lt;/p&gt; &#xA;&lt;h2&gt;The Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Modular Word Counting&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;Fold&lt;/code&gt; in Streamly is a composable stream consumer. For our first example, we will use &lt;code&gt;Fold&lt;/code&gt;s to count the number of bytes, words and lines present in a file. We will then compose individual &lt;code&gt;Fold&lt;/code&gt;s together to count words, bytes and lines at the same time.&lt;/p&gt; &#xA;&lt;p&gt;Please see the file &lt;a href=&#34;https://github.com/composewell/streamly-examples/raw/master/examples/WordCountModular.hs&#34;&gt;WordCountModular.hs&lt;/a&gt; for the complete example program, including the imports that we have omitted here.&lt;/p&gt; &#xA;&lt;h4&gt;Count Bytes (wc -c)&lt;/h4&gt; &#xA;&lt;p&gt;We start with a code fragment that counts the number of bytes in a file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import qualified Streamly.Data.Fold as Fold&#xA;import qualified Streamly.Internal.FileSystem.File as File&#xA;import qualified Streamly.Prelude as Stream&#xA;&#xA;wcb :: String -&amp;gt; IO Int&#xA;wcb file =&#xA;    File.toBytes file        -- SerialT IO Word8&#xA;  &amp;amp; Stream.fold Fold.length  -- IO Int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Count Lines (wc -l)&lt;/h3&gt; &#xA;&lt;p&gt;The next code fragment shows how to count the number of lines in a file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- ASCII character 10 is a newline.&#xA;countl :: Int -&amp;gt; Word8 -&amp;gt; Int&#xA;countl n ch = if ch == 10 then n + 1 else n&#xA;&#xA;-- The fold accepts a stream of `Word8` and returns a line count (`Int`).&#xA;nlines :: Monad m =&amp;gt; Fold m Word8 Int&#xA;nlines = Fold.foldl&#39; countl 0&#xA;&#xA;wcl :: String -&amp;gt; IO Int&#xA;wcl file =&#xA;    File.toBytes file  -- SerialT IO Word8&#xA;  &amp;amp; Stream.fold nlines -- IO Int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Count Words (wc -w)&lt;/h3&gt; &#xA;&lt;p&gt;Our final code fragment counts the number of whitespace-separated words in a stream:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;countw :: (Int, Bool) -&amp;gt; Word8 -&amp;gt; (Int, Bool)&#xA;countw (n, wasSpace) ch =&#xA;    if isSpace $ chr $ fromIntegral ch&#xA;    then (n, True)&#xA;    else (if wasSpace then n + 1 else n, False)&#xA;&#xA;-- The fold accepts a stream of `Word8` and returns a word count (`Int`).&#xA;nwords :: Monad m =&amp;gt; Fold m Word8 Int&#xA;nwords = fst &amp;lt;$&amp;gt; Fold.foldl&#39; countw (0, True)&#xA;&#xA;wcw :: String -&amp;gt; IO Int&#xA;wcw file =&#xA;    File.toBytes file   -- SerialT IO Word8&#xA;  &amp;amp; Stream.fold nwords  -- IO Int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counting Bytes, Words and Lines Together&lt;/h3&gt; &#xA;&lt;p&gt;By using the &lt;code&gt;Tee&lt;/code&gt; combinator we can compose the three folds that count bytes, lines and words individually into a single fold that counts all three at once. The applicative instance of &lt;code&gt;Tee&lt;/code&gt; distributes its input to all the supplied folds (&lt;code&gt;Fold.length&lt;/code&gt;, &lt;code&gt;nlines&lt;/code&gt;, and &lt;code&gt;nwords&lt;/code&gt;) and then combines the outputs from the folds using the supplied combiner function (&lt;code&gt;(,,)&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import qualified Streamly.Internal.Data.Fold.Tee as Tee&#xA;&#xA;-- The fold accepts a stream of `Word8` and returns the three counts.&#xA;countAll :: Fold IO Word8 (Int, Int, Int)&#xA;countAll = Tee.toFold $ (,,) &amp;lt;$&amp;gt; Tee Fold.length &amp;lt;*&amp;gt; Tee nlines &amp;lt;*&amp;gt; Tee nwords&#xA;&#xA;wc :: String -&amp;gt; IO (Int, Int, Int)&#xA;wc file =&#xA;    File.toBytes file    -- SerialT IO Word8&#xA;  &amp;amp; Stream.fold countAll -- IO (Int, Int, Int)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This example demonstrates the excellent modularity offered by &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt;&#39;s simple and concise API. Experienced Haskellers will notice that we have not used bytestringsâ€”we instead used a stream of &lt;code&gt;Word8&lt;/code&gt; values, simplifying our program.&lt;/p&gt; &#xA;&lt;h3&gt;The Performance of Word Counting&lt;/h3&gt; &#xA;&lt;p&gt;We compare two equivalent implementations: one using &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt;, and the other using C.&lt;/p&gt; &#xA;&lt;p&gt;The performance of the &lt;a href=&#34;https://github.com/composewell/streamly-examples/raw/master/examples/WordCount.hs&#34;&gt;Streamly word counting implementation&lt;/a&gt; is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ time WordCount-hs gutenberg-500MB.txt&#xA;11242220 97050938 574714449 gutenberg-500MB.txt&#xA;&#xA;real    0m1.825s&#xA;user    0m1.697s&#xA;sys     0m0.128s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The performance of an equivalent &lt;a href=&#34;https://github.com/composewell/streamly-examples/raw/master/examples/WordCount.c&#34;&gt;wc implementation in C&lt;/a&gt; is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ time WordCount-c gutenberg-500MB.txt&#xA;11242220 97050938 574714449 gutenberg-500MB.txt&#xA;&#xA;real    0m2.100s&#xA;user    0m1.935s&#xA;sys     0m0.165s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Concurrent Word Counting&lt;/h3&gt; &#xA;&lt;p&gt;In our next example we show how the task of counting words, lines, and bytes could be done in parallel on multiprocessor hardware.&lt;/p&gt; &#xA;&lt;p&gt;To count words in parallel we first divide the stream into chunks (arrays), do the counting within each chunk, and then add all the counts across chunks. We use the same code as above except that we use arrays for our input data.&lt;/p&gt; &#xA;&lt;p&gt;Please see the file &lt;a href=&#34;https://github.com/composewell/streamly-examples/raw/master/examples/WordCountParallel.hs&#34;&gt;WordCountParallel.hs&lt;/a&gt; for the complete working code for this example, including the imports that we have omitted below.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;countArray&lt;/code&gt; function counts the line, word, char counts in one chunk:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import qualified Streamly.Data.Array.Foreign as Array&#xA;&#xA;countArray :: Array Word8 -&amp;gt; IO Counts&#xA;countArray arr =&#xA;      Stream.unfold Array.read arr            -- SerialT IO Word8&#xA;    &amp;amp; Stream.decodeLatin1                     -- SerialT IO Char&#xA;    &amp;amp; Stream.foldl&#39; count (Counts 0 0 0 True) -- IO Counts&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here the function &lt;code&gt;count&lt;/code&gt; and the &lt;code&gt;Counts&lt;/code&gt; data type are defined in the &lt;code&gt;WordCount&lt;/code&gt; helper module defined in &lt;a href=&#34;https://github.com/composewell/streamly-examples/raw/master/examples/WordCount.hs&#34;&gt;WordCount.hs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When combining the counts in two contiguous chunks, we need to check whether the first element of the next chunk is a whitespace character in order to determine if the same word continues in the next chunk or whether the chunk starts with a new word. The &lt;code&gt;partialCounts&lt;/code&gt; function adds a &lt;code&gt;Bool&lt;/code&gt; flag to &lt;code&gt;Counts&lt;/code&gt; returned by &lt;code&gt;countArray&lt;/code&gt; to indicate whether the first character in the chunk is a space.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;partialCounts :: Array Word8 -&amp;gt; IO (Bool, Counts)&#xA;partialCounts arr = do&#xA;    let r = Array.getIndex arr 0&#xA;    case r of&#xA;        Just x -&amp;gt; do&#xA;            counts &amp;lt;- countArray arr&#xA;            return (isSpace (chr (fromIntegral x)), counts)&#xA;        Nothing -&amp;gt; return (False, Counts 0 0 0 True)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;addCounts&lt;/code&gt; then adds the counts from two consecutive chunks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;addCounts :: (Bool, Counts) -&amp;gt; (Bool, Counts) -&amp;gt; (Bool, Counts)&#xA;addCounts (sp1, Counts l1 w1 c1 ws1) (sp2, Counts l2 w2 c2 ws2) =&#xA;    let wcount =&#xA;            if not ws1 &amp;amp;&amp;amp; not sp2 -- No space between two chunks.&#xA;            then w1 + w2 - 1&#xA;            else w1 + w2&#xA;     in (sp1, Counts (l1 + l2) wcount (c1 + c2) ws2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To count in parallel we now only need to divide the stream into arrays, apply our counting function to each array, and then combine the counts from each chunk.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;wc :: String -&amp;gt; IO (Bool, Counts)&#xA;wc file = do&#xA;      Stream.unfold File.readChunks file -- AheadT IO (Array Word8)&#xA;    &amp;amp; Stream.mapM partialCounts          -- AheadT IO (Bool, Counts)&#xA;    &amp;amp; Stream.maxThreads numCapabilities  -- AheadT IO (Bool, Counts)&#xA;    &amp;amp; Stream.fromAhead                   -- SerialT IO (Bool, Counts)&#xA;    &amp;amp; Stream.foldl&#39; addCounts (False, Counts 0 0 0 True) -- IO (Bool, Counts)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please note that the only difference between a concurrent and a non-concurrent program lies in the use of the &lt;code&gt;Stream.fromAhead&lt;/code&gt; combinator. If we remove the call to &lt;code&gt;Stream.fromAhead&lt;/code&gt;, we would still have a perfectly valid and performant serial program. Notice how succinctly and idiomatically we have expressed the concurrent word counting problem.&lt;/p&gt; &#xA;&lt;p&gt;A benchmark with 2 CPUs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ time WordCount-hs-parallel gutenberg-500MB.txt&#xA;11242220 97050938 574714449 gutenberg-500MB.txt&#xA;&#xA;real    0m1.284s&#xA;user    0m1.952s&#xA;sys     0m0.140s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These example programs have assumed ASCII encoded input data. For UTF-8 streams, we have a &lt;a href=&#34;https://github.com/composewell/streamly-examples/raw/master/examples/WordCountParallelUTF8.hs&#34;&gt;concurrent wc implementation&lt;/a&gt; with UTF-8 decoding. This concurrent implementation performs as well as the standard &lt;code&gt;wc&lt;/code&gt; program in serial benchmarks. In concurrent mode &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt;&#39;s implementation can utilise multiple processing cores if these are present, and can thereby run much faster than the standard binary.&lt;/p&gt; &#xA;&lt;p&gt;Streamly provides concurrency facilities similar to &lt;a href=&#34;https://en.wikipedia.org/wiki/OpenMP&#34;&gt;OpenMP&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Cilk&#34;&gt;Cilk&lt;/a&gt; but with a more declarative style of expression. With Streamly you can write concurrent programs with ease, with support for different types of concurrent scheduling.&lt;/p&gt; &#xA;&lt;h3&gt;A Concurrent Network Server&lt;/h3&gt; &#xA;&lt;p&gt;We now move to a slightly more complicated example: we simulate a dictionary lookup server which can serve word meanings to multiple clients concurrently. This example demonstrates the use of the concurrent &lt;code&gt;mapM&lt;/code&gt; combinator.&lt;/p&gt; &#xA;&lt;p&gt;Please see the file &lt;a href=&#34;https://github.com/composewell/streamly-examples/raw/master/examples/WordServer.hs&#34;&gt;WordServer.hs&lt;/a&gt; for the complete code for this example, including the imports that we have omitted below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import qualified Streamly.Data.Fold as Fold&#xA;import qualified Streamly.Network.Inet.TCP as TCP&#xA;import qualified Streamly.Network.Socket as Socket&#xA;import qualified Streamly.Unicode.Stream as Unicode&#xA;&#xA;-- Simulate network/db query by adding a delay.&#xA;fetch :: String -&amp;gt; IO (String, String)&#xA;fetch w = threadDelay 1000000 &amp;gt;&amp;gt; return (w,w)&#xA;&#xA;-- Read lines of whitespace separated list of words from a socket, fetch the&#xA;-- meanings of each word concurrently and return the meanings separated by&#xA;-- newlines, in same order as the words were received. Repeat until the&#xA;-- connection is closed.&#xA;lookupWords :: Socket -&amp;gt; IO ()&#xA;lookupWords sk =&#xA;      Stream.unfold Socket.read sk               -- SerialT IO Word8&#xA;    &amp;amp; Unicode.decodeLatin1                       -- SerialT IO Char&#xA;    &amp;amp; Stream.wordsBy isSpace Fold.toList         -- SerialT IO String&#xA;    &amp;amp; Stream.fromSerial                          -- AheadT  IO String&#xA;    &amp;amp; Stream.mapM fetch                          -- AheadT  IO (String, String)&#xA;    &amp;amp; Stream.fromAhead                           -- SerialT IO (String, String)&#xA;    &amp;amp; Stream.map show                            -- SerialT IO String&#xA;    &amp;amp; Stream.intersperse &#34;\n&#34;                    -- SerialT IO String&#xA;    &amp;amp; Unicode.encodeStrings Unicode.encodeLatin1 -- SerialT IO (Array Word8)&#xA;    &amp;amp; Stream.fold (Socket.writeChunks sk)        -- IO ()&#xA;&#xA;serve :: Socket -&amp;gt; IO ()&#xA;serve sk = finally (lookupWords sk) (close sk)&#xA;&#xA;-- | Run a server on port 8091. Accept and handle connections concurrently. The&#xA;-- connection handler is &#34;serve&#34; (i.e. lookupWords).  You can use &#34;telnet&#34; or&#xA;-- &#34;nc&#34; as a client to try it out.&#xA;main :: IO ()&#xA;main =&#xA;      Stream.unfold TCP.acceptOnPort 8091 -- SerialT IO Socket&#xA;    &amp;amp; Stream.fromSerial                   -- AsyncT IO ()&#xA;    &amp;amp; Stream.mapM serve                   -- AsyncT IO ()&#xA;    &amp;amp; Stream.fromAsync                    -- SerialT IO ()&#xA;    &amp;amp; Stream.drain                        -- IO ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Merging Incoming Streams&lt;/h3&gt; &#xA;&lt;p&gt;In the next example, we show how to merge logs coming from multiple nodes in your network. These logs are merged at line boundaries and the merged logs are written to a file or to a network destination. This example uses the &lt;code&gt;concatMapWith&lt;/code&gt; combinator to merge multiple streams concurrently.&lt;/p&gt; &#xA;&lt;p&gt;Please see the file &lt;a href=&#34;https://github.com/composewell/streamly-examples/raw/master/examples/MergeServer.hs&#34;&gt;MergeServer.hs&lt;/a&gt; for the complete working code, including the imports that we have omitted below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import qualified Streamly.Data.Unfold as Unfold&#xA;import qualified Streamly.Network.Socket as Socket&#xA;&#xA;-- | Read a line stream from a socket.&#xA;-- Note: lines are buffered, and we could add a limit to the&#xA;-- buffering for safety.&#xA;readLines :: Socket -&amp;gt; SerialT IO (Array Char)&#xA;readLines sk =&#xA;    Stream.unfold Socket.read sk                 -- SerialT IO Word8&#xA;  &amp;amp; Unicode.decodeLatin1                         -- SerialT IO Char&#xA;  &amp;amp; Stream.splitWithSuffix (== &#39;\n&#39;) Array.write -- SerialT IO String&#xA;&#xA;recv :: Socket -&amp;gt; SerialT IO (Array Char)&#xA;recv sk = Stream.finally (liftIO $ close sk) (readLines sk)&#xA;&#xA;-- | Starts a server at port 8091 listening for lines with space separated&#xA;-- words. Multiple clients can connect to the server and send streams of lines.&#xA;-- The server handles all the connections concurrently, merges the incoming&#xA;-- streams at line boundaries and writes the merged stream to a file.&#xA;server :: Handle -&amp;gt; IO ()&#xA;server file =&#xA;      Stream.unfold TCP.acceptOnPort 8090        -- SerialT IO Socket&#xA;    &amp;amp; Stream.concatMapWith Stream.parallel recv  -- SerialT IO (Array Char)&#xA;    &amp;amp; Stream.unfoldMany Array.read               -- SerialT IO Char&#xA;    &amp;amp; Unicode.encodeLatin1                       -- SerialT IO Word8&#xA;    &amp;amp; Stream.fold (Handle.write file)            -- IO ()&#xA;&#xA;main :: IO ()&#xA;main = withFile &#34;output.txt&#34; AppendMode server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Listing Directories Recursively/Concurrently&lt;/h3&gt; &#xA;&lt;p&gt;Our next example lists a directory tree recursively, reading multiple directories concurrently.&lt;/p&gt; &#xA;&lt;p&gt;This example uses the tree traversing combinator &lt;code&gt;iterateMapLeftsWith&lt;/code&gt;. This combinator maps a stream generator on the &lt;code&gt;Left&lt;/code&gt; values in its input stream (directory names in this case), feeding the resulting &lt;code&gt;Left&lt;/code&gt; values back to the input, while it lets the &lt;code&gt;Right&lt;/code&gt; values (file names in this case) pass through to the output. The &lt;code&gt;Stream.ahead&lt;/code&gt; stream joining combinator then makes it iterate on the directories concurrently.&lt;/p&gt; &#xA;&lt;p&gt;Please see the file &lt;a href=&#34;https://github.com/composewell/streamly-examples/raw/master/examples/ListDir.hs&#34;&gt;ListDir.hs&lt;/a&gt; for the complete working code, including the imports that we have omitted below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Streamly.Internal.Data.Stream.IsStream (iterateMapLeftsWith)&#xA;&#xA;import qualified Streamly.Prelude as Stream&#xA;import qualified Streamly.Internal.FileSystem.Dir as Dir (toEither)&#xA;&#xA;-- Lists a directory as a stream of (Either Dir File).&#xA;listDir :: String -&amp;gt; SerialT IO (Either String String)&#xA;listDir dir =&#xA;      Dir.toEither dir               -- SerialT IO (Either String String)&#xA;    &amp;amp; Stream.map (bimap mkAbs mkAbs) -- SerialT IO (Either String String)&#xA;&#xA;    where mkAbs x = dir ++ &#34;/&#34; ++ x&#xA;&#xA;-- | List the current directory recursively using concurrent processing.&#xA;main :: IO ()&#xA;main = do&#xA;    hSetBuffering stdout LineBuffering&#xA;    let start = Stream.fromPure (Left &#34;.&#34;)&#xA;    Stream.iterateMapLeftsWith Stream.ahead listDir start&#xA;        &amp;amp; Stream.mapM_ print&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rate Limiting&lt;/h3&gt; &#xA;&lt;p&gt;For bounded concurrent streams, a stream yield rate can be specified easily. For example, to print &#34;tick&#34; once every second you can simply write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;main :: IO ()&#xA;main =&#xA;      Stream.repeatM (pure &#34;tick&#34;)  -- AsyncT IO String&#xA;    &amp;amp; Stream.timestamped            -- AsyncT IO (AbsTime, String)&#xA;    &amp;amp; Stream.avgRate 1              -- AsyncT IO (AbsTime, String)&#xA;    &amp;amp; Stream.fromAsync              -- SerialT IO (AbsTime, String)&#xA;    &amp;amp; Stream.mapM_ print            -- IO ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please see the file &lt;a href=&#34;https://github.com/composewell/streamly-examples/raw/master/examples/Rate.hs&#34;&gt;Rate.hs&lt;/a&gt; for the complete working code.&lt;/p&gt; &#xA;&lt;p&gt;The concurrency of the stream is automatically controlled to match the specified rate. &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt;&#39;s rate control works precisely even at throughputs as high as millions of yields per second.&lt;/p&gt; &#xA;&lt;p&gt;For more sophisticated rate control needs please see the Streamly &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;reference documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Reactive Programming&lt;/h3&gt; &#xA;&lt;p&gt;Streamly supports reactive (time domain) programming because of its support for declarative concurrency. Please see the &lt;code&gt;Streamly.Prelude&lt;/code&gt; module for time-specific combinators like &lt;code&gt;intervalsOf&lt;/code&gt;, and folds like &lt;code&gt;takeInterval&lt;/code&gt; in &lt;code&gt;Streamly.Internal.Data.Fold&lt;/code&gt;. Please also see the pre-release sampling combinators in the &lt;code&gt;Streamly.Internal.Data.Stream.IsStream.Top&lt;/code&gt; module for &lt;code&gt;throttle&lt;/code&gt; and &lt;code&gt;debounce&lt;/code&gt; like operations.&lt;/p&gt; &#xA;&lt;p&gt;The examples &lt;a href=&#34;https://github.com/composewell/streamly-examples/tree/master/examples/AcidRain.hs&#34;&gt;AcidRain.hs&lt;/a&gt; and &lt;a href=&#34;https://github.com/composewell/streamly-examples/tree/master/examples/CirclingSquare.hs&#34;&gt;CirclingSquare.hs&lt;/a&gt; demonstrate reactive programming using &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;More Examples&lt;/h3&gt; &#xA;&lt;p&gt;If you would like to view more examples, please visit the &lt;a href=&#34;https://github.com/composewell/streamly-examples&#34;&gt;Streamly Examples&lt;/a&gt; web page.&lt;/p&gt; &#xA;&lt;h3&gt;Further Reading&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/composewell/streaming-benchmarks&#34;&gt;Streaming Benchmarks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/composewell/concurrency-benchmarks&#34;&gt;Concurrency Benchmarks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Functional Conf 2019 &lt;a href=&#34;https://www.youtube.com/watch?v=uzsqgdMMgtk&#34;&gt;Video&lt;/a&gt; | &lt;a href=&#34;https://www.slideshare.net/HarendraKumar10/streamly-concurrent-data-flow-programming&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;/&#34;&gt;Other Guides&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly Homepage&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;As you have seen in the word count example above, &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt; offers highly modular abstractions for building programs while also offering the performance close to an equivalent (imperative) C program.&lt;/p&gt; &#xA;&lt;p&gt;Streamly offers excellent performance even for byte-at-a-time stream operations using efficient abstractions like &lt;code&gt;Unfold&lt;/code&gt;s and terminating &lt;code&gt;Fold&lt;/code&gt;s. Byte-at-a-time stream operations can simplify programming because the developer does not have to deal explicitly with chunking and re-combining data.&lt;/p&gt; &#xA;&lt;p&gt;Streamly exploits GHC&#39;s stream fusion optimizations (&lt;code&gt;case-of-case&lt;/code&gt; and &lt;code&gt;spec-constr&lt;/code&gt;) aggressively to achieve C-like speed, while also offering highly modular abstractions to developers.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt; will usually perform very well without any compiler plugins. However, we have fixed some deficiencies that we had noticed in GHC&#39;s optimizer using a &lt;a href=&#34;https://github.com/composewell/fusion-plugin&#34;&gt;compiler plugin&lt;/a&gt;. We hope to fold these optimizations into GHC in the future; until then we recommend that you use this plugin for applications that are performance sensitive.&lt;/p&gt; &#xA;&lt;h3&gt;Benchmarks&lt;/h3&gt; &#xA;&lt;p&gt;We measured several Haskell streaming implementations using various micro-benchmarks. Please see the &lt;a href=&#34;https://github.com/composewell/streaming-benchmarks&#34;&gt;streaming benchmarks&lt;/a&gt; page for a detailed comparison of Streamly against other streaming libraries.&lt;/p&gt; &#xA;&lt;p&gt;Our results show that &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt; is the fastest effectful streaming implementation on almost all the measured microbenchmarks. In many cases it runs up to 100x faster, and in some cases even 1000x faster than some of the tested alternatives. In some composite operation benchmarks &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt; turns out to be significantly faster than Haskell&#39;s list implementation.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: If you can write a program in some other way or with some other language that runs significantly faster than what &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt; offers, please let us know and we will improve.&lt;/p&gt; &#xA;&lt;h2&gt;Notes&lt;/h2&gt; &#xA;&lt;p&gt;Streamly comes equipped with a very powerful set of abstractions to accomplish many kinds of programming tasks: it provides support for programming with streams and arrays, for reading and writing from the file system and from the network, for time domain programming (reactive programming), and for reacting to file system events using &lt;code&gt;fsnotify&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Please view &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&#39;s documentation&lt;/a&gt; for more information about Streamly&#39;s features.&lt;/p&gt; &#xA;&lt;h3&gt;Concurrency&lt;/h3&gt; &#xA;&lt;p&gt;Streamly uses lock-free synchronization for achieving concurrent operation with low overheads. The number of tasks performed concurrently are determined automatically based on the rate at which a consumer is consuming the results. In other words, you do not need to manage thread pools or decide how many threads to use for a particular task. For CPU-bound tasks Streamly will try to keep the number of threads close to the number of CPUs available; for IO-bound tasks it will utilize more threads.&lt;/p&gt; &#xA;&lt;p&gt;The parallelism available during program execution can be utilized with very little overhead even where the task size is very small, because Streamly will automatically switch between serial or batched execution of tasks on the same CPU depending on whichever is more efficient. Please see our &lt;a href=&#34;https://github.com/composewell/concurrency-benchmarks&#34;&gt;concurrency benchmarks&lt;/a&gt; for more detailed performance measurements, and for a comparison with the &lt;code&gt;async&lt;/code&gt; package.&lt;/p&gt; &#xA;&lt;h3&gt;Design Goals&lt;/h3&gt; &#xA;&lt;p&gt;Our goals for &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt; from the very beginning have been:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;To achieve simplicity by unifying abstractions.&lt;/li&gt; &#xA; &lt;li&gt;To offer high performance.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;These goals are hard to achieve simultaneously because they are usually inversely related. We have spent many years trying to get the abstractions right without compromising performance.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Unfold&lt;/code&gt; is an example of an abstraction that we have created to achieve high performance when mapping streams on streams. &lt;code&gt;Unfold&lt;/code&gt; allows stream generation to be optimized well by the compiler through stream fusion. A &lt;code&gt;Fold&lt;/code&gt; with termination capability is another example which modularizes stream elimination operations through stream fusion. Terminating folds can perform many simple parsing tasks that do not require backtracking. In Streamly, &lt;code&gt;Parser&lt;/code&gt;s are a natural extension to terminating &lt;code&gt;Fold&lt;/code&gt;s; &lt;code&gt;Parser&lt;/code&gt;s add the ability to backtrack to &lt;code&gt;Fold&lt;/code&gt;s. Unification leads to simpler abstractions and lower cognitive overheads while also not compromising performance.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;The following authors/libraries have influenced or inspired this library in a significant way:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Roman Leshchinskiy (&lt;a href=&#34;http://hackage.haskell.org/package/vector&#34;&gt;vector&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Gabriella Gonzalez (&lt;a href=&#34;https://hackage.haskell.org/package/foldl&#34;&gt;foldl&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Alberto G. Corona (&lt;a href=&#34;https://hackage.haskell.org/package/transient&#34;&gt;transient&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://raw.githubusercontent.com/composewell/streamly/master/docs/User/ProjectRelated/Credits.md&#34;&gt;&lt;code&gt;credits&lt;/code&gt;&lt;/a&gt; directory for a full list of contributors, credits and licenses.&lt;/p&gt; &#xA;&lt;h2&gt;Licensing&lt;/h2&gt; &#xA;&lt;p&gt;Streamly is an &lt;a href=&#34;https://github.com/composewell/streamly&#34;&gt;open source&lt;/a&gt; project available under a liberal &lt;a href=&#34;https://raw.githubusercontent.com/composewell/streamly/master/LICENSE&#34;&gt;BSD-3-Clause license&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing to Streamly&lt;/h2&gt; &#xA;&lt;p&gt;As an open project we welcome contributions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/composewell/streamly/master/CONTRIBUTING.md&#34;&gt;Streamly Contributor&#39;s Guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;mailto:streamly@composewell.com&#34;&gt;Contact the streamly development team&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Support&lt;/h2&gt; &#xA;&lt;p&gt;Professional support is available for &lt;a href=&#34;https://streamly.composewell.com/&#34;&gt;Streamly&lt;/a&gt;: please contact &lt;a href=&#34;mailto:support@composewell.com&#34;&gt;support@composewell.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also join our &lt;a href=&#34;https://gitter.im/composewell/streamly&#34;&gt;community chat channel&lt;/a&gt; on Gitter.&lt;/p&gt; &#xA;&lt;!--&#xA;Link References.&#xA;--&gt; &#xA;&lt;!--&#xA;Keep all the unstable links here so that they can be updated to stable&#xA;links (for online docs) before we release.&#xA;--&gt; &#xA;&lt;!-- examples --&gt; &#xA;&lt;!-- local files --&gt;</summary>
  </entry>
</feed>