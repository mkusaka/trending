<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-05-18T01:32:24Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sayo-hs/heftia</title>
    <updated>2025-05-18T01:32:24Z</updated>
    <id>tag:github.com,2025-05-18:/sayo-hs/heftia</id>
    <link href="https://github.com/sayo-hs/heftia" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A theory‑backed, ultra type‑safe algebraic effects&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Heftia: A theory‑backed, ultra type‑safe algebraic effects&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/heftia&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/heftia.svg?logo=haskell&amp;amp;label=heftia&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/heftia-effects&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/heftia-effects.svg?logo=haskell&amp;amp;label=heftia-effects&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.stackage.org/lts/package/heftia-effects&#34;&gt;&lt;img src=&#34;https://www.stackage.org/package/heftia-effects/badge/lts&#34; alt=&#34;Stackage LTS&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.stackage.org/nightly/package/heftia-effects&#34;&gt;&lt;img src=&#34;https://www.stackage.org/package/heftia-effects/badge/nightly&#34; alt=&#34;Stackage Nightly&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/sayo-hs/heftia/actions&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/sayo-hs/heftia/haskell.yml?branch=master&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Heftia is a Haskell library for algebraic effects grounded in solid theoretical foundations.&lt;/p&gt; &#xA;&lt;p&gt;It is the only library that fully supports higher-order algebraic effects with complete type safety.&lt;/p&gt; &#xA;&lt;p&gt;Say goodbye to runtime errors and unsound semantics.&lt;/p&gt; &#xA;&lt;p&gt;This library provides a simple interface, predictable behavior, and maximum flexibility while delivering standard, practical performance.&lt;/p&gt; &#xA;&lt;p&gt;Please refer to the &lt;a href=&#34;https://hackage.haskell.org/package/heftia-0.7.0.0/docs/Control-Monad-Hefty.html&#34;&gt;Haddock documentation&lt;/a&gt; for usage and semantics. For information on performance, please refer to &lt;a href=&#34;https://github.com/sayo-hs/heftia/raw/v0.7.0.0/benchmark/performance.md&#34;&gt;performance.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This library is inspired by the paper:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://doi.org/10.1145/3571255&#34;&gt;Hefty Algebras: Modular Elaboration of Higher-Order Algebraic Effects. Casper Bach Poulsen &amp;amp; Cas van der Rest, POPL 2023.&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The elaboration approach proposed in that paper allows for a straightforward treatment of higher-order effects.&lt;/p&gt; &#xA;&lt;p&gt;Heftia is also grounded in the following theory:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://doi.org/10.1016/j.scico.2024.103086&#34;&gt;A Framework for Higher-Order Effects &amp;amp; Handlers. Birthe&amp;nbsp;van&amp;nbsp;den&amp;nbsp;Berg&amp;nbsp;&amp;amp;&amp;nbsp;Tom&amp;nbsp;Schrijvers, Sci.&amp;nbsp;Comput.&amp;nbsp;Program.&amp;nbsp;2024.&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Why choose this library over others?&lt;/h2&gt; &#xA;&lt;p&gt;This library is based on algebraic effects. Currently, &lt;strong&gt;none of the practical effect libraries other than this one are &#34;algebraic.&#34;&lt;/strong&gt; So, why is being &lt;em&gt;algebraic&lt;/em&gt; important?&lt;/p&gt; &#xA;&lt;p&gt;For example, algebraic effects are essential for managing coroutines, generators, streaming, concurrency, non-deterministic computations, and more in a highly elegant and concise manner.&lt;/p&gt; &#xA;&lt;p&gt;Algebraic effects provide a consistent and predictable framework for handling side effects. Research in cutting-edge languages like &lt;a href=&#34;https://koka-lang.github.io/koka/doc/index.html&#34;&gt;Koka&lt;/a&gt;, &lt;a href=&#34;https://www.eff-lang.org/&#34;&gt;Eff lang&lt;/a&gt;, and &lt;a href=&#34;https://ocaml.org/manual/effects.html&#34;&gt;OCaml 5&lt;/a&gt; is advancing the understanding and implementation of algebraic effects, establishing them as &lt;strong&gt;the programming paradigm of the future&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Heftia extends this by supporting higher-order algebraic effects, allowing for more expressive and modular effect management. This positions Heftia at &lt;strong&gt;the forefront of modern effect handling techniques&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore, &lt;strong&gt;Heftia is functionally a superset of other effect libraries&lt;/strong&gt;, especially those based on &lt;code&gt;ReaderT&lt;/code&gt; over &lt;code&gt;IO&lt;/code&gt;. In other words, anything that is possible with other libraries is also possible with this library. This is because Heftia supports &lt;code&gt;MonadUnliftIO&lt;/code&gt; in the form of higher-order effects.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MonadUnliftIO&lt;/code&gt; is a typeclass that ensures safety in exception handling. Heftia completely resolves runtime-error issues present in certain usages of &lt;code&gt;MonadUnliftIO&lt;/code&gt; with &lt;code&gt;effectful&lt;/code&gt; and &lt;code&gt;bluefin&lt;/code&gt;, thereby demonstrating &lt;strong&gt;stronger safety guarantees&lt;/strong&gt;[^8][^9]. Moreover, Heftia delivers &lt;strong&gt;strong performance&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Heftia should be a good substitute for &lt;code&gt;mtl&lt;/code&gt;, &lt;code&gt;effectful&lt;/code&gt;, &lt;code&gt;polysemy&lt;/code&gt;, &lt;code&gt;fused-effects&lt;/code&gt;, and &lt;code&gt;freer-simple&lt;/code&gt;.&lt;/strong&gt; If performance is particularly important, &lt;a href=&#34;https://github.com/haskell-effectful/effectful&#34;&gt;&lt;code&gt;effectful&lt;/code&gt;&lt;/a&gt; would be the best alternative to this library.&lt;/p&gt; &#xA;&lt;p&gt;[^8]: MonadUnliftIO instance allows escape &lt;a href=&#34;https://github.com/tomjaguarpaw/bluefin/issues/29&#34;&gt;https://github.com/tomjaguarpaw/bluefin/issues/29&lt;/a&gt; [^9]: &lt;a href=&#34;https://github.com/sayo-hs/heftia/raw/v0.7.0.0/heftia-effects/test/Test/UnliftIO.hs&#34;&gt;heftia-effects/test/Test/UnliftIO.hs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Key Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Correct Semantics for Higher-Order Effects &amp;amp; Continuations&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;This library provides the following features simultaneously, which existing libraries could not support together:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;Delimited continuations (algebraic effects)&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Coroutines (non-scoped resumptions)&lt;/li&gt; &#xA;     &lt;li&gt;Coroutine-based, composable, and resumable concurrent streams&lt;/li&gt; &#xA;     &lt;li&gt;Non-deterministic computations&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Higher-order effects&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/unliftio&#34;&gt;&lt;code&gt;MonadUnliftIO&lt;/code&gt;&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;to prevent resource leaks due to runtime exceptions&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://github.com/sayo-hs/heftia/raw/v0.7.0.0/heftia-effects/Example/UnliftIO/Main.hs&#34;&gt;heftia-effects/Example/UnliftIO/Main.hs&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://github.com/sayo-hs/heftia/raw/v0.7.0.0/heftia-effects/Example/Stream/Main.hs&#34;&gt;heftia-effects/Example/Stream/Main.hs&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/effectful-core-2.5.0.0/docs/Effectful-Provider.html&#34;&gt;&lt;code&gt;Provider&lt;/code&gt;&lt;/a&gt; a.k.a. &lt;a href=&#34;https://hackage.haskell.org/package/polysemy-1.9.2.0/docs/Polysemy-Scoped.html&#34;&gt;&lt;code&gt;Scoped&lt;/code&gt;&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;to prevent &lt;a href=&#34;https://h2.jaguarpaw.co.uk/posts/bluefin-prevents-handles-leaking/&#34;&gt;resource handles from leaking out of scopes&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/heftia-effects-0.7.0.0/docs/Control-Monad-Hefty-Concurrent-Subprocess.html&#34;&gt;Control.Monad.Hefty.Concurrent.Subprocess&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://github.com/sayo-hs/heftia/raw/v0.7.0.0/heftia-effects/Example/Subprocess/Main.hs&#34;&gt;heftia-effects/Example/Subprocess/Main.hs&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://github.com/sayo-hs/heftia/raw/v0.7.0.0/heftia-effects/Example/DatabaseProvider/Main.hs&#34;&gt;heftia-effects/Example/DatabaseProvider/Main.hs&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://medium.com/@PerrottaFrancisco/learning-cats-effects-parallel-execution-f617f883e390&#34;&gt;Applicative-style Parallelism&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;like &lt;code&gt;cats-effect&lt;/code&gt; in Scala&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/data-effects-0.4.2.0/docs/Data-Effect-Concurrent-Parallel.html&#34;&gt;Data.Effect.Concurrent.Parallel&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/heftia-effects-0.7.0.0/docs/Control-Monad-Hefty-Concurrent-Parallel.html&#34;&gt;Control.Monad.Hefty.Concurrent.Parallel&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://github.com/sayo-hs/heftia/raw/v0.7.0.0/heftia-effects/test/Test/Concurrent.hs&#34;&gt;heftia-effects/test/Test/Concurrent.hs&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;All of these interact through a simple, consistent, and predictable semantics based on algebraic effects.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Easy and Concise Implementation for Custom Effect Interpreters&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;As you can see from the implementations of basic effect interpreters such as &lt;a href=&#34;https://hackage.haskell.org/package/heftia-effects-0.7.0.0/docs/src/Control.Monad.Hefty.State.html#runState&#34;&gt;State&lt;/a&gt;, &lt;a href=&#34;https://hackage.haskell.org/package/heftia-effects-0.7.0.0/docs/src/Control.Monad.Hefty.Except.html#runThrow&#34;&gt;Throw/Catch&lt;/a&gt;, &lt;a href=&#34;https://hackage.haskell.org/package/heftia-effects-0.7.0.0/docs/src/Control.Monad.Hefty.Writer.html#runTell&#34;&gt;Writer&lt;/a&gt;, &lt;a href=&#34;https://hackage.haskell.org/package/heftia-effects-0.7.0.0/docs/src/Control.Monad.Hefty.NonDet.html#runNonDet&#34;&gt;NonDet&lt;/a&gt;, and &lt;a href=&#34;https://hackage.haskell.org/package/heftia-effects-0.7.0.0/docs/src/Control.Monad.Hefty.Coroutine.html#runCoroutine&#34;&gt;Coroutine&lt;/a&gt;, they can be implemented in just a few lines, or even a single line. Even for effects like NonDet and Coroutine, which involve continuations and might seem difficult to implement at first glance, this is exactly how simple it can be. This is the power of algebraic effects. Users can quickly define experimental and innovative custom effects using continuations.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Standard and Reasonable Performance&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;It operates at a speed roughly on par with &lt;code&gt;effectful&lt;/code&gt; and significantly faster than &lt;code&gt;mtl&lt;/code&gt; and &lt;code&gt;polysemy&lt;/code&gt;: &lt;a href=&#34;https://github.com/sayo-hs/heftia/raw/v0.7.0.0/benchmark/performance.md&#34;&gt;performance.md&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Type Safety and Purity&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Does not depend on the IO monad and can use any monad as the base monad.&lt;/li&gt; &#xA;   &lt;li&gt;Semantics are isolated from the IO monad, meaning that aspects like asynchronous exceptions and threads do not affect the behavior of effects.&lt;/li&gt; &#xA;   &lt;li&gt;The constructors of the &lt;code&gt;Eff&lt;/code&gt; monad are &lt;a href=&#34;https://hackage.haskell.org/package/heftia-0.7.0.0/docs/Control-Monad-Hefty.html#t:Eff&#34;&gt;exposed&lt;/a&gt;, and users can manipulate them directly without any safety concerns. Still, the semantics remain intact.&lt;/li&gt; &#xA;   &lt;li&gt;These are in contrast to libraries like &lt;code&gt;effectful&lt;/code&gt; and &lt;code&gt;eff&lt;/code&gt;, making this library more &lt;strong&gt;Haskell-ish and purely functional&lt;/strong&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;This design effectively prevents obscure behaviors and potential runtime errors.&lt;/strong&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Approach to Inter-Library Compatibility&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Built on the &lt;a href=&#34;https://github.com/sayo-hs/data-effects&#34;&gt;&lt;code&gt;data-effects&lt;/code&gt;&lt;/a&gt; effect framework, &lt;code&gt;heftia&lt;/code&gt; is designed so that it can integrate smoothly with other effect libraries that are built upon the same framework.&lt;/li&gt; &#xA;   &lt;li&gt;Conversion between different libraries&#39; &lt;code&gt;Eff&lt;/code&gt; monads.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;interpret&lt;/code&gt; functions that works independently of any particular library.&lt;/li&gt; &#xA;   &lt;li&gt;At present, only &lt;code&gt;heftia&lt;/code&gt; is based on this framework.&lt;/li&gt; &#xA;   &lt;li&gt;This represents an initial attempt to resolve the issues of incompatibility and lack of interoperability caused by the proliferation of effect libraries in Haskell.&lt;/li&gt; &#xA;   &lt;li&gt;In addition to monads, an effect system built on Applicative and Functor is also available.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Downsides&lt;/h2&gt; &#xA;&lt;p&gt;This library has notable semantic differences, particularly compared to libraries like &lt;code&gt;effectful&lt;/code&gt;, &lt;code&gt;polysemy&lt;/code&gt;, and &lt;code&gt;fused-effects&lt;/code&gt;. The semantics of this library are almost equivalent to those of &lt;code&gt;freer-simple&lt;/code&gt; and are also similar to Alexis King&#39;s &lt;code&gt;eff&lt;/code&gt; library. This type of semantics is often referred to as &lt;em&gt;continuation-based semantics&lt;/em&gt;. Additionally, unlike recent libraries such as &lt;code&gt;effectful&lt;/code&gt;, which have an IO-fused effect system, the semantics of this library are separated from IO. People who are already familiar with the behaviors of other major libraries might potentially find it somewhat challenging to transition to this library, due to differences in their mental models.&lt;/p&gt; &#xA;&lt;p&gt;For those who have not used an extensible effects library in Haskell before, this should not be a problem. Particularly, if you are already somewhat familiar with the semantics of algebraic effects through languages like &lt;code&gt;koka&lt;/code&gt; or &lt;code&gt;eff-lang&lt;/code&gt;, you likely already have the mental model needed for this library, and everything should go smoothly.&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;This library is currently in the beta stage. There may be significant changes and potential bugs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;I am looking forward to your feedback!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ cabal update&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add &lt;code&gt;heftia-effects ^&amp;gt;= 0.7&lt;/code&gt; to the build dependencies. Enable the &lt;code&gt;GHC2021&lt;/code&gt; and the following language extensions as needed:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;LambdaCase&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;BlockArguments&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;FunctionalDependencies&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;RecordWildCards&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Example .cabal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;...&#xA;    build-depends:&#xA;        ...&#xA;        heftia-effects ^&amp;gt;= 0.7,&#xA;&#xA;    default-language: GHC2021&#xA;&#xA;    default-extensions:&#xA;        ...&#xA;        LambdaCase,&#xA;        DerivingStrategies,&#xA;        DataKinds,&#xA;        TypeFamilies,&#xA;        BlockArguments,&#xA;        FunctionalDependencies,&#xA;        RecordWildCards,&#xA;        DefaultSignatures,&#xA;        PatternSynonyms,&#xA;        TemplateHaskell,&#xA;        PartialTypeSignatures,&#xA;        AllowAmbiguousTypes&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you encounter an error like the following, add the pragma:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# OPTIONS_GHC -fconstraint-solver-iterations=16 #-}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to the header of your source file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;solveWanteds: too many iterations (limit = 4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, the number 16 should be set to the maximum number of effects you want to stack. The default in GHC is 4, which is quite low, so it&#39;s a good idea to set it to around 16 globally, rather than specifying the pragma in each file individually.&lt;/p&gt; &#xA;&lt;p&gt;The supported versions are GHC 9.6.2 and later.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;h3&gt;Coroutine-based Composable Concurrent Stream&lt;/h3&gt; &#xA;&lt;p&gt;Below is an example of using concurrent streams (pipes).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# OPTIONS_GHC -fconstraint-solver-iterations=16 #-}&#xA;&#xA;import Control.Monad.Hefty&#xA;import Control.Monad.Hefty.Concurrent.Stream&#xA;import Control.Monad.Hefty.Concurrent.Timer&#xA;import Control.Monad.Hefty.Except&#xA;import Control.Monad.Hefty.Unlift&#xA;import Control.Arrow ((&amp;gt;&amp;gt;&amp;gt;))&#xA;import Control.Monad (forever, void, when)&#xA;import Data.Foldable (for_)&#xA;import UnliftIO (bracket_)&#xA;&#xA;-- | Generates a sequence of 1, 2, 3, 4 at 0.5-second intervals.&#xA;produce :: (Output Int :&amp;gt; es, Timer :&amp;gt; es, FOEs es) =&amp;gt; Eff es ()&#xA;produce = void . runThrow @() $&#xA;    for_ [1 ..] \(i :: Int) -&amp;gt; do&#xA;        when (i == 5) $ throw ()&#xA;        output i&#xA;        sleep 0.5&#xA;&#xA;-- | Receives the sequence at 0.5-second intervals and prints it.&#xA;consume :: (Input Int :&amp;gt; es, Timer :&amp;gt; es, Emb IO :&amp;gt; es) =&amp;gt; Eff es ()&#xA;consume = forever do&#xA;    liftIO . print =&amp;lt;&amp;lt; input @Int&#xA;    sleep 0.5&#xA;&#xA;-- | Transforms by receiving the sequence as input at 0.5-second intervals,&#xA;--   adds 100, and outputs it.&#xA;plus100 :: (Input Int :&amp;gt; es, Output Int :&amp;gt; es, Timer :&amp;gt; es, Emb IO :&amp;gt; es) =&amp;gt; Eff es ()&#xA;plus100 = forever do&#xA;    i &amp;lt;- input @Int&#xA;    let o = i + 100&#xA;    liftIO $ putStrLn $ &#34;Transform &#34; &amp;lt;&amp;gt; show i &amp;lt;&amp;gt; &#34; to &#34; &amp;lt;&amp;gt; show o&#xA;    output o&#xA;    sleep 0.5&#xA;&#xA;main :: IO ()&#xA;main = runUnliftIO . runTimerIO $ do&#xA;    let produceWithBracket =&#xA;            bracket_&#xA;                (liftIO $ putStrLn &#34;Start&#34;)&#xA;                (liftIO $ putStrLn &#34;End&#34;)&#xA;                (onlyFOEs produce)&#xA;&#xA;    runMachineryIO_ $&#xA;        Unit @() @Int do&#xA;            produceWithBracket&#xA;            produceWithBracket&#xA;            &amp;gt;&amp;gt;&amp;gt; Unit @Int @Int plus100&#xA;            &amp;gt;&amp;gt;&amp;gt; Unit @Int @() consume&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; main&#xA;Start&#xA;Transform 1 to 101&#xA;101&#xA;Transform 2 to 102&#xA;102&#xA;Transform 3 to 103&#xA;103&#xA;Transform 4 to 104&#xA;104&#xA;End&#xA;Start&#xA;Transform 1 to 101&#xA;101&#xA;Transform 2 to 102&#xA;102&#xA;Transform 3 to 103&#xA;103&#xA;Transform 4 to 104&#xA;104&#xA;End&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Each function (machine unit) &lt;code&gt;produce&lt;/code&gt;, &lt;code&gt;consume&lt;/code&gt;, and &lt;code&gt;plus100&lt;/code&gt; operates with input/output at 0.5-second intervals, but note that the composed stream also maintains operation intervals at 0.5 seconds (not 1.5 seconds!). This means that each unit operates concurrently based on threads.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;End&lt;/code&gt; is displayed just after the first sequence ends and before the second sequence starts. This demonstrates that the &lt;code&gt;bracket_&lt;/code&gt; function based on &lt;code&gt;MonadUnliftIO&lt;/code&gt; for safe resource release works in such a way that resources are released immediately at the correct timing—even if the stream is still in progress—rather than waiting until the entire stream (including the second sequence) has completed. Existing stream libraries like &lt;a href=&#34;https://hackage.haskell.org/package/pipes&#34;&gt;&lt;code&gt;pipes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://hackage.haskell.org/package/conduit&#34;&gt;&lt;code&gt;conduit&lt;/code&gt;&lt;/a&gt; have the issue that immediate resource release like this is not possible. This problem was first addressed by the effect system library &lt;a href=&#34;https://github.com/tomjaguarpaw/bluefin&#34;&gt;&lt;code&gt;bluefin&lt;/code&gt;&lt;/a&gt;. For more details, please refer to &lt;a href=&#34;https://h2.jaguarpaw.co.uk/posts/bluefin-streams-finalize-promptly/&#34;&gt;Bluefin streams finalize promptly&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The complete code example can be found at &lt;a href=&#34;https://github.com/sayo-hs/heftia/raw/v0.7.0.0/heftia-effects/Example/Stream/Main.hs&#34;&gt;heftia-effects/Example/Stream/Main.hs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Aggregating File Sizes Using Non-Deterministic Computation&lt;/h3&gt; &#xA;&lt;p&gt;The following is an extract of the main parts from an example of non-deterministic computation. For the full code, please refer to &lt;a href=&#34;https://github.com/sayo-hs/heftia/raw/v0.7.0.0/heftia-effects/Example/NonDet/Main.hs&#34;&gt;heftia-effects/Example/NonDet/Main.hs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Aggregate the sizes of all files under the given path&#xA;fileSizes&#xA;    :: (Choose :&amp;gt; es, Empty :&amp;gt; es, FileSystem :&amp;gt; es, Throw NotADir :&amp;gt; es, Emb IO :&amp;gt; es)&#xA;    =&amp;gt; FilePath&#xA;    -&amp;gt; Eff es (Sum Integer)&#xA;fileSizes path = do&#xA;    entities :: [FilePath] &amp;lt;- listDirectory path &amp;amp; joinEither&#xA;    entity :: FilePath &amp;lt;- choice entities -- Non-deterministically /pick/ one item from the list&#xA;    let path&#39; = path &amp;lt;/&amp;gt; entity&#xA;&#xA;    liftIO $ putStrLn $ &#34;Found &#34; &amp;lt;&amp;gt; path&#39;&#xA;&#xA;    getFileSize path&#39; &amp;gt;&amp;gt;= \case&#xA;        Right size -&amp;gt; do&#xA;            liftIO $ putStrLn $ &#34; ... &#34; &amp;lt;&amp;gt; show size &amp;lt;&amp;gt; &#34; bytes&#34;&#xA;            pure $ Sum size&#xA;        Left NotAFile -&amp;gt; do&#xA;            fileSizes path&#39;&#xA;&#xA;main :: IO ()&#xA;main = runEff&#xA;    . runThrowIO @EntryNotFound&#xA;    . runThrowIO @NotADir&#xA;    . runDummyFS exampleRoot&#xA;    $ do&#xA;        total &amp;lt;- runNonDetMonoid pure (fileSizes &#34;.&#34;)&#xA;        liftIO $ print total&#xA;&#xA;-- | Effect for file system operations&#xA;data FileSystem :: Effect where&#xA;    ListDirectory :: FilePath -&amp;gt; FileSystem f (Either NotADir [FilePath])&#xA;    GetFileSize :: FilePath -&amp;gt; FileSystem f (Either NotAFile Integer)&#xA;&#xA;{- |&#xA;Interpreter for the FileSystem effect that virtualizes the file system in memory&#xA;based on a given FSTree, instead of performing actual IO.&#xA;-}&#xA;runDummyFS&#xA;    :: (Throw EntryNotFound `In` es, Throw NotADir `In` es)&#xA;    =&amp;gt; FSTree&#xA;    -&amp;gt; Eff (FileSystem &#39;: es) ~&amp;gt; Eff es&#xA;runDummyFS root = interpret \case&#xA;    ListDirectory path -&amp;gt;&#xA;        lookupFS path root &amp;lt;&amp;amp;&amp;gt; \case&#xA;            Dir entries -&amp;gt; Right $ Map.keys entries&#xA;            File _ -&amp;gt; Left NotADir&#xA;    GetFileSize path -&amp;gt;&#xA;        lookupFS path root &amp;lt;&amp;amp;&amp;gt; \case&#xA;            File size -&amp;gt; Right size&#xA;            Dir _ -&amp;gt; Left NotAFile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; main&#xA;Found ./README.md&#xA; ... 4000 bytes&#xA;Found ./src&#xA;Found ./src/Bar.hs&#xA; ... 1000 bytes&#xA;Found ./src/Foo.hs&#xA; ... 2000 bytes&#xA;Found ./test&#xA;Found ./test/Baz.hs&#xA; ... 3000 bytes&#xA;Sum {getSum = 10000}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;A detailed explanation of usage and semantics is available in &lt;a href=&#34;https://hackage.haskell.org/package/heftia-0.7.0.0/docs/Control-Monad-Hefty.html&#34;&gt;Haddock&lt;/a&gt;. The example codes are located in the &lt;a href=&#34;https://github.com/sayo-hs/heftia/tree/v0.7.0.0/heftia-effects/Example&#34;&gt;heftia-effects/Example/&lt;/a&gt; directory. Also, the following &lt;em&gt;HeftWorld&lt;/em&gt; example (outdated): &lt;a href=&#34;https://github.com/sayo-hs/HeftWorld&#34;&gt;https://github.com/sayo-hs/HeftWorld&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;About the internal &lt;em&gt;elaboration&lt;/em&gt; mechanism: &lt;a href=&#34;https://sayo-hs.github.io/jekyll/update/2024/09/04/how-the-heftia-extensible-effects-library-works.html&#34;&gt;https://sayo-hs.github.io/jekyll/update/2024/09/04/how-the-heftia-extensible-effects-library-works.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Comparison&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Higher-Order Effects: Does it support higher-order effects?&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Delimited Continuation: The ability to manipulate delimited continuations.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Effect System: For a term representing an effectful program, is it possible to statically decidable a type that enumerates all the effects the program may produce?&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Purely Monadic: Is an effectful program represented as a transparent data structure that is a monad, and can it be interpreted into other data types using only pure operations without side effects or &lt;code&gt;unsafePerformIO&lt;/code&gt;?&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Dynamic Effect Rewriting: Can an effectful program have its internal effects altered afterwards (by functions typically referred to as &lt;code&gt;handle with&lt;/code&gt;, &lt;code&gt;intercept&lt;/code&gt;, &lt;code&gt;interpose&lt;/code&gt;, &lt;code&gt;transform&lt;/code&gt;, &lt;code&gt;translate&lt;/code&gt;, or &lt;code&gt;rewrite&lt;/code&gt;) ?&lt;/p&gt; &lt;p&gt;For example, would it be possible to apply &lt;code&gt;interpose&lt;/code&gt; as many times as the number of values input by the user at runtime?&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Semantics: Classification of behaviors resulting from the interpretation of effects.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Algebraic Effects: The same as Algebraic Effects and Handlers.&lt;/li&gt; &#xA;   &lt;li&gt;IO-fused: IO + ReaderT pattern.&lt;/li&gt; &#xA;   &lt;li&gt;Carrier dependent: The behavior depends on the specific type inference result of the monad. Tagless-final style.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Library or Language&lt;/th&gt; &#xA;   &lt;th&gt;Higher-Order Effects&lt;/th&gt; &#xA;   &lt;th&gt;Delimited Continuation&lt;/th&gt; &#xA;   &lt;th&gt;Effect System&lt;/th&gt; &#xA;   &lt;th&gt;Purely Monadic&lt;/th&gt; &#xA;   &lt;th&gt;Dynamic Effect Rewriting&lt;/th&gt; &#xA;   &lt;th&gt;Semantics&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;heftia&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;Multi-shot&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅ (also &lt;code&gt;Applicative&lt;/code&gt; and others)&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;Algebraic Effects&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;freer-simple&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Multi-shot&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;Algebraic Effects&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;polysemy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;Weaving-based (functorial state)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;effectful&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌ (based on the &lt;code&gt;IO&lt;/code&gt; monad)&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;IO-fused&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;bluefin&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅[^7][^10]&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌ (based on the &lt;code&gt;IO&lt;/code&gt; monad)&lt;/td&gt; &#xA;   &lt;td&gt;✅[^5]&lt;/td&gt; &#xA;   &lt;td&gt;IO-fused&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;eff&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;Multi-shot&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌ (based on the &lt;code&gt;IO&lt;/code&gt; monad)&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;Algebraic Effects &amp;amp; IO-fused [^6]&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;speff&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;Multi-shot (restriction: [^4])&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌ (based on the &lt;code&gt;IO&lt;/code&gt; monad)&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;Algebraic Effects &amp;amp; IO-fused&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;mtl&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;Multi-shot (&lt;code&gt;ContT&lt;/code&gt;)&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Carrier dependent&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;fused-effects&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌?&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Carrier dependent &amp;amp; Weaving-based (functorial state)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;in-other-words&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;Multi-shot?&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌?&lt;/td&gt; &#xA;   &lt;td&gt;Carrier dependent&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Koka-lang&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Multi-shot&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌ (language built-in)&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;Algebraic Effects&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Eff-lang&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Multi-shot&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌ (language built-in)&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;Algebraic Effects&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OCaml-lang 5&lt;/td&gt; &#xA;   &lt;td&gt;?&lt;/td&gt; &#xA;   &lt;td&gt;One-shot&lt;/td&gt; &#xA;   &lt;td&gt;❌ [^3]&lt;/td&gt; &#xA;   &lt;td&gt;❌ (language built-in)&lt;/td&gt; &#xA;   &lt;td&gt;?&lt;/td&gt; &#xA;   &lt;td&gt;Algebraic Effects&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;[^3]: Effects do not appear in the type signature and can potentially cause unhandled errors at runtime [^4]: Scoped Resumption only. e.g. Coroutines are not supported. [^5]: &lt;a href=&#34;https://discourse.haskell.org/t/bluefin-compared-to-effectful-video/10723/27?u=ymdfield&#34;&gt;https://discourse.haskell.org/t/bluefin-compared-to-effectful-video/10723/27?u=ymdfield&lt;/a&gt; [^6]: &lt;a href=&#34;https://github.com/hasura/eff/issues/12&#34;&gt;https://github.com/hasura/eff/issues/12&lt;/a&gt; [^7]: &lt;a href=&#34;https://discourse.haskell.org/t/what-is-a-higher-order-effect/10744&#34;&gt;https://discourse.haskell.org/t/what-is-a-higher-order-effect/10744&lt;/a&gt; [^10]: &lt;a href=&#34;https://github.com/tomjaguarpaw/bluefin/pull/27&#34;&gt;https://github.com/tomjaguarpaw/bluefin/pull/27&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Heftia can simply be described as a higher-order version of &lt;code&gt;freer-simple&lt;/code&gt;. This is indeed true in terms of its internal mechanisms as well.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, this library provides a consistent algebraic effects semantics that is independent of carriers and effects. On the other hand, in libraries like &lt;code&gt;in-other-words&lt;/code&gt;, &lt;code&gt;mtl&lt;/code&gt;, and &lt;code&gt;fused-effects&lt;/code&gt;, the semantics of the code depend on the effect and, in part, the carrier inferred by type inference. Fixing the semantics to a algebraic effects model helps improve the predictability of the behavior (interpretation result) of the code without losing flexibility.&lt;/p&gt; &#xA;&lt;p&gt;Carrier-dependent semantics can lead to unexpected behavior for code readers, particularly in situations where the types become implicit. Particularly, attention should be given to the fact that due to type inference, semantic changes may propagate beyond the blocks enclosed by &lt;code&gt;interpret&lt;/code&gt; or &lt;code&gt;interpose&lt;/code&gt;. In the case of carrier-independent semantics, especially with Freer-based effects, &lt;code&gt;interpret&lt;/code&gt; and &lt;code&gt;interpose&lt;/code&gt; do not alter the semantics by intervening in type inference or instance resolution of the carrier. Instead, they function as traditional functions, simply transforming the content of the data structure. This results in minimal surprise to the mental model of the code reader.&lt;/p&gt; &#xA;&lt;h3&gt;Performance&lt;/h3&gt; &#xA;&lt;p&gt;Overall, the performance of this library is roughly on par with &lt;code&gt;effectful&lt;/code&gt;, or only slightly slower. &lt;code&gt;heftia&lt;/code&gt; runs significantly faster compared to existing effect systems such as &lt;code&gt;mtl&lt;/code&gt; and &lt;code&gt;polysemy&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For more details, please refer to &lt;a href=&#34;https://github.com/sayo-hs/heftia/raw/v0.7.0.0/benchmark/performance.md&#34;&gt;performance.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Interoperability with other libraries&lt;/h3&gt; &#xA;&lt;h4&gt;About &lt;code&gt;mtl&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Since the representation of effectful programs in Heftia is simply a monad (&lt;code&gt;Eff&lt;/code&gt;), it can be used as the base monad for transformers. This means you can stack any transformer on top of it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;code&gt;Eff&lt;/code&gt; monad is an instance of &lt;code&gt;MonadIO&lt;/code&gt;, &lt;code&gt;MonadError&lt;/code&gt;, &lt;code&gt;MonadRWS&lt;/code&gt;, &lt;code&gt;MonadUnliftIO&lt;/code&gt;, &lt;code&gt;Alternative&lt;/code&gt;, etc., and these behave as the senders for the embedded &lt;code&gt;IO&lt;/code&gt; or the effect GADTs defined in &lt;a href=&#34;https://github.com/sayo-hs/data-effects&#34;&gt;data-effects&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;About &lt;code&gt;effectful&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;In Heftia, since any monad can be used as the base monad of &lt;code&gt;Eff&lt;/code&gt;, by setting the &lt;code&gt;Eff&lt;/code&gt; monad from &lt;code&gt;effectful&lt;/code&gt; as the base monad of Heftia, you can stack any effect in Heftia on top of &lt;code&gt;effectful&lt;/code&gt;. In other words, the &lt;code&gt;Eff&lt;/code&gt; of &lt;code&gt;Heftia&lt;/code&gt; itself can be used like a monad transformer. This is not limited to &lt;code&gt;effectful&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;By using &lt;code&gt;Control.Monad.Hefty.Unlift.runUnliftIO&lt;/code&gt; instead of &lt;code&gt;Control.Monad.Hefty.runEff&lt;/code&gt;, you can inherit and use the &lt;code&gt;MonadUnliftIO&lt;/code&gt; functionality of &lt;code&gt;effectful&lt;/code&gt;&#39;s &lt;code&gt;Eff&lt;/code&gt; as a higher-order &lt;code&gt;UnliftIO&lt;/code&gt; effect within Heftia.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Representation of effects&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Heftia relies on &lt;a href=&#34;https://hackage.haskell.org/package/data-effects&#34;&gt;data-effects&lt;/a&gt; for the definitions of standard effects such as &lt;code&gt;Reader&lt;/code&gt;, &lt;code&gt;Writer&lt;/code&gt;, and &lt;code&gt;State&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;It is generally recommended to use effects defined with automatic derivation provided by &lt;a href=&#34;https://hackage.haskell.org/package/data-effects-th&#34;&gt;data-effects-th&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The data structures used to represent effects are equivalent to those in &lt;code&gt;polysemy&lt;/code&gt;, &lt;code&gt;cleff&lt;/code&gt;, and &lt;code&gt;fused-effects&lt;/code&gt;. However, in &lt;code&gt;heftia&lt;/code&gt;, in order for operations to work, various type classes and type families (such as &lt;code&gt;HFunctor&lt;/code&gt; and &lt;code&gt;OrderOf&lt;/code&gt;) must also be defined for the effect types. Although it is possible to define them manually, doing so can be quite boilerplate, and to avoid the confusion caused by duplicate definitions of effects, it is recommended to use the effect types already defined in &lt;code&gt;data-effects&lt;/code&gt;, and for new definitions, to use derivation via &lt;code&gt;data-effects-th&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;It is not compatible with the structures of &lt;code&gt;effectful&lt;/code&gt; and &lt;code&gt;bluefin&lt;/code&gt;. A structural conversion between &lt;code&gt;effectful&lt;/code&gt; and &lt;code&gt;heftia&lt;/code&gt; is currently underway.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Future Plans&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Increase effects and nurture the ecosystem &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;File systems, shell scripting, POSIX, networking, Web, markup processing/template engines, multimedia, etc.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Further speedup&lt;/li&gt; &#xA; &lt;li&gt;Write practical software using Heftia&lt;/li&gt; &#xA; &lt;li&gt;(Support for &lt;a href=&#34;https://hackage.haskell.org/package/linear-base&#34;&gt;Linear&lt;/a&gt; effects?)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The license is MPL 2.0. Please refer to the &lt;a href=&#34;https://github.com/sayo-hs/heftia/raw/v0.7.0.0/NOTICE&#34;&gt;NOTICE&lt;/a&gt;. Additionally, the code from &lt;code&gt;freer-simple&lt;/code&gt; has been modified and used internally within this library. Therefore, some modules are licensed under both &lt;code&gt;MPL-2.0 AND BSD-3-Clause&lt;/code&gt;. For details on licenses and copyrights, please refer to the module&#39;s Haddock documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Your contributions are welcome!&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/sayo-hs/heftia/raw/v0.7.0.0/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgements, citations, and related work&lt;/h2&gt; &#xA;&lt;p&gt;The following is a non-exhaustive list of people and works that have had a significant impact, directly or indirectly, on Heftia’s design and implementation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Oleg Kiselyov, Amr Sabry, and Cameron Swords — &lt;a href=&#34;http://okmij.org/ftp/Haskell/extensible/exteff.pdf&#34;&gt;Extensible Effects: An alternative to monad transfomers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Oleg Kiselyov and Hiromi Ishii — &lt;a href=&#34;http://okmij.org/ftp/Haskell/extensible/more.pdf&#34;&gt;Freer Monads, More Extensible Effects&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Rob Rix, Patrick Thomson, and other contributors — &lt;a href=&#34;https://github.com/fused-effects/fused-effects&#34;&gt;&lt;code&gt;fused-effects&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Sandy Maguire and other contributors — &lt;a href=&#34;https://github.com/polysemy-research/polysemy&#34;&gt;&lt;code&gt;polysemy&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Alexis King and other contributors — &lt;a href=&#34;https://github.com/lexi-lambda/freer-simple&#34;&gt;&lt;code&gt;freer-simple&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://github.com/lexi-lambda/eff&#34;&gt;&lt;code&gt;eff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Casper Bach Poulsen and Cas van der Rest — &lt;a href=&#34;https://dl.acm.org/doi/10.1145/3571255&#34;&gt;Hefty Algebras: Modular Elaboration of Higher-Order Algebraic Effects&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Tom Ellis — &lt;a href=&#34;https://h2.jaguarpaw.co.uk/posts/bluefin-streams-finalize-promptly/&#34;&gt;Bluefin streams finalize promptly&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>