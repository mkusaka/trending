<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-28T01:36:53Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nammayatri/shared-kernel</title>
    <updated>2023-02-28T01:36:53Z</updated>
    <id>tag:github.com,2023-02-28:/nammayatri/shared-kernel</id>
    <link href="https://github.com/nammayatri/shared-kernel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>nammayatri/beckn-gateway</title>
    <updated>2023-02-28T01:36:53Z</updated>
    <id>tag:github.com,2023-02-28:/nammayatri/beckn-gateway</id>
    <link href="https://github.com/nammayatri/beckn-gateway" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>alfreb/church1936</title>
    <updated>2023-02-28T01:36:53Z</updated>
    <id>tag:github.com,2023-02-28:/alfreb/church1936</id>
    <link href="https://github.com/alfreb/church1936" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lambda calculus implemented directly from Alonzo Church&#39;s 1936 paper&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;church1936&lt;/h1&gt; &#xA;&lt;p&gt;Lambda calculus implemented directly from Alonzo Church&#39;s 1936 paper “An Unsolvable Problem of Elementary Number Theory.” &lt;em&gt;American Journal of Mathematics&lt;/em&gt;, vol. 58, no. 2, 1936, pp. 345–63. JSTOR, &lt;a href=&#34;https://doi.org/10.2307/2371045&#34;&gt;https://doi.org/10.2307/2371045&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/alfreb/church1936/actions/workflows/haskell.yml&#34;&gt;&lt;img src=&#34;https://github.com/alfreb/church1936/actions/workflows/haskell.yml/badge.svg?sanitize=true&#34; alt=&#34;Haskell CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Build and run unit tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Generate the documentation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal haddock&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Build and run the example program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal run church1936&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The example program prints the following (with some formatting added here for github readability):&lt;/p&gt; &#xA;&lt;h2&gt;A TL;DR of Church&#39;s paper&lt;/h2&gt; &#xA;&lt;p&gt;First the symbols of the lanugage of lambda calculus are introduced:&lt;br&gt; &lt;code&gt;{}()𝝺,[]&lt;/code&gt;&lt;br&gt; &lt;br&gt; Then the variables are introduced as a, b, c ... and so on. We&#39;re told that this is an enumerably infinite set of symbols, but he really only provides the first 3, so we have to improvise beyond z. We did this by implementing Enum for variables as follows: &lt;br&gt; &lt;code&gt;x, y, z, a₁, b₁, c₁, d₁, e₁, f₁, g₁&lt;/code&gt;&lt;br&gt; ... and then &lt;br&gt; &lt;code&gt;x₁, y₁, z₁, a₂, b₂, c₂, d₂, e₂, f₂, g₂&lt;/code&gt; &lt;br&gt; &lt;br&gt; Any sequence of symbols defined above is a &lt;em&gt;formula&lt;/em&gt; in the paper so technically &lt;code&gt;}(&lt;/code&gt; and &lt;code&gt;{o₁[&lt;/code&gt; are formulas, but only the well-formed ones are interesting, which Church defines by induction together with &lt;em&gt;free&lt;/em&gt; and &lt;em&gt;bound&lt;/em&gt; variables.&lt;br&gt; &lt;br&gt; &#34;A variable &lt;em&gt;x&lt;/em&gt; standing alone is a well-formed formula and the occurence of &lt;em&gt;x&lt;/em&gt; in it is an occurence of &lt;em&gt;x&lt;/em&gt; as a free variable in it&#34;&lt;br&gt; &lt;br&gt; Let&#39;s verify. x is a well formed formula: True The &lt;code&gt;Variable&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; is free in the &lt;code&gt;Formula&lt;/code&gt; &lt;code&gt;Var (V &#34;x&#34;)&lt;/code&gt;: True &lt;br&gt; Further, if the formulas &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; are well-formed, &lt;code&gt;{F}(X)&lt;/code&gt; is too. This is one confirmed example: &lt;code&gt;{f}({f}(f))&lt;/code&gt;&lt;br&gt; &lt;br&gt; Now for the lambda: if &lt;code&gt;M&lt;/code&gt; is well formed and &lt;code&gt;x&lt;/code&gt; is free in &lt;code&gt;M&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is bound in &lt;code&gt;𝝺x[M]&lt;/code&gt;. So 𝝺 has one job: to bind variables. Here&#39;s one confirmed example of an &lt;code&gt;M&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt; as free:&lt;br&gt; &lt;code&gt;x(x(x(y)))&lt;/code&gt;&lt;br&gt; &lt;br&gt; Attaching 𝝺x we get a well-formed formula with x now bound:&lt;br&gt; &lt;code&gt;𝝺x . x(x(x(y)))&lt;/code&gt;&lt;br&gt; &lt;br&gt; Church now defines the numerals as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1 → 𝝺ab . a(b)&#xA;2 → 𝝺ab . a(a(b))&#xA;3 → 𝝺ab . a(a(a(b)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The successor function is not defined in this paper, but was defined in Church 33 as follows:&lt;br&gt; &lt;code&gt;𝝺cab . a(c(a,b))&lt;/code&gt;&lt;br&gt; &lt;br&gt; We can apply the successor function to 2 like so:&lt;br&gt; &lt;code&gt;{𝝺cab . a(c(a,b))}(𝝺ab . a(a(b)))&lt;/code&gt;&lt;br&gt; &lt;br&gt; The full form of this expression is really this:&lt;br&gt; &lt;code&gt;{𝝺c[𝝺a[𝝺b[{a}({{c}(a)}(b))]]]}(𝝺a[𝝺b[{a}({a}(b))]])&lt;/code&gt;&lt;br&gt; &lt;br&gt; Thankfully, Church provided a nice set of abbreviation rules to save us from the sea of brackets. You can turn them on or off. &lt;br&gt; Applying Operation II (reduction) repeatedly we eventually get &#34;normal form&#34;, where no further reduction is possible.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;𝝺ab . a({𝝺ab . a(a(b))}(a,b))&#xA;𝝺ab . a({𝝺c . a(a(c))}(b))&#xA;𝝺ab . a(a(a(b)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The successor of 2 is 3. Yay!&lt;br&gt; &lt;br&gt; Addition can now be implemented in terms of successor:&lt;br&gt; &lt;code&gt;𝝺mn . n(𝝺cab . a(c(a,b)),m)&lt;/code&gt;&lt;br&gt; &lt;br&gt; But for multiplication the plot thickens; Church messed up! (see the documentation for details). Rosser helped fix this, as noted in Kleene 35, with this nice baby:&lt;br&gt; &lt;code&gt;𝝺abx . a(b(x))&lt;/code&gt;&lt;br&gt; &lt;br&gt; And to top it off they point out that the numerals themselves are exponentiation functions. 2(3) is 3^2 and 3(2) = 2^3. Reversing the parameters we get it in the order we&#39;re used to:&lt;br&gt; &lt;code&gt;𝝺ab . b(a)&lt;/code&gt;&lt;br&gt; &lt;br&gt; Notice how this is exactly the same as the number 1, with the variables in reversed order:&lt;br&gt; &lt;code&gt;𝝺ab . a(b)&lt;/code&gt;&lt;br&gt; &lt;br&gt; Let&#39;s end here, with proving that 2 + 2 = 4:&lt;br&gt; &lt;code&gt;{𝝺pofx . p(f,o(f,x))}(𝝺ab . a(a(b)),𝝺ab . a(a(b)))&lt;/code&gt;&lt;br&gt; &lt;br&gt; reduces to &lt;br&gt; &lt;code&gt;𝝺fx . f(f(f(f(x))))&lt;/code&gt;&lt;br&gt; &lt;br&gt; Pretty neat!&lt;/p&gt; &#xA;&lt;h2&gt;The point of the paper&lt;/h2&gt; &#xA;&lt;p&gt;Note that the objective of Church&#39;s paper was not to make a computer, it was to prove that Gödel&#39;s incompleteness theorem has implications for even simple statements in elementary number theory. More on that later!&lt;/p&gt;</summary>
  </entry>
</feed>