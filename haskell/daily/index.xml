<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-03T01:30:43Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>toptobes/typefuck-haskell</title>
    <updated>2024-01-03T01:30:43Z</updated>
    <id>tag:github.com,2024-01-03:/toptobes/typefuck-haskell</id>
    <link href="https://github.com/toptobes/typefuck-haskell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Typelevel Brainfuck in Haskell; Brainfuck implemented solely in Haskell&#39;s type system&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Typefuck (Haskell edition)&lt;/h1&gt; &#xA;&lt;p&gt;(inspired by &lt;a href=&#34;https://github.com/susisu/typefuck&#34;&gt;susisu&#39;s Typescript-edition typefuck&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;This Typefuck also runs solely in Haskell&#39;s type system, though (at least I think, as I haven&#39;t looked deeply into their code) it operates a bit differently than susisu&#39;s.&lt;/p&gt; &#xA;&lt;h2&gt;(Roughly) How it works&lt;/h2&gt; &#xA;&lt;p&gt;The state of the program is managed by three main types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;{- | An efficient way to move forwards and backwards through some list&#xA;   (N.B. index == length preceeding) -}&#xA;type Cursor a = &#xA;  ( Nat -- ^ The index of the currently selected thing&#xA;  , [a] -- ^ The preceeding things&#xA;  ,  a  -- ^ The thing the cursor is currently pointing at&#xA;  , [a] -- ^ The succeeding things&#xA;  )&#xA;&#xA;{- | An association list to hold the index of each open bracket and its closing counterpart -}&#xA;type BracketLUT = [(Nat, Nat)]&#xA;&#xA;{- | The state of the brainfuck engine -}&#xA;type TFState = &#xA;  ( Cursor Char -- ^ The cursor for moving through the code&#xA;  , Cursor Nat  -- ^ The cursor for the memory tape&#xA;  , Symbol      -- ^ The input to the program&#xA;  , Symbol      -- ^ The output for the program&#xA;  , BracketLUT  -- ^ The aforementioned LUT for the []s&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and the rest is basically mutually-recursive type-family spam, which you can read through as you please.&lt;/p&gt; &#xA;&lt;p&gt;The tape is (hack-ily) generated through an external haskell script which creates the file which contains the tape (more on that later).&lt;/p&gt; &#xA;&lt;p&gt;I also had to manually implement versions of + and - that would overflow/underflow to emulate ubyte-sized cells:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;type family (a :: Nat) -~ (b :: Nat) :: Nat where&#xA;  a -~ b = UnderflowingSub&#39; (CmpNat a b) a b&#xA;&#xA;type family UnderflowingSub&#39; (ord :: Ordering) (a :: Nat) (b :: Nat) where&#xA;  UnderflowingSub&#39; &#39;LT a b = 256 - (b - a)&#xA;  UnderflowingSub&#39;  _  a b = a - b&#xA;&#xA;type family (a :: Nat) +~ (b :: Nat) :: Nat where&#xA;  a +~ b = Mod (a + b) 256&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using it for yourself&lt;/h2&gt; &#xA;&lt;p&gt;To run this, you need to have at the very least &lt;code&gt;cabal&lt;/code&gt; installed, but it&#39;d be in your favor to also have &lt;code&gt;make&lt;/code&gt; + &lt;code&gt;bash&lt;/code&gt; (or a compatable shell) up and running. &lt;code&gt;node&lt;/code&gt; or (what I use) &lt;code&gt;bun&lt;/code&gt; are also used for tests.&lt;/p&gt; &#xA;&lt;h3&gt;Setting up the tape&lt;/h3&gt; &#xA;&lt;p&gt;The tape should already be pregenerated with 10 0s; however, you can generate a tape with the command &lt;code&gt;make tape TAPE=&#34;&amp;lt;list_gen&amp;gt;&#34;&lt;/code&gt; where &lt;code&gt;&amp;lt;list_gen&amp;gt;&lt;/code&gt; is some expression that generates a haskell list. Examples include&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;TAPE=&#34;[1, 2, 3]&#34;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TAPE=&#34;replicate 10 0&#34;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TAPE=&#34;[2 * x | x &amp;lt;- [1..10], mod x 2 == 0]&#34;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;and it generates a file like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;module TF.Generated.Tape where&#xA;type Tape = &#39;[0,0,0,0,0,0,0,0,0,0]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If, for some reason, you can&#39;t use the command line utility, you can just manually generate the list yourself (make sure you don&#39;t forget to use the &lt;code&gt;&#39;&lt;/code&gt;!)&lt;/p&gt; &#xA;&lt;p&gt;Disclaimer: you&#39;re free to generate long tapes, but if you go too long, you&#39;d risk being overtaken by the heat-death of the universe lol&lt;/p&gt; &#xA;&lt;h3&gt;Actually running Typefuck&lt;/h3&gt; &#xA;&lt;p&gt;My recommended way you use typefuck (if you&#39;re just type-fucking around) is to use &lt;code&gt;make repl&lt;/code&gt; (&lt;code&gt;cabal repl app&lt;/code&gt;), &lt;code&gt;import TF.Core&lt;/code&gt;, and &lt;code&gt;:k! RunTF &#34;&amp;lt;code&amp;gt;&#34; &#34;&amp;lt;input&amp;gt;&#34;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;me@t:~/projects/typefuck-haskell$ make repl&#xA;&amp;lt;...&amp;gt;&#xA;λ&amp;gt; import TF.Core&#xA;λ&amp;gt; :k! RunTF &#34;,.&#34; &#34;a&#34;&#xA;RunTF &#34;,.&#34; &#34;a&#34; :: ghc-prim:GHC.Types.Symbol&#xA;= &#34;a&#34;&#xA;λ&amp;gt; :k! RunTF &#34;++++++++[&amp;gt;++++[&amp;gt;++&amp;gt;+++&amp;gt;+++&amp;gt;+&amp;lt;&amp;lt;&amp;lt;&amp;lt;-]&amp;gt;+&amp;gt;+&amp;gt;-&amp;gt;&amp;gt;+[&amp;lt;]&amp;lt;-]&amp;gt;&amp;gt;.&amp;gt;---.+++++++..+++.&amp;gt;&amp;gt;.&amp;lt;-.&amp;lt;.+++.------.--------.&amp;gt;&amp;gt;+.&#34; &#34;&#34;&#xA;&amp;lt;...&amp;gt;&#xA;= &#34;Hello World!&#34;&#xA;λ&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use &lt;code&gt;reifySF&lt;/code&gt; from &lt;code&gt;Utils&lt;/code&gt; to create a concrete string, but that takes &lt;em&gt;much&lt;/em&gt; longer to generate any non-trivial programs&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;λ&amp;gt; symbolVal $ Proxy @(RunTF &#34;,.&#34; &#34;a&#34;)&#xA;&#34;a&#34;&#xA;λ&amp;gt; reifyTF @&#34;,.&#34; @&#34;a&#34;&#xA;&#34;a&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&#34;Open&#34; vs &#34;Closed&#34; inputs&lt;/h3&gt; &#xA;&lt;p&gt;In the event that your input-requiring code isn&#39;t working when it should be (e.g. printing empty input), there&#39;s a chance it&#39;s because you&#39;re using loops but your input isn&#39;t &lt;code&gt;NUL&lt;/code&gt;-terminated (i.e. it doesn&#39;t read in a closing &lt;code&gt;&#39;\0&#39;&lt;/code&gt; input to stop the loop). In that case, try changing &lt;code&gt;&#34;Hello!&#34;&lt;/code&gt; to &lt;code&gt;&#34;Hello!\0&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By default, when TF runs out of input, it just prints what input it has already (to emulate an interactive interpreter just pausing, waiting for input).&lt;/p&gt; &#xA;&lt;h3&gt;Running the tests&lt;/h3&gt; &#xA;&lt;p&gt;You can run the tests with &lt;code&gt;make test&lt;/code&gt; w/ bun/node (or manually executing &lt;code&gt;spec/run-tests.mjs&lt;/code&gt;). You can add your own tests to &lt;code&gt;spec/tests.json&lt;/code&gt; as you please.&lt;/p&gt; &#xA;&lt;h2&gt;Disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;I basically wrote this in a night or two so there may be some minor bugs and things that could be more efficient, but I&#39;m looking to fix them as I get time and motivation. Feel free to contribute!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>scotty-web/scotty</title>
    <updated>2024-01-03T01:30:43Z</updated>
    <id>tag:github.com,2024-01-03:/scotty-web/scotty</id>
    <link href="https://github.com/scotty-web/scotty" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell web framework inspired by Ruby&#39;s Sinatra, using WAI and Warp (Official Repository)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Scotty &lt;a href=&#34;https://hackage.haskell.org/package/scotty&#34;&gt;&lt;img src=&#34;http://img.shields.io/hackage/v/scotty.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stackage.org/lts/package/scotty&#34;&gt;&lt;img src=&#34;http://stackage.org/package/scotty/badge/lts&#34; alt=&#34;Stackage Lts&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stackage.org/nightly/package/scotty&#34;&gt;&lt;img src=&#34;http://stackage.org/package/scotty/badge/nightly&#34; alt=&#34;Stackage Nightly&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/scotty-web/scotty/actions/workflows/haskell-ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/scotty-web/scotty/actions/workflows/haskell-ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;A Haskell web framework inspired by Ruby&#39;s Sinatra, using WAI and Warp.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE OverloadedStrings #-}&#xA;import Web.Scotty&#xA;&#xA;main = scotty 3000 $&#xA;    get &#34;/:word&#34; $ do&#xA;        beam &amp;lt;- pathParam &#34;word&#34;&#xA;        html $ mconcat [&#34;&amp;lt;h1&amp;gt;Scotty, &#34;, beam, &#34; me up!&amp;lt;/h1&amp;gt;&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Scotty is the cheap and cheerful way to write RESTful, declarative web applications.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A page is as simple as defining the verb, URL pattern, and Text content.&lt;/li&gt; &#xA; &lt;li&gt;It is template-language agnostic. Anything that returns a Text value will do.&lt;/li&gt; &#xA; &lt;li&gt;Conforms to the &lt;a href=&#34;https://github.com/yesodweb/wai/&#34;&gt;web application interface (WAI)&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Uses the very fast Warp webserver by default.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As for the name: Sinatra + Warp = Scotty.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Run /basic.hs to see Scotty in action:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;runghc examples/basic.hs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Setting phasers to stun... (port 3000) (ctrl-c to quit)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Or equivalently with &lt;a href=&#34;https://docs.haskellstack.org/en/stable/&#34;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;stack exec -- scotty-basic&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once the server is running you can interact with it with curl or a browser:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl localhost:3000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;foobar&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl localhost:3000/foo_query?p=42&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;&amp;lt;h1&amp;gt;42&amp;lt;/h1&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Additionally, the &lt;code&gt;examples&lt;/code&gt; directory shows a number of concrete use cases, e.g.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/scotty-web/scotty/master/examples/exceptions.hs&#34;&gt;exception handling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/scotty-web/scotty/master/examples/globalstate.hs&#34;&gt;global state&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/scotty-web/scotty/master/examples/reader.hs&#34;&gt;configuration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/scotty-web/scotty/master/examples/cookies.hs&#34;&gt;cookies&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/scotty-web/scotty/master/examples/upload.hs&#34;&gt;file upload&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;and more&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;More Information&lt;/h2&gt; &#xA;&lt;p&gt;Tutorials and related projects can be found in the &lt;a href=&#34;https://github.com/scotty-web/scotty/wiki&#34;&gt;Scotty wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Feel free to ask questions or report bugs on the &lt;a href=&#34;https://github.com/scotty-web/scotty/issues/&#34;&gt;Github issue tracker&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Github issues are now (September 2023) labeled, so newcomers to the Haskell language can start with &lt;code&gt;easy fix&lt;/code&gt; ones and gradually progress to &lt;code&gt;new feature&lt;/code&gt;s, &lt;code&gt;bug&lt;/code&gt;s and &lt;code&gt;R&amp;amp;D&lt;/code&gt; :)&lt;/p&gt; &#xA;&lt;h2&gt;Package versions&lt;/h2&gt; &#xA;&lt;p&gt;Scotty adheres to the &lt;a href=&#34;https://pvp.haskell.org/&#34;&gt;Package Versioning Policy&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fails to compile regex-posix on Windows &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If you are using stack, add the following parameters to &lt;code&gt;stack.yaml&lt;/code&gt;: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  extra-deps:&#xA;  - regex-posix-clib-2.7&#xA;  flags:&#xA;    regex-posix:&#xA;      _regex-posix-clib: true&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;If you are using cabal, update the &lt;code&gt;constraints&lt;/code&gt; section of &lt;code&gt;cabal.project.local&lt;/code&gt; as follows: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt; &lt;pre&gt;&lt;code&gt;constraints:&#xA;  regex-posix +_regex-posix-clib &#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Contributors&lt;/h3&gt; &#xA;&lt;a href=&#34;https://github.com/scotty-web/scotty/graphs/contributors&#34;&gt; &lt;img src=&#34;https://contrib.rocks/image?repo=scotty-web/scotty&#34;&gt; &lt;/a&gt; &#xA;&lt;h1&gt;Copyright&lt;/h1&gt; &#xA;&lt;p&gt;(c) 2012-Present, Andrew Farmer and Scotty contributors&lt;/p&gt;</summary>
  </entry>
</feed>