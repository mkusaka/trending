<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-20T01:41:36Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>VinylRecords/Vinyl</title>
    <updated>2022-07-20T01:41:36Z</updated>
    <id>tag:github.com,2022-07-20:/VinylRecords/Vinyl</id>
    <link href="https://github.com/VinylRecords/Vinyl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Extensible Records for Haskell. Pull requests welcome! Come visit us on #vinyl on freenode.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Vinyl is a general solution to the records problem in Haskell using type level strings and other modern GHC features, featuring static structural typing (with a subtyping relation), and automatic row-polymorphic lenses. All this is possible without Template Haskell.&lt;/p&gt; &#xA;&lt;p&gt;First, install Vinyl from &lt;a href=&#34;http://hackage.haskell.org/package/vinyl&#34;&gt;Hackage&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal update&#xA;cabal install vinyl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To learn more, &lt;a href=&#34;https://github.com/VinylRecords/Vinyl/raw/master/tests/Intro.lhs&#34;&gt;try this tutorial&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Performance Scaling&lt;/h2&gt; &#xA;&lt;p&gt;Vinyl is an approach to records in Haskell based on a heterogeneous list type: a list where each element may have a different type. Since it is a list, accessing any individual field of a Vinyl record seems as though it should have &lt;em&gt;O(n)&lt;/em&gt; complexity, with &lt;em&gt;n&lt;/em&gt; the size of the record. Sure enough, pattern matching on a Vinyl record works just as with a list: we peel off the head element until we reach the one we are looking for. But we have an option to change these asymptotics.&lt;/p&gt; &#xA;&lt;p&gt;If we anticipate frequent &lt;code&gt;get&lt;/code&gt; operations on a record, we can use the function &lt;code&gt;toARec :: Rec f ts -&amp;gt; ARec f ts&lt;/code&gt; to produce an &lt;em&gt;array-backed &lt;code&gt;Rec&lt;/code&gt;&lt;/em&gt; that offers constant-time field access. We can consider a &lt;a href=&#34;https://github.com/VinylRecords/Vinyl/raw/master/benchmarks/AccessorsBench.hs&#34;&gt;benchmark&lt;/a&gt; of getting specific fields from different varieties of Vinyl records.&lt;/p&gt; &#xA;&lt;p&gt;This benchmark suggests the trends we should expect&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Getting a field deeper in a Vinyl record takes more time than getting one earlier (i.e. it appears to the left, or under fewer &lt;code&gt;:&amp;amp;&lt;/code&gt; constructors) in the record&lt;/li&gt; &#xA; &lt;li&gt;Getting a field of an &lt;code&gt;ARec&lt;/code&gt; (or &lt;code&gt;AFieldRec&lt;/code&gt;, which is an &lt;code&gt;ARec&lt;/code&gt; with named fields) array-backed record does not depend on where in the record that field lies&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The x-axis of this graph should be labeled as &lt;em&gt;nanoseconds&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/VinylRecords/Vinyl/master/images/accessors.png&#34; alt=&#34;Accessors benchmark plot&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ConferOpenSource/composite</title>
    <updated>2022-07-20T01:41:36Z</updated>
    <id>tag:github.com,2022-07-20:/ConferOpenSource/composite</id>
    <link href="https://github.com/ConferOpenSource/composite" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Integrations with Vinyl/Frames records.&lt;/p&gt;&lt;hr&gt;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;span&gt;âš &lt;/span&gt; &lt;strong&gt;This project has moved to &lt;a href=&#34;https://github.com/composite-hs&#34;&gt;https://github.com/composite-hs&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;composite&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.com/ConferOpenSource/composite&#34;&gt;&lt;img src=&#34;https://travis-ci.com/ConferOpenSource/composite.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Composite is a group of libraries focusing on practical uses of composite records, in particular &lt;a href=&#34;https://github.com/VinylRecords/Vinyl/&#34;&gt;Vinyl&lt;/a&gt;, such as querying records from a database and converting them to JSON. These libraries are based on the excellent &lt;a href=&#34;https://github.com/acowley/Frames&#34;&gt;Frames&lt;/a&gt; style use of Vinyl records, though composite implements its own derived from Frames to make for a smaller dependency graph, as Frames is a full CSV parsing/printing and data manipulation library.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;composite-aeson&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;composite-aeson&lt;/code&gt; provides JSON formatting facilities for records. JSON formats can be derived automatically when default formats are available, explicitly assembled, combined, or a mix. Aeson&#39;s use of &lt;code&gt;FromJSON&lt;/code&gt;/&lt;code&gt;ToJSON&lt;/code&gt; type classes is mostly avoided to make using JSON formats first-class while still convenient.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE DataKinds, OverloadedStrings, PatternSynonyms, TypeOperators #-}&#xA;import qualified Data.Aeson as Aeson&#xA;import Composite.Aeson (JsonFormat, defaultJsonFormatRecord, recordJsonFormat, toJsonWithFormat)&#xA;import Composite.Record (Record, Rec(RNil), (:-&amp;gt;), pattern (:*:))&#xA;import Data.Text (Text)&#xA;&#xA;type FId   = &#34;id&#34;   :-&amp;gt; Int&#xA;type FName = &#34;name&#34; :-&amp;gt; Text&#xA;type User = &#39;[FId, FName]&#xA;&#xA;userFormat :: JsonFormat e (Record User)&#xA;userFormat = recordJsonFormat defaultJsonFormatRecord&#xA;&#xA;alice :: Record User&#xA;alice = 1 :*: &#34;Alice&#34; :*: RNil&#xA;&#xA;aliceJson :: Aeson.Value&#xA;aliceJson = toJsonWithFormat userFormat alice&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;composite-aeson-path&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;composite-aeson&lt;/code&gt; support for the &lt;a href=&#34;https://hackage.haskell.org/package/path&#34;&gt;path&lt;/a&gt; library.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;composite-aeson-refined&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;composite-aeson&lt;/code&gt; support for the &lt;a href=&#34;https://hackage.haskell.org/package/refined&#34;&gt;refined&lt;/a&gt; library.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;composite-base&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Definitions shared by the other composite libraries or generally useful when using Vinyl records. Includes some Template Haskell splices to generate various optics for records, as well as a specialization of &lt;code&gt;MonadReader&lt;/code&gt; which works on a context record, providing general environment for a computation.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;composite-binary&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Instance of &lt;code&gt;Binary&lt;/code&gt; from the &lt;a href=&#34;https://hackage.haskell.org/package/binary&#34;&gt;binary&lt;/a&gt; library for composite records.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;composite-ekg&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Autoconfiguration of &lt;a href=&#34;https://hackage.haskell.org/package/ekg&#34;&gt;EKG&lt;/a&gt; from a record of EKG metrics.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;composite-hashable&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Instance of &lt;code&gt;Hashable&lt;/code&gt; from the &lt;a href=&#34;https://hackage.haskell.org/package/hashable&#34;&gt;hashable&lt;/a&gt; library for composite records.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;composite-opaleye&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;composite-opaleye&lt;/code&gt; provides the necessary instances to use a Vinyl record with the &lt;a href=&#34;https://github.com/tomjaguarpaw/haskell-opaleye&#34;&gt;opaleye&lt;/a&gt; library, letting you use records for query expressions as well as result rows.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE Arrows, DataKinds, FlexibleContexts, OverloadedStrings, PatternSynonyms, TemplateHaskell, TypeOperators #-}&#xA;import Control.Arrow (returnA)&#xA;import Composite.Opaleye (defaultRecTable)&#xA;import Composite.Record (Record, (:-&amp;gt;))&#xA;import Composite.TH (withLensesAndProxies)&#xA;import Control.Lens (view)&#xA;import Data.Int (Int64)&#xA;import Data.Proxy (Proxy(Proxy))&#xA;import Data.Text (Text)&#xA;import Opaleye (Column, PGInt8, PGText, Query, Table(Table), (./=), asc, constant, orderBy, queryTable, restrict)&#xA;&#xA;-- For each field type defined with, withLensesAndProxies will expand to the type, a record lens for the type,&#xA;-- and a proxy for the type, so for example FId is the type, fId is a lens which accesses the &#34;id&#34; field of any&#xA;-- record which contains that field, and fId_ is a proxy for the field type in case it&#39;s needed.&#xA;withLensesAndProxies [d|&#xA;  type FId   = &#34;id&#34;   :-&amp;gt; Int64&#xA;  type CId   = &#34;id&#34;   :-&amp;gt; Column PGInt8&#xA;  type FName = &#34;name&#34; :-&amp;gt; Text&#xA;  type CName = &#34;name&#34; :-&amp;gt; Column PGText&#xA;  |]&#xA;&#xA;type User     = &#39;[FId, FName]&#xA;type UserCols = &#39;[CId, CName]&#xA;&#xA;userTable :: Table (Record UserCols) (Record UserCols)&#xA;userTable = Table &#34;users&#34; defaultRecTable&#xA;&#xA;userQuery :: Query (Record UserCols)&#xA;userQuery =&#xA;  orderBy (asc $ view cName) $ proc () -&amp;gt; do&#xA;    user &amp;lt;- queryTable userTable -&amp;lt; ()&#xA;    let recId = view cId user&#xA;    restrict -&amp;lt; recId ./= constant (1 :: Int64)&#xA;    returnA -&amp;lt; user&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;composite-swagger&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Automatic derivation of Swagger 2 (ala &lt;a href=&#34;https://hackage.haskell.org/package/swagger2&#34;&gt;swagger2&lt;/a&gt;) definitions for composite records.&lt;/p&gt; &#xA;&lt;h3&gt;Related work&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/compdoc&#34;&gt;&lt;code&gt;compdoc&lt;/code&gt;&lt;/a&gt; provides functionality for reading a Pandoc into a record.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/composite-dhall&#34;&gt;&lt;code&gt;composite-dhall&lt;/code&gt;&lt;/a&gt; provides &lt;code&gt;ToDhall&lt;/code&gt; and &lt;code&gt;FromDhall&lt;/code&gt; instances for composite records.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/composite-tuple&#34;&gt;&lt;code&gt;composite-tuple&lt;/code&gt;&lt;/a&gt; provides utility functions for treating composite records as tuples, ala &lt;code&gt;Relude.Extra.Tuple&lt;/code&gt; from &lt;a href=&#34;https://hackage.haskell.org/package/relude&#34;&gt;relude&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/fcf-composite&#34;&gt;&lt;code&gt;fcf-composite&lt;/code&gt;&lt;/a&gt; provides integration with first-class-families for type-level computation of records.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/polysemy-methodology-composite&#34;&gt;&lt;code&gt;polysemy-methodology-composite&lt;/code&gt;&lt;/a&gt; provides functions for using polysemy-methodology with composite.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;example&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A small servant based server which uses &lt;code&gt;composite-opaleye&lt;/code&gt; to pull records from the database, reshape the record to an API type, and send the records out to the client as JSON via &lt;code&gt;composite-aeson&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Maturity&lt;/h2&gt; &#xA;&lt;p&gt;As of writing, we use these libraries in all our Haskell projects internally and have had no major issues. There are spots using either composite or vinyl where the compiler error messages could use improvement. There are certain use cases that can cause the simplifier to crash, though we have not observed any runtime errors as yet. They have not been proven out for performance at larger scale. We&#39;d appreciate any fixes, improvements, or experience reports.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions and feedback welcome! File an issue or make a PR.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>digital-asset/lib-finance</title>
    <updated>2022-07-20T01:41:36Z</updated>
    <id>tag:github.com,2022-07-20:/digital-asset/lib-finance</id>
    <link href="https://github.com/digital-asset/lib-finance" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DAML Finance Library (FinLib)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://circleci.com/gh/digital-asset/lib-finance&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/digital-asset/lib-finance.svg?style=svg&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright (c) 2019, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.&#xA;SPDX-License-Identifier: Apache-2.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;The FinLib is a collection of pure functions, DAML templates and triggers that can be used as building blocks to speed up application development and to increase code reuse, standardisation and compatibility across solutions.&lt;/p&gt; &#xA;&lt;p&gt;Currently, it contains code for:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/lib-finance/master/#assets&#34;&gt;Assets&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/lib-finance/master/#asset-transfers&#34;&gt;Asset Transfers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/lib-finance/master/#delivery-vs-payment-(dvp)-trades&#34;&gt;Delivery vs Payment (DvP) Trades&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/lib-finance/master/#corporate-actions&#34;&gt;Corporate Actions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/lib-finance/master/#calendar-functions&#34;&gt;Calendar Functions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Additional functionality will be added over time based on user feedback and demand. Thanks to its modular design, it&#39;s straightforward to use all the workflows of the FinLib or to selectively replace certain steps depending on the requirements of the solution.&lt;/p&gt; &#xA;&lt;p&gt;This Readme provides a conceptual overview of the FinLib. The individual contracts, fields and choices are described in the more detailed &lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/lib-finance/master/docs/Reference_Model.md&#34;&gt;model reference documentation&lt;/a&gt;. Corresponding triggers are described in the &lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/lib-finance/master/docs/Reference_Trigger.md&#34;&gt;trigger reference documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://daml.com/&#34;&gt;DAML SDK&lt;/a&gt; to work with the DAML code&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Digital Asset is working on adding a DAML package management system to the DAML SDK. This will allow to reference the FinLib package from a a project and to import FinLib modules as usual, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;import DA.Finance.Fact.Asset&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the meantime, a pragmatic way to use the FinLib is to copy its source code into a project.&lt;/p&gt; &#xA;&lt;h2&gt;Contract Ids and Trust Models&lt;/h2&gt; &#xA;&lt;p&gt;The FinLib addresses data with the following versioned identifier that is backed by a set of signatories:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;data Id = Id&#xA;  with&#xA;    signatories : Set Party&#xA;    label : Text&#xA;    version : Int&#xA;  deriving (Eq, Show)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;signatories&lt;/code&gt; are the parties that need to sign a contract with this id and that are responsible to ensure uniqueness of the &lt;code&gt;label&lt;/code&gt;. The &lt;code&gt;version&lt;/code&gt; allows to model multiple revisions of the same contract.&lt;/p&gt; &#xA;&lt;p&gt;Using a set of &lt;code&gt;signatories&lt;/code&gt; allows the FinLib to support various trust models. For example, an &lt;code&gt;AssetDeposit&lt;/code&gt; might be signed by (i) both the provider and the owner, (ii) just the provider or (iii) a third party agent. All approaches are valid depending on the desired level of trust between participants or the required flexibility to force upgrades.&lt;/p&gt; &#xA;&lt;h2&gt;Assets&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;AssetDeposit&lt;/code&gt; represents a deposit of a generic, fungible asset in an account. The &lt;code&gt;account.id&lt;/code&gt; and &lt;code&gt;asset.id&lt;/code&gt; fields can be used to link the contract to other contracts that provide further information such as the type of the asset or reference data for it. This allows new asset classes to be added without having to modify business processes that operate on generic asset deposits.&lt;/p&gt; &#xA;&lt;p&gt;A deposit is allocated to an account and backed by the &lt;code&gt;account.id.signatories&lt;/code&gt;. The deposited asset is specified by the &lt;code&gt;asset.id&lt;/code&gt;. The &lt;code&gt;asset.id.signatories&lt;/code&gt; are the parties that publish reference data for the asset and hence define what it is and how it can be lifecycled.&lt;/p&gt; &#xA;&lt;p&gt;The AssetDeposit is &lt;code&gt;fungible&lt;/code&gt; by design as it includes the choices how to &lt;code&gt;Split&lt;/code&gt; a single deposit into multiple and &lt;code&gt;Merge&lt;/code&gt; multiple deposits into a single one.&lt;/p&gt; &#xA;&lt;p&gt;Note that the library does not model positions. Positions can be derived e.g. client side by aggregating all asset deposits or a trigger that periodically updates a position contract by looking at all asset deposits.&lt;/p&gt; &#xA;&lt;h2&gt;Asset Transfers&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;AssetSettlement&lt;/code&gt; template allows to transfer &lt;code&gt;AssetDeposit&lt;/code&gt;s from one account to another by consuming a deposit and then crediting the asset to the receiver`s account. This requires that the sender is allowed to &lt;code&gt;Credit&lt;/code&gt; in the receiver&#39;s account through his &lt;code&gt;AssetSettlement&lt;/code&gt; contract.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/digital-asset/lib-finance/master/docs/AssetSettlement.png&#34; alt=&#34;AssetSettlement&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Delivery vs Payment (DvP) Trades&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;Dvp&lt;/code&gt; is a trade that represents an obligation to exchange the payment assets against the delivery assets at the agreed settlement date. A trade is allocated to a master agreement and backed by &lt;code&gt;masterAgreement.id.signatories&lt;/code&gt;. Depending on the desired trust model this might be both counterparties or a third party agent.&lt;/p&gt; &#xA;&lt;p&gt;Trades in general need to be settled. As part of instructing a trade a set of &lt;code&gt;SettlementInstruction&lt;/code&gt;s should be created. The library does not include the logic of how a DvP gets instructed because the process is often very bespoke to the given use case.&lt;/p&gt; &#xA;&lt;p&gt;Parties need to allocate deposits to &lt;code&gt;SettlementInstruction&lt;/code&gt;s. In the easy case where both counterparties have an account with the same provider a direct transfer from the sender to the receiver is possible, i.e. a single step need to be specified. The &lt;code&gt;SettlementInstruction&lt;/code&gt; can also handle more complex use cases where assets are &lt;em&gt;atomically&lt;/em&gt; transferred up and down an account hierarchy. In these cases multiple steps corresponding to the hierarchy are required.&lt;/p&gt; &#xA;&lt;p&gt;The trigger package includes an &lt;code&gt;AllocationRule&lt;/code&gt; template that helps to allocate deposits to settlement instructions and a trigger that eagerly allocates deposits.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;DvpSettlement&lt;/code&gt; template allows to settle a DvP by providing fully allocated settlement instructions for each payment and delivery obligation.&lt;/p&gt; &#xA;&lt;p&gt;The trigger package again includes a trigger that settles fully allocated DvPs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/digital-asset/lib-finance/master/docs/DvP.png&#34; alt=&#34;DvP&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Corporate Actions&lt;/h2&gt; &#xA;&lt;p&gt;Similar like there is a generic asset deposit that can hold any asset, there is a generic &lt;code&gt;LifecycleEffects&lt;/code&gt; template storing the details of an asset&#39;s lifecycle event by defining the outcome, i.e the &lt;code&gt;effects&lt;/code&gt;. This avoids dealing with any type of corporate action in the &lt;code&gt;AssetLifecycle&lt;/code&gt; and &lt;code&gt;DvpLifecycle&lt;/code&gt; rules. Those rules are used to lifecycle &lt;code&gt;AssetDeposit&lt;/code&gt;s and &lt;code&gt;DvP&lt;/code&gt;s based on &lt;code&gt;LifecycleEffects&lt;/code&gt; contracts only. Triggers are available to automate the process.&lt;/p&gt; &#xA;&lt;p&gt;Details of corporate actions are captured in reference data contracts with the same version number as the asset to which it applies, for example an &lt;code&gt;EquityCashDividend&lt;/code&gt;. The reference data provider can use such a specific reference data contract to create the generic &lt;code&gt;LifecycleEffects&lt;/code&gt; contract.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/digital-asset/lib-finance/master/docs/CorporateAction.png&#34; alt=&#34;CorporateAction&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Calendar Functions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/lib-finance/master/daml/DA/Finance/Base&#34;&gt;DA.Finance.Base&lt;/a&gt; includes a set of pure functions to deal with dates, holiday calendars, and schedules. See the &lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/lib-finance/master/docs/Reference.md&#34;&gt;reference documentation&lt;/a&gt; for all available functions.&lt;/p&gt;</summary>
  </entry>
</feed>