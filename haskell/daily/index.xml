<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-07T01:37:23Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fallen-icarus/cardano-swaps</title>
    <updated>2023-03-07T01:37:23Z</updated>
    <id>tag:github.com,2023-03-07:/fallen-icarus/cardano-swaps</id>
    <link href="https://github.com/fallen-icarus/cardano-swaps" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A distributed Cardano DEX proof-of-concept using composable atomic swaps where users maintain delegation control at all times.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cardano-Swaps&lt;/h1&gt; &#xA;&lt;p&gt;&lt;span&gt;⚠&lt;/span&gt; Knowledge of basic Haskell syntax and cardano-cli usage is assumed.&lt;/p&gt; &#xA;&lt;p&gt;The Getting Started instructions can be found &lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/GettingStarted.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#abstract&#34;&gt;Abstract&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#motivation&#34;&gt;Motivation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#preliminary-discussion&#34;&gt;Preliminary Discussion&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#current-dex-deficiencies&#34;&gt;Current DEX Deficiencies&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#programmable-swaps&#34;&gt;Programmable Swaps&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#beacon-tokens&#34;&gt;Beacon Tokens&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#the-cardano-swaps-protocol&#34;&gt;The Cardano-Swaps Protocol&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#specification&#34;&gt;Specification&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#personal-contracts&#34;&gt;Personal Contracts&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#the-dexs-inline-datum&#34;&gt;The DEX&#39;s Inline Datum&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#swap-contract-logic&#34;&gt;Swap Contract Logic&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#close-redeemer&#34;&gt;Close Redeemer&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#update-redeemer&#34;&gt;Update Redeemer&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#swap-redeemer&#34;&gt;Swap Redeemer&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#features-discussion&#34;&gt;Features Discussion&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#benchmarks-and-fee-estimations-ymmv&#34;&gt;Benchmarks and Fee Estimations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#faq&#34;&gt;FAQ&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Abstract&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;cardano-swaps&lt;/code&gt; is a proof-of-concept implementation of an &lt;em&gt;organically&lt;/em&gt; scalable DEX protocol for the Cardano Settlement Layer (CSL). It solves many of the pitfalls of current DEX implementations by empowering users to deploy their own (and interact with each others&#39;) script addresses. By doing so, users always maintain spending &lt;em&gt;and&lt;/em&gt; delegation control of their assets, and can elect if/when to upgrade their addresses to new contract standards.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;Many DEXes on Cardano are currently implemented in ways that lock users&#39; assets into a tightly fixed, and/or centrally maintained, set(s) of script addresses. Such design patterns are reminiscent of the EVM&#39;s accounts-based programming paradigm, and inherit many of the same downsides; scalability bottlenecks and asset/stake centralization. DEXes that hope to achieve massive scale on the CSL must adhere to a radically different approach that takes full advantage of the concurrency and parallelism offered by the eUTxO model. &lt;code&gt;cardano-swaps&lt;/code&gt; is a first attempt at such an approach.&lt;/p&gt; &#xA;&lt;h2&gt;Preliminary Discussion&lt;/h2&gt; &#xA;&lt;p&gt;To appreciate the necessity of new DEX standards, it first important to understand the deficiencies of the current status-quo:&lt;/p&gt; &#xA;&lt;h3&gt;Current DEX Deficiencies&lt;/h3&gt; &#xA;&lt;p&gt;One consequence of centralized script addresses is the necessity for liquidity pools and LP providers as discrete entities. LPs are a common feature of many DEXes, coming with undesirable properties and corresponding sets of workaround &#34;solutions&#34;. However, these workarounds have issues themselves, as explored here:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Undesirable Property&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Workaround &#34;Solution&#34;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Issues&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Impermanent Loss&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Yield Farming &amp;amp; Concentrated Liquidity&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Medium - Long term unsustainability&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Incomplete or No Delegation Control&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&#xA;    &lt;ul&gt;&#xA;     &lt;li&gt;Asset pool fractionalization&lt;/li&gt;&#xA;     &lt;li&gt;Indirect Delegation via Governance Tokens&lt;/li&gt;&#xA;    &lt;/ul&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&#xA;    &lt;ul&gt;&#xA;     &lt;li&gt;Unfair distribution of Governance tokens &lt;/li&gt;&#xA;     &lt;li&gt;Unavoidable centralization of stake (Major issue for Ouroboros)&lt;/li&gt;&#xA;    &lt;/ul&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Scaling Bottlenecks&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Batchers, Execution/Routing Engines, and/or other middlemen&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Middlemen can take advantage of their position between users and the protocol. Even if MEV is mitigated, more users --&amp;gt; more execution demand --&amp;gt; possible centralization of middlemen if the batchers are not permissionless&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Of course, this is not an exhaustive list, and even if some workarounds can be somewhat effective, the underlying design &lt;em&gt;principles&lt;/em&gt; are suboptimal.&lt;/p&gt; &#xA;&lt;p&gt;The more decoupled delegation control is from the owner, the more distorted Ouroboros&#39; game theory becomes. It is difficult to predict the extent of this distortion, so minimizing it is of critical importance. Additionally, current implementations of order-book style DEXes (which don&#39;t use LPs) still suffer from the scalability challenges of permissioned batchers. No matter how performant a system of batchers is, their resources do &lt;strong&gt;not&lt;/strong&gt; scale in proportion to the number of users unless new batchers can permissionlessly join when there is high demand.&lt;/p&gt; &#xA;&lt;p&gt;All of this is to say that, much like Bittorrent and the CSL-CCL stack, the best p2p protocols are ones that scale in &lt;em&gt;proportion&lt;/em&gt; to the number of users. DEXes are no different.&lt;/p&gt; &#xA;&lt;p&gt;Cardano-Swaps achieves batcher/router-free scalability &lt;em&gt;with&lt;/em&gt; delegation control via a novel combination of user-controlled script addresses and Beacon Tokens (both are expanded upon below).&lt;/p&gt; &#xA;&lt;h3&gt;Programmable Swaps&lt;/h3&gt; &#xA;&lt;p&gt;First proposed by Axo in their original &lt;a href=&#34;https://www.axo.trade/whitepaper.pdf&#34;&gt;whitepaper&lt;/a&gt;, programmable swaps are a more promising design choice than liquidity pools. Swaps are simply UTxOs that may be consumed if and only if the resulting TX outputs satisfy the input script&#39;s logic. Swaps can be fragmented across many user-controlled addresses, so delegation control is maintained. Users then execute swaps from each other&#39;s addresses. Since each swap is atomic and explicitly defined, in aggregate they are the optimal expression of (intra)market sentiment. This design pattern scales naturally, since there must be at &lt;em&gt;least&lt;/em&gt; as many swap addresses as there are users.&lt;/p&gt; &#xA;&lt;p&gt;The challenge now becomes one of indexing: how do users differentiate each others&#39; swap addresses from all other addresses on Cardano, &lt;em&gt;without&lt;/em&gt; relying on a specialized indexer/router? This is where Beacon Tokens come into play.&lt;/p&gt; &#xA;&lt;h3&gt;Beacon Tokens&lt;/h3&gt; &#xA;&lt;p&gt;Beacon Tokens are a (WIP) native token standard that &#34;tag&#34; on-chain data in a way that is efficiently queryable by off-chain APIs. They enable cardano-swaps users to designate their script addresses as &#34;swappable&#34;, such that they stand out in sea of other addresses. DDOS/bloat prevention is achieved by carefully marrying Beacons&#39; minting policies with scripts&#39; spending policies. This is expanded upon in the &lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#specification&#34;&gt;Specification section&lt;/a&gt; below.&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;✅&lt;/span&gt; The novel use of &lt;em&gt;Beacon Tokens&lt;/em&gt; for &#34;tagging&#34; on-chain data can be generalized for many dApps, not just DEXes. More on this in the &lt;a href=&#34;https://github.com/cardano-foundation/CIPs/pull/466&#34;&gt;Beacon Token CIP&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Putting this all together, we finally have:&lt;/p&gt; &#xA;&lt;h3&gt;The Cardano-Swaps Protocol&lt;/h3&gt; &#xA;&lt;p&gt;Cardano-Swaps takes inspiration from Axo&#39;s programmable swaps design, adds delegation control as a foundational feature, and, through the use of Beacon Tokens, removes the need for specialized indexers. The only remaining bottleneck is the querying capacity of existing off-chain APIs, such as Blockfrost or Koios. (For users with powerful enough hardware, even this is not a limitation, as they can run their own API database).&lt;/p&gt; &#xA;&lt;p&gt;Here are some of the key features of Cardano-Swaps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Full Custody&lt;/strong&gt; - users always maintain full spending &lt;em&gt;and&lt;/em&gt; delegation control over their assets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Natural Concurrency&lt;/strong&gt; - throughput scales &lt;em&gt;with&lt;/em&gt; the number of users. No specialized batchers/indexers required.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Composable Swaps&lt;/strong&gt; - many swaps can be fulfilled in a single transaction by &#34;chaining&#34; swap logic&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Emergent Liquidity&lt;/strong&gt; - arbitragers are incentivized to spread liquidity to all trading pairs&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Zero Slippage&lt;/strong&gt; - minimum swap prices are explicitly defined&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;No Superfluous &#34;DEX&#34; Tokens&lt;/strong&gt; - ADA is all you need to pay for TX fees.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Democratic Upgradability&lt;/strong&gt; - users choose if/when to use new contracts.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Frontend Agnosticism&lt;/strong&gt; - relatively straightforward integration with existing frontends (i.e. wallets)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Some of these features are explained further in the &lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/#Discussion%20&amp;amp;%20FAQ&#34;&gt;Discussion section&lt;/a&gt; below&lt;/p&gt; &#xA;&lt;h2&gt;Specification&lt;/h2&gt; &#xA;&lt;h3&gt;Personal Contracts&lt;/h3&gt; &#xA;&lt;p&gt;Cardano addresses are made up of both a payment credential and a staking credential. As long as the staking credential is unique to the user, delegation control over the address is maintained. Cardano-swaps leverages this duality by giving users addresses that are composed of the same spending scripts (per swap pair) and unique staking credentials. The spending credential is implemented in a way that gives the staking credential authority over all owner related actions, besides the actual swap execution.&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;❗&lt;/span&gt; To force the use of a staking credential, it is not possible to mint a beacon token to an address without a staking credential.&lt;/p&gt; &#xA;&lt;h3&gt;Minting and Using Beacon Tokens&lt;/h3&gt; &#xA;&lt;p&gt;Beacon Tokens are used to tag &lt;code&gt;cardano-swaps&lt;/code&gt; addresses so they are readily queryable via an off-chain API, such as Koios or Blockfrost. It is relatively straightforward to find all addresses that contain a specific native token. Here are some examples:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Task&lt;/th&gt; &#xA;   &lt;th&gt;Koios Api&lt;/th&gt; &#xA;   &lt;th&gt;Blockfrost Api&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Addresses with a beacon&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://api.koios.rest/#get-/asset_address_list&#34;&gt;api&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://docs.blockfrost.io/#tag/Cardano-Assets/paths/~1assets~1%7Basset%7D~1addresses/get&#34;&gt;api&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;UTxOs at the address&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://api.koios.rest/#post-/address_info&#34;&gt;api&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://docs.blockfrost.io/#tag/Cardano-Addresses/paths/~1addresses~1%7Baddress%7D~1utxos/get&#34;&gt;api&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The UTxO query also returns which UTxOs contain reference scripts, allowing users to execute their swaps.&lt;/p&gt; &#xA;&lt;p&gt;Technically, all native tokens can be used as beacons like this but this feature is usually not the intended one. The name &lt;em&gt;Beacon Token&lt;/em&gt; refers to any native token whose only purpose is to act as a tag/beacon.&lt;/p&gt; &#xA;&lt;h4&gt;Beacon Tokens with Cardano-Swaps&lt;/h4&gt; &#xA;&lt;p&gt;Every trading pair gets its own spending script. This is accomplished with the help of an extra parameter. Here is the data type of that extra parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Haskell&#34;&gt;data SwapConfig = SwapConfig&#xA;  { swapOffer :: (CurrencySymbol,TokenName)&#xA;  , swapAsk :: (CurrencySymbol,TokenName)&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Each combination of &lt;code&gt;swapOffer&lt;/code&gt; and &lt;code&gt;swapAsk&lt;/code&gt; results in a different spending script. All spending scripts are identical except for this extra parameter. The hash of the resulting spending script is then used as an extra parameter to the beacon policy. &lt;em&gt;All beacon policies are identical except for this extra parameter.&lt;/em&gt; As a result, every &lt;code&gt;SwapConfig&lt;/code&gt; will also have its own unique beacon policy.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Since the beacon policy-id itself carries all the information needed to determine which trading pair is being used, every beacon uses the empty token name - this is enforced by the minting policy.&lt;/p&gt; &#xA;&lt;h4&gt;Minting Requirements&lt;/h4&gt; &#xA;&lt;p&gt;Minting beacons for &lt;code&gt;cardano-swaps&lt;/code&gt; is a tightly controlled process. In order to mint beacons, &lt;strong&gt;all of the following must be true&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Only one beacon is minted per Tx.&lt;/li&gt; &#xA; &lt;li&gt;The minted beacon uses an empty token name.&lt;/li&gt; &#xA; &lt;li&gt;The beacon is minted to an address protected by the &lt;code&gt;cardano-swaps&lt;/code&gt; spending script for a particular trading pair.&lt;/li&gt; &#xA; &lt;li&gt;The beacon is minted to an address with a staking credential (either a pubkey or a script).&lt;/li&gt; &#xA; &lt;li&gt;The beacon is stored in the UTxO containing the reference script of the spending script for that trading pair.&lt;/li&gt; &#xA; &lt;li&gt;The datum of the output containing the beacon must have the proper beacon symbol.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Once the beacon is minted to the swap address, the spending script does not allow consuming the beacon&#39;s UTxO &lt;em&gt;unless&lt;/em&gt; the beacon is being burned. This is done to prevent beacons from being sent to unrelated addresses.&lt;/p&gt; &#xA;&lt;h4&gt;Burning Requirements&lt;/h4&gt; &#xA;&lt;p&gt;Since minting and spending beacons are so heavily controlled, there is no reason to regulate burning. Burning is always allowed as long as the burn redeemer is only used to burn beacons.&lt;/p&gt; &#xA;&lt;h4&gt;Querying the Beacon Tokens&lt;/h4&gt; &#xA;&lt;p&gt;Below is an example response from querying the beacon tokens:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;[&#xA;  {&#xA;    &#34;assets&#34;: [&#xA;      {&#xA;        &#34;asset&#34;: &#34;lovelace&#34;,&#xA;        &#34;quantity&#34;: 150000000&#xA;      }&#xA;    ],&#xA;    &#34;price_denominator&#34;: 1,&#xA;    &#34;price_numerator&#34;: 1,&#xA;    &#34;swap_address&#34;: &#34;addr_test1xqc8dluz63hw3z5jf38nj8vc8hr6w3zffqype75rwzhfqtmgzy4wvf0pv6q4z499a70zm6sadjzwc0w6xx622s2fx30qsq8ppj&#34;,&#xA;    &#34;swap_ref_script_id&#34;: &#34;325f5c8028f867c3dfdcacf750cab0fb43b2ad82d8d606c5b94142a5eb4fd58f#0&#34;,&#xA;    &#34;utxo_id&#34;: &#34;325f5c8028f867c3dfdcacf750cab0fb43b2ad82d8d606c5b94142a5eb4fd58f#1&#34;&#xA;  }&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Only one UTxO was found, containing only Lovelace (ADA). Notice how this UTxO&#39;s required reference script ID was also returned. This response has everything a user needs to swap with the address.&lt;/p&gt; &#xA;&lt;h4&gt;Generalizing Beacon Tokens&lt;/h4&gt; &#xA;&lt;p&gt;While these beacons are used to &#34;tag&#34; all necessary information for engaging in swaps (reference script UTxOs and available swap UTxOs), they can be used for tagging ANY on-chain data w.r.t. to:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The address containing the Beacon&lt;/li&gt; &#xA; &lt;li&gt;The UTxO containing the Beacon&lt;/li&gt; &#xA; &lt;li&gt;The information for any transaction(s) the Beacon has ever been in&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For example, it is possible to query the metadata of all transactions the Beacon was ever a part of. This can be used to create an easily queryable &amp;amp; trustless &#34;metadata history&#34; trail. Here are some examples:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Blockfrost&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Koios&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;TX history&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://docs.blockfrost.io/#tag/Cardano-Assets/paths/~1assets~1%7Basset%7D~1transactions/get&#34;&gt;api&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://api.koios.rest/#get-/asset_txs&#34;&gt;api&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;TX metadata&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://docs.blockfrost.io/#tag/Cardano-Transactions/paths/~1txs~1%7Bhash%7D~1metadata/get&#34;&gt;api&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://api.koios.rest/#post-/tx_metadata&#34;&gt;api&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Beacon Tokens make all of this information readily queryable; no configuration of the tokens is necessary. This can be used in a wide variety of dApps - &lt;strong&gt;the only requirement is that the beacon token is unique for each &lt;em&gt;kind&lt;/em&gt; of datatype.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;The DEX&#39;s Inline Datum&lt;/h3&gt; &#xA;&lt;p&gt;For users to see each others&#39; asking prices, all datums for the DEX must be inline datums. &lt;code&gt;cardano-swaps&lt;/code&gt; contracts enforce this behavior whenever possible. Here is the datum type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Haskell&#34;&gt;-- | Swap Datum&#xA;type Price = Rational -- ^ askedAsset/offeredAsset&#xA;data SwapDatum = SwapDatum&#xA;  {&#xA;    swapPrice :: Price,&#xA;    swapBeacon :: Maybe CurrencySymbol -- ^ Policy id for the DEX&#39;s beacon token&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;swapPrice&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;Rational&lt;/code&gt; type is a fraction (decimal types do not work properly). Fortunately, there is no loss of functionality from using fractions. Users are able to supply decimals to &lt;code&gt;cardano-swaps&lt;/code&gt; and it will properly convert the decimal to &lt;code&gt;Rational&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;All prices in Cardano-Swaps are local (similar to limit orders in an order-book exchange). The price is always askedAsset/offeredAsset. For example, if $ADA is being offered for $DUST at a price of 1.5 (converted to 3/2), the contract requires that 3 $DUST are deposited for every 2 $ADA removed from the swap address. Ratios &amp;lt; 3/2 will fail, while ratios &amp;gt;= 3/2 will pass.&lt;/p&gt; &#xA;&lt;p&gt;When engaging in swaps, it is only necessary that the desired swap ratio is met; &lt;strong&gt;not all assets at the swap address or UTxO must be swapped.&lt;/strong&gt; For example, if there is 100 ADA in a swap address requesting 2:1 for DUST, a user may swap 20 ADA, as long as they return 80 ADA and 10 DUST in the same TX.&lt;/p&gt; &#xA;&lt;p&gt;Since every user explicitly defines their desired swap ratios, oracles are not required. The &#34;global&#34; price naturally emerges where the local bids and asks meet - just like an order-book.&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;❗&lt;/span&gt; A zero or negative price means the assets are effectively free. A malicious user may deposit a UTxO with a negative price in the datum in order to steal user funds. To prevent this, swaps will fail unless all prices are greater than 0.&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;❗&lt;/span&gt; For user-friendliness, when ADA is part of the trading pair, the price &lt;strong&gt;MUST&lt;/strong&gt; be in units of ADA. The swap contract will convert to Lovelace when necessary. If Lovelace units are entered, conversion will still take place and produce undesired behavior.&lt;/p&gt; &#xA;&lt;h4&gt;swapBeacon&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;swapBeacon&lt;/code&gt; field for the datum prevents misuse of beacons. The contract forces all assets with the supplied policy-id to be burned instead of being withdrawn. This ensures the beacons can never be found in an address unrelated to &lt;code&gt;cardano-swaps&lt;/code&gt;. &lt;strong&gt;If the wrong policy id is supplied, assets will be locked forever.&lt;/strong&gt; Only the UTxO containing the beacon needs to use &lt;code&gt;Just beaconSym&lt;/code&gt;; all active swaps can use &lt;code&gt;Nothing&lt;/code&gt; for this field. &lt;code&gt;cardano-swaps&lt;/code&gt; CLI handles this part of the datum automatically, preventing accidental locking.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Swap Contract Logic&lt;/h3&gt; &#xA;&lt;p&gt;Swap contracts have three possible actions, a.k.a. redeemers:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;Close&lt;/code&gt; - withdraw any UTxO located at the swap address and burn the beacon&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Update&lt;/code&gt; - update the asking price for UTxOs at the swap address&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Swap&lt;/code&gt; - executing a swap with assets at the swap address&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Only the owner (signified by the address&#39; staking credential) is allowed to use the &lt;code&gt;Close&lt;/code&gt; or &lt;code&gt;Update&lt;/code&gt; redeemers. Anyone can use the &lt;code&gt;Swap&lt;/code&gt; redeemer.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Close&lt;/code&gt; Redeemer&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;Close&lt;/code&gt; redeemer allows the owner (signified by the address&#39; staking credential) to recover the deposit stored with the reference script, and make the address undiscoverable by burning the beacon. &lt;strong&gt;In order to reclaim the deposit, the beacon must be burned.&lt;/strong&gt; The requirements for successfully using the &lt;code&gt;Close&lt;/code&gt; redeemer are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;All beacons among Tx inputs must be burned.&lt;/li&gt; &#xA; &lt;li&gt;The staking credential must signal approval: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;pubkey must sign&lt;/li&gt; &#xA;   &lt;li&gt;script must be executed in the same tx&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Any new outputs to the address must contain the proper datum: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;swapPrice&lt;/code&gt; &amp;gt; 0&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;swapBeacon&lt;/code&gt; == Nothing&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;&lt;code&gt;Update&lt;/code&gt; Redeemer&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;Update&lt;/code&gt; redeemer allows the owner to change the asking price of their position(s) by changing the inline datum attached of associated UTxOs. This action includes checks to ensure the new datum is properly used. The requirements for a successful update are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;No beacons among tx inputs.&lt;/li&gt; &#xA; &lt;li&gt;The staking credential must signal approval: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;pubkey must sign&lt;/li&gt; &#xA;   &lt;li&gt;script must be executed in the same tx&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;All new outputs to the address must contain the proper datum: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;swapPrice&lt;/code&gt; &amp;gt; 0&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;swapBeacon&lt;/code&gt; == Nothing&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The first requirement also means that the datum attached to the beacon&#39;s reference script &lt;em&gt;cannot&lt;/em&gt; be updated. This is fine since that datum is never allowed in swaps.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Swap&lt;/code&gt; Redeemer&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;Swap&lt;/code&gt; redeemer checks all of the assets leaving the swap address and all of the assets entering the swap address. For a successful swap, all of the following must be true:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;No swap input utxos have reference scripts - this also protects the beacon.&lt;/li&gt; &#xA; &lt;li&gt;All swap input prices are &amp;gt; 0.&lt;/li&gt; &#xA; &lt;li&gt;All outputs to the swap address contain the proper datum: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;swapPrice&lt;/code&gt; == weighted avg price of all swap inputs&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;swapBeacon&lt;/code&gt; == Nothing&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Only the offered asset (as defined in &lt;code&gt;SwapConfig&lt;/code&gt;) is leaving the swap address.&lt;/li&gt; &#xA; &lt;li&gt;QuantityOfferedAssetTaken * weighted average price &amp;lt;= quantityAskedAssetGiven&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Custom error messages are included to help troubleshoot why a swap failed. The weighted average price must match exactly what the swap contract calculates. To help with this, &lt;code&gt;cardano-swaps&lt;/code&gt; can calculate the weighted price for you. The function &lt;code&gt;cardano-swaps&lt;/code&gt; uses is the same function the on-chain swap contract uses.&lt;/p&gt; &#xA;&lt;h2&gt;Features Discussion&lt;/h2&gt; &#xA;&lt;p&gt;Here are some of the most impactful features of Cardano-Swaps:&lt;/p&gt; &#xA;&lt;h3&gt;Delegation Control&lt;/h3&gt; &#xA;&lt;p&gt;Since each user has their own swap address, the process of delegation is identical to that of a normal address (either by staking key or staking script).&lt;/p&gt; &#xA;&lt;p&gt;Check out the &lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/GettingStarted.md#delegate-the-swap-address&#34;&gt;delegation section&lt;/a&gt; of &lt;a href=&#34;https://raw.githubusercontent.com/fallen-icarus/cardano-swaps/main/GettingStarted.md&#34;&gt;GettingStarted.md&lt;/a&gt; for an example using a staking pubkey.&lt;/p&gt; &#xA;&lt;h3&gt;Composable Atomic Swaps&lt;/h3&gt; &#xA;&lt;p&gt;Since multiple swaps are combinable into a single transaction, any arbitrarily complex swap transaction can be created. The only limit is the size of the transaction itself.&lt;/p&gt; &#xA;&lt;p&gt;Do you want to convert 10 ADA into 5 DUST and 5 AGIX? No problem! This can be done in one transaction. What about converting 10 ADA, 5 DUST, and 3 WMT into 16 AGIX and 1 of your favorite NFTs? Piece of cake!&lt;/p&gt; &#xA;&lt;p&gt;By composing these swaps in one transaction, many-to-many multi-asset swaps are possible. The only limits are the maximum transaction limits for Cardano.&lt;/p&gt; &#xA;&lt;h3&gt;Emergent Liquidity&lt;/h3&gt; &#xA;&lt;p&gt;Liquidity in cardano-swaps is an &lt;em&gt;emergent&lt;/em&gt; property; it arises from the (healthy) incentive for arbitragers to engage in complex swap transactions. Discrete liquidity pools are unnecessary.&lt;/p&gt; &#xA;&lt;h4&gt;The Contrived Example&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Txt&#34;&gt;Alice has 10 ADA in her swap address and is willing to swap them for 0.5 AGIX/ADA.&#xA;Bob has 10 AGIX in his swap address and is willing to swap them for 1 ADA/AGIX.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, Charlie can profitably arbitrage and fulfill both of these swaps like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Txt&#34;&gt;Charlie looks up all swap addresses willing to swap AGIX/ADA. Charlie finds Alice&#39;s address.&#xA;Charlie looks up all swap addresses willing to swap ADA/AGIX. Charlie finds Bob&#39;s address.&#xA;Using Bob&#39;s reference script, Charlie gives Bob 10 ADA and receives 10 AGIX.&#xA;Using Alice&#39;s reference script, Charlie gives Alice 5 AGIX and receives 10 ADA.&#xA;Charlie now has his original 10 ADA plus an additional 5 AGIX.&#xA;This all occurs in one transaction where Charlie pays the transaction fee.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On net, Charlie pays the transaction fees and receives 5 AGIX in return, while both Alice and Bob&#39;s swaps are fulfilled.&lt;/p&gt; &#xA;&lt;h4&gt;The Realistic Example&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Txt&#34;&gt;Alice has 10 ADA in her swap address and is willing to swap them for 1 DUST/ADA.&#xA;Bob has 10 DUST in his swap address and is willing to swap them for 0.5 AGIX/DUST.&#xA;Charlie has 10 AGIX in his swap address and is willing to swap them for 1 HOSKY/AGIX.&#xA;Mike has 10 HOSKY in his swap address and is willing to swap them for 1 ADA/HOSKY.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, Sarah can profitably arbitrage and fulfill all of these swaps like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Txt&#34;&gt;Sarah looks up all swap addresses willing to swap DUST/ADA. Sarah finds Alice&#39;s address.&#xA;Sarah looks up all swap addresses willing to swap AGIX/DUST. Sarah finds Bob&#39;s address.&#xA;Sarah looks up all swap addresses willing to swap HOSKY/AGIX. Sarah finds Charlie&#39;s address.&#xA;Sarah looks up all swap addresses willing to swap ADA/HOSKY. Sarah finds Mike&#39;s address.&#xA;Sarah gives Mike 10 ADA and receives 10 HOSKY.&#xA;Sarah gives Charlie 10 HOSKY and receives 10 AGIX.&#xA;Sarah gives Bob 5 AGIX and receives 10 DUST.&#xA;Sarah gives Alice 10 DUST and receives 10 ADA.&#xA;Sarah now has her original 10 ADA plus an additional 5 AGIX.&#xA;This all occurs in one transaction where Sarah pays the transaction fee.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On net, Sarah pays the transaction fees and receives 5 AGIX in return, while four swaps are fulfilled.&lt;/p&gt; &#xA;&lt;h4&gt;Liquidity naturally flows to the less liquid pairs&lt;/h4&gt; &#xA;&lt;p&gt;As shown in the realistic example, Sarah fulfills &lt;em&gt;both&lt;/em&gt; the AGIX/DUST swap and the HOSKY/AGIX swap by &#34;passing through&#34; those pairs on her way back to ADA. As long as the entry and exit pairs (in this case ADA/HOSKY and DUST/ADA) have enough liquidity, arbitragers can spread that liquidity into less liquid swap pairs.&lt;/p&gt; &#xA;&lt;p&gt;As a bonus, &lt;strong&gt;the very nature of &lt;em&gt;illiquidity&lt;/em&gt; implies great arbitrage opportunities&lt;/strong&gt;. The more illiquid a swap pair, the greater the potential arbitrage profits. Participating in arbitrage is permissionless, so anyone can design their own algorithms for finding the most profitable &#34;path&#34; through the currently available swaps.&lt;/p&gt; &#xA;&lt;h3&gt;Democratic Upgradability&lt;/h3&gt; &#xA;&lt;p&gt;Upgrades to &lt;code&gt;cardano-swaps&lt;/code&gt; can propagate through the ecosystem of users in a similarly democratic fashion as SPOs upgrading their pools to a new version of &lt;code&gt;cardano-node&lt;/code&gt;. Since users can close their swaps at any time, whenever there is a potential upgrade, users can choose to close their current swaps and recreate them with the new contracts. The main challenge here is the bifurcation of liquidity that occurs during upgrade periods. However, the more users there are and the more overall liquidity there is, the more this issue is minimized.&lt;/p&gt; &#xA;&lt;h3&gt;Frontend Agnosticism&lt;/h3&gt; &#xA;&lt;p&gt;Thanks to the query-ability of beacon tokens, it is trivial for any frontend to integrate with Cardano-Swaps. For example, any wallet can integrate &lt;code&gt;cardano-swaps&lt;/code&gt; by adding support for querying the beacon tokens. They can also add their own user friendly way to create and use swaps. The only requirement is that all frontends/users agree to use the same beacon token standard. There is no need for risky extensions or dedicated frontends.&lt;/p&gt; &#xA;&lt;h2&gt;Benchmarks and Fee Estimations (YMMV)&lt;/h2&gt; &#xA;&lt;p&gt;Basic benchmarking tests were done to determine the maximum number of inputs or outputs that the spending script can handle in one transaction.&lt;/p&gt; &#xA;&lt;p&gt;Currently, Plutus is limited in that a spending script is always executed once for &lt;em&gt;every&lt;/em&gt; script input, &lt;strong&gt;even if the inputs come from the same script address.&lt;/strong&gt; So if there are 5 inputs from one of the script addresses, the spending script will be executed 5 times. &lt;strong&gt;The latter 4 are completely redundant in this situation.&lt;/strong&gt; These redundant executions impact the maximum number of inputs and outputs that can fit in one transaction. There is a Cardano Problem Statement (CPS) looking to address this (&lt;a href=&#34;https://github.com/cardano-foundation/CIPs/pull/418&#34;&gt;here&lt;/a&gt;). Nonetheless, basic benchmarking results are shown here:&lt;/p&gt; &#xA;&lt;h3&gt;Creating a Live Address&lt;/h3&gt; &#xA;&lt;p&gt;For opening a new address, I was successfully able to mint the beacon, store the reference script, and create 80+ new swap positions in one transaction.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Number of New Swaps&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Tx Fee&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.647711 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;10&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.697339 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;15&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.747768 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;20&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.797797 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;25&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.847869 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Closing a Live Address&lt;/h3&gt; &#xA;&lt;p&gt;For closing a new address, I was successfully able to burn the beacon, remove the reference script, and close 8 open positions in one transaction.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Number of Closed Swaps&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Tx Fee&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.490071 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.574382 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.674041 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.789050 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.919407 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;6&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.065113 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;7&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.226169 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.402573 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Updating Open Swaps&lt;/h3&gt; &#xA;&lt;p&gt;For updating open swaps, I was successfully able to update 5 positions and recreate them in one transaction. If you consolidate your open positions into one output, you may be able to update more in one transaction.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Number of Swaps Updated&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Tx Fee&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.250309 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.381332 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.574544 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.829945 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.147533 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Swapping Assets&lt;/h3&gt; &#xA;&lt;p&gt;For swapping assets, I was successfully able to chain together 4 swap utxos before the redundant executions caused the transaction to exceed the memory limit.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Number of Swaps Chained&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Tx Fee&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.313006 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.511202 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0.772815 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.114271 ADA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h4&gt;If all users share a spending script, how are their assets protected?&lt;/h4&gt; &#xA;&lt;p&gt;The spending script gets the staking credential from the address of the UTxO being spent at run-time. When an owner related action is being performed (closing or updating positions), the spending script requires that the staking credential &#34;signals approval&#34; of the action:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If the staking credential is a pubkey, then the staking pubkey must sign the transaction.&lt;/li&gt; &#xA; &lt;li&gt;If the staking credential is a script, then the script must be executed in the same transaction.&lt;/li&gt; &#xA; &lt;li&gt;the staking credential effectively &lt;em&gt;becomes&lt;/em&gt; the &#34;owner&#34; for all actions except for the actual swap execution, in which case the spending credential is used directly.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is possible to execute a staking script even if 0 ADA is withdrawn from a reward address. The only requirement to use staking scripts like this is that the associated stake address must be registered and delegated. Stake addresses can be utilized this way as soon as the registration+delegation transaction is added to the chain. There is no epoch waiting-period.&lt;/p&gt; &#xA;&lt;h4&gt;Why not just give each user their own spending script?&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;cardano-swaps&lt;/code&gt; relies on the usage of &lt;a href=&#34;#specification/##Beacon%20Tokens&#34;&gt;beacon tokens&lt;/a&gt; to &#34;tag&#34; addresses, which demarcates them as &lt;em&gt;distinct&lt;/em&gt; for efficient off-chain querying/aggregation. However, &lt;strong&gt;address distinction is impossible if each script address is composed of completely unique credentials.&lt;/strong&gt; In other words, for Beacon Tokens to work properly, there must be a clear distinction between addresses participating in a given dApp and all other addresses. &lt;code&gt;cardano-swaps&lt;/code&gt; leverages the dual payment-staking credentials of Cardano addresses to maintain address-distinction (shared spending scripts) without sacrificing self-custody (unique staking keys/scripts). For further clarification, refer to the &lt;a href=&#34;https://github.com/cardano-foundation/CIPs/pull/466&#34;&gt;Beacon Token CIP&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;📌&lt;/span&gt; v1.0.0 of cardano-swaps used unique spending scripts; you can read about the limitations in the v1.0.0 commit README.&lt;/p&gt; &#xA;&lt;h4&gt;If all users have direct access to the spending script for that trading pair, why are reference scripts used?&lt;/h4&gt; &#xA;&lt;p&gt;To disincentivize beacon bloat.&lt;/p&gt; &#xA;&lt;p&gt;The reason is to incentivize users to actually use the DEX as intended. If there were no deposits, users can create a live address with a beacon token and then just leave it open even if they aren&#39;t actually using the address anymore (like if there are no swappable assets in it). This &#34;zombie&#34; address will still appear when querying the beacon tokens even though other users can&#39;t actually do anything with it. By requiring the deposits, users are incentivized to close unused addresses in order to get the deposits back.&lt;/p&gt; &#xA;&lt;h4&gt;What if two arbitragers compete for the same swap?&lt;/h4&gt; &#xA;&lt;p&gt;Recall the contrived example above. What would happen if Charlie and Mike try to arbitrage it at the same time?&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Charlie and Mike both build their transactions since the UTxOs still exist.&lt;/li&gt; &#xA; &lt;li&gt;Charlie and Mike submit their transaction at the same time.&lt;/li&gt; &#xA; &lt;li&gt;Charlie&#39;s is added to a block first.&lt;/li&gt; &#xA; &lt;li&gt;When Mike&#39;s transaction is then picked to go into a block, the UTxOs no longer exist. The transaction fails without needing to run the swap contracts.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Since Mike&#39;s transaction will fail without needing to run the swap script, Mike&#39;s collateral is safe. Further, the more available swaps there are, the less likely these &#34;collisions&#34; will occur.&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;📌&lt;/span&gt; future iterations of Ouroboros (namely Leios) may allow arbitragers to further limit these collisions by segmenting transactions among sharded mempools.&lt;/p&gt; &#xA;&lt;h4&gt;If Cardano-Swaps reaches mass adoption, won&#39;t TVL on Cardano go down?&lt;/h4&gt; &#xA;&lt;p&gt;Yes. Yes it will. TVL is a silly metric. It is a measure of who can be most inefficient with DeFi capital.&lt;/p&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;The cardano-swaps protocol has all of the desired properties of a highly scalable DEX. Thanks to the use of beacon tokens, decentralization is no longer limited by the design of DEXs. Instead, the limiting factor is now the off-chain querying. However, innovations in this space are still in the early days. The Koios API is an example of a more decentralized off-chain platform. As the technology improves, the decentralization of this protocol will improve as well.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>AntoinePoisson/Haskell-Wolfram</title>
    <updated>2023-03-07T01:37:23Z</updated>
    <id>tag:github.com,2023-03-07:/AntoinePoisson/Haskell-Wolfram</id>
    <link href="https://github.com/AntoinePoisson/Haskell-Wolfram" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Wolfram’s elementary cellular automaton.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Haskell-Wolfram&lt;/h1&gt; &#xA;&lt;h2&gt;Purpose:&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s 2nd year project of Epitech.&lt;br&gt; The goal of this project is to implement Wolfram’s elementary cellular automaton (below) in Haskell.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://i1.wp.com/atlas.wolfram.com/01/01/30/01_01_103_30.gif&#34; alt=&#34;wolframn&#34;&gt;&lt;br&gt; &lt;/p&gt; &#xA;&lt;p&gt;In mathematics and computability theory, an elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors.&lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To build (Stack at least 2.1.3 is mandatory):&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Binaire parameter:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;  –rule : the ruleset to use (ryule 30, rule 90 and rule 110)&#xA;  –start : the generation number at which to start the display. The default value is 0.&#xA;  –lines : the number of lines to display. When homited, the program never stops.&#xA;  –window : the number of cells to display on each line (line width). If even,&#xA;   the central cell is displayed in the next cell on the right. The default value is 80.&#xA;  –move : a translation to apply on the window. If negative, the window is translated to the left.&#xA;   If positive, it’s translated to the right.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example:&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./ wolfram -- rule 110 -- lines 45&#xA;                                               *                                               &#xA;                                              **                                               &#xA;                                             ***                                               &#xA;                                            ** *                                               &#xA;                                           *****                                               &#xA;                                          **   *                                               &#xA;                                         ***  **                                               &#xA;                                        ** * ***                                               &#xA;                                       ******* *                                               &#xA;                                      **     ***                                               &#xA;                                     ***    ** *                                               &#xA;                                    ** *   *****                                               &#xA;                                   *****  **   *                                               &#xA;                                  **   * ***  **                                               &#xA;                                 ***  **** * ***                                               &#xA;                                ** * **  ***** *                                               &#xA;                               ******** **   ***                                               &#xA;                              **      ****  ** *                                               &#xA;                             ***     **  * *****                                               &#xA;                            ** *    *** ****   *                                               &#xA;                           *****   ** ***  *  **                                               &#xA;                          **   *  ***** * ** ***                                               &#xA;                         ***  ** **   ******** *                                               &#xA;                        ** * ******  **      ***                                               &#xA;                       *******    * ***     ** *                                               &#xA;                      **     *   **** *    *****                                               &#xA;                     ***    **  **  ***   **   *                                               &#xA;                    ** *   *** *** ** *  ***  **                                               &#xA;                   *****  ** *** ****** ** * ***                                               &#xA;                  **   * ***** ***    ******** *                                               &#xA;                 ***  ****   *** *   **      ***                                               &#xA;                ** * **  *  ** ***  ***     ** *                                               &#xA;               ******** ** ***** * ** *    *****                                               &#xA;              **      ******   ********   **   *                                               &#xA;             ***     **    *  **      *  ***  **                                               &#xA;            ** *    ***   ** ***     ** ** * ***                                               &#xA;           *****   ** *  ***** *    ********** *                                               &#xA;          **   *  ***** **   ***   **        ***                                               &#xA;         ***  ** **   ****  ** *  ***       ** *                                               &#xA;        ** * ******  **  * ***** ** *      *****                                               &#xA;       *******    * *** ****   ******     **   *                                               &#xA;      **     *   **** ***  *  **    *    ***  **                                               &#xA;     ***    **  **  *** * ** ***   **   ** * ***                                               &#xA;    ** *   *** *** ** ******** *  ***  ******* *                                               &#xA;   *****  ** *** ******      *** ** * **     ***                                               &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Note:&lt;/h2&gt; &#xA;&lt;p&gt;Grade A&lt;br&gt; Epitech Moulinette: 100%&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mzabani/codd</title>
    <updated>2023-03-07T01:37:23Z</updated>
    <id>tag:github.com,2023-03-07:/mzabani/codd</id>
    <link href="https://github.com/mzabani/codd" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Codd helps to apply plain postgres SQL migrations with strong cross-environment consistency checks and atomicity guarantees&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;What is Codd?&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;Codd&lt;/em&gt; is a tool to help teams of developers version-control their PostgreSQL databases locally and for deployment. It provides a few main features:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Plain SQL migrations&lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cat create-animals-table.sql&#xA;CREATE TABLE animals (id SERIAL PRIMARY KEY, popular_name TEXT NOT NULL);&#xA;INSERT INTO animals (popular_name) VALUES (&#39;Dog&#39;), (&#39;Cat&#39;);&#xA;$ codd add create-animals-table.sql&#xA;Migration applied and added to sql-migrations/2022-02-27-23-14-50-create-animals-table.sql&#xA;$ psql -c &#34;SELECT popular_name FROM animals&#34;&#xA; popular_name&#xA;--------------&#xA; Dog&#xA; Cat&#xA;(2 rows)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Extensive schema equality checks&lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ psql -c &#34;ALTER TABLE animals ALTER COLUMN popular_name TYPE VARCHAR(30)&#34;&#xA;ALTER TABLE&#xA;$ codd verify-schema&#xA;[Error] DB and expected schemas do not match. Differing objects and their current DB schemas are: {&#34;schemas/public/tables/animals/cols/popular_name&#34;:[&#34;different-schemas&#34;,{&#34;collation&#34;:&#34;default&#34;,&#34;collation_nsp&#34;:&#34;pg_catalog&#34;,&#34;default&#34;:null,&#34;generated&#34;:&#34;&#34;,&#34;hasdefault&#34;:false,&#34;identity&#34;:&#34;&#34;,&#34;inhcount&#34;:0,&#34;local&#34;:true,&#34;notnull&#34;:true,&#34;order&#34;:2,&#34;privileges&#34;:null,&#34;type&#34;:&#34;varchar&#34;}]}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Applies pending migrations in a single transaction, optionally rolls back on schema mismatch before committing¹&lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ codd up&#xA;[Info] Checking if database &#39;codd-experiments&#39; is accessible with the configured connection string... (waiting up to 5sec)&#xA;[Info] Checking which SQL migrations have already been applied...&#xA;[Info] Parse-checking headers of all pending SQL Migrations...&#xA;[Info] BEGINning transaction&#xA;[Info] Applying 2022-02-27-23-14-50-create-animals-table.sql&#xA;[Info] Applying 2022-02-27-23-30-41-create-people-table.sql&#xA;[Info] Database and expected schemas match.&#xA;[Info] COMMITed transaction&#xA;[Info] All migrations applied to codd-experiments successfully&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Meaningful merge conflicts²&lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git merge branch-with-conflicting-db-migration&#xA;Auto-merging expected-schema/schemas/public/tables/animals/cols/popular_name&#xA;CONFLICT (content): Merge conflict in expected-schema/schemas/public/tables/animals/cols/popular_name&#xA;Automatic merge failed; fix conflicts and then commit the result.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;¹ Some SQL must run without explicit transactions; single-transaction application only works when none of that is present.&lt;br&gt; ² There can be false positives and false negatives in some cases.&lt;/p&gt; &#xA;&lt;!-- vscode-markdown-toc --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/#what-is-codd&#34;&gt;What is Codd?&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/#installing-codd&#34;&gt;Installing Codd&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/#1-self-contained-executable&#34;&gt;1. Self-contained executable&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/#2-nix&#34;&gt;2. Nix&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/#3-docker&#34;&gt;3. Docker&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/#get-codd-up-and-running-in-15-minutes&#34;&gt;Get codd up and running in 15 minutes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/#start-using-codd-with-an-existing-database&#34;&gt;Start using codd with an existing database&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/#safety-considerations&#34;&gt;Safety considerations&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/#frequently-asked-questions&#34;&gt;Frequently Asked Questions&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- vscode-markdown-toc-config&#xA;&#x9;numbering=false&#xA;&#x9;autoSave=true&#xA;&#x9;/vscode-markdown-toc-config --&gt; &#xA;&lt;!-- /vscode-markdown-toc --&gt; &#xA;&lt;h2&gt;Installing Codd&lt;/h2&gt; &#xA;&lt;h3&gt;1. Self-contained executable&lt;/h3&gt; &#xA;&lt;p&gt;If you are on x86_64-linux, the easiest thing is to download our self-contained statically linked executable from &lt;a href=&#34;https://github.com/mzabani/codd/releases&#34;&gt;Github Releases&lt;/a&gt;. If you can&#39;t use that, there are two other installation methods, described below.&lt;/p&gt; &#xA;&lt;h3&gt;2. Nix&lt;/h3&gt; &#xA;&lt;p&gt;This method will install an executable named &lt;code&gt;codd&lt;/code&gt; and make it available in your PATH just like installing from a package manager would. It is a bit more cumbersome to install than with docker but easier to use once installed.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install Nix if you don&#39;t have it yet by using your package manager or following instructions from &lt;a href=&#34;https://nixos.org/download.html&#34;&gt;https://nixos.org/download.html&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;sh &amp;lt;(curl -L https://raw.githubusercontent.com/mzabani/codd/master/nix/install-codd.sh)&lt;/code&gt; to install &lt;em&gt;codd&lt;/em&gt;. If things are compiling and taking too long, you may want to check if you&#39;re a privileged Nix user (otherwise it means our Nix cache is not being used). After installed, just run &lt;code&gt;codd --help&lt;/code&gt; to invoke it for the first time. To uninstall it, run &lt;code&gt;nix-env --uninstall codd&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;3. Docker&lt;/h3&gt; &#xA;&lt;p&gt;You can find up-to-date images of &lt;em&gt;codd&lt;/em&gt; in DockerHub. To run &lt;em&gt;codd&lt;/em&gt; through docker just run &lt;code&gt;docker run --rm mzabani/codd --help&lt;/code&gt;. Invoking &lt;em&gt;codd&lt;/em&gt; this way will often require mounting volumes, specifying UIDs and thus is more bureaucratic than other installation methods.&lt;/p&gt; &#xA;&lt;h2&gt;Get codd up and running in 15 minutes&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s a super quick way to get a taste of &lt;em&gt;codd&lt;/em&gt; if you have postgres running. Let&#39;s first define three required environment variables:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ # codd understands URI or keyword value pairs, e.g. dbname=codd_experiments user=postgres host=localhost&#xA;$ export CODD_CONNECTION=postgres://postgres@localhost/codd_experiments&#xA;$ export CODD_MIGRATION_DIRS=sql-migrations&#xA;$ export CODD_EXPECTED_SCHEMA_DIR=expected-schema&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure you create the &lt;code&gt;sql-migrations&lt;/code&gt; folder. If you&#39;re using docker, it helps to have these environment variables in a &lt;em&gt;.env&lt;/em&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;But the database &lt;code&gt;codd_experiments&lt;/code&gt; doesn&#39;t exist yet, so this connection string will not work. That is not a problem, and we can make &lt;em&gt;codd&lt;/em&gt; &lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/docs/BOOTSTRAPPING.md&#34;&gt;create this database&lt;/a&gt; for us with a migration that overrides the connection string just for itself.&lt;/p&gt; &#xA;&lt;p&gt;Create this file and save it as &lt;code&gt;bootstrap-db.sql&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- codd: no-txn&#xA;-- codd-connection: postgres://postgres@localhost/postgres&#xA;&#xA;CREATE DATABASE codd_experiments;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s a lot to take in. &lt;em&gt;Codd&lt;/em&gt; handles pure SQL migrations but also has some special header comments defined that can make it do special things.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;-- codd: no-txn&lt;/code&gt; header comment specifies that this migration can&#39;t run inside a transaction. Postgres doesn&#39;t allow us to create databases (plus a few other statements) inside transactions, after all.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;-- codd-connection&lt;/code&gt; header comment specifies that this specific migration will run with its own connection string, not with the default one.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can find more about the special migration directives that &lt;em&gt;codd&lt;/em&gt; understands &lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/docs/SQL-MIGRATIONS.md#configurability&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Now add this migration by running one of the two commands below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ # If you installed codd with Nix&#xA;$ codd add bootstrap-db.sql&#xA;&#xA;$ # If you&#39;re using the docker image with a .env file:&#xA;$ docker run --rm -it --env-file .env --network=host --user `id -u`:`id -g` -v &#34;$(pwd):/working-dir&#34; mzabani/codd add bootstrap-db.sql&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The file should now have been timestamped and moved to the &lt;code&gt;sql-migrations&lt;/code&gt; folder. The migration ran and so the &lt;code&gt;codd_experiments&lt;/code&gt; database was created, and schema representation files were written to the &lt;code&gt;expected-schema&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;p&gt;Optionally, explore the &lt;code&gt;expected-schema&lt;/code&gt; folder. You won&#39;t find much yet, but all the files in there reflect existing database objects. That&#39;s how &lt;em&gt;codd&lt;/em&gt; knows if schemas in different environments match and also how multiple developers can add migrations and get warned by merge conflicts if any two people modify the same database object.&lt;/p&gt; &#xA;&lt;p&gt;Just for completeness, let&#39;s now create a table. Write the following to a &lt;code&gt;create-employees-table.sql&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE employee (&#xA;    employee_id SERIAL PRIMARY KEY&#xA;    , employee_name TEXT NOT NULL&#xA;);&#xA;INSERT INTO employee (employee_name) VALUES (&#39;John Doe&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add this migration with &lt;code&gt;codd add&lt;/code&gt; just like you did to the previous one and it will be added and applied.&lt;/p&gt; &#xA;&lt;p&gt;Before we finish this tutorial, some things you might want to do:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;psql into your database and manually create a table there, without a migration. Then run &lt;code&gt;codd verify-schema&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;dropdb codd_experiments&lt;/code&gt; and then &lt;code&gt;codd up&lt;/code&gt; to get a fresh database from the start.&lt;/li&gt; &#xA; &lt;li&gt;Read all the knobs you can configure codd with in &lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/docs/CONFIGURATION.md&#34;&gt;CONFIGURATION.md&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Read &lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/#safety-considerations&#34;&gt;safety considerations&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Start using codd with an existing database&lt;/h2&gt; &#xA;&lt;p&gt;If you already have a database and want to start using &lt;em&gt;codd&lt;/em&gt; without losing it, read &lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/docs/START-USING.md&#34;&gt;START-USING.md&lt;/a&gt;. If you&#39;re running &lt;em&gt;codd&lt;/em&gt; in multiple environments where connection strings can differ between them, &lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/docs/SQL-MIGRATIONS.md#templating-environment-variables-into-migrations&#34;&gt;environment variable templating&lt;/a&gt; might be of assistance.&lt;/p&gt; &#xA;&lt;h2&gt;Safety considerations&lt;/h2&gt; &#xA;&lt;p&gt;We recommend following these instructions closely to catch as many possible issues with your database setup/management as possible.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Never merge code that has been tested without &lt;code&gt;master&lt;/code&gt; merged into it. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;There are non-conflicting changes which can break your App. One example is one developer removes a column and another developer writes a new query using that column. Only a test could catch this.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Always run &lt;code&gt;codd up --strict-check&lt;/code&gt; on CI because it&#39;s a good place to be strict.&lt;/li&gt; &#xA; &lt;li&gt;After running &lt;code&gt;codd up --strict-check&lt;/code&gt; on CI, make sure &lt;code&gt;codd verify-schema&lt;/code&gt; doesn&#39;t error. It might seem redundant because &lt;code&gt;codd up --strict-check&lt;/code&gt; verifies schemas, but &lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/docs/DATABASE-EQUALITY.md#delayed-effect-in-pg_catalog&#34;&gt;there are edge cases&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Read about what &lt;em&gt;codd&lt;/em&gt; &lt;strong&gt;cannot do&lt;/strong&gt; in &lt;a href=&#34;https://raw.githubusercontent.com/mzabani/codd/master/docs/DATABASE-EQUALITY.md#delayed-effect-in-pg_catalog&#34;&gt;DATABASE-EQUALITY.md&lt;/a&gt;. This will also give you another idea about how far &lt;em&gt;codd&lt;/em&gt; is willing to go to ensure your schema is the same across environments.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Frequently Asked Questions&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;h3&gt;Why does taking and restoring a database dump affect my expected codd schema?&lt;/h3&gt; &lt;code&gt;pg_dump&lt;/code&gt; does not dump all of the schema state that &lt;em&gt;codd&lt;/em&gt; checks. A few examples include (at least with PG 13) role related state, the database&#39;s default transaction isolation level and deferredness, among possibly others. So check that it isn&#39;t the case that you get different schemas when that happens. We recommend using &lt;code&gt;pg_dumpall&lt;/code&gt; to preserve more when possible instead. If you&#39;ve checked with &lt;code&gt;psql&lt;/code&gt; and everything looks to be the same please report a bug in &lt;em&gt;codd&lt;/em&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>