<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-07-06T01:30:55Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>expipiplus1/vulkan</title>
    <updated>2024-07-06T01:30:55Z</updated>
    <id>tag:github.com,2024-07-06:/expipiplus1/vulkan</id>
    <link href="https://github.com/expipiplus1/vulkan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell bindings for Vulkan&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/expipiplus1/vulkan/main/haskell-vulkan.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Slightly high level Haskell bindings to the Vulkan graphics API.&lt;/p&gt; &#xA;&lt;p&gt;Join us on Matrix at &lt;a href=&#34;https://matrix.to/#/#vulkan:monoid.al?via=monoid.al&amp;amp;via=matrix.org&amp;amp;via=nordgedanken.dev&#34;&gt;#vulkan:monoid.al&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;These bindings present an interface to Vulkan which looks like more idiomatic Haskell and which is much less verbose than the C API. Nevertheless, it retains access to all the functionality. If you find something you can do in the C bindings but not in these high level bindings please raise an issue.&lt;/p&gt; &#xA;&lt;p&gt;Practically speaking this means:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;No fiddling with &lt;code&gt;vkGetInstanceProcAddr&lt;/code&gt; or &lt;code&gt;vkGetDeviceProcAddr&lt;/code&gt; to get function pointers, this is done automatically on instance and device creation&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/expipiplus1/vulkan/main/#fun-ptr&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;No setting the &lt;code&gt;sType&lt;/code&gt; member, this is done automatically.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;No passing length/pointer pairs for arrays, &lt;code&gt;Vector&lt;/code&gt; is used instead&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/expipiplus1/vulkan/main/#opt-vec&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;No passing pointers for return values, this is done for you and multiple results are returned as elements of a tuple.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;No checking &lt;code&gt;VkResult&lt;/code&gt; return values for failure, a &lt;code&gt;VulkanException&lt;/code&gt; will be thrown if a Vulkan command returns an error &lt;code&gt;VkResult&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;No manual memory management for command parameters or Vulkan structs. You&#39;ll still have to manage buffer and image memory yourself however.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Package structure&lt;/h2&gt; &#xA;&lt;p&gt;Types and functions are placed into modules according to the &lt;code&gt;features&lt;/code&gt; and &lt;code&gt;extensions&lt;/code&gt; portions of the specification. As these sections only mention functions, a best guess has to be made for types. Types and constants are drawn in transitively according to the dependencies of the functions.&lt;/p&gt; &#xA;&lt;p&gt;It should be sufficient to import &lt;code&gt;Vulkan.CoreXX&lt;/code&gt; along with &lt;code&gt;Vulkan.Extensions.{whatever extensions you want}&lt;/code&gt;. You might want to import &lt;code&gt;Vulkan.Zero&lt;/code&gt; too.&lt;/p&gt; &#xA;&lt;p&gt;These bindings are intended to be imported qualified and do not feature the &lt;code&gt;Vk&lt;/code&gt; prefixes on commands, structures, members or constants.&lt;/p&gt; &#xA;&lt;h2&gt;Things to know&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Documentation is included more or less verbatim from the Vulkan C API documentation. The parameters it references might not map one-to-one with what&#39;s in these bindings. It should be obvious in most cases what it&#39;s trying to say. If part of the documentation is misleading or unclear with respect to these Haskell bindings please open an issue and we can special case a fix.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The haddock documentation can be browsed on Hackage or &lt;a href=&#34;http://expipiplus1.github.io/vulkan/&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Parameters are named with the &lt;code&gt;:::&lt;/code&gt; operator where it would be useful; this operator simply ignores the string on the left.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There exists a &lt;code&gt;Zero&lt;/code&gt; type class defined in &lt;a href=&#34;https://raw.githubusercontent.com/expipiplus1/vulkan/main/src/Vulkan/Zero.hs&#34;&gt;Vulkan.Zero&lt;/a&gt;. This is a class for initializing values with all zero contents and empty arrays. It&#39;s very handy when initializing structs to use something like &lt;code&gt;zero { only = _, members = _, i = _, care = _, about = _ }&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The library is compiled with &lt;code&gt;-XStrict&lt;/code&gt; so expect all record members to be strict (and unboxed when they&#39;re small)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Calls to Vulkan are marked as &lt;code&gt;unsafe&lt;/code&gt; by default to reduce FFI overhead.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This can be changed by setting the &lt;code&gt;safe-foreign-calls&lt;/code&gt; flag.&lt;/li&gt; &#xA;   &lt;li&gt;It means that Vulkan functions are unable to safely call Haskell code. See the &lt;a href=&#34;https://wiki.haskell.org/Foreign_Function_Interface#Unsafe_calls&#34;&gt;Haskell wiki&lt;/a&gt; for more information. This is important to consider if you want to write allocation or debug callbacks in Haskell.&lt;/li&gt; &#xA;   &lt;li&gt;It&#39;s also means that the garbage collector will not run while these calls are in progress. For some blocking functions (those which can return &lt;code&gt;VK_TIMEOUT&lt;/code&gt; and those with &lt;code&gt;wait&lt;/code&gt; in the name) a &lt;code&gt;safe&lt;/code&gt; version is also provided with the &lt;code&gt;Safe&lt;/code&gt; suffix.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;As encouraged by the Vulkan user guide, commands are linked dynamically (with the sole exception of &lt;code&gt;vkGetInstanceProcAddr&lt;/code&gt;).&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The function pointers are attached to any dispatchable handle to save you the trouble of passing them around.&lt;/li&gt; &#xA;   &lt;li&gt;The function pointers are retrieved by calling &lt;code&gt;vkGetInstanceProcAddr&lt;/code&gt; and &lt;code&gt;vkGetDeviceProcAddr&lt;/code&gt;. These are stored in two records &lt;code&gt;InstanceCmds&lt;/code&gt; and &lt;code&gt;DeviceCmds&lt;/code&gt; which store instance level and device level commands respectively. These tables can be initialized with the &lt;code&gt;initInstanceCmds&lt;/code&gt; and &lt;code&gt;initDeviceCmds&lt;/code&gt; found in &lt;a href=&#34;https://raw.githubusercontent.com/expipiplus1/vulkan/main/src/Vulkan/Dynamic.hs&#34;&gt;Vulkan.Dynamic&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There are nice &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;Show&lt;/code&gt; instances for the enums and bitmasks. These will, where possible, print and parse the pattern synonyms. For example one can do the following:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; read @COMPARE_OP &#34;COMPARE_OP_LESS&#34;&#xA;COMPARE_OP_LESS&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Make sure that all the functions you&#39;re going to use are not &lt;code&gt;nullPtr&lt;/code&gt; in &lt;code&gt;InstanceCmds&lt;/code&gt; or &lt;code&gt;DeviceCmds&lt;/code&gt; before calling them or the command will throw an &lt;code&gt;IOException&lt;/code&gt;. The &lt;code&gt;*Cmds&lt;/code&gt; records can be found inside any dispatchable handle.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Minor things&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;To prevent a name clash between the constructors of &lt;code&gt;VkClearColorValue&lt;/code&gt; and &lt;code&gt;VkPerformanceCounterResultKHR&lt;/code&gt; the latter have had &lt;code&gt;Counter&lt;/code&gt; suffixed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To prevent a name clash between the constructors of &lt;code&gt;DeviceOrHostAddressKHR&lt;/code&gt; and &lt;code&gt;DeviceOrHostAddressConstKHR&lt;/code&gt; the latter have had &lt;code&gt;Const&lt;/code&gt; suffixed.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How the C types relate to Haskell types&lt;/h2&gt; &#xA;&lt;p&gt;These bindings take advantage of the meta information present in the specification detailing the validity of structures and arguments.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Vector&lt;/code&gt; is used in place of pointers to arrays with associated length members/parameters. When interfacing with Vulkan these bindings automatically set the length member/parameter properly. If the vector is optional but the length is not then the length member/parameter is preserved, but will be inferred if the vector is present and the length is 0.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If a struct member or command parameters in the specification is a optional pointer (it may be null) this is replaced with a &lt;code&gt;Maybe&lt;/code&gt; value.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If a struct has a member which can only have one possible value (the most common example is the &lt;code&gt;sType&lt;/code&gt; member, then this member is elided.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;C strings become &lt;code&gt;ByteString&lt;/code&gt;. This is also the case for fixed length C strings, the library will truncate overly long strings in this case.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Pointers to &lt;code&gt;void&lt;/code&gt; accompanied by a length in bytes become &lt;code&gt;ByteString&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Shader code is represented as &lt;code&gt;ByteString&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;VkBool32&lt;/code&gt; becomes &lt;code&gt;Bool&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Some Vulkan commands or structs take several arrays which must be the same length. These are currently exposed as several &lt;code&gt;Vector&lt;/code&gt; arguments which must be the same length. If they are not the same length an exception is thrown.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Vulkan structs with bitfields have them split into their component parts in the Haskell record. Then marshalling to and from C the masking &lt;em&gt;and shifting&lt;/em&gt; takes place automatically.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If anything is unclear please raise an issue. The marshaling to and from Haskell and C is automatically generated and I&#39;ve not checked every single function. It&#39;s possible that there are some commands or structs which could be represented better in Haskell, if so please also raise an issue.&lt;/p&gt; &#xA;&lt;h3&gt;Vulkan errors&lt;/h3&gt; &#xA;&lt;p&gt;If a Vulkan command has the &lt;code&gt;VkResult&lt;/code&gt; type as a return value, this is checked and a &lt;code&gt;VulkanException&lt;/code&gt; is thrown if it is not a success code. If the only success code a command can return is &lt;code&gt;VK_SUCCESS&lt;/code&gt; then this is elided from the return type. If a command can return other success codes, for instance &lt;code&gt;VK_EVENT_SET&lt;/code&gt; then the success code is exposed.&lt;/p&gt; &#xA;&lt;h3&gt;Bracketing commands&lt;/h3&gt; &#xA;&lt;p&gt;There are certain sets commands which must be called in pairs, for instance the &lt;code&gt;create&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt; commands for using resources. In order to facilitate safe use of these commands, (i.e. ensure that the corresponding &lt;code&gt;destroy&lt;/code&gt; command is always called) these bindings expose similarly named commands prefixed with &lt;code&gt;with&lt;/code&gt; (for &lt;code&gt;Create&lt;/code&gt;/&lt;code&gt;Destroy&lt;/code&gt; and &lt;code&gt;Allocate&lt;/code&gt;/&lt;code&gt;Free&lt;/code&gt; pairs) or &lt;code&gt;use&lt;/code&gt; for (&lt;code&gt;Begin&lt;/code&gt;/&lt;code&gt;End&lt;/code&gt; pairs). If the command is used in command buffer building then it is additionally prefixed with &lt;code&gt;cmd&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;These are higher order functions which take as their last argument a consumer for a pair of &lt;code&gt;create&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt; commands. Values which fit this hole include &lt;code&gt;Control.Exception.bracket&lt;/code&gt;, &lt;code&gt;Control.Monad.Trans.Resource.allocate&lt;/code&gt; and &lt;code&gt;(,)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;An example is &lt;code&gt;withInstance&lt;/code&gt; which calls &lt;code&gt;createInstance&lt;/code&gt; and &lt;code&gt;destroyInstance&lt;/code&gt;. Notice how the &lt;code&gt;AllocationCallbacks&lt;/code&gt; parameter is automatically passed to the &lt;code&gt;createInstance&lt;/code&gt; and &lt;code&gt;destroyInstance&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;createInstance&#xA;  :: forall a m&#xA;   . (PokeChain a, MonadIO m)&#xA;  =&amp;gt; InstanceCreateInfo a&#xA;  -&amp;gt; Maybe AllocationCallbacks&#xA;  -&amp;gt; m Instance&#xA;&#xA;destroyInstance&#xA;  :: forall m&#xA;   . MonadIO m&#xA;  =&amp;gt; Instance&#xA;  -&amp;gt; Maybe AllocationCallbacks&#xA;  -&amp;gt; m ()&#xA;&#xA;withInstance&#xA;  :: forall a m r&#xA;   . (PokeChain a, MonadIO m)&#xA;  =&amp;gt; InstanceCreateInfo a&#xA;  -&amp;gt; Maybe AllocationCallbacks&#xA;  -&amp;gt; (m Instance -&amp;gt; (Instance -&amp;gt; m ()) -&amp;gt; r)&#xA;  -&amp;gt; r&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Control.Monad.Trans.Resource (runResourceT, allocate)&#xA;-- Create an instance and print its value&#xA;main = runResourceT $ do&#xA;  (instanceReleaseKey, inst) &amp;lt;- withInstance zero Nothing allocate&#xA;  liftIO $ print inst&#xA;&#xA;-- Begin a render pass, draw something and end the render pass&#xA;drawTriangle =&#xA;  cmdUseRenderPass buffer renderPassBeginInfo SUBPASS_CONTENTS_INLINE bracket_&#xA;    $ do&#xA;        cmdBindPipeline buffer PIPELINE_BIND_POINT_GRAPHICS graphicsPipeline&#xA;        cmdDraw buffer 3 1 0 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These pairs of commands aren&#39;t explicit in the specification, so a list of them is maintained in the generation code, if you see something missing please open an issue (these pairs are generated in &lt;code&gt;VK/Bracket.hs&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Dual use commands&lt;/h3&gt; &#xA;&lt;p&gt;Certain commands, such as &lt;code&gt;vkEnumerateDeviceLayerProperties&lt;/code&gt; or &lt;code&gt;vkGetDisplayModePropertiesKHR&lt;/code&gt;, have a dual use. If they are not given a pointer to return an array of results then they instead return the total number of possible results, otherwise they return a number of results. There is an idiom in Vulkan which involves calling this function once with a null pointer to get the total number of queryable values, allocating space for querying that many values and they calling the function again to get the values. These bindings expose commands which automatically return all the results. As an example &lt;code&gt;enumeratePhysicalDevices&lt;/code&gt; has the type &lt;code&gt;MonadIO m =&amp;gt; Instance -&amp;gt; m (Result, Vector PhysicalDevice)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Structure chains&lt;/h3&gt; &#xA;&lt;p&gt;Most structures in Vulkan have a member called &lt;code&gt;pNext&lt;/code&gt; which can be a pointer to another Vulkan structure containing additional information. In these high level bindings the head of any struct chain is parameterized over the rest of the items in the chain. This allows for using &lt;em&gt;type inference&lt;/em&gt; for getting struct chain return values out of Vulkan, for example: &lt;code&gt;getPhysicalDeviceFeatures2 :: (PokeChain a, PeekChain a) =&amp;gt; PhysicalDevice -&amp;gt; IO (PysicalDeviceFeatures2 a)&lt;/code&gt;; here the variable &lt;code&gt;a :: [Type]&lt;/code&gt; represents the structures present in the chain returned from &lt;code&gt;vkGetPhysicalDeviceFeatures2&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There exists a GADT &lt;code&gt;SomeStruct&lt;/code&gt; which captures the case of an unknown tail in the struct chain. This is also used for nested chains inside structs.&lt;/p&gt; &#xA;&lt;p&gt;Struct chains inside records are represented as nested tuples: &lt;code&gt;next :: (Something, (SomethingElse, (AThirdThing, ())))&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are two pattern synonyms exposed in &lt;code&gt;Vulkan.CStruct.Extends&lt;/code&gt; which help in constructing and deconstructing struct chains.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;h ::&amp;amp; t&lt;/code&gt; which appends the tail &lt;code&gt;t&lt;/code&gt; to the struct &lt;code&gt;h&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;t :&amp;amp; ts&lt;/code&gt; which constructs a struct extending tail comprising struct &lt;code&gt;t&lt;/code&gt; and structs &lt;code&gt;ts&lt;/code&gt;. Note that you must terminate the list with &lt;code&gt;()&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example, to create an instance with a &lt;code&gt;debugUtilsMessenger&lt;/code&gt; and the validation layer&#39;s best practices output enabled:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;makeInst = do&#xA;  let debugCreateInfo = _ :: DebugUtilsMessengerCreateInfoEXT&#xA;      validationFeatures = ValidationFeaturesEXT [VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT] []&#xA;      instanceCreateInfo = zero ::&amp;amp; debugCreateInfo :&amp;amp; validationFeatures :&amp;amp; ()&#xA;  createInstance instanceCreateInfo Nothing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And to deconstruct a return value with a struct tail, for example to find out if a physical device supports Timeline Semaphores:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;hasTimelineSemaphores phys = do&#xA;  _ ::&amp;amp; PhysicalDeviceTimelineSemaphoreFeatures hasTimelineSemaphores :&amp;amp; () &amp;lt;-&#xA;    getPhysicalDeviceFeatures2 phys&#xA;  pure hasTimelineSemaphores&#xA;&#xA;-- If you don&#39;t have a MonadFail instance you&#39;ll have to avoid pattern matching&#xA;-- using do notation because of https://gitlab.haskell.org/ghc/ghc/-/issues/15681&#xA;hasTimelineSemaphores phys = do&#xA;  feats &amp;lt;- getPhysicalDeviceFeatures2 phys&#xA;  let _ ::&amp;amp; PhysicalDeviceTimelineSemaphoreFeatures hasTimelineSemaphores :&amp;amp; ()&#xA;       = feats&#xA;  pure hasTimelineSemaphores&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;This package requires GHC 8.6 or higher due to the use of the &lt;code&gt;QuantifiedConstraints&lt;/code&gt; language extension.&lt;/p&gt; &#xA;&lt;p&gt;Make sure you have initialized the &lt;code&gt;VulkanMemoryAllocator&lt;/code&gt; submodule if you intend to build the &lt;code&gt;VulkanMemoryAllocator&lt;/code&gt; package.&lt;/p&gt; &#xA;&lt;p&gt;If you provision &lt;code&gt;libvulkan.so&lt;/code&gt; (the Vulkan loader) with nix and you&#39;re not on NixOS, you&#39;ll have to use &lt;a href=&#34;https://github.com/guibou/nixGL&#34;&gt;NixGL&lt;/a&gt; to run your programs. For this reason it&#39;s recommended to use the system-provided &lt;code&gt;libvulkan.so&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For instructions on how to regenerate the bindings see &lt;a href=&#34;https://raw.githubusercontent.com/expipiplus1/vulkan/main/generate-new/readme.md&#34;&gt;the readme in ./generate-new&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To build the example programs. You&#39;ll need to supply the following system packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;vulkan-loader&lt;/code&gt; (for &lt;code&gt;libvulkan.so&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;vulkan-headers&lt;/code&gt; (for &lt;code&gt;vulkan.h&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pkg-config&lt;/code&gt; and &lt;code&gt;SDL2&lt;/code&gt; to build the Haskell &lt;code&gt;sdl2&lt;/code&gt; package.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;glslang&lt;/code&gt; (for the &lt;code&gt;glslangValidator&lt;/code&gt; binary, to build the shaders)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Jonathan Merritt has made an excellent video detailing how to set up everything necessary for running the examples on macOS &lt;a href=&#34;https://www.youtube.com/watch?v=BaBt-CNBfd0&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Building using Nix&lt;/h3&gt; &#xA;&lt;p&gt;Here is some generally useful information for using the &lt;code&gt;default.nix&lt;/code&gt; files in this repo.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;default.nix { forShell = false; }&lt;/code&gt; evaluates to an attribute set with one attribute for each of the following packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;vulkan&lt;/code&gt;, the main package of this repository&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VulkanMemoryAllocator&lt;/code&gt;, bindings to VMA&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;vulkan-utils&lt;/code&gt;, a small selection of utility functions for using &lt;code&gt;vulkan&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;vulkan-examples&lt;/code&gt;, some examples, this package is dependency-heavy&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;generate-new&lt;/code&gt;, the program to generate the source of &lt;code&gt;vulkan&lt;/code&gt; and &lt;code&gt;VulkanMemoryAllocator&lt;/code&gt;, also quite dependency-heavy (this only build with ghc 8.10).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You may want to pass your &lt;code&gt;&amp;lt;nixpkgs&amp;gt;&lt;/code&gt; as &lt;code&gt;pkgs&lt;/code&gt; to &lt;code&gt;default.nix&lt;/code&gt; to avoid rebuilding a parallel set of haskell packages based on the pegged nixpkgs version in &lt;code&gt;default.nix&lt;/code&gt;. It should probably work with a wide range of nixpkgss, however some overrides in &lt;code&gt;default.nix&lt;/code&gt; may need tweaking,&lt;/p&gt; &#xA;&lt;p&gt;Alternatively you could use the Cachix repo &lt;a href=&#34;https://app.cachix.org/cache/vulkan-haskell&#34;&gt;https://app.cachix.org/cache/vulkan-haskell&lt;/a&gt; which contains the latest closure for the packages in this repo.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;nix-build -A vulkan&lt;/code&gt; is probably not terribly useful for using the library as it just builds the Haskell library.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;nix-build -A vulkan-examples&lt;/code&gt; will produce a path with several examples, however to run these on a non-NixOS platform you&#39;ll need to use the &lt;a href=&#34;https://github.com/guibou/nixGL&#34;&gt;&lt;code&gt;NixGL&lt;/code&gt;&lt;/a&gt; project (or something similar) to run these. This isn&#39;t something tested very often so may be a little fragile. I&#39;d suggest for non-NixOS platforms compiling without using Nix (or better yet get reliable instructions for using &lt;code&gt;NixGL&lt;/code&gt; and open a PR).&lt;/p&gt; &#xA;&lt;p&gt;This library is currently up to date on nixpkgs master (as of &lt;a href=&#34;https://github.com/NixOS/nixpkgs/commit/af9608d6d133ad9b6de712418db52603bbc8531c&#34;&gt;https://github.com/NixOS/nixpkgs/commit/af9608d6d133ad9b6de712418db52603bbc8531c&lt;/a&gt; 2020-06-23), so if you&#39;re just a consumer it might be best to just use &lt;code&gt;haskellPackages.vulkan&lt;/code&gt; from a recent version there.&lt;/p&gt; &#xA;&lt;p&gt;For using this repository, I have two workflows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;For building and running examples&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;I navigate to the examples directory and use the &lt;code&gt;default.nix&lt;/code&gt; expression in there to provision a shell with the correct dependencies for the examples.&lt;/li&gt; &#xA;   &lt;li&gt;I also make a &lt;code&gt;cabal.project&lt;/code&gt; containing &lt;code&gt;packages: ./&lt;/code&gt;, the reason for this little dance instead of just using the root&#39;s &lt;code&gt;default.nix&lt;/code&gt; is so that nix builds the hoogle database for the dependencies and HIE&#39;s completion and indexing works much better for external dependencies instead of using a multi-package project as is the root.&lt;/li&gt; &#xA;   &lt;li&gt;This will override nixpkgs&#39;s &lt;code&gt;vulkan&lt;/code&gt; and &lt;code&gt;VulkanMemoryAllocator&lt;/code&gt; libraries with the ones in the repo, as well as building &lt;code&gt;vulkan-utils&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For modifying the generation program I navigate to the &lt;code&gt;generate-new&lt;/code&gt; directory and run &lt;code&gt;nix-shell ..&lt;/code&gt; to use &lt;code&gt;default.nix&lt;/code&gt; in the repo&#39;s root to provision a shell with:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The dependencies for running the generator&lt;/li&gt; &#xA;   &lt;li&gt;And the dependencies for compiling the &lt;code&gt;vulkan&lt;/code&gt; source it spits out.&lt;/li&gt; &#xA;   &lt;li&gt;I run the generator with &lt;code&gt;ghci $(HIE_BIOS_OUTPUT=/dev/stdout ./flags.sh $(pwd)/vk/Main.hs) vk/Main.hs +RTS -N16&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For using the source in this package externally it may be easiest to do whatever you do to get a haskell environment with nix and simply override the source to point to this repo, the dependencies haven&#39;t changed for a while, so any version of nixpkgs from the last 3 months should do the trick.&lt;/p&gt; &#xA;&lt;h3&gt;Building on Windows with Cabal&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone this repo with submodules (to get the C header in order to build VulkanMemoryAllocator)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;git clone --recursive https://github.com/expipiplus1/vulkan&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install GHC and Cabal&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;I used &lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;ghcup&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Make sure that the &lt;code&gt;libstdc++&lt;/code&gt; dll is in &lt;code&gt;PATH&lt;/code&gt;, I had to add &lt;code&gt;C:\ghcup\ghc\9.2.4\mingw\bin&lt;/code&gt; to my user &lt;code&gt;PATH&lt;/code&gt; variable&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Make sure your graphics driver has installed &lt;code&gt;vulkan-1.dll&lt;/code&gt; in &lt;code&gt;C:/windows/system32&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the LunarG Vulkan SDK&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://vulkan.lunarg.com/sdk/home#windows&#34;&gt;https://vulkan.lunarg.com/sdk/home#windows&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Remember the installation directory, use in place of &lt;code&gt;C:/VulkanSDK/1.3.224.1&lt;/code&gt; below&lt;/li&gt; &#xA;   &lt;li&gt;Install the SDL2 library/header (You can run &lt;code&gt;maintenancetool&lt;/code&gt; in the SDK directory to install this later if you forgot)&lt;/li&gt; &#xA;   &lt;li&gt;We will link against &lt;code&gt;vulkan-1.lib&lt;/code&gt; from this installation&lt;/li&gt; &#xA;   &lt;li&gt;We will use the &lt;code&gt;glslangValidator&lt;/code&gt; from this installation.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Restart your shell to pick up the new &lt;code&gt;PATH&lt;/code&gt; environment set up by the SDK installer The Vulkan SDK installer&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Inform Cabal about header and library locations by adding the following to &lt;code&gt;cabal.project.local&lt;/code&gt;, changed accodingly for your install path for the Vulkan SDK. Also use a patched SDL2 which doens&#39;t use pkgconfig (a pain to install on Windows)&lt;/p&gt; &lt;pre&gt;&lt;code&gt;package sdl2&#xA;    extra-lib-dirs: C:/VulkanSDK/1.3.224.1/lib/&#xA;    extra-include-dirs: C:/VulkanSDK/1.3.224.1/Include/SDL2&#xA;    flags: -pkgconfig&#xA;source-repository-package&#xA;    type: git&#xA;    location: https://github.com/expipiplus1/sdl2&#xA;    tag: 35f45303a0af522f10197f09e4bf52bc49b97ef4&#xA;&#xA;package vulkan&#xA;    extra-lib-dirs: C:/VulkanSDK/1.3.224.1/lib/&#xA;&#xA;package vulkan-utils&#xA;    extra-include-dirs: C:/VulkanSDK/1.3.224.1/Include/&#xA;&#xA;package VulkanMemoryAllocator&#xA;    extra-include-dirs: C:/VulkanSDK/1.3.224.1/Include/&#xA;&#xA;package vulkan-examples&#xA;    extra-prog-path: C:/VulkanSDK/1.3.224.1/bin&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run &lt;code&gt;cabal build examples&lt;/code&gt; to build the examples&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run &lt;code&gt;cabal run resize&lt;/code&gt; to run the &lt;code&gt;resize&lt;/code&gt; example.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Building on Windows with Stack&lt;/h3&gt; &#xA;&lt;p&gt;Stack is currently (2020-11-02) bundled with an msys2 installation which is too old to use the package repositories (see &lt;a href=&#34;https://github.com/commercialhaskell/stack/issues/5300&#34;&gt;https://github.com/commercialhaskell/stack/issues/5300&lt;/a&gt;) so installing the Vulkan SDK, &lt;code&gt;SDL2&lt;/code&gt; and &lt;code&gt;pkg-config&lt;/code&gt; is not possible with the bundled package manager.&lt;/p&gt; &#xA;&lt;p&gt;Nevertheless, it should be possible to use Stack by adding the following to &lt;code&gt;stack.yaml&lt;/code&gt; (changed appropriately according to SDL2 and VulkanSDK install locations) and building after following the instructions above.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;extra-lib-dirs:&#xA;- C:/VulkanSDK/1.2.135.0/lib/&#xA;&#xA;extra-include-dirs:&#xA;- C:/VulkanSDK/1.2.135.0/Include/&#xA;- C:/VulkanSDK/1.3.224.1/Include/SDL2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;There exists a package to build some example programs in the &lt;a href=&#34;https://raw.githubusercontent.com/expipiplus1/vulkan/main/examples&#34;&gt;&lt;code&gt;examples&lt;/code&gt;&lt;/a&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Current Status&lt;/h2&gt; &#xA;&lt;p&gt;All the core Vulkan 1.0, 1.1, 1.2, and 1.3 functionality is here as well as all the extensions (except the video ones).&lt;/p&gt; &#xA;&lt;p&gt;This is currently a 64 bit only library.&lt;/p&gt; &#xA;&lt;h2&gt;See also&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/VulkanMemoryAllocator&#34;&gt;VulkanMemoryAllocator package&lt;/a&gt; (source in the &lt;a href=&#34;https://raw.githubusercontent.com/expipiplus1/vulkan/main/VulkanMemoryAllocator&#34;&gt;VulkanMemoryAllocator directory&lt;/a&gt;) has similarly styled bindings to the &lt;a href=&#34;https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator&#34;&gt;Vulkan Memory Allocator&lt;/a&gt; library.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/vulkan-utils&#34;&gt;vulkan-utils&lt;/a&gt; (source in the &lt;a href=&#34;https://raw.githubusercontent.com/expipiplus1/vulkan/main/utils&#34;&gt;utils directory&lt;/a&gt;) includes a few utilities for writing programs using these bindings.&lt;/p&gt; &#xA;&lt;p&gt;For an alternative take on Haskell bindings to Vulkan see the &lt;a href=&#34;https://github.com/achirkin/vulkan#readme&#34;&gt;vulkan-api&lt;/a&gt; package. &lt;code&gt;vulkan-api&lt;/code&gt; stores Vulkan structs in their C representation as &lt;code&gt;ByteArray#&lt;/code&gt; whereas this library allocates structs on the stack and keeps them alive for just the lifetime of any Vulkan command call.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a name=&#34;fun-ptr&#34;&gt;1&lt;/a&gt;: Note that you&#39;ll still have to request any required extensions for the function pointers belonging to that extension to be populated. An exception will be thrown if you try to call a function pointer which is null.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;opt-vec&#34;&gt;2&lt;/a&gt;: The exception is where the spec allows the application to pass &lt;code&gt;NULL&lt;/code&gt; for the vector with a non-zero count. In these cases it was deemed clearer to preserve the &#34;count&#34; member and allow the Haskell application to pass a zero-length vector to indicate &lt;code&gt;NULL&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;sdl-load&#34;&gt;3&lt;/a&gt;: &lt;a href=&#34;https://github.com/spurious/SDL-mirror/raw/6b6170caf69b4189c9a9d14fca96e97f09bbcc41/src/video/windows/SDL_windowsvulkan.c#L50-L54&#34;&gt;https://github.com/spurious/SDL-mirror/blob/6b6170caf69b4189c9a9d14fca96e97f09bbcc41/src/video/windows/SDL_windowsvulkan.c#L50-L54&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>