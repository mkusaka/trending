<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-05T01:37:21Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hspec/hspec</title>
    <updated>2023-06-05T01:37:21Z</updated>
    <id>tag:github.com,2023-06-05:/hspec/hspec</id>
    <link href="https://github.com/hspec/hspec" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Testing Framework for Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;Read the &lt;a href=&#34;https://hspec.github.io/&#34;&gt;User&#39;s Manual&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h1&gt;Development&lt;/h1&gt; &#xA;&lt;p&gt;Preparing a release:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ util/release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ util/release major&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will bump the version and update &lt;code&gt;CHANGES.markdown&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Releases happen automatically when a new version ends up on &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Whenever &lt;a href=&#34;https://raw.githubusercontent.com/hspec/hspec/main/.github/workflows/publish.yml&#34;&gt;&lt;code&gt;.github/workflows/publish.yml&lt;/code&gt;&lt;/a&gt; detects a new version without a corresponding tag it:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;creates a tag&lt;/li&gt; &#xA; &lt;li&gt;publishes to Hackage&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>jonathanknowles/monoidmap</title>
    <updated>2023-06-05T01:37:21Z</updated>
    <id>tag:github.com,2023-06-05:/jonathanknowles/monoidmap</id>
    <link href="https://github.com/jonathanknowles/monoidmap" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Monoidal map type with support for semigroup and monoid subclasses.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;code&gt;monoidmap&lt;/code&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/API-Documentation-227755&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Overview&lt;/h1&gt; &#xA;&lt;p&gt;This library provides a &lt;strong&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; type that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;models a &lt;a href=&#34;https://raw.githubusercontent.com/jonathanknowles/monoidmap/main/#relationship-between-keys-and-values&#34;&gt;total function&lt;/a&gt; with &lt;a href=&#34;https://en.wikipedia.org/wiki/Support_(mathematics)&#34;&gt;finite support&lt;/a&gt; from keys to &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Monoid&#34;&gt;monoidal&lt;/a&gt; values, with a default value of &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;encodes key-value mappings with a &lt;a href=&#34;https://raw.githubusercontent.com/jonathanknowles/monoidmap/main/#encoding&#34;&gt;minimal encoding&lt;/a&gt; that only includes values &lt;em&gt;not&lt;/em&gt; equal to &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;provides a comprehensive set of &lt;a href=&#34;https://raw.githubusercontent.com/jonathanknowles/monoidmap/main/#monoidal-operations&#34;&gt;monoidal operations&lt;/a&gt; for transforming, combining, and comparing maps.&lt;/li&gt; &#xA; &lt;li&gt;provides a &lt;a href=&#34;https://raw.githubusercontent.com/jonathanknowles/monoidmap/main/#General-basis-for-more-specialised-map-types&#34;&gt;general basis&lt;/a&gt; for building more specialised monoidal data structures.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Relationship between keys and values&lt;/h1&gt; &#xA;&lt;p&gt;A map of type &lt;code&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;MonoidMap&lt;/a&gt; k v&lt;/code&gt; associates &lt;strong&gt;every&lt;/strong&gt; possible key of type &lt;code&gt;k&lt;/code&gt; with a value of type &lt;code&gt;v&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;MonoidMap.get :: (Ord k, Monoid v) =&amp;gt; k -&amp;gt; MonoidMap k v -&amp;gt; v&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:empty&#34;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt; map associates every key &lt;code&gt;k&lt;/code&gt; with a default value of &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;∀ k. MonoidMap.get k MonoidMap.empty == mempty&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Comparison with standard &lt;code&gt;Map&lt;/code&gt; type&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; type differs from the standard &lt;a href=&#34;https://hackage.haskell.org/package/containers&#34;&gt;&lt;code&gt;containers&lt;/code&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; type in how it relates keys to values:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Type&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Models a total function with finite support&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;code&gt;Map k v&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;Maybe v&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;code&gt;MonoidMap k v&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;This difference can be illustrated by comparing the type signatures of operations to query a key for its value, for both types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;      Map.lookup ::             k -&amp;gt;       Map k v -&amp;gt; Maybe v&#xA;MonoidMap.get    :: Monoid v =&amp;gt; k -&amp;gt; MonoidMap k v -&amp;gt;       v&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Whereas a standard &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; has a default value of &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:Nothing&#34;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; has a default value of &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;∀ k.       Map.lookup k       Map.empty == Nothing&#xA;∀ k. MonoidMap.get    k MonoidMap.empty == mempty&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In practice, the standard &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; type uses &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Maybe.html#t:Maybe&#34;&gt;&lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; to indicate the &lt;em&gt;presence&lt;/em&gt; or &lt;em&gt;absence&lt;/em&gt; of a value for a particular key. This representation is necessary because the &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; type imposes no constraints on value types.&lt;/p&gt; &#xA;&lt;p&gt;However, &lt;em&gt;monoidal&lt;/em&gt; types already have a natural way to represent null or empty values: the &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; constant, which represents the neutral or identity element of a &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Monoid&#34;&gt;&lt;code&gt;Monoid&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Consequently, using a standard &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; with a &lt;em&gt;monoidal&lt;/em&gt; value type gives rise to &lt;em&gt;two&lt;/em&gt; distinct representations for null or empty values:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;&lt;code&gt;Map.lookup k m&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Interpretation&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Map &lt;code&gt;m&lt;/code&gt; has &lt;em&gt;no&lt;/em&gt; entry for key &lt;code&gt;k&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;Just mempty&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Map &lt;code&gt;m&lt;/code&gt; has an entry for key &lt;code&gt;k&lt;/code&gt;, but the value is &lt;em&gt;empty&lt;/em&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;In constrast, the &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; type provides a single, &lt;em&gt;canonical&lt;/em&gt; representation for null or empty values, according to the following conceptual mapping:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;&lt;code&gt;Map.lookup k m&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;⟼&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;&lt;code&gt;MonoidMap.get k m&lt;/code&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;⟼&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;Just v | v == mempty&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;⟼&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;Just v | v /= mempty&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;⟼&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;v&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Advantages of using a canonical representation&lt;/h2&gt; &#xA;&lt;p&gt;A canonical representation for &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; values can make it easier to correctly implement operations that compare or combine pairs of maps.&lt;/p&gt; &#xA;&lt;p&gt;When comparing or combining maps of the standard &lt;a href=&#34;https://hackage.haskell.org/package/containers&#34;&gt;&lt;code&gt;containers&lt;/code&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; type, there are &lt;strong&gt;two&lt;/strong&gt; cases to consider for each key &lt;code&gt;k&lt;/code&gt; in each map:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; &lt;code&gt;m&lt;/code&gt; associates &lt;code&gt;k&lt;/code&gt; with &lt;code&gt;Nothing&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; &lt;code&gt;m&lt;/code&gt; associates &lt;code&gt;k&lt;/code&gt; with &lt;code&gt;Just v&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;With a &lt;em&gt;pair&lt;/em&gt; of maps, there are &lt;strong&gt;four&lt;/strong&gt; possible cases to consider for each key.&lt;/p&gt; &#xA;&lt;p&gt;For maps with monoidal values, and in contexts that assume or require a default value of &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt;, there are now &lt;strong&gt;three&lt;/strong&gt; cases to consider for each map:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; &lt;code&gt;m&lt;/code&gt; associates &lt;code&gt;k&lt;/code&gt; with &lt;code&gt;Nothing&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; &lt;code&gt;m&lt;/code&gt; associates &lt;code&gt;k&lt;/code&gt; with &lt;code&gt;Just v&lt;/code&gt; where &lt;code&gt;v == mempty&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; &lt;code&gt;m&lt;/code&gt; associates &lt;code&gt;k&lt;/code&gt; with &lt;code&gt;Just v&lt;/code&gt; where &lt;code&gt;v /= mempty&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;With a &lt;em&gt;pair&lt;/em&gt; of maps, there are now &lt;strong&gt;nine&lt;/strong&gt; possible cases to consider for each key.&lt;/p&gt; &#xA;&lt;p&gt;Mishandling cases such as these can give rise to subtle bugs that manifest in unexpected places. For maps with more complex value types (such as maps that nest other maps), the number of cases requiring consideration can easily multiply further, making it even easier to introduce bugs.&lt;/p&gt; &#xA;&lt;p&gt;Since all &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; operations provide a canonical representation for &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; values, it&#39;s possible to write functions that compare or combine maps without having to consider &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:Nothing&#34;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Maybe.html#v:Just&#34;&gt;Just&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;mempty&lt;/a&gt;&lt;/code&gt; as separate cases.&lt;/p&gt; &#xA;&lt;h1&gt;Encoding&lt;/h1&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; only encodes mappings from keys to values that are &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; equal to &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The total function $T$ modelled by a &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; is encoded as a &lt;strong&gt;support map&lt;/strong&gt; $S$, where $S$ is the finite subset of key-value mappings in $T$ for which values are &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; equal to &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; (denoted by $\varnothing$):&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;$S = \{ (k, v) \in T \ |\ v \ne \varnothing \} $&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Automatic minimisation&lt;/h2&gt; &#xA;&lt;p&gt;All &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; operations perform &lt;strong&gt;automatic minimisation&lt;/strong&gt; of the support map, so that &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; values do not appear in:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;any encoding of a &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt;;&lt;/li&gt; &#xA; &lt;li&gt;any traversal of a &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Constraints on values&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; operations require the monoidal value type to be an instance of &lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-Null.html#t:MonoidNull&#34;&gt;&lt;code&gt;MonoidNull&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Instances of &lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-Null.html#t:MonoidNull&#34;&gt;&lt;code&gt;MonoidNull&lt;/code&gt;&lt;/a&gt; must provide a &lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-Null.html#v:null&#34;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; indicator function that satisfies the following law:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;null v == (v == mempty)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; operations use the &lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-Null.html#v:null&#34;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; indicator function to detect and exclude &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; values from the support map.&lt;/p&gt; &#xA;&lt;p&gt;Note that it is &lt;em&gt;not&lt;/em&gt; generally necessary for the value type to be an instance of &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq&#34;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;&lt;strong&gt;Justification&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;The set of monoidal types that admit a &lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-Null.html#t:MonoidNull&#34;&gt;&lt;code&gt;MonoidNull&lt;/code&gt;&lt;/a&gt; instance is strictly larger than the set of monoidal types that admit an &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq&#34;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt; &#xA;  &lt;p&gt;For any type &lt;code&gt;v&lt;/code&gt; that is an instance of both &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq&#34;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Monoid&#34;&gt;&lt;code&gt;Monoid&lt;/code&gt;&lt;/a&gt;, it is &lt;em&gt;always&lt;/em&gt; possible to define a &lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-Null.html#t:MonoidNull&#34;&gt;&lt;code&gt;MonoidNull&lt;/code&gt;&lt;/a&gt; instance:&lt;/p&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;instance MonoidNull v where&#xA;    null = (== mempty)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;p&gt;However, there are monoidal types for which it is possible to define a &lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-Null.html#t:MonoidNull&#34;&gt;&lt;code&gt;MonoidNull&lt;/code&gt;&lt;/a&gt; instance, but not practical (or possible) to define a lawful &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq&#34;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt; &#xA;  &lt;p&gt;For example, consider the following type:&lt;/p&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;Maybe (String -&amp;gt; Sum Natural)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;p&gt;Requiring a &lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-Null.html#t:MonoidNull&#34;&gt;&lt;code&gt;MonoidNull&lt;/code&gt;&lt;/a&gt; constraint instead of an &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq&#34;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; constraint allows &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; to be usable with a greater range of monoidal value types.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Examples of automatic minimisation&lt;/h2&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;&lt;strong&gt;Updating a map with a value that &lt;em&gt;may&lt;/em&gt; be &lt;code&gt;mempty&lt;/code&gt;&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;Consider the following operation, which constructs a map of type &lt;code&gt;MonoidMap Int String&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m0 = fromList [(1, &#34;hello&#34;), (2, &#34;brave&#34;), (3, &#34;new&#34;), (4, &#34;world&#34;)]&#xA;&amp;gt;&amp;gt;&amp;gt; m0&#xA;fromList [(1, &#34;hello&#34;), (2, &#34;brave&#34;), (3, &#34;new&#34;), (4, &#34;world&#34;)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Monoid&#34;&gt;&lt;code&gt;Monoid&lt;/code&gt;&lt;/a&gt; instance for &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-String.html#t:String&#34;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; defines &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; to be the empty &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-String.html#t:String&#34;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; &lt;code&gt;&#34;&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;  &lt;p&gt;If we update the map to associate key &lt;code&gt;3&lt;/code&gt; with value &lt;code&gt;&#34;&#34;&lt;/code&gt;, that association will no longer appear when encoding the map:&lt;/p&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m1 = MonoidMap.set 3 &#34;&#34; m0&#xA;&amp;gt;&amp;gt;&amp;gt; m1&#xA;fromList [(1, &#34;hello&#34;), (2, &#34;brave&#34;), (4, &#34;world&#34;)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;p&gt;However, we can still read the updated value for key &lt;code&gt;3&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; MonoidMap.get 3 m1&#xA;&#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;&lt;strong&gt;Constructing a map from a list that &lt;em&gt;may&lt;/em&gt; include &lt;code&gt;mempty&lt;/code&gt; values&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;Consider the following operation, which constructs a map of type &lt;code&gt;MonoidMap Char (Sum Natural)&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m = fromList [(&#39;a&#39;, Sum 0), (&#39;b&#39;, Sum 1), (&#39;c&#39;, Sum 2), (&#39;d&#39;, Sum 3)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Monoid&#34;&gt;&lt;code&gt;Monoid&lt;/code&gt;&lt;/a&gt; instance for &lt;code&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Sum&#34;&gt;Sum&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Numeric-Natural.html#t:Natural&#34;&gt;Natural&lt;/a&gt;&lt;/code&gt; defines &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; to be &lt;code&gt;Sum 0&lt;/code&gt;.&lt;/p&gt; &#xA;  &lt;p&gt;The original list contained a mapping from key &lt;code&gt;&#39;a&#39;&lt;/code&gt; to value &lt;code&gt;Sum 0&lt;/code&gt;, but that association will not appear when encoding the map:&lt;/p&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m&#xA;fromList [(&#39;b&#39;, Sum 1), (&#39;c&#39;, Sum 2), (&#39;d&#39;, Sum 3)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;p&gt;Nevertheless, we can still read the value for key &lt;code&gt;&#39;a&#39;&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; MonoidMap.get &#39;a&#39; m&#xA;Sum 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;&lt;strong&gt;Combining maps with operations that &lt;em&gt;may&lt;/em&gt; produce &lt;code&gt;mempty&lt;/code&gt; values&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;Consider the following operations, which construct two maps of type &lt;code&gt;MonoidMap Char (Sum Natural)&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m1 = fromList [(&#39;a&#39;, Sum 1), (&#39;b&#39;, Sum   1 )]&#xA;&amp;gt;&amp;gt;&amp;gt; m2 = fromList [(&#39;a&#39;, Sum 1), (&#39;b&#39;, Sum (-1))]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#t:Semigroup&#34;&gt;&lt;code&gt;Semigroup&lt;/code&gt;&lt;/a&gt; instance for &lt;code&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Sum&#34;&gt;Sum&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Numeric-Natural.html#t:Natural&#34;&gt;Natural&lt;/a&gt;&lt;/code&gt; defines &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#v:-60--62-&#34;&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/a&gt; as equivalent to ordinary addition.&lt;/p&gt; &#xA;  &lt;p&gt;If we add both maps together with &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#v:-60--62-&#34;&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, then each key in the resulting map will be associated with the result of applying &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#v:-60--62-&#34;&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/a&gt; to each matching pair of values in the original maps. However, adding together the values for key &lt;code&gt;&#39;b&#39;&lt;/code&gt; with &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#v:-60--62-&#34;&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/a&gt; produces &lt;code&gt;Sum 0&lt;/code&gt;, so this value will not appear in the encoding:&lt;/p&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m1 &amp;lt;&amp;gt; m2&#xA;fromList [(&#39;a&#39;, Sum 2)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;p&gt;Nevertheless, we can still read the value for key &lt;code&gt;&#39;b&#39;&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; MonoidMap.get &#39;b&#39; (m1 &amp;lt;&amp;gt; m2)&#xA;Sum 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Advantages of automatic minimisation&lt;/h2&gt; &#xA;&lt;h3&gt;Consistency&lt;/h3&gt; &#xA;&lt;p&gt;Automatic exclusion of &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; values can help to ensure consistency when encoding to or decoding from other formats such as JSON, CBOR, or YAML.&lt;/p&gt; &#xA;&lt;p&gt;For example, you may wish to ensure that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When &lt;em&gt;encoding&lt;/em&gt; a map, no &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; values appear in the encoded result.&lt;/li&gt; &#xA; &lt;li&gt;When &lt;em&gt;decoding&lt;/em&gt; a map, no &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; values appear in the decoded result.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Performance&lt;/h3&gt; &#xA;&lt;p&gt;Automatic exclusion of &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; values makes it possible to perform certain operations in &lt;em&gt;constant time&lt;/em&gt;, rather than in linear time, as it is never necessary to traverse the entire map in order to determine which values may or may not be &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr valign=&#34;top&#34; align=&#34;left&#34;&gt; &#xA;   &lt;th&gt;Operation&lt;/th&gt; &#xA;   &lt;th&gt;With&lt;br&gt;Automatic&lt;br&gt;Minimisation&lt;/th&gt; &#xA;   &lt;th&gt;Without&lt;br&gt;Automatic&lt;br&gt;Minimisation&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:null&#34; rel=&#34;nofollow&#34;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;$O(1)$&lt;/td&gt; &#xA;   &lt;td&gt;$O(n)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:nonNull&#34; rel=&#34;nofollow&#34;&gt;&lt;code&gt;nonNull&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;$O(1)$&lt;/td&gt; &#xA;   &lt;td&gt;$O(n)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:nonNullCount&#34; rel=&#34;nofollow&#34;&gt;&lt;code&gt;nonNullCount&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;$O(1)$&lt;/td&gt; &#xA;   &lt;td&gt;$O(n)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:toMap&#34; rel=&#34;nofollow&#34;&gt;&lt;code&gt;toMap&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;$O(1)$&lt;/td&gt; &#xA;   &lt;td&gt;$O(n)$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Memory usage&lt;/h3&gt; &#xA;&lt;p&gt;Automatic minimisation makes it easier to reason about the memory usage of a &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt;, as memory is not required to encode mappings from keys to empty values.&lt;/p&gt; &#xA;&lt;p&gt;This is a useful property for large, long-lived map structures that are subject to multiple updates over their lifetimes, where it&#39;s important to not retain large numbers of mappings from keys to empty values.&lt;/p&gt; &#xA;&lt;h3&gt;Simplicity&lt;/h3&gt; &#xA;&lt;p&gt;Some total map data types only perform minimisation when &lt;em&gt;explicitly demanded to&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example, the &lt;a href=&#34;https://hackage.haskell.org/package/total-map/docs/Data-TotalMap.html#t:TMap&#34;&gt;&lt;code&gt;TMap&lt;/code&gt;&lt;/a&gt; data type provides a &lt;a href=&#34;https://hackage.haskell.org/package/total-map/docs/Data-TotalMap.html#v:trim&#34;&gt;&lt;code&gt;trim&lt;/code&gt;&lt;/a&gt; operation that traverses the map and removes any values that are equal to the &lt;em&gt;default&lt;/em&gt; value. This approach has some advantages, such the ability to provide a lawful &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Functor.html#t:Functor&#34;&gt;&lt;code&gt;Functor&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt; &#xA;&lt;p&gt;However, this approach also has some disadvantages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It might not be obvious &lt;em&gt;when&lt;/em&gt; it&#39;s necessary to call &lt;a href=&#34;https://hackage.haskell.org/package/total-map/docs/Data-TotalMap.html#v:trim&#34;&gt;&lt;code&gt;trim&lt;/code&gt;&lt;/a&gt;. For example, consider the following operation: &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt;. Could this operation produce a map where some keys map to default values? (Answer: it depends on the choice of default value and the underlying value type.)&lt;/li&gt; &#xA; &lt;li&gt;Calling &lt;a href=&#34;https://hackage.haskell.org/package/total-map/docs/Data-TotalMap.html#v:trim&#34;&gt;&lt;code&gt;trim&lt;/code&gt;&lt;/a&gt; when it &lt;em&gt;isn&#39;t&lt;/em&gt; necessary might adversely affect performance, since &lt;a href=&#34;https://hackage.haskell.org/package/total-map/docs/Data-TotalMap.html#v:trim&#34;&gt;&lt;code&gt;trim&lt;/code&gt;&lt;/a&gt; must traverse the entire data structure.&lt;/li&gt; &#xA; &lt;li&gt;Not calling &lt;a href=&#34;https://hackage.haskell.org/package/total-map/docs/Data-TotalMap.html#v:trim&#34;&gt;&lt;code&gt;trim&lt;/code&gt;&lt;/a&gt; when it &lt;em&gt;is&lt;/em&gt; necessary might affect correctness. The compiler will not help here, as trimmed and untrimmed maps share the same type.&lt;/li&gt; &#xA; &lt;li&gt;Even if &lt;a href=&#34;https://hackage.haskell.org/package/total-map/docs/Data-TotalMap.html#v:trim&#34;&gt;&lt;code&gt;trim&lt;/code&gt;&lt;/a&gt; is a semantic no-op, default values can &lt;em&gt;still&lt;/em&gt; be made visible by operations that encode maps to other types.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since all &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; operations perform automatic minimisation when appropriate, it&#39;s not necessary for users to reason about when or whether it&#39;s necessary to &#34;trim&#34; the map.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore, for nested maps such as &lt;code&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;MonoidMap&lt;/a&gt; k1 (&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;MonoidMap&lt;/a&gt; k2 v)&lt;/code&gt;, automatic minimisation of inner maps enables seamless automatic minimisation of outer maps. See the &lt;a href=&#34;https://github.com/jonathanknowles/monoidmap/raw/main/src/examples/Examples/NestedMonoidMap.hs&#34;&gt;&lt;code&gt;NestedMonoidMap&lt;/code&gt;&lt;/a&gt; type for an example of this.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations of automatic minimisation&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; type has no &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Functor.html#t:Functor&#34;&gt;&lt;code&gt;Functor&lt;/code&gt;&lt;/a&gt; instance, as the requirement to exclude &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; values means that the &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:map&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; operation must remove &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; values from its result. Therefore, &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:map&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; unconditionally satisfy the functor composition law:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;map (f . g) == map f . map g&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;&lt;strong&gt;Example violation&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;Consider the following &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; &lt;code&gt;m&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;m :: MonoidMap String String&#xA;m = singleton &#34;k&#34; &#34;v&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;And the following functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;f :: a -&amp;gt; String&#xA;f = const &#34;z&#34;&#xA;&#xA;g :: Monoid a =&amp;gt; b -&amp;gt; a&#xA;g = const mempty&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;By substituting the above definitions into the left-hand side of the functor composition law, we obtain:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;map (f . g) m = map (const &#34;z&#34; . const mempty) (singleton &#34;k&#34; &#34;v&#34;)&#xA;              = map (const &#34;z&#34;               ) (singleton &#34;k&#34; &#34;v&#34;)&#xA;              =                                (singleton &#34;k&#34; &#34;z&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;By substituting the above definitions into the right-hand side of the functor composition law, we obtain:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;map f (map g m) = map (const &#34;z&#34;) (map (const mempty) (singleton &#34;k&#34; &#34;v&#34;))&#xA;                = map (const &#34;z&#34;) mempty&#xA;                =                 mempty&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;This leads to the following inequality between the left-hand side and right-hand side:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;singleton &#34;k&#34; &#34;z&#34; /= mempty&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Therefore, for this example, the functor composition law is not satisfied.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;However, if applying function &lt;code&gt;f&lt;/code&gt; to &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; produces &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt;, the functor composition law is satisfied:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;(f mempty == mempty) ==&amp;gt; (∀ g. map (f . g) == map f . map g)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Monoidal operations&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; type provides a comprehensive set of monoidal operations for transforming, combining, and comparing maps.&lt;/p&gt; &#xA;&lt;p&gt;Instances for several &lt;em&gt;subclasses&lt;/em&gt; of &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#t:Semigroup&#34;&gt;&lt;code&gt;Semigroup&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Monoid&#34;&gt;&lt;code&gt;Monoid&lt;/code&gt;&lt;/a&gt; are provided, including classes from the following libraries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses&#34;&gt;&lt;code&gt;monoid-subclasses&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/groups&#34;&gt;&lt;code&gt;groups&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;At the root of this hierarchy of subclasses is the &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#t:Semigroup&#34;&gt;&lt;code&gt;Semigroup&lt;/code&gt;&lt;/a&gt; class, whose instance for &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; is defined in terms of the &lt;em&gt;underlying value type&lt;/em&gt;, so that applying &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#v:-60--62-&#34;&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/a&gt; to a &lt;em&gt;pair of maps&lt;/em&gt; is equivalent to applying &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#v:-60--62-&#34;&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/a&gt; to all &lt;em&gt;pairs of values&lt;/em&gt; for matching keys:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;∀ k. MonoidMap.get k (m1 &amp;lt;&amp;gt; m2) == MonoidMap.get k m1 &amp;lt;&amp;gt; get k m2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In general, operations for subclasses of &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#t:Semigroup&#34;&gt;&lt;code&gt;Semigroup&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Monoid&#34;&gt;&lt;code&gt;Monoid&lt;/code&gt;&lt;/a&gt; are defined &lt;em&gt;analogously&lt;/em&gt; to the &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#t:Semigroup&#34;&gt;&lt;code&gt;Semigroup&lt;/code&gt;&lt;/a&gt; instance, so that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;unary&lt;/em&gt; operations on &lt;em&gt;individual maps&lt;/em&gt; are defined in terms of their distributive application to all values.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;binary&lt;/em&gt; operations on &lt;em&gt;pairs of maps&lt;/em&gt; are defined in terms of their distributive application to all &lt;em&gt;pairs of values&lt;/em&gt; for matching keys.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Unary monoidal operations typically satisfy a property similar to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;∀ k. MonoidMap.get k (f m) == f (MonoidMap.get k m)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Binary monoidal operations typically satisfy a property similar to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;∀ k. MonoidMap.get k (f m1 m2) == f (MonoidMap.get k m1) (MonoidMap.get k m2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Defining monoidal operations in this way makes it possible to transform, combine, and compare maps in ways that are consistent with the algebraic properties of the underlying monoidal value type.&lt;/p&gt; &#xA;&lt;h2&gt;Examples of monoidal operations and their properties&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr valign=&#34;top&#34; align=&#34;left&#34;&gt; &#xA;   &lt;th&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;br&gt;operation&lt;/th&gt; &#xA;   &lt;th&gt;Required&lt;br&gt;class&lt;br&gt;constraint&lt;/th&gt; &#xA;   &lt;th&gt;Equivalent&lt;br&gt;class&lt;br&gt;method&lt;/th&gt; &#xA;   &lt;th&gt;Distributive&lt;br&gt;relationship&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:append&#34;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#t:Semigroup&#34;&gt;&lt;code&gt;Semigroup&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#v:-60--62-&#34;&gt;&lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;∀ k. &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k (m1 &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#v:-60--62-&#34;&gt;&amp;lt;&amp;gt;&lt;/a&gt; m2) ≡ &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k m1 &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#v:-60--62-&#34;&gt;&amp;lt;&amp;gt;&lt;/a&gt; &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k m2&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:minus&#34;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://hackage.haskell.org/package/groups/docs/Data-Group.html#t:Group&#34;&gt;&lt;code&gt;Group&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://hackage.haskell.org/package/groups/docs/Data-Group.html#v:-126--126-&#34;&gt;&lt;code&gt;(~~)&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;∀ k. &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k (m1 &lt;a href=&#34;https://hackage.haskell.org/package/groups/docs/Data-Group.html#v:-126--126-&#34;&gt;~~&lt;/a&gt; m2) ≡ &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k m1 &lt;a href=&#34;https://hackage.haskell.org/package/groups/docs/Data-Group.html#v:-126--126-&#34;&gt;~~&lt;/a&gt; &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k m2&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:monus&#34;&gt;&lt;code&gt;monus&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-Monus.html#t:Monus&#34;&gt;&lt;code&gt;Monus&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-Monus.html#v:-60--92--62-&#34;&gt;&lt;code&gt;(&amp;lt;\&amp;gt;)&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;∀ k. &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k (m1 &lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-Monus.html#v:-60--92--62-&#34;&gt;&amp;lt;\&amp;gt;&lt;/a&gt; m2) ≡ &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k m1 &lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-Monus.html#v:-60--92--62-&#34;&gt;&amp;lt;\&amp;gt;&lt;/a&gt; &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k m2&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:intersection&#34;&gt;&lt;code&gt;intersection&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-GCD.html#t:GCDMonoid&#34;&gt;&lt;code&gt;GCDMonoid&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-GCD.html#v:gcd&#34;&gt;&lt;code&gt;gcd&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;∀ k. &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k (m1 `&lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-GCD.html#v:gcd&#34;&gt;gcd&lt;/a&gt;` m2) ≡ &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k m1 `&lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-GCD.html#v:gcd&#34;&gt;gcd&lt;/a&gt;` &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k m2&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:union&#34;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-LCM.html#t:LCMMonoid&#34;&gt;&lt;code&gt;LCMMonoid&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-LCM.html#v:lcm&#34;&gt;&lt;code&gt;lcm&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;∀ k. &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k (m1 `&lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-LCM.html#v:lcm&#34;&gt;lcm&lt;/a&gt;` m2) ≡ &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k m1 `&lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses/docs/Data-Monoid-LCM.html#v:lcm&#34;&gt;lcm&lt;/a&gt;` &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:get&#34;&gt;get&lt;/a&gt; k m2&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Examples of monoidal operations applied to values&lt;/h2&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;&lt;strong&gt;Example: &lt;code&gt;MonoidMap k (Set Integer)&lt;/code&gt;&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;For maps with &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Set.html#t:Set&#34;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt;-based values, &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:union&#34;&gt;&lt;code&gt;MonoidMap.union&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:intersection&#34;&gt;&lt;code&gt;MonoidMap.intersection&lt;/code&gt;&lt;/a&gt; compute the &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Set.html#v:union&#34;&gt;&lt;code&gt;Set.union&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Set.html#v:intersection&#34;&gt;&lt;code&gt;Set.intersection&lt;/code&gt;&lt;/a&gt; of each pair of matching values, respectively.&lt;/p&gt; &#xA; &lt;p&gt;Consider the following maps of type &lt;code&gt;MonoidMap Char (Set Integer)&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m1 = fromList [(&#39;a&#39;, Set.fromList [0, 1]), (&#39;b&#39;, Set.fromList [3, 4])]&#xA;&amp;gt;&amp;gt;&amp;gt; m2 = fromList [(&#39;a&#39;, Set.fromList [0, 2]), (&#39;b&#39;, Set.fromList [3, 5])]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:union&#34;&gt;&lt;code&gt;MonoidMap.union&lt;/code&gt;&lt;/a&gt; of maps &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; is a map that associates every key &lt;code&gt;k&lt;/code&gt; with the &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Set.html#v:union&#34;&gt;&lt;code&gt;Set.union&lt;/code&gt;&lt;/a&gt; of the corresponding sets for &lt;code&gt;k&lt;/code&gt; in &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m1 `union` m2&#xA;fromList [(&#39;a&#39;, Set.fromList [0,1,2]), (&#39;b&#39;, Set.fromList [3,4,5])]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:intersection&#34;&gt;&lt;code&gt;MonoidMap.intersection&lt;/code&gt;&lt;/a&gt; of maps &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; is a map that associates every key &lt;code&gt;k&lt;/code&gt; with the &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Set.html#v:intersection&#34;&gt;&lt;code&gt;Set.intersection&lt;/code&gt;&lt;/a&gt; of the corresponding sets for &lt;code&gt;k&lt;/code&gt; in &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m1 `intersection` m2&#xA;fromList [(&#39;a&#39;, Set.fromList [0]), (&#39;b&#39;, Set.fromList [3])]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;&lt;strong&gt;Example: &lt;code&gt;MonoidMap k (Sum Integer)&lt;/code&gt;&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;Consider the following maps of type &lt;code&gt;MonoidMap Char (Sum Integer)&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m1 = fromList [(&#39;a&#39;, Sum 10), (&#39;b&#39;, Sum 20), (&#39;c, Sum 40)]&#xA;&amp;gt;&amp;gt;&amp;gt; m2 = fromList [(&#39;a&#39;, Sum 40), (&#39;b&#39;, Sum 20), (&#39;c, Sum 10)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:invert&#34;&gt;&lt;code&gt;MonoidMap.invert&lt;/code&gt;&lt;/a&gt; operation produces a new map where every key is associated with the negation of its value in the original map:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; invert m1&#xA;fromList [(&#39;a&#39;, Sum (-10)), (&#39;b&#39;, Sum (-20)), (&#39;c, Sum (-40))]&#xA;&#xA;&amp;gt;&amp;gt;&amp;gt; invert m2&#xA;fromList [(&#39;a&#39;, Sum (-40)), (&#39;b&#39;, Sum (-20)), (&#39;c, Sum (-10))]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:minus&#34;&gt;&lt;code&gt;MonoidMap.minus&lt;/code&gt;&lt;/a&gt; operation, when applied to maps &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt;, produces a new map where every key &lt;code&gt;k&lt;/code&gt; is associated with the value of &lt;code&gt;k&lt;/code&gt; in &lt;code&gt;m1&lt;/code&gt; minus the value of &lt;code&gt;k&lt;/code&gt; in &lt;code&gt;m2&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m1 `minus` m2&#xA;fromList [(&#39;a&#39;, Sum (-30)), (&#39;c&#39;, Sum 30)]&#xA;&#xA;&amp;gt;&amp;gt;&amp;gt; m2 `minus` m1&#xA;fromList [(&#39;a&#39;, Sum 30), (&#39;c&#39;, Sum (-30))]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;&lt;strong&gt;Example: &lt;code&gt;MonoidMap k (Sum Natural)&lt;/code&gt;&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;For maps with &lt;code&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Sum&#34;&gt;Sum&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Numeric-Natural.html#t:Natural&#34;&gt;Natural&lt;/a&gt;&lt;/code&gt; values, &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:union&#34;&gt;&lt;code&gt;MonoidMap.union&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:intersection&#34;&gt;&lt;code&gt;MonoidMap.intersection&lt;/code&gt;&lt;/a&gt; compute the &lt;em&gt;maximum&lt;/em&gt; and &lt;em&gt;minimum&lt;/em&gt; of each pair of matching values, respectively:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m1 = fromList [(&#39;a&#39;, Sum 10), (&#39;b&#39;, Sum 20)]&#xA;&amp;gt;&amp;gt;&amp;gt; m2 = fromList [(&#39;a&#39;, Sum 20), (&#39;b&#39;, Sum 10)]&#xA;&#xA;&amp;gt;&amp;gt;&amp;gt; m1 `union` m2&#xA;fromList [(&#39;a&#39;, Sum 20), (&#39;b&#39;, Sum 20)]&#xA;&#xA;&amp;gt;&amp;gt;&amp;gt; m1 `intersection` m2&#xA;fromList [(&#39;a&#39;, Sum 10), (&#39;b&#39;, Sum 10)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;&lt;strong&gt;Example: &lt;code&gt;MonoidMap k (Product Natural)&lt;/code&gt;&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;For maps with &lt;code&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Product&#34;&gt;Product&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Numeric-Natural.html#t:Natural&#34;&gt;Natural&lt;/a&gt;&lt;/code&gt; values, &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:union&#34;&gt;&lt;code&gt;MonoidMap.union&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:intersection&#34;&gt;&lt;code&gt;MonoidMap.intersection&lt;/code&gt;&lt;/a&gt; compute the &lt;em&gt;lowest common multiple&lt;/em&gt; (LCM) and &lt;em&gt;greatest common divisor&lt;/em&gt; (GCD) of each pair of matching values, respectively:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;&amp;gt;&amp;gt;&amp;gt; m1 = fromList [(&#39;a&#39;, Product  6), (&#39;b&#39;, Product 15), (&#39;c&#39;, Product 35)]&#xA;&amp;gt;&amp;gt;&amp;gt; m2 = fromList [(&#39;a&#39;, Product 15), (&#39;b&#39;, Product 35), (&#39;c&#39;, Product 77)]&#xA;&#xA;&amp;gt;&amp;gt;&amp;gt; m1 `union` m2&#xA;fromList [(&#39;a&#39;, Product 30), (&#39;b&#39;, Product 105), (&#39;c&#39;, Product 385)]&#xA;&#xA;&amp;gt;&amp;gt;&amp;gt; m1 `intersection` m2&#xA;fromList [(&#39;a&#39;, Product 3), (&#39;b&#39;, Product 5), (&#39;c&#39;, Product 7)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h1&gt;General basis for more specialised map types&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; type can be used as a general basis for building other more specialised map types.&lt;/p&gt; &#xA;&lt;p&gt;If you have a &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;-based data type with an invariant that values &lt;strong&gt;must not&lt;/strong&gt; be &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt;, then by expressing this type in terms of &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; will handle the invariant for you:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-patch&#34;&gt;- newtype SomeMap k v = SomeMap (      Map k (SomeMonoidalContainer v))&#xA;+ newtype SomeMap k v = SomeMap (MonoidMap k (SomeMonoidalContainer v))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;re already using a specialised non-empty container type to enforce the invariant that values must not be empty, then &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; makes it possible to &lt;em&gt;replace&lt;/em&gt; the use of the specialised non-empty container type with its ordinary equivalent:&lt;/p&gt; &#xA;&lt;p&gt;Example transformations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-patch&#34;&gt;  -- Non-empty lists:&#xA;- newtype ListMap k v = ListMap (      Map k (NonEmpty v))&#xA;+ newtype ListMap k v = ListMap (MonoidMap k          [v])&#xA;&#xA;  -- Non-empty sets:&#xA;- newtype SetMap k v = SetMap (      Map k (NonEmptySet v))&#xA;+ newtype SetMap k v = SetMap (MonoidMap k         (Set v))&#xA;&#xA;  -- Non-empty sequences:&#xA;- newtype SeqMap k v = SeqMap (      Map k (NonEmptySeq v))&#xA;+ newtype SeqMap k v = SeqMap (MonoidMap k         (Seq v))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; can simplify the implementation of such types, as special handling code for empty values can often be greatly simplified or even eliminated.&lt;/p&gt; &#xA;&lt;h2&gt;Real-world examples from the Haskell ecosystem&lt;/h2&gt; &#xA;&lt;h3&gt;Example: &lt;code&gt;SignedMultiSet&lt;/code&gt; (a signed multiset type)&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/signed-multiset&#34;&gt;&lt;code&gt;signed-multiset&lt;/code&gt;&lt;/a&gt; library provides the &lt;a href=&#34;https://hackage.haskell.org/package/signed-multiset/docs/Data-SignedMultiset.html#t:SignedMultiset&#34;&gt;&lt;code&gt;SignedMultiSet&lt;/code&gt;&lt;/a&gt; type, which is internally defined as a &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; from elements to signed integer occurrence counts:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;newtype SignedMultiset a = SMS {unSMS :: Map a Int}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;All &lt;a href=&#34;https://hackage.haskell.org/package/signed-multiset/docs/Data-SignedMultiset.html#t:SignedMultiset&#34;&gt;&lt;code&gt;SignedMultiSet&lt;/code&gt;&lt;/a&gt; operations maintain an invariant that the internal &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; &lt;strong&gt;must not&lt;/strong&gt; contain any mappings to &lt;code&gt;0&lt;/code&gt; (zero). This requires &lt;a href=&#34;https://hackage.haskell.org/package/signed-multiset/docs/Data-SignedMultiset.html#t:SignedMultiset&#34;&gt;&lt;code&gt;SignedMultiSet&lt;/code&gt;&lt;/a&gt; functions to detect and eliminate values of &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;p&gt;For example, the &lt;a href=&#34;https://hackage.haskell.org/package/signed-multiset/docs/Data-SignedMultiset.html#v:insertMany&#34;&gt;&lt;code&gt;insertMany&lt;/code&gt;&lt;/a&gt; operation:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;insertMany :: Ord a =&amp;gt; a -&amp;gt; Int -&amp;gt; SignedMultiset a -&amp;gt; SignedMultiset a&#xA;insertMany x n = SMS . Map.alter f x . unSMS&#xA;  where&#xA;    f Nothing  = Just n&#xA;    f (Just m) = let k = m + n in if k == 0 then Nothing else Just k&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Let&#39;s redefine &lt;a href=&#34;https://hackage.haskell.org/package/signed-multiset/docs/Data-SignedMultiset.html#t:SignedMultiset&#34;&gt;&lt;code&gt;SignedMultiSet&lt;/code&gt;&lt;/a&gt; in terms of &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- newtype SignedMultiset a = SMS {unSMS ::       Map a      Int }&#xA;+ newtype SignedMultiset a = SMS {unSMS :: MonoidMap a (Sum Int)}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Here we&#39;ve used the &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Sum&#34;&gt;&lt;code&gt;Sum&lt;/code&gt;&lt;/a&gt; wrapper type, whose &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Monoid&#34;&gt;&lt;code&gt;Monoid&lt;/code&gt;&lt;/a&gt; instance defines &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;Sum 0&lt;/code&gt;, and &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#v:-60--62-&#34;&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/a&gt; as ordinary addition.&lt;/p&gt; &#xA; &lt;p&gt;Now we can redefine &lt;a href=&#34;https://hackage.haskell.org/package/signed-multiset/docs/Data-SignedMultiset.html#v:insertMany&#34;&gt;&lt;code&gt;insertMany&lt;/code&gt;&lt;/a&gt; (and similar operations) in a simpler way:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-patch&#34;&gt;  insertMany :: Ord a =&amp;gt; a -&amp;gt; Int -&amp;gt; SignedMultiset a -&amp;gt; SignedMultiset a&#xA;+ insertMany x n = SMS . MonoidMap.adjust (+ Sum n) x . unSMS&#xA;- insertMany x n = SMS . Map.alter f x . unSMS&#xA;-   where&#xA;-     f Nothing  = Just n&#xA;-     f (Just m) = let k = m + n in if k == 0 then Nothing else Just k&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Since the &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:adjust&#34;&gt;&lt;code&gt;MonoidMap.adjust&lt;/code&gt;&lt;/a&gt; operation performs automatic minimisation, values of &lt;code&gt;Sum 0&lt;/code&gt; are automatically excluded from the internal data structure, and there is no need to handle them differently from non-zero values.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Example: &lt;code&gt;SetMultiMap&lt;/code&gt; (a set-based multimap type)&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers&#34;&gt;&lt;code&gt;multi-containers&lt;/code&gt;&lt;/a&gt; library provides the &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers/docs/Data-Multimap-Set.html#t:SetMultimap&#34;&gt;&lt;code&gt;SetMultiMap&lt;/code&gt;&lt;/a&gt; type, which is internally defined as a &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; from keys to (possibly-empty) sets of values, together with a &lt;code&gt;Size&lt;/code&gt; parameter that records the total number of elements in the map (counting duplicates):&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;newtype SetMultimap k a = SetMultimap (Map k (Set a), Size)&#xA;type Size = Int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;All &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers/docs/Data-Multimap-Set.html#t:SetMultimap&#34;&gt;&lt;code&gt;SetMultiMap&lt;/code&gt;&lt;/a&gt; operations maintain an invariant that the internal &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; &lt;strong&gt;must not&lt;/strong&gt; contain any mappings to empty sets. This requires &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers/docs/Data-Multimap-Set.html#t:SetMultimap&#34;&gt;&lt;code&gt;SetMultiMap&lt;/code&gt;&lt;/a&gt; functions to detect and eliminate values of &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Set.html#v:empty&#34;&gt;&lt;code&gt;Set.empty&lt;/code&gt;&lt;/a&gt; (indicated by the &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Set.html#v:null&#34;&gt;&lt;code&gt;Set.null&lt;/code&gt;&lt;/a&gt; function).&lt;/p&gt; &#xA; &lt;p&gt;For example, the &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers/docs/Data-Multimap-Set.html#v:alterWithKey&#34;&gt;&lt;code&gt;alterWithKey&lt;/code&gt;&lt;/a&gt; operation detects if the updated set is empty, and if so, performs a deletion instead of an insertion:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;alterWithKey :: Ord k =&amp;gt; (k -&amp;gt; Set a -&amp;gt; Set a) -&amp;gt; k -&amp;gt; SetMultimap k a -&amp;gt; SetMultimap k a&#xA;alterWithKey f k mm@(SetMultimap (m, _))&#xA;    | Set.null as = fromMap (Map.delete k    m)&#xA;    | otherwise   = fromMap (Map.insert k as m)&#xA;  where&#xA;    as = f k (mm ! k)&#xA;&#xA;fromMap :: Map k (Set a) -&amp;gt; SetMultimap k a&#xA;fromMap m = SetMultimap (m&#39;, sum (fmap Set.size m&#39;))&#xA;  where&#xA;    m&#39; = Map.filter (not . Set.null) m&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Let&#39;s redefine &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers/docs/Data-Multimap-Set.html#t:SetMultimap&#34;&gt;&lt;code&gt;SetMultiMap&lt;/code&gt;&lt;/a&gt; in terms of &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-patch&#34;&gt;- newtype SetMultimap k a = SetMultimap (      Map k (Set a), Size)&#xA;+ newtype SetMultimap k a = SetMultimap (MonoidMap k (Set a), Size)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Now we can provide a simpler definition for &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers/docs/Data-Multimap-Set.html#v:alterWithKey&#34;&gt;&lt;code&gt;alterWithKey&lt;/code&gt;&lt;/a&gt; (and other operations):&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;alterWithKey :: Ord k =&amp;gt; (k -&amp;gt; Set a -&amp;gt; Set a) -&amp;gt; k -&amp;gt; SetMultimap k a -&amp;gt; SetMultimap k a&#xA;alterWithKey f k (SetMultimap (m, size)) = SetMultiMap&#xA;    (MonoidMap.set k new m, size - Set.size old + Set.size new)&#xA;  where&#xA;    old = MonoidMap.get k m&#xA;    new = f k old&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Since the &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:set&#34;&gt;&lt;code&gt;MonoidMap.set&lt;/code&gt;&lt;/a&gt; operation performs automatic minimisation, empty sets are automatically excluded from the internal data structure, and there is no need to handle them any differently from non-empty sets.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Example: &lt;code&gt;MultiMap&lt;/code&gt; (a list-based multimap type)&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers&#34;&gt;&lt;code&gt;multi-containers&lt;/code&gt;&lt;/a&gt; library provides the &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers/docs/Data-Multimap.html#t:Multimap&#34;&gt;&lt;code&gt;MultiMap&lt;/code&gt;&lt;/a&gt; type, which is internally defined as a &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; from keys to non-empty lists of values, together with a &lt;code&gt;Size&lt;/code&gt; parameter that records the total number of elements in the map (counting duplicates):&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;newtype Multimap k a = Multimap (Map k (NonEmpty a), Size)&#xA;type Size = Int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;All &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers/docs/Data-Multimap.html#t:Multimap&#34;&gt;&lt;code&gt;MultiMap&lt;/code&gt;&lt;/a&gt; operations maintain the invariant that the internal &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; &lt;strong&gt;must not&lt;/strong&gt; contain any mappings to empty lists. This invariant is handled rather nicely by the use of the &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-List-NonEmpty.html#t:NonEmpty&#34;&gt;&lt;code&gt;NonEmpty&lt;/code&gt;&lt;/a&gt; list type, which disallows empty lists &lt;em&gt;by construction&lt;/em&gt;. As a result, it&#39;s arguably more difficult to make a mistake in the implementation than it would be if &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers/docs/Data-Multimap.html#t:Multimap&#34;&gt;&lt;code&gt;MultiMap&lt;/code&gt;&lt;/a&gt; were defined in terms of ordinary lists.&lt;/p&gt; &#xA; &lt;p&gt;However, certain operations still need to differentiate between the empty and non-empty case, and it&#39;s still necessary to handle each case specially.&lt;/p&gt; &#xA; &lt;p&gt;For example, the &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers/docs/Data-Multimap.html#v:alterWithKey&#34;&gt;&lt;code&gt;alterWithKey&lt;/code&gt;&lt;/a&gt; operation detects if the updated list is empty, and if so, performs a deletion instead of an insertion:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;alterWithKey :: Ord k =&amp;gt; (k -&amp;gt; [a] -&amp;gt; [a]) -&amp;gt; k -&amp;gt; Multimap k a -&amp;gt; Multimap k a&#xA;alterWithKey f k mm@(Multimap (m, _)) = case nonEmpty (f k (mm ! k)) of&#xA;    Just as&#39; -&amp;gt; fromMap (Map.insert k as&#39; m)&#xA;    Nothing  -&amp;gt; fromMap (Map.delete k     m)&#xA;&#xA;fromMap :: Map k (NonEmpty a) -&amp;gt; Multimap k a&#xA;fromMap m = Multimap (m, sum (fmap length m))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Let&#39;s redefine &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers/docs/Data-Multimap.html#t:Multimap&#34;&gt;&lt;code&gt;MultiMap&lt;/code&gt;&lt;/a&gt; in terms of &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; and ordinary lists:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-patch&#34;&gt;- newtype Multimap k a = Multimap (      Map k (NonEmpty a), Size)&#xA;+ newtype Multimap k a = Multimap (MonoidMap k          [a], Size)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Now we can provide a simpler definition for &lt;a href=&#34;https://hackage.haskell.org/package/multi-containers/docs/Data-Multimap.html#v:alterWithKey&#34;&gt;&lt;code&gt;alterWithKey&lt;/code&gt;&lt;/a&gt; (and other operations):&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;alterWithKey :: Ord k =&amp;gt; (k -&amp;gt; [a] -&amp;gt; [a]) -&amp;gt; k -&amp;gt; Multimap k a -&amp;gt; Multimap k a&#xA;alterWithKey f k (Multimap (m, size)) = MultiMap&#xA;    (MonoidMap.set k new m, size - List.length old + List.length new)&#xA;  where&#xA;    old = MonoidMap.get k m&#xA;    new = f k old&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Since the &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#v:set&#34;&gt;&lt;code&gt;MonoidMap.set&lt;/code&gt;&lt;/a&gt; operation performs automatic minimisation:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;empty lists are automatically excluded from the internal data structure.&lt;/li&gt; &#xA;  &lt;li&gt;there is no need to use a specialised &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-List-NonEmpty.html#t:NonEmpty&#34;&gt;&lt;code&gt;NonEmpty&lt;/code&gt;&lt;/a&gt; type.&lt;/li&gt; &#xA;  &lt;li&gt;there is no need to handle empty lists differently from non-empty lists.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Example: &lt;code&gt;MultiAsset&lt;/code&gt; (a nested map type)&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger&#34;&gt;&lt;code&gt;cardano-ledger&lt;/code&gt;&lt;/a&gt; library provides the &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L157&#34;&gt;&lt;code&gt;MultiAsset&lt;/code&gt;&lt;/a&gt; type, which models a &lt;strong&gt;nested&lt;/strong&gt; mapping from &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L140&#34;&gt;&lt;code&gt;PolicyID&lt;/code&gt;&lt;/a&gt; keys to &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L110&#34;&gt;&lt;code&gt;AssetName&lt;/code&gt;&lt;/a&gt; keys to &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer&#34;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; values:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;newtype MultiAsset c = MultiAsset (Map (PolicyID c) (Map AssetName Integer))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Each &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer&#34;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; value represents the value of an &lt;strong&gt;asset&lt;/strong&gt; on the Cardano blockchain, where each asset is uniquely identified by the combination of a &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L140&#34;&gt;&lt;code&gt;PolicyID&lt;/code&gt;&lt;/a&gt; and an &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L110&#34;&gt;&lt;code&gt;AssetName&lt;/code&gt;&lt;/a&gt;. (Multiple assets can share the same &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L140&#34;&gt;&lt;code&gt;PolicyID&lt;/code&gt;&lt;/a&gt;.)&lt;/p&gt; &#xA; &lt;p&gt;All &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L157&#34;&gt;&lt;code&gt;MultiAsset&lt;/code&gt;&lt;/a&gt; operations maintain a &lt;strong&gt;dual invariant&lt;/strong&gt; that:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;there must be no mappings from &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L140&#34;&gt;&lt;code&gt;PolicyID&lt;/code&gt;&lt;/a&gt; keys to empty maps; and that&lt;/li&gt; &#xA;  &lt;li&gt;there must be no mappings from &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L110&#34;&gt;&lt;code&gt;AssetName&lt;/code&gt;&lt;/a&gt; keys to &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer&#34;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; values of &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;To satisfy this invariant, &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L157&#34;&gt;&lt;code&gt;MultiAsset&lt;/code&gt;&lt;/a&gt; operations use a variety of helper functions to ensure that &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L157&#34;&gt;&lt;code&gt;MultiAsset&lt;/code&gt;&lt;/a&gt; values are always in a canonical form.&lt;/p&gt; &#xA; &lt;p&gt;For example, consider the &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#t:Semigroup&#34;&gt;&lt;code&gt;Semigroup&lt;/code&gt;&lt;/a&gt; instance for &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L157&#34;&gt;&lt;code&gt;MultiAsset&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;instance Semigroup (MultiAsset c) where&#xA;    MultiAsset m1 &amp;lt;&amp;gt; MultiAsset m2 =&#xA;        MultiAsset (canonicalMapUnion (canonicalMapUnion (+)) m1 m2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The above definition of &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#v:-60--62-&#34;&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/a&gt; performs pointwise addition of all pairs of values for matching assets.&lt;/p&gt; &#xA; &lt;p&gt;For example, if:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L157&#34;&gt;&lt;code&gt;MultiAsset&lt;/code&gt;&lt;/a&gt; &lt;code&gt;m1&lt;/code&gt; maps asset &lt;code&gt;a&lt;/code&gt; to a value of &lt;code&gt;10&lt;/code&gt;;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L157&#34;&gt;&lt;code&gt;MultiAsset&lt;/code&gt;&lt;/a&gt; &lt;code&gt;m2&lt;/code&gt; maps asset &lt;code&gt;a&lt;/code&gt; to a value of &lt;code&gt;20&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;Then:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L157&#34;&gt;&lt;code&gt;MultiAsset&lt;/code&gt;&lt;/a&gt; &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; will map asset &lt;code&gt;a&lt;/code&gt; to a value of &lt;code&gt;30&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;The definition of &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#v:-60--62-&#34;&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/a&gt; uses a function called &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/libs/cardano-data/src/Data/CanonicalMaps.hs#L42&#34;&gt;&lt;code&gt;canonicalMapUnion&lt;/code&gt;&lt;/a&gt;, which does the heavy lifting work of performing a union while ensuring that each resulting &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; is in canonical form.&lt;/p&gt; &#xA; &lt;p&gt;Let&#39;s have a look at the definition of &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/libs/cardano-data/src/Data/CanonicalMaps.hs#L42&#34;&gt;&lt;code&gt;canonicalMapUnion&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;canonicalMapUnion ::&#xA;  (Ord k, CanonicalZero a) =&amp;gt;&#xA;  (a -&amp;gt; a -&amp;gt; a) -&amp;gt;&#xA;  Map k a -&amp;gt;&#xA;  Map k a -&amp;gt;&#xA;  Map k a&#xA;canonicalMapUnion _f t1 Tip                 = t1&#xA;canonicalMapUnion  f t1 (Bin _ k x Tip Tip) = canonicalInsert f k x t1&#xA;canonicalMapUnion  f (Bin _ k x Tip Tip) t2 = canonicalInsert f k x t2&#xA;canonicalMapUnion _f Tip t2                 = t2&#xA;canonicalMapUnion  f (Bin _ k1 x1 l1 r1) t2 = case Map.splitLookup k1 t2 of&#xA;  (l2, mb, r2) -&amp;gt; case mb of&#xA;    Nothing -&amp;gt;&#xA;      if x1 == zeroC&#xA;        then link2 l1l2 r1r2&#xA;        else link k1 x1 l1l2 r1r2&#xA;    Just x2 -&amp;gt;&#xA;      if new == zeroC&#xA;        then link2 l1l2 r1r2&#xA;        else link k1 new l1l2 r1r2&#xA;      where&#xA;        new = f x1 x2&#xA;    where&#xA;      !l1l2 = canonicalMapUnion f l1 l2&#xA;      !r1r2 = canonicalMapUnion f r1 r2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/libs/cardano-data/src/Data/CanonicalMaps.hs#L42&#34;&gt;&lt;code&gt;canonicalMapUnion&lt;/code&gt;&lt;/a&gt; function in turn relies on &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/libs/cardano-data/src/Data/CanonicalMaps.hs#L69&#34;&gt;&lt;code&gt;canonicalInsert&lt;/code&gt;&lt;/a&gt;, which handles individual insertions:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;canonicalInsert ::&#xA;  (Ord k, CanonicalZero a) =&amp;gt;&#xA;  (a -&amp;gt; a -&amp;gt; a) -&amp;gt;&#xA;  k -&amp;gt;&#xA;  a -&amp;gt;&#xA;  Map k a -&amp;gt;&#xA;  Map k a&#xA;canonicalInsert f !kx x = go&#xA;  where&#xA;    go Tip = if x == zeroC then Tip else Map.singleton kx x&#xA;    go (Bin sy ky y l r) =&#xA;      case compare kx ky of&#xA;        LT -&amp;gt; link ky y (go l) r&#xA;        GT -&amp;gt; link ky y l (go r)&#xA;        EQ -&amp;gt; if new == zeroC then link2 l r else Bin sy kx new l r&#xA;          where&#xA;            new = f y x&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Similarly, the &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#LL831C1-L868C10&#34;&gt;&lt;code&gt;insertMultiAsset&lt;/code&gt;&lt;/a&gt; function, which &#34;inserts&#34; the value of an individual asset into a &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L157&#34;&gt;&lt;code&gt;MultiAsset&lt;/code&gt;&lt;/a&gt; value, has the following definition:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;insertMultiAsset ::&#xA;  (Integer -&amp;gt; Integer -&amp;gt; Integer) -&amp;gt;&#xA;  PolicyID c -&amp;gt;&#xA;  AssetName -&amp;gt;&#xA;  Integer -&amp;gt;&#xA;  MultiAsset c -&amp;gt;&#xA;  MultiAsset c&#xA;insertMultiAsset combine pid aid new (MultiAsset m1) =&#xA;  case Map.splitLookup pid m1 of&#xA;    (l1, Just m2, l2) -&amp;gt;&#xA;      case Map.splitLookup aid m2 of&#xA;        (v1, Just old, v2) -&amp;gt;&#xA;          if n == 0&#xA;            then&#xA;              let m3 = link2 v1 v2&#xA;               in if Map.null m3&#xA;                    then MultiAsset (link2 l1 l2)&#xA;                    else MultiAsset (link pid m3 l1 l2)&#xA;            else MultiAsset (link pid (link aid n v1 v2) l1 l2)&#xA;          where&#xA;            n = combine old new&#xA;        (_, Nothing, _) -&amp;gt;&#xA;          MultiAsset&#xA;            ( link&#xA;                pid&#xA;                ( if new == 0&#xA;                    then m2&#xA;                    else Map.insert aid new m2&#xA;                )&#xA;                l1&#xA;                l2&#xA;            )&#xA;    (l1, Nothing, l2) -&amp;gt;&#xA;      MultiAsset&#xA;        ( if new == 0&#xA;            then link2 l1 l2&#xA;            else link pid (Map.singleton aid new) l1 l2&#xA;        )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;A notable feature of all the above functions is that they completely eschew the use of &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Merge-Strict.html#v:merge&#34;&gt;&lt;code&gt;Map.merge&lt;/code&gt;&lt;/a&gt;. Instead, they directly manipulate constructors exported from &lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Internal.html&#34;&gt;&lt;code&gt;Map.Internal&lt;/code&gt;&lt;/a&gt;. This approach was probably taken for performance reasons.&lt;/p&gt; &#xA; &lt;p&gt;However, it&#39;s clear that maintaining the invariant in this way comes at a &lt;strong&gt;cost&lt;/strong&gt;: the code is rather complex, and it were not for a comprehensive test suite, it would probably be very easy to introduce a regression.&lt;/p&gt; &#xA; &lt;p&gt;In the spirit of demonstration, let&#39;s see what happens if we redefine the &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L157&#34;&gt;&lt;code&gt;MultiAsset&lt;/code&gt;&lt;/a&gt; type in terms of &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-patch&#34;&gt;- newtype MultiAsset c = MultiAsset (Map       (PolicyID c) (      Map AssetName      Integer))&#xA;+ newtype MultiAsset c = MultiAsset (MonoidMap (PolicyID c) (MonoidMap AssetName (Sum Integer))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Note that we have replaced &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer&#34;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Sum&#34;&gt;Sum&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer&#34;&gt;Integer&lt;/a&gt;&lt;/code&gt;, whose &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Monoid&#34;&gt;&lt;code&gt;Monoid&lt;/code&gt;&lt;/a&gt; instance defines &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Sum&#34;&gt;Sum&lt;/a&gt; 0&lt;/code&gt;, and whose &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#t:Semigroup&#34;&gt;&lt;code&gt;Semigroup&lt;/code&gt;&lt;/a&gt; instance defines &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#v:-60--62-&#34;&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/a&gt; as equivalent to ordinary integer addition.&lt;/p&gt; &#xA; &lt;p&gt;Recall that all &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; operations automatically take care of the invariant that values cannot be &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:mempty&#34;&gt;&lt;code&gt;mempty&lt;/code&gt;&lt;/a&gt;. For the &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L157&#34;&gt;&lt;code&gt;MultiAsset&lt;/code&gt;&lt;/a&gt; type, this means that:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;outer maps are now prevented from including any mappings from &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L140&#34;&gt;&lt;code&gt;PolicyID&lt;/code&gt;&lt;/a&gt; to empty inner maps.&lt;/li&gt; &#xA;  &lt;li&gt;inner maps are now prevented from including any mappings from &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L110&#34;&gt;&lt;code&gt;AssetName&lt;/code&gt;&lt;/a&gt; to values of &lt;code&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#v:Sum&#34;&gt;Sum&lt;/a&gt; 0&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;As a result, we can remove virtually all code that deals with canonicalisation.&lt;/p&gt; &#xA; &lt;p&gt;For example, we can now simplify the &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#t:Semigroup&#34;&gt;&lt;code&gt;Semigroup&lt;/code&gt;&lt;/a&gt; instance for &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L157&#34;&gt;&lt;code&gt;MultiAsset&lt;/code&gt;&lt;/a&gt;, dispensing entirely with the need to call &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/libs/cardano-data/src/Data/CanonicalMaps.hs#L42&#34;&gt;&lt;code&gt;canonicalMapUnion&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-patch&#34;&gt;  instance Semigroup (MultiAsset c) where&#xA;      MultiAsset m1 &amp;lt;&amp;gt; MultiAsset m2 =&#xA;-         MultiAsset (canonicalMapUnion (canonicalMapUnion (+)) m1 m2)&#xA;+         m1 &amp;lt;&amp;gt; m2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Given that the above instance is trivial, we can even derive the &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Semigroup.html#t:Semigroup&#34;&gt;&lt;code&gt;Semigroup&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Monoid&#34;&gt;&lt;code&gt;Monoid&lt;/code&gt;&lt;/a&gt; instances automatically:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-patch&#34;&gt;  newtype MultiAsset c = MultiAsset (MonoidMap (PolicyID c) (MonoidMap AssetName (Sum Integer))&#xA;+     deriving newtype (Semigroup, Monoid)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;We can also simplify the &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#LL831C1-L868C10&#34;&gt;&lt;code&gt;insertMultiAsset&lt;/code&gt;&lt;/a&gt; function:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-patch&#34;&gt;  insertMultiAsset ::&#xA;    (Integer -&amp;gt; Integer -&amp;gt; Integer) -&amp;gt;&#xA;    PolicyID c -&amp;gt;&#xA;    AssetName -&amp;gt;&#xA;    Integer -&amp;gt;&#xA;    MultiAsset c -&amp;gt;&#xA;    MultiAsset c&#xA;  insertMultiAsset combine pid aid new (MultiAsset m1) =&#xA;+   MultiAsset $&#xA;+   MonoidMap.adjust&#xA;+     (MonoidMap.adjust (\(M.Sum old) -&amp;gt; M.Sum (combine old new)) aid) pid m1&#xA;-  ...&#xA;-  ### 27 lines deleted ###&#xA;-  ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Finally, since &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; already provides &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq&#34;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://hackage.haskell.org/package/groups/docs/Data-Group.html#t:Group&#34;&gt;&lt;code&gt;Group&lt;/code&gt;&lt;/a&gt; instances that are defined in terms of the underlying monoidal value type, we can automatically derive &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq&#34;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://hackage.haskell.org/package/groups/docs/Data-Group.html#t:Group&#34;&gt;&lt;code&gt;Group&lt;/code&gt;&lt;/a&gt; instances for &lt;a href=&#34;https://github.com/input-output-hk/cardano-ledger/raw/b00e28698d9c7fbbeda1c9cfdd1238d3bc4569cf/eras/mary/impl/src/Cardano/Ledger/Mary/Value.hs#L157&#34;&gt;&lt;code&gt;MultiAsset&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-patch&#34;&gt;  newtype MultiAsset c = MultiAsset (MonoidMap (PolicyID c) (MonoidMap AssetName (Sum Integer))&#xA;-     deriving newtype (Semigroup, Monoid)&#xA;+     deriving newtype (Eq, Semigroup, Monoid, Group)&#xA;&#xA;- instance Eq (MultiAsset c) where&#xA;-   MultiAsset x == MultiAsset y = pointWise (pointWise (==)) x y&#xA;-&#xA;- instance Group (MultiAsset c) where&#xA;-   invert (MultiAsset m) =&#xA;-     MultiAsset (canonicalMap (canonicalMap ((-1 :: Integer) *)) m)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Many other simplifications are also possible. (Left as an exercise for readers!)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Comparison with other generalised map types&lt;/h1&gt; &#xA;&lt;p&gt;The Haskell ecosystem has several different types for maps with monoidal properties, and several different types that model total functions from keys to values. Each type comes with its own set of advantages and limitations.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a comparison between the &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt;&lt;code&gt;MonoidMap&lt;/code&gt;&lt;/a&gt; type provided by this library and types provided by other libraries:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr valign=&#34;top&#34; align=&#34;left&#34;&gt; &#xA;   &lt;th rowspan=&#34;2&#34;&gt;Type&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/th&gt; &#xA;   &lt;th colspan=&#34;2&#34;&gt;Features&lt;/th&gt; &#xA;   &lt;th colspan=&#34;5&#34;&gt;Class Instances&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr valign=&#34;top&#34; align=&#34;left&#34;&gt; &#xA;   &lt;th&gt; Models&lt;br&gt;total&lt;br&gt;functions &lt;/th&gt; &#xA;   &lt;th&gt; Performs&lt;br&gt;automatic&lt;br&gt;minimisation &lt;/th&gt; &#xA;   &lt;th&gt; &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq&#34;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; &lt;/th&gt; &#xA;   &lt;th&gt; &lt;a href=&#34;https://hackage.haskell.org/package/monoid-subclasses&#34;&gt; &lt;code&gt;Monoid&lt;/code&gt;&lt;br&gt;&lt;em&gt;subclasses&lt;/em&gt; &lt;/a&gt; &lt;/th&gt; &#xA;   &lt;th&gt; &lt;a href=&#34;https://hackage.haskell.org/package/groups/docs/Data-Group.html#t:Group&#34;&gt; &lt;code&gt;Group&lt;/code&gt; &lt;/a&gt; &lt;/th&gt; &#xA;   &lt;th&gt; &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Functor.html#t:Functor&#34;&gt; &lt;code&gt;Functor&lt;/code&gt; &lt;/a&gt; &lt;/th&gt; &#xA;   &lt;th&gt; &lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Control-Applicative.html#t:Applicative&#34;&gt; &lt;code&gt;Applicative&lt;/code&gt; &lt;/a&gt; &lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://github.com/jonathanknowles/monoidmap&#34;&gt; &lt;code&gt;&lt;em&gt;monoidmap&lt;/em&gt;&lt;/code&gt; &lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://jonathanknowles.github.io/monoidmap/Data-MonoidMap.html#t:MonoidMap&#34;&gt; &lt;code&gt;MonoidMap&lt;/code&gt; &lt;/a&gt; &lt;br&gt; (this library) &lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://hackage.haskell.org/package/monoid-map&#34;&gt; &lt;code&gt;&lt;em&gt;monoid‑map&lt;/em&gt;&lt;/code&gt; &lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://hackage.haskell.org/package/monoid-map/docs/Data-MonoidMap.html&#34;&gt; &lt;code&gt;MonoidMap&lt;/code&gt; &lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://hackage.haskell.org/package/monoidal-containers&#34;&gt; &lt;code&gt;&lt;em&gt;monoidal‑containers&lt;/em&gt;&lt;/code&gt; &lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://hackage.haskell.org/package/monoidal-containers/docs/Data-Map-Monoidal.html#t:MonoidalMap&#34;&gt; &lt;code&gt;MonoidalMap&lt;/code&gt; &lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://hackage.haskell.org/package/total-map&#34;&gt; &lt;code&gt;&lt;em&gt;total‑map&lt;/em&gt;&lt;/code&gt; &lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://hackage.haskell.org/package/total-map/docs/Data-TotalMap.html#t:TMap&#34;&gt; &lt;code&gt;TMap&lt;/code&gt; &lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://hackage.haskell.org/package/total-maps&#34;&gt; &lt;code&gt;&lt;em&gt;total‑maps&lt;/em&gt;&lt;/code&gt; &lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://hackage.haskell.org/package/total-maps/docs/Data-Total-Map-Sparse.html#t:TotalSparseMap&#34;&gt; &lt;code&gt;TotalSparseMap&lt;/code&gt; &lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://hackage.haskell.org/package/defaultable-map&#34;&gt; &lt;code&gt;&lt;em&gt;defaultable‑map&lt;/em&gt;&lt;/code&gt; &lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://hackage.haskell.org/package/defaultable-map/docs/Defaultable-Map.html#t:Defaultable&#34;&gt; &lt;code&gt;DefaultableMap&lt;/code&gt; &lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://hackage.haskell.org/package/chatter&#34;&gt; &lt;code&gt;&lt;em&gt;chatter&lt;/em&gt;&lt;/code&gt; &lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://hackage.haskell.org/package/chatter/docs/Data-DefaultMap.html#t:DefaultMap&#34;&gt; &lt;code&gt;DefaultMap&lt;/code&gt; &lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://hackage.haskell.org/package/stack&#34;&gt; &lt;code&gt;&lt;em&gt;stack&lt;/em&gt;&lt;/code&gt; &lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://hackage.haskell.org/package/stack/docs/Data-Monoid-Map.html#t:MonoidMap&#34;&gt; &lt;code&gt;MonoidMap&lt;/code&gt; &lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✔&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;❌&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
  <entry>
    <title>osa1/Shen.hs</title>
    <updated>2023-06-05T01:37:21Z</updated>
    <id>tag:github.com,2023-06-05:/osa1/Shen.hs</id>
    <link href="https://github.com/osa1/Shen.hs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Shen implementation in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Shen.hs&lt;/h2&gt; &#xA;&lt;p&gt;Shen.hs is a K Lambda interpreter written in Haskell. It&#39;s main goal is to run Shen language.&lt;/p&gt; &#xA;&lt;h2&gt;Current status&lt;/h2&gt; &#xA;&lt;p&gt;Shen test suite runs with following result:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;passed ... 120&#xA;failed ...8&#xA;pass rate ...93.75%&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And benchmarks fails with: &lt;code&gt;UserError &#34;==&amp;gt; is not a legitimate function name.\r\n&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Shen.hs comes with required K Lambda source, but interpreter doesn&#39;t automatically load Shen sources.&lt;/p&gt; &#xA;&lt;p&gt;Just clone the repository and install with &lt;code&gt;cabal install&lt;/code&gt;. An executable with name &lt;code&gt;Shen.hs&lt;/code&gt; will be installed. This executable actually runs the K Lambda interpreter, it doesn&#39;t load Shen sources.&lt;/p&gt; &#xA;&lt;p&gt;To load Shen sources, run &lt;code&gt;(load-shen &#34;path-to-K Lambda-folder&#34;)&lt;/code&gt;. ie. &lt;code&gt;(load-shen &#34;/home/omer/Shen 12/K Lambda&#34;)&lt;/code&gt; in interpreter.&lt;/p&gt; &#xA;&lt;h2&gt;Contributions&lt;/h2&gt; &#xA;&lt;p&gt;This project has been a long time hobby of mine, but I can&#39;t spare enough time to fix bugs and improve performance. There are lots of things to improve and fix in the source. Contributions are welcome, please visit issues page to see list of reported issues.&lt;/p&gt;</summary>
  </entry>
</feed>