<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-04T01:38:21Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>marknsikora/euler</title>
    <updated>2023-06-04T01:38:21Z</updated>
    <id>tag:github.com,2023-06-04:/marknsikora/euler</id>
    <link href="https://github.com/marknsikora/euler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Project Euler solutions&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>markandrus/Matrix-Decomposition</title>
    <updated>2023-06-04T01:38:21Z</updated>
    <id>tag:github.com,2023-06-04:/markandrus/Matrix-Decomposition</id>
    <link href="https://github.com/markandrus/Matrix-Decomposition" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Matrix Decomposition&lt;/h1&gt; &#xA;&lt;p&gt;This source repository contains my solutions to Homework 6, consisting of the three programs&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;main&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tests&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsa&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;code&gt;sample-output.txt&lt;/code&gt; shows the kind of output you should expect from running &lt;code&gt;./main -v -P -S -R -T&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;All three programs are written in Haskell and rely on GHC and a number of Cabal packages.&lt;/p&gt; &#xA;&lt;p&gt;The included &lt;code&gt;Makefile&lt;/code&gt; handles compilation, and the three binaries may be built with &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Package Requirements&lt;/h3&gt; &#xA;&lt;p&gt;If &lt;code&gt;make&lt;/code&gt; fails, it is probably because you are missing a cabal package. These programs rely on &lt;a href=&#34;https://github.com/AlbertoRuiz/hmatrix&#34;&gt;HMatrix&lt;/a&gt;, which can be installed with the included &lt;code&gt;setup.sh&lt;/code&gt; script, or with the command &lt;code&gt;cabal install hmatrix&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CSV&lt;/li&gt; &#xA; &lt;li&gt;HMatrix&lt;/li&gt; &#xA; &lt;li&gt;QuickCheck&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Eigendecomposition and Singular Value Decomposition (SVD)&lt;/h2&gt; &#xA;&lt;p&gt;Parts 1 and 2 of Homework 6 require implementation of &lt;a href=&#34;http://en.wikipedia.org/wiki/Eigendecomposition&#34;&gt;Eigendecomposition&lt;/a&gt; and &lt;a href=&#34;http://en.wikipedia.org/wiki/Singular_Value_Decomposition&#34;&gt;SVD&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;My implementation of eigendecomposition uses the Power Method (&lt;a href=&#34;http://en.wikipedia.org/wiki/Power_iteration&#34;&gt;power iteration&lt;/a&gt; and &lt;a href=&#34;http://www.miislita.com/information-retrieval-tutorial/matrix-tutorial-3-eigenvalues-eigenvectors.html&#34;&gt;deflation&lt;/a&gt;) to compute &lt;code&gt;A = V \Lambda V^T&lt;/code&gt; for a real-valued matrix &lt;code&gt;A&lt;/code&gt;. See &lt;code&gt;PowerMethod.hs&lt;/code&gt; for a detailed comments.&lt;/p&gt; &#xA;&lt;p&gt;My SVD implementation also relies on eigendecomposition to compute &lt;code&gt;A = U S V^T&lt;/code&gt;. See &lt;code&gt;SVD.hs&lt;/code&gt; for detailed comments.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./main -h&#xA;main&#xA;&#x9;-d INT     --decimal-places=INT  Number of decimal places to display&#xA;&#x9;-e DOUBLE  --epsilon=DOUBLE      Precision parameter&#xA;&#x9;-P         --power-method        Compute the eigen-vectors and values of the 2D matrix&#xA;&#x9;-S         --svd                 Compute the singular value decomposition of the 2D matrix&#xA;&#x9;-R         --recombine           Compute the Frobenius norm of the difference between the 2D matrix and its reconstructions&#xA;&#x9;-T         --test-truncation     Compute the Frobenius norms of the differences between the 2D matrix and its reconstructions from truncated singular values&#xA;&#x9;-v         --verbose             Enable verbose messages&#xA;&#x9;-h         --help                Show help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Executing &lt;code&gt;./main -v -P -S -R -T path/to/A.txt&lt;/code&gt;, where &lt;code&gt;A.txt&lt;/code&gt; is a 2D ASCII representation of the real-valued matrix &lt;code&gt;A&lt;/code&gt;, will generate a report demonstrating&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Eigenvector decomposition of the input matrix, &lt;code&gt;A&lt;/code&gt;, including (enabled with &lt;code&gt;-P&lt;/code&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Reconstruction of &lt;code&gt;A&#39;&lt;/code&gt; from &lt;code&gt;V \Lambda V^T&lt;/code&gt; (enabled with &lt;code&gt;-R&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;The Frobenius norm of the difference between the input matrix and its reconstruction (enabled with &lt;code&gt;-R&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Singular value decomposition of the input matrix, &lt;code&gt;A&lt;/code&gt;, including (enabled with &lt;code&gt;-S&lt;/code&gt;) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Reconstruction of &lt;code&gt;A&#39;&lt;/code&gt; from &lt;code&gt;U S V^T&lt;/code&gt; (enabled with &lt;code&gt;-R&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;The Frobenius norm of the difference between the input matrix and its reconstruction (enabled with &lt;code&gt;-R&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The Frobenius norm of a 10 by 20 random matrix minus its recomposition, &lt;code&gt;U S_i V^T&lt;/code&gt;--where &lt;code&gt;S_i&lt;/code&gt; is a diagonal matrix with all but the first &lt;code&gt;i&lt;/code&gt; singular values truncated (enabled with &lt;code&gt;-T&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Results from Truncating Singular Values&lt;/h3&gt; &#xA;&lt;p&gt;The following table shows the Frobenius norms of the differences (&lt;code&gt;d&lt;/code&gt;) between the 2D matrix and its reconstructions from &lt;code&gt;i&lt;/code&gt; singular values&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;code&gt;i&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;code&gt;d&lt;/code&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;3.793e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;3.249e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;2.869e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;2.484e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;   &lt;td&gt;2.106e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;6&lt;/td&gt; &#xA;   &lt;td&gt;1.651e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;7&lt;/td&gt; &#xA;   &lt;td&gt;1.196e0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;8&lt;/td&gt; &#xA;   &lt;td&gt;9.026e-1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;9&lt;/td&gt; &#xA;   &lt;td&gt;5.626e-1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;10&lt;/td&gt; &#xA;   &lt;td&gt;5.920e-4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Tests&lt;/h2&gt; &#xA;&lt;p&gt;I offer a set of QuickCheck tests to verify against HMatrix&#39;s own implementation of &lt;code&gt;eigSH&lt;/code&gt; that my &lt;code&gt;powerMethod&lt;/code&gt; works:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./tests&#xA;ident/isSymmetric        : +++ OK, passed 100 tests.&#xA;multByIdent/id           : +++ OK, passed 100 tests.&#xA;powMeth/eigVals_ex1      : +++ OK, passed 100 tests.&#xA;powMeth/eigVals_ex2      : +++ OK, passed 100 tests.&#xA;powMeth/eigVals_ex3      : +++ OK, passed 100 tests.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Examples 1 through 3 in &lt;code&gt;Tests.hs&lt;/code&gt; confirm that&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The the N eigenvalues of an N by N identity matrix are all 1&lt;/li&gt; &#xA; &lt;li&gt;That the eigenvalues computed for a small, 2 by 2 matrix match those expected (within &lt;code&gt;epsilon&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;That the eigenvalues computed by &lt;code&gt;powerMethod&lt;/code&gt; for an arbitrary square matrix match those computed by &lt;code&gt;eigSH&lt;/code&gt; (within &lt;code&gt;epsilon&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>