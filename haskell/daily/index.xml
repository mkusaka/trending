<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-25T01:42:26Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>GaloisInc/parameterized-utils</title>
    <updated>2022-07-25T01:42:26Z</updated>
    <id>tag:github.com,2022-07-25:/GaloisInc/parameterized-utils</id>
    <link href="https://github.com/GaloisInc/parameterized-utils" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A set of utilities for using indexed types including containers, equality, and comparison.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Overview&lt;/h1&gt; &#xA;&lt;p&gt;The parameterized-utils module contains a collection of typeclasses and datatypes for working with parameterized types, that is types that have a type argument. One example would be a algebraic data type for expressions, that use a type parameter to describe the type of the expression.&lt;/p&gt; &#xA;&lt;p&gt;This packaged provides collections classes for these parameterized types.&lt;/p&gt; &#xA;&lt;h1&gt;Parameterized Types Motivation&lt;/h1&gt; &#xA;&lt;p&gt;Parameterized types are types with a single type parameter. One use of the type parameter is to embed the type system of an AST into Haskell, in order to have the Haskell compiler provide static guarantees of correctness. The notion of parameterized types in this library is similar to that of the singletons library, but in some ways more flexible but less automated.&lt;/p&gt; &#xA;&lt;h2&gt;A Simple Example&lt;/h2&gt; &#xA;&lt;p&gt;As an example of a parameterized type, consider the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE DataKinds #-}&#xA;{-# LANGUAGE GADTs #-}&#xA;data EmbeddedType = EInt | EBool&#xA;&#xA;data Expr (tp :: EmbeddedType) where&#xA;  IntLit :: Int -&amp;gt; Expr &#39;EInt&#xA;  BoolLit :: Bool -&amp;gt; Expr &#39;EBool&#xA;  Add :: Expr &#39;EInt -&amp;gt; Expr &#39;EInt -&amp;gt; Expr &#39;EInt&#xA;  Lt :: Expr &#39;EInt -&amp;gt; Expr &#39;EInt -&amp;gt; Expr &#39;EBool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;Expr&lt;/code&gt; type is a parameterized type, as it has a single type parameter. The GADT uses the type parameter to embed a simple type system into the language. The datakind &lt;code&gt;EmbeddedType&lt;/code&gt; is used as a type index. GADT use comes with some potential challenges, depending on use case. Creating collections of values of this &lt;code&gt;Expr&lt;/code&gt; type can be slightly tricky due to the type parameter.&lt;/p&gt; &#xA;&lt;p&gt;Attempting to define the value &lt;code&gt;[IntLit 5, BoolLit False]&lt;/code&gt; results in a type error because the two terms in the list have different types: &lt;code&gt;Expr &#39;EInt&lt;/code&gt; and &lt;code&gt;Expr &#39;EBool&lt;/code&gt;, respectively.&lt;/p&gt; &#xA;&lt;p&gt;One option is to existentially quantify away the type parameter. There is a helper type, &lt;code&gt;Some&lt;/code&gt;, defined in Data.Parameterized.Some that does just this: &lt;code&gt;[Some (IntLit 5), Some (BoolLit False)] :: [Some Expr]&lt;/code&gt;. Because &lt;code&gt;Expr&lt;/code&gt; is defined as a GADT, pattern matching on constructors allows us to recover the type parameter.&lt;/p&gt; &#xA;&lt;p&gt;Another option is to use a container designed to accommodate parameterized types, such as &lt;code&gt;List&lt;/code&gt; defined in Data.Parameterized.List. This would look something like &lt;code&gt;(IntLit 5 :&amp;lt; BoolLit False :&amp;lt; Nil) :: List Expr &#39;[EInt, EBool]&lt;/code&gt;. Note that the type-level list reflects the types of the terms, allowing for some powerful indexing and traversal patterns.&lt;/p&gt; &#xA;&lt;h2&gt;An Extended Example&lt;/h2&gt; &#xA;&lt;p&gt;In the previous example, it is possible to recover the type parameters after they have been existentially quantified away by pattern matching. In a more complicated example, that is not always possible:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE DataKinds #-}&#xA;{-# LANGUAGE GADTs #-}&#xA;data EmbeddedType = EInt | EBool&#xA;&#xA;data Expr (tp :: EmbeddedType) where&#xA;  IntLit :: Int -&amp;gt; Expr &#39;EInt&#xA;  BoolLit :: Bool -&amp;gt; Expr &#39;EBool&#xA;  Add :: Expr &#39;EInt -&amp;gt; Expr &#39;EInt -&amp;gt; Expr &#39;EInt&#xA;  Lt :: Expr &#39;EInt -&amp;gt; Expr &#39;EInt -&amp;gt; Expr &#39;EBool&#xA;  IsEq :: Expr tp -&amp;gt; Expr tp -&amp;gt; Expr &#39;EBool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, pattern matching on the &lt;code&gt;IsEq&lt;/code&gt; constructor does &lt;em&gt;not&lt;/em&gt; recover the types of the operands. &lt;code&gt;IsEq&lt;/code&gt; is polymorphic, so the parameters could either be of type &lt;code&gt;EBool&lt;/code&gt; or &lt;code&gt;EInt&lt;/code&gt;, though we do learn that the types of the sub-terms must at least be the same. We could pattern match on those sub-terms individually, but doing so might introduce an unpredictable amount of recursion and significantly complicate the code. One way to solve this issue is to introduce run-time type representatives to allow us to more easily recover types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE DataKinds #-}&#xA;{-# LANGUAGE GADTs #-}&#xA;data EmbeddedType = EInt | EBool&#xA;&#xA;data Repr tp where&#xA;  IntRepr :: Repr &#39;EInt&#xA;  BoolRepr :: Repr &#39;EBool&#xA;&#xA;data Expr (tp :: EmbeddedType) where&#xA;  IntLit :: Int -&amp;gt; Expr &#39;EInt&#xA;  BoolLit :: Bool -&amp;gt; Expr &#39;EBool&#xA;  Add :: Expr &#39;EInt -&amp;gt; Expr &#39;EInt -&amp;gt; Expr &#39;EInt&#xA;  Lt :: Expr &#39;EInt -&amp;gt; Expr &#39;EInt -&amp;gt; Expr &#39;EBool&#xA;  IsEq :: Repr tp -&amp;gt; Expr tp -&amp;gt; Expr tp -&amp;gt; Expr &#39;EBool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The new type, &lt;code&gt;Repr&lt;/code&gt;, is a singleton type that establishes a connection between a run-time value and a type. When we pattern match on &lt;code&gt;IsEq&lt;/code&gt;, we can simply inspect (i.e., pattern match on) the contained &lt;code&gt;Repr&lt;/code&gt; value to determine the types of the sub-terms:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;withBoolExprs :: Expr tp -&amp;gt; a -&amp;gt; ([Expr &#39;EBool] -&amp;gt; a) -&amp;gt; a&#xA;withBoolExprs e def k =&#xA;  case e of&#xA;    BoolLit {} -&amp;gt; k [e]&#xA;    Lt {} -&amp;gt; k [e]&#xA;    IsEq rep e1 e2&#xA;      | Just Refl &amp;lt;- testEquality rep BoolRepr -&amp;gt;&#xA;          -- Because we used a GADT pattern match, we know that tp ~ EBool&#xA;          k [e, e1, e2]&#xA;      | otherwise -&amp;gt; def&#xA;    _ -&amp;gt; def&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Package Structure&lt;/h1&gt; &#xA;&lt;p&gt;This package provides three main types of functionality:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Typeclasses mirroring core Haskell classes, but adapted to parameterized types&lt;/li&gt; &#xA; &lt;li&gt;Data structures suitable for holding values of parameterized types&lt;/li&gt; &#xA; &lt;li&gt;Utilities for working with parameterized types, including tools for proving properties at the type level (dependently-typed programming in Haskell)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Typeclasses&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Classes&lt;/p&gt; &lt;p&gt;This module contains a number of basic classes lifted to parameterized types, including &lt;code&gt;EqF&lt;/code&gt;, &lt;code&gt;OrdF&lt;/code&gt;, &lt;code&gt;ShowF&lt;/code&gt;, and &lt;code&gt;HashableF&lt;/code&gt;. It also re-exports a few types from base that are useful for working with parameterized types, including &lt;code&gt;TestEquality&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The related module Data.Parameterized.TH.GADT provides Template Haskell functions to automatically implement instances of some of these classes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.ClassesC&lt;/p&gt; &lt;p&gt;This module defines classes like Data.Parameterized.Classes, except that the class methods accept an additional parameter for comparing sub-terms.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.TraversableFC&lt;/p&gt; &lt;p&gt;This module generalizes &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt;, and &lt;code&gt;Traversable&lt;/code&gt; to parameterized types. In these operations, type parameters must be preserved.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.TraversableF&lt;/p&gt; &lt;p&gt;This module is like Data.Parameterized.TraversableFC, but intended for types that have a single parametric type parameter, rather than two. The most common use of these functions and classes is with the &lt;code&gt;MapF&lt;/code&gt; type described below.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Data Structures&lt;/h2&gt; &#xA;&lt;p&gt;This package provides data structures that are either lifted to hold parameterized types or otherwise type indexed. The following modules implement data structures:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Context (&lt;code&gt;Assignment (f :: k -&amp;gt; Type) (ctx :: Ctx k)&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;&lt;code&gt;Assignment&lt;/code&gt; is a sequence type that holds values of parameterized types. It is essentially a snoc list (i.e., a list that is extended on the right instead of the left). The &lt;code&gt;Ctx&lt;/code&gt; (Context) type is a type-level snoc list. In the default implementation, indexing is O(log(n)) time and total.&lt;/p&gt; &lt;p&gt;There are technically two implementations of &lt;code&gt;Assignment&lt;/code&gt;: a safe implementation based on a snoc list in pure Haskell and the default implementation based on a balanced binary tree that uses &lt;code&gt;unsafeCoerce&lt;/code&gt; to manipulate type indexes for efficiency. The safe implementation is a proof that the API presented is safe, while the unsafe implementation is efficient enough to use in practice.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.List (&lt;code&gt;List (f :: k -&amp;gt; Type) [k]&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;&lt;code&gt;List&lt;/code&gt; is the plain Haskell list lifted to hold values of parameterized types. Moreover, it uses the data kind lifted list syntax instead of the &lt;code&gt;Ctx&lt;/code&gt; type. Indexing into &lt;code&gt;List&lt;/code&gt; is total but O(n).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Map (&lt;code&gt;MapF (key :: k -&amp;gt; Type) (value :: k -&amp;gt; Type)&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;&lt;code&gt;MapF&lt;/code&gt; an associative map from keys to values where both keys and values are parameterized types. The lookup operation is O(log(n)), and recovers the type parameter of the value during lookup.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.HashTable (&lt;code&gt;HashTable s (key :: k -&amp;gt; Type) (value :: k -&amp;gt; Type)&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;&lt;code&gt;HashTable&lt;/code&gt; is an associative container like &lt;code&gt;MapF&lt;/code&gt;, except is mutable in &lt;code&gt;ST&lt;/code&gt; (or &lt;code&gt;IO&lt;/code&gt; via &lt;code&gt;stToIO&lt;/code&gt;) due to the &lt;code&gt;s&lt;/code&gt; type parameter.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Vector (&lt;code&gt;Vector (n :: Nat) (a :: Type)&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;This module implements a length-indexed vector. Unlike the other data structures in parameterized-utils, the type parameter only describes the length of the vector as a type-level natural; the elements in the vector do not have type indexes.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Additionally:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Pair (&lt;code&gt;data Pair a b = forall tp . Pair (a tp) (b tp)&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;This module provides an existentially-quantified pair where both types in the pair are indexed by the same existentially quantified parameter. Pattern matching on the constructor recovers the equality. This type is primarily used in Data.Parameterized.Map, but is sometimes separately useful.&lt;/p&gt; &lt;p&gt;Note that there is another useful notion of type parameterized pair, which is provided by Data.Functor.Product in base: &lt;code&gt;data Product a b tp = Pair (a tp) (b tp)&lt;/code&gt;. The difference is that the type parameter of &lt;code&gt;Product&lt;/code&gt; is made manifest in the type, and thus is not quantified away.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Utilities&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.NatRepr&lt;/p&gt; &lt;p&gt;This module provides run-time representative values for natural numbers lifted to the type level, as well as some utilities for proving properties over type-level naturals.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Peano&lt;/p&gt; &lt;p&gt;This module provides an implementation of type-level Peano numbers, as well as run-time representative values for them. It also provides some utilities for proving properties over Peano numbers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Fin&lt;/p&gt; &lt;p&gt;&lt;code&gt;Fin n&lt;/code&gt; is a finite type with &lt;code&gt;n&lt;/code&gt; (terminating/non-bottom) inhabitants. It can be used to index into a &lt;code&gt;Vector n&lt;/code&gt; or other size-indexed datatype.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.SymbolRepr&lt;/p&gt; &lt;p&gt;This module provides run-time representative values for strings lifted to the type level (symbols).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.BoolRepr&lt;/p&gt; &lt;p&gt;This module provides run-time representative values for booleans lifted to the type level.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Some&lt;/p&gt; &lt;p&gt;The &lt;code&gt;Some&lt;/code&gt; type is a wrapper that existentially quantifies away the type parameter of a parameterized value. This can be used on any value with a parameterized type, but is most useful when an operation exists to recover the type parameter later (either via pattern matching over a GADT or by consulting a run-time type representative value).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Data.Parameterized.Nonce&lt;/p&gt; &lt;p&gt;&lt;code&gt;Nonce&lt;/code&gt; is a parameterized type backed by a &lt;code&gt;Word64&lt;/code&gt;. Its &lt;code&gt;TestEquality&lt;/code&gt; instance uses &lt;code&gt;unsafeCoerce&lt;/code&gt; to allow the type parameter to be recovered. Similarly to a cryptographic nonce, the &lt;code&gt;Nonce&lt;/code&gt; type is safe as long as no nonce value is reused.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>adamancini/lyahfgg</title>
    <updated>2022-07-25T01:42:26Z</updated>
    <id>tag:github.com,2022-07-25:/adamancini/lyahfgg</id>
    <link href="https://github.com/adamancini/lyahfgg" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;lyahfgg&lt;/h1&gt; &#xA;&lt;p&gt;Learn You a Haskell for Great Good exercises&lt;/p&gt;</summary>
  </entry>
</feed>