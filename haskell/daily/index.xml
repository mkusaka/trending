<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-09T01:41:05Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>benwbooth/cleo</title>
    <updated>2022-06-09T01:41:05Z</updated>
    <id>tag:github.com,2022-06-09:/benwbooth/cleo</id>
    <link href="https://github.com/benwbooth/cleo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Beginnings of a parser for a new functional language&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Beginnings of a parser for a new functional language&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cardano-foundation/dab</title>
    <updated>2022-06-09T01:41:05Z</updated>
    <id>tag:github.com,2022-06-09:/cardano-foundation/dab</id>
    <link href="https://github.com/cardano-foundation/dab" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Decentralized applicaton backend for Cardano.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;dab&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/cardano-foundation/dab/actions/workflows/ci.yaml&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint.svg?url=https%3A%2F%2Factions-badge.atrox.dev%2Fcardano-foundation%2Fdab%2Fbadge&amp;amp;style=flat-square&#34; alt=&#34;GitHub Actions&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/f/ff/ADA_Cardano_Logo.png&#34; width=&#34;76&#34; align=&#34;right&#34; height=&#34;70&#34;&gt; &#xA;&lt;br&gt; &#xA;&lt;p align=&#34;center&#34;&gt;Decentralized application backend for Cardano.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/cardano-foundation/dab/main/#about&#34;&gt;About&lt;/a&gt; â€¢ &lt;a href=&#34;https://raw.githubusercontent.com/cardano-foundation/dab/main/#installation&#34;&gt;Installation&lt;/a&gt; â€¢ &lt;a href=&#34;https://raw.githubusercontent.com/cardano-foundation/dab/main/#usage&#34;&gt;Usage&lt;/a&gt; â€¢ &lt;a href=&#34;https://raw.githubusercontent.com/cardano-foundation/dab/main/#contributing&#34;&gt;Contributing&lt;/a&gt; &lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;About&lt;/h1&gt; &#xA;&lt;p&gt;Decentralized application backend (dab) is a toolset that help developers interact with the Cardano blockchain and its smart validators.&lt;/p&gt; &#xA;&lt;p&gt;At its core, the component called &lt;code&gt;chain-watcher&lt;/code&gt; is following the chain looking for specific events expected by the application backend. It supports different providers to access the Cardano network.&lt;/p&gt; &#xA;&lt;h1&gt;Community&lt;/h1&gt; &#xA;&lt;p&gt;Decentralized application backend (dab) is a community project. We are releasing this minimal viable product in a modular form (at the moment it supports &lt;a href=&#34;https://blockfrost.io/&#34;&gt;Blockfrost&lt;/a&gt; as a provider), we hope that it will gather developer community momentum and we will see many more different providers such as Oura, Koios or Ogmios emerge from the development community.&lt;/p&gt; &#xA;&lt;p&gt;We strongly encourage community members to apply for Project Catalyst funding to make this project their own and better.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;h2&gt;Building with Nix&lt;/h2&gt; &#xA;&lt;p&gt;Nix is the prefered way to build the chain-watcher and its components.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-command&#34;&gt;nix-build -A chain-watcher.components.exes.chain-watcher-blockfrost&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building with Docker&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/cardano-foundation/dab/main/docs/Docker.md&#34;&gt;docs/Docker.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;Running the application backend demo&lt;/h2&gt; &#xA;&lt;p&gt;To run the application backend demo &lt;span&gt;âš¡&lt;/span&gt;, do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-command&#34;&gt;nix-shell&#xA;export BLOCKFROST_TOKEN_PATH=~/.blockfrost.testnet.token&#xA;cabal run chain-watcher-blockfrost&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;View the demo on &lt;a href=&#34;http://localhost:8282/demo/index.html&#34;&gt;http://localhost:8282/demo/index.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Demo of demo&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cardano-foundation/dab/main/.github/workflows/demo.gif&#34;&gt; &#xA;&lt;h2&gt;Client API&lt;/h2&gt; &#xA;&lt;h3&gt;Register new client&lt;/h3&gt; &#xA;&lt;p&gt;To register a new client on the chain-watcher.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-command&#34;&gt;cid=&#34;$( curl -q -X POST -v localhost:8282/clients/new | jq -r)&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Remove client&lt;/h3&gt; &#xA;&lt;p&gt;To remove an exising client on the chain-watcher.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-command&#34;&gt;curl -X POST -v localhost:8282/clients/remove/${cid}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Subscribe to event&lt;/h3&gt; &#xA;&lt;p&gt;To subscribe your client to a specific event on the chain-watcher.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-command&#34;&gt;curl \&#xA;  -X POST \&#xA;  -H &#34;Content-Type: application/json&#34; \&#xA;  -v localhost:8282/clients/request/${cid} \&#xA;  --data &#39;{&#34;contents&#34;:&#34;1075a1c98dbdf3486ec8f5050c84da30a057cb79ae0ce6d03d157c719c559332&#34;,&#34;tag&#34;:&#34;TransactionStatusRequest&#34;}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Recurring request&lt;/h3&gt; &#xA;&lt;p&gt;To subscribe your client to a reoccuring specific event on the chain-watcher.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-command&#34;&gt;curl -X POST --data &#39;{&#34;contents&#34;:{&#34;tag&#34;:&#34;Ping&#34;},&#34;tag&#34;:&#34;Recurring&#34;}&#39; -H &#34;Content-Type: application/json&#34; -v localhost:8282/clients/request/${cid}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Address change request&lt;/h3&gt; &#xA;&lt;p&gt;To change your address event watching.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-command&#34;&gt;curl -X POST --data &#39;{&#34;contents&#34;:&#34;addr_test1wpzjtlyp6v4qx6gzjm4zc7lsdufw597507y060qhk84vpjsjd625n&#34;,&#34;tag&#34;:&#34;AddressFundsRequest&#34;}&#39; -H &#34;Content-Type: application/json&#34; -v localhost:8282/clients/request/${cid}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Follow server-sent event stream&lt;/h3&gt; &#xA;&lt;p&gt;To follow on the even stream from the chain-watcher.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-command&#34;&gt;curl -v -N --http2 -H &#34;Accept:text/event-stream&#34; localhost:8282/sse/${cid}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;We are looking forward to your contributions!&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;ðŸ’¡&lt;/span&gt; See &lt;a href=&#34;https://raw.githubusercontent.com/cardano-foundation/dab/main/CONTRIBUTING.md&#34;&gt;Contributing&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/cardano-foundation/dab/main/CODE_OF_CONDUCT.md&#34;&gt;Code of conduct&lt;/a&gt; for more information about how to contribute your code.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ucsd-progsys/liquidhaskell</title>
    <updated>2022-06-09T01:41:05Z</updated>
    <id>tag:github.com,2022-06-09:/ucsd-progsys/liquidhaskell</id>
    <link href="https://github.com/ucsd-progsys/liquidhaskell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Liquid Types For Haskell&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ucsd-progsys/liquidhaskell/develop/resources/logo.png&#34; alt=&#34;LiquidHaskell&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/liquidhaskell&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/liquidhaskell.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://packdeps.haskellers.com/feed?needle=liquidhaskell&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage-deps/v/liquidhaskell.svg?sanitize=true&#34; alt=&#34;Hackage-Deps&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/ucsd-progsys/liquidhaskell&#34;&gt;&lt;img src=&#34;https://img.shields.io/circleci/project/ucsd-progsys/liquidhaskell/master.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://ci.appveyor.com/project/varosi/liquidhaskell-nlhra/branch/develop&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/78y7uusjcgor5p16/branch/develop?svg=true&#34; alt=&#34;Windows build status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is the &lt;strong&gt;development&lt;/strong&gt; site of the LiquidHaskell formal verification tool.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re a LiquidHaskell &lt;strong&gt;user&lt;/strong&gt; (or just curious), you probably want to go to &lt;a href=&#34;https://ucsd-progsys.github.io/liquidhaskell/&#34;&gt;the documentation website&lt;/a&gt; instead.&lt;/p&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;This is an open-source project, and we love getting feedback (and patches)!&lt;/p&gt; &#xA;&lt;h2&gt;Reporting a Bug&lt;/h2&gt; &#xA;&lt;p&gt;If something doesn&#39;t work as it should, please consider opening a &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/issues&#34;&gt;github issue&lt;/a&gt; to let us know. If possible, try to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Try to use a descriptive title;&lt;/li&gt; &#xA; &lt;li&gt;State as clearly as possible what is the problem you are facing;&lt;/li&gt; &#xA; &lt;li&gt;Provide a small Haskell file producing the issue;&lt;/li&gt; &#xA; &lt;li&gt;Write down the expected behaviour vs the actual behaviour;&lt;/li&gt; &#xA; &lt;li&gt;If possible, let us know if you have used the &lt;a href=&#34;https://raw.githubusercontent.com/ucsd-progsys/liquidhaskell/develop/install.md&#34;&gt;plugin&lt;/a&gt; or the &lt;a href=&#34;https://raw.githubusercontent.com/ucsd-progsys/liquidhaskell/develop/legacy.md&#34;&gt;executable&lt;/a&gt; and which &lt;em&gt;GHC version&lt;/em&gt; you are using.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Your first Pull Request&lt;/h2&gt; &#xA;&lt;p&gt;We are thrilled to get PRs! Please follow these guidelines, as doing so will increase the chances of having your PR accepted:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The main LH repo &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell&#34;&gt;lives here&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Please create pull requests against the &lt;code&gt;develop&lt;/code&gt; branch.&lt;/li&gt; &#xA; &lt;li&gt;Please be sure to include test cases that illustrate the effect of the PR &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;e.g. show new features that that are supported or how it fixes some previous issue&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;If you&#39;re making user-visible changes, please also add documentation &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;e.g. &lt;a href=&#34;https://raw.githubusercontent.com/ucsd-progsys/liquidhaskell/develop/options.md&#34;&gt;options.md&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/ucsd-progsys/liquidhaskell/develop/specifications.md&#34;&gt;specifications.md&lt;/a&gt;, the &lt;a href=&#34;https:///github.com/ucsd-progsys/intro-refinement-types&#34;&gt;main tutorial&lt;/a&gt; (as relevant)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Pull requests don&#39;t just have to be about code: documentation can often be improved too!&lt;/p&gt; &#xA;&lt;h2&gt;Ask for Help&lt;/h2&gt; &#xA;&lt;p&gt;If you have further questions or you just need help, you can always reach out on our &lt;a href=&#34;https://join.slack.com/t/liquidhaskell/shared_invite/enQtMjY4MTk3NDkwODE3LTFmZGFkNGEzYWRkNDJmZDQ0ZGU1MzBiZWZiZDhhNmY3YTJiMjUzYTRlNjMyZDk1NDU3ZGIxYzhlOTIzN2UxNWE&#34;&gt;slack channel&lt;/a&gt;, &lt;a href=&#34;https://groups.google.com/forum/#!forum/liquidhaskell&#34;&gt;google groups mailing list&lt;/a&gt;, &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/issues&#34;&gt;GitHub issue tracker&lt;/a&gt;, or by emailing &lt;a href=&#34;https://github.com/ranjitjhala&#34;&gt;Ranjit Jhala&lt;/a&gt;, &lt;a href=&#34;https://github.com/nikivazou&#34;&gt;Niki Vazou&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;General Development Guide&lt;/h1&gt; &#xA;&lt;p&gt;For those diving into the implementation of LiquidHaskell, here are a few tips:&lt;/p&gt; &#xA;&lt;h2&gt;Fast (re)compilation&lt;/h2&gt; &#xA;&lt;p&gt;When working on the &lt;code&gt;liquidhaskell&lt;/code&gt; library, usually all we want is to make changes and quickly recompile only the bare minimum, to try out new ideas. Using a fully-fledged GHC plugin doesn&#39;t help in this sense, because packages like &lt;code&gt;liquid-base&lt;/code&gt; or &lt;code&gt;liquid-ghc-prim&lt;/code&gt; all have a direct dependency on &lt;code&gt;liquidhaskell&lt;/code&gt;, and therefore every time the latter changes, an expensive rebuild of those packages is triggered, which might become tedious overtime. To mitigate this, we offer a faster, &#34;dev-style&#34; build mode which is based on the assumption that most changes to the &lt;code&gt;liquidhaskell&lt;/code&gt; library do not alter the validity of already-checked libraries, and therefore things like &lt;code&gt;liquid-base&lt;/code&gt; and &lt;code&gt;liquid-ghc-prim&lt;/code&gt; can be considered &#34;static assets&#34;, avoiding the need for a recompilation. In other terms, we explicitly disable recompilation of any of the &lt;code&gt;liquid-*&lt;/code&gt; ancillary library in dev mode, so that rebuilds would also influence the &lt;code&gt;liquidhaskell&lt;/code&gt; library.&lt;/p&gt; &#xA;&lt;h3&gt;Usage and recommended workflow&lt;/h3&gt; &#xA;&lt;p&gt;This is how you can use this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;To begin with, perform a &lt;strong&gt;full&lt;/strong&gt; build of &lt;strong&gt;all&lt;/strong&gt; the libraries, by doing either &lt;code&gt;cabal v2-build&lt;/code&gt; or &lt;code&gt;stack build&lt;/code&gt;, &lt;strong&gt;without&lt;/strong&gt; specifying any extra environment variables from the command line. This is needed to ensure that we things like &lt;code&gt;liquid-base&lt;/code&gt; and &lt;code&gt;liquid-ghc-prim&lt;/code&gt; are compiled at least once, as we would need the refinements they contain to correctly checks other downstream programs;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;At this point, the content of the &lt;code&gt;liquid-*&lt;/code&gt; packages is considered &#34;trusted&#34; and &#34;frozen&#34;, until you won&#39;t force another full, &lt;em&gt;non-dev&lt;/em&gt; build;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In order to quickly test changes to the &lt;code&gt;liquidhaskell&lt;/code&gt; library without recompiling the &lt;code&gt;liquid-*&lt;/code&gt; packages, we need to start a build passing the &lt;code&gt;LIQUID_DEV_MODE&lt;/code&gt; env var as part of the build command. Examples:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Stack&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;env LIQUID_DEV_MODE=true stack build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Cabal&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;LIQUID_DEV_MODE=true cabal v2-build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s also possible (but not recommended) to add &lt;code&gt;LIQUID_DEV_MODE&lt;/code&gt; to .bashrc or similar, but this would permanently disable building the &lt;code&gt;liquid-*&lt;/code&gt; packages, and this might silently mask breaking changes to the &lt;code&gt;liquidhaskell&lt;/code&gt; library that would manifest only when compiling these other packages.&lt;/p&gt; &#xA;&lt;p&gt;If you wish to force building all the libraries again, it&#39;s sufficient to issue the same builds commands without the &lt;code&gt;LIQUID_DEV_MODE&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How To Run Regression Tests&lt;/h2&gt; &#xA;&lt;p&gt;For documentation on the &lt;code&gt;test-driver&lt;/code&gt; executable itself, please refer to the &lt;code&gt;README.md&lt;/code&gt; in &lt;code&gt;tests/&lt;/code&gt; or run &lt;code&gt;cabal run tests:test-driver -- --help&lt;/code&gt; or &lt;code&gt;stack run test-driver -- --help&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;For a way of running the test suite for multiple GHC versions, consult the General Development FAQs. below&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are particular scripts for running LH in the different modes, e.g. for different compiler versions. These scripts are in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./scripts/test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So you can run &lt;em&gt;all&lt;/em&gt; the tests for say the ghc-8.10 version by&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./scripts/test/test_810_plugin.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can run a bunch of particular test-groups instead by&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ LIQUID_DEV_MODE=true ./scripts/test/test_810_plugin.sh &amp;lt;test-group-name1&amp;gt; &amp;lt;test-group-name2&amp;gt; ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and you can list all the possible test options with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ LIQUID_DEV_MODE=true ./scripts/test/test_810_plugin.sh --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or get a list of just the test groups, one per line, with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ LIQUID_DEV_MODE=true ./scripts/tests/test_810_plugin.sh --show-all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To pass in specific parameters and run a subset of the tests, you can invoke cabal directly with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ LIQUID_DEV_MODE=true cabal build tests:&amp;lt;test-group-name&amp;gt; --ghc-options=-fplugin-opt=LiquidHaskell:--no-termination MySpecificTest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ LIQUID_DEV_MODE=true cabal build tests:unit-neg --ghc-options=--fplugin-opt=LiquidHaskell:--no-termination AbsApp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or your favorite number of threads, depending on cores etc.&lt;/p&gt; &#xA;&lt;p&gt;You can directly extend and run the tests by modifying the files in&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;tests/harness/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parallelism in Tests&lt;/h3&gt; &#xA;&lt;p&gt;Most tests run in parallel, with a few module dependencies built sequentially in advance. Benchmarks are run sequentially after all other tests have finished. For details on adding tests, see note [Parallel_Tests] in &lt;code&gt;tests/test.hs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How to create performance comparison charts&lt;/h2&gt; &#xA;&lt;p&gt;Everytime &lt;code&gt;liquidhaskell&lt;/code&gt; tests are run, measures are collected in &lt;code&gt;.dump-timings&lt;/code&gt; files. This can be converted to json data with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cabal v2-build ghc-timings&#xA;cabal v2-exec ghc-timings dist-newstyle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which will produce &lt;code&gt;tmp/*.json&lt;/code&gt; files.&lt;/p&gt; &#xA;&lt;p&gt;Then a csv report can be generated from this json files with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal v2-run benchmark-timings -- tmp/*.json --phase CoreTidy --phase Renamer/typechecker -o summary.csv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On each line, the report will contain the time taken by each test.&lt;/p&gt; &#xA;&lt;p&gt;There is a script &lt;code&gt;scripts/plot-performance/chart_perf.sh&lt;/code&gt; that can be used to generate comparison charts in &lt;code&gt;svg&lt;/code&gt; and &lt;code&gt;png&lt;/code&gt; formats. It requires &lt;a href=&#34;http://www.gnuplot.info/&#34;&gt;gnuplot&lt;/a&gt; to run. The following command will produce two files &lt;code&gt;perf.svg&lt;/code&gt; and &lt;code&gt;perf.png&lt;/code&gt; in the current directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ scripts/plot-performance/chart_perf.sh path_to_before_summary.csv path_to_after_summary.csv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The current formatting is optimized for comparing the outputs of running the benchmarks alone.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ scripts/test/test_810_plugin.sh&#xA;    benchmark-stitch-lh \&#xA;    benchmark-bytestring \&#xA;    benchmark-vector-algorithms&#xA;    benchmark-cse230 \&#xA;    benchmark-esop2013 \&#xA;    benchmark-icfp15-pos \&#xA;    benchmark-icfp15-ne&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How to Profile&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Build with profiling on&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ stack build liquidhaskell --fast --profile&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run with profiling&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ stack exec -- liquid range.hs +RTS -hc -p&#xA;$ stack exec -- liquid range.hs +RTS -hy -p&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Followed by this which shows the stats file&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ more liquid.prof&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;or by this to see the graph&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ hp2ps -e8in -c liquid.hp&#xA;$ gv liquid.ps&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;etc.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;How to Get Stack Traces On Exceptions&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Build with profiling on&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ stack build liquidhaskell --fast --profile&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run with backtraces&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ liquid +RTS -xc -RTS foo.hs&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code&gt;stack exec -- liquid List00.hs +RTS -p -xc -RTS&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Working With Submodules&lt;/h2&gt; &#xA;&lt;p&gt;To update the &lt;code&gt;liquid-fixpoint&lt;/code&gt; submodule, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd ./liquid-fixpoint&#xA;git fetch --all&#xA;git checkout &amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt;&#xA;cd ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will update &lt;code&gt;liquid-fixpoint&lt;/code&gt; to the latest version on &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; (usually &lt;code&gt;master&lt;/code&gt;) from &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; (usually &lt;code&gt;origin&lt;/code&gt;). After updating &lt;code&gt;liquid-fixpoint&lt;/code&gt;, make sure to include this change in a commit! Running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git add ./liquid-fixpoint&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will save the current commit hash of &lt;code&gt;liquid-fixpoint&lt;/code&gt; in your next commit to the &lt;code&gt;liquidhaskell&lt;/code&gt; repository. For the best experience, &lt;strong&gt;don&#39;t&lt;/strong&gt; make changes directly to the &lt;code&gt;./liquid-fixpoint&lt;/code&gt; submodule, or else git may get confused. Do any &lt;code&gt;liquid-fixpoint&lt;/code&gt; development inside a separate clone/copy elsewhere. If something goes wrong, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rm -r ./liquid-fixpoint&#xA;git submodule update --init&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to blow away your copy of the &lt;code&gt;liquid-fixpoint&lt;/code&gt; submodule and revert to the last saved commit hash.&lt;/p&gt; &#xA;&lt;p&gt;Want to work fully offline? &lt;code&gt;git&lt;/code&gt; lets you add a local directory as a remote. Run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd ./liquid-fixpoint&#xA;git remote add local /path/to/your/fixpoint/clone&#xA;cd ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then to update the submodule from your local clone, you can run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd ./liquid-fixpoint&#xA;git fetch local&#xA;git checkout local/&amp;lt;branch&amp;gt;&#xA;cd ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Releasing on Hackage&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE: The following section is relevant only for few developers, i.e. the ones which are directly involved in the release process. Most contributors can skip this section.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;We provide a convenience script to upload all the &lt;code&gt;liquid-*&lt;/code&gt; packages (&lt;strong&gt;including&lt;/strong&gt; &lt;code&gt;liquid-fixpoint&lt;/code&gt;) on Hackage, in a lockstep fashion. To do so, it&#39;s possible to simply run the &lt;code&gt;scripts/release_to_hackage.sh&lt;/code&gt; Bash script. The script doesn&#39;t accept any argument and it tries to determine the packages to upload by scanning the &lt;code&gt;$PWD&lt;/code&gt; for packages named appropriately. It will ask the user for confirmation before proceeding, and &lt;code&gt;stack upload&lt;/code&gt; will be used under the hood.&lt;/p&gt; &#xA;&lt;h2&gt;The GHC.API module&lt;/h2&gt; &#xA;&lt;p&gt;In order to allow LH to work with multiple GHC versions, we need a way to abstract over all the breaking changes of the &lt;code&gt;ghc&lt;/code&gt; library, which might change substantially with every major GHC release. This is accomplished by the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/develop/src/Language/Haskell/Liquid/GHC/API.hs&#34;&gt;GHC.API&lt;/a&gt; module. The idea is that &lt;strong&gt;rather than importing multiple &lt;code&gt;ghc&lt;/code&gt; modules, LH developers must import this single module in order to write future-proof code&lt;/strong&gt;. This is especially important for versions of the compiler greater than 9, where the module hierarchy changed substantially, and using the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/develop/src/Language/Haskell/Liquid/GHC/API.hs&#34;&gt;GHC.API&lt;/a&gt; makes it easier to support new versions of GHC when they are released.&lt;/p&gt; &#xA;&lt;h3&gt;Fragile import strategy&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Predicate&#xA;import TyCoRep&#xA;&#xA;...&#xA;&#xA;-- This will break if &#39;isEqPrimPred&#39; is (re)moved or the import hierarchy changes.&#xA;foo :: Type -&amp;gt; Bool&#xA;foo = isEqPrimPred&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Recommended import strategy&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import qualified Language.Haskell.Liquid.GHC.API as GHC&#xA;&#xA;...&#xA;&#xA;foo :: GHC.Type -&amp;gt; Bool&#xA;foo = GHC.isEqPrimPred -- OK.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;GHC Plugin Development Guide&lt;/h1&gt; &#xA;&lt;p&gt;This code commentary describes the current architecture for the GHC &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs&#34;&gt;Plugin&lt;/a&gt; that enables LiquidHaskell to check files as part of the normal compilation process. For the sake of this commentary, we refer to the code provided as part of the &lt;code&gt;release/0.8.10.2&lt;/code&gt; branch, commit &lt;code&gt;9a2f8284c5fe5b18ed0410e842acd3329a629a6b&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;GHC.Interface vs GHC.Plugin&lt;/h2&gt; &#xA;&lt;p&gt;The module &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs&#34;&gt;GHC.Plugin&lt;/a&gt; is the main entrypoint for all the plugin functionalities. Whenever possible, this module is reusing common functionalities from the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs&#34;&gt;GHC.Interface&lt;/a&gt;, which is the original module used to interface LH with the old executable. Generally speaking, the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs&#34;&gt;GHC.Interface&lt;/a&gt; module is considered &#34;legacy&#34; and it&#39;s rarely what one wants to modify. It will probably be removed once the old executable stops being supported, with the functions now in use by the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs&#34;&gt;GHC.Plugin&lt;/a&gt; being moved into the latter.&lt;/p&gt; &#xA;&lt;h2&gt;The GhcMonadLike shim&lt;/h2&gt; &#xA;&lt;p&gt;Part of the tension in designing the plugin was trying to reuse as much code as possible from the original &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs&#34;&gt;GHC.Interface&lt;/a&gt; shipped with LiquidHaskell. Unfortunately this was not possible from the get-go due to the fact most of the functions provided by that module were requiring a &lt;a href=&#34;https://hackage.haskell.org/package/ghc-8.10.1/docs/GHC.html#t:GhcMonad&#34;&gt;GhcMonad&lt;/a&gt; constraint or usually living in the &lt;a href=&#34;https://hackage.haskell.org/package/ghc-8.10.1/docs/GHC.html#t:Ghc&#34;&gt;Ghc monad&lt;/a&gt;, which is also the only concrete type which derives an instance for &lt;a href=&#34;https://hackage.haskell.org/package/ghc-8.10.1/docs/GHC.html#t:GhcMonad&#34;&gt;GhcMonad&lt;/a&gt;. While we could have run each and every function with &lt;code&gt;runGhc&lt;/code&gt;, this was not very satisfactory due to the fact running the &lt;code&gt;Ghc&lt;/code&gt; monad is fairly expensive as it requires a bit of extra state in order to run it.&lt;/p&gt; &#xA;&lt;p&gt;However, most of the functions used by the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs&#34;&gt;Ghc.Interface&lt;/a&gt; didn&#39;t require anything specific from the underlying &lt;a href=&#34;https://hackage.haskell.org/package/ghc-8.10.1/docs/GHC.html#t:Ghc&#34;&gt;Ghc monad&lt;/a&gt; if not access to the &lt;a href=&#34;https://hackage.haskell.org/package/ghc-8.10.1/docs/GHC.html#t:HscEnv&#34;&gt;HscEnv&lt;/a&gt; and the ability to grab the &lt;a href=&#34;https://hackage.haskell.org/package/ghc-8.10.1/docs/GHC.html#t:DynFlags&#34;&gt;DynFlags&lt;/a&gt;, as well as doing &lt;code&gt;IO&lt;/code&gt;. Therefore, the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/GhcMonadLike.hs&#34;&gt;GhcMonadLike&lt;/a&gt; shim was born with the intent of replicating some of the functions used by the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs&#34;&gt;GHC.Interface&lt;/a&gt; but crucially making those polymorphic in a generic &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/GhcMonadLike.hs&#34;&gt;GhcMonadLike&lt;/a&gt; for which we can give instances for &lt;code&gt;CoreM&lt;/code&gt;, &lt;code&gt;TcM&lt;/code&gt; etc. We can do this because we do not require the extra &lt;code&gt;ExceptionMonad&lt;/code&gt; constraint and we do not require to implement &lt;code&gt;setHscEnv&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This allowed us to change ever so slightly the functions provided by the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs&#34;&gt;GHC.Interface&lt;/a&gt;, expose them and reuse them in the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs&#34;&gt;Plugin&lt;/a&gt; module.&lt;/p&gt; &#xA;&lt;h2&gt;Plugin architecture&lt;/h2&gt; &#xA;&lt;p&gt;Broadly speaking, the Plugin is organised this way: In the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs#L196-L224&#34;&gt;typechecking phase&lt;/a&gt;, we typecheck and desugar each module via the GHC API in order to extract the unoptimised &lt;a href=&#34;https://hackage.haskell.org/package/ghc-8.10.1/docs/CoreSyn.html#t:CoreBind&#34;&gt;core binds&lt;/a&gt; that are needed by LH to work correctly. This is due to a tension in the design space; from one side LH needs access to the &#34;raw&#34; core binds (binds where primitives types are not unboxed in the presence of a PRAGMA annotation, for example) but yet the user can specify any arbitrary optimisation settings during compilation and we do not want to betray the principle of least expectation by silently compiling the code with &lt;code&gt;-O0&lt;/code&gt;. Practically speaking, this introduces some overhead and is far from ideal, but for now it allows us to iterate quickly. This phase is also responsible for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Extracting the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/Types/Specs.hs#L301&#34;&gt;BareSpec&lt;/a&gt;s associated to any of the dependent modules;&lt;/li&gt; &#xA; &lt;li&gt;Producing the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/Types/Specs.hs#L476&#34;&gt;LiftedSpec&lt;/a&gt; for the currently-compiled module;&lt;/li&gt; &#xA; &lt;li&gt;Storing the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/Types/Specs.hs#L476&#34;&gt;LiftedSpec&lt;/a&gt; into an interface annotation for later retrieval;&lt;/li&gt; &#xA; &lt;li&gt;Checking and verifying the module using LH&#39;s existing API.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The reason why we do everything in the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs#L196-L224&#34;&gt;typechecking phase&lt;/a&gt; is also to allow integrations with tools like &lt;a href=&#34;https://github.com/haskell/ghcide&#34;&gt;ghcide&lt;/a&gt;. There are a number of differences between the plugin and the operations performed as part of the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs&#34;&gt;GHC.Interface&lt;/a&gt;, which we are going to outline in the next section.&lt;/p&gt; &#xA;&lt;h2&gt;Differences with the GHC.Interface&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs&#34;&gt;GHC.Interface&lt;/a&gt; pre-processes the input files and calls into &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs#L268&#34;&gt;configureGhcTargets&lt;/a&gt; trying to build a dependency graph by discovering dependencies the target files might require. Then, from this list any file in the include directory is filtered out, as well as any module which has a &#34;fresh&#34; &lt;code&gt;.bspec&lt;/code&gt; file on disk, to save time during checking. In the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs&#34;&gt;GHC.Plugin&lt;/a&gt; module though we don&#39;t do this and for us, essentially, each input file is considered a target, where we exploit the fact GHC will skip recompilation if unnecessary. This also implies that while the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs&#34;&gt;GHC.Interface&lt;/a&gt; calls into &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs#L468&#34;&gt;processTargetModule&lt;/a&gt; only for target files, the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs&#34;&gt;GHC.Plugin&lt;/a&gt; has a single, flat function simply called &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs#L393&#34;&gt;processModule&lt;/a&gt; that essentially does the same as &lt;code&gt;GHC.Interface.processModule&lt;/code&gt; and &lt;code&gt;GHC.Interface.processTargetModule&lt;/code&gt; fused together.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;While the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs&#34;&gt;GHC.Interface&lt;/a&gt; sometimes &#34;assembles&#34; a &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/Types/Specs.hs#L301&#34;&gt;BareSpec&lt;/a&gt; by &lt;code&gt;mappend&lt;/code&gt;ing the &lt;code&gt;commSpec&lt;/code&gt; (i.e. comment spec) with the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/Types/Specs.hs#L476&#34;&gt;LiftedSpec&lt;/a&gt; fetched from disk, if any, the Plugin doesn&#39;t do this but rather piggybacks on the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin/SpecFinder.hs&#34;&gt;SpecFinder&lt;/a&gt; (described later) to fetch dependencies&#39; specs.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There is a difference in how we process LIQUID pragmas. In particular, for the executable they seems to be accumulated &#34;in bulk&#34; i.e. if we are refining a &lt;em&gt;target&lt;/em&gt; module &lt;code&gt;A&lt;/code&gt; that depends on &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; seems to inherit whichever flags we were using in the &lt;em&gt;target&lt;/em&gt; module &lt;code&gt;A&lt;/code&gt;. Conversely, the source plugin is &#34;stateless&#34; when it comes to LIQUID options, i.e. it doesn&#39;t have memory of &lt;em&gt;past&lt;/em&gt; options, what it counts when compiling a module &lt;code&gt;B&lt;/code&gt; is the &lt;em&gt;global&lt;/em&gt; options and &lt;em&gt;any&lt;/em&gt; option this module defines. The analogy is exactly the same as with GHC language extensions, they have either global scope (i.e. &lt;code&gt;default-extensions&lt;/code&gt; in the cabal manifest) or local scope (i.e. &lt;code&gt;{-# LANGUAGE ... #-}&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Finding specs for existing modules&lt;/h2&gt; &#xA;&lt;p&gt;This is all done by a specialised module called the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin/SpecFinder.hs&#34;&gt;SpecFinder&lt;/a&gt;. The main exported function is &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin/SpecFinder.hs#L61&#34;&gt;findRelevantSpecs&lt;/a&gt; which, given a list of &lt;code&gt;Module&lt;/code&gt;s, tries to retrieve the &lt;code&gt;LiftedSpec&lt;/code&gt;s associated with them. Typically this is done by looking into the interface files of the input modules, trying to deserialise any &lt;code&gt;LiftedSpec&lt;/code&gt; from the interface file&#39;s annotations.&lt;/p&gt; &#xA;&lt;h1&gt;General Development FAQs&lt;/h1&gt; &#xA;&lt;h2&gt;A new version of GHC is out. How do I support it?&lt;/h2&gt; &#xA;&lt;p&gt;Typically the first thing you might want to do is to run a &#34;clean&#34; &lt;code&gt;cabal v2-build&lt;/code&gt; or &lt;code&gt;stack build&lt;/code&gt; using the latest compiler and &#34;check the damage&#34;. If you are lucky, everything works out of the box, otherwise compilation might fail with an error, typically because some &lt;code&gt;ghc&lt;/code&gt; API function has been removed/moved/renamed. The way to fix it is to modify the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/develop/src/Language/Haskell/Liquid/GHC/API.hs&#34;&gt;GHC.API&lt;/a&gt; shim module and perform any required change, likely by conditionally compiling some code in a &lt;code&gt;CPP&lt;/code&gt; block. For minor changes, it&#39;s usually enough to perform small changes, but for more tricky migrations it might be necessary to backport some GHC code, or create some patter synonym to deal with changes in type constructors. You can see an example of this technique in action by looking at the pattern synonym for &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/develop/src/Language/Haskell/Liquid/GHC/API.hs#L224&#34;&gt;FunTy&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Is there a way to run the testsuite for different versions of GHC?&lt;/h2&gt; &#xA;&lt;p&gt;Yes. The easiest way is to run one of the scripts inside the &lt;code&gt;scripts/test&lt;/code&gt; directory. We provide scripts to run the testsuite for a variety of GHC versions, mostly using &lt;code&gt;stack&lt;/code&gt; but also with &lt;code&gt;cabal&lt;/code&gt; (e.g. &lt;code&gt;test_810_plugin.sh&lt;/code&gt;). If run without arguments, the script will run the &lt;em&gt;full&lt;/em&gt; testsuite. If an argument is given, only a particular pattern/test will be run. Running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./scripts/test/test_810_plugin.sh BST&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will run all the tests which name matches &#34;BST&#34;. In case the &#34;fast recompilation&#34; is desired, it&#39;s totally possibly to pass &lt;code&gt;LIQUID_DEV_MODE&lt;/code&gt; to the script, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;LIQUID_DEV_MODE=true ./scripts/test/test_810_plugin.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;GHC Plugin Development FAQs&lt;/h1&gt; &#xA;&lt;h2&gt;Is it possible that the behaviour of the old executable and the new / the plugin differ?&lt;/h2&gt; &#xA;&lt;p&gt;It might happen, yes, but the surface area is fairly small. Both modules work by producing a &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/Types/Specs.hs#L160&#34;&gt;TargetSrc&lt;/a&gt; that is passed to the internal LH API, which is shared by &lt;em&gt;both&lt;/em&gt; modules. Therefore, any difference in behaviour has to be researched in the code path that produces such &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/Types/Specs.hs#L160&#34;&gt;TargetSrc&lt;/a&gt;. For the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs&#34;&gt;GHC.Plugin&lt;/a&gt; this happens in the &lt;code&gt;makeTargetSrc&lt;/code&gt;, whereas for the &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs&#34;&gt;GHC.Interface&lt;/a&gt; this happens inside the [makeGhcSrc][] function.&lt;/p&gt; &#xA;&lt;h2&gt;Why is the GHC.Interface using slightly different types than the GHC.Plugin module?&lt;/h2&gt; &#xA;&lt;p&gt;Mostly for backward-compatibility and for historical reasons. Types like &lt;a href=&#34;https://github.com/ucsd-progsys/liquidhaskell/raw/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/Types/Specs.hs#L301&#34;&gt;BareSpec&lt;/a&gt; used to be type alias rather than &lt;code&gt;newtype&lt;/code&gt;s, and things were slightly renamed to reflect better purpose when the support for the plugin was added. While doing so we also added a compatibility layer in the form of some &lt;code&gt;optics&lt;/code&gt; that can be used to map back and forth (sometimes in a partial way) between old and new data structures. When in doubt, &lt;strong&gt;consider the GHC.Plugin as the single source of truth, and prefer whichever data structure the latter is using&lt;/strong&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>