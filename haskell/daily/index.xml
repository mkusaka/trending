<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-28T01:35:50Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bfops/midi-effect</title>
    <updated>2023-07-28T01:35:50Z</updated>
    <id>tag:github.com,2023-07-28:/bfops/midi-effect</id>
    <link href="https://github.com/bfops/midi-effect" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Cross-platform Haskell library for MIDI playback&lt;/p&gt;&lt;hr&gt;&lt;p&gt;midi-effect is a MIDI I/O library for Haskell. It currently only works through ALSA, which means Linux.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>runtimeverification/hs-backend-booster</title>
    <updated>2023-07-28T01:35:50Z</updated>
    <id>tag:github.com,2023-07-28:/runtimeverification/hs-backend-booster</id>
    <link href="https://github.com/runtimeverification/hs-backend-booster" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Accelerates K Framework&#39;s Haskell backend&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Haskell Backend Booster&lt;/h1&gt; &#xA;&lt;p&gt;A simpler and faster version of &lt;a href=&#34;https://raw.githubusercontent.com/runtimeverification/hs-backend-booster/haskell-backend&#34;&gt;K-Framework&#39;s haskell-backend&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A simple rewrite engine that focuses on the K configuration as the main term&lt;/li&gt; &#xA; &lt;li&gt;Aims to solve &lt;em&gt;easy and common&lt;/em&gt; rewrites quickly, rather than &lt;em&gt;all&lt;/em&gt; rewrites completely&lt;/li&gt; &#xA; &lt;li&gt;Reverts to the standard backend for complex unification and term simplification&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Kompiling a K definition and running the RPC server&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;kore-rpc-booster&lt;/code&gt; binary takes a &lt;code&gt;kore&lt;/code&gt; file definition, parses and internalises it and then launches an RPC server, which executes requests agains this definition. It additionally accepts a path to a dynamic library compiled by the LLVM backend, which is used for simplification of bool sorted terms. In order to build the kore definition and the shared library out of a K definition, first call&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;kompile --llvm-kompile-type c my_defintion.k&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and then launch the server via&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;kore-rpc-booster ./my_defintion-kompiled/definition.kore --module MY-DEFINITION --llvm-backend-library ./my_defintion-kompiled/interpreter&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;h3&gt;Package structure&lt;/h3&gt; &#xA;&lt;p&gt;At the moment, all code lives in a single package. This might change in the future as the software grows in terms of features.&lt;/p&gt; &#xA;&lt;h3&gt;Building&lt;/h3&gt; &#xA;&lt;p&gt;The software can be built with &lt;code&gt;stack&lt;/code&gt; or &lt;code&gt;cabal&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ stack build&#xA;  # or&#xA;$ cabal build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Prerequisites: &lt;code&gt;stack&lt;/code&gt; or &lt;code&gt;cabal&lt;/code&gt;, &lt;code&gt;ghc-9.2.7&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Stackage resolver: &lt;code&gt;lts-20.20&lt;/code&gt; (&lt;code&gt;ghc-9.2.7&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Nix&lt;/h3&gt; &#xA;&lt;p&gt;There are several things you can do, to make the development via nix as seamless as possible.&lt;/p&gt; &#xA;&lt;h4&gt;Nix shell&lt;/h4&gt; &#xA;&lt;p&gt;To open the nix shell you will need nix version 2.4 or newer. Then use either &lt;code&gt;nix develop&lt;/code&gt; (if you have flakes enabled) or use the old style &lt;code&gt;nix-shell&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;p&gt;If you want to open a shell for a different version of ghc (currently supporting &lt;code&gt;ghc927&lt;/code&gt;), use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix develop .#ghc927&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix-shell --argstr ghc ghc927&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can open a dev shell which contains cabal with all the required libraries compiled with profiling via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nix develop .#ghc925-prof&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Nix-direnv&lt;/h4&gt; &#xA;&lt;p&gt;Using a version of direnv that works with nix (&lt;a href=&#34;https://github.com/nix-community/nix-direnv&#34;&gt;https://github.com/nix-community/nix-direnv&lt;/a&gt;) allows seamless loading and unloading of the nix shell, which adds all the required packages such as &lt;code&gt;cabal&lt;/code&gt;, &lt;code&gt;hpack&lt;/code&gt;, &lt;code&gt;fourmolu&lt;/code&gt;, etc. Use the above link to install &lt;code&gt;nix-direnv&lt;/code&gt;, making sure to hook direnv into whichever shell you are using (&lt;a href=&#34;https://direnv.net/docs/hook.html&#34;&gt;https://direnv.net/docs/hook.html&lt;/a&gt;). You can use the default nix shell (currently GHC version 9.2.7) by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#34;use nix&#34; &amp;gt; .envrc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use a different version of GHC for your shell, e.g. &lt;code&gt;ghc927&lt;/code&gt;, use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#34;use flake .#ghc927&#34; &amp;gt; .envrc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, run &lt;code&gt;direnv allow&lt;/code&gt; inside the repo folder to load up the nix shell.&lt;/p&gt; &#xA;&lt;p&gt;Note that only &lt;code&gt;cabal&lt;/code&gt; currently works within the nix shell and since it does not support the HPack &lt;code&gt;package.yaml&lt;/code&gt; file format, any changes to this file will require running &lt;code&gt;hpack&lt;/code&gt; before they are picked up by cabal.&lt;/p&gt; &#xA;&lt;h3&gt;scripts/update-haskell-backend.sh&lt;/h3&gt; &#xA;&lt;p&gt;To bump the version of the haskell-backend consistently within the project (i.e. in nix, cabal.project and stack.yaml) call&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nix run .#update-haskell-backend&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;you can optionally pass a commit hash above if you don&#39;t want master.&lt;/p&gt; &#xA;&lt;h3&gt;HLS in VSCode&lt;/h3&gt; &#xA;&lt;p&gt;To get HLS working in VSCode, install these two extensions:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=arrterian.nix-env-selector&#34;&gt;https://marketplace.visualstudio.com/items?itemName=arrterian.nix-env-selector&lt;/a&gt; &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=haskell.haskell&#34;&gt;https://marketplace.visualstudio.com/items?itemName=haskell.haskell&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;nix-env-selector&lt;/code&gt; extension may prompt for the workspace to be re-loaded. Once re-loaded, HLS should start working. In case you need to use a specific version of ghc for this extension, modify the &lt;code&gt;.vscode/settings.json&lt;/code&gt; file here:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &#34;nixEnvSelector.args&#34;: &#34;--argstr ghc ghc927&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Eventlog tracing&lt;/h2&gt; &#xA;&lt;p&gt;Besides compiling the backend with profiling mode, we can also enable a targeted profiling mode by emitting useful debug events into the eventlog. So far we can emit/trace the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;LLVM backend API calls - using &lt;code&gt;--trace llvm-calls +RTS -l-au&lt;/code&gt; we can collect all the LLVM backend API calls the server performs during execution. Running the obtained eventlog through &lt;code&gt;eventlog-parser&lt;/code&gt; will produce an &lt;code&gt;llvm_calls.c&lt;/code&gt; file of the form:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;kore_symbol* sym_m5952705877914568462 = kore_symbol_new(&#34;LblnotBool&#39;Unds&#39;&#34;);&#xA;kore_pattern* pat_m7294887483024610198 = kore_composite_pattern_from_symbol(sym_m5952705877914568462);&#xA;kore_symbol* sym_2859997003983430356 = kore_symbol_new(&#34;LblSet&#39;Coln&#39;in&#34;);&#xA;kore_pattern* pat_7796859658648783000 = kore_composite_pattern_from_symbol(sym_2859997003983430356);&#xA;kore_symbol* sym_m6495506210664726973 = kore_symbol_new(&#34;inj&#34;);&#xA;kore_sort* sort_m1174205405547972024 = kore_composite_sort_new(&#34;SortId&#34;);&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Timing information in IO - using &lt;code&gt;--trace timing +RTS -lsu&lt;/code&gt; we can instrument code with &lt;code&gt;Trace.timeIO &#34;foo&#34; ...&lt;/code&gt; calls which will measure time spent in &lt;code&gt;...&lt;/code&gt; and attach the label &lt;code&gt;foo&lt;/code&gt; to this region in the speedscope profile. &lt;code&gt;eventlog-parser&lt;/code&gt; will produce a JSON file of these calls viewable in the speedscope app.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>