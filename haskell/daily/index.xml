<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-02T01:25:57Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>haskell-cryptography/botan</title>
    <updated>2024-03-02T01:25:57Z</updated>
    <id>tag:github.com,2024-03-02:/haskell-cryptography/botan</id>
    <link href="https://github.com/haskell-cryptography/botan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell bindings for the Botan cryptography library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Welcome to botan&lt;/h1&gt; &#xA;&lt;!-- TODO: Badges: hackage)  --&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/haskellfoundation/botan/actions/workflows/CI.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;botan&lt;/code&gt; is a set of Haskell bindings for the &lt;a href=&#34;https://botan.randombit.net/&#34;&gt;Botan&lt;/a&gt; cryptography library.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Botan&#39;s goal is to be the best option for cryptography in C++ by offering the tools necessary to implement a range of practical systems, such as TLS protocol, X.509 certificates, modern AEAD ciphers, PKCS#11 and TPM hardware support, password hashing, and post quantum crypto schemes.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Acknowledgements&lt;/h1&gt; &#xA;&lt;p&gt;This project has received support from the &lt;a href=&#34;https://haskell.foundation/&#34;&gt;Haskell Foundation&lt;/a&gt;, and was made possible through funding provided by &lt;a href=&#34;https://mercury.com/&#34;&gt;Mercury&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://mercury.com/&#34; alt=&#34;Mercury&#34;&gt;&lt;img src=&#34;https://github.com/haskellfoundation/botan/raw/main/contributors/mercury.svg?sanitize=true&#34; width=&#34;320&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Navigation&lt;/h1&gt; &#xA;&lt;details open&gt;&#xA; &lt;summary&gt;Expand / Collapse Navigation&lt;/summary&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Welcome-to-botan&#34;&gt;Welcome to botan&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Installation&#34;&gt;Installation&lt;/a&gt; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Unix-package&#34;&gt;Unix package&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#MacOS-package&#34;&gt;MacOS package&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#From-source&#34;&gt;From source&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Windows-from-source&#34;&gt;Windows from source&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Usage&#34;&gt;Usage&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Tutorials&#34;&gt;Tutorials&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Enabling-experimental-support&#34;&gt;Enabling experimental support&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Resources&#34;&gt;Resources&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#License&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Contributing&#34;&gt;Contributing&lt;/a&gt; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Reporting-Bugs&#34;&gt;Reporting Bugs&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Assist-in-Development&#34;&gt;Assist in Development&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Donations&#34;&gt;Donations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;h1&gt;Introduction&lt;/h1&gt; &#xA;&lt;p&gt;This project has the goal of providing a set of safe and performant bindings to the Botan C++ cryptography library via its C FFI (Foreign Function Interface). It does this by providing 3 libraries at varying levels of complexity and abstraction:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;botan-bindings&lt;/code&gt; contains raw bindings with buffers and pointers, and is otherwise an almost a 1:1 translation of the C FFI into Haskell&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;botan-low&lt;/code&gt; contains low-level bindings with imperative IO and exceptions, and safely wraps buffers and pointers into bytestrings and autoreleased objects&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;botan&lt;/code&gt; contains high-level bindings with strong types and idiomatic Haskell, and provides algebraic data types and convenience functions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We suggest using the highest-level library possible, unless you wish to build your own abstraction over the Botan C++ library. The highest-level stable library is currently: &lt;code&gt;botan-low&lt;/code&gt;&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Features&lt;/summary&gt; &#xA; &lt;p&gt;This library provides its bindings through the Botan C FFI, which does not currently cover the entire range of features available in C++. As such, it provides a sizeable yet limited subset of those features.&lt;/p&gt; &#xA; &lt;p&gt;These bindings provide the following features:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Random number generators&lt;/li&gt; &#xA;  &lt;li&gt;Hashing and non-cryptographic checksums&lt;/li&gt; &#xA;  &lt;li&gt;Message authentication codes&lt;/li&gt; &#xA;  &lt;li&gt;Block, mode, and AEAD ciphers&lt;/li&gt; &#xA;  &lt;li&gt;Password hashing and key derivation functions&lt;/li&gt; &#xA;  &lt;li&gt;Hash- and time-based one-time passwords&lt;/li&gt; &#xA;  &lt;li&gt;Post-quantum crypto schemes&lt;/li&gt; &#xA;  &lt;li&gt;SRP6 password authenticated key exchange&lt;/li&gt; &#xA;  &lt;li&gt;X.509 certificate systems (experimental)&lt;/li&gt; &#xA;  &lt;li&gt;ZFEC forward error correction&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;NOTE: This project includes efforts to expand this subset of features through a fork of the Botan C++ library - see &lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#Enabling-experimental-support&#34;&gt;Enabling experimental support&lt;/a&gt; for more details. This fork will be contributed back to the original library when it becomes sufficiently stable.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;This library requires Botan 3 to be installed in order to work. See &lt;a href=&#34;https://botan.randombit.net/handbook/building.html&#34;&gt;Building the Library&lt;/a&gt; in the handbook for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Unix package&lt;/h2&gt; &#xA;&lt;p&gt;&lt;del&gt;Botan is available already in nearly all &lt;a href=&#34;https://repology.org/project/botan/versions&#34;&gt;packaging systems&lt;/a&gt; so you can probably install it through your distribution / system package manager.&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;At current, Botan &lt;strong&gt;2&lt;/strong&gt; is readily available, but Botan &lt;strong&gt;3&lt;/strong&gt; is not yet available as a prebuilt linux package. Please see &#39;Building from source&#39;.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Arch&lt;/summary&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;Untested.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pacman -S botan&#xA;# or maybe&#xA;pacman -S botan3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Debian&lt;/summary&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;Untested.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;apt-get update&#xA;apt-get install botan&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Red Hat&lt;/summary&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;Untested.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum update&#xA;yum install botan&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Ubuntu&lt;/summary&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;Untested.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt update&#xA;sudo apt install botan&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;MacOS package&lt;/h2&gt; &#xA;&lt;p&gt;Botan is available through the &lt;a href=&#34;https://brew.sh/&#34;&gt;Homebrew&lt;/a&gt; package manager:&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Homebrew&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew install botan&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;From source&lt;/h2&gt; &#xA;&lt;p&gt;Botan can be built from source, for additional configuration options and customization.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Build from source&lt;/summary&gt; &#xA; &lt;p&gt;First, clone the Botan C++ repository:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/randombit/botan&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Botan’s build configuration is controlled by &lt;code&gt;configure.py&lt;/code&gt;, and requires Python 3.x or later.&lt;/p&gt; &#xA; &lt;p&gt;This works for most systems:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./configure.py [--prefix=/some/directory]&#xA;make&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;If you wish to run unit tests before installation, run &lt;code&gt;make check&lt;/code&gt; before &lt;code&gt;make install&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;p&gt;On platforms that do not understand the &lt;code&gt;#!&lt;/code&gt; convention for beginning script files, or that have Python installed in an unusual spot, you might need to prefix the &lt;code&gt;configure.py&lt;/code&gt; command with &lt;code&gt;python3&lt;/code&gt; or &lt;code&gt;/path/to/python&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python3 ./configure.py [arguments]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The &lt;code&gt;make install&lt;/code&gt; target has a default directory in which it will install Botan (typically &lt;code&gt;/usr/local&lt;/code&gt;). You can override this by using the &lt;code&gt;--prefix&lt;/code&gt; argument to &lt;code&gt;configure.py&lt;/code&gt;, like so:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./configure.py --prefix=/botan [arguments]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Some features rely on third party libraries which your system might not have or that you might not want the resulting binary to depend on. For instance to enable &lt;code&gt;sqlite3&lt;/code&gt; support, add &lt;code&gt;--with-sqlite3&lt;/code&gt; to your invocation of &lt;code&gt;configure.py&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./configure.py --with-sqlite3 [arguments]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Windows from source&lt;/h2&gt; &#xA;&lt;p&gt;Prebuilt botan is not available for windows, and it must be built from source. The process is similar to building from source in Unix or MacOS.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Windows from source&lt;/summary&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;Untested.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;You need to have a copy of Python installed, and have both Python and your chosen compiler in your path. Open a command shell (or the SDK shell), and run:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python3 configure.py --cc=msvc --os=windows&#xA;nmake&#xA;nmake check&#xA;nmake install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Alternately, starting in Botan 3.2, there is additionally support for using the ninja build tool as an alternative to nmake:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python3 configure.py --cc=msvc --os=windows --build-tool=ninja&#xA;ninja&#xA;ninja check&#xA;ninja install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;For MinGW, use:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python3 configure.py --cc=gcc --os=mingw&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;By default the install target will be &lt;code&gt;C:\botan&lt;/code&gt;; you can modify this with the &lt;code&gt;--prefix&lt;/code&gt; option.&lt;/p&gt; &#xA; &lt;p&gt;When building your applications, all you have to do is tell the compiler to look for both include files and library files in C:\botan, and it will find both. Or you can move them to a place where they will be in the default compiler search paths (consult your documentation and/or local expert for details).&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;You will need to add &lt;code&gt;botan&lt;/code&gt; as a package dependency in order to use it.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Cabal&lt;/summary&gt; &#xA; &lt;!-- This package is not yet available on hackage, so you&#39;ll have to add the repo to your `cabal.project` file using a `source-repository-package` stanza:&#xA;&#xA;```&#xA;source-repository-package&#xA;    type: git&#xA;    location: git://github.com/haskellfoundation/botan.git&#xA;    tag: [commit-hash]&#xA;```&#xA;--&gt; &#xA; &lt;p&gt;This package is now available on hackage. Simply add it to your &lt;code&gt;[project].cabal&lt;/code&gt; under the &lt;code&gt;build-depends&lt;/code&gt; stanza:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;build-depends:&#xA;    botan-low&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;If you installed botan in a non-standard location, you may need to specify where using &lt;code&gt;--extra-include-dirs&lt;/code&gt; and &lt;code&gt;--extra-lib-dirs&lt;/code&gt; flags:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cabal repl TARGET --extra-include-dirs /botan/include --extra-lib-dirs /botan/lib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You can add these flags permanently to your &lt;code&gt;cabal.project&lt;/code&gt; or &lt;code&gt;cabal.project.local&lt;/code&gt; file:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;extra-include-dirs:&#xA;- /botan/include&#xA;extra-lib-dirs:&#xA;- /botan/lib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Stack&lt;/summary&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;Untested.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;This package is not yet available on stackage, so you&#39;ll have to add the repo to your &lt;code&gt;stack.yaml&lt;/code&gt; file under the &lt;code&gt;extra-deps&lt;/code&gt; stanza:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;extra-deps:&#xA;- github: haskellfoundation/botan&#xA;  commit: [commit-hash]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Then, add it to your &lt;code&gt;package.yaml&lt;/code&gt; file under the &lt;code&gt;dependencies&lt;/code&gt; stanza:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;dependencies:&#xA;- botan-low&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;If you installed botan in a non-standard location, you may need to specify where using &lt;code&gt;--extra-include-dirs&lt;/code&gt; and &lt;code&gt;--extra-lib-dirs&lt;/code&gt; flags:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;stack repl TARGET --extra-include-dirs /botan/include --extra-lib-dirs /botan/lib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You can add these flags permanently to your &lt;code&gt;stack.yaml&lt;/code&gt; or global &lt;code&gt;config.yaml&lt;/code&gt; file:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;extra-include-dirs:&#xA;- /botan/include&#xA;extra-lib-dirs:&#xA;- /botan/lib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;After you have added &lt;code&gt;botan&lt;/code&gt; as a dependency, you can begin importing modules and using them in your code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.Hash&#xA;&#xA;main = do&#xA;    hash &amp;lt;- hashInit &#34;SHA-256&#34;&#xA;    digest &amp;lt;- hashUpdateFinalize hash &#34;Fee fi fo fum!&#34;&#xA;    print digest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Tutorials&lt;/h1&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.Bcrypt&lt;/summary&gt; &#xA; &lt;p&gt;&lt;code&gt;bcrypt&lt;/code&gt; is a password-hashing algorithm designed to protect your passwords against hackers using an expensive key setup phase. Instead of storing a user&#39;s password in plaintext in the database, the server may instead generate a salted bcrypt digest upon signup, and verify it upon login.&lt;/p&gt; &#xA; &lt;p&gt;The &lt;code&gt;bcrypt&lt;/code&gt; implementation provided by &lt;code&gt;botan&lt;/code&gt; generates a random salt for you automatically. A work factor of 12 or greater is recommended.&lt;/p&gt; &#xA; &lt;p&gt;To generate a bcrypt digest:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.RNG&#xA;import Botan.Low.Bcrypt&#xA;&#xA;-- The user has sent us a username and password in order to sign up &#xA;onUserSignup :: ByteString -&amp;gt; ByteString -&amp;gt; IO ()&#xA;onUserSignup username password = do&#xA;    rng &amp;lt;- rngInit &#34;user&#34;&#xA;    digest &amp;lt;- bcryptGenerate password rng 12&#xA;    createAndStoreNewUser username digest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To validate a bcrypt digest:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.RNG&#xA;import Botan.Low.Bcrypt&#xA;&#xA;-- The user has sent us a username and password in order to log in&#xA;onUserLogin :: ByteString -&amp;gt; ByteString -&amp;gt; IO Bool&#xA;onUserLogin username password = do&#xA;    rng &amp;lt;- rngInit &#34;user&#34;&#xA;    digestMaybe &amp;lt;- getStoredUserDigest username&#xA;    case digestMaybe of&#xA;        Nothing     -&amp;gt; return False&#xA;        Just digest -&amp;gt; bcryptIsValid password digest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.BlockCipher&lt;/summary&gt; &#xA; &lt;p&gt;A &lt;code&gt;block cipher&lt;/code&gt; is a deterministic, cryptographic primitive suitable for encrypting or decrypting a single, fixed-size block of data at a time. Block ciphers are used as building blocks for more complex cryptographic operations. If you are looking to encrypt user data, you are probably looking for &lt;code&gt;Botan.Low.Cipher&lt;/code&gt; instead.&lt;/p&gt; &#xA; &lt;p&gt;Unless you need a specific block cipher, it is strongly recommended that you use the &lt;code&gt;AES256&lt;/code&gt; algorithm.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.BlockCipher&#xA;blockCipher &amp;lt;- blockCipherInit AES256&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To use a block cipher, we first need to generate (if we haven&#39;t already) a secret key.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.RNG&#xA;rng &amp;lt;- rngInit &#34;user&#34;&#xA;-- We will use the maximum key size; AES256 keys are always 16 bytes&#xA;(_,keySize,_) &amp;lt;- blockCipherGetKeyspec blockCipher&#xA;-- Block cipher keys are randomly generated&#xA;key &amp;lt;- rngGet rng keySize&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;After the key is generated, we must set it as the block cipher key:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;blockCipherSetKey blockCipher key&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To encrypt a message, it must be a multiple of the block size.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;blockSize &amp;lt;- blockCipherBlockSize blockCipher&#xA;-- AES256 block size is always 16 bytes&#xA;message = &#34;0000DEADBEEF0000&#34; :: ByteString&#xA;ciphertext &amp;lt;- blockCipherEncryptBlocks blockCipher message&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To decrypt a message, simply reverse the process:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;plaintext &amp;lt;- blockCipherDecryptBlocks blockCipher ciphertext&#xA;message == plaintext -- True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.Cipher&lt;/summary&gt; &#xA; &lt;p&gt;A &lt;code&gt;cipher&lt;/code&gt; mode is a cryptographic algorithm suitable for encrypting and decrypting large quantities of arbitrarily-sized data. An &lt;code&gt;aead&lt;/code&gt; is a cipher mode that also used to provide authentication of the ciphertext, potentially with plaintext &lt;code&gt;associated data&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;p&gt;Unless you need a specific &lt;code&gt;cipher&lt;/code&gt; or &lt;code&gt;aead&lt;/code&gt;, it is strongly recommended that you use the &lt;code&gt;cbcMode AES256 PKCS7&lt;/code&gt; and &lt;code&gt;gcmMode AES256&lt;/code&gt; (or &lt;code&gt;ChaCha20Poly1305&lt;/code&gt;) algorithms respectively.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.Cipher&#xA;encrypter &amp;lt;- cipherInit ChaCha20Poly1305 Encrypt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To use a cipher, we first need to generate (if we haven&#39;t already) a secret key.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.RNG&#xA;rng &amp;lt;- rngInit &#34;user&#34;&#xA;-- We will use the maximum key size; ChaCha20Poly1305 keys are always 32 bytes&#xA;(_,keySize,_) &amp;lt;- cipherGetKeyspec encrypter&#xA;-- Block cipher keys are randomly generated&#xA;key &amp;lt;- rngGet rng keySize&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;After the key is generated, we must set it as the cipher key:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;cipherSetKey encrypter key&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;If the cipher is an &lt;code&gt;aead&lt;/code&gt;, we may also set the &lt;code&gt;associated data&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;cipherSetAssociatedData encrypter &#34;Fee fi fo fum!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To ensure that the key is not leaked, we should generate a new nonce for every encryption. The range of allowed nonce sizes depends on the specific algorithm.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.RNG&#xA;-- The default ChaCha20Poly1305 nonce is always 12 bytes.&#xA;nonceSize &amp;lt;- cipherGetDefaultNonceLength encrypter&#xA;nonce &amp;lt;- rngGet rng nonceSize&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To encrypt a message, it must be a multiple of the block size. If the cipher was an aead, the authentication tag will automatically be included in the ciphertext&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- Rarely, some cipher modes require that the message size be aligned to the block size&#xA;-- Consult algorithm-specific documentation if this occurs. &#xA;message = &#34;I smell the blood of an Englishman!&#34;&#xA;cipherStart encrypter nonce&#xA;ciphertext &amp;lt;- cipherEncrypt encrypter message&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To decrypt a message, we run the same process with a decrypter, using the same &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;nonce&lt;/code&gt; to decode the &lt;code&gt;ciphertext&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;decrypter &amp;lt;- cipherInit ChaCha20Poly1305 Decrypt&#xA;cipherSetKey decrypter key&#xA;cipherSetAssociatedData decrypter &#34;Fee fi fo fum!&#34;&#xA;cipherStart decrypter nonce&#xA;plaintext &amp;lt;- cipherDecrypt decrypter ciphertext&#xA;message == plaintext -- True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You can completely clear a cipher&#39;s state, leaving it ready for reuse:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;cipherClear encrypter&#xA;-- You&#39;ll have to set the key, nonce, (and ad, if aead) again.&#xA;cipherSetKey encrypter anotherKey&#xA;cipherStart encrypter anotherNonce&#xA;cipherSetAssociatedData encrypter anotherAD&#xA;-- Process another message&#xA;anotherCiphertext &amp;lt;- cipherEncrypt encrypter anotherMessage&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;If you are encrypting or decrypting multiple messages with the same key, you can reset the cipher instead of clearing it, leaving the key set:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;cipherClear encrypter&#xA;-- This is equivalent to calling cipherClear followed by cipherSetKey with the original key.&#xA;-- You&#39;ll have to set the nonce  (and ad, if aead) again, but not the key.&#xA;cipherStart encrypter anotherNonce&#xA;cipherSetAssociatedData encrypter anotherAD&#xA;-- Process another message with the same key&#xA;anotherCiphertext &amp;lt;- cipherEncrypt encrypter anotherMessage&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;!-- &lt;details&gt;&lt;summary&gt;Botan.Low.FPE&lt;/summary&gt;&#xA;&#xA;&lt;/details&gt; --&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.Hash&lt;/summary&gt; &#xA; &lt;p&gt;A &lt;code&gt;hash&lt;/code&gt; is deterministic, one-way function suitable for producing a deterministic, fixed-size digest from an arbitrarily-sized message, which is used to verify the integrity of the data.&lt;/p&gt; &#xA; &lt;p&gt;Unless you need a specific &lt;code&gt;hash&lt;/code&gt;, it is strongly recommended that you use the &lt;code&gt;SHA3&lt;/code&gt; algorithm.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.Hash&#xA;hash &amp;lt;- hashInit SHA3&#xA;message = &#34;Fee fi fo fum!&#34;&#xA;hashUpdate hash message&#xA;digest &amp;lt;- hashFinal hash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You can verify a digest by hashing the message a second time, and comparing the two:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;rehash &amp;lt;- hashInit SHA3&#xA;hashUpdate rehash message&#xA;redigest &amp;lt;- hashFinal rehash&#xA;digest == redigest -- True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You can clear a hash&#39;s state, leaving it ready for reuse:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;hashClear hash&#xA;-- Process another message&#xA;hashUpdate hash anotherMessage&#xA;anotherDigest &amp;lt;- hashFinal hash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.HOTP&lt;/summary&gt; &#xA; &lt;p&gt;To use HOTP for MFA / 2FA, the client authenticator must generate a client-specific shared secret and counter value, and securely communicate them to the server authenticator.&lt;/p&gt; &#xA; &lt;p&gt;The secret key may be any bytestring value with more than 160 bits, such as a Bcrypt digest or SRP6 shared key. The counter value is not required to be a secret; it may start at 0 for simplicity, or it may start at a value that was selected at random.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.HOTP&#xA;import Botan.Low.RNG&#xA;import Botan.Low.MPI&#xA;import Data.Bits&#xA;sharedSecret &amp;lt;- systemRNGGet 16&#xA;-- TODO: Use random:System.Random.Stateful.Uniform instead of MPI in `botan`&#xA;(hi :: Word32) &amp;lt;- mpInit &amp;gt;&amp;gt;= \ w -&amp;gt; mpRandBits w rng 32 &amp;gt;&amp;gt; mpToWord32 w&#xA;(lo :: Word32) &amp;lt;- mpInit &amp;gt;&amp;gt;= \ w -&amp;gt; mpRandBits w rng 32 &amp;gt;&amp;gt; mpToWord32 w&#xA;(counter :: Word64) = shiftL (fromIntegral hi) 32 `xor` fromIntegral lo &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The client and server authenticators are now in a shared state, and any login attempts from a new device may be authenticated using HOTP as MFA.&lt;/p&gt; &#xA; &lt;p&gt;A client has requested a new connection, and HOTP is being used as MFA/2FA to authenticate their request. The server authenticator receives the client connection request and initializes a HOTP session using the stored client-specific shared secret, and then sends an authentication request to the client authenticator:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- (serverSharedSecret, serverCounter) &amp;lt;- lookupServerSharedSecretAndCounter&#xA;serverSession &amp;lt;- hotpInit serverSharedSecret HOTP_SHA512 8&#xA;-- sendMFAAuthenticationRequest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The client authenticator receives the authentication request, generates a client-side code, increments their counter, and displays the HOTP code to the user:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- (clientSharedSecret, clientCounter) &amp;lt;- lookupClientSharedSecretAndCounter&#xA;clientSession &amp;lt;- hotpInit clientSharedSecret HOTP_SHA512 8&#xA;clientCode &amp;lt;- hotpGenerate clientSession clientCounter&#xA;-- incrementAndPersistClientCounter&#xA;-- displayClientCode clientCode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;NOTE: The client authenticator is responsible for incrementing and persisting their own counter manually.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;The client then sends the client code to the server authenticator using the unauthenticated / requested connection:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- clientCode &amp;lt;- readClientCode&#xA;-- sendMFAAuthenticationResponse clientCode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The server authenticator receives the authentication response, and performs a check of the key, with a resync range of R in case the client has generated a few codes without logging in successfully:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- serverClientCode &amp;lt;- didreceiveMFAAuthenticationResponse&#xA;(isValid,nextCounter) &amp;lt;- hotpCheck serverSession serverClientCode serverCounter 10&#xA;persistClientCounter nextCounter&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;NOTE: The server authentication check returns an incremented and resynced counter which must be persisted manually. If the authentication check fails, the counter value is return unchanged.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;If the code is valid, then the signin may be completed on the new connection as normal.&lt;/p&gt; &#xA; &lt;p&gt;The server should discontinue the session and refuse any new connections to the account after T unsuccessful authentication attempts, where T &amp;lt; R. The user should then be notified.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;!-- &lt;details&gt;&lt;summary&gt;Botan.Low.KDF&lt;/summary&gt;&#xA;&#xA;&lt;/details&gt; --&gt; &#xA;&lt;!-- &lt;details&gt;&lt;summary&gt;Botan.Low.KeyWrap&lt;/summary&gt;&#xA;&#xA;&lt;/details&gt; --&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.MAC&lt;/summary&gt; &#xA; &lt;p&gt;A &lt;code&gt;mac&lt;/code&gt; (or message authentication code) is a cryptographic algorithm that uses a secret key to produce a fixed-size digest from an arbitrarily-sized message, which is then used to verify the integrity and authenticity of the data.&lt;/p&gt; &#xA; &lt;p&gt;Unless you need a specific &lt;code&gt;mac&lt;/code&gt;, it is strongly recommended that you use the &lt;code&gt;hmac SHA3&lt;/code&gt; algorithm.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.MAC&#xA;import Botan.Low.Hash&#xA;mac &amp;lt;- macInit (hmac SHA3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To use a MAC, we first need to generate (if we haven&#39;t already) a secret key.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.RNG&#xA;rng &amp;lt;- rngInit &#34;user&#34;&#xA;-- HMAC allows for an arbitrary key size, but we can check the key spec if necessary&#xA;(keyMin,keyMax,keyMod) &amp;lt;- macGetKeyspec mac&#xA;-- MAC are randomly generated; 32 bytes is acceptable&#xA;key &amp;lt;- rngGet rng 32&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;After the key is generated, we must set it as the mac key:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;macSetKey mac key&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Then, we may produce an authentication code from a message using the secret key:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;macUpdate mac &#34;Fee fi fo fum!&#34;&#xA;auth &amp;lt;- macFinal mac&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To verify an message authentication code, we can reproduce it using the secret key and message, and then check for equality:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;verify &amp;lt;- macInit (hmac SHA3)&#xA;macSetKey verify key&#xA;macUpdate verify &#34;Fee fi fo fum!&#34;&#xA;verifyAuth &amp;lt;- macFinal verify&#xA;auth == verifyAuth -- True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You can completely clear a mac&#39;s state, leaving it ready for reuse:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;macClear mac&#xA;-- You&#39;ll have to set the key again&#xA;macSetKey mac anotherKey&#xA;-- Process another message&#xA;macUpdate mac anotherMessage&#xA;anotherAuth &amp;lt;- macFinal mac&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Some algorithms (GMAC, Poly1305) have additional requirements for use. Avoid if possible, and consult algorithm-specific documentation for GMAC and Poly1305. If you must use GMAC, a nonce needs to be set:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mac &amp;lt;- macInit (gmac AES256)&#xA;k &amp;lt;- systemRNGGet 32&#xA;n &amp;lt;- systemRNGGet 32    -- Here&#xA;macSetKey mac k&#xA;macSetNonce mac n       -- Here&#xA;macUpdate mac &#34;Fee fi fo fum!&#34;&#xA;auth &amp;lt;- macFinal mac&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;!-- &lt;details&gt;&lt;summary&gt;Botan.Low.MPI&lt;/summary&gt;&#xA;&#xA;&lt;/details&gt; --&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.PubKey&lt;/summary&gt; &#xA; &lt;p&gt;Unless you need a specific &lt;code&gt;public key cryptosystem&lt;/code&gt;, it is strongly recommended that you use the &lt;code&gt;RSA&lt;/code&gt;, &lt;code&gt;Ed25519&lt;/code&gt;, or &lt;code&gt;Curve25519&lt;/code&gt; algorithms, depending on your desired operation.&lt;/p&gt; &#xA; &lt;p&gt;Create an RSA keypair:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.RNG&#xA;import Botan.Low.PubKey&#xA;rng &amp;lt;- rngInit &#34;user&#34;&#xA;-- Alice generates her keys&#xA;alicePrivKey &amp;lt;- privKeyCreate RSA &#34;4096&#34; rng&#xA;alicePubKey &amp;lt;- privKeyExportPubKey alicePrivKey&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;NOTE: For algorithm-specific parameters, consult the Botan documentation and source&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.PubKey.Encrypt&lt;/summary&gt; &#xA; &lt;p&gt;Encrypt a message:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.PubKey.Encrypt&#xA;message = &#34;Fee fi fo fum!&#34;&#xA;-- Bob encrypts a message for Alice using her public key&#xA;-- Unlike `Crypto.Saltine.Core.Box`, the message is only encrypted, not signed.&#xA;encrypter &amp;lt;- encryptCreate alicePubKey EME_PKCS1_v1_5&#xA;ciphertext &amp;lt;- encrypt encrypter rng message&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;NOTE: For algorithm-specific padding parameters, consult the Botan documentation and source&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;Decrypt a message:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.PubKey.Decrypt&#xA;-- Alice decrypts the message from Bob using her private key&#xA;decrypter &amp;lt;- decryptCreate alicePrivKey EME_PKCS1_v1_5&#xA;plaintext &amp;lt;- decrypt decrypter ciphertext&#xA;message == plaintext -- True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;NOTE: The same padding must be used for both encryption and decryption&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.PubKey.Sign&lt;/summary&gt; &#xA; &lt;p&gt;Sign a message:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.PubKey.Sign&#xA;import Botan.Low.Hash&#xA;message = &#34;Fee fi fo fum!&#34;&#xA;-- Alice signs the message using her private key&#xA;signer &amp;lt;- signCreate alicePrivKey (emsa_emsa4 SHA3) StandardFormatSignature&#xA;signUpdate signer message&#xA;sig &amp;lt;- signFinish signer rng&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;NOTE: Signing uses a different set of padding algorithms &lt;code&gt;EMSA&lt;/code&gt; from encryption &lt;code&gt;EME&lt;/code&gt;, and different signing / encryption algorithms support different specific padding algorithms&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;NOTE: Signing does not yet have proper constants for selecting a padding mechanism. For more information, refer to the &lt;code&gt;Botan.PubKey&lt;/code&gt;, &lt;code&gt;Botan.PubKey.Sign&lt;/code&gt;, or the Botan C++ documentation. This area will be improved in the near future.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;Verify a message:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.PubKey.Verify&#xA;-- Bob verifies the message using Alice&#39;s public key&#xA;verifier &amp;lt;- verifyCreate alicePubKey (emsa_emsa4 SHA3) StandardFormatSignature&#xA;verifyUpdate verifier message&#xA;verified &amp;lt;- verifyFinish verifier sig&#xA;verified -- True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;NOTE: The same padding must be used for both encryption and decryption&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.PubKey.KeyAgreement&lt;/summary&gt; &#xA; &lt;p&gt;First, Alice and Bob generate their private keys:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.PubKey&#xA;import Botan.Low.PubKey.KeyAgreement&#xA;import Botan.Low.RNG&#xA;import Botan.Low.Hash&#xA;import Botan.Low.KDF&#xA;rng &amp;lt;- rngInit &#34;system&#34;&#xA;-- Alice creates her private key&#xA;alicePrivKey &amp;lt;- privKeyCreate ECDH Secp521r1 rng &#xA;-- Bob creates his private key&#xA;bobPrivKey &amp;lt;-  privKeyCreate ECDH Secp521r1 rng &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Then, they exchange their public keys using any channel, private or public:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- Alice and Bob exchange public keys&#xA;alicePubKey &amp;lt;- keyAgreementExportPublic alicePrivKey&#xA;bobPubKey &amp;lt;- keyAgreementExportPublic bobPrivKey&#xA;-- ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Then, they may separately generate the same agreed-upon key and a randomized, agreed-upon salt:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;salt &amp;lt;- rngGet rng 4&#xA;-- Alice generates her shared key:&#xA;aliceKeyAgreement &amp;lt;- keyAgreementCreate alicePrivKey (kdf2 SHA256)&#xA;aliceSharedKey    &amp;lt;- keyAgreement aliceKeyAgreement bobPubKey salt&#xA;-- Bob generates his shared key:&#xA;bobKeyAgreement   &amp;lt;- keyAgreementCreate bobPrivKey (kdf2 SHA256)&#xA;bobSharedKey      &amp;lt;- keyAgreement bobKeyAgreement alicePubKey salt&#xA;-- They are the same&#xA;aliceSharedKey == bobSharedKey&#xA;-- True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.PubKey.KeyEncapsulation&lt;/summary&gt; &#xA; &lt;p&gt;First, Alice generates her private and public key pair:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.PubKey&#xA;import Botan.Low.PubKey.KeyEncapsulation&#xA;import Botan.Low.Hash&#xA;import Botan.Low.KDF&#xA;import Botan.Low.RNG&#xA;rng &amp;lt;- rngInit UserRNG&#xA;-- Alice generates her private and public keys&#xA;alicePrivKey &amp;lt;- privKeyCreate RSA &#34;2048&#34; rng&#xA;alicePubKey &amp;lt;- privKeyExportPubKey alicePrivKey&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Then, Alice shares her public key somewhere where others can see. When Bob wants to create a shared key with Alice, they choose a KDF algorithm, generate a salt, and choose a shared key length.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;kdfAlg = hkdf SHA256&#xA;salt &amp;lt;- rngGet rng 4&#xA;sharedKeyLength = 256&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Then, Bob generates the shared + encapsulated key, and sends the encapsulated key to Alice:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;encryptCtx &amp;lt;- kemEncryptCreate alicePubKey kdfAlg&#xA;(bobSharedKey, encapsulatedKey) &amp;lt;- kemEncryptCreateSharedKey encryptCtx rng salt sharedKeyLength&#xA;-- sendToAlice encapsulatedKey&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Upon receiving the encapsulated key, Alice can decrypt and extract the shared key using her private key:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;decryptCtx &amp;lt;- kemDecryptCreate alicePrivKey kdfAlg&#xA;aliceSharedKey &amp;lt;- kemDecryptSharedKey decryptCtx salt encapsulatedKey sharedKeyLength&#xA;bobSharedKey == aliceSharedKey&#xA;-- True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Then, this shared key may be used for any suitable purpose.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;!--  &lt;details&gt;&lt;summary&gt;Botan.Low.PwdHash&lt;/summary&gt;&#xA;&#xA;&lt;/details&gt; --&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.RNG&lt;/summary&gt; &#xA; &lt;p&gt;A &lt;code&gt;random number generator&lt;/code&gt; is used to generate uniform samples of pseudorandom bytes.&lt;/p&gt; &#xA; &lt;p&gt;You can always use the system &lt;code&gt;RNG&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.RNG&#xA;randomBytes &amp;lt;- systemRNGGet 16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Unless you need a specific &lt;code&gt;RNG&lt;/code&gt;, it is strongly recommended that you use the autoseeded &lt;code&gt;user&lt;/code&gt; RNG.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.RNG&#xA;rng &amp;lt;- rngInit &#34;user&#34;&#xA;randomBytes &amp;lt;- rngGet rng 16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You can reseed a generator using the system generator:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;rngReseed rng 64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You can also reseed a generator using a specific generator:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;systemRNG &amp;lt;- rngInit &#34;system&#34;&#xA;rngReseedFromRNG rng systemRNG 64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You can also seed it with your own entropy; this is safe and can never &lt;em&gt;decrease&lt;/em&gt; the amount of entropy in the generator.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;rngAddEntropy rng &#34;Fee fi fo fum!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.SRP6&lt;/summary&gt; &#xA; &lt;p&gt;On signup, the client generates a salt and verifier, and securely sends them to a server:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.SRP6&#xA;import Botan.Low.Hash&#xA;import Botan.Low.RNG&#xA;import Botan.Low.MAC&#xA;rng &amp;lt;- rngInit UserRNG&#xA;group = MODP_SRP_4096&#xA;hash = SHA512&#xA;identifier = &#34;alice&#34;&#xA;password = &#34;Fee fi fo fum!&#34;&#xA;salt &amp;lt;- rngGet rng 12&#xA;verifier &amp;lt;- srp6GenerateVerifier identifier password salt group hash&#xA;-- signUpUserWithServer identifier verifier salt group hash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Later, on the server when the client request authentication, the server looks up the verfier, generates a server key (a SRP6 &#39;B&#39; value), and sends it back to the client:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- rng &amp;lt;- rngInit UserRNG&#xA;session &amp;lt;- srp6ServerSessionInit &#xA;-- (verifier, salt, group, hash) &amp;lt;- lookupUser identifier&#xA;serverKey &amp;lt;- srp6ServerSessionStep1 session verifier group hash rng&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Once the client receives the server key, it generates a client key (SRP6 &#39;A&#39; value) and the session key, and sends the client key to the server:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- serverKey &amp;lt;- didReceiveServerKey&#xA;(clientKey, clientSessionKey) &amp;lt;- srp6ClientAgree identifier password group hash salt serverKey rng&#xA;-- sendClientKey clientKey&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The server then receives client key, and generates a matching session key:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- clientKey &amp;lt;- didReceiveClientKey&#xA;serverSessionKey &amp;lt;- srp6ServerSessionStep2 session clientKey&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;At this point, clientSessionKey and serverSessionKey should be equal, but this should be confirmed by exchanging a hash digest to check for integrity, using the exchange&#39;s session key, identifier, salt, and client and server keys.&lt;/p&gt; &#xA; &lt;p&gt;There are many ways to do this, but preferrably, an (h)mac digest should be used to also include authentication and avoid impersonation.&lt;/p&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;NOTE: Both sides could calculate &#39;identifier &amp;lt;&amp;gt; salt &amp;lt;&amp;gt; serverKey &amp;lt;&amp;gt; clientKey&#39; individually but then we need to prove that each side has calculated it without relying on the copy received for validation, so we do this song and dance:&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;The client should first calculate and send the HMAC auth, using identifier + salt + clientKey:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mac &amp;lt;- macInit (hmac SHA3)&#xA;macSetKey mac clientSessionKey&#xA;macUpdate mac $ identifier &amp;lt;&amp;gt; salt &amp;lt;&amp;gt; clientKey&#xA;clientAuth &amp;lt;- macFinal mac&#xA;-- sendClientAuth clientAuth&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The server should then verify the client auth, and send its own HMAC auth back to the client using serverKey + clientAuth:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- clientAuth &amp;lt;- didReceiveClientAuth&#xA;mac &amp;lt;- macInit (hmac SHA3)&#xA;macSetKey mac serverSessionKey&#xA;macUpdate mac $ identifier &amp;lt;&amp;gt; salt &amp;lt;&amp;gt; clientKey&#xA;verifiedClientAuth &amp;lt;- macFinal mac&#xA;-- clientAuth == verifiedClientAuth&#xA;macClear mac&#xA;macSetKey mac serverSessionKey&#xA;macUpdate mac $ serverKey &amp;lt;&amp;gt; clientAuth&#xA;serverAuth &amp;lt;- macFinal mac&#xA;-- sendServerAuth serverAuth&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The client then receives the server HMAC auth, and validates it&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- serverAuth &amp;lt;- didReceiveServerAuth&#xA;macClear mac&#xA;macSetKey mac clientSessionKey&#xA;macUpdate mac $ serverKey &amp;lt;&amp;gt; clientAuth&#xA;verifiedServerAuth &amp;lt;- macFinal mac&#xA;-- serverAuth == verifiedServerAuth&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;After this, the shared session key may be safely used.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.TOTP&lt;/summary&gt; &#xA; &lt;p&gt;To use TOTP for MFA / 2FA, the client authenticator must generate a client-specific shared secret, and securely communicate it to the server authenticator.&lt;/p&gt; &#xA; &lt;p&gt;The secret key may be any bytestring value with more than 160 bits, such as a Bcrypt digest or SRP6 shared key.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Botan.Low.TOTP&#xA;import Botan.Low.RNG&#xA;import Data.Time.Clock.POSIX&#xA;timestep = 30&#xA;drift = 3&#xA;sharedSecret &amp;lt;- systemRNGGet 16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The client and server authenticators are now in a shared state, and any login attempts from a new device may be authenticated using TOTP as MFA.&lt;/p&gt; &#xA; &lt;p&gt;A client has requested a new connection, and TOTP is being used as MFA/2FA to authenticate their request. The server authenticator receives the client connection request and initializes a TOTP session using the stored client-specific shared secret, and then sends an authentication request to the client authenticator:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- serverSharedSecret &amp;lt;- lookupServerSharedSecret&#xA;serverSession &amp;lt;- totpInit serverSharedSecret TOTP_SHA512 8 timestep&#xA;-- sendMFAAuthenticationRequest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;NOTE: We are using a timestep value of 30 seconds, which means that the code will refresh every 30 seconds&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;The client authenticator receives the authentication request, generates a client-side code using their timestamp, and displays the TOTP code to the user:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- clientSharedSecret &amp;lt;- lookupClientSharedSecret&#xA;clientSession &amp;lt;- totpInit clientSharedSecret TOTP_SHA512 8 timestep&#xA;(clientTimestamp :: TOTPTimestamp) &amp;lt;- round &amp;lt;$&amp;gt; getPOSIXTime&#xA;clientCode &amp;lt;- totpGenerate clientSession clientTimestamp&#xA;-- displayClientCode clientCode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The client then sends the client code to the server authenticator using the unauthenticated / requested connection:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- clientCode &amp;lt;- readClientCode&#xA;-- sendMFAAuthenticationResponse clientCode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The server authenticator receives the authentication response, and performs a check of the key, with an acceptable clock drift in steps, in case the client and server are slightly desynchronized.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- serverClientCode &amp;lt;- didreceiveMFAAuthenticationResponse&#xA;(serverTimestamp :: TOTPTimestamp) &amp;lt;- round &amp;lt;$&amp;gt; getPOSIXTime&#xA;isValid &amp;lt;- totpCheck serverSession serverClientCode serverTimestamp drift&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;NOTE: We are using a acceptable clock drift value of 3, which means that the codes for the previous 3 time steps are still valid.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;If the code is valid, then the signin may be completed on the new connection as normal.&lt;/p&gt; &#xA; &lt;p&gt;The server should discontinue the session and refuse any new connections to the account after multiple unsuccessful authentication attempts. The user should then be notified.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;!-- &lt;details&gt;&lt;summary&gt;Botan.Low.X509&lt;/summary&gt;&#xA;&#xA;&lt;/details&gt; --&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Botan.Low.ZFEC&lt;/summary&gt; &#xA; &lt;p&gt;Forward error correction takes an input and creates multiple “shares”, such that any K of N shares is sufficient to recover the entire original input.&lt;/p&gt; &#xA; &lt;p&gt;First, we choose a K value appropriate to our message - the higher K is, the smaller (but more numerous) the resulting shares will be:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;k = 7&#xA;message = &#34;The length of this message must be divisible by K&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;NOTE: ZFEC requires that the input length be exactly divisible by K; if needed define a padding scheme to pad your input to the necessary size.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;We can calculate N = K + R, where R is the number of redundant shares, meaning we can tolerate the loss of up to R shares and still recover the original message.&lt;/p&gt; &#xA; &lt;p&gt;We want 2 additional shares of redundancy, so we set R and N appropriately:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;r = 2&#xA;n = k + r -- 7 + 2 = 9&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Then, we encode the message into N shares:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;shares &amp;lt;- zfecEncode k n message&#xA;length shares&#xA;-- 9&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Then, we can recover the message from any K of N shares:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;someShares &amp;lt;- take k &amp;lt;$&amp;gt; shuffle shares&#xA;recoveredMessage &amp;lt;- zfecDecode k n someShares&#xA;message == recoveredMessage&#xA;-- True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h1&gt;Enabling experimental support&lt;/h1&gt; &#xA;&lt;p&gt;Some features rely on an experimental fork of the Botan C++ library, which will be contributed back upstream to Botan C++ when it is stable.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Build with experimental features&lt;/summary&gt; &#xA; &lt;ol&gt; &#xA;  &lt;li&gt;Clone the experimental &lt;a href=&#34;https://github.com/apotheca/botan-upstream&#34;&gt;fork&lt;/a&gt;&lt;/li&gt; &#xA; &lt;/ol&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/apotheca/botan-upstream $BOTAN_CPP&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;ol start=&#34;2&#34;&gt; &#xA;  &lt;li&gt;Build and install the experimental fork as &lt;a href=&#34;https://raw.githubusercontent.com/haskell-cryptography/botan/main/#From-source&#34;&gt;from source&lt;/a&gt;. You may wish to install to a non-standard location using &lt;code&gt;--prefix&lt;/code&gt; during configuration, to avoid overwriting any pre-existing install.&lt;/li&gt; &#xA; &lt;/ol&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd $BOTAN_CPP&#xA;./configure.py --prefix=$BOTAN_OUT&#xA;make&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;ol start=&#34;3&#34;&gt; &#xA;  &lt;li&gt;Use the &lt;code&gt;XFFI&lt;/code&gt; flag to enable the experimental FFI modules. If you installed the experimental fork to a non-standard location, you may also need to specify where using &lt;code&gt;--extra-include-dirs&lt;/code&gt; and &lt;code&gt;--extra-lib-dirs&lt;/code&gt; flags.&lt;/li&gt; &#xA; &lt;/ol&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd $BOTAN_HASKELL&#xA;cabal build TARGET -fXFFI --extra-include-dirs $BOTAN_OUT/include --extra-lib-dirs $BOTAN_OUT/lib&#xA;# or&#xA;stack build TARGET --flag XFFI --extra-include-dirs $BOTAN_OUT/include --extra-lib-dirs $BOTAN_OUT/lib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To check that you&#39;ve done everything correctly, you can run the following:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;import Botan.Bindings.Version &#xA;import Foreign.C.String&#xA;import Prelude&#xA;botan_version_string &amp;gt;&amp;gt;= peekCString&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The version will say &lt;code&gt;unreleased&lt;/code&gt; if it is properly pointing to our built Botan.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h1&gt;Resources&lt;/h1&gt; &#xA;&lt;p&gt;There are several resources for this project that might be helpful:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://discourse.haskell.org/t/botan-bindings-devlog/6855?u=apothecalabs&#34;&gt;Devlog&lt;/a&gt;&lt;/strong&gt; for project status and updates.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/haskellfoundation/botan&#34;&gt;GitHub&lt;/a&gt;&lt;/strong&gt; for Haskell source code, issues, and pull requests.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/apotheca/botan-upstream&#34;&gt;Upstream C++ Github&lt;/a&gt;&lt;/strong&gt; experimental fork of Botan C++&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/haskellfoundation/tech-proposals/pull/57&#34;&gt;Proposal&lt;/a&gt;&lt;/strong&gt; Haskell Foundation funding proposal submission thread.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As well, there are resources for the original Botan C++ library:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://botan.randombit.net/&#34;&gt;Botan&lt;/a&gt;&lt;/strong&gt; Crypto and TLS for Modern C++&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/randombit/botan/&#34;&gt;Botan C++ Github&lt;/a&gt;&lt;/strong&gt; for original Botan C++ source code, issues, and pull requests.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://botan.randombit.net/handbook/&#34;&gt;Botan Handbook&lt;/a&gt;&lt;/strong&gt; for documentation on the original library&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://botan.randombit.net/handbook/api_ref/ffi.html&#34;&gt;Botan FFI&lt;/a&gt;&lt;/strong&gt; for documentation on the Botan C FFI&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/randombit/botan/issues/3627&#34;&gt;Issue&lt;/a&gt;&lt;/strong&gt; FFI APIs for X.509 are insufficient&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;This project is licensed under the &lt;a href=&#34;https://github.com/haskellfoundation/botan/raw/main/LICENSE&#34;&gt;BSD 3-Clause License&lt;/a&gt; and is free, open-source software.&lt;/p&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;There are several ways to contribute to the development of this project, and we are happy to receive any bug reports, fixes, documentation, and any other improvements to this project.&lt;/p&gt; &#xA;&lt;h2&gt;Reporting Bugs&lt;/h2&gt; &#xA;&lt;p&gt;See a bug?&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Describe the issue&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Write down the steps required to reproduce the issue&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Report the issue by &lt;a href=&#34;https://github.com/haskellfoundation/botan/issues/new&#34;&gt;opening a ticket!&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Assist in Development&lt;/h2&gt; &#xA;&lt;p&gt;Want to help?&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork or clone the repo, and create a new branch:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git checkout https://github.com/haskellfoundation/botan -b some_new_branch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Make your changes, and test them&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Submit a pull request with a comprehensive description of the changes&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;!-- # Contributors --&gt; &#xA;&lt;!-- TODO: Acknowlege code contributors --&gt; &#xA;&lt;!-- TODO: Adding a CONTRIBUTING file: https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/setting-guidelines-for-repository-contributors --&gt; &#xA;&lt;h1&gt;Donations&lt;/h1&gt; &#xA;&lt;p&gt;This is free, open-source software. If you&#39;d like to support the continued development of this project and future projects like this, or just to say thanks, you can donate directly using the following link(s):&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ko-fi.com/V7V1S5JTG&#34;&gt;&lt;img src=&#34;https://ko-fi.com/img/githubbutton_sm.svg?sanitize=true&#34; alt=&#34;ko-fi&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>