<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-09-07T01:30:32Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>MercuryTechnologies/moat</title>
    <updated>2024-09-07T01:30:32Z</updated>
    <id>tag:github.com,2024-09-07:/MercuryTechnologies/moat</id>
    <link href="https://github.com/MercuryTechnologies/moat" rel="alternate"></link>
    <summary type="html">&lt;p&gt;mobile type (currently Swift, Kotlin) generation from Haskell types&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;moat&lt;/h1&gt; &#xA;&lt;h2&gt;Given Haskell Types Generate Equivalents in Your Frontend Language&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- This extension generates Haskell code &#xA;{-# LANGUAGE TemplateHaskell #-}&#xA;-- These extensions for the generated code to compile&#xA;{-# LANGUAGE ScopedTypeVariables, DataKinds #-}&#xA;&#xA;import Moat (mobileGen)&#xA;&#xA;data User =&#xA;  User &#xA;    { firstName :: String&#xA;    , lastName :: String&#xA;    , age :: Int&#xA;    }&#xA;&#xA;$(mobileGen &#39;&#39;User)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function &lt;code&gt;mobileGen&lt;/code&gt; will build two instances for you: &lt;code&gt;ToMoatType&lt;/code&gt; and &lt;code&gt;ToMoatData&lt;/code&gt;. Using these instance we can generate code for your favorite language!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE TypeApplications #-}&#xA;&#xA;import Moat (prettySwiftData)&#xA;import Data.Proxy (Proxy (..))&#xA;&#xA;generatedSwiftCode :: String&#xA;generatedSwiftCode = prettySwiftData . toMoatData $ Proxy @User&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Would generate the following Swift code&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct User {&#xA;    let firstName: String&#xA;    let lastName: String&#xA;    let age: Int&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;At Mercury, we want a single source of truth for all the types in our applications. Haskell has a very strong type system and therefore we choose this as our source of truth. Most programming languages have libraries or built-ins to deserialize JSON, e.g. &lt;code&gt;Parcelize&lt;/code&gt; in Android (Kotlin) and &lt;code&gt;Codable&lt;/code&gt; in Swift, which we use as our interchange format. This allows us to automatically convert our Haskell types to the frontend equivalents and be sure everyone is on the same page.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/MercuryTechnologies/moat/master/diagrams/moat-use-case.png&#34; alt=&#34;Why use moat?&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here is a more practical Swift example that uses &lt;code&gt;Codable&lt;/code&gt; to decode JSON blobs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Moat (mobileGenWith, defaultOptions, Options (..))&#xA;&#xA;$(mobileGenWith defaultOptions {dataProtocols = [Codable]} &#39;&#39;User)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which will generate the following Swift code,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct User: Codable {&#xA;    let firstName: String&#xA;    let lastName: String&#xA;    let age: Int&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Android, one can use the &lt;code&gt;kotlin-parcelize&lt;/code&gt; package (using &lt;code&gt;prettyKotlinData&lt;/code&gt;), i.e.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Moat (mobileGenWith, defaultOptions, Options (..))&#xA;&#xA;$(mobileGenWith defaultOptions {dataInterfaces = [Parcelable], dataAnnotations = [Parcelize]} &#39;&#39;User)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Parcelize&#xA;data class User(&#xA;    val firstName: String,&#xA;    val lastName: String,&#xA;    val age: Int,&#xA;) : Parcelable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;We use &lt;a href=&#34;https://garnix.io&#34;&gt;garnix&lt;/a&gt; to cache development shells. You can get directions for pulling from that cache via &lt;a href=&#34;https://garnix.io/docs/caching&#34;&gt;their docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Why Template Haskell&lt;/h3&gt; &#xA;&lt;p&gt;Template Haskell is already prevalent in our Haskell codebase. It would increase our compile times drastically to additionally use &lt;code&gt;Generic&lt;/code&gt; to derive AST for each of our Haskell types.&lt;/p&gt; &#xA;&lt;h2&gt;Useful tidbits&lt;/h2&gt; &#xA;&lt;p&gt;To see the TH AST for a given type&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:set -XTemplateHaskell&#xA;$(stringE . show =&amp;lt;&amp;lt; reifyDatatype &#39;&#39;A)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;&#39;&#39;A&lt;/code&gt; takes a type constructor &lt;code&gt;A&lt;/code&gt; and converts it to a &lt;code&gt;Name&lt;/code&gt;. We then bind from the &lt;code&gt;Q&lt;/code&gt; monad to generate a string expression via &lt;code&gt;stringE&lt;/code&gt; and &lt;code&gt;show&lt;/code&gt; it&lt;/p&gt;</summary>
  </entry>
</feed>