<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-11T01:37:08Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Liqwid-Labs/liqwid-libs</title>
    <updated>2023-01-11T01:37:08Z</updated>
    <id>tag:github.com,2023-01-11:/Liqwid-Labs/liqwid-libs</id>
    <link href="https://github.com/Liqwid-Labs/liqwid-libs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A monorepo for Liqwid Labs plutarch libraries.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;liqwid-libs&lt;/h1&gt; &#xA;&lt;p&gt;A monorepo for Liqwid Labs plutarch libraries.&lt;/p&gt; &#xA;&lt;p&gt;Public discussion and assistance can be found on &lt;a href=&#34;https://discord.gg/yGkjxrYueB&#34;&gt;discord&lt;/a&gt; @ #liqwid-libs. Issues and project-management-related information are tracked on &lt;a href=&#34;https://www.notion.so/liqwid/&#34;&gt;Notion&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Library&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Liqwid-Labs/liqwid-libs/main/liqwid-plutarch-extra&#34;&gt;liqwid-plutarch-extra&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Collection of Plutarch types, typeclasses, helpers, and utilities shared between projects.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Liqwid-Labs/liqwid-libs/main/liqwid-script-export&#34;&gt;liqwid-script-export&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Export scripts for off-chain consumption through a HTTP server.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Liqwid-Labs/liqwid-libs/main/plutarch-quickcheck&#34;&gt;plutarch-quickcheck&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Helper library to write Plutarch-oriented QuickCheck property tests.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Liqwid-Labs/liqwid-libs/main/plutarch-context-builder&#34;&gt;plutarch-context-builder&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Helpful builders for &lt;code&gt;ScriptContext&lt;/code&gt;s.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Liqwid-Labs/liqwid-libs/main/plutarch-benchmark&#34;&gt;plutarch-benchmark&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Library to compare algorithm implementations of Plutarch code.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Liqwid-Labs/liqwid-libs/main/plutarch-unit&#34;&gt;plutarch-unit&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Library to write Plutarch-oriented unit tests using &lt;code&gt;tasty&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Organization&lt;/h2&gt; &#xA;&lt;p&gt;Please read the README of the library you are trying to use. Versioning and changelogs are kept on a per-library basis.&lt;/p&gt; &#xA;&lt;h2&gt;Importing using &lt;code&gt;liqwid-nix&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;When importing these libraries using &lt;a href=&#34;https://github.com/Liqwid-Labs/liqwid-nix&#34;&gt;&lt;code&gt;liqwid-nix&lt;/code&gt;&lt;/a&gt;, you can use &lt;code&gt;extraHackageDeps&lt;/code&gt; to specify which packages to include:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;&#34;${inputs.liqwid-libs}/plutarch-quickcheck&#34;&#xA;&#34;${inputs.liqwid-libs}/plutarch-context-builder&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will include plutarch-quickcheck and plutarch-context-builder and make them available to cabal.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>JakobBruenker/monadic-bang</title>
    <updated>2023-01-11T01:37:08Z</updated>
    <id>tag:github.com,2023-01-11:/JakobBruenker/monadic-bang</id>
    <link href="https://github.com/JakobBruenker/monadic-bang" rel="alternate"></link>
    <summary type="html">&lt;p&gt;GHC plugin to desugar ! into do-notation&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Monadic Bang&lt;/h1&gt; &#xA;&lt;p&gt;This is a GHC Parser plugin for GHC 9.4 and above, intended to make monadic code within &lt;code&gt;do&lt;/code&gt;-blocks more concise and nicer to work with. Works with HLS.&lt;/p&gt; &#xA;&lt;p&gt;This is heavily inspired by &lt;a href=&#34;https://idris2.readthedocs.io/en/latest/tutorial/interfaces.html#notation&#34;&gt;Idris&#39;s !-notation&lt;/a&gt;, but with some &lt;a href=&#34;https://raw.githubusercontent.com/JakobBruenker/monadic-bang/main/#comparison-with-idriss--notation&#34;&gt;important differences&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contents&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JakobBruenker/monadic-bang/main/#motivating-examples&#34;&gt;Motivating Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JakobBruenker/monadic-bang/main/#usage&#34;&gt;Usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JakobBruenker/monadic-bang/main/#cute-things&#34;&gt;Cute Things&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JakobBruenker/monadic-bang/main/#caveats&#34;&gt;Caveats&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JakobBruenker/monadic-bang/main/#details&#34;&gt;Details&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/JakobBruenker/monadic-bang/main/#comparison-with-idriss--notation&#34;&gt;Comparison with Idris&#39;s &lt;code&gt;!&lt;/code&gt;-notation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Motivating Examples&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s look at a few examples where Haskell syntax can be a bit annoying when it comes to monads - and what this plugin allows you to write instead:&lt;/p&gt; &#xA;&lt;p&gt;When you use &lt;code&gt;Reader&lt;/code&gt; or &lt;code&gt;State&lt;/code&gt;, you will often have to use &lt;code&gt;&amp;lt;-&lt;/code&gt; to bind fairly simple expressions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;launchMissile :: StateT Int IO ()&#xA;launchMissile = do&#xA;  count &amp;lt;- get&#xA;  liftIO . putStrLn $ &#34;Missile no. &#34; &amp;lt;&amp;gt; show count &amp;lt;&amp;gt; &#34; has been launched&#34;&#xA;  modify&#39; (+ 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;help :: Reader Config String&#xA;help = do&#xA;  manualLink &amp;lt;- asks (.links.manual)&#xA;  email &amp;lt;- asks (.contact.email)&#xA;  pure $&#xA;    &#34;You can find help by going to &#34; &amp;lt;&amp;gt; manualLink &amp;lt;&amp;gt;&#xA;    &#34; or writing us at &#34; &amp;lt;&amp;gt; email&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With Monadic Bang, you can instead write&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;launchMissile :: StateT Int IO ()&#xA;launchMissile = do&#xA;  liftIO . putStrLn $ &#34;Missile no. &#34; &amp;lt;&amp;gt; show !get &amp;lt;&amp;gt; &#34; has been launched&#34;&#xA;  modify&#39; (+ 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;help :: Reader Config String&#xA;help = do&#xA;  pure $&#xA;    &#34;You can find help by going to &#34; &amp;lt;&amp;gt; (!ask).links.manual &amp;lt;&amp;gt;&#xA;    &#34; or writing us at &#34; &amp;lt;&amp;gt; (!ask).contact.email&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With &lt;code&gt;IORefs&lt;/code&gt;, &lt;code&gt;STRefs&lt;/code&gt;, mutable arrays, and so on, you&#39;ll often have to write code that looks like this, having to use somewhat redundant variable names:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;addIORefs :: IORef Int -&amp;gt; IORef Int -&amp;gt; IO Int&#xA;addIORefs aRef bRef = do&#xA;  a &amp;lt;- readIORef aRef&#xA;  b &amp;lt;- readIORef bRef&#xA;  pure $ a + b&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With Monadic Bang, you can write&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;addIORefs :: IORef Int -&amp;gt; IORef Int -&amp;gt; IO Int&#xA;addIORefs a b = do pure $ !(readIORef a) + !(readIORef b)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Implicit parameter definitions have somewhat more limited syntax than regular definitions: You can&#39;t write something like &lt;code&gt;?foo &amp;lt;- action&lt;/code&gt;.&lt;br&gt; That lead me to have to write this in a Vulkan program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;initQueues = do&#xA;  let getQueue = getDeviceQueue ?device&#xA;  graphicsQueue &amp;lt;- getQueue ?graphicsQueueFamily 0&#xA;  presentQueue  &amp;lt;- getQueue ?presentQueueFamily  0&#xA;  computeQueue  &amp;lt;- getQueue ?computeQueueFamily  1&#xA;  let ?graphicsQueue = graphicsQueue&#xA;      ?presentQueue  = presentQueue&#xA;      ?computeQueue  = computeQueue&#xA;  pure Dict&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;with Monadic Bang, I can write&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;initQueues = do&#xA;  let getQueue = getDeviceQueue ?device&#xA;  let ?graphicsQueue = !(getQueue ?graphicsQueueFamily 0)&#xA;      ?presentQueue  = !(getQueue ?presentQueueFamily  0)&#xA;      ?computeQueue  = !(getQueue ?computeQueueFamily  1)&#xA;  pure Dict&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Take this (slightly adapted) code used for the test suite of this very plugin:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;settings :: MonadIO m =&amp;gt; m Settings&#xA;settings = ... -- some long function body&#xA;&#xA;initialDynFlags :: MonadIO m =&amp;gt; m DynFlags&#xA;initialDynFlags = do&#xA;  settings&#39; &amp;lt;- settings&#xA;  dflags &amp;lt;- defaultDynFlags settings&#39; llvmConfig&#xA;  pure $ dflags{generalFlags = addCompileFlags $ generalFlags dflags}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With this plugin, I can instead write&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;settings :: MonadIO m =&amp;gt; m Settings&#xA;settings = ... -- some long function body&#xA;&#xA;initialDynFlags :: MonadIO m =&amp;gt; m DynFlags&#xA;initialDynFlags = do&#xA;  dflags &amp;lt;- defaultDynFlags !settings llvmConfig&#xA;  pure $ dflags{generalFlags = addCompileFlags $ generalFlags dflags}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, to take some more code from this plugin&#39;s implementation&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;do logger &amp;lt;- getLogger&#xA;   liftIO $ logMsg logger MCInfo (UnhelpfulSpan UnhelpfulNoLocationInfo) m&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Why have &lt;code&gt;logger&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;getLogger&lt;/code&gt; when you can instead write&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;do liftIO $ logMsg !getLogger MCInfo (UnhelpfulSpan UnhelpfulNoLocationInfo) m&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The pattern you might have noticed here is that this plugin is convenient whenever you have a &lt;code&gt;do&lt;/code&gt;-block with a &lt;code&gt;&amp;lt;-&lt;/code&gt; that doesn&#39;t do pattern matching, whose bound variable is only used once, and has a short right-hand side. While that might sound like a lot of qualifiers, it does occur fairly often in practice.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;To use this plugin, you have to add &lt;code&gt;monadic-bang&lt;/code&gt; to the &lt;code&gt;build-depends&lt;/code&gt; stanza in your &lt;code&gt;.cabal&lt;/code&gt; file. Then you can either add &lt;code&gt;-fplugin=MonadicBang&lt;/code&gt; to the &lt;code&gt;ghc-options&lt;/code&gt; stanza, or add&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# OPTIONS_GHC -fplugin=MonadicBang #-}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to the top of the files you want to use it in.&lt;/p&gt; &#xA;&lt;p&gt;This should also allow HLS to pick up on the plugin, as long as you use HLS 1.9.0.0 or above.&lt;/p&gt; &#xA;&lt;p&gt;The plugin supports a couple of options, which you can provide via invocations of &lt;code&gt;-fplugin-opt=MonadicBang:&amp;lt;option&amp;gt;&lt;/code&gt;. The options are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-ddump&lt;/code&gt;: Print the altered AST&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-preserve-errors&lt;/code&gt;: Keep parse errors about &lt;code&gt;!&lt;/code&gt; outside of &lt;code&gt;do&lt;/code&gt; in their original form, rather then a more relevant explanation. This is mainly useful if another plugin expects those errors.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Cute Things&lt;/h2&gt; &#xA;&lt;h3&gt;Idiom Brackets Alternative&lt;/h3&gt; &#xA;&lt;p&gt;In some cases where idiom brackets would be ideal, &lt;code&gt;!&lt;/code&gt; can be a reasonable alternative. For example, compare these four options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;1. liftA2 (&amp;amp;&amp;amp;) (readIORef useMetric) (readIORef useCelsius)&#xA;2. (&amp;amp;&amp;amp;) &amp;lt;$&amp;gt; readIORef useMetric &amp;lt;*&amp;gt; readIORef useCelsius&#xA;   -- hypothetical idiom brackets:&#xA;3. [| readIORef useMetric &amp;amp;&amp;amp; readIORef useCelsius |]&#xA;   -- Monadic Bang:&#xA;4. do pure (!(readIORef useMetric) &amp;amp;&amp;amp; !(readIORef useCelsius))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;while &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; are probably better here for prefix functions, &lt;code&gt;!&lt;/code&gt; plays nicer with infix operators.&lt;/p&gt; &#xA;&lt;p&gt;If you have &lt;code&gt;-XApplicativeDo&lt;/code&gt; enabled, this even works with &lt;code&gt;Applicative&lt;/code&gt; instances.&lt;/p&gt; &#xA;&lt;h3&gt;Nested &lt;code&gt;!&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;!&lt;/code&gt; can easily be nested. E.g. you could have&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;do putStrLn !(readFile (!getArgs !! 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For how this is desugared, see &lt;a href=&#34;https://raw.githubusercontent.com/JakobBruenker/monadic-bang/main/#desugaring&#34;&gt;Desugaring&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Using &lt;code&gt;-XQualifiedDo&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;!&lt;/code&gt; always has to be used inside a &lt;code&gt;do&lt;/code&gt;-block, but it &lt;em&gt;can&lt;/em&gt; be a qualified &lt;code&gt;do&lt;/code&gt;-block. For example, if you use &lt;code&gt;-XLinearTypes&lt;/code&gt;, you could write things like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE QualifiedDo, BlockArguments, OverloadedStrings #-}&#xA;import Prelude.Linear&#xA;import Control.Functor.Linear as Linear&#xA;import System.IO.Resource.Linear&#xA;&#xA;main :: IO ()&#xA;main = run Linear.do&#xA;  Linear.pure !(move Linear.&amp;lt;$&amp;gt; hClose !(hPutStrLn !(openFile &#34;tmp&#34; WriteMode) &#34;foo&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which would be desugared as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Haskell&#34;&gt;main :: IO ()&#xA;main = run Linear.do&#xA;  a &amp;lt;- openFile &#34;tmp&#34; WriteMode&#xA;  b &amp;lt;- hPutStrLn a &#34;foo&#34;&#xA;  c &amp;lt;- move Linear.&amp;lt;$&amp;gt; hClose b&#xA;  Linear.pure c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;List comprehensions&lt;/h3&gt; &#xA;&lt;p&gt;List comprehensions are kind of just special &lt;code&gt;do&lt;/code&gt;-blocks, so &lt;code&gt;!&lt;/code&gt; can be used here as well (and also in monad comprehensions). Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[ x + ![1, 2, 3] | x &amp;lt;- [60, 70, ![800, 900]] ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This would be equivalent to&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[ x + b | a &amp;lt;- [800, 900], x &amp;lt;- [60, 70, a], b &amp;lt;- [1, 2, 3]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reason &lt;code&gt;b &amp;lt;- ...&lt;/code&gt; is at the end here instead of the beginning is that everything that appears to the left of the &lt;code&gt;|&lt;/code&gt; in a list comprehension is essentially comparable to the last statement of a &lt;code&gt;do&lt;/code&gt;-block (+ &lt;code&gt;pure&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Get Rid of &lt;code&gt;&amp;lt;-&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;In principle, every instance of &lt;code&gt;pattern &amp;lt;- action&lt;/code&gt; in a &lt;code&gt;do&lt;/code&gt;-block could be replaced by &lt;code&gt;let pattern = !action&lt;/code&gt;. Should they? That&#39;s a separate question, though it could be a viable style.&lt;/p&gt; &#xA;&lt;p&gt;The implicit parameter example in the first section is a valid use case of this.&lt;/p&gt; &#xA;&lt;h3&gt;Monadic Variants&lt;/h3&gt; &#xA;&lt;p&gt;Oftentimes, some generic function exists, but then it turns out that a monadic variant of said function would be useful as well. For example, hoogle finds at least a dozen different packages offering &lt;code&gt;whenM&lt;/code&gt;. With this plugin, you can instead write&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;main = do&#xA;  when (null !getArgs) $ print usage&#xA;  ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;⚠️ NB: This would not work for e.g. &lt;code&gt;whileM&lt;/code&gt;. In implementations of &lt;code&gt;whileM&lt;/code&gt;, the condition is re-evaluated after every iteration. If you wrote e.g. &lt;code&gt;while (!(readIORef i) &amp;gt; 0)&lt;/code&gt;, it would only be evaluated once, before the first iteration.&lt;/p&gt; &#xA;&lt;h2&gt;Caveats&lt;/h2&gt; &#xA;&lt;p&gt;There are a few disadvantages to using this that are worth mentioning:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Since the plugin modifies the source code, the location info in error messages might look a bit strange, since it contains the desugared version. This shouldn&#39;t be an issue if you use HLS or another tool to highlight errors within your editor.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;HLint currently does not work with this plugin (HLint will show you a parse error if you try to use &lt;code&gt;!&lt;/code&gt;.)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If there are fatal parse errors in the source code, unfortunately each &lt;code&gt;!&lt;/code&gt; will also be highlighted as a parse error. This is unavoidable at the moment, since the plugin can only intercept those messages if the module is otherwise successfully parsed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Plugins like this cannot affect GHCi&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Arguably this makes &lt;code&gt;do&lt;/code&gt;-desugaring slightly more confusing - e.g., compare the following:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;do put 4&#xA;   put 5 &amp;gt;&amp;gt; print !get&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;do put 4&#xA;   put 5&#xA;   print !get&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;With the usual desugaring rules, whether you use &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; or a new line shouldn&#39;t make a difference, but here, the first snippet will print &lt;code&gt;4&lt;/code&gt;, while the second snippet will print &lt;code&gt;5&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Details&lt;/h2&gt; &#xA;&lt;p&gt;While the above information should cover most use cases, there are some details that could sometimes be relevant&lt;/p&gt; &#xA;&lt;h3&gt;Desugaring&lt;/h3&gt; &#xA;&lt;p&gt;The desugaring is essentially what one would expect from comparing the motivating examples with the versions using &lt;code&gt;!&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To illustrate with a fairly extensive example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;x = g do&#xA;  foo&#xA;  bar &amp;lt;- !a + !(!b ++ !c)&#xA;  baz &amp;lt;- case !d of&#xA;    (!f -&amp;gt; e) -&amp;gt; do !g e&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is desugared into&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;x = g do&#xA;  foo&#xA;  &amp;lt;!a&amp;gt; &amp;lt;- a&#xA;  &amp;lt;!b&amp;gt; &amp;lt;- b&#xA;  &amp;lt;!c&amp;gt; &amp;lt;- c&#xA;  &amp;lt;!(!b ++ !c)&amp;gt; &amp;lt;- &amp;lt;!b&amp;gt; ++ &amp;lt;!c&amp;gt;&#xA;  bar &amp;lt;- &amp;lt;!a&amp;gt; + &amp;lt;!(!b ++ !c)&amp;gt;&#xA;  &amp;lt;!d&amp;gt; &amp;lt;- d&#xA;  &amp;lt;!f&amp;gt; &amp;lt;- f&#xA;  baz &amp;lt;- case &amp;lt;!d&amp;gt; of&#xA;    (&amp;lt;!f&amp;gt; -&amp;gt; e) -&amp;gt; do&#xA;      &amp;lt;!g&amp;gt; &amp;lt;- g&#xA;      &amp;lt;!g&amp;gt; e&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &lt;code&gt;&amp;lt;!a&amp;gt;&lt;/code&gt; etc. are simply special variable names.&lt;/p&gt; &#xA;&lt;p&gt;So, broadly speaking, the order in which things are bound is top-to-bottom (statement-wise), inside-out, and left-to-right.&lt;/p&gt; &#xA;&lt;p&gt;This can be important when the order of effects matters - though if order does matter, &lt;code&gt;!&lt;/code&gt; might not be the clearest way to express things.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;!&lt;/code&gt; will only bubble up to the nearest &lt;code&gt;do&lt;/code&gt;-block. To illustrate:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;x = do when nuclearStrikeDetected $ log !launchMissiles&#xA;&#xA;y = do when nuclearStrikeDetected $ do log !launchMissiles&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;x&lt;/code&gt; will launch the missiles regardless of whether or not a strike has been detected. But it will only log the results in the case of detection. &lt;code&gt;y&lt;/code&gt; will only launch the missiles (and log the results) if a strike has been detected.&lt;/p&gt; &#xA;&lt;p&gt;The desugaring:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;x = do&#xA;  &amp;lt;!launchMissiles&amp;gt; &amp;lt;- launchMissiles&#xA;  when nuclearStrikeDetected $ log &amp;lt;!launchMissiles&amp;gt;&#xA;&#xA;y = do&#xA;  when nuclearStrikeDetected $ do&#xA;    &amp;lt;!launchMissiles&amp;gt; &amp;lt;- launchMissiles&#xA;    log &amp;lt;!launchMissiles&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The story for &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt; expressions is similar, &lt;code&gt;!&lt;/code&gt; in the individual branches will &lt;em&gt;all&lt;/em&gt; be executed unless the branches have their own &lt;code&gt;do&lt;/code&gt;-blocks.&lt;/p&gt; &#xA;&lt;h3&gt;Variable scope&lt;/h3&gt; &#xA;&lt;p&gt;A variable can be used inside a &lt;code&gt;!&lt;/code&gt; if&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;it was bound outside the current &lt;code&gt;do&lt;/code&gt;-block&lt;/li&gt; &#xA; &lt;li&gt;or it was bound before the statement the &lt;code&gt;!&lt;/code&gt; is in&lt;/li&gt; &#xA; &lt;li&gt;or it is bound inside the &lt;code&gt;!&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In other words, this is legal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;f x = do&#xA;  let a = a&#xA;  foo !(let b = b in x + a + b)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but this is not:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;c = do&#xA;  let a = a in foo !a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s because this would be desugared as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;c = do&#xA;  &amp;lt;!a&amp;gt; &amp;lt;- a&#xA;  let a = a in foo &amp;lt;!a&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but &lt;code&gt;a&lt;/code&gt; is not in scope in the second line.&lt;/p&gt; &#xA;&lt;h3&gt;Where it can be used&lt;/h3&gt; &#xA;&lt;p&gt;It can be used in any expression that is somewhere inside a &lt;code&gt;do&lt;/code&gt;-block. In particular, this includes for example &lt;code&gt;where&lt;/code&gt;-blocks in &lt;code&gt;case&lt;/code&gt;-expressions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;main = do&#xA;  putStrLn case !getLine of&#xA;    &#34;print args&#34; -&amp;gt; prettyArgs &#34;\n&#34;&#xA;      where prettyArgs sep = intercalate sep !getArgs&#xA;    &#34;greeting&#34; -&amp;gt; &#34;hello there!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and view patterns&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;do (extract !getSettings -&amp;gt; contents) &amp;lt;- readArchive&#xA;   print contents&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Comparison with Idris&#39;s &lt;code&gt;!&lt;/code&gt;-notation&lt;/h2&gt; &#xA;&lt;p&gt;The main difference is that Idris will insert a &lt;code&gt;do&lt;/code&gt; if there is none - e.g. this is legal in Idris:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;f : IO ()&#xA;f = putStrLn !getLine&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but (assuming it&#39;s at top-level) wouldn&#39;t be with this plugin; you would have to write &lt;code&gt;f = do putStrLn !getLine&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;p&gt;Some other differences:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;In Idris, &lt;code&gt;!&lt;/code&gt;&#39;d expressions cannot escape outside of a lambda expression (it effectively inserts a new &lt;code&gt;do&lt;/code&gt; at the beginning of the lambda body instead)&lt;/li&gt; &#xA; &lt;li&gt;The same difference applies to &lt;code&gt;let&lt;/code&gt; bindings that define functions&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>ArtixLabs/Ark</title>
    <updated>2023-01-11T01:37:08Z</updated>
    <id>tag:github.com,2023-01-11:/ArtixLabs/Ark</id>
    <link href="https://github.com/ArtixLabs/Ark" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt; &lt;a href=&#34;https://github.com/artixlabs/ark/releases/latest&#34;&gt; &lt;img alt=&#34;Latest release&#34; src=&#34;https://img.shields.io/github/v/release/artixlabs/ark?style=for-the-badge&amp;amp;logo=starship&amp;amp;color=C9CBFF&amp;amp;logoColor=D9E0EE&amp;amp;labelColor=302D41&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/artixlabs/ark/pulse&#34;&gt; &lt;img alt=&#34;Last commit&#34; src=&#34;https://img.shields.io/github/last-commit/artixlabs/ark?style=for-the-badge&amp;amp;logo=starship&amp;amp;color=8bd5ca&amp;amp;logoColor=D9E0EE&amp;amp;labelColor=302D41&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/artixlabs/ark/raw/master/LICENSE&#34;&gt; &lt;img alt=&#34;License&#34; src=&#34;https://img.shields.io/github/license/artixlabs/ark?style=for-the-badge&amp;amp;logo=starship&amp;amp;color=ee999f&amp;amp;logoColor=D9E0EE&amp;amp;labelColor=302D41&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/artixlabs/ark/stargazers&#34;&gt; &lt;img alt=&#34;Stars&#34; src=&#34;https://img.shields.io/github/stars/artixlabs/ark?style=for-the-badge&amp;amp;logo=starship&amp;amp;color=c69ff5&amp;amp;logoColor=D9E0EE&amp;amp;labelColor=302D41&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/artixlabs/ark/issues&#34;&gt; &lt;img alt=&#34;Issues&#34; src=&#34;https://img.shields.io/github/issues/artixlabs/ark?style=for-the-badge&amp;amp;logo=bilibili&amp;amp;color=F5E0DC&amp;amp;logoColor=D9E0EE&amp;amp;labelColor=302D41&#34;&gt; &lt;/a&gt; &lt;/p&gt;&#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Ark&lt;/h2&gt; &#xA;&lt;p&gt;Ark is a program that aims to provide an easy way to manage system themes. Ark can set themes for specific programs, or the whole system with only one command!&lt;/p&gt; &#xA;&lt;p&gt;Please note that Ark is currently in early development, and &lt;em&gt;&lt;strong&gt;there will be bugs&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ark --update # This fetches the updated themes.&#xA;$ ark --program=&amp;lt;program&amp;gt; --theme=&amp;lt;theme&amp;gt; # Sets the theme&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As mentioned earlier, Ark can also be run with a system flag, which sets every available theme.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ark -u # Same as --update&#xA;$ ark --system --theme=&amp;lt;theme&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;New contributors should submit a PR with a short description of their changes.&lt;/p&gt; &#xA;&lt;h2&gt;Todo&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Get more themes&lt;/li&gt; &#xA; &lt;li&gt;Add support for more programs&lt;/li&gt; &#xA; &lt;li&gt;Add documentation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;ark&lt;/strong&gt; was written by cobaltinferno&lt;/p&gt;</summary>
  </entry>
</feed>