<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-08T01:36:49Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>well-typed/memory-profiling-webinar</title>
    <updated>2022-12-08T01:36:49Z</updated>
    <id>tag:github.com,2022-12-08:/well-typed/memory-profiling-webinar</id>
    <link href="https://github.com/well-typed/memory-profiling-webinar" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Source code for the memory profiling webinar livestreamed at Dec 1, 2022&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Profiling Memory Usage With &lt;code&gt;eventlog2html&lt;/code&gt; and &lt;code&gt;ghc-debug&lt;/code&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;Abstract&lt;/h2&gt; &#xA;&lt;p&gt;Understanding and analysing the memory usage of Haskell programs is a notoriously difficult yet important problem. Recent improvements to GHC&#39;s profiling capabilities, along with better tooling, has made it much easier to deeply and precisely analyse the memory usage characteristics of even large Haskell programs.&lt;/p&gt; &#xA;&lt;p&gt;This workshop aims to present three such tools that allow high and low level memory usage analysis of Haskell programs: &lt;code&gt;eventlog2html&lt;/code&gt;, &lt;code&gt;nothunks&lt;/code&gt;, and &lt;code&gt;ghc-debug&lt;/code&gt;. We will learn how to set up and use &lt;code&gt;eventlog2html&lt;/code&gt; to generate high-level visuals and statistics of our program&#39;s execution. We will also learn how to set up and use &lt;code&gt;ghc-debug&lt;/code&gt; to precisely and programmatically explore our program&#39;s low-level memory usage profile.&lt;/p&gt; &#xA;&lt;p&gt;We will examine these tools by using them on several pre-prepared Haskell programs. The workshop aims to be beneficial to Haskell programmers of all levels. Beginner Haskell programmers can expect to gain a deeper understanding of lazy evaluation and the impacts it can have on program performance. Experienced Haskell programmers can expect to gain an understanding of exactly what these tools have to offer and the skills necessary to use these tools on their own Haskell programs.&lt;/p&gt; &#xA;&lt;h2&gt;Before The Workshop&lt;/h2&gt; &#xA;&lt;p&gt;Make sure you have the tools installed and built. You need to use GHC 9.2.4 or greater. After that, in the root of this repository, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal build all&#xA;cabal install eventlog2html&#xA;cabal install ghc-debug-brick&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And everything should be ready to go.&lt;/p&gt; &#xA;&lt;h2&gt;Workshop Outline&lt;/h2&gt; &#xA;&lt;h3&gt;Goal&lt;/h3&gt; &#xA;&lt;p&gt;The primary goal of this workshop is for participants to gain experience and familiarity with the &lt;code&gt;eventlog2html&lt;/code&gt; and &lt;code&gt;ghc-debug&lt;/code&gt; memory profiling tools, and to observe how these tools complement one another in their features and use cases.&lt;/p&gt; &#xA;&lt;h3&gt;Prerequisites: Lazy Evaluation, Normal Forms, etc.&lt;/h3&gt; &#xA;&lt;p&gt;A crucial step towards understanding the memory usage of Haskell programs is understanding Haskell&#39;s semantics as a lazy programming language. While thorough coverage of such semantics is outside the scope of this workshop, I do hope that much of what we cover will be approachable and enlightening to Haskell beginners and experts alike.&lt;/p&gt; &#xA;&lt;h3&gt;A First Look at &lt;code&gt;ghc-debug&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;ghc-debug&lt;/code&gt; style of debugging is, like Haskell, somewhat unique. In this style, we have a &lt;em&gt;debuggee&lt;/em&gt; and a &lt;em&gt;debugger&lt;/em&gt;. The debuggee is the application whose heap profile we would like to analyse. The debugger is the application which will actually execute the analysis.&lt;/p&gt; &#xA;&lt;p&gt;Communication between the debuggee and debugger happens over a socket, where the debuggee simply responds to requests sent by the debugger. Crucially, it is incredibly simple to turn a Haskell application into a debuggee for analysis using &lt;code&gt;ghc-debug&lt;/code&gt; debuggers, as we will see later.&lt;/p&gt; &#xA;&lt;p&gt;With the above in mind, we can introduce &lt;code&gt;ghc-debug&lt;/code&gt; as a set of libraries and tools:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/ghc-debug-stub&#34;&gt;&lt;code&gt;ghc-debug-stub&lt;/code&gt;&lt;/a&gt;: A library containing the functions you should include in your program to perform analysis with &lt;code&gt;ghc-debug&lt;/code&gt; debuggers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/ghc-debug-client&#34;&gt;&lt;code&gt;ghc-debug-client&lt;/code&gt;&lt;/a&gt;: A library containing useful functions for writing your own heap analysis scripts.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/ghc-debug-brick&#34;&gt;&lt;code&gt;ghc-debug-brick&lt;/code&gt;&lt;/a&gt;: An executable terminal user interface application that can connect to any debuggee.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These aren&#39;t all of the packages involved, but they are the big three that we care about as users of &lt;code&gt;ghc-debug&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To get started in the workshop, we will be examining the example &lt;code&gt;heap-shapes&lt;/code&gt; application as a debuggee using &lt;code&gt;ghc-debug-brick&lt;/code&gt; as our debugger. This will serve as an introduction to the &lt;code&gt;ghc-debug&lt;/code&gt; style of debugging, and it will cover some examples of evaluation scenarios that will be important later in the workshop.&lt;/p&gt; &#xA;&lt;h3&gt;The Haskell Is Obviously Better at Everything (HIOBE) Index&lt;/h3&gt; &#xA;&lt;p&gt;The HIOBE Index server (in &lt;code&gt;hiobe-index/server&lt;/code&gt;) is the application we would like to profile with the &lt;code&gt;eventlog2html&lt;/code&gt;, &lt;code&gt;nothunks&lt;/code&gt;, and &lt;code&gt;ghc-debug&lt;/code&gt; tools. It is a simple &lt;a href=&#34;https://hackage.haskell.org/package/scotty&#34;&gt;scotty&lt;/a&gt; web server application that serves data from a sqlite database on various endpoints. The database is already populated with over 70000 rows. We will generate fake traffic for the application which will cause interesting objects to build up on the heap.&lt;/p&gt; &#xA;&lt;p&gt;For a full description of the HIOBE Index, see &lt;a href=&#34;https://raw.githubusercontent.com/well-typed/memory-profiling-webinar/main/hiobe-index/README.md&#34;&gt;its README&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We will spend the rest of the workshop analysing, understanding, and tuning the memory profile of the HIOBE Index server.&lt;/p&gt; &#xA;&lt;p&gt;If you want to give it a try, run the server with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal run hiobe-server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should see the classic scotty &lt;code&gt;Setting phasers to stun...&lt;/code&gt; output if everything is okay.&lt;/p&gt; &#xA;&lt;p&gt;Then run the traffic with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal run hiobe-traffic&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some output should start scrolling by reporting various requests to the server.&lt;/p&gt; &#xA;&lt;h4&gt;Trying the &lt;code&gt;-s&lt;/code&gt; flag&lt;/h4&gt; &#xA;&lt;p&gt;We know this program has bad space behavior, because I wanted it to. However, we don&#39;t know how bad it is. We&#39;ll try to get a &lt;em&gt;very&lt;/em&gt; high-level view of its profile by using the &lt;code&gt;-s&lt;/code&gt; RTS flag, which prints memory usage statistics on program termination. This is usually a great place to start when profiling a Haskell program&#39;s space usage.&lt;/p&gt; &#xA;&lt;p&gt;In our case, we will find that the reported memory usage of the HIOBE server is a little high. Indeed, if we run the application for longer or shorter periods of time, the reported memory usage grows and shrinks! This indicates a non-constant space complexity that we should probably be concerned about.&lt;/p&gt; &#xA;&lt;h4&gt;Using &lt;code&gt;eventlog2html&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;We can dig deeper by having our program emit an &lt;a href=&#34;https://downloads.haskell.org/ghc/latest/docs/users_guide/runtime_control.html#rts-eventlog&#34;&gt;eventlog&lt;/a&gt; using the &lt;code&gt;-l&lt;/code&gt; RTS option. However, to make the eventlog useful for &lt;code&gt;eventlog2html&lt;/code&gt;, we need to supply another flag that enables heap profiling! To start, we&#39;ll use the &lt;a href=&#34;https://downloads.haskell.org/ghc/latest/docs/users_guide/profiling.html#rts-options-for-heap-profiling&#34;&gt;&lt;code&gt;-hT&lt;/code&gt;&lt;/a&gt; flag to tell the RTS to break down the heap profile by closure type.&lt;/p&gt; &#xA;&lt;p&gt;In the resulting profile, we see big spikes of allocations happening with &lt;code&gt;ARR_WORDS&lt;/code&gt;, &lt;code&gt;THUNK&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt; closures: &lt;img src=&#34;https://raw.githubusercontent.com/well-typed/memory-profiling-webinar/main/assets/hiobe-hT-1.png&#34; alt=&#34;area-chart&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;For the rest of the workshop, we will use &lt;code&gt;eventlog2html&lt;/code&gt; and &lt;code&gt;ghc-debug&lt;/code&gt; to answer some very precise questions about the HIOBE server&#39;s memory profile.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Haskell-Things/ImplicitCAD</title>
    <updated>2022-12-08T01:36:49Z</updated>
    <id>tag:github.com,2022-12-08:/Haskell-Things/ImplicitCAD</id>
    <link href="https://github.com/Haskell-Things/ImplicitCAD" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A math-inspired CAD program in haskell. CSG, bevels, and shells; 2D &amp; 3D geometry; 2D gcode generation...&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ImplicitCAD: Math Inspired CAD&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Haskell-Things/ImplicitCAD/actions/workflows/ci.yaml&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/Haskell-Things/ImplicitCAD/Haskell%20CI&#34; alt=&#34;GitHub Workflow Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/implicit&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/implicit.svg?color=success&#34; alt=&#34;Hackage version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://libera.chat/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/irc.libera.chat-%23ImplicitCAD-blue.svg?sanitize=true&#34; alt=&#34;IRC&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;ImplicitCAD is a programmatic CAD program, implemented in Haskell. Unlike traditional CAD programs, programmatic CAD programs use text descriptions of objects, as in programming. Concepts like variables, control structures and abstraction are used, just as in programming. This provides a number of advantages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Objects can be abstracted and reused&lt;/li&gt; &#xA; &lt;li&gt;Repetitive tasks can be automated&lt;/li&gt; &#xA; &lt;li&gt;Objects can be designed parametrically&lt;/li&gt; &#xA; &lt;li&gt;The usual tools for software development (like version control) can be used&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The traditional example of programmatic CAD is OpenSCAD.&lt;/p&gt; &#xA;&lt;p&gt;Generally, objects in programmatic CAD are built with Constructive Solid Geometry or CSG. Unions, intersections and differences of simpler shapes slowly build the object. ImplicitCAD supports all this and much more! For example, it provides rounded unions so that one can have smooth interfaces between objects.&lt;/p&gt; &#xA;&lt;p&gt;It also directly provides some GCode generation, and has a parser for OpenSCAD to make it easier for people to transition/use.&lt;/p&gt; &#xA;&lt;p&gt;ImplicitCAD is very much a work in progress. The author considers it ready for beta testers and greatly appreciates bug reports.&lt;/p&gt; &#xA;&lt;h2&gt;ExtOpenSCAD Examples&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s begin with OpenSCAD examples, since they&#39;re likely a more comfortable format than Haskell for most readers :)&lt;/p&gt; &#xA;&lt;p&gt;ImplicitCAD supports a modified version of the OpenSCAD language, used by the popular programmatic CAD tool of the same name.&lt;/p&gt; &#xA;&lt;p&gt;Generally, normal OpenSCAD code should work. For example, save the following as &lt;code&gt;example1.scad&lt;/code&gt; (or grab it out of the Examples/ directory shipped with ImplicitCAD).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// example1.scad -- The union of a square and a circle.&#xA;union() {&#xA;        square([80,80]);&#xA;        translate ([80,80]) circle(30);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running &lt;code&gt;extopenscad example1.scad&lt;/code&gt; will produce &lt;code&gt;example1.svg&lt;/code&gt;, which will look like:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://faikvm.com/ImplicitCAD/example1.svg?sanitize=true&#34; alt=&#34;A Union of a Square and Circle&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can read more about standard openscad functionality in the &lt;a href=&#34;http://en.wikibooks.org/wiki/OpenSCAD_User_Manual&#34;&gt;OpenSCAD User Manual&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, there are additional ImplicitCAD specific features. For example a rounded union:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//example2.escad -- A rounded union of a square and a circle.&#xA;union(r=14) {&#xA;        square([80,80]);&#xA;        translate ([80,80]) circle(30);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://faikvm.com/ImplicitCAD/example2.svg?sanitize=true&#34; alt=&#34;A Rounded Union of a Square and Circle&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;(For code like this that is not backwards compatible with OpenSCAD, it is recommended that you save it as a .escad file -- Extended OpenSCAD.)&lt;/p&gt; &#xA;&lt;p&gt;Like openscad, ImplicitCAD supports extruding objects.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// example3.escad -- the extruded product of the union of five circles.&#xA;linear_extrude (height = 40, center=true){&#xA;        union ( r = 8) {&#xA;                circle (10);&#xA;                translate ([22,0]) circle (10);&#xA;                translate ([0,22]) circle (10);&#xA;                translate ([-22,0]) circle (10);&#xA;                translate ([0,-22]) circle (10);&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://faikvm.com/ImplicitCAD/example3.png&#34; alt=&#34;An Extrusion&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;And we allow you to twist them as you extrude.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// example4.escad -- the twisted extruded product of the union of five circles.&#xA;linear_extrude (height = 40, center=true, twist=90){&#xA;        union ( r = 8) {&#xA;                circle (10);&#xA;                translate ([22,0]) circle (10);&#xA;                translate ([0,22]) circle (10);&#xA;                translate ([-22,0]) circle (10);&#xA;                translate ([0,-22]) circle (10);&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://faikvm.com/ImplicitCAD/example4.png&#34; alt=&#34;An twisted extrusion&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In fact, we&#39;ve extended this to allow you to twist at non-constant rates and even reverse directions. You just make &lt;code&gt;twist&lt;/code&gt; a function! (We&#39;re following the openscad convention of using degrees...)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// example5.escad -- the variably twisted extruded product of the union of 5 circles.&#xA;linear_extrude (height = 40, center=true, twist(h) = 35*cos(h*2*pi/60)) {&#xA;        union ( r = 8) {&#xA;                circle (10);&#xA;                translate ([22,0]) circle (10);&#xA;                translate ([0,22]) circle (10);&#xA;                translate ([-22,0]) circle (10);&#xA;                translate ([0,-22]) circle (10);&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://faikvm.com/ImplicitCAD/example5.png&#34; alt=&#34;A variably twisted ImplicitCAD extrusion&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;We also allow you to do rounded extrusions. See, we heard you like rounding, so we set this up so you can rounded extrude your rounded union...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// example6.escad -- A rounded extrusion of the rounded union of 5 circles.&#xA;linear_extrude (height = 40, center=true, r=5){&#xA;        union ( r = 8) {&#xA;                circle (10);&#xA;                translate ([22,0]) circle (10);&#xA;                translate ([0,22]) circle (10);&#xA;                translate ([-22,0]) circle (10);&#xA;                translate ([0,-22]) circle (10);&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://faikvm.com/ImplicitCAD/example6.png&#34; alt=&#34;A rounded extrusion made with ImplicitCAD&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is fully compatible with twisting, of course!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// example7.escad -- A twisted rounded extrusion of the rounded union of 5 circles.&#xA;linear_extrude (height = 40, center=true, twist=90, r=5){&#xA;        union ( r = 8) {&#xA;                circle (10);&#xA;                translate ([22,0]) circle (10);&#xA;                translate ([0,22]) circle (10);&#xA;                translate ([-22,0]) circle (10);&#xA;                translate ([0,-22]) circle (10);&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://faikvm.com/ImplicitCAD/example7.png&#34; alt=&#34;A rounded twisted extrusion&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;ImplicitCAD also provides full programmatic functionality, like variable assignment in loops. For example, the trivial program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Example8.escad -- variable assignment in loops.&#xA;a = 5;&#xA;for (c = [1, 2, 3]) {&#xA;        echo(c);&#xA;        a = a*c;&#xA;        echo(a);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Has the output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1.0&#xA;5.0&#xA;2.0&#xA;10.0&#xA;3.0&#xA;30.0&#xA;Nothing to render&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As a functional programmer, I couldn&#39;t resist adding some other niceties to the language. For example, function currying:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Example9.escad -- function currying.&#xA;f = max(4);&#xA;echo(f(5));&#xA;echo(max(4,5));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And some higher order functions, like my friend map:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Example10.escad -- map!.&#xA;echo(map(cos, [0, pi/2, pi]));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Haskell Examples&lt;/h2&gt; &#xA;&lt;p&gt;Everything you saw above can be done with the Haskell API. For example, a simple 2D example, the same as our first ExtOpenSCAD one:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- Example 11 - the union of a square and a circle.&#xA;import Graphics.Implicit&#xA;&#xA;out = union [&#xA;    squareR 0 True (80, 80)&#xA;  , translate (40, 40) (circle 30)&#xA;  ]&#xA;&#xA;main = writeSVG 2 &#34;test.svg&#34; out&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://faikvm.com/ImplicitCAD/example11.svg?sanitize=true&#34; alt=&#34;A Union of a Square and a Circle&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A rounded union:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- Example 12 - the rounded union of a square and a circle.&#xA;import Graphics.Implicit&#xA;&#xA;out = unionR 14 [&#xA;    squareR 0 True (80, 80)&#xA;  , translate (80, 80) (circle 30)&#xA;  ]&#xA;&#xA;main = writeSVG 2 &#34;test.svg&#34; out&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://faikvm.com/ImplicitCAD/example12.svg?sanitize=true&#34; alt=&#34;A Rounded Union of a Square and a Circle&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A simple 3D example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- Example 13 - the union of a cube and a sphere.&#xA;import Graphics.Implicit&#xA;&#xA;out = union [&#xA;    cubeR 0 False (20, 20, 20)&#xA;  , translate (20, 20, 20) (sphere 15)&#xA;  ]&#xA;&#xA;main = writeSTL 1 &#34;test.stl&#34; out&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://faikvm.com/ImplicitCAD/example13.png&#34; alt=&#34;A Rounded Union of a Cube and a Sphere&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can do a whole lot more!&lt;/p&gt; &#xA;&lt;h2&gt;Try ImplicitCAD!&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install GHC and cabal. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Debain/Ubuntu: &lt;code&gt;apt-get install ghc cabal-install zlib1g-dev&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Archlinux: &lt;code&gt;pacman -S ghc cabal-install&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Red Hat/Fedora: &lt;code&gt;yum install ghc cabal-install&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Mac OSX: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Homebrew: &lt;code&gt;brew install ghc cabal-install&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;em&gt;Fink doesn&#39;t seem to have a package for cabal&lt;/em&gt;; Install the Haskell Platform &lt;a href=&#34;http://hackage.haskell.org/platform/mac.html&#34;&gt;manually&lt;/a&gt;.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Windows: Follows &lt;a href=&#34;http://hackage.haskell.org/platform/windows.html&#34;&gt;these install instructions&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Other unices: If your package manager does not include ghc and cabal you should &lt;a href=&#34;http://www.haskell.org/platform&#34;&gt;install the Haskell platform&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;You now have two options for installation: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Latest release: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Use cabal to install ImplicitCAD: &lt;code&gt;cabal update &amp;amp;&amp;amp; cabal install implicit&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Development version: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Initialize your haskell environment: &lt;code&gt;cabal update&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;Git clone this repo: &lt;code&gt;git clone https://github.com/Haskell-Things/ImplicitCAD.git&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;cd in: &lt;code&gt;cd ImplicitCAD/&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;install the dependencies: &lt;code&gt;cabal install --only-dependencies&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;The previous step may fail, but it should tell you what&#39;s missing.&lt;/li&gt; &#xA;     &lt;li&gt;Track down the relevant package in your package manager. You may need to install the -dev package.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Finally, to build and install implicitcad: &lt;code&gt;cabal configure &amp;amp;&amp;amp; cabal install&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Try it! &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;extopenscad test: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Make a test file: &lt;code&gt;echo &#34;circle(30);&#34; &amp;gt; test.escad&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;Run extopencad: &lt;code&gt;extopenscad test.escad&lt;/code&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;Alternatively, &lt;code&gt;~/.cabal/bin/extopenscad test.escad&lt;/code&gt; -- see bellow.&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Haskell ImplicitCAD test: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Start ghci: &lt;code&gt;ghci&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;Load ImplicitCAD: &lt;code&gt;import Graphics.Implicit&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;Try it! &lt;code&gt;writeSVG 1 &#34;test.svg&#34; (circle 30)&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Known issues: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;extopenscad test results in &lt;code&gt;bash: extopenscad: command not found&lt;/code&gt; (or similar for your shell) &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;This probably means &lt;code&gt;~/.cabal/bin/&lt;/code&gt; is not in your &lt;code&gt;$PATH&lt;/code&gt; variable. Try using &lt;code&gt;~/.cabal/bin/extopenscad&lt;/code&gt; as your command instead.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Haskell test results in &lt;code&gt;module is not loaded: &#39;Graphics.Implicit&#39; (./Graphics/Implicit.hs)&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;This is most likely a problem with your Linux distro and cabal not playing nice. GHC is not configured to see the ImplicitCAD libraries. You can confirm this by trying the test in &lt;code&gt;~/.cabal/lib/&lt;/code&gt;. If that works, you should be able to use ghc anywhere with the &lt;code&gt;-Ldir&lt;/code&gt; or &lt;code&gt;-llib&lt;/code&gt; options. Alternatively, some people have permanently fixed this by doing the cabal install as root.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Documentation can be generated from the source code of ImplicitCAD by Haddock by running &lt;code&gt;cabal haddock&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Releases of ImplicitCAD are uploaded to HackageDB which, in addition to making them avaialable through &lt;code&gt;cabal install&lt;/code&gt;, puts the generated documentation on the Internet. So you can read the documentation for the most recent release of ImplicitCAD, 0.4.0.0, &lt;a href=&#34;http://hackage.haskell.org/packages/archive/implicit/0.4.0.0/doc/html/Graphics-Implicit.html&#34;&gt;on HackageDB&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In Implicit CAD, we consider objects as functions of `outwardness&#39;. The boundary is 0, negative is the interior and positive the exterior. The magnitude is how far out or in. A description of the mathematical ideas underpinning ImplicitCAD are in a &lt;a href=&#34;http://christopherolah.wordpress.com/2011/11/06/manipulation-of-implicit-functions-with-an-eye-on-cad/&#34;&gt;blog post on colah&#39;s blog&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Related projects&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kliment/explicitcad/&#34;&gt;ExplicitCAD&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Haskell-Things/hslice/&#34;&gt;HSlice&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Haskell-Things/implicitpipe/&#34;&gt;implicitpipe&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;ImplicitCAD is very much a work in progress.&lt;/p&gt; &#xA;&lt;p&gt;What works (January 26th, 2020 -- regressions are possible if not probable):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CSG, bevelled CSG, shells.&lt;/li&gt; &#xA; &lt;li&gt;2D output (svg, png, dxf).&lt;/li&gt; &#xA; &lt;li&gt;3D output (stl, png, obj).&lt;/li&gt; &#xA; &lt;li&gt;gcode generation for 2D to hacklab laser cutter. Not configurable.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;What still needs to be done:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;gcode generation for 3D printers, gcode generator config.&lt;/del&gt; -- now a seperate program, &lt;a href=&#34;https://github.com/julialongtin/hslice/&#34;&gt;HSlice&lt;/a&gt;!&lt;/li&gt; &#xA; &lt;li&gt;Multi-material / color support.&lt;/li&gt; &#xA; &lt;li&gt;Hull support.&lt;/li&gt; &#xA; &lt;li&gt;Minkowski sum support.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And a wishlist of things to be done as we go:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;More optimisation.&lt;/li&gt; &#xA; &lt;li&gt;Less bugs.&lt;/li&gt; &#xA; &lt;li&gt;More coverage of the openscad language.&lt;/li&gt; &#xA; &lt;li&gt;Pull the hacklab laser cutter support, and place it in HSlice.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>runtimeverification/plutus-core-semantics</title>
    <updated>2022-12-08T01:36:49Z</updated>
    <id>tag:github.com,2022-12-08:/runtimeverification/plutus-core-semantics</id>
    <link href="https://github.com/runtimeverification/plutus-core-semantics" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;KPlutus - K Semantics of Plutus-Core&lt;/h1&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install needed K dependencies: &lt;a href=&#34;https://github.com/kframework/k&#34;&gt;https://github.com/kframework/k&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Update submodules: &lt;code&gt;git submodule update --init --recursive&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Make dependencies: &lt;code&gt;make deps RELEASE=true&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Ubuntu (20.04 Focal, 22.04 Jammy)&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install build-essential m4 openjdk-11-jdk libgmp-dev libmpfr-dev pkg-config flex bison z3 libsecp256k1-dev libz3-dev maven python3 python3-dev python3-pip cmake gcc clang-12 lld-12 llvm-12-tools zlib1g-dev libboost-test-dev libyaml-dev libjemalloc-dev libsecp256k1-dev libssl-dev xxd&#xA;pip install virtualenv poetry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MacOS (12.6 Monterey over Intel)&lt;/h3&gt; &#xA;&lt;p&gt;Follow instructions for K&#39;s dependencies in MacOS from &lt;a href=&#34;https://github.com/kframework/k&#34;&gt;https://github.com/kframework/k&lt;/a&gt;. However, there are some remarks regarding:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;llvm: make sure you install llvm@14, not llvm@15 or later, unless K supports it.&lt;/li&gt; &#xA; &lt;li&gt;openssl: make sure you install openssl@3, or the version required by K. Your system may ship with openssl@1.1.&lt;/li&gt; &#xA; &lt;li&gt;secp256k1: you may need to build it from &lt;a href=&#34;https://github.com/bitcoin-core/secp256k1&#34;&gt;source&lt;/a&gt;. For that you will need to install GNU&#39;s autotools using homebrew. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;brew install autoconf&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;brew install automake&lt;/code&gt; While building secp256k1, make sure you run:&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;./configure --enable-module-recovery&lt;/code&gt; in the appropriate step.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Build everything: &lt;code&gt;make build -j8&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Build LLVM backend: &lt;code&gt;make build-llvm -j8&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Build Haskell backend: &lt;code&gt;make build-haskell -j8&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Build just KPlutus runner and includes: &lt;code&gt;make build-kplutus -j8&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;A note about Crypto++&lt;/h3&gt; &#xA;&lt;p&gt;Due to a bug in the ubuntu bionic and focal packages for crypto++ that affects us here, we build a static library for it from source. If you&#39;re certain that you have a crypto++ package installed that doesn&#39;t have this bug, you can run the make commands with &lt;code&gt;NOBUILD_CRYPTOPP=true&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Update your &lt;code&gt;PATH&lt;/code&gt; variable&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You might want to update your shell resource file to extend &lt;code&gt;PATH&lt;/code&gt;: &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export PATH=`&amp;lt;PATH-TO-PLUTUS-CORE-SEMANTICS&amp;gt;/plutus-core-semantics/.build/usr/bin:$PATH&#xA;``&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Optionally, &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export PATH=`&amp;lt;PATH-TO-PLUTUS-CORE-SEMANTICS&amp;gt;/plutus-core-semantics/.build/usr/lib/kplutus/kframework/bin&#xA;&lt;/code&gt;&lt;/pre&gt; to have direct access to the package&#39;s K tools, in case there is something you need that the &lt;code&gt;kplc&lt;/code&gt; command doesn&#39;t offer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Building with nix&lt;/h3&gt; &#xA;&lt;p&gt;We now support building KPlutus using &lt;a href=&#34;https://nixos.wiki/wiki/Flakes&#34;&gt;nix flakes&lt;/a&gt;. To set up nix flakes you will need to be on &lt;code&gt;nix&lt;/code&gt; 2.4 or higher and follow the instructions &lt;a href=&#34;https://nixos.wiki/wiki/Flakes&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you are on a standard Linux distribution, such as Ubuntu, first &lt;a href=&#34;https://nixos.org/download.html#download-nix&#34;&gt;install nix&lt;/a&gt; and then enable flakes by editing either &lt;code&gt;~/.config/nix/nix.conf&lt;/code&gt; or &lt;code&gt;/etc/nix/nix.conf&lt;/code&gt; and adding:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;experimental-features = nix-command flakes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is needed to expose the Nix 2.0 CLI and flakes support that are hidden behind feature-flags.&lt;/p&gt; &#xA;&lt;p&gt;By default, Nix will build the project and its transitive dependencies from source, which can take up to an hour. We recommend setting up &lt;a href=&#34;https://app.cachix.org/cache/kore&#34;&gt;the binary cache&lt;/a&gt; to speed up the build process significantly. You will also need to add the following sections to &lt;code&gt;/etc/nix/nix.conf&lt;/code&gt; or, if you are a trusted user, &lt;code&gt;~/.config/nix/nix.conf&lt;/code&gt; (if you don&#39;t know what a &#34;trusted user&#34; is, you probably want to do the former):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;trusted-public-keys = ... hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=&#xA;substituters = ... https://cache.iog.io&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;i.e. if the file was originally&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;substituters = https://cache.nixos.org&#xA;trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;it will now read&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;substituters = https://cache.nixos.org https://cache.iog.io&#xA;trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above cache is used for building general haskell packages, however also consider installing cachix to add our kframework specific cache:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nix-env -iA cachix -f https://cachix.org/api/v1/install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above will install cachix, afterwards add the &lt;code&gt;k-framework&lt;/code&gt; cache:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cachix use k-framework&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build the KPlutus via nix, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix build .#kplutus&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will build the KPlutus binary along with K and put a link to the resulting binaries in the &lt;code&gt;result/&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: Mac users, especially those running M1/M2 Macs may find nix segfaulting on occasion. If this happens, try running the nix command like this: &lt;code&gt;GC_DONT_GC=1 nix build .#kplutus&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you want to temporarily add the KPlutus binary to the current shell, run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix shell .#kplutus&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Conformance tests: &lt;code&gt;make conformance-test&lt;/code&gt; Runs all tests where an input program is executed by the &lt;code&gt;kplc run&lt;/code&gt; command. The output is compared against the reference implementation as well as a previous run of &lt;code&gt;kplc run&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Simple hand-written tests: &lt;code&gt;make test-simple&lt;/code&gt; These contain small tests that have been written during the development of the semantics.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Examples generated by the uplc program: &lt;code&gt;make test-uplc-examples&lt;/code&gt; The uplc program contains several small examples. These are slightly larger programs than files in simple tests. The uplc program is a part of the plutus repository &lt;a href=&#34;https://github.com/input-output-hk/plutus&#34;&gt;https://github.com/input-output-hk/plutus&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Examples benchmark examples: &lt;code&gt;test-benchmark-validation-examples&lt;/code&gt; This contains many examples derived from the plutus-apps directory. These represent are more realistic plutus programs. The tests from this directory were extracted from &lt;a href=&#34;https://github.com/input-output-hk/plutus/tree/master/plutus-benchmark/validation/data&#34;&gt;https://github.com/input-output-hk/plutus/tree/master/plutus-benchmark/validation/data&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Examples generated by the nofib-exe program: test-nofib-exe-examples nofib-exe is a program that generates large programs that can serve as performance tests. This program is a part of the plutus repository.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Tests that evaluate to an &lt;code&gt;error&lt;/code&gt; term: &lt;code&gt;make test-error&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Update test results: &lt;code&gt;make update-results&lt;/code&gt; Update all test results. Note: this requires having the uplc program installed in the machine&#39;s PATH.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Rule Coverage&lt;/h2&gt; &#xA;&lt;p&gt;This project contains facilities to generate coverage metrics for K rewrite rules that were executed by &lt;code&gt;kplc run&lt;/code&gt;. This is helpful in ensuring that the test suite contains input programs that exercise all rewrite rules in the semantics.&lt;/p&gt; &#xA;&lt;p&gt;To generate this information, run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  make fresh-test-coverage&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This command generates a &lt;code&gt;.build/coverage.xml&lt;/code&gt; file. This file contains information about the K rewrite rules that have been exercised for all tests in the tests/ directory.&lt;/p&gt; &#xA;&lt;p&gt;After running &lt;code&gt;make fresh-test-coverage&lt;/code&gt;, the execution of &lt;code&gt;./no-hits.py -r&lt;/code&gt; will show all the rules that have not been exercised in the last execution of &lt;code&gt;make fresh-test-coverage&lt;/code&gt;. (By executing &lt;code&gt;./no-hits.py -t&lt;/code&gt;, a Python 3 dictionary containing file names and line numbers is pretty-printed. This dictionary denotes the same as the rules printed with option &lt;code&gt;-r&lt;/code&gt;.)&lt;/p&gt; &#xA;&lt;h2&gt;Profiling with perf&lt;/h2&gt; &#xA;&lt;p&gt;There are build targets for profiling the semantics with perf.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make k-deps-profiling&#xA;make build-llvm-profiling&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will build kplc with optimizations but debug info left in so perf can collect more meaningful data.&lt;/p&gt; &#xA;&lt;p&gt;You can install perf on ubuntu by installing the &lt;code&gt;linux-tools-common&lt;/code&gt; package. Information about perf and how to use it can be found on the &lt;a href=&#34;https://perf.wiki.kernel.org/index.php/Main_Page&#34;&gt;perf wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example of steps you can follow to generate and view a report:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;perf record -g -- kplc run tests/textual/nofib-exe-examples/lastpiece.uplc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;lastpiece.uplc is a very long running program. You can kill it after about one minute and perf will have collected a sizeable amount of data.&lt;/p&gt; &#xA;&lt;p&gt;View the report with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;perf report -g -c interpreter&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>