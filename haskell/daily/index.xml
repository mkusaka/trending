<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-09T01:36:32Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>vipo/bimaru-client</title>
    <updated>2022-09-09T01:36:32Z</updated>
    <id>tag:github.com,2022-09-09:/vipo/bimaru-client</id>
    <link href="https://github.com/vipo/bimaru-client" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;bimaru-client&lt;/h1&gt; &#xA;&lt;p&gt;We will solve &lt;a href=&#34;https://en.wikipedia.org/wiki/Battleship_(puzzle)&#34;&gt;bimaru&lt;/a&gt; puzzles!&lt;/p&gt; &#xA;&lt;p&gt;Steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone this repository (in the future you will have to merge this repo into your repo multiple times)&lt;/li&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;GHCup&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;ghcup tui&lt;/code&gt; and install: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;GHC 8.10.7&lt;/li&gt; &#xA;   &lt;li&gt;Recommended version of Stack&lt;/li&gt; &#xA;   &lt;li&gt;Recommended version of HLS&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;(Optional) Install VSCode with Haskell plugin&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;stack build&lt;/code&gt; to see if everything works&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;stack run -- $YOUR_TOKEN&lt;/code&gt; play a game&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Some other notes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;On Windows you might need to install &#34;Msys2&#34;&lt;/li&gt; &#xA; &lt;li&gt;On Linux you might need to install &#34;libtinfo-dev&#34; and &#34;zlib1g-dev&#34;&lt;/li&gt; &#xA; &lt;li&gt;On Linux you might need to use &lt;code&gt;stack&lt;/code&gt; with version suffix, e.g. &lt;code&gt;stack-2.7.5&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>jsoffer/gapsim</title>
    <updated>2022-09-09T01:36:32Z</updated>
    <id>tag:github.com,2022-09-09:/jsoffer/gapsim</id>
    <link href="https://github.com/jsoffer/gapsim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simula operaciones de memoria y caché a partir de datos extraídos de sesiones GAP&lt;/p&gt;&lt;hr&gt;&lt;p&gt;El archivo &#34;rubik.gap&#34; es &lt;a href=&#34;http://www.gap-system.org/Doc/Examples/rubik.in&#34;&gt;http://www.gap-system.org/Doc/Examples/rubik.in&lt;/a&gt; modificado para que haya siempre espacios alrededor de &#34;;&#34;, &#34;:=&#34;, &#34;=&#34;, y que no haya &#34;;&#34; dobles.&lt;/p&gt; &#xA;&lt;p&gt;&#34;datos&#34; es la salida de una sesión de GAP, modificado para almacenar los objetos que crea y las relaciones entre ellos e imprimirlos cuando GAP finaliza. Hace falta una versión modificada de GAP para crear archivos &#34;datos&#34; para una sesión arbitraria; no he publicado aún las modificaciones.&lt;/p&gt; &#xA;&lt;p&gt;El formato de salida es&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;(5,14,464) &#34;cube1&#34; 36/6 INVOCA N memoria: fromList [&#34;cmpl2&#34;,&#34;cube&#34;,&#34;cube2&#34;,&#34;cube2b&#34;] cache: fromList [&#34;blockhom1&#34;,&#34;blockhom2&#34;,&#34;cmpl1&#34;,&#34;corners&#34;,&#34;cube1&#34;,&#34;cube1b&#34;,&#34;edges&#34;,&#34;orbits&#34;] cola: [&#34;cube&#34;,&#34;cmpl2&#34;,&#34;cube2&#34;,&#34;cube2b&#34;]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;donde:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;El triple en la primera línea es el número de fallos, número de desalojos, y la transferencia total, respectivamente.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;La segunda línea contiene:&lt;br&gt; ** El nombre del siguiente identificador en la sesión ** El tamaño del objeto asociado al identificador / la memoria principal libre ** El comando, indica si se va a crear un objeto nuevo o si se lee uno existente ** Y si el objeto asociado al identificador se encuentra en memoria, N en otro caso&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&#34;memoria&#34; y &#34;cache&#34; son conjuntos (sin orden) de los identificadores actualmente en memoria y en caché, respectivamente.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&#34;cola&#34; es una lista ordenada de los identificadores de los objetos en el orden que serán desalojados; el identificador más a la derecha es el siguiente que se intentará desalojar si un objeto debe ser ingresado a la memoria y la memoria no tiene espacio libre suficiente.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;La función &#34;main&#34; regresa un Estado, que consiste en:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;El total final de fallos, desalojos y transferencia&lt;/li&gt; &#xA; &lt;li&gt;El estado final de la cola&lt;/li&gt; &#xA; &lt;li&gt;El estado final de la memoria&lt;/li&gt; &#xA; &lt;li&gt;El estado final del caché&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>piccolo-lang/piccolo</title>
    <updated>2022-09-09T01:36:32Z</updated>
    <id>tag:github.com,2022-09-09:/piccolo-lang/piccolo</id>
    <link href="https://github.com/piccolo-lang/piccolo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;the piccolo parallel compiler&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Piccolo&lt;/h1&gt; &#xA;&lt;h2&gt;Pre-requisites&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The GHC compiler&lt;/li&gt; &#xA; &lt;li&gt;cabal (&amp;gt;= 1.18)&lt;/li&gt; &#xA; &lt;li&gt;The gcc compiler&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;h3&gt;Installation:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using the piccolo compiler:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;piccolo file.pi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will hopefully generate the executable &lt;em&gt;a.out&lt;/em&gt; in the current directory.&lt;/p&gt;</summary>
  </entry>
</feed>