<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-10T01:37:06Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>falgon/roki-web</title>
    <updated>2023-02-10T01:37:06Z</updated>
    <id>tag:github.com,2023-02-10:/falgon/roki-web</id>
    <link href="https://github.com/falgon/roki-web" rel="alternate"></link>
    <summary type="html">&lt;p&gt;My website&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;roki-web&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;span&gt;üìù&lt;/span&gt; The &lt;a href=&#34;https://github.com/falgon&#34;&gt;roki&lt;/a&gt;&#39;s website and blog&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://github.com/falgon/roki-web/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt; &lt;a href=&#34;https://dl.circleci.com/status-badge/redirect/gh/falgon/roki-web/tree/develop&#34;&gt;&lt;img src=&#34;https://dl.circleci.com/status-badge/img/gh/falgon/roki-web/tree/develop.svg?style=shield&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://snyk.io/test/github/falgon/roki-web?targetFile=package.json&#34;&gt;&lt;img src=&#34;https://snyk.io/test/github/falgon/roki-web/badge.svg?targetFile=package.json&#34; alt=&#34;Known Vulnerabilities&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.codefactor.io/repository/github/falgon/roki-web&#34;&gt;&lt;img src=&#34;https://www.codefactor.io/repository/github/falgon/roki-web/badge?s=e4b1f45b3bb2dc89c42f654d991238ef7771bc9f&#34; alt=&#34;CodeFactor&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.codacy.com?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=falgon/roki-web&amp;amp;utm_campaign=Badge_Grade&#34;&gt;&lt;img src=&#34;https://app.codacy.com/project/badge/Grade/0f3e0d5c5bbe43a78eaeed7485b72c7f&#34; alt=&#34;Codacy Badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/falgon/roki-web/maintainability&#34;&gt;&lt;img src=&#34;https://api.codeclimate.com/v1/badges/e6574c3042df63bf6d41/maintainability&#34; alt=&#34;Maintainability&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/falgon/roki-web/actions/workflows/codeql.yml&#34;&gt;&lt;img src=&#34;https://github.com/falgon/roki-web/actions/workflows/codeql.yml/badge.svg?sanitize=true&#34; alt=&#34;CI-CodeQL&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://app.fossa.com/projects/git%2Bgithub.com%2Ffalgon%2Froki-web?ref=badge_shield&#34;&gt;&lt;img src=&#34;https://app.fossa.com/api/projects/git%2Bgithub.com%2Ffalgon%2Froki-web.svg?type=shield&#34; alt=&#34;FOSSA Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Website: &lt;a href=&#34;https://roki.dev&#34;&gt;roki.dev&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Tech blog: &lt;a href=&#34;https://roki.dev/roki.log/&#34;&gt;roki.dev/roki.log&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Diary: &lt;a href=&#34;https://roki.dev/roki.diary/&#34;&gt;roki.dev/roki.diary&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone --recursive git@github.com:falgon/roki-web.git &amp;amp;&amp;amp; cd roki-web&#xA;nvm install &amp;amp;&amp;amp; nvm use &amp;amp;&amp;amp; npm i&#xA;stack build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Building a site&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stack exec site -- --help&#xA;Usage: site [--version] [--preview] [-v|--verbose] [--internal-links] COMMAND&#xA;  The static site roki.dev compiler version 0.1.0.0 powerted by Hakyll&#xA;&#xA;Available options:&#xA;  -h,--help                Show this help text&#xA;  --version                Show version&#xA;  --preview                Enable a preview flag&#xA;  -v,--verbose             Run in verbose mode&#xA;  --internal-links         Check internal links only&#xA;&#xA;Available commands:&#xA;  build                    Generate the site&#xA;  check                    Validate the site output&#xA;  clean                    Clean up and remove cache&#xA;  deploy                   Upload/deploy roki.dev&#xA;  rebuild                  Clean and build again&#xA;  server                   Start a preview server&#xA;  watch                    Autocompile on changes and start a preview server&#xA;&#xA;stack exec site -- build --preview # fast build (This does not render KaTeX)&#xA;stack exec site -- build # release build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Scheduled posting&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stack exec spa -- --help&#xA;Usage: spa [--version] COMMAND [-d|--date date] [-b|--branch-name ARG] [-y]&#xA;  The roki-web Scheduling Post Action manager 0.1.0.0&#xA;&#xA;Available options:&#xA;  -h,--help                Show this help text&#xA;  --version                Show spa version information&#xA;  -d,--date date           Date to schedule (mm-dd-%H:%M)&#xA;  -b,--branch-name ARG     The name of the branch you plan to deploy&#xA;  -y                       Generate a file without checking the branch name and&#xA;                           repository name&#xA;&#xA;Available commands:&#xA;  cexpr                    show crontab expression&#xA;  yaml                     generate GitHub Actions yaml from template&#xA;  clean                    clean up and remove cache&#xA;&#xA;stack exec spa -- cexpr -d $(date &#34;+%m-%d-%R&#34;) # from current time&#xA;00 15 11 09 *&#xA;stack exec spa -- yaml -d $(date &#34;+%m-%d-%R&#34;) -b my-awesome-scheduled-post # from current time&#xA;current branch name is: draft&#xA;Are you sure you want to continue connecting? (y/N)y&#xA;Initialising...&#xA;  Creating store...&#xA;  Creating provider...&#xA;  Running rules...&#xA;Checking for out-of-date items&#xA;Compiling&#xA;  updated tools/scheduled_post/template.yml&#xA;  updated my-awesome-scheduled-post.yml&#xA;Success&#xA;mv .github/workflows/scheduled/my-awesome-scheduled-post.yaml .github/workflows/ &amp;amp;&amp;amp; rmdir .github/workflows/scheduled # apply&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Update blog posts using docker container&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# start a preview server&#xA;pushd ./docker \&#xA;    &amp;amp;&amp;amp; docker-compose up -d preview \&#xA;    &amp;amp;&amp;amp; COMPOSE_HTTP_TIMEOUT=86400 docker-compose logs -f preview \&#xA;    ; popd&#xA;&#xA;# build blog posts&#xA;pushd ./docker &amp;amp;&amp;amp; docker-compose run build; popd&#xA;&#xA;# clean the generated docs&#xA;pushd ./docker &amp;amp;&amp;amp; docker-compose run clean; popd&#xA;&#xA;# Reservation posting&#xA;DATE=$(date &#34;+%m-%d-%R&#34;) BRANCH_NAME=&#34;hoge&#34; pushd ./docker &amp;amp;&amp;amp; docker-compose run spa; popd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using a pre-built image (Requires PAT with &lt;code&gt;read:packages&lt;/code&gt; permission)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat ~/.ghcr.txt | docker login ghcr.io -u falgon --password-stdin&#xA;docker pull docker.pkg.github.com/falgon/roki-web/roki-web-env:latest&#xA;&#xA;# start a preview server&#xA;pushd ./docker \&#xA;    &amp;amp;&amp;amp; docker-compose -f docker-compose-ghpr.yml up -d preview \&#xA;    &amp;amp;&amp;amp; COMPOSE_HTTP_TIMEOUT=86400 docker-compose -f docker-compose-ghpr.yml logs -f preview \&#xA;    ; popd&#xA;&#xA;# build blog posts&#xA;pushd ./docker &amp;amp;&amp;amp; docker-compose -f docker-compose-ghpr.yml run build; popd&#xA;&#xA;# clean the generated docs&#xA;pushd ./docker &amp;amp;&amp;amp; docker-compose -f docker-compose-ghpr.yml run clean; popd&#xA;&#xA;# Reservation posting&#xA;DATE=$(date &#34;+%m-%d-%R&#34;) BRANCH_NAME=&#34;hoge&#34; pushd ./docker \&#xA;    &amp;amp;&amp;amp; docker-compose -f docker-compose-ghpr.yml run spa \&#xA;    ; popd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Develop/build inside docker container&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pushd ./docker &amp;amp;&amp;amp; docker-compose up -d dev &amp;amp;&amp;amp; popd&#xA;docker exec -it roki-web-dev bash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using a pre-built image (Requires PAT with &lt;code&gt;read:packages&lt;/code&gt; permission)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat ~/.ghcr.txt | docker login ghcr.io -u falgon --password-stdin&#xA;docker pull docker.pkg.github.com/falgon/roki-web/roki-web-dev:latest&#xA;pushd ./docker &amp;amp;&amp;amp; docker-compose -f docker-compose-ghpr.yml up -d dev; popd&#xA;docker exec -it roki-web-dev bash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;System overview&lt;/h2&gt; &#xA;&lt;h3&gt;Overview of blog posts and website system updates&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/1241783/90969880-d99b8a00-e538-11ea-8f35-684365e14406.png&#34; width=&#34;640&#34; alt=&#34;system overview&#34;&gt; &lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/falgon/roki-web&#34;&gt;roki-web&lt;/a&gt; (this repository)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/falgon/roki-web-post&#34;&gt;roki-web-post&lt;/a&gt; (private repository)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/peaceiris/actions-gh-pages&#34;&gt;GitHub Actions for GitHub pages&lt;/a&gt; has been very helpful in building this system. Thanks for it.&lt;/p&gt; &#xA;&lt;h3&gt;Overview of preview function accompanying PR&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/1241783/92309894-3fc9e780-efe4-11ea-88f2-29697c54b156.png&#34; height=&#34;450px&#34; alt=&#34;pr&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;When PR is issued, artifact is built on CircleCI as shown above and it is possible to preview. Also, the bot &lt;a href=&#34;https://github.com/kiirotori&#34;&gt;@kiirotori&lt;/a&gt; will add a comment containing the URL of the preview site and the URL of the circleci JOB log that can be displayed in the artifact.&lt;/p&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;p&gt;This is a project for a new website that integrates the following two sites.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://falgon.github.io/roki/&#34;&gt;Roki Profile&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Repo: &lt;a href=&#34;https://github.com/falgon/roki&#34;&gt;https://github.com/falgon/roki&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://falgon.github.io/roki.log/&#34;&gt;roki.log&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Repo: &lt;a href=&#34;https://bitbucket.org/r0ki/roki.log/&#34;&gt;https://bitbucket.org/r0ki/roki.log/&lt;/a&gt; (private)&lt;/li&gt; &#xA;   &lt;li&gt;Repo (gh-page): &lt;a href=&#34;https://github.com/falgon/roki.log&#34;&gt;https://github.com/falgon/roki.log&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These two will be discontinued in the future and replaced by this new website and have the following characteristics.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The website &lt;a href=&#34;https://falgon.github.io/roki/&#34;&gt;Roki Profile&lt;/a&gt; is deployed manually (maintained by snyk-bot)&lt;/li&gt; &#xA; &lt;li&gt;The blog &lt;a href=&#34;https://falgon.github.io/roki.log/&#34;&gt;roki.log&lt;/a&gt; is deployed bitbucket-pipelines&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I used bitbucket, a kind of Git service that I can use private repositories for free, because github couldn&#39;t use private repositories for free before. But times have changed and now private repositories are now available for free and native CI (GitHub Actions) are also available. In this project, I use &lt;a href=&#34;https://jaspervdj.be/hakyll/&#34;&gt;Hakyll&lt;/a&gt;, which is a static site generator, to manage the frontend library with node.js and have it managed with synk-bot. Deployment is done with github actions, drafts of blog posts are managed in another repository, and commits to a specific branch in that repository are triggered and pushed to this branch. This makes it possible to make open source and keep drafts private, improving and integrating the previously separated management form.&lt;/p&gt; &#xA;&lt;h2&gt;License &lt;a href=&#34;https://app.fossa.com/projects/git%2Bgithub.com%2Ffalgon%2Froki-web?ref=badge_small&#34;&gt;&lt;img src=&#34;https://app.fossa.com/api/projects/git%2Bgithub.com%2Ffalgon%2Froki-web.svg?type=small&#34; alt=&#34;FOSSA Status&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Licenses of this project is managed by &lt;a href=&#34;https://fossa.com/&#34;&gt;FOSSA&lt;/a&gt; (you can see above &#34;license scan&#34; badge). For more details, you can see &lt;a href=&#34;https://app.fossa.com/projects/git%2Bgithub.com%2Ffalgon%2Froki-web?utm_source=share_link&#34;&gt;the dependency report of FOSSA&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://app.fossa.com/projects/git%2Bgithub.com%2Ffalgon%2Froki-web?ref=badge_large&#34;&gt;&lt;img src=&#34;https://app.fossa.com/api/projects/git%2Bgithub.com%2Ffalgon%2Froki-web.svg?type=large&#34; alt=&#34;FOSSA Status&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>deoxyribose/BeginningHaskell</title>
    <updated>2023-02-10T01:37:06Z</updated>
    <id>tag:github.com,2023-02-10:/deoxyribose/BeginningHaskell</id>
    <link href="https://github.com/deoxyribose/BeginningHaskell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;BeginningHaskell&lt;/h1&gt;</summary>
  </entry>
  <entry>
    <title>LighghtEeloo/data-types-a-la-carte</title>
    <updated>2023-02-10T01:37:06Z</updated>
    <id>tag:github.com,2023-02-10:/LighghtEeloo/data-types-a-la-carte</id>
    <link href="https://github.com/LighghtEeloo/data-types-a-la-carte" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A quick tour to *Data types √† la carte* for reading group presentation.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;https://www.cambridge.org/core/journals/journal-of-functional-programming/article/data-types-a-la-carte/14416CB20C4637164EA9F77097909409&#34;&gt;Data Types √† la Carte&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Author: Wouter Swierstra&lt;/p&gt; &#xA;&lt;p&gt;Presenter: Yuchen Jiang&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;This presentation uses &lt;code&gt;cabal&lt;/code&gt;. To run, simply&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cabal run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Most titles contain a link to the corresponding Haskell code. Maybe I should try literate programming sometime...&lt;/p&gt; &#xA;&lt;h2&gt;Motivating Problem&lt;/h2&gt; &#xA;&lt;p&gt;Suppose we want to represent an AST of a developing language that needs to add nodes incrementally, what approach should we take?&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LighghtEeloo/data-types-a-la-carte/main/app/OldDays.hs&#34;&gt;Good Old Days&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Why not ADTs?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Expr = Val Int&#xA;          | Add Expr Expr&#xA;&#xA;val :: Int -&amp;gt; Expr&#xA;val = Val&#xA;&#xA;add :: Expr -&amp;gt; Expr -&amp;gt; Expr&#xA;add = Add&#xA;&#xA;eval :: Expr -&amp;gt; Int&#xA;eval (Val n) = n&#xA;eval (Add x y) = eval x + eval y&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Easy, intuitive and straight forward, but...&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Hard to add new structures - have to go through and change all the files &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;High Cohesion&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Can I write a partial function on some of them? &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Can&#39;t represent a part of them; have to split to several ADTs&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Prelude.undefined&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;What if there&#39;s a new demand that requires side effects? &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Have to rewrite most of them into various monads&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;A Quick Inspection&lt;/h2&gt; &#xA;&lt;p&gt;What do we need ADT for representing the AST?&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Recursion (both type level and term level)&lt;/li&gt; &#xA; &lt;li&gt;Composability&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;It turns out that we can solve them one by one.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LighghtEeloo/data-types-a-la-carte/main/app/Cata.hs&#34;&gt;Catamorphism (Fold)&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Our first goal is to re-invent recursion. Borrowing the (bad) name from &lt;a href=&#34;https://arxiv.org/abs/2202.13633&#34;&gt;Fantastic Morphisms and Where to Find Them: A Guide to Recursion Schemes&lt;/a&gt;, we can use &lt;code&gt;catamorphism&lt;/code&gt; to create a fix-point on inductive data types &lt;code&gt;Mu&lt;/code&gt; that folds an algebra over a term.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype Mu f = In (f (Mu f))&#xA;cata :: Functor f =&amp;gt; (f a -&amp;gt; a) -&amp;gt; Mu f -&amp;gt; a&#xA;cata alg (In e) =&#xA;  f $ fmap (cata alg) e&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The corresponding commute diagram looks like this:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/LighghtEeloo/data-types-a-la-carte/main/docs/cata.png&#34; alt=&#34;cata_diagram&#34; style=&#34;width: 30%; left: 35%;&#34;&gt; &#xA;&lt;p&gt;Now the only input we need is &lt;code&gt;f :: * -&amp;gt; *&lt;/code&gt; that takes the &lt;code&gt;Mu f&lt;/code&gt; itself and returns the node.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LighghtEeloo/data-types-a-la-carte/main/app/Cata.hs&#34;&gt;Either&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;To build an AST, we need to have a generalized &lt;code&gt;Sum&lt;/code&gt; type - which is &lt;code&gt;Either&lt;/code&gt;!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data (a :+: b) e = Left (a e) | Right (b e)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Well, a form of &lt;code&gt;Either&lt;/code&gt; that take an extra type parameter for the use of &lt;code&gt;Mu&lt;/code&gt;. And written in a fancy form.&lt;/p&gt; &#xA;&lt;h2&gt;Introduction and Elimination Forms&lt;/h2&gt; &#xA;&lt;p&gt;With the tools in hand, we can try and build the term constructors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Expr = Mu (Val :+: Add)&#xA;&#xA;newtype Val e = Val Int&#xA;val :: Int -&amp;gt; Expr&#xA;val n = In (Left (Val n))&#xA;&#xA;data Add e = Add e e&#xA;add :: Expr -&amp;gt; Expr -&amp;gt; Expr&#xA;add x y = In (Right (Add x y))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hmmm. Indeed we have made the nodes to be separated, but even if we only have two nodes, the &lt;code&gt;Left&lt;/code&gt;s and &lt;code&gt;Right&lt;/code&gt;s and the outermost &lt;code&gt;In&lt;/code&gt; look annoying. If we add more nodes to the structure the complexity will soon pile up. We deserve better.&lt;/p&gt; &#xA;&lt;p&gt;And term consumers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;eval :: Expr -&amp;gt; Int&#xA;eval (In (Left (Val n))) = n&#xA;eval (In (Right (Add x y))) = eval x + eval y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Still far from satisfactory. So let&#39;s hide all the ugly details from the language implementor.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LighghtEeloo/data-types-a-la-carte/main/app/Eval.hs&#34;&gt;&lt;code&gt;Eval&lt;/code&gt; Algebra&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;The first thing we can notice is that for any &#34;node&#34; in our AST, the evaluation doesn&#39;t need to depend on the definition of the &lt;code&gt;Expr&lt;/code&gt;. Because if there is a field that needs to, it&#39;s a recursive call to &lt;code&gt;eval&lt;/code&gt; the &lt;code&gt;Expr&lt;/code&gt; part, which has been avoided by &lt;code&gt;cata&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As a result, we can give the definition of &lt;code&gt;Eval&lt;/code&gt; by:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class (Functor f) =&amp;gt; Eval f where&#xA;  eval :: f Int -&amp;gt; Int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reason for the constraint of &lt;code&gt;Functor f&lt;/code&gt; comes from &lt;code&gt;cata&lt;/code&gt;. An intuition could be we will only run &lt;code&gt;eval&lt;/code&gt; on &lt;code&gt;data Add Int = Add Int Int&lt;/code&gt;, which is just &lt;code&gt;(+)&lt;/code&gt;, and similar for all &lt;code&gt;f&lt;/code&gt; passed into &lt;code&gt;Mu f&lt;/code&gt;. &lt;code&gt;cata&lt;/code&gt; will do the rest of the work for us.&lt;/p&gt; &#xA;&lt;p&gt;After the definition of &lt;code&gt;Eval&lt;/code&gt; we can implement it for all nodes that can be evaluated:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance Eval Val where&#xA;  eval (Val n) = n&#xA;&#xA;instance Eval Add where&#xA;  eval (Add a b) = a + b&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Easy.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LighghtEeloo/data-types-a-la-carte/main/app/Inject.hs&#34;&gt;Injection&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;To avoid unsatisfactory constructors, we can use injection, which is a way to express the fact that &#34;if we have the ability to build a smaller term in our generalized sum type, we can build the sum type&#34;. The injections is expressed in three instances:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class (Functor sub, Functor sup) =&amp;gt; sub :&amp;lt;: sup where&#xA;  inj :: sub e -&amp;gt; sup e&#xA;&#xA;instance Functor f =&amp;gt; f :&amp;lt;: f where&#xA;  inj = id&#xA;instance (Functor f, Functor g) =&amp;gt; g :&amp;lt;: (f :+: g) where&#xA;  inj = Right&#xA;instance {-# OVERLAPPABLE #-} (Functor f, Functor g, Functor h, f :&amp;lt;: g) =&amp;gt; f :&amp;lt;: (g :+: h) where&#xA;  inj = Left . inj&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first instance shows that the injection is reflexive. The last two rules are responsible for the inductive definition of &lt;code&gt;:&amp;lt;:&lt;/code&gt; over &lt;code&gt;:+:&lt;/code&gt;. The only structure that the injection needs to penetrate is &lt;code&gt;Mu&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;inject :: (f :&amp;lt;: g) =&amp;gt; f (Mu g) -&amp;gt; Mu g&#xA;inject = In . inj&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and we can just prepend &lt;code&gt;inject $&lt;/code&gt; to any node and get its constructor automatically:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;val :: Int -&amp;gt; Expr&#xA;val n = inject $ Val n&#xA;&#xA;add :: Expr -&amp;gt; Expr -&amp;gt; Expr&#xA;add x y = inject $ Add x y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;No more lispy &lt;code&gt;In (Left (Right (Add (In (Left (Left (Val 1)))) (In (Left (Left (Val 1)))))))&lt;/code&gt; anymore.&lt;/p&gt; &#xA;&lt;h2&gt;What have we achieved?&lt;/h2&gt; &#xA;&lt;p&gt;With all the preparations, we can separate all algebra definitions and all data definitions into different files, and only implement the needed algebras for each data type. We can flexibly combine data type with &lt;code&gt;:+:&lt;/code&gt; at any time and use the algebra with all required instances defined. The powerful flexivity is where this approach gets its name from - it&#39;s like ordering pre-deined dishes and combine them as you wish.&lt;/p&gt; &#xA;&lt;p&gt;The rest of the paper will focus on the famous free monad, the holy grail of monadic operations.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LighghtEeloo/data-types-a-la-carte/main/app/Free.hs&#34;&gt;Monads for Free&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;As long as a type constructor &lt;code&gt;f&lt;/code&gt; has type class &lt;code&gt;Functor&lt;/code&gt; defined, we can get &lt;code&gt;Monad&lt;/code&gt; for &lt;code&gt;Term f&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Term f a = Pure a&#xA;              | Impure (f (Term f a))&#xA;&#xA;instance Functor f =&amp;gt; Functor (Term f) where&#xA;  fmap f (Pure a) = Pure $ f a&#xA;  fmap f (Impure e) = Impure $ fmap (fmap f) e&#xA;instance Functor f =&amp;gt; Applicative (Term f) where&#xA;  pure = Pure&#xA;  Pure f &amp;lt;*&amp;gt; x = fmap f x&#xA;  Impure f &amp;lt;*&amp;gt; x = Impure $ fmap (&amp;lt;*&amp;gt; x) f&#xA;instance Functor f =&amp;gt; Monad (Term f) where&#xA;  return = pure&#xA;  Pure x &amp;gt;&amp;gt;= f = f x&#xA;  Impure e &amp;gt;&amp;gt;= f = Impure $ fmap (&amp;gt;&amp;gt;= f) e&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is called the &lt;strong&gt;free monad&lt;/strong&gt; for two reasons.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;We can get the monad for free.&lt;/li&gt; &#xA; &lt;li&gt;The property of this monad is relative to the forgetful functor.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LighghtEeloo/data-types-a-la-carte/main/app/FreeRun.hs&#34;&gt;Encapsulating Side Effects&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;We can then use &lt;code&gt;Term&lt;/code&gt; to characterize side effects via state monads:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type State a = Int -&amp;gt; (a, Int)&#xA;class (Functor f) =&amp;gt; Run f where&#xA;  run :: f (State a) -&amp;gt; State a&#xA;instance (Run f, Run g) =&amp;gt; Run (f :+: g) where&#xA;  run (Left x) = run x&#xA;  run (Right x) = run x&#xA;&#xA;runTerm :: (Run f) =&amp;gt; Term f a -&amp;gt; State a&#xA;runTerm = foldTerm ((,), run)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and later implement some operators:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype Recall t = Recall (Int -&amp;gt; t) deriving (Functor)&#xA;recall :: (Recall :&amp;lt;: f) =&amp;gt; Term f Int&#xA;recall = inject $ Recall pure&#xA;instance Run Recall where&#xA;  run (Recall f) i = f i i&#xA;&#xA;data Incr t = Incr Int t deriving (Functor)&#xA;incr :: (Incr :&amp;lt;: f) =&amp;gt; Int -&amp;gt; Term f ()&#xA;incr n = inject $ Incr n (pure ())&#xA;instance Run Incr where&#xA;  run (Incr n f) i = f (i + n)&#xA;&#xA;newtype Clear t = Clear t deriving (Functor)&#xA;clear :: (Clear :&amp;lt;: f) =&amp;gt; Term f ()&#xA;clear = inject $ Clear (pure ())&#xA;instance Run Clear where&#xA;  run (Clear f) _ = f 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and finally write a program in the DSL we&#39;ve just defined:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- tick :: Term (Recall :+: Incr :+: Clear) Int&#xA;tick :: (Recall :&amp;lt;: f, Incr :&amp;lt;: f) =&amp;gt; Term f Int&#xA;tick = do&#xA;  x &amp;lt;- recall&#xA;  incr 1&#xA;  pure x&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The comment is a concrete typed program, while the actual type annotation is less limited. Though the consequence follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;main1 :: IO ()&#xA;main1 = do&#xA;  print $ runTerm (tick :: Term (Recall :+: Incr) Int) 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Our main program will need type annotation to determine which exact implementation to choose.&lt;/p&gt; &#xA;&lt;h2&gt;Final Comments&lt;/h2&gt; &#xA;&lt;p&gt;The discovery of free monads eased a major source of painfulness when writing code in pure functional languages like Haskell - defining different monads all the time. This innovative approach of creating composable monads has established fame for the classical functional pearl paper.&lt;/p&gt; &#xA;&lt;h2&gt;Lingering Questions&lt;/h2&gt; &#xA;&lt;p&gt;The paper introduced a better way to organize ADTs. What about GADTs?&lt;/p&gt; &#xA;&lt;p&gt;Does the approach that the author suggested result in performance impact?&lt;/p&gt; &#xA;&lt;h2&gt;Special Thanks&lt;/h2&gt; &#xA;&lt;p&gt;A fantastic &lt;a href=&#34;https://iota.huohuo.moe/FreeMonad.html&#34;&gt;blog&lt;/a&gt; (in Chinese though) by Niltok (Áé©ÁÅ´) that goes through the main ideas of the paper.&lt;/p&gt;</summary>
  </entry>
</feed>