<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-12T02:25:50Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>josephsumabat/static-ls</title>
    <updated>2023-04-12T02:25:50Z</updated>
    <id>tag:github.com,2023-04-12:/josephsumabat/static-ls</id>
    <link href="https://github.com/josephsumabat/static-ls" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;static-ls&lt;/h1&gt; &#xA;&lt;p&gt;static-ls is a hie and hiedb based language server heavily inspired by &lt;code&gt;halfsp&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The goal of static-ls is to provide a high-speed, low-memory solution for large projects for which haskell-language-server tends to take up too much memory on recompilation. Haskell-language-server is recommended if you are not experiencing these issues. &lt;code&gt;static-ls&lt;/code&gt; is meant to work on enterprise size projects. &lt;code&gt;static-ls&lt;/code&gt; tends to work better standalone as a code navigation tool since project edits require re-indexing of hie files but also works reasonably well for editing with a program such as &lt;code&gt;ghcid&lt;/code&gt; to watch files for compilation and the &lt;code&gt;-fdefer-type-errors flag&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In the future we plan to use interface files to fetch documentation information as well as possibly other static sources of information&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Compile your project with ide info &lt;code&gt;-fwrite-ide-info&lt;/code&gt; and &lt;code&gt;-hiedir .hiefiles&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;If you&#39;re using hpack you can add:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  ghc-options:&#xA;    - -fwrite-ide-info&#xA;    - -hiedir .hiefiles&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;to your &lt;code&gt;package.yaml&lt;/code&gt; See this project&#39;s &lt;code&gt;package.yaml&lt;/code&gt; or &lt;code&gt;static-ls.cabal&lt;/code&gt; for examples&lt;/p&gt; &lt;p&gt;For better re-indexing while editing &lt;code&gt;-fdefer-type-errors&lt;/code&gt; is also recommended - note however that this will cause type errors to be surfaced as warnings but will allow hie files to be regenerated on a failed compile&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Index your project in hiedb running &lt;code&gt;hiedb -D .hiedb index .hiefiles --src-base-dir .&lt;/code&gt; from your workspace root&lt;/li&gt; &#xA; &lt;li&gt;Point your language client to the &lt;code&gt;static-ls&lt;/code&gt; binary and begin editing! (See &lt;a href=&#34;https://raw.githubusercontent.com/josephsumabat/static-ls/main/#editor-setup&#34;&gt;Editor Setup&lt;/a&gt; for instructions if you&#39;re not sure how)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;code&gt;ghcid&lt;/code&gt; is recommended to refresh hie files&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;static-ls supports the following lsp methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;textDocument/references&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Note that find references only works on top level definitions and can be slow for functions which are used frequently&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/josephsumabat/static-ls/main/docs/gifs/find-references.gif&#34; alt=&#34;Find references&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;textDocument/hover&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Provides type information and definition location on hover&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/josephsumabat/static-ls/main/docs/gifs/hover.gif&#34; alt=&#34;Type on hover&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;textDocument/definition&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Works on both local and top level definitions&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/josephsumabat/static-ls/main/docs/gifs/find-definition.gif&#34; alt=&#34;Find definition&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Must be compiled on the same version of ghc as the project&lt;/li&gt; &#xA; &lt;li&gt;You will need to re-index your hie files once you edit your project&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Editor setup&lt;/h2&gt; &#xA;&lt;p&gt;Instructions for editor setup&lt;/p&gt; &#xA;&lt;h3&gt;neovim - coc.nvim&lt;/h3&gt; &#xA;&lt;p&gt;call &lt;code&gt;:CocConfig&lt;/code&gt; and copy the following in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;  &#34;languageserver&#34;: {&#xA;    &#34;static-ls&#34;: {&#xA;      &#34;command&#34;: &#34;static-ls&#34;,&#xA;      &#34;rootPatterns&#34;: [&#34;*.cabal&#34;, &#34;stack.yaml&#34;, &#34;cabal.project&#34;, &#34;package.yaml&#34;, &#34;hie.yaml&#34;],&#xA;      &#34;filetypes&#34;: [&#34;haskell&#34;]&#xA;    },&#xA;  },&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>marvinborner/bruijn</title>
    <updated>2023-04-12T02:25:50Z</updated>
    <id>tag:github.com,2023-04-12:/marvinborner/bruijn</id>
    <link href="https://github.com/marvinborner/bruijn" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üßÆ Programming language based on pure bruijn-indexed lambda calculus and strong call-by-need reduction using abstract machines&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;200&#34; src=&#34;https://raw.githubusercontent.com/marvinborner/bruijn/main/docs/res/logo.png&#34; alt=&#34;Bruijn logo&#34;&gt; &lt;/p&gt; &#xA;&lt;h1 align=&#34;center&#34;&gt; bruijn &lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;A purely academic programming language based on lambda calculus and De Bruijn indices written in Haskell.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marvinborner/bruijn/main/#Examples&#34;&gt;Jump to examples&lt;/a&gt; or use the navigation tree to jump to other sections.&lt;/p&gt; &#xA;&lt;p&gt;Docs, examples and more: &lt;a href=&#34;https://bruijn.marvinborner.de&#34;&gt;website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;De Bruijn indices&lt;a href=&#34;https://raw.githubusercontent.com/marvinborner/bruijn/main/#References&#34;&gt;[0]&lt;/a&gt;&lt;/strong&gt; eliminate the complexity of Œ±-equivalence and Œ±-conversion&lt;/li&gt; &#xA; &lt;li&gt;Unique &lt;strong&gt;bracket-style representation&lt;/strong&gt; for lambda abstractions enables improved human-readability and faster syntactic perception&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Call-by-need&lt;/strong&gt; reduction with mostly linear time/memory complexity by using the RKNL&lt;a href=&#34;https://raw.githubusercontent.com/marvinborner/bruijn/main/#References&#34;&gt;[4]&lt;/a&gt; abstract machine (similar to &lt;a href=&#34;https://github.com/marvinborner/calm/&#34;&gt;calm&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Syntactic sugar&lt;/strong&gt; for unary/binary/ternary numerals and binary-encoded strings and chars&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;No primitive functions&lt;/strong&gt; - every function is implemented in Bruijn itself&lt;/li&gt; &#xA; &lt;li&gt;Highly space-efficient compilation to &lt;strong&gt;binary lambda calculus (BLC)&lt;a href=&#34;https://raw.githubusercontent.com/marvinborner/bruijn/main/#References&#34;&gt;[2]&lt;/a&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marvinborner/bruijn/main/#References&#34;&gt;[3]&lt;/a&gt;&lt;/strong&gt; additionally to normal interpretation and REPL&lt;/li&gt; &#xA; &lt;li&gt;Strongly &lt;strong&gt;opinionated parser&lt;/strong&gt; with strict syntax rules&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Recursion&lt;/strong&gt; can be implemented using combinators such as Y, Z or œâ&lt;/li&gt; &#xA; &lt;li&gt;Substantial &lt;strong&gt;standard library&lt;/strong&gt; featuring many useful functions (see &lt;code&gt;std/&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Basics&lt;/h2&gt; &#xA;&lt;h3&gt;De Bruijn indices&lt;/h3&gt; &#xA;&lt;p&gt;De Bruijn indices&lt;a href=&#34;https://raw.githubusercontent.com/marvinborner/bruijn/main/#References&#34;&gt;[0]&lt;/a&gt; replace the concept of variables in lambda calculus. The index basically represents the abstraction layer you want to reference beginning at 0 with the innermost layer.&lt;/p&gt; &#xA;&lt;p&gt;For example, Œªx.x becomes Œª0 because x referenced the first abstraction layer. Furthermore, Œªx.Œªy.xy becomes ŒªŒª10 and so forth.&lt;/p&gt; &#xA;&lt;p&gt;You can read more about De Bruijn indices on &lt;a href=&#34;https://en.wikipedia.org/wiki/De_Bruijn_index&#34;&gt;Wikipedia&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Syntax&lt;/h3&gt; &#xA;&lt;p&gt;In general the syntax of bruijn is pretty similar to the previously presented normal lambda calculus syntax with De Bruijn indices. The main difference of the syntax of expressions is the usage of square brackets instead of Œªs (e.g.&amp;nbsp;&lt;code&gt;[[1 0]]&lt;/code&gt; instead of ŒªŒª10).&lt;/p&gt; &#xA;&lt;p&gt;You can use any function that you‚Äôve previously defined. You can also overwrite previously defined functions. The environment gets interpreted from bottom to top (starting at &lt;code&gt;main&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The following are the main syntax specifications in the (minorly extended) &lt;a href=&#34;https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form&#34;&gt;Backus-Naur form&lt;/a&gt; (prefix/infix/mixfix operators are omitted for simplicity).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;identifier&amp;gt;  ::= [a-œâ,A-Œ©,_][a-œâ,A-Œ©,0-9,?,!,&#39;,-]*&#xA;&amp;lt;namespace&amp;gt;   ::= [A-Œ©][a-œâ,A-Œ©]+&#xA;&amp;lt;abstraction&amp;gt; ::= &#34;[&#34; &amp;lt;expression&amp;gt; &#34;]&#34;&#xA;&amp;lt;number&amp;gt;      ::= (&#34;+&#34; | &#34;-&#34;)[0-9]+[u|b|t]&#xA;&amp;lt;bruijn&amp;gt;      ::= [0-9]&#xA;&amp;lt;singleton&amp;gt;   ::= &amp;lt;bruijn&amp;gt; | &amp;lt;number&amp;gt; | &amp;lt;abstraction&amp;gt; | &#34;(&#34; &amp;lt;application&amp;gt; &#34;)&#34; | [namespace.]&amp;lt;identifier&amp;gt;&#xA;&amp;lt;application&amp;gt; ::= &amp;lt;singleton&amp;gt; &amp;lt;singleton&amp;gt;&#xA;&amp;lt;expression&amp;gt;  ::= &amp;lt;application&amp;gt; | &amp;lt;singleton&amp;gt;&#xA;&amp;lt;test&amp;gt;        ::= &#34;:test &#34; &#34;(&#34; &amp;lt;expression&amp;gt; &#34;) (&#34; &amp;lt;expression&amp;gt; &#34;)&#34;&#xA;&amp;lt;import&amp;gt;      ::= &#34;:import &#34; &amp;lt;path&amp;gt; [namespace]&#xA;&amp;lt;input&amp;gt;       ::= &#34;:input &#34; &amp;lt;path&amp;gt;&#xA;&amp;lt;comment&amp;gt;     ::= &#34;# &#34; &amp;lt;letter&amp;gt;*&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Differences in syntax between REPL and file:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;For files&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;p&gt;The execution of a file begins at the &lt;code&gt;main&lt;/code&gt; function. Its existence is mandatory. Note the missing equal sign in definitions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;definition&amp;gt; ::= &amp;lt;identifier&amp;gt; &amp;lt;expression&amp;gt;&#xA;&amp;lt;line&amp;gt;       ::= &amp;lt;definition&amp;gt; | &amp;lt;comment&amp;gt; | &amp;lt;import&amp;gt; | &amp;lt;test&amp;gt; | &#34;\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;For REPL&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;definition&amp;gt; ::= &amp;lt;identifier&amp;gt; = &amp;lt;expression&amp;gt;&#xA;&amp;lt;watch&amp;gt;      ::= &#34;:watch &#34; &amp;lt;path&amp;gt;&#xA;&amp;lt;time&amp;gt;       ::= &#34;:time &#34; &amp;lt;expression&amp;gt;&#xA;&amp;lt;free&amp;gt;       ::= &#34;:free&#34;&#xA;&amp;lt;line&amp;gt;       ::= &amp;lt;definition&amp;gt; | &amp;lt;expression&amp;gt; | &amp;lt;comment&amp;gt; | &amp;lt;import&amp;gt; | &amp;lt;watch&amp;gt; | &amp;lt;test&amp;gt; | &amp;lt;time&amp;gt; | &amp;lt;free&amp;gt; | &#34;\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Numbers&lt;/h3&gt; &#xA;&lt;p&gt;Numbers in bruijn always have a sign in front of them or else they will be mistaken for De Bruijn indices. They also need to be between parenthesis because of prefix functions. You can then enter a character indicating the desired base of the number.&lt;/p&gt; &#xA;&lt;p&gt;Generally the decimal representation is only syntactic sugar for a lambda calculus encoding. The default base is balanced ternary because it‚Äôs a great compromise between performance and size (according to &lt;a href=&#34;https://raw.githubusercontent.com/marvinborner/bruijn/main/#References&#34;&gt;[1]&lt;/a&gt;). The currently supported base suffixes are ‚Äòt‚Äô for balanced ternary (default), ‚Äòb‚Äô for binary and ‚Äòu‚Äô for unary (church-encoded).&lt;/p&gt; &#xA;&lt;p&gt;You don‚Äôt have to care about the internals too much though as long as you use the included operations from the standard library (&lt;code&gt;std/Number/&lt;/code&gt;). The REPL even tries its best at displaying decimal numbers directly for expressions that look like numbers.&lt;/p&gt; &#xA;&lt;p&gt;For example, in the REPL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Œª (+42)&#xA;*&amp;gt; [[[[(0 (2 (2 (2 (1 3)))))]]]]&#xA;?&amp;gt; 42t&#xA;&#xA;Œª (+42b)&#xA;*&amp;gt; [[[(0 (1 (0 (1 (0 (1 2))))))]]]&#xA;?&amp;gt; 42b&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Standard library&lt;/h3&gt; &#xA;&lt;p&gt;You may want to use the included standard library to reach your program‚Äôs full potential. It includes many common combinators as well as functions for numerical, boolean and IO operations and much more.&lt;/p&gt; &#xA;&lt;p&gt;For example, you can import the standard library for numbers using &lt;code&gt;:import std/Number&lt;/code&gt;. You can find all available libraries in the &lt;code&gt;std/&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h3&gt;Broogle&lt;/h3&gt; &#xA;&lt;p&gt;You can use the broogle script (inspired by Haskell‚Äôs hoogle) to search for standard library functions by type, name or comment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./broogle.sh -t &#34;a -&amp;gt; a&#34;&#xA;./broogle.sh -f &#34;i&#34;&#xA;./broogle.sh -c &#34;idiot combinator&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The script uses the dependencies &lt;code&gt;rg&lt;/code&gt;, &lt;code&gt;jq&lt;/code&gt;, &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;awk&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;p&gt;You can find more ‚Äúreal world‚Äù examples here: &lt;a href=&#34;https://raw.githubusercontent.com/marvinborner/bruijn/main/samples&#34;&gt;samples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can try these by experimenting in the REPL or by running them as a file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Remember&lt;/strong&gt; that you need an equal sign between the function name and its definition if you‚Äôre using the REPL.&lt;/p&gt; &#xA;&lt;h4&gt;Plain execution without any predefined functions&lt;/h4&gt; &#xA;&lt;p&gt;Without using its standard library bruijn is basically unmodified pure lambda calculus with syntactically sugared numerals, strings and chars. Bruijn doesn‚Äôt support any numerical operations or any other infix/prefix functions by default. Using it without its standard library can be quite fun, though - especially for exploring and understanding the logic of lambda calculus:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# this is a comment&#xA;# we now define a function returning a ternary 1 (syntactic sugar)&#xA;get-one (+1)&#xA;&#xA;# we can use the function in all functions below its definition&#xA;get-one2 get-one&#xA;&#xA;# tests are similar to assertions in other languages&#xA;# they test equality using Œ±-equivalence of reduced expressions&#xA;# in this example they&#39;re used to show the reduced expressions&#xA;:test (get-one2) ((+1))&#xA;&#xA;# remember that numbers always need to be written in parenthesis&#xA;# therefore two braces are needed in tests because testing exprs&#xA;# must always be in parenthesis as well&#xA;&#xA;# indenting acts similarly to Haskell&#39;s where statement&#xA;get-one3 foo&#xA;    bar (+1)&#xA;    foo bar&#xA;&#xA;# equivalent of Œªx.x or Haskell&#39;s id x = x&#xA;id [0]&#xA;&#xA;# testing equivalent of (Œªx.x) (Œªx.Œªy.x) = Œªx.Œªy.x&#xA;# the numbers in the abstractions refer to arguments using&#xA;# De Bruijn indices&#xA;:test (id [[1]]) ([[1]])&#xA;&#xA;# prefix function definition&#xA;!‚Ä£ [[1]]&#xA;&#xA;# use prefix function &#39;!&#39;&#xA;# ![0] becomes ([[1]] [0]) which in turn becomes [[0]]&#xA;:test (![0]) ([[0]])&#xA;&#xA;# infix function definition: flip and apply arguments&#xA;‚Ä¶&amp;lt;&amp;gt;‚Ä¶ [[0 1]]&#xA;&#xA;# use infix function &#39;&amp;lt;&amp;gt;&#39;&#xA;# [[0]] &amp;lt;&amp;gt; [[1]] becomes (([[0 1]] [[0]]) [[1]])&#xA;:test ([[0]] &amp;lt;&amp;gt; [[1]]) ([[1]] [[0]])&#xA;&#xA;# multiple arguments&#xA;number-set set-of-three (+1) (+2) (+3)&#xA;    set-of-three [[[[0 1 2 3]]]]&#xA;&#xA;access-first [0 [[[0]]]]&#xA;&#xA;:test (access-first number-set) ((+1))&#xA;&#xA;# ignore args and return string &#xA;main [&#34;Hello world!\n&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Using standard library&lt;/h4&gt; &#xA;&lt;p&gt;Concatenating ‚ÄúHello world‚Äù program using IO (the first argument of the &lt;code&gt;main&lt;/code&gt; function is a binary representation of stdin):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:import std/List .&#xA;&#xA;main [&#34;Hello &#34; ++ 0 ++ &#34;!\n&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then use &lt;code&gt;printf &#34;world&#34; | bruijn file.bruijn&lt;/code&gt; to get ‚ÄúHello world!‚Äù&lt;/p&gt; &#xA;&lt;p&gt;Some other great functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:import std/Combinator .&#xA;:import std/List .&#xA;:import std/Logic .&#xA;:import std/Number .&#xA;:import std/Option .&#xA;:import std/Pair .&#xA;&#xA;# pairs with some values&#xA;love pair me you&#xA;    me [[[1]]]&#xA;    you [[[2]]]&#xA;&#xA;:test (fst love) ([[[1]]])&#xA;:test (snd love) ([[[2]]])&#xA;&#xA;# you can also write (me : you) instead of (pair me you)&#xA;# also (^love) and (~love) instead of (fst love) and (snd love)&#xA;&#xA;# numerical operations&#xA;# remember that every mixfix chain is left-associative&#xA;five --((+8) + (-4) - (-2))&#xA;&#xA;not-five? [if (0 =? (+5)) false true]&#xA;&#xA;# awesome mixfix functions&#xA;:test (‚àë (+1) ‚Üí (+3) | [++0]) ((+9))&#xA;:test (‚àè (+1) ‚Üí (+3) | [++0]) ((+24))&#xA;&#xA;:test (not-five? five) (false)&#xA;&#xA;:test ((uncurry mul (pair (+3) (+2))) =? (+6)) (true)&#xA;&#xA;# lazy evaluation using infinite lists and indexing&#xA;pow2 ‚Ä¶!!‚Ä¶ (iterate (‚Ä¶‚ãÖ‚Ä¶ (+2)) (+1))&#xA;&#xA;:test ((pow2 (+5)) =? (+32)) (true)&#xA;&#xA;# options&#xA;:test (map inc (some (+1))) (some (+2))&#xA;:test (apply (some (+1)) [some ++0]) (some (+2))&#xA;&#xA;# boolean&#xA;# the main function gets executed automatically&#xA;# ignore stdin arguments by not referencing 0&#xA;main [¬¨(false ‚ãÄ? true ‚ãÅ? true)]&#xA;&#xA;:test (main [0]) (false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Read the files in &lt;code&gt;std/&lt;/code&gt; for an overview of all functions/libraries or visit the interactive &lt;a href=&#34;https://bruijn.marvinborner.de&#34;&gt;website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Compilation to BLC&lt;/h3&gt; &#xA;&lt;p&gt;You can compile bruijn to John Tromp‚Äôs BLC&lt;a href=&#34;https://raw.githubusercontent.com/marvinborner/bruijn/main/#References&#34;&gt;[2]&lt;/a&gt;&lt;a href=&#34;https://raw.githubusercontent.com/marvinborner/bruijn/main/#References&#34;&gt;[3]&lt;/a&gt;. Only the used functions actually get compiled in order to achieve a minimal binary size.&lt;/p&gt; &#xA;&lt;p&gt;BLC uses the following encoding:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;term&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;lambda&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;bruijn&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;BLC&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;abstraction&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;ŒªM&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;[M]&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;00M&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;MN&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;MN&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;01MN&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;bruijn index&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;i&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;i&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;1&lt;sup&gt;i+1&lt;/sup&gt;0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You first need to install Haskell and Haskell Stack using the guidelines of your operating system.&lt;/p&gt; &#xA;&lt;p&gt;Using Haskell Stack, run &lt;code&gt;stack run&lt;/code&gt; or &lt;code&gt;stack run -- [args]&lt;/code&gt; to play around and use &lt;code&gt;stack install&lt;/code&gt; to install bruijn into your path.&lt;/p&gt; &#xA;&lt;h2&gt;REPL config&lt;/h2&gt; &#xA;&lt;p&gt;You can configure the REPL by editing the &lt;code&gt;config&lt;/code&gt; file. &lt;code&gt;stack install&lt;/code&gt; or &lt;code&gt;stack run&lt;/code&gt; will move the file into a data directory.&lt;/p&gt; &#xA;&lt;p&gt;More options can be found &lt;a href=&#34;https://github.com/judah/haskeline/wiki/UserPreferences&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Please read the usage information in the executable by using the &lt;code&gt;-h&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;De Bruijn, Nicolaas Govert. ‚ÄúLambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser theorem.‚Äù Indagationes Mathematicae (Proceedings). Vol. 75. No.&amp;nbsp;5. North-Holland, 1972.&lt;/li&gt; &#xA; &lt;li&gt;Mogensen, Torben. ‚ÄúAn investigation of compact and efficient number representations in the pure lambda calculus.‚Äù International Andrei Ershov Memorial Conference on Perspectives of System Informatics. Springer, Berlin, Heidelberg, 2001.&lt;/li&gt; &#xA; &lt;li&gt;Tromp, John. ‚ÄúBinary lambda calculus and combinatory logic.‚Äù Randomness and Complexity, from Leibniz to Chaitin. 2007. 237-260.&lt;/li&gt; &#xA; &lt;li&gt;Tromp, John. ‚ÄúFunctional Bits: Lambda Calculus based Algorithmic Information Theory.‚Äù (2022).&lt;/li&gt; &#xA; &lt;li&gt;Biernacka, M., Charatonik, W., &amp;amp; Drab, T. (2022). A simple and efficient implementation of strong call by need by an abstract machine. Proceedings of the ACM on Programming Languages, 6(ICFP), 109-136.&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>thoferon/question_mark</title>
    <updated>2023-04-12T02:25:50Z</updated>
    <id>tag:github.com,2023-04-12:/thoferon/question_mark</id>
    <link href="https://github.com/thoferon/question_mark" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Stylish test framework for Haskell (just for fun, my first code in Haskell)&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>