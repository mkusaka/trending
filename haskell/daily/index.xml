<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-09T01:35:37Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>markandrus/DX1</title>
    <updated>2023-04-09T01:35:37Z</updated>
    <id>tag:github.com,2023-04-09:/markandrus/DX1</id>
    <link href="https://github.com/markandrus/DX1" rel="alternate"></link>
    <summary type="html">&lt;p&gt;DX1&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DX1&lt;/h1&gt; &#xA;&lt;p&gt;For better-looking documentation, run &lt;code&gt;haddock -h DX1.hs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Format&lt;/h2&gt; &#xA;&lt;p&gt;Every line of a &lt;code&gt;.dx1&lt;/code&gt; file contains a word, its number of occurrences (in the corpus it originates from), and its pronunciation (as a sequence of phonemes). Typically, this data is encoded in the form of a space-separated string. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; A 23310 AH0&#xA; AARON 8 EH1 R AH0 N&#xA; ABANDON 18 AH0 B AE1 N D AH0 N&#xA; ABANDONED 26 AH0 B AE1 N D AH0 N D&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the interest of robustness, this library supports tab-separation between a word&#39;s name, count, and pronunciation, as well as both &lt;code&gt;DOS&lt;/code&gt;- and &lt;code&gt;UNIX&lt;/code&gt;-style newlines.&lt;/p&gt; &#xA;&lt;h3&gt;data DX1Entry&lt;/h3&gt; &#xA;&lt;p&gt;Stores a word, its number of occurrences, and its phonemes.&lt;/p&gt; &#xA;&lt;h4&gt;Instances&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Eq DX1Entry&lt;/li&gt; &#xA; &lt;li&gt;Read DX1Entry&lt;/li&gt; &#xA; &lt;li&gt;Show DX1Entry&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Calculations&lt;/h2&gt; &#xA;&lt;h3&gt;sumCounts :: [DX1Entry] -&amp;gt; Int&lt;/h3&gt; &#xA;&lt;p&gt;Sum the counts of each &lt;code&gt;DX1Entry&lt;/code&gt; in a list.&lt;/p&gt; &#xA;&lt;h3&gt;frequencies :: [DX1Entry] -&amp;gt; [(DX1Entry, Float)]&lt;/h3&gt; &#xA;&lt;p&gt;Pair each &lt;code&gt;DX1Entry&lt;/code&gt; in a list with its frequency.&lt;/p&gt; &#xA;&lt;h3&gt;sortedFrequencies :: [DX1Entry] -&amp;gt; [(DX1Entry, Float)]&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;O(nlog n)&lt;/em&gt;. Sort each &lt;code&gt;DX1Entry&lt;/code&gt; in a list by its frequency.&lt;/p&gt; &#xA;&lt;h2&gt;Parser&lt;/h2&gt; &#xA;&lt;h3&gt;parseDX1 :: String -&amp;gt; Either ParseError [DX1Entry]&lt;/h3&gt; &#xA;&lt;p&gt;Parses a &lt;code&gt;.dx1&lt;/code&gt; file to a list of &lt;code&gt;DX1Entry&lt;/code&gt;s (uses &lt;code&gt;Parsec&lt;/code&gt; internally).&lt;/p&gt; &#xA;&lt;h2&gt;Example Program&lt;/h2&gt; &#xA;&lt;h3&gt;main :: IO ()&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;O(nlog n)&lt;/em&gt;. Parses a &lt;code&gt;.dx1&lt;/code&gt; file from &lt;code&gt;stdin&lt;/code&gt; or a given filename, computes the frequency of each word, sorts by frequency in ascending order, and prints the result.&lt;/p&gt; &#xA;&lt;p&gt;Produced by &lt;a href=&#34;http://www.haskell.org/haddock/&#34;&gt;Haddock&lt;/a&gt; version 2.11.0. Munged by &lt;a href=&#34;http://johnmacfarlane.net/pandoc&#34;&gt;Pandoc&lt;/a&gt; version 1.9.4.2. Cleaned by hand.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tonyday567/prettychart</title>
    <updated>2023-04-09T01:35:37Z</updated>
    <id>tag:github.com,2023-04-09:/tonyday567/prettychart</id>
    <link href="https://github.com/tonyday567/prettychart" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;prettychart&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;[[https://hackage.haskell.org/package/prettychart][https://img.shields.io/hackage/v/prettychart.svg]]&lt;/p&gt; &#xA;&lt;p&gt;This library contains:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A chart server, for use in conjunction with ghci, or other live coding situations. (See Chartpretty.Server)&lt;/li&gt; &#xA; &lt;li&gt;anyChart, which attempts to convert text (of numbers) to a chart. (See Chartpretty.Any)&lt;/li&gt; &#xA; &lt;li&gt;Some useful chart patterns that didn&#39;t make the cut in chart-svg (See Chartpretty.Charts)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage ** ghci integration&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Add this to your .ghci.conf file to automatically go into :prettychart mode.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output -- :set -package prettychart :{ :def! prettychart _ -&amp;gt; pure $ unlines [ &#34;import Prettychart&#34;, &#34;(sendChart, quitChartServer) &amp;lt;- startChartServer&#34;, &#34;printc=printChart False sendChart&#34;, &#34;:set -interactive-print printc&#34; ] :}&lt;/p&gt; &#xA;&lt;p&gt;:{ :def! noprettychart _ -&amp;gt; pure $ unlines [ &#34;quitChartServer&#34;, &#34;:set -interactive-print print&#34; ] :}&lt;/p&gt; &#xA;&lt;p&gt;:prettychart #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output [1..200] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output :noprettychart #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** live coding&lt;/p&gt; &#xA;&lt;p&gt;The server can also be used to view and develop chart-svg charts.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;(sendChart, quitChartServer) &amp;lt;- startChartServer Setting phaser&amp;gt;s to stun... (port 9160) (ctrl-c to quit)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;-- open localhost:9160 -- developing and sending a chart to the server&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;import Chart.Examples sendChart $ lineExample&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;quitServer [1..10] [1,2,3,4,5,6,7,8,9,10]&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Development&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output :r :set prompt &#34;&amp;gt; &#34; :set -Wno-type-defaults :set -Wno-name-shadowing :set -XOverloadedStrings :set -XTupleSections :set -XOverloadedLabels import Chart hiding (quantiles) import Optics.Core import Prettychart.Charts import Prettychart.Any import Prettychart.ExampleData import Prettychart.Server import Web.Rep import Box import FlatParse.Basic hiding (take) import Data.Time.Calendar import Data.Mealy import Data.Maybe import Data.Bifunctor import NumHask.Space hiding (quantiles) import qualified Data.Map as Map import Data.FormatN import Data.Text (Text,pack) import qualified Data.Text as Text import qualified Data.Text.IO as Text import Data.Time import Data.Mealy.Quantiles import qualified Data.List as List import Control.Category ((&amp;gt;&amp;gt;&amp;gt;)) import Data.Profunctor print &#34;ok&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : [1 of 5] Compiling Prettychart.Charts ( src/Prettychart/Charts.hs, interpreted ) [Source file changed] : Ok, five modules loaded. : &amp;gt; : &amp;gt; : &amp;gt; : ok&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Prettychart.Any Examples ** single list&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** 10 or less elements =&amp;gt; bar chart&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell xs = [0..9] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/list1a.svg :results output graphics file :exports both either Text.putStrLn (writeChartOptions &#34;other/list1a.svg&#34;) $ anyChart (pack . show $ xs) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/list1a.svg]]&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output either Text.putStrLn (writeChartOptions &#34;other/list1a.svg&#34;) $ anyChart (pack . show $ xs) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** &amp;gt;1000 elements =&amp;gt; histogram&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell xs = sin &amp;lt;$&amp;gt; [0..2000] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/list1b.svg :results output graphics file :exports both either Text.putStrLn (writeChartOptions &#34;other/list1b.svg&#34;) $ anyChart (pack . show $ xs) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/list1b.svg]]&lt;/p&gt; &#xA;&lt;p&gt;*** &amp;lt; 1000 &amp;amp;&amp;amp; &amp;gt; 10 =&amp;gt; line chart&lt;/p&gt; &#xA;&lt;p&gt;In between goes for a line chartIn between goes for a line chart.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell xs = sin . (/100) &amp;lt;$&amp;gt; [0..500] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/list1c.svg :results output graphics file :exports both either Text.putStrLn (writeChartOptions &#34;other/list1c.svg&#34;) $ anyChart (pack . show $ xs) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/list1c.svg]]&lt;/p&gt; &#xA;&lt;p&gt;** double list *** &amp;lt; 4 lists &amp;amp;&amp;amp; &amp;lt; 10 values per list =&amp;gt; bar chart&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output xs = [(1+) . sin &amp;lt;$&amp;gt; [0..8], (1+) . cos &amp;lt;$&amp;gt; [0..8]] xs #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : [[1.0,1.8414709848078965,1.9092974268256817,1.1411200080598671,0.2431975046920718,4.1075725336861546e-2,0.7205845018010741,1.656986598718789,1.989358246623382],[2.0,1.5403023058681398,0.5838531634528576,1.0007503399554585e-2,0.34635637913638806,1.2836621854632262,1.960170286650366,1.7539022543433047,0.8544999661913865]]&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/dlista.svg :results output graphics file :exports both either Text.putStrLn (writeChartOptions &#34;other/dlista.svg&#34;) $ anyChart (pack . show $ xs) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/dlista.svg]]&lt;/p&gt; &#xA;&lt;p&gt;*** square =&amp;gt; surface chart&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output iter2 f xs ys = f &amp;lt;$&amp;gt; xs &amp;lt;&amp;amp;&amp;gt; flip fmap ys -- or (\a -&amp;gt; f a &amp;lt;$&amp;gt; ys) &amp;lt;$&amp;gt; xs xs = iter2 (*) (fmap sin [1..20]) (fmap cos [1..20]) :: [[Double]] :t xs length xs fmap length xs #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : xs :: [[Double]] : 20 : [20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20]&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/dlistb.svg :results output graphics file :exports both either Text.putStrLn (writeChartOptions &#34;other/dlistb.svg&#34;) $ anyChart (pack . show $ xs) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/dlistb.svg]]&lt;/p&gt; &#xA;&lt;p&gt;** tuple list [(Double, Double)] =&amp;gt; scatter&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output xs = zip (fmap (sin . (0.06*)) [1..100]) (fmap (cos . (0.06*)) [1..100]) :t xs #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : xs : :: (TrigField b1, TrigField b2, Fractional b1, Fractional b2, : Enum b1, Enum b2) =&amp;gt; : [(b1, b2)]&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/dtuple.svg :results output graphics file :exports both either Text.putStrLn (writeChartOptions &#34;other/dtuple.svg&#34;) $ anyChart (pack . show $ xs) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/dtuple.svg]]&lt;/p&gt; &#xA;&lt;p&gt;** double tuple list [(Double, Double)] =&amp;gt; scatter&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output iter2 f xs ys = f &amp;lt;$&amp;gt; xs &amp;lt;&amp;amp;&amp;gt; flip fmap ys -- or (\a -&amp;gt; f a &amp;lt;$&amp;gt; ys) &amp;lt;$&amp;gt; xs&lt;/p&gt; &#xA;&lt;p&gt;xs = iter2 (\s (x,y) -&amp;gt; (s&lt;em&gt;x, s&lt;/em&gt;y)) ((0.1*) &amp;lt;$&amp;gt; [1..10]) (zip (fmap (sin . (0.06*)) [1..100]) (fmap (cos . (0.06*)) [1..100])) :t xs #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : &amp;gt; &amp;gt; : xs :: (Fractional b, Enum b, TrigField b) =&amp;gt; [[(b, b)]]&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/dtupleb.svg :results output graphics file :exports both either Text.putStrLn (writeChartOptions &#34;other/dtupleb.svg&#34;) $ anyChart (pack . show $ xs) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/dtupleb.svg]]&lt;/p&gt; &#xA;&lt;p&gt;** (Text, Double) tuple list&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell xs = (\x -&amp;gt; (show x, x)) &amp;lt;$&amp;gt; [0..9] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: #+begin_src haskell :file other/tdtuple.svg :results output graphics file :exports both either Text.putStrLn (writeChartOptions &#34;other/tdtuple.svg&#34;) $ anyChart (pack . show $ xs) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/tdtuple.svg]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Prettychart.Charts Examples ** Example data&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output r &amp;lt;- getReturns length r accret = scan (second&#39; (dipure (+))) r decay = 0.004 rs = snd &amp;lt;$&amp;gt; r xma = scan (ma decay) rs xstd = scan (std decay) rs #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : 10897&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output xify [1..3] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : [Point 0.0 1.0,Point 1.0 2.0,Point 2.0 3.0]&lt;/p&gt; &#xA;&lt;p&gt;** simpleLineChart&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output c = simpleLineChart 0.01 (palette1 2) (snd &amp;lt;$&amp;gt; accret) xaxis = (5, timeXAxis 8 ((\x -&amp;gt; UTCTime x 0) . fst &amp;lt;$&amp;gt; accret)) yaxis = (5, defaultAxisOptions &amp;amp; #place .~ PlaceLeft &amp;amp; #ticks % #style .~ TickRound (FormatN FSPercent (Just 2) 4 True True) 6 TickExtend) h = defaultHudOptions &amp;amp; #titles .~ (titles3 8 (&#34;Simple Line Example&#34;, &#34;&#34;, &#34;accumulated return&#34;)) &amp;amp; #axes .~ [xaxis, yaxis] simpleLine = mempty &amp;amp; #charts .~ named &#34;line&#34; [c] &amp;amp; #hudOptions .~ h :: ChartOptions #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/simpleline.svg :results output graphics file :exports both writeChartOptions &#34;other/simpleline.svg&#34; simpleLine #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/simpleline.svg]]&lt;/p&gt; &#xA;&lt;p&gt;** histChart&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/hist.svg :results output graphics file :exports both writeChartOptions &#34;other/hist.svg&#34; $ histChart (Range (-0.04) 0.04) 40 xma #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/hist.svg]]&lt;/p&gt; &#xA;&lt;p&gt;** scatterChart&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell maVstd = zipWith Point (taker 500 xma) (taker 500 xstd) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output c = scatterChart [maVstd] xaxis = (5, defaultAxisOptions &amp;amp; #place .~ PlaceBottom &amp;amp; #ticks % #style .~ TickRound (FormatN FSPercent (Just 2) 4 True True) 6 TickExtend) yaxis = (5, defaultAxisOptions &amp;amp; #place .~ PlaceLeft &amp;amp; #ticks % #style .~ TickRound (FormatN FSPercent (Just 2) 4 True True) 6 TickExtend) h = defaultHudOptions &amp;amp; #titles .~ (titles3 8 (&#34;scatter&#34;, &#34;ma&#34;, &#34;std&#34;)) &amp;amp; #axes .~ [xaxis, yaxis] xsChart = mempty &amp;amp; #charts .~ unnamed c &amp;amp; #hudOptions .~ h :: ChartOptions #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/scatter.svg :results output graphics file :exports both writeChartOptions &#34;other/scatter.svg&#34; xsChart #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/scatter.svg]] ** quantileChart&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output qs = [0.01, 0.1, 0.5, 0.9, 0.99] qss = fmap (taker 1000) $ List.transpose $ scan (Data.Mealy.Quantiles.quantiles 0.99 qs) (snd &amp;lt;$&amp;gt; r) c = quantileChart (quantileNames qs) ( blendMidLineStyles (length qss) 0.005 (Colour 0.7 0.1 0.3 0.5, Colour 0.1 0.4 0.8 1)) qss xaxis = (5, timeXAxis 8 (taker 1000 $ (\x -&amp;gt; UTCTime x 0) . fst &amp;lt;$&amp;gt; accret)) yaxis = (5, defaultAxisOptions &amp;amp; #place .~ PlaceLeft &amp;amp; #ticks % #style .~ TickRound (FormatN FSPercent (Just 2) 4 True True) 6 TickExtend) c&#39; = c &amp;amp; (#hudOptions % #axes) .~ [xaxis,yaxis] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/quantile.svg :results output graphics file :exports both writeChartOptions &#34;other/quantile.svg&#34; c&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/quantile.svg]]&lt;/p&gt; &#xA;&lt;p&gt;** quantileHistChart&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output qs = [0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.99] qslast = Data.Mealy.fold (Data.Mealy.Quantiles.quantiles 0.99 qs) (snd &amp;lt;$&amp;gt; r) c = quantileHistChart (Just $ quantileNames qs) qs qslast #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/qhist.svg :results output graphics file :exports both writeChartOptions &#34;other/qhist.svg&#34; c #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/qhist.svg]]&lt;/p&gt; &#xA;&lt;p&gt;** digitChart&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output qs = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9] digits = scan (digitize 0.99 qs) (snd &amp;lt;$&amp;gt; taker 1000 r) c = digitChart ((\x -&amp;gt; UTCTime x 0) . fst &amp;lt;$&amp;gt; taker 1000 r) (fromIntegral &amp;lt;$&amp;gt; digits) (quantileNames qs) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/digit.svg :results output graphics file :exports both writeChartOptions &#34;other/digit.svg&#34; c #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/digit.svg]]&lt;/p&gt; &#xA;&lt;p&gt;** digitSurfaceChart&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    #+begin_src haskell :results output&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;qs = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1] d1 = ((,) &amp;lt;$&amp;gt; (ma 0.95 &amp;gt;&amp;gt;&amp;gt; digitize 0.99 qs) &amp;lt;*&amp;gt; (std 0.95 &amp;gt;&amp;gt;&amp;gt; digitize 0.99 qs)) :t d1 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : d1 :: Mealy Double (Int, Int)&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output ds = taker 5000 $ scan d1 (snd &amp;lt;$&amp;gt; r) c = digitSurfaceChart defaultSurfaceStyle (defaultSurfaceLegendOptions dark &#34;&#34;) (&#34;ma versus std&#34;, &#34;ma&#34;, &#34;std&#34;) (quantileNames qs) ds #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :file other/digitsurface.svg :results output graphics file :exports both writeChartOptions &#34;other/digitsurface.svg&#34; $ mempty &amp;amp; #charts .~ c #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: [[file:other/digitsurface.svg]]&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output import Data.Foldable mapCount = foldl&#39; (\m x -&amp;gt; Map.insertWith (+) x 1.0 m) Map.empty ds #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src haskell :results output mapCount #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : fromList [((1,1),10.0),((1,2),12.0),((1,3),14.0),((1,4),21.0),((1,5),30.0),((1,6),42.0),((1,7),47.0),((1,8),45.0),((1,9),77.0),((1,10),195.0),((2,1),28.0),((2,2),29.0),((2,3),44.0),((2,4),51.0),((2,5),47.0),((2,6),58.0),((2,7),54.0),((2,8),46.0),((2,9),75.0),((2,10),99.0),((3,1),58.0),((3,2),53.0),((3,3),49.0),((3,4),45.0),((3,5),75.0),((3,6),37.0),((3,7),43.0),((3,8),45.0),((3,9),47.0),((3,10),45.0),((4,1),97.0),((4,2),65.0),((4,3),45.0),((4,4),49.0),((4,5),68.0),((4,6),37.0),((4,7),47.0),((4,8),41.0),((4,9),31.0),((4,10),34.0),((5,1),141.0),((5,2),88.0),((5,3),57.0),((5,4),48.0),((5,5),47.0),((5,6),45.0),((5,7),38.0),((5,8),43.0),((5,9),29.0),((5,10),28.0),((6,1),129.0),((6,2),101.0),((6,3),55.0),((6,4),39.0),((6,5),51.0),((6,6),43.0),((6,7),43.0),((6,8),28.0),((6,9),24.0),((6,10),23.0),((7,1),103.0),((7,2),73.0),((7,3),61.0),((7,4),51.0),((7,5),49.0),((7,6),38.0),((7,7),34.0),((7,8),24.0),((7,9),14.0),((7,10),8.0),((8,1),117.0),((8,2),99.0),((8,3),56.0),((8,4),62.0),((8,5),43.0),((8,6),35.0),((8,7),40.0),((8,8),29.0),((8,9),19.0),((8,10),9.0),((9,1),108.0),((9,2),65.0),((9,3),76.0),((9,4),49.0),((9,5),53.0),((9,6),48.0),((9,7),27.0),((9,8),15.0),((9,9),11.0),((9,10),9.0),((10,1),75.0),((10,2),37.0),((10,3),60.0),((10,4),55.0),((10,5),37.0),((10,6),80.0),((10,7),59.0),((10,8),23.0),((10,9),9.0),((10,10),5.0)]&lt;/p&gt;</summary>
  </entry>
</feed>