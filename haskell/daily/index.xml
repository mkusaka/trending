<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-01T01:38:15Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bgamari/b-tree</title>
    <updated>2022-10-01T01:38:15Z</updated>
    <id>tag:github.com,2022-10-01:/bgamari/b-tree</id>
    <link href="https://github.com/bgamari/b-tree" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell on-disk B* tree implementation&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;b-tree - Disk-backed B* trees&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;b-tree&lt;/code&gt; is a Haskell implementation of a disk-backed B* tree. The library uses streaming IO to write an immutable B-tree to disk from ordered keys. This tree can then be opened via mmap for lookups. The tree can also be iterated over as well as merged with other trees and leaf sources.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>input-output-hk/quickcheck-dynamic</title>
    <updated>2022-10-01T01:38:15Z</updated>
    <id>tag:github.com,2022-10-01:/input-output-hk/quickcheck-dynamic</id>
    <link href="https://github.com/input-output-hk/quickcheck-dynamic" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A library for stateful property-based testing&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;quickcheck-dynamic&lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://github.com/input-output-hk/quickcheck-dynamic/actions&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/input-output-hk/hydra-poc/CI&#34;&gt;&lt;/a&gt;&amp;nbsp; &#xA; &lt;a href=&#34;https://hackage.haskell.org/package/quickcheck-dynamic/&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/quickcheck-dynamic&#34;&gt;&lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;A library for testing stateful programs using &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;QuickCheck&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Dynamic_logic_(modal_logic)&#34;&gt;dynamic logic&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This repository hosts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The core &lt;a href=&#34;https://raw.githubusercontent.com/input-output-hk/quickcheck-dynamic/main/quickcheck-dynamic&#34;&gt;quickcheck-dynamic&lt;/a&gt; library providing tools for quickchecking stateful models,&lt;/li&gt; &#xA; &lt;li&gt;Example of integrating &lt;a href=&#34;https://github.com/input-output-hk/io-sim&#34;&gt;io-sim&lt;/a&gt;&#39;s Haskell runtime simulator and &lt;em&gt;quickcheck-dynamic&lt;/em&gt; to model and test complex multi-threaded application.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The original stateful testing approach is described in John Hughes&#39; research paper: &lt;a href=&#34;https://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf&#34;&gt;https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quviq-testing.pdf &lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://github.com/input-output-hk/quickcheck-dynamic/tree/main/quickcheck-io-sim-compat&#34;&gt;Registry example&lt;/a&gt; is a common case study that&#39;s been explored in two papers: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://publications.lib.chalmers.se/records/fulltext/232552/local_232552.pdf&#34;&gt;How well are your requirements tested?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;and &lt;a href=&#34;https://mengwangoxf.github.io/Papers/Erlang18.pdf&#34;&gt;Understanding Formal Specifications through Good Examples&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The dynamic logic addition allows you to specify that after a generated test sequence, the system is able to reach a specific required state. In other words, you can specify that some &#34;good&#34; state is reachable from any possible state.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following talks provide concrete examples on how this approach is used to test smart contracts in Plutus:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;John Hughes high level talk on how to test Plutus smart contracts using this library: &lt;a href=&#34;https://youtu.be/V9_14jjJiuQ&#34;&gt;https://youtu.be/V9_14jjJiuQ&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;55 minutes in to this lecture an example of using the state machine formalism: &lt;a href=&#34;https://www.youtube.com/watch?v=zW3D2iM5uVg&amp;amp;t=3300&#34;&gt;https://www.youtube.com/watch?v=zW3D2iM5uVg&amp;amp;t=3300&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Edsko de Vries wrote a &lt;a href=&#34;https://well-typed.com/blog/2022/09/lockstep-with-quickcheck-dynamic/&#34;&gt;nice blog post&lt;/a&gt; to compare &lt;code&gt;quickcheck-dynamic&lt;/code&gt; with &lt;a href=&#34;https://hackage.haskell.org/package/quickcheck-state-machine&#34;&gt;quickcheck-state-machine&lt;/a&gt;, another library to write model-based tests on top of QuickCheck. This blog post introduces &lt;a href=&#34;https://github.com/well-typed/quickcheck-lockstep&#34;&gt;quickcheck-lockstep&lt;/a&gt; which provides &lt;em&gt;lockstep-style&lt;/em&gt; testing on top of quickcheck-dynamic.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;h3&gt;Without nix&lt;/h3&gt; &#xA;&lt;p&gt;This package uses &lt;a href=&#34;https://www.haskell.org/cabal/&#34;&gt;Cabal&lt;/a&gt;-based build. To build from source:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ensure both &lt;code&gt;ghc&lt;/code&gt; and &lt;code&gt;cabal&lt;/code&gt; executables are in your &lt;code&gt;PATH&lt;/code&gt;. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;ghcup&lt;/a&gt; is a great way to manage Haskell toolchain.&lt;/li&gt; &#xA;   &lt;li&gt;quickcheck-dynamic currently requires a GHC version &amp;gt; 8.10&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Run &lt;pre&gt;&lt;code&gt;cabal update &amp;amp;&amp;amp; cabal build all&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;To run tests: &lt;pre&gt;&lt;code&gt;cabal test all&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;With nix&lt;/h3&gt; &#xA;&lt;p&gt;This repository comes with some &lt;a href=&#34;https://nixos.org&#34;&gt;nix&lt;/a&gt; files which might or might not help hacking on quickcheck-dynamic simpler. Before you start using nix, please make sure you&#39;ve configured haskell.nix caching as per &lt;a href=&#34;https://input-output-hk.github.io/haskell.nix/tutorials/getting-started.html#setting-up-the-binary-cache&#34;&gt;those instructions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Building with nix should be as simple as: &lt;pre&gt;&lt;code&gt;nix-build -A quickcheck-dynamic.components.library&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;To enter a shell providing basic development tool: &lt;pre&gt;&lt;code&gt;nix-shell&#xA;&lt;/code&gt;&lt;/pre&gt; This can automated using &lt;a href=&#34;https://direnv.net/&#34;&gt;direnv&lt;/a&gt;: &lt;pre&gt;&lt;code&gt;direnv allow&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Then go back to &lt;a href=&#34;https://raw.githubusercontent.com/input-output-hk/quickcheck-dynamic/main/#without-nix&#34;&gt;Without nix&lt;/a&gt; instructions&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>deepin-community/alex</title>
    <updated>2022-10-01T01:38:15Z</updated>
    <id>tag:github.com,2022-10-01:/deepin-community/alex</id>
    <link href="https://github.com/deepin-community/alex" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Alex: A Lexical Analyser Generator&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://travis-ci.org/simonmar/alex&#34;&gt;&lt;img src=&#34;https://secure.travis-ci.org/simonmar/alex.png?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alex is a Lex-like tool for generating Haskell scanners. For complete documentation, see the doc directory.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.haskell.org/alex/&#34;&gt;https://www.haskell.org/alex/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/alex&#34;&gt;https://hackage.haskell.org/package/alex&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Alex version 2.0 has changed fairly considerably since version 1.x, and the syntax is almost completely different. For a detailed list of changes, see the release notes in the documentation.&lt;/p&gt; &#xA;&lt;p&gt;Alex is now covered by a BSD-Style licence; see the licence file in the &#39;doc&#39; directory for details.&lt;/p&gt; &#xA;&lt;p&gt;The sources are in the &#39;src&#39; directory and the documentation in the &#39;doc&#39; directory; various examples are in the &#39;examples&#39; subdirectory.&lt;/p&gt; &#xA;&lt;p&gt;The source code in the &#39;src&#39; and &#39;examples&#39; directories is intended for a Haskell 98 compiler with hierarchical modules. It should work with GHC &amp;gt;= 5.04.&lt;/p&gt; &#xA;&lt;h2&gt;Build Instructions&lt;/h2&gt; &#xA;&lt;p&gt;If you just want to &lt;em&gt;use&lt;/em&gt; Alex, you can download or install (via &lt;code&gt;cabal install alex&lt;/code&gt;) an &lt;a href=&#34;https://hackage.haskell.org/package/alex&#34;&gt;Alex release from Hackage&lt;/a&gt;; also note that distributions such as the &lt;a href=&#34;https://www.haskell.org/platform/&#34;&gt;Haskell Platform&lt;/a&gt; and other package manager-based distributions provide packages for Alex. Moreover, recent versions of &lt;code&gt;cabal&lt;/code&gt; will automatically install the required version of &lt;code&gt;alex&lt;/code&gt; based on &lt;a href=&#34;http://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-build-tool-depends&#34;&gt;&lt;code&gt;build-tools&lt;/code&gt;/&lt;code&gt;build-tool-depends&lt;/code&gt; declarations&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Read on if you want to build Alex directly from Git.&lt;/p&gt; &#xA;&lt;p&gt;Alex is built using GHC &amp;amp; Cabal; so first install &lt;a href=&#34;https://www.haskell.org/ghc&#34;&gt;GHC&lt;/a&gt; and &lt;a href=&#34;https://www.haskell.org/cabal&#34;&gt;&lt;code&gt;cabal-install-2.0&lt;/code&gt;&lt;/a&gt; (or later).&lt;/p&gt; &#xA;&lt;p&gt;Since Alex itself is implemented in terms of an Alex scanner, bootstrapping Alex is a bit tricky:&lt;/p&gt; &#xA;&lt;p&gt;You need to have the build-tools &lt;code&gt;alex&lt;/code&gt; and &lt;code&gt;happy&lt;/code&gt; manually installed; either via your system package manager distribution, the Haskell Platform, or e.g. via (run this outside the Git repository!):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal install alex happy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which installs them into &lt;code&gt;${HOME}/.cabal/bin&lt;/code&gt; by default (make sure they&#39;re in your &lt;code&gt;$PATH&lt;/code&gt; for the next steps!).&lt;/p&gt; &#xA;&lt;h3&gt;Variant A&lt;/h3&gt; &#xA;&lt;p&gt;First you need to generate the pre-processed templates via&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal new-run gen-alex-sdist&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(otherwise &lt;code&gt;cabal install&lt;/code&gt; will complain about &#34;&lt;code&gt;data/AlexTemplate: copyFile: does not exist (No such file or directory)&lt;/code&gt;&#34;)&lt;/p&gt; &#xA;&lt;p&gt;And then you can install &lt;code&gt;alex&lt;/code&gt; simply by invoking&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;from inside the Git folder.&lt;/p&gt; &#xA;&lt;h3&gt;Variant B&lt;/h3&gt; &#xA;&lt;p&gt;Alternatively, you can use the &lt;code&gt;Makefile&lt;/code&gt; which automates the steps of producing a self-contained pre-bootstrapped source distribution with pre-generated lexer/scanners (and which also performs the &lt;code&gt;cabal new-run gen-alex-sdist&lt;/code&gt; pre-preprocessing step):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make sdist&#xA;$ cabal install dist/alex-*.tar.gz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For convenience, there&#39;s also a &lt;code&gt;make sdist-test&lt;/code&gt; target which builds the source source tarball and runs the test-suite from within the source dist.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing &amp;amp; Reporting Issues&lt;/h2&gt; &#xA;&lt;p&gt;Please report any bugs or comments at &lt;a href=&#34;https://github.com/simonmar/alex/issues&#34;&gt;https://github.com/simonmar/alex/issues&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Share and enjoy,&lt;/p&gt; &#xA;&lt;p&gt;Chris Dornan: &lt;a href=&#34;mailto:cdornan@arm.com&#34;&gt;cdornan@arm.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Isaac Jones: &lt;a href=&#34;mailto:ijones@syntaxpolice.org&#34;&gt;ijones@syntaxpolice.org&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Simon Marlow: &lt;a href=&#34;mailto:simonmar@microsoft.com&#34;&gt;simonmar@microsoft.com&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>