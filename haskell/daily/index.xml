<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-28T01:39:51Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>B-Lang-org/bsc</title>
    <updated>2023-06-28T01:39:51Z</updated>
    <id>tag:github.com,2023-06-28:/B-Lang-org/bsc</id>
    <link href="https://github.com/B-Lang-org/bsc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Bluespec Compiler (BSC)&lt;/p&gt;&lt;hr&gt;&lt;div class=&#34;title-block&#34; style=&#34;text-align: center;&#34; align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;Bluespec Compiler&lt;/h1&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/B-Lang-org/bsc/releases/tag/2023.01&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/release-2023.01-red.svg?logo=v&#34; alt=&#34;Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/B-Lang-org/bsc/main/COPYING&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-BSD%203-blueviolet.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/b-lang-org/bsc/actions?query=workflow%3ACI+event%3Apush&#34;&gt;&lt;img src=&#34;https://github.com/b-lang-org/bsc/workflows/CI/badge.svg?branch=main&amp;amp;event=push&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/B-Lang-org/bsc/main/#community&#34;&gt;Community&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/B-Lang-org/bsc/main/#download&#34;&gt;Download&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/B-Lang-org/bsc/main/#documentation&#34;&gt;Documentation&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/B-Lang-org/bsc/main/INSTALL.md&#34;&gt;Build&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/B-Lang-org/bsc/main/testsuite/README.md&#34;&gt;Test&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;hr&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;Compiler, simulator, and tools for the &lt;strong&gt;Bluespec Hardware Description Language&lt;/strong&gt;. Bluespec is a single language for digital electronic hardware designs that comes in two syntactic flavors, which are interchangeable:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bluespec &lt;strong&gt;SystemVerilog&lt;/strong&gt; (BSV)&lt;/li&gt; &#xA; &lt;li&gt;Bluespec &lt;strong&gt;Haskell&lt;/strong&gt; (BH, or &#34;Bluespec Classic&#34;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Bluespec is a &lt;em&gt;high-level&lt;/em&gt; hardware description language. It has a variety of advanced features including a powerful type system that can prevent errors prior to synthesis time, and its most distinguishing feature, &lt;strong&gt;Guarded Atomic Actions&lt;/strong&gt;, allow you to define hardware components in a modular manner based on their invariants, and let the compiler pick a scheduler.&lt;/p&gt; &#xA;&lt;p&gt;The toolchain was under development by &lt;a href=&#34;https://bluespec.com&#34;&gt;Bluespec Inc&lt;/a&gt; for almost 20 years, and has been proven repeatedly in production designs like &lt;a href=&#34;https://github.com/bluespec/Flute&#34;&gt;Flute&lt;/a&gt;, &lt;a href=&#34;https://github.com/bluespec/Piccolo&#34;&gt;Piccolo&lt;/a&gt;, and &lt;a href=&#34;https://shakti.org.in&#34;&gt;Shakti&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The Bluespec compiler &lt;code&gt;bsc&lt;/code&gt; emits standard Verilog for maximum compatibility with any synthesis toolchain and comes with an included simulator (&#34;bluesim&#34;), standard library, and TCL scripting support (&#34;bluetcl&#34;).&lt;/p&gt; &#xA;&lt;p&gt;The repository is still evolving. We welcome your feedback, issue reports, and pull requests.&lt;/p&gt; &#xA;&lt;p&gt;A separate repository, &lt;a href=&#34;https://github.com/B-Lang-org/bsc-contrib&#34;&gt;bsc-contrib&lt;/a&gt;, exists for sharing libraries and utilities that don&#39;t (or don&#39;t yet) belong in the core tools.&lt;/p&gt; &#xA;&lt;p&gt;A graphical environment for using BSC is available in a separate &lt;a href=&#34;https://github.com/B-Lang-org/bdw&#34;&gt;bdw&lt;/a&gt; repository. BDW (the BSC Development Workstation) provides a number of tools, including the ability to view simulation waveforms as source-level values.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;To receive announcements about BSC and related projects, subscribe to &lt;a href=&#34;https://groups.io/g/b-lang-announce&#34;&gt;b-lang-announce@groups.io&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For questions and discussion about BSC source, subscribe to the developers&#39; mailing list &lt;a href=&#34;https://groups.io/g/bsc-dev&#34;&gt;bsc-dev@groups.io&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For any questions or discussion about Bluespec HDLs, using BSC, or related projects, subscribe to &lt;a href=&#34;https://groups.io/g/b-lang-discuss&#34;&gt;b-lang-discuss@groups.io&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;IRC users might try joining the &lt;code&gt;#bluespec&lt;/code&gt; channel on &lt;a href=&#34;https://libera.chat/&#34;&gt;Libera.Chat&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s also a &lt;a href=&#34;https://stackoverflow.com/questions/tagged/bluespec&#34;&gt;bluespec&lt;/a&gt; tag on StackOverflow.&lt;/p&gt; &#xA;&lt;p&gt;And we&#39;ve enabled the &lt;a href=&#34;https://github.com/B-Lang-org/bsc/discussions&#34;&gt;Discussions&lt;/a&gt; tab in this GitHub repo. This is a new feature to support discussion within the project itself. Feel free to give it a try and see if it can be useful to our community.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;For the following systems, the Bluespec toolchain is available as a package that can be installed with the standard package manager:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ArchLinux AUR: &lt;a href=&#34;https://aur.archlinux.org/packages/bluespec-git/&#34;&gt;&lt;code&gt;bluespec-git&lt;/code&gt;&lt;/a&gt; (&lt;a href=&#34;https://aur.archlinux.org/packages/?K=bluespec&#34;&gt;among others&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Nix/NixOS: &lt;a href=&#34;https://search.nixos.org/packages?channel=20.09&amp;amp;from=0&amp;amp;size=50&amp;amp;sort=relevance&amp;amp;query=bluespec&#34;&gt;&lt;code&gt;bluespec&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If a package exists for your system, we recommend installing that. Otherwise, a tar-archive may be available for download from our &lt;a href=&#34;https://github.com/B-Lang-org/bsc/releases&#34;&gt;Releases&lt;/a&gt; page. Install instructions can be found inside the tar-file.&lt;/p&gt; &#xA;&lt;p&gt;If a pre-built tar-file does not exist for your system, you will need to &lt;a href=&#34;https://raw.githubusercontent.com/B-Lang-org/bsc/main/INSTALL.md&#34;&gt;compile BSC from source&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;More details on using BSC, Bluesim, and Bluetcl can be found in the &lt;a href=&#34;https://github.com/B-Lang-org/bsc/releases/latest/download/bsc_user_guide.pdf&#34;&gt;&lt;em&gt;BSC User Guide&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The standard libraries that come with BSC are documented in the &lt;a href=&#34;https://github.com/B-Lang-org/bsc/releases/latest/download/bsc_libraries_ref_guide.pdf&#34;&gt;&lt;em&gt;BSC Libraries Reference Guide&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For the specification of the Bluespec language, see the &lt;a href=&#34;https://github.com/B-Lang-org/bsc/releases/latest/download/BSV_lang_ref_guide.pdf&#34;&gt;&lt;em&gt;BSV Language Reference Guide&lt;/em&gt;&lt;/a&gt; and the &lt;a href=&#34;https://github.com/B-Lang-org/bsc/releases/latest/download/BH_lang_ref_guide.pdf&#34;&gt;&lt;em&gt;BH (Bluespec Haskell/Classic) Language Reference Guide&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The sources for these documents are found in the &lt;code&gt;doc&lt;/code&gt; directory of this repo. Pre-built PDF files can also be downloaded from the &lt;a href=&#34;https://github.com/B-Lang-org/bsc/releases&#34;&gt;Releases&lt;/a&gt; page.&lt;/p&gt; &#xA;&lt;p&gt;Training and tutorials can be found in the &lt;a href=&#34;https://github.com/BSVLang/Main&#34;&gt;BSVLang repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The Bluespec toolchain is provided by &lt;a href=&#34;https://bluespec.com&#34;&gt;Bluespec Inc&lt;/a&gt; and available under the BSD-3-Clause license. The source code also includes several other components under various license agreements (all of it open/copyleft software). See &lt;a href=&#34;https://raw.githubusercontent.com/B-Lang-org/bsc/main/COPYING&#34;&gt;&lt;code&gt;COPYING&lt;/code&gt;&lt;/a&gt; for copyright and license details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ekmett/ad</title>
    <updated>2023-06-28T01:39:51Z</updated>
    <id>tag:github.com,2023-06-28:/ekmett/ad</id>
    <link href="https://github.com/ekmett/ad" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Automatic Differentiation&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ad&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/ad&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/ad.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ekmett/ad/actions?query=workflow%3AHaskell-CI&#34;&gt;&lt;img src=&#34;https://github.com/ekmett/ad/workflows/Haskell-CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A package that provides an intuitive API for &lt;a href=&#34;http://en.wikipedia.org/wiki/Automatic_differentiation&#34;&gt;Automatic Differentiation&lt;/a&gt; (AD) in Haskell. Automatic differentiation provides a means to calculate the derivatives of a function while evaluating it. Unlike numerical methods based on running the program with multiple inputs or symbolic approaches, automatic differentiation typically only decreases performance by a small multiplier.&lt;/p&gt; &#xA;&lt;p&gt;AD employs the fact that any program &lt;code&gt;y = F(x)&lt;/code&gt; that computes one or more value does so by composing multiple primitive operations. If the (partial) derivatives of each of those operations is known, then they can be composed to derive the answer for the derivative of the entire program at a point.&lt;/p&gt; &#xA;&lt;p&gt;This library contains at its core a single implementation that describes how to compute the partial derivatives of a wide array of primitive operations. It then exposes an API that enables a user to safely combine them using standard higher-order functions, just as you would with any other Haskell numerical type.&lt;/p&gt; &#xA;&lt;p&gt;There are several ways to compose these individual &lt;a href=&#34;http://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant&#34;&gt;Jacobian matrices&lt;/a&gt;. We hide the choice used by the API behind an explicit &#34;Mode&#34; type-class and universal quantification. This prevents users from &lt;a href=&#34;http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Differentiation/&#34;&gt;confusing infinitesimals&lt;/a&gt;. If you want to risk infinitesimal confusion in order to get greater flexibility in how you curry, flip and generally combine the differential operators, then the &lt;code&gt;Rank1.*&lt;/code&gt; modules are probably your cup of tea.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Provides forward- and reverse- mode AD combinators with a common API.&lt;/li&gt; &#xA; &lt;li&gt;Optional type-level &#34;branding&#34; is available to prevent the end user from confusing infinitesimals&lt;/li&gt; &#xA; &lt;li&gt;Each mode has a separate module full of combinators, with a consistent look and feel.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;You can compute derivatives of functions&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Prelude Numeric.AD&amp;gt; diff sin 0 {- cos 0 -}&#xA;1.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or both the answer and the derivative of a function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Prelude Numeric.AD&amp;gt; diff&#39; (exp . log) 2&#xA;(2.0,1.0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can compute the derivative of a function with a constant parameter using &lt;code&gt;auto&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Prelude Numeric.AD&amp;gt; let t = 2.0 :: Double&#xA;Prelude Numeric.AD&amp;gt; diff (\ x -&amp;gt; auto t * sin x) 0&#xA;2.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use a symbolic numeric type, like the one from &lt;code&gt;simple-reflect&lt;/code&gt; to obtain symbolic derivatives:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Prelude Debug.SimpleReflect Numeric.AD&amp;gt; diff atanh x&#xA;recip (1 - x * x) * 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can compute gradients for functions that take non-scalar values in the form of a Traversable functor full of AD variables.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Prelude Numeric.AD Debug.SimpleReflect&amp;gt; grad (\[x,y,z] -&amp;gt; x * sin (x + log y)) [x,y,z]&#xA;[ 0 + (0 + sin (x + log y) * 1 + 1 * (0 + cos (x + log y) * (0 + x * 1)))&#xA;, 0 + (0 + recip y * (0 + 1 * (0 + cos (x + log y) * (0 + x * 1))))&#xA;, 0&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which one can simplify to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[ sin (x + log y) + cos (x + log y) * x, recip y * cos (x + log y) * x, 0 ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need multiple derivatives you can calculate them with &lt;code&gt;diffs&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Prelude Numeric.AD&amp;gt; take 10 $ diffs sin 1&#xA;[0.8414709848078965,0.5403023058681398,-0.8414709848078965,-0.5403023058681398,0.8414709848078965,0.5403023058681398,-0.8414709848078965,-0.5403023058681398,0.8414709848078965,0.5403023058681398]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or if your function takes multiple inputs, you can use grads, which returns an &#39;f-branching stream&#39; of derivatives, that you can inspect lazily. Somewhat more intuitive answers can be obtained by converting the stream into the polymorphically recursive &lt;code&gt;Jet&lt;/code&gt; data type. With that we can look at a single &#34;layer&#34; of the answer at a time:&lt;/p&gt; &#xA;&lt;p&gt;The answer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Prelude Numeric.AD&amp;gt; headJet $ jet $  grads (\[x,y] -&amp;gt; exp (x * y)) [1,2]&#xA;7.38905609893065&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The gradient:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Prelude Numeric.AD&amp;gt; headJet $ tailJet $ jet $  grads (\[x,y] -&amp;gt; exp (x * y)) [1,2]&#xA;[14.7781121978613,7.38905609893065]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The hessian (n * n matrix of 2nd derivatives)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Prelude Numeric.AD&amp;gt; headJet $ tailJet $ tailJet $ jet $  grads (\[x,y] -&amp;gt; exp (x * y)) [1,2]&#xA;[[29.5562243957226,22.16716829679195],[22.16716829679195,7.38905609893065]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or even higher order tensors of derivatives as a jet.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Prelude Numeric.AD&amp;gt; headJet $ tailJet $ tailJet $ tailJet $ jet $  grads (\[x,y] -&amp;gt; exp (x * y)) [1,2]&#xA;[[[59.1124487914452,44.3343365935839],[44.3343365935839,14.7781121978613]],[[44.3343365935839,14.7781121978613],[14.7781121978613,7.38905609893065]]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note the redundant values caused by the various symmetries in the tensors. The &lt;code&gt;ad&lt;/code&gt; library is careful to compute each distinct derivative only once, lazily and to share the resulting computation.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;h3&gt;Modules&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Numeric.AD&lt;/code&gt; computes using whichever mode or combination thereof is suitable to each individual combinator. This mode is the default, re-exported by &lt;code&gt;Numeric.AD&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Numeric.AD.Mode.Forward&lt;/code&gt; provides basic forward-mode AD. It is good for computing simple derivatives.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Numeric.AD.Mode.Sparse&lt;/code&gt; computes a sparse forward-mode AD tower. It is good for higher derivatives or large numbers of outputs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Numeric.AD.Mode.Kahn&lt;/code&gt; computes with reverse-mode AD. It is good for computing a few outputs given many inputs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Numeric.AD.Mode.Reverse&lt;/code&gt; computes with reverse-mode AD. It is good for computing a few outputs given many inputs, when not using sparks heavily.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Numeric.AD.Mode.Tower&lt;/code&gt; computes a dense forward-mode AD tower useful for higher derivatives of single input functions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Numeric.AD.Newton&lt;/code&gt; provides a number of combinators for root finding using Newton&#39;s method with quadratic convergence.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Numeric.AD.Halley&lt;/code&gt; provides a number of combinators for root finding using Halley&#39;s method with cubic convergence.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Numeric.AD.Rank1.*&lt;/code&gt; provides combinators for AD that are strictly rank-1. This makes it easier to flip and contort them with higher order functions at the expense of type safety when it comes to infinitsimal confusion.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Combinators&lt;/h3&gt; &#xA;&lt;p&gt;While not every mode can provide all operations, the following basic operations are supported, modified as appropriate by the suffixes below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;grad&lt;/code&gt; computes the gradient (vector of partial derivatives at a given point) of a function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;jacobian&lt;/code&gt; computes the Jacobian matrix of a function at a point.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;diff&lt;/code&gt; computes the derivative of a function at a point.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;du&lt;/code&gt; computes a directional derivative of a function at a point.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;hessian&lt;/code&gt; computes the Hessian matrix (matrix of second partial derivatives) of a function at a point.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Combinator Suffixes&lt;/h3&gt; &#xA;&lt;p&gt;The following suffixes alter the meanings of the functions above as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#39;&lt;/code&gt; also return the answer&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;With&lt;/code&gt; lets the user supply a function to blend the input with the output&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;F&lt;/code&gt; is a version of the base function lifted to return a &lt;code&gt;Traversable&lt;/code&gt; (or &lt;code&gt;Functor&lt;/code&gt;) result&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s&lt;/code&gt; means the function returns all higher derivatives in a list or f-branching &lt;code&gt;Stream&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;T&lt;/code&gt; means the result is transposed with respect to the traditional formulation (usually to avoid paying for transposing back)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;0&lt;/code&gt; means that the resulting derivative list is padded with 0s at the end.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NoEq&lt;/code&gt; means that an infinite list of converging values is returned rather than truncating the list when they become constant&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contact Information&lt;/h2&gt; &#xA;&lt;p&gt;Contributions and bug reports are welcome!&lt;/p&gt; &#xA;&lt;p&gt;Please feel free to contact me through github or on the #haskell IRC channel on irc.freenode.net.&lt;/p&gt; &#xA;&lt;p&gt;-Edward Kmett&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>blynn/compiler</title>
    <updated>2023-06-28T01:39:51Z</updated>
    <id>tag:github.com,2023-06-28:/blynn/compiler</id>
    <link href="https://github.com/blynn/compiler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The adventures of a Haskell compiler&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Compiler Quest&lt;/h1&gt; &#xA;&lt;div id=&#34;preamble&#34;&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;&lt;a href=&#34;https://crypto.stanford.edu/~blynn/compiler/&#34;&gt;The adventures of a Haskell compiler&lt;/a&gt;.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;The main goal is to continually level-up a self-hosting Haskell compiler. However, it’s a survival game as well as an RPG: it should always be possible to build this compiler starting with only a C compiler.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;I had thought this was a daunting challenge. In the past, constructing a parser alone was a laborious grind for me. Then it got worse: compilers manipulate abstract syntax trees, so the self-hosting requirement demands the source language be complex enough to handle compound data types.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;This time around, I found it shockingly easy to bootstrap a compiler for stripped-down Haskell (or perhaps I should say souped-up lambda calculus), thanks to a few tricks:&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;ulist&#34;&gt; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt; &lt;p&gt;Parsing combinators are a joy to build from scratch and a joy to use.&lt;/p&gt; &lt;/li&gt; &#xA;    &lt;li&gt; &lt;p&gt;Kiselyov’s bracket abstraction algorithm is simple yet practical.&lt;/p&gt; &lt;/li&gt; &#xA;    &lt;li&gt; &lt;p&gt;Interpreting basic combinators is child’s play, and almost the only task we need perform in C or assembly.&lt;/p&gt; &lt;/li&gt; &#xA;    &lt;li&gt; &lt;p&gt;Lambda calculus gives us the Scott encoding for free. Thus we effortlessly gain algebraic data types.&lt;/p&gt; &lt;/li&gt; &#xA;    &lt;li&gt; &lt;p&gt;Laziness is at odds with native instructions, which are eagerly evaluated. However, we can readily reconcile their differences with shrewdly chosen combinators.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;/ul&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Perhaps the greatest difficulty was mustering the discipline to mark the road taken so that anyone with a C compiler can follow.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;div class=&#34;sect1&#34;&gt; &#xA; &lt;h2 id=&#34;_how_to_build&#34;&gt;How to build&lt;/h2&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;The earliest generations of our compiler reside in &lt;code&gt;vm.c&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;literalblock&#34;&gt; &#xA;   &lt;div class=&#34;content&#34;&gt; &#xA;    &lt;pre&gt;$ cc -O2 vm.c -o vm&lt;/pre&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;When run without arguments, this program gets each compiler to compile its successor, which results in a series of numbers that we output to &lt;code&gt;raw&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;literalblock&#34;&gt; &#xA;   &lt;div class=&#34;content&#34;&gt; &#xA;    &lt;pre&gt;$ ./vm &amp;gt; raw&lt;/pre&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;These numbers are a compiled form of the &lt;code&gt;barely.hs&lt;/code&gt; compiler. The &lt;code&gt;vm run&lt;/code&gt; command reads this &lt;code&gt;raw&lt;/code&gt; file and interprets it to compile a given Haskell file:&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;literalblock&#34;&gt; &#xA;   &lt;div class=&#34;content&#34;&gt; &#xA;    &lt;pre&gt;$ echo &#34;prependH s = &#39;H&#39;:s;&#34; &amp;gt; /tmp/example.hs&#xA;$ echo &#34;ello, World!&#34; | ./vm run /tmp/example.hs&lt;/pre&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;It only accepts code that type-checks. Moreover, the &lt;code&gt;(⇐)&lt;/code&gt; operator is undefined and disallows mixing the &lt;code&gt;(++)&lt;/code&gt; operator with &lt;code&gt;(:)&lt;/code&gt; unless its fixity has been declared. This conflicts with the examples bundled with &lt;a href=&#34;https://www.ioccc.org/2019/whowon.html&#34;&gt;my IOCCC entry&lt;/a&gt;. The &lt;code&gt;vm ioccc&lt;/code&gt; command inserts code to fix these issues:&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;literalblock&#34;&gt; &#xA;   &lt;div class=&#34;content&#34;&gt; &#xA;    &lt;pre&gt;$ ./vm ioccc fib.hs&lt;/pre&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;The compilers thus far expect pure functions as input. The last function should have type &lt;code&gt;String → String&lt;/code&gt;, and we implicitly wrap it in the &lt;code&gt;interact&lt;/code&gt; function from the standard Haskell Prelude during compilation.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;The &lt;code&gt;effectively.hs&lt;/code&gt; compiler bucks the trend. It assumes the last function has type &lt;code&gt;IO ()&lt;/code&gt;, and treats it like &lt;code&gt;main&lt;/code&gt; in a standard Haskell program. It also has support for FFI.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;The &lt;code&gt;lonely.hs&lt;/code&gt; compiler is the first generation with a main function of type &lt;code&gt;IO ()&lt;/code&gt;. It also outputs C code that should be appended to &lt;code&gt;rts.c&lt;/code&gt;.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;In sum, after running the above to produce &lt;code&gt;raw&lt;/code&gt;, we can build a standalone compiler with:&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;literalblock&#34;&gt; &#xA;   &lt;div class=&#34;content&#34;&gt; &#xA;    &lt;pre&gt;$ (cat rts.c; ./vm run effectively.hs &amp;lt; lonely.hs) &amp;gt; lonely.c&#xA;$ cc -O2 lonely.c -o lonely&lt;/pre&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;(A few generations later, our &lt;code&gt;virtually.hs&lt;/code&gt; compiler bundles the runtime system with the output, so the &lt;code&gt;cat&lt;/code&gt; is no longer needed.)&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt;</summary>
  </entry>
</feed>