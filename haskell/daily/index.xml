<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-25T01:32:40Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>anton-k/handle-pattern-servant-app</title>
    <updated>2022-11-25T01:32:40Z</updated>
    <id>tag:github.com,2022-11-25:/anton-k/handle-pattern-servant-app</id>
    <link href="https://github.com/anton-k/handle-pattern-servant-app" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Handle pattern with servant to build flexible web-apps in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Haskell Reversed Handle pattern and servant example app&lt;/h1&gt; &#xA;&lt;p&gt;Show case for a small application written with servant and Reversed Handle pattern. It is an example on how to make Dependency Injection in Haskell with Handle-pattern.&lt;/p&gt; &#xA;&lt;p&gt;The main idea of reversed handle pattern is that we build interfaces for external services not driven by services themselves but by the methods we use in concrete API-routes. In the original article on &lt;a href=&#34;https://jaspervdj.be/posts/2018-03-08-handle-pattern.html&#34;&gt;Handle pattern&lt;/a&gt; we describe interfaces to DB or Logging based on the natural API of the library. But I argue that it&#39;s much more beneficial to create small interfaces dedicated to concrete task of the API-route. This way our interfaces are more flexible and local regarding to change of the code. Also it might be interesting to check the same project implemented in &lt;a href=&#34;https://github.com/anton-k/reader-pattern-servant-app&#34;&gt;Reader pattern&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Application allows to save messages with tags. User can create a new message and then user can query it by id or by tag.&lt;/p&gt; &#xA;&lt;p&gt;API methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;POST: api/v1/save:&#xA;   input: JSON text of the message and list of tags&#xA;   output: id of the message &#xA;&#xA;GET: api/v1/get/message/{message-id}&#xA;  input: id of the message&#xA;  output: message or error  &#xA;&#xA;GET: api/v1/list/tag/{tag} &#xA;  input: tag &#xA;  output: list of messages that belong to the tag&#xA;&#xA;POST: api/v1/toggle-logs&#xA;  toggles the logs (active or silent)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Applications shows how to create interfaces for mocks and real instances. Also we show how to use interfaces that depend on run-time data and how we can split the top-level interface to smaller ones dedicated to concrete methods. On save message is augmented with current time stamp which is queried over external service. We use &lt;code&gt;getCurrentTime&lt;/code&gt; for mock but it serves as an example of external dependency.&lt;/p&gt; &#xA;&lt;h3&gt;Application user guide&lt;/h3&gt; &#xA;&lt;p&gt;See makefile for available actions for installation and testing the service. The app can be build with stack. The GHC extension list is kept lightweight but we rely on modern compiler GHC 9.2 for nice record-dot syntax.&lt;/p&gt; &#xA;&lt;p&gt;We can&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;build the app:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;make build&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;run the executable:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;make run&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;It will start the server on default port.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;trigger API-routes over &lt;code&gt;curl&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;make message=&#39;{&#34;message&#34;: &#34;waiting for the summer&#34;, &#34;tags&#34;: [&#34;random&#34;] }&#39; post-save&#xA;make id=0 get-id&#xA;make tag=random list-tag&#xA;make toggle-logs&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The rest of the article is tutorial explaining the application of Handle pattern in Haskell to build web-apps.&lt;/p&gt; &#xA;&lt;h4&gt;Stress tests with k6&lt;/h4&gt; &#xA;&lt;p&gt;Also we can run stress testing for our server. For that we need to install &lt;a href=&#34;https://k6.io/&#34;&gt;&lt;code&gt;k6&lt;/code&gt;&lt;/a&gt; and see the &lt;a href=&#34;https://github.com/anton-k/handle-pattern-servant-app/tree/main/test-stress&#34;&gt;&lt;code&gt;README.md&lt;/code&gt;&lt;/a&gt; for docs on how to run them in the directory &lt;code&gt;test-stress&lt;/code&gt; of this repo (note that it features it&#39;s own Makefile).&lt;/p&gt; &#xA;&lt;h3&gt;The application structure&lt;/h3&gt; &#xA;&lt;p&gt;The library &lt;code&gt;src/&lt;/code&gt; defines types, interfaces, server and handlers&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Types&lt;/code&gt; - types of the domain&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Error&lt;/code&gt; - custom server errors&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Api&lt;/code&gt; - API for the app&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Server&lt;/code&gt; - servant server and main environment (state) of the service&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DI.[Log | Time | Setup]&lt;/code&gt; - interfaces for the app and common functions&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Server.[Save | GetMessage | ListTag | ToggleLog]&lt;/code&gt; - handlers of the API-routes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Executable &lt;code&gt;app/&lt;/code&gt; implements interfaces initialises service state and launches the app.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Main&lt;/code&gt; - init and launch server&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Config&lt;/code&gt; - read server configs from command line arguments&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;App.DI.[DB | Log | Time | Setup]&lt;/code&gt; - implement interfaces&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;App.State&lt;/code&gt; - mutable state of the app&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;App.DI.Db.MockDb&lt;/code&gt; - mock db, should be in separate package but kept here for simplicity&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;In this example and tutorial we will learn how to build flexible web-apps with the help of handle pattern. We will mention some key-factors of the web-development domain, discuss the problems and solutions and look at how to combine Handle pattern with servant. While implementing a small app.&lt;/p&gt; &#xA;&lt;p&gt;What we will learn:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;How to organise application with collection of interfaces&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;we can keep interface for external services separate to mock them for testing or swap implementations&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;to be flexible we propose API-route or user action first design for interfaces. It&#39;s better to build interfaces not from the point of view of the actual external service but from the user perspective of the app. From what our app wants form that external service in the given API-route.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;the web-app domain is ocean wave not a solid ground to build castles. So we need to build with presence of uncertainty and unexpected changes in mind. Which corresponds badly with mathematical thinking. We need to use more flexible solutions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;How to hide mutable state with interfaces&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In this app we use the Handle pattern for DI&#39;s But our version of Handle pattern is reversed in terms of where interfaces originate. In original Handle pattern we wrap external services with concrete interfaces. So interface is driven by external dependency. But I&#39;d like to stress the point of user or app driven interfaces. We build small interfaces that are dedicated to concrete part of the app and use it locally. And on level of the executable we use concrete implementation.&lt;/p&gt; &#xA;&lt;h3&gt;Links&lt;/h3&gt; &#xA;&lt;p&gt;This approach is inspired by the book &lt;a href=&#34;https://pragprog.com/titles/swdddf/domain-modeling-made-functional/&#34;&gt;Domain Modeling Made Functional&lt;/a&gt; by Scott Walschin (it uses F#). In this book it&#39;s well described how to build small and focused interfaces. I&#39;d like to thank the &lt;a href=&#34;https://fsharpforfunandprofit.com/&#34;&gt;Scott Walschin&lt;/a&gt; for providing this simple yet powerful technique to mitigate complexity. In this tutorial I&#39;d like to adapt it to Haskell and building web apps with Reader pattern.&lt;/p&gt; &#xA;&lt;h3&gt;History of project&lt;/h3&gt; &#xA;&lt;p&gt;The history of this project is fun road of simplification of the Reader pattern to the bare essentials which eventually lead me to the question: Do we really need Reader in the first place?&lt;/p&gt; &#xA;&lt;p&gt;So here is my progress:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;type App env a = ReaderT env (ExceptT IO) a&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;newtype App env a = App (ReaderT env (ExceptT IO) a) deriving newtype (...)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;newtype App env a = App (ReaderT env IO a)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;split env to local per API-route interfaces&lt;/li&gt; &#xA; &lt;li&gt;find out that mutable state can be hidden with interfaces also&lt;/li&gt; &#xA; &lt;li&gt;but if everything is described in interfaces, do we really need &lt;code&gt;ReaderT&lt;/code&gt; at all?&lt;/li&gt; &#xA; &lt;li&gt;handle pattern: &lt;code&gt;interfaces -&amp;gt; request -&amp;gt; IO response&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;During rewrite of the library code the library code size reduced from 266 to 210 LOC. I&#39;ve remove all dependencies on mtl, exceptions, &lt;code&gt;liftIO&lt;/code&gt; and etc. from the code.&lt;/p&gt; &#xA;&lt;p&gt;This is an open question to me. But I&#39;m inclined to think that no, we don&#39;t need the reader for our next web-application.&lt;/p&gt; &#xA;&lt;p&gt;So let&#39;s dive in.&lt;/p&gt; &#xA;&lt;h2&gt;Handle pattern&lt;/h2&gt; &#xA;&lt;p&gt;The Handle pattern is a very simple way to make dependency injection (DI) in Haskell. We express interfaces as plain records of functions and pass them around as arguments. So we notice that DI in Haskell is just a currying.&lt;/p&gt; &#xA;&lt;p&gt;Why do we go with records and not with type classes? Because they are more flexible. We can store them as a value, pass to the function, transform with the function, keep in collection and even in mutable refs and they are not tied to particular type that is instance of the type class.&lt;/p&gt; &#xA;&lt;p&gt;Using records can be somewhat cumbersome with polymorphic functions as generic parameters should become parameters of the interface. But it turns out that this generic behavior is rarely needed in web-apps so we can stick with plain &lt;code&gt;IO&lt;/code&gt; and handling errors with &lt;code&gt;Either&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There is alternative way to pass interfaces with Reader-pattern. Reader pattern encapsulates the collection of interfaces into environment. But this approach can lead to frustration that we need to have uniform collection of interfaces for all functions. And also we have some tiny performance overhead.&lt;/p&gt; &#xA;&lt;p&gt;In contrast with currying we have no performance penalty and we can pass different flavours interfaces on the spot. This comes at the price of being self-repetitive as we don&#39;t use direct calls to external dependencies but call them over interface. This is why we have DI-in the first place.&lt;/p&gt; &#xA;&lt;p&gt;Pros of the Handle-pattern&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;easy to implement and reason about (as simple as applying argument to the function)&lt;/li&gt; &#xA; &lt;li&gt;very fast and efficient&lt;/li&gt; &#xA; &lt;li&gt;light-weight on dependencies and extensions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Dependency injection for Haskell&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s start with the notion of interface as a record. Let&#39;s look at the examples. Here is the logger interface:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Log = Log&#xA;  { logInfo  :: Text -&amp;gt; IO ()&#xA;  , logError :: Text -&amp;gt; IO ()&#xA;  , logDebug :: Text -&amp;gt; IO ()&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is an interface for the persistent storage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Db = Db &#xA;  { getMessage  :: MessageId -&amp;gt; IO (Maybe Message)&#xA;  , saveMessage :: Message -&amp;gt; IO MessageId&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And instead of directly calling those functions we pass them around to functions that need them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;doSomethingWithStorage :: Db -&amp;gt; Message -&amp;gt; IO ()&#xA;doSomethingWithStorage Db{..} msg = ... use interface ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can use &lt;code&gt;RecordWildCards&lt;/code&gt; extension to bring all functions of the interface in scope of the function. This our &lt;code&gt;import&lt;/code&gt; for interfaces.&lt;/p&gt; &#xA;&lt;p&gt;Also interfaces can be organised in groups:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Env = Env&#xA;  { db  :: Db&#xA;  , log :: Log&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So if we want to do something with storage and log results as we go we can use this combined interface:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;logAndStore :: Env -&amp;gt; a -&amp;gt; IO b&#xA;logAndStore (Env Db{..} Log{..}) a = ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also have collection of interfaces. Imagine that we have a list of competing http-services that can be identified by name and all of them can be wrapped in the some interface.&lt;/p&gt; &#xA;&lt;p&gt;We can create a map of interfaces:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Services = Map ServiceName ServiceInterface&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can do some fun with it like querying a method concurrently and returning which ever returns first. Or iterating over all of them and returning result in the list. This all stems from the benefit of having interfaces as plain values.&lt;/p&gt; &#xA;&lt;p&gt;For the web application we will pass the interface record to the handler of the API-route as first argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;handler :: Interface -&amp;gt; ApiRequest -&amp;gt; IO ApiResponce&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Mutable internal state as interface&lt;/h3&gt; &#xA;&lt;p&gt;I used to extensively apply the Reader-pattern to keep the track of internal state in &lt;code&gt;TVars&lt;/code&gt;. But it&#39;s interesting to note that with some discipline mutable variable management can also be organised in interfaces.&lt;/p&gt; &#xA;&lt;p&gt;In our app we have mutable shared state of logger verbosity we can update it by calling a API-method &lt;code&gt;toggle-logs&lt;/code&gt;. It turns out that instead of using &lt;code&gt;TVar&lt;/code&gt; directly we can pass it to interface initialization functions and internally if they rely on IO and usually they do as we express external services with interfaces. They can read those variables and behave according to changes.&lt;/p&gt; &#xA;&lt;p&gt;So instead of doing this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Env = Env&#xA;  { isVerbose :: TVar Bool&#xA;  , log       :: Log&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can pass the &lt;code&gt;TVar&lt;/code&gt; to the initialization of the logger:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;initLog :: TVar Bool -&amp;gt; IO Log&#xA;initLog =&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function &lt;code&gt;initLog&lt;/code&gt; hides dependency on mutable interface in the logger. And we have to face the reality of &lt;code&gt;isVerbose&lt;/code&gt; mutable &lt;code&gt;TVar&lt;/code&gt;-state. But what if it was also an interface?&lt;/p&gt; &#xA;&lt;p&gt;We can provide an interface to tweak the logger state:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Interface for tweaking configs&#xA;data Setup = Setup&#xA;  { toggleLogs  :: IO ()&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And in in the executable code we can initialise &lt;code&gt;TVar&lt;/code&gt; and pass it to interface constructors for &lt;code&gt;Log&lt;/code&gt; and &lt;code&gt;Setup&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;initEnv :: IO Env&#xA;initEnv = do&#xA;  verboseVar &amp;lt;- newVerboseVar&#xA;  setup &amp;lt;- initSetup verboseVar&#xA;  log &amp;lt;- initLog verboseVar&#xA;  pure $ Env setup log&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;Setup&lt;/code&gt; is not a data structure it&#39;s an interface to trigger changes in the configs of the system. And we share the link between logger and config only inside the executable &lt;code&gt;app&lt;/code&gt;. On the level of the library they look decoupled.&lt;/p&gt; &#xA;&lt;p&gt;This way we are not forced to chose &lt;code&gt;TVar&lt;/code&gt; between some other method of sharing mutable state. It&#39;s all hided from the library. By the &lt;code&gt;Env&lt;/code&gt; we only see the list of available actions that can be performed on the app in terms of interfaces.&lt;/p&gt; &#xA;&lt;p&gt;Keeping mutable variables visible to the user is more flexible approach as it allows for mutual-recursive dependencies. But for keeping them in interfaces graph should be acyclic. If your application does not need cyclic dependencies of interfaces. And I&#39;m sure you don&#39;t want that to happen. We can turn mutable variables to interfaces and this matches nicely with Handle-pattern as everything becomes just a collection of interfaces.&lt;/p&gt; &#xA;&lt;h3&gt;Hiding mutable variables with interfaces&lt;/h3&gt; &#xA;&lt;p&gt;For the previous example instead of passing &lt;code&gt;TVar Bool&lt;/code&gt; directly to initialization functions we can create a wrapper that hides away internal details of that mutable variable. We do that in the module &lt;code&gt;app/App/State.hs&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Application mutable state&#xA;module App.State&#xA;  ( VerboseVar&#xA;  , newVerboseVar&#xA;  , isVerbose&#xA;  , toggleVerbose&#xA;  ) where&#xA;&#xA;import Control.Concurrent.STM&#xA;&#xA;newtype VerboseVar = VerboseVar (TVar Bool)&#xA;&#xA;newVerboseVar :: IO VerboseVar&#xA;newVerboseVar = VerboseVar &amp;lt;$&amp;gt; newTVarIO True&#xA;&#xA;isVerbose :: VerboseVar -&amp;gt; IO Bool&#xA;isVerbose (VerboseVar var) = readTVarIO var&#xA;&#xA;toggleVerbose :: VerboseVar -&amp;gt; IO ()&#xA;toggleVerbose (VerboseVar var) = atomically $ modifyTVar&#39; var not&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We define a &lt;code&gt;newtype&lt;/code&gt; wrapper for the mutable variable that controls verbosity of the logs and provide several functions with which we can read that variable and set it up.&lt;/p&gt; &#xA;&lt;p&gt;And signatures for our initialization functions become more self-explanatory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;initLog   :: VerboseVar -&amp;gt; IO Log&#xA;initSetup :: VerboseVar -&amp;gt; Setup&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can look at the code how it&#39;s organised in the implementation of &lt;code&gt;Log&lt;/code&gt; and &lt;code&gt;Setup&lt;/code&gt; in the &lt;code&gt;app/App/DI&lt;/code&gt; modules.&lt;/p&gt; &#xA;&lt;h3&gt;Using it with Servant&lt;/h3&gt; &#xA;&lt;p&gt;In the servant we need to wrap response to Servant.Handler monad. The main idea of the approach is to use servant only on top-level Server-method and inside handlers we should work only in terms of the &lt;code&gt;IO&lt;/code&gt; and interfaces that are passed as arguments to the handlers.&lt;/p&gt; &#xA;&lt;p&gt;The cool thing about servant that it supports building handlers not only with builtin monad &lt;code&gt;Servant.Handler&lt;/code&gt; but also with other monads that can be converted to it.&lt;/p&gt; &#xA;&lt;p&gt;So we can build server with plain &lt;code&gt;IO&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Service interfaces by methods&#xA;data Env = Env&#xA;  { save        :: Save.Env&#xA;  , getMessage  :: GetMessage.Env&#xA;  , listTag     :: ListTag.Env&#xA;  , toggleLogs  :: ToggleLog.Env&#xA;  }&#xA;&#xA;-- | Servant server for the app&#xA;server :: Env -&amp;gt; ServerT Api IO&#xA;server env =&#xA;       Save.handle env.save&#xA;  :&amp;lt;|&amp;gt; GetMessage.handle env.getMessage&#xA;  :&amp;lt;|&amp;gt; ListTag.handle env.listTag&#xA;  :&amp;lt;|&amp;gt; ToggleLog.handle env.toggleLogs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And in the &lt;code&gt;app&lt;/code&gt; to launch the server we use &lt;code&gt;serveWithContextT&lt;/code&gt; with our custom lifting of &lt;code&gt;IO&lt;/code&gt; to &lt;code&gt;Handler&lt;/code&gt; monad:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Control.Exception (try)&#xA;import Control.Monad.Except (ExceptT(..))&#xA;...&#xA;&#xA;run config.port $ serveWithContextT (Proxy :: Proxy Api) EmptyContext toHandler $ server env&#xA;  where&#xA;    toHandler :: IO resp -&amp;gt; Servant.Handler resp&#xA;    toHandler  = Handler . ExceptT . try&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Custom error messages&lt;/h4&gt; &#xA;&lt;p&gt;For simplicity we use plain &lt;code&gt;Text&lt;/code&gt; error messages but in real app we should define more fine grained type for &lt;code&gt;ApiError&lt;/code&gt; that we can convert to servant errors.&lt;/p&gt; &#xA;&lt;p&gt;Also as we work with plain &lt;code&gt;IO&lt;/code&gt;-monad we need to convert our exceptions to servant ones so that they can be handled properly. For that we use custom &lt;code&gt;throwApi&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Control.Exception      (throwIO)&#xA;import Data.ByteString.Lazy   qualified as BL&#xA;import Data.Text.Encoding     qualified as Text&#xA;...&#xA;&#xA;throwApi :: ApiError -&amp;gt; IO a&#xA;throwApi = throwIO . toServantError&#xA;  where&#xA;    toServantError (ApiError err) = err400 { errBody = BL.fromStrict $ Text.encodeUtf8 err }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Implement interfaces outside of the library&lt;/h3&gt; &#xA;&lt;p&gt;In this example we keep all interfaces separate from the implementation. And separation is on package level. Implementation is defined in the executable &lt;code&gt;app&lt;/code&gt; and interfaces are declared in the library &lt;code&gt;src&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This way we can facilitate top-down approach and work in terms of interfaces that are yet to be implemented. So if we zoom in building of the library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;stack build handler-proto:lib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We are not tied to concrete implementation and can quickly invent new interfaces and try them out.&lt;/p&gt; &#xA;&lt;h3&gt;Flexibility of record-style interfaces&lt;/h3&gt; &#xA;&lt;p&gt;I&#39;d like to mention how easy it&#39;s to adapt our interfaces. As they are expressed as plain functions in the records. Let&#39;s consider logging example. We need to define the logging context dedicated to specific route. For example we need to prefix the logs with the name of the route.&lt;/p&gt; &#xA;&lt;p&gt;We can adapt the whole logging interface by plugging the function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mapLog :: (Text -&amp;gt; Text) -&amp;gt; Log -&amp;gt; Log&#xA;mapLog go logger = Log&#xA;  { logInfo = logger.logInfo . go&#xA;  , logDebug = logger.logDebug . go&#xA;  , logError = logger.logError . go&#xA;  }&#xA;&#xA;addLogContext :: Text -&amp;gt; Log -&amp;gt; Log&#xA;addLogContext contextMesage =&#xA;  mapLog (mappend (contextMesage &amp;lt;&amp;gt; &#34;: &#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example we use sort of logging middleware that inserts text-processing function prior to user call. We can transform the whole interface with it. And we can use it in the code by passing the logger to concrete API-route:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;    saveEnv =&#xA;      Save.Env&#xA;        { db = env.db.save&#xA;        , time = env.time&#xA;        , log = addLogContext &#34;api.save&#34; env.log&#xA;        }&#xA;&#xA;    listTagEnv =&#xA;      ListTag.Env&#xA;        { db = env.db.listTag&#xA;        , log = addLogContext &#34;api.list-tag&#34; env.log&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we transform the common logger defined in top-level environment state of the service reader and pass it to the local loggers. And all local loggers will have this modified logging built into it.&lt;/p&gt; &#xA;&lt;h3&gt;Keep your interfaces small&lt;/h3&gt; &#xA;&lt;p&gt;I&#39;d like to avoid having one big &lt;code&gt;Env&lt;/code&gt; record type that declares all possible interfaces of the server. Instead of this it&#39;s much better to have local small environments and interfaces that are dedicated to concrete part of the app.&lt;/p&gt; &#xA;&lt;p&gt;This example app is tiny. But for full-blown application one single &lt;code&gt;Env&lt;/code&gt; can become a source of compilation-time pain very quickly. Because if every handler will depend on it every additional feature will force &lt;strong&gt;recompile everything&lt;/strong&gt; scenario. And with time it would be very hard to be able to reason about gigantic &lt;code&gt;Env&lt;/code&gt;. This will lead to reduce our time to market as app is strongly coupled on one type of &lt;code&gt;Env&lt;/code&gt; and there will be many interdependencies and compilation time will be bad.&lt;/p&gt; &#xA;&lt;p&gt;Instead of this I prefer to keep &lt;code&gt;Env&lt;/code&gt; dedicated to methods. Let&#39;s take a look at the interface of the &lt;code&gt;ListTag&lt;/code&gt; API-method. In the task it returns the message by &lt;code&gt;Tag&lt;/code&gt;. Here is complete definition:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Get by tag handler&#xA;module Server.ListTag&#xA;  ( Env(..)&#xA;  , Db(..)&#xA;  , handle&#xA;  ) where&#xA;&#xA;import DI.Log&#xA;import Types&#xA;&#xA;data Env = Env&#xA;  { db  :: Db&#xA;  , log :: Log&#xA;  }&#xA;&#xA;data Db = Db&#xA;  { listTag :: Tag -&amp;gt; IO [Message]&#xA;  }&#xA;&#xA;-----------------------------------------&#xA;-- Handler&#xA;&#xA;handle :: Env -&amp;gt; Tag -&amp;gt; IO [Message]&#xA;handle (Env Db{..} Log{..}) tag = do&#xA;  logInfo $ &#34;list tag call: &#34; &amp;lt;&amp;gt; display tag&#xA;  listTag tag&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s take it apart. It has it&#39;s own &lt;code&gt;Env&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Env = Env&#xA;  { db  :: Db&#xA;  , log :: Log&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And we can see that &lt;code&gt;DB&lt;/code&gt;-interface is also local to the method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Db = Db&#xA;  { listTag :: Tag -&amp;gt; IO [Message]&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And the handler is defined in terms of local reader:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;handle :: Env -&amp;gt; Tag -&amp;gt; IO [Message]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By imports we can see that it depends on common &lt;code&gt;Types&lt;/code&gt; and common logger interface:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import DI.Log&#xA;import Types&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So with this approach we don&#39;t rely on Servant or on big one-for-all &lt;code&gt;Env&lt;/code&gt;. We keep it small, simple and local to the method. It would be painless to make a micro-service out of it.&lt;/p&gt; &#xA;&lt;p&gt;But how we use it in the service? In the service we have that big &lt;code&gt;Env&lt;/code&gt;. It contains all environments for the methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Service environment by methods&#xA;data Env = Env&#xA;  { save        :: Save.Env&#xA;  , getMessage  :: GetMessage.Env&#xA;  , listTag     :: ListTag.Env&#xA;  , toggleLogs  :: ToggleLog.Env&#xA;  }&#xA;&#xA;server :: Env -&amp;gt; ServerT Api IO&#xA;server env =&#xA;       Save.handle env.save&#xA;  :&amp;lt;|&amp;gt; GetMessage.handle env.listTag&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we instantiate concrete set of interfaces for the API-method. This way by local environment definition we can see which dependencies are used. For example the &lt;code&gt;ToggleLog&lt;/code&gt; method uses only &lt;code&gt;Log&lt;/code&gt; and &lt;code&gt;Setup&lt;/code&gt; services and modification of &lt;code&gt;DB&lt;/code&gt; or &lt;code&gt;Time&lt;/code&gt; interface will not affect it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module Server.ToggleLog where&#xA;&#xA;data Env = Env&#xA;  { log   :: Log&#xA;  , setup :: Setup&#xA;  }&#xA;&#xA;handle :: Env -&amp;gt; IO ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s consider some benefits of this approach.&lt;/p&gt; &#xA;&lt;h4&gt;Interfaces are driven by the API-methods&lt;/h4&gt; &#xA;&lt;p&gt;With this approach we define interfaces in terms of the method domain and we use only that much from the external dependency as we need to implement by the user action.&lt;/p&gt; &#xA;&lt;p&gt;This can save us lots of trouble by trying to define beautiful and shiny DB-interface that will fit every needs. With single DB-interface to rule them all it can lead to disaster of bloated interfaces that are hard to modify and reason about. And they usually trigger recompilation of the whole project.&lt;/p&gt; &#xA;&lt;h4&gt;The price of change&lt;/h4&gt; &#xA;&lt;p&gt;I argue that writing methods in this style we can keep our changes local.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s consider two types of changes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;adding new method to existing interface&lt;/li&gt; &#xA; &lt;li&gt;adding new type of external dependency&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Add method to existing interface&lt;/h5&gt; &#xA;&lt;p&gt;For example if we want to add &lt;code&gt;validTag&lt;/code&gt; to our DB-interface for the API-route &lt;code&gt;ListTag&lt;/code&gt;. We can add it to the local DB-interface:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Db = Db&#xA;  { listTag  :: Tag -&amp;gt; IO [Message]&#xA;  , validTag :: Tag -&amp;gt; IO Bool&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And with this approach we re-compile only two modules (this one and server that puts it all together) and we have no errors on the level of the library. But we will have missing field in the DI-implementation. Which is easy to define with mock or we can compile on the library level with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;stack build handler-proto:lib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a while and keep implementing our feature in terms of interfaces.&lt;/p&gt; &#xA;&lt;h5&gt;Add new external dependency&lt;/h5&gt; &#xA;&lt;p&gt;Let&#39;s imagine that &lt;code&gt;validTag&lt;/code&gt; is provided not by &lt;code&gt;DB&lt;/code&gt; but by some http-client &lt;code&gt;Foo&lt;/code&gt;. We have two options here to consider:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;is it well defined and settled interface like &lt;code&gt;Log&lt;/code&gt;?&lt;/li&gt; &#xA; &lt;li&gt;is it hard to define interface with many features like &lt;code&gt;DB&lt;/code&gt;?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If it&#39;s well defined then we can declare it under &lt;code&gt;DI&lt;/code&gt;-umbrella and just import it to the handler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module Server.ListTag where&#xA;&#xA;import DI.Foo&#xA;&#xA;data Env = Env&#xA;  { db  :: Db&#xA;  , log :: Log&#xA;  , foo :: Foo    -- ^ new interface here&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And in handler we can use it in the same way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;handle :: Env -&amp;gt; Tag -&amp;gt; IO [Message]&#xA;handle (Env Db{..} Log{..} Foo{..}) tag = do&#xA;  -- use validTag from Foo &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that main service &lt;code&gt;Env&lt;/code&gt; does not change at all with this change. It only changes if we add a new API-route.&lt;/p&gt; &#xA;&lt;p&gt;Also we pass it to the local environment for &lt;code&gt;ListTag&lt;/code&gt; to make it compile. Again we get no errors on library level and we recompile only two modules if &lt;code&gt;Foo&lt;/code&gt; is already defined in &lt;code&gt;DI&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In the second option if we decide that this is hard to settle down and vague interface like &lt;code&gt;Db&lt;/code&gt; one. We create local version of the &lt;code&gt;Foo&lt;/code&gt; and keep it inside the handler module:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module Server.ListTag where&#xA;&#xA;data Env = Env&#xA;  { db  :: Db&#xA;  , log :: Log&#xA;  , foo :: Foo -- ^ new interface here&#xA;  }&#xA;&#xA;data Foo = Foo&#xA;  { validTag  :: Tag -&amp;gt; IO Bool &#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And that&#39;s it. We also recompile only two modules and get no errors on the library level.&lt;/p&gt; &#xA;&lt;h5&gt;Coding through the uncertainty&lt;/h5&gt; &#xA;&lt;p&gt;In web-applications domains are very flexible and features are incoherent at best and come to life and death as fast as the market wants them. And nothing can be done about that. Our domain is ocean wave and it&#39;s hard to build castles on top of it.&lt;/p&gt; &#xA;&lt;p&gt;But we are Haskellers. We are mathy people. We like beautiful solid Math interfaces.&lt;/p&gt; &#xA;&lt;p&gt;Forget it. This approach can lead to disaster in the web-application domain. The interfaces starting solid and cool quickly become incoherent and bloated.&lt;/p&gt; &#xA;&lt;p&gt;So instead of building rock solid, beautiful interfaces I propose to build local small interfaces that are easy to introduce and throw away if they are not needed. It makes us more flexible and easy to adapt to the changes.&lt;/p&gt; &#xA;&lt;h4&gt;Downsides of the approach&lt;/h4&gt; &#xA;&lt;p&gt;Let&#39;s consider some downsides.&lt;/p&gt; &#xA;&lt;h5&gt;Interface duplication&lt;/h5&gt; &#xA;&lt;p&gt;One downside that comes to mind is code duplication. Say we work as a team on new features. And our project uses small interfaces as this post advertised and we can build stuff in isolation and we are happy with that.&lt;/p&gt; &#xA;&lt;p&gt;But say what if sub-team A working on route A wants some interfaces that are local to the route B that team B works on. What should we do?&lt;/p&gt; &#xA;&lt;p&gt;Should we introduce cross dependencies or try to isolate or regroup interfaces in the &lt;code&gt;DI&lt;/code&gt;? This is an open question. If we take this approach to extreme we should allow the code to be duplicated. So the same local DB-method used in both cases should stay inside local version.&lt;/p&gt; &#xA;&lt;p&gt;And in the &lt;code&gt;DI&lt;/code&gt; implementation stage we will just use the same low-level function to instantiate it.&lt;/p&gt; &#xA;&lt;p&gt;This code duplication I think is a price that worth it. As we still don&#39;t get artificial coupling. Because as I stated our domain is always in flux. As it evolves what looked the same on Monday might become not so the same on Friday next month. And with this coupling introduced we will bring the unwonted change to the interface that does not really need it. But as coupling was codified we will forget that we need to keep them separate and we will bring stronger bound that will prevent changes from being local and flexible.&lt;/p&gt; &#xA;&lt;p&gt;I think that this is where software engineering stops to look like a Science and starts to look like like an Art. There is no right answer to this. We should balance it as we grow and our app grows. Some interfaces can be reused and we might want to solidify them to not to copy over and over. But some are real demons of change and it would be hard to keep them at bay. And we should use them localised per method.&lt;/p&gt; &#xA;&lt;p&gt;So it becomes the matter of taste and intuition. But starting small with local ones I think it pays off and great decision for web-application building. As it&#39;s much more flexible approach.&lt;/p&gt; &#xA;&lt;h3&gt;Service configs&lt;/h3&gt; &#xA;&lt;p&gt;Recommended way to organise service settings is with config file that is easy to read for humans (for example &lt;code&gt;YAML&lt;/code&gt; or &lt;code&gt;TOML&lt;/code&gt; formats). We can parse the &lt;code&gt;YAML&lt;/code&gt; with &lt;code&gt;yaml&lt;/code&gt; library and parse CLI-arguments with &lt;code&gt;optparse-applicative&lt;/code&gt; library. The code example is in the &lt;code&gt;app/Config.hs&lt;/code&gt;. For our app we can see the available options with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;stack run -- --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creation of middlewares&lt;/h3&gt; &#xA;&lt;p&gt;We can transform our interfaces to augment the default implementation with some new behavior. For example we can transform the DB-interface to add logging for every call to DB. This approach is implemented in the branch &lt;a href=&#34;https://github.com/anton-k/handle-pattern-servant-app/tree/middlewares&#34;&gt;&lt;code&gt;middlewares&lt;/code&gt;&lt;/a&gt;. Let&#39;s outline the idea.&lt;/p&gt; &#xA;&lt;p&gt;Take for example the interface to get the message by it&#39;s id:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Db = Db&#xA;  { getMessage :: MessageId -&amp;gt; IO (Maybe Message)&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can use logger to log every call to the interface:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;dbLog :: Log -&amp;gt; Db -&amp;gt; Db&#xA;dbLog logger (Db getMessage) = Db getMessage&#39;&#xA;  where&#xA;    Log{..} = addLogContext &#34;db.getMessage&#34;&#xA;&#xA;    getMessage&#39; msgId = do&#xA;      logInfo $ &#34;Input message id: &#34; &amp;lt;&amp;gt; display msgId&#xA;      mRes &amp;lt;- getMessage msgId&#xA;      case mRes of&#xA;        Just res -&amp;gt; logInfo $ &#34;Output message: &#34; &amp;lt;&amp;gt; display res&#xA;        Nothing  -&amp;gt; logError $ &#34;Failed to get message for id: &#34; &amp;lt;&amp;gt; display msgId&#xA;      pure mRes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We transform the Db-interface in a way that every call to &lt;code&gt;getMessage&lt;/code&gt; gets wrapped with logging calls. After that transformation we can even omit the logger from the dependency of the handler and we can just use transformed DB-interface.&lt;/p&gt; &#xA;&lt;p&gt;We can apply transformation in the &lt;code&gt;Main&lt;/code&gt; function prior to launch of the app:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;    -- init local envirnoments&#xA;    env =&#xA;      Env&#xA;        {&#xA;           save = ...&#xA;&#xA;           getMessage = &#xA;             let logGetMessage = addLogContext &#34;api.get-message&#34; ilog&#xA;             in  GetMessage.Env (GetMessage.dbLog logGetMessage idb.getMessage) logGetMessage&#xA;&#xA;           listTag = ...&#xA;&#xA;           toggleLogs = ...&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And we can do the same with DB-interfaces for other methods. This example shows how we can add middleware behavior to our interfaces without changing concrete implementation of the interface. We use interface at the input as a black box and augment it with some additional behavior. In this case it was logging.&lt;/p&gt; &#xA;&lt;h3&gt;Scaling up&lt;/h3&gt; &#xA;&lt;p&gt;So we have defined our small app. But story does not end there. We have to implement new and new API-routes and features and app becomes not so small. How to keep it small nonetheless?&lt;/p&gt; &#xA;&lt;p&gt;I think there is no answer to this. We have to balance on the waves. But in this section I&#39;d like to mention some further steps.&lt;/p&gt; &#xA;&lt;p&gt;For simplicity I kept all API definition in the single module &lt;code&gt;Api&lt;/code&gt;. In real case we can split it also to modules as we did it with handlers. This is a proper place not only for servant API definition but also for all transport types that are used for response and requests. We should keep it separate from domain types.&lt;/p&gt; &#xA;&lt;p&gt;Also we can go down to micro-service route and split the app by groups of logically related methods to separate services. On this stage our method with local interfaces can pay off well. As we already have separated environments we can define separate apps with local &lt;code&gt;Env&lt;/code&gt;&#39;s becoming top-level ones.&lt;/p&gt; &#xA;&lt;p&gt;But keep in mind the hidden dependencies of mutable state on the app initialization level. It can also become tangled. I advise instead of direct usage of &lt;code&gt;TVar&lt;/code&gt;&#39;s to wrap them to &lt;code&gt;newtype&lt;/code&gt;s and create the modules that provide meaningful interface for them so that &lt;code&gt;TVar&lt;/code&gt; details are hidden. This way it&#39;s easier to decouple things or see which one depends on which.&lt;/p&gt; &#xA;&lt;h3&gt;Conclusion&lt;/h3&gt; &#xA;&lt;p&gt;We have discussed a Handle pattern and how to use it to build flexible web-apps with servant that are easy to change and keep development with the wave.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s mention the points:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;we can organise application with interfaces as records&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;with this approach we can decouple implementation from the servant details&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;we can use local environments for groups of interfaces for API-routes and assemble them in the last stage on level of the server definition or we can swap it to micro-service design.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;local interfaces that are driven by the API-routes give more flexible solutions that are local to the compiling routine and more easy to think about at price of possible duplication.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;the web-app domain is ocean wave not a solid ground to build castles. So we need to build with presence of uncertainty and unexpected changes in mind. Which corresponds badly with mathematical thinking. We need to use more flexible solutions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Separation of interface definition and implementation on package level. Use executable (or separate package) for implementation and inside the library think in terms of open interfaces that are yet to be defined.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Mutable state can be hided behind interfaces completely. We can link internal dependencies in the initialisation step if interfaces want to communicate with each other.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Happy web-apps building with Haskell!&lt;/p&gt;</summary>
  </entry>
</feed>