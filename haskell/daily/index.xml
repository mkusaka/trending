<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-26T01:32:06Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>haskell/hie-bios</title>
    <updated>2022-12-26T01:32:06Z</updated>
    <id>tag:github.com,2022-12-26:/haskell/hie-bios</id>
    <link href="https://github.com/haskell/hie-bios" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Set up a GHC API session for various Haskell Projects&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;hie-bios&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#hie-bios&#34;&gt;hie-bios&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#explicit-configuration&#34;&gt;Explicit Configuration&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#stack&#34;&gt;Stack&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#debugging-a-stack-cradle&#34;&gt;Debugging a &lt;code&gt;stack&lt;/code&gt; cradle&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#ignoring-directories&#34;&gt;Ignoring directories&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#internal-libraries&#34;&gt;Internal Libraries&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#cabal&#34;&gt;Cabal&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#debugging-a-cabal-cradle&#34;&gt;Debugging a &lt;code&gt;cabal&lt;/code&gt; cradle&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#ignoring-directories-1&#34;&gt;Ignoring directories&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#bios&#34;&gt;Bios&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#debugging-a-bios-cradle&#34;&gt;Debugging a &lt;code&gt;bios&lt;/code&gt; cradle&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#direct&#34;&gt;Direct&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#debugging-a-direct-cradle&#34;&gt;Debugging a &lt;code&gt;direct&lt;/code&gt; cradle&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#none&#34;&gt;None&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#multi-cradle&#34;&gt;Multi-Cradle&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#cradle-dependencies&#34;&gt;Cradle Dependencies&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#configuration-specification&#34;&gt;Configuration specification&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#testing-your-configuration&#34;&gt;Testing your configuration&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#implicit-configuration&#34;&gt;Implicit Configuration&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#priority&#34;&gt;Priority&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#cabal-install&#34;&gt;&lt;code&gt;cabal-install&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#stack-1&#34;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#bios-1&#34;&gt;&lt;code&gt;bios&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#supporting-bazel-and-obelisk&#34;&gt;Supporting Bazel and Obelisk&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;hie-bios&lt;/code&gt; is the way to specify how &lt;a href=&#34;https://github.com/haskell/haskell-language-server&#34;&gt;&lt;code&gt;haskell-language-server&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://github.com/digital-asset/ghcide&#34;&gt;&lt;code&gt;ghcide&lt;/code&gt;&lt;/a&gt; set up a GHC API session.&lt;/p&gt; &#xA;&lt;p&gt;Given a Haskell project that is managed by Stack, Cabal, or other package tools, &lt;code&gt;haskell-language-server&lt;/code&gt; needs to know the full set of flags to pass to GHC in order to build the project. These flags might contain some compilation options like &lt;code&gt;-O2&lt;/code&gt;, but a lot of the time they are package dependencies such as &lt;code&gt;-package-id directory-1.3.6.0&lt;/code&gt;, which also need to be built beforehand. &lt;code&gt;hie-bios&lt;/code&gt; satisfies both these needs.&lt;/p&gt; &#xA;&lt;p&gt;Its design is motivated by the guiding principle:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;It is the responsibility of the build tool to describe the environment which a package should be built in.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Using this principle, it is possible to easily support a wide range of tools including &lt;code&gt;cabal-install&lt;/code&gt;, &lt;code&gt;stack&lt;/code&gt;, &lt;code&gt;rules_haskell&lt;/code&gt;, &lt;code&gt;hadrian&lt;/code&gt; and &lt;code&gt;obelisk&lt;/code&gt; without major contortions. &lt;code&gt;hie-bios&lt;/code&gt; does not depend on the &lt;code&gt;Cabal&lt;/code&gt; library nor does it read any complicated build products and so on.&lt;/p&gt; &#xA;&lt;p&gt;How does a tool specify a session? A session is fully specified by a set of standard GHC flags. Most tools already produce this information if they support a &lt;code&gt;repl&lt;/code&gt; command. Launching a repl is achieved by calling &lt;code&gt;ghci&lt;/code&gt; with the right flags to specify the package database. &lt;code&gt;hie-bios&lt;/code&gt; needs a way to get these flags and then it can set up a GHC API session correctly.&lt;/p&gt; &#xA;&lt;p&gt;Further it means that any failure to set up the API session is the responsibility of the build tool. It is up to them to provide the correct information if they want the tool to work correctly.&lt;/p&gt; &#xA;&lt;h2&gt;Explicit Configuration&lt;/h2&gt; &#xA;&lt;p&gt;The user can place a &lt;code&gt;hie.yaml&lt;/code&gt; file in the root of the workspace which describes how to set up the environment. There are several supported ways to setup the environment.&lt;/p&gt; &#xA;&lt;h3&gt;Stack&lt;/h3&gt; &#xA;&lt;p&gt;To explicitly state that you want to use &lt;code&gt;stack&lt;/code&gt;, the basic configuration &lt;code&gt;hie.yaml&lt;/code&gt; would look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  stack:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This configuration suffices if your whole project can be loaded by the command &lt;code&gt;stack repl&lt;/code&gt;. As a rule of thumb, this works if the project consists of only one executable, one library and one test-suite.&lt;/p&gt; &#xA;&lt;p&gt;Some projects have multiple &lt;code&gt;stack-*.yaml&lt;/code&gt; files for multiple versions of ghc/resolvers. In this case you can specify an alternate relative file to use by using the &lt;code&gt;stackYaml&lt;/code&gt; option. The path is relative to the configuration file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  stack:&#xA;    stackYaml: &#34;./stack-8.8.3.yaml&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your project is more complicated, you need to specify which &lt;a href=&#34;https://docs.haskellstack.org/en/stable/build_command/#components&#34;&gt;components&lt;/a&gt; you want to load. A component is, roughly speaking, a library/executable/test-suite or benchmark in &lt;code&gt;stack&lt;/code&gt;. You can view the components/targets of a stack project by executing the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ stack ide targets&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since we have two test-suites, one executable and a library, for &lt;code&gt;hie-bios&lt;/code&gt;, this would output the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ stack ide targets&#xA;hie-bios:lib&#xA;hie-bios:exe:hie-bios&#xA;hie-bios:test:bios-tests&#xA;hie-bios:test:parser-tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For an explanation of the target syntax, we refer to the documentation of the &lt;a href=&#34;https://docs.haskellstack.org/en/stable/build_command/#target-syntax&#34;&gt;target syntax&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To tell &lt;code&gt;hie-bios&lt;/code&gt; which component it should load, the following &lt;code&gt;hie.yaml&lt;/code&gt; can be used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  stack:&#xA;    component: &#34;&amp;lt;component name&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &lt;code&gt;&amp;lt;component name&amp;gt;&lt;/code&gt; is the name of the component/target you want to load. While the component is optional, this is recommended to make sure the correct component is loaded.&lt;/p&gt; &#xA;&lt;p&gt;Why is this not enough? Usually, you have multiple components with different dependencies. Your library won&#39;t depend on &lt;code&gt;tasty&lt;/code&gt; or &lt;code&gt;hspec&lt;/code&gt;, but your test-suite might. With this setup, you would only be able to load files from the given component.&lt;/p&gt; &#xA;&lt;p&gt;Since you rarely only want to load a single component in a &lt;code&gt;stack&lt;/code&gt; project, we have special syntax to be able to conveniently specify which directory belongs to which component. It is basically a &lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#multi-cradle&#34;&gt;multi-cradle&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  stack:&#xA;    - path: &#34;./src&#34;&#xA;      component: &#34;hie-bios:lib&#34;&#xA;    - path: &#34;./exe&#34;&#xA;      component: &#34;hie-bios:exe:hie-bios&#34;&#xA;    - path: &#34;./tests/BiosTests.hs&#34;&#xA;      component: &#34;hie-bios:test:hie-bios&#34;&#xA;    - path: &#34;./tests/ParserTests.hs&#34;&#xA;      component: &#34;hie-bios:test:parser-tests&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here you can see two important features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We provide a mapping from a filepath to component. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;That way, we specify that a file such as &lt;code&gt;./src/HIE/Bios.hs&lt;/code&gt; belongs to the component &lt;code&gt;hie-bios:lib&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The filepath can be a file. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This is convenient if components are overlapping.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This way we specified which component needs to be compiled given a source file for our whole project.&lt;/p&gt; &#xA;&lt;p&gt;If you use both, multiple components and an alternate &lt;code&gt;stack.yaml&lt;/code&gt; file, there is a way to specify defaults for the path-specific configurations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  stack:&#xA;    stackYaml: &#34;stack-8.3.3.yaml&#34;&#xA;    components:&#xA;    - path: &#34;./src&#34;&#xA;      component: &#34;hie-bios:lib&#34;&#xA;    - path: &#34;./exe&#34;&#xA;      component: &#34;hie-bios:exe:hie-bios&#34;&#xA;    - path: &#34;./tests/BiosTests.hs&#34;&#xA;      component: &#34;hie-bios:test:hie-bios&#34;&#xA;    - path: &#34;./tests/ParserTests.hs&#34;&#xA;      component: &#34;hie-bios:test:parser-tests&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A word of warning: Due to current restrictions in the language server, as mentioned in &lt;a href=&#34;https://github.com/haskell/haskell-language-server/issues/268#issuecomment-667640809&#34;&gt;this bug report&lt;/a&gt; all referenced stack.yaml files must specify the same version of GHC, as only one version of ghcide is loaded at a time per workspace root. This restriction might be lifted in the future.&lt;/p&gt; &#xA;&lt;h4&gt;Debugging a &lt;code&gt;stack&lt;/code&gt; cradle&lt;/h4&gt; &#xA;&lt;p&gt;If you find that &lt;code&gt;hie-bios&lt;/code&gt; can&#39;t load a certain component or file, run &lt;code&gt;stack repl&lt;/code&gt; and &lt;code&gt;stack repl &amp;lt;component name&amp;gt;&lt;/code&gt; to see if &lt;code&gt;stack&lt;/code&gt; succeeds in building your project. Chances are that there is a problem in your project and if you fix that, &lt;code&gt;hie-bios&lt;/code&gt; will succeed to load it.&lt;/p&gt; &#xA;&lt;p&gt;Also, see notes for &lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#testing-your-configuration&#34;&gt;testing your configuration&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Otherwise, please open an &lt;a href=&#34;https://github.com/mpickering/hie-bios/issues/new&#34;&gt;issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Ignoring directories&lt;/h4&gt; &#xA;&lt;p&gt;You can combine the &lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#multi-cradle&#34;&gt;multi-cradle&lt;/a&gt; with a &lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#none-cradle&#34;&gt;none-cradle&lt;/a&gt; to ignore all source files in a certain directory. The syntax is a bit verbose:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  multi:&#xA;    - path: &#34;./tests/projects&#34;&#xA;      config:&#xA;        cradle:&#xA;          none:&#xA;    - path: &#34;./&#34;&#xA;      config:&#xA;        cradle:&#xA;          stack:&#xA;            - path: &#34;./src&#34;&#xA;              component: &#34;hie-bios:lib&#34;&#xA;            - path: &#34;./exe&#34;&#xA;              component: &#34;hie-bios:exe:hie-bios&#34;&#xA;            - path: &#34;./tests/BiosTests.hs&#34;&#xA;              component: &#34;hie-bios:test:hie-bios&#34;&#xA;            - path: &#34;./tests/ParserTests.hs&#34;&#xA;              component: &#34;hie-bios:test:parser-tests&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This way, we specify that we do not want to load any files in our test project directories.&lt;/p&gt; &#xA;&lt;h4&gt;Internal Libraries&lt;/h4&gt; &#xA;&lt;p&gt;Internal libraries are not well supported in &lt;code&gt;stack&lt;/code&gt;. Since the syntax &lt;code&gt;stack repl &amp;lt;internal library name&amp;gt;&lt;/code&gt; &lt;a href=&#34;https://github.com/commercialhaskell/stack/issues/4564&#34;&gt;doesn&#39;t work&lt;/a&gt;, &lt;code&gt;hie-bios&lt;/code&gt; will generally not work with internal libraries using &lt;code&gt;stack&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Cabal&lt;/h3&gt; &#xA;&lt;p&gt;To use &lt;code&gt;cabal&lt;/code&gt;, the basic explicit configuration looks similar to &lt;code&gt;stack&lt;/code&gt;&#39;s configuration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  cabal:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The implication of this configuration is a bit different, though. Given a source file to load, we will use &lt;code&gt;cabal repl &amp;lt;filename&amp;gt;&lt;/code&gt; to find the component of the given filepath.&lt;/p&gt; &#xA;&lt;p&gt;This configuration should work in (almost) every standard project setup, since &lt;code&gt;cabal&lt;/code&gt; finds the component associated to a given source file. However, due to an unfortunate &lt;a href=&#34;https://github.com/haskell/cabal/issues/6622&#34;&gt;bug&lt;/a&gt;, this fails on some files with &lt;code&gt;cabal&lt;/code&gt; versions older than &lt;code&gt;3.4&lt;/code&gt;. So, to make your project loadable by older &lt;code&gt;cabal&lt;/code&gt; versions, you can specify a component to load. A &lt;a href=&#34;https://cabal.readthedocs.io/en/latest/nix-local-build.html?highlight=component#cabal-v2-build&#34;&gt;component&lt;/a&gt; is roughly speaking a library, executable, test-suite or benchmark in &lt;code&gt;cabal&lt;/code&gt;. The &lt;code&gt;hie.yaml&lt;/code&gt; file looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  cabal:&#xA;    component: &amp;lt;component name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This tells &lt;code&gt;hie-bios&lt;/code&gt; that whichever source file it tries to load, this source file should be handled as if it belongs to &lt;code&gt;&amp;lt;component name&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As an example, to load the library of &lt;code&gt;hie-bios&lt;/code&gt;, the following &lt;code&gt;hie.yaml&lt;/code&gt; can be used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  cabal:&#xA;    component: &#34;lib:hie-bios&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The component syntax &lt;code&gt;&#34;lib:hie-bios&#34;&lt;/code&gt; refers to the library of the package &lt;code&gt;hie-bios&lt;/code&gt;. For a complete reference of the component syntax, we refer to the &lt;a href=&#34;https://cabal.readthedocs.io/en/latest/nix-local-build.html?highlight=component#cabal-v2-build&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;cabal&lt;/code&gt; and &lt;code&gt;stack&lt;/code&gt; have different ways of specifying their components.&lt;/p&gt; &#xA;&lt;p&gt;If we only specify a single component, then we can only load source files from this component. This is unsatisfactory as we want to be able to navigate our project freely and work on multiple components (test-suite, library, executable, etc...) in parallel.&lt;/p&gt; &#xA;&lt;p&gt;In a project such as &lt;code&gt;hie-bios&lt;/code&gt;, we have more than one component, in particular we have four:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;An executable&lt;/li&gt; &#xA; &lt;li&gt;A library&lt;/li&gt; &#xA; &lt;li&gt;Two test-suites&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The component syntax can easily be extracted from the &lt;code&gt;hie-bios.cabal&lt;/code&gt; file. Relevant sections are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cabal&#34;&gt;...&#xA;Name:                   hie-bios&#xA;...&#xA;&#xA;Library&#xA;  ...&#xA;  HS-Source-Dirs:       src&#xA;&#xA;Executable hie-bios&#xA;  ...&#xA;  Main-Is:              Main.hs&#xA;  HS-Source-Dirs:       exe&#xA;&#xA;test-suite parser-tests&#xA;  ...&#xA;  hs-source-dirs: tests/&#xA;  main-is: ParserTests.hs&#xA;&#xA;test-suite bios-tests&#xA;  ...&#xA;  hs-source-dirs: tests/&#xA;  main-is: BiosTests.hs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using the documentation of cabal, we extract the four component names of the &lt;code&gt;hie-bios&lt;/code&gt; project:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lib:hie-bios&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;exe:hie-bios&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;test:bios-tests&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;test:parser-tests&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since you rarely only want to load a single component in a &lt;code&gt;cabal&lt;/code&gt; project, we have special syntax to be able to conveniently specify which directory belongs to which component. It is basically a &lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#multi-cradle&#34;&gt;multi-cradle&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  cabal:&#xA;    - path: &#34;./src&#34;&#xA;      component: &#34;lib:hie-bios&#34;&#xA;    - path: &#34;./exe&#34;&#xA;      component: &#34;exe:hie-bios&#34;&#xA;    - path: &#34;./tests/BiosTests.hs&#34;&#xA;      component: &#34;test:hie-bios&#34;&#xA;    - path: &#34;./tests/ParserTests.hs&#34;&#xA;      component: &#34;test:parser-tests&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here you can see two important features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We provide a mapping from filepath to component. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;That way, we specify that a file such as &lt;code&gt;./src/HIE/Bios.hs&lt;/code&gt; belongs to the component &lt;code&gt;lib:hie-bios&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The filepath can be a file. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This is convenient if components are overlapping.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Similarly to &lt;code&gt;multi-stack&lt;/code&gt; configurations, you can also specify multiple components using a &lt;code&gt;components&lt;/code&gt; subkey. While this is currently not used for anything, this syntax gives you a place to put defaults, directly under the &lt;code&gt;cabal&lt;/code&gt; entry.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  cabal:&#xA;    # Reserved for future default options&#xA;    components:&#xA;    - path: &#34;./src&#34;&#xA;      component: &#34;lib:hie-bios&#34;&#xA;    - path: &#34;./exe&#34;&#xA;      component: &#34;exe:hie-bios&#34;&#xA;    - path: &#34;./tests/BiosTests.hs&#34;&#xA;      component: &#34;test:hie-bios&#34;&#xA;    - path: &#34;./tests/ParserTests.hs&#34;&#xA;      component: &#34;test:parser-tests&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This way we specified which component needs to be compiled given a certain source file for our whole project.&lt;/p&gt; &#xA;&lt;h4&gt;Debugging a &lt;code&gt;cabal&lt;/code&gt; cradle&lt;/h4&gt; &#xA;&lt;p&gt;If you find that &lt;code&gt;hie-bios&lt;/code&gt; can&#39;t load a certain component or file, you may run &lt;code&gt;cabal repl &amp;lt;filename&amp;gt;&lt;/code&gt; and &lt;code&gt;cabal repl &amp;lt;component name&amp;gt;&lt;/code&gt; to see if &lt;code&gt;cabal&lt;/code&gt; succeeds in building the components. Chances are that there is a problem and if you fix that, &lt;code&gt;hie-bios&lt;/code&gt; will succeed to load the project.&lt;/p&gt; &#xA;&lt;p&gt;Also, see notes for &lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#testing-your-configuration&#34;&gt;testing your configuration&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Otherwise, please open an &lt;a href=&#34;https://github.com/mpickering/hie-bios/issues/new&#34;&gt;issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Ignoring directories&lt;/h4&gt; &#xA;&lt;p&gt;You can combine the &lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#multi-cradle&#34;&gt;multi-cradle&lt;/a&gt; with a &lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#none-cradle&#34;&gt;none-cradle&lt;/a&gt; to ignore all source files in a certain directory. The syntax is a bit verbose:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  multi:&#xA;    - path: &#34;./tests/projects&#34;&#xA;      config:&#xA;        cradle:&#xA;          none:&#xA;    - path: &#34;./&#34;&#xA;      config:&#xA;        cradle:&#xA;          cabal:&#xA;            - path: &#34;./src&#34;&#xA;              component: &#34;lib:hie-bios&#34;&#xA;            - path: &#34;./exe&#34;&#xA;              component: &#34;exe:hie-bios&#34;&#xA;            - path: &#34;./tests/BiosTests.hs&#34;&#xA;              component: &#34;test:hie-bios&#34;&#xA;            - path: &#34;./tests/ParserTests.hs&#34;&#xA;              component: &#34;test:parser-tests&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This way, we specify that we do not want to load any files in our test project directories.&lt;/p&gt; &#xA;&lt;h3&gt;Bios&lt;/h3&gt; &#xA;&lt;p&gt;Alternatively you can explicitly state a &lt;code&gt;program&lt;/code&gt; or shell command which should be used to collect the options. This is the most general approach and can be extended to handle arbitrary build systems.&lt;/p&gt; &#xA;&lt;p&gt;The path of the &lt;code&gt;program&lt;/code&gt; attribute is interpreted relative to the current working directory if it isn&#39;t absolute. A program is passed the file to return options for as its first argument, and a shell command will have it available in the &lt;code&gt;HIE_BIOS_ARG&lt;/code&gt; environment variable.&lt;/p&gt; &#xA;&lt;p&gt;There are two important environment variables:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;HIE_BIOS_OUTPUT&lt;/code&gt;: describes the filepath the options should be written to. If this file does not exist, the &lt;code&gt;program&lt;/code&gt; should create it.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;HIE_BIOS_ARG&lt;/code&gt;: the source file that we want to load. Options returned by the &lt;code&gt;program&lt;/code&gt; should be able to compile the given source file. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This environment variable is &lt;em&gt;only&lt;/em&gt; available if a shell program is given.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The program flow is roughly as follows: The process must consult the &lt;code&gt;HIE_BIOS_OUTPUT&lt;/code&gt; environment variable and write a list of options to this file, separated by newlines. Once the process finishes running, &lt;code&gt;hie-bios&lt;/code&gt; reads this file and uses the arguments to set up the GHC session. This is how GHC&#39;s build system is able to support &lt;code&gt;hie-bios&lt;/code&gt;. Note, the &lt;code&gt;program&lt;/code&gt; is intended to produce the build flags to compile the &lt;em&gt;whole&lt;/em&gt; component the given source file belongs to. This entails that the &lt;code&gt;program&lt;/code&gt; lists all of the component&#39;s module- and file targets.&lt;/p&gt; &#xA;&lt;p&gt;A good guiding specification for this file is that the following commands should work for any file in your project.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ export HIE_BIOS_OUTPUT=./options.txt # this is usually some temporary file&#xA;$ ./&amp;lt;program&amp;gt; /path/to/foo.hs&#xA;$ ghci $(cat $HIE_BIOS_OUTPUT | tr &#39;\n&#39; &#39; &#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &lt;code&gt;HIE_BIOS_OUTPUT&lt;/code&gt; is some chosen output file and &lt;code&gt;HIE_BIOS_ARG&lt;/code&gt; contains the file parameter.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;hie.yaml&lt;/code&gt; configuration looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  bios:&#xA;    program: &#34;&amp;lt;program&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you may specify shell code directly. This is helpful, if your &lt;code&gt;program&lt;/code&gt; executable consists of only a single call to another executable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  bios:&#xA;    shell: &#34;&amp;lt;build-tool flags $HIE_BIOS_ARG&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, you may specify the path to ghc. Otherwise, the one in the PATH will be used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  bios:&#xA;    program: &#34;&amp;lt;program&amp;gt;&#34;&#xA;    with-ghc: &#34;&amp;lt;ghc&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Debugging a &lt;code&gt;bios&lt;/code&gt; cradle&lt;/h4&gt; &#xA;&lt;p&gt;The most common error in creating &lt;code&gt;bios&lt;/code&gt; cradle is to not list all targets of the component. Please make sure, that you always list all targets of the component, associated with the filepath you want to load.&lt;/p&gt; &#xA;&lt;p&gt;Also, see notes for &lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#testing-your-configuration&#34;&gt;testing your configuration&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Direct&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;direct&lt;/code&gt; cradle allows you to specify exactly the GHC options that should be used to load a project. This is good for debugging but not a very good approach in general as the set of options will quickly get out of sync with a cabal file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  direct:&#xA;    arguments: [arg1, arg2]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Debugging a &lt;code&gt;direct&lt;/code&gt; cradle&lt;/h4&gt; &#xA;&lt;p&gt;The arguments of a &lt;code&gt;direct&lt;/code&gt; cradle will be passed almost directly to &lt;code&gt;ghc&lt;/code&gt;. If the command &lt;code&gt;ghc &amp;lt;cradle arguments&amp;gt;&lt;/code&gt; succeeds, then &lt;code&gt;hie-bios&lt;/code&gt; can load the project.&lt;/p&gt; &#xA;&lt;h3&gt;None&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;none&lt;/code&gt; cradle says that the IDE shouldn&#39;t even try to load the project. It is most useful when combined with the &lt;a href=&#34;https://raw.githubusercontent.com/haskell/hie-bios/master/#multi-cradle&#34;&gt;multi-cradle&lt;/a&gt; which is specified in the next section.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  none:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Multi-Cradle&lt;/h2&gt; &#xA;&lt;p&gt;For a multi-component project you can use the multi-cradle to specify how each subdirectory of the project should be handled by the IDE.&lt;/p&gt; &#xA;&lt;p&gt;The multi-cradle is a list of relative paths and cradle configurations. The path is relative to the configuration file and specifies the scope of the cradle. For example, this configuration specifies that files in the &lt;code&gt;src&lt;/code&gt; subdirectory should be handled with the &lt;code&gt;lib:hie-bios&lt;/code&gt; component and files in the &lt;code&gt;test&lt;/code&gt; directory using the &lt;code&gt;test:bios-tests&lt;/code&gt; component.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  multi:&#xA;    - path: &#34;./src&#34;&#xA;      config:&#xA;        cradle:&#xA;          cabal:&#xA;            component: &#34;lib:hie-bios&#34;&#xA;    - path: &#34;./test&#34;&#xA;      config:&#xA;        cradle:&#xA;          cabal:&#xA;            component: &#34;test:bios-tests&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If a file matches multiple prefixes, the most specific one is chosen. Once a prefix is matched, the selected cradle is used to find the options. This is usually a specific cradle such as &lt;code&gt;cabal&lt;/code&gt; or &lt;code&gt;stack&lt;/code&gt; but it could be another multi-cradle, in which case, matching works in exactly the same way until a specific cradle is chosen.&lt;/p&gt; &#xA;&lt;p&gt;This cradle type is experimental and may not be supported correctly by some libraries which use &lt;code&gt;hie-bios&lt;/code&gt;. It requires some additional care to correctly manage multiple components.&lt;/p&gt; &#xA;&lt;p&gt;Note: Remember you can use the multi-cradle to declare that certain directories shouldn&#39;t be loaded by an IDE, in conjunction with the &lt;code&gt;none&lt;/code&gt; cradle.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  multi:&#xA;    - path: &#34;./src&#34;&#xA;      config: { cradle: {cabal: {component: &#34;lib:hie-bios&#34;}} }&#xA;    - path: &#34;./test&#34;&#xA;      config: { cradle: {cabal: {component: &#34;test:bios-tests&#34;}} }&#xA;    - path: &#34;./test/test-files&#34;&#xA;      config: { cradle: { none: } }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For cabal and stack projects there is a shorthand to specify how to load each component.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  cabal:&#xA;    - path: &#34;./src&#34;&#xA;      component: &#34;lib:hie-bios&#34;&#xA;    - path: &#34;./test&#34;&#xA;      component: &#34;test:bios-tests&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  stack:&#xA;    - path: &#34;./src&#34;&#xA;      component: &#34;hie-bios:lib&#34;&#xA;    - path: &#34;./test&#34;&#xA;      component: &#34;hie-bios:test:bios-tests&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Remember you can combine this shorthand with more complicated configurations as well.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  multi:&#xA;    - path: &#34;./test/testdata&#34;&#xA;      config: { cradle: { none:  } }&#xA;    - path: &#34;./&#34;&#xA;      config: { cradle: { cabal:&#xA;                            [ { path: &#34;./src&#34;, component: &#34;lib:hie-bios&#34; }&#xA;                            , { path: &#34;./tests&#34;, component: &#34;parser-tests&#34; } ] } }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Cradle Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes it is necessary to reload a component, for example when a package dependency is added to the project. Each type of cradle defines a list of files that might cause an existing cradle to no longer provide accurate diagnostics if changed. These are expected to be relative to the root of the cradle.&lt;/p&gt; &#xA;&lt;p&gt;This makes it possible to watch for changes to these files and reload the cradle appropiately. However, if there are files that are not covered by the cradle dependency resolution, you can add these files explicitly to &lt;code&gt;hie.yaml&lt;/code&gt;. The file dependencies are not required to actually exist, since it can be useful to know when they are created, e.g. if there was no &lt;code&gt;cabal.project&lt;/code&gt; in the project before and now there is, it might change how a file in the project is compiled.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example of how you would add cradle dependencies that may not be covered by the &lt;code&gt;cabal&lt;/code&gt; cradle.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  cabal:&#xA;    component: &#34;lib:hie-bios&#34;&#xA;&#xA;dependencies:&#xA;  - package.yaml&#xA;  - shell.nix&#xA;  - default.nix&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For the &lt;code&gt;Bios&lt;/code&gt; cradle type, the newline-separated cradle dependencies must be written out to the file specified by the &lt;code&gt;HIE_BIOS_DEPS&lt;/code&gt; environment variable.&lt;/p&gt; &#xA;&lt;p&gt;Previous versions implemented a different mechanism for collecting cradle dependencies by means of a second program/shell field. This is still supported for backwards compatibility:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  bios:&#xA;    dependency-program: ./dependency.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  bios:&#xA;    dependency-shell: build-tool dependencies $HIE_BIOS_ARG &amp;gt; $HIE_BIOS_OUTPUT&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration specification&lt;/h2&gt; &#xA;&lt;p&gt;The complete configuration is a subset of&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cradle:&#xA;  cabal:&#xA;    component: &#34;optional component name&#34;&#xA;  stack:&#xA;    component: &#34;optional component name&#34;&#xA;  bios:&#xA;    program: &#34;program to run&#34;&#xA;    dependency-program: &#34;optional program to run&#34;&#xA;    shell: build-tool flags $HIE_BIOS_ARG&#xA;    dependency-shell: build-tool dependencies $HIE_BIOS_ARG&#xA;    with-ghc: &#34;optional path to ghc&#34;&#xA;  direct:&#xA;    arguments: [&#34;list&#34;,&#34;of&#34;,&#34;ghc&#34;,&#34;arguments&#34;]&#xA;  none:&#xA;  multi: - path: ./&#xA;           config: { cradle: ... }&#xA;&#xA;dependencies:&#xA;  - someDep&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing your configuration&lt;/h2&gt; &#xA;&lt;p&gt;The given &lt;code&gt;hie-bios&lt;/code&gt; executable is provided to test your configuration.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;flags&lt;/code&gt; command will print out the options that &lt;code&gt;hie-bios&lt;/code&gt; thinks you will need to load a file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ hie-bios flags exe/Main.hs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;check&lt;/code&gt; command will try to use these flags to load the module into the GHC API.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ hie-bios check exe/Main.hs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;debug&lt;/code&gt; command prints verbose information about the cradle, such as where the &lt;code&gt;hie.yaml&lt;/code&gt; file was found, which file is loaded and the options that will eventually be used for loading a session.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ hie-bios debug exe/Main.hs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Implicit Configuration&lt;/h2&gt; &#xA;&lt;p&gt;There are several built in modes which capture the most common Haskell development scenarios. If no &lt;code&gt;hie.yaml&lt;/code&gt; configuration file is found then an implicit configuration is searched for. It is strongly recommended to just explicitly configure your project.&lt;/p&gt; &#xA;&lt;h3&gt;Priority&lt;/h3&gt; &#xA;&lt;p&gt;The targets are searched for in the following order.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;A specific &lt;code&gt;.hie-bios&lt;/code&gt; file.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;stack&lt;/code&gt; project&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;cabal&lt;/code&gt; project&lt;/li&gt; &#xA; &lt;li&gt;The direct cradle which has no specific options.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;&lt;code&gt;cabal-install&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The workspace root is the first folder containing a &lt;code&gt;cabal.project&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;The arguments are collected by running &lt;code&gt;cabal v2-repl &amp;lt;filename&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;cabal v2-repl &amp;lt;filename&amp;gt;&lt;/code&gt; fails, then the user needs to configure the correct target to use by writing a &lt;code&gt;hie.yaml&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The workspace root is the first folder containing a &lt;code&gt;stack.yaml&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;The arguments are collected by executing &lt;code&gt;stack repl&lt;/code&gt;. If this fails, the user needs to configure the correct target to use by writing a &lt;code&gt;hie.yaml&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;bios&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The most general form is the &lt;code&gt;bios&lt;/code&gt; mode which allows users to specify which flags to provide themselves.&lt;/p&gt; &#xA;&lt;p&gt;The program will receive the file to return options for as its first argument.&lt;/p&gt; &#xA;&lt;p&gt;The program flow is roughly as follows: The process must consult the &lt;code&gt;HIE_BIOS_OUTPUT&lt;/code&gt; environment variable and write a list of options to the file pointed to by &lt;code&gt;HIE_BIOS_OUTPUT&lt;/code&gt;, separated by newlines. Once the process finishes running, &lt;code&gt;hie-bios&lt;/code&gt; reads this file and uses the arguments to set up the GHC session. This is how GHC&#39;s build system is able to support &lt;code&gt;hie-bios&lt;/code&gt;. Note, the &lt;code&gt;program&lt;/code&gt; is intended to produce the build flags to compile the &lt;em&gt;whole&lt;/em&gt; component the given source file belongs to. This entails that the &lt;code&gt;program&lt;/code&gt; lists all of the component&#39;s module- and file targets.&lt;/p&gt; &#xA;&lt;p&gt;A good guiding specification for this file is that the following commands should work for any file in your project.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ export HIE_BIOS_OUTPUT=./options.txt # this is usually some temporary file&#xA;$ ./.hie-bios /path/to/foo.hs&#xA;$ ghci $(cat $HIE_BIOS_OUTPUT | tr &#39;\n&#39; &#39; &#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is useful if you are designing a new build system or the other modes fail to setup the correct session for some reason. For example, this is how hadrian (GHC&#39;s build system) is integrated into &lt;code&gt;hie-bios&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Supporting Bazel and Obelisk&lt;/h2&gt; &#xA;&lt;p&gt;In previous versions of &lt;code&gt;hie-bios&lt;/code&gt; there was also support for projects using &lt;code&gt;rules_haskell&lt;/code&gt; and &lt;code&gt;obelisk&lt;/code&gt;. This was removed in the 0.3 release as they were unused and broken. There is no conceptual barrier to adding back support but it requires a user of these two approaches to maintain them.&lt;/p&gt;</summary>
  </entry>
</feed>