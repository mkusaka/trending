<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-24T01:38:25Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>aaronallen8455/breakpoint</title>
    <updated>2022-08-24T01:38:25Z</updated>
    <id>tag:github.com,2022-08-24:/aaronallen8455/breakpoint</id>
    <link href="https://github.com/aaronallen8455/breakpoint" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Set breakpoints using a GHC plugin&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Breakpoint&lt;/h1&gt; &#xA;&lt;p&gt;The ability to set breakpoints in a program can provide valuable insights when debugging. While GHCi has built-in support for setting breakpoints, it is not actively maintained and suffers from several critical limitations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It&#39;s prohibitively buggy when used with concurrent programs, such as web servers.&lt;/li&gt; &#xA; &lt;li&gt;Breakpoints can only be set in interpreted code.&lt;/li&gt; &#xA; &lt;li&gt;Occasionally it simply doesn&#39;t work at all.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;breakpoint&lt;/code&gt; library solves these problems by implementing breakpoints as a GHC plugin.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;Add &lt;code&gt;breakpoint&lt;/code&gt; as a dependency to your project then enable breakpoints in a module by adding &lt;code&gt;{-# OPTIONS_GHC -fplugin Debug.Breakpoint #-}&lt;/code&gt; to the top of the file and importing the &lt;code&gt;Debug.Breakpoint&lt;/code&gt; module. You can then use the &lt;code&gt;breakpoint&lt;/code&gt;, &lt;code&gt;breakpointIO&lt;/code&gt;, or &lt;code&gt;breakpointM&lt;/code&gt; functions as appropriate to set a breakpoint.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;breakpoint :: a -&amp;gt; a&lt;/code&gt; is for use in pure code. Apart from the side-effect of setting a breakpoint, it is the identity function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;breakpointIO :: MonadIO m =&amp;gt; m ()&lt;/code&gt; is for monadic code that can perform IO.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;breakpointM :: Applicative f =&amp;gt; f ()&lt;/code&gt; is for arbitrary &lt;code&gt;Applicative&lt;/code&gt; contexts.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;breakpoint&lt;/code&gt; and &lt;code&gt;breakpointM&lt;/code&gt; both use &lt;code&gt;unsafePerformIO&lt;/code&gt; which means they are at the mercy of the simplifier and all the other pitfalls of lazy IO. For this reason, it&#39;s generally preferable to use &lt;code&gt;breakpointIO&lt;/code&gt; in contexts that support it.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example module:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# OPTIONS_GHC -fplugin Debug.Breakpoint #-}&#xA;&#xA;import Debug.Breakpoint&#xA;&#xA;main :: IO ()&#xA;main = do&#xA;  x &amp;lt;- getLine&#xA;  let y = 2 :: Int&#xA;      z = id :: Bool -&amp;gt; Bool&#xA;  breakpointIO&#xA;  pure ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When the breakpoint expression gets evaluated, you will see terminal output such as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;### Breakpoint Hit ###&#xA;(app/Main.hs:24:3-6)&#xA;x = &#34;input&#34;&#xA;y = 2&#xA;z = &amp;lt;Bool -&amp;gt; Bool&amp;gt;&#xA;&#xA;Press enter to continue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;showing the location of the breakpoint and the free variables that are visible from the callsite, this includes function arguments, let bindings, where binds, monadic binds, pattern binds, etc.&lt;/p&gt; &#xA;&lt;p&gt;If the type of a value has a &lt;code&gt;Show&lt;/code&gt; instance then that will be used to generate the printed value, otherwise the output will contain the type of the value within angle brackets.&lt;/p&gt; &#xA;&lt;p&gt;Execution of the program effectively halts on waiting for user input. In concurrent programs, all threads will be stopped, not just the one executing the breakpoint (GHC &amp;gt;= 9.2.x only).&lt;/p&gt; &#xA;&lt;h3&gt;Querying variables&lt;/h3&gt; &#xA;&lt;p&gt;In contrast to the standard breakpoint functions which print out the values for all current variables, the &lt;code&gt;queryVars&lt;/code&gt;, &lt;code&gt;queryVarsM&lt;/code&gt;, and &lt;code&gt;queryVarsIO&lt;/code&gt; functions first print the variables names and then initiate a prompt where you can enter a specific variable name to have its value printed.&lt;/p&gt; &#xA;&lt;p&gt;This is useful if you are only interested in certain values or if printing one or more values would result in a non-terminating process (an infinite data structure for example).&lt;/p&gt; &#xA;&lt;p&gt;You can tab-complete variable names at the query prompt. Only the current thread is blocked while the prompt is active. To resume execution, press enter with a blank line.&lt;/p&gt; &#xA;&lt;h3&gt;Caveats&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Currently only supports GHC version 8.10.x, 9.0.x, and 9.2.x&lt;/li&gt; &#xA; &lt;li&gt;Printing values may cause thunks to be evaluated earlier than they otherwise would which could be problematic for programs that rely heavily on laziness.&lt;/li&gt; &#xA; &lt;li&gt;Calls to &lt;code&gt;threadDelay&lt;/code&gt; are not paused by breakpoints in the sense that time continues to elapse, however they won&#39;t unblock until the breakpoint finishes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt; can sometimes cause variables that are in scope to not be traced.&lt;/li&gt; &#xA; &lt;li&gt;Implicit params are not currently supported&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RecursiveDo&lt;/code&gt; binds aren&#39;t visible before they are bound, despite being in scope.&lt;/li&gt; &#xA; &lt;li&gt;If there is anything buffered in &lt;code&gt;stdin&lt;/code&gt; then that will interfere with the blocking mechanism.&lt;/li&gt; &#xA; &lt;li&gt;Concurrent threads are not blocked in GHC &amp;lt; 9.2.x&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>digital-asset/ghc</title>
    <updated>2022-08-24T01:38:25Z</updated>
    <id>tag:github.com,2022-08-24:/digital-asset/ghc</id>
    <link href="https://github.com/digital-asset/ghc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fork of GHC (https://gitlab.haskell.org/ghc/ghc.git)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Glasgow Haskell Compiler&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://travis-ci.org/ghc/ghc&#34;&gt;&lt;img src=&#34;https://api.travis-ci.org/ghc/ghc.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is the source tree for &lt;a href=&#34;http://www.haskell.org/ghc/&#34; title=&#34;www.haskell.org/ghc/&#34;&gt;GHC&lt;/a&gt;, a compiler and interactive environment for the Haskell functional programming language.&lt;/p&gt; &#xA;&lt;p&gt;For more information, visit &lt;a href=&#34;http://www.haskell.org/ghc/&#34; title=&#34;www.haskell.org/ghc/&#34;&gt;GHC&#39;s web site&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Information for developers of GHC can be found on the &lt;a href=&#34;http://ghc.haskell.org/trac/ghc&#34; title=&#34;ghc.haskell.org/trac/ghc&#34;&gt;GHC Trac&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Getting the Source&lt;/h1&gt; &#xA;&lt;p&gt;There are two ways to get a source tree:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;em&gt;Download source tarballs&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Download the GHC source distribution:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    ghc-&amp;lt;version&amp;gt;-src.tar.bz2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which contains GHC itself and the &#34;boot&#34; libraries.&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Check out the source code from git&lt;/em&gt;&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ git clone --recursive git@gitlab.haskell.org:ghc/ghc.git&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Note: cloning GHC from Github requires a special setup. See &lt;a href=&#34;https://ghc.haskell.org/trac/ghc/wiki/Building/GettingTheSources#GettingaGHCrepositoryfromGitHub&#34; title=&#34;https://ghc.haskell.org/trac/ghc/wiki/Building/GettingTheSources#GettingaGHCrepositoryfromGitHub&#34;&gt;Getting a GHC repository from Github&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;See the GHC team&#39;s working conventions regarding &lt;a href=&#34;http://ghc.haskell.org/trac/ghc/wiki/WorkingConventions/FixingBugs&#34;&gt;how to contribute a patch to GHC&lt;/a&gt;.&lt;/em&gt; First time contributors are encouraged to get started by just sending a Pull Request.&lt;/p&gt; &#xA;&lt;h1&gt;Building &amp;amp; Installing&lt;/h1&gt; &#xA;&lt;p&gt;For full information on building GHC, see the &lt;a href=&#34;http://ghc.haskell.org/trac/ghc/wiki/Building&#34; title=&#34;ghc.haskell.org/trac/ghc/wiki/Building&#34;&gt;GHC Building Guide&lt;/a&gt;. Here follows a summary - if you get into trouble, the Building Guide has all the answers.&lt;/p&gt; &#xA;&lt;p&gt;Before building GHC you may need to install some other tools and libraries. See, &lt;a href=&#34;http://ghc.haskell.org/trac/ghc/wiki/Building/Preparation&#34; title=&#34;http://ghc.haskell.org/trac/ghc/wiki/Building/Preparation&#34;&gt;Setting up your system for building GHC&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NB.&lt;/em&gt; In particular, you need &lt;a href=&#34;http://www.haskell.org/ghc/&#34; title=&#34;www.haskell.org/ghc/&#34;&gt;GHC&lt;/a&gt; installed in order to build GHC, because the compiler is itself written in Haskell. You also need &lt;a href=&#34;http://www.haskell.org/happy/&#34; title=&#34;www.haskell.org/happy/&#34;&gt;Happy&lt;/a&gt;, &lt;a href=&#34;http://www.haskell.org/alex/&#34; title=&#34;www.haskell.org/alex/&#34;&gt;Alex&lt;/a&gt;, and &lt;a href=&#34;http://www.haskell.org/cabal/&#34; title=&#34;http://www.haskell.org/cabal/&#34;&gt;Cabal&lt;/a&gt;. For instructions on how to port GHC to a new platform, see the &lt;a href=&#34;http://ghc.haskell.org/trac/ghc/wiki/Building&#34; title=&#34;ghc.haskell.org/trac/ghc/wiki/Building&#34;&gt;GHC Building Guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For building library documentation, you&#39;ll need &lt;a href=&#34;http://www.haskell.org/haddock/&#34; title=&#34;www.haskell.org/haddock/&#34;&gt;Haddock&lt;/a&gt;. To build the compiler documentation, you need &lt;a href=&#34;http://www.sphinx-doc.org/&#34;&gt;Sphinx&lt;/a&gt; and Xelatex (only for PDF output).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Quick start&lt;/strong&gt;: the following gives you a default build:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./boot&#xA;$ ./configure&#xA;$ make         # can also say &#39;make -jX&#39; for X number of jobs&#xA;$ make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Windows, you need an extra repository containing some build tools. These can be downloaded for you by configure. This only needs to be done once by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./configure --enable-tarballs-autodownload&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(NB: &lt;strong&gt;Do you have multiple cores? Be sure to tell that to &lt;code&gt;make&lt;/code&gt;!&lt;/strong&gt; This can save you hours of build time depending on your system configuration, and is almost always a win regardless of how many cores you have. As a simple rule, you should have about N+1 jobs, where &lt;code&gt;N&lt;/code&gt; is the amount of cores you have.)&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;./boot&lt;/code&gt; step is only necessary if this is a tree checked out from git. For source distributions downloaded from &lt;a href=&#34;http://www.haskell.org/ghc/&#34; title=&#34;www.haskell.org/ghc/&#34;&gt;GHC&#39;s web site&lt;/a&gt;, this step has already been performed.&lt;/p&gt; &#xA;&lt;p&gt;These steps give you the default build, which includes everything optimised and built in various ways (eg. profiling libs are built). It can take a long time. To customise the build, see the file &lt;code&gt;HACKING.md&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Filing bugs and feature requests&lt;/h1&gt; &#xA;&lt;p&gt;If you&#39;ve encountered what you believe is a bug in GHC, or you&#39;d like to propose a feature request, please let us know! Submit a ticket in our &lt;a href=&#34;http://ghc.haskell.org/trac/ghc/&#34; title=&#34;http://ghc.haskell.org/trac/ghc/&#34;&gt;bug tracker&lt;/a&gt; and we&#39;ll be sure to look into it. Remember: &lt;strong&gt;Filing a bug is the best way to make sure your issue isn&#39;t lost over time&lt;/strong&gt;, so please feel free.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re an active user of GHC, you may also be interested in joining the &lt;a href=&#34;http://www.haskell.org/pipermail/glasgow-haskell-users/&#34; title=&#34;http://www.haskell.org/pipermail/glasgow-haskell-users/&#34;&gt;glasgow-haskell-users&lt;/a&gt; mailing list, where developers and GHC users discuss various topics and hang out.&lt;/p&gt; &#xA;&lt;h1&gt;Hacking &amp;amp; Developing GHC&lt;/h1&gt; &#xA;&lt;p&gt;Once you&#39;ve filed a bug, maybe you&#39;d like to fix it yourself? That would be great, and we&#39;d surely love your company! If you&#39;re looking to hack on GHC, check out the guidelines in the &lt;code&gt;HACKING.md&lt;/code&gt; file in this directory - they&#39;ll get you up to speed quickly.&lt;/p&gt; &#xA;&lt;h1&gt;Contributors &amp;amp; Acknowledgements&lt;/h1&gt; &#xA;&lt;p&gt;GHC in its current form wouldn&#39;t exist without the hard work of &lt;a href=&#34;http://ghc.haskell.org/trac/ghc/wiki/TeamGHC&#34; title=&#34;http://ghc.haskell.org/trac/ghc/wiki/TeamGHC&#34;&gt;its many contributors&lt;/a&gt;. Over time, it has grown to include the efforts and research of many institutions, highly talented people, and groups from around the world. We&#39;d like to thank them all, and invite you to join!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Concordium/concordium-node</title>
    <updated>2022-08-24T01:38:25Z</updated>
    <id>tag:github.com,2022-08-24:/Concordium/concordium-node</id>
    <link href="https://github.com/Concordium/concordium-node" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The main concordium node implementation.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;concordium-node&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/Concordium/.github/raw/main/.github/CODE_OF_CONDUCT.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Contributor%20Covenant-2.0-4baaaa.svg?sanitize=true&#34; alt=&#34;Contributor Covenant&#34;&gt;&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;img src=&#34;https://github.com/Concordium/concordium-node/actions/workflows/rustfmt.yaml/badge.svg?sanitize=true&#34; alt=&#34;Format&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;img src=&#34;https://github.com/Concordium/concordium-node/actions/workflows/build-test.yaml/badge.svg?sanitize=true&#34; alt=&#34;Build and test&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This repository contains the implementation of the concordium p2p node with its dependencies. It is split into two parts&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/concordium-consensus/&#34;&gt;concordium-consensus&lt;/a&gt; is a Haskell package that contains the implementation of the consensus with its dependencies. This includes basic consensus, finalization, scheduler, implementations of block and tree storage, and auxiliaries.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/concordium-node/&#34;&gt;concordium-node&lt;/a&gt; is a Rust package containing a number of executables, the chief among them being &lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/concordium-node/src/bin/cli.rs&#34;&gt;concordium-node.rs&lt;/a&gt; which is the program that participates in the Concordium network and runs consensus, finalization, and other components. It uses &lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/concordium-consensus/&#34;&gt;concordium-consensus&lt;/a&gt; as a package, either linked dynamically or statically, depending on the build configuration. The main feature added by the &lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/concordium-node/&#34;&gt;concordium-node&lt;/a&gt; is the network layer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Submodules&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/concordium-base/&#34;&gt;concordium-base&lt;/a&gt; is a a direct dependency of both &lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/concordium-consensus/&#34;&gt;concordium-consensus/&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/concordium-node/&#34;&gt;concordium-node&lt;/a&gt;. Because &lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/concordium-base/&#34;&gt;concordium-base&lt;/a&gt; is also used by other components it is a separate repository brought in as a submodule.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/concordium-grpc-api/&#34;&gt;concordium-grpc-api&lt;/a&gt; is a simple repository that defines the external GRPC API of the node. This is in term of the &lt;code&gt;.proto&lt;/code&gt; file. Because this is used by other components it is also a small separate repository brought in as a submodule.&lt;/p&gt; &#xA;&lt;p&gt;Do remember to clone recursively or use &lt;code&gt;git submodule update --init --recursive&lt;/code&gt; after cloning this repository, or after changing branches.&lt;/p&gt; &#xA;&lt;h2&gt;Configurations and scripts&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/jenkinsfiles/&#34;&gt;jenkinsfiles&lt;/a&gt; directory contains Jenkins configurations for deployment and testing.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/scripts/&#34;&gt;scripts&lt;/a&gt; directory contains a variety of bash scripts, Dockerfiles, and similar, to build different configurations of the node for testing and deployment.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/docker-compose/&#34;&gt;docker-compose&lt;/a&gt; directory contains a number of different &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;docker-compose&lt;/a&gt; configurations that can be used for setting up small local network for testing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building the node&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/concordium-node/README.md&#34;&gt;concordium-node/README.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;To contribute start a new branch starting from &lt;code&gt;main&lt;/code&gt;, make changes, and make a merge request. A person familiar with the codebase should be asked to review the changes before they are merged.&lt;/p&gt; &#xA;&lt;h2&gt;Haskell workflow&lt;/h2&gt; &#xA;&lt;p&gt;We typically use &lt;a href=&#34;https://docs.haskellstack.org/en/stable/README/&#34;&gt;stack&lt;/a&gt; to build, run, and test the code. In order to build the haskell libraries the rust dependencies must be pre-build, which is done automatically by the cabal setup script.&lt;/p&gt; &#xA;&lt;p&gt;We do not use any code formatting or linting tool on the CI. Running hlint might uncover common issues, and with regards to formatting, the general rule is that lines should not be too long, and follow the naming scheme and code style that already exists.&lt;/p&gt; &#xA;&lt;h2&gt;Rust workflow&lt;/h2&gt; &#xA;&lt;p&gt;We use &lt;strong&gt;stable version&lt;/strong&gt; of rust, 1.62, to compile the code.&lt;/p&gt; &#xA;&lt;p&gt;The CI is configured to check two things&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;the &lt;a href=&#34;https://github.com/rust-lang/rust-clippy&#34;&gt;clippy&lt;/a&gt; tool is run to check for common mistakes and issues. We try to have no clippy warnings. Sometimes what clippy thinks is not reasonable is necessary, in which case you should explicitly disable the warning on that site (a function or module), such as &lt;code&gt;#[allow(clippy::too_many_arguments)]&lt;/code&gt;, but that is a method of last resort. Try to resolve the issue in a different way first.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;the &lt;a href=&#34;https://github.com/rust-lang/rustfmt&#34;&gt;rust fmt&lt;/a&gt; tool is run to check the formatting. Unfortunately the stable version of the tool is quite outdated, so we use a nightly version, which is updated a few times a year. Thus in order for the CI to pass you will need to install the relevant nightly version, see see the file &lt;a href=&#34;https://raw.githubusercontent.com/Concordium/concordium-node/main/.github/workflows/rustfmt.yaml&#34;&gt;.github/workflows/rustfmt.yaml&lt;/a&gt;, look for &lt;code&gt;nightly-...&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>