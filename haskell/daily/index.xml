<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-22T01:34:38Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>haskell-beginners-2022/course-plan</title>
    <updated>2023-03-22T01:34:38Z</updated>
    <id>tag:github.com,2023-03-22:/haskell-beginners-2022/course-plan</id>
    <link href="https://github.com/haskell-beginners-2022/course-plan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üìú Haskell course info, plan, video lectures, slides&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;course-plan&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;256&#34; height=&#34;256&#34; src=&#34;https://raw.githubusercontent.com/haskell-beginners-2022/course-plan/main/logo.png&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Haskell and Functional Programming course for complete beginners.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üë©‚Äçüè´ The course was created in 2022 but it&#39;s still active and constantly improving.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Course learning materials comprises:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=6MsQcUprO9o&amp;amp;list=PLOJjn67NeYg9cWA4hyIWcxfaeX64pwo1c&amp;amp;ab_channel=chshersh&#34;&gt;üé• Four 1-hour lectures on YouTube&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://slides.com/haskellbeginners2022&#34;&gt;üñº Slides&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/haskell-beginners-2022/exercises&#34;&gt;üß© Practical exercises and Haskell installation instructions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The course is entirely free and includes two particularly interesting features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üÜô &lt;strong&gt;Review of your solutions to exercises!&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;üìú &lt;strong&gt;A certificate after successful completion!&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can solve exercises, and I&#39;m (Dmitrii Kovanikov) going to provide review to your solutions, suggesting improvements and alternative ways to solve tasks using idiomatic FP.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Below you can find the plan of each individual lecture with the corresponding links to learning materials.&lt;/p&gt; &#xA;&lt;h2&gt;üè° Lecture 1: Fundamentals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;What is Functional Programming?&lt;/li&gt; &#xA; &lt;li&gt;FP concepts&lt;/li&gt; &#xA; &lt;li&gt;Haskell features&lt;/li&gt; &#xA; &lt;li&gt;Haskell toolchain: GHC, GHCi, ghcup, cabal, hls&lt;/li&gt; &#xA; &lt;li&gt;How to install Haskell?&lt;/li&gt; &#xA; &lt;li&gt;GHCi &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arithmetic expressions&lt;/li&gt; &#xA;   &lt;li&gt;Comparison operators&lt;/li&gt; &#xA;   &lt;li&gt;Boolean expressions&lt;/li&gt; &#xA;   &lt;li&gt;Calling functions&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Types &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;:t&lt;/code&gt; command in GHCi&lt;/li&gt; &#xA;   &lt;li&gt;Types of booleans, numbers and functions&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Lists and operations with them &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Prepending, concatenation&lt;/li&gt; &#xA;   &lt;li&gt;Standard list functions&lt;/li&gt; &#xA;   &lt;li&gt;Ranges&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Laziness&lt;/li&gt; &#xA; &lt;li&gt;String&lt;/li&gt; &#xA; &lt;li&gt;Syntax constructions &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Defining our own functions&lt;/li&gt; &#xA;   &lt;li&gt;packages, modules, imports&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;if-then-else&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;guards&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;let-in&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;where&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Immutability&lt;/li&gt; &#xA; &lt;li&gt;Recursion&lt;/li&gt; &#xA; &lt;li&gt;Higher-Order Functions (HOF) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Functions as first-class values&lt;/li&gt; &#xA;   &lt;li&gt;Lambda functions&lt;/li&gt; &#xA;   &lt;li&gt;Partial application&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, etc.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;üéû Slides: &lt;a href=&#34;https://slides.com/haskellbeginners2022/lecture-1&#34;&gt;https://slides.com/haskellbeginners2022/lecture-1&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;üìΩ Video: &lt;a href=&#34;https://www.youtube.com/watch?v=6MsQcUprO9o&#34;&gt;Haskell Beginners 2022: Lecture 1&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üèó Lecture 2: Data types&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pattern-matching &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Top level&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;case-of&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;List patterns&lt;/li&gt; &#xA;   &lt;li&gt;Recursion and pattern matching&lt;/li&gt; &#xA;   &lt;li&gt;Pattern matching pitfalls&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Totality&lt;/li&gt; &#xA; &lt;li&gt;Tuples&lt;/li&gt; &#xA; &lt;li&gt;Algebraic Data Types &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Product types&lt;/li&gt; &#xA;   &lt;li&gt;Sum types&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Data types in Haskell &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;data&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Simple product types&lt;/li&gt; &#xA;   &lt;li&gt;Records&lt;/li&gt; &#xA;   &lt;li&gt;Enumerations&lt;/li&gt; &#xA;   &lt;li&gt;Simple sum types&lt;/li&gt; &#xA;   &lt;li&gt;Recursive data types&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;type&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;newtype&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Polymorphism &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Parametric polymorphism&lt;/li&gt; &#xA;   &lt;li&gt;Types of standard functions&lt;/li&gt; &#xA;   &lt;li&gt;Hoogle&lt;/li&gt; &#xA;   &lt;li&gt;Polymorphic data types&lt;/li&gt; &#xA;   &lt;li&gt;Standard polymorphic data types&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Eta-reduction&lt;/li&gt; &#xA; &lt;li&gt;Function composition: dot operator &lt;code&gt;(.)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;üéû Slides: &lt;a href=&#34;https://slides.com/haskellbeginners2022/lecture-2&#34;&gt;https://slides.com/haskellbeginners2022/lecture-2&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;üìΩ Video: &lt;a href=&#34;https://www.youtube.com/watch?v=rf-lie7U04Q&#34;&gt;Haskell Beginners 2022: Lecture 2&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üéÆ Lecture 3: Typeclasses&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Parametric polymorphism vs Ad-hoc polymorphism&lt;/li&gt; &#xA; &lt;li&gt;Typeclasses &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;class&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;instance&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Default methods&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;{-# MINIMAL #-}&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Small typeclasses vs Big typeclasses&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Language Extensions &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;{-# LANGUAGE InstanceSigs #-}&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Standard typeclasses &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Haskell Equality Table&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Num&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;deriving&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Stock derivable typeclasses&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;{-# LANGUAGE GeneralizedNewtypeDeriving #-}&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Algebraic typeclasses &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;Semigroup&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Monoid&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Laws&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Kinds&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Functor&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Folds &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;foldr&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;foldl&#39;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;foldr&lt;/code&gt; vs &lt;code&gt;foldl&#39;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Foldable&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Strict and Lazy evaluation &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Lazy evaluation&lt;/li&gt; &#xA;   &lt;li&gt;Tail Call Optimization (TCO)&lt;/li&gt; &#xA;   &lt;li&gt;Equational reasoning&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;{-# LANGUAGE BangPatterns #-}&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;üéû Slides: &lt;a href=&#34;https://slides.com/haskellbeginners2022/lecture-3&#34;&gt;https://slides.com/haskellbeginners2022/lecture-3&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;üìΩ Video: &lt;a href=&#34;https://www.youtube.com/watch?v=Vs-vvlYLtRI&#34;&gt;Haskell Beginners 2022: Lecture 3&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üîàüé§ Lecture 4: Monads and IO&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Monad example &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;andThen&lt;/code&gt; for &lt;code&gt;Maybe&lt;/code&gt;, &lt;code&gt;Either&lt;/code&gt; and list&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Monad as programming pattern&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Monad&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The typeclass&lt;/li&gt; &#xA;   &lt;li&gt;Instances&lt;/li&gt; &#xA;   &lt;li&gt;Laws&lt;/li&gt; &#xA;   &lt;li&gt;Usage example&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;FAM&lt;/strong&gt;ily: &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Applicative&lt;/code&gt;, &lt;code&gt;Monad&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Purity&lt;/li&gt; &#xA; &lt;li&gt;Why Purity + Laziness is a problem for side effects?&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IO&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Why does IO require a monad?&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;String&lt;/code&gt; vs &lt;code&gt;IO String&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;getLine&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;putStrLn&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Main&lt;/code&gt; and &lt;code&gt;main&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Then&lt;/em&gt; operator: &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;do&lt;/code&gt;-notation&lt;/li&gt; &#xA; &lt;li&gt;Cabal &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Packages&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;build-depends&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Functional Core, Imperative Shell&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;üéû Slides: &lt;a href=&#34;https://slides.com/haskellbeginners2022/lecture-4&#34;&gt;https://slides.com/haskellbeginners2022/lecture-4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;üìΩ Video: &lt;a href=&#34;https://www.youtube.com/watch?v=12D4Y2Hdnhg&#34;&gt;Haskell Beginners 2022: Lecture 4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s next?&lt;/h2&gt; &#xA;&lt;p&gt;After you&#39;ve finished the course, you may be interested in the following resources to continue your FP and Haskell journey:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://lhbg-book.link/&#34;&gt;Learn Haskell by building a blog generator&lt;/a&gt;: A project-based course that teaches pragmatic Haskell by building a blog generator from scratch.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.manning.com/books/haskell-in-depth&#34;&gt;Haskell in Depth&lt;/a&gt;: A book about intermediate Haskell topics such as Monad Transformers, metaprogramming, testing, logging and performance analysis.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.manning.com/books/functional-design-and-architecture&#34;&gt;Functional Design and Architecture &lt;/a&gt;: Design patterns and architectures for building production quality applications using functional programming, with examples in Haskell and other FP languages.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/soupi/haskell-study-plan&#34;&gt;Haskell Study Plan&lt;/a&gt;: More links on different topics and examples to real-world Haskell projects.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/willbasky/Awesome-list-of-Haskell-mentors&#34;&gt;Awesome List of Haskell mentors&lt;/a&gt;: A list of Haskell projects and mentors willing to help you master Haskell.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;p&gt;Below is the link to the original course announcement:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kodimensional.dev/course&#34;&gt;Course announcement&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>wereHamster/haskell-css-syntax</title>
    <updated>2023-03-22T01:34:38Z</updated>
    <id>tag:github.com,2023-03-22:/wereHamster/haskell-css-syntax</id>
    <link href="https://github.com/wereHamster/haskell-css-syntax" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Tokenizer and parser for the CSS syntax&lt;/p&gt;&lt;hr&gt;&lt;p&gt;This package provides functions to parse a CSS file into a stream of tokens and from that into rules or declarations. The exact algorithm is defined in the &lt;a href=&#34;https://drafts.csswg.org/css-syntax&#34;&gt;css-syntax&lt;/a&gt; module (it is the same algorithm that Blink uses since mid 2015 when it replaced their old Bison based parser).&lt;/p&gt; &#xA;&lt;p&gt;Note: Only the tokenizer is currently implemented. Parsing the token stream into rules or declarations isn&#39;t available as of yet.&lt;/p&gt; &#xA;&lt;h3&gt;Motivation&lt;/h3&gt; &#xA;&lt;p&gt;I needed a library which would allow me to process a CSS file, modify all image URLs and write the result to disk. Existing CSS libraries for Haskell either focus only on generating CSS (through a DLS) or parse the source into a format that is too high-level and makes this kind of processing difficult.&lt;/p&gt; &#xA;&lt;p&gt;A token stream is just the right level of abstraction for that task. The spec defines &lt;code&gt;&amp;lt;url-token&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;function-token&amp;gt;&lt;/code&gt;, which is what I needed to extract the image URLs from the source.&lt;/p&gt; &#xA;&lt;p&gt;More advanced processing likely requires a higher level abstraction than the token stream provides. E.g. to expand vendor prefixes you&#39;ll need to parse the token stream into a list of rules and declarations, so you can pick the declarations you want to process.&lt;/p&gt; &#xA;&lt;h3&gt;Motivation 2&lt;/h3&gt; &#xA;&lt;p&gt;I (the second author) needed to preprocess HTML in realtime to make it responsive. Besides other things it requires parsing &lt;code&gt;style=...&lt;/code&gt; attribute that can have any amount of junk so I optimized a parser/serializer a lot while still passing all the tests.&lt;/p&gt; &#xA;&lt;h3&gt;Tokenizer&lt;/h3&gt; &#xA;&lt;p&gt;The tokenizer uses fast low-level parser (20-50MB/s on average CSS files) to convert the input to a list of tokens. This process removes all comments and collapses consecutive whitespace into a single space character (U+0020). There may be other occasions where the tokenizer looses information from the input stream.&lt;/p&gt; &#xA;&lt;h3&gt;Serializer&lt;/h3&gt; &#xA;&lt;p&gt;Serializer converts list of tokens back to string. Serialization round-trips: tokenizing produces same tokens list as tokenizing, serializing and tokenizing again. Tokenize-serialize pair works at about 15MB/s or more.&lt;/p&gt; &#xA;&lt;h3&gt;Example&lt;/h3&gt; &#xA;&lt;p&gt;In the following example I replace all URLs in the source CSS file with links to predefined image.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import qualified Data.Text.IO as T&#xA;import           Data.CSS.Syntax.Tokens (tokenize, serialize)&#xA;&#xA;main :: IO ()&#xA;main = do&#xA;    source &amp;lt;- T.readFile &#34;path-to-your.css&#34;&#xA;    let tokens = tokenize source&#xA;&#xA;    putStrLn $ &#34;The CSS file has &#34; ++ show (length tokens)&#xA;        ++ &#34; tokens&#34;&#xA;&#xA;    let newTokens = map f tokens&#xA;&#xA;    T.writeFile &#34;path-to-lolcatted.css&#34; $&#xA;        serialize newTokens&#xA;&#xA;f :: Token -&amp;gt; Token&#xA;f (Url _) = Url &#34;http://lol.cat/img.png&#34;&#xA;f x       = x&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>