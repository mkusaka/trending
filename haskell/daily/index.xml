<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-04-19T01:31:18Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>GaloisInc/crucible</title>
    <updated>2025-04-19T01:31:18Z</updated>
    <id>tag:github.com,2025-04-19:/GaloisInc/crucible</id>
    <link href="https://github.com/GaloisInc/crucible" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Crucible is a library for symbolic simulation of imperative programs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Crucible&lt;/h1&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/GaloisInc/crucible/master/doc/crucible.svg?sanitize=true&#34; alt=&#34;Crucible logo&#34; width=&#34;25%&#34;&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Crucible is a language-agnostic library for performing forward symbolic execution of imperative programs. It provides a collection of data-structures and APIs for expressing programs as control-flow graphs. Programs expressed as CFGs in this way can be automatically explored by the symbolic execution engine. In addition, new data types and operations can be added to the symbolic simulator by implementing fresh primitives directly in Haskell. Crucible relies on an underlying library called &lt;a href=&#34;https://github.com/GaloisInc/what4&#34;&gt;What4&lt;/a&gt; that provides formula representations, and connections to a variety of SAT and SMT solvers that can be used to perform verification and find counterexamples to logical conditions computed from program simulation.&lt;/p&gt; &#xA;&lt;p&gt;Crucible has been designed as a set of Haskell packages organized so that Crucible itself has a minimal number of external dependencies, and functionality independent of crucible can be separated into sub-libraries.&lt;/p&gt; &#xA;&lt;p&gt;Currently, the repository consists of the following Haskell packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;crucible&lt;/code&gt;&lt;/strong&gt; provides the core Crucible definitions, including the symbolic simulator and control-flow-graph program representations.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;crucible-llvm&lt;/code&gt;&lt;/strong&gt; provides translation and runtime support for executing LLVM assembly programs in the Crucible symbolic simulator.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;crucible-jvm&lt;/code&gt;&lt;/strong&gt; provides translation and runtime support for executing JVM bytecode programs in the Crucible symbolic simulator.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;crux&lt;/code&gt;&lt;/strong&gt; provides common support libraries for running the crucible simulator in a basic &#34;all-at-once&#34; use mode for simulation and verification. This includes most of the setup steps required to actually set the simulator off and running, as well as functionality for collecting and discharging safety conditions and generated assertions via solvers. Both the &lt;code&gt;crux-llvm&lt;/code&gt; and &lt;code&gt;crucible-jvm&lt;/code&gt; executables are thin wrappers around the functionality provided by &lt;code&gt;crux&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition, there are the following library/executable packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;crux-llvm&lt;/code&gt;&lt;/strong&gt;, a standalone frontend for executing C and C++ programs in the crucible symbolic simulator. The front-end invokes &lt;code&gt;clang&lt;/code&gt; to produce LLVM bitcode, and runs the resulting programs using the &lt;code&gt;crucible-llvm&lt;/code&gt; language frontend.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;crux-llvm-svcomp&lt;/code&gt;&lt;/strong&gt;, an alternative entrypoint to &lt;code&gt;crux-llvm&lt;/code&gt; that uses the protocol established for the &lt;a href=&#34;https://sv-comp.sosy-lab.org&#34;&gt;SV-COMP&lt;/a&gt; competition. See &lt;a href=&#34;https://raw.githubusercontent.com/GaloisInc/crucible/master/crux-llvm/README.md&#34;&gt;here&lt;/a&gt; for more details.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;crucible-jvm&lt;/code&gt;&lt;/strong&gt;, also contains an executable for directly running compiled JVM bytecode programs, in a similar vein to the &lt;code&gt;crux-llvm&lt;/code&gt; package.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;crux-mir&lt;/code&gt;&lt;/strong&gt;, a tool for executing Rust programs in the crucible symbolic simulator. This is the backend for the &lt;code&gt;cargo crux-test&lt;/code&gt; command provided by &lt;code&gt;mir-json&lt;/code&gt;. See the &lt;a href=&#34;https://raw.githubusercontent.com/GaloisInc/crucible/master/crux-mir/README.md&#34;&gt;&lt;code&gt;crux-mir&lt;/code&gt; README&lt;/a&gt; for details.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Finally, the following packages are intended primarily for use by Crucible developers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;crucible-cli&lt;/code&gt;&lt;/strong&gt; provides a CLI for interacting with the Crucible simulator, via programs written in &lt;code&gt;crucible-syntax&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;crucible-debug&lt;/code&gt;&lt;/strong&gt; provides an interactive debugger for Crucible programs.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;crucible-llvm-cli&lt;/code&gt;&lt;/strong&gt; provides a CLI for interacting with the Crucible simulator, via programs written in &lt;code&gt;crucible-syntax&lt;/code&gt; with the extensions provided by &lt;code&gt;crucible-llvm{,-syntax}&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;crucible-llvm-debug&lt;/code&gt;&lt;/strong&gt; provides extensions to &lt;code&gt;crucible-debug&lt;/code&gt; for Crucible programs using the &lt;code&gt;crucible-llvm&lt;/code&gt; memory model.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;crucible-syntax&lt;/code&gt;&lt;/strong&gt; provides a native S-Expression based concrete syntax for crucible programs. It is useful for being able to directly interact with the core Crucible simulator without bringing in issues related to the translation of other front-ends (e.g. the LLVM translation). It is primarily intended for the purpose of writing test cases.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The development of major features and additions to &lt;code&gt;crucible&lt;/code&gt; is done in separate branches of the repository, all of which are based off &lt;code&gt;master&lt;/code&gt; and merge back into it when completed. Minor features and bug fixes are done in the &lt;code&gt;master&lt;/code&gt; branch. Naming of feature branches is free-form.&lt;/p&gt; &#xA;&lt;p&gt;Each library is BSD-licensed (see the &lt;code&gt;LICENSE&lt;/code&gt; file in a project directory for details).&lt;/p&gt; &#xA;&lt;h2&gt;Quick start&lt;/h2&gt; &#xA;&lt;p&gt;Clone this repository and checkout the immediate submodules to supply the needed dependencies (&lt;code&gt;git submodule update --init&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Crucible can be built with the &lt;code&gt;cabal&lt;/code&gt; tool:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal update&#xA;cabal new-configure&#xA;cabal new-build all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternately, you can target a more specific sub-package instead of &lt;code&gt;all&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Testing and Coverage&lt;/h2&gt; &#xA;&lt;p&gt;Testing is done via &lt;code&gt;cabal test&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To run the tests for crux-mir, you need to have built and installed the mir-json tool such that it can be found on your $PATH. You also need translated Rust libraries for the machine you&#39;re testing on. See &lt;a href=&#34;https://raw.githubusercontent.com/GaloisInc/crucible/master/crux-mir/README.md&#34;&gt;the crux-mir README&lt;/a&gt; for further information.&lt;/p&gt; &#xA;&lt;p&gt;Testing with coverage tracking is done via &lt;code&gt;cabal test --enable-coverage ...&lt;/code&gt; or &lt;code&gt;cabal configure --enable-coverage&lt;/code&gt;, although additional workarounds will be needed as noted in &lt;a href=&#34;https://github.com/galoisinc/crucible/issues/884&#34;&gt;https://github.com/galoisinc/crucible/issues/884&lt;/a&gt; and &lt;a href=&#34;https://github.com/haskell/cabal/issues/6440&#34;&gt;https://github.com/haskell/cabal/issues/6440&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Notes on Freeze Files&lt;/h2&gt; &#xA;&lt;p&gt;We use the &lt;code&gt;cabal.GHC-*.config&lt;/code&gt; files to constrain dependency versions in CI. We recommand using the following command for best results before building locally:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ln -s cabal.GHC-&amp;lt;VER&amp;gt;.config cabal.project.freeze&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These configuration files were generated using &lt;code&gt;cabal freeze --enable-tests --enable-benchmarks&lt;/code&gt;. Note that at present, these configuration files assume a Unix-like operating system, as we do not currently test Windows on CI. If you would like to use these configuration files on Windows, you will need to make some manual changes to remove certain packages and flags:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;regex-posix&#xA;tasty +unix&#xA;unix&#xA;unix-compat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Versioning scheme&lt;/h2&gt; &#xA;&lt;p&gt;All of the library components in this repository conform to the Haskell &lt;a href=&#34;https://pvp.haskell.org/.&#34;&gt;Package Versioning Policy&lt;/a&gt;. Every executable has a corresponding library, and they share a version number.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;crux-llvm&lt;/code&gt; and &lt;code&gt;crux-mir&lt;/code&gt; share the same version number. The major version of these packages is bumped on &lt;em&gt;every&lt;/em&gt; release, regardless of the changes (or lack thereof) in each.&lt;/p&gt; &#xA;&lt;p&gt;In addition to the release versions described above, we use &lt;em&gt;development versions&lt;/em&gt; for each package. Immediately after release, we add a fifth component to the version number of each package. This component starts at &lt;code&gt;.99&lt;/code&gt; and is incremented occasionally thereafter. These make it possible for downstream packages to indicate in their Cabal files that they depend on unreleased functionality, and for developers and users users to identify binaries compiled from development versions (via the &lt;code&gt;--version&lt;/code&gt; flag). Such five-component versions are never uploaded to Hackage.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;Crucible is partly based upon work supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No. N66001-18-C-4011. Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the Defense Advanced Research Projects Agency (DARPA).&lt;/p&gt;</summary>
  </entry>
</feed>