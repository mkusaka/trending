<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-11-06T01:30:52Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ivanperez-keera/dunai</title>
    <updated>2024-11-06T01:30:52Z</updated>
    <id>tag:github.com,2024-11-06:/ivanperez-keera/dunai</id>
    <link href="https://github.com/ivanperez-keera/dunai" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Classic FRP, Arrowized FRP, Reactive Programming, and Stream Programming, all via Monadic Stream Functions&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;Dunai&lt;/h1&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://app.travis-ci.com/github/ivanperez-keera/dunai&#34;&gt;&lt;img src=&#34;https://api.travis-ci.com/ivanperez-keera/dunai.svg?branch=develop&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/dunai&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/dunai.svg?sanitize=true&#34; alt=&#34;Version on Hackage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;Dunai is a &lt;strong&gt;generalized reactive programming library&lt;/strong&gt; on top of which other variants like Classic FRP, Arrowized FRP and Reactive Values can be implemented.&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#installation&#34;&gt;Installation&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#examples&#34;&gt;Examples&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#documentation&#34;&gt;Documentation&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#related-projects&#34;&gt;Related projects&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#technical-information&#34;&gt;Technical information&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#contributions&#34;&gt;Contributions&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#history&#34;&gt;History&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Intuitive syntax and semantics.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Composition of effects via use of different monads and transformers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Isolation of effectful and effect-free reactive functions at type level.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Time-free (time is not explicitly included) and time-able (time can be added).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fully extensible.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Can be used to implement other FRP libraries/flavors on top.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Supports applicative, functional and arrowized style.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Programs can be tested with QuickCheck and debugged using Haskell Titan.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#pre-requisites&#34;&gt;Pre-requisites&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#compilation&#34;&gt;Compilation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#documentation&#34;&gt;Documentation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#publications&#34;&gt;Publications&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#videos&#34;&gt;Videos&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#related-projects&#34;&gt;Related projects&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#games&#34;&gt;Games&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#libraries&#34;&gt;Libraries&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#technical-information&#34;&gt;Technical information&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#performance&#34;&gt;Performance&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#contributions&#34;&gt;Contributions&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#discussions-issues-and-pull-requests&#34;&gt;Discussions, issues and pull requests&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#structure-and-internals&#34;&gt;Structure and internals&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#style&#34;&gt;Style&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#version-control&#34;&gt;Version control&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#versioning-model&#34;&gt;Versioning model&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#history&#34;&gt;History&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Pre-requisites&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;To use Dunai, you must have a Haskell compiler installed (GHC). We currently support &lt;code&gt;GHC&lt;/code&gt; versions 7.6.3 to 9.8.1. It likely works with other versions as well.&lt;/p&gt; &#xA;&lt;p&gt;On Debian/Ubuntu, both can be installed with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ apt-get install ghc cabal-install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Mac, they can be installed with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ brew install ghc cabal-install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compilation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;Once you have a working set of Haskell tools installed, install Dunai by executing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cabal update&#xA;$ cabal install --lib dunai&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running the following will print the word &lt;code&gt;Success&lt;/code&gt; if installation has gone well, or show an error message otherwise:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ runhaskell &amp;lt;&amp;lt;&amp;lt; &#39;import Data.MonadicStreamFunction; main = putStrLn &#34;Success&#34;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;Open a GHCi session and import the main Dunai module:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;$ ghci&#xA;ghci&amp;gt; import Data.MonadicStreamFunction&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An MSF is a time-varying transformation applied to a series of inputs as they come along, one by one.&lt;/p&gt; &#xA;&lt;p&gt;Use the primitive &lt;code&gt;arr :: (a -&amp;gt; b) -&amp;gt; MSF m a b&lt;/code&gt; to turn any pure function into an MSF that applies the given function to every input. The function &lt;code&gt;embed :: MSF m a b -&amp;gt; [a] -&amp;gt; m [b]&lt;/code&gt; runs an MSF with a series of inputs, collecting the outputs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; embed (arr (+1)) [1,2,3,4,5]&#xA;[2,3,4,5,6]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;MSFs can have side effects; hence the &lt;code&gt;m&lt;/code&gt; that accompanies the type &lt;code&gt;MSF&lt;/code&gt; in the signatures of &lt;code&gt;arr&lt;/code&gt; and &lt;code&gt;embed&lt;/code&gt;. The function &lt;code&gt;arrM&lt;/code&gt; turns a &lt;em&gt;monadic function&lt;/em&gt; of type &lt;code&gt;a -&amp;gt; m b&lt;/code&gt; into an MSF that will constantly apply the function to each input.&lt;/p&gt; &#xA;&lt;p&gt;For example, the function &lt;code&gt;print&lt;/code&gt; takes a value and prints it to the terminal (a side effect in the &lt;code&gt;IO&lt;/code&gt; monad), producing an empty &lt;code&gt;()&lt;/code&gt; output. Elevating or lifting &lt;code&gt;print&lt;/code&gt; into an &lt;code&gt;MSF&lt;/code&gt; will turn it into a processor that prints each input passed to it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; :type print&#xA;print :: Show a =&amp;gt; a -&amp;gt; IO ()&#xA;ghci&amp;gt; :type arrM print&#xA;arrM print :: Show a =&amp;gt; MSF IO a ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we now run that MSF with five inputs, all are printed to the terminal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; embed (arrM print) [1,2,3,4,5]&#xA;1&#xA;2&#xA;3&#xA;4&#xA;5&#xA;[(), (), (), (), ()]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As we can see, after all side effects, &lt;code&gt;embed&lt;/code&gt; collects all the outputs, which GHCi shows at the end.&lt;/p&gt; &#xA;&lt;p&gt;When we only care about the side effects and not the output list, we can discard it with &lt;code&gt;Control.Monad.void&lt;/code&gt;. (Dunai provides an auxiliary function &lt;code&gt;embed_&lt;/code&gt; for the same purpose.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; import Control.Monad (void)&#xA;ghci&amp;gt; void $ embed (arrM print) [1,2,3,4,5]&#xA;1&#xA;2&#xA;3&#xA;4&#xA;5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;MSFs can be piped into one another with the functions &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt; or &lt;code&gt;(.)&lt;/code&gt;, so that the output of one MSF is fed as input to another MSF &lt;em&gt;at each point&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; void $ embed (arr (+1) &amp;gt;&amp;gt;&amp;gt; arrM print) [1,2,3,4,5]&#xA;2&#xA;3&#xA;4&#xA;5&#xA;6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A monadic computation without arguments can be lifted into an MSF with the function &lt;code&gt;constM&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; :type getLine&#xA;getLine :: IO String&#xA;ghci&amp;gt; :type constM getLine&#xA;constM getLine :: MSF IO a String&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This MSF will get a line of text from the terminal every time it is called, which we can pipe into an MSF that will print it back.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; void $ embed (constM getLine &amp;gt;&amp;gt;&amp;gt; arrM putStrLn) [(), ()]&#xA;What the user types, the computer repeats.&#xA;What the user types, the computer repeats.&#xA;Once again, the computer repeats.&#xA;Once again, the computer repeats.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice how we did not care about the values in the input list to &lt;code&gt;embed&lt;/code&gt;: the only thing that matters is how many elements it has, which determines how many times &lt;code&gt;embed&lt;/code&gt; will run the MSF.&lt;/p&gt; &#xA;&lt;p&gt;Simulations can run indefinitely with the function &lt;code&gt;reactimate :: MSF m () () -&amp;gt; m ()&lt;/code&gt;, which is useful when the input to the MSFs being executed is being produced by another MSFs, like in the case above with &lt;code&gt;constM getLine&lt;/code&gt; producing inputs consumed by &lt;code&gt;arrM putStrLn&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; reactimate (constM getLine &amp;gt;&amp;gt;&amp;gt; arr reverse &amp;gt;&amp;gt;&amp;gt; arrM putStrLn)&#xA;Hello&#xA;olleH&#xA;Haskell is awesome&#xA;emosewa si lleksaH&#xA;^C&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Dunai has a very extensive API and supports many programming styles. MSFs are applicatives, so we can transform them using applicative style, and they are categories, so they can be piped into one another with &lt;code&gt;Control.Category.(.)&lt;/code&gt;. For example, the line above can also be written as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; reactimate (arrM putStrLn . (reverse &amp;lt;$&amp;gt; constM getLine))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which is equivalent to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; reactimate (arrM putStrLn . fmap reverse . constM getLine)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Other writing styles (e.g., arrow notation) are also supported. This versatility makes it possible for you to use the notation you feel most comfortable with.&lt;/p&gt; &#xA;&lt;p&gt;MSFs are immensely expressive. With MSFs, you can implement stream programming, functional reactive programming (both classic and arrowized), reactive programming, and reactive values, among many others. The real power of MSFs comes from the ability to carry out temporal transformations (e.g., delays), to apply different transformations at different points in time, and to work with different monads. See the documentation below to understand how capable they are.&lt;/p&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Publications&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;The best introduction to the fundamentals of Monadic Stream Functions is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://dl.acm.org/doi/10.1145/2976002.2976010?cid=99658741366&#34;&gt;Functional Reactive Programming, Refactored&lt;/a&gt; (&lt;a href=&#34;http://dl.acm.org/citation.cfm?id=2976010&#34;&gt;official ACM page&lt;/a&gt;) (&lt;a href=&#34;https://ivanperez.io/#FRPRefactored&#34;&gt;mirror&lt;/a&gt;) (&lt;a href=&#34;https://github.com/ivanperez-keera/dunai/tree/develop/dunai-examples/paper&#34;&gt;updated paper examples&lt;/a&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following papers are also related to MSFs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://dl.acm.org/doi/10.1145/3236791?cid=99658741366&#34;&gt;Fault Tolerant Functional Reactive Programming&lt;/a&gt; (&lt;a href=&#34;https://ivanperez.io/#ftfrp&#34;&gt;mirror&lt;/a&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.cambridge.org/core/journals/journal-of-functional-programming/article/abs/faulttolerant-functional-reactive-programming-extended-version/F0C270C83E218FA5627D96A7FD6C56E9&#34;&gt;Fault Tolerant Functional Reactive Programming (extended version)&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://dl.acm.org/doi/10.1145/3242744.3242757?cid=99658741366&#34;&gt;Rhine: FRP with type-level clocks&lt;/a&gt; (&lt;a href=&#34;https://ivanperez.io/#rhine&#34;&gt;mirror&lt;/a&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://dl.acm.org/doi/10.1145/3122955.3122957?cid=99658741366&#34;&gt;Back to the Future: time travel in FRP&lt;/a&gt; (&lt;a href=&#34;https://ivanperez.io/#backtothefuture&#34;&gt;mirror&lt;/a&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://dl.acm.org/doi/10.1145/3110246?cid=99658741366&#34;&gt;Testing and Debugging Functional Reactive Programming&lt;/a&gt; (&lt;a href=&#34;https://ivanperez.io/#testingfrp&#34;&gt;mirror&lt;/a&gt;)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Videos&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://youtu.be/wO_jX8wGhU0?t=781&#34;&gt;Actors Design Patterns and Arrowised FRP&lt;/a&gt;. Talk by Diego Alonso Blas, describing Monadic Stream Functions and an encoding in scala.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=FmwOd4z9LdM&#34;&gt;Functional Reactive Programming, Refactored&lt;/a&gt;. Original talk describing MSFs. Haskell Symposium 2016.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=p2jJGjbjbig&#34;&gt;Back to the Future: Time Travel in FRP&lt;/a&gt;. Talk describing how to do time transformations in FRP and MSFs. Haskell Symposium 2017.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=owojLkI5YyY&#34;&gt;Fault Tolerant Functional Reactive Programming&lt;/a&gt;. Talk describing how MSFs can be used to add fault tolerance information. ICFP 2018.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Xvgz11D7xqs&#34;&gt;Rhine: FRP with Type-level Clocks&lt;/a&gt;. Talk describing how MSFs can be extended with clocks. Haskell Symposium 2018.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Related projects&lt;/h1&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Games&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/walseb/The_Bearriver_Arcade&#34;&gt;The Bearriver Arcade&lt;/a&gt;. Fun arcade games made using Bearriver.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/ivanperez-keera/haskanoid&#34;&gt;Haskanoid&lt;/a&gt;. Haskell breakout game implemented using the Functional Reactive Programming library Yampa (compatible with Dunai/Bearriver).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Libraries&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/ivanperez-keera/Yampa&#34;&gt;ivanperez-keera/Yampa&lt;/a&gt;: a full FRP implementation that has been used extensively in academia, open source and industry.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/turion/rhine&#34;&gt;turion/rhine&lt;/a&gt;: extension of Dunai with type-level clocks and explicit coordination.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/keera-studios/haskell-titan&#34;&gt;keera-studios/haskell-titan&lt;/a&gt;: an advanced, interactive testing framework with support for step-by-step execution and record-and-replay. Haskell-titan supports connecting to dunai systems via its Yampa-compatible interface library bearriver, via a flag in the libraries &lt;a href=&#34;https://hackage.haskell.org/package/titan-debug-yampa&#34;&gt;&lt;code&gt;titan-debug-yampa&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://hackage.haskell.org/package/titan-record-yampa&#34;&gt;&lt;code&gt;titan-record-yampa&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Technical information&lt;/h1&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;Simpler games will be playable without further optimisations. For example, the game &lt;a href=&#34;https://github.com/ivanperez-keera/haskanoid&#34;&gt;haskanoid&lt;/a&gt; works well with Dunai/Bearriver. You can try it with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git clone https://github.com/ivanperez-keera/haskanoid.git&#xA;$ cd haskanoid/&#xA;$ cabal install -f-wiimote -f-kinect -fbearriver&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It uses unaccelerated SDL 1.2, the speed is comparable to Yampa&#39;s:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ haskanoid&#xA;Performance report :: Time per frame: 13.88ms, FPS: 72.04610951008645, Total running time: 1447&#xA;Performance report :: Time per frame: 16.46ms, FPS: 60.75334143377886, Total running time: 3093&#xA;Performance report :: Time per frame: 17.48ms, FPS: 57.20823798627002, Total running time: 4841&#xA;Performance report :: Time per frame: 19.56ms, FPS: 51.12474437627812, Total running time: 6797&#xA;Performance report :: Time per frame: 19.96ms, FPS: 50.100200400801604, Total running time: 8793&#xA;Performance report :: Time per frame: 19.44ms, FPS: 51.440329218106996, Total running time: 10737&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It runs almost in constant memory, with about 50% more memory consumption than with &lt;code&gt;Yampa&lt;/code&gt;: 200k for Yampa and 300K for Dunai/Bearriver. (There is very minor leaking, probably we can fix that with seq.)&lt;/p&gt; &#xA;&lt;p&gt;We have obtained different figures tracking different modules. In &lt;a href=&#34;https://dl.acm.org/authorize?N34896&#34;&gt;the paper&lt;/a&gt;, we provided figures for the whole game, but we need to run newer reliable benchmarks including every module and only definitions from &lt;code&gt;FRP.Yampa&lt;/code&gt;, &lt;code&gt;FRP.BearRiver&lt;/code&gt; and &lt;code&gt;Data.MonadicStreamFunction&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Dunai includes some benchmarks as part of the main library. You are encouraged to use them to evaluate your pull requests, and to improve the benchmarks themselves.&lt;/p&gt; &#xA;&lt;h1&gt;Contributions&lt;/h1&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;If this library helps you, you may want to consider &lt;a href=&#34;https://github.com/sponsors/ivanperez-keera/&#34;&gt;buying the maintainer a cup of coffee&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Discussions, issues and pull requests&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Discussions&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you have any comments, questions, ideas, or other topics that you think will be of interest to the Dunai community, start a new discussion &lt;a href=&#34;https://github.com/ivanperez-keera/dunai/discussions&#34;&gt;here&lt;/a&gt;. Examples include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You&#39;ve created a new game or application that uses Dunai or BearRiver.&lt;/li&gt; &#xA; &lt;li&gt;You&#39;ve written or found a library that helps use Dunai/BearRiver in a particular domain, or apply it to a specific platform.&lt;/li&gt; &#xA; &lt;li&gt;You&#39;ve written or found a paper that mentions Dunai/BearRiver.&lt;/li&gt; &#xA; &lt;li&gt;You have an idea for an extension that will enable writing programs that are not currently possible or convenient to capture.&lt;/li&gt; &#xA; &lt;li&gt;You think you&#39;ve found a bug.&lt;/li&gt; &#xA; &lt;li&gt;You want to propose an improvement (e.g., make the code faster or smaller).&lt;/li&gt; &#xA; &lt;li&gt;You have a question.&lt;/li&gt; &#xA; &lt;li&gt;Something in the documentation, a tutorial or a Dunai / BearRiver / FRP paper is unclear.&lt;/li&gt; &#xA; &lt;li&gt;You like the project and want to introduce yourself.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Issues&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;If a specific change is being proposed (either a new feature or a bug fix), you can &lt;em&gt;open an issue&lt;/em&gt; documenting the proposed change &lt;a href=&#34;https://github.com/ivanperez-keera/dunai/issues&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you are unsure about whether your submission should be filed as an issue or as a discussion, file it as a discussion. We can always move it later.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Pull requests&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Once we determine that an issue will be addressed, we&#39;ll decide who does it and when the change will be added to Dunai. Even if you implement the solution, someone will walk you through the steps to ensure that your submission conforms with our version control process, style guide, etc. More information on our process is included below.&lt;/p&gt; &#xA;&lt;p&gt;Please, do not just send a PR unless there is an issue for it and someone from the Dunai team has confirmed that you should address it. The PR is &lt;em&gt;very&lt;/em&gt; likely to be rejected, and we really want to accept your contributions, so it will make us very sad. Open a discussion / issue first and let us guide you through the process.&lt;/p&gt; &#xA;&lt;h2&gt;Structure and internals&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;This project is split in three parts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Dunai&lt;/em&gt;: a reactive library that combines monads and arrows.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;BearRiver&lt;/em&gt;: Yampa implemented on top of Dunai.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Examples&lt;/em&gt;: ballbounce &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;sample applications that work both on traditional Yampa and BearRiver.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Dunai also includes some benchmarks as part of the main library. You are encouraged to use them to evaluate your pull requests, and to improve the benchmarks themselves.&lt;/p&gt; &#xA;&lt;h2&gt;Style&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;We follow &lt;a href=&#34;https://keera.co.uk/wp-content/uploads/2021/11/haskellguide-v1.3.0.pdf&#34;&gt;this style guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Version control&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;We follow &lt;a href=&#34;http://nvie.com/posts/a-successful-git-branching-model/&#34;&gt;git flow&lt;/a&gt;. In addition:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Please document your commits clearly and separately.&lt;/li&gt; &#xA; &lt;li&gt;Always refer to the issue you are fixing in the commit summary line with the text &lt;code&gt;Refs #&amp;lt;issue_number&amp;gt;&lt;/code&gt; at the end.&lt;/li&gt; &#xA; &lt;li&gt;If there is no issue for your change, then open an issue first and document what you are trying to achieve/improve/fix.&lt;/li&gt; &#xA; &lt;li&gt;Do not address more than one issue per commit or per PR. If two changes are not directly related to one another, they belong in different PRs, issues and commits.&lt;/li&gt; &#xA; &lt;li&gt;Document what you did in the respective CHANGELOGs in a separate commit before you send a PR. This commit should be the last one in the PR.&lt;/li&gt; &#xA; &lt;li&gt;If your commit pertains to one package only, name the package at the beginning of the summary line with the syntax &lt;code&gt;&amp;lt;package_name&amp;gt;: &amp;lt;...rest_of_summary...&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Make sure your changes conform to the &lt;a href=&#34;https://keera.co.uk/wp-content/uploads/2021/11/haskellguide-v1.3.0.pdf&#34;&gt;coding style&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the recent repo history for examples of this process. Using a visual repo inspection tool like &lt;code&gt;gitk&lt;/code&gt; may help.&lt;/p&gt; &#xA;&lt;h2&gt;Versioning model&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;The versioning model we use is the standard in Haskell packages. Versions have the format &lt;code&gt;&amp;lt;PUB&amp;gt;.&amp;lt;MAJOR&amp;gt;.&amp;lt;MINOR&amp;gt;(.&amp;lt;PATCH&amp;gt;)?&lt;/code&gt; where:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;&amp;lt;PUB&amp;gt;&lt;/code&gt; is just a way to signal important milestones or used for promotional reasons (to indicate a major advancement). A zero on this position has no special meaning.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;&amp;lt;MAJOR&amp;gt;&lt;/code&gt; increases on incompatible API changes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;&amp;lt;MINOR&amp;gt;&lt;/code&gt; increases on backwards-compatible changes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;&amp;lt;PATCH&amp;gt;&lt;/code&gt; (optional) increases on small changes that do not affect behavior (e.g., documentation).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;History&lt;/h1&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ivanperez-keera/dunai/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;This library Dunai was created by Ivan Perez and Manuel Baerenz. It is named after the Dunai (aka. Danube, or Дунай) river, one of the main rivers in Europe, originating in Germany and touching Austria, Slovakia, Hungary, Croatia, Serbia, Romania, Bulgaria, Moldova and Ukraine.&lt;/p&gt; &#xA;&lt;p&gt;Other FRP libraries, like Yampa and Rhine, are named after rivers. Dunai has been chosen due to the authors&#39; relation with some of the countries it passes through, and knowing that this library has helped unite otherwise very different people from different backgrounds.&lt;/p&gt;</summary>
  </entry>
</feed>