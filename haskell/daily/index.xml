<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-14T01:27:41Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>MercuryTechnologies/slacklinker</title>
    <updated>2024-03-14T01:27:41Z</updated>
    <id>tag:github.com,2024-03-14:/MercuryTechnologies/slacklinker</id>
    <link href="https://github.com/MercuryTechnologies/slacklinker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Slack backlink bot&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Slacklinker: a Slack backlink bot&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/MercuryTechnologies/slacklinker/main/doc/slacklinker-demo.png&#34; alt=&#34;screenshot of slacklinker replying to a message &amp;quot;I just pushed a PR that definitely works, for sure&amp;quot; with a link to a message linking to it saying &amp;quot;Oh no, prod is on fire&amp;quot;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is a Slack bot that creates backlinks when you link messages. It&#39;s written using the Servant web framework for Haskell, and the &lt;a href=&#34;https://github.com/MercuryTechnologies/slack-web&#34;&gt;slack-web&lt;/a&gt; Slack library.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h3&gt;Slack setup&lt;/h3&gt; &#xA;&lt;p&gt;Here is the app manifest you can use to set up the Slack app on the &lt;a href=&#34;https://api.slack.com/apps&#34;&gt;Slack API site&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;display_information:&#xA;  name: Slacklinker&#xA;features:&#xA;  bot_user:&#xA;    display_name: Slacklinker&#xA;    always_online: true&#xA;oauth_config:&#xA;  redirect_urls:&#xA;    - https://YOUR_SERVICE/oauth_redirect&#xA;  scopes:&#xA;    bot:&#xA;      - channels:history&#xA;      - channels:join&#xA;      - channels:read&#xA;      - chat:write&#xA;      - files:read&#xA;      - im:history&#xA;      - users:read&#xA;      - users:read.email&#xA;settings:&#xA;  event_subscriptions:&#xA;    request_url: https://YOUR_SERVICE/webhook&#xA;    bot_events:&#xA;      - channel_created&#xA;      - channel_left&#xA;      - message.channels&#xA;      - message.im&#xA;  org_deploy_enabled: false&#xA;  socket_mode_enabled: false&#xA;  token_rotation_enabled: false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, on the &#34;App Home&#34; tab, you have to enable &#34;Messages tab&#34; and &#34;Allow users to send Slash commands and messages from the messages tab&#34;.&lt;/p&gt; &#xA;&lt;h3&gt;App setup&lt;/h3&gt; &#xA;&lt;p&gt;This app is developed and deployed using Nix. You can get a development shell with haskell-language-server and all the tools you need with &lt;code&gt;nix develop&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To deploy it, you can equivalently use the &lt;code&gt;packages.${system}.default&lt;/code&gt; attribute from &lt;code&gt;flake.nix&lt;/code&gt; or the &lt;code&gt;build&lt;/code&gt; attribute of &lt;code&gt;release.nix&lt;/code&gt; (which are identical). Before starting the application (&lt;code&gt;result/bin/slacklinker&lt;/code&gt;), your service manager should run &lt;code&gt;result/db/migrate.sh&lt;/code&gt; to run the database migrations.&lt;/p&gt; &#xA;&lt;p&gt;Some basic configuration is done via environment variables:&lt;/p&gt; &#xA;&lt;p&gt;Corresponding to the values in the &#34;Basic Information&#34; pane of the &lt;a href=&#34;https://api.slack.com/apps&#34;&gt;Slack API site&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;SLACK_CLIENT_SECRET&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SLACK_SIGNING_SECRET&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SLACK_CLIENT_ID&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Corresponding to your database:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;POSTGRES_CONNECTION_STRING&lt;/code&gt; is a Postgres connection string like &lt;code&gt;postgresql://slacklinker:yourpassword@localhost:5432/slacklinker&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Corresponding to your OpenTelemetry tracing service (this is the recommended way to debug and monitor Slacklinker):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;OTEL_SERVICE_NAME=slacklinker&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;OTEL_EXPORTER_OTLP_ENDPOINT&lt;/code&gt; (for Honeycomb, &lt;code&gt;https://api.honeycomb.io&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;OTEL_EXPORTER_OTLP_HEADERS&lt;/code&gt; (for Honeycomb, &lt;code&gt;x-honeycomb-team=YOUR-API-KEY&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can set some runtime configuration settings in the database using &lt;code&gt;one-off-task set-setting&lt;/code&gt;. A full list of these is in &lt;a href=&#34;https://raw.githubusercontent.com/MercuryTechnologies/slacklinker/main/src/Slacklinker/Settings/Types.hs&#34;&gt;&lt;code&gt;src/Slacklinker/Settings/Types.hs&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;Once you have the application running at some public URL, you need to authorize it with OAuth2.&lt;/p&gt; &#xA;&lt;p&gt;To do this, go to &lt;code&gt;https://YOUR_SERVICE/authorize&lt;/code&gt;. You will be redirected to Slack to authorize the application.&lt;/p&gt; &#xA;&lt;p&gt;After authorizing Slacklinker on your workspace, unless you intend to run a public instance, you should immediately disable &lt;code&gt;AllowRegistration&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bin/one-off-task set-setting --settingName AllowRegistration --value false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(note that one-off-task needs to have the same environment variables as the service)&lt;/p&gt; &#xA;&lt;p&gt;Once Slacklinker is authorized, you can send the bot a private message &lt;code&gt;join_all&lt;/code&gt;, which will have the bot join all existing public non-shared Slack channels.&lt;/p&gt; &#xA;&lt;p&gt;The bot will automatically join any newly created public channels, so no further action is needed.&lt;/p&gt; &#xA;&lt;h2&gt;Development notes&lt;/h2&gt; &#xA;&lt;p&gt;Since &lt;a href=&#34;https://github.com/MercuryTechnologies/slack-web&#34;&gt;slack-web&lt;/a&gt; does not (currently) support Slack&#39;s &lt;a href=&#34;https://api.slack.com/apis/connections/socket&#34;&gt;Socket Mode&lt;/a&gt;, you &lt;em&gt;need&lt;/em&gt; a public request URL to run Slacklinker. This is most easily achieved with something like &lt;a href=&#34;https://ngrok.com/&#34;&gt;ngrok&lt;/a&gt; in development and your preferred infrastructure in production.&lt;/p&gt; &#xA;&lt;p&gt;We recommend using &lt;a href=&#34;https://direnv.net/&#34;&gt;&lt;code&gt;direnv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://github.com/nix-community/nix-direnv&#34;&gt;&lt;code&gt;nix-direnv&lt;/code&gt;&lt;/a&gt; to get a working environment for working on slacklinker. You can see a sample for &lt;code&gt;.envrc&lt;/code&gt; at &lt;a href=&#34;https://raw.githubusercontent.com/MercuryTechnologies/slacklinker/main/.envrc.sample&#34;&gt;./.envrc.sample&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Schema changes &amp;amp; Migrations&lt;/h3&gt; &#xA;&lt;p&gt;If you do a database schema change, you will need to generate a migration. These use the &lt;a href=&#34;https://github.com/rust-db/refinery&#34;&gt;Refinery&lt;/a&gt; CLI, which basically just runs SQL. You can get Persistent to generate the outline of the migration like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal run one-off-task -- suggest-migrations --migrationName your_migration_name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Golden tests&lt;/h3&gt; &#xA;&lt;p&gt;Use &lt;code&gt;scripts/update-golden.sh SOME_GOLDEN_DIR&lt;/code&gt; to update golden snapshot test files.&lt;/p&gt; &#xA;&lt;h3&gt;Logging&lt;/h3&gt; &#xA;&lt;p&gt;Set log level with &lt;code&gt;LOG_LEVEL=debug&lt;/code&gt; and SQL log level with &lt;code&gt;LOG_SQL=debug&lt;/code&gt; environment variables.&lt;/p&gt;</summary>
  </entry>
</feed>