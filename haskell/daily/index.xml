<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-12T01:36:51Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>UCSC-CSE-114A/01-haskell</title>
    <updated>2023-02-12T01:36:51Z</updated>
    <id>tag:github.com,2023-02-12:/UCSC-CSE-114A/01-haskell</id>
    <link href="https://github.com/UCSC-CSE-114A/01-haskell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;See wiki for instructions &lt;a href=&#34;https://github.com/UCSC-CSE-114A/01-haskell/wiki/README&#34;&gt;https://github.com/UCSC-CSE-114A/01-haskell/wiki/README&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>probcomp/adev</title>
    <updated>2023-02-12T01:36:51Z</updated>
    <id>tag:github.com,2023-02-12:/probcomp/adev</id>
    <link href="https://github.com/probcomp/adev" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell prototype to accompany the paper &#34;ADEV: Sound Automatic Differentiation of Expected Values of Probabilistic Programs&#34;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ADEV&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains the Haskell prototype that accompanies the paper &#34;&lt;a href=&#34;https://popl23.sigplan.org/details/POPL-2023-popl-research-papers/5/ADEV-Sound-Automatic-Differentiation-of-Expected-Values-of-Probabilistic-Programs&#34;&gt;ADEV: Sound Automatic Differentiation of Expected Values of Probabilistic Programs&lt;/a&gt;&#34;.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/probcomp/adev/main/figures/adev-diagram.png&#34; alt=&#34;Overview of ADEV&#34;&gt; ADEV is a method of automatically differentiating loss functions defined as &lt;em&gt;expected values&lt;/em&gt; of probabilistic processes. ADEV users define a &lt;em&gt;probabilistic program&lt;/em&gt; $t$, which, given a parameter of type $\mathbb{R}$ (or a subtype), outputs a value of type $\widetilde{\mathbb{R}}$, which represents probabilistic estimators of losses. We translate $t$ to a new probabilistic program $s$, whose expected return value is the derivative of $t$’s expected return value. Running $s$ yields provably unbiased estimates $x_i$ of the loss&#39;s derivative, which can be used in the inner loop of stochastic optimization algorithms like ADAM or stochastic gradient descent.&lt;/p&gt; &#xA;&lt;p&gt;ADEV goes beyond standard AD by explicitly supporting probabilistic primitives, like &lt;code&gt;flip&lt;/code&gt;, for flipping a coin. If these probabilistic constructs are ignored, standard AD may produce incorrect results, as this figure from our paper illustrates: &lt;img src=&#34;https://raw.githubusercontent.com/probcomp/adev/main/figures/example.png&#34; alt=&#34;Optimizing an example loss function using ADEV&#34;&gt; In this example, standard AD fails to account for the parameter $\theta$&#39;s effect on the &lt;em&gt;probability&lt;/em&gt; of entering each branch. ADEV, by contrast, correctly accounts for the probabilistic effects, generating similar code to what a practitioner might hand-derive. Correct gradients are often crucial for downstream applications, e.g. optimization via stochastic gradient descent.&lt;/p&gt; &#xA;&lt;p&gt;ADEV compositionally supports various gradient estimation strategies from the literature, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Reparameterization trick (Kingma &amp;amp; Welling 2014)&lt;/li&gt; &#xA; &lt;li&gt;Score function estimator (Ranganath et al. 2014)&lt;/li&gt; &#xA; &lt;li&gt;Baselines as control variates (Mnih and Gregor 2014)&lt;/li&gt; &#xA; &lt;li&gt;Multi-sample estimators that Storchastic supports (e.g. leave-one-out baselines) (van Krieken et al. 2021)&lt;/li&gt; &#xA; &lt;li&gt;Variance reduction via dependency tracking (Schulman et al. 2015)&lt;/li&gt; &#xA; &lt;li&gt;Special estimators for differentiable particle filtering (Ścibior et al. 2021)&lt;/li&gt; &#xA; &lt;li&gt;Implicit reparameterization (Figurnov et al. 2018)&lt;/li&gt; &#xA; &lt;li&gt;Measure-valued derivatives (Heidergott and Vázquez-Abad 2000)&lt;/li&gt; &#xA; &lt;li&gt;Reparameterized rejection sampling (Nasseth et al. 2017)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Haskell Example&lt;/h2&gt; &#xA;&lt;p&gt;ADEV extends forward-mode automatic differentiation to support &lt;em&gt;probabilistic programs&lt;/em&gt;. Consider the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Numeric.ADEV.Class (ADEV(..))&#xA;import Numeric.ADEV.Interp ()&#xA;import Numeric.ADEV.Diff (diff)&#xA;import Control.Monad (replicateM)&#xA;import Control.Monad.Bayes.Sampler.Strict (sampleIO)&#xA;&#xA;-- Define a loss function l as the expected&#xA;-- value of a probabilistic process.&#xA;l theta = expect $ do&#xA;    b &amp;lt;- flip_reinforce theta&#xA;    if b then&#xA;        return 0&#xA;    else&#xA;        return (-theta / 2)&#xA;&#xA;-- Take its derivative.&#xA;l&#39; = diff l&#xA;&#xA;-- Helper function for computing averages&#xA;mean xs = sum xs / (realToFrac $ length xs)&#xA;&#xA;-- Estimating the loss and its derivative &#xA;-- by averaging many samples&#xA;estimate_loss  = fmap mean (replicateM 1000 (l 0.4))&#xA;estimate_deriv = fmap mean (replicateM 1000 (l&#39; 0.4))&#xA;&#xA;main = do&#xA;    loss  &amp;lt;- sampleIO estimate_loss&#xA;    deriv &amp;lt;- sampleIO estimate_deriv&#xA;    print (loss, deriv)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Defining a loss.&lt;/strong&gt; The function &lt;code&gt;l&lt;/code&gt; is defined to be the &lt;em&gt;expected value&lt;/em&gt; of a probabilistic process, using &lt;code&gt;expect&lt;/code&gt;. The process in question involves flipping a coin, whose probability of heads is &lt;code&gt;theta&lt;/code&gt;, and returning either &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;-theta / 2&lt;/code&gt;, depending on the coin flip&#39;s result.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Differentiating.&lt;/strong&gt; ADEV&#39;s &lt;code&gt;diff&lt;/code&gt; operator converts such a loss into a new function &lt;code&gt;l&#39;&lt;/code&gt; representing its derivative, with respect to the input parameter &lt;code&gt;theta&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Running the estimators.&lt;/strong&gt; Operationally, neither &lt;code&gt;l&lt;/code&gt; nor &lt;code&gt;l&#39;&lt;/code&gt; compute exact expectations (or derivatives of expecations): instead, they represent &lt;em&gt;unbiased estimators&lt;/em&gt; of the desired values, which can be run using &lt;code&gt;sampleIO&lt;/code&gt;. On one run, the above code printed &lt;code&gt;(-0.122, -0.10)&lt;/code&gt;, which are very close to the correct values of $-0.12$ and $-0.1$.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Composing &lt;code&gt;expect&lt;/code&gt; with other operators.&lt;/strong&gt; Note that ADEV also provides primitives for manipulating expected values, e.g. &lt;code&gt;exp_&lt;/code&gt; for taking their exponents. For example, the code &lt;code&gt;fmap mean (replicateM 1000 (exp_ (l 0.4)))&lt;/code&gt; yielded &lt;code&gt;0.881&lt;/code&gt; on a sample run, close to the true value of $e^{-0.12} = 0.886$. This is the exponent of the expected value, not the expected value of the exponent, which is slightly different, and would yield $0.6 \times e^{-0.2} + 0.4 \times e^0 = 0.891$.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Optimization.&lt;/strong&gt; We can use ADEV&#39;s estimated derivatives to implement a stochastic optimization algorithm:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sgd loss eta x0 steps = &#xA;    if steps == 0 then&#xA;        return [x0]&#xA;    else do&#xA;        v &amp;lt;- diff loss x0&#xA;        let x1 = x0 - eta * v&#xA;        xs &amp;lt;- sgd loss eta x1 (steps - 1)&#xA;        return (x0:xs)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running &lt;code&gt;sampleIO $ sgd l 0.2 0.2 100&lt;/code&gt; finds the value of $\theta$ that minimizes $l$, namely $\theta = 0.5$.&lt;/p&gt; &#xA;&lt;h2&gt;Haskell Encoding of ADEV Programs&lt;/h2&gt; &#xA;&lt;p&gt;In the ADEV paper, the program &lt;code&gt;l&lt;/code&gt; above would have type $\mathbb{R} \to \widetilde{\mathbb{R}}$. In Haskell, its type is &lt;code&gt;ADEV p m r =&amp;gt; r -&amp;gt; m r&lt;/code&gt;. Why?&lt;/p&gt; &#xA;&lt;p&gt;In general, expressions in the ADEV source language are represented by Haskell expressions with polymorphic type &lt;code&gt;ADEV p m r =&amp;gt; ...&lt;/code&gt;, where the &lt;code&gt;...&lt;/code&gt; is a Haskell type that uses the three type variables &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;r&lt;/code&gt; as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;r&lt;/code&gt; represents real numbers, $\mathbb{R}$ in the ADEV paper. (The type of positive reals reals, $\mathbb{R}_{&amp;gt;0}$, is represented as &lt;code&gt;Log r&lt;/code&gt;.)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;m r&lt;/code&gt; represents estimated real numbers, $\widetilde{\mathbb{R}}$ in the ADEV paper.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;p m a&lt;/code&gt; represents probabilistic programs returning &lt;code&gt;a&lt;/code&gt;, $P~a$ in the ADEV paper.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Below, we show how &lt;code&gt;l&lt;/code&gt;&#39;s type relates to the types of its sub-expressions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- `flip_reinforce` takes a real parameter and &#xA;-- probabilistically outputs a Boolean.&#xA;flip_reinforce :: ADEV p m r =&amp;gt; r -&amp;gt; p m Bool&#xA;&#xA;-- Using `do`, we can build a larger computation that&#xA;-- uses the result of a flip to compute a real.&#xA;-- Its type reflects that it still takes a real parameter&#xA;-- as input, but now probabilistically outputs a real.&#xA;prog :: ADEV p m r =&amp;gt; r -&amp;gt; p m r&#xA;prog theta = do &#xA;  b &amp;lt;- flip_reinforce theta &#xA;  if b then &#xA;    return 0 &#xA;  else &#xA;    return (-theta/2)&#xA;&#xA;-- The `expect` operation turns a probabilistic computation&#xA;-- over reals (type P R) into an estimator of its expected&#xA;-- value (type R~).&#xA;expect :: ADEV p m r =&amp;gt; p m r -&amp;gt; m r&#xA;&#xA;-- By composing expect and prog, we get l from above.&#xA;l :: ADEV p m r =&amp;gt; r -&amp;gt; m r&#xA;l = expect . prog&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Implementation&lt;/h2&gt; &#xA;&lt;p&gt;To understand ADEV&#39;s implementation, it is useful to first skim the ADEV paper, which explains how ADEV modularly extends standard forward-mode AD with support for probabilistic primitives. The Haskell code is a relatively direct encoding of the ideas described in the paper. Briefly:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;All the primitives in the ADEV language, including those introduced by the extensions from Appendix B, are encoded as methods of the &lt;code&gt;ADEV&lt;/code&gt; typeclass, in the &lt;a href=&#34;https://raw.githubusercontent.com/probcomp/adev/main/src/Numeric/ADEV/Class.hs&#34;&gt;Numeric.ADEV.Class&lt;/a&gt; module. This is like a &#39;specification&#39; that a specific interpreter of the ADEV language can satisfy. It leaves open what concrete Haskell types will be used to represent the ADEV types of real numbers $\mathbb{R}$, estimated reals $\widetilde{\mathbb{R}}$, and monadic probabilistic programs $P~\tau$ — it uses the type variables &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;m r&lt;/code&gt;, and &lt;code&gt;p m tau&lt;/code&gt; for this purpose.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/probcomp/adev/main/src/Numeric/ADEV/Interp.hs&#34;&gt;Numeric.ADEV.Interp&lt;/a&gt; module provides one instance of the &lt;code&gt;ADEV&lt;/code&gt; typeclass, implementing the standard semantics of an ADEV term. The type variables &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;r&lt;/code&gt; are instantiated so that the type of reals &lt;code&gt;r&lt;/code&gt; is interpreted as &lt;code&gt;Double&lt;/code&gt;, the type &lt;code&gt;m r&lt;/code&gt; of &lt;em&gt;estimated&lt;/em&gt; reals is interpreted as the type &lt;code&gt;m Double&lt;/code&gt; for some &lt;code&gt;MonadDistribution&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; (where &lt;code&gt;MonadDistribution&lt;/code&gt; is the &lt;a href=&#34;https://github.com/tweag/monad-bayes&#34;&gt;monad-bayes&lt;/a&gt; typeclass for probabilistic programs), and the type of probabilistic programs &lt;code&gt;p m a&lt;/code&gt; is interpreted as &lt;code&gt;WriterT Sum m a&lt;/code&gt; (the &lt;code&gt;Sum&lt;/code&gt; maintains an accumulated loss, and is described in Appendix B.2 of the ADEV paper).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/probcomp/adev/main/src/Numeric/ADEV/Diff.hs&#34;&gt;Numeric.ADEV.Diff&lt;/a&gt; module provides built-in derivatives for each primitive. These are organized into a second instance of the &lt;code&gt;ADEV&lt;/code&gt; typeclass, where now the type &lt;code&gt;r&lt;/code&gt; of reals is interpreted as &lt;code&gt;ForwardDouble&lt;/code&gt;, representing forward-mode dual numbers $\mathcal{D}\{\mathbb{R}\}$ from the paper; the type &lt;code&gt;m r&lt;/code&gt; of estimated reals is interpreted as the type &lt;code&gt;m ForwardDouble&lt;/code&gt; for some &lt;code&gt;MonadDistribution&lt;/code&gt; &lt;code&gt;m&lt;/code&gt;, which implements the type $\widetilde{\mathbb{R}}_\mathcal{D}$ of estimated dual numbers from the paper; and the type &lt;code&gt;p m tau&lt;/code&gt; of probabilistic programs is interpreted as &lt;code&gt;ContT ForwardDouble m tau&lt;/code&gt;, i.e., the type of &lt;em&gt;higher-order functions&lt;/em&gt; that transform an input &lt;code&gt;loss_to_go : tau -&amp;gt; m ForwardDouble&lt;/code&gt; into an estimated dual-number loss of type &lt;code&gt;m ForwardDouble&lt;/code&gt; (this implements the type $P_\mathcal{D}~\tau$ from the paper).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installing ADEV&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install &lt;code&gt;stack&lt;/code&gt; (&lt;a href=&#34;https://docs.haskellstack.org/en/stable/install_and_upgrade/&#34;&gt;https://docs.haskellstack.org/en/stable/install_and_upgrade/&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Clone this repository.&lt;/li&gt; &#xA; &lt;li&gt;Run the examples using &lt;code&gt;stack run ExampleName&lt;/code&gt;, where &lt;code&gt;ExampleName.hs&lt;/code&gt; is the name of a file from the &lt;code&gt;examples&lt;/code&gt; directory.&lt;/li&gt; &#xA; &lt;li&gt;Or: Run &lt;code&gt;stack ghci&lt;/code&gt; to enter a REPL.&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>Pascal-So/hackerrank-solutions</title>
    <updated>2023-02-12T01:36:51Z</updated>
    <id>tag:github.com,2023-02-12:/Pascal-So/hackerrank-solutions</id>
    <link href="https://github.com/Pascal-So/hackerrank-solutions" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Some of my hackerrank solutions&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Hackerrank solutions&lt;/h1&gt; &#xA;&lt;p&gt;Some of my solutions for hackerrank.com&lt;/p&gt; &#xA;&lt;p&gt;Includes some incomplete solutions.&lt;/p&gt;</summary>
  </entry>
</feed>