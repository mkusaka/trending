<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-15T01:43:07Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>system-f/fp-course</title>
    <updated>2022-06-15T01:43:07Z</updated>
    <id>tag:github.com,2022-06-15:/system-f/fp-course</id>
    <link href="https://github.com/system-f/fp-course" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Functional Programming Course&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Functional Programming Course&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://system-f.gitlab.io/logo/systemf-450x450.jpg&#34; alt=&#34;System-F&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Written by Tony Morris &amp;amp; Mark Hibberd&lt;/h3&gt; &#xA;&lt;h3&gt;With contributions from individuals and organisations (thanks!)&lt;/h3&gt; &#xA;&lt;h4&gt;Special note 1&lt;/h4&gt; &#xA;&lt;p&gt;If you have arrived here by &lt;a href=&#34;https://github.com/system-f/fp-course&#34;&gt;https://github.com/system-f/fp-course&lt;/a&gt; and you are looking for the &lt;em&gt;answers&lt;/em&gt; (not the exercises), please go to &lt;a href=&#34;https://github.com/tonymorris/fp-course&#34;&gt;https://github.com/tonymorris/fp-course&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Special note 2&lt;/h4&gt; &#xA;&lt;p&gt;As of February 2017, this repository is taking the place of the repository hosted at &lt;a href=&#34;https://github.com/NICTA/course&#34;&gt;https://github.com/NICTA/course&lt;/a&gt; which is deprecated.&lt;/p&gt; &#xA;&lt;p&gt;The new repository is located at &lt;a href=&#34;https://github.com/system-f/fp-course&#34;&gt;https://github.com/system-f/fp-course&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Introduction&lt;/h4&gt; &#xA;&lt;p&gt;The course is structured according to a linear progression and uses the Haskell programming language to learn programming concepts pertaining to functional programming.&lt;/p&gt; &#xA;&lt;p&gt;Exercises are annotated with a comment containing the word &#34;Exercise.&#34; The existing code compiles, however answers have been replaced with a call to the Haskell &lt;code&gt;error&lt;/code&gt; function and so the code will throw an exception if it is run. Some exercises contain tips, which are annotated with a preceding &#34;Tip:&#34;. It is not necessary to adhere to tips. Tips are provided for potential guidance, which may be discarded if you prefer a different path to a solution.&lt;/p&gt; &#xA;&lt;p&gt;The exercises are designed in a way that requires personal guidance, so if you attempt it on your own and feel a little lost, this is normal. All the instructions are not contained herein.&lt;/p&gt; &#xA;&lt;h3&gt;Getting Help&lt;/h3&gt; &#xA;&lt;p&gt;There are two mailing lists for asking questions. All questions are welcome, however, your first post might be moderated. This is simply to prevent spam.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://groups.google.com/forum/#!forum/nicta-fp&#34;&gt;[nicta-fp]&lt;/a&gt; is a Google Group for any queries related to functional programming. This mailing list is owned by System F and is open to the public. Questions relating to this course are most welcome here.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://groups.google.com/forum/#!forum/haskell-exercises&#34;&gt;[haskell-exercises]&lt;/a&gt; is a Google Group for queries related specifically to this System F functional programming course material. This mailing list is not owned by System F, but is run by others who are keen to share ideas relating to the course.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;#bfpg &lt;a href=&#34;ircs://irc.libera.chat:6697/#bfpg&#34;&gt;on Libera.chat&lt;/a&gt; is the IRC channel of the Queensland Functional Programming Lab - the team that runs the course in Brisbane.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;#scalaz &lt;a href=&#34;ircs://irc.libera.chat:6697/#scalaz&#34;&gt;on Libera.chat&lt;/a&gt; is an IRC channel that is operated by others who are keen to share ideas relating to functional programming in general. Most of the participants of this channel have completed the System F functional programming course to some extent. They are in various timezones and share a passion for functional programming, so may be able to provide relatively quick assistance with questions.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Getting Started&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the Glasgow Haskell Compiler (GHC) version 8.0 or higher. &lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;GHCup&lt;/a&gt; is the recommended way to do that these days&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Change to the directory containing this document.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Execute the command &lt;code&gt;ghci&lt;/code&gt;, which will compile and load all the source code. You may need to set permissions on the root directory and the ghci configuration file, &lt;code&gt;chmod go-w .ghci ./&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Inspect the introductory modules to get a feel for Haskell&#39;s syntax, then move on to the exercises starting with &lt;code&gt;Course.Optional&lt;/code&gt;. The &lt;a href=&#34;https://raw.githubusercontent.com/system-f/fp-course/master/#progression&#34;&gt;Progression&lt;/a&gt; section of this document lists the recommended order in which to attempt the exercises.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Edit a source file to a proposed solution to an exercise. At the &lt;code&gt;ghci&lt;/code&gt; prompt, issue the command &lt;code&gt;:reload&lt;/code&gt;. This will compile your solution and reload it in the GHC interpreter. You may use &lt;code&gt;:r&lt;/code&gt; for short.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Tips after having started&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Some questions take a particular form. These are called &lt;em&gt;WTF questions&lt;/em&gt;. WTF questions are those of this form or similar:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;What does ____ mean?&lt;/li&gt; &#xA; &lt;li&gt;What does the ____ function mean?&lt;/li&gt; &#xA; &lt;li&gt;What is a ____ ?&lt;/li&gt; &#xA; &lt;li&gt;Where did ____ come from ?&lt;/li&gt; &#xA; &lt;li&gt;What is the structure of ____ ?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;They are all answerable with the &lt;code&gt;:info&lt;/code&gt; command. For example, suppose you have the question, &#34;What does the &lt;code&gt;swiggletwoop&lt;/code&gt; function mean?&#34; You may answer this at GHCi with:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;&amp;gt; :info swiggletwoop&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;You may also use &lt;code&gt;:i&lt;/code&gt; for short.&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Functional Programming techniques rely heavily on types. This reliance may feel foreign at first, however, it is an important part of this course. If you wish to know the type of an expression or value, use &lt;code&gt;:type&lt;/code&gt;. For example,&lt;/p&gt; &lt;p&gt;&lt;code&gt;&amp;gt; :type reverse&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;List t -&amp;gt; List t&lt;/code&gt;&lt;/p&gt; &lt;p&gt;This tells you that the &lt;code&gt;reverse&lt;/code&gt; function takes a list of elements of some arbitrary type (&lt;code&gt;t&lt;/code&gt;) and returns a list of elements of that same type. Try it.&lt;/p&gt; &lt;p&gt;You may also use &lt;code&gt;:t&lt;/code&gt; for short.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;GHCi has TAB-completion. For example you might type the following:&lt;/p&gt; &lt;p&gt;&lt;code&gt;&amp;gt; :type rev&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Now hit the TAB key. If there is only one function in scope that begins with the characters &lt;code&gt;rev&lt;/code&gt;, then that name will auto-complete. Try it. This completion is context-sensitive. For example, it doesn&#39;t make sense to ask for the type of a data type itself, so data type names will not auto-complete in that context, however, if you ask for &lt;code&gt;:info&lt;/code&gt;, then they are included in that context. Be aware of this when you use auto-complete.&lt;/p&gt; &lt;p&gt;This also works for file names:&lt;/p&gt; &lt;p&gt;&lt;code&gt;&amp;gt; readFile &#34;/etc/pas&#34;&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Now hit the TAB key. If there is only one existing filename on a path that begins with &lt;code&gt;/etc/pas&lt;/code&gt;, then that name will auto-complete. Try it.&lt;/p&gt; &lt;p&gt;If there is more than one identifier that can complete, hit TAB twice quickly. This will present you with your options to complete.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Follow the types.&lt;/p&gt; &lt;p&gt;You may find yourself in a position of being unsure how to proceed for a given exercise. You are encouraged to adopt a different perspective. Instead of asking how to proceed, ask how you might proceed while adhering to the guideline provided by the types for the exercise at hand.&lt;/p&gt; &lt;p&gt;It is possible to follow the types without achieving the desired goal, however, this is reasonably unlikely at the start. As you become more reliant on following the types, you will develop more trust in the potential paths that they can take you, including identification of false paths.&lt;/p&gt; &lt;p&gt;Where types fall short, use the tests written in comments above each exercise. They can be copied and pasted into GHCi. You should also take the first step of following the types. Do it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Do not use tab characters&lt;/p&gt; &lt;p&gt;Set up your text editor to use space characters rather than tabs. Using tab characters in Haskell can lead to confusing error messages. GHC will give you a warning if your program contains a tab character.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Running the tests&lt;/h3&gt; &#xA;&lt;p&gt;Tests are stored under the &lt;code&gt;src/Test/&lt;/code&gt; directory. Each module from the course that has tests has a corresponding &lt;code&gt;&amp;lt;MODULE&amp;gt;Test.hs&lt;/code&gt; file. Within each test module, tests for each function are grouped using the &lt;code&gt;testGroup&lt;/code&gt; function. Within each test group there are test cases (&lt;code&gt;testCase&lt;/code&gt; function), and properties (&lt;code&gt;testProperty&lt;/code&gt; function).&lt;/p&gt; &#xA;&lt;p&gt;Tests are run using a built-in test runner that has no requirements beyond those of the course (a supported version of GHCi). By default, the full test suite is loaded, and each module&#39;s tests are exported. You can run the tests in GHCi like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; test test_List&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Specific modules&lt;/h4&gt; &#xA;&lt;p&gt;For convenience, each test module also exports individual tests. To run tests from a single module, load it, and then run &lt;code&gt;test &amp;lt;tests&amp;gt;&lt;/code&gt;. For example, in &lt;code&gt;GHCi&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; :l src/Test/ListTest.hs&#xA;&amp;gt;&amp;gt; test headOrTest&#xA;&amp;gt;&amp;gt; test productTest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;:reload&lt;/code&gt; and run tests&lt;/h4&gt; &#xA;&lt;p&gt;There is also a custom &lt;code&gt;:test&lt;/code&gt; command defined in &lt;code&gt;.ghci&lt;/code&gt; that will invoke &lt;code&gt;:reload&lt;/code&gt; and then &lt;code&gt;test&lt;/code&gt; in a single action:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; :test test_List&#xA;&amp;gt;&amp;gt; :test headOrTest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;doctest&lt;/h4&gt; &#xA;&lt;p&gt;The doctest tests are a mirror of the tests that reside in comments alongside the code. They are not executable, but examples can be copied into GHCI. Examples begin with &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; while properties begin with &lt;code&gt;prop&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Progression&lt;/h3&gt; &#xA;&lt;p&gt;We recommend you perform some exercises before others. The first step is to inspect the introduction modules.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.ExactlyOne&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.Validation&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;They contain examples of data structures and Haskell syntax. They do not contain exercises and exist to provide a cursory examination of Haskell syntax. The next step is to complete the exercises in &lt;code&gt;Course.Optional&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;After this, we recommend the following progression of modules:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.List&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.Functor&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.Applicative&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.Monad&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.FileIO&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.State&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.StateT&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.Extend&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.Comonad&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.Contravariant&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.Compose&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.Traversable&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.ListZipper&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.Parser&lt;/code&gt; &lt;em&gt;(see also &lt;code&gt;Course.Person&lt;/code&gt; for the parsing rules)&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.MoreParser&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.JsonParser&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.Interactive&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.Anagrams&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.FastAnagrams&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Course.Cheque&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;During this progression, it is often the case that some exercises are abandoned due to time constraints and the benefit of completing some exercises over others. For example, in the progression, &lt;code&gt;Course.Functor&lt;/code&gt; to &lt;code&gt;Course.Monad&lt;/code&gt;, the exercises repeat a similar theme. Instead, a participant may wish to do different exercises, such as &lt;code&gt;Course.Parser&lt;/code&gt;. In this case, the remaining answers are filled out, so that progress on to &lt;code&gt;Course.Parser&lt;/code&gt; can begin (which depends on correct answers up to &lt;code&gt;Course.Monad&lt;/code&gt;). It is recommended to take this deviation if it is felt that there is more reward in doing so.&lt;/p&gt; &#xA;&lt;p&gt;Answers for the exercises can be found here: &lt;a href=&#34;https://github.com/tonymorris/fp-course&#34;&gt;https://github.com/tonymorris/fp-course&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;After these are completed, complete the exercises in the &lt;code&gt;projects&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h3&gt;Introducing Haskell&lt;/h3&gt; &#xA;&lt;p&gt;This section is a guide for the instructor to introduce Haskell syntax. Each of these points should be covered before attempting the exercises.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;values, assignment&lt;/li&gt; &#xA; &lt;li&gt;type signatures &lt;code&gt;::&lt;/code&gt; reads as &lt;em&gt;has the type&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The &lt;code&gt;-&amp;gt;&lt;/code&gt; in a type signature is &lt;em&gt;right-associative&lt;/em&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;functions are values&lt;/li&gt; &#xA; &lt;li&gt;functions take arguments &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;functions take &lt;em&gt;only one argument&lt;/em&gt; but we approximate with spoken language&lt;/li&gt; &#xA;   &lt;li&gt;functions can be declared inline using &lt;em&gt;lambda expressions&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;the &lt;code&gt;\&lt;/code&gt; symbol in a lambda expression denotes a Greek lambda&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;operators, beginning with non-alpha character, are in infix position by default &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;use in prefix position by surrounding with &lt;em&gt;(parentheses)&lt;/em&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;regular identifiers, beginning with alpha character, are in prefix position by default &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;use in infix position by surrounding with &lt;code&gt;backticks&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;polymorphism &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;type variables &lt;em&gt;always&lt;/em&gt; start with a lower-case character&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;data types, declared using the &lt;code&gt;data&lt;/code&gt; keyword &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;following the &lt;code&gt;data&lt;/code&gt; keyword is the &lt;em&gt;data type name&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;following the data type name are zero of more type variables&lt;/li&gt; &#xA;   &lt;li&gt;then &lt;code&gt;=&lt;/code&gt; sign&lt;/li&gt; &#xA;   &lt;li&gt;data types have zero or more constructors &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;data type constructors start with an upper-case character, or colon &lt;code&gt;(:)&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;following each constructor is a list of zero or more &lt;em&gt;constructor arguments&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;between each constructor is a pipe symbol &lt;code&gt;(|)&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;the &lt;code&gt;deriving&lt;/code&gt; keyword gives us default implementations for some functions on that data type&lt;/li&gt; &#xA;   &lt;li&gt;when constructors appear on the left side of &lt;code&gt;=&lt;/code&gt; we are &lt;em&gt;pattern-matching&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;when constructors appear on the right side of &lt;code&gt;=&lt;/code&gt; we are &lt;em&gt;constructing&lt;/em&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;type-classes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Learning the tools&lt;/h3&gt; &#xA;&lt;p&gt;When this course is run in-person, some tools, particularly within Haskell, are covered first.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GHCi &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;values&lt;/li&gt; &#xA; &lt;li&gt;type signatures &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;x :: T&lt;/code&gt; is read as &lt;em&gt;x is of the type T&lt;/em&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;functions are values&lt;/li&gt; &#xA; &lt;li&gt;functions take arguments&lt;/li&gt; &#xA; &lt;li&gt;functions take one argument&lt;/li&gt; &#xA; &lt;li&gt;lambda expressions&lt;/li&gt; &#xA; &lt;li&gt;operators (infix/prefix) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;identifiers starting with &lt;code&gt;isAlpha&lt;/code&gt; are prefix by default, infix surrounded in backticks (`)&lt;/li&gt; &#xA;   &lt;li&gt;other identifiers are infix by default, prefix surrounded in parentheses&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;data types &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;data&lt;/code&gt; keyword&lt;/li&gt; &#xA;   &lt;li&gt;recursive data types&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;pattern matching&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;deriving&lt;/code&gt; keyword&lt;/li&gt; &#xA; &lt;li&gt;type-classes&lt;/li&gt; &#xA; &lt;li&gt;type parameters &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;always lower-case &#39;a&#39;..&#39;z&#39;&lt;/li&gt; &#xA;   &lt;li&gt;aka generics, templates C++, parametric polymorphism&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Parser grammar assistance&lt;/h3&gt; &#xA;&lt;p&gt;The exercises in &lt;code&gt;Parser.hs&lt;/code&gt; can be assisted by stating problems in a specific way, with a conversion to code.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;English&lt;/th&gt; &#xA;   &lt;th&gt;Parser library&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;and then&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bindParser&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;always&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;valueParser&lt;/code&gt; &lt;code&gt;pure&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;or&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;|||&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0 or many&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;list&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1 or many&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;list1&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;is&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;is&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;exactly n&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;thisMany n&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;call it x&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;\x -&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Monad comprehension&lt;/h3&gt; &#xA;&lt;h5&gt;do-notation&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;insert the word &lt;code&gt;do&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;turn &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; into &lt;code&gt;&amp;lt;-&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;delete &lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;delete &lt;code&gt;\&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;swap each side of &lt;code&gt;&amp;lt;-&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;LINQ&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;write &lt;code&gt;from&lt;/code&gt; on each line&lt;/li&gt; &#xA; &lt;li&gt;turn &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; into in&lt;/li&gt; &#xA; &lt;li&gt;delete &lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;delete &lt;code&gt;\&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;swap each side of &lt;code&gt;in&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;turn value into &lt;code&gt;select&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Demonstrate IO maintains referential transparency&lt;/h3&gt; &#xA;&lt;p&gt;Are these two programs, the same program?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;p1 ::&#xA;  IO ()&#xA;p1 =&#xA;  let file = &#34;/tmp/file&#34;&#xA;  in  do  _ &amp;lt;- writeFile file &#34;abcdef&#34;&#xA;          x &amp;lt;- readFile file&#xA;          _ &amp;lt;- putStrLn x&#xA;          _ &amp;lt;- writeFile file &#34;ghijkl&#34;&#xA;          y &amp;lt;- readFile file&#xA;          putStrLn (show (x, y))&#xA;&#xA;p2 ::&#xA;  IO ()&#xA;p2 =&#xA;  let file = &#34;/tmp/file&#34;&#xA;      expr = readFile file&#xA;  in  do  _ &amp;lt;- writeFile file &#34;abcdef&#34;&#xA;          x &amp;lt;- expr&#xA;          _ &amp;lt;- putStrLn x&#xA;          _ &amp;lt;- writeFile file &#34;ghijkl&#34;&#xA;          y &amp;lt;- expr&#xA;          putStrLn (show (x, y))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What about these two programs?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;def writeFile(filename, contents):&#xA;    with open(filename, &#34;w&#34;) as f:&#xA;        f.write(contents)&#xA;&#xA;def readFile(filename):&#xA;    contents = &#34;&#34;&#xA;    with open(filename, &#34;r&#34;) as f:&#xA;        contents = f.read()&#xA;        return contents&#xA;&#xA;def p1():&#xA;    file = &#34;/tmp/file&#34;&#xA;&#xA;    writeFile(file, &#34;abcdef&#34;)&#xA;    x = readFile(file)&#xA;    print(x)&#xA;    writeFile(file, &#34;ghijkl&#34;)&#xA;    y = readFile(file)&#xA;    print (x + y)&#xA;&#xA;def p2():&#xA;    file = &#34;/tmp/file&#34;&#xA;    expr = readFile(file)&#xA;&#xA;    writeFile(file, &#34;abcdef&#34;)&#xA;    x = expr&#xA;    print(x)&#xA;    writeFile(file, &#34;ghijkl&#34;)&#xA;    y = expr&#xA;    print (x + y)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;One-day&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes this course material is condensed into one-day. In these cases, the following exercises are recommended:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Optional&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;mapOptional&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;bindOptional&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;(??)&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;(&amp;lt;+&amp;gt;)&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;List&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;headOr&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;product&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;length&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;map&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;(++)&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;flatMap&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Functor&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;instance Functor List&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;instance Functor Optional&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;instance Functor ((-&amp;gt;) t)&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;instance Functor void&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Applicative&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;instance Applicative List&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;instance Applicative Optional&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;instance Applicative ((-&amp;gt;) t)&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;lift2&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;sequence&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FileIO&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;What about cabal and stack?&lt;/h3&gt; &#xA;&lt;p&gt;This repository&#39;s primary purpose is to support in-person instruction for people who have potentially not even used development tools at all. We have therefore designed the course around &lt;code&gt;ghci&lt;/code&gt; as the primary tool.&lt;/p&gt; &#xA;&lt;p&gt;If you are a more experienced developer with tooling set up, and you need a cabal file, &lt;code&gt;shell.nix&lt;/code&gt; or &lt;code&gt;stack.yaml&lt;/code&gt; to have working development tools, run the &lt;code&gt;support/copy-tool-files.sh&lt;/code&gt; script from the root of the repository.&lt;/p&gt; &#xA;&lt;p&gt;(Windows users, try running &lt;code&gt;support\copy-tool-files.bat&lt;/code&gt; from the repository root.)&lt;/p&gt; &#xA;&lt;h3&gt;References&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:error&#34;&gt;The Haskell &lt;code&gt;error&lt;/code&gt; function&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://haskell.org/ghc&#34;&gt;Glasgow Haskell Compiler&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>necrobious/hS3</title>
    <updated>2022-06-15T01:43:07Z</updated>
    <id>tag:github.com,2022-06-15:/necrobious/hS3</id>
    <link href="https://github.com/necrobious/hS3" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell S3 Client, forked from http://hackage.haskell.org/package/hS3 to support MD5 validation on upload and removed dependency on MissingH&lt;/p&gt;&lt;hr&gt;&lt;p&gt;This is the Haskell S3 library (hS3). It provides an interface to Amazon&#39;s Simple Storage Service, allowing Haskell developers to reliably store and retrieve arbitrary amounts of data from anywhere on the Internet. To learn more about Amazon S3, and sign up for an account, visit [http://aws.amazon.com/s3].&lt;/p&gt;</summary>
  </entry>
</feed>