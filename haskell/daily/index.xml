<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-08T01:36:22Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nomeata/cabal-plan-bounds</title>
    <updated>2023-01-08T01:36:22Z</updated>
    <id>tag:github.com,2023-01-08:/nomeata/cabal-plan-bounds</id>
    <link href="https://github.com/nomeata/cabal-plan-bounds" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Calculate Haskell dependency ranges from multiple build plans&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;cabal-plan-bounds: generate cabal bounds from actual build plans&lt;/h1&gt; &#xA;&lt;p&gt;TL;DR: Updates the &lt;code&gt;.cabal&lt;/code&gt; file’s &lt;code&gt;build-depends&lt;/code&gt; and (not yet) &lt;code&gt;tested-with&lt;/code&gt; based on the &lt;code&gt;build.json&lt;/code&gt; of actual build paths. You never have to edit the build depends manually again.&lt;/p&gt; &#xA;&lt;h2&gt;The problem&lt;/h2&gt; &#xA;&lt;p&gt;Manually curated dependency version ranges tend to become a lie: They likely include versions of your dependencies that are neither longer tested by your CI system, or implied by compatibility with the tested versions (by way of the &lt;a href=&#34;https://pvp.haskell.org/&#34;&gt;PVP&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Typically, these are versions near the lower edge of the bounds, but can also be on the upper end (e.g. when they are packaged with GHC and Cabal prefers installed versions, or when they are not actually installable yet).&lt;/p&gt; &#xA;&lt;p&gt;There are ways to mitigate this problem, such as being very careful, and maybe using Cabal&#39;s new &lt;a href=&#34;https://cabal.readthedocs.io/en/latest/cabal-project.html#cfg-field-prefer-oldest&#34;&gt;&lt;code&gt;--prefer-oldest&lt;/code&gt;&lt;/a&gt; flag. But these are not reliable.&lt;/p&gt; &#xA;&lt;h2&gt;The solution&lt;/h2&gt; &#xA;&lt;p&gt;So the conclusion must be to &lt;strong&gt;not write build-depends ranges by hand.&lt;/strong&gt; Which is an unpleasant chore anyway.&lt;/p&gt; &#xA;&lt;p&gt;Instead, &lt;strong&gt;derive the build-depends from your actual CI builds&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Presumably you test your code in different situations anyways – different versions of GHC, stackage releases etc. Keep doing that, collect the &lt;em&gt;actual&lt;/em&gt; build plans used in these CI systems. Then pass them to &lt;code&gt;cabal-plan-bounds&lt;/code&gt; which will update the bounds accordingly.&lt;/p&gt; &#xA;&lt;h2&gt;Simple example&lt;/h2&gt; &#xA;&lt;p&gt;For a simple example, you can just call &lt;code&gt;cabal build&lt;/code&gt; with different compilers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal build -w ghc-8.10.7 --builddir dist-8.10.7&#xA;$ cabal build -w ghc-9.0.2 --builddir dist-9.0.2&#xA;$ cabal build -w ghc-9.2.5 --builddir dist-9.2.5&#xA;$ cabal build -w ghc-9.4.4 --builddir dist-9.4.4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and then update the cabal file&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal-plan-bounds dist-{8.10.7,9.0.2,9.2.5,9.4.4}/cache/plan.json -c cabal-plan-bounds.cabal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will lead to the following diff:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;diff --git a/cabal-plan-bounds.cabal b/cabal-plan-bounds.cabal&#xA;index 1db21ca..a99e7bc 100644&#xA;--- a/cabal-plan-bounds.cabal&#xA;+++ b/cabal-plan-bounds.cabal&#xA;@@ -20,9 +20,12 @@ executable cabal-plan-bounds&#xA;     import:           warnings&#xA;     main-is:          Main.hs&#xA;     other-modules:    ReplaceDependencies&#xA;-    build-depends:    base, Cabal-syntax, cabal-plan,&#xA;-                      optparse-applicative, containers,&#xA;-                      text&#xA;-    build-depends:    bytestring,&#xA;+    build-depends:    base ^&amp;gt;=4.14.3.0 || ^&amp;gt;=4.15.1.0 || ^&amp;gt;=4.16.4.0 || ^&amp;gt;=4.17.0.0,&#xA;+                      Cabal-syntax ^&amp;gt;=3.8.1.0,&#xA;+                      cabal-plan ^&amp;gt;=0.7.2.3,&#xA;+                      optparse-applicative ^&amp;gt;=0.17.0.0,&#xA;+                      containers ^&amp;gt;=0.6.4.1,&#xA;+                      text ^&amp;gt;=1.2.4.1 || ^&amp;gt;=2.0.1&#xA;+    build-depends:    bytestring ^&amp;gt;=0.10.12.0 || ^&amp;gt;=0.11.3.1&#xA;     hs-source-dirs:   src/&#xA;     default-language: Haskell2010&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;More sophisticated setup&lt;/h2&gt; &#xA;&lt;p&gt;For a more sophisticated setup, you can create multiple &lt;code&gt;cabal.project&lt;/code&gt; files, one for each setting:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ls ci-configs/&#xA;ghc-8.10.7.config  ghc-9.2.5.config  stackage-nightly.config&#xA;ghc-9.0.2.config   ghc-9.4.4.config&#xA;$ cat ci-configs/ghc-9.4.4.config&#xA;import: cabal.project&#xA;active-repositories: hackage.haskell.org:merge&#xA;index-state: hackage.haskell.org 2022-12-21T10:40:48Z&#xA;with-compiler: ghc-9.4.4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we pin the compiler version and the precise view of Hackage repo to get reproducible results. You can imagine a separate tool that regularly updates these time stamps.&lt;/p&gt; &#xA;&lt;p&gt;Similarly, we can pull in stackage configurations, simply by importing the corresponding &lt;code&gt;cabal.config&lt;/code&gt;, which also pins down the compiler&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cat ci-configs/stackage-nightly.config&#xA;import: cabal.project&#xA;import: https://www.stackage.org/nightly-2023-01-03/cabal.config&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Probably these should also pin the &lt;code&gt;index-state&lt;/code&gt; for reproducibility -- up to you.)&lt;/p&gt; &#xA;&lt;p&gt;Now you can configure your CI system to run one job for each of these configs, collect the &lt;code&gt;plan.json&lt;/code&gt; files, and finally check that the version bounds in your &lt;code&gt;.cabal&lt;/code&gt; file match, and if not, complain or auto-update them. See the workflow file of this repository for an example.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal-plan-bounds -- --help&#xA;Derives dependency bounds from build plans&#xA;&#xA;Usage: cabal-plan-bounds [PLAN] [-c|--cabal CABALFILE]&#xA;&#xA;Available options:&#xA;  -h,--help                Show this help text&#xA;  PLAN                     plan file to read (.json)&#xA;  -c,--cabal CABALFILE     cabal file to update (.cabal)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Features and limitations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;You can pass more than one cabal file at the same time.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;It edits the &lt;code&gt;.cabal&lt;/code&gt; file in place.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;It leaves the &lt;code&gt;.cabal&lt;/code&gt; file as is: No reformatting, all comments are preserved.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Only the &lt;code&gt;build-depends&lt;/code&gt; fields are touched. They are reformatted (one dependency per line).&lt;/p&gt; &lt;p&gt;It does not add, remove or reorder the packages mentioned in the dependencies.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;It will apply the same bounds to &lt;em&gt;all&lt;/em&gt; mentions of a dependency in the &lt;code&gt;.cabal&lt;/code&gt; file (e.g. in different components, or in conditionals).&lt;/p&gt; &lt;p&gt;It does not support different ranges in different components. (Maybe it could be smarter here, but due to &lt;code&gt;common&lt;/code&gt; sections and conditionals, it cannot be complete.)&lt;/p&gt; &lt;p&gt;This means some behaviour cannot be achieved. Maybe this needs to be revised (especially with regard to conditionals).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Future work (contributions welcome!)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Proper error handling, e.g. while parsing.&lt;/li&gt; &#xA; &lt;li&gt;A test suite&lt;/li&gt; &#xA; &lt;li&gt;Printing a nice human-readable summary of dependency changes.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;--extend&lt;/code&gt; mode that only &lt;em&gt;extends&lt;/em&gt; the &lt;code&gt;.cabal&lt;/code&gt; file. This can be used locally if you add a new configuration, and leave it to CI to run all configurations and clean up the &lt;code&gt;.cabal&lt;/code&gt; file.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;--dry-run&lt;/code&gt; mode that does not touch the &lt;code&gt;.cabal&lt;/code&gt; file.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;--check&lt;/code&gt; mode that does not touch the &lt;code&gt;.cabal&lt;/code&gt; file, but fails if it would change it (for CI).&lt;/li&gt; &#xA; &lt;li&gt;Update the &lt;code&gt;tested-with&lt;/code&gt; field according to the compiler versions used.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>