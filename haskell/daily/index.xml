<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-11T01:33:39Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cachix/cachix</title>
    <updated>2022-11-11T01:33:39Z</updated>
    <id>tag:github.com,2022-11-11:/cachix/cachix</id>
    <link href="https://github.com/cachix/cachix" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Command line client for Nix binary cache hosting:&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/cachix/cachix/actions&#34;&gt;&lt;img src=&#34;https://github.com/cachix/cachix/workflows/Test/badge.svg?sanitize=true&#34; alt=&#34;Test&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/cachix&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/cachix.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://cachix.org&#34;&gt;Cachix&lt;/a&gt; - Nix binary cache hosting: Never build software twice.&lt;/h2&gt; &#xA;&lt;img src=&#34;https://user-images.githubusercontent.com/126339/130430964-7794b915-89d1-4b08-94be-3d32444dc8b2.png&#34; width=&#34;200&#34;&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cachix --help&#xA;https://cachix.org command line interface&#xA;&#xA;Usage: cachix [--hostname URI] [-c|--config CONFIGPATH] [-v|--verbose]&#xA;              (COMMAND | (-V|--version))&#xA;&#xA;  To get started log in to https://app.cachix.org&#xA;&#xA;Available options:&#xA;  -h,--help                Show this help text&#xA;  --hostname URI           Host to connect to (default: https://cachix.org)&#xA;  -c,--config CONFIGPATH   Cachix configuration file&#xA;                           (default: &#34;/home/domen/.config/cachix/cachix.dhall&#34;)&#xA;  -v,--verbose             Verbose mode&#xA;  -V,--version             Show cachix version&#xA;&#xA;Available commands:&#xA;  authtoken                Configure authentication token for communication to&#xA;                           HTTP API&#xA;  config                   Manage configuration settings for cachix&#xA;  generate-keypair         Generate signing key pair for a binary cache&#xA;  push                     Upload Nix store paths to a binary cache&#xA;  watch-exec               Run a command while it&#39;s running watch /nix/store for&#xA;                           newly added store paths and upload them to a binary&#xA;                           cache&#xA;  watch-store              Indefinitely watch /nix/store for newly added store&#xA;                           paths and upload them to a binary cache&#xA;  use                      Configure a binary cache by writing nix.conf and&#xA;                           netrc files&#xA;  deploy                   Cachix Deploy commands&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install Cachix client using Nix:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ nix-env -iA cachix -f https://cachix.org/api/v1/install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Login via &lt;a href=&#34;https://www.cachix.org/api/v1/login&#34;&gt;https://www.cachix.org/api/v1/login&lt;/a&gt; to start using the service&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;Install Cachix from master:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ nix-env -if https://github.com/cachix/cachix/tarball/master --substituters &#39;https://cache.nixos.org https://cachix.cachix.org&#39; --trusted-public-keys &#39;cachix.cachix.org-1:eWNHQldwUO7G2VkjpnjDbWwy4KQ/HNxht7H4SSoMckM= cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or with Nix 2.4+:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ nix profile install github:cachix/cachix/latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.cachix.org&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://matrix.to/#/#cachix:matrix.org&#34;&gt;#cachix@matrix.org&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;mailto:support@cachix.org&#34;&gt;support@cachix.org&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cachix/cachix/master/cachix/CHANGELOG.md&#34;&gt;Cachix changelog&lt;/a&gt; for the command&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cachix/cachix/master/cachix-api/CHANGELOG.md&#34;&gt;API changelog&lt;/a&gt; (Haskell)&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>aspiwack/haskell-benign</title>
    <updated>2022-11-11T01:33:39Z</updated>
    <id>tag:github.com,2022-11-11:/aspiwack/haskell-benign</id>
    <link href="https://github.com/aspiwack/haskell-benign" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A library for benign effects in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Benign&lt;/h1&gt; &#xA;&lt;p&gt;A library for benign effects in Haskell&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;The current state is a proof of concept, it is not meant to be used in actual projects nor do I guarantee any stability yet&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Philosophy&lt;/h2&gt; &#xA;&lt;p&gt;A core tenet of Haskell programming is “pure core, imperative shell”. We write most of our programs in pure style, and a small outer layer in imperative shell. This is great for correctness, but it comes at a great cost for observability. Because logging, tracing, or measuring time are all considered effects, we can&#39;t log, trace or measure time in pure code.&lt;/p&gt; &#xA;&lt;p&gt;This means that most of our code is traditionally unobservable. There are some built-in facilities in GHC, such as cost-centre profiling. But besides putting pressure on the compiler to build these tools, these facilities are out of the language, hence not programmable in anyway way.&lt;/p&gt; &#xA;&lt;p&gt;The Benign library is an attempt to address this gap. A difficulty is laziness. With laziness, things have a beginning (when the thunk is being forced), but not a well-defined end. So what do we measure the time of? The solution of the Benign library is to be less lazy. We keep laziness for algorithms, but use strict (or at least stricter) types to assemble bigger steps. It&#39;s fine to log or trace in pure code, since we don&#39;t consider that these observations are part of the semantics of the program.&lt;/p&gt; &#xA;&lt;p&gt;The Benign library provides facilities to create benign effects, including to use strict types to assemble these large steps.&lt;/p&gt; &#xA;&lt;p&gt;The premise underlying all this, as well as the implementation of the library, is that logging or tracing is not very fast. So we don&#39;t want to log or trace in places where performance is really essential. This is why at the most inner level, where tight loops and algorithms live, laziness is not a problem: we are not going to log there, this would cost too much performance. At a more outer level, we can use strictness to make steps with a beginning and an end. It&#39;s ok if there is a cost in terms of conversion, this is not where we need to optimise too much. The library can, and does, prevent optimisation through its functions (note that cost-centre profiling also prevents optimisation through cost centres; it isn&#39;t surprising that we are having a similar problem). With the optimisation not working at that level, strictness is much less of a problem.&lt;/p&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;Build as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ stack build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The formatter is Ormolu 0.5.0.1. Format with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ just format&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use Nix (specifically &lt;code&gt;nix-shell&lt;/code&gt;) to provide all the necessary dependencies (including a compatible Haskell Language Server).&lt;/p&gt; &#xA;&lt;p&gt;For reasons unknown to me, Ormolu is not cached in the pinned version of Nix. I haven&#39;t had time to investigate, instead I&#39;m using Cachix. For the &lt;code&gt;nix-shell&lt;/code&gt; to load fast, &lt;a href=&#34;https://docs.cachix.org/installation&#34;&gt;install cachix&lt;/a&gt; and run (once per machine) prior to building the Nix shell.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cachix use aspiwack&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Acknowledgement&lt;/h2&gt; &#xA;&lt;p&gt;Credits go to&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Alexis King for helping me come up with the implementation strategy based on &lt;code&gt;async&lt;/code&gt; and thread ids.&lt;/li&gt; &#xA; &lt;li&gt;Thomas Bagrel for suggesting (in another context) the phrase “lexical state” to me. I don&#39;t know whether the phrase has been used before, a quick googling didn&#39;t turn up anything.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>