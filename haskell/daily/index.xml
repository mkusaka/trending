<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-11T01:49:22Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>github/semantic</title>
    <updated>2022-06-11T01:49:22Z</updated>
    <id>tag:github.com,2022-06-11:/github/semantic</id>
    <link href="https://github.com/github/semantic" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Parsing, analyzing, and comparing source code across many languages&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Semantic&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;semantic&lt;/code&gt; is a Haskell library and command line tool for parsing, analyzing, and comparing source code.&lt;/p&gt; &#xA;&lt;p&gt;In a hurry? Check out our documentation of &lt;a href=&#34;https://raw.githubusercontent.com/github/semantic/main/docs/examples.md&#34;&gt;example uses for the &lt;code&gt;semantic&lt;/code&gt; command line tool&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Table of Contents&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/github/semantic/main/#usage&#34;&gt;Usage&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/github/semantic/main/#language-support&#34;&gt;Language support&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/github/semantic/main/#development&#34;&gt;Development&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/github/semantic/main/#technology-and-architecture&#34;&gt;Technology and architecture&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/github/semantic/main/#licensing&#34;&gt;Licensing&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Run &lt;code&gt;semantic --help&lt;/code&gt; for complete list of up-to-date options.&lt;/p&gt; &#xA;&lt;h4&gt;Parse&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: semantic parse [--sexpression | (--json-symbols|--symbols) |&#xA;                        --proto-symbols | --show | --quiet] [FILES...]&#xA;  Generate parse trees for path(s)&#xA;&#xA;Available options:&#xA;  --sexpression            Output s-expression parse trees (default)&#xA;  --json-symbols,--symbols Output JSON symbol list&#xA;  --proto-symbols          Output protobufs symbol list&#xA;  --show                   Output using the Show instance (debug only, format&#xA;                           subject to change without notice)&#xA;  --quiet                  Don&#39;t produce output, but show timing stats&#xA;  -h,--help                Show this help text&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Language support&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Language&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Parse&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;AST Symbols‚Ä†&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Stack graphs&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Ruby&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;JavaScript&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;TypeScript&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;üöß&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Python&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;üöß&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Go&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;PHP&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Java&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;üöß&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;JSON&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚¨úÔ∏è&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚¨úÔ∏è&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;JSX&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;TSX&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;CodeQL&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;‚úÖ&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Haskell&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;üöß&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;üöß&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;‚Ä† Used for &lt;a href=&#34;https://help.github.com/en/github/managing-files-in-a-repository/navigating-code-on-github&#34;&gt;code navigation&lt;/a&gt; on github.com.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;‚úÖ ‚Äî Supported&lt;/li&gt; &#xA; &lt;li&gt;üî∂ ‚Äî Partial support&lt;/li&gt; &#xA; &lt;li&gt;üöß ‚Äî Under development&lt;/li&gt; &#xA; &lt;li&gt;‚¨ú - N/A Ô∏è&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;semantic&lt;/code&gt; requires at least GHC 8.10.1 and Cabal 3.0. We strongly recommend using &lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;&lt;code&gt;ghcup&lt;/code&gt;&lt;/a&gt; to sandbox GHC versions, as GHC packages installed through your OS&#39;s package manager may not install statically-linked versions of the GHC boot libraries. &lt;code&gt;semantic&lt;/code&gt; currently builds only on Unix systems; users of other operating systems may wish to use the &lt;a href=&#34;https://github.com/github/semantic/packages/11609&#34;&gt;Docker images&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We use &lt;code&gt;cabal&#39;s&lt;/code&gt; &lt;a href=&#34;https://cabal.readthedocs.io/en/3.4/nix-local-build-overview.html&#34;&gt;Nix-style local builds&lt;/a&gt; for development. To get started quickly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git@github.com:github/semantic.git&#xA;cd semantic&#xA;script/bootstrap&#xA;cabal v2-build all&#xA;cabal v2-run semantic:test&#xA;cabal v2-run semantic:semantic -- --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use the &lt;a href=&#34;https://bazel.build&#34;&gt;Bazel&lt;/a&gt; build system for development. To learn more about Bazel and why it might give you a better development experience, check the &lt;a href=&#34;https://raw.githubusercontent.com/github/semantic/main/docs/build.md&#34;&gt;build documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git@github.com:github/semantic.git&#xA;cd semantic&#xA;script/bootstrap-bazel&#xA;bazel build //...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;stack&lt;/code&gt; as a build tool is not officially supported; there is &lt;a href=&#34;https://github.com/jkachmar/semantic-stack-yaml&#34;&gt;unofficial &lt;code&gt;stack.yaml&lt;/code&gt; support&lt;/a&gt; available, though we cannot make guarantees as to its stability.&lt;/p&gt; &#xA;&lt;h2&gt;Technology and architecture&lt;/h2&gt; &#xA;&lt;p&gt;Architecturally, &lt;code&gt;semantic&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Generates per-language Haskell syntax types based on &lt;a href=&#34;https://github.com/tree-sitter/tree-sitter&#34;&gt;tree-sitter&lt;/a&gt; grammar definitions.&lt;/li&gt; &#xA; &lt;li&gt;Reads blobs from a filesystem or provided via a protocol buffer request.&lt;/li&gt; &#xA; &lt;li&gt;Returns blobs or performs analysis.&lt;/li&gt; &#xA; &lt;li&gt;Renders output in one of many supported formats.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Throughout its lifestyle, &lt;code&gt;semantic&lt;/code&gt; has leveraged a number of interesting algorithms and techniques, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Myers&#39; algorithm (SES) as described in the paper &lt;a href=&#34;http://www.xmailserver.org/diff2.pdf&#34;&gt;&lt;em&gt;An O(ND) Difference Algorithm and Its Variations&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;RWS as described in the paper &lt;a href=&#34;https://db.in.tum.de/~finis/papers/RWS-Diff.pdf&#34;&gt;&lt;em&gt;RWS-Diff: Flexible and Efficient Change Detection in Hierarchical Data&lt;/em&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Open unions and &lt;a href=&#34;http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf&#34;&gt;data types √† la carte&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;An implementation of &lt;a href=&#34;https://plum-umd.github.io/abstracting-definitional-interpreters/&#34;&gt;Abstracting Definitional Interpreters&lt;/a&gt; extended to work with an √† la carte representation of syntax terms.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributions&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are welcome! Please see our &lt;a href=&#34;https://raw.githubusercontent.com/github/semantic/main/CONTRIBUTING.md&#34;&gt;contribution guidelines&lt;/a&gt; and our &lt;a href=&#34;https://raw.githubusercontent.com/github/semantic/main/CODE_OF_CONDUCT.md&#34;&gt;code of conduct&lt;/a&gt; for details on how to participate in our community.&lt;/p&gt; &#xA;&lt;h2&gt;Licensing&lt;/h2&gt; &#xA;&lt;p&gt;Semantic is licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/github/semantic/main/semantic/LICENSE&#34;&gt;MIT license&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>kowainik/relude</title>
    <updated>2022-06-11T01:49:22Z</updated>
    <id>tag:github.com,2022-06-11:/kowainik/relude</id>
    <link href="https://github.com/kowainik/relude" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üåÄ Safe, performant, user-friendly and lightweight Haskell standard library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;relude&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/8126674/67678250-9d8eab80-f99f-11e9-96ca-27883ceeefa6.png&#34; alt=&#34;Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kowainik/relude/actions&#34;&gt;&lt;img src=&#34;https://github.com/kowainik/relude/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;GitHub CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/relude&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/relude.svg?logo=haskell&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stackage.org/lts/package/relude&#34;&gt;&lt;img src=&#34;http://stackage.org/package/relude/badge/lts&#34; alt=&#34;Stackage LTS&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stackage.org/nightly/package/relude&#34;&gt;&lt;img src=&#34;http://stackage.org/package/relude/badge/nightly&#34; alt=&#34;Stackage Nightly&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-yellow.svg?sanitize=true&#34; alt=&#34;License: MIT&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;relude&lt;/code&gt;&lt;/strong&gt; is a safe, performant, user-friendly and lightweight Haskell standard library.&lt;/p&gt; &#xA;&lt;p&gt;The default &lt;code&gt;Prelude&lt;/code&gt; is not perfect and doesn&#39;t always satisfy one&#39;s needs. At this stage you may want to try an alternative prelude library. In this README we are going to give you convincing reasons to consider using &lt;code&gt;relude&lt;/code&gt; as such alternative in your next project.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;relude&lt;/code&gt; has some strong goals and principles that it sticks to. That principles defines the library decisions and might tell you more about the priorities of the library. So below you can find the key design principles behind &lt;code&gt;relude&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Productivity.&lt;/strong&gt; You can be more productive with a &#34;non-standard&#34; standard library, and &lt;code&gt;relude&lt;/code&gt; helps you with writing safer and more efficient code faster.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Total programming&lt;/strong&gt;. Usage of &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/5n51u3/why_are_partial_functions_as_in_head_tail_bad/&#34;&gt;&lt;em&gt;partial functions&lt;/em&gt;&lt;/a&gt; can lead to unexpected bugs and runtime exceptions in pure code. The types of partial functions lie about their behaviour. And even if it is not always possible to rely only on total functions, &lt;code&gt;relude&lt;/code&gt; strives to encourage best-practices and reduce the chances of introducing a bug.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Partial&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Total&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;head :: [a] -&amp;gt; a&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;head :: NonEmpty a -&amp;gt; a&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;tail :: [a] -&amp;gt; [a]&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tail :: NonEmpty a -&amp;gt; [a]&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;read :: Read a =&amp;gt; String -&amp;gt; a&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;readMaybe :: Read a =&amp;gt; String -&amp;gt; Maybe a&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;fromJust :: Maybe a -&amp;gt; a&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;fromMaybe :: a -&amp;gt; Maybe a -&amp;gt; a&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Type-safety&lt;/strong&gt;. We use the &lt;em&gt;&#34;make invalid states unrepresentable&#34;&lt;/em&gt; motto as one of our guiding principles. If it is possible, we express this concept through the types.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Example:&lt;/em&gt; Here the function&#39;s name type and actions are aligned with each other&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;whenNotNull :: Applicative f =&amp;gt; [a] -&amp;gt; (NonEmpty a -&amp;gt; f ()) -&amp;gt; f ()&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;While in here, the type could represent an unreachable state:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;whenNotNull :: Applicative f =&amp;gt; [a] -&amp;gt; ([a] -&amp;gt; f ()) -&amp;gt; f ()&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Performance.&lt;/strong&gt; We prefer &lt;code&gt;Text&lt;/code&gt; over &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/29jw0s/whats_wrong_with_string/&#34;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, use space-leaks-free functions (e.g. our custom performant &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;product&lt;/code&gt;), introduce &lt;code&gt;{-# INLINE #-}&lt;/code&gt; and &lt;code&gt;{-# SPECIALIZE #-}&lt;/code&gt; pragmas where appropriate, and make efficient container types (e.g. &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;) more accessible.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Minimalism&lt;/strong&gt; (low number of dependencies). We do not force users of &lt;code&gt;relude&lt;/code&gt; to stick to any specific lens or text formatting or logging library. Where possible, &lt;code&gt;relude&lt;/code&gt; depends only on boot libraries. The &lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/relude-dependency-graph.png&#34;&gt;Dependency graph&lt;/a&gt; of &lt;code&gt;relude&lt;/code&gt; can give you a clearer picture.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Convenience&lt;/strong&gt;. Despite minimalism, we want to bring commonly used types and functions into scope, and make available functions easier to use. Some examples of conveniences:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;No need to add &lt;code&gt;containers&lt;/code&gt;, &lt;code&gt;unordered-containers&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;bytestring&lt;/code&gt; to dependencies in your &lt;code&gt;.cabal&lt;/code&gt; file to use the main API of these libraries&lt;/li&gt; &#xA;   &lt;li&gt;No need to import types like &lt;code&gt;NonEmpty&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Reader[T]&lt;/code&gt;, &lt;code&gt;MVar&lt;/code&gt;, &lt;code&gt;STM&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Functions like &lt;code&gt;liftIO&lt;/code&gt;, &lt;code&gt;fromMaybe&lt;/code&gt;, &lt;code&gt;sortWith&lt;/code&gt; are available by default as well&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;IO&lt;/code&gt; actions are lifted to &lt;code&gt;MonadIO&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Excellent documentation.&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Tutorial&lt;/li&gt; &#xA;   &lt;li&gt;Migration guide from &lt;code&gt;Prelude&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Haddock for every function with examples tested by &lt;a href=&#34;http://hackage.haskell.org/package/doctest&#34;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Documentation on &lt;a href=&#34;http://hackage.haskell.org/package/relude/docs/Relude.html&#34;&gt;internal module structure&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;relude&lt;/code&gt;-specific &lt;a href=&#34;http://hackage.haskell.org/package/hlint&#34;&gt;HLint&lt;/a&gt; rules: &lt;a href=&#34;https://github.com/kowainik/relude/raw/main/.hlint.yaml&#34;&gt;&lt;code&gt;.hlint.yaml&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;User-friendliness.&lt;/strong&gt; Anyone should be able to quickly migrate to &lt;code&gt;relude&lt;/code&gt;. Only some basic familiarity with the common libraries like &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;containers&lt;/code&gt; should be enough (but not necessary).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Exploration.&lt;/strong&gt; We have space to experiment with new ideas and proposals without introducing breaking changes. &lt;code&gt;relude&lt;/code&gt; uses the approach with &lt;code&gt;Extra.*&lt;/code&gt; modules which are not exported by default. The chosen approach makes it quite easy for us to provide new functionality without breaking anything and let the users decide to use it or not.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;In addition to our key design principles, the following list of &lt;strong&gt;anti-goals&lt;/strong&gt; describes what &lt;code&gt;relude&lt;/code&gt; is trying to avoid:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Rewrite &lt;code&gt;base&lt;/code&gt; from the ground up.&lt;/strong&gt; With &lt;code&gt;relude&lt;/code&gt; you don&#39;t need to unlearn what you already knew, you can leverage existing knowledge to achieve higher productivity.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Invent custom abstractions.&lt;/strong&gt; Learning abstractions is hard, so we do our best not to introduce new overwhelming concepts.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Rename common definitions.&lt;/strong&gt; If something is called &lt;code&gt;foo&lt;/code&gt; in &lt;code&gt;base&lt;/code&gt;, it&#39;s also called &lt;code&gt;foo&lt;/code&gt; in &lt;code&gt;relude&lt;/code&gt;. So, &lt;code&gt;relude&lt;/code&gt; doesn&#39;t rename any existing abstractions, but it may introduce a few new ones, if their benefits outweigh learning curve.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This README contains an introduction to &lt;code&gt;relude&lt;/code&gt; and a tutorial on how to use it.&lt;/p&gt; &#xA;&lt;p&gt;For a general introduction to alternative preludes, check the excellent blog post by &lt;a href=&#34;https://typeclasses.com/&#34;&gt;Type Classes&lt;/a&gt; that highlights &lt;code&gt;relude&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://typeclasses.com/ghc/no-implicit-prelude&#34;&gt;No implicit Prelude&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For guiding development principles behind &lt;code&gt;relude&lt;/code&gt; and comparison with &lt;code&gt;base&lt;/code&gt;, check out the following talk:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=qwAmiJ5M_zM&#34;&gt;&lt;img src=&#34;https://img.youtube.com/vi/qwAmiJ5M_zM/0.jpg&#34; alt=&#34;Introduction to relude ‚Äî an alternative Haskell prelude&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Structure of this tutorial&lt;/h2&gt; &#xA;&lt;p&gt;This tutorial has several parts:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#when-to-use-an-alternative-prelude&#34;&gt;When to use an alternative prelude?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#get-started&#34;&gt;Get started&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#mixins&#34;&gt;Mixins&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#base-noprelude&#34;&gt;base-noprelude&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#NoImplicitPrelude&#34;&gt;NoImplicitPrelude&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#difference-from-prelude&#34;&gt;Difference from Prelude&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#reexports&#34;&gt;Reexports&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#whats-new&#34;&gt;What&#39;s new?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#migration-guide&#34;&gt;Migration guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#comparison-with-other-alternative-preludes&#34;&gt;Comparison with other alternative preludes&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#relude-vs-protolude&#34;&gt;Relude vs Protolude&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#for-developers&#34;&gt;For developers&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This is neither a tutorial on &lt;em&gt;Haskell Standard Library&lt;/em&gt; nor a tutorial on each function contained in &lt;code&gt;relude&lt;/code&gt;. For latter see the detailed documentation of every data type, type class and function together with examples and usages in the &lt;a href=&#34;http://hackage.haskell.org/package/relude&#34;&gt;&lt;em&gt;Haddock documentation for &lt;code&gt;relude&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;When to use an alternative prelude?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#structure-of-this-tutorial&#34;&gt;[Back to the Table of Contents] ‚Üë&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The module with the name &lt;code&gt;Prelude&lt;/code&gt; is a module imported by default in every Haskell source file of your project. If you want to use some data types or functions which are not exposed by &lt;code&gt;Prelude&lt;/code&gt;, you need to import them, adding necessary libraries to your project dependencies. Unlike ordinary libraries, alternative preludes provide a different set of available by default functions and data types by replacing the &lt;code&gt;Prelude&lt;/code&gt; module.&lt;/p&gt; &#xA;&lt;p&gt;Replacing default &lt;code&gt;Prelude&lt;/code&gt; from &lt;code&gt;base&lt;/code&gt; has the following &lt;em&gt;disadvantages&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Increased entry threshold: you need to &lt;em&gt;learn&lt;/em&gt; a different standard library. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;relude&lt;/code&gt; tries to lower this threshold as much as possible: it comes with the excellent documentation, no custom abstractions, and behavior is changed only for a small subset of functions.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Extra dependencies: adding more libraries to dependencies increases build times and maintenance burden. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;relude&lt;/code&gt; depends only on the boot libraries (almost) which results in small build time, follows &lt;a href=&#34;https://pvp.haskell.org/&#34;&gt;PVP&lt;/a&gt; and cares about backwards compatibility.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;However, using an alternative prelude, specifically &lt;code&gt;relude&lt;/code&gt;, has the following &lt;strong&gt;advantages&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Increased code safety: no partial functions, no space-leak functions.&lt;/li&gt; &#xA; &lt;li&gt;Increased productivity: no need to import common functions and data types, more common idioms are provided.&lt;/li&gt; &#xA; &lt;li&gt;Increased performance: some functions in &lt;code&gt;relude&lt;/code&gt; are faster than in the default &lt;code&gt;Prelude&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Taking into consideration all the above points, we put together our recommendations when to use &lt;code&gt;relude&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;When you develop an application (e.g. CLI tool, web-app). In that case, greater productivity is more important than a low number of dependencies.&lt;/li&gt; &#xA; &lt;li&gt;When writing a big framework. Some of them can be bigger than applications.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;And when you may want to stay with the default standard:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;When you write a small library that is supposed to be used by other people in their projects.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Get started&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#structure-of-this-tutorial&#34;&gt;[Back to the Table of Contents] ‚Üë&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you want to start using &lt;code&gt;relude&lt;/code&gt; in your project, you can set the library up for you by one of the following ways.&lt;/p&gt; &#xA;&lt;h3&gt;Mixins&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#structure-of-this-tutorial&#34;&gt;[Back to the Table of Contents] ‚Üë&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is the recommended way to use a custom prelude.&lt;/p&gt; &#xA;&lt;p&gt;You can use the Cabal feature &lt;code&gt;mixins&lt;/code&gt; to replace the default &lt;code&gt;Prelude&lt;/code&gt; with &lt;code&gt;Relude&lt;/code&gt; without the need to add extra dependencies or to import &lt;code&gt;Relude&lt;/code&gt; manually in each module. For this you need to add the following lines into your &lt;code&gt;.cabal&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;  mixins:   base hiding (Prelude)&#xA;          , relude (Relude as Prelude)&#xA;          , relude&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; this requires Cabal version to be at least &lt;code&gt;2.2&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The above syntax does the following:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Makes all modules of &lt;code&gt;base&lt;/code&gt; available except &lt;code&gt;Prelude&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Renames the &lt;code&gt;Relude&lt;/code&gt; module in &lt;code&gt;relude&lt;/code&gt; to &lt;code&gt;Prelude&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Additionally allows importing all other modules from &lt;code&gt;relude&lt;/code&gt; (extra modules and reexports from other libraries).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;See the following complete example of how your &lt;code&gt;.cabal&lt;/code&gt; file may look like after the set up:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cabal&#34;&gt;cabal-version:       2.2&#xA;name:                prelude-example&#xA;version:             0.0.0.0&#xA;&#xA;library&#xA;  exposed-modules:     Example&#xA;  build-depends:       base &amp;gt;= 4.14 &amp;amp;&amp;amp; &amp;lt; 4.17&#xA;                     , relude ^&amp;gt;= 1.1.0.0&#xA;&#xA;  mixins:              base hiding (Prelude)&#xA;                     , relude (Relude as Prelude)&#xA;                     , relude&#xA;&#xA;  default-language:    Haskell2010&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; if you use &lt;a href=&#34;https://github.com/kowainik/summoner&#34;&gt;&lt;code&gt;summoner&lt;/code&gt;&lt;/a&gt; to generate a Haskell project, the tool automatically creates the &lt;code&gt;mixins&lt;/code&gt; field when you specify a custom prelude.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If you want to restrict allowed modules in &lt;code&gt;relude&lt;/code&gt; to a specific list (e.g. use only &lt;code&gt;Relude.Extra.Enum&lt;/code&gt; or &lt;code&gt;Relude.Unsafe&lt;/code&gt; or &lt;code&gt;Data.Text&lt;/code&gt; from &lt;code&gt;text&lt;/code&gt;), you can alternatively list them explicitly under the first &lt;code&gt;mixins&lt;/code&gt; entry field as well, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cabal&#34;&gt;  mixins: base hiding (Prelude)&#xA;        , relude (Relude as Prelude&#xA;                 , Relude.Extra.Enum&#xA;                 , Relude.Unsafe&#xA;                 , Data.Text&#xA;                 )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to bring only all &lt;code&gt;Extra.*&lt;/code&gt; modules into scope, you can add a single &lt;code&gt;Relude.Extra&lt;/code&gt; module to &lt;code&gt;mixins&lt;/code&gt;, and after that you can import all extra functions and data types from &lt;code&gt;Relude.Extra&lt;/code&gt;. This is the easiest way to bring all functions and types from &lt;code&gt;relude&lt;/code&gt; to your project (excluding &lt;code&gt;Relude.Unsafe&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cabal&#34;&gt;  mixins: base hiding (Prelude)&#xA;        , relude (Relude as Prelude&#xA;                 , Relude.Extra&#xA;                 )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; due to the existing &lt;a href=&#34;https://github.com/commercialhaskell/stack/issues/5077&#34;&gt;stack issue&lt;/a&gt;, &lt;code&gt;mixins&lt;/code&gt; technique doesn&#39;t work with the &lt;code&gt;stack repl&lt;/code&gt; at the moment. Please, consider this before using this method of turning &lt;code&gt;relude&lt;/code&gt; on in the project.&lt;/p&gt; &#xA; &lt;p&gt;If having &lt;code&gt;stack repl&lt;/code&gt; crucial for your workflow, see the following options of how to use Relude in your project.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;base-noprelude&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#structure-of-this-tutorial&#34;&gt;[Back to the Table of Contents] ‚Üë&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can use the &lt;code&gt;base-noprelude&lt;/code&gt; trick to enable alternative preludes. This approach can be helpful if you want to have your own &lt;code&gt;Prelude&lt;/code&gt; module with some custom functions, not provided by &lt;code&gt;relude&lt;/code&gt;. To use the trick, perform the following steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Replace the &lt;code&gt;base&lt;/code&gt; dependency with the corresponding version of &lt;code&gt;base-noprelude&lt;/code&gt; in your &lt;code&gt;.cabal&lt;/code&gt; file.&lt;/li&gt; &#xA; &lt;li&gt;Add the &lt;code&gt;relude&lt;/code&gt; dependency to your &lt;code&gt;.cabal&lt;/code&gt; file.&lt;/li&gt; &#xA; &lt;li&gt;Create the file called &lt;code&gt;Prelude.hs&lt;/code&gt; in your source directory with the following content: &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module Prelude&#xA;    ( module Relude&#xA;    ) where&#xA;&#xA;import Relude&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Add this module to &lt;code&gt;exposed-modules&lt;/code&gt; in your &lt;code&gt;.cabal&lt;/code&gt; file: &lt;pre&gt;&lt;code class=&#34;language-cabal&#34;&gt;exposed-modules: Prelude&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Optionally modify your &lt;code&gt;Prelude&lt;/code&gt; module to include more or fewer functions. Potentially, you can hide something from the &lt;code&gt;Relude&lt;/code&gt; module. Or maybe you want to add something from &lt;code&gt;Relude.Extra.*&lt;/code&gt; modules! Customize the module for your needs.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This is a very convenient way to add a custom prelude to your project because you don&#39;t need to import module manually inside each file and enable the &lt;code&gt;NoImplicitPrelude&lt;/code&gt; extension.&lt;/p&gt; &#xA;&lt;h3&gt;NoImplicitPrelude&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#structure-of-this-tutorial&#34;&gt;[Back to the Table of Contents] ‚Üë&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;For this option, you need to disable the default &lt;code&gt;Prelude&lt;/code&gt; module first. To disable the built-in prelude on module basis, you can add the following pragma at the top of your file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE NoImplicitPrelude #-}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;if you want to disable the default &lt;code&gt;Prelude&lt;/code&gt; for every module by default, you can specify this directly in your project &lt;code&gt;.cabal&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;default-extensions: NoImplicitPrelude&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you need to add &lt;code&gt;relude&lt;/code&gt; as a dependency of your project.&lt;/p&gt; &#xA;&lt;p&gt;After doing all above, you can now use &lt;code&gt;Relude&lt;/code&gt; in any module of your project by adding a single import:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Relude&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Difference from Prelude&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#structure-of-this-tutorial&#34;&gt;[Back to the Table of Contents] ‚Üë&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Main differences from &lt;code&gt;Prelude&lt;/code&gt; can be grouped into the following categories:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Changed behavior of common functions &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;head&lt;/code&gt;, &lt;code&gt;tail&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;init&lt;/code&gt; work with &lt;code&gt;NonEmpty a&lt;/code&gt; instead of &lt;code&gt;[a]&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;lines&lt;/code&gt;, &lt;code&gt;unlines&lt;/code&gt;, &lt;code&gt;words&lt;/code&gt;, &lt;code&gt;unwords&lt;/code&gt; work with &lt;code&gt;Text&lt;/code&gt; instead of &lt;code&gt;String&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;show&lt;/code&gt; is polymorphic over the return type.&lt;/li&gt; &#xA;   &lt;li&gt;Functions &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;product&lt;/code&gt; are strict now, which makes them more efficient.&lt;/li&gt; &#xA;   &lt;li&gt;You can&#39;t call &lt;code&gt;elem&lt;/code&gt; and &lt;code&gt;notElem&lt;/code&gt; functions over &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;HashSet&lt;/code&gt;. These functions are forbidden for these two types due to performance reasons.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;error&lt;/code&gt; takes &lt;code&gt;Text&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;undefined&lt;/code&gt; triggers a compiler warning, because you probably don&#39;t want to leave &lt;code&gt;undefined&lt;/code&gt; in your code. Either use &lt;code&gt;throwIO&lt;/code&gt;, &lt;code&gt;Except&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;bug&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Not reexported &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;read&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;lookup&lt;/code&gt; for lists&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;log&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Completely new functions are brought into scope &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#whats-new&#34;&gt;What&#39;s new?&lt;/a&gt; section for a detailed overview.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;New reexports &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#reexports&#34;&gt;Reexports&lt;/a&gt; section for a detailed overview.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Reexports&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#structure-of-this-tutorial&#34;&gt;[Back to the Table of Contents] ‚Üë&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;relude&lt;/code&gt; reexports some parts of the following libraries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://hackage.haskell.org/package/base&#34;&gt;&lt;code&gt;base&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://hackage.haskell.org/package/bytestring&#34;&gt;&lt;code&gt;bytestring&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://hackage.haskell.org/package/containers&#34;&gt;&lt;code&gt;containers&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://hackage.haskell.org/package/deepseq&#34;&gt;&lt;code&gt;deepseq&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://hackage.haskell.org/package/ghc-prim&#34;&gt;&lt;code&gt;ghc-prim&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://hackage.haskell.org/package/hashable&#34;&gt;&lt;code&gt;hashable&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://hackage.haskell.org/package/mtl&#34;&gt;&lt;code&gt;mtl&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://hackage.haskell.org/package/stm&#34;&gt;&lt;code&gt;stm&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://hackage.haskell.org/package/text&#34;&gt;&lt;code&gt;text&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://hackage.haskell.org/package/transformers&#34;&gt;&lt;code&gt;transformers&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://hackage.haskell.org/package/unordered-containers&#34;&gt;&lt;code&gt;unordered-containers&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to clean up your imports after switching to &lt;code&gt;relude&lt;/code&gt;, you can use the &lt;code&gt;relude&lt;/code&gt;-specific &lt;a href=&#34;https://github.com/kowainik/relude/raw/main/.hlint.yaml&#34;&gt;&lt;code&gt;.hlint.yaml&lt;/code&gt;&lt;/a&gt; configuration for this task. With this config, &lt;code&gt;HLint&lt;/code&gt; will produce warnings and hints on how to have more benefits from &lt;code&gt;relude&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;base&lt;/h3&gt; &#xA;&lt;p&gt;Multiple sorting functions are available for different use-cases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;sortBy :: (a -&amp;gt; a -&amp;gt; Ordering) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;: sorts a list using given custom comparator.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sortWith :: Ord b =&amp;gt; (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;: sorts a list based on some property of its elements.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sortOn :: Ord b =&amp;gt; (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;: similar to &lt;code&gt;sortWith&lt;/code&gt;, but more time-efficient if function is calculated slowly (though less space-efficient). So you should write &lt;code&gt;sortOn length&lt;/code&gt; (would sort elements by length) but &lt;code&gt;sortWith fst&lt;/code&gt; (would sort list of pairs by first element).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;readMaybe&lt;/code&gt; and &lt;code&gt;readEither&lt;/code&gt; are similar to &lt;code&gt;read&lt;/code&gt; but unlike it, they are total and return either &lt;code&gt;Maybe&lt;/code&gt; or &lt;code&gt;Either&lt;/code&gt; with a parse error.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;(&amp;amp;)&lt;/code&gt; is the reverse application. The following three expressions are semantically equivalent:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;g (f x)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;g $ f $ x&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;x &amp;amp; f &amp;amp; g&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some generally useful modules from &lt;code&gt;base&lt;/code&gt; package are exported, e.g. &lt;code&gt;Control.Applicative&lt;/code&gt;, &lt;code&gt;Data.Traversable&lt;/code&gt;, &lt;code&gt;Data.Monoid&lt;/code&gt;, &lt;code&gt;Data.List&lt;/code&gt;, and many more.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;liftIO&lt;/code&gt; and &lt;code&gt;MonadIO&lt;/code&gt; are exported by default. A lot of &lt;code&gt;IO&lt;/code&gt; functions are generalized to &lt;code&gt;MonadIO&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://hackage.haskell.org/package/base/docs/Data-Bifunctor.html&#34;&gt;&lt;code&gt;Bifunctor&lt;/code&gt;&lt;/a&gt; type class with useful instances is exported.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; functions apply a function to the first and second part of a &lt;code&gt;Bifunctor&lt;/code&gt; (&lt;code&gt;fst&lt;/code&gt; and &lt;code&gt;snd&lt;/code&gt; for tuples, &lt;code&gt;Left&lt;/code&gt; and &lt;code&gt;Right&lt;/code&gt; for &lt;code&gt;Either&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bimap&lt;/code&gt; takes two functions and applies them to the first and second parts respectively.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;traceM&lt;/code&gt;, &lt;code&gt;traceShow&lt;/code&gt;, etc. are available by default. However, GHC will warn you if you accidentally leave them in code. Same goes for the &lt;code&gt;undefined&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;We also have &lt;code&gt;data Undefined = Undefined&lt;/code&gt; (which also comes with the warning).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;relude&lt;/code&gt; reexports &lt;code&gt;Exception&lt;/code&gt; type from the &lt;code&gt;base&lt;/code&gt; package and introduces the &lt;code&gt;bug&lt;/code&gt; function as an alternative to &lt;code&gt;error&lt;/code&gt;. There is also a very convenient &lt;code&gt;Exc&lt;/code&gt; pattern-synonym to handle exceptions of different types.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://hackage.haskell.org/package/relude/docs/Relude-Exception.html&#34;&gt;&lt;code&gt;Relude.Exception&lt;/code&gt;&lt;/a&gt; module for details on exceptions.&lt;/p&gt; &#xA;&lt;h3&gt;containers &amp;amp; unordered-containers&lt;/h3&gt; &#xA;&lt;p&gt;The following types from these two packages are exported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Maps: strict versions of &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;IntMap&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Sets: &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;HashSet&lt;/code&gt;, &lt;code&gt;IntSet&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Sequences: &lt;code&gt;Seq&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;text &amp;amp; bytestring&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;relude&lt;/code&gt; exports &lt;code&gt;Text&lt;/code&gt; and &lt;code&gt;ByteString&lt;/code&gt; (as well as their lazy versions ‚Äî &lt;code&gt;LText&lt;/code&gt; and &lt;code&gt;LByteString&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Also, some functions now work with &lt;code&gt;Text&lt;/code&gt; instead of &lt;code&gt;String&lt;/code&gt; ‚Äì &lt;code&gt;words&lt;/code&gt;, &lt;code&gt;lines&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;p&gt;In addition, &lt;code&gt;relude&lt;/code&gt; provides specialised versions of the &lt;code&gt;IO&lt;/code&gt; functions to work with &lt;code&gt;Text&lt;/code&gt; and &lt;code&gt;ByteString&lt;/code&gt; ‚Äî &lt;code&gt;readFileText&lt;/code&gt;, &lt;code&gt;writeFileBS&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;show&lt;/code&gt; is polymorphic and can produce strict or lazy &lt;code&gt;Text&lt;/code&gt; or &lt;code&gt;ByteString&lt;/code&gt; as well as &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Also, &lt;code&gt;toText|toLText|toString&lt;/code&gt; can convert &lt;code&gt;Text|LText|String&lt;/code&gt; types to &lt;code&gt;Text|LText|String&lt;/code&gt;. If you want to convert to and from &lt;code&gt;ByteString&lt;/code&gt; use &lt;code&gt;encodeUtf8|decodeUtf8&lt;/code&gt; functions.&lt;/p&gt; &#xA;&lt;h3&gt;transformers &amp;amp; mtl&lt;/h3&gt; &#xA;&lt;p&gt;The following parts of these two libraries are exported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Transformers: &lt;code&gt;State[T]&lt;/code&gt;, &lt;code&gt;Reader[T]&lt;/code&gt;, &lt;code&gt;ExceptT&lt;/code&gt;, &lt;code&gt;MaybeT&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Classes: &lt;code&gt;MonadReader&lt;/code&gt;, &lt;code&gt;MonadState&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Deepseq&lt;/h3&gt; &#xA;&lt;p&gt;All the main parts of the &lt;code&gt;deepseq&lt;/code&gt; library are exported. For instance, if you want to force the deep evaluation of some value (in &lt;code&gt;IO&lt;/code&gt;), you can write &lt;code&gt;evaluateNF a&lt;/code&gt;. Additionally, the WHNF evaluation is possible with provided &lt;code&gt;evaluateWHNF&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s new?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#structure-of-this-tutorial&#34;&gt;[Back to the Table of Contents] ‚Üë&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Finally, let&#39;s move to part describing the new cool features we bring with &lt;code&gt;relude&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Available by default&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Safe analogue for the list functions:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;head :: NonEmpty a -&amp;gt; a    -- the first element of the list&#xA;tail :: NonEmpty a -&amp;gt; [a]  -- the list without the first element&#xA;last :: NonEmpty a -&amp;gt; a    -- the last element of the list&#xA;init :: NonEmpty a -&amp;gt; [a]  -- the list without the last element&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You can also still work with lists for these functions. Using &lt;code&gt;viaNonEmpty&lt;/code&gt; function you will get &lt;code&gt;Maybe a&lt;/code&gt; from the list:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- viaNonEmpty head :: [a] -&amp;gt; Maybe a&#xA;ghci&amp;gt; viaNonEmpty head [1,2,3]&#xA;Just 1&#xA;ghci&amp;gt; viaNonEmpty head []&#xA;Nothing&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;uncons&lt;/code&gt; splits a list at the first element.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ordNub&lt;/code&gt; and &lt;code&gt;sortNub&lt;/code&gt; are &lt;em&gt;O(n log n)&lt;/em&gt; versions of &lt;code&gt;nub&lt;/code&gt; (which is quadratic), also, &lt;code&gt;hashNub&lt;/code&gt; and &lt;code&gt;unstableNub&lt;/code&gt; are almost &lt;em&gt;O(n)&lt;/em&gt; versions of &lt;code&gt;nub&lt;/code&gt;, and &lt;code&gt;intNub&lt;/code&gt; for fast &lt;code&gt;Int&lt;/code&gt;s nub.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;whenM&lt;/code&gt;, &lt;code&gt;unlessM&lt;/code&gt;, &lt;code&gt;ifM&lt;/code&gt;, &lt;code&gt;guardM&lt;/code&gt; ‚Äî monadic guard combinators, that work with any &lt;code&gt;Monad&lt;/code&gt;, e.g. &lt;code&gt;whenM (doesFileExist &#34;foo&#34;)&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;General fold functions:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;foldMapA :: (Monoid b, Applicative m, Foldable f) =&amp;gt; (a -&amp;gt; m b) -&amp;gt; f a -&amp;gt; m b&#xA;foldMapM :: (Monoid b, Monad m, Foldable f) =&amp;gt; (a -&amp;gt; m b) -&amp;gt; f a -&amp;gt; m b&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;when(Just|Nothing|Left|Right|NotEmpty)[M][_]&lt;/code&gt; functions that let you conditionally execute something.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Before:&lt;/strong&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;case mbX of&#xA;    Nothing -&amp;gt; return ()&#xA;    Just x  -&amp;gt; f x&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;After:&lt;/strong&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;whenJust mbX $ \x -&amp;gt;&#xA;    f x&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;for_&lt;/code&gt; and &lt;code&gt;forM_&lt;/code&gt; for loops.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;for_ files $ \file -&amp;gt; do&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;andM&lt;/code&gt;, &lt;code&gt;allM&lt;/code&gt;, &lt;code&gt;anyM&lt;/code&gt;, &lt;code&gt;orM&lt;/code&gt; are monadic versions of the corresponding functions from &lt;code&gt;base&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Conversions between &lt;code&gt;Either&lt;/code&gt; and &lt;code&gt;Maybe&lt;/code&gt;, e.g. &lt;code&gt;rightToMaybe&lt;/code&gt; and &lt;code&gt;maybeToLeft&lt;/code&gt; with clear semantics.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;using(Reader|State)[T]&lt;/code&gt; functions as aliases for &lt;code&gt;flip run(Reader|State)[T]&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://hackage.haskell.org/package/relude/docs/Relude-Container-One.html&#34;&gt;&lt;code&gt;One&lt;/code&gt; type class&lt;/a&gt; for creating singleton containers (even monomorphic ones like &lt;code&gt;Text&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;evaluateWHNF&lt;/code&gt; and &lt;code&gt;evaluateNF&lt;/code&gt; functions as clearer and lifted aliases for &lt;code&gt;evaluate&lt;/code&gt; and &lt;code&gt;evaluate . force&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;MonadFail&lt;/code&gt; instance for &lt;code&gt;Either&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Extra bonuses&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;relude&lt;/code&gt; has a number of &lt;code&gt;Extra&lt;/code&gt; modules that are not exposed by default (they are not a part of the &lt;code&gt;Relude&lt;/code&gt; module). You need to import such modules separately.&lt;/p&gt; &#xA;&lt;p&gt;These extra modules include the following functionality:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Convenient functions to work with &lt;code&gt;(Bounded a, Enum a)&lt;/code&gt; types:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;universe :: (Bounded a, Enum a) =&amp;gt; [a]&lt;/code&gt;: get all values of the type.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; universe @Bool&#xA;[True,False]&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;inverseMap :: (Bounded a, Enum a, Ord k) =&amp;gt; (a -&amp;gt; k) -&amp;gt; k -&amp;gt; Maybe a&lt;/code&gt;: convert functions like &lt;code&gt;show&lt;/code&gt; to parsers:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;readMyEnums :: Text -&amp;gt; Maybe MyEnum&#xA;readMyEnums = inverseMap myShow&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Nice helpers to deal with &lt;code&gt;newtype&lt;/code&gt;s in a more pleasant way:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; newtype Foo = Foo Bool deriving Show&#xA;ghci&amp;gt; under not (Foo True)&#xA;Foo False&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Functions to operate with &lt;code&gt;CallStack&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; foo :: HasCallStack =&amp;gt; String; foo = ownName&#xA;ghci&amp;gt; foo&#xA;&#34;foo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Foldable1&lt;/code&gt; typeclass that contains generalized interface for folding non-empty structures like &lt;code&gt;NonEmpty&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/kowainik/relude/raw/main/src/Relude/Extra/Map.hs&#34;&gt;&lt;code&gt;StaticMap&lt;/code&gt; and &lt;code&gt;DynamicMap&lt;/code&gt; type classes&lt;/a&gt; as a general interface for &lt;code&gt;Map&lt;/code&gt;-like data structures.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;And much more!&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Explore &lt;code&gt;Extra&lt;/code&gt; modules: &lt;a href=&#34;http://hackage.haskell.org/package/relude/docs/Relude-Extra.html&#34;&gt;&lt;code&gt;Relude.Extra&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Migration guide&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#structure-of-this-tutorial&#34;&gt;[Back to the Table of Contents] ‚Üë&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This section of the guide helps to migrate your project from &lt;code&gt;base&lt;/code&gt; to the &lt;code&gt;relude&lt;/code&gt; library.&lt;/p&gt; &#xA;&lt;p&gt;In order to replace the default &lt;code&gt;Prelude&lt;/code&gt; with &lt;code&gt;relude&lt;/code&gt; you should start with instructions provided in the &lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#get-started&#34;&gt;&lt;em&gt;Get Started&lt;/em&gt;&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h3&gt;Code changes&lt;/h3&gt; &#xA;&lt;p&gt;This section describes what you need to change to make your code compile with &lt;code&gt;relude&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Enable &lt;code&gt;-XOverloadedStrings&lt;/code&gt; extension by default for your project.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Since &lt;code&gt;head&lt;/code&gt;, &lt;code&gt;tail&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;init&lt;/code&gt; work for &lt;code&gt;NonEmpty&lt;/code&gt; you should refactor your code in one of the described below ways:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Change &lt;code&gt;[a]&lt;/code&gt; to &lt;code&gt;NonEmpty a&lt;/code&gt; where it makes sense.&lt;/li&gt; &#xA;   &lt;li&gt;Use functions which return &lt;code&gt;Maybe&lt;/code&gt;. There is the &lt;code&gt;viaNonEmpty&lt;/code&gt; function for this. And you can use it like &lt;code&gt;viaNonEmpty last l&lt;/code&gt;. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;tail&lt;/code&gt; is &lt;code&gt;drop 1&lt;/code&gt;. It&#39;s almost never a good idea to use &lt;code&gt;tail&lt;/code&gt; from &lt;code&gt;Prelude&lt;/code&gt;.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Add &lt;code&gt;import qualified Relude.Unsafe as Unsafe&lt;/code&gt; and replace the function with its qualified usage: &lt;code&gt;Unsafe.head&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you use &lt;code&gt;fromJust&lt;/code&gt; or &lt;code&gt;!!&lt;/code&gt; you should import them from &lt;code&gt;import qualified Relude.Unsafe as Unsafe&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you use &lt;code&gt;foldr&lt;/code&gt; or &lt;code&gt;forM_&lt;/code&gt; or similar for something like &lt;code&gt;Maybe a&lt;/code&gt; or &lt;code&gt;Either a b&lt;/code&gt; it is recommended to replace usages of such functions with the monomorhpic alternatives:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt;&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;(?:) :: Maybe a -&amp;gt; a -&amp;gt; a&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;fromMaybe :: a -&amp;gt; Maybe a -&amp;gt; a&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;maybeToList :: Maybe a -&amp;gt; [a]&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;maybeToMonoid :: Monoid m =&amp;gt; Maybe m -&amp;gt; m&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;maybe :: b -&amp;gt; (a -&amp;gt; b) -&amp;gt; Maybe a -&amp;gt; b&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;whenJust :: Applicative f =&amp;gt; Maybe a -&amp;gt; (a -&amp;gt; f ()) -&amp;gt; f ()&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;whenJustM :: Monad m =&amp;gt; m (Maybe a) -&amp;gt; (a -&amp;gt; m ()) -&amp;gt; m ()&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;Either&lt;/code&gt;&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;fromLeft :: a -&amp;gt; Either a b -&amp;gt; a&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;fromRight :: b -&amp;gt; Either a b -&amp;gt; b&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;either :: (a -&amp;gt; c) -&amp;gt; (b -&amp;gt; c) -&amp;gt; Either a b -&amp;gt; c&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;whenRight_ :: Applicative f =&amp;gt; Either l r -&amp;gt; (r -&amp;gt; f ()) -&amp;gt; f ()&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;whenRightM_ :: Monad m =&amp;gt; m (Either l r) -&amp;gt; (r -&amp;gt; m ()) -&amp;gt; m ()&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Replace the &lt;code&gt;String&lt;/code&gt; type with more efficient and suitable ones (e.g. &lt;code&gt;Text&lt;/code&gt;):&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Replace &lt;code&gt;(++)&lt;/code&gt; with &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; for &lt;code&gt;String&lt;/code&gt;-like types.&lt;/li&gt; &#xA;   &lt;li&gt;Use &lt;code&gt;toText/toLText/toString&lt;/code&gt; functions to convert to &lt;code&gt;Text/LazyText/String&lt;/code&gt; types.&lt;/li&gt; &#xA;   &lt;li&gt;Use &lt;code&gt;encodeUtf8/decodeUtf8&lt;/code&gt; to convert to/from &lt;code&gt;ByteString&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Use &lt;code&gt;(putStr[Ln]|readFile|writeFile|appendFile)[Text|LText|BS|LBS]&lt;/code&gt; functions.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Since &lt;code&gt;show&lt;/code&gt; doesn&#39;t come from &lt;code&gt;Show&lt;/code&gt; anymore, you need to import the &lt;code&gt;Text.Show&lt;/code&gt; module if you want to implement &lt;code&gt;Show&lt;/code&gt; instance manually. This can be done in the following way:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import qualified Text.Show&#xA;&#xA;data MyType = ...&#xA;&#xA;instance Show MyType where&#xA;    show :: MyType -&amp;gt; String&#xA;    show = ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;7&#34;&gt; &#xA; &lt;li&gt;Run &lt;code&gt;hlint&lt;/code&gt; using &lt;code&gt;.hlint.yaml&lt;/code&gt; file from &lt;code&gt;relude&lt;/code&gt; package to cleanup code and imports.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Running HLint on CI&lt;/h3&gt; &#xA;&lt;p&gt;Instead of storing a &lt;code&gt;relude&lt;/code&gt;-specific &lt;code&gt;.hlint.yaml&lt;/code&gt; file inside your repository, you can run HLint with this file automatically on any CI service such as &lt;a href=&#34;https://travis-ci.org/&#34;&gt;Travis CI&lt;/a&gt; or &lt;a href=&#34;https://circleci.com/&#34;&gt;Circle CI&lt;/a&gt;. For this you need to:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Find the commit hash of the &lt;code&gt;relude&lt;/code&gt; version you are using (can be found in &lt;a href=&#34;https://github.com/kowainik/relude/releases&#34;&gt;releases&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Run the command that downloads &lt;code&gt;.hlint.yaml&lt;/code&gt; for that version.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;hlint&lt;/code&gt; using this file.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For the latest &lt;code&gt;relude&lt;/code&gt; version, this can be achieved by executing the following two commands on your CI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;curl https://raw.githubusercontent.com/kowainik/relude/v1.1.0.0/.hlint.yaml -o .hlint-relude.yaml&#xA;curl -sSL https://raw.github.com/ndmitchell/neil/master/misc/travis.sh | sh -s -- hlint -h .hlint-relude.yaml .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See an example of this feature described in the following blog post about Travis CI settings:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kodimensional.dev/posts/2019-02-25-haskell-travis#customization-hlint&#34;&gt;Kodimensional: Dead simple Haskell Travis settings for cabal and stack&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Comparison with other alternative preludes&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#structure-of-this-tutorial&#34;&gt;[Back to the Table of Contents] ‚Üë&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are quite a few libraries that can be used as alternative preludes in Haskell, let&#39;s compare Relude with some of them.&lt;/p&gt; &#xA;&lt;h3&gt;Relude vs Protolude&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#structure-of-this-tutorial&#34;&gt;[Back to the Table of Contents] ‚Üë&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sdiehl/protolude&#34;&gt;Protolude&lt;/a&gt; is one of the most popular alternative preludes. It&#39;s also relatively small, but:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;relude&lt;/code&gt; has custom HLint rules specific to it: you can use them to remove redundant imports or find hints on how to use functions from &lt;code&gt;relude&lt;/code&gt;. Moreover, the HLint rules are generated using Dhall and there is &lt;a href=&#34;https://kowainik.github.io/posts/2018-09-09-dhall-to-hlint&#34;&gt;a blog post about this technique&lt;/a&gt;. This allows to maintain HLint rules with less effort, even though it is already not an easy task.&lt;/li&gt; &#xA; &lt;li&gt;One significant difference: &lt;code&gt;head&lt;/code&gt; in &lt;code&gt;protolude&lt;/code&gt; returns &lt;code&gt;Maybe a&lt;/code&gt; while in &lt;code&gt;relude&lt;/code&gt; it works with &lt;code&gt;NonEmpty&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;relude&lt;/code&gt; uses type-level features to provide better error messages on the difference from &lt;code&gt;Prelude&lt;/code&gt;, and also to forbid &lt;code&gt;elem&lt;/code&gt; and &lt;code&gt;notElem&lt;/code&gt; functions for &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;HashSet&lt;/code&gt; (because &lt;code&gt;elem&lt;/code&gt; from &lt;code&gt;Foldable&lt;/code&gt; runs in &lt;em&gt;O(n)&lt;/em&gt; time and you can accidentally use &lt;code&gt;elem&lt;/code&gt; from &lt;code&gt;Foldable&lt;/code&gt; but with &lt;code&gt;relude&lt;/code&gt; you can&#39;t).&lt;/li&gt; &#xA; &lt;li&gt;Protolude supports older GHC versions (from GHC 7.6.1) while &lt;code&gt;relude&lt;/code&gt; only supports from GHC 8.2.2. So if you aim ancient GHC versions, &lt;code&gt;protolude&lt;/code&gt; might be a better choice. But because of that it contains a lot of CPP, code is scary in some places as a consequence and it is more difficult to add, remove or change things there.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;relude&lt;/code&gt; has much better documentation: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;http://hackage.haskell.org/package/relude/docs/Relude.html&#34;&gt;High-level overview of internal module structure&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;100% Haddock coverage&lt;/li&gt; &#xA;   &lt;li&gt;Every function has usage examples and all examples are tested with &lt;code&gt;doctest&lt;/code&gt; (which also sometimes hard to do due to the multiple GHC versions support, but we try really hard)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#structure-of-this-tutorial&#34;&gt;Tutorial + migration guide&lt;/a&gt; from &lt;code&gt;Prelude&lt;/code&gt; and just general description of the whole package and libraries it depends on.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;relude&lt;/code&gt; has fewer dependencies and is slightly lighter because of that but still is very powerful and useful.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;relude&lt;/code&gt; is opt-in oriented and has a notion of &lt;code&gt;Extra.*&lt;/code&gt; modules that are not exported by default from the &lt;code&gt;Relude&lt;/code&gt; module. That means that we do not spoil the global namespace but still have a lot of useful features, like polymorphic functions to work with every &lt;code&gt;newtype&lt;/code&gt;, &lt;code&gt;Enum/Bounded&lt;/code&gt;-related useful utilities, functions to take a name of any type as &lt;code&gt;Text&lt;/code&gt; and much more. It is a straightforward process to make them accessible package-wide with the &lt;code&gt;base-noprelude&lt;/code&gt; trick!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;For Developers&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kowainik/relude/main/#structure-of-this-tutorial&#34;&gt;[Back to the Table of Contents] ‚Üë&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Generating .hlint.yaml&lt;/h3&gt; &#xA;&lt;p&gt;Note, that we are using custom &lt;code&gt;hlint&lt;/code&gt; setting which are &lt;code&gt;Relude&lt;/code&gt; specific. To keep it up to date don&#39;t forget to reflect your changes in this file. We are using &lt;code&gt;Dhall&lt;/code&gt; to maintain the configurations (lang version 22.0.0). To use it follow the steps below.&lt;/p&gt; &#xA;&lt;p&gt;First time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cabal v2-install dhall-yaml-1.2.10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To generate &lt;code&gt;hlint&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ dhall-to-yaml-ng &amp;lt;&amp;lt;&amp;lt; &#39;./hlint/hlint.dhall&#39; &amp;gt; .hlint.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check that you have generated valid &lt;code&gt;.hlint.yaml&lt;/code&gt; file without parse errors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ hlint test/Spec.hs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See our blog post where we describe the details of the implementation for this solution:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kowainik.github.io/posts/2018-09-09-dhall-to-hlint&#34;&gt;Dhall To HLint&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Producing dependency graph&lt;/h3&gt; &#xA;&lt;p&gt;Install &lt;code&gt;cabal-plan&lt;/code&gt; first:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cabal v2-install cabal-plan&#xA;$ cabal-plan --version&#xA;cabal-plan 0.6.2.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then draw the graph only for the library dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cabal-plan dot --root lib:relude | dot -Tpng -o relude-dependency-graph.png&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating license headers&lt;/h3&gt; &#xA;&lt;p&gt;Install the &lt;code&gt;headroom&lt;/code&gt; tool and run it from this repository:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cabal v2-install headroom-0.4.3.0&#xA;headroom run&#xA;rg &#34;SPDX-License-Identifier : MPL-2.0&#34; --files-with-matches src/ | xargs sed -i &#39;s/SPDX-License-Identifier : MPL-2.0/SPDX-License-Identifier : MIT/g&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>Roguelazer/sedc</title>
    <updated>2022-06-11T01:49:22Z</updated>
    <id>tag:github.com,2022-06-11:/Roguelazer/sedc</id>
    <link href="https://github.com/Roguelazer/sedc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A compiler for sed&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;sedc - an optimizing sed compiler&lt;/h1&gt; &#xA;&lt;p&gt;I don&#39;t know if you realize this, but &lt;strong&gt;sed&lt;/strong&gt; is capable of much more than just pipelines containing only &lt;code&gt;s///&lt;/code&gt; operations. I suspect that it might be possible to make it Turing-complete (even though it&#39;s just single-pass).&lt;/p&gt; &#xA;&lt;p&gt;I&#39;ve been enjoying using some of its more esoteric features, and one day I realized that the X86 instruction &lt;code&gt;XLAT&lt;/code&gt; is a reasonable simulacrum of the &lt;code&gt;y///&lt;/code&gt; operator. Thus this project was born. I&#39;ve never written a compiler in Haskell before, so I decided to do this project in Haskell rather than my more comfortable SML or Ocaml.&lt;/p&gt; &#xA;&lt;p&gt;Much of the structure of this project is based on my &lt;a href=&#34;https://www.cs.hmc.edu/twiki/bin/view/CS132Spring2009&#34;&gt;Compilers class&lt;/a&gt; with the always-awesome &lt;a href=&#34;http://www.cs.hmc.edu/~stone/&#34;&gt;Professor Stone&lt;/a&gt;. I obviously won&#39;t be taking any code whole-hog from there, especially since it&#39;s in a different language and was sourcing a much more complicated language. But the ideas come from that class.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This work is available under the ISC (OpenBSD) license. The full contents of this license are checked in as &lt;code&gt;license.txt&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Project status&lt;/h2&gt; &#xA;&lt;p&gt;I just started this project, so it hasn&#39;t come very far. The parser is going to be tricky, since regular expressions are pretty complicated in and of itself. After that, there&#39;ll be writing an efficient regexp engine (it&#39;d be cheating to use somebody else&#39;s).&lt;/p&gt; &#xA;&lt;p&gt;Oh, and all of the other steps of the compilation process.&lt;/p&gt; &#xA;&lt;p&gt;Cheers,&lt;/p&gt; &#xA;&lt;p&gt;James Brown &lt;a href=&#34;mailto:roguelazer@roguelazer.com&#34;&gt;roguelazer@roguelazer.com&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>