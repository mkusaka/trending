<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-01T01:32:37Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>resonatehq/durable-promise</title>
    <updated>2023-09-01T01:32:37Z</updated>
    <id>tag:github.com,2023-09-01:/resonatehq/durable-promise</id>
    <link href="https://github.com/resonatehq/durable-promise" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Durable Promise Specification&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Durable Promises&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Keywords&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Promise, Future, Awaitable, Future Value, Write Once Register, Write Only Register, Single Assignment Container, Concurrency, Coordination&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;tl;dr&lt;/strong&gt; This repository is a specification for a Durable Promise API&lt;/p&gt; &#xA;&lt;p&gt;20 years after the launch of Amazon Web Services, building reliable and scalable cloud-based applications is a challenge even for the most seasoned developers. Developing distributed applications is a dissonant mix of idioms, patterns, and technologies, feeling fragmented and inconsistent. Yet developing traditional applications feels coherent and consistent. Developers who craft these applications have access to composable abstractions, functions &amp;amp; promises a.k.a asyncâ€¢await, and enjoy a delightful developer experience.&lt;/p&gt; &#xA;&lt;p&gt;Even the largest traditional systems are built consistently from the smallest building blocks: functions &amp;amp; promises. Functions &amp;amp; promises are the foundational model to express concurrency and coordination. While their interpretations vary across languages and runtimes, the ideas are the same.&lt;/p&gt; &#xA;&lt;h2&gt;Promises&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;strong&gt;promise&lt;/strong&gt;, also called future, awaitable, or deferred is a representation of a future value. A promise is either pending or completed, that is, resolved or rejected: A promise is pending, signaling that the value is not yet available or completed, signaling success or failure.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/resonatehq/durable-promise/main/img/Promise.jpg&#34; alt=&#34;Promise&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A promise is a coordination primitive: In a typical scenario, a downstream function execution creates a promise and awaits its completion. An upstream function execution either resolves or rejects the promise. On completion, the downstream execution resumes with the value of the promise.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/resonatehq/durable-promise/main/img/PromiseAPI.jpg&#34; alt=&#34;Promise API&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Adding Durability&lt;/h2&gt; &#xA;&lt;p&gt;Recently, durable functions a.k.a durable executions have emerged as an abstraction for building distributed systems. Durable functions are functions with strong execution guarantees. Traditional, that is, volatile functions are bound to a single runtime. If the runtime crashes, any volatile function execution ceases to exist. Durable function executions are not bound to a runtime. If the runtime crashes, a durable function execution is simply rescheduled on a different runtime.&lt;/p&gt; &#xA;&lt;p&gt;Durable promises are the counterpart to durable functions. Durable promises have identity and state that is not bound to a single runtime.&amp;nbsp;Based on durable promises you can compose reliable and scalable distributed systems across heterogenous technology stacks.&lt;/p&gt; &#xA;&lt;h2&gt;Application Programming Interface (API)&lt;/h2&gt; &#xA;&lt;p&gt;Logically, the Application Programming Interface (API) is divided in two parts, the Downstream API and the Upstream API.&lt;/p&gt; &#xA;&lt;h2&gt;Downstream API&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Create&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;A downstream component may create a promise&lt;/p&gt; &lt;pre&gt;&lt;code&gt;Create(promise-id, idempotence-key, param, timeout)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Cancel&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;A downstream component can cancel an existing promise&lt;/p&gt; &lt;pre&gt;&lt;code&gt;Cancel(promise-id, idempotence-key, value)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Upstream API&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Resolve&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;An upstream component can resolve an existing promise, signaling success&lt;/p&gt; &lt;pre&gt;&lt;code&gt;Resolve(promise-id, idempotence-key, value)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Reject&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;An upstream component can reject a promise, signalling failure&lt;/p&gt; &lt;pre&gt;&lt;code&gt;Reject(promise-id, idempotence-key, value)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Idempotence&lt;/h1&gt; &#xA;&lt;p&gt;When creating, resolving, or rejecting a Durable Promise, use an idempotency key. An idempotency key is a client generated value which the server uses to recognize a duplicated request.&lt;/p&gt; &#xA;&lt;p&gt;TBD&lt;/p&gt;</summary>
  </entry>
</feed>