<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-03T01:36:20Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>NethermindEth/horus-checker</title>
    <updated>2023-02-03T01:36:20Z</updated>
    <id>tag:github.com,2023-02-03:/NethermindEth/horus-checker</id>
    <link href="https://github.com/NethermindEth/horus-checker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Horus, a formal verification tool for StarkNet smart contracts.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;br&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/horus_logo.png&#34; alt=&#34;&#34; width=&#34;2000&#34;&gt; &#xA; &lt;br&gt; &#xA; &lt;p align=&#34;center&#34;&gt; Formal verification of &lt;a href=&#34;https://starkware.co/starknet/&#34;&gt;StarkNet&lt;/a&gt; smart contracts with language annotations &lt;br&gt; &lt;a href=&#34;https://github.com/NethermindEth/horus-checker/issues&#34;&gt;Report bug&lt;/a&gt; · &lt;a href=&#34;https://github.com/NethermindEth/horus-checker/issues&#34;&gt;Request feature&lt;/a&gt; &lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Horus is a command-line formal verification tool for &lt;a href=&#34;https://starkware.co/starknet/&#34;&gt;StarkNet&lt;/a&gt; contracts.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- **Note.** Horus is currently in alpha, and thus should not be fully trusted yet! -&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Our documentation&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#installation&#34;&gt;&lt;strong&gt;Installation&lt;/strong&gt;&lt;/a&gt; - Get the &lt;code&gt;horus-compile&lt;/code&gt; and &lt;code&gt;horus-check&lt;/code&gt; executables setup for your development environment.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#tutorial-your-first-verified-starknet-contract&#34;&gt;Tutorial: Your first verified StarkNet contract&lt;/a&gt; - Try this if you&#39;re new to Horus or formal verification in general. This will walk you through an example step-by-step.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#faq&#34;&gt;FAQ&lt;/a&gt; - What is Cairo? What is Horus? When should I use Horus? Why should I use Horus? All these answered and more!&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#usage&#34;&gt;Usage&lt;/a&gt; - Exhastive reference information on the CLI options, among other things.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#internals&#34;&gt;Internals&lt;/a&gt; - In which we explain why things are implemented the way they are, and discuss details relevant to the development of Horus. This is prose to aid contributors and onboard new team members.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Horus is supported on Linux and MacOS (including AArch64 Macs)!&lt;/p&gt; &#xA;&lt;p&gt;We also have instructions for &lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#quick-installation-using-docker&#34;&gt;installing with Docker&lt;/a&gt; if you want to run Horus in a container.&lt;/p&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.python.org/downloads/release/python-3913/&#34;&gt;Python 3.9&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.haskellstack.org/en/stable/&#34;&gt;Stack&lt;/a&gt; (Haskell build tool)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://python-poetry.org/&#34;&gt;Poetry&lt;/a&gt; (Python package and dependency manager)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Z3Prover/z3&#34;&gt;Z3&lt;/a&gt; (version 4.10.2)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cvc5.github.io/downloads.html&#34;&gt;CVC5&lt;/a&gt; (version 1.0.3)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Installing Python 3.9&lt;/h3&gt; &#xA;&lt;p&gt;Check your python version:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;python3 --version&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Expected output:&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Python 3.9.13&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you see &lt;code&gt;3.9&lt;/code&gt; as in above (any variant of 3.9 should be okay), &lt;strong&gt;you can skip ahead to &lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#installing-stack&#34;&gt;installing stack&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Otherwise, you may have a different version, or you may not have python installed at all. Follow the instructions below to install the needed version.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download and install &lt;a href=&#34;https://docs.conda.io/en/latest/miniconda.html&#34;&gt;&lt;code&gt;miniconda&lt;/code&gt;&lt;/a&gt; on your system:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh&#34;&gt;Linux 64-bit&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh&#34;&gt;macOS Intel x86 64-bit&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh&#34;&gt;macOS Apple M1 64-bit&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In each case, run the downloaded script/executable, and follow the instructions.&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Create a conda environment with python 3.9:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;conda create -n horus-py39 python=3.9&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above, &lt;code&gt;horus-py39&lt;/code&gt; is just a name we&#39;ve chosen for this environment.&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Activate the created environmment:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;conda activate horus-py39&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Verify that you&#39;re running 3.9:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;python3 --version&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Expected output:&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Python 3.9.13&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Installing the Haskell tool stack&lt;/h3&gt; &#xA;&lt;h6&gt;On Linux:&lt;/h6&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;curl -sSL https://get.haskellstack.org/ | sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;On macOS:&lt;/h6&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;brew install stack&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;These setup instructions assume that you have &lt;a href=&#34;https://brew.sh/&#34;&gt;Homebrew&lt;/a&gt; installed on your Mac.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;Check that the install was successful:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;stack --version&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;sub&gt;Expected output (something like this):&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Version 2.7.5, Git revision ba147e6f59b2da75b1beb98b1888cce97f7032b1 x86_64 hpack-0.34.4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Install poetry&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;pip3 install poetry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Clone repositories&lt;/h3&gt; &#xA;&lt;p&gt;Clone the &lt;code&gt;horus-compile&lt;/code&gt; and &lt;code&gt;horus-checker&lt;/code&gt; repositories to your machine.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;git clone git@github.com:NethermindEth/horus-compile.git&#xA;git clone git@github.com:NethermindEth/horus-checker.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Install SMT solvers&lt;/h3&gt; &#xA;&lt;p&gt;Navigate to the &lt;code&gt;horus-checker/&lt;/code&gt; repository root.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;cd horus-checker/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;On Linux:&lt;/h6&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# Inside the `horus-checker/` repository root.&#xA;sh ./scripts/ci/install-z3-linux-amd64.sh&#xA;sh ./scripts/ci/install-cvc5-linux.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;On macOS:&lt;/h6&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# Inside the `horus-checker/` repository root.&#xA;sh ./scripts/ci/install-z3-macos.sh&#xA;sh ./scripts/ci/install-cvc5-macos.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;On macOS (&lt;code&gt;aarch64&lt;/code&gt;):&lt;/h6&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# Inside the `horus-checker/` repository root.&#xA;sh ./scripts/ci/install-z3-macos.sh&#xA;sh ./scripts/ci/install-cvc5-macos-aarch64.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Create a python virtual environment&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re using &lt;code&gt;conda&lt;/code&gt;, you can skip to &lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#install-horus-compile&#34;&gt;install &lt;code&gt;horus-compile&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Otherwise, navigate to the &lt;code&gt;horus-compile/&lt;/code&gt; repository root and run the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;python -m venv .venv/horus&#xA;source .venv/horus/bin/activate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above, &lt;code&gt;horus&lt;/code&gt; is just the name we chose for our virtual environment.&lt;/p&gt; &#xA;&lt;h3&gt;Install &lt;code&gt;horus-compile&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Make sure you&#39;re inside the &lt;code&gt;horus-compile&lt;/code&gt; repository root.&lt;/p&gt; &#xA;&lt;p&gt;On Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;pip install .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On macOS:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;CFLAGS=-I`brew --prefix gmp`/include LDFLAGS=-L`brew --prefix gmp`/lib pip install .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Install &lt;code&gt;horus-checker&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Navigate to the &lt;code&gt;horus-checker&lt;/code&gt; repository root and run:&lt;/p&gt; &#xA;&lt;p&gt;On Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;stack install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On macOS:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;C_INCLUDE_PATH=&#34;`xcrun --show-sdk-path`/usr/include/ffi&#34; stack --extra-include-dirs=/opt/homebrew/opt/z3@4.10.2/include --extra-lib-dirs=/opt/homebrew/opt/z3@4.10.2/lib install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note.&lt;/strong&gt; Stack installs executables to &lt;code&gt;~/.local/bin&lt;/code&gt; by default. Make sure this directory is on your &lt;code&gt;PATH&lt;/code&gt; or pass a different install directory with &lt;code&gt;stack install --local-bin-path &amp;lt;dir&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;You can check that the install was successful with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-check --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the above command executed without error, you are ready to use Horus!&lt;/p&gt; &#xA;&lt;h3&gt;Quick installation using Docker&lt;/h3&gt; &#xA;&lt;p&gt;Follow these instructions if you prefer to install Horus in a docker container. Refer to the &lt;a href=&#34;https://docs.docker.com/&#34;&gt;Docker documentation&lt;/a&gt; for more information on working with containers.&lt;/p&gt; &#xA;&lt;h4&gt;1. Clone repositories&lt;/h4&gt; &#xA;&lt;p&gt;Clone the &lt;code&gt;horus-compile&lt;/code&gt; and &lt;code&gt;horus-checker&lt;/code&gt; repositories to your machine.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;git clone git@github.com:NethermindEth/horus-checker.git&#xA;cd horus-checker&#xA;git clone git@github.com:NethermindEth/horus-compile.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;2. Build docker image&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;sudo docker build . -t horus&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This process might take several minutes.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note.&lt;/strong&gt; If your local platform is an AArch64 Mac, this process will take even longer because some dependencies will be compiled from source. For us, it took 38min in a MacBook Pro M1.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;At the end you should see a message like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;Successfully built e48336cb10ae&#xA;Successfully tagged horus:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;3. Prepare a project directory&lt;/h4&gt; &#xA;&lt;p&gt;To access files on the host (your machine) from inside a docker container, you must mount some extant directory. This makes the directory readable and writable from both the host and the container.&lt;/p&gt; &#xA;&lt;p&gt;Here, we&#39;ll create an example project directory named &lt;code&gt;my-cairo-project&lt;/code&gt; for this purpose.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;mkdir my-cairo-project/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the docker documentation section on &lt;a href=&#34;https://docs.docker.com/storage/bind-mounts/&#34;&gt;bind mounts&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h4&gt;4. Start docker container&lt;/h4&gt; &#xA;&lt;p&gt;The following command will:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run the container&lt;/li&gt; &#xA; &lt;li&gt;Mount the directory &lt;code&gt;my-cairo-project/&lt;/code&gt; on your filesystem to the location &lt;code&gt;/home/&lt;/code&gt; on the container&#39;s filesystem&lt;/li&gt; &#xA; &lt;li&gt;Drop you into a root shell inside the container&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;sudo docker run -v $(pwd)/my-cairo-project/:/home/ -it horus:latest /bin/bash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;5. Check &lt;code&gt;horus-compile&lt;/code&gt; and &lt;code&gt;horus-check&lt;/code&gt; installation.&lt;/h4&gt; &#xA;&lt;p&gt;Inside the docker container, run the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-compile --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-check --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If these commands execute without error, you&#39;re ready to use Horus!&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Tutorial: Your first verified StarkNet contract&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s verify a StarkNet contract! First, we&#39;ll write a simple program that implements a stack data structure in Cairo. If you&#39;re unfamiliar with Cairo, or you need a refresher, check out the &lt;a href=&#34;https://www.cairo-lang.org/docs/&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To follow along, the full example program without annotations is provided in &lt;a href=&#34;https://github.com/NethermindEth/horus-checker/raw/langfield/documentation/example.cairo&#34;&gt;&lt;code&gt;example.cairo&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Define a struct called &lt;code&gt;Stack&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Let&#39;s define a &lt;a href=&#34;https://www.cairo-lang.org/docs/reference/syntax.html#structs&#34;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; called &lt;code&gt;Stack&lt;/code&gt; with two members:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;one called &lt;code&gt;value&lt;/code&gt; which has type &lt;a href=&#34;https://www.cairo-lang.org/docs/hello_cairo/intro.html#field-element&#34;&gt;&lt;code&gt;felt&lt;/code&gt;&lt;/a&gt;,&lt;/li&gt; &#xA; &lt;li&gt;one called &lt;code&gt;next&lt;/code&gt; of type &lt;code&gt;Stack*&lt;/code&gt;, which means it&#39;s a pointer to an instance of the struct &lt;code&gt;Stack&lt;/code&gt; that we&#39;re currently defining.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;struct Stack {&#xA;  value: felt,&#xA;  next: Stack*,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Intuitively, we are representing our stack as a linked list. The &lt;code&gt;value&lt;/code&gt; is the head of the list, i.e. the top of the stack, and the &lt;code&gt;next&lt;/code&gt; member is a pointer to the next node in the list.&lt;/p&gt; &#xA;&lt;p&gt;Now we&#39;ve got a bare data structure. Let&#39;s define some functions that operate on it.&lt;/p&gt; &#xA;&lt;h4&gt;Define a function that constructs an empty &lt;code&gt;Stack&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;First, we&#39;ll define a function called &lt;code&gt;empty()&lt;/code&gt; that takes no arguments and returns a pointer to a new, empty &lt;code&gt;Stack&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;struct Stack {&#xA;  value: felt,&#xA;  next: Stack*,&#xA;}&#xA;&#xA;func empty() -&amp;gt; (stack: Stack*) {&#xA;  return (cast(0, Stack*),);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The use of &lt;code&gt;cast()&lt;/code&gt; above is a &lt;a href=&#34;https://www.cairo-lang.org/docs/how_cairo_works/consts.html?highlight=cast#typed-references&#34;&gt;typed reference&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Define a function that adds the top two elements on the stack&lt;/h4&gt; &#xA;&lt;p&gt;We&#39;ll also define a function called &lt;code&gt;add()&lt;/code&gt;. It will take one argument, which will be a pointer to a stack, and it will have one return value, also a pointer to a stack.&lt;/p&gt; &#xA;&lt;p&gt;We can use &lt;a href=&#34;https://www.cairo-lang.org/docs/how_cairo_works/consts.html?highlight=cast#typed-references&#34;&gt;member accessor notation&lt;/a&gt; to access the appropriate data from our parameter &lt;code&gt;stack&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;struct Stack {&#xA;  value: felt,&#xA;  next: Stack*,&#xA;}&#xA;&#xA;func empty() -&amp;gt; (stack: Stack*) {&#xA;  return (cast(0, Stack*),);&#xA;}&#xA;&#xA;func add(stack: Stack*) -&amp;gt; (stack: Stack*) {&#xA;  let x = stack.value;&#xA;  let y = stack.next.value;&#xA;  return (new Stack(value=x + y, next=stack.next.next),);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use the &lt;a href=&#34;https://www.cairo-lang.org/docs/how_cairo_works/object_allocation.html?highlight=new#the-new-operator&#34;&gt;&lt;code&gt;new&lt;/code&gt; operator&lt;/a&gt; which creates a specified object, in this case a &lt;code&gt;Stack&lt;/code&gt;, in the &lt;a href=&#34;https://www.cairo-lang.org/docs/how_cairo_works/segments.html#the-program-and-execution-segments&#34;&gt;execution segment&lt;/a&gt; of our program. It then returns a pointer to the newly created object. In this case, it returns a pointer to a &lt;code&gt;Stack&lt;/code&gt;, and that makes sense, since our return value is &lt;code&gt;stack: Stack*&lt;/code&gt;!&lt;/p&gt; &#xA;&lt;h4&gt;Define a function that pushes values onto the stack&lt;/h4&gt; &#xA;&lt;p&gt;Next, we&#39;ll define a function called &lt;code&gt;lit()&lt;/code&gt; for pushing values onto the stack.&lt;/p&gt; &#xA;&lt;p&gt;By convention, &lt;code&gt;lit&lt;/code&gt; stands for &#34;literal&#34;, since we&#39;re pushing &#34;literal&#34; values. This is a naming tradition that originates from implementations of stack machines and stack-based languages:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;LIT is the primitive word for pushing a &#34;literal&#34; number onto the data stack. -&lt;a href=&#34;https://en.wikipedia.org/wiki/Forth_(programming_language)&#34;&gt;Wikipedia page for Forth&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Our function will take two arguments, a pointer to a stack, and a literal value &lt;code&gt;i&lt;/code&gt;, which has type &lt;a href=&#34;https://www.cairo-lang.org/docs/hello_cairo/intro.html#field-element&#34;&gt;&lt;code&gt;felt&lt;/code&gt;&lt;/a&gt;. It will return a pointer to a stack to which the literal &lt;code&gt;i&lt;/code&gt; has been pushed, and is now the top element. Our function will leave the rest of the stack unmodified.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;struct Stack {&#xA;  value: felt,&#xA;  next: Stack*,&#xA;}&#xA;&#xA;func empty() -&amp;gt; (stack: Stack*) {&#xA;  return (cast(0, Stack*),);&#xA;}&#xA;&#xA;func add(stack: Stack*) -&amp;gt; (stack: Stack*) {&#xA;  let x = stack.value;&#xA;  let y = stack.next.value;&#xA;  return (new Stack(value=x + y, next=stack.next.next),);&#xA;}&#xA;&#xA;func lit(stack: Stack*, i: felt) -&amp;gt; (stack: Stack*) {&#xA;  return (new Stack(value=i, next=stack),);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Define a function to peek the top value of the stack&lt;/h4&gt; &#xA;&lt;p&gt;And finally, we&#39;ll define a function &lt;code&gt;top()&lt;/code&gt; which simply returns the top value on the stack without modifying the stack.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;struct Stack {&#xA;  value: felt,&#xA;  next: Stack*,&#xA;}&#xA;&#xA;func empty() -&amp;gt; (stack: Stack*) {&#xA;  return (cast(0, Stack*),);&#xA;}&#xA;&#xA;func add(stack: Stack*) -&amp;gt; (stack: Stack*) {&#xA;  let x = stack.value;&#xA;  let y = stack.next.value;&#xA;  return (new Stack(value=x + y, next=stack.next.next),);&#xA;}&#xA;&#xA;func lit(stack: Stack*, i: felt) -&amp;gt; (stack: Stack*) {&#xA;  return (new Stack(value=i, next=stack),);&#xA;}&#xA;&#xA;func top(stack: Stack*) -&amp;gt; (res: felt) {&#xA;  return (stack.value,);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Add a namespace for our &lt;code&gt;Stack&lt;/code&gt;-related functions&lt;/h4&gt; &#xA;&lt;p&gt;We can wrap all these functions up in a namespace called &lt;code&gt;_Stack&lt;/code&gt; to clarify usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;struct Stack {&#xA;  value: felt,&#xA;  next: Stack*,&#xA;}&#xA;&#xA;namespace _Stack {&#xA;  func empty() -&amp;gt; (stack: Stack*) {&#xA;      return (cast(0, Stack*),);&#xA;  }&#xA;&#xA;  func add(stack: Stack*) -&amp;gt; (stack: Stack*) {&#xA;      let x = stack.value;&#xA;      let y = stack.next.value;&#xA;      return (new Stack(value=x + y, next=stack.next.next),);&#xA;  }&#xA;&#xA;  func lit(stack: Stack*, i: felt) -&amp;gt; (stack: Stack*) {&#xA;      return (new Stack(value=i, next=stack),);&#xA;  }&#xA;&#xA;  func top(stack: Stack*) -&amp;gt; (res: felt) {&#xA;      return (stack.value,);&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This means when we call them we must write, for example, &lt;code&gt;_Stack.add&lt;/code&gt; instead of just &lt;code&gt;add&lt;/code&gt;, which makes it slightly clearer what sort of objects we&#39;re operating on, and where to find the implementation of that operation.&lt;/p&gt; &#xA;&lt;h4&gt;Add the necessary imports and a &lt;code&gt;main()&lt;/code&gt; function&lt;/h4&gt; &#xA;&lt;p&gt;Great! Now we&#39;ll just add a short &lt;code&gt;main()&lt;/code&gt; function to test that our stack functions as we expect.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// Declare this program as a starknet contract.&#xA;%lang starknet&#xA;&#xA;struct Stack {&#xA;  value: felt,&#xA;  next: Stack*,&#xA;}&#xA;&#xA;namespace _Stack {&#xA;  func empty() -&amp;gt; (stack: Stack*) {&#xA;      return (cast(0, Stack*),);&#xA;  }&#xA;&#xA;  func add(stack: Stack*) -&amp;gt; (stack: Stack*) {&#xA;      let x = stack.value;&#xA;      let y = stack.next.value;&#xA;      return (new Stack(value=x + y, next=stack.next.next),);&#xA;  }&#xA;&#xA;  func lit(stack: Stack*, i: felt) -&amp;gt; (stack: Stack*) {&#xA;      return (new Stack(value=i, next=stack),);&#xA;  }&#xA;&#xA;  func top(stack: Stack*) -&amp;gt; (res: felt) {&#xA;      return (stack.value,);&#xA;  }&#xA;}&#xA;&#xA;// Perform some example operations on a stack to sum two integers.&#xA;@external&#xA;func main() -&amp;gt; (res : felt) {&#xA;  let (stack) = _Stack.empty();&#xA;  let (stack) = _Stack.lit(stack, 5);&#xA;  let (stack) = _Stack.lit(stack, 6);&#xA;  let (stack) = _Stack.add(stack);&#xA;  let (top) = _Stack.top(stack);&#xA;  return (res=top);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Our example &lt;code&gt;main()&lt;/code&gt; function pushes two literals to an empty stack, adds them, and then returns the result.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://www.cairo-lang.org/docs/hello_starknet/index.html&#34;&gt;Hello, StarkNet&lt;/a&gt; tutorial if you&#39;d like to try running this contract on a testnet. You should get the answer &lt;code&gt;11&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Formally verify our example program&lt;/h4&gt; &#xA;&lt;p&gt;Now, let&#39;s add some annotations that describe how we expect our &lt;code&gt;_Stack&lt;/code&gt; functions to behave, and then we&#39;ll prove that the implementations we wrote always do what the annotations say.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s our program with the annotations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;%lang starknet&#xA;&#xA;struct Stack {&#xA;  value: felt,&#xA;  next: Stack*,&#xA;}&#xA;&#xA;namespace _Stack {&#xA;  func empty() -&amp;gt; (stack: Stack*) {&#xA;      return (cast(0, Stack*),);&#xA;  }&#xA;&#xA;  // @post $Return.stack.value == stack.value + stack.next.value&#xA;  // @post $Return.stack.next == stack.next.next&#xA;  func add(stack: Stack*) -&amp;gt; (stack: Stack*) {&#xA;      let x = stack.value;&#xA;      let y = stack.next.value;&#xA;      return (new Stack(value=x + y, next=stack.next.next),);&#xA;  }&#xA;&#xA;  // @post $Return.stack.value == i&#xA;  // @post $Return.stack.next == stack&#xA;  func lit(stack: Stack*, i: felt) -&amp;gt; (stack: Stack*) {&#xA;      return (new Stack(value=i, next=stack),);&#xA;  }&#xA;&#xA;  // @post $Return.res == stack.value&#xA;  func top(stack: Stack*) -&amp;gt; (res: felt) {&#xA;      return (stack.value,);&#xA;  }&#xA;}&#xA;&#xA;// Perform some example operations on a stack.&#xA;// @post $Return.res == 11&#xA;@external&#xA;func main () -&amp;gt; (res : felt) {&#xA;  let (stack) = _Stack.empty();&#xA;  let (stack) = _Stack.lit(stack, 5);&#xA;  let (stack) = _Stack.lit(stack, 6);&#xA;  let (stack) = _Stack.add(stack);&#xA;  let (top) = _Stack.top(stack);&#xA;  return (res=top);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The annotations are the comments directly above each of the functions &lt;code&gt;add()&lt;/code&gt;, &lt;code&gt;lit()&lt;/code&gt;, and &lt;code&gt;top()&lt;/code&gt;, along with the assert comment in &lt;code&gt;main()&lt;/code&gt;. They all begin with &lt;code&gt;// @&lt;/code&gt;. The &lt;code&gt;@post&lt;/code&gt; keyword indicates that an annotation is specifying a condition that must hold &lt;strong&gt;at the end of the function call&lt;/strong&gt;, when the function returns. It is called &lt;code&gt;@post&lt;/code&gt; because it is a &#34;postcondition&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Briefly, with the annotations we&#39;ve added, we are checking that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;add()&lt;/code&gt; function returns a pointer to a stack with the sum of the first two elements on top, and the remainder of the original stack (the third element and so on) after that.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;lit&lt;/code&gt; function puts &lt;code&gt;i&lt;/code&gt; on the top of the stack, and preserves the old stack underneath it.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;top&lt;/code&gt; function actually returns the top of the stack we pass as an argument.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;top&lt;/code&gt; value on the stack in &lt;code&gt;main()&lt;/code&gt; is actually &lt;code&gt;11&lt;/code&gt; (the sum of pushed values &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;6&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As an example, let&#39;s examine the annotations for the &lt;code&gt;_Stack.add()&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @post $Return.stack.value == stack.value + stack.next.value&#xA;// @post $Return.stack.next == stack.next.next&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s what&#39;s going on:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;//&lt;/code&gt; is just the syntax for comments.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;@post&lt;/code&gt; declares a Horus postcondition annotation. This condition must hold at the end of each function call.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;$Return&lt;/code&gt; syntax is a way of referring to the return values of the function. So &lt;code&gt;$Return.stack&lt;/code&gt; is the return value named &lt;code&gt;stack&lt;/code&gt; of the &lt;code&gt;add()&lt;/code&gt; function. In general, the &lt;code&gt;$&lt;/code&gt; syntax is how we reference &lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#declare&#34;&gt;logical variables&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Both annotations are boolean expressions asserting equality of a pair of values, and we can use arithmetic operators like &lt;code&gt;+&lt;/code&gt; in annotations for supported datatypes. See the section on &lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#annotations&#34;&gt;spec syntax&lt;/a&gt; for more info on what operators and symbols are supported.&lt;/li&gt; &#xA; &lt;li&gt;It is notable that we &lt;strong&gt;cannot reference locals&lt;/strong&gt; within preconditions or postconditions. So if we tried to say &lt;code&gt;@pre x == 0&lt;/code&gt; for the &lt;code&gt;add&lt;/code&gt; function, the compiler would print an error message telling us it cannot find the identifier &lt;code&gt;x&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Let&#39;s compile this annotated program with Horus and then check these properties:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-compile annotated.cairo --output compiled.json --spec_output spec.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This should create two files called &lt;code&gt;compiled.json&lt;/code&gt; and &lt;code&gt;spec.json&lt;/code&gt;. Now let&#39;s verify the compiled binary:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-check --solver z3 compiled.json spec.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;--solver z3&lt;/code&gt; flag tells Horus which SMT solver to use (Z3, in this case). See also the &lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#usage&#34;&gt;available solvers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;sub&gt;Expected output:&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Warning: Horus is currently in the *alpha* stage. Please be aware of the&#xA;Warning: known issues: https://github.com/NethermindEth/horus-checker/issues&#xA;&#xA;_Stack.add&#xA;Verified&#xA;&#xA;_Stack.lit&#xA;Verified&#xA;&#xA;_Stack.top&#xA;Verified&#xA;&#xA;main&#xA;Verified&#xA;&#xA;_Stack.empty [inlined]&#xA;Verified&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The four functions &lt;code&gt;_Stack.add&lt;/code&gt;, &lt;code&gt;_Stack.lit&lt;/code&gt;, &lt;code&gt;_Stack.top&lt;/code&gt;, and &lt;code&gt;main&lt;/code&gt; that we annotated all say &lt;code&gt;Verified&lt;/code&gt;, which means our implementations are correct with respect to the specifications we wrote in our annotations.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: &lt;code&gt;_Stack.empty&lt;/code&gt; appears here since Horus implicitly gives all unannotated functions a trivial (always true) specification.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: The &lt;code&gt;[inlined]&lt;/code&gt; marker just tells us that a given function was &lt;a href=&#34;https://en.wikipedia.org/wiki/Inline_expansion&#34;&gt;inline expanded&lt;/a&gt;, which happens whenever a function has no explicit &lt;code&gt;@pre&lt;/code&gt; or &lt;code&gt;@post&lt;/code&gt; annotations, and but needs to be checked for the purposes of checking something else.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Congrats! You&#39;ve just formally verified your first StarkNet contract!&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h4&gt;What is Horus?&lt;/h4&gt; &#xA;&lt;p&gt;Horus is a command-line tool for the &lt;a href=&#34;https://starkware.co/starknet/&#34;&gt;StarkNet ecosystem&lt;/a&gt;. It helps you &lt;a href=&#34;https://en.wikipedia.org/wiki/Formal_verification&#34;&gt;formally verify&lt;/a&gt; &lt;a href=&#34;https://starkware.co/starknet/&#34;&gt;StarkNet smart contracts&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The way it works is like this:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;You write a StarkNet smart contract.&lt;/li&gt; &#xA; &lt;li&gt;You add annotations that describe how the program should operate.&lt;/li&gt; &#xA; &lt;li&gt;You run Horus on your program, and Horus tells you one of the following: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The program obeys the annotations.&lt;/li&gt; &#xA;   &lt;li&gt;The program does not obey the annotations (found a counterexample).&lt;/li&gt; &#xA;   &lt;li&gt;Ran out of time (&lt;code&gt;Unknown&lt;/code&gt;).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;“Program testing can be used to show the presence of bugs, but never to show their absence!” ― Edsger W. Dijkstra&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Horus can be used to show the &lt;strong&gt;absence&lt;/strong&gt; of bugs.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note.&lt;/strong&gt; Horus is currently in &lt;strong&gt;alpha&lt;/strong&gt;, and thus should not be fully trusted yet. Both Horus and SMT solvers may have bugs themselves, and so a given judgement is never a &#34;certainty&#34;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Horus consists of two command-line tools, called &lt;code&gt;horus-compile&lt;/code&gt; and &lt;code&gt;horus-check&lt;/code&gt;. The first, &lt;code&gt;horus-compile&lt;/code&gt;, is a modified version of the Cairo compiler that you can use to compile a program with &lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#annotations&#34;&gt;Horus annotations&lt;/a&gt;. You can then run &lt;code&gt;horus-check&lt;/code&gt; on the compiled program to formally verify the program&#39;s behavior.&lt;/p&gt; &#xA;&lt;h4&gt;What is Cairo/StarkNet?&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://starkware.co/starknet/&#34;&gt;&lt;strong&gt;StarkNet&lt;/strong&gt;&lt;/a&gt; is a Layer 2 network over Ethereum. Specifically, it is a &lt;a href=&#34;https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/zk-rollups/&#34;&gt;ZK-Rollup (zero-knowledge rollup)&lt;/a&gt;, which is basically a way of scaling up the number of transactions that a blockchain can process by bundling (rolling-up) many transactions into one.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.cairo-lang.org/&#34;&gt;&lt;strong&gt;Cairo&lt;/strong&gt;&lt;/a&gt; is a &lt;a href=&#34;https://en.wikipedia.org/wiki/Turing_completeness&#34;&gt;Turing-complete&lt;/a&gt; language for writing &lt;a href=&#34;https://ethereum.org/en/dapps/#what-are-dapps&#34;&gt;dApps&lt;/a&gt; using &lt;a href=&#34;https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/zk-starks/&#34;&gt;STARKs&lt;/a&gt;. STARK stands for Scalable Transparent Argument of Knowledge.&lt;/p&gt; &#xA;&lt;p&gt;Basically, it&#39;s a programming language for &lt;a href=&#34;https://en.wikipedia.org/wiki/Verifiable_computing&#34;&gt;verifiable computing&lt;/a&gt; that runs on StarkNet. It lets you write programs where one party can prove to another that a certain computation was executed correctly. The syntax is a bit like &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can write StarkNet smart contracts in the Cairo language.&lt;/p&gt; &#xA;&lt;h4&gt;When should I use Horus?&lt;/h4&gt; &#xA;&lt;p&gt;Use Horus when you need to be absolutely sure that a function in a StarkNet contract executes correctly according to some specification. Horus is good for when you know what your program should do, but you aren&#39;t sure that the implementation actually does that thing, in all cases, no matter what. Horus will not help you if you don&#39;t know exactly what your program should do.&lt;/p&gt; &#xA;&lt;p&gt;You could also use Horus for lightweight things like a sanity check on the bounds of the output of some function, for instance.&lt;/p&gt; &#xA;&lt;p&gt;Horus has been designed to be easy to use without an extensive background in formal verification. You can start simple and iteratively refine your specifications as you learn how to use the tool better.&lt;/p&gt; &#xA;&lt;p&gt;Horus, and formal verification in general, proves that the implementation of a program &lt;strong&gt;matches the expected behavior&lt;/strong&gt;, as expressed in some formal specification.&lt;/p&gt; &#xA;&lt;p&gt;You get the most mileage out of this when the expected behavior is simple, but the implementation is very complex.&lt;/p&gt; &#xA;&lt;h4&gt;Why should I use Horus?&lt;/h4&gt; &#xA;&lt;p&gt;Because you love formal verification and care about writing provably correct programs!&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://arstechnica.com/information-technology/2021/12/hackers-drain-31-million-from-cryptocurrency-service-monox-finance/&#34;&gt;Really stupid “smart contract” bug let hackers steal $31 million in digital coin&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Alternatively, because you don&#39;t want your firm to be in the news.&lt;/p&gt; &#xA;&lt;h4&gt;What does Horus do?&lt;/h4&gt; &#xA;&lt;p&gt;It uses a modified version of the StarkNet compiler to translate your &lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#annotations&#34;&gt;function specification annotations&lt;/a&gt; into &lt;a href=&#34;https://en.wikipedia.org/wiki/Satisfiability_modulo_theories&#34;&gt;SMT solver&lt;/a&gt; queries. These are mathematical assertions that the desired properties of the function in question are true for all inputs. Then these queries are run, and the SMT solver magically tells us whether or not it was able to prove that the program is sound!&lt;/p&gt; &#xA;&lt;h4&gt;What things can I assert/check about a program?&lt;/h4&gt; &#xA;&lt;p&gt;You can assert things about function parameters, function return values, arbitrary labels/variables in a function body, and storage variables. Here are examples of things you can check about these values:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Two values are equal (&lt;code&gt;==&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;One value is less/greater than (or equal) to another (e.g. &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;A storage variable is updated with a particular value&lt;/li&gt; &#xA; &lt;li&gt;An invariant holds, e.g. in a loop&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that arithmetic operations are defined over &lt;a href=&#34;https://en.wikipedia.org/wiki/Finite_field&#34;&gt;finite field&lt;/a&gt; elements (felts).&lt;/p&gt; &#xA;&lt;p&gt;You can check these conditions hold at the start and end of a function call with &lt;code&gt;@pre&lt;/code&gt; and &lt;code&gt;@post&lt;/code&gt;, respectively, and also in the middle of a function body with &lt;code&gt;@invariant&lt;/code&gt; and &lt;code&gt;@assert&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;What SMT solvers are available?&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;-s&lt;/code&gt;/&lt;code&gt;--solver&lt;/code&gt; flag is used to tell Horus which SMT solver to use.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-check -s cvc5 program.json spec.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above example, we use the solver named &lt;code&gt;cvc5&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-check -s mathsat program.json spec.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above example, we use the solver named &lt;code&gt;mathsat&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Horus supports the following solvers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cvc5&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mathsat&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;z3&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://mathsat.fbk.eu/download.html&#34;&gt;MathSAT5&lt;/a&gt; must be installed separately.&lt;/p&gt; &#xA;&lt;h4&gt;How can I refer to return values in an annotation?&lt;/h4&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;$Return&lt;/code&gt; syntax to refer to elements of the return tuple by name. This can only be done in a postcondition, i.e. a &lt;code&gt;@post&lt;/code&gt; annotation. The names must be declared in the type signature of the function, after the &lt;code&gt;-&amp;gt;&lt;/code&gt; notation. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @post $Return.a == 1&#xA;// @post $Return.b == 2&#xA;func f() -&amp;gt; (a: felt, b: felt) {&#xA;    return (a=1, b=2);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How can I refer to the address of the caller in an annotation?&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;get_caller_address()&lt;/code&gt;. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;%lang starknet&#xA;from starkware.starknet.common.syscalls import get_caller_address&#xA;&#xA;// @post $Return.res == get_caller_address()&#xA;func f{syscall_ptr: felt*}() -&amp;gt; (res: felt) {&#xA;    let (res) = get_caller_address();&#xA;    return (res=res);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How can I refer to the address of the contract itself in an annotation?&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;get_contract_address()&lt;/code&gt;. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;%lang starknet&#xA;from starkware.starknet.common.syscalls import get_contract_address&#xA;&#xA;// @post $Return.res == get_contract_address()&#xA;func f{syscall_ptr: felt*}() -&amp;gt; (res: felt) {&#xA;    let (res) = get_contract_address();&#xA;    return (res=res);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How can I refer to the current block timestamp in an annotation?&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;get_block_timestamp()&lt;/code&gt;. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;%lang starknet&#xA;from starkware.starknet.common.syscalls import get_block_timestamp&#xA;&#xA;// @post $Return.res == get_block_timestamp()&#xA;func f{syscall_ptr: felt*}() -&amp;gt; (res: felt) {&#xA;    let (res) = get_block_timestamp();&#xA;    return (res=res);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Why do extra functions/things appear in the output even though I didn&#39;t give them annotations?&lt;/h4&gt; &#xA;&lt;p&gt;Horus prints a judgement for every function it uses to verify your annotations. If an annotated function &lt;code&gt;f&lt;/code&gt; calls an unannotated function &lt;code&gt;g&lt;/code&gt; (perhaps a library function), the judgement for &lt;code&gt;g&lt;/code&gt; may also be printed.&lt;/p&gt; &#xA;&lt;p&gt;Horus also adds a trivial annotation (equivalent to &lt;code&gt;@pre True&lt;/code&gt; and &lt;code&gt;@post True&lt;/code&gt;) which is &lt;strong&gt;always&lt;/strong&gt; verifiable to all unannotated functions, and so judgements for these will also be printed.&lt;/p&gt; &#xA;&lt;h4&gt;Why am I getting &lt;code&gt;Verified&lt;/code&gt; when I expect &lt;code&gt;False&lt;/code&gt;?&lt;/h4&gt; &#xA;&lt;p&gt;One common reason this happens is contradictions in the &lt;code&gt;@pre&lt;/code&gt; condition. If you have constraints that cannot ever be true, i.e. are impossible, and you ask Horus, &lt;em&gt;&#34;if you assume my &lt;code&gt;@pre&lt;/code&gt; conditions, are my &lt;code&gt;@post&lt;/code&gt; conditions always true?&#34;&lt;/em&gt;, what you are asking is really, &lt;em&gt;&#34;if you assume an impossible situation, are my &lt;code&gt;@post&lt;/code&gt; conditions always true?&#34;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;In first-order logic, anything can be proved, i.e. anything is possible, if you start from an impossible state.&lt;/p&gt; &#xA;&lt;p&gt;As an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @pre 9 == 10&#xA;// @post $Return.a == 1&#xA;func f() -&amp;gt; (a: felt) {&#xA;  return (a=0);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above program has a postcondition which is obviously &lt;code&gt;False&lt;/code&gt;, since we return a literal &lt;code&gt;a=0&lt;/code&gt;, and we assert that &lt;code&gt;$Return.a == 1&lt;/code&gt;. &lt;em&gt;However&lt;/em&gt;, since the &lt;code&gt;@pre&lt;/code&gt; condition assumes &lt;code&gt;9 == 10&lt;/code&gt;, which is impossible, we will get &lt;code&gt;Verified&lt;/code&gt;, because we are asking Horus to prove that &lt;em&gt;&#34;if &lt;code&gt;9 == 10&lt;/code&gt;, does &lt;code&gt;f&lt;/code&gt; return &lt;code&gt;a=1&lt;/code&gt;?&#34;&lt;/em&gt;, and this is indeed true in a vacuous sort of way, because it will never be the case that &lt;code&gt;9 == 10&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;More generally, you may also expect &lt;code&gt;False&lt;/code&gt; when you use a &lt;code&gt;@pre&lt;/code&gt; condition which is obviously not always satisfied. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @pre x == 2&#xA;// @post $Return.a == 1&#xA;func f(x: felt) -&amp;gt; (a: felt) {&#xA;  return (a=1);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We may expect to get &lt;code&gt;False&lt;/code&gt; for the above, since, obviously, &lt;code&gt;x&lt;/code&gt; is not always going to be &lt;code&gt;2&lt;/code&gt;, in general. However, Horus will tell us that &lt;code&gt;f&lt;/code&gt; has judgement &lt;code&gt;Verified&lt;/code&gt;. This is because what Horus checks is that &lt;strong&gt;if&lt;/strong&gt; &lt;code&gt;x == 2&lt;/code&gt;, &lt;strong&gt;then&lt;/strong&gt; the function returns &lt;code&gt;a=1&lt;/code&gt;. It never checks &lt;strong&gt;whether&lt;/strong&gt; &lt;code&gt;x == 2&lt;/code&gt;. It only &lt;strong&gt;assumes&lt;/strong&gt; &lt;code&gt;x == 2&lt;/code&gt; to then check other things.&lt;/p&gt; &#xA;&lt;p&gt;Instead, we only get a failure when we &lt;strong&gt;call&lt;/strong&gt; &lt;code&gt;f&lt;/code&gt; from some other place where Horus is unable to prove that &lt;code&gt;x&lt;/code&gt; is always &lt;code&gt;2&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @pre x == 2&#xA;// @post $Return.a == 1&#xA;func f(x: felt) -&amp;gt; (a: felt) {&#xA;  return (a=1);&#xA;}&#xA;&#xA;// @pre x &amp;gt; 0&#xA;func g(x: felt) -&amp;gt; (b: felt) {&#xA;  let (b,) = f(x);&#xA;  return (b=b);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When we run Horus on the above program, we get:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;user@computer:~/pkgs/horus-checker$ horus-check -s cvc5 a.json spec.json&#xA;f&#xA;Verified&#xA;&#xA;g&#xA;False&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So we see that the &lt;code&gt;False&lt;/code&gt; is given for the caller &lt;code&gt;g&lt;/code&gt;, and not &lt;code&gt;f&lt;/code&gt;, since in order for the call to &lt;code&gt;f&lt;/code&gt; to satisfy &lt;code&gt;f&lt;/code&gt;&#39;s precondition, we must have that &lt;code&gt;x == 2&lt;/code&gt;, but all we know is that &lt;code&gt;x &amp;gt; 0&lt;/code&gt;, from the precondition of &lt;code&gt;g&lt;/code&gt;. So it is easy for Horus to find a counterexample that breaks our specification. In particular, we could pick &lt;code&gt;x == 1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Why am I seeing &lt;code&gt;Cannot obtain identifier &#34;y&#34;. Expected a reference but got &#34;future&#34;&lt;/code&gt;?&lt;/h4&gt; &#xA;&lt;p&gt;You may see this error message when you try to reference a variable that is out-of-scope in an annotation.&lt;/p&gt; &#xA;&lt;p&gt;Consider the following program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @pre y == 3&#xA;// @post $Return.a == 1&#xA;func f(x: felt) -&amp;gt; (a: felt) {&#xA;    let y = 4;&#xA;    return (a=x + 2);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When we compile this, we see:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;(horus39) user@computer:~/pkgs/horus-checker$ horus-compile contra.cairo --output a.json --spec_output spec.json&#xA;contra.cairo:1:6: Cannot obtain identifier &#34;y&#34;. Expected a reference but got &#34;future&#34;&#xA;@pre y == 3&#xA;     ^&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is because &lt;code&gt;y&lt;/code&gt; is a local variable. It is not present in the function&#39;s type signature, it is defined &lt;em&gt;within&lt;/em&gt; the function body. We see this error because &lt;strong&gt;local variables cannot be referenced in preconditions or postconditions&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Why am I getting &lt;code&gt;Unknown&lt;/code&gt;?&lt;/h4&gt; &#xA;&lt;p&gt;There are many reasons why an SMT solver may timeout on a query. Unfortunately, satisfiability is a very difficult problem (&lt;a href=&#34;https://en.wikipedia.org/wiki/Undecidable_problem&#34;&gt;undecidable&lt;/a&gt; in general), and it is nigh impossible to accurately predict how long an arbitrary query will take to solve.&lt;/p&gt; &#xA;&lt;p&gt;However, besides increasing the timeout passed to the solver with the &lt;code&gt;-t&lt;/code&gt; flag, it may also be helpful to try using a different solver backend to resolve &lt;code&gt;Unknown&lt;/code&gt; results. It is notable that &lt;strong&gt;&lt;code&gt;cvc5&lt;/code&gt; (the default solver) does not perform well with nonlinear arithmetic&lt;/strong&gt;, and thus it is better to use &lt;code&gt;z3&lt;/code&gt; or &lt;code&gt;mathsat&lt;/code&gt; for these cases.&lt;/p&gt; &#xA;&lt;p&gt;It is also sometimes helpful to rewrite your annotations in a different, but logically equivalent form, as this sometimes has the effect of making the query easier for solver.&lt;/p&gt; &#xA;&lt;h4&gt;Why don&#39;t &lt;code&gt;@assert&lt;/code&gt; annotations work in my function?&lt;/h4&gt; &#xA;&lt;p&gt;Unfortunately, we currently don’t support &lt;code&gt;@assert&lt;/code&gt; annotations inside functions that read/write storage variables, so this is one possible reason why you may be having trouble with &lt;code&gt;@assert&lt;/code&gt; annotations. If you&#39;re still stuck, please open an issue!&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Horus consists of two command-line tools, &lt;code&gt;horus-compile&lt;/code&gt; and &lt;code&gt;horus-check&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;horus-compile&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-compile [-h] [--abi ABI] [--disable_hint_validation]&#xA;              [--account_contract] [--spec_output SPEC_OUTPUT]&#xA;              [--prime PRIME] [--cairo_path CAIRO_PATH]&#xA;              [--preprocess] [--output OUTPUT] [--no_debug_info]&#xA;              [--debug_info_with_source]&#xA;              [--cairo_dependencies CAIRO_DEPENDENCIES]&#xA;              [--no_opt_unused_functions] [-v]&#xA;              file [file ...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A tool to compile checked StarkNet contracts.&lt;/p&gt; &#xA;&lt;p&gt;Emits a compiled StarkNet contract in the form of JSON, printed to &lt;code&gt;stdout&lt;/code&gt; by default.&lt;/p&gt; &#xA;&lt;h4&gt;Example&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-compile a.cairo --output b.json --spec_output spec.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Compiles the annotated StarkNet contract &lt;code&gt;a.cairo&lt;/code&gt;, and dumps the output into &lt;code&gt;b.json&lt;/code&gt; and &lt;code&gt;spec.json&lt;/code&gt; for the specifications.&lt;/p&gt; &#xA;&lt;h4&gt;Positional arguments&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;file&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;One or more StarkNet contracts to compile.&lt;/p&gt; &#xA;&lt;h4&gt;Flags&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;-h, --help&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Show a help message and exit&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--abi ABI&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Dump the contract&#39;s ABI (application binary interface) to a file. This is a JSON list containing metadata (like type signatures and members) on functions, structs, and other things within the program.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--disable-hint-validation&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Disable the hint validation, which ordinarily checks program hints against a whitelist.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--account-contract&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Compile as account contract, which means the ABI will be checked for expected builtin entry points.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--spec_output SPEC_OUTPUT&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The specification output file name (default: stdout).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--prime PRIME&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The positive integer size of the finite field. This is a (usually large) prime power over which basic arithmetic within the program is carried out.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--cairo_path CAIRO_PATH&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;A list of directories, separated by &#34;:&#34; to resolve import paths. The full list will consist of directories defined by this argument, followed by the environment variable &lt;code&gt;CAIRO_PATH&lt;/code&gt;, the working directory and the standard library path.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--preprocess&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Stop after the preprocessor step and output the preprocessed program, which consists only of low-level Cairo (e.g. frame pointer and allocation pointer manipulations) along with annotations indicating relevant source code locations.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--output OUTPUT&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The output file name (default: stdout).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--no_debug_info&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Don&#39;t include debug information in the compiled file. Removes the &#39;debug_info&#39; field from the JSON output, which by default contains an &#39;instruction_locations&#39; map with information on flow tracking data, hints, accessible scopes, and source code location.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--cairo_dependencies CAIRO_DEPENDENCIES&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Path to dump a list of the Cairo source files used during the compilation as a CMake file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--no_opt_unused_functions&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Disable unused function optimization, which ordinarily only compiles functions reachable from the main scope in the dependency graph, i.e. functions that are actually called.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-v, --version&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Show program&#39;s version number and exit&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;horus-check&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-check [COMPILED_FILE] [SPECIFICATION] [-v|--verbose] &#xA;            [--output-queries DIR] [--output-optimized-queries DIR] &#xA;            [--version] [(-s|--solver SOLVER)] [-t|--timeout TIMEOUT]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Example&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-check b.json spec.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Attempts to verify the compiled StarkNet contract &lt;code&gt;b.json&lt;/code&gt; and its specification &lt;code&gt;spec.json&lt;/code&gt; with the default SMT solver &lt;code&gt;cvc5&lt;/code&gt;, and prints the output to &lt;code&gt;stdout&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Positional arguments&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;COMPILED_FILE&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;A JSON contract compiled with &#39;horus-compile&#39;. This can be generated from a &#39;.cairo&#39; file as follows (for an example contract called &lt;code&gt;program.cairo&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-compile --output program.json --spec_output spec.json program.cairo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;SPECIFICATION&lt;/code&gt; A JSON file containing additional information about annotations. This is produced by &lt;code&gt;horus-compile&lt;/code&gt; as well.&lt;/p&gt; &#xA;&lt;h4&gt;Flags&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;-v,--verbose&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Print all intermediate steps (control flow graph, SMT2 queries, metadata for each module).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--output-queries DIR&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Stores the (unoptimized) SMT queries for each module in .smt2 files inside DIR.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;--output-optimized-queries DIR&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Stores the (optimized) SMT queries for each module in .smt2 files inside DIR.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-s,--solver SOLVER&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Solver to check the resulting SMT queries (options: &lt;code&gt;z3&lt;/code&gt;, &lt;code&gt;cvc5&lt;/code&gt;, &lt;code&gt;mathsat&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If verifying a function &lt;code&gt;f()&lt;/code&gt; that calls a function &lt;code&gt;g()&lt;/code&gt; whose Horus annotations contain logical variables, the &lt;code&gt;mathsat&lt;/code&gt; and &lt;code&gt;cvc5&lt;/code&gt; solvers will fail, and thus &lt;code&gt;z3&lt;/code&gt; must be used.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;You can also pass multiple solvers, which will be tried in the order they are passed as flags. In the example below, we run &lt;code&gt;z3&lt;/code&gt; followed by &lt;code&gt;mathsat&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-check example.json spec.json -s z3 mathsat cvc5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The timeout will apply to each solver individually, meaning that running two solvers doubles the maximum time the &lt;code&gt;horus-check&lt;/code&gt; command will run before terminating.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-t,--timeout TIMEOUT&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Time limit (ms) per-SMT query, per-SMT solver.&lt;/p&gt; &#xA;&lt;p&gt;Horus makes at least one SMT query per function in the program. It may make multiple SMT queries for a single function. And it does this when there are multiple control flow branches in that function.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you have 2 functions in a contract/program, and both have an &lt;code&gt;if-then-else&lt;/code&gt; clause, then we will have 4 branches, and thus 4 SMT queries made. If we run Horus with two separate solvers (say &lt;code&gt;Z3&lt;/code&gt; and &lt;code&gt;cvc5&lt;/code&gt;), then we will make a total of 8 queries.&lt;/p&gt; &#xA;&lt;p&gt;Thus if we set a timeout of 1000ms, the maximum running time of the &lt;code&gt;horus-check&lt;/code&gt; invocation is 8000ms or 8s.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-h,--help&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Show this help text&lt;/p&gt; &#xA;&lt;h2&gt;Annotations&lt;/h2&gt; &#xA;&lt;p&gt;To formally verify a program, we must prove that it behaves as expected. In order to do this, we must tell Horus what the expected behavior of the program is. The way that we do this is with the &lt;strong&gt;annotation language&lt;/strong&gt;. Annotations are comments that contain special syntax that Horus can understand. The set of all of a function&#39;s annotations is sometimes referred to as its &lt;em&gt;specification&lt;/em&gt; or &lt;em&gt;spec&lt;/em&gt;. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @post $Return.res == 3&#xA;func example() -&amp;gt; (res: felt) {&#xA;&#x9;return (3,);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The annotation in the example above is the line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @post $Return.res == 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It asserts that the &lt;code&gt;res&lt;/code&gt; return value must always be &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Annotation syntax&lt;/h3&gt; &#xA;&lt;p&gt;In order to describe the expected behavior of a function, we need to be able to talk about the function&#39;s inputs, outputs, and effects. This means, we need to be able to reference the function&#39;s parameters and return values in annotations. Below, we describe the syntax for references, &lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#declare&#34;&gt;logical variables&lt;/a&gt;, boolean expressions, and implications:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;$a&lt;/code&gt; cairo references and logical variables can be used by name&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;$Return.a&lt;/code&gt; the special logical variable &lt;code&gt;$Return&lt;/code&gt; is defined to contain the values returned from the function&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a+b&lt;/code&gt;, &lt;code&gt;a==b&lt;/code&gt;, arithmetic operations and comparisons are supported for felts as in Cairo&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a==b or c==d&lt;/code&gt;, &lt;code&gt;a==b and c==d&lt;/code&gt;, &lt;code&gt;not a==b&lt;/code&gt;, &lt;code&gt;a==b -&amp;gt; c==d&lt;/code&gt; (disjunctions, conjunctions, negations, and implications)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;True&lt;/code&gt;, &lt;code&gt;False&lt;/code&gt; are defined as keywords&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Annotation types&lt;/h3&gt; &#xA;&lt;h3&gt;&lt;code&gt;@post&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Specifies conditions that must be true when the function returns. The name &lt;code&gt;post&lt;/code&gt; is short for &#34;postcondition&#34;.&lt;/p&gt; &#xA;&lt;p&gt;No claim is made about whether the function completes or reverts. We only assert that &lt;em&gt;if it completes&lt;/em&gt;, then the postcondition holds.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @post $Return.res &amp;lt; 100 &amp;amp;&amp;amp; $Return.res &amp;gt;= 50&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The annotation above asserts that the return value with name &lt;code&gt;res&lt;/code&gt; of the function (not pictured here) is less than 100 and greater than or equal to 50.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Local variables cannot be referenced in postconditions.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;@pre&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Specifies conditions that must be true immediately before a function is called. The name &lt;code&gt;pre&lt;/code&gt; is short for &#34;precondition&#34;. This annotation type allows us to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Place constraints on the values of function parameters&lt;/li&gt; &#xA; &lt;li&gt;Assign values to &lt;a href=&#34;https://raw.githubusercontent.com/NethermindEth/horus-checker/master/#declare&#34;&gt;logical variables&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @pre flag * (flag - 1) == 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The annotation above asserts that the function parameter with name &lt;code&gt;flag&lt;/code&gt; satisfies the equation $x(x - 1) = 0$, which implies that $x = 0$ or $x = 1$.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Local variables cannot be referenced in preconditions.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;@declare&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Allows the introduction of logical variables.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;strong&gt;logical variable&lt;/strong&gt; is a variable defined and used within a function specification (i.e. a set of annotations for a function, i.e. a set of lines starting with &lt;code&gt;// @&lt;/code&gt;) for conveniently referring to subexpressions. They play the same role that ordinary variables do in any programming language, but they can only be used within &lt;code&gt;horus&lt;/code&gt; annotations.&lt;/p&gt; &#xA;&lt;p&gt;Logical variable names must begin with a &lt;code&gt;$&lt;/code&gt;. Note that if a logical variable is not mentioned in the precondition, then the specification must hold for all possible values of that variable.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @declare $x : felt&#xA;// @pre $x == 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;In the above example, &lt;code&gt;$x&lt;/code&gt; is the logical variable being declared, and we assign it a value using a precondition.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;&lt;code&gt;@storage_update&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Allows claims to be made about the state of a &lt;a href=&#34;https://docs.starknet.io/documentation/architecture_and_concepts/Contracts/contract-storage/#storage_variables&#34;&gt;storage variable&lt;/a&gt; before and after the function. A storage update &lt;strong&gt;must be included for all storage variables modified by a function&lt;/strong&gt;, or verification will fail.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The first new primitive that we see in the code is &lt;code&gt;@storage_var&lt;/code&gt;. Unlike a Cairo program, which is stateless, StarkNet contracts have a state, called “the contract’s storage”. Transactions invoked on such contracts may modify this state, in a way defined by the contract.&lt;/p&gt; &#xA; &lt;p&gt;The &lt;code&gt;@storage_var&lt;/code&gt; decorator declares a variable which will be kept as part of this storage. In our case, this variable consists of a single felt, called balance. To use this variable, we will use the &lt;code&gt;balance.read()&lt;/code&gt; and &lt;code&gt;balance.write()&lt;/code&gt; functions which are automatically created by the &lt;code&gt;@storage_var&lt;/code&gt; decorator. When a contract is deployed, all its storage cells are initialized to zero. In particular, all storage variables are initially zero.&lt;/p&gt; &#xA; &lt;p&gt;&lt;em&gt;From the Cairo documentation on &lt;a href=&#34;https://www.cairo-lang.org/docs/hello_starknet/intro.html?highlight=storage%20variable&#34;&gt;writing Starknet contracts&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @storage_update x() := x() + 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;In the above example, only the top-level storage variable reference on the left hand side refers to the state after the function. As such, if &lt;code&gt;x&lt;/code&gt; took one input and we specified the update as such &lt;code&gt;x(y()) := x(y()) + 1&lt;/code&gt;, both instances of &lt;code&gt;y()&lt;/code&gt; refer to the state before the function was called.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you would like to make claims about the relationship between multiple storage variables after the function is complete, this can be achieved via the use of logical variables. To do so, equate your &#39;before&#39; logical variable to the storage variable in the precondition. Then, also in the precondition, relate the &#39;after&#39; and &#39;before&#39; logical variables. Finally assign the &#39;after&#39; logical variable to the storage variable in a storage update annotation.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;@invariant&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Introduces a constraint attached to a label, typically used for loop invariants.&lt;/p&gt; &#xA;&lt;p&gt;The invariant annotation is only required in the case of low level loops implemented with jump instructions, however it can also be used to make claims that must hold at any specific point in a function by adding an appropriately named label and attaching the annotation to it. Note that this effectively splits the function in two, and that anything from before the invariant that is not mentioned within it cannot be used after.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @invariant i &amp;lt;= 10&#xA;label1:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;In the above example, we assert that a local variable &lt;code&gt;i&lt;/code&gt; (perhaps a loop variable) is always less than or equal to 10. This invariant assertion is attached to the label named &lt;code&gt;label1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;&lt;code&gt;@assert&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Introduces a boolean constraint at an arbitrary point in a function body.&lt;/p&gt; &#xA;&lt;p&gt;You write a boolean expression after &lt;code&gt;@assert&lt;/code&gt;, and Horus will try to prove that the expression will always evaluate to &lt;code&gt;True&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-cairo&#34;&gt;// @assert j &amp;gt;= 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;In the above example, we assert that a local variable &lt;code&gt;j&lt;/code&gt; is at least 10.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; Assertions constitute a full-stop in the continuity of Horus&#39;s reasoning and should be thought of exactly as though a function with unknown allocation pointer change was invoked and its postcondition is the annotation present at &lt;code&gt;@assert&lt;/code&gt;. Horus can no longer reason about anything that &#39;happened&#39; prior to said assertion, whether it is contents of memory or preceding annotations such as the precondition.&lt;/p&gt; &#xA;&lt;p&gt;It is therefore recommended to avoid &lt;code&gt;@assert&lt;/code&gt;, or alternatively, to make sure to propagate all information that one wants to remember for further reasoning.&lt;/p&gt; &#xA;&lt;p&gt;In other words, use at your own peril, the semantics are complicated. It is &lt;em&gt;not&lt;/em&gt; like a typical &lt;code&gt;assert&lt;/code&gt; statement in an ordinary programming language.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://github.com/NethermindEth/horus-checker/issues/125&#34;&gt;this relevant bug report&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Storage variable rules&lt;/h3&gt; &#xA;&lt;p&gt;In a function that updates a storage variable &lt;code&gt;x&lt;/code&gt;, it is ambiguous what the name &lt;code&gt;x&lt;/code&gt; refers to in an annotation. It could be the &lt;strong&gt;initial&lt;/strong&gt; value, before the update, or the &lt;strong&gt;final&lt;/strong&gt; value, after the update.&lt;/p&gt; &#xA;&lt;p&gt;Here are the rules for figuring out which value is being referenced:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If a storage variable is referenced in a precondition (&lt;code&gt;@pre&lt;/code&gt;), it is the &lt;strong&gt;initial&lt;/strong&gt; value.&lt;/li&gt; &#xA; &lt;li&gt;If a storage variable is referenced in a postcondition (&lt;code&gt;@post&lt;/code&gt;), it is the &lt;strong&gt;final&lt;/strong&gt; value.&lt;/li&gt; &#xA; &lt;li&gt;Storage variables cannot be referenced in &lt;code&gt;@assert&lt;/code&gt; annotations within function bodies.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Internals&lt;/h2&gt; &#xA;&lt;p&gt;The purpose of this section is to give a brief high-level overview of the architecture of Horus. Hopefully this can serve as a minimal guide to understanding the source code and contributing to the project.&lt;/p&gt; &#xA;&lt;p&gt;The entrypoint source file is &lt;code&gt;app/Main.hs&lt;/code&gt;. When we run &lt;code&gt;horus-check&lt;/code&gt; on a compiled JSON file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;horus-check -s z3 a.json spec.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;the first thing that happens is that we deserialize the JSONs into a value of type &lt;code&gt;ContractDefinition&lt;/code&gt;, which is defined in &lt;code&gt;ContractDefinition.hs&lt;/code&gt;. This contract is then preprocessed into a richer value of type called &lt;code&gt;ContractInfo&lt;/code&gt;, which contains information on the instructions, storage variables, identifiers, etc.&lt;/p&gt; &#xA;&lt;p&gt;A mutable configuration record and the immutable &lt;code&gt;ContractInfo&lt;/code&gt; data are carried around in an &lt;code&gt;Env&lt;/code&gt; throughout the program, accessible from within a &lt;code&gt;ReaderT&lt;/code&gt; stack.&lt;/p&gt; &#xA;&lt;p&gt;The implementation makes use of several eDSLs (embedded domain-specific languages), the most important of which is &lt;code&gt;GlobalL&lt;/code&gt;, defined in &lt;code&gt;Global.hs&lt;/code&gt;. Each DSL is separated into two source files: one containing functions written &lt;em&gt;in&lt;/em&gt; the DSL, like &lt;code&gt;Global.hs&lt;/code&gt;, and one containing the implementation of the interpreter for the DSL, as well as a runner, like &lt;code&gt;Global/Runner.hs&lt;/code&gt;. Each DSL contains a record type defining the &#39;instructions&#39; that constitute the language, which is named something like &lt;code&gt;GlobalL&lt;/code&gt;, where the &lt;code&gt;L&lt;/code&gt; suffix stands for &#34;Language&#34;.&lt;/p&gt; &#xA;&lt;p&gt;There is an &lt;code&gt;Impl&lt;/code&gt; type defined in the &lt;code&gt;Runner.hs&lt;/code&gt; file for each DSL, which is the monad stack in which the interpreter is run. For example, the &lt;code&gt;Impl&lt;/code&gt; type for &lt;code&gt;GlobalL&lt;/code&gt; looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Impl = ReaderT Env (ExceptT Text IO)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The DSLs are written in a continuation-passing style. For example, the constructor &lt;code&gt;GetConfig&lt;/code&gt; within the &lt;code&gt;GlobalL&lt;/code&gt; DSL looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data GlobalF a&#xA;  ...&#xA;  | GetConfig (Config -&amp;gt; a)&#xA;  ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This constructor can be thought of as an &#34;instruction&#34; within the DSL, which, when run by the interpreter, returns a value of type &lt;code&gt;Config&lt;/code&gt;. The reason why we see &lt;code&gt;(Config -&amp;gt; a)&lt;/code&gt; is because &lt;code&gt;a&lt;/code&gt; is the continuation of the &#34;program&#34; within the DSL, i.e. more instructions for the interpreter to process.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Global&lt;/code&gt; DSL, and in particular the &lt;code&gt;solveContract&lt;/code&gt; routine within &lt;code&gt;Global.hs&lt;/code&gt;, serves as the entrypoint to the rest of the program, and its runner is called from within &lt;code&gt;Main.hs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Apart from &lt;code&gt;GlobalL&lt;/code&gt;, there are several other sub-DSLs, which include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CFGBuildL&lt;/code&gt; -- builds the control flow graph.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ModuleL&lt;/code&gt; -- constructs a list of &lt;code&gt;Module&lt;/code&gt;s from the control flow graph.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CairoSemanticsL&lt;/code&gt; -- constructs the set of memory variables, assertions, etc. for a given module.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PreprocessorL&lt;/code&gt; -- preprocesses and runs SMT queries.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Glossary&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;contract&lt;/strong&gt; - a Starknet smart contract.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;control flow&lt;/strong&gt; - refers to things like &lt;code&gt;if-else&lt;/code&gt; blocks, loops, function calls, etc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;control flow graph&lt;/strong&gt; - consists of a list of labels, which are our vertices, along with the code between these labels, which is represented as edges between those vertices.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;label&lt;/strong&gt; - a construct within the Cairo language implementation that identifies instructions which may be jumped-to.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;module&lt;/strong&gt; - a set of contiguous Cairo instructions between control flow primitives. A function may contain multiple modules. For example, a function with &lt;code&gt;if&lt;/code&gt; branching will include a module for when the branching condition is &lt;code&gt;True&lt;/code&gt;, and another module for when it is &lt;code&gt;False&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;SMT query&lt;/strong&gt; - a symbolic proposition which may be passed to an SMT solver, which will attempt to prove it or give a counterexample.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Disclaimer&lt;/h3&gt; &#xA;&lt;p&gt;Kindly note, Horus is a tool consisting of two separate components: Horus-Checker, released under the AGPLv3 license, and Horus-Compile, released under the Cairo Toolkit License. When &#34;Horus&#34; is referenced, the reference is to the two components jointly.&lt;/p&gt; &#xA;&lt;p&gt;Horus is currently in the alpha stage and no guarantee is being given as to the accuracy and/or completeness of any of the outputs the tool may generate. The tool is provided on an &#39;as is&#39; basis, without warranties or conditions of any kind, either express or implied, including without limitation as to the outputs of the verification process and the security of any system verified using Horus. As per the relevant licenses, to the fullest extent permitted by the law, Nethermind disclaims any liability in connection with your use of Horus and/or any of its outputs.&lt;/p&gt; &#xA;&lt;p&gt;Please also note that the terminology used by Horus, including but not limited to words such as &#39;guarantee&#39;, should be interpreted strictly within the remit of formal verification terminology. These words are not intended to, and shall not be construed as having legal significance of any kind.&lt;/p&gt; &#xA;&lt;p&gt;For the avoidance of doubt, the outputs generated by Horus and/or your usage thereof shall not be considered or relied upon as any form of financial, investment, tax, legal, regulatory, or other advice.&lt;/p&gt; &#xA;&lt;p&gt;Horus-Checker is licensed under AGPLv3 (Copyright (C) 2023 Nethermind). For more information on the dependencies, please see &lt;a href=&#34;https://github.com/NethermindEth/horus-checker/raw/master/LICENSE&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Horus-Compile is licensed under the Cairo Toolkit License (Copyright (C) 2023 Nethermind), pursuant to an exception granted to Nethermind by Starkware Industries Ltd. For more information on the dependencies please see &lt;a href=&#34;https://github.com/NethermindEth/horus-compile/raw/master/LICENSE&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>