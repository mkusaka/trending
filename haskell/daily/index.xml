<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-13T01:33:20Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>utdemir/nix-tree</title>
    <updated>2022-12-13T01:33:20Z</updated>
    <id>tag:github.com,2022-12-13:/utdemir/nix-tree</id>
    <link href="https://github.com/utdemir/nix-tree" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Interactively browse dependency graphs of Nix derivations.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;nix-tree&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/utdemir/nix-tree/workflows/nix-build/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt; &lt;a href=&#34;https://repology.org/project/haskell:nix-tree/versions&#34;&gt;&lt;img src=&#34;https://repology.org/badge/vertical-allrepos/haskell:nix-tree.svg?sanitize=true&#34; alt=&#34;Packaging status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Interactively browse dependency graphs of Nix derivations.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/cnilbmPXW51g97hdNJZcM5F6h&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/cnilbmPXW51g97hdNJZcM5F6h.svg?sanitize=true&#34; alt=&#34;asciicast&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;nix-tree&lt;/code&gt; is on &lt;code&gt;nixpkgs&lt;/code&gt; since &lt;code&gt;20.09&lt;/code&gt;, so just use your preferred method for adding packages to your system, eg:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nix-env -i nix-tree&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run the current development version:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nix run github:utdemir/nix-tree -- --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ nix-tree --help&#xA;Usage: nix-tree [--version] [--derivation] [INSTALLABLE]&#xA;  Interactively browse dependency graphs of Nix derivations.&#xA;&#xA;Available options:&#xA;  --version                Show the nix-tree version.&#xA;  --derivation             Operate on the store derivation rather than its&#xA;                           outputs.&#xA;  INSTALLABLE              A store path or a flake reference. Paths default to&#xA;                           &#34;~/.nix-profile&#34; and &#34;/var/run/current-system&#34;.&#xA;  -h,--help                Show this help text&#xA;&#xA;Keybindings:&#xA;  hjkl/Arrow Keys : Navigate&#xA;  w               : Open why-depends mode&#xA;  /               : Open search mode&#xA;  s               : Change sort order&#xA;  y               : Yank selected path to clipboard&#xA;  ?               : Show help&#xA;  q/Esc           : Quit / close modal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Glossary&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;NAR Size&lt;/strong&gt;: Size of the store path itself.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Closure size&lt;/strong&gt;: Total size of the store path and all its transitive dependencies.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Added size&lt;/strong&gt;: Size of the store path, and all its &lt;em&gt;unique&lt;/em&gt; transitive dependencies. In other words, the cost of having that store path on top of all other paths. See &lt;a href=&#34;https://github.com/utdemir/nix-tree/issues/14&#34;&gt;issue #14&lt;/a&gt; for a better explanation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Tips&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;nix-build&lt;/code&gt; prints built paths to stdout, which can be piped conveniently with &lt;code&gt;| xargs -o nix-tree&lt;/code&gt;. Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Output of a local derivation&#xA;nix-build . --no-out-link | xargs -o nix-tree&#xA;&#xA;# Build time dependencies (passing a `.drv` path)&#xA;nix-instantiate -r | xargs -o nix-tree --derivation&#xA;&#xA;# Dependencies from shell.nix&#xA;nix-build shell.nix -A inputDerivation | xargs -o nix-tree&#xA;&#xA;# All outputs of a derivation in nixpkgs:&#xA;nix-build &#39;&amp;lt;nixpkgs&amp;gt;&#39; -A openssl.all --no-out-link | xargs -o nix-tree&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;nix-tree&lt;/code&gt; also supports flake references:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Build time dependencies of a flake on the current directory&#xA;nix-tree --derivation &#39;.#&#39;&#xA;&#xA;# Same thing works for any flake reference&#xA;nix-tree --derivation &#39;nixpkgs#asciiquarium&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;All contributions, issues and feature requests are welcome.&lt;/p&gt; &#xA;&lt;p&gt;To hack on it, simply run &lt;code&gt;nix-shell&lt;/code&gt; and use &lt;code&gt;cabal&lt;/code&gt; as usual. Please run &lt;code&gt;./format.sh&lt;/code&gt; before sending a PR.&lt;/p&gt; &#xA;&lt;h2&gt;Related tools&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/symphorien/nix-du&#34;&gt;nix-du&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cdepillabout/nix-query-tree-viewer&#34;&gt;nix-query-tree-viewer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/craigmbooth/nix-visualize&#34;&gt;nix-visualize&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>nasa/ogma</title>
    <updated>2022-12-13T01:33:20Z</updated>
    <id>tag:github.com,2022-12-13:/nasa/ogma</id>
    <link href="https://github.com/nasa/ogma" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;OGMA&lt;/h1&gt; &#xA;&lt;p&gt;Ogma is a tool to facilitate the integration of safe runtime monitors into other systems. Ogma extends &lt;a href=&#34;https://github.com/Copilot-Language/copilot&#34;&gt;Copilot&lt;/a&gt;, a high-level runtime verification framework that generates hard real-time C99 code.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Translating requirements defined in &lt;a href=&#34;https://github.com/NASA-SW-VnV/fret&#34;&gt;NASA&#39;s requirements elicitation tool FRET&lt;/a&gt; into corresponding monitors in Copilot.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Generating &lt;a href=&#34;https://cfs.gsfc.nasa.gov/&#34;&gt;NASA Core Flight System&lt;/a&gt; applications that use Copilot for monitoring data received from the message bus.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Generating message handlers for NASA Core Flight System applications to make external data in structs available to a Copilot monitor.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Generating the glue code necessary to work with C structs in Copilot.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/nasa/ogma/gh-pages/images/fret-to-c.gif&#34; alt=&#34;Conversion of requirements into C code&#34;&gt; &lt;br&gt; &lt;i&gt;Conversion of FRET requirements into C code.&lt;/i&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/nasa/ogma/gh-pages/images/simulator.gif&#34; alt=&#34;Monitoring within simulation video&#34;&gt; &lt;br&gt; &lt;i&gt;Integration of monitors into larger applications (e.g., simulators).&lt;/i&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#pre-requisites&#34;&gt;Pre-requisites&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#compilation&#34;&gt;Compilation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#language-transformations-fret&#34;&gt;Language Transformations: FRET&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#cfs-application-generation&#34;&gt;cFS Application Generation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#struct-interface-generation&#34;&gt;Struct Interface Generation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#contributions&#34;&gt;Contributions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Pre-requisites&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;To install Ogma from source, users must have the tools GHC and cabal-install. At this time, we recommend GHC 8.6 and a version of cabal-install between 2.4 and 3.2. (Ogma has been tested with GHC versions up to 9.2 and cabal-install versions up to 3.6, although the installation steps may vary slightly depending on the version of cabal-install being used.)&lt;/p&gt; &#xA;&lt;p&gt;On Debian or Ubuntu Linux, both can be installed with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ apt-get install ghc cabal-install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Mac, they can be installed with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ brew install ghc cabal-install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compilation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;Once GHC and cabal are installed, the simplest way to install Ogma is with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git clone https://github.com/nasa/ogma.git&#xA;$ cd ogma&#xA;$ export PATH=&#34;$HOME/.cabal/bin/:$PATH&#34;&#xA;$ cabal v1-install alex happy&#xA;$ cabal v1-install BNFC copilot&#xA;$ cabal v1-install ogma-*/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that, the &lt;code&gt;ogma&lt;/code&gt; executable will be placed in the directory &lt;code&gt;$HOME/.cabal/bin/&lt;/code&gt;, where &lt;code&gt;$HOME&lt;/code&gt; represents your user&#39;s home directory.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;The main invocation of &lt;code&gt;ogma&lt;/code&gt; with &lt;code&gt;--help&lt;/code&gt; lists sub-commands available:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ogma --help&#xA;ogma - an anything-to-Copilot application generator&#xA;&#xA;Usage: ogma COMMAND&#xA;  Generate complete or partial Copilot applications from multiple languages&#xA;&#xA;Available options:&#xA;  -h,--help                Show this help text&#xA;&#xA;Available commands:&#xA;  structs                  Generate Copilot structs from C structs&#xA;  handlers                 Generate message handlers from C structs&#xA;  cfs                      Generate a complete cFS/Copilot application&#xA;  fret-component-spec      Generate a Copilot file from a FRET Component&#xA;                           Specification&#xA;  fret-reqs-db             Generate a Copilot file from a FRET Requirements&#xA;                           Database&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Language transformations: FRET&lt;/h2&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/NASA-SW-VnV/fret&#34;&gt;FRET&lt;/a&gt; is a requirements elicitation tool created by NASA Ames Research Center. Requirements can be specified in structured natural language called FRETish, and the tool helps users understand them, validate them, and formalize them. For instructions on how to specify, analyze and export FRET requirements, see &lt;a href=&#34;https://github.com/NASA-SW-VnV/fret/raw/master/fret-electron/docs/_media/userManual.md&#34;&gt;the FRET manual&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/docs/fret.png&#34; width=&#34;75%&#34;&gt; &lt;br&gt; &lt;sup&gt;&lt;i&gt;Screenshot of requirement specified inside NASA&#39;s requirements elicitation tool FRET.&lt;/i&gt;&lt;/sup&gt; &lt;/p&gt; &#xA;&lt;p&gt;Ogma can convert specifications generated by FRET into Copilot monitors. Specifically, the commands &lt;code&gt;fret-component-spec&lt;/code&gt; and &lt;code&gt;fret-reqs-db&lt;/code&gt; allow users to interact with the different kinds of files produced by FRET.&lt;/p&gt; &#xA;&lt;p&gt;FRET files include properties encoded using Temporal Logic, both in &lt;a href=&#34;http://www.cs.cmu.edu/~modelcheck/smv.html&#34;&gt;SMV&lt;/a&gt; and in &lt;a href=&#34;https://link.springer.com/chapter/10.1007%2F978-3-319-41591-8_24&#34;&gt;CoCoSpec&lt;/a&gt;, the latter of which is an extension of Lustre. Ogma uses the SMV expressions by default, but the CLI flag &lt;code&gt;--cocospec&lt;/code&gt; can be used to select the CoCoSpec variant of requirements instead.&lt;/p&gt; &#xA;&lt;p&gt;As an example, from the following FRET requirement:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;test_component shall satisfy (input_signal &amp;lt;= 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Ogma generates the following Copilot specification:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Copilot.Compile.C99&#xA;import Copilot.Language          hiding (prop)&#xA;import Copilot.Language.Prelude&#xA;import Copilot.Library.LTL       (next)&#xA;import Copilot.Library.MTL       hiding (since, alwaysBeen, trigger)&#xA;import Copilot.Library.PTLTL     (since, previous, alwaysBeen)&#xA;import Language.Copilot          (reify)&#xA;import Prelude                   hiding ((&amp;amp;&amp;amp;), (||), (++), not, (&amp;lt;=), (&amp;gt;=), (&amp;lt;), (&amp;gt;))&#xA;&#xA;input_signal :: Stream Double&#xA;input_signal = extern &#34;input_signal&#34; Nothing&#xA;&#xA;-- | propTestCopilot_001&#xA;--   @&#xA;--   test_component shall satisfy (input_signal &amp;lt;= 5)&#xA;--   @&#xA;propTestCopilot_001 :: Stream Bool&#xA;propTestCopilot_001 = ( alwaysBeen (( ( ( input_signal &amp;lt;= 5 ) ) )) )&#xA;&#xA;-- | Complete specification. Calls the C function void  handler(); when&#xA;-- the property is violated.&#xA;spec :: Spec&#xA;spec = do&#xA;  trigger &#34;handlerpropTestCopilot_001&#34; (not propTestCopilot_001) []&#xA;&#xA;main :: IO ()&#xA;main = reify spec &amp;gt;&amp;gt;= compile &#34;fret&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This program can be compiled using Copilot to generate a &lt;code&gt;fret.c&lt;/code&gt; file that includes a hard real-time C99 implementation of the monitor. The specification generated by FRET for the FRETish requirement shown above is included with the Ogma distribution, and can be tested with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ogma fret-component-spec --cocospec --fret-file-name examples/fret-reqs-small.json &amp;gt; FretCopilot.hs&#xA;$ runhaskell FretCopilot.hs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first step executes &lt;code&gt;ogma&lt;/code&gt;, generating a Copilot monitor in a file called &lt;code&gt;FretCopilot.hs&lt;/code&gt;. The second step executes the Copilot compiler, generating a C implementation &lt;code&gt;fret.c&lt;/code&gt; and C header file &lt;code&gt;fret.h&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The resulting &lt;code&gt;fret.c&lt;/code&gt; file can be tested with the main provided in &lt;code&gt;examples/fret-reqs-small-main.c&lt;/code&gt;, which defines a handler for Copilot to call when the property monitored is violated, and a main function that steps through the execution, providing new data for the Copilot monitor:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;&#xA;double input_signal;  // Input data made available for the monitor&#xA;void step(void);      // Copilot monitor&#39;s main entry point&#xA;&#xA;void handlerpropTestCopilot_001(void) {&#xA;  printf(&#34;Monitor condition violated\n&#34;);&#xA;}&#xA;&#xA;int main (int argc, char** argv) {&#xA;  int i = 0;&#xA;&#xA;  input_signal = 0;&#xA;&#xA;  for (i=0; i&amp;lt;10; i++) {&#xA;    printf(&#34;Running step %d\n&#34;, i);&#xA;    input_signal += 1;&#xA;    step();&#xA;  }&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To compile both files, run &lt;code&gt;gcc examples/fret-reqs-small-main.c fret.c -o main&lt;/code&gt;. Executing the resulting &lt;code&gt;main&lt;/code&gt; shows that the condition is violated after a number of steps:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Running step 0&#xA;Running step 1&#xA;Running step 2&#xA;Running step 3&#xA;Running step 4&#xA;Running step 5&#xA;Monitor condition violated&#xA;Running step 6&#xA;Monitor condition violated&#xA;Running step 7&#xA;Monitor condition violated&#xA;Running step 8&#xA;Monitor condition violated&#xA;Running step 9&#xA;Monitor condition violated&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Take a peek inside the intermediate files &lt;code&gt;FretCopilot.hs&lt;/code&gt;, &lt;code&gt;fret.c&lt;/code&gt; and &lt;code&gt;fret.h&lt;/code&gt; to see what is being generated by Ogma and by Copilot.&lt;/p&gt; &#xA;&lt;p&gt;The generated C code can be integrated as part of a larger application. For example, the following shows a Copilot monitor generated from a FRET file integrated in an X-Plane widget that presents information to users during a flight in the X-Plane simulator.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/docs/xplane.png&#34; width=&#34;75%&#34;&gt; &lt;br&gt; &lt;sup&gt;&lt;i&gt;Screenshot of Copilot monitor generated by Ogma from FRET requirement, integrated into the X-Plane flight simulator. The widget on the right side of the screen presents information received and returned by the monitor, with a red/fire icon to signal that the monitor has been triggered (i.e., that the property has been violated).&lt;/i&gt;&lt;/sup&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Numeric Representations&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;FRET Component Specifications use the types &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; to represent different numeric variables. Copilot distinguishes between different numeric representations and supports multiple precisions, and so does the final C code generated from the Copilot specification.&lt;/p&gt; &#xA;&lt;p&gt;To help users generate code that works as part of a larger system without modifications, Ogma includes two additional flags to map the types &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; to specific Copilot (Haskell) types. For example, the following command would generate a Copilot specification for a hypothetical &lt;code&gt;numeric-example.json&lt;/code&gt; FRET CS file while mapping all real variables to the type &lt;code&gt;Double&lt;/code&gt; and all integer variables to the type &lt;code&gt;Int32&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ogma fret-component-spec --fret-file-name numeric-example.json --map-int-to Int32 --map-real-to Double&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the name of flexibility, Ogma does not sanitize the values of these variables and copies the types passed to these options verbatim to the generated Copilot code. It is the user&#39;s responsibility to ensure the types passed are valid Haskell types within the scope of the module generated. Note that Copilot supports only a limited subset of numeric types, which must be instances of the type class &lt;a href=&#34;https://hackage.haskell.org/package/copilot-core/docs/Copilot-Core-Type.html#t:Typed&#34;&gt;&lt;code&gt;Typed&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;cFS Application Generation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cfs.gsfc.nasa.gov/&#34;&gt;NASA Core Flight System&lt;/a&gt; (cFS) is a flight software architecture to implement complex systems by combining multiple reusable applications that communicate to one another via a software bus. cFS has been used, among others, on spacecraft, cubesats, and drones.&lt;/p&gt; &#xA;&lt;p&gt;Ogma includes multiple facilities to generate cFS applications. The cFS applications generated by Ogma perform three steps to connect Copilot monitors to the application:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Subscribe to a message in the cFS communication bus.&lt;/li&gt; &#xA; &lt;li&gt;When a message of the desired kind arrives, copy the data to make it available to Copilot and call the monitor&#39;s main entry point.&lt;/li&gt; &#xA; &lt;li&gt;Declare handlers that are executed when the property being monitored is violated.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When using this facility, Ogma produces a Copilot file that the user is expected to modify to implement the property to monitor. To avoid having to modify the generated C files that implement the cFS app itself, Ogma gives the ability to state what information one is interested in monitoring. If the kind of information is known to Ogma, it will automatically subscribe to the necessary messages and make it available to Copilot. Ogma provides additional flags to customize the list of known variables, so that projects can maintain their own variable databases beyond what Ogma includes by default.&lt;/p&gt; &#xA;&lt;p&gt;cFS applications are generated using the Ogma command &lt;code&gt;cfs&lt;/code&gt;, which receives three main arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--app-target-dir DIR&lt;/code&gt;: location where the cFS application files must be stored.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--variable-file FILENAME&lt;/code&gt;: a file containing a list of variables that must be made available to the monitor.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--variable-db FILENAME&lt;/code&gt;: a file containing a database of known variables, and the message they are included with.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following execution generates an initial cFS application for runtime monitoring using Copilot:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ogma cfs --variable-db examples/cfs-variable-db --variable-file examples/cfs-variables&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The application generated by Ogma contains the following files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;copilot-cfs-demo/CMakeLists.txt&#xA;copilot-cfs-demo/fsw/for_build/Makefile&#xA;copilot-cfs-demo/fsw/mission_inc/copilot_cfs_perfids.h&#xA;copilot-cfs-demo/fsw/platform_inc/copilot_cfs_msgids.h&#xA;copilot-cfs-demo/fsw/src/copilot_cfs.c&#xA;copilot-cfs-demo/fsw/src/Properties.hs&#xA;copilot-cfs-demo/fsw/src/copilot_cfs_msg.h&#xA;copilot-cfs-demo/fsw/src/copilot_cfs_events.h&#xA;copilot-cfs-demo/fsw/src/copilot_cfs_version.h&#xA;copilot-cfs-demo/fsw/src/copilot_cfs.h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Users are expected to modify &lt;code&gt;Properties.hs&lt;/code&gt; to adjust the property being monitored. Although it is possible to adjust the file &lt;code&gt;copilot_cfs.c&lt;/code&gt; to include property violation handlers, we recommend adding them in a separate C file and modifying the compilation scripts to include that additional file. That way, invoking Ogma again will not overwrite the changes made to the cFS application.&lt;/p&gt; &#xA;&lt;p&gt;In this particular example, the C code generated contains the following instruction to subscribe to an &lt;code&gt;ICAROUS_POSITION_MID&lt;/code&gt; message to obtain the vehicle position:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    CFE_SB_Subscribe(ICAROUS_POSITION_MID, COPILOT_CommandPipe);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The message dispatcher included in the application detects a message of this kind and calls a dedicated subroutine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void COPILOT_ProcessCommandPacket(void)&#xA;{&#xA;    CFE_SB_MsgId_t  MsgId;&#xA;&#xA;    MsgId = CFE_SB_GetMsgId(COPILOTMsgPtr);&#xA;&#xA;    switch (MsgId)&#xA;    {&#xA;        case ICAROUS_POSITION_MID:&#xA;            COPILOT_ProcessIcarousPosition();&#xA;            break;&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, the dedicated subroutine makes data available to the monitor and calls the main Copilot entry point &lt;code&gt;step&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void COPILOT_ProcessIcarousPosition(void)&#xA;{&#xA;    position_t* msg;&#xA;    msg = (position_t*) COPILOTMsgPtr;&#xA;    position = *msg;&#xA;    step();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Struct Interface Generation&lt;/h2&gt; &#xA;&lt;p&gt;A lot of the information that must be monitored in real-world C applications is packed in structs. Copilot allows accessing specific fields of C structs, but requires additional definitions in the Copilot language to make the shape of those structs known to the compiler.&lt;/p&gt; &#xA;&lt;p&gt;Ogma is able to generate the boilerplate code needed to work with C structs in Copilot. For example, to use the following struct as the type of an extern stream in Copilot, the user is expected to define several Copilot (Haskell) types and type class instances:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct {&#xA;   double x;&#xA;   double y;&#xA;} point;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Ogma can generate that code automatically with the &lt;code&gt;structs&lt;/code&gt; subcommand:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;$ ogma structs --header-file-name examples/point.h&#xA;data Point = Point&#xA;  { pX :: Field &#34;x&#34; Double&#xA;  , pY :: Field &#34;y&#34; Double&#xA;  }&#xA;&#xA;instance Struct Point where&#xA;  typename _ = &#34;point&#34;&#xA;  toValues v = [ Value Double (pX v), Value Double (pY v) ]&#xA;&#xA;instance Typed Point where&#xA;  typeOf = Struct (Point (Field 0) (Field 0))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By including these definitions in a Copilot file, users can now access the individual &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; fields of a &lt;code&gt;Point&lt;/code&gt; in a stream.&lt;/p&gt; &#xA;&lt;h1&gt;Contributions&lt;/h1&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;The best way to contribute to Ogma is to report any issues you find via the issue tracker, and to use Ogma to build applications or in your own research and let us know about your results.&lt;/p&gt; &#xA;&lt;p&gt;We kindly ask users not to send PRs to this project. Instead, please document the bugs you find or other suggestions as issues and we will make the necessary changes.&lt;/p&gt; &#xA;&lt;h1&gt;Acknowledgements&lt;/h1&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ogma has been created by Ivan Perez and Alwyn Goodloe.&lt;/p&gt; &#xA;&lt;p&gt;The Ogma team would like to thank Dimitra Giannakopoulou, Anastasia Mavridou, and Thomas Pressburger, from the FRET Team at NASA Ames, for the continued input during the development of Ogma.&lt;/p&gt; &#xA;&lt;p&gt;We would also like to thank Cesar Munoz and Swee Balachandran, for their help with the cFS backend.&lt;/p&gt; &#xA;&lt;p&gt;X-Plane images obtained via the X-Plane 10 (Pro) flight simulator. Re-shared with permission.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nasa/ogma/develop/#table-of-contents&#34;&gt;(Back to top)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;Copyright 2020-2021 United States Government as represented by the Administrator of the National Aeronautics and Space Administration. All Rights Reserved.&lt;/p&gt; &#xA;&lt;p&gt;See the file LICENSE.pdf for details.&lt;/p&gt;</summary>
  </entry>
</feed>