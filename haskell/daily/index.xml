<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-05T01:35:37Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ftufek/HackageUI</title>
    <updated>2023-03-05T01:35:37Z</updated>
    <id>tag:github.com,2023-03-05:/ftufek/HackageUI</id>
    <link href="https://github.com/ftufek/HackageUI" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;HackageUI&lt;/h1&gt; &#xA;&lt;p&gt;Some improvements on the original HackageDB. You can see the demo at &lt;a href=&#34;http://ftufek.github.com/HackageUI/&#34;&gt;http://ftufek.github.com/HackageUI/&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>phulin/symbolic-trace</title>
    <updated>2023-03-05T01:35:37Z</updated>
    <id>tag:github.com,2023-03-05:/phulin/symbolic-trace</id>
    <link href="https://github.com/phulin/symbolic-trace" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Symbolic execution of LLVM IR traces for program understanding.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;RESET&lt;/h1&gt; &#xA;&lt;p&gt;Reverse Engineering through Symbolic Execution of Traces: Symbolic execution of LLVM IR traces for program understanding.&lt;/p&gt; &#xA;&lt;p&gt;To evaluate a trace, first run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal configure&#xA;cabal build --ghc-options=&#34;-rtsopts&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, to run a program, grab a trace&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dist/build/Eval/Eval -q &amp;lt;qemu_build_dir&amp;gt; &amp;lt;program&amp;gt; &amp;lt;program-args&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The qemu_build_dir should be the build directory, such as ~/qemu/x86_64-linux-user.&lt;/p&gt; &#xA;&lt;p&gt;For a trace in whole-system mode, you need to gather the trace manually. First, make a PANDA record/replay recording of the execution you want to look at. Next, use Volatility or a similar tool to find the CR3 you&#39;re looking for, and then run a command like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;echo &#34;begin_replay &amp;lt;recording&amp;gt;&#34; | ~/qemu/i386-softmmu/qemu-system-i386 -panda-plugin ~/qemu/i386-softmmu/panda_plugins/panda_llvm_trace.so -panda-arg llvm_trace:cr3=0xDEADBEEF -monitor stdio ~/win7.1.qcows2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;followed by&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dist/build/Eval/Eval&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can do &lt;code&gt;Eval --help&lt;/code&gt; to see a list of command line options. By default, PANDA stores trace information in &lt;code&gt;/tmp&lt;/code&gt;; if you want to change this, use &lt;code&gt;Eval -d&lt;/code&gt; and &lt;code&gt;qemu -panda-arg llvm_trace:base=/other/dir&lt;/code&gt;. Eval will also probably run out stack space; increase that by adding the arguments &lt;code&gt;+RTS -K1G -RTS&lt;/code&gt;, where the 1G specifies 1 GB of stack space.&lt;/p&gt; &#xA;&lt;p&gt;This will start a server that accepts JSON requests for symbolic execution data from the RESET IDA plugin (github.com/phulin/RESETPlugin)&lt;/p&gt; &#xA;&lt;h1&gt;Files&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;types/&lt;/code&gt;: Definitions of basic types. This is in a separate Cabal package due to GHC bug #3333 - you can&#39;t have Template Haskell code in a package that links to C++ code. We use TH for the JSON parsing; aeson provides a nice auto-serialization interface.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AppList.hs&lt;/code&gt;: Definition of a linked list type which is optimized for appending; we use this instead of normal List for pretty much everything.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Memlog.hs&lt;/code&gt;: Functions for parsing and processing the Panda dynamic log&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Instances.hs&lt;/code&gt;: Miscellanous instances of Show, mostly for debugging&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Options.hs&lt;/code&gt;: Definition and parsing of command-line arguments.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Pretty.hs&lt;/code&gt;: The Pretty class for pretty-printing; probably could be done in a much nicer way&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Expr.hs&lt;/code&gt;: Operations for working with our expression format&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Eval.hs&lt;/code&gt;: Main functions - meat of the symbolic evaluation engine&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Main.hs&lt;/code&gt;: Server code and command-line argument processing, etc&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>