<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-16T01:36:08Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>joar/hs-hitchhiker</title>
    <updated>2023-02-16T01:36:08Z</updated>
    <id>tag:github.com,2023-02-16:/joar/hs-hitchhiker</id>
    <link href="https://github.com/joar/hs-hitchhiker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Working copy for my progress on http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>deepflowinc/guardian</title>
    <updated>2023-02-16T01:36:08Z</updated>
    <id>tag:github.com,2023-02-16:/deepflowinc/guardian</id>
    <link href="https://github.com/deepflowinc/guardian" rel="alternate"></link>
    <summary type="html">&lt;p&gt;guardian - the border guardian for your Haskell monorepo package dependencies&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;guardian - The border guardian for your package dependencies&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#introduction---how-to-keep-your-haskell-monorepo-sane&#34;&gt;Introduction - How to keep your Haskell monorepo sane&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#dependency-inversion-principle&#34;&gt;Dependency Inversion Principle&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#the-emergence-of-guardian---package-dependency-domain-isolation-in-practice&#34;&gt;The emergence of Guardian - package dependency domain isolation in practice&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#summary&#34;&gt;Summary&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#actual-validation-logic&#34;&gt;Actual validation logic&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#syntax-of-dependency-domainsyaml&#34;&gt;Syntax of &lt;code&gt;dependency-domains.yaml&lt;/code&gt;&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#domain-definition&#34;&gt;Domain Definition&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#component-section&#34;&gt;Component Section&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#cabal-specific-settings&#34;&gt;Cabal specific settings&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#stack-specific-settings&#34;&gt;Stack specific settings&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#example-configuration&#34;&gt;Example Configuration&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#github-actions&#34;&gt;GitHub Actions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#contribution&#34;&gt;Contribution&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#copyright&#34;&gt;Copyright&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction - How to keep your Haskell monorepo sane&lt;/h2&gt; &#xA;&lt;p&gt;Maintaining a large monorepo consisting of dozens of Haskell packages is not easy. Sometimes, just making sure all packages compile on CI is not enough - to accelerate the development cycle, it is crucial to ensure that changes to the codebase trigger only necessary rebuilds as far as possible.&lt;/p&gt; &#xA;&lt;p&gt;But enforcing this requirement by hand is not easy. To make things work, a kind of people known as programmers - especially Haskellers, you know - are inherently lazy. They are so lazy to grep through the project, shouting out &#34;look, there is what we want!&#34;, and adding extra dependency - finally they make everything depend on each other and constitute the gigantic net of dependencies that takes a quarter day even if only a small portion of the code was changed.&lt;/p&gt; &#xA;&lt;p&gt;Indeed, this was exactly the situation we developers at DeepFlow faced in 2021. Our main product is a high-performance numeric solver[^1], consisting of ~70 Haskell packages, which sums up to ~150k lines of code. It includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;abstraction of numeric computation backend,&lt;/li&gt; &#xA; &lt;li&gt;its concrete implemenatations,&lt;/li&gt; &#xA; &lt;li&gt;abstraction of plugins to extend solvers,&lt;/li&gt; &#xA; &lt;li&gt;its concrete implementations,&lt;/li&gt; &#xA; &lt;li&gt;abstraction of equation system,&lt;/li&gt; &#xA; &lt;li&gt;its concrete implementations,&lt;/li&gt; &#xA; &lt;li&gt;abstraction of communication strategies,&lt;/li&gt; &#xA; &lt;li&gt;its concrete implementations (e.g. MPI, standalone),&lt;/li&gt; &#xA; &lt;li&gt;abstract solver logic, and&lt;/li&gt; &#xA; &lt;li&gt;concrete solver implementations putting these all together.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;What we had in 2021 was the chaotic melting pot of these players. If one changes a single line of a backend, it forces seemingly unrelated plugins to be recompiled. If one removes a single redundant instance, then it miraculously triggers the rebuild in some concrete implementation of some specialised solver. In any case, it took at most six hours and ~100 GiB to complete, as we make heavy use of type-level hackery and rely on the aggressive optimisation mechanism of GHC[^2].&lt;/p&gt; &#xA;&lt;p&gt;This situation is far from optimal, sacrifices developer experience, and severely slows down the iteration speed. Our product seems dying slowly but surely.&lt;/p&gt; &#xA;&lt;p&gt;[^1]: For those who are curious, please read our &lt;a href=&#34;https://speakerdeck.com/konn/da-gui-mo-shu-zhi-ji-suan-wozhi-eru-haskell-nil-nil-pragmatic-haskell-in-large-scale-numerical-computation-nil-nil&#34;&gt;old slide&lt;/a&gt; - it is an old presentation, so some details are outdated, but the overall situation is not so different. [^2]: The situation, however, gets better as newer GHC releases came out and we refactor the code structure. Nowadays, it takes at most two and a half hours and only ~20GiB. The detail of such change is out of the scope of this article.&lt;/p&gt; &#xA;&lt;h3&gt;Dependency Inversion Principle&lt;/h3&gt; &#xA;&lt;p&gt;In the middle of 2021, we decided to fight against this situation to save our project. Our rule of thumb here was &lt;em&gt;Dependency Inversion Principle&lt;/em&gt; from the realm of OOP. That says:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;ol&gt; &#xA;  &lt;li&gt;High-level modules should not import anything from low-level modules. Both should depend on abstractions&lt;/li&gt; &#xA;  &lt;li&gt;Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.&lt;/li&gt; &#xA; &lt;/ol&gt; &#xA; &lt;p&gt;(&lt;em&gt;excerpt from &lt;a href=&#34;https://en.wikipedia.org/wiki/Dependency_inversion_principle&#34;&gt;Wikipedia&lt;/a&gt;; renumbering is due to the author&lt;/em&gt;)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This is called dependency &lt;em&gt;inversion&lt;/em&gt; because it seems inverse to the traditional usage of inheritance in OOP. We decided to apply this principle to package dependencies.&lt;/p&gt; &#xA;&lt;p&gt;We divided the packages into several groups, called &lt;em&gt;dependency domains&lt;/em&gt;. We drew the term and intuition from the &lt;a href=&#34;https://github.blog/2021-09-27-partitioning-githubs-relational-databases-scale/&#34;&gt;blog post by GitHub about partitioning databases into domains&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Our packages are divided into the following groups[^3]:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;infra&lt;/code&gt;: providing common infrastructure, such as data containers and algorithms.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;highlevel&lt;/code&gt;: high-level abstractions of backends, equations, and plugins.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lowlevel&lt;/code&gt;: low-level and concrete implementations.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;plugin&lt;/code&gt;: concrete plugin implementations&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;solver&lt;/code&gt;: concrete solver implementations.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tool&lt;/code&gt;: misc utility apps independent of solvers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;test&lt;/code&gt;: test packages, mainly providing cross-package integration tests.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Any package in monorepo must be classified into exactly one dependency domain. Furthermore, we define constraints on the dependencies between domains: each domain is given the set of domains on which its members can (transitively) depend, and the induced dependency graph must form a directed acyclic graph.&lt;/p&gt; &#xA;&lt;p&gt;The example is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart TD&#xA;  test[test] --&amp;gt; solver[solver];&#xA;  test --&amp;gt; tool[tool];&#xA;  highlevel[highlevel] --&amp;gt; infra[infra];&#xA;  plugin[plugin] --&amp;gt; highlevel;&#xA;  lowlevel[lowlevel] --&amp;gt; infra;&#xA;  solver[solver] --&amp;gt; highlevel;&#xA;  solver --&amp;gt; lowlevel;&#xA;  solver --&amp;gt; plugin;&#xA;  tool --&amp;gt; lowlevel;&#xA;  tool --&amp;gt; plugin;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each package of a domain can depend only on the packages in the same or downstream package in the diagram. Note that, in this setting, high-level (or abstract) packages can only depend on another abstraction or infrastructure package and only the application packages (say, &lt;code&gt;solver&lt;/code&gt; and `tool) can depend both on abstractions and implementations.&lt;/p&gt; &#xA;&lt;p&gt;[^3]: These are not exactly what we have in reality but in simplified form.&lt;/p&gt; &#xA;&lt;h3&gt;The emergence of Guardian - package dependency domain isolation in practice&lt;/h3&gt; &#xA;&lt;p&gt;So far, so good. Now that we have the grand picture of the package dependency hierarchy, it is time to make things laid out.&lt;/p&gt; &#xA;&lt;p&gt;The problem is: enforcing such an invariant by hand is almost impossible as the number of packages gets larger and larger. Even after we sorted out where the violation occurred, it takes much time to fix them all up while continuing to add new features and fix bugs. Furthermore, even if we had worked out things once somehow, our laziness could strike back to slowly violate such constraints and make everything rotten again. Uh-oh.&lt;/p&gt; &#xA;&lt;p&gt;... Not really. Here, our brave &lt;code&gt;guardian&lt;/code&gt; can help us!&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Guardian&lt;/code&gt; is a tool designed for this purpose and developed in DeepFlow. We are running &lt;code&gt;guardian&lt;/code&gt; on our CI for almost two years.&lt;/p&gt; &#xA;&lt;p&gt;In guardian, we declare the whole dependency constraints in &lt;code&gt;dependency-domains.yaml&lt;/code&gt;. The above constraints are expressed as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;domains:&#xA;  infra: &#xA;    depends_on: []&#xA;    packages:&#xA;    - algorithms&#xA;    - geometry&#xA;    - linalgs&#xA;  highlevel: &#xA;    packages:&#xA;    - numeric-backends&#xA;    - plugin-base&#xA;    - equation-class&#xA;    depends_on: [infra]&#xA;  lowlevel:&#xA;    packages:&#xA;    - reference-backend&#xA;    - fast-backend&#xA;    - mesh-format&#xA;    depends_on: [infra]&#xA;  plugin:&#xA;    packages:&#xA;    - plugin-A&#xA;    - plugin-B&#xA;    depends_on: [highlevel]&#xA;  solver:&#xA;    packages:&#xA;    - solver-standalone&#xA;    - solver-parallel&#xA;    depends_on: [plugin, lowlevel, highlevel]&#xA;  tool:&#xA;    packages:&#xA;    - post&#xA;    - pre&#xA;    depends_on: [plugin, lowlevel]&#xA;  test:&#xA;    packages:&#xA;    - integration-tests&#xA;    - regression-tests&#xA;    depends_on: [solver, tool]&#xA;&#xA;# We track dependencies in test &amp;amp; benchmark components as well.&#xA;components:&#xA;  tests: true&#xA;  benchmarks: false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we don&#39;t have to include &lt;code&gt;highlevel&lt;/code&gt; into the dependencies of &lt;code&gt;solver&lt;/code&gt; - it is already introduced via dependency on &lt;code&gt;plugin&lt;/code&gt;. Here, we include &lt;code&gt;highlevel&lt;/code&gt; just for documentation.&lt;/p&gt; &#xA;&lt;p&gt;Actually, this is not the first rule we had. As mentioned above, our codebase consists of ~70 packages summing up to ~150k lines of code. In some cases, it takes much effort to remove dependency violating the dependency domain boundary without sacrificing performance.&lt;/p&gt; &#xA;&lt;p&gt;To accommodate such cases, &lt;code&gt;guradian&lt;/code&gt; provides &lt;em&gt;exception rules&lt;/em&gt; for compromise. It looks like this[^4]:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;...&#xA;  plugin:&#xA;    packages:&#xA;    - package: plugin-A&#xA;      exception:&#xA;        depends_on:&#xA;        - lowlevel&#xA;        - package: fast-backend&#xA;    - plugin-B&#xA;    depends_on: [highlevel]&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As shown above, exception rules are specified per-package manner. It can allow dependencies to other dependency domains and/or individual package which is otherwise banned. An exception rule doesn&#39;t affect the transitive dependency - only the dependencies of the specified package are exempted. In the above example, only &lt;code&gt;plugin-A&lt;/code&gt; is allowed to depend on the exempted targets. So, if &lt;code&gt;plugin-B&lt;/code&gt; depends on &lt;code&gt;plugin-A&lt;/code&gt;, it cannot depend on &lt;code&gt;fast-backend&lt;/code&gt; package explicitly.&lt;/p&gt; &#xA;&lt;p&gt;The point is that exception rules must be considered as tentative compromises - they must be removed at some points to enforce dependency inversion at the package level to keep the entire project healthy. To make it clear, &lt;code&gt;guardian&lt;/code&gt; will emit warnings when the exception rules are used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;[info] Using configuration: dependency-domains.yaml&#xA;[info] Checking dependency of /path/to/project/&#34; with backend Cabal&#xA;[warn] ------------------------------&#xA;[warn] * Following exceptional rules are used:&#xA;[warn]     - &#34;A2&#34; depends on: PackageDep &#34;B1&#34;&#xA;[info] ------------------------------&#xA;[info] All dependency boundary is good, with some additional warning.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And when the situation allows some rules to be lifted, it also tells us as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;[warn] * 1 redundant exceptional dependency(s) found:&#xA;[warn]     - &#34;A2&#34; doesn&#39;t depends on: PackageDep &#34;B1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So, what &lt;code&gt;guardian&lt;/code&gt; would do is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Check if all the packages are disjointly classified into dependency domains.&lt;/li&gt; &#xA; &lt;li&gt;Makes sure that the dependency graph between each domain forms a DAG.&lt;/li&gt; &#xA; &lt;li&gt;Check if all the dependency constraint is met, except for prescribed exceptions.&lt;/li&gt; &#xA; &lt;li&gt;Report the validation results with information about used/redundant exception rules.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;One thing to note is that &lt;code&gt;guardian&lt;/code&gt; checks dependency constraints based solely on the dependencies specified in &lt;code&gt;*.cabal&lt;/code&gt; and/or &lt;code&gt;package.yaml&lt;/code&gt; file. In other words, guardian doesn&#39;t treat a dependency introduced by module imports. This is because such a dependency is already handled by the compiler.&lt;/p&gt; &#xA;&lt;p&gt;In our case, we had two exception rules enabled at first and it took almost half a year to finally abolish all of the exception rules. This was finally done when the major rework on the entire structure of our product. Indeed, one of the motivations of the refactoring was to completely deprecate the exception rules and the overall dependency graph above was the driving force to make out the correct design of the entire package structure. In this way, the presence of exception rules in the dependency boundary constraints signals the design flaw in the package hierarchy and gives us a useful guideline for a redesign.&lt;/p&gt; &#xA;&lt;p&gt;The benefit of dependency constraint enforcement by guardian is not limited to refactoring. Running &lt;code&gt;guardian&lt;/code&gt; on CI, one can always check the sanity of the entire structure when adding new features/packages to the monorepo. When one adds new packages to the monorepo, guardian force us to think in which domain to put them. If we accidentally add package dependencies violating constraints in the midway of adding new features, guardian will tell us it generously. In this way, guardian helps the product evolve healthily while preventing getting rotten.&lt;/p&gt; &#xA;&lt;p&gt;[^4]: As package &lt;code&gt;fast-backend&lt;/code&gt; is already included in &lt;code&gt;lowlevel&lt;/code&gt; domain, we don&#39;t have to include &lt;code&gt;fast-backend&lt;/code&gt; as a separate exception rule. Here, we included it for the exposition.&lt;/p&gt; &#xA;&lt;h3&gt;Summary&lt;/h3&gt; &#xA;&lt;p&gt;With guardian, you can:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;divide monorepo packages into disjoint groups called &lt;em&gt;dependency domains&lt;/em&gt;,&lt;/li&gt; &#xA; &lt;li&gt;define the topology of DAG of dependency domains to secure dependency boundaries,&lt;/li&gt; &#xA; &lt;li&gt;you can still specify exception rules for compromise - they will be warned so that you can finally remove it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Equipped with these features, we can:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Keep the package hierarchy of the monorepo clean and loose-coupled.&lt;/li&gt; &#xA; &lt;li&gt;Be more careful when adding new packages/features as guardian shouts at us when violations are found.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There are several possibilities in the design of actual DAG of domains, we recommend the following rules:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Separate abstractions and concrete implementations as far as possible. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Ideally, applications and/or tests can depend on both.&lt;/li&gt; &#xA;   &lt;li&gt;Keep DIP in mind: Abstractions SHOULD NOT depend on implementations. Implementation should depend on abstractions.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Refine domains based on semantics/purposes.&lt;/li&gt; &#xA; &lt;li&gt;Use dependency domain constraints as a guideline for the design of the overall monorepo. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;It guides us in making out the &#34;correct&#34; place to put new packages/features.&lt;/li&gt; &#xA;   &lt;li&gt;The number of exception rules indicates the code smell.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can download prebuilt binaries for macOS and Linux from &lt;a href=&#34;https://github.com/deepflowinc/guardian/releases/latest&#34;&gt;Release&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also use &lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#github-actions&#34;&gt;GitHub Action&lt;/a&gt; in your CI.&lt;/p&gt; &#xA;&lt;p&gt;To build from source, we recommend using &lt;code&gt;cabal-install &amp;gt;= 3.8&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone git@github.com/deepflowinc/guardian.git&#xA;cd guardian&#xA;cabal install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;guardian (auto|stack|cabal) [-c|--config PATH] [DIR]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Subcommand &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;stack&lt;/code&gt;, &lt;code&gt;cabal&lt;/code&gt; specifies the &lt;em&gt;adapter&lt;/em&gt;, i.e. build-system, to compute dependency.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;stack&lt;/code&gt;: uses Stack (&amp;gt;= 2.9) as an adapter.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cabal&lt;/code&gt;: uses cabal-install (&amp;gt;= 3.8) as an adapter.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;auto&lt;/code&gt;: determines adapter based on the directory contents and guardian configuration. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If exactly one of &lt;code&gt;cabal.project&lt;/code&gt; or &lt;code&gt;stack.yaml&lt;/code&gt; is found, use the corresponding build system as an adapter.&lt;/li&gt; &#xA;   &lt;li&gt;If exactly one of the custom config sections (say, &lt;code&gt;cabal:&lt;/code&gt; or &lt;code&gt;stack:&lt;/code&gt;) is found in the config file, use the corresponding build system.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;guardian&lt;/code&gt; links directly to &lt;code&gt;stack&lt;/code&gt; and &lt;code&gt;cabal-install&lt;/code&gt;, so you don&#39;t need those binaries. Make sure the project configuration is compatible with the above version constraint.&lt;/p&gt; &#xA;&lt;p&gt;Optional argument &lt;code&gt;DIR&lt;/code&gt; specifies the project root directory to check. If omitted, the current working directory is used.&lt;/p&gt; &#xA;&lt;p&gt;The option &lt;code&gt;--config&lt;/code&gt; (or &lt;code&gt;-c&lt;/code&gt; for short) specifies the path of the guardian configuration file relative to the project root. If omitted, &lt;code&gt;dependency-domains.yaml&lt;/code&gt; is used.&lt;/p&gt; &#xA;&lt;h3&gt;Actual validation logic&lt;/h3&gt; &#xA;&lt;p&gt;When invoked, guardian will check in these steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Defines a dependency graph based on the package dependencies.&lt;/li&gt; &#xA; &lt;li&gt;Checks if the graph forms DAG.&lt;/li&gt; &#xA; &lt;li&gt;Checks if the dependency domain constraints are satisfied first ignoring exception rules.&lt;/li&gt; &#xA; &lt;li&gt;If violating dependency is detected, exempt it if it is covered by any exception rule. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If any exception rule can be used, warn of its use; otherwise, report it as an error.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Report results, warning about used and redundant exception rules.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Syntax of &lt;code&gt;dependency-domains.yaml&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Guardian configuration file consists of the following top-level sections:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Section&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;domains&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Required&lt;/strong&gt;. Definition of Dependency Domains (see &lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#domain-definition&#34;&gt;Domain Definition&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;components&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Optional&lt;/em&gt;. Configuration whether track test/benchmark dependencies as well (see &lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#component-section&#34;&gt;Component Section&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;cabal&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Optional&lt;/em&gt;. Cabal-specific configurations. (see &lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#cabal-specific-settings&#34;&gt;Cabal specific settings&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Optional&lt;/em&gt;. Stack-specific configurations. (see &lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#stack-specific-settings&#34;&gt;stack specific settings&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The ordering of sections is irrelevant.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/#example-configuration&#34;&gt;Example Configuration&lt;/a&gt; for a complete example.&lt;/p&gt; &#xA;&lt;h4&gt;Domain Definition&lt;/h4&gt; &#xA;&lt;p&gt;Dependency domains, their members, and constraints are specified in the &lt;code&gt;domains&lt;/code&gt; section.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;domains&lt;/code&gt; section must be a dictionary associating each domain label to the domain definition. A domain label must match &lt;code&gt;/[A-Za-z0-9-_]+/&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Individual domain definition object has the following fields:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Field&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;depends_on&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;[String]&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Required&lt;/strong&gt;. Labels of the other domains that the dependency being defined is depending on.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;packages&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Package&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Required&lt;/strong&gt;. A list of packages of the domain. Each package can be a string or object; see below for detail&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;description&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Maybe String&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Optional&lt;/em&gt;. A human-readable description of the domain. Note that this field is not processed by guardian.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Package entry occurring in the &lt;code&gt;packages&lt;/code&gt; field can either be a string or package object. A single string, e.g. &lt;code&gt;mypackage&lt;/code&gt; is interpreted as a package object with only the &lt;code&gt;package&lt;/code&gt; field specified, e.g. &lt;code&gt;{package: &#34;mypackage&#34;}&lt;/code&gt;. Package object has the following field:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Field&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;package&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;String&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Required&lt;/strong&gt;. Package name&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;exception&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ExceptionRule&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Optional&lt;/em&gt;. Package-specific exception rules&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Exception rule object is an object of form &lt;code&gt;{depends_on: &amp;lt;an array of ExceptionItem&#39;s&amp;gt;]}&lt;/code&gt;. Exception item can be either a simple string or an object of form &lt;code&gt;{package: &#34;package-name&#34;}&lt;/code&gt;. A single string as an exception rule is interpreted as a dependency on the domain with having the string itself as the label. An object &lt;code&gt;{package: &#34;package-name&#34;}&lt;/code&gt; is interpreted as a dependency on the package &lt;code&gt;package-name&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;domains:&#xA;  A: &#xA;    depends_on: [C]&#xA;    packages: &#xA;    - A1&#xA;    - package: A2&#xA;      exception: {depends_on: [package: B1]}&#xA;  B: &#xA;    packages: [B1]&#xA;    depends_on: [C]&#xA;  C: &#xA;    packages: [C]&#xA;    depends_on: []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above example, packages are divided into three domains: &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;. Apart from the packages in the same domain, packages in domains &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; can depend on those in &lt;code&gt;C&lt;/code&gt;. Exception rule is specified for package &lt;code&gt;A2&lt;/code&gt; in domain &lt;code&gt;A&lt;/code&gt;, which allows &lt;code&gt;A2&lt;/code&gt; to directly depend on package &lt;code&gt;B1&lt;/code&gt;. Even if &lt;code&gt;A1&lt;/code&gt; depends on &lt;code&gt;A2&lt;/code&gt;, &lt;code&gt;A1&lt;/code&gt; cannot depend on it directly - this is how exception rules work.&lt;/p&gt; &#xA;&lt;h4&gt;Component Section&lt;/h4&gt; &#xA;&lt;p&gt;Sometimes, one wants to exclude special components such as tests or benchmarks from dependency tracking. The &lt;code&gt;component&lt;/code&gt; section is exactly for this purpose. It consists of the following optional fields:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Field&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;tests&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Optional&lt;/em&gt;. If &lt;code&gt;true&lt;/code&gt;, tracks tests (default: &lt;code&gt;true&lt;/code&gt;).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;benchmarks&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Optional&lt;/em&gt;. If &lt;code&gt;true&lt;/code&gt;, tracks benchmarks (default: &lt;code&gt;true&lt;/code&gt;).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The &lt;code&gt;component&lt;/code&gt; section itself can be omitted - in such cases, all the tests and benchmarks will be tracked for dependency.&lt;/p&gt; &#xA;&lt;h4&gt;Cabal specific settings&lt;/h4&gt; &#xA;&lt;p&gt;Configurations specified to &lt;code&gt;cabal-install&lt;/code&gt; backend can be specified in &lt;code&gt;cabal&lt;/code&gt; top-level section.&lt;/p&gt; &#xA;&lt;p&gt;It has the following fields:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Field&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;projectFile&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;FilePath&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Optional&lt;/em&gt;. The path of the cabal project file relative to the project root (default: &lt;code&gt;cabal.project&lt;/code&gt;).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;update&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Bool&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Optional&lt;/em&gt;. If &lt;code&gt;true&lt;/code&gt;, run (the equivalent of) &lt;code&gt;cabal update&lt;/code&gt; before dependency checking. If a non-empty string is given, it will be treated as an &lt;code&gt;index-state&lt;/code&gt; string and passed to the &lt;code&gt;update&lt;/code&gt; command. (default: &lt;code&gt;false&lt;/code&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cabal:&#xA;  projectFile: cabal-custom.project&#xA;  update: true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example with index-state:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cabal:&#xA;  projectFile: cabal-custom.project&#xA;  update: &#34;hackage.haskell.org,2023-02-03T00:00:00Z&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Stack specific settings&lt;/h4&gt; &#xA;&lt;p&gt;Stack-specific options are specified in the &lt;code&gt;stack&lt;/code&gt; top-level section. For the time being, it only has the &lt;code&gt;options&lt;/code&gt; field, which is a possibly empty list of options to be passed to the &lt;code&gt;stack&lt;/code&gt; command. It can be used, for example, to specify the custom &lt;code&gt;stack.yaml&lt;/code&gt; file as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;stack:&#xA;  options: &#xA;  - &#34;--stack-yaml=stack-test.yaml&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the &lt;code&gt;stack&lt;/code&gt; section is omitted, the &lt;code&gt;options&lt;/code&gt; will be treated as empty.&lt;/p&gt; &#xA;&lt;h4&gt;Example Configuration&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;components: # Specifies whether track test/benchmark dependencies as well:&#xA;  tests: true&#xA;  benchmarks: false&#xA;&#xA;domains:&#xA;  domain-A:&#xA;    depends_on:&#xA;    - common&#xA;    # Domain CANNOT depend on a separate package directly!&#xA;    # - package: B3 # Error!&#xA;    packages:&#xA;    - A1&#xA;    - A2&#xA;    - package: A3&#xA;      exception: # Exception rules for a particular package.&#xA;        depends_on:&#xA;        - C # domain name if a plain string&#xA;        - package: B3 # You can specify a single package name ONLY in package rule.&#xA;  domain-B:&#xA;    depends_on:&#xA;    - common&#xA;    packages:&#xA;    - B1&#xA;    - B2&#xA;    - B3&#xA;  C:&#xA;    depends_on:&#xA;    - common&#xA;    packages:&#xA;    - C1&#xA;  common:&#xA;    depends_on: [] # You MUST specify empty dependency explicitly.&#xA;    packages: &#xA;    - mybase&#xA;    - urbase&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;GitHub Actions&lt;/h2&gt; &#xA;&lt;p&gt;Guardian provides a GitHub Action that can be used in GitHub Workflow.&lt;/p&gt; &#xA;&lt;p&gt;Prerequisites:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;OS running the action must be either Linux or macOS with the following executables in PATH: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;sha256sum&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;tar&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;curl&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;jq&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;If you are using the Cabal backend and &lt;code&gt;with-compiler&lt;/code&gt; is specified explicitly, the corresponding version of GHC must be in the PATH.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example workflow:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  check-dependecy-boundary:&#xA;    name: Checks Dependency Constraint&#xA;    runs-on: ubuntu-20.04&#xA;    continue-on-error: true&#xA;    steps:&#xA;      - uses: actions/checkout@v3&#xA;      - uses: haskell/actions/setup@v2&#xA;        with:&#xA;          ghc-version: 9.0.2  # Install needed version of ghc&#xA;      - uses: deepflowinc/guardian/action@v0.4.0.0&#xA;        name: Check with guardian&#xA;        with:&#xA;          backend: cabal    # auto, cabal, or stack; auto if omitted&#xA;          version: 0.4.0.0  # latest if omitted&#xA;&#xA;          ## Specify the following if the project root /= repository root&#xA;          # target: path/to/project/root&#xA;&#xA;          ## If you are using non-standard name for config file&#xA;          # config: custom-dependency-domains.yaml &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contribution&lt;/h2&gt; &#xA;&lt;p&gt;Please feel free to open an issue, but also please search for existing issues to check if there already is a similar one.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/deepflowinc/guardian/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;(c) 2021-2023, DeepFlow Inc.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>schrotthaufen/dotfiles</title>
    <updated>2023-02-16T01:36:08Z</updated>
    <id>tag:github.com,2023-02-16:/schrotthaufen/dotfiles</id>
    <link href="https://github.com/schrotthaufen/dotfiles" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;dotfiles&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains various configuration files.&lt;/p&gt;</summary>
  </entry>
</feed>