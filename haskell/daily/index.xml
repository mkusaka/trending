<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-29T01:45:42Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jonschoning/espial</title>
    <updated>2022-06-29T01:45:42Z</updated>
    <id>tag:github.com,2022-06-29:/jonschoning/espial</id>
    <link href="https://github.com/jonschoning/espial" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Espial is an open-source, web-based bookmarking server.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Espial&lt;/h1&gt; &#xA;&lt;p&gt;Espial is an open-source, web-based bookmarking server.&lt;/p&gt; &#xA;&lt;p&gt;It allows mutiple accounts, but currently intended for self-host scenarios.&lt;/p&gt; &#xA;&lt;p&gt;The bookmarks are stored in a sqlite3 database, for ease of deployment &amp;amp; maintenence.&lt;/p&gt; &#xA;&lt;p&gt;The easist way for logged-in users to add bookmarks, is with the &#34;bookmarklet&#34;, found on the Settings page.&lt;/p&gt; &#xA;&lt;p&gt;Also, see the android app for adding bookmarks via an Android Share intent &lt;a href=&#34;https://github.com/jonschoning/espial-share-android&#34;&gt;https://github.com/jonschoning/espial-share-android&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;demo server&lt;/h2&gt; &#xA;&lt;p&gt;log in â€” username: demo password: demo&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://esp.ae8.org/u:demo&#34;&gt;https://esp.ae8.org/u:demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/jdnV93c.png&#34; alt=&#34;jpg&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Docker Setup&lt;/h2&gt; &#xA;&lt;p&gt;see &lt;a href=&#34;https://github.com/jonschoning/espial-docker&#34;&gt;https://github.com/jonschoning/espial-docker&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Server Setup (from source)&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the Stack executable here:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tech.fpcomplete.com/haskell/get-started&#34;&gt;https://tech.fpcomplete.com/haskell/get-started&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build executables&lt;/p&gt; &lt;pre&gt;&lt;code&gt;stack build&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create the database&lt;/p&gt; &lt;pre&gt;&lt;code&gt;stack exec migration -- createdb --conn espial.sqlite3&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a user&lt;/p&gt; &lt;pre&gt;&lt;code&gt;stack exec migration -- createuser --conn espial.sqlite3 --userName myusername --userPassword myuserpassword&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Import a pinboard bookmark file for a user (optional)&lt;/p&gt; &lt;pre&gt;&lt;code&gt;stack exec migration -- importbookmarks --conn espial.sqlite3 --userName myusername --bookmarkFile sample-bookmarks.json&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Import a firefox bookmark file for a user (optional)&lt;/p&gt; &lt;pre&gt;&lt;code&gt;stack exec migration -- importfirefoxbookmarks --conn espial.sqlite3 --userName myusername --bookmarkFile firefox-bookmarks.json&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Start a production server:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;stack exec espial&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;code&gt;config/settings.yml&lt;/code&gt; for changing default run-time parameters &amp;amp; environment variables.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;config/settings.yml&lt;/code&gt; is embedded into the app executable when compiled, so after changing &lt;code&gt;config/settings.yml&lt;/code&gt;, run &lt;code&gt;stack build&lt;/code&gt; again to apply the new settings.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;config/settings.yml&lt;/code&gt; values formatted like &lt;code&gt;_env:ENV_VAR_NAME:default_value&lt;/code&gt; can be overridden by the specified environment variable.&lt;/li&gt; &#xA; &lt;li&gt;Example &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;_env:PORT:3000&lt;/code&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;environment variable &lt;code&gt;PORT&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;default app http port: &lt;code&gt;3000&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;SSL: use reverse proxy&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;h3&gt;Backend&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the &lt;code&gt;yesod&lt;/code&gt; command line tool: &lt;code&gt;stack install yesod-bin --install-ghc&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Start a development server:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;yesod devel&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Frontend&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;See &lt;code&gt;purs/&lt;/code&gt; folder&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Import Bookmark file format (pinboard compatible format)&lt;/h2&gt; &#xA;&lt;p&gt;see &lt;code&gt;sample-bookmarks.json&lt;/code&gt;, which contains a JSON array, each line containing a &lt;code&gt;FileBookmark&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;p&gt;example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[ {&#34;href&#34;:&#34;http://raganwald.com/2018/02/23/forde.html&#34;,&#34;description&#34;:&#34;Forde&#39;s Tenth Rule, or, \&#34;How I Learned to Stop Worrying and \u2764\ufe0f the State Machine\&#34;&#34;,&#34;extended&#34;:&#34;&#34;,&#34;time&#34;:&#34;2018-02-26T22:57:20Z&#34;,&#34;shared&#34;:&#34;yes&#34;,&#34;toread&#34;:&#34;yes&#34;,&#34;tags&#34;:&#34;raganwald&#34;},&#xA;, {&#34;href&#34;:&#34;http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html&#34;,&#34;description&#34;:&#34;7.6. Flag reference \u2014 Glasgow Haskell Compiler 8.2.2 User&#39;s Guide&#34;,&#34;extended&#34;:&#34;-fprint-expanded-synonyms&#34;,&#34;time&#34;:&#34;2018-02-26T21:52:02Z&#34;,&#34;shared&#34;:&#34;yes&#34;,&#34;toread&#34;:&#34;no&#34;,&#34;tags&#34;:&#34;ghc haskell&#34;},&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>sifive/RiscvSpecFormal</title>
    <updated>2022-06-29T01:45:42Z</updated>
    <id>tag:github.com,2022-06-29:/sifive/RiscvSpecFormal</id>
    <link href="https://github.com/sifive/RiscvSpecFormal" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The RiscvSpecKami package provides SiFive&#39;s RISC-V processor model. Built using Coq, this processor model can be used for simulation, model checking, and semantics analysis. The RISC-V processor model can be output as Verilog and simulated/synthesized using standard Verilog tools.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Formal Specification of RISC-V ISA in Kami&lt;/h1&gt; &#xA;&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt; &#xA; &lt;div id=&#34;toctitle&#34;&gt;&#xA;  Table of Contents&#xA; &lt;/div&gt; &#xA; &lt;ul class=&#34;sectlevel1&#34;&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sifive/RiscvSpecFormal/master/#_organization&#34;&gt;1. Organization&lt;/a&gt; &#xA;   &lt;ul class=&#34;sectlevel2&#34;&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sifive/RiscvSpecFormal/master/#_funcunits_directory&#34;&gt;1.1. FuncUnits directory&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sifive/RiscvSpecFormal/master/#generators&#34;&gt;1.2. Top-level directory and files&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/div&gt; &#xA;&lt;div id=&#34;preamble&#34;&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;This project gives the formal specification of RISC-V ISA in &lt;a href=&#34;https://github.com/sifive/Kami&#34;&gt;Kami&lt;/a&gt;. In particular, it gives the semantics for RV32GC and RV64GC ISAs with User-mode, Supervisor-mode and Machine-mode instructions and the Zam extension (unaligned atomics).&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Installation instructions are available in &lt;a href=&#34;https://raw.githubusercontent.com/sifive/RiscvSpecFormal/master/INSTALL.adoc&#34; class=&#34;bare&#34;&gt;INSTALL.adoc&lt;/a&gt;.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;div class=&#34;sect1&#34;&gt; &#xA; &lt;h2 id=&#34;_organization&#34;&gt;1. Organization&lt;/h2&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;The semantics are organized into two parts, the &lt;a href=&#34;https://github.com/sifive/ProcKami/tree/master/FuncUnits&#34;&gt;ProcKami/FuncUnits&lt;/a&gt; directory, and the top-level &lt;a href=&#34;https://github.com/sifive/ProcKami&#34;&gt;ProcKami&lt;/a&gt; directory.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;sect2&#34;&gt; &#xA;   &lt;h3 id=&#34;_funcunits_directory&#34;&gt;1.1. FuncUnits directory&lt;/h3&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;This is a directory that contains a list of instructions that defines the RISC-V ISA, along with the semantics of these instructions, written as Kami expressions, that define how the instruction reads and updates the state of a processor such as the register files, the floating point register files, the PC, etc.&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;The directory is organized as the different functional units that execute a set of instructions, each, of the RISC-V ISA. Related functional units are grouped together into directories (e.g., the different functional units comprising the ALU functional units, such as the &lt;a href=&#34;https://github.com/sifive/ProcKami/tree/master/FuncUnits/Alu/Add.v&#34;&gt;Add&lt;/a&gt;, &lt;a href=&#34;https://github.com/sifive/ProcKami/tree/master/FuncUnits/Alu/Add.v&#34;&gt;Logical&lt;/a&gt;, &lt;a href=&#34;https://github.com/sifive/ProcKami/tree/master/FuncUnits/Alu/Add.v&#34;&gt;Branch&lt;/a&gt;, &lt;a href=&#34;https://github.com/sifive/ProcKami/tree/master/FuncUnits/Alu/Add.v&#34;&gt;DivRem&lt;/a&gt;, etc. are grouped into the &lt;a href=&#34;https://github.com/sifive/ProcKami/tree/master/FuncUnits/Alu&#34;&gt;ProcKami/FuncUnits/Alu&lt;/a&gt; directory).&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;Each functional unit is is represented by a record which contains the following fields:&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;dlist&#34;&gt; &#xA;    &lt;dl&gt; &#xA;     &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;      fuName&#xA;     &lt;/dt&gt; &#xA;     &lt;dd&gt; &#xA;      &lt;p&gt;The name of the functional unit (for documentation purposes only)&lt;/p&gt; &#xA;     &lt;/dd&gt; &#xA;     &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;      fuFunc&#xA;     &lt;/dt&gt; &#xA;     &lt;dd&gt; &#xA;      &lt;p&gt;The function represented by the functional unit as a Kami expression (which takes some inputs, in the form of a Kami struct and produces some outputs, again in the form of a Kami struct)`&lt;/p&gt; &#xA;     &lt;/dd&gt; &#xA;     &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;      fuInsts&#xA;     &lt;/dt&gt; &#xA;     &lt;dd&gt; &#xA;      &lt;p&gt;The list of instructions that are supported by this functional unit. The fuInsts itself is a list of records where each record contains the following fields:&lt;/p&gt; &#xA;      &lt;div class=&#34;dlist&#34;&gt; &#xA;       &lt;dl&gt; &#xA;        &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;         instName&#xA;        &lt;/dt&gt; &#xA;        &lt;dd&gt; &#xA;         &lt;p&gt;The name of the instruction (for documentation purposes only)&lt;/p&gt; &#xA;        &lt;/dd&gt; &#xA;        &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;         extensions&#xA;        &lt;/dt&gt; &#xA;        &lt;dd&gt; &#xA;         &lt;p&gt;The list of extensions that the instruction is necessary to be included in&lt;/p&gt; &#xA;        &lt;/dd&gt; &#xA;        &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;         uniqId&#xA;        &lt;/dt&gt; &#xA;        &lt;dd&gt; &#xA;         &lt;p&gt;The unique identification information for the instruction as defined by the RISC-V ISA. It contains a list of ranges (between 0 and 31) and the bit patterns in those ranges&lt;/p&gt; &#xA;        &lt;/dd&gt; &#xA;        &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;         inputXform&#xA;        &lt;/dt&gt; &#xA;        &lt;dd&gt; &#xA;         &lt;p&gt;The transformation of the generic &lt;strong&gt;&lt;em&gt;ExecContextPkt&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;ContextCfgPkt&lt;/em&gt;&lt;/strong&gt; into the inputs for the functional unit that executes this instruction.&lt;/p&gt; &#xA;         &lt;div class=&#34;ulist&#34;&gt; &#xA;          &lt;ul&gt; &#xA;           &lt;li&gt; &lt;p&gt;&lt;strong&gt;ExecContextPkt&lt;/strong&gt; represents the register state which the current instruction that is being executed requires to execute. It contains the following fields:&lt;/p&gt; &#xA;            &lt;div class=&#34;dlist&#34;&gt; &#xA;             &lt;dl&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               pc&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;The PC of the instruction packet&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               reg1&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;The value in the register file for the first register referenced by the instruction packet, in either the integer register file or the floating point register file, depending on the instruction&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               reg2&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;The value in the register file for the second register referenced by the instruction packet, again, in either the integer register file or the floating point register file, depending on the instruction&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               reg3&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;The value in the register file for the third register referenced by the instruction packet. This is needed only for the FMADD instruction and its variants, and therefore necessarily from the floating point register file&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               fflags&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;The current status of the floating point flags, in order to set the new flags&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               frm&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;The floating point rounding mode&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               inst&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;The uncompressed 32-bit instruction represented by the current packet&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               compressed?&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;Whether the instruction represented by the current packet was compressed or not&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;             &lt;/dl&gt; &#xA;            &lt;/div&gt; &lt;/li&gt; &#xA;           &lt;li&gt; &lt;p&gt;&lt;strong&gt;ContextCfgPkt&lt;/strong&gt; represents more of the register state which the current instruction requires to execute. The difference from the ExecContextPkt is that this represents the state which changes less frequently as opposed to the state represented by the ExecContextPkt, which changes more or less after exery instruction. It contains the following fields:&lt;/p&gt; &#xA;            &lt;div class=&#34;dlist&#34;&gt; &#xA;             &lt;dl&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               xlen&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;Specifies whether we are running the 32-bit ISA or the 64-bit ISA&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               mode&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;Specifies whether we are in user mode, supervisor mode, hypervisor mode or machine mode&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               extensions&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;Specifies the extensions that the machine should be supporting when executing the current instruction&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               instMisalignedException?&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;Specifies whether the instruction should throw an exception when fetching an instruction not aligned to 32-bit boundaries&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               memMisalignedException?&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;Specifies whether the instruction should throw an exception when performing a load, store, AMO or LR/SC on an unaligned address&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               accessException?&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;Specifies whether the instruction should throw an access fault instead of misaligned fault (memory accesses resulting in misaligned faults are usually still completed by the trap handler by splitting the access into multiple aligned accesses; access faults result in system error)&lt;/p&gt; &#xA;              &lt;/dd&gt; &#xA;             &lt;/dl&gt; &#xA;            &lt;/div&gt; &lt;/li&gt; &#xA;          &lt;/ul&gt; &#xA;         &lt;/div&gt; &#xA;        &lt;/dd&gt; &#xA;        &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;         outputXform&#xA;        &lt;/dt&gt; &#xA;        &lt;dd&gt; &#xA;         &lt;p&gt;Specifies how to transform the output of a functional unit into a processor-state update packet &lt;strong&gt;ExecUpdPkt&lt;/strong&gt;, which contains the following fields:&lt;/p&gt; &#xA;         &lt;div class=&#34;dlist&#34;&gt; &#xA;          &lt;dl&gt; &#xA;           &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;            val1&#xA;           &lt;/dt&gt; &#xA;           &lt;dd&gt; &#xA;            &lt;p&gt;The value for the first destination register, along with whether it is an updated value of an integer register or a floating point register, the PC, the floating point flags register, a memory address, a memory data (for stores and AMOs) or a CSR register.&lt;/p&gt; &#xA;           &lt;/dd&gt; &#xA;           &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;            val2&#xA;           &lt;/dt&gt; &#xA;           &lt;dd&gt; &#xA;            &lt;p&gt;Same as &lt;em&gt;*val1*&lt;/em&gt;. This is needed when we update multiple locations, for instance the PC and an integer register in case of the JALR instruction.&lt;/p&gt; &#xA;           &lt;/dd&gt; &#xA;           &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;            memBitMask&#xA;           &lt;/dt&gt; &#xA;           &lt;dd&gt; &#xA;            &lt;p&gt;The memory mask for Store, AMO and SC operations&lt;/p&gt; &#xA;           &lt;/dd&gt; &#xA;           &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;            mem&#xA;           &lt;/dt&gt; &#xA;           &lt;dd&gt; &#xA;            &lt;p&gt;The value written to memory for Store, AMO and SC operations&lt;/p&gt; &#xA;           &lt;/dd&gt; &#xA;           &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;            taken?&#xA;           &lt;/dt&gt; &#xA;           &lt;dd&gt; &#xA;            &lt;p&gt;In case of a branch or jump instruction, tells whether the branch or jump is taken or not&lt;/p&gt; &#xA;           &lt;/dd&gt; &#xA;           &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;            aq&#xA;           &lt;/dt&gt; &#xA;           &lt;dd&gt; &#xA;            &lt;p&gt;In case of AMO or LR/SC operation, tells whether it has the &lt;a href=&#34;https://en.wikipedia.org/wiki/Release_consistency&#34;&gt;acquire&lt;/a&gt; semantics&lt;/p&gt; &#xA;           &lt;/dd&gt; &#xA;           &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;            rl&#xA;           &lt;/dt&gt; &#xA;           &lt;dd&gt; &#xA;            &lt;p&gt;In case of AMO or LR/SC operation, tells whether it has the &lt;a href=&#34;https://en.wikipedia.org/wiki/Release_consistency&#34;&gt;release&lt;/a&gt; semantics&lt;/p&gt; &#xA;           &lt;/dd&gt; &#xA;          &lt;/dl&gt; &#xA;         &lt;/div&gt; &#xA;        &lt;/dd&gt; &#xA;        &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;         optMemXform&#xA;        &lt;/dt&gt; &#xA;        &lt;dd&gt; &#xA;         &lt;p&gt;In case of memory-related instructions, specifies how the data from the memory is transformed before storing into the register file (for instance, in the case of a load byte, load half word, etc), and how the register value gets transformed before storing into the memory (in the case of a store byte, store half word, etc). This function takes a &lt;strong&gt;&lt;em&gt;MemoryInput&lt;/em&gt;&lt;/strong&gt; packet that specifies what comes out of the register file and what comes out of the memory and transforms it into a &lt;strong&gt;&lt;em&gt;MemoryOutput&lt;/em&gt;&lt;/strong&gt; packet that specifies what goes into the register file and what goes into the memory.&lt;/p&gt; &#xA;         &lt;div class=&#34;dlist&#34;&gt; &#xA;          &lt;dl&gt; &#xA;           &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;            &lt;strong&gt;&lt;em&gt;MemoryInput&lt;/em&gt;&lt;/strong&gt;&#xA;           &lt;/dt&gt; &#xA;           &lt;dd&gt; &#xA;            &lt;p&gt;It has the following fields:&lt;/p&gt; &#xA;            &lt;div class=&#34;dlist&#34;&gt; &#xA;             &lt;dl&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               aq:&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;In case of AMO or LR/SC operation, tells whether it has the &lt;a href=&#34;https://en.wikipedia.org/wiki/Release_consistency&#34;&gt;acquire&lt;/a&gt; semantics&lt;/p&gt; &#xA;               &lt;div class=&#34;dlist&#34;&gt; &#xA;                &lt;dl&gt; &#xA;                 &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;                  rl:&#xA;                 &lt;/dt&gt; &#xA;                 &lt;dd&gt; &#xA;                  &lt;p&gt;In case of AMO or LR/SC operation, tells whether it has the &lt;a href=&#34;https://en.wikipedia.org/wiki/Release_consistency&#34;&gt;release&lt;/a&gt; semantics&lt;/p&gt; &#xA;                  &lt;div class=&#34;dlist&#34;&gt; &#xA;                   &lt;dl&gt; &#xA;                    &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;                     reservation:&#xA;                    &lt;/dt&gt; &#xA;                    &lt;dd&gt; &#xA;                     &lt;p&gt;In case of LR/SC, specifies whether the reservation bit is set for each byte corresponding to the memory operation&lt;/p&gt; &#xA;                     &lt;div class=&#34;dlist&#34;&gt; &#xA;                      &lt;dl&gt; &#xA;                       &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;                        mem:&#xA;                       &lt;/dt&gt; &#xA;                       &lt;dd&gt; &#xA;                        &lt;p&gt;The value written into the memory in case of a store, AMO or SC&lt;/p&gt; &#xA;                        &lt;div class=&#34;dlist&#34;&gt; &#xA;                         &lt;dl&gt; &#xA;                          &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;                           reg_data:&#xA;                          &lt;/dt&gt; &#xA;                          &lt;dd&gt; &#xA;                           &lt;p&gt;The value written into the register file in case of a load, AMO or LR&lt;/p&gt; &#xA;                          &lt;/dd&gt; &#xA;                         &lt;/dl&gt; &#xA;                        &lt;/div&gt; &#xA;                       &lt;/dd&gt; &#xA;                      &lt;/dl&gt; &#xA;                     &lt;/div&gt; &#xA;                    &lt;/dd&gt; &#xA;                   &lt;/dl&gt; &#xA;                  &lt;/div&gt; &#xA;                 &lt;/dd&gt; &#xA;                &lt;/dl&gt; &#xA;               &lt;/div&gt; &#xA;              &lt;/dd&gt; &#xA;             &lt;/dl&gt; &#xA;            &lt;/div&gt; &#xA;           &lt;/dd&gt; &#xA;           &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;            &lt;strong&gt;&lt;em&gt;MemoryOutput&lt;/em&gt;&lt;/strong&gt;&#xA;           &lt;/dt&gt; &#xA;           &lt;dd&gt; &#xA;            &lt;p&gt;It has the following fields:&lt;/p&gt; &#xA;            &lt;div class=&#34;dlist&#34;&gt; &#xA;             &lt;dl&gt; &#xA;              &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;               aq:&#xA;              &lt;/dt&gt; &#xA;              &lt;dd&gt; &#xA;               &lt;p&gt;In case of AMO or LR/SC operation, tells whether it has the &lt;a href=&#34;https://en.wikipedia.org/wiki/Release_consistency&#34;&gt;acquire&lt;/a&gt; semantics&lt;/p&gt; &#xA;               &lt;div class=&#34;dlist&#34;&gt; &#xA;                &lt;dl&gt; &#xA;                 &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;                  rl:&#xA;                 &lt;/dt&gt; &#xA;                 &lt;dd&gt; &#xA;                  &lt;p&gt;In case of AMO or LR/SC operation, tells whether it has the &lt;a href=&#34;https://en.wikipedia.org/wiki/Release_consistency&#34;&gt;release&lt;/a&gt; semantics&lt;/p&gt; &#xA;                  &lt;div class=&#34;dlist&#34;&gt; &#xA;                   &lt;dl&gt; &#xA;                    &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;                     isWr:&#xA;                    &lt;/dt&gt; &#xA;                    &lt;dd&gt; &#xA;                     &lt;p&gt;Tells whether the memory operation involves writing the memory (i.e. Store, AMO or SC)&lt;/p&gt; &#xA;                     &lt;div class=&#34;dlist&#34;&gt; &#xA;                      &lt;dl&gt; &#xA;                       &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;                        mask:&#xA;                       &lt;/dt&gt; &#xA;                       &lt;dd&gt; &#xA;                        &lt;p&gt;Tells which bytes will be written in case of Store, AMO or SC&lt;/p&gt; &#xA;                        &lt;div class=&#34;dlist&#34;&gt; &#xA;                         &lt;dl&gt; &#xA;                          &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;                           data:&#xA;                          &lt;/dt&gt; &#xA;                          &lt;dd&gt; &#xA;                           &lt;p&gt;Tells the written value in case of Store, AMO or SC&lt;/p&gt; &#xA;                           &lt;div class=&#34;dlist&#34;&gt; &#xA;                            &lt;dl&gt; &#xA;                             &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;                              isLrSc:&#xA;                             &lt;/dt&gt; &#xA;                             &lt;dd&gt; &#xA;                              &lt;p&gt;Tells whether the operation is LR or SC&lt;/p&gt; &#xA;                              &lt;div class=&#34;dlist&#34;&gt; &#xA;                               &lt;dl&gt; &#xA;                                &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;                                 reservation:&#xA;                                &lt;/dt&gt; &#xA;                                &lt;dd&gt; &#xA;                                 &lt;p&gt;Tells which bytes will be reserved in case of LR and which bytes&#39; reservations have to be checked in case of SC&lt;/p&gt; &#xA;                                 &lt;div class=&#34;dlist&#34;&gt; &#xA;                                  &lt;dl&gt; &#xA;                                   &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;                                    tag:&#xA;                                   &lt;/dt&gt; &#xA;                                   &lt;dd&gt; &#xA;                                    &lt;p&gt;Tells whether the value from a load is written into the integer register file or floating point register file&lt;/p&gt; &#xA;                                    &lt;div class=&#34;dlist&#34;&gt; &#xA;                                     &lt;dl&gt; &#xA;                                      &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;                                       reg_data:&#xA;                                      &lt;/dt&gt; &#xA;                                      &lt;dd&gt; &#xA;                                       &lt;p&gt;Tells the value read in case of Load, AMO or LR&lt;/p&gt; &#xA;                                      &lt;/dd&gt; &#xA;                                     &lt;/dl&gt; &#xA;                                    &lt;/div&gt; &#xA;                                   &lt;/dd&gt; &#xA;                                  &lt;/dl&gt; &#xA;                                 &lt;/div&gt; &#xA;                                &lt;/dd&gt; &#xA;                               &lt;/dl&gt; &#xA;                              &lt;/div&gt; &#xA;                             &lt;/dd&gt; &#xA;                            &lt;/dl&gt; &#xA;                           &lt;/div&gt; &#xA;                          &lt;/dd&gt; &#xA;                         &lt;/dl&gt; &#xA;                        &lt;/div&gt; &#xA;                       &lt;/dd&gt; &#xA;                      &lt;/dl&gt; &#xA;                     &lt;/div&gt; &#xA;                    &lt;/dd&gt; &#xA;                   &lt;/dl&gt; &#xA;                  &lt;/div&gt; &#xA;                 &lt;/dd&gt; &#xA;                &lt;/dl&gt; &#xA;               &lt;/div&gt; &#xA;              &lt;/dd&gt; &#xA;             &lt;/dl&gt; &#xA;            &lt;/div&gt; &#xA;           &lt;/dd&gt; &#xA;          &lt;/dl&gt; &#xA;         &lt;/div&gt; &#xA;        &lt;/dd&gt; &#xA;        &lt;dt class=&#34;hdlist1&#34;&gt;&#xA;         instHints&#xA;        &lt;/dt&gt; &#xA;        &lt;dd&gt; &#xA;         &lt;p&gt;Specifies various information about the instruction, such as whether it has a source 1 integer register, source 2 integer register, destination integer register, source 1 floating point register, source 2 floating point register, source 3 floating point register, destination floating point register, whether it is a branch, a jump to a register, a jump to an immediate value, a system call, a CSR-related instruction, a store or AMO instruction, etc.&lt;/p&gt; &#xA;        &lt;/dd&gt; &#xA;       &lt;/dl&gt; &#xA;      &lt;/div&gt; &#xA;     &lt;/dd&gt; &#xA;    &lt;/dl&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;One reason for such an organization, where each functional unit handles a set of instructions is for clarity. The other, more important reason is as follows. We want to be able to automatically analyze these functional units and generate decoders, executors, memory units, etc (see &lt;a href=&#34;https://raw.githubusercontent.com/sifive/RiscvSpecFormal/master/#generators&#34;&gt;Top-level directory and files&lt;/a&gt;). These generated functions will be used not only in the specification in &lt;a href=&#34;https://github.com/sifive/ProcKami&#34;&gt;ProcKami&lt;/a&gt;, but also to generate complex microarchitecture implementations (such as the &lt;a href=&#34;https://en.wikipedia.org/wiki/Out-of-order_execution&#34;&gt;out-of-order processor&lt;/a&gt;). This makes formal verification of these complex microarchitectures easier, as they share the same generated functions (such as decoder, executor, etc) with the specification they must be proven against. For actual implementations, it is important that each functional unit handles several instructions, where the inputs and outputs for the functional units are transformed based on the instruction. This organization of separating the semantics of an instruction into a &lt;strong&gt;ExecContextPkt&lt;/strong&gt; transformer to feed a functional unit, the generic functionality of the functional unit and a transformation of the output of the functional unit to an &lt;strong&gt;UpdateContextPkt&lt;/strong&gt; does not overly impose any burden on the readability or the understandability of the RISC-V ISA specification, but eases the formal verification cost of implementations significantly.&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;sect2&#34;&gt; &#xA;   &lt;h3 id=&#34;generators&#34;&gt;1.2. Top-level directory and files&lt;/h3&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;These files take the tables in the &lt;a href=&#34;https://github.com/sifive/ProcKami/tree/master/FuncUnits&#34;&gt;ProcKami/FuncUnits&lt;/a&gt; directory and produce several useful functions like the &lt;a href=&#34;https://github.com/sifive/ProcKami/raw/master/Decoder.v&#34;&gt;decoder&lt;/a&gt;, &lt;a href=&#34;https://github.com/sifive/ProcKami/raw/master/RegReader.v&#34;&gt;reg-reader&lt;/a&gt;, &lt;a href=&#34;https://github.com/sifive/ProcKami/raw/master/Executer.v&#34;&gt;executor&lt;/a&gt;, etc. These functions are all assembled in &lt;a href=&#34;https://github.com/sifive/ProcKami/tree/master/ProcessorCore.v&#34;&gt;ProcessorCore.v&lt;/a&gt; to create a formal specification of the processor.&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt;</summary>
  </entry>
  <entry>
    <title>Gabriella439/defaultable-map</title>
    <updated>2022-06-29T01:45:42Z</updated>
    <id>tag:github.com,2022-06-29:/Gabriella439/defaultable-map</id>
    <link href="https://github.com/Gabriella439/defaultable-map" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Applicative maps&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>