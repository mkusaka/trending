<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-10T01:37:46Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>luqui/Djest</title>
    <updated>2023-03-10T01:37:46Z</updated>
    <id>tag:github.com,2023-03-10:/luqui/Djest</id>
    <link href="https://github.com/luqui/Djest" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A programming language that deduces code from tests&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Djest was born as an entry into the Jan 2013 PLT Games competition, &lt;a href=&#34;http://www.pltgames.com/competition/2013/1&#34;&gt;Testing The Waters&lt;/a&gt; (but I didn&#39;t finish in time to enter). It improves Haskell&#39;s support for automated testing, by making it so you don&#39;t have to write the code you are testing at all!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;succ :: Int -&amp;gt; Int&#xA;succ 0 == 1&#xA;succ 1 == 2&#xA;succ 10 == 11&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is enough to have Djest deduce that &lt;code&gt;succ x = x + 1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Djest uses a &lt;a href=&#34;http://lambda-the-ultimate.org/node/1178&#34;&gt;Djinn&lt;/a&gt;-like satisfier which searches for functions of a given type. The generated functions are then tested with the test suite until one that passes all the tests is found, at which point that function is taken as its definition. If it uses the wrong function, then clearly your test suite was not comprehensive!&lt;/p&gt; &#xA;&lt;p&gt;Generated functions are tested in roughly increasing order of complexity, so simpler functions are used in preference to more complex ones. This is what allows Djest to find &lt;code&gt;succ x = x + 1&lt;/code&gt; instead of&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;succ x = case x of&#xA;             0 -&amp;gt; 1&#xA;             1 -&amp;gt; 2&#xA;             10 -&amp;gt; 11&#xA;             _ -&amp;gt; 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which is most likely not the function the programmer had in mind.&lt;/p&gt; &#xA;&lt;p&gt;Djest is powerful enough to deduce the predecessor function on Church numerals, which Alonzo Church himself could not find (albeit without a computer). It handles rank &lt;em&gt;n&lt;/em&gt; polymorphism and only finds total functions (I believe it will eventually find every non-recursive function, but I am not sure).&lt;/p&gt; &#xA;&lt;p&gt;Check out the examples/ directory.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>psii/hmtpfs</title>
    <updated>2023-03-10T01:37:46Z</updated>
    <id>tag:github.com,2023-03-10:/psii/hmtpfs</id>
    <link href="https://github.com/psii/hmtpfs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;MTP Filesystem based on FUSE and libmtp&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>