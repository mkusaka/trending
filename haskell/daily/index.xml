<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-29T01:40:54Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>alt-romes/hegg</title>
    <updated>2022-08-29T01:40:54Z</updated>
    <id>tag:github.com,2022-08-29:/alt-romes/hegg</id>
    <link href="https://github.com/alt-romes/hegg" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fast equality saturation in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;hegg&lt;/h2&gt; &#xA;&lt;p&gt;Fast equality saturation in Haskell&lt;/p&gt; &#xA;&lt;p&gt;Based on &lt;a href=&#34;https://arxiv.org/pdf/2004.03082.pdf&#34;&gt;&lt;em&gt;egg: Fast and Extensible Equality Saturation&lt;/em&gt;&lt;/a&gt;, &lt;a href=&#34;https://arxiv.org/pdf/2108.02290.pdf&#34;&gt;&lt;em&gt;Relational E-matching&lt;/em&gt;&lt;/a&gt; and the &lt;a href=&#34;https://github.com/egraphs-good/egg&#34;&gt;rust implementation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Equality Saturation and E-graphs&lt;/h3&gt; &#xA;&lt;p&gt;Suggested material on equality saturation and e-graphs for beginners&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;(tutorial) &lt;a href=&#34;https://docs.rs/egg/latest/egg/tutorials/_01_background/index.html&#34;&gt;https://docs.rs/egg/latest/egg/tutorials/_01_background/index.html&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;(5m video) &lt;a href=&#34;https://www.youtube.com/watch?v=ap29SzDAzP0&#34;&gt;https://www.youtube.com/watch?v=ap29SzDAzP0&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Equality saturation in Haskell&lt;/h2&gt; &#xA;&lt;p&gt;To get a feel for how we can use &lt;code&gt;hegg&lt;/code&gt; and do equality saturation in Haskell, we&#39;ll write a simple numeric &lt;em&gt;symbolic&lt;/em&gt; manipulation library that can simplify expressions according to a set of rewrite rules by leveraging equality saturation.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;ve never heard of symbolic mathematics you might get some intuition from reading &lt;a href=&#34;https://iagoleal.com/posts/calculus-symbolic/&#34;&gt;Letâ€™s Program a Calculus Student&lt;/a&gt; first.&lt;/p&gt; &#xA;&lt;h3&gt;Syntax&lt;/h3&gt; &#xA;&lt;p&gt;We&#39;ll start by defining the abstract syntax tree for our simple symbolic expressions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;data SymExpr = Const Double&#xA;             | Symbol String&#xA;             | SymExpr :+: SymExpr&#xA;             | SymExpr :*: SymExpr&#xA;             | SymExpr :/: SymExpr&#xA;infix 6 :+:&#xA;infix 7 :*:, :/:&#xA;&#xA;e1 :: SymExpr&#xA;e1 = (Symbol &#34;x&#34; :*: Const 2) :/: (Const 2) -- (x*2)/2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You might notice that &lt;code&gt;(x*2)/2&lt;/code&gt; is the same as just &lt;code&gt;x&lt;/code&gt;. Our goal is to get equality saturation to do that for us.&lt;/p&gt; &#xA;&lt;p&gt;Our second step is to instance &lt;code&gt;Language&lt;/code&gt; for our &lt;code&gt;SymExpr&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Language&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Language&lt;/code&gt; is the required constraint on &lt;em&gt;expressions&lt;/em&gt; that are to be represented in e-graph and on which equality saturation can be run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;class (Analysis l, Traversable l, Ord1 l) =&amp;gt; Language l&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To declare a &lt;code&gt;Language&lt;/code&gt; we must write the &#34;base functor&#34; of &lt;code&gt;SymExpr&lt;/code&gt; (i.e. use a type parameter where the recursion points used to be in the original &lt;code&gt;SymExpr&lt;/code&gt;), then instance &lt;code&gt;Traversable&lt;/code&gt;, &lt;code&gt;Ord1&lt;/code&gt;, and write an &lt;code&gt;Analysis&lt;/code&gt; instance for it (see next section).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;data SymExpr a = Const Double&#xA;               | Symbol String&#xA;               | a :+: a&#xA;               | a :*: a&#xA;               | a :/: a&#xA;               deriving (Functor, Foldable, Traversable)&#xA;infix 6 :+:&#xA;infix 7 :*:, :/:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Suggested reading on defining recursive data types in their parametrized version: &lt;a href=&#34;https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html&#34;&gt;Introduction To Recursion Schemes&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If we now wanted to represent an expression, we&#39;d write it in its fixed-point form&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;e1 :: Fix SymExpr&#xA;e1 = Fix (Fix (Fix (Symbol &#34;x&#34;) :*: Fix (Const 2)) :/: (Fix (Const 2))) -- (x*2)/2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;ve already automagically derived &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt; and &lt;code&gt;Traversable&lt;/code&gt; instances, and can use the following template haskell functions from &lt;code&gt;derive-compat&lt;/code&gt; to derive &lt;code&gt;Ord1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;deriveEq1   &#39;&#39;SymExpr&#xA;deriveOrd1  &#39;&#39;SymExpr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, we define an &lt;code&gt;Analysis&lt;/code&gt; for our &lt;code&gt;SymExpr&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Analysis&lt;/h3&gt; &#xA;&lt;p&gt;E-class analysis is first described in &lt;a href=&#34;https://arxiv.org/pdf/2004.03082.pdf&#34;&gt;&lt;em&gt;egg: Fast and Extensible Equality Saturation&lt;/em&gt;&lt;/a&gt; as a way to make equality saturation more &lt;em&gt;extensible&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;With it, we can attach &lt;em&gt;analysis data&lt;/em&gt; from a semilattice to each e-class. More can be read about e-class analysis in the &lt;a href=&#34;&#34;&gt;&lt;code&gt;Data.Equality.Analsysis&lt;/code&gt;&lt;/a&gt; module and in the paper.&lt;/p&gt; &#xA;&lt;p&gt;We could easily define constant folding (&lt;code&gt;2+2&lt;/code&gt; being simplified to &lt;code&gt;4&lt;/code&gt;) through an &lt;code&gt;Analysis&lt;/code&gt; instance, but for the sake of simplicity we&#39;ll simply define the analysis data as &lt;code&gt;()&lt;/code&gt; and always ignore it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;instance Analysis SymExpr where&#xA;  type Domain SymExpr = ()&#xA;  makeA _ _ = ()&#xA;  joinA _ _ = ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Language, again&lt;/h3&gt; &#xA;&lt;p&gt;With this setup, we can now express that &lt;code&gt;SymExpr&lt;/code&gt; forms a &lt;code&gt;Language&lt;/code&gt; which we can represent and manipulate in an e-graph by simply instancing it (there are no additional functions to define).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;instance Language SymExpr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Equality saturation&lt;/h3&gt; &#xA;&lt;p&gt;Equality saturation is defined as the function&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;equalitySaturation :: forall l. Language l&#xA;                   =&amp;gt; Fix l             -- ^ Expression to run equality saturation on&#xA;                   -&amp;gt; [Rewrite l]       -- ^ List of rewrite rules&#xA;                   -&amp;gt; CostFunction l    -- ^ Cost function to extract the best equivalent representation&#xA;                   -&amp;gt; (Fix l, EGraph l) -- ^ Best equivalent expression and resulting e-graph&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To recap, our goal is to reach &lt;code&gt;x&lt;/code&gt; starting from &lt;code&gt;(x*2)/2&lt;/code&gt; by means of equality saturation.&lt;/p&gt; &#xA;&lt;p&gt;We already have a starting expression, so we&#39;re missing a list of rewrite rules (&lt;code&gt;[Rewrite l]&lt;/code&gt;) and a cost function (&lt;code&gt;CostFunction&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Cost function&lt;/h3&gt; &#xA;&lt;p&gt;Picking up the easy one first:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;type CostFunction l = l Cost -&amp;gt; Cost&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A cost function is used to attribute a cost to representations in the e-graph and to extract the best one.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ll say &lt;code&gt;Const&lt;/code&gt;s and &lt;code&gt;Symbol&lt;/code&gt;s are the cheapest and then in increasing cost we have &lt;code&gt;:+:&lt;/code&gt;, &lt;code&gt;:*:&lt;/code&gt; and &lt;code&gt;:/:&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;cost :: CostFunction SymExpr&#xA;cost = \case&#xA;  Const  x -&amp;gt; 1&#xA;  Symbol x -&amp;gt; 1&#xA;  c1 :+: c2 -&amp;gt; c1 + c2 + 2&#xA;  c1 :*: c2 -&amp;gt; c1 + c2 + 3&#xA;  c1 :/: c2 -&amp;gt; c1 + c2 + 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rewrite rules&lt;/h3&gt; &#xA;&lt;p&gt;Rewrite rules are transformations applied to matching expressions represented in an e-graph.&lt;/p&gt; &#xA;&lt;p&gt;We can write simple rewrite rules and conditional rewrite rules, but we&#39;ll only look at the simple ones.&lt;/p&gt; &#xA;&lt;p&gt;A simple rewrite is formed of its left hand side and right hand side. When the left hand side is matched in the e-graph, the right hand side is added to the e-class where the left hand side was found.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;data Rewrite lang = Pattern lang := Pattern lang          -- Simple rewrite rule&#xA;                  | Rewrite lang :| RewriteCondition lang -- Conditional rewrite rule&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;Pattern&lt;/code&gt; is basically an expression that might contain variables and which can be matched against actual expressions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;data Pattern lang&#xA;    = NonVariablePattern (lang (Pattern lang))&#xA;    | VariablePattern Var&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A patterns is defined by its non-variable and variable parts, and can be constructed directly or using the helper function &lt;code&gt;pat&lt;/code&gt; and using &lt;code&gt;OverloadedStrings&lt;/code&gt; for the variables, where &lt;code&gt;pat&lt;/code&gt; is just a synonym for &lt;code&gt;NonVariablePattern&lt;/code&gt; and a string literal &lt;code&gt;&#34;abc&#34;&lt;/code&gt; is turned into a &lt;code&gt;Pattern&lt;/code&gt; constructed with &lt;code&gt;VariablePattern&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We can then write the following very specific set of rewrite rules to simplify our simple symbolic expressions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;rewrites :: [Rewrite SymExpr]&#xA;rewrites =&#xA;  [ pat (pat (&#34;a&#34; :*: &#34;b&#34;) :/: &#34;c&#34;) := pat (&#34;a&#34; :*: pat (&#34;b&#34; :/: &#34;c&#34;))&#xA;  , pat (&#34;x&#34; :/: &#34;x&#34;)               := pat (Const 1)&#xA;  , pat (&#34;x&#34; :*: (pat (Const 1)))   := &#34;x&#34;&#xA;  ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Equality saturation, again&lt;/h3&gt; &#xA;&lt;p&gt;We can now run equality saturation on our expression!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-hs&#34;&gt;let expr = fst (equalitySaturation e1 rewrites cost)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And upon printing we&#39;d see &lt;code&gt;expr = Symbol &#34;x&#34;&lt;/code&gt;!&lt;/p&gt; &#xA;&lt;p&gt;This was a first introduction which skipped over some details but that tried to walk through fundamental concepts for using e-graphs and equality saturation with this library.&lt;/p&gt; &#xA;&lt;p&gt;The final code for this tutorial is available under &lt;code&gt;test/SimpleSym.hs&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;A more complicated symbolic rewrite system which simplifies some derivatives and integrals was written for the testsuite. It can be found at &lt;code&gt;test/Sym.hs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This library could also be used not only for equality-saturation but also for the equality-graphs and other equality-things (such as e-matching) available. For example, using just the e-graphs from &lt;code&gt;Data.Equality.Graph&lt;/code&gt; to improve GHC&#39;s pattern match checker (&lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/-/issues/19272&#34;&gt;https://gitlab.haskell.org/ghc/ghc/-/issues/19272&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Profiling&lt;/h2&gt; &#xA;&lt;p&gt;Notes on profiling for development.&lt;/p&gt; &#xA;&lt;p&gt;For producing the info table, ghc-options must include &lt;code&gt;-finfo-table-map -fdistinct-constructor-tables&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal run --enable-profiling hegg-test -- +RTS -p -s -hi -l-agu&#xA;ghc-prof-flamegraph hegg-test.prof&#xA;eventlog2html hegg-test.eventlog&#xA;open hegg-test.svg&#xA;open hegg-test.eventlog.html&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>haskell/lsp</title>
    <updated>2022-08-29T01:40:54Z</updated>
    <id>tag:github.com,2022-08-29:/haskell/lsp</id>
    <link href="https://github.com/haskell/lsp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell library for the Microsoft Language Server Protocol&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/alanz/lsp/workflows/Haskell%20CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt; &lt;a href=&#34;https://hackage.haskell.org/package/lsp&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/lsp?label=lsp&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/lsp-types&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/lsp?label=lsp-types&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/lsp-test&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/lsp?label=lsp-test&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;lsp&lt;/h1&gt; &#xA;&lt;p&gt;Haskell library for the Microsoft Language Server Protocol. It currently implements all of the &lt;a href=&#34;https://microsoft.github.io/language-server-protocol/specifications/specification-3-15/&#34;&gt;3.15 specification&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is split into three separate packages, &lt;code&gt;lsp&lt;/code&gt;, &lt;code&gt;lsp-types&lt;/code&gt;, and &lt;code&gt;lsp-test&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-types&lt;/code&gt; provides &lt;em&gt;type-safe&lt;/em&gt; definitions that match up with the typescript definitions laid out in the specification&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp&lt;/code&gt; is a library for building language servers, handling: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;JSON-RPC transport&lt;/li&gt; &#xA;   &lt;li&gt;Keeping track of the document state in memory with the Virtual File System (VFS)&lt;/li&gt; &#xA;   &lt;li&gt;Responding to notifications and requests via handlers&lt;/li&gt; &#xA;   &lt;li&gt;Setting the server capabilities in the initialize request based on registered handlers&lt;/li&gt; &#xA;   &lt;li&gt;Dynamic registration of capabilities&lt;/li&gt; &#xA;   &lt;li&gt;Cancellable requests and progress notifications&lt;/li&gt; &#xA;   &lt;li&gt;Publishing and flushing of diagnostics&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-test&lt;/code&gt; is a functional testing framework for Language Server Protocol servers.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Language servers built on lsp&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/haskell/haskell-language-server&#34;&gt;haskell-language-server&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dhall-lang/dhall-haskell/tree/master/dhall-lsp-server#readme&#34;&gt;dhall-lsp-server&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/byorgey/swarm/raw/main/src/Swarm/Language/LSP.hs&#34;&gt;swarm&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example language servers&lt;/h2&gt; &#xA;&lt;p&gt;There are two example language servers in the &lt;code&gt;lsp/example/&lt;/code&gt; folder. &lt;code&gt;Simple.hs&lt;/code&gt; provides a minimal example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE OverloadedStrings #-}&#xA;&#xA;import Language.LSP.Server&#xA;import Language.LSP.Types&#xA;import Control.Monad.IO.Class&#xA;import qualified Data.Text as T&#xA;&#xA;handlers :: Handlers (LspM ())&#xA;handlers = mconcat&#xA;  [ notificationHandler SInitialized $ \_not -&amp;gt; do&#xA;      let params = ShowMessageRequestParams MtInfo &#34;Turn on code lenses?&#34;&#xA;            (Just [MessageActionItem &#34;Turn on&#34;, MessageActionItem &#34;Don&#39;t&#34;])&#xA;      _ &amp;lt;- sendRequest SWindowShowMessageRequest params $ \res -&amp;gt;&#xA;        case res of&#xA;          Right (Just (MessageActionItem &#34;Turn on&#34;)) -&amp;gt; do&#xA;            let regOpts = CodeLensRegistrationOptions Nothing Nothing (Just False)&#xA;              &#xA;            _ &amp;lt;- registerCapability STextDocumentCodeLens regOpts $ \_req responder -&amp;gt; do&#xA;              let cmd = Command &#34;Say hello&#34; &#34;lsp-hello-command&#34; Nothing&#xA;                  rsp = List [CodeLens (mkRange 0 0 0 100) (Just cmd) Nothing]&#xA;              responder (Right rsp)&#xA;            pure ()&#xA;          Right _ -&amp;gt;&#xA;            sendNotification SWindowShowMessage (ShowMessageParams MtInfo &#34;Not turning on code lenses&#34;)&#xA;          Left err -&amp;gt;&#xA;            sendNotification SWindowShowMessage (ShowMessageParams MtError $ &#34;Something went wrong!\n&#34; &amp;lt;&amp;gt; T.pack (show err))&#xA;      pure ()&#xA;  , requestHandler STextDocumentHover $ \req responder -&amp;gt; do&#xA;      let RequestMessage _ _ _ (HoverParams _doc pos _workDone) = req&#xA;          Position _l _c&#39; = pos&#xA;          rsp = Hover ms (Just range)&#xA;          ms = HoverContents $ markedUpContent &#34;lsp-demo-simple-server&#34; &#34;Hello world&#34;&#xA;          range = Range pos pos&#xA;      responder (Right $ Just rsp)&#xA;  ]&#xA;&#xA;main :: IO Int&#xA;main = runServer $ ServerDefinition&#xA;  { onConfigurationChange = const $ pure $ Right ()&#xA;  , doInitialize = \env _req -&amp;gt; pure $ Right env&#xA;  , staticHandlers = handlers&#xA;  , interpretHandler = \env -&amp;gt; Iso (runLspT env) liftIO&#xA;  , options = defaultOptions&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Whilst &lt;code&gt;Reactor.hs&lt;/code&gt; shows how a reactor design can be used to handle all requests on a separate thread, such in a way that we could then execute them on multiple threads without blocking server communication. They can be installed from source with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal install lsp-demo-simple-server lsp-demo-reactor-server&#xA;stack install :lsp-demo-simple-server :lsp-demo-reactor-server --flag haskell-lsp:demo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples of using lsp-test&lt;/h2&gt; &#xA;&lt;h3&gt;Setting up a session&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Language.LSP.Test&#xA;main = runSession &#34;hie&#34; fullCaps &#34;proj/dir&#34; $ do&#xA;  doc &amp;lt;- openDoc &#34;Foo.hs&#34; &#34;haskell&#34;&#xA;  skipMany anyNotification&#xA;  symbols &amp;lt;- getDocumentSymbols doc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unit tests with HSpec&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;describe &#34;diagnostics&#34; $&#xA;  it &#34;report errors&#34; $ runSession &#34;hie&#34; fullCaps &#34;test/data&#34; $ do&#xA;    openDoc &#34;Error.hs&#34; &#34;haskell&#34;&#xA;    [diag] &amp;lt;- waitForDiagnosticsSource &#34;ghcmod&#34;&#xA;    liftIO $ do&#xA;      diag ^. severity `shouldBe` Just DsError&#xA;      diag ^. source `shouldBe` Just &#34;ghcmod&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Replaying captured session&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;replaySession &#34;hie&#34; &#34;test/data/renamePass&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parsing with combinators&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;skipManyTill loggingNotification publishDiagnosticsNotification&#xA;count 4 (message :: Session ApplyWorkspaceEditRequest)&#xA;anyRequest &amp;lt;|&amp;gt; anyResponse&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Try out the example tests in the &lt;code&gt;lsp-test/example&lt;/code&gt; directory with &lt;code&gt;cabal test&lt;/code&gt;. For more examples check the &lt;a href=&#34;https://github.com/bubba/lsp-test/wiki/Introduction&#34;&gt;Wiki&lt;/a&gt;, or see this &lt;a href=&#34;https://lukelau.me/haskell/posts/lsp-test/&#34;&gt;introductory blog post&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Whilst writing your tests you may want to debug them to see what&#39;s going wrong. You can set the &lt;code&gt;logMessages&lt;/code&gt; and &lt;code&gt;logStdErr&lt;/code&gt; options in &lt;code&gt;SessionConfig&lt;/code&gt; to see what the server is up to. There are also corresponding environment variables so you can turn them on from the command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;LSP_TEST_LOG_MESSAGES=1 LSP_TEST_LOG_STDERR=1 cabal test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;Seeing funny stuff when running lsp-test via stack? If your server is built upon Haskell tooling, &lt;a href=&#34;https://github.com/alanz/haskell-ide-engine/raw/bfb16324d396da71000ef81d51acbebbdaa854ab/test/utils/TestUtils.hs#L290-L298&#34;&gt;keep in mind that stack sets some environment variables related to GHC, and you may want to unset them.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Useful links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Microsoft/language-server-protocol/raw/master/protocol.md&#34;&gt;Language Server Protocol Specification&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Other resources&lt;/h2&gt; &#xA;&lt;p&gt;See #haskell-language-server on IRC freenode.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ghc/ghc</title>
    <updated>2022-08-29T01:40:54Z</updated>
    <id>tag:github.com,2022-08-29:/ghc/ghc</id>
    <link href="https://github.com/ghc/ghc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Mirror of the Glasgow Haskell Compiler. Please submit issues and patches to GHC&#39;s Gitlab instance (https://gitlab.haskell.org/ghc/ghc). First time contributors are encouraged to get started with the newcomers info (https://gitlab.haskell.org/ghc/ghc/wikis/contributing).&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Glasgow Haskell Compiler&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/commits/master&#34;&gt;&lt;img src=&#34;https://gitlab.haskell.org/ghc/ghc/badges/master/pipeline.svg?style=flat&#34; alt=&#34;pipeline status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is the source tree for &lt;a href=&#34;http://www.haskell.org/ghc/&#34; title=&#34;www.haskell.org/ghc/&#34;&gt;GHC&lt;/a&gt;, a compiler and interactive environment for the Haskell functional programming language.&lt;/p&gt; &#xA;&lt;p&gt;For more information, visit &lt;a href=&#34;http://www.haskell.org/ghc/&#34; title=&#34;www.haskell.org/ghc/&#34;&gt;GHC&#39;s web site&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Information for developers of GHC can be found on the &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/issues&#34; title=&#34;gitlab.haskell.org/ghc/ghc/issues&#34;&gt;GHC issue tracker&lt;/a&gt;, and you can also view &lt;a href=&#34;https://github.com/ghc-proposals/ghc-proposals&#34; title=&#34;https://github.com/ghc-proposals/ghc-proposals&#34;&gt;proposals for new GHC features&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Getting the Source&lt;/h1&gt; &#xA;&lt;p&gt;There are two ways to get a source tree:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Download source tarballs&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Download the GHC source distribution:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;ghc-&amp;lt;version&amp;gt;-src.tar.xz&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;which contains GHC itself and the &#34;boot&#34; libraries.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Check out the source code from git&lt;/em&gt;&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ git clone --recurse-submodules git@gitlab.haskell.org:ghc/ghc.git&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Note: cloning GHC from Github requires a special setup. See &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/wikis/building/getting-the-sources#cloning-from-github&#34; title=&#34;https://gitlab.haskell.org/ghc/ghc/wikis/building/getting-the-sources#cloning-from-github&#34;&gt;Getting a GHC repository from Github&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;em&gt;See the GHC team&#39;s working conventions regarding &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/wikis/working-conventions/fixing-bugs&#34;&gt;how to contribute a patch to GHC&lt;/a&gt;.&lt;/em&gt; First time contributors are encouraged to get started by just sending a Merge Request.&lt;/p&gt; &#xA;&lt;h1&gt;Building &amp;amp; Installing&lt;/h1&gt; &#xA;&lt;p&gt;For full information on building GHC, see the &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/wikis/building&#34; title=&#34;https://gitlab.haskell.org/ghc/ghc/wikis/building&#34;&gt;GHC Building Guide&lt;/a&gt;. Here follows a summary - if you get into trouble, the Building Guide has all the answers.&lt;/p&gt; &#xA;&lt;p&gt;Before building GHC you may need to install some other tools and libraries. See, &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/wikis/building/preparation&#34; title=&#34;https://gitlab.haskell.org/ghc/ghc/wikis/building/preparation&#34;&gt;Setting up your system for building GHC&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NB.&lt;/em&gt; In particular, you need &lt;a href=&#34;http://www.haskell.org/ghc/&#34; title=&#34;www.haskell.org/ghc/&#34;&gt;GHC&lt;/a&gt; installed in order to build GHC, because the compiler is itself written in Haskell. You also need &lt;a href=&#34;http://www.haskell.org/happy/&#34; title=&#34;www.haskell.org/happy/&#34;&gt;Happy&lt;/a&gt;, &lt;a href=&#34;http://www.haskell.org/alex/&#34; title=&#34;www.haskell.org/alex/&#34;&gt;Alex&lt;/a&gt;, and &lt;a href=&#34;http://www.haskell.org/cabal/&#34; title=&#34;http://www.haskell.org/cabal/&#34;&gt;Cabal&lt;/a&gt;. For instructions on how to port GHC to a new platform, see the &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/wikis/building&#34; title=&#34;https://gitlab.haskell.org/ghc/ghc/wikis/building&#34;&gt;GHC Building Guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For building library documentation, you&#39;ll need &lt;a href=&#34;http://www.haskell.org/haddock/&#34; title=&#34;www.haskell.org/haddock/&#34;&gt;Haddock&lt;/a&gt;. To build the compiler documentation, you need &lt;a href=&#34;http://www.sphinx-doc.org/&#34;&gt;Sphinx&lt;/a&gt; and Xelatex (only for PDF output).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Quick start&lt;/strong&gt;: the following gives you a default build:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./boot&#xA;$ ./configure&#xA;$ make         # can also say &#39;make -jX&#39; for X number of jobs&#xA;$ make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Windows, you need an extra repository containing some build tools. These can be downloaded for you by configure. This only needs to be done once by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./configure --enable-tarballs-autodownload&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(NB: &lt;strong&gt;Do you have multiple cores? Be sure to tell that to &lt;code&gt;make&lt;/code&gt;!&lt;/strong&gt; This can save you hours of build time depending on your system configuration, and is almost always a win regardless of how many cores you have. As a simple rule, you should have about N+1 jobs, where &lt;code&gt;N&lt;/code&gt; is the amount of cores you have.)&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;./boot&lt;/code&gt; step is only necessary if this is a tree checked out from git. For source distributions downloaded from &lt;a href=&#34;http://www.haskell.org/ghc/&#34; title=&#34;www.haskell.org/ghc/&#34;&gt;GHC&#39;s web site&lt;/a&gt;, this step has already been performed.&lt;/p&gt; &#xA;&lt;p&gt;These steps give you the default build, which includes everything optimised and built in various ways (eg. profiling libs are built). It can take a long time. To customise the build, see the file &lt;code&gt;HACKING.md&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Filing bugs and feature requests&lt;/h1&gt; &#xA;&lt;p&gt;If you&#39;ve encountered what you believe is a bug in GHC, or you&#39;d like to propose a feature request, please let us know! Submit an &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/issues&#34; title=&#34;https://gitlab.haskell.org/ghc/ghc/issues&#34;&gt;issue&lt;/a&gt; and we&#39;ll be sure to look into it. Remember: &lt;strong&gt;Filing a bug is the best way to make sure your issue isn&#39;t lost over time&lt;/strong&gt;, so please feel free.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re an active user of GHC, you may also be interested in joining the &lt;a href=&#34;http://www.haskell.org/pipermail/glasgow-haskell-users/&#34; title=&#34;http://www.haskell.org/pipermail/glasgow-haskell-users/&#34;&gt;glasgow-haskell-users&lt;/a&gt; mailing list, where developers and GHC users discuss various topics and hang out.&lt;/p&gt; &#xA;&lt;h1&gt;Hacking &amp;amp; Developing GHC&lt;/h1&gt; &#xA;&lt;p&gt;Once you&#39;ve filed a bug, maybe you&#39;d like to fix it yourself? That would be great, and we&#39;d surely love your company! If you&#39;re looking to hack on GHC, check out the guidelines in the &lt;code&gt;HACKING.md&lt;/code&gt; file in this directory - they&#39;ll get you up to speed quickly.&lt;/p&gt; &#xA;&lt;h1&gt;Contributors &amp;amp; Acknowledgements&lt;/h1&gt; &#xA;&lt;p&gt;GHC in its current form wouldn&#39;t exist without the hard work of &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/wikis/team-ghc&#34; title=&#34;https://gitlab.haskell.org/ghc/ghc/wikis/team-ghc&#34;&gt;its many contributors&lt;/a&gt;. Over time, it has grown to include the efforts and research of many institutions, highly talented people, and groups from around the world. We&#39;d like to thank them all, and invite you to join!&lt;/p&gt;</summary>
  </entry>
</feed>