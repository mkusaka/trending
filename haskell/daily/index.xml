<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-08T01:34:13Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>luc-tielen/eclair-lang</title>
    <updated>2022-11-08T01:34:13Z</updated>
    <id>tag:github.com,2022-11-08:/luc-tielen/eclair-lang</id>
    <link href="https://github.com/luc-tielen/eclair-lang" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A minimal, fast Datalog implementation in Haskell that compiles to LLVM&lt;/p&gt;&lt;hr&gt;&lt;picture&gt; &#xA; &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;./logo_dark.png&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/luc-tielen/eclair-lang/main/logo_light.png&#34; alt=&#34;Logo for the Eclair programming language&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34;&gt; &#xA;&lt;/picture&gt; &#xA;&lt;p&gt;&lt;em&gt;An experimental and minimal Datalog implementation that compiles down to LLVM.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Eclair is a minimal Datalog (for now). It supports the following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Facts containing literals&lt;/li&gt; &#xA; &lt;li&gt;Rules consisting of one or more clauses.&lt;/li&gt; &#xA; &lt;li&gt;Rules can be non-recursive, recursive or mutually recursive.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It&#39;s still early stage software, not ready for real use. Right now it compiles to LLVM but be aware there might still be bugs. Some edge cases might not be handled yet.&lt;/p&gt; &#xA;&lt;h2&gt;Motivating example&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s say we want to find out which points are reachable in a graph. We can determine which points are reachable using the following two logical rules:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;One point is reachable from another point, iff there is a direct edge between those two points.&lt;/li&gt; &#xA; &lt;li&gt;One point is reachable from another point, iff there is a third point &#39;z&#39; such that there is a direct edge between &#39;x&#39; and &#39;z&#39;, and between &#39;z&#39; and &#39;y&#39;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The Eclair code below can be used to calculate the solution:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-eclair&#34;&gt;@def edge(u32, u32).&#xA;@def reachable(u32, u32).&#xA;&#xA;reachable(x, y) :-&#xA;  edge(x, y).&#xA;&#xA;reachable(x, z) :-&#xA;  edge(x, y),&#xA;  reachable(y, z).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above code can be compiled to LLVM using the Docker image provided by this repo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone git@github.com:luc-tielen/eclair-lang.git&#xA;$ cd eclair-lang&#xA;$ docker build . -t eclair&#xA;# The next line assumes the eclair code is saved as &#34;example.dl&#34; in the current directory&#xA;$ docker run -v $PWD:/code --rm -it eclair:latest compile /code/example.dl&#xA;# NOTE: output can be redirected to a file using standard shell functionality: docker run ... &amp;gt; example.ll&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will emit the generated LLVM IR to the stdout of the terminal. If we save this generated LLVM IR to a file (e.g. &lt;code&gt;example.ll&lt;/code&gt;), we can link it with the following C code that calls into Eclair, using the following command: &lt;code&gt;clang -o program main.c example.ll&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Save this file as &#34;main.c&#34;.&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;#include &amp;lt;stdbool.h&amp;gt;&#xA;#include &amp;lt;stdint.h&amp;gt;&#xA;&#xA;&#xA;struct program;&#xA;&#xA;extern struct program* eclair_program_init();&#xA;extern void eclair_program_destroy(struct program*);&#xA;extern void eclair_program_run(struct program*);&#xA;extern void eclair_add_facts(struct program*, uint16_t fact_type, uint32_t* data, size_t fact_count);&#xA;extern void eclair_add_fact(struct program*, uint16_t fact_type, uint32_t* data);&#xA;extern uint32_t* eclair_get_facts(struct program*, uint16_t fact_type);&#xA;extern void eclair_free_buffer(uint32_t* data);&#xA;&#xA;int main(int argc, char** argv)&#xA;{&#xA;    struct program* prog = eclair_program_init();&#xA;&#xA;    // edge(1,2), edge(2,3)&#xA;    uint32_t data[] = {&#xA;        1, 2,&#xA;        2, 3&#xA;    };&#xA;    eclair_add_facts(prog, 0, data, 2);&#xA;&#xA;    eclair_program_run(prog);&#xA;&#xA;    // NOTE: normally you call btree_size here to figure out the size, but I know there are only 3 facts&#xA;    uint32_t* data_out = eclair_get_facts(prog, 1);&#xA;    printf(&#34;REACHABLE: (%d, %d)\n&#34;, data_out[0], data_out[1]);  // (1,2)&#xA;    printf(&#34;REACHABLE: (%d, %d)\n&#34;, data_out[2], data_out[3]);  // (2,3)&#xA;    printf(&#34;REACHABLE: (%d, %d)\n&#34;, data_out[4], data_out[5]);  // (1,3)&#xA;&#xA;    eclair_free_buffer(data_out);&#xA;&#xA;    eclair_program_destroy(prog);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you run the resulting program, this should print the reachable node pairs &lt;code&gt;(1,2)&lt;/code&gt;, &lt;code&gt;(2,3)&lt;/code&gt; and &lt;code&gt;(1,3)&lt;/code&gt; to the screen!&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Compile to LLVM&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Release 0.0.1&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Proper error handling&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support wildcards (&lt;code&gt;_&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support other data types than integers (strings, ...), add typesystem&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support &lt;code&gt;=&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Compile to WASM&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Release 0.0.2&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; LSP support&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Support negation, &lt;code&gt;!=&lt;/code&gt; operator&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Support arithmetic / logical / ... operators&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Optimizations on the AST / RA / LLVM level&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Support other underlying data structures than btree&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; ...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This roadmap is not set in stone, but it gives an idea on the direction of the project. &lt;span&gt;ðŸ˜„&lt;/span&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing to Eclair&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are welcome! Take a look at the &lt;a href=&#34;https://raw.githubusercontent.com/luc-tielen/eclair-lang/main/docs/getting_started.md&#34;&gt;getting started guide&lt;/a&gt; on how to set up your machine to build, run and test the project. Once setup, the Makefile contains the most commonly used commands needed during development.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Take a look at our &lt;a href=&#34;https://raw.githubusercontent.com/luc-tielen/eclair-lang/main/docs/&#34;&gt;docs folder&lt;/a&gt; for more information about Eclair.&lt;/p&gt; &#xA;&lt;h2&gt;Why the name?&lt;/h2&gt; &#xA;&lt;p&gt;Eclair is inspired by &lt;a href=&#34;https://souffle-lang.github.io/&#34;&gt;SoufflÃ©&lt;/a&gt;, a high performance Datalog that compiles to C++. Because of the similarities, I chose a different kind of food that I like. I mean, an eclair contains &lt;em&gt;both&lt;/em&gt; chocolate and pudding, what&#39;s not to like!?&lt;/p&gt; &#xA;&lt;p&gt;Logo art by &lt;a href=&#34;https://www.instagram.com/bruno_monts/&#34;&gt;Bruno Monts&lt;/a&gt;, with special thanks to the &lt;a href=&#34;https://fission.codes&#34;&gt;Fission&lt;/a&gt; team. Please contact Luc Tielen before using the logo for anything.&lt;/p&gt;</summary>
  </entry>
</feed>