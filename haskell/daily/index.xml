<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-03T01:34:46Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>japiirainen/fp</title>
    <updated>2022-11-03T01:34:46Z</updated>
    <id>tag:github.com,2022-11-03:/japiirainen/fp</id>
    <link href="https://github.com/japiirainen/fp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A small, weird and unpractical programming language.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/#table-of-contents&#34;&gt;Table of contents&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/#fp-programming-language&#34;&gt;fp programming language&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/#examples-of-fp&#34;&gt;Examples of &lt;code&gt;fp&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/#command-line&#34;&gt;Command line&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/#interpret&#34;&gt;Interpret&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/#repl&#34;&gt;REPL&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/#documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/#development&#34;&gt;Development&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/#nix-support&#34;&gt;Nix support&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/#tips&#34;&gt;Tips&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/#credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;fp programming language&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;fp&lt;/code&gt; is a programming language heavily inspired by the language John Backus described in his 1977 Turing Award lecture.&lt;/p&gt; &#xA;&lt;p&gt;The paper can be found &lt;a href=&#34;https://dl.acm.org/doi/10.1145/359576.359579&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Examples of &lt;code&gt;fp&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{- Matrix multiplication.&#xA;-}&#xA;&#xA;Def ip ≡ /+∘α*∘⍉&#xA;&#xA;Def mm ≡ α(α ip) ∘ α distl ∘ distr ∘ [~0, ⍉∘~1]&#xA;&#xA;mm:&amp;lt; &amp;lt; &amp;lt;1,2&amp;gt;, &amp;lt;4,5&amp;gt; &amp;gt;,&#xA;     &amp;lt; &amp;lt;6,8&amp;gt;, &amp;lt;7,9&amp;gt;&amp;gt; &amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;This section will give a quick tour of many of the language features of &lt;code&gt;fp&lt;/code&gt;. It will also cover the usage of the tools provided by &lt;code&gt;fp&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Command line&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;fp&lt;/code&gt; can be used without explicitly installing it via nix!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;nix run github:japiirainen/fp -- --help&#xA;                 &#xA;Up to date&#xA;Usage: fp COMMAND&#xA;&#xA;  Command-line utility for the `fp` programming language&#xA;&#xA;Available options:&#xA;  -h,--help                Show this help text&#xA;&#xA;Available commands:&#xA;  interpret                Interpret a `fp` file&#xA;  repl                     Enter a REPL for `fp`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Interpret&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;interpret&lt;/code&gt; command can be used to interpret &lt;code&gt;fp&lt;/code&gt; files.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Def ip ≡ /+∘α*∘⍉&#xA;&#xA;ip:&amp;lt;&amp;lt;1,2,3&amp;gt;,&amp;lt;6,5,4&amp;gt;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This program lives in &lt;code&gt;examples/ip.fp&lt;/code&gt; and can be interpreted like this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;cabal run fp -- interpret examples/ip.fp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which will yield &lt;code&gt;28&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;REPL&lt;/h3&gt; &#xA;&lt;p&gt;you can enter the &lt;code&gt;fp&lt;/code&gt; repl to get an interactive environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;fp repl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;λ +:&amp;lt;1,2&amp;gt;&#xA;3&#xA;λ :let xs = &amp;lt;1,2,3&amp;gt;&#xA;λ xs&#xA;&amp;lt;1,2,3&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Currently the &lt;code&gt;examples&lt;/code&gt; directory serves as the documentation! I will list some important topics below for reference.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/condition.fp&#34;&gt;Conditionals&lt;/a&gt; &lt;code&gt;Fp&lt;/code&gt; has a condition expression. It is similar to ternary operator in many ordinary languages.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/while.fp&#34;&gt;While&lt;/a&gt; &lt;code&gt;while&lt;/code&gt; provides a way to run a specific program many times, specifically untile some condition is met.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/bu.fp&#34;&gt;Binary to unary&lt;/a&gt; &lt;code&gt;bu&lt;/code&gt; gives a convenient way to turn binary (2 argument) functions into unary (1 argument) functions. This is kind of like partial application.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/mm.fp&#34;&gt;Matrix multiplication&lt;/a&gt; This examples shows how to do matrix multiplication in &lt;code&gt;fp&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/fact.fp&#34;&gt;Facrorials&lt;/a&gt; A way to compute factorial&#39;s in &lt;code&gt;fp&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here&#39;s a bunch of primitive functions.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/and-or-not.fp&#34;&gt;boolean algebra&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/append.fp&#34;&gt;append&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/applyToAll.fp&#34;&gt;applyToAll&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/atom.fp&#34;&gt;atom&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/const.fp&#34;&gt;const&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/construction.fp&#34;&gt;construction&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/dist.fp&#34;&gt;dist&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/eq.fp&#34;&gt;eq&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/id.fp&#34;&gt;id&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/length.fp&#34;&gt;length&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/nth.fp&#34;&gt;nth&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/null.fp&#34;&gt;null&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/reverse.fp&#34;&gt;reverse&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/transpose.fp&#34;&gt;transpose&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/rotate.fp&#34;&gt;rotate&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/japiirainen/fp/main/examples/fact.fp&#34;&gt;Unbound variable error&lt;/a&gt; &lt;code&gt;Fp&lt;/code&gt; also has nice error messages.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;You can also run the test suite.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cabal test tasty&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Nix support&lt;/h3&gt; &#xA;&lt;p&gt;You can alternatively use nix for dev environment and for building the project.&lt;/p&gt; &#xA;&lt;p&gt;Build:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nix build .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nix run .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Start Nix shell:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nix-shell&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tips&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Run &lt;code&gt;nix flake update&lt;/code&gt; to update all flake inputs.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;./bin/hoogle&lt;/code&gt; to start Hoogle with packages in your cabal file.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;treefmt&lt;/code&gt; in nix shell to autoformat the project. This uses treefmt, which uses ./treefmt.toml (where fourmolu and nixpkgs-fmt are specified).&lt;/li&gt; &#xA; &lt;li&gt;Run the application without installing: &lt;code&gt;nix run github:japiirainen/fp&lt;/code&gt; (or &lt;code&gt;nix run .&lt;/code&gt; from checkout)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;fp&lt;/code&gt; is a programming language heavily inspired by the language John Backus described in his 1977 Turing Award lecture.&lt;/p&gt; &#xA;&lt;p&gt;Currently almost all features described in the paper are implemented. This not implemented:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;recursion (I&#39;m not sure if I want to allow user defined recursion).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Gabriella Gonzalez&#39;s (Gabriella439) &lt;a href=&#34;https://github.com/Gabriella439/grace&#34;&gt;grace&lt;/a&gt; was an invaluable resource for interpreter design in haskell.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>snapframework/io-streams</title>
    <updated>2022-11-03T01:34:46Z</updated>
    <id>tag:github.com,2022-11-03:/snapframework/io-streams</id>
    <link href="https://github.com/snapframework/io-streams" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple, composable, and easy-to-use stream I/O for Haskell&lt;/p&gt;&lt;hr&gt;&lt;p&gt;The io-streams library contains simple and easy to use primitives for I/O using streams. Based on simple types with one type parameter (&lt;code&gt;InputStream a&lt;/code&gt; and &lt;code&gt;OutputStream a&lt;/code&gt;), io-streams provides a basic interface to side-effecting input and output in &lt;code&gt;IO&lt;/code&gt; monad with the following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;three fundamental I/O primitives that anyone can understand: &lt;code&gt;read :: InputStream a -&amp;gt; IO (Maybe a)&lt;/code&gt;, &lt;code&gt;unRead :: a -&amp;gt; InputStream a -&amp;gt; IO ()&lt;/code&gt;, and &lt;code&gt;write :: Maybe a -&amp;gt; OutputStream a -&amp;gt; IO ()&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;simple types and side-effecting IO operations mean straightforward and simple exception handling and resource cleanup using standard Haskell facilities like &lt;code&gt;bracket&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;code to transform files, handles, and sockets to streams&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;a variety of combinators for wrapping and transforming streams, including compression and decompression using zlib, controlling precisely how many bytes are read to or written from a socket, buffering output using &lt;code&gt;blaze-builder&lt;/code&gt;, etc.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;support for parsing from streams using &lt;code&gt;attoparsec&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>ingolia-lab/RiboSeq</title>
    <updated>2022-11-03T01:34:46Z</updated>
    <id>tag:github.com,2022-11-03:/ingolia-lab/RiboSeq</id>
    <link href="https://github.com/ingolia-lab/RiboSeq" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;FpAnalysis&lt;/h1&gt;</summary>
  </entry>
</feed>