<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-24T01:34:57Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>willtim/Expresso</title>
    <updated>2024-01-24T01:34:57Z</updated>
    <id>tag:github.com,2024-01-24:/willtim/Expresso</id>
    <link href="https://github.com/willtim/Expresso" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A simple expressions language with polymorphic extensible row types.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;☕ Expresso&lt;/h1&gt; &#xA;&lt;p&gt;A simple expressions language with polymorphic extensible row types.&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Expresso is a minimal statically-typed functional programming language, designed with embedding and/or extensibility in mind. Possible use cases for such a minimal language include configuration (à la Nix), data exchange (à la JSON) or even a starting point for a custom external DSL.&lt;/p&gt; &#xA;&lt;p&gt;Expresso has the following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A small and simple implementation&lt;/li&gt; &#xA; &lt;li&gt;Statically typed with type inference&lt;/li&gt; &#xA; &lt;li&gt;Structural typing with extensible records and variants&lt;/li&gt; &#xA; &lt;li&gt;Lazy evaluation&lt;/li&gt; &#xA; &lt;li&gt;Convenient use from Haskell (a type class for marshalling values)&lt;/li&gt; &#xA; &lt;li&gt;Whitespace insensitive syntax&lt;/li&gt; &#xA; &lt;li&gt;Type annotations to support first-class modules and schema validation use cases&lt;/li&gt; &#xA; &lt;li&gt;Built-in support for ints, double, bools, chars and lists&lt;/li&gt; &#xA; &lt;li&gt;Support for fixed-points (useful for dynamic binding), but without recursive records.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Expresso the library and executable (the REPL) is currently built and tested using cabal.&lt;/p&gt; &#xA;&lt;h2&gt;Functions&lt;/h2&gt; &#xA;&lt;p&gt;Expresso is a functional language and so we use lambda terms as our basic means of abstraction. To create a named function, we simply bind a lambda using let. I toyed with the idea of using Nix-style lambda syntax, e.g. &lt;code&gt;x: x&lt;/code&gt; for the identity function, but many mainstream languages, not just Haskell, use an arrow to denote a lambda term. An arrow is also consistent with the notation we use for types. Expresso therefore uses the arrow &lt;code&gt;-&amp;gt;&lt;/code&gt; to denote lambdas, with the parameters to bind on the left and the expression body on the right, for example &lt;code&gt;x -&amp;gt; x&lt;/code&gt; for identity.&lt;/p&gt; &#xA;&lt;p&gt;Note that multiple juxtaposed arguments is sugar for currying. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;f x -&amp;gt; f x&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is the same as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;f -&amp;gt; x -&amp;gt; f x&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function composition operators are &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; for forwards and backwards composition respectively.&lt;/p&gt; &#xA;&lt;h2&gt;Records&lt;/h2&gt; &#xA;&lt;p&gt;Expresso records are built upon row-types with row extension as the fundamental primitive. This gives a very simple and easy-to-use type system when compared to more advanced systems built upon concatenation as a primitive. However, even in this simple system, concatenation can be encoded quite easily using difference records.&lt;/p&gt; &#xA;&lt;p&gt;Records can of course contain arbitrary types and be arbitrarily nested. They can also be compared for equality. The dot operator (select) is used to project out values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Expresso REPL&#xA;Type :help or :h for a list of commands&#xA;Loaded Prelude from /home/tim/Expresso/Prelude.x&#xA;λ&amp;gt; {x = 1}.x&#xA;1&#xA;λ&amp;gt; {x = {y = &#34;foo&#34;}, z = [1,2,3]}.x.y&#xA;&#34;foo&#34;&#xA;λ&amp;gt; {x = 1, y = True} == {y = True, x = 1}&#xA;True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that records cannot refer to themselves, as Expresso does not support type-level recursion.&lt;/p&gt; &#xA;&lt;h3&gt;Record extension&lt;/h3&gt; &#xA;&lt;p&gt;Records are eliminated using selection &lt;code&gt;.&lt;/code&gt; and introduced using extension &lt;code&gt;|&lt;/code&gt;. For example, the record literal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{x = 1, y = True}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is really sugar for:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{x = 1 | { y = True | {}}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The row types use lacks constraints to prohibit overlapping field names. For example, the following is ill-typed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{x = 1, x = 2} -- DOES NOT TYPE CHECK!&#xA;&#xA;let r = {x = &#34;foo&#34;} in {x = &#34;bar&#34; | r} -- DOES NOT TYPE CHECK!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The lacks constraints are shown when printing out inferred row types via the REPL, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; :type r -&amp;gt; {x = 1 | r}&#xA;forall r. (r\x) =&amp;gt; {r} -&amp;gt; {x : Int | r}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above output, the REPL reports that this lambda can take a record with underlying row-type &lt;code&gt;r&lt;/code&gt;, providing &lt;code&gt;r&lt;/code&gt; satisfies the constraint that it does not have a field &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The type of a literal record is &lt;em&gt;closed&lt;/em&gt;, in that the set of fields is fully known:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; :type {x = 1}&#xA;{x : Int}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, we permit records with redundant fields as arguments to functions, by inferring &lt;em&gt;open&lt;/em&gt; record types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; let sqmag = {x, y} -&amp;gt; x*x + y*y&#xA;λ&amp;gt; :type sqmag&#xA;forall a r. (Num a, r\x\y) =&amp;gt; {x : a, y : a | r} -&amp;gt; a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An open record type is indicated by a row-type in the tail of the record.&lt;/p&gt; &#xA;&lt;p&gt;Note that the function definition for &lt;code&gt;sqmag&lt;/code&gt; above makes use of field punning. We could have alternatively written:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; let sqmag = r -&amp;gt; r.x*r.x + r.y*r.y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When matching on record arguments, sometimes it can be necessary to supply a new name to bind the values of a field to, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; let add = {x=r, y=s} {x=u, y=v} -&amp;gt; {x = r + u, y = s + v}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Record restriction&lt;/h3&gt; &#xA;&lt;p&gt;We can remove a field by using the restriction primitive &lt;code&gt;\&lt;/code&gt;. For example, the following will type-check:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{x = 1 | {x = 2}\x}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also use the following syntactic sugar, for such an override:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{x := 1 | {x = 1}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;First-class modules&lt;/h3&gt; &#xA;&lt;p&gt;Records can be used as a simple but powerful module system. For example, imagine a module &lt;code&gt;&#34;List.x&#34;&lt;/code&gt; with derived operations on lists:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;let&#xA;    reverse     = foldl (xs x -&amp;gt; x :: xs) [];&#xA;    intercalate = xs xss -&amp;gt; concat (intersperse xs xss);&#xA;    ...&#xA;&#xA;-- Exports&#xA;in { reverse&#xA;   , intercalate&#xA;   , ...&#xA;   }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Such a module can be imported using a &lt;code&gt;let&lt;/code&gt; declaration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; let list = import &#34;List.x&#34;&#xA;λ&amp;gt; :type list.intercalate&#xA;forall a. [a] -&amp;gt; [[a]] -&amp;gt; [a]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or simply:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; let {..} = import &#34;List.x&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Records with polymorphic functions can be passed as lambda arguments and remain polymorphic using &lt;em&gt;higher-rank polymorphism&lt;/em&gt;. To accomplish this, we must provide Expresso with a suitable type annotation of the argument. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;let f = (m : forall a. { reverse : [a] -&amp;gt; [a] |_}) -&amp;gt;&#xA;            {l = m.reverse [True, False], r = m.reverse [1,2,3] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function &lt;code&gt;f&lt;/code&gt; above takes a &#34;module&#34; &lt;code&gt;m&lt;/code&gt; containing a polymorphic function &lt;code&gt;reverse&lt;/code&gt;. We annotate &lt;code&gt;m&lt;/code&gt; with a type by using a single colon &lt;code&gt;:&lt;/code&gt; followed by the type we are expecting. Note the underscore &lt;code&gt;_&lt;/code&gt; in the tail of the record. This is a &lt;em&gt;type wildcard&lt;/em&gt;, meaning we have specified a &lt;em&gt;partial type signature&lt;/em&gt;. This type wildcard allows us to pass an arbitrary module containing a &lt;code&gt;reverse&lt;/code&gt; function with this signature. To see the full type signature of &lt;code&gt;f&lt;/code&gt;, we can use the Expresso REPL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; :t f&#xA;forall r. (r\reverse) =&amp;gt; (forall a. {reverse : [a] -&amp;gt; [a] | r}) -&amp;gt;&#xA;    {l : [Bool], r : [Int]}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the &lt;code&gt;r&lt;/code&gt;, representing the rest of the module fields, is a top-level quantifier. The type wildcard is especially useful here, as it allows us to avoid creating a top-level signature for the entire function and explicitly naming this row variable. More generally, type wildcards allow us to leave parts of a type signature unspecified.&lt;/p&gt; &#xA;&lt;p&gt;Function &lt;code&gt;f&lt;/code&gt; can now of course be applied to any module satisfying the type signature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; f (import &#34;List.x&#34;)&#xA;{l = [False, True], r = [3,2,1]}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Difference records and concatenation&lt;/h3&gt; &#xA;&lt;p&gt;To encode concatenation, we can use functions that extend records and compose them using straightforward function composition:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;let f = (r -&amp;gt; { x = &#34;foo&#34;, y = True | r}) &amp;gt;&amp;gt; (r -&amp;gt; { z = &#34;bar&#34; | r})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Expresso has a special syntax for such &#34;difference records&#34;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; let f = {| x = &#34;foo&#34;, y = True |} &amp;gt;&amp;gt; {| z = &#34;bar&#34; |}&#xA;λ&amp;gt; f {}&#xA;{z = &#34;bar&#34;, x = &#34;foo&#34;, y = True}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Concatenation is asymmetric whenever we use overrides, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; {| x = &#34;foo&#34; |} &amp;gt;&amp;gt; {| x := &#34;bar&#34; |} -- Type checks&#xA; {| x = &#34;foo&#34; |} &amp;lt;&amp;lt; {| x := &#34;bar&#34; |} -- DOES NOT TYPE CHECK!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;The Unit type&lt;/h3&gt; &#xA;&lt;p&gt;The type &lt;code&gt;{}&lt;/code&gt; is an example of a &lt;em&gt;Unit&lt;/em&gt; type. It has only one inhabitant, the empty record &lt;code&gt;{}&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; :type {}&#xA;{}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Variants&lt;/h2&gt; &#xA;&lt;p&gt;The dual of records are variants, which are also polymorphic and extensible since they use the same underlying row-types. Variants are introduced via injection (the dual of record selection), for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; Foo 1&#xA;Foo 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unlike literal records, literal variants are &lt;em&gt;open&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; :type Foo 1&#xA;forall r. (r\Foo) =&amp;gt; &amp;lt;Foo : Int | r&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Variants are eliminated using the case construct, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; case Foo 1 of { Foo x -&amp;gt; x, Bar{x,y} -&amp;gt; x+y }&#xA;1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above case expression eliminates a &lt;em&gt;closed&lt;/em&gt; variant, meaning any value other than &lt;code&gt;Foo&lt;/code&gt; or &lt;code&gt;Bar&lt;/code&gt; with their expected payloads would lead to a type error. To eliminate an &lt;em&gt;open&lt;/em&gt; variant, we use a syntax analogous to extension:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; let f = x -&amp;gt; case x of { Foo x -&amp;gt; x, Bar{x,y} -&amp;gt; x+y | otherwise -&amp;gt; 42 }&#xA;λ&amp;gt; f (Baz{})&#xA;42&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here the unmatched variant is passed to a lambda (with &lt;code&gt;otherwise&lt;/code&gt; as the parameter). The expression after the bar &lt;code&gt;|&lt;/code&gt; typically either ignores the variant or delegates it to another function.&lt;/p&gt; &#xA;&lt;h3&gt;Closed variants&lt;/h3&gt; &#xA;&lt;p&gt;We will often need to create closed variant types. For example, we may want to create a structural type analogous to Haskell&#39;s &lt;code&gt;Maybe a&lt;/code&gt;, having only two constructors: &lt;code&gt;Nothing&lt;/code&gt; and &lt;code&gt;Just&lt;/code&gt;. This can be accomplished using smart constructors with type annotations. In the Prelude, we define the equivalent constructors &lt;code&gt;just&lt;/code&gt; and &lt;code&gt;nothing&lt;/code&gt;, as well as a fold &lt;code&gt;maybe&lt;/code&gt; over this closed set:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;type Maybe a = &amp;lt;Just : a, Nothing : {}&amp;gt;;&#xA;&#xA;just        : forall a. a -&amp;gt; Maybe a&#xA;            = x -&amp;gt; Just x;&#xA;&#xA;nothing     : forall a. Maybe a&#xA;            = Nothing{};&#xA;&#xA;maybe       = b f m -&amp;gt; case m of { Just a -&amp;gt; f a, Nothing{} -&amp;gt; b }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we declare and use a type synonym &lt;code&gt;Maybe a&lt;/code&gt; to avoid repeating the type &lt;code&gt;&amp;lt;Just : a, Nothing : {}&amp;gt;&lt;/code&gt;. Type synonyms can be included at the top of any file and have global scope.&lt;/p&gt; &#xA;&lt;h3&gt;Variant embedding&lt;/h3&gt; &#xA;&lt;p&gt;The dual of record restriction is variant embedding. This allows us to restrict the behaviour exposed by a case expression, by exploiting the non-overlapping field constraints. For example, to prevent use of the &lt;code&gt;Bar&lt;/code&gt; alternative of function &lt;code&gt;f&lt;/code&gt; above, we can define a new function &lt;code&gt;g&lt;/code&gt; as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; let g = x -&amp;gt; f (&amp;lt;|Bar|&amp;gt; x)&#xA;λ&amp;gt; :type g&#xA;forall r. (r\Bar\Foo) =&amp;gt; &amp;lt;Foo : Int | r&amp;gt; -&amp;gt; Int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Embedding is used internally to implement overriding alternatives, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; let g = x -&amp;gt; case x of { override Foo x -&amp;gt; x + 1 | f }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is sugar for:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; let g = x -&amp;gt; case x of { Foo x -&amp;gt; x + 1 | &amp;lt;|Foo|&amp;gt; &amp;gt;&amp;gt; f }&#xA;&#xA;λ&amp;gt; :type g&#xA;forall r1 r2. (r1\x\y, r2\Bar\Foo) =&amp;gt; &amp;lt;Foo : Int, Bar : {x : Int, y : Int | r1} | r2&amp;gt; -&amp;gt; Int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;The Void type&lt;/h3&gt; &#xA;&lt;p&gt;Internally, the syntax to eliminate a closed variant uses the empty variant type &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, also known as &lt;em&gt;Void&lt;/em&gt;. The Void type has no inhabitants, but we can use it to define a function &lt;code&gt;absurd&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; :type absurd&#xA;forall a. &amp;lt;&amp;gt; -&amp;gt; a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Absurd is an example of &lt;em&gt;Ex Falso Quodlibet&lt;/em&gt; from classical logic (anything can be proven using a contradiction as a premise).&lt;/p&gt; &#xA;&lt;p&gt;As an example of the above, the following closed case expression:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;case x of { Foo{} -&amp;gt; 1, Bar{} -&amp;gt; 2 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is actually sugar for:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;case x of { Foo{} -&amp;gt; 1 | x&#39; -&amp;gt; case x&#39; of { Bar{} -&amp;gt; 2 | absurd } }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;A data-exchange format with schemas&lt;/h2&gt; &#xA;&lt;p&gt;We could use Expresso as a lightweight data-exchange format (i.e. JSON with types). But how might we validate terms against a schema?&lt;/p&gt; &#xA;&lt;p&gt;A simple type annotation &lt;code&gt;&amp;lt;term&amp;gt; : &amp;lt;type&amp;gt;&lt;/code&gt; , will not suffice for &#34;schema validation&#34;. For example, consider this attempt at validating an integer against a schema that permits everything:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1 : forall a. a        -- DOES NOT TYPE CHECK!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above fails to type check since the left-hand-side is inferred as the most general type (here a concrete int) and the right-hand-side must be less so.&lt;/p&gt; &#xA;&lt;p&gt;Instead we need something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(id : forall a. a -&amp;gt; a) 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A nice syntactic sugar for this is a &lt;em&gt;signature section&lt;/em&gt;, although the version in Expresso is slightly different from the Haskell proposal. We write &lt;code&gt;(:T)&lt;/code&gt; to mean &lt;code&gt;id : T -&amp;gt; T&lt;/code&gt;, where any quantifiers are kept at the top-level. We can now use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(: forall a. a) 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we really do have places in our schema where we want to permit arbitrary data, we should use the equality constraint to guarantee the absence of partially-applied functions. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(: forall a. Eq a =&amp;gt; { x : &amp;lt;Foo : Int, Bar : a&amp;gt; }) { x = Bar id }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;would fail to type check. But the following succeeds:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; (: forall a. Eq a =&amp;gt; { x : &amp;lt;Foo : Int, Bar : a&amp;gt; }) { x = Bar &#34;abc&#34; }&#xA;{x = Bar &#34;abc&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Lazy evaluation&lt;/h2&gt; &#xA;&lt;p&gt;Expresso uses lazy evaluation in the hope that it might lead to efficiency gains when working with large nested records.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; :peek {x = &#34;foo&#34;}&#xA;{x = &amp;lt;Thunk&amp;gt;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Turing equivalence?&lt;/h2&gt; &#xA;&lt;p&gt;Turing equivalence is introduced via a single &lt;code&gt;fix&lt;/code&gt; primitive, which can be easily removed or disabled. &lt;code&gt;fix&lt;/code&gt; can be useful to achieve open recursive records and dynamic binding (à la Nix).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;λ&amp;gt; let r = mkOverridable (self -&amp;gt; {x = &#34;foo&#34;, y = self.x &amp;lt;&amp;gt; &#34;bar&#34;})&#xA;λ&amp;gt; r&#xA;{override_ = &amp;lt;Lambda&amp;gt;, x = &#34;foo&#34;, y = &#34;foobar&#34;}&#xA;&#xA;λ&amp;gt; override r {| x := &#34;baz&#34; |}&#xA;{override_ = &amp;lt;Lambda&amp;gt;, x = &#34;baz&#34;, y = &#34;bazbar&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that removing &lt;code&gt;fix&lt;/code&gt; and Turing equivalence does not guarantee termination in practice. It is still possible to write exponential programs that will not terminate during the lifetime of the universe without recursion or fix.&lt;/p&gt; &#xA;&lt;h2&gt;A configuration file format&lt;/h2&gt; &#xA;&lt;p&gt;Expresso can be used as a typed configuration file format from within Haskell programs. As an example, let&#39;s consider a hypothetical small config file for a backup program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;let awsTemplate =&#xA;    { location =&#34;s3://s3-eu-west-1.amazonaws.com/tim-backup&#34;&#xA;    , include  = []&#xA;    , exclude  = []&#xA;    }&#xA;in&#xA;{ cachePath   = Default{}&#xA;, taskThreads = Override 2&#xA;, profiles =&#xA;   [ { name = &#34;pictures&#34;&#xA;     , source = &#34;~/Pictures&#34;&#xA;     | awsTemplate&#xA;     }&#xA;   , { name = &#34;music&#34;&#xA;     , source = &#34;~/Music&#34;&#xA;     , exclude := [&#34;**/*.m4a&#34;]&#xA;     | awsTemplate }&#xA;   ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that even for such a small example, we can already leverage some of the abstraction power of extensible records to avoid repetition in the config file.&lt;/p&gt; &#xA;&lt;p&gt;In order to consume this file from a Haskell program, we can define some corresponding nominal data types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;data Config = Config&#xA;    { configCachePath   :: Overridable Text&#xA;    , configTaskThreads :: Overridable Integer&#xA;    , configProfiles    :: [Profile]&#xA;    } deriving Show&#xA;&#xA;data Overridable a = Default | Override a deriving Show&#xA;&#xA;data Profile = Profile&#xA;    { profileName     :: Text&#xA;    , profileLocation :: Text&#xA;    , profileInclude  :: [Text]&#xA;    , profileExclude  :: [Text]&#xA;    , profileSource   :: Text&#xA;    } deriving Show&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using the Expresso API, we can write &lt;code&gt;HasValue&lt;/code&gt; instances to handle the projection into and injection from, Haskell values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;import Expresso&#xA;&#xA;instance HasValue Config where&#xA;    proj v = Config&#xA;        &amp;lt;$&amp;gt; v .: &#34;cachePath&#34;&#xA;        &amp;lt;*&amp;gt; v .: &#34;taskThreads&#34;&#xA;        &amp;lt;*&amp;gt; v .: &#34;profiles&#34;&#xA;    inj Config{..} = mkRecord&#xA;        [ &#34;cachePath&#34;      .= inj configCachePath&#xA;        , &#34;taskThreads&#34;    .= inj configTaskThreads&#xA;        , &#34;profiles&#34;       .= inj configProfiles&#xA;        ]&#xA;&#xA;instance HasValue a =&amp;gt; HasValue (Overridable a) where&#xA;    proj = choice [(&#34;Override&#34;, fmap Override . proj)&#xA;                  ,(&#34;Default&#34;,  const $ pure Default)&#xA;                  ]&#xA;    inj (Override x) = mkVariant &#34;Override&#34; (inj x)&#xA;    inj Default = mkVariant &#34;Default&#34; unit&#xA;&#xA;instance HasValue Profile where&#xA;    proj v = Profile&#xA;        &amp;lt;$&amp;gt; v .: &#34;name&#34;&#xA;        &amp;lt;*&amp;gt; v .: &#34;location&#34;&#xA;        &amp;lt;*&amp;gt; v .: &#34;include&#34;&#xA;        &amp;lt;*&amp;gt; v .: &#34;exclude&#34;&#xA;        &amp;lt;*&amp;gt; v .: &#34;source&#34;&#xA;    inj Profile{..} = mkRecord&#xA;        [ &#34;name&#34;     .= inj profileName&#xA;        , &#34;location&#34; .= inj profileLocation&#xA;        , &#34;include&#34;  .= inj profileInclude&#xA;        , &#34;exclude&#34;  .= inj profileExclude&#xA;        , &#34;source&#34;   .= inj profileSource&#xA;        ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Before we load the config file, we will probably want to check the inferred types against an agreed signature (a.k.a. schema validation). The Expresso API provides a Template Haskell quasi-quoter to make this convenient from within Haskell:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;import Expresso.TH.QQ&#xA;&#xA;schema :: Type&#xA;schema =&#xA;  [expressoType|&#xA;    { cachePath   : &amp;lt;Default : {}, Override : Text&amp;gt;&#xA;    , taskThreads : &amp;lt;Default : {}, Override : Int&amp;gt;&#xA;    , profiles :&#xA;        [ { name     : Text&#xA;          , location : Text&#xA;          , include  : [Text]&#xA;          , exclude  : [Text]&#xA;          , source   : Text&#xA;          }&#xA;        ]&#xA;    }|]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can thus load, validate and evaluate the above config file using the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;loadConfig :: FilePath -&amp;gt; IO (Either String Config)&#xA;loadConfig = evalFile (Just schema)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we can also install our own custom values/functions for users to reference in their config files. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;loadConfig :: FilePath -&amp;gt; IO (Either String Config)&#xA;loadConfig = evalFile&#39; envs (Just schema)&#xA;  where&#xA;    envs = installBinding &#34;system&#34; TText (inj System.Info.os)&#xA;         . installBinding &#34;takeFileName&#34;  (TFun TText TText) (inj takeFileName)&#xA;         . installBinding &#34;takeDirectory&#34; (TFun TText TText) (inj takeDirectory)&#xA;         . installBinding &#34;doesPathExist&#34; (TFun TText TBool) (inj doesPathExist) -- NB: This does IO reads&#xA;         $ initEnvironments&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, we need not limit ourselves to config files that specify record values. We can project Expresso function values into Haskell functions (in IO), allowing higher-order config files! The projection itself is handled by the &lt;code&gt;HasValue&lt;/code&gt; class, just like any other value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; Haskell&amp;gt; Right (f :: Integer -&amp;gt; IO Integer) &amp;lt;- evalString (Just $ TFun TInt TInt) &#34;x -&amp;gt; x + 1&#34;&#xA; Haskell&amp;gt; f 1&#xA; 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;p&gt;Expresso is built upon many ideas described in the following publications:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;Practical type inference for arbitrary-rank types&#34; Peyton-Jones et al. 2011.&lt;/li&gt; &#xA; &lt;li&gt;&#34;A Polymorphic Type System for Extensible Records and Variants&#34; B. R. Gaster and M. P. Jones, 1996.&lt;/li&gt; &#xA; &lt;li&gt;&#34;Extensible records with scoped labels&#34; D. Leijen, 2005.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>ivanbakel/hout-prover</title>
    <updated>2024-01-24T01:34:57Z</updated>
    <id>tag:github.com,2024-01-24:/ivanbakel/hout-prover</id>
    <link href="https://github.com/ivanbakel/hout-prover" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A non-interactive proof assistant using the Haskell type system&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;hout - a non-interactive proof assistant for first-order logic, in Haskell &lt;a href=&#34;https://hackage.haskell.org/package/hout&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/hout&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;hout is an in-Haskell non-interactive proof assistant for intuitionistic first-order logic.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, hout provides a monad that allows you to write functions in the style of proof-assistant proofs, which are then computable Haskell terms.&lt;/p&gt; &#xA;&lt;p&gt;This is possible thanks to the Curry-Howard isomorphism.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Have a look at &lt;code&gt;examples/Hout/Examples.hs&lt;/code&gt; for some examples.&lt;/p&gt; &#xA;&lt;h2&gt;What?&lt;/h2&gt; &#xA;&lt;p&gt;If you know about the CHI and intuitionistic logic, skip this section.&lt;/p&gt; &#xA;&lt;h3&gt;The Curry-Howard isomorphism&lt;/h3&gt; &#xA;&lt;p&gt;The Curry-Howard isomorphism (or correspondence) is a pattern between intuitionistic logic and type theory, which says that propositions correspond to types, and proofs correspond to terms.&lt;/p&gt; &#xA;&lt;p&gt;The basis of this correspondence is that an &lt;em&gt;inhabitant&lt;/em&gt; of a type is a proof that the type is inhabited. For example, the term &lt;code&gt;3 :: Int&lt;/code&gt; is a proof that you can construct some terminating value of type &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;What about types with no inhabitant? Taking some type known to have no inhabitants, like &lt;code&gt;Void&lt;/code&gt;, you can show that a type &lt;code&gt;a&lt;/code&gt; is uninhabited by producing a terminating term of type &lt;code&gt;a -&amp;gt; Void&lt;/code&gt;. Why? Because &lt;code&gt;a -&amp;gt; Void&lt;/code&gt; is inhabited only if &lt;code&gt;a&lt;/code&gt; is uninhabited, and a term of type &lt;code&gt;a -&amp;gt; Void&lt;/code&gt; is a &lt;em&gt;proof that &lt;code&gt;a -&amp;gt; Void&lt;/code&gt; is inhabited&lt;/em&gt;!&lt;/p&gt; &#xA;&lt;p&gt;This also has implications for function types - a term with type &lt;code&gt;a -&amp;gt; b&lt;/code&gt; is a function from terms of type &lt;code&gt;a&lt;/code&gt; to terms of type &lt;code&gt;b&lt;/code&gt;. You can equally consider it as a function from proofs of the proposition &lt;code&gt;a&lt;/code&gt; to proofs of the proposition &lt;code&gt;b&lt;/code&gt; - in other words, the function itself is a proof that &lt;code&gt;a&lt;/code&gt; implies &lt;code&gt;b&lt;/code&gt;, because if you have a proof that &lt;code&gt;a&lt;/code&gt; is true, you can obtain a proof that &lt;code&gt;b&lt;/code&gt; is true.&lt;/p&gt; &#xA;&lt;p&gt;Other logical connectives also have equivalents in Haskell types. &lt;code&gt;False&lt;/code&gt; is &lt;code&gt;Void&lt;/code&gt;, because you can&#39;t construct a proof for it; &lt;code&gt;a /\ b&lt;/code&gt; is the tuple (or product) &lt;code&gt;(a, b)&lt;/code&gt;; &lt;code&gt;a \/ b&lt;/code&gt; is (the sum) &lt;code&gt;Either a b&lt;/code&gt;; and &lt;code&gt;Not a&lt;/code&gt; - the claim that &lt;code&gt;a&lt;/code&gt; is uninhabited - is precisely &lt;code&gt;a -&amp;gt; False&lt;/code&gt;. &lt;code&gt;True&lt;/code&gt; can be any inhabited type, but it&#39;s helpful to have a type with a canonical construction, so &lt;code&gt;True&lt;/code&gt; is normally &lt;code&gt;()&lt;/code&gt;, the empty tuple, which has the unique constructor &lt;code&gt;()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can see the correspondence in these types - &lt;code&gt;(a, b)&lt;/code&gt; is inhabited if and only if both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are inhabited. Similarly, &lt;code&gt;Either a b&lt;/code&gt; is inhabited if and only if at least one of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is inhabited. Phrasing it in terms of proofs, if you have a proof of &lt;code&gt;a&lt;/code&gt; and a proof of &lt;code&gt;b&lt;/code&gt;, you can construct a proof of &lt;code&gt;a /\ b&lt;/code&gt; (and vice-versa) - and with a proof of &lt;code&gt;a&lt;/code&gt;, you can construct a proof of &lt;code&gt;a \/ b&lt;/code&gt;. With a proof of &lt;code&gt;a \/ b&lt;/code&gt;, you can &lt;em&gt;destruct&lt;/em&gt; the proof to get either a proof for &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;Left a&lt;/code&gt;) or a proof for &lt;code&gt;b&lt;/code&gt; (&lt;code&gt;Right b&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;For notation&#39;s sake, we write &lt;code&gt;a &amp;lt;-&amp;gt; b&lt;/code&gt; for the type &lt;code&gt;(a -&amp;gt; b) /\ (b -&amp;gt; a)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Intuistionistic logic&lt;/h3&gt; &#xA;&lt;p&gt;Intuistionistic (or constructive) logic is a subset of classical logic (the kind of logic you normally learn in a CS or Maths course). It behaves exactly like classical logic, but with one caveat - &lt;em&gt;you can only &lt;em&gt;construct&lt;/em&gt; proofs of a proposition&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To see what that means, consider the type of the law of the excluded middle - &lt;code&gt;forall a. a \/ Not a&lt;/code&gt;. For every type &lt;code&gt;a&lt;/code&gt;, one of these two terms must be constructable - either &lt;code&gt;a&lt;/code&gt; is inhabited, so you can construct a value of type &lt;code&gt;a&lt;/code&gt;, or &lt;code&gt;a&lt;/code&gt; is uninhabited, so you can construct a function of type &lt;code&gt;a -&amp;gt; Void&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;But you can&#39;t write a terminating Haskell function with type &lt;code&gt;forall a. a \/ Not a&lt;/code&gt; - because it would require you to somehow decide if &lt;code&gt;a&lt;/code&gt; is inhabited, and then get a value of type &lt;code&gt;a&lt;/code&gt; if it was. In other words, you have to construct either a &lt;code&gt;Left a&lt;/code&gt; or a &lt;code&gt;Right (Not a)&lt;/code&gt;, and you have no way to do either of those things.&lt;/p&gt; &#xA;&lt;p&gt;There are lots of other consequences of this caveat: the following implications do &lt;em&gt;not&lt;/em&gt; hold in intuitionistic logic - and similarly, you cannot write a terminating Haskell term for their type.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Not (Not a) -&amp;gt; a&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(a -&amp;gt; b) -&amp;gt; (Not a \/ b)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Not (Not a /\ Not b) -&amp;gt; a \/ b&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Proofs and the Tactic monad&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;Tactic&lt;/code&gt; monad is an indexed monad for which the monad state is the current proof goal, and the type argument is an additional hypothesis introduced at that proof step. Looking at its definition&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;data Tactic from to a = Tactic ((a -&amp;gt; to) -&amp;gt; from)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;Tactic&lt;/code&gt; term represents a valid goal transformation - you are allowed to change a proof of &lt;code&gt;from&lt;/code&gt; into a proof of &lt;code&gt;to&lt;/code&gt;, and introduce the additional hypothesis &lt;code&gt;a&lt;/code&gt;, if you can use a proof of &lt;code&gt;a -&amp;gt; to&lt;/code&gt; to prove &lt;code&gt;from&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example, the &lt;code&gt;apply&lt;/code&gt; function has the signature&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;apply :: (a -&amp;gt; b) -&amp;gt; Tactic b a ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Given a function &lt;code&gt;a -&amp;gt; b&lt;/code&gt;, it allows you to transform the goal from proving &lt;code&gt;b&lt;/code&gt; to proving &lt;code&gt;a&lt;/code&gt; - because once you prove &lt;code&gt;a&lt;/code&gt;, it will be possible to use the given function to produce a proof of &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Some tactics introduce additional hypotheses - such as &lt;code&gt;intro&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;intro :: Tactic (a -&amp;gt; b) b a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;intro&lt;/code&gt; allows you to transform a goal of &lt;code&gt;a -&amp;gt; b&lt;/code&gt; to a goal of &lt;code&gt;b&lt;/code&gt;, giving you the hypothesis of type &lt;code&gt;a&lt;/code&gt; to bind into a variable. If you can use the proof of &lt;code&gt;a&lt;/code&gt; to construct a proof of &lt;code&gt;b&lt;/code&gt;, then the resulting function term is indeed a proof of &lt;code&gt;a -&amp;gt; b&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Available tactics&lt;/h3&gt; &#xA;&lt;p&gt;hout provides some tactics based on those used in &lt;code&gt;Coq&lt;/code&gt; - for example, you can &lt;code&gt;apply&lt;/code&gt; hypotheses to a goal; you can &lt;code&gt;split&lt;/code&gt; the proof a conjunction into proofs of its conjuncts; you can &lt;code&gt;intro&lt;/code&gt; a variable; you can &lt;code&gt;exists&lt;/code&gt; the witness of an existential goal; you can &lt;code&gt;rewrite&lt;/code&gt; propositions with equality; you can even &lt;code&gt;assert&lt;/code&gt; hypothesis and produce subgoals.&lt;/p&gt; &#xA;&lt;p&gt;The full list of tactics is given in &lt;code&gt;Hout.Prover.Tactics&lt;/code&gt;, and it is possible to write your own using the type signature of the &lt;code&gt;Tactic&lt;/code&gt; monad.&lt;/p&gt; &#xA;&lt;h3&gt;Proofs in do notation&lt;/h3&gt; &#xA;&lt;p&gt;Because &lt;code&gt;Tactic&lt;/code&gt; is an indexed monad, you can use the &lt;code&gt;do-notation&lt;/code&gt; package to write proofs in do notation, which end up looking quite similar to proofs in interactive proof assistants. Some advice for doing this is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;use pattern-matching in binds, particularly when working with existential types. GHC has some unfortunate behaviour when trying to use &lt;code&gt;let&lt;/code&gt; in do notation when working with existential type arguments.&lt;/li&gt; &#xA; &lt;li&gt;Enable block arguments, and use do notation for subgoals&lt;/li&gt; &#xA; &lt;li&gt;If your final statement is a tactic that introduces a hypothesis, but the new goal is trivial &lt;code&gt;()&lt;/code&gt;, use &lt;code&gt;qed&lt;/code&gt; to end your proof.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Limitations&lt;/h3&gt; &#xA;&lt;p&gt;The use of &lt;code&gt;Forall&lt;/code&gt; is limited by Haskell&#39;s lack of support for impredicative polymorphism - the instantiation of type variables with higher-ranked types. This makes it basically impossible to prove a &lt;code&gt;Forall&lt;/code&gt; using the &lt;code&gt;Tactic&lt;/code&gt; monad, since under the hood &lt;code&gt;Forall&lt;/code&gt; is just a Haskell type-level &lt;code&gt;forall&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Computations written in the proof style&lt;/h2&gt; &#xA;&lt;p&gt;hout also has the nice property of intuitionistic proof assistants that proofs are themselves terms, and can be run as Haskell code. This gives hout the alternative use of writing functions in a proof-y syntax using the &lt;code&gt;Tactic&lt;/code&gt; monad. For example, the &lt;code&gt;identity&lt;/code&gt; function can be written as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;identity :: a -&amp;gt; a&#xA;identity :: runProof $ Proof do&#xA;  a &amp;lt;- intro&#xA;  exact a&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>