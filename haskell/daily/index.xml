<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-17T01:35:01Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>wereHamster/snap-assets</title>
    <updated>2023-11-17T01:35:01Z</updated>
    <id>tag:github.com,2023-11-17:/wereHamster/snap-assets</id>
    <link href="https://github.com/wereHamster/snap-assets" rel="alternate"></link>
    <summary type="html">&lt;p&gt;My thoughts and snippets of code of an asset pipeline for snap&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Snap Asset Pipeline&lt;/h2&gt; &#xA;&lt;p&gt;This package provides tools and helpers to integrate a Ruby on Rails-like asset pipeline into Snap. The asset pipeline serves two purposes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Allows you to build/compile/preprocess your assets. A common example would be to concatenate multiple JavaScript files into a single file. Or compiling your CSS files using SASS/Stylus/Compass etc.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fingerprints files so you can set a Expires header far in the future, but still have a way to force the client to refresh it.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;First, you have to define the assets. Each asset has a name (that is what will be used in the URL to request it) and a builder. The builder defines how to build the asset. The builder runs in the IO monad, so you can read files, fork external processes etc. It&#39;s also perfectly valid to have a piece of pure Haskell code that builds the asset (for example using Clay to generate CSS).&lt;/p&gt; &#xA;&lt;p&gt;The snap asset pipeline comes with one builder: &lt;code&gt;concatBuilder&lt;/code&gt;. The concat builder will simply concatenate all the files and serve them to the client as a single blob. Let&#39;s use it to define our application JavaScript file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;assets :: [ Asset ]&#xA;assets =&#xA;  [ Asset &#34;application.js&#34; $ concatBuilder&#xA;    [ &#34;javascript/jquery.js&#34;&#xA;    , &#34;javascript/app.js&#34;&#xA;    ]&#xA;  ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the builder reads the assets from a directory &lt;code&gt;assets&lt;/code&gt;. So let&#39;s create the two files, &lt;code&gt;jquery.js&lt;/code&gt; and &lt;code&gt;app.js&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ mkdir -p assets/javascript&#xA;$ echo &#34;// jquery.js&#34; &amp;gt; assets/javascript/jquery.js&#xA;$ echo &#34;// app.js&#34;    &amp;gt; assets/javascript/app.js&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sweet, we have our asset. The pipeline uses a &lt;code&gt;Config&lt;/code&gt; structure to store various configuration options used by the pipeline. The defaults are reasonable, we just have to supply our asset list:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;loadConfig :: IO Config&#xA;loadConfig = do&#xA;    config &amp;lt;- defaultConfig&#xA;    return $ config { assetDefinitions = assets }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, in development mode, you can use the &lt;code&gt;snapAssetHandler&lt;/code&gt; to serve the assets to clients. The handler simply runs the builder and streams the result to the client. It uses minimal caching, just to be useful in development mode.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;main :: IO ()&#xA;main = do&#xA;    config &amp;lt;- loadConfig&#xA;    quickHttpServe $ snapAssetHandler config&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you start the web server, you can request the &#34;application.js&#34; file. What you will see is the two javascript files concatenated:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ curl http://localhost:8000/assets/application.js&#xA;// jquery.js&#xA;// app.js&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you probably have a template and want to insert the url to this application.js into your html. Use &lt;code&gt;assetUrl&lt;/code&gt; for that:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;site :: Config -&amp;gt; Snap ()&#xA;site config = do&#xA;    appJsUrl &amp;lt;- assetUrl config &#34;application.js&#34;&#xA;    -- appJsUrl == &#34;//localhost:8000/assets/application.js&#34;&#xA;&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Fingerprinting&lt;/h2&gt; &#xA;&lt;p&gt;Fingerprinting is the process of adding a unique fingerprint to each asset. This fingerprint is generated from the asset contents. If the contents change, so does the fingerprint. This allows you to set the Expires header far in the future, without having to worry about stale files on the client. You do this in production mode so that clients can cache the files, that speeds up your website.&lt;/p&gt; &#xA;&lt;p&gt;You usually serve the assets from a static file server or a CDN. So you first have to compile them. The snap asset pipeline has a function which will do that and output the assets into an output directory. You can then upload the contents of the output directory to your file server.&lt;/p&gt; &#xA;&lt;p&gt;The function will return a manifest. That is a mapping from asset name to its fingerprint. This is needed in production mode so that &lt;code&gt;assetUrl&lt;/code&gt; can generate the correct urls. You have to store the manifest somewhere and load it in production mode.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;prepareAssetsForDeployment :: Config -&amp;gt; IO ()&#xA;prepareAssetsForDeployment config = do&#xA;    manifest &amp;lt;- compileAssets config &#34;output-directory&#34;&#xA;    dumpManifest manifest &#34;manifest.mf&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The contents of &lt;code&gt;output-directory&lt;/code&gt; will look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ find output-directory&#xA;output-directory/&#xA;output-directory/assets&#xA;output-directory/assets/application-a8aaf357acfc18f55dc6d93ae875e38babdd0d08.js&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In production, you use a different config. Instead of supplying asset definitions, you supply the manifest.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;productionAssetConfig :: IO Config&#xA;productionAssetConfig = do&#xA;    config   &amp;lt;- defaultConfig&#xA;    manifest &amp;lt;- loadManifest &#34;manifest.mf&#34;&#xA;    return $ config { manifest = manifest }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With this production config, &lt;code&gt;assetUrl config &#34;application.js&#34;&lt;/code&gt; will return a different url. Something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;//localhost:8000/assets/application-a8aaf357acfc18f55dc6d93ae875e38babdd0d08.js&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Asset Path Helpers&lt;/h2&gt; &#xA;&lt;p&gt;Notice that in production mode, the assets have different url. This url is only known once you compile the asset. So when you reference an image from a CSS file, you have to insert special placeholders which will be resolved upon compilation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;body {&#xA;    background-image: url(&amp;lt;* images/background.png *&amp;gt;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will turn into something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;body {&#xA;    background-image: url(/images/background-c10a4572b80930ff9c13c4f09269bfe809c06a48.png);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>k-wisniewski/Haskell-regex-matcher</title>
    <updated>2023-11-17T01:35:01Z</updated>
    <id>tag:github.com,2023-11-17:/k-wisniewski/Haskell-regex-matcher</id>
    <link href="https://github.com/k-wisniewski/Haskell-regex-matcher" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Just a simple haskell regex implementation using regex derivatives&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Haskell-regex-matcher&lt;/h1&gt; &#xA;&lt;p&gt;Just a simple haskell regex implementation using regex derivatives (algorithm by J. Brzozowski)&lt;/p&gt;</summary>
  </entry>
</feed>