<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-14T01:48:35Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ElementAI/picard</title>
    <updated>2022-06-14T01:48:35Z</updated>
    <id>tag:github.com,2022-06-14:/ElementAI/picard</id>
    <link href="https://github.com/ElementAI/picard" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PICARD - Parsing Incrementally for Constrained Auto-Regressive Decoding from Language Models&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;em&gt;ServiceNow completed its acquisition of Element AI on January 8, 2021. All references to Element AI in the materials that are part of this project should refer to ServiceNow.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;br&gt; &lt;img alt=&#34;make it parse&#34; src=&#34;https://repository-images.githubusercontent.com/401779782/c2f46be5-b74b-4620-ad64-57487be3b1ab&#34; width=&#34;600&#34;&gt; &lt;br&gt; &lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/ElementAI/picard/actions/workflows/build.yml&#34;&gt; &lt;img alt=&#34;build&#34; src=&#34;https://github.com/ElementAI/picard/actions/workflows/build.yml/badge.svg?branch=main&amp;amp;event=push&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/ElementAI/picard/raw/main/LICENSE&#34;&gt; &lt;img alt=&#34;license&#34; src=&#34;https://img.shields.io/github/license/ElementAI/picard.svg?color=blue&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://paperswithcode.com/paper/picard-parsing-incrementally-for-constrained&#34;&gt; &lt;img src=&#34;https://img.shields.io/endpoint.svg?url=https://paperswithcode.com/badge/picard-parsing-incrementally-for-constrained/text-to-sql-on-spider&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://paperswithcode.com/paper/picard-parsing-incrementally-for-constrained&#34;&gt; &lt;img src=&#34;https://img.shields.io/endpoint.svg?url=https://paperswithcode.com/badge/picard-parsing-incrementally-for-constrained/dialogue-state-tracking-on-cosql&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;This is the official implementation of the following paper:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://twitter.com/tscholak&#34;&gt;Torsten Scholak&lt;/a&gt;, Nathan Schucher, Dzmitry Bahdanau. &lt;a href=&#34;https://arxiv.org/abs/2109.05093&#34;&gt;PICARD - Parsing Incrementally for Constrained Auto-Regressive Decoding from Language Models&lt;/a&gt;. &lt;em&gt;Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing (EMNLP).&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you use this code, please cite:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@inproceedings{Scholak2021:PICARD,&#xA;  author = {Torsten Scholak and Nathan Schucher and Dzmitry Bahdanau},&#xA;  title = &#34;{PICARD}: Parsing Incrementally for Constrained Auto-Regressive Decoding from Language Models&#34;,&#xA;  booktitle = &#34;Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing&#34;,&#xA;  month = nov,&#xA;  year = &#34;2021&#34;,&#xA;  publisher = &#34;Association for Computational Linguistics&#34;,&#xA;  url = &#34;https://aclanthology.org/2021.emnlp-main.779&#34;,&#xA;  pages = &#34;9895--9901&#34;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Watch The Video&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://youtu.be/kTpixsr-37w&#34;&gt;&lt;img src=&#34;https://img.youtube.com/vi/kTpixsr-37w/maxresdefault.jpg&#34; alt=&#34;Watch the video&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;This code implements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The PICARD algorithm for constrained decoding from language models.&lt;/li&gt; &#xA; &lt;li&gt;A text-to-SQL semantic parser based on pre-trained sequence-to-sequence models and PICARD achieving state-of-the-art performance on both the &lt;a href=&#34;https://yale-lily.github.io/spider&#34;&gt;Spider&lt;/a&gt; and the &lt;a href=&#34;https://yale-lily.github.io/cosql&#34;&gt;CoSQL&lt;/a&gt; datasets.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;About PICARD&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;TL;DR:&lt;/strong&gt; We introduce PICARD -- a new method for simple and effective constrained decoding from large pre-trained language models. On the challenging Spider and CoSQL text-to-SQL datasets, PICARD significantly improves the performance of fine-tuned but otherwise unmodified T5 models. Using PICARD, our T5-3B models achieved state-of-the-art performance on both Spider and CoSQL.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;In text-to-SQL translation, the goal is to translate a natural language question into a SQL query. There are two main challenges to this task:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The generated SQL needs to be semantically correct, that is, correctly reflect the meaning of the question.&lt;/li&gt; &#xA; &lt;li&gt;The SQL also needs to be valid, that is, it must not result in an execution error.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;So far, there has been a trade-off between these two goals: The second problem can be solved by using a special decoder architecture that -- by construction -- always produces valid SQL. This is the approach taken by most prior work. Those decoders are called &#34;constrained decoders&#34;, and they need to be trained from scratch on the text-to-SQL dataset. However, this limits the generality of the decoders, which is a problem for the first goal.&lt;/p&gt; &#xA;&lt;p&gt;A better approach would be to use a pre-trained encoder-decoder model and to constrain its decoder to produce valid SQL after fine-tuning the model on the text-to-SQL task. This is the approach taken by the PICARD algorithm.&lt;/p&gt; &#xA;&lt;h3&gt;How is PICARD different from existing constrained decoders?&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It’s an incremental parsing algorithm that integrates with ordinary beam search.&lt;/li&gt; &#xA; &lt;li&gt;It doesn’t require any training.&lt;/li&gt; &#xA; &lt;li&gt;It doesn’t require modifying the model.&lt;/li&gt; &#xA; &lt;li&gt;It works with any model that generates a sequence of tokens (including language models).&lt;/li&gt; &#xA; &lt;li&gt;It doesn’t require a special vocabulary.&lt;/li&gt; &#xA; &lt;li&gt;It works with character-, sub-word-, and word-level language models.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;How does PICARD work?&lt;/h3&gt; &#xA;&lt;p&gt;The following picture shows how PICARD is integrated with beam search.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/ElementAI/picard/main/beam_search_with_picard.svg?sanitize=true&#34; width=&#34;400&#34;&gt; &lt;br&gt; &lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&lt;p&gt;Decoding starts from the left and proceeds to the right. The algorithm begins with a single token (usually &lt;code&gt;&amp;lt;s&amp;gt;&lt;/code&gt;), and then keeps expanding the beam with hypotheses generated token-by-token by the decoder. At each decoding step and for each hypothesis, PICARD checks whether the next top-&lt;code&gt;k&lt;/code&gt; tokens are valid. In the image above, only 3 token predictions are shown, and &lt;code&gt;k&lt;/code&gt; is set to 2. Valid tokens (☑) are added to the beam. Invalid ones (☒) are discarded. The &lt;code&gt;k+1&lt;/code&gt;-th, &lt;code&gt;k+2&lt;/code&gt;-th, ... tokens are discarded, too. Like in normal beam search, the beam is pruned to contain only the top-&lt;code&gt;n&lt;/code&gt; hypotheses. &lt;code&gt;n&lt;/code&gt; is the beam size, and in the image above it is set to 2 as well. Hypotheses that are terminated with the end-of-sentence token (usually &lt;code&gt;&amp;lt;/s&amp;gt;&lt;/code&gt;) are not expanded further. The algorithm stops when the all hypotheses are terminated or when the maximum number of tokens has been reached.&lt;/p&gt; &#xA;&lt;h3&gt;How does PICARD know whether a token is valid?&lt;/h3&gt; &#xA;&lt;p&gt;In PICARD, checking, accepting, and rejecting of tokens and token sequences is achieved through &lt;em&gt;parsing&lt;/em&gt;. Parsing means that we attempt to assemble a data structure from the tokens that are currently in the beam or are about to be added to it. This data structure (and the parsing rules that are used to build it) encode the constraints we want to enforce.&lt;/p&gt; &#xA;&lt;p&gt;In the case of SQL, the data structure we parse to is the abstract syntax tree (AST) of the SQL query. The parsing rules are defined in a computer program called a parser. Database engines, such as PostgreSQL, MySQL, and SQLite, have their own built-in parser that they use internally to process SQL queries. For Spider and CoSQL, we have implemented a parser that supports a subset of the SQLite syntax and that checks additional constraints on the AST. In our implementation, the parsing rules are made up from simpler rules and primitives that are provided by a third-party parsing library.&lt;/p&gt; &#xA;&lt;p&gt;PICARD uses a parsing library called &lt;a href=&#34;https://hackage.haskell.org/package/attoparsec&#34;&gt;attoparsec&lt;/a&gt; that supports incremental input. This is a special capability that is not available in many other parsing libraries. You can feed attoparsec a string that represents only part of the expected input to parse. When parsing reaches the end of an input fragment, attoparsec will return a &lt;a href=&#34;https://hackage.haskell.org/package/attoparsec-0.14.1/docs/Data-Attoparsec-Text.html#t:IResult&#34;&gt;continuation function&lt;/a&gt; that can be used to continue parsing. Think of the continuation function as a suspended computation that can be resumed later. Input fragments can be parsed one after the other when they become available until the input is complete.&lt;/p&gt; &#xA;&lt;p&gt;Herein lies the key to PICARD: Incremental parsing of input fragments is exactly what we need to check tokens one by one during decoding.&lt;/p&gt; &#xA;&lt;p&gt;In PICARD, parsing is initialized with an empty string, and attoparsec will return the first continuation function. We then call that continuation function with all the token predictions we want to check in the first decoding step. For those tokens that are valid, the continuation function will return a new continuation function that we can use to continue parsing in the next decoding step. For those tokens that are invalid, the continuation function will return a failure value which cannot be used to continue parsing. Such failures are discarded and never end up in the beam. We repeat the process until the end of the input is reached. The input is complete once the model predicts the end-of-sentence token. When that happens, we finalize the parsing by calling the continuation function with an empty string. If the parsing is successful, it will return the final AST. If not, it will return a failure value.&lt;/p&gt; &#xA;&lt;p&gt;The parsing rules are described at a high level in the &lt;a href=&#34;https://arxiv.org/abs/2109.05093&#34;&gt;PICARD paper&lt;/a&gt;. For details, see the PICARD code, specifically the &lt;a href=&#34;https://github.com/ElementAI/picard/raw/main/picard/src/Language/SQL/SpiderSQL/Parse.hs&#34;&gt;Language.SQL.SpiderSQL.Parse module&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How well does PICARD work?&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s look at the numbers:&lt;/p&gt; &#xA;&lt;h4&gt;On &lt;a href=&#34;https://yale-lily.github.io/spider&#34;&gt;Spider&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th rowspan=&#34;2&#34; valign=&#34;bottom&#34;&gt;URL&lt;/th&gt; &#xA;   &lt;th rowspan=&#34;2&#34; valign=&#34;bottom&#34;&gt;Based on&lt;/th&gt; &#xA;   &lt;th colspan=&#34;2&#34;&gt;Exact-set Match Accuracy&lt;/th&gt; &#xA;   &lt;th colspan=&#34;2&#34;&gt;Execution Accuracy&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Dev&lt;/th&gt; &#xA;   &lt;th&gt;Test&lt;/th&gt; &#xA;   &lt;th&gt;Dev&lt;/th&gt; &#xA;   &lt;th&gt;Test&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;&lt;a href=&#34;https://huggingface.co/tscholak/cxmefzzi&#34;&gt;tscholak/cxmefzzi&lt;/a&gt; w PICARD&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;T5-3B&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;75.5 %&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;71.9 %&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;79.3 %&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;75.1 %&lt;/b&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/tscholak/cxmefzzi&#34;&gt;tscholak/cxmefzzi&lt;/a&gt; w/o PICARD&lt;/td&gt; &#xA;   &lt;td&gt;T5-3B&lt;/td&gt; &#xA;   &lt;td&gt;71.5 %&lt;/td&gt; &#xA;   &lt;td&gt;68.0 %&lt;/td&gt; &#xA;   &lt;td&gt;74.4 %&lt;/td&gt; &#xA;   &lt;td&gt;70.1 %&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/tscholak/3vnuv1vf&#34;&gt;tscholak/3vnuv1vf&lt;/a&gt; w PICARD&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/google-research/text-to-text-transfer-transformer/raw/main/released_checkpoints.md#lm-adapted-t511lm100k&#34;&gt;t5.1.1.lm100k.large&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;74.8 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;   &lt;td&gt;79.2 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/tscholak/3vnuv1vf&#34;&gt;tscholak/3vnuv1vf&lt;/a&gt; w/o PICARD&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/google-research/text-to-text-transfer-transformer/raw/main/released_checkpoints.md#lm-adapted-t511lm100k&#34;&gt;t5.1.1.lm100k.large&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;71.2 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;   &lt;td&gt;74.4 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/tscholak/1wnr382e&#34;&gt;tscholak/1wnr382e&lt;/a&gt; w PICARD&lt;/td&gt; &#xA;   &lt;td&gt;T5-Large&lt;/td&gt; &#xA;   &lt;td&gt;69.1 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;   &lt;td&gt;72.9 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/tscholak/1wnr382e&#34;&gt;tscholak/1wnr382e&lt;/a&gt; w/o PICARD&lt;/td&gt; &#xA;   &lt;td&gt;T5-Large&lt;/td&gt; &#xA;   &lt;td&gt;65.3 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;   &lt;td&gt;67.2 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/tscholak/1zha5ono&#34;&gt;tscholak/1zha5ono&lt;/a&gt; w PICARD&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/google-research/text-to-text-transfer-transformer/raw/main/released_checkpoints.md#lm-adapted-t511lm100k&#34;&gt;t5.1.1.lm100k.base&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;66.6 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;   &lt;td&gt;68.4 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/tscholak/1zha5ono&#34;&gt;tscholak/1zha5ono&lt;/a&gt; w/o PICARD&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/google-research/text-to-text-transfer-transformer/raw/main/released_checkpoints.md#lm-adapted-t511lm100k&#34;&gt;t5.1.1.lm100k.base&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;59.4 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;   &lt;td&gt;60.0 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;Click on the links to download the models. &lt;a href=&#34;https://huggingface.co/tscholak/cxmefzzi&#34;&gt;tscholak/cxmefzzi&lt;/a&gt; and &lt;a href=&#34;https://huggingface.co/tscholak/1wnr382e&#34;&gt;tscholak/1wnr382e&lt;/a&gt; are the versions of the model that we used in our experiments for the paper, reported as T5-3B and T5-Large, respectively. &lt;a href=&#34;https://huggingface.co/tscholak/cxmefzzi&#34;&gt;tscholak/cxmefzzi&lt;/a&gt;, &lt;a href=&#34;https://huggingface.co/tscholak/3vnuv1vf&#34;&gt;tscholak/3vnuv1vf&lt;/a&gt;, and &lt;a href=&#34;https://huggingface.co/tscholak/1zha5ono&#34;&gt;tscholak/1zha5ono&lt;/a&gt; were trained to use database content, whereas &lt;a href=&#34;https://huggingface.co/tscholak/1wnr382e&#34;&gt;tscholak/1wnr382e&lt;/a&gt; was not.&lt;/p&gt; &#xA;&lt;p&gt;Note that, without PICARD, 12% of the SQL queries generated by &lt;a href=&#34;https://huggingface.co/tscholak/cxmefzzi&#34;&gt;tscholak/cxmefzzi&lt;/a&gt; on Spider’s development set resulted in an execution error. With PICARD, this number decreased to 2%.&lt;/p&gt; &#xA;&lt;h4&gt;On &lt;a href=&#34;https://yale-lily.github.io/cosql&#34;&gt;CoSQL&lt;/a&gt; Dialogue State Tracking&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th rowspan=&#34;2&#34; valign=&#34;bottom&#34;&gt;URL&lt;/th&gt; &#xA;   &lt;th rowspan=&#34;2&#34; valign=&#34;bottom&#34;&gt;Based on&lt;/th&gt; &#xA;   &lt;th colspan=&#34;2&#34;&gt;Question Match Accuracy&lt;/th&gt; &#xA;   &lt;th colspan=&#34;2&#34;&gt;Interaction Match Accuracy&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Dev&lt;/th&gt; &#xA;   &lt;th&gt;Test&lt;/th&gt; &#xA;   &lt;th&gt;Dev&lt;/th&gt; &#xA;   &lt;th&gt;Test&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;&lt;a href=&#34;https://huggingface.co/tscholak/2e826ioa&#34;&gt;tscholak/2e826ioa&lt;/a&gt; w PICARD&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;T5-3B&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;56.9 %&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;54.6 %&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;24.2 %&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;23.7 %&lt;/b&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/tscholak/2e826ioa&#34;&gt;tscholak/2e826ioa&lt;/a&gt; w/o PICARD&lt;/td&gt; &#xA;   &lt;td&gt;T5-3B&lt;/td&gt; &#xA;   &lt;td&gt;53.8 %&lt;/td&gt; &#xA;   &lt;td&gt;51.4 %&lt;/td&gt; &#xA;   &lt;td&gt;21.8 %&lt;/td&gt; &#xA;   &lt;td&gt;21.7 %&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/tscholak/2jrayxos&#34;&gt;tscholak/2jrayxos&lt;/a&gt; w PICARD&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/google-research/text-to-text-transfer-transformer/raw/main/released_checkpoints.md#lm-adapted-t511lm100k&#34;&gt;t5.1.1.lm100k.large&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;54.2 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/tscholak/2jrayxos&#34;&gt;tscholak/2jrayxos&lt;/a&gt; w/o PICARD&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/google-research/text-to-text-transfer-transformer/raw/main/released_checkpoints.md#lm-adapted-t511lm100k&#34;&gt;t5.1.1.lm100k.large&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;52.5 %&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;   &lt;td&gt;—&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;Click on the links to download the models. &lt;a href=&#34;https://huggingface.co/tscholak/2e826ioa&#34;&gt;tscholak/2e826ioa&lt;/a&gt; is the version of the model that we used in our experiments for the paper, reported as T5-3B.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;p&gt;This repository uses git submodules. Clone it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ git clone git@github.com:ElementAI/picard.git&#xA;$ cd picard&#xA;$ git submodule update --init --recursive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Training&lt;/h3&gt; &#xA;&lt;p&gt;The training script is located in &lt;code&gt;seq2seq/run_seq2seq.py&lt;/code&gt;. You can run it with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make train&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The model will be trained on the Spider dataset by default. You can also train on CoSQL by running &lt;code&gt;make train-cosql&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The training script will create the directory &lt;code&gt;train&lt;/code&gt; in the current directory. Training artifacts like checkpoints will be stored in this directory.&lt;/p&gt; &#xA;&lt;p&gt;The default configuration is stored in &lt;code&gt;configs/train.json&lt;/code&gt;. The settings are optimized for a GPU with 40GB of memory.&lt;/p&gt; &#xA;&lt;p&gt;These training settings should result in a model with at least 71% exact-set-match accuracy on the Spider development set. With PICARD, the accuracy should go up to at least 75%.&lt;/p&gt; &#xA;&lt;p&gt;We have uploaded a model trained on the Spider dataset to the huggingface model hub, &lt;a href=&#34;https://huggingface.co/tscholak/cxmefzzi&#34;&gt;tscholak/cxmefzzi&lt;/a&gt;. A model trained on the CoSQL dialog state tracking dataset is available, too, &lt;a href=&#34;https://huggingface.co/tscholak/2e826ioa&#34;&gt;tscholak/2e826ioa&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Evaluation&lt;/h3&gt; &#xA;&lt;p&gt;The evaluation script is located in &lt;code&gt;seq2seq/run_seq2seq.py&lt;/code&gt;. You can run it with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make eval&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the evaluation will be run on the Spider evaluation set. Evaluation on the CoSQL evaluation set can be run with &lt;code&gt;make eval-cosql&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The evaluation script will create the directory &lt;code&gt;eval&lt;/code&gt; in the current directory. The evaluation results will be stored there.&lt;/p&gt; &#xA;&lt;p&gt;The default configuration is stored in &lt;code&gt;configs/eval.json&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Serving&lt;/h3&gt; &#xA;&lt;p&gt;A trained model can be served using the &lt;code&gt;seq2seq/serve_seq2seq.py&lt;/code&gt; script. The configuration file can be found in &lt;code&gt;configs/serve.json&lt;/code&gt;. You can start serving with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make serve&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the 800-million-parameter &lt;a href=&#34;https://huggingface.co/tscholak/3vnuv1vf&#34;&gt;tscholak/3vnuv1vf&lt;/a&gt; model will be loaded. You can also load a different model by specifying the model name in the configuration file. The device to use can be specified as well. The default is to use the first available GPU. CPU can be used by specifying &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When the script is called, it uses the folder specified by the &lt;code&gt;db_path&lt;/code&gt; option to look for SQL database files. The default folder is &lt;code&gt;database&lt;/code&gt;, which will be created in the current directory. Initially, this folder will be empty, and you can add your own SQL files to it. The structure of the folder should be like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;database/&#xA;  my_1st_database/&#xA;    my_1st_database.sqlite&#xA;  my_2nd_database/&#xA;    my_2nd_database.sqlite&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &lt;code&gt;my_1st_database&lt;/code&gt; and &lt;code&gt;my_2nd_database&lt;/code&gt; are the &lt;code&gt;db_id&lt;/code&gt;s of the databases.&lt;/p&gt; &#xA;&lt;p&gt;Once the server is up and running, use the Swagger UI to test inference with the &lt;code&gt;/ask&lt;/code&gt; endpoint. The server will be listening at &lt;code&gt;http://localhost:8000/&lt;/code&gt;, and the Swagger UI will be available at &lt;code&gt;http://localhost:8000/docs#/default/ask_ask__db_id___question__get&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Docker&lt;/h3&gt; &#xA;&lt;p&gt;There are three docker images that can be used to run the code:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://hub.docker.com/repository/docker/tscholak/text-to-sql-dev&#34;&gt;tscholak/text-to-sql-dev&lt;/a&gt;:&lt;/strong&gt; Base image with development dependencies. Use this for development. Pull it with &lt;code&gt;make pull-dev-image&lt;/code&gt; from the docker hub. Rebuild the image with &lt;code&gt;make build-dev-image&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://hub.docker.com/repository/docker/tscholak/text-to-sql-train&#34;&gt;tsscholak/text-to-sql-train&lt;/a&gt;:&lt;/strong&gt; Training image with development dependencies but without Picard dependencies. Use this for fine-tuning a model. Pull it with &lt;code&gt;make pull-train-image&lt;/code&gt; from the docker hub. Rebuild the image with &lt;code&gt;make build-train-image&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://hub.docker.com/repository/docker/tscholak/text-to-sql-eval&#34;&gt;tscholak/text-to-sql-eval&lt;/a&gt;:&lt;/strong&gt; Training/evaluation image with all dependencies. Use this for evaluating a fine-tuned model with Picard. This image can also be used for training if you want to run evaluation during training with Picard. Pull it with &lt;code&gt;make pull-eval-image&lt;/code&gt; from the docker hub. Rebuild the image with &lt;code&gt;make build-eval-image&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All images are tagged with the current commit hash. The images are built with the buildx tool which is available in the latest docker-ce. Use &lt;code&gt;make init-buildkit&lt;/code&gt; to initialize the buildx tool on your machine. You can then use &lt;code&gt;make build-dev-image&lt;/code&gt;, &lt;code&gt;make build-train-image&lt;/code&gt;, etc. to rebuild the images. Local changes to the code will not be reflected in the docker images unless they are committed to git.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>haskell/error-messages</title>
    <updated>2022-06-14T01:48:35Z</updated>
    <id>tag:github.com,2022-06-14:/haskell/error-messages</id>
    <link href="https://github.com/haskell/error-messages" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Haskell Errors&lt;/h1&gt; &#xA;&lt;p&gt;So you would like to help improve the error messages we see in the Haskell toolchain and ecosystem?&lt;/p&gt; &#xA;&lt;p&gt;Welcome! We&#39;re glad to have you, and we will do our best to ensure your efforts are worthwhile.&lt;/p&gt; &#xA;&lt;h2&gt;Project Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Serve the Haskell community, focusing on improvements to the error messages seen in the Haskell ecosystem.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Lower Haskell&#39;s barrier-to-entry by increasing the general understanding of the error messages experienced during development.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What and How?&lt;/h2&gt; &#xA;&lt;p&gt;This project is taking shape, so many details are still being worked out, however:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using the issue tracker, this repo will provide a space and workflow for the discussion and collaboration around improving error messages.&lt;/li&gt; &#xA; &lt;li&gt;We are interested in building a catalog of error messages for each tool in common use (GHC, Cabal, Stack, ghcup, HLS, etc).&lt;/li&gt; &#xA; &lt;li&gt;For each error message that is identified for potential improvement: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;We would like to have a reasonable means of reproducing the error message under different circumstances&lt;/li&gt; &#xA;   &lt;li&gt;We should identify specific improvements to the messaging&lt;/li&gt; &#xA;   &lt;li&gt;We will reach out to and work collaboratively with tool developers&lt;/li&gt; &#xA;   &lt;li&gt;We should document and help improve understanding of the error messaging&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;For tools that use error message codes: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;We describe the messages and how to interpret them in the Haskell Message Index (see below)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As a result, this repo may include code that demonstrates the errors we wish to improve, as well as code and material to render documentation relevant to explaining each error and the possible situations the error relates to.&lt;/p&gt; &#xA;&lt;h2&gt;Contributor Expectations&lt;/h2&gt; &#xA;&lt;p&gt;We welcome contributions that help to further progress the project towards its goals.&lt;/p&gt; &#xA;&lt;p&gt;Contributions may come in the form of changes to the code base, as well as opening or commenting on issues and pull requests.&lt;/p&gt; &#xA;&lt;p&gt;All contributors are expected to follow the &lt;a href=&#34;https://haskell.foundation/guidelines-for-respectful-communication/&#34;&gt;Haskell Foundation&#39;s Code of Conduct&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;The Haskell Message Index&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/haskell/error-messages/actions/workflows/deploy.yml&#34;&gt;&lt;img src=&#34;https://github.com/haskell/error-messages/actions/workflows/deploy.yml/badge.svg?branch=main&#34; alt=&#34;.github/workflows/deploy.yml&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Haskell tooling emits a variety of errors, warnings, and other messages. In an unreleased branch, GHC emits a unique code for each message that allows it to be identified. This site allows these codes to be looked up, providing examples, context, and further information that can make them easier to understand.&lt;/p&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/haskell/error-messages/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for instructions on improving the site. Thanks!&lt;/p&gt; &#xA;&lt;h3&gt;Running Locally&lt;/h3&gt; &#xA;&lt;p&gt;The site is built with the &lt;a href=&#34;https://jaspervdj.be/hakyll/&#34;&gt;Hakyll&lt;/a&gt; static site generator. To view the site locally, enter the &lt;code&gt;message-index&lt;/code&gt; directory and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cabal run -- site watch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ stack run -- site watch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which fires up an HTTP server on &lt;code&gt;localhost:8000&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The error messages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal: There is no &amp;lt;pkgname&amp;gt;.cabal package file or cabal.project file. To&#xA;build packages locally you need at minimum a &amp;lt;pkgname&amp;gt;.cabal file. You can use&#xA;&#39;cabal init&#39; to create one.&#xA;&#xA;For non-trivial projects you will also want a cabal.project file in the root&#xA;directory of your project. This file lists the packages in your project and&#xA;all other build configuration. See the Cabal user guide for full details.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;No executables found.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;typically indicate that the site was started from the root of the repository, rather than the &lt;code&gt;message-index&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h3&gt;Maintenance&lt;/h3&gt; &#xA;&lt;p&gt;The Message Index is a project of the &lt;a href=&#34;http://haskell.foundation&#34;&gt;Haskell Foundation&lt;/a&gt;. Please get in touch if you have ideas, requests, or any other feedback!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Simspace/simformat</title>
    <updated>2022-06-14T01:48:35Z</updated>
    <id>tag:github.com,2022-06-14:/Simspace/simformat</id>
    <link href="https://github.com/Simspace/simformat" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Formats haskell import lists&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SimFormat&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.com/simspace/simformat&#34;&gt;&lt;img src=&#34;https://travis-ci.com/simspace/simformat.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Formats Haskell import lists.&lt;/p&gt; &#xA;&lt;p&gt;It produces import lists that look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Range.Shared.Types&#xA;  ( ExternalRef(..), Imports(Imports), SomeExternalRef(SomeExternalRef), SpecEntity(..)&#xA;  , SpecRef(SpecRefExternal, SpecRefLocal), ExternalEntities, IsSpecEntity, ResolvedSpec&#xA;  , SpecEntities, VmRepetitionGroup, VmRgTag, importsConfigModuleDefs, importsOperatingSystems&#xA;  , importsVmTemplates, specEntitiesConfigModuleDefs, specEntitiesOperatingSystems&#xA;  , specEntitiesVmTemplates, specEntity, specificationEntities&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;simformat&lt;/code&gt; formats an entire git repository using a &lt;code&gt;.simformatrc&lt;/code&gt; config file in the repo root to identify files to include. To bypass this behavior you can call it with &lt;code&gt;simformat &amp;lt;file&amp;gt;&lt;/code&gt; which will format the file regardless of whether it&#39;s in the configuration. It should always succeed: if it cannot find any import blocks, it will simply pass the text on unchanged. You can always run &lt;code&gt;simformat --help&lt;/code&gt; for more command-line options.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ stack install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Emacs&lt;/h3&gt; &#xA;&lt;p&gt;From within Emacs, assuming you have the &lt;code&gt;haskell-mode&lt;/code&gt; and &lt;code&gt;stylish-haskell&lt;/code&gt; packages installed and working, &lt;code&gt;(setq haskell-mode-stylish-haskell-path &#34;simformat -e&#34;)&lt;/code&gt; and &lt;code&gt;(setq haskell-stylish-on-save t)&lt;/code&gt; should automatically reformat your import list on every save.&lt;/p&gt; &#xA;&lt;p&gt;If you prefer not to run code on save, you can use &lt;code&gt;shell-command-on-region&lt;/code&gt; with a region active and the prefix argument set, i.e. &lt;code&gt;C-u M-| simformat&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Vim&lt;/h3&gt; &#xA;&lt;p&gt;If you use &lt;a href=&#34;https://github.com/jose-elias-alvarez/null-ls.nvim/&#34;&gt;&lt;code&gt;null-ls.nvim&lt;/code&gt;&lt;/a&gt; an excellent plugin for integrating external tools for formatting / diagnostics in a way compatible with neovim&#39;s builtin LSP you can use this snippet to register a source that will format Haskell files using &lt;code&gt;simformat&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-viml&#34;&gt;lua &amp;lt;&amp;lt; EOF&#xA;local null_ls = require(&#39;null-ls&#39;)&#xA;local simformat = {&#xA;  name = &#39;simformat&#39;,&#xA;  method = null_ls.methods.FORMATTING,&#xA;  filetypes = {&#39;haskell&#39;},&#xA;  generator = require(&#39;null-ls.helpers&#39;).formatter_factory {&#xA;    command = &#39;simformat&#39;,&#xA;    args = {&#39;-e&#39;},&#xA;    to_stdin = true,&#xA;  },&#xA;}&#xA;null_ls.register(simformat)&#xA;EOF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One possible vim solution is to add this to your &lt;code&gt;.vimrc&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;function! s:RunSimformat()&#xA;  if &amp;amp;filetype == &#39;haskell&#39;&#xA;    let cmd = &#39;simformat -e&#39;&#xA;    let stdin = join(getline(1, &#39;$&#39;), &#34;\n&#34;)&#xA;    let output = system(cmd, stdin)&#xA;    if v:shell_error != 0&#xA;      echom output&#xA;    else&#xA;      call s:OverwriteBuffer(output)&#xA;    endif&#xA;  endif&#xA;endfunction&#xA;&#xA;function! s:OverwriteBuffer(output)&#xA;  if &amp;amp;modifiable&#xA;    let l:curw=winsaveview()&#xA;    try | silent undojoin | catch | endtry&#xA;    let splitted = split(a:output, &#39;\n&#39;)&#xA;    if line(&#39;$&#39;) &amp;gt; len(splitted)&#xA;      execute len(splitted) .&#39;,$delete&#39;&#xA;    endif&#xA;    call setline(1, splitted)&#xA;    call winrestview(l:curw)&#xA;  else&#xA;    echom &#34;Cannot write to non-modifiable buffer&#34;&#xA;  endif&#xA;endfunction&#xA;&#xA;augroup Simformat&#xA;  autocmd!&#xA;  autocmd BufWritePre * call &amp;lt;SID&amp;gt;RunSimformat()&#xA;augroup END&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To format without running on save, run &lt;code&gt;:!simformat&lt;/code&gt; (to format all files that are children of the &lt;code&gt;pwd&lt;/code&gt;) or run &lt;code&gt;:%!simformat -e&lt;/code&gt; (to format just the current file).&lt;/p&gt; &#xA;&lt;h3&gt;VSCode&lt;/h3&gt; &#xA;&lt;p&gt;Add this to &lt;code&gt;~/Library/Application Support/Code/User/settings.json&lt;/code&gt; once you have installed the &lt;a href=&#34;https://github.com/pucelle/vscode-run-on-save&#34;&gt;Run on Save&lt;/a&gt; extension.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;    &#34;runOnSave.statusMessageTimeout&#34;: 3000,&#xA;    &#34;runOnSave.commands&#34;: [&#xA;        {&#xA;            &#34;match&#34;: &#34;.*\\.hs$&#34;,&#xA;            &#34;notMatch&#34;: &#34;[\\\\\\/]_[^\\\\\\/]*\\.hs$&#34;,&#xA;            &#34;command&#34;: &#34;simformat ${file}&#34;,&#xA;            &#34;runIn&#34;: &#34;backend&#34;,&#xA;            &#34;runningStatusMessage&#34;: &#34;Formatting ${fileBasename}&#34;,&#xA;            &#34;finishStatusMessage&#34;: &#34;${fileBasename} formatted&#34;&#xA;        }&#xA;    ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;.simformatrc example&lt;/h2&gt; &#xA;&lt;p&gt;The config file, &lt;code&gt;.simformatrc&lt;/code&gt;, is expected to live in the directory where the &lt;code&gt;simformat&lt;/code&gt; executable is being run. It&#39;s a YAML file containing two keys: &lt;code&gt;files&lt;/code&gt; and &lt;code&gt;whitelist&lt;/code&gt;, each with a list of filepaths. If &lt;code&gt;.simformatrc&lt;/code&gt; is not present, it will interpret &lt;code&gt;files&lt;/code&gt; to be all files, and &lt;code&gt;whitelist&lt;/code&gt; to be empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;files:&#xA;  - foo&#xA;whitelist:&#xA;  - foo/bar&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>