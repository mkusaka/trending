<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-18T01:34:07Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>GaloisInc/demangler</title>
    <updated>2023-11-18T01:34:07Z</updated>
    <id>tag:github.com,2023-11-18:/GaloisInc/demangler</id>
    <link href="https://github.com/GaloisInc/demangler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell library for (C++) symbol name demangling&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;Demangler&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is a demangler for &#34;mangled&#34; source code names. A &#34;mangled&#34; name is an encoded form of a function or other symbol that includes additional information (types, template arguments, etc.) and possibly also compression, such that the result is smaller and is entirely comprised of characters that are valiod for a simple identifier (alphanumeric characters and underscores).&lt;/p&gt; &#xA;&lt;p&gt;C++ is the pre-emininent source of mangled names, although other languages perform mangling as well.&lt;/p&gt; &#xA;&lt;p&gt;Normal usage of this library will return the original demangled form if the demangling fails (usually because of incompleteness in this parser). There are occasional scenarios where the conversion to the string format is incomplete: these will generate obviously bad output... let us know what the right output is and we&#39;ll fix it!&lt;/p&gt; &#xA;&lt;p&gt;** Details&lt;/p&gt; &#xA;&lt;p&gt;*** General Implementation&lt;/p&gt; &#xA;&lt;p&gt;This library is intended to be used when processing compiled code that contains mangled names (e.g. LLVM bitcode, ELF symbol tables, etc.). When processing compiled code, it is not uncommon to encounter upwards of 10-15 thousand mangled symbols, all of which may need to be demangled. To support the primary goals of performance and tight memory footprint, this library uses a &lt;del&gt;Context&lt;/del&gt; that is essentially a state threaded through the demangling process to normalize (i.e. use sharing) textual information. There are two primary entry points: one that demangles a single string and internally creates and discards a &lt;del&gt;Context&lt;/del&gt; for that single demangling, and one that allows the re-use of a &lt;del&gt;Context&lt;/del&gt;, which is updated as each name is demangled.&lt;/p&gt; &#xA;&lt;p&gt;The demangling process is designed to never fail or throw exceptions: if a name cannot be demangled it is assumed to be an unmangled name (or garbage) and the original, unmangled form is returned. It is also possible to build this library with the debug flag enabled (&lt;del&gt;$ cabal configure -fdebug&lt;/del&gt;). In the debug mode, the library will panic on unrecognized parse scenarios or unimplemented string output forms. The panic provides additional information to help fix this issue, but is obviously a sub-optimal result for production code, so please only use the debug mode in appropriate scenarios.&lt;/p&gt; &#xA;&lt;p&gt;*** C++&lt;/p&gt; &#xA;&lt;p&gt;C++ mangling is a twisted and ill-documented process, primarily documented at &lt;a href=&#34;https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling&#34;&gt;https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling&lt;/a&gt;). There are lots of special considerations (e.g. expressions can be template arguments that must be mangled, thread-local data and guard variables are encoded), as well as relations to C++ syntax (e.g. nested template args require a space between closing &#39;&amp;gt;&#39; characters). This library is NOT YET a complete implementation: there are mangled forms that are not correctly parsed and/or printed; expect updates as these are encountered and needed (and patches are welcome).&lt;/p&gt; &#xA;&lt;p&gt;** Other options&lt;/p&gt; &#xA;&lt;p&gt;This is not the only Haskell demangler library; there is at least one other one that is built on the Boomerang parsing library, which has the advantage in that it is bi-directional, but the disadvantage that it is slow and uses considerably more memory. These disadvantages become very significant when processing source code that contains 10K-15K+ mangled names, ergo this library is &lt;em&gt;not&lt;/em&gt; bi-directional but it &lt;em&gt;is&lt;/em&gt; oriented towards performance and memory utilization.&lt;/p&gt; &#xA;&lt;p&gt;** Usage&lt;/p&gt; &#xA;&lt;p&gt;This is available as a library that can be used by other applications to demangle code, and also provides a &lt;del&gt;demangle&lt;/del&gt; application that is the equivalent of the &lt;del&gt;c++-filt&lt;/del&gt; application to demangle names provided on the command line or as standard input.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_example $ cabal run demangle _Znwm #+end_example&lt;/p&gt; &#xA;&lt;p&gt;The output of the demangling function(s) is an AST that represents the name in a semantically rich (but messy) manner. The &#34;sayable&#34; library (&lt;a href=&#34;https://hackage.haskell.org/package/sayable&#34;&gt;https://hackage.haskell.org/package/sayable&lt;/a&gt;) is used convert this AST to an actual rich string representation: there is a &lt;del&gt;Sayable&lt;/del&gt; instance for each &lt;del&gt;(AST_object, Context)&lt;/del&gt; tuple. The instances defined support the &lt;del&gt;&#34;diagnostic&#34;&lt;/del&gt; saytag for obtaining some additional information during output; normally the &lt;del&gt;&#34;normal&#34;&lt;/del&gt; saytag should be used.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_example putStrLn $ sez_ @&#34;normal&#34; $ demangle1 &#34;_Znwm&#34; #+end_example&lt;/p&gt; &#xA;&lt;p&gt;** Bugs&lt;/p&gt; &#xA;&lt;p&gt;Please use the issue tracker to notify us of any issues. There are certain to be some.&lt;/p&gt;</summary>
  </entry>
</feed>