<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-19T01:45:10Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Sekomer/Victim</title>
    <updated>2022-07-19T01:45:10Z</updated>
    <id>tag:github.com,2022-07-19:/Sekomer/Victim</id>
    <link href="https://github.com/Sekomer/Victim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Victim programming language written in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;strong&gt;Victim&lt;/strong&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;Victim&lt;/code&gt; is dynamically typed interpreted scripting language written in &lt;code&gt;Haskell&lt;/code&gt;. The name is inspired by source code of &lt;a href=&#34;https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3038&#34;&gt;malloc&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Installation&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;You need &lt;code&gt;Glasgow Haskell Compiler&lt;/code&gt; and &lt;code&gt;Cabal&lt;/code&gt; to install &lt;code&gt;Victim&lt;/code&gt; interpreter on your computer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cabal install -O2 --overwrite-policy=always &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;creates &lt;code&gt;Victim&lt;/code&gt; symlink to original binary.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;To run &lt;code&gt;Victim&lt;/code&gt; interpreter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Victim main.v&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Data Types&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Integer&lt;/td&gt; &#xA;   &lt;td&gt;Whole number&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Double&lt;/td&gt; &#xA;   &lt;td&gt;Number with floating points&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Bool&lt;/td&gt; &#xA;   &lt;td&gt;Truth values, internally Integer 0 and 1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;String&lt;/td&gt; &#xA;   &lt;td&gt;Sequence of characters&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Function&lt;/td&gt; &#xA;   &lt;td&gt;Subroutine&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Null&lt;/td&gt; &#xA;   &lt;td&gt;Representation of uselessness, inspired by the &lt;a href=&#34;https://en.wikipedia.org/wiki/JavaScript&#34;&gt;legend&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Examples are stored under &lt;a href=&#34;https://github.com/Sekomer/Victim/tree/main/examples&#34;&gt;example&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Language&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;strong&gt;Comments&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Haskell&#34;&gt;-- this is a single line comment&#xA;&#xA;{-&#xA; this&#xA; is&#xA; a&#xA; multi&#xA; line&#xA; comment&#xA;-}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;strong&gt;Variable Decleration and Assignment&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;var&lt;/code&gt; keyword is used to declare a variable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var num := null;    -- declare&#xA;num := 42           -- assign&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;strong&gt;Control Flow&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;-- single line conditional statements doesnt require braces&#xA;var cond := true;&#xA;if (cond) print( &#34;yeey&#34; );&#xA;&#xA;&#xA;-- multi line conditional statements require braces&#xA;var a  := 2;&#xA;var b  := 3;&#xA;var op := &#34;add&#34;;&#xA;&#xA;if ( op == &#34;add&#34; )&#xA;{&#xA;    var res := a + b;&#xA;    print(res);&#xA;}&#xA;else if ( op == &#34;mul&#34; )&#xA;{&#xA;    var res := a * b;&#xA;    print(res);&#xA;}&#xA;else    print( &#34;unknown operation!&#34; );&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;strong&gt;Case&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;case&lt;/code&gt; statements are clean alternatives of &lt;code&gt;if-else&lt;/code&gt; statements. &lt;code&gt;case&lt;/code&gt; keyword used to create a case statement, following expression is evaluated once and compared with the values of each &lt;code&gt;when&lt;/code&gt; label. If none of them match, &lt;code&gt;otherwise&lt;/code&gt; is executed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var a  := 2;&#xA;var b  := 3;&#xA;var op := &#34;mul&#34;;&#xA;&#xA;&#xA;case (op)&#xA;{&#xA;    when &#34;add&#34; =&amp;gt;&#xA;    {&#xA;        var f := anon x, y -&amp;gt; x + y;&#xA;        print( f(a, b) );&#xA;    }&#xA;&#xA;    when &#34;mul&#34; =&amp;gt;&#xA;    {&#xA;        var f := anon x, y -&amp;gt; x * y;&#xA;        print( f(a, b) );&#xA;    }&#xA;    &#xA;    otherwise =&amp;gt;&#xA;        print(&#34;Unknown op!&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;strong&gt;Loops&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;while&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt; keywords are used to create &lt;code&gt;loop&lt;/code&gt; statements.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;strong&gt;[*] while&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;while&lt;/code&gt; loops in the &lt;code&gt;Victim&lt;/code&gt; language contain 2 sections; cond and body.&lt;/p&gt; &#xA;&lt;p&gt;while &lt;code&gt;cond&lt;/code&gt; expression is true, the &lt;code&gt;body&lt;/code&gt; block is executed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[ pseudo ]&#xA;while (cond) { statement(s); }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;var condition := true;&#xA;&#xA;while (condition)&#xA;{&#xA;    print( &#34;YES!&#34; );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;strong&gt;[*] for&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;for&lt;/code&gt; loops in the &lt;code&gt;Victim&lt;/code&gt; language contain 4 sections; init, cond, after and body.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;init&lt;/code&gt; section is used for the decleration or assignment of variables.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cond&lt;/code&gt; section is evaluated before each execution the body. If it is left empty, it&#39;s considered as &lt;code&gt;true&lt;/code&gt; like in &lt;a href=&#34;https://en.wikipedia.org/wiki/C_(programming_language)&#34;&gt;the language of the gods&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;after&lt;/code&gt; section is evaluated after each execution of the &lt;code&gt;body&lt;/code&gt;. It can be empty.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;body&lt;/code&gt; section contains what will be executed in the &lt;code&gt;loop&lt;/code&gt; statement.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[ pseudo ]&#xA;for (init; cond; after) { statement(s); }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;for (var i := 0; i &amp;lt; 42; i := i + 1)&#xA;{&#xA;    print( i );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;following statements are also valid in &lt;code&gt;Victim&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;for (;;)&#xA;    print( &#34;C is the best!&#34; );&#xA;&#xA;for (;; print(&#34;C is the best!&#34;));&#xA;&#xA;-- like the good old C&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;loops support both &lt;code&gt;continue&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; statements.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;strong&gt;Functions&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;strong&gt;[*] Named Functions&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Named functions can be created with &lt;code&gt;fn&lt;/code&gt; keyword.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn add(a, b)&#xA;{&#xA;    return a + b;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Functions are not required to have &lt;code&gt;return&lt;/code&gt; statement. &lt;code&gt;return&lt;/code&gt; statement without an &lt;code&gt;expression&lt;/code&gt; and functions without &lt;code&gt;return&lt;/code&gt; statements return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;strong&gt;[*] Anonymous Functions&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Anonymous&lt;/code&gt; functions can be created with the &lt;code&gt;anon&lt;/code&gt; keyword. Anonymous functions are expressions, therefore, they need to be assigned to a variable or passed into the function as a parameter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;-- passed&#xA;fn apply (f, a, b)&#xA;{&#xA;    return f(a, b);&#xA;}&#xA;&#xA;print( apply(anon x, y -&amp;gt; x**y, 5, 6) );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;-- assigned&#xA;var f := anon x -&amp;gt; x**2;&#xA;print( f(5) );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;strong&gt;Contributing&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Please open an issue to discuss what you would like to change.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;License&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://choosealicense.com/licenses/mit/&#34;&gt;MIT&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>serokell/universum</title>
    <updated>2022-07-19T01:45:10Z</updated>
    <id>tag:github.com,2022-07-19:/serokell/universum</id>
    <link href="https://github.com/serokell/universum" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸŒŒ Prelude written in @serokell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Universum&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/serokell/universum/actions&#34;&gt;&lt;img src=&#34;https://github.com/serokell/universum/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;GitHub CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hackage.haskell.org/package/universum&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/universum.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stackage.org/lts/package/universum&#34;&gt;&lt;img src=&#34;http://stackage.org/package/universum/badge/lts&#34; alt=&#34;Stackage LTS&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stackage.org/nightly/package/universum&#34;&gt;&lt;img src=&#34;http://stackage.org/package/universum/badge/nightly&#34; alt=&#34;Stackage Nightly&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-yellow.svg?sanitize=true&#34; alt=&#34;License: MIT&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;universum&lt;/code&gt; is a custom prelude used in @Serokell that has:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Excellent documentation&lt;/strong&gt;: tutorial, migration guide from &lt;code&gt;Prelude&lt;/code&gt;, Haddock with examples for (almost) every function, all examples are tested with &lt;a href=&#34;http://hackage.haskell.org/package/doctest&#34;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt;, documentation regarding internal module structure.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;universum&lt;/code&gt;-specific &lt;a href=&#34;http://hackage.haskell.org/package/hlint&#34;&gt;HLint&lt;/a&gt; rules: &lt;a href=&#34;https://github.com/serokell/universum/raw/master/.hlint.yaml&#34;&gt;&lt;code&gt;.hlint.yaml&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Focus on safety, convenience and efficiency.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;What is this file about?&lt;/h2&gt; &#xA;&lt;p&gt;This README contains introduction to &lt;code&gt;Universum&lt;/code&gt; and a tutorial on how to use it.&lt;/p&gt; &#xA;&lt;h2&gt;Structure of this tutorial&lt;/h2&gt; &#xA;&lt;p&gt;This tutorial has several parts:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/#why-another-custom-prelude-&#34;&gt;Philosophy and motivation.&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/#how-to-use-universum-&#34;&gt;How to use &lt;code&gt;universum&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/#gotchas-&#34;&gt;Changes in &lt;code&gt;Prelude&lt;/code&gt; (some gotchas).&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/#things-that-you-were-already-using-but-now-you-dont-have-to-import-them-explicitly-&#34;&gt;Already known things that weren&#39;t in &lt;code&gt;Prelude&lt;/code&gt; brought into scope.&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/#whats-new-&#34;&gt;New things added.&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/#migration-guide-from-prelude-&#34;&gt;Migration guide from &lt;code&gt;Prelude&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This is neither a tutorial on &lt;em&gt;Haskell&lt;/em&gt; nor tutorial on each function contained in Universum. For detailed documentation of every function together with examples and usage, see &lt;a href=&#34;http://hackage.haskell.org/package/universum&#34;&gt;&lt;em&gt;Haddock documentation&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Why another custom Prelude? &lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/#structure-of-this-tutorial&#34;&gt;â†‘&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;Motivation&lt;/h3&gt; &#xA;&lt;p&gt;At &lt;a href=&#34;https://github.com/serokell/&#34;&gt;Serokell&lt;/a&gt;, we strive to be as productive as possible. That&#39;s why we are using &lt;a href=&#34;https://haskell-lang.org/&#34;&gt;&lt;em&gt;Haskell&lt;/em&gt;&lt;/a&gt;. This choice of language implies that we&#39;re restricted to use &lt;a href=&#34;http://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html&#34;&gt;&lt;code&gt;Prelude&lt;/code&gt;&lt;/a&gt;: implicit import of basic functions, type classes and data types. Unfortunately, the default &lt;code&gt;Prelude&lt;/code&gt; &lt;a href=&#34;https://news.ycombinator.com/item?id=8002749&#34;&gt;is considered to be not so good&lt;/a&gt; due to some historical reasons.&lt;/p&gt; &#xA;&lt;p&gt;This is why we decided to use a better tool. Luckily, &lt;em&gt;Haskell&lt;/em&gt; provides us with the ability to replace default &lt;code&gt;Prelude&lt;/code&gt; with an alternative. All we had to do is to implement a new basic set of defaults. There already were plenty of &lt;a href=&#34;https://guide.aelve.com/haskell/alternative-preludes-zr69k1hc&#34;&gt;preludes&lt;/a&gt;, so we didn&#39;t plan to implement everything from scratch. After some long, hot discussions, our team decided to base our custom prelude on &lt;a href=&#34;https://github.com/sdiehl/protolude&#34;&gt;&lt;code&gt;protolude&lt;/code&gt;&lt;/a&gt;. If you&#39;re not familiar with it, you can read &lt;a href=&#34;http://www.stephendiehl.com/posts/protolude.html&#34;&gt;a tutorial about &lt;code&gt;protolude&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The next section explains why we&#39;ve made this choice and what we are willing to do. This tutorial doesn&#39;t cover the differences from &lt;code&gt;protolude&lt;/code&gt;. Instead, it explains how Universum is different from regular &lt;code&gt;Prelude&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Main goals&lt;/h3&gt; &#xA;&lt;p&gt;While creating and maintaining a custom prelude, we are pursuing the following goals:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Avoid all &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/5n51u3/why_are_partial_functions_as_in_head_tail_bad/&#34;&gt;partial functions&lt;/a&gt;. We like &lt;a href=&#34;http://mathworld.wolfram.com/TotalFunction.html&#34;&gt;total&lt;/a&gt; and exception-free functions. You can still use some unsafe functions from &lt;code&gt;Universum.Unsafe&lt;/code&gt; module, but they are not exported by default.&lt;/li&gt; &#xA; &lt;li&gt;Use more efficient &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/29jw0s/whats_wrong_with_string/&#34;&gt;string representations&lt;/a&gt;. &lt;code&gt;String&lt;/code&gt; type is crushingly inefficient. All our functions either try to be polymorphic over string type or use &lt;a href=&#34;http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text.html&#34;&gt;&lt;code&gt;Text&lt;/code&gt;&lt;/a&gt; as the default string type. Because the community is evolving slowly, some libraries still use &lt;code&gt;String&lt;/code&gt; type, so &lt;code&gt;String&lt;/code&gt; type alias is still reexported. We recommend to avoid &lt;code&gt;String&lt;/code&gt; as much as you can!&lt;/li&gt; &#xA; &lt;li&gt;Try to not reinvent the wheel. We&#39;re not trying to rebuild whole type hierarchy from scratch, as it&#39;s done in &lt;a href=&#34;https://github.com/snoyberg/mono-traversable&#34;&gt;&lt;code&gt;classy-prelude&lt;/code&gt;&lt;/a&gt;. Instead, we reexport common and well-known things from &lt;code&gt;base&lt;/code&gt; and some other libraries that are used in everyday production programming in &lt;em&gt;Haskell&lt;/em&gt;. &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: well, we did end up inventing &lt;em&gt;some&lt;/em&gt; new things.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt;Export more useful and commonly used functions. &lt;a href=&#34;https://twitter.com/magnars/status/834683466130345984&#34;&gt;Hello, my name is Dmitry. I was coding &lt;em&gt;Haskell&lt;/em&gt; for 3 years but still hoogling which module &lt;code&gt;liftIO&lt;/code&gt; comes from.&lt;/a&gt; Things like &lt;code&gt;liftIO&lt;/code&gt;, &lt;code&gt;ReaderT&lt;/code&gt; type, &lt;code&gt;MVar&lt;/code&gt;-related functions have unambiguous names, are used in almost every non-trivial project, and it&#39;s really tedious to import them manually every time.&lt;/li&gt; &#xA; &lt;li&gt;Make changes only when there are enough good reasons to make these changes. We have a &lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/CONTRIBUTING.md#code-modification-policy&#34;&gt;code modification policy&lt;/a&gt; which semi-formally describes pre-conditions for different types of changes.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Unlike &lt;code&gt;protolude&lt;/code&gt;, we are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Not trying to be as general as possible (thus we don&#39;t export much from &lt;a href=&#34;https://github.com/sdiehl/protolude/raw/41710698eedc66fb0bfc5623d3c3a672421fbab5/src/Protolude.hs#L365&#34;&gt;&lt;code&gt;GHC.Generics&lt;/code&gt;&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Not trying to maintain every version of &lt;code&gt;ghc&lt;/code&gt; compiler (but &lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/.github/workflows/ci.yml&#34;&gt;at least the latest 3&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Trying to make writing production code easier (see &lt;a href=&#34;https://github.com/serokell/universum/issues&#34;&gt;enhancements and fixes&lt;/a&gt;).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;How to use Universum &lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/#structure-of-this-tutorial&#34;&gt;â†‘&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Okay, enough philosophy. If you want to just start using &lt;code&gt;universum&lt;/code&gt; and explore it with the help of compiler, set everything up according to the instructions below.&lt;/p&gt; &#xA;&lt;p&gt;Disable the built-in prelude at the top of your file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE NoImplicitPrelude #-}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or directly in your project &lt;code&gt;.cabal&lt;/code&gt; file, if you want to use in every module by default:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;default-extensions: NoImplicitPrelude&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then add the following import to your modules:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Universum&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;re using &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;Emacs&lt;/a&gt; and don&#39;t want to type &lt;code&gt;import Universum&lt;/code&gt; manually every time, you can &lt;a href=&#34;https://github.com/serokell/universum/issues/8#issuecomment-276444879&#34;&gt;modify your configs&lt;/a&gt; a little bit.&lt;/p&gt; &#xA;&lt;p&gt;If you want to get familiar with &lt;code&gt;universum&lt;/code&gt; internal structure, you can just read top-level documentation for &lt;a href=&#34;http://hackage.haskell.org/package/universum/docs/Universum.html&#34;&gt;&lt;code&gt;Universum&lt;/code&gt;&lt;/a&gt; module.&lt;/p&gt; &#xA;&lt;h2&gt;Gotchas &lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/#structure-of-this-tutorial&#34;&gt;â†‘&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;head&lt;/code&gt;, &lt;code&gt;tail&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;init&lt;/code&gt;, &lt;code&gt;foldl1&lt;/code&gt;, &lt;code&gt;minimum&lt;/code&gt; and other were-partial functions work with &lt;code&gt;NonEmpty a&lt;/code&gt; instead of &lt;code&gt;[a]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Safe analogue for &lt;code&gt;head&lt;/code&gt;, &lt;code&gt;foldl1&lt;/code&gt;, &lt;code&gt;foldr1&lt;/code&gt;, &lt;code&gt;minimum&lt;/code&gt;, &lt;code&gt;maximum&lt;/code&gt; functions, for instance: &lt;code&gt;safeHead :: [a] -&amp;gt; Maybe a&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;undefined&lt;/code&gt; triggers a compiler warning, which is probably not what you want. Either use &lt;code&gt;throwIO&lt;/code&gt;, &lt;code&gt;Except&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;bug&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;map&lt;/code&gt; is &lt;code&gt;fmap&lt;/code&gt; now.&lt;/li&gt; &#xA; &lt;li&gt;Multiple sorting functions are available without imports: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;sortBy :: (a -&amp;gt; a -&amp;gt; Ordering) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;: sorts list using given custom comparator.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;sortWith :: Ord b =&amp;gt; (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;: sorts a list based on some property of its elements.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;sortOn :: Ord b =&amp;gt; (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;: just like &lt;code&gt;sortWith&lt;/code&gt;, but more time-efficient if function is calculated slowly (though less space-efficient). So you should write &lt;code&gt;sortOn length&lt;/code&gt; (would sort elements by length) but &lt;code&gt;sortWith fst&lt;/code&gt; (would sort list of pairs by first element).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Functions &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;product&lt;/code&gt; are strict now, which makes them more efficient.&lt;/li&gt; &#xA; &lt;li&gt;If you try to do something like &lt;code&gt;putStrLn &#34;hi&#34;&lt;/code&gt;, you&#39;ll get an error message if &lt;code&gt;OverloadedStrings&lt;/code&gt; is enabled â€“ it happens because the compiler doesn&#39;t know what type to infer for the string. Use &lt;code&gt;putTextLn&lt;/code&gt; in this case.&lt;/li&gt; &#xA; &lt;li&gt;Since &lt;code&gt;show&lt;/code&gt; doesn&#39;t come from &lt;code&gt;Show&lt;/code&gt; anymore, you can&#39;t write &lt;code&gt;Show&lt;/code&gt; instances easily. See &lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/#migration-guide-from-prelude-&#34;&gt;migration guide&lt;/a&gt; for details.&lt;/li&gt; &#xA; &lt;li&gt;You can&#39;t call some &lt;code&gt;Foldable&lt;/code&gt; methods over &lt;code&gt;Maybe&lt;/code&gt; and some other types. &lt;code&gt;Foldable&lt;/code&gt; generalization is useful but &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/60r9hu/proposal_suggest_explicit_type_application_for/&#34;&gt;potentially error-prone&lt;/a&gt;. Instead we created our own fully compatible with &lt;code&gt;Foldable&lt;/code&gt; &lt;a href=&#34;https://github.com/serokell/universum/raw/b6353285859e9ed3544bddbf55d70237330ad64a/src/Universum/Container/Class.hs#L180&#34;&gt;&lt;code&gt;Container&lt;/code&gt; type class&lt;/a&gt; but that restricts the usage of functions like &lt;code&gt;length&lt;/code&gt; over &lt;code&gt;Maybe&lt;/code&gt;, &lt;code&gt;Either&lt;/code&gt;, &lt;code&gt;Identity&lt;/code&gt; and tuples. We&#39;re also using &lt;em&gt;GHC 8&lt;/em&gt; feature of &lt;a href=&#34;https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/type_errors.html&#34;&gt;custom compile-time errors&lt;/a&gt; to produce &lt;a href=&#34;https://github.com/serokell/universum/raw/54a742c10720f11c739f2d268365d723924b83a9/src/Containers.hs#L474&#34;&gt;more helpful messages&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;As a consequence of previous point, some functions like &lt;code&gt;traverse_&lt;/code&gt;, &lt;code&gt;forM_&lt;/code&gt;, &lt;code&gt;sequenceA_&lt;/code&gt;, etc. are generalized over &lt;code&gt;Container&lt;/code&gt; type classes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;error&lt;/code&gt; takes &lt;code&gt;Text&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;We are exporting a rewrite rule which replaces &lt;code&gt;toString . toText :: Text -&amp;gt; Text&lt;/code&gt; with &lt;code&gt;id&lt;/code&gt;. Note that this changes semantics in some corner cases.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Things that you were already using, but now you don&#39;t have to import them explicitly &lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/#structure-of-this-tutorial&#34;&gt;â†‘&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;Commonly used libraries&lt;/h3&gt; &#xA;&lt;p&gt;First of all, we reexport some generally useful modules: &lt;code&gt;Control.Applicative&lt;/code&gt;, &lt;code&gt;Data.Traversable&lt;/code&gt;, &lt;code&gt;Data.Monoid&lt;/code&gt;, &lt;code&gt;Control.DeepSeq&lt;/code&gt;, &lt;code&gt;Data.List&lt;/code&gt;, and lots of others. Just remove unneeded imports after importing &lt;code&gt;Universum&lt;/code&gt; (GHC should tell you which ones).&lt;/p&gt; &#xA;&lt;p&gt;Then, some commonly used types: &lt;code&gt;Map/HashMap/IntMap&lt;/code&gt;, &lt;code&gt;Set/HashSet/IntSet&lt;/code&gt;, &lt;code&gt;Seq&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt; and &lt;code&gt;ByteString&lt;/code&gt; (as well as synonyms &lt;code&gt;LText&lt;/code&gt; and &lt;code&gt;LByteString&lt;/code&gt; for lazy versions).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;liftIO&lt;/code&gt; and &lt;code&gt;MonadIO&lt;/code&gt; are exported by default. A lot of &lt;code&gt;IO&lt;/code&gt; functions are generalized to &lt;code&gt;MonadIO&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;deepseq&lt;/code&gt; is exported. For instance, if you want to force deep evaluation of some value (in IO), you can write &lt;code&gt;evaluateNF a&lt;/code&gt;. WHNF evaluation is possible with &lt;code&gt;evaluateWHNF a&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We also reexport big chunks of these libraries: &lt;code&gt;mtl&lt;/code&gt;, &lt;code&gt;stm&lt;/code&gt;, &lt;code&gt;microlens&lt;/code&gt;, &lt;code&gt;microlens-mtl&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Bifunctor.html&#34;&gt;&lt;code&gt;Bifunctor&lt;/code&gt;&lt;/a&gt; type class with useful instances is exported.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; functions apply a function to first/second part of a tuple (for tuples).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bimap&lt;/code&gt; takes two functions and applies them to first and second parts respectively.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Text&lt;/h3&gt; &#xA;&lt;p&gt;We export &lt;code&gt;Text&lt;/code&gt; and &lt;code&gt;LText&lt;/code&gt;, and some functions work with &lt;code&gt;Text&lt;/code&gt; instead of &lt;code&gt;String&lt;/code&gt; â€“ specifically, IO functions (&lt;code&gt;readFile&lt;/code&gt;, &lt;code&gt;putStrLn&lt;/code&gt;, etc) and &lt;code&gt;show&lt;/code&gt;. In fact, &lt;code&gt;show&lt;/code&gt; is polymorphic and can produce strict or lazy &lt;code&gt;Text&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, or &lt;code&gt;ByteString&lt;/code&gt;. Also, &lt;code&gt;toText/toLText/toString&lt;/code&gt; can convert &lt;code&gt;Text|LText|String&lt;/code&gt; types to &lt;code&gt;Text/LText/String&lt;/code&gt;. If you want to convert to and from &lt;code&gt;ByteString&lt;/code&gt; use &lt;code&gt;encodeUtf8/decodeUtf8&lt;/code&gt; functions.&lt;/p&gt; &#xA;&lt;h3&gt;Debugging and &lt;code&gt;undefined&lt;/code&gt;s&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;traceM&lt;/code&gt;, &lt;code&gt;traceShow&lt;/code&gt;, etc. are available by default. GHC will warn you if you accidentally leave them in code, however (same for &lt;code&gt;undefined&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;We also have &lt;code&gt;data Undefined = Undefined&lt;/code&gt; (which, too, comes with warnings).&lt;/p&gt; &#xA;&lt;h3&gt;Exceptions&lt;/h3&gt; &#xA;&lt;p&gt;We use &lt;a href=&#34;https://github.com/fpco/safe-exceptions&#34;&gt;&lt;code&gt;safe-exceptions&lt;/code&gt;&lt;/a&gt; library for exceptions handling. Don&#39;t import &lt;code&gt;Control.Exceptions&lt;/code&gt; module explicitly. Instead use functionality from &lt;code&gt;safe-exceptions&lt;/code&gt; provided by &lt;code&gt;universum&lt;/code&gt; or import &lt;code&gt;Control.Exceptions.Safe&lt;/code&gt; module.&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s new? &lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/#structure-of-this-tutorial&#34;&gt;â†‘&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Finally, we can move to part describing the new cool features we bring with &lt;code&gt;universum&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;uncons&lt;/code&gt; splits a list at the first element.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ordNub&lt;/code&gt; and &lt;code&gt;sortNub&lt;/code&gt; are &lt;em&gt;O(n log n)&lt;/em&gt; versions of &lt;code&gt;nub&lt;/code&gt; (which is quadratic) and &lt;code&gt;hashNub&lt;/code&gt; and &lt;code&gt;unstableNub&lt;/code&gt; are almost &lt;em&gt;O(n)&lt;/em&gt; versions of &lt;code&gt;nub&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;(&amp;amp;)&lt;/code&gt; â€“ reverse application. &lt;code&gt;x &amp;amp; f &amp;amp; g&lt;/code&gt; instead of &lt;code&gt;g $ f $ x&lt;/code&gt; is useful sometimes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;whenM&lt;/code&gt;, &lt;code&gt;unlessM&lt;/code&gt;, &lt;code&gt;ifM&lt;/code&gt;, &lt;code&gt;guardM&lt;/code&gt; are available and do what you expect them to do (e.g. &lt;code&gt;whenM (doesFileExist &#34;foo&#34;)&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Very generalized version of &lt;code&gt;concatMapM&lt;/code&gt;, too, is available and does what expected.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;readMaybe&lt;/code&gt; and &lt;code&gt;readEither&lt;/code&gt; are like &lt;code&gt;read&lt;/code&gt; but total and give either &lt;code&gt;Maybe&lt;/code&gt; or &lt;code&gt;Either&lt;/code&gt; with parse error.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;when(Just|Nothing|Left|Right|NotEmpty)[M][_]&lt;/code&gt; let you conditionally execute something. Before:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;case mbX of&#xA;    Nothing -&amp;gt; return ()&#xA;    Just x  -&amp;gt; ... x ...&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;After:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;whenJust mbX $ \x -&amp;gt;&#xA;    ... x ...&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;for_&lt;/code&gt; for loops. There&#39;s also &lt;code&gt;forM_&lt;/code&gt; but &lt;code&gt;for_&lt;/code&gt; looks a bit nicer.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;for_ [1..10] $ \i -&amp;gt; do&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;andM&lt;/code&gt;, &lt;code&gt;allM&lt;/code&gt;, &lt;code&gt;anyM&lt;/code&gt;, &lt;code&gt;orM&lt;/code&gt; are monadic version of corresponding functions from &lt;code&gt;base&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Type operator &lt;code&gt;$&lt;/code&gt; for writing types like &lt;code&gt;Maybe $ Either String $ Maybe Int&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Each&lt;/code&gt; type family. So this:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;f :: Each [Show, Read] [a, b] =&amp;gt; a -&amp;gt; b -&amp;gt; String&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;translates into this:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;f :: (Show a, Show b, Read a, Read b) =&amp;gt; a -&amp;gt; b -&amp;gt; String&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;With&lt;/code&gt; type operator. So this:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;a :: With [Show, Read] a =&amp;gt; a -&amp;gt; a&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;translates into this:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;a :: (Show a, Read a) =&amp;gt; a -&amp;gt; a&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Variadic composition operator &lt;code&gt;(...)&lt;/code&gt;. So you can write:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; (show ... (+)) 1 2&#xA;&#34;3&#34;&#xA;ghci&amp;gt; show ... 5&#xA;&#34;5&#34;&#xA;ghci&amp;gt; (null ... zip5) [1] [2] [3] [] [5]&#xA;True&#xA;ghci&amp;gt; let process = map (+3) ... filter&#xA;ghci&amp;gt; process even [1..5]&#xA;[5,7]&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Conversions between &lt;code&gt;Either&lt;/code&gt; and &lt;code&gt;Maybe&lt;/code&gt; like &lt;code&gt;rightToMaybe&lt;/code&gt; and &lt;code&gt;maybeToLeft&lt;/code&gt; with clear semantic.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;using(Reader|State)[T]&lt;/code&gt; functions as aliases for &lt;code&gt;flip run(Reader|State)[T]&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/src/Universum/Container/Class.hs&#34;&gt;&lt;code&gt;One&lt;/code&gt; type class&lt;/a&gt; for creating singleton containers. Even monomorhpic ones like &lt;code&gt;Text&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;evaluateWHNF&lt;/code&gt; and &lt;code&gt;evaluateNF&lt;/code&gt; functions as clearer and lifted aliases for &lt;code&gt;evaluate&lt;/code&gt; and &lt;code&gt;evaluate . force&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ToPairs&lt;/code&gt; type class for data types that can be converted to list of pairs (like &lt;code&gt;Map&lt;/code&gt; or &lt;code&gt;HashMap&lt;/code&gt; or &lt;code&gt;IntMap&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Migration guide from Prelude &lt;a href=&#34;https://raw.githubusercontent.com/serokell/universum/master/#structure-of-this-tutorial&#34;&gt;â†‘&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;In order to replace default &lt;code&gt;Prelude&lt;/code&gt; with &lt;code&gt;universum&lt;/code&gt; you should start with instructions given in &lt;a href=&#34;https://github.com/serokell/universum#how-to-use-universum-&#34;&gt;how to use universum&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;p&gt;This section describes what you need to change to make your code compile with &lt;code&gt;universum&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Enable &lt;code&gt;-XOverloadedStrings&lt;/code&gt; and &lt;code&gt;-XTypeFamilies&lt;/code&gt; extension by default for your project.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Since &lt;code&gt;head&lt;/code&gt;, &lt;code&gt;tail&lt;/code&gt;, &lt;code&gt;minimum&lt;/code&gt; and some other functions work for &lt;code&gt;NonEmpty&lt;/code&gt; you should refactor your code in one of the multiple ways described below:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Change &lt;code&gt;[a]&lt;/code&gt; to &lt;code&gt;NonEmpty a&lt;/code&gt; where it makes sense.&lt;/li&gt; &#xA;   &lt;li&gt;Use functions which return &lt;code&gt;Maybe&lt;/code&gt;. They can be implemented using &lt;code&gt;nonEmpty&lt;/code&gt; function. Like &lt;code&gt;head &amp;lt;$&amp;gt; nonEmpty l&lt;/code&gt;. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;head &amp;lt;$&amp;gt; nonEmpty l&lt;/code&gt; is &lt;code&gt;safeHead l&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;tail&lt;/code&gt; is &lt;code&gt;drop 1&lt;/code&gt;. It&#39;s almost never a good idea to use &lt;code&gt;tail&lt;/code&gt; from &lt;code&gt;Prelude&lt;/code&gt;.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Add &lt;code&gt;import qualified Universum.Unsafe as Unsafe&lt;/code&gt; and replace function with qualified usage.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you use &lt;code&gt;fromJust&lt;/code&gt; or &lt;code&gt;!!&lt;/code&gt; you should use them from &lt;code&gt;import qualified Universum.Unsafe as Unsafe&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Derive or implement &lt;code&gt;Container&lt;/code&gt; instances for your data types which implement &lt;code&gt;Foldable&lt;/code&gt; instances. This can be done in a single line because &lt;code&gt;Container&lt;/code&gt; type class automatically derives from &lt;code&gt;Foldable&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Container&lt;/code&gt; type class from &lt;code&gt;universum&lt;/code&gt; replaces &lt;code&gt;Foldable&lt;/code&gt; and doesn&#39;t have instances for &lt;code&gt;Maybe a&lt;/code&gt;, &lt;code&gt;(a, b)&lt;/code&gt;, &lt;code&gt;Identity a&lt;/code&gt; and &lt;code&gt;Either a b&lt;/code&gt;. If you use &lt;code&gt;foldr&lt;/code&gt; or &lt;code&gt;forM_&lt;/code&gt; or similar for something like &lt;code&gt;Maybe a&lt;/code&gt; you should replace usages of such function with monomorhpic alternatives:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt;&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;(?:) :: Maybe a -&amp;gt; a -&amp;gt; a&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;fromMaybe :: a -&amp;gt; Maybe a -&amp;gt; a&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;maybeToList :: Maybe a -&amp;gt; [a]&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;maybeToMonoid :: Monoid m =&amp;gt; Maybe m -&amp;gt; m&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;maybe :: b -&amp;gt; (a -&amp;gt; b) -&amp;gt; Maybe a -&amp;gt; b&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;whenJust :: Applicative f =&amp;gt; Maybe a -&amp;gt; (a -&amp;gt; f ()) -&amp;gt; f ()&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;whenJustM :: Monad m =&amp;gt; m (Maybe a) -&amp;gt; (a -&amp;gt; m ()) -&amp;gt; m ()&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;Either&lt;/code&gt;&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;fromLeft :: a -&amp;gt; Either a b -&amp;gt; a&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;fromRight :: b -&amp;gt; Either a b -&amp;gt; b&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;either :: (a -&amp;gt; c) -&amp;gt; (b -&amp;gt; c) -&amp;gt; Either a b -&amp;gt; c&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;whenRight :: Applicative f =&amp;gt; Either l r -&amp;gt; (r -&amp;gt; f ()) -&amp;gt; f ()&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;whenRightM :: Monad m =&amp;gt; m (Either l r) -&amp;gt; (r -&amp;gt; m ()) -&amp;gt; m ()&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you have types like &lt;code&gt;foo :: Foldable f =&amp;gt; f a -&amp;gt; a -&amp;gt; a&lt;/code&gt; you should chose one of the following:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;Right&lt;/code&gt;: Modify types for &lt;code&gt;Container&lt;/code&gt; like &lt;code&gt;foo :: (Container t, Element t ~ a) =&amp;gt; t -&amp;gt; a -&amp;gt; a&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Left&lt;/code&gt;: Import &lt;code&gt;Data.Foldable&lt;/code&gt; module &lt;code&gt;qualified&lt;/code&gt; and use everything &lt;code&gt;Foldable&lt;/code&gt;-related qualified.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Forget about &lt;code&gt;String&lt;/code&gt; type.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Replace &lt;code&gt;putStr&lt;/code&gt; and &lt;code&gt;putStrLn&lt;/code&gt; with &lt;code&gt;putText&lt;/code&gt; and &lt;code&gt;putTextLn&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Replace &lt;code&gt;(++)&lt;/code&gt; with &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; for &lt;code&gt;String&lt;/code&gt;-like types.&lt;/li&gt; &#xA;   &lt;li&gt;Try to use &lt;a href=&#34;http://hackage.haskell.org/package/fmt&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt; library if you need to construct messages.&lt;/li&gt; &#xA;   &lt;li&gt;Use &lt;code&gt;toText/toLText/toString&lt;/code&gt; functions to convert to &lt;code&gt;Text/LazyText/String&lt;/code&gt; types.&lt;/li&gt; &#xA;   &lt;li&gt;Use &lt;code&gt;encodeUtf8/decodeUtf8&lt;/code&gt; to convert to/from &lt;code&gt;ByteString&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run &lt;code&gt;hlint&lt;/code&gt; using &lt;code&gt;.hlint.yaml&lt;/code&gt; file from &lt;code&gt;universum&lt;/code&gt; package to cleanup code and imports.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Since vanilla &lt;code&gt;show&lt;/code&gt; from the &lt;code&gt;Show&lt;/code&gt; class is not available, your custom &lt;code&gt;Show&lt;/code&gt; instances will fail to compile. You can &lt;code&gt;import qualified Text.Show&lt;/code&gt; to bring vanilla &lt;code&gt;show&lt;/code&gt; to scope with qualified name. It will not conflict with &lt;code&gt;show&lt;/code&gt; from &lt;code&gt;universum&lt;/code&gt; and your &lt;code&gt;Show&lt;/code&gt; instances will compile successfully.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>haskell/unix</title>
    <updated>2022-07-19T01:45:10Z</updated>
    <id>tag:github.com,2022-07-19:/haskell/unix</id>
    <link href="https://github.com/haskell/unix" rel="alternate"></link>
    <summary type="html">&lt;p&gt;POSIX functionality&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The &lt;code&gt;unix&lt;/code&gt; Package &lt;a href=&#34;https://hackage.haskell.org/package/unix&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/unix.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/haskell/unix/actions?query=workflow%3Aci&#34;&gt;&lt;img src=&#34;https://github.com/haskell/unix/workflows/ci/badge.svg?sanitize=true&#34; alt=&#34;GitHub Build Status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://hackage.haskell.org/package/unix&#34;&gt;&lt;code&gt;unix&lt;/code&gt; on Hackage&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Installing from Git&lt;/h2&gt; &#xA;&lt;p&gt;To build this package using Cabal directly from Git, you must run &lt;code&gt;autoreconf -i&lt;/code&gt; before the usual Cabal build steps (&lt;code&gt;cabal {configure,build,install}&lt;/code&gt;). The program &lt;code&gt;autoreconf&lt;/code&gt; is part of &lt;a href=&#34;http://www.gnu.org/software/autoconf/&#34;&gt;GNU autoconf&lt;/a&gt;. There is no need to run the &lt;code&gt;configure&lt;/code&gt; script: &lt;code&gt;cabal configure&lt;/code&gt; will do this for you.&lt;/p&gt;</summary>
  </entry>
</feed>