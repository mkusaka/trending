<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-09T01:33:54Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tweag/smtlib-backends</title>
    <updated>2022-12-09T01:33:54Z</updated>
    <id>tag:github.com,2022-12-09:/tweag/smtlib-backends</id>
    <link href="https://github.com/tweag/smtlib-backends" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Haskell library providing low-level functions for SMT-LIB-based interaction with SMT solvers.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SMT-LIB backends&lt;/h1&gt; &#xA;&lt;p&gt;This Haskell library provides different low-level ways of interacting with SMT solvers using &lt;a href=&#34;https://smtlib.cs.uiowa.edu/&#34;&gt;SMT-LIB&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It was created because there are a lot of Haskell projects using SMT solvers through SMT-LIB, but most of them only use solvers through external processes and implement the interaction with the solver themselves. But running solvers as external processes can be quite slow, hence this library aims to provide other, more efficient ways to do so. We believe having one well-optimized and safe library is more efficient than having the same code be spread out between different projects.&lt;/p&gt; &#xA;&lt;p&gt;We currently provide two different backends: a classic backend implemented by running solvers as external processes, and a faster backend, available in the &lt;code&gt;smtlib-backends-z3&lt;/code&gt; package, implemented using inlined calls to Z3&#39;s C API.&lt;/p&gt; &#xA;&lt;h1&gt;Building and testing&lt;/h1&gt; &#xA;&lt;p&gt;This repository provides a reproducible build environment through a &lt;a href=&#34;https://www.tweag.io/blog/2020-05-25-flakes/&#34;&gt;Nix flake&lt;/a&gt;. If this is not an option for you, you&#39;ll have to get a copy of Z3 for testing &lt;code&gt;smtlib-backends&lt;/code&gt; and of the Z3 C library for building &lt;code&gt;smtlib-backends-z3&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can then build and test the libraries using &lt;code&gt;cabal build&lt;/code&gt; and &lt;code&gt;cabal test&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;h2&gt;Code formatting&lt;/h2&gt; &#xA;&lt;p&gt;We format our code using &lt;a href=&#34;https://github.com/tweag/ormolu&#34;&gt;ormolu&lt;/a&gt; (more specifically the version from &lt;a href=&#34;https://github.com/NixOS/nixpkgs&#34;&gt;NixOS/nixpkgs&lt;/a&gt;&#39;s master branch). It is thus recommended to add the following script as your &lt;code&gt;.git/hooks/pre-commit&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env bash&#xA;set -e&#xA;&#xA;# command adapted from https://github.com/JLLeitschuh/ktlint-gradle  task addKtlintFormatGitPreCommitHook&#xA;filesToFormat=&#34;$(git --no-pager diff --name-status --no-color --cached | \&#xA;  awk &#39;($1 == &#34;M&#34; || $1 == &#34;A&#34;) &amp;amp;&amp;amp; $2 ~ /\.hs/ { print $2} $1 ~ /R/ &amp;amp;&amp;amp; $3 ~ /\.hs/ { print $3 } &#39;)&#34;&#xA;&#xA;echo &#34;files to format $filesToFormat&#34;&#xA;for sourceFilePath in $filesToFormat&#xA;do&#xA;  ormolu --command ormolu --mode inplace &#34;$(pwd)/$sourceFilePath&#34;&#xA;  git add $sourceFilePath&#xA;done;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Implementing backends&lt;/h2&gt; &#xA;&lt;p&gt;For our implementation of backends, we use and recommend using the &lt;a href=&#34;https://jaspervdj.be/posts/2018-03-08-handle-pattern.html#the-module-layout&#34;&gt;Handle design pattern&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>