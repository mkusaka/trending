<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-09T01:34:26Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ed-o-saurus/PLHaskell</title>
    <updated>2022-10-09T01:34:26Z</updated>
    <id>tag:github.com,2022-10-09:/ed-o-saurus/PLHaskell</id>
    <link href="https://github.com/ed-o-saurus/PLHaskell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Haskell extension for PostgreSQL that allows embedded Haskell code.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PL/Haskell&lt;/h1&gt; &#xA;&lt;p&gt;This project is a &#34;procedural language&#34; extension of PostgreSQL allowing the execution of code in Haskell within SQL code. Despite the name, Haskell is, of course, not a procedural language as it is a functional language. However, &#34;procedural language&#34; is the term that PostgreSQL uses to describe languages that can be embedded in its SQL code.&lt;/p&gt; &#xA;&lt;p&gt;The extension allows users, even unprivileged ones, to write, install, and run functions written in Haskell.&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (C) 2022 Edward F. Behn, Jr.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.&lt;/p&gt; &#xA;&lt;p&gt;You should have received a copy of the GNU General Public License along with this program. If not, see &lt;a href=&#34;https://www.gnu.org/licenses/&#34;&gt;https://www.gnu.org/licenses/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;I wrote the project mostly for my own amusement and as a challenge. If you have any questions, comments, or issues, or if you find the project interesting or useful, please don&#39;t hesitate to contact me at &lt;a href=&#34;mailto:ed@behn.us&#34;&gt;ed@behn.us&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;p&gt;This document assumes that the reader is familiar with PostgreSQL (specifically procedural languages) and with the Haskell language.&lt;/p&gt; &#xA;&lt;h2&gt;Build and Install&lt;/h2&gt; &#xA;&lt;p&gt;This extension is intended to be build and installed in a Linux environment. It has only been tested on the x86-64 architecture.&lt;/p&gt; &#xA;&lt;p&gt;The following are needed to build and install PL/Haskell:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;PostgreSQL server&lt;/li&gt; &#xA; &lt;li&gt;PostgreSQL development files&lt;/li&gt; &#xA; &lt;li&gt;Glasgow Haskell Compiler (GHC)&lt;/li&gt; &#xA; &lt;li&gt;The GHC Hint development module&lt;/li&gt; &#xA; &lt;li&gt;libpq-devel&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Build&lt;/h3&gt; &#xA;&lt;p&gt;Ensure that &lt;code&gt;pg_config&lt;/code&gt; is available in the path. Run &lt;code&gt;make&lt;/code&gt; to build all the files needed for the extension.&lt;/p&gt; &#xA;&lt;h3&gt;Install&lt;/h3&gt; &#xA;&lt;p&gt;You must be &lt;code&gt;root&lt;/code&gt; to install the extension. As root, run &lt;code&gt;install.sh&lt;/code&gt; from the root directory.&lt;/p&gt; &#xA;&lt;p&gt;In each database that you wish to have the extension, run the SQL command &lt;code&gt;CREATE EXTENSION plhaskell;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Uninstall&lt;/h3&gt; &#xA;&lt;p&gt;Run the SQL command &lt;code&gt;DROP EXTENSION plhaskell;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As root, run &lt;code&gt;uninstall.sh&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Testing&lt;/h3&gt; &#xA;&lt;p&gt;A test battery is provided in the &lt;code&gt;tests.sql&lt;/code&gt; file in the root directory. It can be run with the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;psql -f tests.sql&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If successful, it will terminate with the notice &lt;code&gt;All tests passed&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Room for Improvement&lt;/h3&gt; &#xA;&lt;p&gt;The Makefile, install and uninstall scripts should probably be replaced by a cabal or stack script. Unfortunately, I&#39;m not familiar with either of them. If you see room for improvement or have a complete rewrite, drop me a note.&lt;/p&gt; &#xA;&lt;h2&gt;Trust&lt;/h2&gt; &#xA;&lt;p&gt;PL/Haskell is a &#34;trusted&#34; language. The PostgreSQL manual explains:&lt;/p&gt; &#xA;&lt;blockquote&gt;&#xA;  The optional key word TRUSTED specifies that the language does not grant access to data that the user would not otherwise have. Trusted languages are designed for ordinary database users (those without superuser privilege) and allows them to safely create functions and procedures. &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;As such, unprivileged users are permitted to write and execute functions without the possibility that they will be able to access information or resources that are not allowed to access. This is accomplished by enforcing Haskell&#39;s strong type system.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Functions in PL/Haskell are created the same manner as other PostgreSQL functions. The code must be valid Haskell. It must import the &lt;code&gt;PGm&lt;/code&gt; monad type from the &lt;code&gt;PGutils&lt;/code&gt; module.&lt;/p&gt; &#xA;&lt;p&gt;The code must contain a function with the same name as the PostgreSQL function. Each of its arguments must be of the type &lt;code&gt;Maybe &lt;/code&gt;&lt;em&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/em&gt; where &lt;em&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/em&gt; is the Haskell type as determined by the PostgreSQL type as indicated by the following table.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;PostgreSQL Type&lt;/th&gt; &#xA;   &lt;th&gt;Module&lt;/th&gt; &#xA;   &lt;th&gt;Haskell Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;bytea&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Data.Word&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;[Word8]&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;text&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Prelude&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;String&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;char&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Prelude&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Prelude&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;smallint&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Data.Int&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Int16&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;integer&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Data.Int&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;bigint&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Data.Int&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;real&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Prelude&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Float&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;float&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Prelude&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The function must return type &lt;code&gt;PGm (Maybe &lt;/code&gt;&lt;em&gt;&lt;code&gt;result&lt;/code&gt;&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; where &lt;em&gt;&lt;code&gt;result&lt;/code&gt;&lt;/em&gt; is the appropriate Haskell type as determined by the return type of function.&lt;/p&gt; &#xA;&lt;p&gt;In addition, functions can use composite types as arguments or return values provided that the composite types consist of elements that are listed in the table above or are themselves composite types. Composite values are represented as Haskell tuples.&lt;/p&gt; &#xA;&lt;h3&gt;Returning Sets&lt;/h3&gt; &#xA;&lt;p&gt;Functions can return sets of values by returning type &lt;code&gt;PGm [Maybe &lt;/code&gt;&lt;em&gt;&lt;code&gt;result&lt;/code&gt;&lt;/em&gt;&lt;code&gt;]&lt;/code&gt; where &lt;em&gt;&lt;code&gt;result&lt;/code&gt;&lt;/em&gt; is the appropriate Haskell type as determined by the return type of function.&lt;/p&gt; &#xA;&lt;h3&gt;Reporting Messages and Raising Error&lt;/h3&gt; &#xA;&lt;p&gt;To report a message or raise an error, use the function &lt;code&gt;report :: ErrorLevel -&amp;gt; String -&amp;gt; PGm ()&lt;/code&gt;. &lt;code&gt;ErrorLevel&lt;/code&gt; is any of the following:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Level&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;exception&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;warning&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;notice&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;info&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;log&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;debug1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;debug2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;debug3&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;debug4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;debug5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;In addition, the function &lt;code&gt;raiseError :: String -&amp;gt; a&lt;/code&gt; stops execution and raises an error.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Addition&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;CREATE FUNCTION add(int, int) RETURNS int AS&#xA;$$&#xA;    import PGutils (PGm)&#xA;    import Data.Int (Int32)&#xA;&#xA;    add :: Maybe Int32 -&amp;gt; Maybe Int32 -&amp;gt; PGm (Maybe Int32)&#xA;&#xA;    add Nothing Nothing = return Nothing&#xA;    add (Just a) (Just b) = return (Just (a+b))&#xA;    add a Nothing = return a&#xA;    add Nothing b = return b&#xA;$$&#xA;LANGUAGE plhaskell;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fibonacci Sequence&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;CREATE FUNCTION fibonacci(int) RETURNS int AS&#xA;$$&#xA;    import PGutils (PGm)&#xA;    import Data.Int (Int32)&#xA;&#xA;    fibonacci&#39; :: Int32 -&amp;gt; Int32&#xA;    fibonacci&#39; 0 = 0&#xA;    fibonacci&#39; 1 = 1&#xA;    fibonacci&#39; n = fibonacci&#39; (n-2) + fibonacci&#39; (n-1)&#xA;&#xA;    fibonacci :: Maybe Int32 -&amp;gt; PGm (Maybe Int32)&#xA;    fibonacci Nothing = return Nothing&#xA;    fibonacci (Just n) = return (Just (fibonacci&#39; n))&#xA;$$&#xA;LANGUAGE plhaskell;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Primes&lt;/h3&gt; &#xA;&lt;p&gt;This section shows how to return a set of results. The functions listed produce lists of prime numbers using the &lt;a href=&#34;https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&#34;&gt;Sieve of Eratosthenes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Composite type&lt;/h4&gt; &#xA;&lt;p&gt;The function in this section returns a set of composite results.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;CREATE TYPE n_p AS (n int, p int);&#xA;&#xA;CREATE FUNCTION primes(int) RETURNS SETOF n_p AS&#xA;$$&#xA;    import PGutils (PGm, raiseError)&#xA;    import Data.Int (Int32)&#xA;&#xA;    sieve :: [Int32] -&amp;gt; [Int32]&#xA;    sieve (p:xs) = p : sieve [x | x &amp;lt;- xs, x `mod` p /= 0]&#xA;    sieve [] = []&#xA;&#xA;    primes :: Maybe Int32 -&amp;gt; PGm [Maybe (Maybe Int32, Maybe Int32)]&#xA;    primes Nothing = raiseError &#34;Invalid Null&#34;&#xA;    primes (Just n) = return (map Just (zip [Just i | i &amp;lt;- [1..n]] (map Just (sieve [2..]))))&#xA;$$&#xA;LANGUAGE plhaskell;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By running the query&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SELECT *&#xA;FROM primes(10)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following is produced&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;n&lt;/th&gt; &#xA;   &lt;th&gt;p&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;7&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;   &lt;td&gt;11&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;6&lt;/td&gt; &#xA;   &lt;td&gt;13&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;7&lt;/td&gt; &#xA;   &lt;td&gt;17&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;8&lt;/td&gt; &#xA;   &lt;td&gt;19&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;9&lt;/td&gt; &#xA;   &lt;td&gt;23&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;10&lt;/td&gt; &#xA;   &lt;td&gt;29&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Infinite list&lt;/h4&gt; &#xA;&lt;p&gt;The following function returns a infinite list of prime numbers&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;CREATE FUNCTION primes() RETURNS SETOF int AS&#xA;$$&#xA;    import PGutils (PGm)&#xA;    import Data.Int (Int32)&#xA;&#xA;    sieve :: [Int32] -&amp;gt; [Int32]&#xA;    sieve (p:xs) = p : sieve [x | x &amp;lt;- xs, x `mod` p /= 0]&#xA;&#xA;    primes :: PGm [Maybe Int32]&#xA;    primes = return (map Just (sieve [2..]))&#xA;$$&#xA;LANGUAGE plhaskell;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To generate the first twenty-five prime numbers, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SELECT primes()&#xA;LIMIT 25&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;primes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;7&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;11&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;13&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;17&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;19&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;23&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;29&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;37&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;41&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;43&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;47&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;53&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;59&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;61&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;67&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;71&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;73&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;79&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;83&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;89&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;97&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Message&lt;/h3&gt; &#xA;&lt;p&gt;The following demonstrates how to show a notice from within a function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;CREATE FUNCTION forty_two() RETURNS int AS&#xA;$$&#xA;    import PGutils (PGm, report, notice)&#xA;    import Data.Int (Int32)&#xA;&#xA;    forty_two :: PGm (Maybe Int32)&#xA;    forty_two = do&#xA;        report notice &#34;Don&#39;t Panic&#34;&#xA;        return (Just 42)&#xA;$$&#xA;LANGUAGE plhaskell;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>input-output-hk/ekg-forward</title>
    <updated>2022-10-09T01:34:26Z</updated>
    <id>tag:github.com,2022-10-09:/input-output-hk/ekg-forward</id>
    <link href="https://github.com/input-output-hk/ekg-forward" rel="alternate"></link>
    <summary type="html">&lt;p&gt;EKG forwarding library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ekg-forward&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/input-output-hk/ekg-forward/actions&#34;&gt;&lt;img src=&#34;https://github.com/input-output-hk/ekg-forward/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;GitHub CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What Is It&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;ekg-forward&lt;/code&gt; is a library allowing to forward &lt;a href=&#34;https://hackage.haskell.org/package/ekg-core&#34;&gt;EKG system metrics&lt;/a&gt; from one process to another one.&lt;/p&gt; &#xA;&lt;h2&gt;Main Use Case&lt;/h2&gt; &#xA;&lt;p&gt;You have one Haskell application that collects its EKG system metrics (both predefined and custom) and another Haskell application that needs to receive those metrics. You can think of the first application as a Forwarder and the second one as an Acceptor.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;There is &lt;code&gt;ekg&lt;/code&gt; &lt;a href=&#34;https://hackage.haskell.org/package/ekg&#34;&gt;package&lt;/a&gt; that already lets you remotely monitor a running Haskell process over HTTP. But there are three main differences between &lt;code&gt;ekg&lt;/code&gt; and &lt;code&gt;ekg-forward&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;ekg&lt;/code&gt; provides HTTP server for monitoring, &lt;code&gt;ekg-forward&lt;/code&gt; is a lightweight library without HTTP and REST API.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ekg-forward&lt;/code&gt; is based on Haskell typed protocol, which provides type-level guarantees of correctness.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ekg-forward&lt;/code&gt;&#39;s network layer uses &lt;code&gt;ouroboros-network-framework&lt;/code&gt; &lt;a href=&#34;https://github.com/input-output-hk/ouroboros-network/&#34;&gt;package&lt;/a&gt; which supports both network sockets and local pipes for connection.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;How To Use It&lt;/h2&gt; &#xA;&lt;p&gt;You can find demo programs in the &lt;code&gt;demo&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;Please note that &lt;strong&gt;not all&lt;/strong&gt; EKG metrics are supported in the current release:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/ekg-core-0.1.1.7/docs/System-Metrics-Gauge.html&#34;&gt;Gauge&lt;/a&gt; - supported&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/ekg-core-0.1.1.7/docs/System-Metrics-Label.html&#34;&gt;Label&lt;/a&gt; - supported&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/ekg-core-0.1.1.7/docs/System-Metrics-Counter.html&#34;&gt;Counter&lt;/a&gt; - supported&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/ekg-core-0.1.1.7/docs/System-Metrics-Distribution.html&#34;&gt;Distribution&lt;/a&gt; - does &lt;strong&gt;not&lt;/strong&gt; supported&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>agda/agda2hs</title>
    <updated>2022-10-09T01:34:26Z</updated>
    <id>tag:github.com,2022-10-09:/agda/agda2hs</id>
    <link href="https://github.com/agda/agda2hs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Compiling Agda code to readable Haskell&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/agda/agda2hs/actions&#34;&gt;&lt;img src=&#34;https://github.com/agda/agda2hs/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;GitHub CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;agda2hs&lt;/h1&gt; &#xA;&lt;p&gt;Agda2hs is a tool for producing verified and readable Haskell code by extracting it from a (lightly annotated) Agda program. For example, the following Agda program encodes well-formed binary search trees:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-agda&#34;&gt;open import Haskell.Prelude&#xA;&#xA;_≤_ : {{Ord a}} → a → a → Set&#xA;x ≤ y = (x &amp;lt;= y) ≡ True&#xA;&#xA;data BST (a : Set) {{@0 _ : Ord a}} (@0 lower upper : a) : Set where&#xA;  Leaf : (@0 pf : lower ≤ upper) → BST a lower upper&#xA;  Node : (x : a) (l : BST a lower x) (r : BST a x upper) → BST a lower upper&#xA;&#xA;{-# COMPILE AGDA2HS BST #-}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;agda2hs translates this to the following Haskell datatype:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module BST where&#xA;&#xA;data BST a = Leaf&#xA;           | Node a (BST a) (BST a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Objective&lt;/h2&gt; &#xA;&lt;p&gt;The goal of this project is &lt;em&gt;not&lt;/em&gt; to translate arbitrary Agda code to Haskell. Rather it is to carve out a common sublanguage between Agda and Haskell, with a straightforward translation from the Agda side to the Haskell side. This lets you write your program in the Agda fragment, using full Agda to prove properties about it, and then translate it to nice looking readable Haskell code that you can show your Haskell colleagues without shame.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;At the moment there is no user manual yet. The best way to learn how to use agda2hs is by reading the Haskell Symposium &#39;22 paper &lt;a href=&#34;https://jesper.sikanda.be/files/reasonable-agda-is-correct-haskell.pdf&#34;&gt;Reasonable Agda is Correct Haskell: Writing Verified Haskell using agda2hs&lt;/a&gt;. You can also find examples in the &lt;code&gt;test&lt;/code&gt; directory of this repository, in particular the file &lt;a href=&#34;https://github.com/agda/agda2hs/raw/master/test/Test.agda&#34;&gt;Test.agda&lt;/a&gt;. If you have been using agda2hs and want to contribute in some way, adding documentation or examples would be very welcome.&lt;/p&gt; &#xA;&lt;h2&gt;Future work&lt;/h2&gt; &#xA;&lt;p&gt;Currently agda2hs is under active development, please take a look at the &lt;a href=&#34;https://github.com/agda/agda2hs/issues&#34;&gt;issue tracker&lt;/a&gt;. If you have a suggestion for a new feature that is not yet on the issue tracker, you are welcome to create a new issue or a PR. Feature requests should be of the form &#34;Add support for Haskell feature X&#34;, &lt;em&gt;not&lt;/em&gt; &#34;Add support for Agda feature Y&#34; (see &#34;Objective&#34; above). If you want to compile arbitrary Agda code to Haskell, you are advised to use Agda&#39;s built-in GHC backend instead.&lt;/p&gt;</summary>
  </entry>
</feed>