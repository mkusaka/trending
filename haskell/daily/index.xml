<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-30T01:38:54Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jhickner/minions</title>
    <updated>2022-09-30T01:38:54Z</updated>
    <id>tag:github.com,2022-09-30:/jhickner/minions</id>
    <link href="https://github.com/jhickner/minions" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fast parallel ssh tool written in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Minions&lt;/h1&gt; &#xA;&lt;p&gt;Minions is a fast parallel SSH tool written in haskell. It uses haskell&#39;s concurrent channel abstraction to return results quickly and incrementally.&lt;/p&gt; &#xA;&lt;h3&gt;Usage:&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;minions [-ts] &amp;lt;file with list of hostnames&amp;gt; &amp;lt;ssh command to run&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ minions list_of_hostnames.txt uname&#xA;host1 (0.37s)&#xA;Darwin&#xA;&#xA;host2 (1.2s)&#xA;Darwin&#xA;&#xA;host3 (1.3s)&#xA;Darwin&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;s also a small mode that prints the results in a compact format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ minions -s list_of_hostsnames.txt uname&#xA;host1: Darwin&#xA;host2: Darwin&#xA;host3: Darwin&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;First install ghc via your system&#39;s package manager. On OSX it&#39;s as simple as:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;brew install haskell-platform&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;then install minions with:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cabal install minions&lt;/code&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ucsd-progsys/elsa</title>
    <updated>2022-09-30T01:38:54Z</updated>
    <id>tag:github.com,2022-09-30:/ucsd-progsys/elsa</id>
    <link href="https://github.com/ucsd-progsys/elsa" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Elsa is a lambda calculus evaluator&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ELSA&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;elsa&lt;/code&gt; is a tiny language designed to build intuition about how the Lambda Calculus, or more generally, &lt;em&gt;computation-by-substitution&lt;/em&gt; works. Rather than the usual interpreter that grinds lambda terms down to values, &lt;code&gt;elsa&lt;/code&gt; aims to be a light-weight &lt;em&gt;proof checker&lt;/em&gt; that determines whether, under a given sequence of definitions, a particular term &lt;em&gt;reduces to&lt;/em&gt; to another.&lt;/p&gt; &#xA;&lt;h2&gt;Online Demo&lt;/h2&gt; &#xA;&lt;p&gt;You can try &lt;code&gt;elsa&lt;/code&gt; online at &lt;a href=&#34;http://goto.ucsd.edu/elsa/index.html&#34;&gt;this link&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;You can locally build and run &lt;code&gt;elsa&lt;/code&gt; by&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Installing &lt;a href=&#34;https://www.haskellstack.org&#34;&gt;stack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Cloning this repo&lt;/li&gt; &#xA; &lt;li&gt;Building &lt;code&gt;elsa&lt;/code&gt; with &lt;code&gt;stack&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;That is, to say&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -sSL https://get.haskellstack.org/ | sh&#xA;$ git clone https://github.com/ucsd-progsys/elsa.git&#xA;$ cd elsa&#xA;$ stack install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Editor Plugins&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mistzzt/vscode-elsa-lang&#34;&gt;VSCode&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/glapa-grossklag/elsa.vim&#34;&gt;Vim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;elsa&lt;/code&gt; programs look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- id_0.lc&#xA;let id   = \x -&amp;gt; x&#xA;let zero = \f x -&amp;gt; x&#xA;&#xA;eval id_zero :&#xA;  id zero&#xA;  =d&amp;gt; (\x -&amp;gt; x) (\f x -&amp;gt; x)   -- expand definitions&#xA;  =a&amp;gt; (\z -&amp;gt; z) (\f x -&amp;gt; x)   -- alpha rename&#xA;  =b&amp;gt; (\f x -&amp;gt; x)             -- beta reduce&#xA;  =d&amp;gt; zero                    -- expand definitions&#xA;&#xA;eval id_zero_tr :&#xA;  id zero  &#xA;  =*&amp;gt; zero                    -- transitive reductions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you run &lt;code&gt;elsa&lt;/code&gt; on the above, you should get the following output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ elsa ex1.lc&#xA;&#xA;OK id_zero, id_zero_tr.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Partial Evaluation&lt;/h2&gt; &#xA;&lt;p&gt;If instead you write a partial sequence of reductions, i.e. where the &lt;em&gt;last&lt;/em&gt; term can still be further reduced:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- succ_1_bad.lc&#xA;let one  = \f x -&amp;gt; f x&#xA;let two  = \f x -&amp;gt; f (f x)&#xA;let incr = \n f x -&amp;gt; f (n f x)&#xA;&#xA;eval succ_one :&#xA;  incr one&#xA;  =d&amp;gt; (\n f x -&amp;gt; f (n f x)) (\f x -&amp;gt; f x)&#xA;  =b&amp;gt; \f x -&amp;gt; f ((\f x -&amp;gt; f x) f x)&#xA;  =b&amp;gt; \f x -&amp;gt; f ((\x -&amp;gt; f x) x)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then &lt;code&gt;elsa&lt;/code&gt; will complain that&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ elsa ex2.lc&#xA;&#xA;ex2.lc:11:7-30: succ_one can be further reduced&#xA;&#xA;  11  |   =b&amp;gt; \f x -&amp;gt; f ((\x -&amp;gt; f x) x)&#xA;              ^^^^^^^^^^^^^^^^^^^^^^^^^&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can &lt;em&gt;fix&lt;/em&gt; the error by completing the reduction&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- succ_1.lc&#xA;let one  = \f x -&amp;gt; f x&#xA;let two  = \f x -&amp;gt; f (f x)&#xA;let incr = \n f x -&amp;gt; f (n f x)&#xA;&#xA;eval succ_one :&#xA;  incr one&#xA;  =d&amp;gt; (\n f x -&amp;gt; f (n f x)) (\f x -&amp;gt; f x)&#xA;  =b&amp;gt; \f x -&amp;gt; f ((\f x -&amp;gt; f x) f x)&#xA;  =b&amp;gt; \f x -&amp;gt; f ((\x -&amp;gt; f x) x)&#xA;  =b&amp;gt; \f x -&amp;gt; f (f x)                 -- beta-reduce the above&#xA;  =d&amp;gt; two                             -- optional&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, &lt;code&gt;elsa&lt;/code&gt; rejects the following program,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- id_0_bad.lc&#xA;let id   = \x -&amp;gt; x&#xA;let zero = \f x -&amp;gt; x&#xA;&#xA;eval id_zero :&#xA;  id zero&#xA;  =b&amp;gt; (\f x -&amp;gt; x)&#xA;  =d&amp;gt; zero&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;with the error&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ elsa ex4.lc&#xA;&#xA;ex4.lc:7:5-20: id_zero has an invalid beta-reduction&#xA;&#xA;   7  |   =b&amp;gt; (\f x -&amp;gt; x)&#xA;          ^^^^^^^^^^^^^^^&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can fix the error by inserting the appropriate intermediate term as shown in &lt;code&gt;id_0.lc&lt;/code&gt; above.&lt;/p&gt; &#xA;&lt;h2&gt;Syntax of &lt;code&gt;elsa&lt;/code&gt; Programs&lt;/h2&gt; &#xA;&lt;p&gt;An &lt;code&gt;elsa&lt;/code&gt; program has the form&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- definitions&#xA;[let &amp;lt;id&amp;gt; = &amp;lt;term&amp;gt;]+&#xA;&#xA;-- reductions&#xA;[&amp;lt;reduction&amp;gt;]*&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where the basic elements are lambda-calulus &lt;code&gt;term&lt;/code&gt;s&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;lt;term&amp;gt; ::=  &amp;lt;id&amp;gt;&#xA;          \ &amp;lt;id&amp;gt;+ -&amp;gt; &amp;lt;term&amp;gt;&#xA;            (&amp;lt;term&amp;gt; &amp;lt;term&amp;gt;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and &lt;code&gt;id&lt;/code&gt; are lower-case identifiers&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;id&amp;gt;   ::= x, y, z, ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;&amp;lt;reduction&amp;gt;&lt;/code&gt; is a sequence of &lt;code&gt;term&lt;/code&gt;s chained together with a &lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;lt;reduction&amp;gt; ::= eval &amp;lt;id&amp;gt; : &amp;lt;term&amp;gt; (&amp;lt;step&amp;gt; &amp;lt;term&amp;gt;)*&#xA;&#xA;&amp;lt;step&amp;gt;      ::= =a&amp;gt;   -- alpha equivalence&#xA;                =b&amp;gt;   -- beta  equivalence&#xA;                =d&amp;gt;   -- def   equivalence&#xA;                =*&amp;gt;   -- trans equivalence&#xA;                =~&amp;gt;   -- normalizes to&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Semantics of &lt;code&gt;elsa&lt;/code&gt; programs&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;code&gt;reduction&lt;/code&gt; of the form &lt;code&gt;t_1 s_1 t_2 s_2 ... t_n&lt;/code&gt; is &lt;strong&gt;valid&lt;/strong&gt; if&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Each &lt;code&gt;t_i s_i t_i+1&lt;/code&gt; is &lt;strong&gt;valid&lt;/strong&gt;, and&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;t_n&lt;/code&gt; is in normal form (i.e. cannot be further beta-reduced.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Furthermore, a &lt;code&gt;step&lt;/code&gt; of the form&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;t =a&amp;gt; t&#39;&lt;/code&gt; is valid if &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;t&#39;&lt;/code&gt; are equivalent up to &lt;strong&gt;alpha-renaming&lt;/strong&gt;,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;t =b&amp;gt; t&#39;&lt;/code&gt; is valid if &lt;code&gt;t&lt;/code&gt; &lt;strong&gt;beta-reduces&lt;/strong&gt; to &lt;code&gt;t&#39;&lt;/code&gt; in a single step,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;t =d&amp;gt; t&#39;&lt;/code&gt; is valid if &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;t&#39;&lt;/code&gt; are identical after &lt;strong&gt;let-expansion&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;t =*&amp;gt; t&#39;&lt;/code&gt; is valid if &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;t&#39;&lt;/code&gt; are in the reflexive, transitive closure of the union of the above three relations.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;t =~&amp;gt; t&#39;&lt;/code&gt; is valid if &lt;code&gt;t&lt;/code&gt; &lt;a href=&#34;http://dl.acm.org/citation.cfm?id=860276&#34;&gt;normalizes to&lt;/a&gt; &lt;code&gt;t&#39;&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(Due to Michael Borkowski)&lt;/p&gt; &#xA;&lt;p&gt;The difference between &lt;code&gt;=*&amp;gt;&lt;/code&gt; and &lt;code&gt;=~&amp;gt;&lt;/code&gt; is as follows.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;t =*&amp;gt; t&#39;&lt;/code&gt; is &lt;em&gt;any&lt;/em&gt; sequence of zero or more steps from &lt;code&gt;t&lt;/code&gt; to &lt;code&gt;t&#39;&lt;/code&gt;. So if you are working forwards from the start, backwards from the end, or a combination of both, you could use &lt;code&gt;=*&amp;gt;&lt;/code&gt; as a quick check to see if you&#39;re on the right track.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;t =~&amp;gt; t&#39;&lt;/code&gt; says that &lt;code&gt;t&lt;/code&gt; reduces to &lt;code&gt;t&#39;&lt;/code&gt; in zero or more steps &lt;strong&gt;and&lt;/strong&gt; that &lt;code&gt;t&#39;&lt;/code&gt; is in &lt;strong&gt;normal form&lt;/strong&gt; (i.e. &lt;code&gt;t&#39;&lt;/code&gt; cannot be reduced further). This means you can only place it as the &lt;em&gt;final step&lt;/em&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;So &lt;code&gt;elsa&lt;/code&gt; would accept these three&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;eval ex1:&#xA;  (\x y -&amp;gt; x y) (\x -&amp;gt; x) b &#xA;  =*&amp;gt; b&#xA;&#xA;eval ex2:&#xA;  (\x y -&amp;gt; x y) (\x -&amp;gt; x) b &#xA;  =~&amp;gt; b&#xA;&#xA;eval ex3:&#xA;  (\x y -&amp;gt; x y) (\x -&amp;gt; x) (\z -&amp;gt; z) &#xA;  =*&amp;gt; (\x -&amp;gt; x) (\z -&amp;gt; z) &#xA;  =b&amp;gt; (\z -&amp;gt; z)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but &lt;code&gt;elsa&lt;/code&gt; would &lt;em&gt;not&lt;/em&gt; accept&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;eval ex3:&#xA;  (\x y -&amp;gt; x y) (\x -&amp;gt; x) (\z -&amp;gt; z) &#xA;  =~&amp;gt; (\x -&amp;gt; x) (\z -&amp;gt; z) &#xA;  =b&amp;gt; (\z -&amp;gt; z)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;because the right hand side of &lt;code&gt;=~&amp;gt;&lt;/code&gt; can still be reduced further.&lt;/p&gt;</summary>
  </entry>
</feed>