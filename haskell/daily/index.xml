<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-08T01:36:31Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kadena-io/pact</title>
    <updated>2023-02-08T01:36:31Z</updated>
    <id>tag:github.com,2023-02-08:/kadena-io/pact</id>
    <link href="https://github.com/kadena-io/pact" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Pact Smart Contract Language&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://i.imgur.com/bAZFAGF.png&#34; width=&#34;450&#34; height=&#34;243&#34; alt=&#34;Kadena&#34; title=&#34;Kadena&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp;&lt;/p&gt; &#xA;&lt;h1&gt;The Pact Programming Language&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/kadena-io/pact&#34;&gt;&lt;img src=&#34;https://travis-ci.org/kadena-io/pact.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://kadena.io/build&#34;&gt;Pact&lt;/a&gt; is an open-source, Turing-&lt;strong&gt;in&lt;/strong&gt;complete smart contract language that has been purpose-built with blockchains first in mind. Pact focuses on facilitating transactional logic with the optimal mix of functionality in authorization, data management, and workflow.&lt;/p&gt; &#xA;&lt;p&gt;Read the whitepaper:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://d31d887a-c1e0-47c2-aa51-c69f9f998b07.filesusr.com/ugd/86a16f_442a542b64554cb2a4c1ae7f528ce4c3.pdf&#34;&gt;The Pact Smart Contract Language&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For additional information, press, and development inquiries, please refer to the Kadena &lt;a href=&#34;https://kadena.io&#34;&gt;website&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Table Of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#tutorials&#34;&gt;Tutorials&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#quickstart&#34;&gt;Quickstart&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#installing-pact&#34;&gt;Installing Pact&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#binary-distributions&#34;&gt;Binary Distributions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#instructions-for-mac-users&#34;&gt;Instructions for Mac users&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#instructions-for-linux-users&#34;&gt;Instructions for Linux users&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#building-from-source&#34;&gt;Building from Source&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#verifying-installation&#34;&gt;Verifying Installation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#supported-editors&#34;&gt;Supported Editors&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#chainweaver&#34;&gt;Chainweaver&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#in-browser&#34;&gt;In Browser&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#atom&#34;&gt;Atom&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#vs-code&#34;&gt;VS Code&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#emacs&#34;&gt;Emacs&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#vim&#34;&gt;Vim&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#the-pact-rest-api&#34;&gt;The Pact REST Api&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#api-documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#rest-api-server&#34;&gt;Pact REST Api Server&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#related-projects&#34;&gt;Related Projects&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Tutorials&lt;/h2&gt; &#xA;&lt;p&gt;Extensive tutorials on every facet of the Pact language may be found &lt;a href=&#34;https://docs.kadena.io/learn-pact/intro&#34;&gt;on docs.kadena.io&lt;/a&gt;. Additionally, users may find example scripts in Kadena&#39;s &lt;a href=&#34;https://github.com/kadena-io/pact-examples&#34;&gt;pact-examples&lt;/a&gt; repository, in the &lt;a href=&#34;https://github.com/kadena-io/pact/tree/master/examples&#34;&gt;examples&lt;/a&gt; directory, and in production as part of the &lt;a href=&#34;https://github.com/kadena-io/chainweb-node/&#34;&gt;Kadena Public Blockchain&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The Pact language specification, API documentation, features, motivations, and in-depth tutorial content may be found &lt;a href=&#34;http://pact-language.readthedocs.io&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Documentation is always in flux, and corrections to out of date documentation are always appreciated. Feel free to do so if you find such an error by opening an &lt;a href=&#34;https://github.com/kadena-io/pact/issues&#34;&gt;issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;The easiest and quickest way to try Pact is &lt;a href=&#34;http://pact.kadena.io&#34;&gt;in the browser&lt;/a&gt;, or via the Chainweaver &lt;a href=&#34;https://github.com/kadena-io/chainweaver&#34;&gt;wallet&lt;/a&gt;. Both environments support error and warning highlighting, as well as an in-app REPL environment for you to test out your code immediately. The Kadena docs also include a &lt;a href=&#34;https://docs.kadena.io/basics/quickstart&#34;&gt;developer quickstart&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installing Pact&lt;/h2&gt; &#xA;&lt;h3&gt;Binary Distributions&lt;/h3&gt; &#xA;&lt;p&gt;Pact can be installed via binary distribution for Linux or Mac by following the instructions below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://github.com/Z3Prover/z3/wiki&#34;&gt;z3&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Download the &lt;a href=&#34;https://github.com/kadena-io/pact/releases&#34;&gt;prebuilt binaries&lt;/a&gt; for either Linux or Mac, depending on your OS.&lt;/li&gt; &#xA; &lt;li&gt;Once you&#39;ve downloaded the binary, make sure that it is marked as executable by running &lt;code&gt;chmod +x &amp;lt;executable-file&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Put the binary somewhere in your PATH.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Once you have Pact in your path, proceed to validating your installation by trying out &lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#verifying-installation&#34;&gt;the repl&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Instructions for Mac Users&lt;/h3&gt; &#xA;&lt;h4&gt;Using Brew&lt;/h4&gt; &#xA;&lt;p&gt;On Mac, the easiest way to install pact is with Homebrew. Make sure that Homebrew has been installed in your machine. Instructions for how to install it can be found &lt;a href=&#34;https://brew.sh&#34;&gt;here&lt;/a&gt;. Once Homebrew is installed, run the following command to install pact:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew update&#xA;brew install kadena-io/pact/pact&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to install from source, see &lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#building-from-source&#34;&gt;building from source&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Instructions for Linux Users&lt;/h3&gt; &#xA;&lt;p&gt;Linux is supported in terms of both the binary distributions (see below) and building from source. For installing &lt;code&gt;pact&lt;/code&gt; on Linux distributions in the Arch family, refer to &lt;a href=&#34;https://aur.archlinux.org/packages/pact/&#34;&gt;this package on the AUR&lt;/a&gt;. Otherwise, please refer to &lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/#building-from-source&#34;&gt;building from source&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Building from Source&lt;/h3&gt; &#xA;&lt;h4&gt;Dependencies&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;(Mac only) Homebrew: &lt;code&gt;brew install git&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;(Linux/Mac) &lt;a href=&#34;https://git-scm.com/downloads&#34;&gt;Installer&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To get the code, you can go &lt;a href=&#34;https://github.com/kadena-io/pact/releases/&#34;&gt;here&lt;/a&gt;. Once you have the code, we can pick a build tool.&lt;/p&gt; &#xA;&lt;h4&gt;Building with Cabal&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.haskell.org/cabal/&#34;&gt;Cabal&lt;/a&gt; is the preferred way to manage packages by the Haskell community. You will need a version of GHC installed on your machine to use it.&lt;/p&gt; &#xA;&lt;h5&gt;Dependencies&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ghc &amp;gt;= 8.4&lt;/code&gt; (Haskell compiler) and &lt;code&gt;cabal &amp;gt;= 2.2&lt;/code&gt; (Haskell build-tool) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The easiest way to get this is to install it using (Linux/Mac) &lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;ghcup&lt;/a&gt; and issue &lt;code&gt;ghcup install 8.6.5&lt;/code&gt;, followed by &lt;code&gt;ghcup install-cabal&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;ghc may also be installed via brew, issuing &lt;code&gt;brew install ghc&lt;/code&gt; and &lt;code&gt;brew install cabal-install&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(You may also need to install &lt;code&gt;zlib&lt;/code&gt;, &lt;code&gt;z3&lt;/code&gt;, and &lt;code&gt;sqlite&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;p&gt;To build a Pact binary:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Only necessary if you haven&#39;t done this recently.&#xA;cabal v2-update&#xA;&#xA;# Build the project.&#xA;cabal v2-build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On some systems the default build might fail with linker errors complaining about cryptonite and ed25519, try:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# configure cabal &#xA;cabal v2-configure -f cryptonite-ed25519&#xA;&#xA;# Build the project.&#xA;cabal v2-build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will install a runnable version of Pact, which you can run via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cabal v2-exec pact&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, &lt;code&gt;cabal v2-install&lt;/code&gt; will install the binary to &lt;code&gt;~/.cabal/bin/&lt;/code&gt;, which you may need to add to your path. Then, you can call &lt;code&gt;pact&lt;/code&gt; as-is.&lt;/p&gt; &#xA;&lt;h4&gt;Building with Stack&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;(stack is no longer supported)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Stack is a Haskell build tool that manages compiler and dependency versions for you. It&#39;s easy to install and use.&lt;/p&gt; &#xA;&lt;h5&gt;Dependencies&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;stack &amp;gt;= 1.9&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;(Mac only) Homebrew: &lt;code&gt;brew install haskell-stack&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;(Linux/Mac) &lt;a href=&#34;https://docs.haskellstack.org/en/stable/README/&#34;&gt;Installer&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(You may also need to install &lt;code&gt;zlib&lt;/code&gt;, &lt;code&gt;z3&lt;/code&gt;, and &lt;code&gt;sqlite&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;p&gt;To build a Pact binary:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;stack build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will compile a runnable version of Pact, which you can run via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;stack exec pact&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, &lt;code&gt;stack install&lt;/code&gt; will install the binary to &lt;code&gt;~/.local/bin/&lt;/code&gt;, which you may need to add to your path. Then, you can call &lt;code&gt;pact&lt;/code&gt; as-is.&lt;/p&gt; &#xA;&lt;h4&gt;Building with Nix&lt;/h4&gt; &#xA;&lt;p&gt;The fastest way to build and run Pact is to use the Nix package manager which has binary caching capabilities that allow you to download pre-built binaries for everything needed by Pact. For detailed instructions see &lt;a href=&#34;https://github.com/kadena-io/pact/wiki/Building-Kadena-Projects&#34;&gt;our wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When the build is finished, you can run Pact with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./result/ghc/pact/bin/pact&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Verifying Installation&lt;/h3&gt; &#xA;&lt;p&gt;Test by issuing &lt;code&gt;pact&lt;/code&gt; in a terminal or by executing your binary. Try out some commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ pact&#xA;pact&amp;gt; (+ 1 2)&#xA;3&#xA;pact&amp;gt; (+ &#34;hello, &#34; &#34;world&#34;)&#xA;&#34;hello, world&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Supported Editors&lt;/h2&gt; &#xA;&lt;p&gt;Pact is supported by a variety of editors ranging from full-fledged IDE environments to syntax highlighting.&lt;/p&gt; &#xA;&lt;h3&gt;Chainweaver&lt;/h3&gt; &#xA;&lt;p&gt;The Chainweaver &lt;a href=&#34;https://github.com/kadena-io/chainweaver&#34;&gt;wallet&lt;/a&gt; is the Kadena&#39;s wallet, offering a seamless IDE experience and wallet in one. It supports a full in-app REPL, code preview, error/warning highlighting, code deployment, key generation, and integration with existing Kadena blockchains.&lt;/p&gt; &#xA;&lt;h3&gt;In-Browser&lt;/h3&gt; &#xA;&lt;p&gt;An implementation of Chainweaver exists &lt;a href=&#34;http://pact.kadena.io&#34;&gt;in the browser&lt;/a&gt;, if you do not wish to download the wallet.&lt;/p&gt; &#xA;&lt;h3&gt;Atom&lt;/h3&gt; &#xA;&lt;p&gt;For a full-fledged IDE experience, install the &lt;a href=&#34;https://atom.io&#34;&gt;Atom&lt;/a&gt; editor along with &lt;code&gt;language-pact&lt;/code&gt; using the &lt;a href=&#34;http://flight-manual.atom.io/using-atom/sections/atom-packages/&#34;&gt;atom package manager&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;VS Code&lt;/h3&gt; &#xA;&lt;p&gt;The Pact language has community support for VS Code via the &lt;a href=&#34;https://github.com/kadena-community/pact-vscode&#34;&gt;pact-vscode&lt;/a&gt; package. (&lt;a href=&#34;https://github.com/kadena-community/pact-vscode&#34;&gt;https://github.com/kadena-community/pact-vscode&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;h3&gt;Emacs&lt;/h3&gt; &#xA;&lt;p&gt;Emacs has &lt;a href=&#34;https://melpa.org/#/pact-mode&#34;&gt;&lt;code&gt;pact-mode&lt;/code&gt;&lt;/a&gt; support via MELPA, along with &lt;a href=&#34;https://melpa.org/#/flycheck-pact&#34;&gt;&lt;code&gt;flycheck-pact&lt;/code&gt;&lt;/a&gt; for on-the-fly error highlighting. Download &lt;code&gt;pact-mode&lt;/code&gt; and (optionally) &lt;code&gt;flycheck-pact&lt;/code&gt; by opening Emacs and issuing &lt;code&gt;M-x package-list-packages&lt;/code&gt;, syncing MELPA, and installing by name. Then, in your &lt;code&gt;init.el&lt;/code&gt; or &lt;code&gt;.emacs&lt;/code&gt;, include&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package pact-mode&#xA;  :ensure t&#xA;  :config&#xA;  ;; optionally&#xA;  (require &#39;flycheck-pact))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;ve chosen to include &lt;code&gt;flycheck-pact&lt;/code&gt;, you can start the interactive buffer and trace by calling &lt;code&gt;flycheck-pact-toggle-trace&lt;/code&gt; and &lt;code&gt;flycheck-pact-interactive-buffer&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Vim&lt;/h3&gt; &#xA;&lt;p&gt;If you are a &lt;a href=&#34;https://vim.org&#34;&gt;vim&lt;/a&gt; user, the &lt;a href=&#34;https://github.com/wsdjeg/vim-pact&#34;&gt;vim-pact&lt;/a&gt; plugin provides support for the pact syntax.&lt;/p&gt; &#xA;&lt;h2&gt;The Pact REST Api&lt;/h2&gt; &#xA;&lt;h3&gt;Api Documentation&lt;/h3&gt; &#xA;&lt;p&gt;The REST API is documented at &lt;a href=&#34;http://pact-language.readthedocs.io/en/latest/pact-reference.html#rest-api&#34;&gt;http://pact-language.readthedocs.io/en/latest/pact-reference.html#rest-api&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Pact REST API Server&lt;/h3&gt; &#xA;&lt;p&gt;Pact features a full REST API HTTP server and SQLite database implementation, making blockchain application development painless and easy. The Pact server simulates a single-node blockchain environment, with the same API supported by the Kadena ScalableBFT blockchain.&lt;/p&gt; &#xA;&lt;p&gt;To start the server, issue&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pact --serve CONFIG&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pact -s CONFIG&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where CONFIG is a valid &lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/config.yaml&#34;&gt;config.yaml&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Hosting static files.&lt;/h4&gt; &#xA;&lt;p&gt;The HTTP server will host any static files it finds in its working directory.&lt;/p&gt; &#xA;&lt;h4&gt;Config file format&lt;/h4&gt; &#xA;&lt;p&gt;The pact dev server (pact-serve) requires a configuration Yaml file (e.g. server.conf) to operate. The documentation for it is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;console&amp;gt; pact --serve --help&#xA;Config file is YAML format with the following properties:&#xA;port       - HTTP server port&#xA;persistDir - Directory for database files.&#xA;             If ommitted, runs in-memory only.&#xA;logDir     - Directory for HTTP logs&#xA;pragmas    - SQLite pragmas to use with persistence DBs&#xA;verbose    - [True|False] Provide extra logging information&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Replay from disk.&lt;/h4&gt; &#xA;&lt;p&gt;When running pact-serve with persistence enabled, the server automatically replays from the database &lt;code&gt;commands.sqlite&lt;/code&gt; in the persist dir. To prevent replay, simply delete this file before starting the server.&lt;/p&gt; &#xA;&lt;h3&gt;Related Projects&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://www.npmjs.com/package/pact-lang-api&#34;&gt;pact-lang-api&lt;/a&gt; &lt;code&gt;npm&lt;/code&gt; package provides a JavaScript library to aid interaction with the API.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://github.com/kadena-io/pact-todomvc&#34;&gt;pact-todomvc&lt;/a&gt; is a working demonstration.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This code is distributed under the terms of the BSD3 license. See &lt;a href=&#34;https://raw.githubusercontent.com/kadena-io/pact/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>christiaanb/SoOSiM</title>
    <updated>2023-02-08T01:36:31Z</updated>
    <id>tag:github.com,2023-02-08:/christiaanb/SoOSiM</id>
    <link href="https://github.com/christiaanb/SoOSiM" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Abstract full system simulator&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SoOSiM - Abstract Full System Simulator&lt;/h1&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download the latest Haskell Platform from: &lt;a href=&#34;http://hackage.haskell.org/platform/&#34;&gt;http://hackage.haskell.org/platform/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Execute on the command-line: &lt;code&gt;cabal update&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Execute on the command-line: &lt;code&gt;cabal install SoOSiM&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Creating OS Components&lt;/h2&gt; &#xA;&lt;p&gt;We jump straight into some code, by showing the description of the &lt;em&gt;Memory Manager&lt;/em&gt; (&lt;a href=&#34;http://www.soos-project.eu/wiki/index.php/Application_Cases#Memory_Manager&#34;&gt;http://www.soos-project.eu/wiki/index.php/Application_Cases#Memory_Manager&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;h4&gt;./examples/MemoryManager.hs&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE TypeFamilies #-}&#xA;module MemoryManager where&#xA;&#xA;import SoOSiM&#xA;&#xA;import MemoryManager.Types&#xA;import MemoryManager.Util&#xA;&#xA;memoryManager :: MemState -&amp;gt; Input MemCommand -&amp;gt; Sim MemState&#xA;memoryManager s (Message content retAddr) = do&#xA;  case content of&#xA;    (Register memorySource) -&amp;gt; do&#xA;      yield $ s {addressLookup = memorySource:(addressLookup s)}&#xA;&#xA;    (Read addr) -&amp;gt; do&#xA;      let src = checkAddress (addressLookup s) addr&#xA;      case (sourceId src) of&#xA;        Nothing -&amp;gt; do&#xA;          addrVal &amp;lt;- readMemory addr&#xA;          respond MemoryManager retAddr addrVal&#xA;          yield s&#xA;        Just remote -&amp;gt; do&#xA;          response &amp;lt;- invoke MemoryManager remote content&#xA;          respond MemoryManager retAddr response&#xA;          yield s&#xA;&#xA;    (Write addr val) -&amp;gt; do&#xA;      let src = checkAddress (addressLookup s) addr&#xA;      case (sourceId src) of&#xA;        Nothing -&amp;gt; do&#xA;          addrVal &amp;lt;- writeMemory addr val&#xA;          yield s&#xA;        Just remote -&amp;gt; do&#xA;          invokeAsync MemoryManager remote content ignore&#xA;          yield s&#xA;&#xA;memoryManager s _ = yield s&#xA;&#xA;instance ComponentInterface MemoryManager where&#xA;  type State   MemoryManager = MemState&#xA;  type Receive MemoryManager = MemCommand&#xA;  type Send    MemoryManager = Dynamic&#xA;  initState _                = (MemState [])&#xA;  componentName _            = &#34;MemoryManager&#34;&#xA;  componentBehaviour _       = memoryManager&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;./examples/MemoryManager/Types.hs&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE DeriveDataTypeable        #-}&#xA;{-# LANGUAGE ExistentialQuantification #-}&#xA;module MemoryManager.Types where&#xA;&#xA;import SoOSiM&#xA;&#xA;data MemorySource&#xA;  = MemorySource&#xA;  { baseAddress :: Int&#xA;  , scope       :: Int&#xA;  , sourceId    :: Maybe ComponentId&#xA;  }&#xA;&#xA;&#xA;data MemState =&#xA;  MemState { addressLookup :: [MemorySource]&#xA;           }&#xA;&#xA;data MemCommand = Register Int Int (Maybe ComponentId)&#xA;                | Read     Int&#xA;                | forall a . Typeable a =&amp;gt; Write Int a&#xA;  deriving Typeable&#xA;&#xA;data MemoryManager = MemoryManager&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;./examples/MemoryManager/Util.hs&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module MemoryManager.Util where&#xA;&#xA;import MemoryManager.Types&#xA;&#xA;checkAddress ::&#xA;  [MemorySource]&#xA;  -&amp;gt; Int&#xA;  -&amp;gt; MemorySource&#xA;checkAddress sources addr = case (filter containsAddr sources) of&#xA;    []    -&amp;gt; error (&#34;address unknown: &#34; ++ show addr)&#xA;    (x:_) -&amp;gt; x&#xA;  where&#xA;    containsAddr (MemorySource base sc _) = base &amp;lt;= addr &amp;amp;&amp;amp; addr &amp;lt; sc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Component definition Step-by-Step&lt;/h3&gt; &#xA;&lt;p&gt;We will now walk through the code step-by-step:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module MemoryManager where&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We start by defining the name of our Haskell module, in this case &lt;code&gt;MemoryManager&lt;/code&gt;. Make sure the name of file matches the name of the module, where haskell src files use the &lt;code&gt;.hs&lt;/code&gt; file-name extension.&lt;/p&gt; &#xA;&lt;p&gt;We continue with importing modules that we require to build our component:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import SoOSiM&#xA;&#xA;import MemoryManager.Types&#xA;import MemoryManager.Util&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;SoOSiM&lt;/code&gt; module defines all the simulator API functions. Besides the &lt;em&gt;external&lt;/em&gt; module, we also import two &lt;em&gt;local&lt;/em&gt; module called &lt;code&gt;MemoryManager.Types&lt;/code&gt; and &lt;code&gt;MemoryManager.Util&lt;/code&gt;, which we define in &lt;code&gt;./MemoryManager/Types.hs&lt;/code&gt; and &lt;code&gt;./MemoryManager/Util.hs&lt;/code&gt; respectively.&lt;/p&gt; &#xA;&lt;p&gt;We start our description with a datatype definition describing the internal state of our memory manager component, and the datatype encoding the messages our memory manager will receive:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data MemorySource&#xA;  = MemorySource&#xA;  { baseAddress :: Int&#xA;  , scope       :: Int&#xA;  , sourceId    :: Maybe ComponentId&#xA;  }&#xA;&#xA;data MemState =&#xA;  MemState { addressLookup :: [MemorySource]&#xA;           }&#xA;&#xA;data MemCommand = Register MemorySource&#xA;                | Read     Int&#xA;                | forall a . Typeable a =&amp;gt; Write Int a&#xA;  deriving Typeable&#xA;&#xA;data MemoryManager = MemoryManager&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We define two record datatypes [1]; and with three fields (&lt;code&gt;baseAddress&lt;/code&gt;, &lt;code&gt;scope&lt;/code&gt;, and &lt;code&gt;sourceId&lt;/code&gt;) and another with one field (&lt;code&gt;addressLookup&lt;/code&gt;). The first record type defines an address range (&lt;code&gt;baseAddress&lt;/code&gt; and &lt;code&gt;scope&lt;/code&gt;) and an indication which memory manager is responsible for tht memory range. The second record type, which has only one field, which defines a dynamically-sized list of &lt;code&gt;MemorySource&lt;/code&gt; elements.&lt;/p&gt; &#xA;&lt;p&gt;The third datatype is an algebraic datatype defining the kind of messages that can be send to the memory manager: registering a memory range, reading, and writing.&lt;/p&gt; &#xA;&lt;p&gt;The fourth datatype is a singleton datatype, which will act as the label/name for the interface defining our memory manager.&lt;/p&gt; &#xA;&lt;p&gt;We now start defining the actual behaviour of our memory manager, starting with its type annotation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;memoryManager :: MemState -&amp;gt; Input MemCommand -&amp;gt; Sim MemState&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The type definition tells us that the first argument has the type of our internal component state, and the second argument a value of type &lt;code&gt;Input a&lt;/code&gt;, where the &lt;code&gt;a&lt;/code&gt; is instantiate to the &lt;code&gt;MemCommand&lt;/code&gt; datatype. The possible values of the &lt;code&gt;Input a&lt;/code&gt; type are enumerated in the &lt;em&gt;OS Component API&lt;/em&gt; section. The value of the result is of type &lt;code&gt;Sim MemState&lt;/code&gt;. This tells us two things:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;memoryManager&lt;/code&gt; function is executed within the &lt;code&gt;Sim&lt;/code&gt; monad.&lt;/li&gt; &#xA; &lt;li&gt;The actual value that is returned is of type &lt;code&gt;MemState&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A &lt;em&gt;monad&lt;/em&gt; is many wonderful things [2], way too much to explain here, so for the rest of this README we see it as an execution environment. Only inside this execution environment will we have access to the SoOSiM API functions.&lt;/p&gt; &#xA;&lt;p&gt;Although we know the types of the arguments and the result of the function, we don&#39;t know their actual meaning. The SoOSiM simulator will call your component behaviour, passing as the first argument its current internal state. The second argument is an event that triggered the execution of your component: for example a message send to you by another component. The result that you must ultimately return is the, potentially updated, internal state of your component.&lt;/p&gt; &#xA;&lt;p&gt;We now turn to the first line of the actual function definition:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;memoryManager s (Message content retAddr) = do&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where &lt;code&gt;memoryManager&lt;/code&gt; is the name of the function, &lt;code&gt;s&lt;/code&gt; the first argument (of type &lt;code&gt;MemState&lt;/code&gt;). We pattern-match on the second argument, meaning this function definition clause only works for values whose constructor is &lt;code&gt;Message&lt;/code&gt;. By pattern matching we get access to the fields of the datatype, where we bind the names &lt;code&gt;content&lt;/code&gt; and &lt;code&gt;retAddr&lt;/code&gt; to the values of these fields.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;do&lt;/code&gt; &lt;em&gt;keyword&lt;/em&gt; after the &lt;code&gt;=&lt;/code&gt; sign indicates that the function executes within a monadic environment, the &lt;code&gt;Sim&lt;/code&gt; environment in our case. The semantics in a monadic environment are different from those in a normal Haskell functions. A monadic environment has a more imperative feel, in which your function definition interacts with the environment step-by-step, statement after statements. This also gives rise to the scoping rules familiar to the imperative programmer: names cannot be used before they are declared.&lt;/p&gt; &#xA;&lt;p&gt;Next we define a nested &lt;code&gt;case&lt;/code&gt;-statement that contains most of the actual behaviour of our memory manager component:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;case content of&#xA;  (Register memorySource) -&amp;gt; do&#xA;    yield $ s {addressLookup = memorySource:(addressLookup s)}&#xA;&#xA;  (Read addr) -&amp;gt; do&#xA;    let src = checkAddress (addressLookup s) addr&#xA;    case (sourceId src) of&#xA;      Nothing -&amp;gt; do&#xA;        addrVal &amp;lt;- readMemory addr&#xA;        respond MemoryManager retAddr addrVal&#xA;        yield s&#xA;      Just remote -&amp;gt; do&#xA;        response &amp;lt;- invoke MemoryManager remote content&#xA;        respond MemoryManager retAddr response&#xA;        yield s&#xA;&#xA;  (Write addr val) -&amp;gt; do&#xA;    let src = checkAddress (addressLookup s) addr&#xA;    case (sourceId src) of&#xA;      Nothing -&amp;gt; do&#xA;        addrVal &amp;lt;- writeMemory addr val&#xA;        yield s&#xA;      Just remote -&amp;gt; do&#xA;        invokeAsync MemoryManager remote content ignore&#xA;        yield s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the first alternative of our case-statement we handle a &lt;code&gt;Register&lt;/code&gt; message, by updating our address lookup table with an additional memory source. We &lt;code&gt;yield&lt;/code&gt; to the simulator with our updated internal state.&lt;/p&gt; &#xA;&lt;p&gt;In the second alternative we handle a &lt;code&gt;Read&lt;/code&gt; request. The next line in our function definition, which checks which specific memory manager is responsible for the address, is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;let src = checkAddress (addressLookup s) addr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Haskell is white-space sensitive, so make sure that you have a good editor that does automatic indenting. We use the &lt;code&gt;let&lt;/code&gt; construct to bind the expression &lt;code&gt;checkAddress (addressLookup s) addr&lt;/code&gt; to the name &lt;code&gt;src&lt;/code&gt;. We use these let-bindings to bind &lt;em&gt;pure&lt;/em&gt; expressions to names, where &lt;em&gt;pure&lt;/em&gt; means that the expression has no side-effects [3]. We can now just use the name &lt;code&gt;src&lt;/code&gt; instead of having to type &lt;code&gt;checkAddress (addressLookup s) addr&lt;/code&gt; every time. Don&#39;t worry about efficiency, the evaluation mechanics of Haskell will ensure that the actual expression is only calculated once, even when we use the &lt;code&gt;src&lt;/code&gt; name multiple times.&lt;/p&gt; &#xA;&lt;p&gt;In the next case-statement we check if the current or a remote memory manager is responsible for handling the address. In either alternative we must use the &lt;code&gt;do&lt;/code&gt; keyword again because we will be executing multiple statements. We will now finally use some of the API functions, the first we encounter is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;addrVal &amp;lt;- readMemory addr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;readMemory&lt;/code&gt; function accesses the simulator environment, retrieving the value of the memory location specified by &lt;code&gt;addr&lt;/code&gt;. We use the left-arrow &lt;code&gt;&amp;lt;-&lt;/code&gt; to indicate that this is a side-effecting expression (we are accessing the simulator environment), and that &lt;code&gt;addrVal&lt;/code&gt; is not bound to the expression itself, but the value belonging to the execution of this statement.&lt;/p&gt; &#xA;&lt;p&gt;After reading the memory, we send the value back to the module that initially requested the memory access. We send the read value as a response to the return address (&lt;code&gt;retAddr&lt;/code&gt;). Having serviced the request, we use the &lt;code&gt;yield&lt;/code&gt; function to give the (unaltered) internal state back to the simulation environment.&lt;/p&gt; &#xA;&lt;p&gt;If a remote memory manager is responsible for the address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Just remote -&amp;gt; do&#xA;  response &amp;lt;- invoke MemoryManager remote content&#xA;  respond MemoryManager retAddr response&#xA;  yield s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We then synchronously invoke the remote memory manager with the original read request, and forward the received response to the component making the original memory request.&lt;/p&gt; &#xA;&lt;p&gt;The third alternative, handling a write request, is analogous to handling a read request.&lt;/p&gt; &#xA;&lt;p&gt;In the situations which we didn&#39;t handle explicitly, such as receiving a &lt;code&gt;Tick&lt;/code&gt;, we simply disregard the simulator event, and return our unaltered internal state to the simulator.&lt;/p&gt; &#xA;&lt;h4&gt;ComponentInterface Instance&lt;/h4&gt; &#xA;&lt;p&gt;At the bottom of our &lt;code&gt;MemoryManager&lt;/code&gt; module we see the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance ComponentInterface MemoryManager where&#xA;  type State   MemoryManager = MemState&#xA;  type Receive MemoryManager = MemCommand&#xA;  type Send    MemoryManager = Dynamic&#xA;  initState _                = (MemState [])&#xA;  componentName _            = &#34;MemoryManager&#34;&#xA;  componentBehaviour _       = memoryManager&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we define a so-called type-class instance. At this moment you do not need to know what a type-class is, just that you need to define this instance if you want your component to be able to be used by the SoOSiM simulator.&lt;/p&gt; &#xA;&lt;p&gt;We use our singleton datatype, &lt;code&gt;MemoryManager&lt;/code&gt;, as the label/name for our ComponentInterface instance. All (type-)functions in this interface receive the interface label as their first argument. For the type-functions (such as &lt;code&gt;State s&lt;/code&gt;) we must explicitly mention the label, for normal function we can just use the underscore (&lt;code&gt;_&lt;/code&gt;) as a place holder.&lt;/p&gt; &#xA;&lt;p&gt;The instance must always contain the definitions for &lt;code&gt;State&lt;/code&gt;, &lt;code&gt;Receive&lt;/code&gt;, &lt;code&gt;Send&lt;/code&gt;, &lt;code&gt;initState&lt;/code&gt;, &lt;code&gt;componentName&lt;/code&gt; and &lt;code&gt;componentBehaviour&lt;/code&gt;. The &lt;code&gt;State&lt;/code&gt; indicates the datatype representing the internal state of a module. The &lt;code&gt;Receive&lt;/code&gt; indicates the datatype of messages that this component is expecting to receive. The &lt;code&gt;Send&lt;/code&gt; indicates the datatype of messages this component will send as responses to invocation. The &lt;code&gt;initState&lt;/code&gt; function returns a minimal internal state of your component. The &lt;code&gt;componentName&lt;/code&gt; is a function returning the globally unique name of your component. Finally &lt;code&gt;componentBehaviour&lt;/code&gt; is a function returning the behaviour of your component. The behaviour of your component must always have the type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(State iface) -&amp;gt; Input (Receive iface) -&amp;gt; Sim (State iface)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where &lt;code&gt;State iface&lt;/code&gt; is the datatype of your component&#39;s internal state, and &lt;code&gt;Receive iface&lt;/code&gt; is the datetype of the type of messages the component handles.&lt;/p&gt; &#xA;&lt;h2&gt;SoOSiM API&lt;/h2&gt; &#xA;&lt;h4&gt;ComponentInterface Type Class&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Type class that defines every OS component&#xA;class ComponentInterface s where&#xA;  -- | Type of messages send by the component&#xA;  type Send    s&#xA;  -- | Type of messages received by the component&#xA;  type Receive s&#xA;  -- | Type of internal state of the component&#xA;  type State   s&#xA;  -- | The minimal internal state of your component&#xA;  initState          :: s -&amp;gt; State s&#xA;  -- | A function returning the unique global name of your component&#xA;  componentName      :: s -&amp;gt; ComponentName&#xA;  -- | The function defining the behaviour of your component&#xA;  componentBehaviour :: s -&amp;gt; State s -&amp;gt; Input (Receive s) -&amp;gt; Sim (State s)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Simulator Events&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Input a&#xA;  = Message a ReturnAddress -- ^ A message send by another component: the&#xA;                            --   first field is the message content, the&#xA;                            --   second field is the address to send&#xA;                            --   responses to&#xA;  | Tick                    -- ^ Event send every simulation round&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Accessing the simulator&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Create a new component&#xA;createComponent ::&#xA;  (ComponentInterface iface, Typeable (Receive iface))&#xA;  =&amp;gt; iface&#xA;  -- ^ Component Interface&#xA;  -&amp;gt; Sim ComponentId&#xA;  -- ^ &#39;ComponentId&#39; of the created component&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Synchronously invoke another component&#xA;invoke ::&#xA;  (ComponentInterface iface, Typeable (Receive iface), Typeable (Send iface))&#xA;  =&amp;gt; iface&#xA;  -- ^ Interface type&#xA;  -&amp;gt; ComponentId&#xA;  -- ^ ComponentId of callee&#xA;  -&amp;gt; Receive iface&#xA;  -- ^ Argument&#xA;  -&amp;gt; Sim (Send iface)&#xA;  -- ^ Response from callee&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Invoke another component, handle response asynchronously&#xA;invokeAsync ::&#xA;  (ComponentInterface iface, Typeable (Receive iface), Typeable (Send iface))&#xA;  =&amp;gt; iface&#xA;  -- ^ Interface type&#xA;  -&amp;gt; ComponentId&#xA;  -- ^ ComponentId of callee&#xA;  -&amp;gt; Receive iface&#xA;  -- ^ Argument&#xA;  -&amp;gt; (Send iface -&amp;gt; Sim ())&#xA;  -- ^ Response Handler&#xA;  -&amp;gt; Sim ()&#xA;  -- ^ Call returns immediately&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Respond to an invocation&#xA;respond ::&#xA;  (ComponentInterface iface, Typeable (Send iface))&#xA;  =&amp;gt; iface&#xA;  -- ^ Interface type&#xA;  -&amp;gt; ReturnAddress&#xA;  -- ^ Return address to send response to&#xA;  -&amp;gt; (Send iface)&#xA;  -- ^ Value to send as response&#xA;  -&amp;gt; Sim ()&#xA;  -- ^ Call returns immediately&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Yield internal state to the simulator scheduler&#xA;yield ::&#xA;  a&#xA;  -&amp;gt; Sim a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Get the component id of your component&#xA;getComponentId ::&#xA;  Sim ComponentId&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Get the node id of of the node your component is currently running on&#xA;getNodeId ::&#xA;  SimM NodeId&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Create a new node&#xA;createNode ::&#xA;  Sim NodeId -- ^ NodeId of the created node&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Write memory of local node&#xA;writeMemory ::&#xA;  Typeable a&#xA;  =&amp;gt; Int&#xA;  -- ^ Address to write&#xA;  -&amp;gt; a&#xA;  -- ^ Value to write&#xA;  -&amp;gt; Sim ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Read memory of local node&#xA;readMemory ::&#xA;  Int&#xA;  -- ^ Address to read&#xA;  -&amp;gt; Sim Dynamic&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Return the component Id of the component that created the current&#xA;--   component&#xA;componentCreator ::&#xA;  Sim ComponentId&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Get the unique &#39;ComponentId&#39; of a component implementing an interface&#xA;componentLookup ::&#xA;  ComponentInterface iface&#xA;  =&amp;gt; iface&#xA;  -- ^ Interface type of the component you are looking for&#xA;  -&amp;gt; Sim (Maybe ComponentId)&#xA;  -- ^ &#39;Just&#39; &#39;ComponentID&#39; if a component is found, &#39;Nothing&#39; otherwise&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Handling &lt;code&gt;Dynamic&lt;/code&gt; Values&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- | Converts a &#39;Dynamic&#39; object back into an ordinary Haskell value of the&#xA;--   correct type.&#xA;unmarshall ::&#xA;  Typeable a&#xA;  =&amp;gt; Dynamic  -- ^ The dynamically-typed object&#xA;  -&amp;gt; a        -- ^ Returns: the value of the first argument, if it has the&#xA;              -- correct type, otherwise it gives an error.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;p&gt;[1] Here is a chapter from a book that introduces the correspondence between Haskell types and C types: &lt;a href=&#34;http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html&#34;&gt;http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;[2] Some resources that discuss monads: &lt;a href=&#34;http://book.realworldhaskell.org/read/monads.html&#34;&gt;http://book.realworldhaskell.org/read/monads.html&lt;/a&gt; and &lt;a href=&#34;http://learnyouahaskell.com/a-fistful-of-monads&#34;&gt;http://learnyouahaskell.com/a-fistful-of-monads&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;[3] A more elaborate explanation of purity can be found here: &lt;a href=&#34;http://learnyouahaskell.com/introduction#so-whats-haskell&#34;&gt;http://learnyouahaskell.com/introduction#so-whats-haskell&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>