<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-22T01:43:29Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>evincarofautumn/kitten</title>
    <updated>2022-07-22T01:43:29Z</updated>
    <id>tag:github.com,2022-07-22:/evincarofautumn/kitten</id>
    <link href="https://github.com/evincarofautumn/kitten" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A statically typed concatenative systems programming language.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Kitten Programming Language&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/kittenlang/Lobby&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/gitterHQ/gitter.png&#34; alt=&#34;Gitter chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/evincarofautumn/kitten&#34;&gt;&lt;img src=&#34;https://travis-ci.org/evincarofautumn/kitten.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Kitten&lt;/strong&gt; is a statically typed, &lt;a href=&#34;http://concatenative.org/&#34;&gt;stack-based functional programming language&lt;/a&gt; designed for simplicity, speed, and safety. This is an in-progress implementation of that language, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;An interactive console for testing code&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;An interpreter&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A native-code compiler producing static executables (incomplete)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;I need help to make Kitten a reality! If you’re interested in helping in any way, you’re more than welcome, even if you’re not experienced with Haskell or compiler development. You can look at the project for the &lt;a href=&#34;https://github.com/evincarofautumn/kitten/projects/1&#34;&gt;initial release&lt;/a&gt; to see what I’m working on, and check out the &lt;a href=&#34;https://github.com/evincarofautumn/kitten/raw/master/CONTRIBUTING.md&#34;&gt;contribution guidelines&lt;/a&gt; for suggestions on how you can help.&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Browse some &lt;a href=&#34;https://github.com/evincarofautumn/kitten/tree/master/examples&#34;&gt;examples&lt;/a&gt; to get a feel for the language&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Join the &lt;a href=&#34;https://gitter.im/kittenlang/Lobby&#34;&gt;chat room&lt;/a&gt; to ask questions&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Skim a quick &lt;a href=&#34;http://kittenlang.org/intro/&#34;&gt;intro&lt;/a&gt; on the &lt;a href=&#34;http://kittenlang.org/&#34;&gt;official site&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Read the most recent updates to the &lt;a href=&#34;https://evincarofautumn.gitbooks.io/programming-with-kitten/&#34;&gt;ebook&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Read my article introducing some interesting things about concatenative programming, &lt;a href=&#34;http://evincarofautumn.blogspot.com/2012/02/why-concatenative-programming-matters.html&#34;&gt;Why Concatenative Programming Matters&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Watch my lecture describing the theory, history, and implementation techniques of the paradigm, &lt;a href=&#34;https://www.youtube.com/watch?v=_IgqJr8jG8M&#34;&gt;Concatenative Programming: From Ivory to Metal&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building and Installing&lt;/h2&gt; &#xA;&lt;p&gt;If you’re building the compiler just to try it out or work on it, you can follow the preferred build method of using &lt;a href=&#34;https://docs.haskellstack.org/en/stable/README/&#34;&gt;Stack&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/evincarofautumn/kitten.git&#xA;cd kitten&#xA;stack setup  # only necessary on first build&#xA;stack build&#xA;&#xA;stack exec kitten&#xA;stack exec kitten -- &amp;lt;flags&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, if you want to &lt;em&gt;install&lt;/em&gt; Kitten in a standard location outside the build directory, due to a deficiency in Stack’s support for Cabal’s &lt;code&gt;data-files&lt;/code&gt; feature, it is &lt;strong&gt;not&lt;/strong&gt; recommended to use &lt;code&gt;stack install&lt;/code&gt; to install a copy of the executable, because this will not install the &lt;em&gt;common vocabulary&lt;/em&gt; &lt;code&gt;common.ktn&lt;/code&gt; containing Kitten’s standard library.&lt;/p&gt; &#xA;&lt;p&gt;There are two workarounds. One is to forgo Stack, and build and install Kitten using Cabal directly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal sandbox init&#xA;cabal install --only-dependencies&#xA;cabal install --prefix=&#34;$HOME/.local&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will correctly install the common vocab so that Kitten can find it. The preferred install location for Kitten is &lt;code&gt;~/.local&lt;/code&gt; on Unix-like systems (so the executable resides at &lt;code&gt;~/.local/bin/kitten&lt;/code&gt;) or &lt;code&gt;%APPDATA%\local&lt;/code&gt; on Windows (resp. &lt;code&gt;%APPDATA%\local\bin\kitten.exe&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The other option is to manually copy &lt;code&gt;common.ktn&lt;/code&gt; to the install directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;stack install&#xA;cp common.ktn ~/.local/bin/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It’s also recommended to add the install directory (&lt;code&gt;~/.local/bin&lt;/code&gt; or &lt;code&gt;%APPDATA\local\bin&lt;/code&gt;) to your &lt;code&gt;PATH&lt;/code&gt; so that you can invoke &lt;code&gt;kitten&lt;/code&gt; directly without a path prefix.&lt;/p&gt; &#xA;&lt;p&gt;These are the only files installed by Kitten, so to uninstall it, you only need to delete the compiler and common vocab from the install directory.&lt;/p&gt; &#xA;&lt;h2&gt;Miscellany&lt;/h2&gt; &#xA;&lt;p&gt;Kitten is distributed under the terms of the &lt;a href=&#34;https://github.com/evincarofautumn/kitten/raw/master/LICENSE.md&#34;&gt;MIT license&lt;/a&gt;. Contributors should agree to abide by the &lt;a href=&#34;https://github.com/evincarofautumn/kitten/raw/master/CODE_OF_CONDUCT.md&#34;&gt;code of conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ConferOpenSource/refurb</title>
    <updated>2022-07-22T01:43:29Z</updated>
    <id>tag:github.com,2022-07-22:/ConferOpenSource/refurb</id>
    <link href="https://github.com/ConferOpenSource/refurb" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Database maintenance tool support&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;code&gt;refurb&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Refurb is a library for building PostgreSQL database migration software. Over the course of developing a database-backed software product in a team, you&#39;ll want to make organized updates to the database&#39;s schema and data that can be automatically reproduced in other environments. Refurb implements this process for Haskell projects in a fairly straightforward way, where individual changes to the database are applied in order by Haskell actions you make and check in with your code as usual.&lt;/p&gt; &#xA;&lt;h3&gt;Quick tour&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;refurb&lt;/code&gt; is a library whose primary public interface is &lt;code&gt;Refurb.refurbMain&lt;/code&gt; and is intended to implement a command-line tool, much like &lt;code&gt;Setup.hs&lt;/code&gt; uses &lt;code&gt;defaultMain&lt;/code&gt; from Cabal (the library) to implement the build system or &lt;code&gt;test/Main.hs&lt;/code&gt; might use &lt;code&gt;hspec&lt;/code&gt;. You pass a list of &lt;code&gt;Migration&lt;/code&gt;s to &lt;code&gt;refurbMain&lt;/code&gt; along with a way to obtain the database connection parameters, and the library will take care of creating and maintaining an in-database list of applied migrations and providing a CLI for users to apply migrations, query applied migrations, and make backups.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;code&gt;Migration&lt;/code&gt; is a small structure with:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;What PostgreSQL schema to apply the migration to. All migrations are qualified by the schema they apply to and schemas are automatically created by Refurb if they don&#39;t already exist.&lt;/li&gt; &#xA; &lt;li&gt;A key to identify the migration within the schema, for example &lt;code&gt;create-first-table&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;An execution action of the type &lt;code&gt;MonadMigration m =&amp;gt; m ()&lt;/code&gt; which is invoked to apply the actual change, e.g. issue some &lt;code&gt;create table&lt;/code&gt; statements.&lt;/li&gt; &#xA; &lt;li&gt;An optional check action of the type &lt;code&gt;MonadMigration m =&amp;gt; Maybe (m ())&lt;/code&gt; which is invokved prior to the execution action to check preconditions. It can signal errors (much as the execution action can) to abort the migration from being executed and is present purely to help you organize your code. It&#39;s run just like the execution action is, if present.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A working example is located in the &lt;code&gt;example/&lt;/code&gt; directory. It&#39;s not a complete worked example project, as in a normal project you&#39;d have your own product code as well as the migration related code presented in the example.&lt;/p&gt; &#xA;&lt;h3&gt;Using refurb in your project&lt;/h3&gt; &#xA;&lt;p&gt;While &lt;code&gt;example/&lt;/code&gt; contains a working example of refurb, it doesn&#39;t reflect totally how you might use it in your own project. Project organization is in the end up to you and who you work with of course, but here&#39;s how we arrange our projects with Refurb:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;package.yaml&lt;/code&gt; - &lt;a href=&#34;https://github.com/sol/hpack&#34;&gt;hpack&lt;/a&gt; file which generates &lt;code&gt;myawesomeserver.cabal&lt;/code&gt;. If you&#39;re not familiar with hpack, it&#39;s not required. It&#39;s just a nicer way to generate cabal files than by hand.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;myawesomeserver.cabal&lt;/code&gt; - generated by hpack and contains: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A library section with sources in &lt;code&gt;src/&lt;/code&gt; (&lt;code&gt;hs-source-dirs: src&lt;/code&gt; in cabal terms). &lt;code&gt;src&lt;/code&gt; contains all the primary code of your product.&lt;/li&gt; &#xA;   &lt;li&gt;An executable section &lt;code&gt;myawesomeserver-exe&lt;/code&gt; with sources in &lt;code&gt;app/server/&lt;/code&gt; that depends on the &lt;code&gt;myawesomeserver&lt;/code&gt; library. This executable launches your main product (presumably a server). This launch expects that the database has already been migrated and doesn&#39;t use refurb directly.&lt;/li&gt; &#xA;   &lt;li&gt;An executable section &lt;code&gt;myawesomeserver-refurb&lt;/code&gt; with sources in &lt;code&gt;app/refurb/&lt;/code&gt; that depends on the &lt;code&gt;myawesomeserver&lt;/code&gt; and &lt;code&gt;refurb&lt;/code&gt; libraries. This executable runs refurb for your project.&lt;/li&gt; &#xA;   &lt;li&gt;One or more other test suites or executable sections. At Confer, we have another executable which makes starting and stopping a development environment with PostgreSQL easy, for example.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;app/server/Main.hs&lt;/code&gt; - main entry point to your server. Usually just calls something in the &lt;code&gt;myawesomeserver&lt;/code&gt; library.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;app/refurb/Main.hs&lt;/code&gt; - entry point for refurb. Usually just calls &lt;code&gt;refurbMain&lt;/code&gt; with your list of migrations. Those migrations could be in &lt;code&gt;app/refurb/&lt;/code&gt; or in your main &lt;code&gt;src/&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/&lt;/code&gt; - directory with your main product source files.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;With this arrangement a build produces both &lt;code&gt;myawesomeserver-exe&lt;/code&gt; and &lt;code&gt;myawesomeserver-refurb&lt;/code&gt;. Make sure to run &lt;code&gt;myawesomeserver-refurb migrate --execute&lt;/code&gt; before running &lt;code&gt;myawesomeserver-exe&lt;/code&gt; so the database gets migrated before the server tries to start.&lt;/p&gt; &#xA;&lt;h3&gt;Invoking a refurb executable&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;refurb&lt;/code&gt; implements a CLI to query what migrations have been applied to a database, query what would happen prior to actually migrating, and migrating. It&#39;s broken into several subcommands which perform different maintenance functions. There are also a few top-level switches:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Available options:&#xA;  -h,--help                Show this help text&#xA;  -d,--debug               Turn on debug diagnostic logging&#xA;  --no-color               disable ANSI colorization&#xA;  -c,--config SERVER-CONFIG&#xA;                           Path to server config file to read database&#xA;                           connection information from&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-h&lt;/code&gt; / &lt;code&gt;--help&lt;/code&gt; shows that help output.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-d&lt;/code&gt; / &lt;code&gt;--debug&lt;/code&gt; turns on extra execution logging. Note that all log messages produced by a migration action are always captured, even with this switch off. This merely controls the console output.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--no-color&lt;/code&gt; suppresses ANSI colorization, e.g. for CI builds.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-c&lt;/code&gt; / &lt;code&gt;--config&lt;/code&gt; tells &lt;code&gt;refurb&lt;/code&gt; where to find the server&#39;s config file. &lt;code&gt;refurb&lt;/code&gt; itself doesn&#39;t care about the file contents, it just passes the config file path off to the function given to &lt;code&gt;refurbMain&lt;/code&gt; to get the database connection information back.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;show-log&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;myawesomeserver-refurb -c configfile show-log&lt;/code&gt; shows a complete list of migrations known about and applied to the database. It displays a table similar to the following though with glorious ANSI coloration unless you suppress it with &lt;code&gt;--no-color&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ID     Timestamp           Duration        Result  Key&#xA;1      2017-04-03 15:27:17 5 milliseconds  success example.create-first-table&#xA;       not applied                                 example.populate-first-table (seed data)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each column is probably self-explanatory, but:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ID&lt;/code&gt; is the primary key in the &lt;code&gt;refurb.migration-log&lt;/code&gt;. If this column is populated, it means that the corresponding migration was applied at some point for better or worse.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Timestamp&lt;/code&gt; is the time and date (in UTC) when the migration was applied to the database. Shows &lt;code&gt;not applied&lt;/code&gt; if the migration hasn&#39;t been applied.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Duration&lt;/code&gt; is how long the migration took to execute when it was applied. If empty, it means the migration hasn&#39;t been applied.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Result&lt;/code&gt; indicates whether the migration application succeeded or failed. If empty, it means the migration hasn&#39;t been applied.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Key&lt;/code&gt; shows the qualified (that is, with schema) key of the migration along with a parenthetical note for seed data migrations.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;&lt;code&gt;show-migration&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;myawesomeserver-refurb -c configfile show-migration example.create-first-table&lt;/code&gt; shows the status of and log from the application of &lt;code&gt;example.create-first-table&lt;/code&gt;. Naturally, if the migration has never been applied then no log will be available.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ID     Timestamp           Duration        Result  Key&#xA;1      2017-04-03 15:27:17 5 milliseconds  success example.create-first-table&#xA;&#xA;2017-04-03 15:27:17.780579 [LevelDebug] create sequence first_table_seq @(refurb-0.2.0.0-eWyEcrirqVIapweij3svH:Refurb.MigrationUtils src/Refurb/MigrationUtils.hs:98:3)&#xA;2017-04-03 15:27:17.782271 [LevelDebug] create table first_table (id int not null primary key default nextval(&#39;first_table_seq&#39;), t text not null) @(refurb-0.2.0.0-eWyEcrirqVIapweij3svH:Refurb.MigrationUtils src/Refurb/MigrationUtils.hs:98:3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;backup&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;myawesomeserver-refurb -c configfile backup path/to/backupfile&lt;/code&gt; creates a compressed binary database backup using &lt;code&gt;pg_dump&lt;/code&gt; which can be restored with &lt;code&gt;pg_restore&lt;/code&gt;. You can also trigger a backup automatically before migration with the &lt;code&gt;-b path/to/backupfile&lt;/code&gt; switch to &lt;code&gt;migrate&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;migrate&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;myawesomeserver-refurb -c configfile migrate&lt;/code&gt; is the main purpose of &lt;code&gt;refurb&lt;/code&gt; - applying migrations to a database. If given no additional options it will consult the database and known migration list and display a list of migrations that would be executed. As a safety measure those migrations do not actually get executed unless you confirm that you want your database altered with &lt;code&gt;-e&lt;/code&gt; / &lt;code&gt;--execute&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By default the list of migrations to apply will be only the schema migrations and not seed data migrations (see next section for more); in a development or QA environment where you want seed data, pass &lt;code&gt;-s&lt;/code&gt; / &lt;code&gt;--seed&lt;/code&gt; to see what migrations including seed data migrations would be applied and pass &lt;code&gt;-s -e&lt;/code&gt; / &lt;code&gt;--seed --execute&lt;/code&gt; to actually apply them.&lt;/p&gt; &#xA;&lt;p&gt;You can additionally request that the database be backed up prior to migration using &lt;code&gt;-b&lt;/code&gt; / &lt;code&gt;--backup&lt;/code&gt; and passing the path where you want the backup file created.&lt;/p&gt; &#xA;&lt;h3&gt;Migration types&lt;/h3&gt; &#xA;&lt;p&gt;Migrations come in two flavors: &lt;code&gt;schemaMigration&lt;/code&gt; and &lt;code&gt;seedDataMigration&lt;/code&gt;. The former type are run everywhere, while the second type are only run when requested with &lt;code&gt;--seed&lt;/code&gt; and the &lt;code&gt;refurb.config&lt;/code&gt; table doesn&#39;t have the &lt;code&gt;prod_system&lt;/code&gt; flag set. The two types are intended to help with a common workflow, where in development and QA environments it&#39;s helpful to have seed data installed in your database, e.g. test users and configuration. Conversely seed data should never make its way into production, especially when installing that seed data might be destructive.&lt;/p&gt; &#xA;&lt;p&gt;Other than when they run, both types are equivalent in functionality.&lt;/p&gt; &#xA;&lt;p&gt;As an extra check to make it hard to accidentally apply seed data migrations to production systems, &lt;code&gt;refurb&lt;/code&gt; will flatly refuse to run any seed data migrations when the &lt;code&gt;prod_system&lt;/code&gt; boolean is true in &lt;code&gt;refurb.config&lt;/code&gt;. It&#39;s not possible to set this boolean via the &lt;code&gt;refurb&lt;/code&gt; CLI, so just &lt;code&gt;update refurb.config set prod_system = &#39;t&#39;&lt;/code&gt; to set it.&lt;/p&gt; &#xA;&lt;h3&gt;Migration actions&lt;/h3&gt; &#xA;&lt;p&gt;Migration actions are Haskell actions of the type &lt;code&gt;MonadMigration m =&amp;gt; m ()&lt;/code&gt;. &lt;code&gt;MonadMigration&lt;/code&gt; is defined this way (with &lt;code&gt;ConstraintKinds&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type MonadMigration m =&#xA;  ( MonadBaseControl IO m       -- access to underlying IO&#xA;  , MonadMask m                 -- can use bracket and friends&#xA;  , MonadReader PG.Connection m -- can ask for a connection to the DB&#xA;  , MonadLogger m               -- can log using monad-logger&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The database connection is of type &lt;code&gt;PG.Connection&lt;/code&gt; with &lt;code&gt;PG&lt;/code&gt; being &lt;code&gt;Database.PostgreSQL.Simple&lt;/code&gt; from &lt;a href=&#34;https://github.com/lpsmith/postgresql-simple&#34;&gt;&lt;code&gt;postgresql-simple&lt;/code&gt;&lt;/a&gt;. So at its most basic a migration action could use that connection straightforwardly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;executeMyMigration :: MonadMigration m =&amp;gt; m ()&#xA;executeMyMigration = do&#xA;  conn &amp;lt;- ask&#xA;  rowsAffected &amp;lt;- PG.execute_ conn &#34;create table foo (bar text)&#34;&#xA;  $logInfo &#34;created foo!&#34;&#xA;  pure ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Though this can be simplified as &lt;code&gt;refurb&lt;/code&gt; provides several shorthands and utilities for writing migrations. They&#39;re located in the &lt;code&gt;Refurb.MigrationUtils&lt;/code&gt; module and re-exported by &lt;code&gt;Refurb&lt;/code&gt;. The previous example could be shortened to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;executeMyMigration :: MonadMigration m =&amp;gt; m ()&#xA;executeMyMigration =&#xA;  void $ execute_ &#34;create table foo (bar text)&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;execute_&lt;/code&gt; being a helper which asks for the database connection and runs some query against it, logging that query at debug level.&lt;/p&gt; &#xA;&lt;h4&gt;Migration action helpers&lt;/h4&gt; &#xA;&lt;p&gt;These helpers are all located in &lt;code&gt;Refurb.MigrationUtils&lt;/code&gt;, so go there for more details.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;execute&lt;/code&gt; / &lt;code&gt;execute_&lt;/code&gt; executes a single SQL statement which doesn&#39;t produce table output. The &lt;code&gt;_&lt;/code&gt; version takes a literal query, while the non-&lt;code&gt;_&lt;/code&gt; version takes a parameterized query along with parameters to substitute in. See &lt;code&gt;qqSql&lt;/code&gt; below for a helper quasiquote which makes embedding a multiline SQL statement more pleasant.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;executeMany&lt;/code&gt; / &lt;code&gt;executeSeries_&lt;/code&gt; execute a series of SQL statements which don&#39;t produce table output. The &lt;code&gt;_&lt;/code&gt; version takes a literal query, while the non-&lt;code&gt;_&lt;/code&gt; version takes a parameterized query along with parameters to substitute in. See &lt;code&gt;qqSqls&lt;/code&gt; below for a helper quasiquote which makes embedding multiple statement SQL scripts more pleasant.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;query&lt;/code&gt; / &lt;code&gt;query_&lt;/code&gt; executes a SQL query and return the results as a list using &lt;code&gt;postgresql-simple&lt;/code&gt;&#39;s &lt;code&gt;FromRow&lt;/code&gt; machinery. The &lt;code&gt;_&lt;/code&gt; version takes a literal query, while the non-&lt;code&gt;_&lt;/code&gt; version takes a parameterized query along with parameters to substitute in.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;runQuery&lt;/code&gt; executes an &lt;a href=&#34;https://github.com/tomjaguarpaw/haskell-opaleye&#34;&gt;Opaleye&lt;/a&gt; &lt;code&gt;Query&lt;/code&gt;. &lt;code&gt;refurb&lt;/code&gt; internally uses Opaleye to manage its storage tables, so this comes at no extra cost in dependency terms.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;runInsertMany&lt;/code&gt; inserts a series of rows into a table using Opaleye.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;runUpdate&lt;/code&gt; updates rows in a table using Opaleye.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;runDelete&lt;/code&gt; deletes rows from a table using Opaleye.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;doesSchemaExist&lt;/code&gt; checks if a schema exists or not using &lt;code&gt;information_schema&lt;/code&gt;. Note that this is not typically required as &lt;code&gt;refurb&lt;/code&gt; automatically creates schemas for you if they don&#39;t already exist.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;doesTableExist&lt;/code&gt; check if a table exists or not in a given schema using &lt;code&gt;information_schema&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;SQL embedding quasiquotes&lt;/h4&gt; &#xA;&lt;p&gt;Writing SQL as string literals can get very tedious as Haskell doesn&#39;t have a separate multiline string literal syntax and instead relies on &lt;code&gt;\&lt;/code&gt; to elide the newlines. To make embedding SQL queries in code easier, &lt;code&gt;refurb&lt;/code&gt; provides two quasiquotes: &lt;code&gt;qqSql&lt;/code&gt; and &lt;code&gt;qqSqls&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;qqSql&lt;/code&gt; is essentially a multiline string literal and &lt;code&gt;[qqSql|foo|]&lt;/code&gt; is equivalent to &lt;code&gt;&#34;foo&#34; :: PG.Query&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;qqSqls&lt;/code&gt; is more complicated and intended for use with &lt;code&gt;executeSeries_&lt;/code&gt;. It implements a simplistic version of the &lt;code&gt;;&lt;/code&gt; delimited syntax common in SQL REPLs and yields a &lt;code&gt;[Query]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;queries :: [PG.Query]&#xA;queries =&#xA;  [qqSqls|&#xA;    create sequence stuff_seq;&#xA;    create table stuff&#xA;      ( id bigint not null primary key default nextval(&#39;stuff_seq&#39;)&#xA;      );&#xA;    |]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is equivalent to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;queries =&#xA;  [ &#34;create sequence stuff_seq\n&#34;&#xA;  , &#34;create table stuff\n( id bigint not null primary key default nextval(&#39;stuff_seq&#39;)\n)\n&#34;&#xA;  ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As mentioned, it only implements a simplistic &lt;code&gt;;&lt;/code&gt; delimited syntax. It separates statements whenever a &lt;code&gt;;&lt;/code&gt; occurs at the beginning or end of line after stripping whitespace. Thus if you have a literal &lt;code&gt;;&lt;/code&gt; don&#39;t put it at beginning or end of line, and conversely don&#39;t have more than one statement per line.&lt;/p&gt; &#xA;&lt;h3&gt;Migration logs and output&lt;/h3&gt; &#xA;&lt;p&gt;Migrations usually produce log entries as they execute, e.g. with the DDL statements they execute. This output is copied to the console output as the migrations run if the log message is at info or higher, or if &lt;code&gt;-d&lt;/code&gt; / &lt;code&gt;--debug&lt;/code&gt; is given when running &lt;code&gt;migrate --execute&lt;/code&gt;. This output (including debug messages) is also captured and stored in the &lt;code&gt;refurb.migration_log&lt;/code&gt; table for later perusal using &lt;code&gt;show-migration&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Failed migrations&lt;/h3&gt; &#xA;&lt;p&gt;Presently if a migration fails refurb will store a record of it along with the logs from the failing migration and will never try to apply that migration again because there&#39;s no general safe way to untangle what the migration might have done before it failed. The intended pattern is that if a migration fails, you figure out what went wrong and untangle it and then either update the existing &lt;code&gt;refurb.migration_log&lt;/code&gt; to be marked successful, or remove the record and rerun the migration.&lt;/p&gt; &#xA;&lt;p&gt;Failure of a migration is currently done by using either &lt;code&gt;fail&lt;/code&gt; or throwing an exception from the migration execution or check action.&lt;/p&gt; &#xA;&lt;p&gt;Future improvements to the handling of failed migrations might be implemented, and suggestions are welcome.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;refurb&lt;/code&gt; schema&lt;/h3&gt; &#xA;&lt;p&gt;Refurb maintains its own schema to keep track of applied migrations, both for informational purposes and to determine which known migrations (i.e. those given to &lt;code&gt;refurbMain&lt;/code&gt;) have not yet been applied and need execution.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;refurb&lt;/code&gt; schema contains two tables: &lt;code&gt;migration_log&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt;. &lt;code&gt;migration_log&lt;/code&gt; contains a record for each migration applied.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;config&lt;/code&gt; has only one column presently, &lt;code&gt;prod_system&lt;/code&gt;. &lt;code&gt;prod_system&lt;/code&gt; is a boolean whose only effect is to disable the application of seed data migrations (when &lt;code&gt;t&lt;/code&gt;rue).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;migration_log&lt;/code&gt; has several columns:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;id&lt;/code&gt; - primary key, serially assigned.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;qualified_key&lt;/code&gt; - the migration&#39;s key qualified by its schema in &lt;code&gt;schema.key&lt;/code&gt; form, e.g. &lt;code&gt;example.create-first-table&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;applied&lt;/code&gt; - timestamp when the migration was applied.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;output&lt;/code&gt; - the log output of the migration application.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;result&lt;/code&gt; - either &lt;code&gt;success&lt;/code&gt; or &lt;code&gt;failure&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;duration&lt;/code&gt; - number of (fractional) seconds the migration took to execute.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Long term maintenance&lt;/h3&gt; &#xA;&lt;p&gt;One issue with using Haskell migration actions is that over time the migrations for a previous version might use types which no longer exist or have different definitions and thus not compile or do the wrong thing. It&#39;s up to you to decide what works best for your project. If you use mostly &lt;code&gt;execute&lt;/code&gt; style migrations with embedded SQL there might not be a problem. Alternatively, you could keep old versions of data structures around for migrations to use, or comment out old migrations between releases and rely on running previous releases&#39; migrations.&lt;/p&gt; &#xA;&lt;p&gt;Suggestions and contributions welcome to assist with various strategies here.&lt;/p&gt; &#xA;&lt;h2&gt;Maturity&lt;/h2&gt; &#xA;&lt;p&gt;As of writing, we use this library in our Haskell project which employs a database and have had no major issues. We have not yet released to production and have not gone through a series of releases, so improvements in the long term use might still be due. We&#39;d appreciate any fixes, improvements, or experience reports.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions and feedback welcome! File and issue or make a PR.&lt;/p&gt; &#xA;&lt;h2&gt;Chat&lt;/h2&gt; &#xA;&lt;p&gt;Asa (@asa) and Ross (@dridus) lurk on &lt;a href=&#34;https://fpchat.com&#34;&gt;fpchat&lt;/a&gt;. You can also reach us at &lt;code&gt;oss@confer.health&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ocharles/libsystemd-journal</title>
    <updated>2022-07-22T01:43:29Z</updated>
    <id>tag:github.com,2022-07-22:/ocharles/libsystemd-journal</id>
    <link href="https://github.com/ocharles/libsystemd-journal" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell bindings to libsystemd-journal&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>