<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-31T01:36:57Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cdupont/Timeloop</title>
    <updated>2023-05-31T01:36:57Z</updated>
    <id>tag:github.com,2023-05-31:/cdupont/Timeloop</id>
    <link href="https://github.com/cdupont/Timeloop" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;TimeLoop&lt;/h1&gt; &#xA;&lt;p&gt;This is a demonstrator for studying time travel in a simple setting. The application will generate and display all the possible trajectories in a universe, in presence of time travel. See this &lt;a href=&#34;https://www.corentindupont.info/blog/posts/Cosmology/2022-04-04-TimeTravel2.html&#34;&gt;series of blog posts&lt;/a&gt; for more explainations.&lt;/p&gt; &#xA;&lt;h1&gt;Install&lt;/h1&gt; &#xA;&lt;p&gt;run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cabal install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Launch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;timetravel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;How to play&lt;/h1&gt; &#xA;&lt;p&gt;You start by setting up the universe, and then running the simulation. In the picture bellow, there is an &#34;emitter&#34; arrow on the left and two time portals: an entry portal, and an exit portal.&lt;br&gt; The emitter will emit a &#34;walker&#34;, here at time step 0. The walkers always walk straight, except when they collides with another walker. When a walker collide with another walker, they always turn right (as a rule). If the walker enters the entry portal at the right time, it will walk out of the exit portal at the mentioned time.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cdupont/Timeloop/main/img/start.png&#34; alt=&#34;start&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can move the various elements of the universe (emitters and portals), setup their activation time, and add more of them (see the instructions).&lt;br&gt; &lt;strong&gt;When you are ready, hit Enter.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cdupont/Timeloop/main/img/whole.gif&#34; alt=&#34;whole&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In this universe setup, there are 2 possible trajectories for the walker:&lt;br&gt; The first solution is simple: he just goes straight. At step 6, he will walk over the exit portal (this has no effects).&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cdupont/Timeloop/main/img/sol1.gif&#34; alt=&#34;sol1&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;However, there is another solution!&lt;br&gt; At the start of the simulation (highlighted as step 0), another walker appears in the exit portal: it&#39;s you from the future! Both goes straight some steps, meeting in the middle. Then, as per the rule on collisions, both turn right. The initial walker enters the portal at step 6, thus closing the loop. The second walker continues toward the top.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cdupont/Timeloop/main/img/sol2.gif&#34; alt=&#34;sol2&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can play around with different universe setups, and generate interresting configurations such as paradoxes, &#34;Djinns&#34; and more. You can load examples using the number keys.&lt;br&gt; Have fun!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>stefanmuenchow/npuzzle</title>
    <updated>2023-05-31T01:36:57Z</updated>
    <id>tag:github.com,2023-05-31:/stefanmuenchow/npuzzle</id>
    <link href="https://github.com/stefanmuenchow/npuzzle" rel="alternate"></link>
    <summary type="html">&lt;p&gt;NPuzzle solver implemented in Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;N-Puzzle in Haskell&lt;/h1&gt; &#xA;&lt;p&gt;Zurzeit bereite ich mich auf eine Prüfung vor, in der es unter anderem um Suchverfahren gehen wird. Nachdem ich die verschiedenen Algorithmen gelernt hatte, dachte ich mir, dass es vielleicht interessant wäre, mal einen von ihnen zu kodieren. Und da ich die Programmiersprache Haskell genial finde, aber leider viel zu selten dazu komme sie zu benutzen, habe ich das ganze mit Haskell getan. Das Ergebnis ist ein kleines Programm, welches ein n-Puzzle mithilfe des A*-Algorithmus löst. Als Heuristik benutze ich die Summe aller Manhattan-Abstände der Plättchen zu der Position des jewiligen Plättchens im Zielzustand. Diese Heuristik ist zulässig, das bedeutet sie überschätzt die Restkosten nie. Würde sie das nämlich tun, so könnte es passieren, dass der Algorithmus während des Suchens an der optimalen Lösung vorbeiläuft, da diese scheinbar zu “teuer” ist. Nur wenn die Heuristik zulässig ist, wird auch die optimale Lösung gefunden. In meiner Implementierung sind nur quadratische n-Puzzle erlaubt.&lt;/p&gt; &#xA;&lt;p&gt;Bei der Auswahl der Start- und Zielzustände ist ein bisschen Vorsicht geboten: Das Programm findet für alle lösbaren Puzzle den kürzesten Weg. Allerdings gibt es Puzzle, die unlösbar sind. Wenn ihr eine Kombination von Start- und Zielzustand wählt, die nicht lösbar ist, so wird das Programm solange laufen, bis es alle möglichen Zustände ausprobiert hat und das kann eine ganze Weile dauern.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>fullstack-development/greenfield-hs</title>
    <updated>2023-05-31T01:36:57Z</updated>
    <id>tag:github.com,2023-05-31:/fullstack-development/greenfield-hs</id>
    <link href="https://github.com/fullstack-development/greenfield-hs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Greenfield Haskell Tools&lt;/h1&gt; &#xA;&lt;p&gt;Greenfield client CLI tool written in Haskell.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;You will need &lt;code&gt;stack&lt;/code&gt; tools in order to build binaries from source. &lt;a href=&#34;https://www.haskell.org/ghcup/&#34;&gt;GHCUP&lt;/a&gt; is recommended for easy install.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;stack build&#xA;stack run greenfield-hs-cli-exe -- -h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should see the following output if all done correctly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Greenfield Haskell CLI&#xA;&#xA;Usage: greenfield-hs-cli-exe [--version] [--numeric-version] [--no-input]&#xA;                             --host ARG --rpcAddr ARG --chainId ARG&#xA;                             --passwordFile ARG (-c|--config ARG)&#xA;                             (-k|--keystore ARG) COMMAND&#xA;                             [--colour | --no-colour]&#xA;&#xA;  CLI tool for making request to greenfield&#xA;&#xA;Available options:&#xA;  -h,--help                Show this help text&#xA;  --version                Show application version&#xA;  --numeric-version        Show only numeric application version&#xA;  --no-input               Enter the terminal in non-interactive mode&#xA;  --host ARG               host name of request&#xA;  --rpcAddr ARG            greenfield chain client rpc address&#xA;  --chainId ARG            greenfield chainId&#xA;  --passwordFile ARG       password file for encrypting and decoding the private&#xA;                           key&#xA;  -c,--config ARG          Load configuration from `FILE`&#xA;  -k,--keystore ARG        key file path&#xA;  --colour                 Always output colours&#xA;  --no-colour              Never output colours&#xA;&#xA;Available commands:&#xA;  payment                  Support the payment operation functions&#xA;  bucket                   Support the bucket operation functions&#xA;  object                   Support the object operation functions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;secp256k1&lt;/h2&gt; &#xA;&lt;p&gt;Some components of this project use the &lt;code&gt;secp256k1&lt;/code&gt; cryptographic library, which needs to be present during compilation.&lt;/p&gt; &#xA;&lt;p&gt;On Linux, it can be installed through a system&#39;s package manager, for example, on Ubuntu:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt update&#xA;sudo apt install libsecp256k1-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Reference&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bnb-chain/greenfield-cmd&#34;&gt;Greenfield GO cmd&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>