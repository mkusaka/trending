<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-07-28T01:33:19Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>haskell/vector</title>
    <updated>2025-07-28T01:33:19Z</updated>
    <id>tag:github.com,2025-07-28:/haskell/vector</id>
    <link href="https://github.com/haskell/vector" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An efficient implementation of Int-indexed arrays (both mutable and immutable), with a powerful loop optimisation framework .&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The &lt;code&gt;vector&lt;/code&gt; package &lt;a href=&#34;https://github.com/haskell/vector/actions?query=branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/haskell/vector/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Vector is a collection of efficient &lt;code&gt;Int&lt;/code&gt;-indexed array implementations: &lt;a href=&#34;https://raw.githubusercontent.com/haskell/vector/master/#vectors-available-in-the-package&#34;&gt;boxed, unboxed, storable, and primitive vectors&lt;/a&gt; (all can be mutable or immutable). The package features a generic API, polymorphic in vector type, and implements &lt;a href=&#34;https://raw.githubusercontent.com/haskell/vector/master/#stream-fusion&#34;&gt;&lt;em&gt;stream fusion&lt;/em&gt;&lt;/a&gt;, a powerful optimisation framework that can help eliminate intermediate data structures.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;!-- no toc --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/vector/master/#tutorial&#34;&gt;Tutorial&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/vector/master/#vector-vs-array&#34;&gt;Vector vs Array&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/vector/master/#vectors-available-in-the-package&#34;&gt;Vectors Available in the Package&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/haskell/vector/master/#stream-fusion&#34;&gt;Stream Fusion&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Tutorial&lt;/h2&gt; &#xA;&lt;p&gt;A beginner-friendly tutorial for vectors can be found on &lt;a href=&#34;https://mmhaskell.com/data-structures/vector&#34;&gt;MMHaskell&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you have already started your adventure with vectors, the tutorial on &lt;a href=&#34;https://wiki.haskell.org/Numeric_Haskell:_A_Vector_Tutorial&#34;&gt;Haskell Wiki&lt;/a&gt; covers more ground.&lt;/p&gt; &#xA;&lt;h2&gt;Vector vs Array&lt;/h2&gt; &#xA;&lt;p&gt;Arrays are data structures that can store a multitude of elements and allow immediate access to every one of them. However, they are often seen as legacy constructs that are rarely used in modern Haskell. Even though Haskell has a built-in &lt;a href=&#34;https://hackage.haskell.org/package/array-0.5.7.0&#34;&gt;Data.Array module&lt;/a&gt;, arrays might be a bit overwhelming to use due to their complex API. Conversely, vectors incorporate the array’s &lt;em&gt;O(1)&lt;/em&gt; access to elements with a much friendlier API of lists. Since they allow for framework optimisation via loop fusion, vectors emphasise efficiency and keep a rich interface. Unless you’re confident with arrays, it’s well-advised to use vectors when looking for a similar functionality.&lt;/p&gt; &#xA;&lt;h2&gt;Vectors Available in the Package&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lazy boxed vectors&lt;/strong&gt; (&lt;code&gt;Data.Vector&lt;/code&gt;) store each of their elements as a pointer to a heap-allocated value. Because of indirection, lazy boxed vectors are slower in comparison to unboxed vectors.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Strict boxed vectors&lt;/strong&gt; (&lt;code&gt;Data.Vector.Strict&lt;/code&gt;) contain elements that are &lt;a href=&#34;https://tech.fpcomplete.com/haskell/tutorial/all-about-strictness/&#34;&gt;strictly evaluated&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Unboxed vectors&lt;/strong&gt; (&lt;code&gt;Data.Vector.Unboxed&lt;/code&gt;) determine an array&#39;s representation from its elements&#39; type. For example, vector of primitive types (e.g. &lt;code&gt;Int&lt;/code&gt;) will be backed by primitive array while vector of product types by structure of arrays. They are quite efficient due to the unboxed representation they use.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Storable vectors&lt;/strong&gt; (&lt;code&gt;Data.Vector.Storable&lt;/code&gt;) are backed by pinned memory, i.e., they cannot be moved by the garbage collector. Their primary use case is C FFI.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Primitive vectors&lt;/strong&gt; (&lt;code&gt;Data.Vector.Primitive&lt;/code&gt;) are backed by simple byte array and can store only data types that are represented in memory as a sequence of bytes without a pointer, i.e., they belong to the &lt;code&gt;Prim&lt;/code&gt; type class, e.g., &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, etc. It&#39;s advised to use unboxed vectors if you&#39;re looking for the performance of primitive vectors, but more versality.&lt;/p&gt; &#xA;&lt;h2&gt;Stream Fusion&lt;/h2&gt; &#xA;&lt;p&gt;An optimisation framework used by vectors, stream fusion is a technique that merges several functions into one and prevents creation of intermediate data structures. For example, the expression &lt;code&gt;sum . filter g . map f&lt;/code&gt; won&#39;t allocate temporary vectors if compiled with optimisations.&lt;/p&gt;</summary>
  </entry>
</feed>