<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-08T01:44:39Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mvoidex/carma-models</title>
    <updated>2022-07-08T01:44:39Z</updated>
    <id>tag:github.com,2022-07-08:/mvoidex/carma-models</id>
    <link href="https://github.com/mvoidex/carma-models" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;carma-models&lt;/h1&gt; &#xA;&lt;p&gt;Define model as ADT, where every member is &#34;Field&#34;, then make instance. Such model can be serialized into JSON, Redis Map and Postgresql row.&lt;/p&gt; &#xA;&lt;pre&gt;&#xA;data My k = My {&#xA;    myInt :: Field k Int,&#xA;    myString :: Field k String }&#xA;        deriving (Generic)&#xA;&#xA;instance Model My where&#xA;    modelTable _ = &#34;mytbl&#34;&#xA;&lt;/pre&gt; &#xA;&lt;p&gt;Object of model &lt;code&gt;My&lt;/code&gt;: each field is value of its type, &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; in example&lt;/p&gt; &#xA;&lt;pre&gt;&#xA;test :: My Object&#xA;test = My 10 &#34;Hello!&#34;&#xA;&lt;/pre&gt; &#xA;&lt;p&gt;Patch: each field is of type &lt;code&gt;OptField&lt;/code&gt;, where &lt;code&gt;Has&lt;/code&gt; means, that field will be updated. &lt;code&gt;testp&lt;/code&gt; is patch, which will update &lt;code&gt;String&lt;/code&gt; field:&lt;/p&gt; &#xA;&lt;pre&gt;&#xA;testp :: My Patch&#xA;testp = My HasNo (Has &#34;World!&#34;)&#xA;&lt;/pre&gt; &#xA;&lt;p&gt;Usage:&lt;/p&gt; &#xA;&lt;pre&gt;&#xA;main :: IO ()&#xA;main = do&#xA;    either (const $ return ()) C8.putStrLn $ encodeJSON test&#xA;    -- {&#34;myInt&#34;:10,&#34;myString&#34;:&#34;Hello!&#34;}&#xA;    either (const $ return ()) C8.putStrLn $ encodeJSON testp&#xA;    -- {&#34;myString&#34;:&#34;World!&#34;}&#xA;    either (const $ return ()) print $ encodeRedis test&#xA;    -- fromList [(&#34;myInt&#34;,&#34;10&#34;),(&#34;myString&#34;,&#34;\&#34;Hello!\&#34;&#34;)]&#xA;    either (const $ return ()) print $ encodeRedis testp&#xA;    -- fromList [(&#34;myString&#34;,&#34;\&#34;World!\&#34;&#34;)]&#xA;    con &amp;lt;- connect testcon&#xA;    create con (Table :: Table (My Object))&#xA;    insert con (My 0 &#34;hello&#34; :: My Object)&#xA;    update_ con (My HasNo (Has &#34;new&#34;) :: My Patch) &#34; where myint = 0&#34;&#xA;    v &amp;lt;- select_ con &#34;&#34; :: IO [My Object]&#xA;    mapM_ (either (const $ return ()) C8.putStrLn . encodeJSON) v&#xA;    -- {&#34;myInt&#34;:0,&#34;myString&#34;:&#34;new&#34;}&#xA;    return ()&#xA;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>alexandermorozov/icfp2012-haskell</title>
    <updated>2022-07-08T01:44:39Z</updated>
    <id>tag:github.com,2022-07-08:/alexandermorozov/icfp2012-haskell</id>
    <link href="https://github.com/alexandermorozov/icfp2012-haskell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Bot for icpf2012 lifter game reimplemented in haskell&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>