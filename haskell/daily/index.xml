<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-10-26T01:30:51Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>advancedtelematic/quickcheck-state-machine</title>
    <updated>2024-10-26T01:30:51Z</updated>
    <id>tag:github.com,2024-10-26:/advancedtelematic/quickcheck-state-machine</id>
    <link href="https://github.com/advancedtelematic/quickcheck-state-machine" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Test monadic programs using state machine based models&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;quickcheck-state-machine&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/quickcheck-state-machine&#34;&gt;&lt;img src=&#34;https://img.shields.io/hackage/v/quickcheck-state-machine.svg?sanitize=true&#34; alt=&#34;Hackage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stackage.org/nightly/package/quickcheck-state-machine&#34;&gt;&lt;img src=&#34;http://stackage.org/package/quickcheck-state-machine/badge/nightly&#34; alt=&#34;Stackage Nightly&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stackage.org/lts/package/quickcheck-state-machine&#34;&gt;&lt;img src=&#34;http://stackage.org/package/quickcheck-state-machine/badge/lts&#34; alt=&#34;Stackage LTS&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/advancedtelematic/quickcheck-state-machine&#34;&gt;&lt;img src=&#34;https://api.travis-ci.org/advancedtelematic/quickcheck-state-machine.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;quickcheck-state-machine&lt;/code&gt; is a Haskell library, based on &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;QuickCheck&lt;/a&gt;, for testing stateful programs. The library is different from the &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck/docs/Test-QuickCheck-Monadic.html&#34;&gt;&lt;code&gt;Test.QuickCheck.Monadic&lt;/code&gt;&lt;/a&gt; approach in that it lets the user specify the correctness by means of a state machine based model using pre- and post-conditions. The advantage of the state machine approach is twofold: 1) specifying the correctness of your programs becomes less adhoc, and 2) you get testing for race conditions for free.&lt;/p&gt; &#xA;&lt;p&gt;The combination of state machine based model specification and property based testing first appeard in Erlang&#39;s proprietary QuickCheck. The &lt;code&gt;quickcheck-state-machine&lt;/code&gt; library can be seen as an attempt to provide similar functionality to Haskell&#39;s QuickCheck library.&lt;/p&gt; &#xA;&lt;h3&gt;Example&lt;/h3&gt; &#xA;&lt;p&gt;As a first example, let&#39;s implement and test programs using mutable references. Our implementation will be using &lt;code&gt;IORef&lt;/code&gt;s, but let&#39;s start with a representation of what actions are possible with programs using mutable references. Our mutable references can be created, read from, written to and incremented:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Command r&#xA;  = Create&#xA;  | Read      (Reference (Opaque (IORef Int)) r)&#xA;  | Write     (Reference (Opaque (IORef Int)) r) Int&#xA;  | Increment (Reference (Opaque (IORef Int)) r)&#xA;&#xA;data Response r&#xA;  = Created (Reference (Opaque (IORef Int)) r)&#xA;  | ReadValue Int&#xA;  | Written&#xA;  | Incremented&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When we generate actions we won&#39;t be able to create arbitrary &lt;code&gt;IORef&lt;/code&gt;s, that&#39;s why all uses of &lt;code&gt;IORef&lt;/code&gt;s are wrapped in &lt;code&gt;Reference _ r&lt;/code&gt;, where the parameter &lt;code&gt;r&lt;/code&gt; will let us use symbolic references while generating (and concrete ones when executing).&lt;/p&gt; &#xA;&lt;p&gt;In order to be able to show counterexamples, we need a show instance for our actions. &lt;code&gt;IORef&lt;/code&gt;s don&#39;t have a show instance, thats why we wrap them in &lt;code&gt;Opaque&lt;/code&gt;; which gives a show instance to a type that doesn&#39;t have one.&lt;/p&gt; &#xA;&lt;p&gt;Next, we give the actual implementation of our mutable references. To make things more interesting, we parametrise the semantics by a possible problem.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Bug = None | Logic | Race&#xA;  deriving Eq&#xA;&#xA;semantics :: Bug -&amp;gt; Command Concrete -&amp;gt; IO (Response Concrete)&#xA;semantics bug cmd = case cmd of&#xA;  Create        -&amp;gt; Created     &amp;lt;$&amp;gt; (reference . Opaque &amp;lt;$&amp;gt; newIORef 0)&#xA;  Read ref      -&amp;gt; ReadValue   &amp;lt;$&amp;gt; readIORef  (opaque ref)&#xA;  Write ref i   -&amp;gt; Written     &amp;lt;$  writeIORef (opaque ref) i&#39;&#xA;    where&#xA;    -- One of the problems is a bug that writes a wrong value to the&#xA;    -- reference.&#xA;      i&#39; | bug == Logic &amp;amp;&amp;amp; i `elem` [5..10] = i + 1&#xA;         | otherwise                        = i&#xA;  Increment ref -&amp;gt; do&#xA;    -- The other problem is that we introduce a possible race condition&#xA;    -- when incrementing.&#xA;    if bug == Race&#xA;    then do&#xA;      i &amp;lt;- readIORef (opaque ref)&#xA;      threadDelay =&amp;lt;&amp;lt; randomRIO (0, 5000)&#xA;      writeIORef (opaque ref) (i + 1)&#xA;    else&#xA;      atomicModifyIORef&#39; (opaque ref) (\i -&amp;gt; (i + 1, ()))&#xA;    return Incremented&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that above &lt;code&gt;r&lt;/code&gt; is instantiated to &lt;code&gt;Concrete&lt;/code&gt;, which is essentially the identity type, so while writing the semantics we have access to real &lt;code&gt;IORef&lt;/code&gt;s.&lt;/p&gt; &#xA;&lt;p&gt;We now have an implementation, the next step is to define a model for the implementation to be tested against. We&#39;ll use a simple map between references and integers as a model.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype Model r = Model [(Reference (Opaque (IORef Int)) r, Int)]&#xA;&#xA;initModel :: Model r&#xA;initModel = Model []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The pre-condition of an action specifies in what context the action is well-defined. For example, we can always create a new mutable reference, but we can only read from references that already have been created. The pre-conditions are used while generating programs (lists of actions).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;precondition :: Model Symbolic -&amp;gt; Command Symbolic -&amp;gt; Logic&#xA;precondition (Model m) cmd = case cmd of&#xA;  Create        -&amp;gt; Top&#xA;  Read  ref     -&amp;gt; ref `member` map fst m&#xA;  Write ref _   -&amp;gt; ref `member` map fst m&#xA;  Increment ref -&amp;gt; ref `member` map fst m&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The transition function explains how actions change the model. Note that the transition function is polymorphic in &lt;code&gt;r&lt;/code&gt;. The reason for this is that we use the transition function both while generating and executing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;transition :: Eq1 r =&amp;gt; Model r -&amp;gt; Command r -&amp;gt; Response r -&amp;gt; Model r&#xA;transition m@(Model model) cmd resp = case (cmd, resp) of&#xA;  (Create, Created ref)        -&amp;gt; Model ((ref, 0) : model)&#xA;  (Read _, ReadValue _)        -&amp;gt; m&#xA;  (Write ref x, Written)       -&amp;gt; Model (update ref x model)&#xA;  (Increment ref, Incremented) -&amp;gt; case lookup ref model of&#xA;    Just i  -&amp;gt; Model (update ref (succ i) model)&#xA;&#xA;update :: Eq a =&amp;gt; a -&amp;gt; b -&amp;gt; [(a, b)] -&amp;gt; [(a, b)]&#xA;update ref i m = (ref, i) : filter ((/= ref) . fst) m&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Post-conditions are checked after we executed an action and got access to the result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;postcondition :: Model Concrete -&amp;gt; Command Concrete -&amp;gt; Response Concrete -&amp;gt; Logic&#xA;postcondition (Model m) cmd resp = case (cmd, resp) of&#xA;  (Create,        Created ref) -&amp;gt; m&#39; ! ref .== 0 .// &#34;Create&#34;&#xA;    where&#xA;      Model m&#39; = transition (Model m) cmd resp&#xA;  (Read ref,      ReadValue v)  -&amp;gt; v .== m ! ref .// &#34;Read&#34;&#xA;  (Write _ref _x, Written)      -&amp;gt; Top&#xA;  (Increment _ref, Incremented) -&amp;gt; Top&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next we have to explain how to generate and shrink actions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;generator :: Model Symbolic -&amp;gt; Maybe (Gen (Command Symbolic))&#xA;generator (Model []) = Just (pure Create)&#xA;generator model      = Just $ frequency&#xA;  [ (1, pure Create)&#xA;  , (4, Read  &amp;lt;$&amp;gt; elements (map fst model))&#xA;  , (4, Write &amp;lt;$&amp;gt; elements (map fst model) &amp;lt;*&amp;gt; arbitrary)&#xA;  , (4, Increment &amp;lt;$&amp;gt; elements (domain model))&#xA;  ]&#xA;&#xA;shrinker :: Model Symbolic -&amp;gt; Command Symbolic -&amp;gt; [Command Symbolic]&#xA;shrinker _ (Write ref i) = [ Write ref i&#39; | i&#39; &amp;lt;- shrink i ]&#xA;shrinker _ _             = []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To stop the generation of new commands, e.g., when the model has reached a terminal or error state, let &lt;code&gt;generator&lt;/code&gt; return &lt;code&gt;Nothing&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Finally, we show how to mock responses given a model.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mock :: Model Symbolic -&amp;gt; Command Symbolic -&amp;gt; GenSym (Response Symbolic)&#xA;mock (Model m) cmd = case cmd of&#xA;  Create      -&amp;gt; Created   &amp;lt;$&amp;gt; genSym&#xA;  Read ref    -&amp;gt; ReadValue &amp;lt;$&amp;gt; pure (m ! ref)&#xA;  Write _ _   -&amp;gt; pure Written&#xA;  Increment _ -&amp;gt; pure Incremented&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(&lt;code&gt;mock&lt;/code&gt; is a hack to make it possible for responses to have multiple reference, and an experiment which maybe one day will let us create mocked APIs. See issue &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/issues/236&#34;&gt;#236&lt;/a&gt; for further details.)&lt;/p&gt; &#xA;&lt;p&gt;To be able to fit the code on a line we pack up all of them above into a record.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sm :: Bug -&amp;gt; StateMachine Model Command IO Response&#xA;sm bug = StateMachine initModel transition precondition postcondition&#xA;           Nothing generator shrinker (semantics bug) mock&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can now define a sequential property as follows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;prop_sequential :: Bug -&amp;gt; Property&#xA;prop_sequential bug = forAllCommands sm&#39; Nothing $ \cmds -&amp;gt; monadicIO $ do&#xA;  (hist, _model, res) &amp;lt;- runCommands sm&#39; cmds&#xA;  prettyCommands sm&#39; hist (checkCommandNames cmds (res === Ok))&#xA;    where&#xA;      sm&#39; = sm bug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we run the sequential property without introducing any problems to the semantics function, i.e. &lt;code&gt;quickCheck (prop_sequential None)&lt;/code&gt;, then the property passes. If we however introduce the logic bug problem, then it will fail with the minimal counterexample:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; quickCheck (prop_sequential Logic)&#xA;*** Failed! Falsifiable (after 12 tests and 2 shrinks):&#xA;Commands&#xA;  { unCommands =&#xA;      [ Command Create [ Var 0 ]&#xA;      , Command (Write (Reference (Symbolic (Var 0))) 5) []&#xA;      , Command (Read (Reference (Symbolic (Var 0)))) []&#xA;      ]&#xA;  }&#xA;&#xA;Model []&#xA;&#xA;   == Create ==&amp;gt; Created (Reference (Concrete Opaque)) [ 0 ]&#xA;&#xA;Model [+_×_ (Reference Opaque)&#xA;          0]&#xA;&#xA;   == Write (Reference (Concrete Opaque)) 5 ==&amp;gt; Written [ 0 ]&#xA;&#xA;Model [_×_ (Reference Opaque)&#xA;         -0&#xA;         +5]&#xA;&#xA;   == Read (Reference (Concrete Opaque)) ==&amp;gt; ReadValue 6 [ 0 ]&#xA;&#xA;Model [_×_ (Reference Opaque) 5]&#xA;&#xA;PostconditionFailed &#34;AnnotateC \&#34;Read\&#34; (PredicateC (6 :/= 5))&#34; /= Ok&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Recall that the bug problem causes the write of values &lt;code&gt;i `elem` [5..10]&lt;/code&gt; to actually write &lt;code&gt;i + 1&lt;/code&gt;. Also notice how the diff of the model is displayed between each action.&lt;/p&gt; &#xA;&lt;p&gt;Running the sequential property with the race condition problem will not uncover the race condition.&lt;/p&gt; &#xA;&lt;p&gt;If we however define a parallel property as follows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;prop_parallel :: Bug -&amp;gt; Property&#xA;prop_parallel bug = forAllParallelCommands sm&#39; $ \cmds -&amp;gt; monadicIO $ do&#xA;  prettyParallelCommands cmds =&amp;lt;&amp;lt; runParallelCommands sm&#39; cmds&#xA;    where&#xA;      sm&#39; = sm bug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And run it using the race condition problem, then we&#39;ll find the race condition:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; quickCheck (prop_parallel Race)&#xA;*** Failed! Falsifiable (after 26 tests and 6 shrinks):&#xA;ParallelCommands&#xA;  { prefix =&#xA;      Commands { unCommands = [ Command Create [ Var 0 ] ] }&#xA;  , suffixes =&#xA;      [ Pair&#xA;          { proj1 =&#xA;              Commands&#xA;                { unCommands =&#xA;                    [ Command (Increment (Reference (Symbolic (Var 0)))) []&#xA;                    , Command (Read (Reference (Symbolic (Var 0)))) []&#xA;                    ]&#xA;                }&#xA;          , proj2 =&#xA;              Commands&#xA;                { unCommands =&#xA;                    [ Command (Increment (Reference (Symbolic (Var 0)))) []&#xA;                    ]&#xA;                }&#xA;          }&#xA;      ]&#xA;  }&#xA;┌─────────────────────────────────────────────────────────────────────────────────────────────────┐&#xA;│ [Var 0] ← Create                                                                                │&#xA;│                                                         → Created (Reference (Concrete Opaque)) │&#xA;└─────────────────────────────────────────────────────────────────────────────────────────────────┘&#xA;┌──────────────────────────────────────────────┐ │&#xA;│ [] ← Increment (Reference (Concrete Opaque)) │ │&#xA;│                                              │ │ ┌──────────────────────────────────────────────┐&#xA;│                                              │ │ │ [] ← Increment (Reference (Concrete Opaque)) │&#xA;│                                              │ │ │                                → Incremented │&#xA;│                                              │ │ └──────────────────────────────────────────────┘&#xA;│                                → Incremented │ │&#xA;└──────────────────────────────────────────────┘ │&#xA;┌──────────────────────────────────────────────┐ │&#xA;│ [] ← Read (Reference (Concrete Opaque))      │ │&#xA;│                                → ReadValue 1 │ │&#xA;└──────────────────────────────────────────────┘ │&#xA;&#xA;AnnotateC &#34;Read&#34; (PredicateC (1 :/= 2))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As we can see above, a mutable reference is first created, and then in parallel (concurrently) we do two increments of said reference, and finally we read the value &lt;code&gt;1&lt;/code&gt; while the model expects &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Recall that incrementing is implemented by first reading the reference and then writing it, if two such actions are interleaved then one of the writes might end up overwriting the other one -- creating the race condition.&lt;/p&gt; &#xA;&lt;p&gt;We shall come back to this example below, but if your are impatient you can find the full source code &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/raw/master/test/MemoryReference.hs&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How it works&lt;/h3&gt; &#xA;&lt;p&gt;The rough idea is that the user of the library is asked to provide:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a datatype of actions;&lt;/li&gt; &#xA; &lt;li&gt;a datatype model;&lt;/li&gt; &#xA; &lt;li&gt;pre- and post-conditions of the actions on the model;&lt;/li&gt; &#xA; &lt;li&gt;a state transition function that given a model and an action advances the model to its next state;&lt;/li&gt; &#xA; &lt;li&gt;a way to generate and shrink actions;&lt;/li&gt; &#xA; &lt;li&gt;semantics for executing the actions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The library then gives back a bunch of combinators that let you define a sequential and a parallel property.&lt;/p&gt; &#xA;&lt;h4&gt;Sequential property&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;em&gt;sequential property&lt;/em&gt; checks if the model is consistent with respect to the semantics. The way this is done is:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;generate a list of actions;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;starting from the initial model, for each action do the the following:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;check that the pre-condition holds;&lt;/li&gt; &#xA;   &lt;li&gt;if so, execute the action using the semantics;&lt;/li&gt; &#xA;   &lt;li&gt;check if the the post-condition holds;&lt;/li&gt; &#xA;   &lt;li&gt;advance the model using the transition function.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If something goes wrong, shrink the initial list of actions and present a minimal counterexample.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Parallel property&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;em&gt;parallel property&lt;/em&gt; checks if parallel execution of the semantics can be explained in terms of the sequential model. This is useful for trying to find race conditions -- which normally can be tricky to test for. It works as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;generate a list of actions that will act as a sequential prefix for the parallel program (think of this as an initialisation bit that setups up some state);&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;generate two lists of actions that will act as parallel suffixes;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;execute the prefix sequentially;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;execute the suffixes in parallel and gather the a trace (or history) of invocations and responses of each action;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;try to find a possible sequential interleaving of action invocations and responses that respects the post-conditions.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The last step basically tries to find a &lt;a href=&#34;https://en.wikipedia.org/wiki/Linearizability&#34;&gt;linearisation&lt;/a&gt; of calls that could have happend on a single thread.&lt;/p&gt; &#xA;&lt;h3&gt;More examples&lt;/h3&gt; &#xA;&lt;p&gt;Here are some more examples to get you started:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The water jug problem from &lt;em&gt;Die Hard 3&lt;/em&gt; -- this is a simple &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/raw/master/test/DieHard.hs&#34;&gt;example&lt;/a&gt; of a specification where we use the sequential property to find a solution (counterexample) to a puzzle from an action movie. Note that this example has no meaningful semantics, we merely model-check. It might be helpful to compare the solution to the Hedgehog &lt;a href=&#34;http://clrnd.com.ar/posts/2017-04-21-the-water-jug-problem-in-hedgehog.html&#34;&gt;solution&lt;/a&gt; and the TLA+ &lt;a href=&#34;https://github.com/tlaplus/Examples/raw/master/specifications/DieHard/DieHard.tla&#34;&gt;solution&lt;/a&gt;;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The Tower of Hanoi puzzle -- this &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/raw/master/test/Hanoi.hs&#34;&gt;example&lt;/a&gt; uses property based testing in a very similar manner to the Die Hard &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/raw/master/test/DieHard.hs&#34;&gt;example&lt;/a&gt; to find a solution to the classic &lt;a href=&#34;https://en.wikipedia.org/wiki/Tower_of_Hanoi&#34;&gt;Tower of Hanoi puzzle&lt;/a&gt;;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Mutable reference &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/raw/master/test/MemoryReference.hs&#34;&gt;example&lt;/a&gt; -- this is a bigger example that shows both how the sequential property can find normal bugs, and how the parallel property can find race conditions;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Circular buffer &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/raw/master/test/CircularBuffer.hs&#34;&gt;example&lt;/a&gt; -- another example that shows how the sequential property can find help find different kind of bugs. This example is borrowed from the paper &lt;em&gt;Testing the Hard Stuff and Staying Sane&lt;/em&gt; [&lt;a href=&#34;http://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf&#34;&gt;PDF&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/watch?v=zi0rHwfiX1Q&#34;&gt;video&lt;/a&gt;]. For a more direct translation from the paper, see the following &lt;a href=&#34;https://github.com/polux/qsm-ffi-demo&#34;&gt;variant&lt;/a&gt; which uses the C FFI;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The union-find &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/raw/master/test/UnionFind.hs&#34;&gt;example&lt;/a&gt; -- an imperative implementation of the union-find algorithm. It could be useful to compare the solution to the one that appears in the paper &lt;em&gt;Testing Monadic Code with QuickCheck&lt;/em&gt; [&lt;a href=&#34;http://www.cse.chalmers.se/~rjmh/Papers/QuickCheckST.ps&#34;&gt;PS&lt;/a&gt;], which the &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck/docs/Test-QuickCheck-Monadic.html&#34;&gt;&lt;code&gt;Test.QuickCheck.Monadic&lt;/code&gt;&lt;/a&gt; module is based on;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ticket dispenser &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/raw/master/test/TicketDispenser.hs&#34;&gt;example&lt;/a&gt; -- a simple example where the parallel property is used once again to find a race condition. The semantics in this example uses a simple database file that needs to be setup and cleaned up. This example also appears in the &lt;em&gt;Testing a Database for Race Conditions with QuickCheck&lt;/em&gt; and &lt;em&gt;Testing the Hard Stuff and Staying Sane&lt;/em&gt; [&lt;a href=&#34;http://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf&#34;&gt;PDF&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/watch?v=zi0rHwfiX1Q&#34;&gt;video&lt;/a&gt;] papers;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CRUD webserver where create returns unique ids &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/raw/master/test/CrudWebserverDb.hs&#34;&gt;example&lt;/a&gt; -- create, read, update and delete users in a postgres database on a webserver using an API written using &lt;a href=&#34;https://github.com/haskell-servant/servant&#34;&gt;Servant&lt;/a&gt;. Creating a user will return a unique id, which subsequent reads, updates, and deletes need to use. In this example, unlike in the last one, the server is setup and torn down once per property rather than generate program;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Bookstore &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/raw/master/test/Bookstore.hs&#34;&gt;example&lt;/a&gt; -- another database application, that uses simple SQL queries to manage a bookstore. It is based on a &lt;a href=&#34;https://propertesting.com/book_case_study_stateful_properties_with_a_bookstore.html&#34;&gt;case study&lt;/a&gt; in Erlang from online version of Fred Hebert&#39;s &lt;a href=&#34;https://propertesting.com/toc.html&#34;&gt;PropEr Testing&lt;/a&gt; book;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Process registry &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/raw/master/test/ProcessRegistry.hs&#34;&gt;example&lt;/a&gt; -- an example often featured in the Erlang QuickCheck papers. This example shows how one can tag the specification with which requirements are covered and then generate (minimal) examples of test cases that cover each requirement, as shown in the &lt;em&gt;How well are your requirements tested?&lt;/em&gt; [&lt;a href=&#34;https://publications.lib.chalmers.se/records/fulltext/232552/local_232552.pdf&#34;&gt;PDF&lt;/a&gt;] and &lt;em&gt;Understanding Formal Specifications through Good Examples&lt;/em&gt; [&lt;a href=&#34;https://doi.org/10.1145/3239332.3242763&#34;&gt;PDF&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/watch?v=w2fin2V83e8&#34;&gt;video&lt;/a&gt;] papers.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All properties from the examples can be found in the &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/tree/master/test/Spec.hs&#34;&gt;&lt;code&gt;Spec&lt;/code&gt;&lt;/a&gt; module located in the &lt;a href=&#34;https://github.com/advancedtelematic/quickcheck-state-machine/tree/master/test&#34;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; directory. The properties from the examples get tested as part of &lt;a href=&#34;https://travis-ci.org/advancedtelematic/quickcheck-state-machine&#34;&gt;Travis CI&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To get a better feel for the examples it might be helpful to &lt;code&gt;git clone&lt;/code&gt; this repo, &lt;code&gt;cd&lt;/code&gt; into it, fire up &lt;code&gt;stack ghci --test&lt;/code&gt;, load the different examples, e.g. &lt;code&gt;:l test/CrudWebserverDb.hs&lt;/code&gt;, and run the different properties interactively.&lt;/p&gt; &#xA;&lt;h3&gt;Real world examples&lt;/h3&gt; &#xA;&lt;p&gt;More examples from the &#34;real world&#34;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;IOHK are using a state machine models in several &lt;a href=&#34;https://github.com/search?l=Haskell&amp;amp;q=org%3Ainput-output-hk+Test.StateMachine&amp;amp;type=Code&#34;&gt;places&lt;/a&gt;. For example &lt;a href=&#34;https://github.com/input-output-hk/ouroboros-network/raw/master/ouroboros-consensus/test-storage/Test/Ouroboros/Storage/FS/StateMachine.hs&#34;&gt;here&lt;/a&gt; is a test of a mock file system that they in turn use to simulate file system errors when testing a blockchain database. The following blog &lt;a href=&#34;http://www.well-typed.com/blog/2019/01/qsm-in-depth/&#34;&gt;post&lt;/a&gt; describes their tests in more detail;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Wire are using a state machine model to &lt;a href=&#34;https://github.com/wireapp/wire-server/raw/master/services/gundeck/test/unit/ThreadBudget.hs&#34;&gt;test&lt;/a&gt; the lower bound of running threads in their push notification system;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Adjoint&#39;s (now abandoned?) implementation of the Raft consensus algorithm, contains state machine &lt;a href=&#34;https://github.com/stevana/raft/raw/master/test/QuickCheckStateMachine.hs&#34;&gt;tests&lt;/a&gt; combined with fault injection (node and network failures).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;How to contribute&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;quickcheck-state-machine&lt;/code&gt; library is still very experimental.&lt;/p&gt; &#xA;&lt;p&gt;We would like to encourage users to try it out, and join the discussion of how we can improve it on the issue tracker!&lt;/p&gt; &#xA;&lt;h3&gt;See also&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The QuickCheck bugtrack &lt;a href=&#34;https://github.com/nick8325/quickcheck/issues/139&#34;&gt;issue&lt;/a&gt; -- where the initial discussion about how to add state machine based testing to QuickCheck started;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;John Hughes&#39; Midlands Graduate School 2019 &lt;a href=&#34;http://www.cse.chalmers.se/~rjmh/MGS2019/&#34;&gt;course&lt;/a&gt; on property-based testing, which covers the basics of state machine modelling and testing. It also contains a minimal implementation of a state machine testing library built on top of Haskell&#39;s QuickCheck;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Finding Race Conditions in Erlang with QuickCheck and PULSE&lt;/em&gt; [&lt;a href=&#34;http://www.cse.chalmers.se/~nicsma/papers/finding-race-conditions.pdf&#34;&gt;PDF&lt;/a&gt;, &lt;a href=&#34;https://vimeo.com/6638041&#34;&gt;video&lt;/a&gt;] -- this is the first paper to describe how Erlang&#39;s QuickCheck works (including the parallel testing);&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Linearizability: a correctness condition for concurrent objects&lt;/em&gt; [&lt;a href=&#34;https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf&#34;&gt;PDF&lt;/a&gt;, TLA+ &lt;a href=&#34;https://github.com/lorin/tla-linearizability&#34;&gt;formalisation&lt;/a&gt;], this is a classic paper that describes the main technique of the parallel property;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Aphyr&#39;s blogposts about &lt;a href=&#34;https://github.com/jepsen-io/jepsen&#34;&gt;Jepsen&lt;/a&gt;, which also uses the linearisability technique, and has found bugs in many distributed systems:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://aphyr.com/posts/309-knossos-redis-and-linearizability&#34;&gt;Knossos: Redis and linearizability&lt;/a&gt;;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://aphyr.com/posts/313-strong-consistency-models&#34;&gt;Strong consistency models&lt;/a&gt;;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://aphyr.com/posts/314-computational-techniques-in-knossos&#34;&gt;Computational techniques in Knossos&lt;/a&gt;;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://aphyr.com/posts/333-serializability-linearizability-and-locality&#34;&gt;Serializability, linearizability, and locality&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The use of state machines to model and verify properties about programs is quite well-established, as witnessed by several books on the subject:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.microsoft.com/en-us/research/publication/specifying-systems-the-tla-language-and-tools-for-hardware-and-software-engineers/&#34;&gt;Specifying Systems&lt;/a&gt;: The TLA+ Language and Tools for Hardware and Software Engineers. Parts of this book are also presented by the author, Leslie Lamport, in the following video &lt;a href=&#34;https://lamport.azurewebsites.net/video/videos.html&#34;&gt;course&lt;/a&gt;;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://www.event-b.org/abook.html&#34;&gt;Modeling in Event-B&lt;/a&gt;: System and Software Engineering. Parts of this book are covered in the following (video) course given at Microsoft Research by the author, Jean-Raymond Abrial, himself:&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=2GP1pJINVT4&#34;&gt;Lecture 1&lt;/a&gt;: introduction to modelling and Event-B (chapter 1 of the book) and start of &#34;controlling cars on bridge&#34; example (chapter 2);&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=M8nvVaZ74wA&#34;&gt;Lecture 2&lt;/a&gt;: refining the &#34;controlling cars on a bridge&#34; example (sections 2.6 and 2.7);&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Y5OUtq8cdV8&#34;&gt;Lecture 3&lt;/a&gt;: design patterns and the &#34;mechanical press controller&#34; example (chapter 3);&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=ku-lfjxM4WI&#34;&gt;Lecture 4&lt;/a&gt;: sorting algorithm example (chapter 15);&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=C0tpgPOKAyg&#34;&gt;Lecture 5&lt;/a&gt;: designing sequential programs (chapter 15);&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=i-GKHZAWWjU&#34;&gt;Lecture 6&lt;/a&gt;: status report of the hypervisor that Microsoft Research are developing using Event-B.&lt;/p&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://www.di.unipi.it/~boerger/AsmBook/&#34;&gt;Abstract State Machines&lt;/a&gt;: A Method for High-Level System Design and Analysis.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;The books contain general advice how to model systems using state machines, and are hence relevant to us. For shorter texts on why state machines are important for modelling, see:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;Lamport&#39;s &lt;a href=&#34;https://www.microsoft.com/en-us/research/publication/computation-state-machines/&#34;&gt;&lt;em&gt;Computation and State Machines&lt;/em&gt;&lt;/a&gt;;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Gurevich&#39;s &lt;a href=&#34;https://www.microsoft.com/en-us/research/publication/103-evolving-algebras-1993-lipari-guide/&#34;&gt;&lt;em&gt;Evolving Algebras 1993: Lipari Guide&lt;/em&gt;&lt;/a&gt; and &lt;em&gt;Sequential Abstract State Machines Capture Sequential Algorithms&lt;/em&gt; [&lt;a href=&#34;http://delta-apache-vm.cs.tau.ac.il/~nachumd/models/gurevich.pdf&#34;&gt;PDF&lt;/a&gt;].&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Other similar libraries:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;Erlang QuickCheck, &lt;a href=&#34;http://quviq.com/documentation/eqc/&#34;&gt;eqc&lt;/a&gt;, the first property based testing library to have support for state machines (closed source);&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;The Erlang library &lt;a href=&#34;https://github.com/manopapad/proper&#34;&gt;PropEr&lt;/a&gt; is &lt;em&gt;eqc&lt;/em&gt;-inspired, open source, and has support for state machine &lt;a href=&#34;http://propertesting.com/&#34;&gt;testing&lt;/a&gt;;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;The Haskell library &lt;a href=&#34;https://github.com/hedgehogqa/haskell-hedgehog&#34;&gt;Hedgehog&lt;/a&gt;, also has support for state machine based testing;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://www.scalacheck.org/&#34;&gt;ScalaCheck&lt;/a&gt;, likewise has support for state machine based &lt;a href=&#34;https://github.com/rickynils/scalacheck/raw/master/doc/UserGuide.md#stateful-testing&#34;&gt;testing&lt;/a&gt; (no parallel property);&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;The Python library &lt;a href=&#34;https://hypothesis.readthedocs.io/en/latest/&#34;&gt;Hypothesis&lt;/a&gt;, also has support for state machine based &lt;a href=&#34;https://hypothesis.readthedocs.io/en/latest/stateful.html&#34;&gt;testing&lt;/a&gt; (no parallel property).&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;BSD-style (see the file LICENSE).&lt;/p&gt;</summary>
  </entry>
</feed>