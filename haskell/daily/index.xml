<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-02-15T01:31:20Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>HigherOrderCO/HVM3</title>
    <updated>2025-02-15T01:31:20Z</updated>
    <id>tag:github.com,2025-02-15:/HigherOrderCO/HVM3</id>
    <link href="https://github.com/HigherOrderCO/HVM3" rel="alternate"></link>
    <summary type="html">&lt;p&gt;HVM3&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;HVM3 - Work In Progress&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;HVM3&lt;/strong&gt; will combine the strengths of HVM1 and HVM2 while addressing their limitations. It aims to be the long-term runtime for &lt;a href=&#34;https://github.com/HigherOrderCO/Bend&#34;&gt;Bend&lt;/a&gt;. It has 2 modes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;HVML&lt;/strong&gt;: lazy mode. Pointers represent positive-to-negative ports in polarized nets, which coincides with the &lt;a href=&#34;https://GitHub.com/VictorTaelin/Interaction-Calculus&#34;&gt;Interaction Calculus&lt;/a&gt;. Strengths: efficient lazy evaluation, Î²-optimality. Drawbacks: 1. &lt;code&gt;whnf()&lt;/code&gt; may return a pending variable; 2.garbage collection is needed; 3. parallelism is less pervasive. It is based on &lt;a href=&#34;https://github.com/HigherOrderCO/hvm1&#34;&gt;HVM1&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;HVMS&lt;/strong&gt;: strict mode. Pointers represent aux-to-main ports, resulting in a tree-like memory format. Strengths: efficient massively parallel evaluation and no garbage-collection. Drawbacks: not laziness and no optimal evaluation. It is based on &lt;a href=&#34;https://github.com/HigherOrderCO/hvm&#34;&gt;HVM2&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;HVM3 is a work-in-progress. Its features are being actively implemented.&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install Cabal.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone this repository.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run &lt;code&gt;cabal install&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cabal run hvml -- run file.hvml     # runs lazy-mode, interpreted&#xA;cabal run hvml -- run file.hvml -c  # runs lazy-mode, compiled&#xA;&#xA;cabal run hvml -- run file.hvms     # runs strict-mode, interpreted (TODO)&#xA;cabal run hvml -- run file.hvms -c  # runs strict-mode, compiled (TODO)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: the &lt;code&gt;-c&lt;/code&gt; flag will also generate a standalone &lt;code&gt;.main.c&lt;/code&gt; file, which if you want, you can compile and run it independently. See examples on the &lt;a href=&#34;https://raw.githubusercontent.com/HigherOrderCO/HVM3/main/book/&#34;&gt;book/&lt;/a&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;Benchmarks will be added later. In the few programs tested, HVM3 is up to 42x faster single-core than Bend, due to its compiler (Bend was interpreted). It is also 2x-3x faster than Node.js and Haskell in the first program I tested, but possibly slower in others. HVM3 is a work-in-progress. It is currently single threaded. Threading (both on CPU and GPU) will be added later.&lt;/p&gt;</summary>
  </entry>
</feed>