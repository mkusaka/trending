<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Haskell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-13T01:29:16Z</updated>
  <subtitle>Daily Trending of Haskell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>AndrasKovacs/dawg</title>
    <updated>2024-03-13T01:29:16Z</updated>
    <id>tag:github.com,2024-03-13:/AndrasKovacs/dawg</id>
    <link href="https://github.com/AndrasKovacs/dawg" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Generation and traversal of highly compressed directed acyclic word graphs.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;dawg&lt;/h1&gt; &#xA;&lt;p&gt;Generation and traversal of highly compressed directed acyclic word graphs.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>augustss/MicroHs</title>
    <updated>2024-03-13T01:29:16Z</updated>
    <id>tag:github.com,2024-03-13:/augustss/MicroHs</id>
    <link href="https://github.com/augustss/MicroHs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Haskell implemented with combinators&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Micro Haskell&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains an implementation of an extended subset of Haskell. It uses combinators for the runtime execution.&lt;/p&gt; &#xA;&lt;p&gt;The runtime system has minimal dependencies, and can be compiled even for micro-controllers. The &lt;code&gt;boards/&lt;/code&gt; directory contains some samples, e.g., some sample code for an STM32F407G-DISC1 board.&lt;/p&gt; &#xA;&lt;p&gt;The compiler can compile itself.&lt;/p&gt; &#xA;&lt;h2&gt;Compiling MicroHs&lt;/h2&gt; &#xA;&lt;p&gt;There are two different ways to compile MicroHs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using GHC. &lt;code&gt;Makefile&lt;/code&gt; target &lt;code&gt;bin/gmhs&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Using the included combinator file and runtime. &lt;code&gt;Makefile&lt;/code&gt; target &lt;code&gt;bin/mhs&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These different ways of compiling need slightly different imports etc. This happens by GHC looking in the &lt;code&gt;ghc/&lt;/code&gt; subdirectory first for any extras/overrides.&lt;/p&gt; &#xA;&lt;p&gt;Compiling MicroHs is really best done using &lt;code&gt;make&lt;/code&gt;, but there is also a &lt;code&gt;MicroHs.cabal&lt;/code&gt; file for use with &lt;code&gt;cabal&lt;/code&gt;. This only builds what corresponds to the first target. Doing &lt;code&gt;cabal install&lt;/code&gt; will install the compiler. Note that &lt;code&gt;mhs&lt;/code&gt; built with ghc does not have all the functionality.&lt;/p&gt; &#xA;&lt;p&gt;Also note that there is no need to have a Haskell compiler to run MicroHs. All you need is a C compiler, and MicroHs can bootstrap, given the included combinator file.&lt;/p&gt; &#xA;&lt;p&gt;To install &lt;code&gt;mhs&lt;/code&gt; use &lt;code&gt;make install&lt;/code&gt;. By default this copies the files to &lt;code&gt;/usr/local&lt;/code&gt;, but this can be overridden by &lt;code&gt;make PREFIX=dir install&lt;/code&gt;. You also need to set the environment variable &lt;code&gt;MHSDIR&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To compile on Windows make sure &lt;code&gt;cl&lt;/code&gt; is in the path, and then use &lt;code&gt;nmake&lt;/code&gt; with &lt;code&gt;Makefile.windows&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The compiler can also be used with emscripten to produce JavaScript/WASM, see &lt;code&gt;Makefile.emscripten&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Language&lt;/h2&gt; &#xA;&lt;p&gt;The language is an extended subset of Haskell-2010.&lt;/p&gt; &#xA;&lt;p&gt;Differences:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;There is only deriving for &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, and &lt;code&gt;Typeable&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;default&lt;/code&gt; list is empty, except in the interactive system.&lt;/li&gt; &#xA; &lt;li&gt;Kind variables need an explicit &lt;code&gt;forall&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Always enabled extension: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;BangPatterns&lt;/li&gt; &#xA;   &lt;li&gt;ConstraintKinds&lt;/li&gt; &#xA;   &lt;li&gt;DuplicateRecordFields&lt;/li&gt; &#xA;   &lt;li&gt;EmptyDataDecls&lt;/li&gt; &#xA;   &lt;li&gt;ExistentialQuantification&lt;/li&gt; &#xA;   &lt;li&gt;ExtendedDefaultRules&lt;/li&gt; &#xA;   &lt;li&gt;FlexibleContexts&lt;/li&gt; &#xA;   &lt;li&gt;FlexibleInstance&lt;/li&gt; &#xA;   &lt;li&gt;ForeignFunctionInterface&lt;/li&gt; &#xA;   &lt;li&gt;FunctionalDependencies&lt;/li&gt; &#xA;   &lt;li&gt;IncoherentInstances&lt;/li&gt; &#xA;   &lt;li&gt;KindSignatures&lt;/li&gt; &#xA;   &lt;li&gt;MonoLocalBinds&lt;/li&gt; &#xA;   &lt;li&gt;MultiParamTypeClasses&lt;/li&gt; &#xA;   &lt;li&gt;NamedFieldPuns&lt;/li&gt; &#xA;   &lt;li&gt;NegativeLiterals&lt;/li&gt; &#xA;   &lt;li&gt;NoMonomorphismRestriction&lt;/li&gt; &#xA;   &lt;li&gt;NoStarIsType&lt;/li&gt; &#xA;   &lt;li&gt;OverlappingInstances&lt;/li&gt; &#xA;   &lt;li&gt;OverloadedRecordDot&lt;/li&gt; &#xA;   &lt;li&gt;OverloadedRecordUpdate&lt;/li&gt; &#xA;   &lt;li&gt;OverloadedStrings&lt;/li&gt; &#xA;   &lt;li&gt;PolyKinds&lt;/li&gt; &#xA;   &lt;li&gt;RankNTypes&lt;/li&gt; &#xA;   &lt;li&gt;RecordWildCards&lt;/li&gt; &#xA;   &lt;li&gt;QualifiedDo&lt;/li&gt; &#xA;   &lt;li&gt;ScopedTypeVariables&lt;/li&gt; &#xA;   &lt;li&gt;StandaloneKindSignatures&lt;/li&gt; &#xA;   &lt;li&gt;TupleSections (only pairs right now)&lt;/li&gt; &#xA;   &lt;li&gt;TypeLits&lt;/li&gt; &#xA;   &lt;li&gt;TypeSynonymInstances&lt;/li&gt; &#xA;   &lt;li&gt;UndecidableInstances&lt;/li&gt; &#xA;   &lt;li&gt;UndecidableSuperClasses&lt;/li&gt; &#xA;   &lt;li&gt;ViewPatterns&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;main&lt;/code&gt; in the top module given to &lt;code&gt;mhs&lt;/code&gt; serves at the program entry point.&lt;/li&gt; &#xA; &lt;li&gt;Many things that should be an error (but which are mostly harmless) are not reported.&lt;/li&gt; &#xA; &lt;li&gt;Text file I/O uses UTF8, but the source code does not allow Unicode.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;BangPatterns&lt;/code&gt; extension is parsed, but only effective at the a top level &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;where&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Lazy patterns (&lt;code&gt;~pat&lt;/code&gt;) are ignored.&lt;/li&gt; &#xA; &lt;li&gt;More differences that I don&#39;t remember right now.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;The file &lt;code&gt;Example.hs&lt;/code&gt; contains the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Haskell&#34;&gt;module Example(main) where&#xA;&#xA;fac :: Int -&amp;gt; Int&#xA;fac 0 = 1&#xA;fac n = n * fac(n-1)&#xA;&#xA;main :: IO ()&#xA;main = do&#xA;  let rs = map fac [1,2,3,10]&#xA;  putStrLn &#34;Some factorials&#34;&#xA;  print rs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;First, make sure the compiler is built by doing &lt;code&gt;make&lt;/code&gt;. Then compile the file by &lt;code&gt;bin/mhs Example -oEx&lt;/code&gt; which produces &lt;code&gt;Ex&lt;/code&gt;. Finally, run the binary file by &lt;code&gt;./Ex&lt;/code&gt;. This should produce&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Some factorials&#xA;[1,2,6,3628800]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Libraries&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;Prelude&lt;/code&gt; contains the functions from the Haskell Report and a few extensions, with the notable exception that &lt;code&gt;Foldable&lt;/code&gt; and &lt;code&gt;Traversable&lt;/code&gt; are not part of the &lt;code&gt;Prelude&lt;/code&gt;. They can be imported separately, though.&lt;/p&gt; &#xA;&lt;h2&gt;Types&lt;/h2&gt; &#xA;&lt;p&gt;There are some primitive data types, e.g &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;IO&lt;/code&gt;, &lt;code&gt;Ptr&lt;/code&gt;, and &lt;code&gt;Double&lt;/code&gt;. These are known by the runtime system and various primitive operations work on them. The function type, &lt;code&gt;-&amp;gt;&lt;/code&gt;, is (of course) also built in.&lt;/p&gt; &#xA;&lt;p&gt;All other types are defined with the language. They are converted to lambda terms using an encoding. For types with few constructors (&amp;lt; 5) it uses Scott encoding, otherwise it is a pair with an integer tag and a tuple (Scott encoded) with all arguments. The runtime system knows how lists and booleans are encoded.&lt;/p&gt; &#xA;&lt;h2&gt;Compiler&lt;/h2&gt; &#xA;&lt;p&gt;The compiler is written in Micro Haskell. It takes a name of a module (or a file name) and compiles to a target (see below). This module should contain the function &lt;code&gt;main&lt;/code&gt; of type &lt;code&gt;IO ()&lt;/code&gt; and it will be the entry point to the program.&lt;/p&gt; &#xA;&lt;h3&gt;Compiler flags&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--version&lt;/code&gt; show version number&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-iDIR&lt;/code&gt; add &lt;code&gt;DIR&lt;/code&gt; to search path for modules&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-oFILE&lt;/code&gt; output file. If the &lt;code&gt;FILE&lt;/code&gt; ends in &lt;code&gt;.comb&lt;/code&gt; it will produce a textual combinator file. If &lt;code&gt;FILE&lt;/code&gt; ends in &lt;code&gt;.c&lt;/code&gt; it will produce a C file with the combinators. For all other &lt;code&gt;FILE&lt;/code&gt; it will compile the combinators together with the runtime system to produce a regular executable.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-r&lt;/code&gt; run directly&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-v&lt;/code&gt; be more verbose, flag can be repeated&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-CW&lt;/code&gt; write compilation cache to &lt;code&gt;.mhscache&lt;/code&gt; at the end of compilation&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-CR&lt;/code&gt; read compilation cache from &lt;code&gt;.mhscache&lt;/code&gt; at the start of compilation&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-C&lt;/code&gt; short for &lt;code&gt;-CW&lt;/code&gt; and &lt;code&gt;-CR&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-T&lt;/code&gt; generate dynamic function usage statistics&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-z&lt;/code&gt; compress combinator code generated in the &lt;code&gt;.c&lt;/code&gt; file&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-XCPP&lt;/code&gt; run &lt;code&gt;cpphs&lt;/code&gt; on source files&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-Dxxx&lt;/code&gt; passed to &lt;code&gt;cpphs&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;With the &lt;code&gt;-v&lt;/code&gt; flag the processing time for each module is reported. E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;importing done MicroHs.Exp, 284ms (91 + 193)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which means that processing the module &lt;code&gt;MicroHs.Exp&lt;/code&gt; took 284ms, with parsing taking 91ms and typecheck&amp;amp;desugar taking 193ms.&lt;/p&gt; &#xA;&lt;p&gt;With the &lt;code&gt;-C&lt;/code&gt; flag the compiler writes out its internal cache of compiled modules to the file &lt;code&gt;.mhscache&lt;/code&gt; at the end of compilation. At startup it reads this file if it exists, and then validates the contents by an MD5 checksum for all the files in the cache. This can make compilation much faster since the compiler will not parse and typecheck a module if it is in the cache. Do &lt;strong&gt;NOT&lt;/strong&gt; use &lt;code&gt;-C&lt;/code&gt; when you are changing the compiler itself; if the cached data types change the compiler will probably just crash.&lt;/p&gt; &#xA;&lt;h3&gt;Environment variables&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;MHSDIR&lt;/code&gt; the directory where &lt;code&gt;lib/&lt;/code&gt; and &lt;code&gt;src/&lt;/code&gt; are expected to be. Defaults to &lt;code&gt;./&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MHSCC&lt;/code&gt; command use to compile C file to produce binaries. Look at the source for more information.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MHSCPPHS&lt;/code&gt; command to use with &lt;code&gt;-XCPP&lt;/code&gt; flag. Defaults to &lt;code&gt;cpphs&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Compiler modules&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Abstract&lt;/code&gt;, combinator bracket abstraction and optimization.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Compile&lt;/code&gt;, top level compiler. Maintains a cache of already compiled modules.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CompileCache&lt;/code&gt;, cache for compiled modules.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Deriving&lt;/code&gt;, do deriving for various type classes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Desugar&lt;/code&gt;, desugar full expressions to simple expressions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;EncodeData&lt;/code&gt;, data type encoding.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Exp&lt;/code&gt;, simple expression type.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ExpPrint&lt;/code&gt;, serialize &lt;code&gt;Exp&lt;/code&gt; for the runtime system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Expr&lt;/code&gt;, parsed expression type.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FFI&lt;/code&gt;, generate C wrappers for FFI.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Fixity&lt;/code&gt;, resolve operator fixities.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Flags&lt;/code&gt;, compiler flags.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Graph&lt;/code&gt;, strongly connected component algorithm.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Ident&lt;/code&gt;, identifiers and related types.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IdentMap&lt;/code&gt;, map from identifiers to something.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Interactive&lt;/code&gt;, top level for the interactive REPL.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Lex&lt;/code&gt;, lexical analysis and indentation processing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Main&lt;/code&gt;, the main module. Decodes flags, compiles, and writes result.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MakeCArray&lt;/code&gt;, generate a C version of the combinator file.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Parse&lt;/code&gt;, parse and build and abstract syntax tree.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;StateIO&lt;/code&gt;, state + IO monad.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SymTab&lt;/code&gt;, symbol table manipulation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TCMonad&lt;/code&gt;, type checking monad.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Translate&lt;/code&gt;, convert an expression tree to its value.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TypeCheck&lt;/code&gt;, type checker.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Interactive mode&lt;/h2&gt; &#xA;&lt;p&gt;If no module name is given the compiler enters interactive mode. You can enter expressions to be evaluated, or top level definitions (including &lt;code&gt;import&lt;/code&gt;). Simple line editing is available.&lt;/p&gt; &#xA;&lt;p&gt;All definitions are saved in the file &lt;code&gt;Interactive.hs&lt;/code&gt; and all input lines as saved in &lt;code&gt;.mhsi&lt;/code&gt;. The latter file is read on startup so the command history is persisted.&lt;/p&gt; &#xA;&lt;p&gt;Available commands:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:quit&lt;/code&gt; Quit the interactive system&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:clear&lt;/code&gt; Get back to start state&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:del STR&lt;/code&gt; Delete all definitions that begin with &lt;code&gt;STR&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:reload&lt;/code&gt; Reload all modules&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:type EXPR&lt;/code&gt; Show type of &lt;code&gt;EXPR&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:kind TYPE&lt;/code&gt; Show kind of &lt;code&gt;TYPE&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;expr&lt;/code&gt; Evaluate expression.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;defn&lt;/code&gt; Add definition (can also be an &lt;code&gt;import&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Files&lt;/h2&gt; &#xA;&lt;p&gt;There is a number of subdirectories:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Tools/&lt;/code&gt; a few useful tools for compressions etc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bin/&lt;/code&gt; executables are put here&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;generated/&lt;/code&gt; this contains the (machine generated) combinator file for the compiler.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lib/&lt;/code&gt; this contains the &lt;code&gt;Prelude&lt;/code&gt; and other base library file.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/MicroHs/&lt;/code&gt; the compiler source&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/runtime/&lt;/code&gt; the runtime source&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tests/&lt;/code&gt; some tests&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Runtime&lt;/h2&gt; &#xA;&lt;p&gt;The runtime system is written in C and is in &lt;code&gt;src/runtime/eval.c&lt;/code&gt;. It uses combinators for handling variables, and has primitive operations for built in types and for executing IO operations. There is a also a simple mark-scan garbage collector. The runtime system is written in a reasonably portable C code.&lt;/p&gt; &#xA;&lt;h3&gt;Runtime flags&lt;/h3&gt; &#xA;&lt;p&gt;Runtime flags are given between the flags &lt;code&gt;+RTS&lt;/code&gt; and &lt;code&gt;-RTS&lt;/code&gt;. Between those the runtime decodes the flags, everything else is available to the running program.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-HSIZE&lt;/code&gt; set heap size to &lt;code&gt;SIZE&lt;/code&gt; cells, can be suffixed by &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;, or &lt;code&gt;G&lt;/code&gt;, default is &lt;code&gt;50M&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-KSIZE&lt;/code&gt; set stack size to &lt;code&gt;SIZE&lt;/code&gt; entries, can be suffixed by &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;, or &lt;code&gt;G&lt;/code&gt;, default is&lt;code&gt;100k&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-rFILE&lt;/code&gt; read combinators from &lt;code&gt;FILE&lt;/code&gt;, instead of &lt;code&gt;out.comb&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-v&lt;/code&gt; be more verbose, flag can be repeated&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example, &lt;code&gt;bin/mhseval +RTS -H1M -v -RTS hello&lt;/code&gt; runs &lt;code&gt;out.comb&lt;/code&gt; and the program gets the argument &lt;code&gt;hello&lt;/code&gt;, whereas the runtime system sets the heap to 1M cells and is verbose.&lt;/p&gt; &#xA;&lt;h3&gt;FFI&lt;/h3&gt; &#xA;&lt;p&gt;MicroHs supports calling C functions. When running the program directly (using &lt;code&gt;-r&lt;/code&gt;) or when generating a &lt;code&gt;.comb&lt;/code&gt; file only the functions in the table built into &lt;code&gt;src/runtime/eval.c&lt;/code&gt; can be used. When generating a &lt;code&gt;.c&lt;/code&gt; file or an executable any C function can be called.&lt;/p&gt; &#xA;&lt;h3&gt;Records&lt;/h3&gt; &#xA;&lt;p&gt;MicroHs implements the record dot extensions. So accessing a field &lt;code&gt;a&lt;/code&gt; in record &lt;code&gt;r&lt;/code&gt; is written &lt;code&gt;r.a&lt;/code&gt;, as well as the usual &lt;code&gt;a r&lt;/code&gt;. The former is overloaded and can access any &lt;code&gt;a&lt;/code&gt; field, whereas the latter is the usual monomorphic field selector. Updating a field has the usual Haskell syntax &lt;code&gt;r{ a = e }&lt;/code&gt;, but the type is overloaded so this can update the &lt;code&gt;a&lt;/code&gt; field in any record. The typeclasses &lt;code&gt;HasField&lt;/code&gt; and &lt;code&gt;SetField&lt;/code&gt; capture this. &lt;code&gt;HasField &#34;name&#34; rec ty&lt;/code&gt; expresses that the record type &lt;code&gt;rec&lt;/code&gt; has a field &lt;code&gt;name&lt;/code&gt; with type &lt;code&gt;ty&lt;/code&gt; that can be extracted with &lt;code&gt;getField&lt;/code&gt;. &lt;code&gt;SetField &#34;name&#34; rec ty&lt;/code&gt; expresses that the record type &lt;code&gt;rec&lt;/code&gt; has a field &lt;code&gt;name&lt;/code&gt; with type &lt;code&gt;ty&lt;/code&gt; that can be set &lt;code&gt;setField&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Record updates can also update nested fields, e.g., &lt;code&gt;r{ a.b.c = e }&lt;/code&gt;. Note that this will not easily work in GHC, since GHC does not fully implement &lt;code&gt;OverloadedRecordUpdate&lt;/code&gt;. When GHC decides how to do it, MicroHs will follow suit.&lt;/p&gt; &#xA;&lt;p&gt;Note that record updates cannot change the type of polymorphic fields.&lt;/p&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;p&gt;The runtime system can serialize and deserialize any expression and keep its graph structure (sharing and cycles). The only exceptions to this are C pointers (e.g., file handles), which cannot be serialized (except for &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Memory layout&lt;/h3&gt; &#xA;&lt;p&gt;Memory allocation is based on cells. Each cell has room for two pointers (i.e., two words, typically 16 bytes), so it can represent an application node. One bit is used to indicate if the cell is an application or something else. If it is something else one word is a tag indicating what it is, e.g., a combinator or an integer. The second word is then used to store any payload, e.g., the number itself for an integer node.&lt;/p&gt; &#xA;&lt;p&gt;Memory allocation has a bitmap with one bit per cell. Allocating a cell consists of finding the next free cell using the bitmap, and then marking it as used. The garbage collector first clears the bitmap and then (recursively) marks every used cell in the bitmap. There is no explicit scan phase since that is baked into the allocation. Allocation is fast assuming the CPU has some kind of FindFirstSet instruction.&lt;/p&gt; &#xA;&lt;p&gt;It is possible to use smaller cells by using 32 bit &#34;pointers&#34; instead of 64 bit pointers. This has a performance penalty, though.&lt;/p&gt; &#xA;&lt;h3&gt;Portability&lt;/h3&gt; &#xA;&lt;p&gt;The C code for the evaluator does not use any special features, and should be portable to many platforms. It has mostly been tested with MacOS and Linux, and somewhat with Windows.&lt;/p&gt; &#xA;&lt;p&gt;The code has mostly been tested on 64 bit platforms, so again, there are lurking problems with other word sizes, but they should be easy to fix.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;src/runtime/&lt;/code&gt; directory contains configuration files for different platform. Use the appropriate &lt;code&gt;src/runtime/eval-&lt;/code&gt;&lt;em&gt;platform&lt;/em&gt;&lt;code&gt;.c&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Bootstrapping&lt;/h2&gt; &#xA;&lt;p&gt;The compiler can compile itself. To replace &lt;code&gt;bin/mhs&lt;/code&gt; with a new version, do &lt;code&gt;make bootstrap&lt;/code&gt;. This will recompile the compiler twice and compare the outputs to make sure the new compiler still works.&lt;/p&gt; &#xA;&lt;h1&gt;Preprocessor&lt;/h1&gt; &#xA;&lt;p&gt;Sadly, compiling a lot of Haskell packages needs the C preprocessor. To this end, the distribution contains the combinator code for &lt;code&gt;cpphs&lt;/code&gt;. Doing &lt;code&gt;make bin/cpphs&lt;/code&gt; will create the binary for the preprocessor.&lt;/p&gt; &#xA;&lt;p&gt;To bootstrap &lt;code&gt;cpphs&lt;/code&gt; you can do &lt;code&gt;make bootstrapcpphs&lt;/code&gt;. This assumes that you have &lt;code&gt;git&lt;/code&gt; to download the needed packages. At the moment, the downloaded packages are forks of the original to make it compile with &lt;code&gt;mhs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;FAQ&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Q: When will it get &lt;em&gt;insert feature&lt;/em&gt;?&lt;/li&gt; &#xA;   &lt;li&gt;A: Maybe some time, maybe never.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Q: Why are the error messages so bad?&lt;/li&gt; &#xA;   &lt;li&gt;A: Error messages are boring.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Q: Why is the so much source code?&lt;/li&gt; &#xA;   &lt;li&gt;A: I wonder this myself. 7000+ lines of Haskell seems excessive. 2500+ lines of C is also more than I&#39;d like for such a simple system.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Q: Why are the binaries so big?&lt;/li&gt; &#xA;   &lt;li&gt;A: The combinator file is rather verbose. The combinator file for the compiler shrinks from 350kB to 75kB when compressed with upx. The evaluator alone is about 70kB (26kB compressed with upx).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>imeckler/todo</title>
    <updated>2024-03-13T01:29:16Z</updated>
    <id>tag:github.com,2024-03-13:/imeckler/todo</id>
    <link href="https://github.com/imeckler/todo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A simple, useful todo list app&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>