<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-12T02:04:24Z</updated>
  <subtitle>Weekly Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>alexrudall/ruby-openai</title>
    <updated>2023-02-12T02:04:24Z</updated>
    <id>tag:github.com,2023-02-12:/alexrudall/ruby-openai</id>
    <link href="https://github.com/alexrudall/ruby-openai" rel="alternate"></link>
    <summary type="html">&lt;p&gt;OpenAI API + Ruby! ü§ñ‚ù§Ô∏è&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ruby::OpenAI&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://badge.fury.io/rb/ruby-openai&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/ruby-openai.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/alexrudall/ruby-openai/raw/main/LICENSE.txt&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-blue.svg?sanitize=true&#34; alt=&#34;GitHub license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/alexrudall/ruby-openai&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/alexrudall/ruby-openai.svg?style=shield&#34; alt=&#34;CircleCI Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/codeclimate/codeclimate/maintainability&#34;&gt;&lt;img src=&#34;https://api.codeclimate.com/v1/badges/a99a88d28ad37a79dbf6/maintainability&#34; alt=&#34;Maintainability&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Use the &lt;a href=&#34;https://openai.com/blog/openai-api/&#34;&gt;OpenAI API&lt;/a&gt; with Ruby! ü§ñ‚ù§Ô∏è&lt;/p&gt; &#xA;&lt;p&gt;Generate text with GPT-3, create images with DALL¬∑E, or write code with Codex...&lt;/p&gt; &#xA;&lt;p&gt;Want to instantly make your own AIs without writing a line of code? Check out &lt;a href=&#34;https://peaceterms.com&#34;&gt;Peaceterms&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Bundler&lt;/h3&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    gem &#34;ruby-openai&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;p&gt;$ bundle install&lt;/p&gt; &#xA;&lt;h3&gt;Gem install&lt;/h3&gt; &#xA;&lt;p&gt;Or install with:&lt;/p&gt; &#xA;&lt;p&gt;$ gem install ruby-openai&lt;/p&gt; &#xA;&lt;p&gt;and require with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    require &#34;ruby/openai&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Get your API key from &lt;a href=&#34;https://beta.openai.com/account/api-keys&#34;&gt;https://beta.openai.com/account/api-keys&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;If you belong to multiple organizations, you can get your Organization ID from &lt;a href=&#34;https://beta.openai.com/account/org-settings&#34;&gt;https://beta.openai.com/account/org-settings&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Quickstart&lt;/h3&gt; &#xA;&lt;p&gt;For a quick test you can pass your token directly to a new client:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    client = OpenAI::Client.new(access_token: &#34;access_token_goes_here&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;With Config&lt;/h3&gt; &#xA;&lt;p&gt;For a more robust setup, you can configure the gem with your API keys, for example in an &lt;code&gt;openai.rb&lt;/code&gt; initializer file. Never hardcode secrets into your codebase - instead use something like &lt;a href=&#34;https://github.com/motdotla/dotenv&#34;&gt;dotenv&lt;/a&gt; to pass the keys safely into your environments.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    Ruby::OpenAI.configure do |config|&#xA;        config.access_token = ENV.fetch(&#39;OPENAI_ACCESS_TOKEN&#39;)&#xA;        config.organization_id = ENV.fetch(&#39;OPENAI_ORGANIZATION_ID&#39;) # Optional.&#xA;    end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can create a client like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    client = OpenAI::Client.new&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Models&lt;/h3&gt; &#xA;&lt;p&gt;There are different models that can be used to generate text. For a full list and to retrieve information about a single models:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    client.models.list&#xA;    client.models.retrieve(id: &#34;text-ada-001&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Examples&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://beta.openai.com/docs/models/gpt-3&#34;&gt;GPT-3&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;text-ada-001&lt;/li&gt; &#xA;   &lt;li&gt;text-babbage-001&lt;/li&gt; &#xA;   &lt;li&gt;text-curie-001&lt;/li&gt; &#xA;   &lt;li&gt;text-davinci-001&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://beta.openai.com/docs/models/codex-series-private-beta&#34;&gt;Codex (private beta)&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;code-davinci-002&lt;/li&gt; &#xA;   &lt;li&gt;code-cushman-001&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Completions&lt;/h3&gt; &#xA;&lt;p&gt;Hit the OpenAI API for a completion:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    response = client.completions(&#xA;        parameters: {&#xA;            model: &#34;text-davinci-001&#34;,&#xA;            prompt: &#34;Once upon a time&#34;,&#xA;            max_tokens: 5&#xA;        })&#xA;    puts response[&#34;choices&#34;].map { |c| c[&#34;text&#34;] }&#xA;    =&amp;gt; [&#34;, there lived a great&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Edits&lt;/h3&gt; &#xA;&lt;p&gt;Send a string and some instructions for what to do to the string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    response = client.edits(&#xA;        parameters: {&#xA;            model: &#34;text-davinci-edit-001&#34;,&#xA;            input: &#34;What day of the wek is it?&#34;,&#xA;            instruction: &#34;Fix the spelling mistakes&#34;&#xA;        }&#xA;    )&#xA;    puts response.dig(&#34;choices&#34;, 0, &#34;text&#34;)&#xA;    =&amp;gt; What day of the week is it?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Embeddings&lt;/h3&gt; &#xA;&lt;p&gt;You can use the embeddings endpoint to get a vector of numbers representing an input. You can then compare these vectors for different inputs to efficiently check how similar the inputs are.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    client.embeddings(&#xA;        parameters: {&#xA;            model: &#34;babbage-similarity&#34;,&#xA;            input: &#34;The food was delicious and the waiter...&#34;&#xA;        }&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Files&lt;/h3&gt; &#xA;&lt;p&gt;Put your data in a &lt;code&gt;.jsonl&lt;/code&gt; file like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;    {&#34;text&#34;: &#34;puppy A is happy&#34;, &#34;metadata&#34;: &#34;emotional state of puppy A&#34;}&#xA;    {&#34;text&#34;: &#34;puppy B is sad&#34;, &#34;metadata&#34;: &#34;emotional state of puppy B&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and pass the path to &lt;code&gt;client.files.upload&lt;/code&gt; to upload it to OpenAI, and then interact with it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    client.files.upload(parameters: { file: &#34;path/to/puppy.jsonl&#34;, purpose: &#34;search&#34; })&#xA;    client.files.list&#xA;    client.files.retrieve(id: 123)&#xA;    client.files.delete(id: 123)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fine-tunes&lt;/h3&gt; &#xA;&lt;p&gt;Put your fine-tuning data in a &lt;code&gt;.jsonl&lt;/code&gt; file like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;    {&#34;prompt&#34;:&#34;Overjoyed with my new phone! -&amp;gt;&#34;, &#34;completion&#34;:&#34; positive&#34;}&#xA;    {&#34;prompt&#34;:&#34;@lakers disappoint for a third straight night -&amp;gt;&#34;, &#34;completion&#34;:&#34; negative&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and pass the path to &lt;code&gt;client.files.upload&lt;/code&gt; to upload it to OpenAI and get its ID:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    response = client.files.upload(parameters: { file: &#34;path/to/sentiment.jsonl&#34;, purpose: &#34;fine-tune&#34; })&#xA;    file_id = JSON.parse(response.body)[&#34;id&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then use this file ID to create a fine-tune model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    response = client.finetunes.create(&#xA;        parameters: {&#xA;        training_file: file_id,&#xA;        model: &#34;text-ada-001&#34;&#xA;    })&#xA;    fine_tune_id = JSON.parse(response.body)[&#34;id&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That will give you the fine-tune ID. If you made a mistake you can cancel the fine-tune model before it is processed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    client.finetunes.cancel(id: fine_tune_id)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may need to wait a short time for processing to complete. Once processed, you can use list or retrieve to get the name of the fine-tuned model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    client.finetunes.list&#xA;    response = client.finetunes.retrieve(id: fine_tune_id)&#xA;    fine_tuned_model = JSON.parse(response.body)[&#34;fine_tuned_model&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This fine-tuned model name can then be used in completions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    response = client.completions(&#xA;        parameters: {&#xA;            model: fine_tuned_model,&#xA;            prompt: &#34;I love Mondays!&#34;&#xA;        }&#xA;    )&#xA;    JSON.parse(response.body)[&#34;choices&#34;].map { |c| c[&#34;text&#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can delete the fine-tuned model when you are done with it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    client.finetunes.delete(fine_tuned_model: fine_tuned_model)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Image Generation&lt;/h3&gt; &#xA;&lt;p&gt;Generate an image using DALL¬∑E! The size of any generated images must be one of &lt;code&gt;256x256&lt;/code&gt;, &lt;code&gt;512x512&lt;/code&gt; or &lt;code&gt;1024x1024&lt;/code&gt; - if not specified the image will default to &lt;code&gt;1024x1024&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    response = client.images.generate(parameters: { prompt: &#34;A baby sea otter cooking pasta wearing a hat of some sort&#34;, size: &#34;256x256&#34; })&#xA;    puts response.dig(&#34;data&#34;, 0, &#34;url&#34;)&#xA;    =&amp;gt; &#34;https://oaidalleapiprodscus.blob.core.windows.net/private/org-Rf437IxKhh...&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.ibb.co/6y4HJFx/img-d-Tx-Rf-RHj-SO5-Gho-Cbd8o-LJvw3.png&#34; alt=&#34;Ruby&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Image Edit&lt;/h3&gt; &#xA;&lt;p&gt;Fill in the transparent part of an image, or upload a mask with transparent sections to indicate the parts of an image that can be changed according to your prompt...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    response = client.images.edit(parameters: { prompt: &#34;A solid red Ruby on a blue background&#34;, image: &#34;image.png&#34;, mask: &#34;mask.png&#34; })&#xA;    puts response.dig(&#34;data&#34;, 0, &#34;url&#34;)&#xA;    =&amp;gt; &#34;https://oaidalleapiprodscus.blob.core.windows.net/private/org-Rf437IxKhh...&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.ibb.co/sWVh3BX/dalle-ruby.png&#34; alt=&#34;Ruby&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Image Variations&lt;/h3&gt; &#xA;&lt;p&gt;Create n variations of an image.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    response = client.images.variations(parameters: { image: &#34;image.png&#34;, n: 2 })&#xA;    puts response.dig(&#34;data&#34;, 0, &#34;url&#34;)&#xA;    =&amp;gt; &#34;https://oaidalleapiprodscus.blob.core.windows.net/private/org-Rf437IxKhh...&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.ibb.co/TWJLP2y/img-miu-Wk-Nl0-QNy-Xtj-Lerc3c0l-NW.png&#34; alt=&#34;Ruby&#34;&gt; &lt;img src=&#34;https://i.ibb.co/ScBhDGB/img-a9-Be-Rz-Au-Xwd-AV0-ERLUTSTGdi.png&#34; alt=&#34;Ruby&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Moderations&lt;/h3&gt; &#xA;&lt;p&gt;Pass a string to check if it violates OpenAI&#39;s Content Policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    response = client.moderations(parameters: { input: &#34;I&#39;m worried about that.&#34; })&#xA;    puts response.dig(&#34;results&#34;, 0, &#34;category_scores&#34;, &#34;hate&#34;)&#xA;    =&amp;gt; 5.505014632944949e-05&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;After checking out the repo, run &lt;code&gt;bin/setup&lt;/code&gt; to install dependencies. You can run &lt;code&gt;bin/console&lt;/code&gt; for an interactive prompt that will allow you to experiment.&lt;/p&gt; &#xA;&lt;p&gt;To install this gem onto your local machine, run &lt;code&gt;bundle exec rake install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Release&lt;/h2&gt; &#xA;&lt;p&gt;First run the specs without VCR so they actually hit the API. This will cost about 2 cents. You&#39;ll need to add your &lt;code&gt;OPENAI_ACCESS_TOKEN=&lt;/code&gt; in &lt;code&gt;.env&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  NO_VCR=true bundle exec rspec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then update the version number in &lt;code&gt;version.rb&lt;/code&gt;, update &lt;code&gt;CHANGELOG.md&lt;/code&gt;, run &lt;code&gt;bundle install&lt;/code&gt; to update Gemfile.lock, and then run &lt;code&gt;bundle exec rake release&lt;/code&gt;, which will create a git tag for the version, push git commits and tags, and push the &lt;code&gt;.gem&lt;/code&gt; file to &lt;a href=&#34;https://rubygems.org&#34;&gt;rubygems.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Bug reports and pull requests are welcome on GitHub at &lt;a href=&#34;https://github.com/alexrudall/ruby-openai&#34;&gt;https://github.com/alexrudall/ruby-openai&lt;/a&gt;. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the &lt;a href=&#34;https://github.com/alexrudall/ruby-openai/raw/main/CODE_OF_CONDUCT.md&#34;&gt;code of conduct&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;Everyone interacting in the Ruby::OpenAI project&#39;s codebases, issue trackers, chat rooms and mailing lists is expected to follow the &lt;a href=&#34;https://github.com/alexrudall/ruby-openai/raw/main/CODE_OF_CONDUCT.md&#34;&gt;code of conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-3-enumerables-debugging</title>
    <updated>2023-02-12T02:04:24Z</updated>
    <id>tag:github.com,2023-02-12:/learn-co-curriculum/phase-3-enumerables-debugging</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-enumerables-debugging" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Enumerables: Debugging with Pry&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use Pry to debug code running in enumerable method blocks&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Methods using enumerables and loops can be a bit more challenging to debug than other methods. In this lesson, you&#39;ll practice using &lt;code&gt;binding.pry&lt;/code&gt; to pause the execution of your code inside a loop so you can inspect variables in enumerable methods.&lt;/p&gt; &#xA;&lt;h2&gt;Code Along&lt;/h2&gt; &#xA;&lt;p&gt;Fork and clone this lesson to code along!&lt;/p&gt; &#xA;&lt;p&gt;In this lesson, we&#39;ll be writing a method called &lt;code&gt;#reverse_each_word&lt;/code&gt; that takes in a argument of a sentence as a string, and returns that same sentence with each word reversed in place.&lt;/p&gt; &#xA;&lt;p&gt;The input will be a sentence, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;&#34;Hello there, and how are you?&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And calling our method will produce an output like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;reverse_each_word(&#34;Hello there, and how are you?&#34;)&#xA;  #=&amp;gt; &#34;olleH ,ereht dna woh era ?uoy&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Before writing this method out, let&#39;s do a bit of pseudocoding, and decide how we need to approach this problem:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Split the string on &#34; &#34; to get access to each word in the sentence&lt;/li&gt; &#xA; &lt;li&gt;Reverse each word, and add it to a new array&lt;/li&gt; &#xA; &lt;li&gt;Join the array of words on &#34; &#34; to create one string&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;With that plan of attack in mind, let&#39;s start writing the method, and use &lt;code&gt;pry&lt;/code&gt; to check our work on each step of this pseudocode.&lt;/p&gt; &#xA;&lt;h3&gt;Step 1: Splitting the String&lt;/h3&gt; &#xA;&lt;p&gt;To start, add the following code to your &lt;code&gt;reverse_each_word.rb&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;pry&#39;&#xA;&#xA;def reverse_each_word(sentence)&#xA;  binding.pry&#xA;end&#xA;&#xA;reverse_each_word(&#34;Hello there, and how are you?&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run the file with &lt;code&gt;ruby reverse_each_word.rb&lt;/code&gt;. From the Pry session in your terminal, inspect the &lt;code&gt;sentence&lt;/code&gt; variable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;sentence&#xA;# =&amp;gt; &#34;Hello there, and how are you?&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, let&#39;s try getting the first step of our pseudocode working from the Pry session:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Split the string on &#34; &#34; to get access to each word in the sentence&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We can use the &lt;code&gt;#split&lt;/code&gt; method for this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;sentence.split(&#34; &#34;)&#xA;# =&amp;gt; [&#34;Hello&#34;, &#34;there,&#34;, &#34;and&#34;, &#34;how&#34;, &#34;are&#34;, &#34;you?&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also use &lt;code&gt;#split&lt;/code&gt; with no arguments, since the default argument is a space:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;sentence.split&#xA;# =&amp;gt; [&#34;Hello&#34;, &#34;there,&#34;, &#34;and&#34;, &#34;how&#34;, &#34;are&#34;, &#34;you?&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Great! Now that we know this method works in Pry, exit out of Pry in the terminal by typing &lt;code&gt;exit&lt;/code&gt; or &lt;code&gt;control + d&lt;/code&gt;. Then, back in the &lt;code&gt;reverse_each_word.rb&lt;/code&gt; file, add this code to the method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Step 2: Reverse Each Word&lt;/h3&gt; &#xA;&lt;p&gt;For the next step of our pseudocode, we&#39;ll need to tackle this problem:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Reverse each word, and add it to a new array&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We can break this step down a bit further:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create a new array&lt;/li&gt; &#xA; &lt;li&gt;Iterate over the array of words&lt;/li&gt; &#xA; &lt;li&gt;Reverse each word, and add it to the new array&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Let&#39;s start by creating a variable for the new array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, we&#39;ll need iterate over each word in the array and reverse it. You might know what do to from here, but to get some practice with Pry, let&#39;s add a &lt;code&gt;binding.pry&lt;/code&gt; breakpoint inside the &lt;code&gt;#each&lt;/code&gt; loop:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    binding.pry&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the program again with &lt;code&gt;ruby reverse_each_word.rb&lt;/code&gt;. You&#39;ll now enter a Pry session within the &lt;code&gt;#each&lt;/code&gt; loop! This makes it easy to see what&#39;s happening as you iterate over the array.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Depending on the size of your terminal window, Pry might not be able to fit your entire method on the screen, in which case you&#39;ll see a screen like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;     5: def reverse_each_word(sentence)&#xA;     6:   words = sentence.split&#xA;     7:   reversed_words = []&#xA;     8:&#xA;     9:   words.each do |word|&#xA;    10:     binding.pry&#xA;    11:   end&#xA;:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you ever get into this situation, just type the letter &lt;code&gt;q&lt;/code&gt; in the terminal to exit out.&lt;/p&gt; &#xA;&lt;p&gt;From here, our goal from the pseudocode is to:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Reverse each word, and add it to the new array&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We can try this out in the Pry session:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;word&#xA;# =&amp;gt; &#34;Hello&#34;&#xA;word.reverse&#xA;# =&amp;gt; &#34;olleH&#34;&#xA;reversed_words &amp;lt;&amp;lt; word.reverse&#xA;# =&amp;gt; [&#34;olleH&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Success! Type &lt;code&gt;exit&lt;/code&gt; now. This will exit the current breakpoint, but since our code is running in a loop, we&#39;ll hit the same breakpoint again, with the next word in the array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;word&#xA;# =&amp;gt; &#34;there,&#34;&#xA;reversed_words &amp;lt;&amp;lt; word.reverse&#xA;# =&amp;gt; [&#34;olleH&#34;, &#34;,ereht&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can type &lt;code&gt;exit&lt;/code&gt; again to see the next word, but if you&#39;re confident your code is working as expected, you can exit from Pry entirely by typing &lt;code&gt;exit-program&lt;/code&gt; or &lt;code&gt;!!!&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;You can also see a list of all Pry commands by typing &lt;code&gt;help&lt;/code&gt; from your Pry session.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Add the working code to your method. All together, your files should look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;pry&#39;&#xA;&#xA;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    reversed_words &amp;lt;&amp;lt; word.reverse&#xA;  end&#xA;end&#xA;&#xA;reverse_each_word(&#34;Hello there, and how are you?&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Step 3: Join the Reversed Array&lt;/h3&gt; &#xA;&lt;p&gt;We&#39;re onto the last step of our pseudocode:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Join the array of words on &#34; &#34; to create one string&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Let&#39;s use Pry one more time to check our work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    reversed_words &amp;lt;&amp;lt; word.reverse&#xA;  end&#xA;&#xA;  binding.pry&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the program again. From the Pry session, we can use the &lt;code&gt;#join&lt;/code&gt; method to create a string from our array of reversed words.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Remember: hit the &lt;code&gt;q&lt;/code&gt; key if you&#39;re unable to interact with the terminal in Pry!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;reversed_words.join&#xA;# =&amp;gt; &#34;olleH,erehtdnawohera?uoy&#34;&#xA;reversed_words.join(&#34; &#34;)&#xA;# =&amp;gt; &#34;olleH ,ereht dna woh era ?uoy&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;ve done it! Exit the Pry session, and add that final bit of code in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;pry&#39;&#xA;&#xA;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    reversed_words &amp;lt;&amp;lt; word.reverse&#xA;  end&#xA;&#xA;  reversed_words.join(&#34; &#34;)&#xA;end&#xA;&#xA;reverse_each_word(&#34;Hello there, and how are you?&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, let&#39;s test out our method by running the file once more with &lt;code&gt;ruby reverse_each_word.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ruby reverse_each_word.rb&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hmmm... There&#39;s no output, and there are no tests to run! How can we tell if the program is doing what we expect? One way would be to use &lt;code&gt;puts&lt;/code&gt; to inspect the output of running the method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;pry&#39;&#xA;&#xA;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    reversed_words &amp;lt;&amp;lt; word.reverse&#xA;  end&#xA;&#xA;  reversed_words.join(&#34; &#34;)&#xA;end&#xA;&#xA;puts reverse_each_word(&#34;Hello there, and how are you?&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now that we&#39;ve got some terminal output, we can see if the method does indeed produce the desired return value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ruby reverse_each_word.rb&#xA;olleH ,ereht dna woh era ?uoy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pry is also useful in this situation. Add a &lt;code&gt;binding.pry&lt;/code&gt; at the bottom of the file, followed by a 0:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;pry&#39;&#xA;&#xA;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    reversed_words &amp;lt;&amp;lt; word.reverse&#xA;  end&#xA;&#xA;  reversed_words.join(&#34; &#34;)&#xA;end&#xA;&#xA;binding.pry&#xA;0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The 0 is necessary because of some &lt;a href=&#34;https://github.com/deivid-rodriguez/pry-byebug/issues/45&#34;&gt;quirky behavior&lt;/a&gt; with &lt;code&gt;binding.pry&lt;/code&gt;: you can&#39;t use a breakpoint as the last line of code in a program. So adding any arbitrary data on the line below ensures our breakpoint will be hit.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Then run &lt;code&gt;ruby reverse_each_word.rb&lt;/code&gt; again to run the program, and enter a Pry session. From this Pry session, you can test your method with any data you like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;reverse_each_word(&#34;does it work?&#34;)&#xA;# =&amp;gt; &#34;seod ti ?krow&#34;&#xA;reverse_each_word(&#34;i think it does&#34;)&#xA;# =&amp;gt; &#34;i kniht ti seod&#34;&#xA;reverse_each_word(&#34;racecar madam wow&#34;)&#xA;# =&amp;gt; &#34;racecar madam wow&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Bonus: Refactor&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;ve had enough, feel free to skip ahead to the conclusion; for those interested in refactoring our &lt;code&gt;reverse_each_word&lt;/code&gt; method, stick around!&lt;/p&gt; &#xA;&lt;p&gt;Take a moment to review the code from the final version of our method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    reversed_words &amp;lt;&amp;lt; word.reverse&#xA;  end&#xA;&#xA;  reversed_words.join(&#34; &#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It works as intended, but are there any ways we could make this code a bit cleaner? In particular, think about our use of the &lt;code&gt;#each&lt;/code&gt; method: are there any other methods that might be better suited for the task at hand? We&#39;re trying to iterate over every element of an array, transform it in some way, and return a new array.&lt;/p&gt; &#xA;&lt;p&gt;Sounds like the perfect job for &lt;code&gt;#map&lt;/code&gt;! Try updating the method using the code below, and run &lt;code&gt;ruby reverse_each_word.rb&lt;/code&gt; to check that the refactor still produces the expected result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;&#xA;  reversed_words = words.map do |word|&#xA;    word.reverse&#xA;  end&#xA;&#xA;  reversed_words.join(&#34; &#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We could also write out &lt;code&gt;#map&lt;/code&gt; using the &lt;a href=&#34;https://www.honeybadger.io/blog/how-ruby-ampersand-colon-works/&#34;&gt;Proc shorthand&lt;/a&gt; syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;&#xA;  reversed_words = words.map(&amp;amp;:reverse)&#xA;&#xA;  reversed_words.join(&#34; &#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also take advantage of some method chaining to combine all this on one line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  sentence.split.map(&amp;amp;:reverse).join(&#34; &#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;You&#39;ve now had a chance to use Pry for breakpoint debugging in a few scenarios. This kind of debugging is a great way to gain confidence in what your code is doing, so make sure to practice using &lt;code&gt;binding.pry&lt;/code&gt; in the lessons to come!&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pry/pry/wiki&#34;&gt;Pry wiki&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>ThrowTheSwitch/Ceedling</title>
    <updated>2023-02-12T02:04:24Z</updated>
    <id>tag:github.com,2023-02-12:/ThrowTheSwitch/Ceedling</id>
    <link href="https://github.com/ThrowTheSwitch/Ceedling" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ruby/Rake-based build and test system for C projects&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ceedling &lt;img src=&#34;https://github.com/ThrowTheSwitch/Ceedling/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Ceedling is a build system for C projects that is something of an extension around Ruby‚Äôs Rake (make-ish) build system. Ceedling also makes TDD (Test-Driven Development) in C a breeze by integrating &lt;a href=&#34;https://github.com/throwtheswitch/cmock&#34;&gt;CMock&lt;/a&gt;, &lt;a href=&#34;https://github.com/throwtheswitch/unity&#34;&gt;Unity&lt;/a&gt;, and &lt;a href=&#34;https://github.com/throwtheswitch/cexception&#34;&gt;CException&lt;/a&gt; -- three other awesome open-source projects you can‚Äôt live without if you&#39;re creating awesomeness in the C language. Ceedling is also extensible with a handy plugin mechanism.&lt;/p&gt; &#xA;&lt;h1&gt;Usage Documentation&lt;/h1&gt; &#xA;&lt;p&gt;Documentation and license info exists &lt;a href=&#34;https://raw.githubusercontent.com/ThrowTheSwitch/Ceedling/master/docs/CeedlingPacket.md&#34;&gt;in the repo in docs/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Getting Started&lt;/h1&gt; &#xA;&lt;p&gt;First make sure Ruby is installed on your system (if it&#39;s not already). Then, from a command prompt:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; gem install ceedling&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;(Alternate Installation for Those Planning to Be Ceedling Developers)&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; git clone --recursive https://github.com/throwtheswitch/ceedling.git&#xA;&amp;gt; cd ceedling&#xA;&amp;gt; bundle install # Ensures you have all RubyGems needed&#xA;&amp;gt; git submodule update --init --recursive # Updates all submodules&#xA;&amp;gt; bundle exec rake # Run all Ceedling library tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If bundler isn&#39;t installed on your system or you run into problems, you might have to install it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; sudo gem install bundler&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you run into trouble running bundler and get messages like this &lt;code&gt;can&#39;t find gem bundler (&amp;gt;= 0.a) with executable bundle (Gem::GemNotFoundException)&lt;/code&gt;, you may need to install a different version of bundler. For this please reference the version in the Gemfile.lock. An example based on the current Gemfile.lock is as followed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; sudo gem install bundler -v 1.16.2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Creating A Project&lt;/h1&gt; &#xA;&lt;p&gt;Creating a project with Ceedling is easy. Simply tell ceedling the name of the project, and it will create a subdirectory called that name and fill it with a default directory structure and configuration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ceedling new YourNewProjectName&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can add files to your src and test directories and they will instantly become part of your test build. Need a different structure? You can start to tweak the &lt;code&gt;project.yml&lt;/code&gt; file immediately with your new path or tool requirements.&lt;/p&gt; &#xA;&lt;p&gt;You can upgrade to the latest version of Ceedling at any time, automatically gaining access to the packaged Unity and CMock that come with it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gem update ceedling&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;Are you just getting started with Ceedling? Maybe you&#39;d like your project to be installed with some of its handy documentation? No problem! You can do this when you create a new project.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ceedling new --docs MyAwesomeProject&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Bonding Your Tools And Project&lt;/h1&gt; &#xA;&lt;p&gt;Ceedling can deploy all of its guts into the project as well. This allows it to be used without having to worry about external dependencies. You don&#39;t have to worry about Ceedling changing for this particular project just because you updated your gems... no need to worry about changes in Unity or CMock breaking your build in the future. If you&#39;d like to use Ceedling this way, tell it you want a local copy when you create your project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ceedling new --local YourNewProjectName&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will install all of Unity, CMock, and Ceedling into a new folder named &lt;code&gt;vendor&lt;/code&gt; inside your project &lt;code&gt;YourNewProjectName&lt;/code&gt;. It will still create the simple directory structure for you with &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; folders.&lt;/p&gt; &#xA;&lt;p&gt;SCORE!&lt;/p&gt; &#xA;&lt;p&gt;If you want to force a locally installed version of Ceedling to upgrade to match your latest gem later, it&#39;s easy! Just issue the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ceedling upgrade --local YourNewProjectName&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Just like the &lt;code&gt;new&lt;/code&gt; command, it&#39;s called from the parent directory of your project.&lt;/p&gt; &#xA;&lt;p&gt;Are you afraid of losing all your local changes when this happens? You can keep Ceedling from updating your project file by issuing &lt;code&gt;no_configs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ceedling upgrade --local --no_configs TheProject&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Git Integration&lt;/h1&gt; &#xA;&lt;p&gt;Are you using Git? You might want to automatically have Ceedling create a &lt;code&gt;gitignore&lt;/code&gt; file for you by adding &lt;code&gt;--gitignore&lt;/code&gt; to your &lt;code&gt;new&lt;/code&gt; call.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;HAPPY TESTING!&lt;/em&gt;&lt;/p&gt;</summary>
  </entry>
</feed>