<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-24T01:58:51Z</updated>
  <subtitle>Weekly Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bensheldon/good_job</title>
    <updated>2023-12-24T01:58:51Z</updated>
    <id>tag:github.com,2023-12-24:/bensheldon/good_job</id>
    <link href="https://github.com/bensheldon/good_job" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Multithreaded, Postgres-based, Active Job backend for Ruby on Rails.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GoodJob&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://rubygems.org/gems/good_job&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/good_job.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bensheldon/good_job/actions/workflows/test.yml?query=branch%3Amain&#34;&gt;&lt;img src=&#34;https://github.com/bensheldon/good_job/actions/workflows/test.yml/badge.svg?branch=main&#34; alt=&#34;Test Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.ruby-toolbox.com/projects/good_job&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/dynamic/json?color=blue&amp;amp;label=Ruby%20Toolbox&amp;amp;query=%24.projects%5B0%5D.score&amp;amp;url=https%3A%2F%2Fwww.ruby-toolbox.com%2Fapi%2Fprojects%2Fcompare%2Fgood_job&amp;amp;logo=data:image/svg+xml;base64,PHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgZm9jdXNhYmxlPSJmYWxzZSIgZGF0YS1wcmVmaXg9ImZhcyIgZGF0YS1pY29uPSJmbGFzayIgY2xhc3M9InN2Zy1pbmxpbmUtLWZhIGZhLWZsYXNrIGZhLXctMTQiIHJvbGU9ImltZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgNDQ4IDUxMiI+PHBhdGggZmlsbD0id2hpdGUiIGQ9Ik00MzcuMiA0MDMuNUwzMjAgMjE1VjY0aDhjMTMuMyAwIDI0LTEwLjcgMjQtMjRWMjRjMC0xMy4zLTEwLjctMjQtMjQtMjRIMTIwYy0xMy4zIDAtMjQgMTAuNy0yNCAyNHYxNmMwIDEzLjMgMTAuNyAyNCAyNCAyNGg4djE1MUwxMC44IDQwMy41Qy0xOC41IDQ1MC42IDE1LjMgNTEyIDcwLjkgNTEyaDMwNi4yYzU1LjcgMCA4OS40LTYxLjUgNjAuMS0xMDguNXpNMTM3LjkgMzIwbDQ4LjItNzcuNmMzLjctNS4yIDUuOC0xMS42IDUuOC0xOC40VjY0aDY0djE2MGMwIDYuOSAyLjIgMTMuMiA1LjggMTguNGw0OC4yIDc3LjZoLTE3MnoiPjwvcGF0aD48L3N2Zz4=&#34; alt=&#34;Ruby Toolbox&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;GoodJob is a multithreaded, Postgres-based, Active Job backend for Ruby on Rails.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Inspired by &lt;a href=&#34;https://github.com/collectiveidea/delayed_job&#34;&gt;Delayed::Job&lt;/a&gt; and &lt;a href=&#34;https://github.com/que-rb/que&#34;&gt;Que&lt;/a&gt;, GoodJob is designed for maximum compatibility with Ruby on Rails, Active Job, and Postgres to be simple and performant for most workloads.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Designed for Active Job.&lt;/strong&gt; Complete support for &lt;a href=&#34;https://edgeguides.rubyonrails.org/active_job_basics.html&#34;&gt;async, queues, delays, priorities, timeouts, and retries&lt;/a&gt; with near-zero configuration.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Built for Rails.&lt;/strong&gt; Fully adopts Ruby on Rails &lt;a href=&#34;https://guides.rubyonrails.org/threading_and_code_execution.html&#34;&gt;threading and code execution guidelines&lt;/a&gt; with &lt;a href=&#34;https://github.com/ruby-concurrency/concurrent-ruby&#34;&gt;Concurrent::Ruby&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Backed by Postgres.&lt;/strong&gt; Relies upon Postgres integrity, session-level Advisory Locks to provide run-once safety and stay within the limits of &lt;code&gt;schema.rb&lt;/code&gt;, and LISTEN/NOTIFY to reduce queuing latency.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;For most workloads.&lt;/strong&gt; Targets full-stack teams, economy-minded solo developers, and applications that enqueue 1-million jobs/day and more.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more of the story of GoodJob, read the &lt;a href=&#34;https://island94.org/2020/07/introducing-goodjob-1-0&#34;&gt;introductory blog post&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;details markdown=&#34;1&#34;&gt; &#xA; &lt;summary&gt;&lt;strong&gt;üìä Comparison of GoodJob with other job queue backends (click to expand)&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;table&gt; &#xA;  &lt;thead&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;th&gt;&lt;/th&gt; &#xA;    &lt;th&gt;Queues, priority, retries&lt;/th&gt; &#xA;    &lt;th&gt;Database&lt;/th&gt; &#xA;    &lt;th&gt;Concurrency&lt;/th&gt; &#xA;    &lt;th&gt;Reliability/Integrity&lt;/th&gt; &#xA;    &lt;th&gt;Latency&lt;/th&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/thead&gt; &#xA;  &lt;tbody&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;strong&gt;GoodJob&lt;/strong&gt;&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Yes&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Postgres&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Multithreaded&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ ACID, Advisory Locks&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Postgres LISTEN/NOTIFY&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;strong&gt;Que&lt;/strong&gt;&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Yes&lt;/td&gt; &#xA;    &lt;td&gt;üî∂Ô∏è Postgres, requires &lt;code&gt;structure.sql&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Multithreaded&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ ACID, Advisory Locks&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Postgres LISTEN/NOTIFY&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;strong&gt;Delayed Job&lt;/strong&gt;&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Yes&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Postgres&lt;/td&gt; &#xA;    &lt;td&gt;üî¥ Single-threaded&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ ACID, record-based&lt;/td&gt; &#xA;    &lt;td&gt;üî∂ Polling&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;strong&gt;Sidekiq&lt;/strong&gt;&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Yes&lt;/td&gt; &#xA;    &lt;td&gt;üî¥ Redis&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Multithreaded&lt;/td&gt; &#xA;    &lt;td&gt;üî¥ Crashes lose jobs&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Redis BRPOP&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;strong&gt;Sidekiq Pro&lt;/strong&gt;&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Yes&lt;/td&gt; &#xA;    &lt;td&gt;üî¥ Redis&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Multithreaded&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Redis RPOPLPUSH&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Redis RPOPLPUSH&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/tbody&gt; &#xA; &lt;/table&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#set-up&#34;&gt;Set up&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#compatibility&#34;&gt;Compatibility&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#configuration&#34;&gt;Configuration&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#command-line-options&#34;&gt;Command-line options&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#good_job-start&#34;&gt;&lt;code&gt;good_job start&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#good_job-cleanup_preserved_jobs&#34;&gt;&lt;code&gt;good_job cleanup_preserved_jobs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#configuration-options&#34;&gt;Configuration options&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#global-options&#34;&gt;Global options&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#dashboard&#34;&gt;Dashboard&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#api-only-rails-applications&#34;&gt;API-only Rails applications&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#live-polling&#34;&gt;Live polling&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#job-priority&#34;&gt;Job priority&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#concurrency-controls&#34;&gt;Concurrency controls&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#how-concurrency-controls-work&#34;&gt;How concurrency controls work&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#cron-style-repeatingrecurring-jobs&#34;&gt;Cron-style repeating/recurring jobs&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#bulk-enqueue&#34;&gt;Bulk enqueue&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#batches&#34;&gt;Batches&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#updating&#34;&gt;Updating&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#upgrading-minor-versions&#34;&gt;Upgrading minor versions&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#upgrading-v2-to-v3&#34;&gt;Upgrading v2 to v3&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#upgrading-v1-to-v2&#34;&gt;Upgrading v1 to v2&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#go-deeper&#34;&gt;Go deeper&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#exceptions-retries-and-reliability&#34;&gt;Exceptions, retries, and reliability&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#exceptions&#34;&gt;Exceptions&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#retries&#34;&gt;Retries&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#action-mailer-retries&#34;&gt;Action Mailer retries&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#interrupts&#34;&gt;Interrupts&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#timeouts&#34;&gt;Timeouts&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#optimize-queues-threads-and-processes&#34;&gt;Optimize queues, threads, and processes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#database-connections&#34;&gt;Database connections&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#production-setup&#34;&gt;Production setup&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#queue-performance-with-queue-select-limit&#34;&gt;Queue performance with Queue Select Limit&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#execute-jobs-async--in-process&#34;&gt;Execute jobs async / in-process&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#migrate-to-goodjob-from-a-different-active-job-backend&#34;&gt;Migrate to GoodJob from a different Active Job backend&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#monitor-and-preserve-worked-jobs&#34;&gt;Monitor and preserve worked jobs&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#write-tests&#34;&gt;Write tests&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#pgbouncer-compatibility&#34;&gt;PgBouncer compatibility&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#cli-http-health-check-probes&#34;&gt;CLI HTTP health check probes&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#contribute&#34;&gt;Contribute&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#gem-development&#34;&gt;Gem development&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#development-setup&#34;&gt;Development setup&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#rails-development-harness&#34;&gt;Rails development harness&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#running-tests&#34;&gt;Running tests&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#release&#34;&gt;Release&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Set up&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Add &lt;code&gt;good_job&lt;/code&gt; to your application&#39;s Gemfile and install the gem:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;bundle add good_job&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run the GoodJob install generator. This will generate a database migration to create a table for GoodJob&#39;s job records:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g good_job:install&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Run the migration:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Optional: If using Rails&#39; multiple databases with the &lt;code&gt;migrations_paths&lt;/code&gt; configuration option, use the &lt;code&gt;--database&lt;/code&gt; option:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g good_job:install --database animals&#xA;bin/rails db:migrate:animals&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Configure the Active Job adapter:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/application.rb or config/environments/{RAILS_ENV}.rb&#xA;config.active_job.queue_adapter = :good_job&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Inside of your application, queue your job üéâ:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;YourJob.perform_later&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;GoodJob supports all Active Job features:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;YourJob.set(queue: :some_queue, wait: 5.minutes, priority: 10).perform_later&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;In Rails&#39; development environment&lt;/strong&gt;, by default, GoodJob&#39;s Adapter executes jobs &lt;code&gt;async&lt;/code&gt; in a background thread pool in &lt;code&gt;rails server&lt;/code&gt;.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Because of Rails deferred autoloading, jobs enqueued via the &lt;code&gt;rails console&lt;/code&gt; may not begin executing on a separate server process until the Rails application is fully initialized by loading a web page once.&lt;/li&gt; &#xA;   &lt;li&gt;Remember, only Active Job&#39;s &lt;code&gt;perform_later&lt;/code&gt; sends jobs to the queue adapter; Active Job&#39;s &lt;code&gt;perform_now&lt;/code&gt; executes the job immediately and does not invoke the queue adapter. GoodJob is not involved in &lt;code&gt;perform_now&lt;/code&gt; jobs.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;In Rails&#39; test environment&lt;/strong&gt;, by default, GoodJob&#39;s Adapter executes jobs &lt;code&gt;inline&lt;/code&gt; immediately in the current thread.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Future-scheduled jobs can be executed with &lt;code&gt;GoodJob.perform_inline&lt;/code&gt; using using a tool like Timecop or &lt;code&gt;ActiveSupport::Testing::TimeHelpers&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Note that Active Job&#39;s TestAdapter, which powers test helpers (e.g. &lt;code&gt;assert_enqueued_with&lt;/code&gt;), may override GoodJob&#39;s Adapter in &lt;a href=&#34;https://github.com/rails/rails/issues/37270&#34;&gt;some configurations&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;In Rails&#39; production environment&lt;/strong&gt;, by default, GoodJob&#39;s Adapter enqueues jobs in &lt;code&gt;external&lt;/code&gt; mode to be executed by a separate execution process:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;By default, GoodJob separates job enqueuing from job execution so that jobs can be scaled independently of the web server. Use the GoodJob command-line tool to execute jobs:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec good_job start&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Ideally the command-line tool should be run on a separate machine or container from the web process. For example, on Heroku:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-Procfile&#34;&gt;web: rails server&#xA;worker: bundle exec good_job start&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The command-line tool supports a variety of options, see the reference below for command-line configuration.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;GoodJob can also be configured to execute jobs within the web server process to save on resources. This is useful for low-workloads when economy is paramount.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;GOOD_JOB_EXECUTION_MODE=async rails server&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Additional configuration is likely necessary, see the reference below for configuration.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ruby on Rails:&lt;/strong&gt; 6.0+&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ruby:&lt;/strong&gt; Ruby 2.6+. JRuby 9.3+&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Postgres:&lt;/strong&gt; 10.0+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h3&gt;Command-line options&lt;/h3&gt; &#xA;&lt;p&gt;There are several top-level commands available through the &lt;code&gt;good_job&lt;/code&gt; command-line tool.&lt;/p&gt; &#xA;&lt;p&gt;Configuration options are available with &lt;code&gt;help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;good_job start&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;good_job start&lt;/code&gt; executes queued jobs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle exec good_job help start&#xA;&#xA;Usage:&#xA;  good_job start&#xA;&#xA;Options:&#xA;  [--queues=QUEUE_LIST]        # Queues or pools to work from. (env var: GOOD_JOB_QUEUES, default: *)&#xA;  [--max-threads=COUNT]        # Default number of threads per pool to use for working jobs. (env var: GOOD_JOB_MAX_THREADS, default: 5)&#xA;  [--poll-interval=SECONDS]    # Interval between polls for available jobs in seconds (env var: GOOD_JOB_POLL_INTERVAL, default: 1)&#xA;  [--max-cache=COUNT]          # Maximum number of scheduled jobs to cache in memory (env var: GOOD_JOB_MAX_CACHE, default: 10000)&#xA;  [--shutdown-timeout=SECONDS] # Number of seconds to wait for jobs to finish when shutting down before stopping the thread. (env var: GOOD_JOB_SHUTDOWN_TIMEOUT, default: -1 (forever))&#xA;  [--enable-cron]              # Whether to run cron process (default: false)&#xA;  [--enable-listen-notify]     # Whether to enqueue and read jobs with Postgres LISTEN/NOTIFY (default: true)&#xA;  [--idle-timeout=SECONDS]     # Exit process when no jobs have been performed for this many seconds (env var: GOOD_JOB_IDLE_TIMEOUT, default: nil)&#xA;  [--daemonize]                # Run as a background daemon (default: false)&#xA;  [--pidfile=PIDFILE]          # Path to write daemonized Process ID (env var: GOOD_JOB_PIDFILE, default: tmp/pids/good_job.pid)&#xA;  [--probe-port=PORT]          # Port for http health check (env var: GOOD_JOB_PROBE_PORT, default: nil)&#xA;  [--queue-select-limit=COUNT] # The number of queued jobs to select when polling for a job to run. (env var: GOOD_JOB_QUEUE_SELECT_LIMIT, default: nil)&#34;&#xA;&#xA;Executes queued jobs.&#xA;&#xA;All options can be configured with environment variables.&#xA;See option descriptions for the matching environment variable name.&#xA;&#xA;== Configuring queues&#xA;&#xA;Separate multiple queues with commas; exclude queues with a leading minus;&#xA;separate isolated execution pools with semicolons and threads with colons.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;good_job cleanup_preserved_jobs&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;good_job cleanup_preserved_jobs&lt;/code&gt; destroys preserved job records. See &lt;code&gt;GoodJob.preserve_job_records&lt;/code&gt; for when this command is useful.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle exec good_job help cleanup_preserved_jobs&#xA;&#xA;Usage:&#xA;  good_job cleanup_preserved_jobs&#xA;&#xA;Options:&#xA;  [--before-seconds-ago=SECONDS] # Destroy records finished more than this many seconds ago (env var:  GOOD_JOB_CLEANUP_PRESERVED_JOBS_BEFORE_SECONDS_AGO, default: 1209600 (14 days))&#xA;&#xA;Manually destroys preserved job records.&#xA;&#xA;By default, GoodJob automatically destroys job records when the job is performed&#xA;and this command is not required to be used.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuration options&lt;/h3&gt; &#xA;&lt;p&gt;Active Job configuration depends on where the code is placed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;config.active_job.queue_adapter = :good_job&lt;/code&gt; within &lt;code&gt;config/application.rb&lt;/code&gt; or &lt;code&gt;config/environments/*.rb&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ActiveJob::Base.queue_adapter = :good_job&lt;/code&gt; within an initializer (e.g. &lt;code&gt;config/initializers/active_job.rb&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;GoodJob configuration can be placed within Rails &lt;code&gt;config&lt;/code&gt; directory for all environments (&lt;code&gt;config/application.rb&lt;/code&gt;), within a particular environment (e.g. &lt;code&gt;config/environments/development.rb&lt;/code&gt;), or within an initializer (e.g. &lt;code&gt;config/initializers/good_job.rb&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Configuration examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb OR config/application.rb OR config/environments/{RAILS_ENV}.rb&#xA;&#xA;Rails.application.configure do&#xA;  # Configure options individually...&#xA;  config.good_job.preserve_job_records = true&#xA;  config.good_job.retry_on_unhandled_error = false&#xA;  config.good_job.on_thread_error = -&amp;gt; (exception) { Rails.error.report(exception) }&#xA;  config.good_job.execution_mode = :async&#xA;  config.good_job.queues = &#39;*&#39;&#xA;  config.good_job.max_threads = 5&#xA;  config.good_job.poll_interval = 30 # seconds&#xA;  config.good_job.shutdown_timeout = 25 # seconds&#xA;  config.good_job.enable_cron = true&#xA;  config.good_job.cron = { example: { cron: &#39;0 * * * *&#39;, class: &#39;ExampleJob&#39;  } }&#xA;  config.good_job.dashboard_default_locale = :en&#xA;&#xA;  # ...or all at once.&#xA;  config.good_job = {&#xA;    preserve_job_records: true,&#xA;    retry_on_unhandled_error: false,&#xA;    on_thread_error: -&amp;gt; (exception) { Rails.error.report(exception) },&#xA;    execution_mode: :async,&#xA;    queues: &#39;*&#39;,&#xA;    max_threads: 5,&#xA;    poll_interval: 30,&#xA;    shutdown_timeout: 25,&#xA;    enable_cron: true,&#xA;    cron: {&#xA;      example: {&#xA;        cron: &#39;0 * * * *&#39;,&#xA;        class: &#39;ExampleJob&#39;&#xA;      },&#xA;    },&#xA;    dashboard_default_locale: :en,&#xA;  }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Available configuration options are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;execution_mode&lt;/code&gt; (symbol) specifies how and where jobs should be executed. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_EXECUTION_MODE&lt;/code&gt;. It can be any one of:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;:inline&lt;/code&gt; executes jobs immediately in whatever process queued them (usually the web server process). This should only be used in test and development environments.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:external&lt;/code&gt; causes the adapter to enqueue jobs, but not execute them. When using this option (the default for production environments), you‚Äôll need to use the command-line tool to actually execute your jobs.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:async&lt;/code&gt; (or &lt;code&gt;:async_server&lt;/code&gt;) executes jobs in separate threads within the Rails web server process (&lt;code&gt;bundle exec rails server&lt;/code&gt;). It can be more economical for small workloads because you don‚Äôt need a separate machine or environment for running your jobs, but if your web server is under heavy load or your jobs require a lot of resources, you should choose &lt;code&gt;:external&lt;/code&gt; instead. When not in the Rails web server, jobs will execute in &lt;code&gt;:external&lt;/code&gt; mode to ensure jobs are not executed within &lt;code&gt;rails console&lt;/code&gt;, &lt;code&gt;rails db:migrate&lt;/code&gt;, &lt;code&gt;rails assets:prepare&lt;/code&gt;, etc.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:async_all&lt;/code&gt; executes jobs in separate threads in &lt;em&gt;any&lt;/em&gt; Rails process.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;queues&lt;/code&gt; (string) sets queues or pools to execute jobs. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_QUEUES&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;max_threads&lt;/code&gt; (integer) sets the default number of threads per pool to use for working jobs. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_MAX_THREADS&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;poll_interval&lt;/code&gt; (integer) sets the number of seconds between polls for jobs when &lt;code&gt;execution_mode&lt;/code&gt; is set to &lt;code&gt;:async&lt;/code&gt;. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_POLL_INTERVAL&lt;/code&gt;. A poll interval of &lt;code&gt;-1&lt;/code&gt; disables polling completely.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;max_cache&lt;/code&gt; (integer) sets the maximum number of scheduled jobs that will be stored in memory to reduce execution latency when also polling for scheduled jobs. Caching 10,000 scheduled jobs uses approximately 20MB of memory. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_MAX_CACHE&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;shutdown_timeout&lt;/code&gt; (integer) number of seconds to wait for jobs to finish when shutting down before stopping the thread. Defaults to forever: &lt;code&gt;-1&lt;/code&gt;. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_SHUTDOWN_TIMEOUT&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;enable_cron&lt;/code&gt; (boolean) whether to run cron process. Defaults to &lt;code&gt;false&lt;/code&gt;. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_ENABLE_CRON&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;enable_listen_notify&lt;/code&gt; (boolean) whether to enqueue and read jobs with Postgres LISTEN/NOTIFY. Defaults to &lt;code&gt;true&lt;/code&gt;. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_ENABLE_LISTEN_NOTIFY&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cron&lt;/code&gt; (hash) cron configuration. Defaults to &lt;code&gt;{}&lt;/code&gt;. You can also set this as a JSON string with the environment variable &lt;code&gt;GOOD_JOB_CRON&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cleanup_discarded_jobs&lt;/code&gt; (boolean) whether to destroy discarded jobs when cleaning up preserved jobs using the &lt;code&gt;$ good_job cleanup_preserved_jobs&lt;/code&gt; CLI command or calling &lt;code&gt;GoodJob.cleanup_preserved_jobs&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;. Can also be set with the environment variable &lt;code&gt;GOOD_JOB_CLEANUP_DISCARDED_JOBS&lt;/code&gt;. &lt;em&gt;This configuration is only used when {GoodJob.preserve_job_records} is &lt;code&gt;true&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cleanup_preserved_jobs_before_seconds_ago&lt;/code&gt; (integer) number of seconds to preserve jobs when using the &lt;code&gt;$ good_job cleanup_preserved_jobs&lt;/code&gt; CLI command or calling &lt;code&gt;GoodJob.cleanup_preserved_jobs&lt;/code&gt;. Defaults to &lt;code&gt;1209600&lt;/code&gt; (14 days). Can also be set with the environment variable &lt;code&gt;GOOD_JOB_CLEANUP_PRESERVED_JOBS_BEFORE_SECONDS_AGO&lt;/code&gt;. &lt;em&gt;This configuration is only used when {GoodJob.preserve_job_records} is &lt;code&gt;true&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cleanup_interval_jobs&lt;/code&gt; (integer) Number of jobs a Scheduler will execute before cleaning up preserved jobs. Defaults to &lt;code&gt;1000&lt;/code&gt;. Disable with &lt;code&gt;false&lt;/code&gt;. Can also be set with the environment variable &lt;code&gt;GOOD_JOB_CLEANUP_INTERVAL_JOBS&lt;/code&gt; and disabled with &lt;code&gt;0&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cleanup_interval_seconds&lt;/code&gt; (integer) Number of seconds a Scheduler will wait before cleaning up preserved jobs. Defaults to &lt;code&gt;600&lt;/code&gt; (10 minutes). Disable with &lt;code&gt;false&lt;/code&gt;. Can also be set with the environment variable &lt;code&gt;GOOD_JOB_CLEANUP_INTERVAL_SECONDS&lt;/code&gt; and disabled with &lt;code&gt;0&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;inline_execution_respects_schedule&lt;/code&gt; (boolean) Opt-in to future behavior of inline execution respecting scheduled jobs. Defaults to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;logger&lt;/code&gt; (&lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveSupport/Logger.html&#34;&gt;Rails Logger&lt;/a&gt;) lets you set a custom logger for GoodJob. It should be an instance of a Rails &lt;code&gt;Logger&lt;/code&gt; (Default: &lt;code&gt;Rails.logger&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;preserve_job_records&lt;/code&gt; (boolean) keeps job records in your database even after jobs are completed. (Default: &lt;code&gt;true&lt;/code&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;smaller_number_is_higher_priority&lt;/code&gt; (boolean) allows you to specifiy that jobs should be run in ascending order of priority (smallest priority numbers first). This will be enabled by default in the next major version of GoodJob (v4.0), but jobs with the highest priority number are run first by default in all earlier versions of GoodJob.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;retry_on_unhandled_error&lt;/code&gt; (boolean) causes jobs to be re-queued and retried if they raise an instance of &lt;code&gt;StandardError&lt;/code&gt;. Be advised this may lead to jobs being repeated infinitely (&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#retries&#34;&gt;see below for more on retries&lt;/a&gt;). Instances of &lt;code&gt;Exception&lt;/code&gt;, like SIGINT, will &lt;em&gt;always&lt;/em&gt; be retried, regardless of this attribute‚Äôs value. (Default: &lt;code&gt;false&lt;/code&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;on_thread_error&lt;/code&gt; (proc, lambda, or callable) will be called when there is an Exception. It can be useful for logging errors to bug tracking services, like Sentry or Airbrake. Example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.good_job.on_thread_error = -&amp;gt; (exception) { Rails.error.report(exception) }&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default, GoodJob configures the following execution modes per environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#xA;# config/environments/development.rb&#xA;config.active_job.queue_adapter = :good_job&#xA;config.good_job.execution_mode = :async&#xA;&#xA;# config/environments/test.rb&#xA;config.active_job.queue_adapter = :good_job&#xA;config.good_job.execution_mode = :inline&#xA;&#xA;# config/environments/production.rb&#xA;config.active_job.queue_adapter = :good_job&#xA;config.good_job.execution_mode = :external&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Global options&lt;/h3&gt; &#xA;&lt;p&gt;Good Job‚Äôs general behavior can also be configured via attributes directly on the &lt;code&gt;GoodJob&lt;/code&gt; module:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;GoodJob.configure_active_record { ... }&lt;/code&gt;&lt;/strong&gt; Inject Active Record configuration into GoodJob&#39;s base model, for example, when using &lt;a href=&#34;https://guides.rubyonrails.org/active_record_multiple_databases.html&#34;&gt;multiple databases with Active Record&lt;/a&gt; or when other custom configuration is necessary for the Active Record model to connect to the Postgres database. Example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;GoodJob.configure_active_record do&#xA;  connects_to database: :special_database&#xA;  self.table_name_prefix = &#34;special_application_&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;GoodJob.active_record_parent_class&lt;/code&gt;&lt;/strong&gt; (string) Alternatively, modify the Active Record parent class inherited by GoodJob&#39;s Active Record model &lt;code&gt;GoodJob::Job&lt;/code&gt; (defaults to &lt;code&gt;&#34;ActiveRecord::Base&#34;&lt;/code&gt;). Configure this &lt;em&gt;The value must be a String to avoid premature initialization of Active Record.&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You‚Äôll generally want to configure these in &lt;code&gt;config/initializers/good_job.rb&lt;/code&gt;, like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;GoodJob.active_record_parent_class = &#34;ApplicationRecord&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following options are also configurable via accessors, but you are encouraged to use the configuration attributes instead because these may be deprecated and removed in the future:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;GoodJob.logger&lt;/code&gt;&lt;/strong&gt; (&lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveSupport/Logger.html&#34;&gt;Rails Logger&lt;/a&gt;) lets you set a custom logger for GoodJob. It should be an instance of a Rails &lt;code&gt;Logger&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;GoodJob.preserve_job_records&lt;/code&gt;&lt;/strong&gt; (boolean) keeps job records in your database even after jobs are completed. (Default: &lt;code&gt;true&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;GoodJob.retry_on_unhandled_error&lt;/code&gt;&lt;/strong&gt; (boolean) causes jobs to be re-queued and retried if they raise an instance of &lt;code&gt;StandardError&lt;/code&gt;. Be advised this may lead to jobs being repeated infinitely (&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#retries&#34;&gt;see below for more on retries&lt;/a&gt;). Instances of &lt;code&gt;Exception&lt;/code&gt;, like SIGINT, will &lt;em&gt;always&lt;/em&gt; be retried, regardless of this attribute‚Äôs value. (Default: &lt;code&gt;false&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;GoodJob.on_thread_error&lt;/code&gt;&lt;/strong&gt; (proc, lambda, or callable) will be called when there is an Exception. It can be useful for logging errors to bug tracking services, like Sentry or Airbrake.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Dashboard&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/bensheldon/good_job/raw/main/SCREENSHOT.png&#34; alt=&#34;Dashboard UI&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;üöß GoodJob&#39;s dashboard is a work in progress. Please contribute ideas and code on &lt;a href=&#34;https://github.com/bensheldon/good_job/issues&#34;&gt;Github&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;GoodJob includes a Dashboard as a mountable &lt;code&gt;Rails::Engine&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Mount the engine in your &lt;code&gt;config/routes.rb&lt;/code&gt; file. The following will mount it at &lt;code&gt;http://example.com/good_job&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/routes.rb&#xA;# ...&#xA;mount GoodJob::Engine =&amp;gt; &#39;good_job&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Configure authentication. Because jobs can potentially contain sensitive information, you should authorize access. For example, using Devise&#39;s &lt;code&gt;authenticate&lt;/code&gt; helper, that might look like:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/routes.rb&#xA;# ...&#xA;authenticate :user, -&amp;gt;(user) { user.admin? } do&#xA;  mount GoodJob::Engine =&amp;gt; &#39;good_job&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Another option is using basic auth like this:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;GoodJob::Engine.middleware.use(Rack::Auth::Basic) do |username, password|&#xA;  ActiveSupport::SecurityUtils.secure_compare(Rails.application.credentials.good_job_username, username) &amp;amp;&amp;amp;&#xA;    ActiveSupport::SecurityUtils.secure_compare(Rails.application.credentials.good_job_password, password)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;To support custom authentication, you can extend GoodJob&#39;s &lt;code&gt;ApplicationController&lt;/code&gt; using the following hook:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;&#xA;ActiveSupport.on_load(:good_job_application_controller) do&#xA;  # context here is GoodJob::ApplicationController&#xA;&#xA;  before_action do&#xA;    raise ActionController::RoutingError.new(&#39;Not Found&#39;) unless current_user&amp;amp;.admin?&#xA;  end&#xA;&#xA;  def current_user&#xA;    # load current user&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;em&gt;To view finished jobs (succeeded and discarded) on the Dashboard, GoodJob must be configured to preserve job records. Preservation is enabled by default.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Troubleshooting the Dashboard:&lt;/strong&gt; Some applications are unable to autoload the Goodjob Engine. To work around this, explicitly require the Engine at the top of your &lt;code&gt;config/application.rb&lt;/code&gt; file, immediately after Rails is required and before Bundler requires the Rails&#39; groups.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/application.rb&#xA;require_relative &#39;boot&#39;&#xA;require &#39;rails/all&#39;&#xA;require &#39;good_job/engine&#39; # &amp;lt;= Add this line&#xA;# ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;API-only Rails applications&lt;/h4&gt; &#xA;&lt;p&gt;API-only Rails applications may not have all of the required Rack middleware for the GoodJob Dashboard to function. To re-add the middleware:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/application.rb&#xA;module MyApp&#xA;  class Application &amp;lt; Rails::Application&#xA;    #...&#xA;    config.middleware.use Rack::MethodOverride&#xA;    config.middleware.use ActionDispatch::Flash&#xA;    config.middleware.use ActionDispatch::Cookies&#xA;    config.middleware.use ActionDispatch::Session::CookieStore&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Live polling&lt;/h4&gt; &#xA;&lt;p&gt;The Dashboard can be set to automatically refresh by checking &#34;Live Poll&#34; in the Dashboard header, or by setting &lt;code&gt;?poll=10&lt;/code&gt; with the interval in seconds (default 30 seconds).&lt;/p&gt; &#xA;&lt;h3&gt;Job priority&lt;/h3&gt; &#xA;&lt;p&gt;Higher priority numbers run first in all versions of GoodJob v3.x and below. GoodJob v4.x will change job &lt;code&gt;priority&lt;/code&gt; to give smaller numbers higher priority (default: &lt;code&gt;0&lt;/code&gt;), in accordance with Active Job&#39;s definition of priority (see #524). To opt-in to this behavior now, set &lt;code&gt;config.good_job.smaller_number_is_higher_priority = true&lt;/code&gt; in your GoodJob initializer or &lt;code&gt;application.rb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Labelled jobs&lt;/h3&gt; &#xA;&lt;p&gt;Labels are the recommended way to add context or metadata to specific jobs. For example, all jobs that have a dependency on an email service could be labeled &lt;code&gt;email&lt;/code&gt;. Using labels requires adding the Active Job extension &lt;code&gt;GoodJob::ActiveJobExtensions::Labels&lt;/code&gt; to your job class.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationRecord &amp;lt; ActiveJob::Base&#xA;  include GoodJob::ActiveJobExtensions::Labels&#xA;end&#xA;&#xA;# Add a default label to every job within the class&#xA;class WelcomeJob &amp;lt; ApplicationRecord&#xA;  self.good_job_labels = [&#34;email&#34;]&#xA;&#xA;  def perform&#xA;    # Labels can be inspected from within the job&#xA;    puts good_job_labels # =&amp;gt; [&#34;email&#34;]&#xA;  end&#xA;end&#xA;&#xA;# Or add to individual jobs when enqueued&#xA;WelcomeJob.set(good_job_labels: [&#34;email&#34;]).perform_later&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Labels can be used to search jobs in the Dashboard. For example, to find all jobs labeled &lt;code&gt;email&lt;/code&gt;, search for &lt;code&gt;email&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Concurrency controls&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob can extend Active Job to provide limits on concurrently running jobs, either at time of &lt;em&gt;enqueue&lt;/em&gt; or at &lt;em&gt;perform&lt;/em&gt;. Limiting concurrency can help prevent duplicate, double or unnecessary jobs from being enqueued, or race conditions when performing, for example when interacting with 3rd-party APIs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyJob &amp;lt; ApplicationJob&#xA;  include GoodJob::ActiveJobExtensions::Concurrency&#xA;&#xA;  good_job_control_concurrency_with(&#xA;    # Maximum number of unfinished jobs to allow with the concurrency key&#xA;    # Can be an Integer or Lambda/Proc that is invoked in the context of the job&#xA;    total_limit: 1,&#xA;&#xA;    # Or, if more control is needed:&#xA;    # Maximum number of jobs with the concurrency key to be&#xA;    # concurrently enqueued (excludes performing jobs)&#xA;    # Can be an Integer or Lambda/Proc that is invoked in the context of the job&#xA;    enqueue_limit: 2,&#xA;&#xA;    # Maximum number of jobs with the concurrency key to be&#xA;    # concurrently performed (excludes enqueued jobs)&#xA;    # Can be an Integer or Lambda/Proc that is invoked in the context of the job&#xA;    perform_limit: 1,&#xA;&#xA;    # Note: Under heavy load, the total number of jobs may exceed the&#xA;    # sum of `enqueue_limit` and `perform_limit` because of race conditions&#xA;    # caused by imperfectly disjunctive states. If you need to constrain&#xA;    # the total number of jobs, use `total_limit` instead. See #378.&#xA;&#xA;    # A unique key to be globally locked against.&#xA;    # Can be String or Lambda/Proc that is invoked in the context of the job.&#xA;    # Note: Arguments passed to #perform_later can be accessed through Active Job&#39;s `arguments` method&#xA;    # which is an array containing positional arguments and, optionally, a kwarg hash.&#xA;    key: -&amp;gt; { &#34;MyJob-#{arguments.first}-#{arguments.last[:version]}&#34; } #  MyJob.perform_later(&#34;Alice&#34;, version: &#39;v2&#39;) =&amp;gt; &#34;MyJob-Alice-v2&#34;&#xA;  )&#xA;&#xA;  def perform(first_name)&#xA;    # do work&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When testing, the resulting concurrency key value can be inspected:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;job = MyJob.perform_later(&#34;Alice&#34;)&#xA;job.good_job_concurrency_key #=&amp;gt; &#34;MyJob-Alice&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How concurrency controls work&lt;/h4&gt; &#xA;&lt;p&gt;GoodJob&#39;s concurrency control strategy for &lt;code&gt;perform_limit&lt;/code&gt; is &#34;optimistic retry with an incremental backoff&#34;. The &lt;a href=&#34;https://github.com/bensheldon/good_job/raw/main/lib/good_job/active_job_extensions/concurrency.rb&#34;&gt;code is readable&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;Optimistic&#34; meaning that the implementation&#39;s performance trade-off assumes that collisions are atypical (e.g. two users enqueue the same job at the same time) rather than regular (e.g. the system enqueues thousands of colliding jobs at the same time). Depending on your concurrency requirements, you may also want to manage concurrency through the number of GoodJob threads and processes that are performing a given queue.&lt;/li&gt; &#xA; &lt;li&gt;&#34;Retry with an incremental backoff&#34; means that when &lt;code&gt;perform_limit&lt;/code&gt; is exceeded, the job will raise a &lt;code&gt;GoodJob::ActiveJobExtensions::Concurrency::ConcurrencyExceededError&lt;/code&gt; which is caught by a &lt;code&gt;retry_on&lt;/code&gt; handler which re-schedules the job to execute in the near future with an incremental backoff.&lt;/li&gt; &#xA; &lt;li&gt;First-in-first-out job execution order is not preserved when a job is retried with incremental back-off.&lt;/li&gt; &#xA; &lt;li&gt;For pessimistic usecases that collisions are expected, use number of threads/processes (e.g., &lt;code&gt;good_job --queues &#34;serial:1;-serial:5&#34;&lt;/code&gt;) to control concurrency. It is also a good idea to use &lt;code&gt;perform_limit&lt;/code&gt; as backstop.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Cron-style repeating/recurring jobs&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob can enqueue Active Job jobs on a recurring basis that can be used as a replacement for cron.&lt;/p&gt; &#xA;&lt;p&gt;Cron-style jobs can be performed by any GoodJob process (e.g., CLI or &lt;code&gt;:async&lt;/code&gt; execution mode) that has &lt;code&gt;config.good_job.enable_cron&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;. That is, one or more job executor processes can be configured to perform recurring jobs.&lt;/p&gt; &#xA;&lt;p&gt;GoodJob&#39;s cron uses unique indexes to ensure that only a single job is enqueued at the given time interval. In order for this to work, GoodJob must preserve cron-created job records; these records will be automatically deleted like any other preserved record.&lt;/p&gt; &#xA;&lt;p&gt;Cron-format is parsed by the &lt;a href=&#34;https://github.com/floraison/fugit&#34;&gt;&lt;code&gt;fugit&lt;/code&gt;&lt;/a&gt; gem, which has support for seconds-level resolution (e.g. &lt;code&gt;* * * * * *&lt;/code&gt;) and natural language parsing (e.g. &lt;code&gt;every second&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;If you use the &lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#dashboard&#34;&gt;Dashboard&lt;/a&gt; the scheduled tasks can be viewed in the &#39;cron&#39; menu. In this view you can also disable a task or run/enqueue a task immediately.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/environments/application.rb or a specific environment e.g. production.rb&#xA;&#xA;# Enable cron in this process, e.g., only run on the first Heroku worker process&#xA;config.good_job.enable_cron = ENV[&#39;DYNO&#39;] == &#39;worker.1&#39; # or `true` or via $GOOD_JOB_ENABLE_CRON&#xA;&#xA;# Configure cron with a hash that has a unique key for each recurring job&#xA;config.good_job.cron = {&#xA;  # Every 15 minutes, enqueue `ExampleJob.set(priority: -10).perform_later(42, &#34;life&#34;, name: &#34;Alice&#34;)`&#xA;  frequent_task: { # each recurring job must have a unique key&#xA;    cron: &#34;*/15 * * * *&#34;, # cron-style scheduling format by fugit gem&#xA;    class: &#34;ExampleJob&#34;, # name of the job class as a String; must reference an Active Job job class&#xA;    args: [42, &#34;life&#34;], # positional arguments to pass to the job; can also be a proc e.g. `-&amp;gt; { [Time.now] }`&#xA;    kwargs: { name: &#34;Alice&#34; }, # keyword arguments to pass to the job; can also be a proc e.g. `-&amp;gt; { { name: NAMES.sample } }`&#xA;    set: { priority: -10 }, # additional Active Job properties; can also be a lambda/proc e.g. `-&amp;gt; { { priority: [1,2].sample } }`&#xA;    description: &#34;Something helpful&#34;, # optional description that appears in Dashboard&#xA;  },&#xA;  another_task: {&#xA;    cron: &#34;0 0,12 * * *&#34;,&#xA;    class: &#34;AnotherJob&#34;,&#xA;  },&#xA;  complex_schedule: {&#xA;    class: &#34;ComplexScheduleJob&#34;,&#xA;    cron: -&amp;gt; (last_ran) { (last_ran.blank? ? Time.now : last_ran + 14.hours).at_beginning_of_minute }&#xA;  }&#xA;  # etc.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Bulk enqueue&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob&#39;s Bulk-enqueue functionality can buffer and enqueue multiple jobs at once, using a single INSERT statement. This can more performant when enqueuing a large number of jobs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Capture jobs using `.perform_later`:&#xA;active_jobs = GoodJob::Bulk.enqueue do&#xA;  MyJob.perform_later&#xA;  AnotherJob.perform_later&#xA;  # If an exception is raised within this block, no jobs will be inserted.&#xA;end&#xA;&#xA;# All Active Job instances are returned from GoodJob::Bulk.enqueue.&#xA;# Jobs that have been successfully enqueued have a `provider_job_id` set.&#xA;active_jobs.all?(&amp;amp;:provider_job_id)&#xA;&#xA;# Bulk enqueue Active Job instances directly without using `.perform_later`:&#xA;GoodJob::Bulk.enqueue(MyJob.new, AnotherJob.new)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Batches&lt;/h3&gt; &#xA;&lt;p&gt;Batches track a set of jobs, and enqueue an optional callback job when all of the jobs have finished (succeeded or discarded).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;A simple example that enqueues your &lt;code&gt;MyBatchCallbackJob&lt;/code&gt; after the two jobs have finished, and passes along the current user as a batch property:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;GoodJob::Batch.enqueue(on_finish: MyBatchCallbackJob, user: current_user) do&#xA;  MyJob.perform_later&#xA;  OtherJob.perform_later&#xA;end&#xA;&#xA;# When these jobs have finished, it will enqueue your `MyBatchCallbackJob.perform_later(batch, options)`&#xA;class MyBatchCallbackJob &amp;lt; ApplicationJob&#xA;  # Callback jobs must accept a `batch` and `options` argument&#xA;  def perform(batch, params)&#xA;    # The batch object will contain the Batch&#39;s properties, which are mutable&#xA;    batch.properties[:user] # =&amp;gt; &amp;lt;User id: 1, ...&amp;gt;&#xA;&#xA;    # Params is a hash containing additional context (more may be added in the future)&#xA;    params[:event] # =&amp;gt; :finish, :success, :discard&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Jobs can be added to an existing batch. Jobs in a batch are enqueued and performed immediately/asynchronously. The final callback job will not be enqueued until &lt;code&gt;GoodJob::Batch#enqueue&lt;/code&gt; is called.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;batch = GoodJob::Batch.new&#xA;batch.add do&#xA;  10.times { MyJob.perform_later }&#xA;end&#xA;&#xA;batch.add do&#xA;  10.times { OtherJob.perform_later }&#xA;end&#xA;batch.enqueue(on_finish: MyBatchCallbackJob, age: 42)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you need to access the batch within a job that is part of the batch, include &lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/lib/good_job/active_job_extensions/batches.rb&#34;&gt;&lt;code&gt;GoodJob::ActiveJobExtensions::Batches&lt;/code&gt;&lt;/a&gt; in your job class:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class MyJob &amp;lt; ApplicationJob&#xA;    include GoodJob::ActiveJobExtensions::Batches&#xA;&#xA;    def perform&#xA;      self.batch # =&amp;gt; &amp;lt;GoodJob::Batch id: 1, ...&amp;gt;&#xA;    end&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/app/models/good_job/batch.rb&#34;&gt;&lt;code&gt;GoodJob::Batch&lt;/code&gt;&lt;/a&gt; has a number of assignable attributes and methods:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;batch = GoodJob::Batch.new&#xA;batch.description = &#34;My batch&#34;&#xA;batch.on_finish = &#34;MyBatchCallbackJob&#34; # Callback job when all jobs have finished&#xA;batch.on_success = &#34;MyBatchCallbackJob&#34; # Callback job when/if all jobs have succeeded&#xA;batch.on_discard = &#34;MyBatchCallbackJob&#34; # Callback job when the first job in the batch is discarded&#xA;batch.callback_queue_name = &#34;special_queue&#34; # Optional queue for callback jobs, otherwise will defer to job class&#xA;batch.callback_priority = 10 # Optional priority name for callback jobs, otherwise will defer to job class&#xA;batch.properties = { age: 42 } # Custom data and state to attach to the batch&#xA;batch.add do&#xA;  MyJob.perform_later&#xA;end&#xA;batch.enqueue&#xA;&#xA;batch.discarded? # =&amp;gt; Boolean&#xA;batch.discarded_at # =&amp;gt; &amp;lt;DateTime&amp;gt;&#xA;batch.finished? # =&amp;gt; Boolean&#xA;batch.finished_at # =&amp;gt; &amp;lt;DateTime&amp;gt;&#xA;batch.succeeded? # =&amp;gt; Boolean&#xA;batch.active_jobs # =&amp;gt; Array of ActiveJob::Base-inherited jobs that are part of the batch&#xA;&#xA;batch = GoodJob::Batch.find(batch.id)&#xA;batch.description = &#34;Updated batch description&#34;&#xA;batch.save&#xA;batch.reload&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Batch callback jobs&lt;/h3&gt; &#xA;&lt;p&gt;Batch callbacks are Active Job jobs that are enqueued at certain events during the execution of jobs within the batch:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:finish&lt;/code&gt; - Enqueued when all jobs in the batch have finished, after all retries. Jobs will either be discarded or succeeded.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:success&lt;/code&gt; - Enqueued only when all jobs in the batch have finished and succeeded.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:discard&lt;/code&gt; - Enqueued immediately the first time a job in the batch is discarded.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Callback jobs must accept a &lt;code&gt;batch&lt;/code&gt; and &lt;code&gt;params&lt;/code&gt; argument in their &lt;code&gt;perform&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyBatchCallbackJob &amp;lt; ApplicationJob&#xA;  def perform(batch, params)&#xA;    # The batch object will contain the Batch&#39;s properties&#xA;    batch.properties[:user] # =&amp;gt; &amp;lt;User id: 1, ...&amp;gt;&#xA;    # Batches are mutable&#xA;    batch.properties[:user] = User.find(2)&#xA;    batch.save&#xA;&#xA;    # Params is a hash containing additional context (more may be added in the future)&#xA;    params[:event] # =&amp;gt; :finish, :success, :discard&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Complex batches&lt;/h4&gt; &#xA;&lt;p&gt;Consider a multi-stage batch with both parallel and serial job steps:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD&#xA;    0{&#34;BatchJob\n{ stage: nil }&#34;}&#xA;    0 --&amp;gt; a[&#34;WorkJob]\n{ step: a }&#34;]&#xA;    0 --&amp;gt; b[&#34;WorkJob]\n{ step: b }&#34;]&#xA;    0 --&amp;gt; c[&#34;WorkJob]\n{ step: c }&#34;]&#xA;    a --&amp;gt; 1&#xA;    b --&amp;gt; 1&#xA;    c --&amp;gt; 1&#xA;    1{&#34;BatchJob\n{ stage: 1 }&#34;}&#xA;    1 --&amp;gt; d[&#34;WorkJob]\n{ step: d }&#34;]&#xA;    1 --&amp;gt; e[&#34;WorkJob]\n{ step: e }&#34;]&#xA;    e --&amp;gt; f[&#34;WorkJob]\n{ step: f }&#34;]&#xA;    d --&amp;gt; 2&#xA;    f --&amp;gt; 2&#xA;    2{&#34;BatchJob\n{ stage: 2 }&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can be implemented with a single, mutable batch job:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class WorkJob &amp;lt; ApplicationJob&#xA;  include GoodJob::ActiveJobExtensions::Batches&#xA;&#xA;  def perform(step)&#xA;    # ...&#xA;    if step == &#39;e&#39;&#xA;      batch.add { WorkJob.perform_later(&#39;f&#39;) }&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;class BatchJob &amp;lt; ApplicationJob&#xA;  def perform(batch, options)&#xA;    if batch.properties[:stage].nil?&#xA;      batch.enqueue(stage: 1) do&#xA;        WorkJob.perform_later(&#39;a&#39;)&#xA;        WorkJob.perform_later(&#39;b&#39;)&#xA;        WorkJob.perform_later(&#39;c&#39;)&#xA;      end&#xA;    elsif batch.properties[:stage] == 1&#xA;      batch.enqueue(stage: 2) do&#xA;        WorkJob.perform_later(&#39;d&#39;)&#xA;        WorkJob.perform_later(&#39;e&#39;)&#xA;      end&#xA;    elsif batch.properties[:stage] == 2&#xA;      # ...&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;GoodJob::Batch.enqueue(on_finish: BatchJob)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Other batch details&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Whether to enqueue a callback job is evaluated once the batch is in an &lt;code&gt;enqueued?&lt;/code&gt;-state by using &lt;code&gt;GoodJob::Batch.enqueue&lt;/code&gt; or &lt;code&gt;batch.enqueue&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Callback job enqueueing will be re-triggered if additional jobs are &lt;code&gt;enqueue&lt;/code&gt;&#39;d to the batch; use &lt;code&gt;add&lt;/code&gt; to add jobs to the batch without retriggering callback jobs.&lt;/li&gt; &#xA; &lt;li&gt;Callback jobs will be enqueued even if the batch contains no jobs.&lt;/li&gt; &#xA; &lt;li&gt;Callback jobs perform asynchronously. It&#39;s possible that &lt;code&gt;:finish&lt;/code&gt; and &lt;code&gt;:success&lt;/code&gt; or &lt;code&gt;:discard&lt;/code&gt; callback jobs perform at the same time. Keep this in mind when updating batch properties.&lt;/li&gt; &#xA; &lt;li&gt;Batch properties are serialized using Active Job serialization. This is flexible, but can lead to deserialization errors if a GlobalID record is directly referenced but is subsequently deleted and thus unloadable.&lt;/li&gt; &#xA; &lt;li&gt;üößBatches are a work in progress. Please let us know what would be helpful to improve their functionality and usefulness.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Updating&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob follows semantic versioning, though updates may be encouraged through deprecation warnings in minor versions.&lt;/p&gt; &#xA;&lt;h4&gt;Upgrading minor versions&lt;/h4&gt; &#xA;&lt;p&gt;Upgrading between minor versions (e.g. v1.4 to v1.5) should not introduce breaking changes, but can introduce new deprecation warnings and database migration warnings.&lt;/p&gt; &#xA;&lt;p&gt;Database migrations introduced in minor releases are &lt;em&gt;not required&lt;/em&gt; to be applied until the next major release. If you would like to apply newly introduced migrations immediately, assert &lt;code&gt;GoodJob.migrated?&lt;/code&gt; in your application&#39;s test suite.&lt;/p&gt; &#xA;&lt;p&gt;To perform upgrades to the GoodJob database tables:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Generate new database migration files:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g good_job:update&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Optional: If using Rails&#39; multiple databases with the &lt;code&gt;migrations_paths&lt;/code&gt; configuration option, use the &lt;code&gt;--database&lt;/code&gt; option:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g good_job:update --database animals&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run the database migration locally&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Commit the migration files and resulting &lt;code&gt;db/schema.rb&lt;/code&gt; changes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Deploy the code, run the migrations against the production database, and restart server/worker processes.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Upgrading v2 to v3&lt;/h4&gt; &#xA;&lt;p&gt;GoodJob v3 is operationally identical to v2; upgrading to GoodJob v3 should be simple. If you are already using &lt;code&gt;&amp;gt;= v2.9+&lt;/code&gt; no other changes are necessary.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Upgrade to &lt;code&gt;v2.99.x&lt;/code&gt;, following the minor version upgrade process, running any remaining database migrations (&lt;code&gt;rails g good_job:update&lt;/code&gt;) and addressing deprecation warnings.&lt;/li&gt; &#xA; &lt;li&gt;Upgrade from &lt;code&gt;v2.99.x&lt;/code&gt; to &lt;code&gt;v3.x&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Notable changes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Defaults to preserve job records, and automatically delete them after 14 days.&lt;/li&gt; &#xA; &lt;li&gt;Defaults to discarding failed jobs, instead of immediately retrying them.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:inline&lt;/code&gt; execution mode respects job schedules. Tests can invoke &lt;code&gt;GoodJob.perform_inline&lt;/code&gt; to execute jobs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;GoodJob::Adapter&lt;/code&gt; can no longer can be initialized with custom execution options (&lt;code&gt;queues:&lt;/code&gt;, &lt;code&gt;max_threads:&lt;/code&gt;, &lt;code&gt;poll_interval:&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Renames &lt;code&gt;GoodJob::ActiveJobJob&lt;/code&gt; to &lt;code&gt;GoodJob::Job&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Removes support for Rails 5.2.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Upgrading v1 to v2&lt;/h4&gt; &#xA;&lt;p&gt;GoodJob v2 introduces a new Advisory Lock key format that is operationally different than the v1 advisory lock key format; it&#39;s therefore necessary to perform a simple, but staged production upgrade. If you are already using &lt;code&gt;&amp;gt;= v1.12+&lt;/code&gt; no other changes are necessary.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Upgrade your production environment to &lt;code&gt;v1.99.x&lt;/code&gt; following the minor version upgrade process, including database migrations. &lt;code&gt;v1.99&lt;/code&gt; is a transitional release that is safely compatible with both &lt;code&gt;v1.x&lt;/code&gt; and &lt;code&gt;v2.0.0&lt;/code&gt; because it uses both &lt;code&gt;v1&lt;/code&gt;- and &lt;code&gt;v2&lt;/code&gt;-formatted advisory locks.&lt;/li&gt; &#xA; &lt;li&gt;Address any deprecation warnings generated by &lt;code&gt;v1.99&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Upgrade your production environment from &lt;code&gt;v1.99.x&lt;/code&gt; to &lt;code&gt;v2.0.x&lt;/code&gt; again following the &lt;em&gt;minor&lt;/em&gt; upgrade process.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Notable changes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Renames &lt;code&gt;:async_server&lt;/code&gt; execution mode to &lt;code&gt;:async&lt;/code&gt;; renames prior &lt;code&gt;:async&lt;/code&gt; execution mode to &lt;code&gt;:async_all&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Sets default Development environment&#39;s execution mode to &lt;code&gt;:async&lt;/code&gt; with disabled polling.&lt;/li&gt; &#xA; &lt;li&gt;Excludes performing jobs from &lt;code&gt;enqueue_limit&lt;/code&gt;&#39;s count in &lt;code&gt;GoodJob::ActiveJobExtensions::Concurrency&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Triggers &lt;code&gt;GoodJob.on_thread_error&lt;/code&gt; for unhandled Active Job exceptions.&lt;/li&gt; &#xA; &lt;li&gt;Renames &lt;code&gt;GoodJob.reperform_jobs_on_standard_error&lt;/code&gt; accessor to &lt;code&gt;GoodJob.retry_on_unhandled_error&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Renames &lt;code&gt;GoodJob::Adapter.shutdown(wait:)&lt;/code&gt; argument to &lt;code&gt;GoodJob::Adapter.shutdown(timeout:)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Changes Advisory Lock key format from &lt;code&gt;good_jobs[ROW_ID]&lt;/code&gt; to &lt;code&gt;good_jobs-[ACTIVE_JOB_ID]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Expects presence of columns &lt;code&gt;good_jobs.active_job_id&lt;/code&gt;, &lt;code&gt;good_jobs.concurrency_key&lt;/code&gt;, &lt;code&gt;good_jobs.concurrency_key&lt;/code&gt;, and &lt;code&gt;good_jobs.retried_good_job_id&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Go deeper&lt;/h2&gt; &#xA;&lt;h3&gt;Exceptions, retries, and reliability&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob guarantees that a completely-performed job will run once and only once. GoodJob fully supports Active Job&#39;s built-in functionality for error handling, retries and timeouts.&lt;/p&gt; &#xA;&lt;h4&gt;Exceptions&lt;/h4&gt; &#xA;&lt;p&gt;Active Job provides &lt;a href=&#34;https://guides.rubyonrails.org/active_job_basics.html#exceptions&#34;&gt;tools for rescuing and retrying exceptions&lt;/a&gt;, including &lt;code&gt;retry_on&lt;/code&gt;, &lt;code&gt;discard_on&lt;/code&gt;, &lt;code&gt;rescue_from&lt;/code&gt; that will rescue exceptions before they get to GoodJob.&lt;/p&gt; &#xA;&lt;p&gt;If errors do reach GoodJob, you can assign a callable to &lt;code&gt;GoodJob.on_thread_error&lt;/code&gt; to be notified. For example, to log errors to an exception monitoring service like Sentry (or Bugsnag, Airbrake, Honeybadger, etc.):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;GoodJob.on_thread_error = -&amp;gt; (exception) { Rails.error.report(exception) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Retries&lt;/h4&gt; &#xA;&lt;p&gt;By default, GoodJob relies on Active Job&#39;s retry functionality.&lt;/p&gt; &#xA;&lt;p&gt;Active Job can be configured to retry an infinite number of times, with a polynomial backoff. Using Active Job&#39;s &lt;code&gt;retry_on&lt;/code&gt; prevents exceptions from reaching GoodJob:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationJob &amp;lt; ActiveJob::Base&#xA;  retry_on StandardError, wait: :exponentially_longer, attempts: Float::INFINITY&#xA;  # ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using &lt;code&gt;retry_on&lt;/code&gt; with &lt;em&gt;a limited number of retries&lt;/em&gt;, the final exception will not be rescued and will raise to GoodJob&#39;s error handler. To avoid this, pass a block to &lt;code&gt;retry_on&lt;/code&gt; to handle the final exception instead of raising it to GoodJob:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationJob &amp;lt; ActiveJob::Base&#xA;  retry_on StandardError, attempts: 5 do |_job, _exception|&#xA;    # Log error, do nothing, etc.&#xA;  end&#xA;  # ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using &lt;code&gt;retry_on&lt;/code&gt; with an infinite number of retries, exceptions will never be raised to GoodJob, which means &lt;code&gt;GoodJob.on_thread_error&lt;/code&gt; will never be called. To report log or report exceptions to an exception monitoring service (e.g. Sentry, Bugsnag, Airbrake, Honeybadger, etc), create an explicit exception wrapper. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationJob &amp;lt; ActiveJob::Base&#xA;  retry_on StandardError, wait: :exponentially_longer, attempts: Float::INFINITY&#xA;&#xA;  retry_on SpecialError, attempts: 5 do |_job, exception|&#xA;    Rails.error.report(exception)&#xA;  end&#xA;&#xA;  around_perform do |_job, block|&#xA;    block.call&#xA;  rescue StandardError =&amp;gt; e&#xA;    Rails.error.report(e)&#xA;    raise&#xA;  end&#xA;  # ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, jobs will not be retried unless &lt;code&gt;retry_on&lt;/code&gt; is configured. This can be overridden by setting &lt;code&gt;GoodJob.retry_on_unhandled_error&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;; GoodJob will then retry the failing job immediately and infinitely, potentially causing high load.&lt;/p&gt; &#xA;&lt;h4&gt;Action Mailer retries&lt;/h4&gt; &#xA;&lt;p&gt;Any configuration in &lt;code&gt;ApplicationJob&lt;/code&gt; will have to be duplicated on &lt;code&gt;ActionMailer::MailDeliveryJob&lt;/code&gt; because ActionMailer uses that custom class which inherits from &lt;code&gt;ActiveJob::Base&lt;/code&gt;, rather than your application&#39;s &lt;code&gt;ApplicationJob&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can use an initializer to configure &lt;code&gt;ActionMailer::MailDeliveryJob&lt;/code&gt;, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;ActionMailer::MailDeliveryJob.retry_on StandardError, wait: :exponentially_longer, attempts: Float::INFINITY&#xA;&#xA;# With Sentry (or Bugsnag, Airbrake, Honeybadger, etc.)&#xA;ActionMailer::MailDeliveryJob.around_perform do |_job, block|&#xA;  block.call&#xA;rescue StandardError =&amp;gt; e&#xA;  Rails.error.report(e)&#xA;  raise&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note, that &lt;code&gt;ActionMailer::MailDeliveryJob&lt;/code&gt; is a default since Rails 6.0. Be sure that your app is using that class, as it might also be configured to use (deprecated now) &lt;code&gt;ActionMailer::DeliveryJob&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Interrupts&lt;/h3&gt; &#xA;&lt;p&gt;Jobs will be automatically retried if the process is interrupted while performing a job, for example as the result of a &lt;code&gt;SIGKILL&lt;/code&gt; or power failure.&lt;/p&gt; &#xA;&lt;p&gt;If you need more control over interrupt-caused retries, include the &lt;code&gt;GoodJob::ActiveJobExtensions::InterruptErrors&lt;/code&gt; extension in your job class. When an interrupted job is retried, the extension will raise a &lt;code&gt;GoodJob::InterruptError&lt;/code&gt; exception within the job, which allows you to use Active Job&#39;s &lt;code&gt;retry_on&lt;/code&gt; and &lt;code&gt;discard_on&lt;/code&gt; to control the behavior of the job.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyJob &amp;lt; ApplicationJob&#xA;  # The extension must be included before other extensions&#xA;  include GoodJob::ActiveJobExtensions::InterruptErrors&#xA;  # Discard the job if it is interrupted&#xA;  discard_on GoodJob::InterruptError&#xA;  # Retry the job if it is interrupted&#xA;  retry_on GoodJob::InterruptError, wait: 0, attempts: Float::INFINITY&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Timeouts&lt;/h3&gt; &#xA;&lt;p&gt;Job timeouts can be configured with an &lt;code&gt;around_perform&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationJob &amp;lt; ActiveJob::Base&#xA;  JobTimeoutError = Class.new(StandardError)&#xA;&#xA;  around_perform do |_job, block|&#xA;    # Timeout jobs after 10 minutes&#xA;    Timeout.timeout(10.minutes, JobTimeoutError) do&#xA;      block.call&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Optimize queues, threads, and processes&lt;/h3&gt; &#xA;&lt;p&gt;By default, GoodJob creates a single thread execution pool that will execute jobs from any queue. Depending on your application&#39;s workload, job types, and service level objectives, you may wish to optimize execution resources. For example, providing dedicated execution resources for transactional emails so they are not delayed by long-running batch jobs. Some options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Multiple isolated execution pools within a single process:&lt;/p&gt; &lt;p&gt;For moderate workloads, multiple isolated thread execution pools offers a good balance between congestion management and economy.&lt;/p&gt; &lt;p&gt;A pool is configured with the following syntax &lt;code&gt;&amp;lt;participating_queues&amp;gt;:&amp;lt;thread_count&amp;gt;&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;&amp;lt;participating_queues&amp;gt;&lt;/code&gt;: either &lt;code&gt;queue1,queue2&lt;/code&gt; (only those queues), &lt;code&gt;+queue1,queue2&lt;/code&gt; (only those queues, and processed in order), &lt;code&gt;*&lt;/code&gt; (all) or &lt;code&gt;-queue1,queue2&lt;/code&gt; (all except those queues).&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;&amp;lt;thread_count&amp;gt;&lt;/code&gt;: a count overriding for this specific pool the global &lt;code&gt;max-threads&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Pool configurations are separated with a semicolon (;) in the &lt;code&gt;queues&lt;/code&gt; configuration&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle exec good_job \&#xA;    --queues=&#34;transactional_messages:2;batch_processing:1;-transactional_messages,batch_processing:2;*&#34; \&#xA;    --max-threads=5&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This configuration will result in a single process with 4 isolated thread execution pools.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;transactional_messages:2&lt;/code&gt;: execute jobs enqueued on &lt;code&gt;transactional_messages&lt;/code&gt;, with up to 2 threads.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;batch_processing:1&lt;/code&gt; execute jobs enqueued on &lt;code&gt;batch_processing&lt;/code&gt;, with a single thread.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;-transactional_messages,batch_processing:2&lt;/code&gt;: execute jobs enqueued on &lt;em&gt;any&lt;/em&gt; queue &lt;em&gt;excluding&lt;/em&gt; &lt;code&gt;transactional_messages&lt;/code&gt; or &lt;code&gt;batch_processing&lt;/code&gt;, with up to 2 threads.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;*&lt;/code&gt;: execute jobs on any queue, with up to 5 threads (as configured by &lt;code&gt;--max-threads=5&lt;/code&gt;).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;When a pool is performing jobs from multiple queues, jobs will be performed from specified queues, ordered by priority and creation time. To perform jobs from queues in the queues&#39; given order, use the &lt;code&gt;+&lt;/code&gt; modifier. In this example, jobs in &lt;code&gt;batch_processing&lt;/code&gt; will be performed only when there are no jobs in &lt;code&gt;transactional_messages&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec good_job --queues=&#34;+transactional_messages,batch_processing&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Configuration can be injected by environment variables too:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ GOOD_JOB_QUEUES=&#34;transactional_messages:2;batch_processing:1;-transactional_messages,batch_processing:2;*&#34; \&#xA;  GOOD_JOB_MAX_THREADS=5 \&#xA;  bundle exec good_job&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Multiple processes:&lt;/p&gt; &lt;p&gt;While multiple isolated thread execution pools offer a way to provide dedicated execution resources, those resources are bound to a single machine. To scale them independently, define several processes.&lt;/p&gt; &lt;p&gt;For example, this configuration on Heroku allows to customize the dyno count (instances), or type (CPU/RAM), per process type:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-procfile&#34;&gt;# Procfile&#xA;&#xA;# Separate process types&#xA;worker: bundle exec good_job --max-threads=5&#xA;transactional_worker: bundle exec good_job --queues=&#34;transactional_messages&#34; --max-threads=2&#xA;batch_worker: bundle exec good_job --queues=&#34;batch_processing&#34; --max-threads=1&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;To optimize for CPU performance at the expense of greater memory and system resource usage, while keeping a single process type (and thus a single dyno), combine several processes and wait for them:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-procfile&#34;&gt;# Procfile&#xA;&#xA;# Combined multi-process&#xA;combined_worker: bundle exec good_job --max-threads=5 &amp;amp; bundle exec good_job --queues=&#34;transactional_messages&#34; --max-threads=2 &amp;amp; bundle exec good_job --queues=&#34;batch_processing&#34; --max-threads=1 &amp;amp; wait -n&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Keep in mind, queue operations and management is an advanced discipline. This stuff is complex, especially for heavy workloads and unique processing requirements. Good job üëç&lt;/p&gt; &#xA;&lt;h3&gt;Database connections&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob job executor processes require the following database connections:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;1 connection per execution pool thread. E.g., &lt;code&gt;--queues=mice:2;elephants:1&lt;/code&gt; is 3 threads and thus 3 connections. Pool size defaults to &lt;code&gt;--max-threads&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;2 additional connections that GoodJob uses for utility functionality (e.g. LISTEN/NOTIFY, cron, etc.)&lt;/li&gt; &#xA; &lt;li&gt;1 connection per subthread, if your application makes multithreaded database queries (e.g. &lt;code&gt;load_async&lt;/code&gt;) within a job.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The executor process will not crash if the connections pool is exhausted, instead it will report an exception (eg. &lt;code&gt;ActiveRecord::ConnectionTimeoutError&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;When GoodJob runs in &lt;code&gt;:inline&lt;/code&gt; mode (in Rails&#39; test environment, by default), the default database pool configuration works.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# config/database.yml&#xA;&#xA;pool: &amp;lt;%= ENV.fetch(&#34;RAILS_MAX_THREADS&#34;) { 5 } %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When GoodJob runs in &lt;code&gt;:async&lt;/code&gt; mode (in Rails&#39;s development environment, by default), the following database pool configuration works, where:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ENV.fetch(&#34;RAILS_MAX_THREADS&#34;, 5)&lt;/code&gt; is the number of threads used by the web server&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;1&lt;/code&gt; is the number of connections used by the job listener&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;2&lt;/code&gt; is the number of connections used by the cron scheduler and executor&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ENV.fetch(&#34;GOOD_JOB_MAX_THREADS&#34;, 5)&lt;/code&gt; is the number of threads used to perform jobs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# config/database.yml&#xA;&#xA;pool: &amp;lt;%= ENV.fetch(&#34;RAILS_MAX_THREADS&#34;, 5).to_i + 1 + 2 + ENV.fetch(&#34;GOOD_JOB_MAX_THREADS&#34;, 5).to_i %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When GoodJob runs in &lt;code&gt;:external&lt;/code&gt; mode (in Rails&#39; production environment, by default), the following database pool configurations work for web servers and worker processes, respectively.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# config/database.yml&#xA;&#xA;pool: &amp;lt;%= ENV.fetch(&#34;RAILS_MAX_THREADS&#34;, 5) %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# config/database.yml&#xA;&#xA;pool: &amp;lt;%= 1 + 2 + ENV.fetch(&#34;GOOD_JOB_MAX_THREADS&#34;, 5).to_i %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Production setup&lt;/h3&gt; &#xA;&lt;p&gt;When running GoodJob in a production environment, you should be mindful of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#execute-jobs-async--in-process&#34;&gt;Execution mode&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#database-connections&#34;&gt;Database connection pool size&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#cli-http-health-check-probes&#34;&gt;Health check probes&lt;/a&gt; and potentially the &lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#monitor-and-preserve-worked-jobs&#34;&gt;instrumentation support&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The recommended way to monitor the queue in production is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;have an exception notifier callback (see &lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#configuration-options&#34;&gt;&lt;code&gt;on_thread_error&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;if possible, run the queue as a dedicated instance and use available HTTP health check probes instead of PID-based monitoring&lt;/li&gt; &#xA; &lt;li&gt;keep an eye on the number of jobs in the queue (abnormal high number of unscheduled jobs means the queue could be underperforming)&lt;/li&gt; &#xA; &lt;li&gt;consider performance monitoring services which support the built-in Rails instrumentation (eg. Sentry, Skylight, etc.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Queue performance with Queue Select Limit&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob‚Äôs advisory locking strategy uses a materialized CTE (Common Table Expression). This strategy can be non-performant when querying a very large queue of executable jobs (100,000+) because the database query must materialize all executable jobs before acquiring an advisory lock.&lt;/p&gt; &#xA;&lt;p&gt;GoodJob offers an optional optimization to limit the number of jobs that are queried: Queue Select Limit.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;# CLI option&#xA;--queue-select-limit=1000&#xA;&#xA;# Rails configuration&#xA;config.good_job.queue_select_limit = 1000&#xA;&#xA;# Environment Variable&#xA;GOOD_JOB_QUEUE_SELECT_LIMIT=1000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Queue Select Limit value should be set to a rough upper-bound that exceeds all GoodJob execution threads / database connections. &lt;code&gt;1000&lt;/code&gt; is a number that likely exceeds the available database connections on most PaaS offerings, but still offers a performance boost for GoodJob when executing very large queues.&lt;/p&gt; &#xA;&lt;p&gt;To explain where this value is used, here is the pseudo-query that GoodJob uses to find executable jobs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  SELECT *&#xA;  FROM good_jobs&#xA;  WHERE id IN (&#xA;    WITH rows AS MATERIALIZED (&#xA;      SELECT id, active_job_id&#xA;      FROM good_jobs&#xA;      WHERE (scheduled_at &amp;lt;= NOW() OR scheduled_at IS NULL) AND finished_at IS NULL&#xA;      ORDER BY priority DESC NULLS LAST, created_at ASC&#xA;      [LIMIT 1000] -- &amp;lt;= introduced when queue_select_limit is set&#xA;    )&#xA;    SELECT id&#xA;    FROM rows&#xA;    WHERE pg_try_advisory_lock((&#39;x&#39; || substr(md5(&#39;good_jobs&#39; || &#39;-&#39; || active_job_id::text), 1, 16))::bit(64)::bigint)&#xA;    LIMIT 1&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Execute jobs async / in-process&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob can execute jobs &#34;async&#34; in the same process as the web server (e.g. &lt;code&gt;bin/rails s&lt;/code&gt;). GoodJob&#39;s async execution mode offers benefits of economy by not requiring a separate job worker process, but with the tradeoff of increased complexity. Async mode can be configured in two ways:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Via Rails configuration:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/environments/production.rb&#xA;config.active_job.queue_adapter = :good_job&#xA;&#xA;# To change the execution mode&#xA;config.good_job.execution_mode = :async&#xA;&#xA;# Or with more configuration&#xA;config.good_job = {&#xA;  execution_mode: :async,&#xA;  max_threads: 4,&#xA;  poll_interval: 30&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Or, with environment variables:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;GOOD_JOB_EXECUTION_MODE=async GOOD_JOB_MAX_THREADS=4 GOOD_JOB_POLL_INTERVAL=30 bin/rails server&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Depending on your application configuration, you may need to take additional steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Ensure that you have enough database connections for both web and job execution threads:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# config/database.yml&#xA;pool: &amp;lt;%= ENV.fetch(&#34;RAILS_MAX_THREADS&#34;, 5).to_i + ENV.fetch(&#34;GOOD_JOB_MAX_THREADS&#34;, 4).to_i %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;When running Puma with workers (&lt;code&gt;WEB_CONCURRENCY &amp;gt; 0&lt;/code&gt;) or another process-forking web server, GoodJob&#39;s threadpool schedulers should be stopped before forking, restarted after fork, and cleanly shut down on exit. Stopping GoodJob&#39;s scheduler pre-fork is recommended to ensure that GoodJob does not continue executing jobs in the parent/controller process. For example, with Puma:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/puma.rb&#xA;&#xA;before_fork do&#xA;  GoodJob.shutdown&#xA;end&#xA;&#xA;on_worker_boot do&#xA;  GoodJob.restart&#xA;end&#xA;&#xA;on_worker_shutdown do&#xA;  GoodJob.shutdown&#xA;end&#xA;&#xA;MAIN_PID = Process.pid&#xA;at_exit do&#xA;  GoodJob.shutdown if Process.pid == MAIN_PID&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;GoodJob is compatible with Puma&#39;s &lt;code&gt;preload_app!&lt;/code&gt; method.&lt;/p&gt; &lt;p&gt;For Passenger:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-Ruby&#34;&gt;if defined? PhusionPassenger&#xA;  PhusionPassenger.on_event :starting_worker_process do |forked|&#xA;    # If `forked` is true, we&#39;re in smart spawning mode.&#xA;    # https://www.phusionpassenger.com/docs/advanced_guides/in_depth/ruby/spawn_methods.html#smart-spawning-hooks&#xA;    if forked&#xA;      GoodJob.logger.info { &#39;Starting Passenger worker process.&#39; }&#xA;      GoodJob.restart&#xA;    end&#xA;  end&#xA;&#xA;  PhusionPassenger.on_event :stopping_worker_process do&#xA;    GoodJob.logger.info { &#39;Stopping Passenger worker process.&#39; }&#xA;    GoodJob.shutdown&#xA;  end&#xA;end&#xA;&#xA;# GoodJob also starts in the Passenger preloader process. This one does not&#xA;# trigger the above events, thus we catch it with `Kernel#at_exit`.&#xA;PRELOADER_PID = Process.pid&#xA;at_exit do&#xA;  if Process.pid == PRELOADER_PID&#xA;    GoodJob.logger.info { &#39;Passenger AppPreloader shutting down.&#39; }&#xA;    GoodJob.shutdown&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;If you are using cron-style jobs, you might also want to look at your Passenger configuration, especially at &lt;a href=&#34;https://www.phusionpassenger.com/library/config/nginx/reference/#passenger_pool_idle_time&#34;&gt;&lt;code&gt;passenger_pool_idle_time&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://www.phusionpassenger.com/library/config/nginx/reference/#passenger_min_instances&#34;&gt;&lt;code&gt;passenger_min_instances&lt;/code&gt;&lt;/a&gt; to make sure there&#39;s always at least once process running that can execute cron-style scheduled jobs. See also &lt;a href=&#34;https://www.phusionpassenger.com/library/config/nginx/optimization/#minimizing-process-spawning&#34;&gt;Passenger&#39;s optimization guide&lt;/a&gt; for more information.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Migrate to GoodJob from a different Active Job backend&lt;/h3&gt; &#xA;&lt;p&gt;If your application is already using an Active Job backend, you will need to install GoodJob to enqueue and perform newly created jobs &lt;em&gt;and&lt;/em&gt; finish performing pre-existing jobs on the previous backend.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Enqueue newly created jobs on GoodJob either entirely by setting &lt;code&gt;ActiveJob::Base.queue_adapter = :good_job&lt;/code&gt; or progressively via individual job classes:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# jobs/specific_job.rb&#xA;class SpecificJob &amp;lt; ApplicationJob&#xA;  self.queue_adapter = :good_job&#xA;  # ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Continue running executors for both backends. For example, on Heroku it&#39;s possible to run &lt;a href=&#34;https://help.heroku.com/CTFS2TJK/how-do-i-run-multiple-processes-on-a-dyno&#34;&gt;two processes&lt;/a&gt; within the same dyno:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-procfile&#34;&gt; # Procfile&#xA; # ...&#xA; worker: bundle exec que ./config/environment.rb &amp;amp; bundle exec good_job &amp;amp; wait -n&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Once you are confident that no unperformed jobs remain in the previous Active Job backend, code and configuration for that backend can be completely removed.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Monitor and preserve worked jobs&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob is fully instrumented with &lt;a href=&#34;https://edgeguides.rubyonrails.org/active_support_instrumentation.html#introduction-to-instrumentation&#34;&gt;&lt;code&gt;ActiveSupport::Notifications&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By default, GoodJob will preserve job records for 14 days after they are run, regardless of whether they succeed or raised an exception.&lt;/p&gt; &#xA;&lt;p&gt;To instead delete job records immediately after they are finished:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;config.good_job.preserve_job_records = false # defaults to true; can also be `false` or `:on_unhandled_error`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;GoodJob will automatically delete preserved job records after 14 days. The retention period, as well as the frequency GoodJob checks for deletable records can be configured:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.good_job.cleanup_preserved_jobs_before_seconds_ago = 14.days&#xA;config.good_job.cleanup_interval_jobs = 1_000 # Number of executed jobs between deletion sweeps.&#xA;config.good_job.cleanup_interval_seconds = 10.minutes # Number of seconds between deletion sweeps.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is also possible to manually trigger a cleanup of preserved job records:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;For example, in a Rake task:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;GoodJob.cleanup_preserved_jobs # Will use default retention period&#xA;GoodJob.cleanup_preserved_jobs(older_than: 7.days) # custom retention period&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For example, using the &lt;code&gt;good_job&lt;/code&gt; command-line utility:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec good_job cleanup_preserved_jobs --before-seconds-ago=86400&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Write tests&lt;/h3&gt; &#xA;&lt;p&gt;By default, GoodJob uses its inline adapter in the test environment; the inline adapter is designed for the test environment. When enqueuing a job with GoodJob&#39;s inline adapter, the job will be executed immediately on the current thread; unhandled exceptions will be raised.&lt;/p&gt; &#xA;&lt;p&gt;In GoodJob 2.0, the inline adapter will execute future scheduled jobs immediately. In the next major release, GoodJob 3.0, the inline adapter will not execute future scheduled jobs and instead enqueue them in the database.&lt;/p&gt; &#xA;&lt;p&gt;To opt into this behavior immediately set: &lt;code&gt;config.good_job.inline_execution_respects_schedule = true&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;To perform jobs inline at any time, use &lt;code&gt;GoodJob.perform_inline&lt;/code&gt;. For example, using time helpers within an integration test:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MyJob.set(wait: 10.minutes).perform_later&#xA;travel_to(15.minutes.from_now) { GoodJob.perform_inline }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: Rails &lt;code&gt;travel&lt;/code&gt;/&lt;code&gt;travel_to&lt;/code&gt; time helpers do not have millisecond precision, so you must leave at least 1 second between the schedule and time traveling for the job to be executed. This &lt;a href=&#34;https://github.com/rails/rails/pull/44088&#34;&gt;behavior may change in Rails 7.1&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;PgBouncer compatibility&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob is not compatible with PgBouncer in &lt;em&gt;transaction&lt;/em&gt; mode, but is compatible with PgBouncer&#39;s &lt;em&gt;connection&lt;/em&gt; mode. GoodJob uses connection-based advisory locks and LISTEN/NOTIFY, both of which require full database connections.&lt;/p&gt; &#xA;&lt;p&gt;A workaround to this limitation is to make a direct database connection available to GoodJob. With Rails 6.0&#39;s support for &lt;a href=&#34;https://guides.rubyonrails.org/active_record_multiple_databases.html&#34;&gt;multiple databases&lt;/a&gt;, a direct connection to the database can be configured:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Define a direct connection to your database that is not proxied through PgBouncer, for example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# config/database.yml&#xA;&#xA;production:&#xA;  primary:&#xA;    url: postgres://pgbouncer_host/my_database&#xA;  primary_direct:&#xA;    url: postgres://database_host/my_database&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a new Active Record base class that uses the direct database connection&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/models/application_direct_record.rb&#xA;&#xA;class ApplicationDirectRecord &amp;lt; ActiveRecord::Base&#xA;  self.abstract_class = true&#xA;  connects_to database: :primary_direct&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Configure GoodJob to use the newly created Active Record base class:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;&#xA;GoodJob.active_record_parent_class = &#34;ApplicationDirectRecord&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;CLI HTTP health check probes&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob&#39;s CLI offers an http health check probe to better manage process lifecycle in containerized environments like Kubernetes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Run the CLI with a health check on port 7001&#xA;good_job start --probe-port=7001&#xA;&#xA;# or via an environment variable&#xA;GOOD_JOB_PROBE_PORT=7001 good_job start&#xA;&#xA;# Probe the status&#xA;curl localhost:7001/status&#xA;curl localhost:7001/status/started&#xA;curl localhost:7001/status/connected&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Multiple health checks are available at different paths:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;/&lt;/code&gt; or &lt;code&gt;/status&lt;/code&gt;: the CLI process is running&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/status/started&lt;/code&gt;: the multithreaded job executor is running&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/status/connected&lt;/code&gt;: the database connection is established&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This can be configured, for example with Kubernetes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spec:&#xA;  containers:&#xA;    - name: good_job&#xA;      image: my_app:latest&#xA;      env:&#xA;        - name: RAILS_ENV&#xA;          value: production&#xA;        - name: GOOD_JOB_PROBE_PORT&#xA;          value: 7001&#xA;      command:&#xA;          - good_job&#xA;          - start&#xA;      ports:&#xA;        - name: probe-port&#xA;          containerPort: 7001&#xA;      startupProbe:&#xA;        httpGet:&#xA;          path: &#34;/status/started&#34;&#xA;          port: probe-port&#xA;        failureThreshold: 30&#xA;        periodSeconds: 10&#xA;      livenessProbe:&#xA;        httpGet:&#xA;          path: &#34;/status/connected&#34;&#xA;          port: probe-port&#xA;        failureThreshold: 1&#xA;        periodSeconds: 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;!-- Please keep this section in sync with CONTRIBUTING.md --&gt; &#xA;&lt;p&gt;All contributions, from feedback to code and beyond, are welcomed and appreciated üôè&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Review the &lt;a href=&#34;https://github.com/bensheldon/good_job/projects/1&#34;&gt;Prioritized Project Backlog&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Open a new issue or contribute to an &lt;a href=&#34;https://github.com/bensheldon/good_job/issues&#34;&gt;existing Issue&lt;/a&gt;. Questions or suggestions are fantastic.&lt;/li&gt; &#xA; &lt;li&gt;Participate according to our &lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/CODE_OF_CONDUCT.md&#34;&gt;Code of Conduct&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Financially support the project via &lt;a href=&#34;https://github.com/sponsors/bensheldon&#34;&gt;Sponsorship&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For gem development and debugging information, please review the &lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/README.md#gem-development&#34;&gt;README&#39;s Gem Development section&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Gem development&lt;/h3&gt; &#xA;&lt;h4&gt;Development setup&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Clone the repository locally&#xA;git clone git@github.com:bensheldon/good_job.git&#xA;&#xA;# Set up the gem development environment&#xA;bin/setup&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Rails development harness&lt;/h4&gt; &#xA;&lt;p&gt;A Rails application exists within &lt;code&gt;demo&lt;/code&gt; that is used for development, test, and GoodJob Demo environments.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Run a local development webserver&#xA;bin/rails s&#xA;&#xA;# Disable job execution and cron for cleaner console output&#xA;GOOD_JOB_ENABLE_CRON=0 GOOD_JOB_EXECUTION_MODE=external bin/rails s&#xA;&#xA;# Open the Rails console&#xA;bin/rails c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For developing locally within another Ruby on Rails project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Within Ruby on Rails project directory&#xA;# Ensure that the Gemfile is set to git with a branch e.g.&#xA;# gem &#34;good_job&#34;, git: &#34;https://github.com/bensheldon/good_job.git&#34;, branch: &#34;main&#34;&#xA;# Then, override the Bundle config to point to the local filesystem&#39;s good_job repository&#xA;bundle config local.good_job /path/to/local/good_job/repository&#xA;&#xA;# Confirm that the local copy is used&#xA;bundle install&#xA;&#xA;# =&amp;gt; Using good_job 0.1.0 from https://github.com/bensheldon/good_job.git (at /Users/You/Projects/good_job@dc57fb0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Running tests&lt;/h4&gt; &#xA;&lt;p&gt;Tests can be run against the primary development environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Set up the gem development environment&#xA;bin/setup&#xA;&#xA;# Run the tests&#xA;bin/rspec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Environment variables that may help with debugging:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;LOUD=1&lt;/code&gt;: display all stdout/stderr output from all sources. This is helpful because GoodJob wraps some tests with &lt;code&gt;quiet { }&lt;/code&gt; for cleaner test output, but it can hinder debugging.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SHOW_BROWSER=1&lt;/code&gt;: Run system tests headfully with Chrome/Chromedriver. Use &lt;code&gt;binding.irb&lt;/code&gt; in the system tests to pause.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Appraisal can be used to run a test matrix of multiple versions of Rails:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install Appraisal matrix of gemfiles&#xA;bin/appraisal&#xA;&#xA;# Run tests against matrix&#xA;bin/appraisal bin/rspec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Release&lt;/h3&gt; &#xA;&lt;p&gt;Package maintainers can release this gem by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Sign into rubygems&#xA;$ gem signin&#xA;&#xA;# Add a .env file with the following:&#xA;# CHANGELOG_GITHUB_TOKEN= # Github Personal Access Token&#xA;&#xA;# Update version number, changelog, and create git commit:&#xA;$ bundle exec rake release_good_job[minor] # major,minor,patch&#xA;&#xA;# ..and follow subsequent directions.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>omniauth/omniauth</title>
    <updated>2023-12-24T01:58:51Z</updated>
    <id>tag:github.com,2023-12-24:/omniauth/omniauth</id>
    <link href="https://github.com/omniauth/omniauth" rel="alternate"></link>
    <summary type="html">&lt;p&gt;OmniAuth is a flexible authentication system utilizing Rack middleware.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;OmniAuth: Standardized Multi-Provider Authentication&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://rubygems.org/gems/omniauth&#34;&gt;&lt;img src=&#34;http://img.shields.io/gem/v/omniauth.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/omniauth/omniauth/actions/workflows/main.yml&#34;&gt;&lt;img src=&#34;https://github.com/omniauth/omniauth/actions/workflows/main.yml/badge.svg?sanitize=true&#34; alt=&#34;Ruby&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/omniauth/omniauth/actions/workflows/truffle_ruby.yml&#34;&gt;&lt;img src=&#34;https://github.com/omniauth/omniauth/actions/workflows/truffle_ruby.yml/badge.svg?sanitize=true&#34; alt=&#34;TruffleRuby&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/omniauth/omniauth/actions/workflows/jruby.yml&#34;&gt;&lt;img src=&#34;https://github.com/omniauth/omniauth/actions/workflows/jruby.yml/badge.svg?sanitize=true&#34; alt=&#34;JRuby&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/omniauth/omniauth&#34;&gt;&lt;img src=&#34;https://api.codeclimate.com/v1/badges/ffd33970723587806744/maintainability&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/r/omniauth/omniauth&#34;&gt;&lt;img src=&#34;http://img.shields.io/coveralls/omniauth/omniauth.svg?sanitize=true&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is the documentation for the in-development branch of OmniAuth. You can find the documentation for the latest stable release &lt;a href=&#34;https://github.com/omniauth/omniauth/tree/v2.1.2&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;An Introduction&lt;/h2&gt; &#xA;&lt;p&gt;OmniAuth is a library that standardizes multi-provider authentication for web applications. It was created to be powerful, flexible, and do as little as possible. Any developer can create &lt;strong&gt;strategies&lt;/strong&gt; for OmniAuth that can authenticate users via disparate systems. OmniAuth strategies have been created for everything from Facebook to LDAP.&lt;/p&gt; &#xA;&lt;p&gt;In order to use OmniAuth in your applications, you will need to leverage one or more strategies. These strategies are generally released individually as RubyGems, and you can see a &lt;a href=&#34;https://github.com/omniauth/omniauth/wiki/List-of-Strategies&#34;&gt;community maintained list&lt;/a&gt; on the wiki for this project.&lt;/p&gt; &#xA;&lt;p&gt;One strategy, called &lt;code&gt;Developer&lt;/code&gt;, is included with OmniAuth and provides a completely insecure, non-production-usable strategy that directly prompts a user for authentication information and then passes it straight through. You can use it as a placeholder when you start development and easily swap in other strategies later.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Each OmniAuth strategy is a Rack Middleware. That means that you can use it the same way that you use any other Rack middleware. For example, to use the built-in Developer strategy in a Sinatra application you might do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;sinatra&#39;&#xA;require &#39;omniauth&#39;&#xA;&#xA;class MyApplication &amp;lt; Sinatra::Base&#xA;  use Rack::Session::Cookie&#xA;  use OmniAuth::Strategies::Developer&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because OmniAuth is built for &lt;em&gt;multi-provider&lt;/em&gt; authentication, you may want to leave room to run multiple strategies. For this, the built-in &lt;code&gt;OmniAuth::Builder&lt;/code&gt; class gives you an easy way to specify multiple strategies. Note that there is &lt;strong&gt;no difference&lt;/strong&gt; between the following code and using each strategy individually as middleware. This is an example that you might put into a Rails initializer at &lt;code&gt;config/initializers/omniauth.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.application.config.middleware.use OmniAuth::Builder do&#xA;  provider :developer unless Rails.env.production?&#xA;  provider :twitter, ENV[&#39;TWITTER_KEY&#39;], ENV[&#39;TWITTER_SECRET&#39;]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should look to the documentation for each provider you use for specific initialization requirements.&lt;/p&gt; &#xA;&lt;h2&gt;Integrating OmniAuth Into Your Application&lt;/h2&gt; &#xA;&lt;p&gt;OmniAuth is an extremely low-touch library. It is designed to be a black box that you can send your application&#39;s users into when you need authentication and then get information back. OmniAuth was intentionally built not to automatically associate with a User model or make assumptions about how many authentication methods you might want to use or what you might want to do with the data once a user has authenticated. This makes OmniAuth incredibly flexible. To use OmniAuth, you need only to redirect users to &lt;code&gt;/auth/:provider&lt;/code&gt;, where &lt;code&gt;:provider&lt;/code&gt; is the name of the strategy (for example, &lt;code&gt;developer&lt;/code&gt; or &lt;code&gt;twitter&lt;/code&gt;). From there, OmniAuth will take over and take the user through the necessary steps to authenticate them with the chosen strategy.&lt;/p&gt; &#xA;&lt;p&gt;Once the user has authenticated, what do you do next? OmniAuth simply sets a special hash called the Authentication Hash on the Rack environment of a request to &lt;code&gt;/auth/:provider/callback&lt;/code&gt;. This hash contains as much information about the user as OmniAuth was able to glean from the utilized strategy. You should set up an endpoint in your application that matches to the callback URL and then performs whatever steps are necessary for your application.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;omniauth.auth&lt;/code&gt; key in the environment hash provides an Authentication Hash which will contain information about the just authenticated user including a unique id, the strategy they just used for authentication, and personal details such as name and email address as available. For an in-depth description of what the authentication hash might contain, see the &lt;a href=&#34;https://github.com/omniauth/omniauth/wiki/Auth-Hash-Schema&#34;&gt;Auth Hash Schema wiki page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that OmniAuth does not perform any actions beyond setting some environment information on the callback request. It is entirely up to you how you want to implement the particulars of your application&#39;s authentication flow.&lt;/p&gt; &#xA;&lt;h2&gt;rack_csrf&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;omniauth&lt;/code&gt; is not OOTB-compatible with &lt;a href=&#34;https://github.com/baldowl/rack_csrf&#34;&gt;rack_csrf&lt;/a&gt;. In order to do so, the following code needs to be added to the application bootstrapping code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;OmniAuth::AuthenticityTokenProtection.default_options(key: &#34;csrf.token&#34;, authenticity_param: &#34;_csrf&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Rails (without Devise)&lt;/h2&gt; &#xA;&lt;p&gt;To get started, add the following gems&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Gemfile&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;omniauth&#39;&#xA;gem &#34;omniauth-rails_csrf_protection&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then insert OmniAuth as a middleware&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;config/initializers/omniauth.rb&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.application.config.middleware.use OmniAuth::Builder do&#xA;  provider :developer if Rails.env.development?&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additional providers can be added here in the future. Next we wire it all up using routes, a controller and a login view.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;config/routes.rb&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  get &#39;auth/:provider/callback&#39;, to: &#39;sessions#create&#39;&#xA;  get &#39;/login&#39;, to: &#39;sessions#new&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;app/controllers/sessions_controller.rb&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SessionsController &amp;lt; ApplicationController&#xA;  def new&#xA;    render :new&#xA;  end&#xA;&#xA;  def create&#xA;    user_info = request.env[&#39;omniauth.auth&#39;]&#xA;    raise user_info # Your own session management should be placed here.&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;app/views/sessions/new.html.erb&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;%= form_tag(&#39;/auth/developer&#39;, method: &#39;post&#39;, data: {turbo: false}) do %&amp;gt;&#xA;  &amp;lt;button type=&#39;submit&#39;&amp;gt;Login with Developer&amp;lt;/button&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now if you visit &lt;code&gt;/login&lt;/code&gt; and click the Login button, you should see the OmniAuth developer login screen. After submitting it, you are returned to your application at &lt;code&gt;Sessions#create&lt;/code&gt;. The raise should now display all the Omniauth details you have available to integrate it into your own user management.&lt;/p&gt; &#xA;&lt;p&gt;If you want out of the box usermanagement, you should consider using Omniauth through Devise. Please visit the &lt;a href=&#34;https://github.com/heartcombo/devise#omniauth&#34;&gt;Devise Github page&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Rails API&lt;/h2&gt; &#xA;&lt;p&gt;The following middleware are (by default) included for session management in Rails applications. When using OmniAuth with a Rails API, you&#39;ll need to add one of these required middleware back in:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ActionDispatch::Session::CacheStore&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ActionDispatch::Session::CookieStore&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ActionDispatch::Session::MemCacheStore&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The trick to adding these back in is that, by default, they are passed &lt;code&gt;session_options&lt;/code&gt; when added (including the session key), so you can&#39;t just add a &lt;code&gt;session_store.rb&lt;/code&gt; initializer, add &lt;code&gt;use ActionDispatch::Session::CookieStore&lt;/code&gt; and have sessions functioning as normal.&lt;/p&gt; &#xA;&lt;p&gt;To be clear: sessions may work, but your session options will be ignored (i.e. the session key will default to &lt;code&gt;_session_id&lt;/code&gt;). Instead of the initializer, you&#39;ll have to set the relevant options somewhere before your middleware is built (like &lt;code&gt;application.rb&lt;/code&gt;) and pass them to your preferred middleware, like this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;application.rb:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.session_store :cookie_store, key: &#39;_interslice_session&#39;&#xA;config.middleware.use ActionDispatch::Cookies # Required for all session management&#xA;config.middleware.use ActionDispatch::Session::CookieStore, config.session_options&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Thanks @mltsy)&lt;/p&gt; &#xA;&lt;h2&gt;Logging&lt;/h2&gt; &#xA;&lt;p&gt;OmniAuth supports a configurable logger. By default, OmniAuth will log to &lt;code&gt;STDOUT&lt;/code&gt; but you can configure this using &lt;code&gt;OmniAuth.config.logger&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Rails application example&#xA;OmniAuth.config.logger = Rails.logger&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Origin Param&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;origin&lt;/code&gt; url parameter is typically used to inform where a user came from and where, should you choose to use it, they&#39;d want to return to. Omniauth supports the following settings which can be configured on a provider level:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Default&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;provider :twitter, ENV[&#39;KEY&#39;], ENV[&#39;SECRET&#39;]&#xA;POST /auth/twitter/?origin=[URL]&#xA;# If the `origin` parameter is blank, `omniauth.origin` is set to HTTP_REFERER&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Using a differently named origin parameter&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;provider :twitter, ENV[&#39;KEY&#39;], ENV[&#39;SECRET&#39;], origin_param: &#39;return_to&#39;&#xA;POST /auth/twitter/?return_to=[URL]&#xA;# If the `return_to` parameter is blank, `omniauth.origin` is set to HTTP_REFERER&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Disabled&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;provider :twitter, ENV[&#39;KEY&#39;], ENV[&#39;SECRET&#39;], origin_param: false&#xA;POST /auth/twitter&#xA;# This means the origin should be handled by your own application. &#xA;# Note that `omniauth.origin` will always be blank.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/omniauth/omniauth/wiki&#34;&gt;OmniAuth Wiki&lt;/a&gt; has actively maintained in-depth documentation for OmniAuth. It should be your first stop if you are wondering about a more in-depth look at OmniAuth, how it works, and how to use it.&lt;/p&gt; &#xA;&lt;h2&gt;OmniAuth for Enterprise&lt;/h2&gt; &#xA;&lt;p&gt;Available as part of the Tidelift Subscription.&lt;/p&gt; &#xA;&lt;p&gt;The maintainers of OmniAuth and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source packages you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact packages you use. &lt;a href=&#34;https://tidelift.com/subscription/pkg/rubygems-omniauth?utm_source=undefined&amp;amp;utm_medium=referral&amp;amp;utm_campaign=enterprise&amp;amp;utm_term=repo&#34;&gt;Learn more.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Supported Ruby Versions&lt;/h2&gt; &#xA;&lt;p&gt;OmniAuth is tested under 2.5, 2.6, 2.7, 3.0, 3.1, 3.2, truffleruby, and JRuby.&lt;/p&gt; &#xA;&lt;h2&gt;Versioning&lt;/h2&gt; &#xA;&lt;p&gt;This library aims to adhere to &lt;a href=&#34;http://semver.org/&#34;&gt;Semantic Versioning 2.0.0&lt;/a&gt;. Violations of this scheme should be reported as bugs. Specifically, if a minor or patch version is released that breaks backward compatibility, that version should be immediately yanked and/or a new version should be immediately released that restores compatibility. Breaking changes to the public API will only be introduced with new major versions. As a result of this policy, you can (and should) specify a dependency on this gem using the &lt;a href=&#34;http://guides.rubygems.org/patterns/#pessimistic-version-constraint&#34;&gt;Pessimistic Version Constraint&lt;/a&gt; with two digits of precision. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;spec.add_dependency &#39;omniauth&#39;, &#39;~&amp;gt; 1.0&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2010-2017 Michael Bleigh and Intridea, Inc. See &lt;a href=&#34;https://raw.githubusercontent.com/omniauth/omniauth/master/LICENSE.md&#34;&gt;LICENSE&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
</feed>