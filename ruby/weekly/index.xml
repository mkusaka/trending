<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-09-22T01:44:54Z</updated>
  <subtitle>Weekly Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ankane/searchkick</title>
    <updated>2024-09-22T01:44:54Z</updated>
    <id>tag:github.com,2024-09-22:/ankane/searchkick</id>
    <link href="https://github.com/ankane/searchkick" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Intelligent search made easy&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Searchkick&lt;/h1&gt; &#xA;&lt;p&gt;&lt;span&gt;üöÄ&lt;/span&gt; Intelligent search made easy&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Searchkick learns what your users are looking for.&lt;/strong&gt; As more people search, it gets smarter and the results get better. It‚Äôs friendly for developers - and magical for your users.&lt;/p&gt; &#xA;&lt;p&gt;Searchkick handles:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;stemming - &lt;code&gt;tomatoes&lt;/code&gt; matches &lt;code&gt;tomato&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;special characters - &lt;code&gt;jalapeno&lt;/code&gt; matches &lt;code&gt;jalape√±o&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;extra whitespace - &lt;code&gt;dishwasher&lt;/code&gt; matches &lt;code&gt;dish washer&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;misspellings - &lt;code&gt;zuchini&lt;/code&gt; matches &lt;code&gt;zucchini&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;custom synonyms - &lt;code&gt;pop&lt;/code&gt; matches &lt;code&gt;soda&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Plus:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;query like SQL - no need to learn a new query language&lt;/li&gt; &#xA; &lt;li&gt;reindex without downtime&lt;/li&gt; &#xA; &lt;li&gt;easily personalize results for each user&lt;/li&gt; &#xA; &lt;li&gt;autocomplete&lt;/li&gt; &#xA; &lt;li&gt;‚ÄúDid you mean‚Äù suggestions&lt;/li&gt; &#xA; &lt;li&gt;supports many languages&lt;/li&gt; &#xA; &lt;li&gt;works with Active Record and Mongoid&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Check out &lt;a href=&#34;https://github.com/ankane/searchjoy&#34;&gt;Searchjoy&lt;/a&gt; for analytics and &lt;a href=&#34;https://github.com/ankane/autosuggest&#34;&gt;Autosuggest&lt;/a&gt; for query suggestions&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;üçä&lt;/span&gt; Battle-tested at &lt;a href=&#34;https://www.instacart.com/opensource&#34;&gt;Instacart&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ankane/searchkick/actions&#34;&gt;&lt;img src=&#34;https://github.com/ankane/searchkick/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#getting-started&#34;&gt;Getting Started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#querying&#34;&gt;Querying&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#indexing&#34;&gt;Indexing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#intelligent-search&#34;&gt;Intelligent Search&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#instant-search--autocomplete&#34;&gt;Instant Search / Autocomplete&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#aggregations&#34;&gt;Aggregations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#testing&#34;&gt;Testing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#deployment&#34;&gt;Deployment&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#performance&#34;&gt;Performance&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#advanced&#34;&gt;Advanced Search&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#reference&#34;&gt;Reference&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://www.elastic.co/downloads/elasticsearch&#34;&gt;Elasticsearch&lt;/a&gt; or &lt;a href=&#34;https://opensearch.org/downloads.html&#34;&gt;OpenSearch&lt;/a&gt;. For Homebrew, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install elastic/tap/elasticsearch-full&#xA;brew services start elasticsearch-full&#xA;# or&#xA;brew install opensearch&#xA;brew services start opensearch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add these lines to your application‚Äôs Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;searchkick&#34;&#xA;&#xA;gem &#34;elasticsearch&#34;   # select one&#xA;gem &#34;opensearch-ruby&#34; # select one&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The latest version works with Elasticsearch 7 and 8 and OpenSearch 1 and 2. For Elasticsearch 6, use version 4.6.3 and &lt;a href=&#34;https://github.com/ankane/searchkick/raw/v4.6.3/README.md&#34;&gt;this readme&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Add searchkick to models you want to search.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add data to the search index.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.reindex&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And to query, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;products = Product.search(&#34;apples&#34;)&#xA;products.each do |product|&#xA;  puts product.name&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Searchkick supports the complete &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html&#34;&gt;Elasticsearch Search API&lt;/a&gt; and &lt;a href=&#34;https://opensearch.org/docs/latest/opensearch/rest-api/search/&#34;&gt;OpenSearch Search API&lt;/a&gt;. As your search becomes more advanced, we recommend you use the &lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#advanced&#34;&gt;search server DSL&lt;/a&gt; for maximum flexibility.&lt;/p&gt; &#xA;&lt;h2&gt;Querying&lt;/h2&gt; &#xA;&lt;p&gt;Query like SQL&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;apples&#34;, where: {in_stock: true}, limit: 10, offset: 50)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Search specific fields&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;fields: [:name, :brand]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;where: {&#xA;  expires_at: {gt: Time.now},    # lt, gte, lte also available&#xA;  orders_count: 1..10,           # equivalent to {gte: 1, lte: 10}&#xA;  aisle_id: [25, 30],            # in&#xA;  store_id: {not: 2},            # not&#xA;  aisle_id: {not: [25, 30]},     # not in&#xA;  user_ids: {all: [1, 3]},       # all elements in array&#xA;  category: {like: &#34;%frozen%&#34;},  # like&#xA;  category: {ilike: &#34;%frozen%&#34;}, # ilike&#xA;  category: /frozen .+/,         # regexp&#xA;  category: {prefix: &#34;frozen&#34;},  # prefix&#xA;  store_id: {exists: true},      # exists&#xA;  _not: {store_id: 1},           # negate a condition&#xA;  _or: [{in_stock: true}, {backordered: true}],&#xA;  _and: [{in_stock: true}, {backordered: true}]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Order&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;order: {_score: :desc} # most relevant first - default&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html&#34;&gt;All of these sort options are supported&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Limit / offset&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;limit: 20, offset: 40&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Select&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;select: [:name]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-fields.html#source-filtering&#34;&gt;These source filtering options are supported&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Results&lt;/h3&gt; &#xA;&lt;p&gt;Searches return a &lt;code&gt;Searchkick::Relation&lt;/code&gt; object. This responds like an array to most methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;results = Product.search(&#34;milk&#34;)&#xA;results.size&#xA;results.any?&#xA;results.each { |result| ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, ids are fetched from the search server and records are fetched from your database. To fetch everything from the search server, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;apples&#34;, load: false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Get total results&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;results.total_count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Get the time the search took (in milliseconds)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;results.took&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Get the full response from the search server&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;results.response&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; By default, Elasticsearch and OpenSearch &lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#deep-paging&#34;&gt;limit paging&lt;/a&gt; to the first 10,000 results for performance. This applies to the total count as well.&lt;/p&gt; &#xA;&lt;h3&gt;Boosting&lt;/h3&gt; &#xA;&lt;p&gt;Boost important fields&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;fields: [&#34;title^10&#34;, &#34;description&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Boost by the value of a field (field must be numeric)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;boost_by: [:orders_count] # give popular documents a little boost&#xA;boost_by: {orders_count: {factor: 10}} # default factor is 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Boost matching documents&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;boost_where: {user_id: 1}&#xA;boost_where: {user_id: {value: 1, factor: 100}} # default factor is 1000&#xA;boost_where: {user_id: [{value: 1, factor: 100}, {value: 2, factor: 200}]}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Boost by recency&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;boost_by_recency: {created_at: {scale: &#34;7d&#34;, decay: 0.5}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also boost by:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#intelligent-search&#34;&gt;Conversions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#boost-by-distance&#34;&gt;Distance&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Get Everything&lt;/h3&gt; &#xA;&lt;p&gt;Use a &lt;code&gt;*&lt;/code&gt; for the query.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;*&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Pagination&lt;/h3&gt; &#xA;&lt;p&gt;Plays nicely with kaminari and will_paginate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# controller&#xA;@products = Product.search(&#34;milk&#34;, page: params[:page], per_page: 20)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;View with kaminari&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;%= paginate @products %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;View with will_paginate&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;%= will_paginate @products %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Partial Matches&lt;/h3&gt; &#xA;&lt;p&gt;By default, results must match all words in the query.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;fresh honey&#34;) # fresh AND honey&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To change this, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;fresh honey&#34;, operator: &#34;or&#34;) # fresh OR honey&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, results must match the entire word - &lt;code&gt;back&lt;/code&gt; will not match &lt;code&gt;backpack&lt;/code&gt;. You can change this behavior with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick word_start: [:name]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And to search (after you reindex):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;back&#34;, fields: [:name], match: :word_start)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Available options are:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Option&lt;/th&gt; &#xA;   &lt;th&gt;Matches&lt;/th&gt; &#xA;   &lt;th&gt;Example&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;:word&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;entire word&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;apple&lt;/code&gt; matches &lt;code&gt;apple&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;:word_start&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;start of word&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;app&lt;/code&gt; matches &lt;code&gt;apple&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;:word_middle&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;any part of word&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ppl&lt;/code&gt; matches &lt;code&gt;apple&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;:word_end&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;end of word&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ple&lt;/code&gt; matches &lt;code&gt;apple&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;:text_start&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;start of text&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;gre&lt;/code&gt; matches &lt;code&gt;green apple&lt;/code&gt;, &lt;code&gt;app&lt;/code&gt; does not match&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;:text_middle&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;any part of text&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;een app&lt;/code&gt; matches &lt;code&gt;green apple&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;:text_end&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;end of text&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ple&lt;/code&gt; matches &lt;code&gt;green apple&lt;/code&gt;, &lt;code&gt;een&lt;/code&gt; does not match&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The default is &lt;code&gt;:word&lt;/code&gt;. The most matches will happen with &lt;code&gt;:word_middle&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To specify different matching for different fields, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(query, fields: [{name: :word_start}, {brand: :word_middle}])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Exact Matches&lt;/h3&gt; &#xA;&lt;p&gt;To match a field exactly (case-sensitive), use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(query, fields: [{name: :exact}])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Phrase Matches&lt;/h3&gt; &#xA;&lt;p&gt;To only match the exact order, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;fresh honey&#34;, match: :phrase)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stemming and Language&lt;/h3&gt; &#xA;&lt;p&gt;Searchkick stems words by default for better matching. &lt;code&gt;apple&lt;/code&gt; and &lt;code&gt;apples&lt;/code&gt; both stem to &lt;code&gt;appl&lt;/code&gt;, so searches for either term will have the same matches.&lt;/p&gt; &#xA;&lt;p&gt;Searchkick defaults to English for stemming. To change this, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick language: &#34;german&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-stemmer-tokenfilter.html#analysis-stemmer-tokenfilter-configure-parms&#34;&gt;list of languages&lt;/a&gt;. A few languages require plugins:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;chinese&lt;/code&gt; - &lt;a href=&#34;https://github.com/medcl/elasticsearch-analysis-ik&#34;&gt;analysis-ik plugin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;chinese2&lt;/code&gt; - &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis-smartcn.html&#34;&gt;analysis-smartcn plugin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;japanese&lt;/code&gt; - &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis-kuromoji.html&#34;&gt;analysis-kuromoji plugin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;korean&lt;/code&gt; - &lt;a href=&#34;https://github.com/open-korean-text/elasticsearch-analysis-openkoreantext&#34;&gt;analysis-openkoreantext plugin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;korean2&lt;/code&gt; - &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis-nori.html&#34;&gt;analysis-nori plugin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;polish&lt;/code&gt; - &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis-stempel.html&#34;&gt;analysis-stempel plugin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ukrainian&lt;/code&gt; - &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/plugins/7.4/analysis-ukrainian.html&#34;&gt;analysis-ukrainian plugin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;vietnamese&lt;/code&gt; - &lt;a href=&#34;https://github.com/duydo/elasticsearch-analysis-vietnamese&#34;&gt;analysis-vietnamese plugin&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can also use a Hunspell dictionary for stemming.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick stemmer: {type: &#34;hunspell&#34;, locale: &#34;en_US&#34;}&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Disable stemming with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Image &amp;lt; ApplicationRecord&#xA;  searchkick stem: false&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Exclude certain words from stemming with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Image &amp;lt; ApplicationRecord&#xA;  searchkick stem_exclusion: [&#34;apples&#34;]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or change how words are stemmed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Image &amp;lt; ApplicationRecord&#xA;  searchkick stemmer_override: [&#34;apples =&amp;gt; other&#34;]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Synonyms&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick search_synonyms: [[&#34;pop&#34;, &#34;soda&#34;], [&#34;burger&#34;, &#34;hamburger&#34;]]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Call &lt;code&gt;Product.reindex&lt;/code&gt; after changing synonyms. Synonyms are applied at search time before stemming, and can be a single word or multiple words.&lt;/p&gt; &#xA;&lt;p&gt;For directional synonyms, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;search_synonyms: [&#34;lightbulb =&amp;gt; halogenlamp&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dynamic Synonyms&lt;/h3&gt; &#xA;&lt;p&gt;The above approach works well when your synonym list is static, but in practice, this is often not the case. When you analyze search conversions, you often want to add new synonyms without a full reindex.&lt;/p&gt; &#xA;&lt;h4&gt;Elasticsearch 7.3+ and OpenSearch&lt;/h4&gt; &#xA;&lt;p&gt;For Elasticsearch 7.3+ and OpenSearch, we recommend placing synonyms in a file on the search server (in the &lt;code&gt;config&lt;/code&gt; directory). This allows you to reload synonyms without reindexing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;pop, soda&#xA;burger, hamburger&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick search_synonyms: &#34;synonyms.txt&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And reload with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search_index.reload_synonyms&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Elasticsearch &amp;lt; 7.3&lt;/h4&gt; &#xA;&lt;p&gt;You can use a library like &lt;a href=&#34;https://github.com/mbleigh/acts-as-taggable-on&#34;&gt;ActsAsTaggableOn&lt;/a&gt; and do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  acts_as_taggable&#xA;  scope :search_import, -&amp;gt; { includes(:tags) }&#xA;&#xA;  def search_data&#xA;    {&#xA;      name_tagged: &#34;#{name} #{tags.map(&amp;amp;:name).join(&#34; &#34;)}&#34;&#xA;    }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Search with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(query, fields: [:name_tagged])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Misspellings&lt;/h3&gt; &#xA;&lt;p&gt;By default, Searchkick handles misspelled queries by returning results with an &lt;a href=&#34;https://en.wikipedia.org/wiki/Levenshtein_distance&#34;&gt;edit distance&lt;/a&gt; of one.&lt;/p&gt; &#xA;&lt;p&gt;You can change this with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;zucini&#34;, misspellings: {edit_distance: 2}) # zucchini&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To prevent poor precision and improve performance for correctly spelled queries (which should be a majority for most applications), Searchkick can first perform a search without misspellings, and if there are too few results, perform another with them.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;zuchini&#34;, misspellings: {below: 5})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If there are fewer than 5 results, a 2nd search is performed with misspellings enabled. The result of this query is returned.&lt;/p&gt; &#xA;&lt;p&gt;Turn off misspellings with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;zuchini&#34;, misspellings: false) # no zucchini&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Specify which fields can include misspellings with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;zucini&#34;, fields: [:name, :color], misspellings: {fields: [:name]})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;When doing this, you must also specify fields to search&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Bad Matches&lt;/h3&gt; &#xA;&lt;p&gt;If a user searches &lt;code&gt;butter&lt;/code&gt;, they may also get results for &lt;code&gt;peanut butter&lt;/code&gt;. To prevent this, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;butter&#34;, exclude: [&#34;peanut butter&#34;])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can map queries and terms to exclude with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;exclude_queries = {&#xA;  &#34;butter&#34; =&amp;gt; [&#34;peanut butter&#34;],&#xA;  &#34;cream&#34; =&amp;gt; [&#34;ice cream&#34;, &#34;whipped cream&#34;]&#xA;}&#xA;&#xA;Product.search(query, exclude: exclude_queries[query])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can demote results by boosting by a factor less than one:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;butter&#34;, boost_where: {category: {value: &#34;pantry&#34;, factor: 0.5}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Emoji&lt;/h3&gt; &#xA;&lt;p&gt;Search &lt;span&gt;üç®&lt;/span&gt;&lt;span&gt;üç∞&lt;/span&gt; and get &lt;code&gt;ice cream cake&lt;/code&gt;!&lt;/p&gt; &#xA;&lt;p&gt;Add this line to your application‚Äôs Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;gemoji-parser&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;üç®üç∞&#34;, emoji: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Indexing&lt;/h2&gt; &#xA;&lt;p&gt;Control what data is indexed with the &lt;code&gt;search_data&lt;/code&gt; method. Call &lt;code&gt;Product.reindex&lt;/code&gt; after changing this method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  belongs_to :department&#xA;&#xA;  def search_data&#xA;    {&#xA;      name: name,&#xA;      department_name: department.name,&#xA;      on_sale: sale_price.present?&#xA;    }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Searchkick uses &lt;code&gt;find_in_batches&lt;/code&gt; to import documents. To eager load associations, use the &lt;code&gt;search_import&lt;/code&gt; scope.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  scope :search_import, -&amp;gt; { includes(:department) }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, all records are indexed. To control which records are indexed, use the &lt;code&gt;should_index?&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  def should_index?&#xA;    active # only index active records&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If a reindex is interrupted, you can resume it with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.reindex(resume: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For large data sets, try &lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#parallel-reindexing&#34;&gt;parallel reindexing&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;To Reindex, or Not to Reindex&lt;/h3&gt; &#xA;&lt;h4&gt;Reindex&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;when you install or upgrade searchkick&lt;/li&gt; &#xA; &lt;li&gt;change the &lt;code&gt;search_data&lt;/code&gt; method&lt;/li&gt; &#xA; &lt;li&gt;change the &lt;code&gt;searchkick&lt;/code&gt; method&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;No need to reindex&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;app starts&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Strategies&lt;/h3&gt; &#xA;&lt;p&gt;There are four strategies for keeping the index synced with your database.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Inline (default)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Anytime a record is inserted, updated, or deleted&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Asynchronous&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Use background jobs for better performance&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick callbacks: :async&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Jobs are added to a queue named &lt;code&gt;searchkick&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Queuing&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Push ids of records that need updated to a queue and reindex in the background in batches. This is more performant than the asynchronous method, which updates records individually. See &lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#queuing&#34;&gt;how to set up&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Manual&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Turn off automatic syncing&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick callbacks: false&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And reindex a record or relation manually.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;product.reindex&#xA;# or&#xA;store.products.reindex(mode: :async)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also do bulk updates.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.callbacks(:bulk) do&#xA;  Product.find_each(&amp;amp;:update_fields)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or temporarily skip updates.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.callbacks(false) do&#xA;  Product.find_each(&amp;amp;:update_fields)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or override the model‚Äôs strategy.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;product.reindex(mode: :async) # :inline or :queue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Associations&lt;/h3&gt; &#xA;&lt;p&gt;Data is &lt;strong&gt;not&lt;/strong&gt; automatically synced when an association is updated. If this is desired, add a callback to reindex:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Image &amp;lt; ApplicationRecord&#xA;  belongs_to :product&#xA;&#xA;  after_commit :reindex_product&#xA;&#xA;  def reindex_product&#xA;    product.reindex&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Default Scopes&lt;/h3&gt; &#xA;&lt;p&gt;If you have a default scope that filters records, use the &lt;code&gt;should_index?&lt;/code&gt; method to exclude them from indexing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  default_scope { where(deleted_at: nil) }&#xA;&#xA;  def should_index?&#xA;    deleted_at.nil?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to index and search filtered records, set:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick unscope: true&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Intelligent Search&lt;/h2&gt; &#xA;&lt;p&gt;The best starting point to improve your search &lt;strong&gt;by far&lt;/strong&gt; is to track searches and conversions. &lt;a href=&#34;https://github.com/ankane/searchjoy&#34;&gt;Searchjoy&lt;/a&gt; makes it easy.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;apple&#34;, track: {user_id: current_user.id})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ankane/searchjoy&#34;&gt;See the docs&lt;/a&gt; for how to install and use. Focus on top searches with a low conversion rate.&lt;/p&gt; &#xA;&lt;p&gt;Searchkick can then use the conversion data to learn what users are looking for. If a user searches for ‚Äúice cream‚Äù and adds Ben &amp;amp; Jerry‚Äôs Chunky Monkey to the cart (our conversion metric at Instacart), that item gets a little more weight for similar searches. This can make a huge difference on the quality of your search.&lt;/p&gt; &#xA;&lt;p&gt;Add conversion data with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  has_many :conversions, class_name: &#34;Searchjoy::Conversion&#34;, as: :convertable&#xA;  has_many :searches, class_name: &#34;Searchjoy::Search&#34;, through: :conversions&#xA;&#xA;  searchkick conversions: [:conversions] # name of field&#xA;&#xA;  def search_data&#xA;    {&#xA;      name: name,&#xA;      conversions: searches.group(:query).distinct.count(:user_id)&#xA;      # {&#34;ice cream&#34; =&amp;gt; 234, &#34;chocolate&#34; =&amp;gt; 67, &#34;cream&#34; =&amp;gt; 2}&#xA;    }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Reindex and set up a cron job to add new conversions daily. For zero downtime deployment, temporarily set &lt;code&gt;conversions: false&lt;/code&gt; in your search calls until the data is reindexed.&lt;/p&gt; &#xA;&lt;h3&gt;Performant Conversions&lt;/h3&gt; &#xA;&lt;p&gt;A performant way to do conversions is to cache them to prevent N+1 queries. For Postgres, create a migration with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;add_column :products, :search_conversions, :jsonb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For MySQL, use &lt;code&gt;:json&lt;/code&gt;, and for others, use &lt;code&gt;:text&lt;/code&gt; with a &lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveRecord/AttributeMethods/Serialization/ClassMethods.html&#34;&gt;JSON serializer&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Next, update your model. Create a separate method for conversion data so you can use &lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#partial-reindexing&#34;&gt;partial reindexing&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick conversions: [:conversions]&#xA;&#xA;  def search_data&#xA;    {&#xA;      name: name,&#xA;      category: category&#xA;    }.merge(conversions_data)&#xA;  end&#xA;&#xA;  def conversions_data&#xA;    {&#xA;      conversions: search_conversions || {}&#xA;    }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Deploy and reindex your data. For zero downtime deployment, temporarily set &lt;code&gt;conversions: false&lt;/code&gt; in your search calls until the data is reindexed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.reindex&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, create a job to update the conversions column and reindex records with new conversions. Here‚Äôs one you can use for Searchjoy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UpdateConversionsJob &amp;lt; ApplicationJob&#xA;  def perform(class_name, since: nil, update: true, reindex: true)&#xA;    model = Searchkick.load_model(class_name)&#xA;&#xA;    # get records that have a recent conversion&#xA;    recently_converted_ids =&#xA;      Searchjoy::Conversion.where(convertable_type: class_name).where(created_at: since..)&#xA;      .order(:convertable_id).distinct.pluck(:convertable_id)&#xA;&#xA;    # split into batches&#xA;    recently_converted_ids.in_groups_of(1000, false) do |ids|&#xA;      if update&#xA;        # fetch conversions&#xA;        conversions =&#xA;          Searchjoy::Conversion.where(convertable_id: ids, convertable_type: class_name)&#xA;          .joins(:search).where.not(searchjoy_searches: {user_id: nil})&#xA;          .group(:convertable_id, :query).distinct.count(:user_id)&#xA;&#xA;        # group by record&#xA;        conversions_by_record = {}&#xA;        conversions.each do |(id, query), count|&#xA;          (conversions_by_record[id] ||= {})[query] = count&#xA;        end&#xA;&#xA;        # update conversions column&#xA;        model.transaction do&#xA;          conversions_by_record.each do |id, conversions|&#xA;            model.where(id: id).update_all(search_conversions: conversions)&#xA;          end&#xA;        end&#xA;      end&#xA;&#xA;      if reindex&#xA;        # reindex conversions data&#xA;        model.where(id: ids).reindex(:conversions_data)&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the job:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;UpdateConversionsJob.perform_now(&#34;Product&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And set it up to run daily.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;UpdateConversionsJob.perform_later(&#34;Product&#34;, since: 1.day.ago)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Personalized Results&lt;/h2&gt; &#xA;&lt;p&gt;Order results differently for each user. For example, show a user‚Äôs previously purchased products before other results.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  def search_data&#xA;    {&#xA;      name: name,&#xA;      orderer_ids: orders.pluck(:user_id) # boost this product for these users&#xA;    }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Reindex and search with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;milk&#34;, boost_where: {orderer_ids: current_user.id})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Instant Search / Autocomplete&lt;/h2&gt; &#xA;&lt;p&gt;Autocomplete predicts what a user will type, making the search experience faster and easier.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://gist.githubusercontent.com/ankane/b6988db2802aca68a589b31e41b44195/raw/40febe948427e5bc53ec4e5dc248822855fef76f/autocomplete.png&#34; alt=&#34;Autocomplete&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; To autocomplete on search terms rather than results, check out &lt;a href=&#34;https://github.com/ankane/autosuggest&#34;&gt;Autosuggest&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note 2:&lt;/strong&gt; If you only have a few thousand records, don‚Äôt use Searchkick for autocomplete. It‚Äôs &lt;em&gt;much&lt;/em&gt; faster to load all records into JavaScript and autocomplete there (eliminates network requests).&lt;/p&gt; &#xA;&lt;p&gt;First, specify which fields use this feature. This is necessary since autocomplete can increase the index size significantly, but don‚Äôt worry - this gives you blazing faster queries.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Movie &amp;lt; ApplicationRecord&#xA;  searchkick word_start: [:title, :director]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Reindex and search with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Movie.search(&#34;jurassic pa&#34;, fields: [:title], match: :word_start)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Typically, you want to use a JavaScript library like &lt;a href=&#34;https://twitter.github.io/typeahead.js/&#34;&gt;typeahead.js&lt;/a&gt; or &lt;a href=&#34;https://jqueryui.com/autocomplete/&#34;&gt;jQuery UI&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Here‚Äôs how to make it work with Rails&lt;/h4&gt; &#xA;&lt;p&gt;First, add a route and controller action.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MoviesController &amp;lt; ApplicationController&#xA;  def autocomplete&#xA;    render json: Movie.search(params[:query], {&#xA;      fields: [&#34;title^5&#34;, &#34;director&#34;],&#xA;      match: :word_start,&#xA;      limit: 10,&#xA;      load: false,&#xA;      misspellings: {below: 5}&#xA;    }).map(&amp;amp;:title)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Use &lt;code&gt;load: false&lt;/code&gt; and &lt;code&gt;misspellings: {below: n}&lt;/code&gt; (or &lt;code&gt;misspellings: false&lt;/code&gt;) for best performance.&lt;/p&gt; &#xA;&lt;p&gt;Then add the search box and JavaScript code to a view.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input type=&#34;text&#34; id=&#34;query&#34; name=&#34;query&#34; /&amp;gt;&#xA;&#xA;&amp;lt;script src=&#34;jquery.js&#34;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&#34;typeahead.bundle.js&#34;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script&amp;gt;&#xA;  var movies = new Bloodhound({&#xA;    datumTokenizer: Bloodhound.tokenizers.whitespace,&#xA;    queryTokenizer: Bloodhound.tokenizers.whitespace,&#xA;    remote: {&#xA;      url: &#39;/movies/autocomplete?query=%QUERY&#39;,&#xA;      wildcard: &#39;%QUERY&#39;&#xA;    }&#xA;  });&#xA;  $(&#39;#query&#39;).typeahead(null, {&#xA;    source: movies&#xA;  });&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Suggestions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://gist.githubusercontent.com/ankane/b6988db2802aca68a589b31e41b44195/raw/40febe948427e5bc53ec4e5dc248822855fef76f/recursion.png&#34; alt=&#34;Suggest&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick suggest: [:name] # fields to generate suggestions&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Reindex and search with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;products = Product.search(&#34;peantu butta&#34;, suggest: true)&#xA;products.suggestions # [&#34;peanut butter&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Aggregations&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html&#34;&gt;Aggregations&lt;/a&gt; provide aggregated search data.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://gist.githubusercontent.com/ankane/b6988db2802aca68a589b31e41b44195/raw/40febe948427e5bc53ec4e5dc248822855fef76f/facets.png&#34; alt=&#34;Aggregations&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;products = Product.search(&#34;chuck taylor&#34;, aggs: [:product_type, :gender, :brand])&#xA;products.aggs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;where&lt;/code&gt; conditions apply to aggregations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;wingtips&#34;, where: {color: &#34;brandy&#34;}, aggs: [:size])&#xA;# aggregations for brandy wingtips are returned&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Change this with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;wingtips&#34;, where: {color: &#34;brandy&#34;}, aggs: [:size], smart_aggs: false)&#xA;# aggregations for all wingtips are returned&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set &lt;code&gt;where&lt;/code&gt; conditions for each aggregation separately with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;wingtips&#34;, aggs: {size: {where: {color: &#34;brandy&#34;}}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Limit&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;apples&#34;, aggs: {store_id: {limit: 10}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Order&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;wingtips&#34;, aggs: {color: {order: {&#34;_key&#34; =&amp;gt; &#34;asc&#34;}}}) # alphabetically&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-order&#34;&gt;All of these options are supported&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ranges&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;price_ranges = [{to: 20}, {from: 20, to: 50}, {from: 50}]&#xA;Product.search(&#34;*&#34;, aggs: {price: {ranges: price_ranges}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Minimum document count&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;apples&#34;, aggs: {store_id: {min_doc_count: 2}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Script support&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;*&#34;, aggs: {color: {script: {source: &#34;&#39;Color: &#39; + _value&#34;}}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Date histogram&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;pear&#34;, aggs: {products_per_year: {date_histogram: {field: :created_at, interval: :year}}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For other aggregation types, including sub-aggregations, use &lt;code&gt;body_options&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;orange&#34;, body_options: {aggs: {price: {histogram: {field: :price, interval: 10}}}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Highlight&lt;/h2&gt; &#xA;&lt;p&gt;Specify which fields to index with highlighting.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Band &amp;lt; ApplicationRecord&#xA;  searchkick highlight: [:name]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Highlight the search query in the results.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;bands = Band.search(&#34;cinema&#34;, highlight: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;View the highlighted fields with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;bands.with_highlights.each do |band, highlights|&#xA;  highlights[:name] # &#34;Two Door &amp;lt;em&amp;gt;Cinema&amp;lt;/em&amp;gt; Club&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To change the tag, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Band.search(&#34;cinema&#34;, highlight: {tag: &#34;&amp;lt;strong&amp;gt;&#34;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To highlight and search different fields, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Band.search(&#34;cinema&#34;, fields: [:name], highlight: {fields: [:description]})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the entire field is highlighted. To get small snippets instead, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;bands = Band.search(&#34;cinema&#34;, highlight: {fragment_size: 20})&#xA;bands.with_highlights(multiple: true).each do |band, highlights|&#xA;  highlights[:name].join(&#34; and &#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additional options can be specified for each field:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Band.search(&#34;cinema&#34;, fields: [:name], highlight: {fields: {name: {fragment_size: 200}}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can find available highlight options in the &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/highlighting.html&#34;&gt;Elasticsearch reference&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Similar Items&lt;/h2&gt; &#xA;&lt;p&gt;Find similar items.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;product = Product.first&#xA;product.similar(fields: [:name], where: {size: &#34;12 oz&#34;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Geospatial Searches&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Restaurant &amp;lt; ApplicationRecord&#xA;  searchkick locations: [:location]&#xA;&#xA;  def search_data&#xA;    attributes.merge(location: {lat: latitude, lon: longitude})&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Reindex and search with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Restaurant.search(&#34;pizza&#34;, where: {location: {near: {lat: 37, lon: -114}, within: &#34;100mi&#34;}}) # or 160km&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Bounded by a box&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Restaurant.search(&#34;sushi&#34;, where: {location: {top_left: {lat: 38, lon: -123}, bottom_right: {lat: 37, lon: -122}}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;code&gt;top_right&lt;/code&gt; and &lt;code&gt;bottom_left&lt;/code&gt; also work&lt;/p&gt; &#xA;&lt;p&gt;Bounded by a polygon&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Restaurant.search(&#34;dessert&#34;, where: {location: {geo_polygon: {points: [{lat: 38, lon: -123}, {lat: 39, lon: -123}, {lat: 37, lon: 122}]}}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Boost By Distance&lt;/h3&gt; &#xA;&lt;p&gt;Boost results by distance - closer results are boosted more&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Restaurant.search(&#34;noodles&#34;, boost_by_distance: {location: {origin: {lat: 37, lon: -122}}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also supports &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#function-decay&#34;&gt;additional options&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Restaurant.search(&#34;wings&#34;, boost_by_distance: {location: {origin: {lat: 37, lon: -122}, function: &#34;linear&#34;, scale: &#34;30mi&#34;, decay: 0.5}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Geo Shapes&lt;/h3&gt; &#xA;&lt;p&gt;You can also index and search geo shapes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Restaurant &amp;lt; ApplicationRecord&#xA;  searchkick geo_shape: [:bounds]&#xA;&#xA;  def search_data&#xA;    attributes.merge(&#xA;      bounds: {&#xA;        type: &#34;envelope&#34;,&#xA;        coordinates: [{lat: 4, lon: 1}, {lat: 2, lon: 3}]&#xA;      }&#xA;    )&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-shape.html&#34;&gt;Elasticsearch documentation&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;p&gt;Find shapes intersecting with the query shape&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Restaurant.search(&#34;soup&#34;, where: {bounds: {geo_shape: {type: &#34;polygon&#34;, coordinates: [[{lat: 38, lon: -123}, ...]]}}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Falling entirely within the query shape&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Restaurant.search(&#34;salad&#34;, where: {bounds: {geo_shape: {type: &#34;circle&#34;, relation: &#34;within&#34;, coordinates: {lat: 38, lon: -123}, radius: &#34;1km&#34;}}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Not touching the query shape&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Restaurant.search(&#34;burger&#34;, where: {bounds: {geo_shape: {type: &#34;envelope&#34;, relation: &#34;disjoint&#34;, coordinates: [{lat: 38, lon: -123}, {lat: 37, lon: -122}]}}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Inheritance&lt;/h2&gt; &#xA;&lt;p&gt;Searchkick supports single table inheritance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Dog &amp;lt; Animal&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In your parent model, set:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Animal &amp;lt; ApplicationRecord&#xA;  searchkick inheritance: true&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The parent and child model can both reindex.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Animal.reindex&#xA;Dog.reindex # equivalent, all animals reindexed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And to search, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Animal.search(&#34;*&#34;)                   # all animals&#xA;Dog.search(&#34;*&#34;)                      # just dogs&#xA;Animal.search(&#34;*&#34;, type: [Dog, Cat]) # just cats and dogs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Notes:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;code&gt;suggest&lt;/code&gt; option retrieves suggestions from the parent at the moment.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Dog.search(&#34;airbudd&#34;, suggest: true) # suggestions for all animals&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;This relies on a &lt;code&gt;type&lt;/code&gt; field that is automatically added to the indexed document. Be wary of defining your own &lt;code&gt;type&lt;/code&gt; field in &lt;code&gt;search_data&lt;/code&gt;, as it will take precedence.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Debugging Queries&lt;/h2&gt; &#xA;&lt;p&gt;To help with debugging queries, you can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;soap&#34;, debug: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This prints useful info to &lt;code&gt;stdout&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See how the search server scores your queries with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;soap&#34;, explain: true).response&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See how the search server tokenizes your queries with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search_index.tokens(&#34;Dish Washer Soap&#34;, analyzer: &#34;searchkick_index&#34;)&#xA;# [&#34;dish&#34;, &#34;dishwash&#34;, &#34;washer&#34;, &#34;washersoap&#34;, &#34;soap&#34;]&#xA;&#xA;Product.search_index.tokens(&#34;dishwasher soap&#34;, analyzer: &#34;searchkick_search&#34;)&#xA;# [&#34;dishwashersoap&#34;] - no match&#xA;&#xA;Product.search_index.tokens(&#34;dishwasher soap&#34;, analyzer: &#34;searchkick_search2&#34;)&#xA;# [&#34;dishwash&#34;, &#34;soap&#34;] - match!!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Partial matches&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search_index.tokens(&#34;San Diego&#34;, analyzer: &#34;searchkick_word_start_index&#34;)&#xA;# [&#34;s&#34;, &#34;sa&#34;, &#34;san&#34;, &#34;d&#34;, &#34;di&#34;, &#34;die&#34;, &#34;dieg&#34;, &#34;diego&#34;]&#xA;&#xA;Product.search_index.tokens(&#34;dieg&#34;, analyzer: &#34;searchkick_word_search&#34;)&#xA;# [&#34;dieg&#34;] - match!!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/lib/searchkick/index_options.rb#L36&#34;&gt;complete list of analyzers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;As you iterate on your search, it‚Äôs a good idea to add tests.&lt;/p&gt; &#xA;&lt;p&gt;For performance, only enable Searchkick callbacks for the tests that need it.&lt;/p&gt; &#xA;&lt;h3&gt;Parallel Tests&lt;/h3&gt; &#xA;&lt;p&gt;Rails 6 enables parallel tests by default. Add to your &lt;code&gt;test/test_helper.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ActiveSupport::TestCase&#xA;  parallelize_setup do |worker|&#xA;    Searchkick.index_suffix = worker&#xA;&#xA;    # reindex models&#xA;    Product.reindex&#xA;&#xA;    # and disable callbacks&#xA;    Searchkick.disable_callbacks&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProductTest &amp;lt; ActiveSupport::TestCase&#xA;  def setup&#xA;    Searchkick.enable_callbacks&#xA;  end&#xA;&#xA;  def teardown&#xA;    Searchkick.disable_callbacks&#xA;  end&#xA;&#xA;  def test_search&#xA;    Product.create!(name: &#34;Apple&#34;)&#xA;    Product.search_index.refresh&#xA;    assert_equal [&#34;Apple&#34;], Product.search(&#34;apple&#34;).map(&amp;amp;:name)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Minitest&lt;/h3&gt; &#xA;&lt;p&gt;Add to your &lt;code&gt;test/test_helper.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# reindex models&#xA;Product.reindex&#xA;&#xA;# and disable callbacks&#xA;Searchkick.disable_callbacks&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProductTest &amp;lt; Minitest::Test&#xA;  def setup&#xA;    Searchkick.enable_callbacks&#xA;  end&#xA;&#xA;  def teardown&#xA;    Searchkick.disable_callbacks&#xA;  end&#xA;&#xA;  def test_search&#xA;    Product.create!(name: &#34;Apple&#34;)&#xA;    Product.search_index.refresh&#xA;    assert_equal [&#34;Apple&#34;], Product.search(&#34;apple&#34;).map(&amp;amp;:name)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;RSpec&lt;/h3&gt; &#xA;&lt;p&gt;Add to your &lt;code&gt;spec/spec_helper.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;RSpec.configure do |config|&#xA;  config.before(:suite) do&#xA;    # reindex models&#xA;    Product.reindex&#xA;&#xA;    # and disable callbacks&#xA;    Searchkick.disable_callbacks&#xA;  end&#xA;&#xA;  config.around(:each, search: true) do |example|&#xA;    Searchkick.callbacks(nil) do&#xA;      example.run&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;describe Product, search: true do&#xA;  it &#34;searches&#34; do&#xA;    Product.create!(name: &#34;Apple&#34;)&#xA;    Product.search_index.refresh&#xA;    assert_equal [&#34;Apple&#34;], Product.search(&#34;apple&#34;).map(&amp;amp;:name)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Factory Bot&lt;/h3&gt; &#xA;&lt;p&gt;Use a trait and an after &lt;code&gt;create&lt;/code&gt; hook for each indexed model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;FactoryBot.define do&#xA;  factory :product do&#xA;    # ...&#xA;&#xA;    # Note: This should be the last trait in the list so `reindex` is called&#xA;    # after all the other callbacks complete.&#xA;    trait :reindex do&#xA;      after(:create) do |product, _evaluator|&#xA;        product.reindex(refresh: true)&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;# use it&#xA;FactoryBot.create(:product, :some_trait, :reindex, some_attribute: &#34;foo&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;GitHub Actions&lt;/h3&gt; &#xA;&lt;p&gt;Check out &lt;a href=&#34;https://github.com/ankane/setup-elasticsearch&#34;&gt;setup-elasticsearch&lt;/a&gt; for an easy way to install Elasticsearch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;    - uses: ankane/setup-elasticsearch@v1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And &lt;a href=&#34;https://github.com/ankane/setup-opensearch&#34;&gt;setup-opensearch&lt;/a&gt; for an easy way to install OpenSearch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;    - uses: ankane/setup-opensearch@v1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Deployment&lt;/h2&gt; &#xA;&lt;p&gt;For the search server, Searchkick uses &lt;code&gt;ENV[&#34;ELASTICSEARCH_URL&#34;]&lt;/code&gt; for Elasticsearch and &lt;code&gt;ENV[&#34;OPENSEARCH_URL&#34;]&lt;/code&gt; for OpenSearch. This defaults to &lt;code&gt;http://localhost:9200&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#elastic-cloud&#34;&gt;Elastic Cloud&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#heroku&#34;&gt;Heroku&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#amazon-opensearch-service&#34;&gt;Amazon OpenSearch Service&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#self-hosted-and-other&#34;&gt;Self-Hosted and Other&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Elastic Cloud&lt;/h3&gt; &#xA;&lt;p&gt;Create an initializer &lt;code&gt;config/initializers/elasticsearch.rb&lt;/code&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ENV[&#34;ELASTICSEARCH_URL&#34;] = &#34;https://user:password@host:port&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then deploy and reindex:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rake searchkick:reindex:all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Heroku&lt;/h3&gt; &#xA;&lt;p&gt;Choose an add-on: &lt;a href=&#34;https://elements.heroku.com/addons/bonsai&#34;&gt;Bonsai&lt;/a&gt;, &lt;a href=&#34;https://elements.heroku.com/addons/searchbox&#34;&gt;SearchBox&lt;/a&gt;, or &lt;a href=&#34;https://elements.heroku.com/addons/foundelasticsearch&#34;&gt;Elastic Cloud&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For Elasticsearch on Bonsai:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;heroku addons:create bonsai&#xA;heroku config:set ELASTICSEARCH_URL=`heroku config:get BONSAI_URL`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For OpenSearch on Bonsai:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;heroku addons:create bonsai --engine=opensearch&#xA;heroku config:set OPENSEARCH_URL=`heroku config:get BONSAI_URL`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For SearchBox:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;heroku addons:create searchbox:starter&#xA;heroku config:set ELASTICSEARCH_URL=`heroku config:get SEARCHBOX_URL`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Elastic Cloud (previously Found):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;heroku addons:create foundelasticsearch&#xA;heroku addons:open foundelasticsearch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Visit the Shield page and reset your password. You‚Äôll need to add the username and password to your url. Get the existing url with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;heroku config:get FOUNDELASTICSEARCH_URL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And add &lt;code&gt;elastic:password@&lt;/code&gt; right after &lt;code&gt;https://&lt;/code&gt; and add port &lt;code&gt;9243&lt;/code&gt; at the end:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;heroku config:set ELASTICSEARCH_URL=https://elastic:password@12345.us-east-1.aws.found.io:9243&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then deploy and reindex:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;heroku run rake searchkick:reindex:all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Amazon OpenSearch Service&lt;/h3&gt; &#xA;&lt;p&gt;Create an initializer &lt;code&gt;config/initializers/opensearch.rb&lt;/code&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ENV[&#34;OPENSEARCH_URL&#34;] = &#34;https://es-domain-1234.us-east-1.es.amazonaws.com:443&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To use signed requests, include in your Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;faraday_middleware-aws-sigv4&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and add to your initializer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.aws_credentials = {&#xA;  access_key_id: ENV[&#34;AWS_ACCESS_KEY_ID&#34;],&#xA;  secret_access_key: ENV[&#34;AWS_SECRET_ACCESS_KEY&#34;],&#xA;  region: &#34;us-east-1&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then deploy and reindex:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rake searchkick:reindex:all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Self-Hosted and Other&lt;/h3&gt; &#xA;&lt;p&gt;Create an initializer with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ENV[&#34;ELASTICSEARCH_URL&#34;] = &#34;https://user:password@host:port&#34;&#xA;# or&#xA;ENV[&#34;OPENSEARCH_URL&#34;] = &#34;https://user:password@host:port&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then deploy and reindex:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rake searchkick:reindex:all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Data Protection&lt;/h3&gt; &#xA;&lt;p&gt;We recommend encrypting data at rest and in transit (even inside your own network). This is especially important if you send &lt;a href=&#34;https://en.wikipedia.org/wiki/Personally_identifiable_information&#34;&gt;personal data&lt;/a&gt; of your users to the search server.&lt;/p&gt; &#xA;&lt;p&gt;Bonsai, Elastic Cloud, and Amazon OpenSearch Service all support encryption at rest and HTTPS.&lt;/p&gt; &#xA;&lt;h3&gt;Automatic Failover&lt;/h3&gt; &#xA;&lt;p&gt;Create an initializer with multiple hosts:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ENV[&#34;ELASTICSEARCH_URL&#34;] = &#34;https://user:password@host1,https://user:password@host2&#34;&#xA;# or&#xA;ENV[&#34;OPENSEARCH_URL&#34;] = &#34;https://user:password@host1,https://user:password@host2&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Client Options&lt;/h3&gt; &#xA;&lt;p&gt;Create an initializer with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.client_options[:reload_connections] = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the docs for &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/ruby-api/current/advanced-config.html&#34;&gt;Elasticsearch&lt;/a&gt; or &lt;a href=&#34;https://rubydoc.info/gems/opensearch-transport#configuration&#34;&gt;Opensearch&lt;/a&gt; for a complete list of options.&lt;/p&gt; &#xA;&lt;h3&gt;Lograge&lt;/h3&gt; &#xA;&lt;p&gt;Add the following to &lt;code&gt;config/environments/production.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.lograge.custom_options = lambda do |event|&#xA;  options = {}&#xA;  options[:search] = event.payload[:searchkick_runtime] if event.payload[:searchkick_runtime].to_f &amp;gt; 0&#xA;  options&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/ankane/production_rails&#34;&gt;Production Rails&lt;/a&gt; for other good practices.&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;h3&gt;JSON Generation&lt;/h3&gt; &#xA;&lt;p&gt;Significantly increase performance with faster JSON generation. Add &lt;a href=&#34;https://github.com/ohler55/oj&#34;&gt;Oj&lt;/a&gt; to your Gemfile.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;oj&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This speeds up all JSON generation and parsing in your application (automatically!)&lt;/p&gt; &#xA;&lt;h3&gt;Persistent HTTP Connections&lt;/h3&gt; &#xA;&lt;p&gt;Significantly increase performance with persistent HTTP connections. Add &lt;a href=&#34;https://github.com/typhoeus/typhoeus&#34;&gt;Typhoeus&lt;/a&gt; to your Gemfile and it‚Äôll automatically be used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;typhoeus&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To reduce log noise, create an initializer with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Ethon.logger = Logger.new(nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you run into issues on Windows, check out &lt;a href=&#34;https://www.rastating.com/fixing-issues-in-typhoeus-and-httparty-on-windows/&#34;&gt;this post&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Searchable Fields&lt;/h3&gt; &#xA;&lt;p&gt;By default, all string fields are searchable (can be used in &lt;code&gt;fields&lt;/code&gt; option). Speed up indexing and reduce index size by only making some fields searchable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick searchable: [:name]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Filterable Fields&lt;/h3&gt; &#xA;&lt;p&gt;By default, all string fields are filterable (can be used in &lt;code&gt;where&lt;/code&gt; option). Speed up indexing and reduce index size by only making some fields filterable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick filterable: [:brand]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Non-string fields are always filterable and should not be passed to this option.&lt;/p&gt; &#xA;&lt;h3&gt;Parallel Reindexing&lt;/h3&gt; &#xA;&lt;p&gt;For large data sets, you can use background jobs to parallelize reindexing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.reindex(mode: :async)&#xA;# {index_name: &#34;products_production_20170111210018065&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once the jobs complete, promote the new index with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search_index.promote(index_name)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can optionally track the status with Redis:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.redis = Redis.new&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.reindex_status(index_name)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also have Searchkick wait for reindexing to complete&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.reindex(mode: :async, wait: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;https://github.com/nickelser/activejob-traffic_control&#34;&gt;ActiveJob::TrafficControl&lt;/a&gt; to control concurrency. Install the gem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;activejob-traffic_control&#34;, &#34;&amp;gt;= 0.1.3&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And create an initializer with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ActiveJob::TrafficControl.client = Searchkick.redis&#xA;&#xA;class Searchkick::BulkReindexJob&#xA;  concurrency 3&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will allow only 3 jobs to run at once.&lt;/p&gt; &#xA;&lt;h3&gt;Refresh Interval&lt;/h3&gt; &#xA;&lt;p&gt;You can specify a longer refresh interval while reindexing to increase performance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.reindex(mode: :async, refresh_interval: &#34;30s&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This only makes a noticable difference with parallel reindexing.&lt;/p&gt; &#xA;&lt;p&gt;When promoting, have it restored to the value in your mapping (defaults to &lt;code&gt;1s&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search_index.promote(index_name, update_refresh_interval: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Queuing&lt;/h3&gt; &#xA;&lt;p&gt;Push ids of records needing reindexing to a queue and reindex in bulk for better performance. First, set up Redis in an initializer. We recommend using &lt;a href=&#34;https://github.com/mperham/connection_pool&#34;&gt;connection_pool&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.redis = ConnectionPool.new { Redis.new }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And ask your models to queue updates.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick callbacks: :queue&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, set up a background job to run.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick::ProcessQueueJob.perform_later(class_name: &#34;Product&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can check the queue length with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search_index.reindex_queue.length&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more tips, check out &lt;a href=&#34;https://www.elastic.co/blog/found-keeping-elasticsearch-in-sync&#34;&gt;Keeping Elasticsearch in Sync&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Routing&lt;/h3&gt; &#xA;&lt;p&gt;Searchkick supports &lt;a href=&#34;https://www.elastic.co/blog/customizing-your-document-routing&#34;&gt;routing&lt;/a&gt;, which can significantly speed up searches.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Business &amp;lt; ApplicationRecord&#xA;  searchkick routing: true&#xA;&#xA;  def search_routing&#xA;    city_id&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Reindex and search with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Business.search(&#34;ice cream&#34;, routing: params[:city_id])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Partial Reindexing&lt;/h3&gt; &#xA;&lt;p&gt;Reindex a subset of attributes to reduce time spent generating search data and cut down on network traffic.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  def search_data&#xA;    {&#xA;      name: name,&#xA;      category: category&#xA;    }.merge(prices_data)&#xA;  end&#xA;&#xA;  def prices_data&#xA;    {&#xA;      price: price,&#xA;      sale_price: sale_price&#xA;    }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.reindex(:prices_data)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Advanced&lt;/h2&gt; &#xA;&lt;p&gt;Searchkick makes it easy to use the Elasticsearch or OpenSearch DSL on its own.&lt;/p&gt; &#xA;&lt;h3&gt;Advanced Mapping&lt;/h3&gt; &#xA;&lt;p&gt;Create a custom mapping:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick mappings: {&#xA;    properties: {&#xA;      name: {type: &#34;keyword&#34;}&#xA;    }&#xA;  }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you use a custom mapping, you&#39;ll need to use &lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#advanced-search&#34;&gt;custom searching&lt;/a&gt; as well.&lt;/p&gt; &#xA;&lt;p&gt;To keep the mappings and settings generated by Searchkick, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick merge_mappings: true, mappings: {...}&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Advanced Search&lt;/h3&gt; &#xA;&lt;p&gt;And use the &lt;code&gt;body&lt;/code&gt; option to search:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;products = Product.search(body: {query: {match: {name: &#34;milk&#34;}}})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;View the response with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;products.response&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To modify the query generated by Searchkick, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;products = Product.search(&#34;milk&#34;, body_options: {min_score: 1})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;products =&#xA;  Product.search(&#34;apples&#34;) do |body|&#xA;    body[:min_score] = 1&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Client&lt;/h3&gt; &#xA;&lt;p&gt;To access the &lt;code&gt;Elasticsearch::Client&lt;/code&gt; or &lt;code&gt;OpenSearch::Client&lt;/code&gt; directly, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.client&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Multi Search&lt;/h2&gt; &#xA;&lt;p&gt;To batch search requests for performance, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;products = Product.search(&#34;snacks&#34;)&#xA;coupons = Coupon.search(&#34;snacks&#34;)&#xA;Searchkick.multi_search([products, coupons])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then use &lt;code&gt;products&lt;/code&gt; and &lt;code&gt;coupons&lt;/code&gt; as typical results.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Errors are not raised as with single requests. Use the &lt;code&gt;error&lt;/code&gt; method on each query to check for errors.&lt;/p&gt; &#xA;&lt;h2&gt;Multiple Models&lt;/h2&gt; &#xA;&lt;p&gt;Search across multiple models with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.search(&#34;milk&#34;, models: [Product, Category])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Boost specific models with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;indices_boost: {Category =&amp;gt; 2, Product =&amp;gt; 1}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Multi-Tenancy&lt;/h2&gt; &#xA;&lt;p&gt;Check out &lt;a href=&#34;https://www.tiagoamaro.com.br/2014/12/11/multi-tenancy-with-searchkick/&#34;&gt;this great post&lt;/a&gt; on the &lt;a href=&#34;https://github.com/influitive/apartment&#34;&gt;Apartment&lt;/a&gt; gem. Follow a similar pattern if you use another gem.&lt;/p&gt; &#xA;&lt;h2&gt;Scroll API&lt;/h2&gt; &#xA;&lt;p&gt;Searchkick also supports the &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#scroll-search-results&#34;&gt;scroll API&lt;/a&gt;. Scrolling is not intended for real time user requests, but rather for processing large amounts of data.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;*&#34;, scroll: &#34;1m&#34;).scroll do |batch|&#xA;  # process batch ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also scroll batches manually.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;products = Product.search(&#34;*&#34;, scroll: &#34;1m&#34;)&#xA;while products.any?&#xA;  # process batch ...&#xA;&#xA;  products = products.scroll&#xA;end&#xA;&#xA;products.clear_scroll&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Deep Paging&lt;/h2&gt; &#xA;&lt;p&gt;By default, Elasticsearch and OpenSearch limit paging to the first 10,000 results. &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/guide/current/pagination.html&#34;&gt;Here‚Äôs why&lt;/a&gt;. We don‚Äôt recommend changing this, but if you really need all results, you can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick deep_paging: true&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you just need an accurate total count, you can instead use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;pears&#34;, body_options: {track_total_hits: true})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Nested Data&lt;/h2&gt; &#xA;&lt;p&gt;To query nested data, use dot notation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;san&#34;, fields: [&#34;store.city&#34;], where: {&#34;store.zip_code&#34; =&amp;gt; 12345})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Nearest Neighbor Search&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Available for Elasticsearch 8.6+ and OpenSearch 2.4+&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick knn: {embedding: {dimensions: 3, distance: &#34;cosine&#34;}}&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also supports &lt;code&gt;euclidean&lt;/code&gt; and &lt;code&gt;inner_product&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Reindex and search with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(knn: {field: :embedding, vector: [1, 2, 3]}, limit: 10)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Semantic Search&lt;/h2&gt; &#xA;&lt;p&gt;First, add &lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#nearest-neighbor-search-unreleased-experimental&#34;&gt;nearest neighbor search&lt;/a&gt; to your model&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick knn: {embedding: {dimensions: 768, distance: &#34;cosine&#34;}}&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Generate an embedding for each record (you can use an external service or a library like &lt;a href=&#34;https://github.com/ankane/informers&#34;&gt;Informers&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;embed = Informers.pipeline(&#34;embedding&#34;, &#34;Snowflake/snowflake-arctic-embed-m-v1.5&#34;)&#xA;embed_options = {model_output: &#34;sentence_embedding&#34;, pooling: &#34;none&#34;} # specific to embedding model&#xA;&#xA;Product.find_each do |product|&#xA;  embedding = embed.(product.name, **embed_options)&#xA;  product.update!(embedding: embedding)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For search, generate an embedding for the query (the query prefix is specific to the &lt;a href=&#34;https://huggingface.co/Snowflake/snowflake-arctic-embed-m-v1.5&#34;&gt;embedding model&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;query_prefix = &#34;Represent this sentence for searching relevant passages: &#34;&#xA;query_embedding = embed.(query_prefix + query, **embed_options)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And perform nearest neighbor search&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(knn: {field: :embedding, vector: query_embedding}, limit: 20)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See a &lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/examples/semantic.rb&#34;&gt;full example&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Hybrid Search&lt;/h2&gt; &#xA;&lt;p&gt;Perform keyword search and semantic search in parallel&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;keyword_search = Product.search(query, limit: 20)&#xA;semantic_search = Product.search(knn: {field: :embedding, vector: query_embedding}, limit: 20)&#xA;Searchkick.multi_search([keyword_search, semantic_search])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To combine the results, use Reciprocal Rank Fusion (RRF)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick::Reranking.rrf(keyword_search, semantic_search).first(5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or a reranking model&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;rerank = Informers.pipeline(&#34;reranking&#34;, &#34;mixedbread-ai/mxbai-rerank-xsmall-v1&#34;)&#xA;results = (keyword_search.to_a + semantic_search.to_a).uniq&#xA;rerank.(query, results.map(&amp;amp;:name)).first(5).map { |v| results[v[:doc_id]] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See a &lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/examples/hybrid.rb&#34;&gt;full example&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Reference&lt;/h2&gt; &#xA;&lt;p&gt;Reindex one record&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;product = Product.find(1)&#xA;product.reindex&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Reindex multiple records&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.where(store_id: 1).reindex&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Reindex associations&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;store.products.reindex&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Remove old indices&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search_index.clean_indices&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use custom settings&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick settings: {number_of_shards: 3}&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use a different index name&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick index_name: &#34;products_v2&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use a dynamic index name&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick index_name: -&amp;gt; { &#34;#{name.tableize}-#{I18n.locale}&#34; }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Prefix the index name&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick index_prefix: &#34;datakick&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For all models&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.index_prefix = &#34;datakick&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use a different term for boosting by conversions&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;banana&#34;, conversions_term: &#34;organic banana&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Multiple conversion fields&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  has_many :searches, class_name: &#34;Searchjoy::Search&#34;&#xA;&#xA;  # searchkick also supports multiple &#34;conversions&#34; fields&#xA;  searchkick conversions: [&#34;unique_user_conversions&#34;, &#34;total_conversions&#34;]&#xA;&#xA;  def search_data&#xA;    {&#xA;      name: name,&#xA;      unique_user_conversions: searches.group(:query).distinct.count(:user_id),&#xA;      # {&#34;ice cream&#34; =&amp;gt; 234, &#34;chocolate&#34; =&amp;gt; 67, &#34;cream&#34; =&amp;gt; 2}&#xA;      total_conversions: searches.group(:query).count&#xA;      # {&#34;ice cream&#34; =&amp;gt; 412, &#34;chocolate&#34; =&amp;gt; 117, &#34;cream&#34; =&amp;gt; 6}&#xA;    }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and during query time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;banana&#34;) # boost by both fields (default)&#xA;Product.search(&#34;banana&#34;, conversions: &#34;total_conversions&#34;) # only boost by total_conversions&#xA;Product.search(&#34;banana&#34;, conversions: false) # no conversion boosting&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Change timeout&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.timeout = 15 # defaults to 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set a lower timeout for searches&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.search_timeout = 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Change the search method name&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.search_method_name = :lookup&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Change search queue name&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.queue_name = :search_reindex&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Eager load associations&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;milk&#34;, includes: [:brand, :stores])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Eager load different associations by model&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.search(&#34;*&#34;,  models: [Product, Store], model_includes: {Product =&amp;gt; [:store], Store =&amp;gt; [:product]})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run additional scopes on results&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;milk&#34;, scope_results: -&amp;gt;(r) { r.with_attached_images })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Specify default fields to search&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick default_fields: [:name]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Turn off special characters&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  # A will not match √Ñ&#xA;  searchkick special_characters: false&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Turn on stemming for conversions&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick stem_conversions: true&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make search case-sensitive&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick case_sensitive: true&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If misspellings are enabled (default), results with a single character case difference will match. Turn off misspellings if this is not desired.&lt;/p&gt; &#xA;&lt;p&gt;Change import batch size&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick batch_size: 200 # defaults to 1000&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create index without importing&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.reindex(import: false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use a different id&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  def search_document_id&#xA;    custom_id&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add &lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html#search-search-api-query-params&#34;&gt;request parameters&lt;/a&gt; like &lt;code&gt;search_type&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;carrots&#34;, request_params: {search_type: &#34;dfs_query_then_fetch&#34;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set options across all models&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Searchkick.model_options = {&#xA;  batch_size: 200&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Reindex conditionally&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick callbacks: false&#xA;&#xA;  # add the callbacks manually&#xA;  after_commit :reindex, if: -&amp;gt; (model) { model.previous_changes.key?(&#34;name&#34;) } # use your own condition&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Reindex all models - Rails only&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rake searchkick:reindex:all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Turn on misspellings after a certain number of characters&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;api&#34;, misspellings: {prefix_length: 2}) # api, apt, no ahi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; With this option, if the query length is the same as &lt;code&gt;prefix_length&lt;/code&gt;, misspellings are turned off with Elasticsearch 7 and OpenSearch 1&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Product.search(&#34;ah&#34;, misspellings: {prefix_length: 2}) # ah, no aha&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;BigDecimal values are indexed as floats by default so they can be used for boosting. Convert them to strings to keep full precision.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  def search_data&#xA;    {&#xA;      units: units.to_s(&#34;F&#34;)&#xA;    }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Gotchas&lt;/h2&gt; &#xA;&lt;h3&gt;Consistency&lt;/h3&gt; &#xA;&lt;p&gt;Elasticsearch and OpenSearch are eventually consistent, meaning it can take up to a second for a change to reflect in search. You can use the &lt;code&gt;refresh&lt;/code&gt; method to have it show up immediately.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;product.save!&#xA;Product.search_index.refresh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Inconsistent Scores&lt;/h3&gt; &#xA;&lt;p&gt;Due to the distributed nature of Elasticsearch and OpenSearch, you can get incorrect results when the number of documents in the index is low. You can &lt;a href=&#34;https://www.elastic.co/blog/understanding-query-then-fetch-vs-dfs-query-then-fetch&#34;&gt;read more about it here&lt;/a&gt;. To fix this, do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ApplicationRecord&#xA;  searchkick settings: {number_of_shards: 1}&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For convenience, this is set by default in the test environment.&lt;/p&gt; &#xA;&lt;h2&gt;Upgrading&lt;/h2&gt; &#xA;&lt;h3&gt;5.0&lt;/h3&gt; &#xA;&lt;p&gt;Searchkick 5 supports both the &lt;code&gt;elasticsearch&lt;/code&gt; and &lt;code&gt;opensearch-ruby&lt;/code&gt; gems. Add the one you want to use to your Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;elasticsearch&#34;&#xA;# or&#xA;gem &#34;opensearch-ruby&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If using the deprecated &lt;code&gt;faraday_middleware-aws-signers-v4&lt;/code&gt; gem, switch to &lt;code&gt;faraday_middleware-aws-sigv4&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Also, searches now use lazy loading:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# search not executed&#xA;Product.search(&#34;milk&#34;)&#xA;&#xA;# search executed&#xA;Product.search(&#34;milk&#34;).to_a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can reindex relations in the background:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;store.products.reindex(mode: :async)&#xA;# or&#xA;store.products.reindex(mode: :queue)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And there‚Äôs a &lt;a href=&#34;https://raw.githubusercontent.com/ankane/searchkick/master/#default-scopes&#34;&gt;new option&lt;/a&gt; for models with default scopes.&lt;/p&gt; &#xA;&lt;p&gt;Check out the &lt;a href=&#34;https://github.com/ankane/searchkick/raw/master/CHANGELOG.md#500-2022-02-21&#34;&gt;changelog&lt;/a&gt; for the full list of changes.&lt;/p&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;p&gt;View the &lt;a href=&#34;https://github.com/ankane/searchkick/raw/master/CHANGELOG.md&#34;&gt;changelog&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to Karel Minarik for &lt;a href=&#34;https://github.com/elasticsearch/elasticsearch-ruby&#34;&gt;Elasticsearch Ruby&lt;/a&gt; and &lt;a href=&#34;https://github.com/karmi/retire&#34;&gt;Tire&lt;/a&gt;, Jaroslav Kalistsuk for &lt;a href=&#34;https://gist.github.com/jarosan/3124884&#34;&gt;zero downtime reindexing&lt;/a&gt;, and Alex Leschenko for &lt;a href=&#34;https://github.com/leschenko/elasticsearch_autocomplete&#34;&gt;Elasticsearch autocomplete&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Everyone is encouraged to help improve this project. Here are a few ways you can help:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ankane/searchkick/issues&#34;&gt;Report bugs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Fix bugs and &lt;a href=&#34;https://github.com/ankane/searchkick/pulls&#34;&gt;submit pull requests&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Write, clarify, or fix documentation&lt;/li&gt; &#xA; &lt;li&gt;Suggest or add new features&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To get started with development:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/ankane/searchkick.git&#xA;cd searchkick&#xA;bundle install&#xA;bundle exec rake test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Feel free to open an issue to get feedback on your idea before spending too much time on it.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>SAML-Toolkits/ruby-saml</title>
    <updated>2024-09-22T01:44:54Z</updated>
    <id>tag:github.com,2024-09-22:/SAML-Toolkits/ruby-saml</id>
    <link href="https://github.com/SAML-Toolkits/ruby-saml" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SAML SSO for Ruby&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ruby SAML&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/SAML-Toolkits/ruby-saml/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/SAML-Toolkits/ruby-saml/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;ruby-saml CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/github/SAML-Toolkits/ruby-saml?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/SAML-Toolkits/ruby-saml/badge.svg?branch=master&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://badge.fury.io/rb/ruby-saml&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/ruby-saml.svg?sanitize=true&#34; alt=&#34;Rubygem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://badge.fury.io/gh/SAML-Toolkits%2Fruby-saml&#34;&gt;&lt;img src=&#34;https://badge.fury.io/gh/SAML-Toolkits%2Fruby-saml.svg?sanitize=true&#34; alt=&#34;GitHub version&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/license/SAML-Toolkits/ruby-saml&#34; alt=&#34;GitHub&#34;&gt; &lt;img src=&#34;https://img.shields.io/gem/dtv/ruby-saml?label=gem%20downloads%20latest&#34; alt=&#34;Gem&#34;&gt; &lt;img src=&#34;https://img.shields.io/gem/dt/ruby-saml?label=gem%20total%20downloads&#34; alt=&#34;Gem&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ruby SAML minor and tiny versions may introduce breaking changes. Please read &lt;a href=&#34;https://raw.githubusercontent.com/SAML-Toolkits/ruby-saml/master/UPGRADING.md&#34;&gt;UPGRADING.md&lt;/a&gt; for guidance on upgrading to new Ruby SAML versions.&lt;/p&gt; &#xA;&lt;p&gt;There is a critical vulnerability affecting ruby-saml &amp;lt; 1.17.0 (CVE-2024-45409). Make sure you are using an updated version. (1.12.3 is safe)&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;The Ruby SAML library is for implementing the client side of a SAML authorization, i.e. it provides a means for managing authorization initialization and confirmation requests from identity providers.&lt;/p&gt; &#xA;&lt;p&gt;SAML authorization is a two step process and you are expected to implement support for both.&lt;/p&gt; &#xA;&lt;p&gt;We created a demo project for Rails 4 that uses the latest version of this library: &lt;a href=&#34;https://github.com/saml-toolkits/ruby-saml-example&#34;&gt;ruby-saml-example&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Supported Ruby Versions&lt;/h3&gt; &#xA;&lt;p&gt;The following Ruby versions are covered by CI testing:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ruby (MRI) 2.1 to 3.3&lt;/li&gt; &#xA; &lt;li&gt;JRuby 9.1 to 9.4&lt;/li&gt; &#xA; &lt;li&gt;TruffleRuby (latest)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Adding Features, Pull Requests&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fork the repository&lt;/li&gt; &#xA; &lt;li&gt;Make your feature addition or bug fix&lt;/li&gt; &#xA; &lt;li&gt;Add tests for your new features. This is important so we don&#39;t break any features in a future version unintentionally.&lt;/li&gt; &#xA; &lt;li&gt;Ensure all tests pass by running &lt;code&gt;bundle exec rake test&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Do not change rakefile, version, or history.&lt;/li&gt; &#xA; &lt;li&gt;Open a pull request, following &lt;a href=&#34;https://gist.github.com/Lordnibbler/11002759&#34;&gt;this template&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Security Guidelines&lt;/h2&gt; &#xA;&lt;p&gt;If you believe you have discovered a security vulnerability in this gem, please report it by mail to the maintainer: &lt;a href=&#34;mailto:sixto.martin.garcia+security@gmail.com&#34;&gt;sixto.martin.garcia+security@gmail.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Security Warning&lt;/h3&gt; &#xA;&lt;p&gt;Some tools may incorrectly report ruby-saml is a potential security vulnerability. ruby-saml depends on Nokogiri, and it&#39;s possible to use Nokogiri in a dangerous way (by enabling its DTDLOAD option and disabling its NONET option). This dangerous Nokogiri configuration, which is sometimes used by other components, can create an XML External Entity (XXE) vulnerability if the XML data is not trusted. However, ruby-saml never enables this dangerous Nokogiri configuration; ruby-saml never enables DTDLOAD, and it never disables NONET.&lt;/p&gt; &#xA;&lt;p&gt;The OneLogin::RubySaml::IdpMetadataParser class does not validate in any way the URL that is introduced in order to be parsed.&lt;/p&gt; &#xA;&lt;p&gt;Usually the same administrator that handles the Service Provider also sets the URL to the IdP, which should be a trusted resource.&lt;/p&gt; &#xA;&lt;p&gt;But there are other scenarios, like a SAAS app where the administrator of the app delegates this functionality to other users. In this case, extra precaution should be taken in order to validate such URL inputs and avoid attacks like SSRF.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;In order to use Ruby SAML you will need to install the gem (either manually or using Bundler), and require the library in your Ruby application:&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;code&gt;Gemfile&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# latest stable&#xA;gem &#39;ruby-saml&#39;, &#39;~&amp;gt; 1.11.0&#39;&#xA;&#xA;# or track master for bleeding-edge&#xA;gem &#39;ruby-saml&#39;, :github =&amp;gt; &#39;saml-toolkit/ruby-saml&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using RubyGems&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gem install ruby-saml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may require the entire Ruby SAML gem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;onelogin/ruby-saml&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or just the required components individually:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;onelogin/ruby-saml/authrequest&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Installation on Ruby 1.8.7&lt;/h3&gt; &#xA;&lt;p&gt;This gem uses Nokogiri as a dependency, which dropped support for Ruby 1.8.x in Nokogiri 1.6. When installing this gem on Ruby 1.8.7, you will need to make sure a version of Nokogiri prior to 1.6 is installed or specified if it hasn&#39;t been already.&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;code&gt;Gemfile&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;nokogiri&#39;, &#39;~&amp;gt; 1.5.10&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using RubyGems&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gem install nokogiri --version &#39;~&amp;gt; 1.5.10&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuring Logging&lt;/h3&gt; &#xA;&lt;p&gt;When troubleshooting SAML integration issues, you will find it extremely helpful to examine the output of this gem&#39;s business logic. By default, log messages are emitted to RAILS_DEFAULT_LOGGER when the gem is used in a Rails context, and to STDOUT when the gem is used outside of Rails.&lt;/p&gt; &#xA;&lt;p&gt;To override the default behavior and control the destination of log messages, provide a ruby Logger object to the gem&#39;s logging singleton:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;OneLogin::RubySaml::Logging.logger = Logger.new(&#39;/var/log/ruby-saml.log&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;The Initialization Phase&lt;/h2&gt; &#xA;&lt;p&gt;This is the first request you will get from the identity provider. It will hit your application at a specific URL that you&#39;ve announced as your SAML initialization point. The response to this initialization is a redirect back to the identity provider, which can look something like this (ignore the saml_settings method call for now):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def init&#xA;  request = OneLogin::RubySaml::Authrequest.new&#xA;  redirect_to(request.create(saml_settings))&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the SP knows who should be authenticated in the IdP, then can provide that info as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def init&#xA;  request = OneLogin::RubySaml::Authrequest.new&#xA;  saml_settings.name_identifier_value_requested = &#34;testuser@example.com&#34;&#xA;  saml_settings.name_identifier_format = &#34;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#34;&#xA;  redirect_to(request.create(saml_settings))&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you&#39;ve redirected back to the identity provider, it will ensure that the user has been authorized and redirect back to your application for final consumption. This can look something like this (the &lt;code&gt;authorize_success&lt;/code&gt; and &lt;code&gt;authorize_failure&lt;/code&gt; methods are specific to your application):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def consume&#xA;  response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], :settings =&amp;gt; saml_settings)&#xA;&#xA;  # We validate the SAML Response and check if the user already exists in the system&#xA;  if response.is_valid?&#xA;     # authorize_success, log the user&#xA;     session[:userid] = response.nameid&#xA;     session[:attributes] = response.attributes&#xA;  else&#xA;    authorize_failure  # This method shows an error message&#xA;    # List of errors is available in response.errors array&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above there are a few assumptions, one being that &lt;code&gt;response.nameid&lt;/code&gt; is an email address. This is all handled with how you specify the settings that are in play via the &lt;code&gt;saml_settings&lt;/code&gt; method. That could be implemented along the lines of this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse])&#xA;response.settings = saml_settings&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the assertion of the SAMLResponse is not encrypted, you can initialize the Response without the &lt;code&gt;:settings&lt;/code&gt; parameter and set it later. If the SAMLResponse contains an encrypted assertion, you need to provide the settings in the initialize method in order to obtain the decrypted assertion, using the service provider private key in order to decrypt. If you don&#39;t know what expect, always use the former (set the settings on initialize).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def saml_settings&#xA;  settings = OneLogin::RubySaml::Settings.new&#xA;&#xA;  settings.assertion_consumer_service_url = &#34;http://#{request.host}/saml/consume&#34;&#xA;  settings.sp_entity_id                   = &#34;http://#{request.host}/saml/metadata&#34;&#xA;  settings.idp_entity_id                  = &#34;https://app.onelogin.com/saml/metadata/#{OneLoginAppId}&#34;&#xA;  settings.idp_sso_service_url            = &#34;https://app.onelogin.com/trust/saml2/http-post/sso/#{OneLoginAppId}&#34;&#xA;  settings.idp_sso_service_binding        = &#34;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&#34; # or :post, :redirect&#xA;  settings.idp_slo_service_url            = &#34;https://app.onelogin.com/trust/saml2/http-redirect/slo/#{OneLoginAppId}&#34;&#xA;  settings.idp_slo_service_binding        = &#34;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect&#34; # or :post, :redirect&#xA;  settings.idp_cert_fingerprint           = OneLoginAppCertFingerPrint&#xA;  settings.idp_cert_fingerprint_algorithm = &#34;http://www.w3.org/2000/09/xmldsig#sha1&#34;&#xA;  settings.name_identifier_format         = &#34;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#34;&#xA;&#xA;  # Optional for most SAML IdPs&#xA;  settings.authn_context = &#34;urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport&#34;&#xA;  # or as an array&#xA;  settings.authn_context = [&#xA;    &#34;urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport&#34;,&#xA;    &#34;urn:oasis:names:tc:SAML:2.0:ac:classes:Password&#34;&#xA;  ]&#xA;&#xA;  # Optional bindings (defaults to Redirect for logout POST for ACS)&#xA;  settings.single_logout_service_binding      = &#34;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect&#34; # or :post, :redirect&#xA;  settings.assertion_consumer_service_binding = &#34;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&#34; # or :post, :redirect&#xA;&#xA;  settings&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The use of settings.issuer is deprecated in favour of settings.sp_entity_id since version 1.11.0&lt;/p&gt; &#xA;&lt;p&gt;Some assertion validations can be skipped by passing parameters to &lt;code&gt;OneLogin::RubySaml::Response.new()&lt;/code&gt;. For example, you can skip the &lt;code&gt;AuthnStatement&lt;/code&gt;, &lt;code&gt;Conditions&lt;/code&gt;, &lt;code&gt;Recipient&lt;/code&gt;, or the &lt;code&gt;SubjectConfirmation&lt;/code&gt; validations by initializing the response with different options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], {skip_authnstatement: true}) # skips AuthnStatement&#xA;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], {skip_conditions: true}) # skips conditions&#xA;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], {skip_subject_confirmation: true}) # skips subject confirmation&#xA;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], {skip_recipient_check: true}) # doesn&#39;t skip subject confirmation, but skips the recipient check which is a sub check of the subject_confirmation check&#xA;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], {skip_audience: true}) # skips audience check&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All that&#39;s left is to wrap everything in a controller and reference it in the initialization and consumption URLs in OneLogin. A full controller example could look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# This controller expects you to use the URLs /saml/init and /saml/consume in your OneLogin application.&#xA;class SamlController &amp;lt; ApplicationController&#xA;  def init&#xA;    request = OneLogin::RubySaml::Authrequest.new&#xA;    redirect_to(request.create(saml_settings))&#xA;  end&#xA;&#xA;  def consume&#xA;    response          = OneLogin::RubySaml::Response.new(params[:SAMLResponse])&#xA;    response.settings = saml_settings&#xA;&#xA;    # We validate the SAML Response and check if the user already exists in the system&#xA;    if response.is_valid?&#xA;       # authorize_success, log the user&#xA;       session[:userid] = response.nameid&#xA;       session[:attributes] = response.attributes&#xA;    else&#xA;      authorize_failure  # This method shows an error message&#xA;      # List of errors is available in response.errors array&#xA;    end&#xA;  end&#xA;&#xA;  private&#xA;&#xA;  def saml_settings&#xA;    settings = OneLogin::RubySaml::Settings.new&#xA;&#xA;    settings.assertion_consumer_service_url = &#34;http://#{request.host}/saml/consume&#34;&#xA;    settings.sp_entity_id                   = &#34;http://#{request.host}/saml/metadata&#34;&#xA;    settings.idp_sso_service_url             = &#34;https://app.onelogin.com/saml/signon/#{OneLoginAppId}&#34;&#xA;    settings.idp_cert_fingerprint           = OneLoginAppCertFingerPrint&#xA;    settings.name_identifier_format         = &#34;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#34;&#xA;&#xA;    # Optional for most SAML IdPs&#xA;    settings.authn_context = &#34;urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport&#34;&#xA;&#xA;    # Optional. Describe according to IdP specification (if supported) which attributes the SP desires to receive in SAMLResponse.&#xA;    settings.attributes_index = 5&#xA;    # Optional. Describe an attribute consuming service for support of additional attributes.&#xA;    settings.attribute_consuming_service.configure do&#xA;      service_name &#34;Service&#34;&#xA;      service_index 5&#xA;      add_attribute :name =&amp;gt; &#34;Name&#34;, :name_format =&amp;gt; &#34;Name Format&#34;, :friendly_name =&amp;gt; &#34;Friendly Name&#34;&#xA;    end&#xA;&#xA;    settings&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Signature Validation&lt;/h2&gt; &#xA;&lt;p&gt;Ruby SAML allows different ways to validate the signature of the SAMLResponse:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can provide the IdP X.509 public certificate at the &lt;code&gt;idp_cert&lt;/code&gt; setting.&lt;/li&gt; &#xA; &lt;li&gt;You can provide the IdP X.509 public certificate in fingerprint format using the &lt;code&gt;idp_cert_fingerprint&lt;/code&gt; setting parameter and additionally the &lt;code&gt;idp_cert_fingerprint_algorithm&lt;/code&gt; parameter.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When validating the signature of redirect binding, the fingerprint is useless and the certificate of the IdP is required in order to execute the validation. You can pass the option &lt;code&gt;:relax_signature_validation&lt;/code&gt; to &lt;code&gt;SloLogoutrequest&lt;/code&gt; and &lt;code&gt;Logoutresponse&lt;/code&gt; if want to avoid signature validation if no certificate of the IdP is provided.&lt;/p&gt; &#xA;&lt;p&gt;In production also we highly recommend to register on the settings the IdP certificate instead of using the fingerprint method. The fingerprint, is a hash, so at the end is open to a collision attack that can end on a signature validation bypass. Other SAML toolkits deprecated that mechanism, we maintain it for compatibility and also to be used on test environment.&lt;/p&gt; &#xA;&lt;h2&gt;Handling Multiple IdP Certificates&lt;/h2&gt; &#xA;&lt;p&gt;If the IdP metadata XML includes multiple certificates, you may specify the &lt;code&gt;idp_cert_multi&lt;/code&gt; parameter. When used, the &lt;code&gt;idp_cert&lt;/code&gt; and &lt;code&gt;idp_cert_fingerprint&lt;/code&gt; parameters are ignored. This is useful in the following scenarios:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The IdP uses different certificates for signing versus encryption.&lt;/li&gt; &#xA; &lt;li&gt;The IdP is undergoing a key rollover and is publishing the old and new certificates in parallel.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;idp_cert_multi&lt;/code&gt; must be a &lt;code&gt;Hash&lt;/code&gt; as follows. The &lt;code&gt;:signing&lt;/code&gt; and &lt;code&gt;:encryption&lt;/code&gt; arrays below, add the IdP X.509 public certificates which were published in the IdP metadata.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;{&#xA;  :signing =&amp;gt; [],&#xA;  :encryption =&amp;gt; []&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Metadata Based Configuration&lt;/h2&gt; &#xA;&lt;p&gt;The method above requires a little extra work to manually specify attributes about both the IdP and your SP application. There&#39;s an easier method: use a metadata exchange. Metadata is an XML file that defines the capabilities of both the IdP and the SP application. It also contains the X.509 public key certificates which add to the trusted relationship. The IdP administrator can also configure custom settings for an SP based on the metadata.&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;code&gt;IdpMetadataParser#parse_remote&lt;/code&gt;, the IdP metadata will be added to the settings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def saml_settings&#xA;&#xA;  idp_metadata_parser = OneLogin::RubySaml::IdpMetadataParser.new&#xA;  # Returns OneLogin::RubySaml::Settings pre-populated with IdP metadata&#xA;  settings = idp_metadata_parser.parse_remote(&#34;https://example.com/auth/saml2/idp/metadata&#34;)&#xA;&#xA;  settings.assertion_consumer_service_url = &#34;http://#{request.host}/saml/consume&#34;&#xA;  settings.sp_entity_id                   = &#34;http://#{request.host}/saml/metadata&#34;&#xA;  settings.name_identifier_format         = &#34;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#34;&#xA;  # Optional for most SAML IdPs&#xA;  settings.authn_context = &#34;urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport&#34;&#xA;&#xA;  settings&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following attributes are set:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;idp_entity_id&lt;/li&gt; &#xA; &lt;li&gt;name_identifier_format&lt;/li&gt; &#xA; &lt;li&gt;idp_sso_service_url&lt;/li&gt; &#xA; &lt;li&gt;idp_slo_service_url&lt;/li&gt; &#xA; &lt;li&gt;idp_attribute_names&lt;/li&gt; &#xA; &lt;li&gt;idp_cert&lt;/li&gt; &#xA; &lt;li&gt;idp_cert_fingerprint&lt;/li&gt; &#xA; &lt;li&gt;idp_cert_multi&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Retrieve one Entity Descriptor when many exist in Metadata&lt;/h3&gt; &#xA;&lt;p&gt;If the Metadata contains several entities, the relevant Entity Descriptor can be specified when retrieving the settings from the IdpMetadataParser by its Entity Id value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  validate_cert = true&#xA;  settings = idp_metadata_parser.parse_remote(&#xA;               &#34;https://example.com/auth/saml2/idp/metadata&#34;,&#xA;               validate_cert,&#xA;               entity_id: &#34;http//example.com/target/entity&#34;&#xA;             )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieve one Entity Descriptor with an specific binding and nameid format when several are available&lt;/h3&gt; &#xA;&lt;p&gt;If the Metadata contains several bindings and nameids, the relevant ones also can be specified when retrieving the settings from the IdpMetadataParser by the values of binding and nameid:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  validate_cert = true&#xA;  options = {&#xA;    entity_id: &#34;http//example.com/target/entity&#34;,&#xA;    name_id_format: &#34;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#34;,&#xA;    sso_binding: &#34;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&#34;,&#xA;    slo_binding: &#34;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&#34;&#xA;  }&#xA;  settings = idp_metadata_parser.parse_remote(&#xA;               &#34;https://example.com/auth/saml2/idp/metadata&#34;,&#xA;               validate_cert,&#xA;               options&#xA;             )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parsing Metadata into an Hash&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;OneLogin::RubySaml::IdpMetadataParser&lt;/code&gt; also provides the methods &lt;code&gt;#parse_to_hash&lt;/code&gt; and &lt;code&gt;#parse_remote_to_hash&lt;/code&gt;. Those return an Hash instead of a &lt;code&gt;Settings&lt;/code&gt; object, which may be useful for configuring &lt;a href=&#34;https://github.com/omniauth/omniauth-saml&#34;&gt;omniauth-saml&lt;/a&gt;, for instance.&lt;/p&gt; &#xA;&lt;h3&gt;Validating Signature of Metadata and retrieve settings&lt;/h3&gt; &#xA;&lt;p&gt;Right now there is no method at ruby_saml to validate the signature of the metadata that gonna be parsed, but it can be done as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download the XML.&lt;/li&gt; &#xA; &lt;li&gt;Validate the Signature, providing the cert.&lt;/li&gt; &#xA; &lt;li&gt;Provide the XML to the parse method if the signature was validated&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;xml_security&#34;&#xA;require &#34;onelogin/ruby-saml/utils&#34;&#xA;require &#34;onelogin/ruby-saml/idp_metadata_parser&#34;&#xA;&#xA;url = &#34;&amp;lt;url_to_the_metadata&amp;gt;&#34;&#xA;idp_metadata_parser = OneLogin::RubySaml::IdpMetadataParser.new&#xA;&#xA;uri = URI.parse(url)&#xA;raise ArgumentError.new(&#34;url must begin with http or https&#34;) unless /^https?/ =~ uri.scheme&#xA;http = Net::HTTP.new(uri.host, uri.port)&#xA;if uri.scheme == &#34;https&#34;&#xA;    http.use_ssl = true&#xA;    http.verify_mode = OpenSSL::SSL::VERIFY_PEER&#xA;end&#xA;&#xA;get = Net::HTTP::Get.new(uri.request_uri)&#xA;get.basic_auth uri.user, uri.password if uri.user&#xA;response = http.request(get)&#xA;xml = response.body&#xA;errors = []&#xA;doc = XMLSecurity::SignedDocument.new(xml, errors)&#xA;cert_str = &#34;&amp;lt;include_cert_here&amp;gt;&#34;&#xA;cert = OneLogin::RubySaml::Utils.format_cert(&#34;cert_str&#34;)&#xA;metadata_sign_cert = OpenSSL::X509::Certificate.new(cert)&#xA;valid = doc.validate_document_with_cert(metadata_sign_cert, true)&#xA;if valid&#xA;  settings = idp_metadata_parser.parse(&#xA;    xml,&#xA;    entity_id: &#34;&amp;lt;entity_id_of_the_entity_to_be_retrieved&amp;gt;&#34;&#xA;  )&#xA;else&#xA;  print &#34;Metadata Signarture failed to be verified with the cert provided&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Retrieving Attributes&lt;/h2&gt; &#xA;&lt;p&gt;If you are using &lt;code&gt;saml:AttributeStatement&lt;/code&gt; to transfer data like the username, you can access all the attributes through &lt;code&gt;response.attributes&lt;/code&gt;. It contains all the &lt;code&gt;saml:AttributeStatement&lt;/code&gt;s with its &#39;Name&#39; as an indifferent key and one or more &lt;code&gt;saml:AttributeValue&lt;/code&gt;s as values. The value returned depends on the value of the &lt;code&gt;single_value_compatibility&lt;/code&gt; (when activated, only the first value is returned)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse])&#xA;response.settings = saml_settings&#xA;&#xA;response.attributes[:username]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Imagine this &lt;code&gt;saml:AttributeStatement&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;saml:AttributeStatement&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;uid&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:type=&#34;xs:string&#34;&amp;gt;demo&amp;lt;/saml:AttributeValue&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;another_value&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:type=&#34;xs:string&#34;&amp;gt;value1&amp;lt;/saml:AttributeValue&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:type=&#34;xs:string&#34;&amp;gt;value2&amp;lt;/saml:AttributeValue&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;role&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:type=&#34;xs:string&#34;&amp;gt;role1&amp;lt;/saml:AttributeValue&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;role&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:type=&#34;xs:string&#34;&amp;gt;role2&amp;lt;/saml:AttributeValue&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:type=&#34;xs:string&#34;&amp;gt;role3&amp;lt;/saml:AttributeValue&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;attribute_with_nil_value&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:nil=&#34;true&#34;/&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;attribute_with_nils_and_empty_strings&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue/&amp;gt;&#xA;      &amp;lt;saml:AttributeValue&amp;gt;valuePresent&amp;lt;/saml:AttributeValue&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:nil=&#34;true&#34;/&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:nil=&#34;1&#34;/&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue&amp;gt;usersName&amp;lt;/saml:AttributeValue&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;  &amp;lt;/saml:AttributeStatement&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pp(response.attributes)   # is an OneLogin::RubySaml::Attributes object&#xA;# =&amp;gt; @attributes=&#xA;  {&#34;uid&#34;=&amp;gt;[&#34;demo&#34;],&#xA;   &#34;another_value&#34;=&amp;gt;[&#34;value1&#34;, &#34;value2&#34;],&#xA;   &#34;role&#34;=&amp;gt;[&#34;role1&#34;, &#34;role2&#34;, &#34;role3&#34;],&#xA;   &#34;attribute_with_nil_value&#34;=&amp;gt;[nil],&#xA;   &#34;attribute_with_nils_and_empty_strings&#34;=&amp;gt;[&#34;&#34;, &#34;valuePresent&#34;, nil, nil]&#xA;   &#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname&#34;=&amp;gt;[&#34;usersName&#34;]}&amp;gt;&#xA;&#xA;# Active single_value_compatibility&#xA;OneLogin::RubySaml::Attributes.single_value_compatibility = true&#xA;&#xA;pp(response.attributes[:uid])&#xA;# =&amp;gt; &#34;demo&#34;&#xA;&#xA;pp(response.attributes[:role])&#xA;# =&amp;gt; &#34;role1&#34;&#xA;&#xA;pp(response.attributes.single(:role))&#xA;# =&amp;gt; &#34;role1&#34;&#xA;&#xA;pp(response.attributes.multi(:role))&#xA;# =&amp;gt; [&#34;role1&#34;, &#34;role2&#34;, &#34;role3&#34;]&#xA;&#xA;pp(response.attributes.fetch(:role))&#xA;# =&amp;gt; &#34;role1&#34;&#xA;&#xA;pp(response.attributes[:attribute_with_nil_value])&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes[:attribute_with_nils_and_empty_strings])&#xA;# =&amp;gt; &#34;&#34;&#xA;&#xA;pp(response.attributes[:not_exists])&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes.single(:not_exists))&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes.multi(:not_exists))&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes.fetch(/givenname/))&#xA;# =&amp;gt; &#34;usersName&#34;&#xA;&#xA;# Deprecated single_value_compatibility&#xA;OneLogin::RubySaml::Attributes.single_value_compatibility = false&#xA;&#xA;pp(response.attributes[:uid])&#xA;# =&amp;gt; [&#34;demo&#34;]&#xA;&#xA;pp(response.attributes[:role])&#xA;# =&amp;gt; [&#34;role1&#34;, &#34;role2&#34;, &#34;role3&#34;]&#xA;&#xA;pp(response.attributes.single(:role))&#xA;# =&amp;gt; &#34;role1&#34;&#xA;&#xA;pp(response.attributes.multi(:role))&#xA;# =&amp;gt; [&#34;role1&#34;, &#34;role2&#34;, &#34;role3&#34;]&#xA;&#xA;pp(response.attributes.fetch(:role))&#xA;# =&amp;gt; [&#34;role1&#34;, &#34;role2&#34;, &#34;role3&#34;]&#xA;&#xA;pp(response.attributes[:attribute_with_nil_value])&#xA;# =&amp;gt; [nil]&#xA;&#xA;pp(response.attributes[:attribute_with_nils_and_empty_strings])&#xA;# =&amp;gt; [&#34;&#34;, &#34;valuePresent&#34;, nil, nil]&#xA;&#xA;pp(response.attributes[:not_exists])&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes.single(:not_exists))&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes.multi(:not_exists))&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes.fetch(/givenname/))&#xA;# =&amp;gt; [&#34;usersName&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;saml:AuthnContextClassRef&lt;/code&gt; of the AuthNRequest can be provided by &lt;code&gt;settings.authn_context&lt;/code&gt;; possible values are described at [SAMLAuthnCxt]. The comparison method can be set using &lt;code&gt;settings.authn_context_comparison&lt;/code&gt; parameter. Possible values include: &#39;exact&#39;, &#39;better&#39;, &#39;maximum&#39; and &#39;minimum&#39; (default value is &#39;exact&#39;). To add a &lt;code&gt;saml:AuthnContextDeclRef&lt;/code&gt;, define &lt;code&gt;settings.authn_context_decl_ref&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In a SP-initiated flow, the SP can indicate to the IdP the subject that should be authenticated. This is done by defining the &lt;code&gt;settings.name_identifier_value_requested&lt;/code&gt; before building the authrequest object.&lt;/p&gt; &#xA;&lt;h2&gt;Service Provider Metadata&lt;/h2&gt; &#xA;&lt;p&gt;To form a trusted pair relationship with the IdP, the SP (you) need to provide metadata XML to the IdP for various good reasons. (Caching, certificate lookups, relaying party permissions, etc)&lt;/p&gt; &#xA;&lt;p&gt;The class &lt;code&gt;OneLogin::RubySaml::Metadata&lt;/code&gt; takes care of this by reading the Settings and returning XML. All you have to do is add a controller to return the data, then give this URL to the IdP administrator.&lt;/p&gt; &#xA;&lt;p&gt;The metadata will be polled by the IdP every few minutes, so updating your settings should propagate to the IdP settings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SamlController &amp;lt; ApplicationController&#xA;  # ... the rest of your controller definitions ...&#xA;  def metadata&#xA;    settings = Account.get_saml_settings&#xA;    meta = OneLogin::RubySaml::Metadata.new&#xA;    render :xml =&amp;gt; meta.generate(settings), :content_type =&amp;gt; &#34;application/samlmetadata+xml&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can add &lt;code&gt;ValidUntil&lt;/code&gt; and &lt;code&gt;CacheDuration&lt;/code&gt; to the SP Metadata XML using instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  # Valid until =&amp;gt; 2 days from now&#xA;  # Cache duration = 604800s = 1 week&#xA;  valid_until = Time.now + 172800&#xA;  cache_duration = 604800&#xA;  meta.generate(settings, false, valid_until, cache_duration)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Signing and Decryption&lt;/h2&gt; &#xA;&lt;p&gt;Ruby SAML supports the following functionality:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Signing your SP Metadata XML&lt;/li&gt; &#xA; &lt;li&gt;Signing your SP SAML messages&lt;/li&gt; &#xA; &lt;li&gt;Decrypting IdP Assertion messages upon receipt (EncryptedAssertion)&lt;/li&gt; &#xA; &lt;li&gt;Verifying signatures on SAML messages and IdP Assertions&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;In order to use functions 1-3 above, you must first define your SP public certificate and private key:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.certificate = &#34;CERTIFICATE TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;  settings.private_key = &#34;PRIVATE KEY TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the same certificate (and its associated private key) are used to perform all decryption and signing-related functions (1-4) above. Ruby SAML does not currently allow to specify different certificates for each function.&lt;/p&gt; &#xA;&lt;p&gt;You may also globally set the SP signature and digest method, to be used in SP signing (functions 1 and 2 above):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.security[:digest_method]    = XMLSecurity::Document::SHA1&#xA;  settings.security[:signature_method] = XMLSecurity::Document::RSA_SHA1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Signing SP Metadata&lt;/h4&gt; &#xA;&lt;p&gt;You may add a &lt;code&gt;&amp;lt;ds:Signature&amp;gt;&lt;/code&gt; digital signature element to your SP Metadata XML using the following setting:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.certificate = &#34;CERTIFICATE TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;  settings.private_key = &#34;PRIVATE KEY TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;&#xA;  settings.security[:metadata_signed] = true # Enable signature on Metadata&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Signing SP SAML Messages&lt;/h4&gt; &#xA;&lt;p&gt;Ruby SAML supports SAML request signing. The Service Provider will sign the request/responses with its private key. The Identity Provider will then validate the signature of the received request/responses with the public X.509 cert of the Service Provider.&lt;/p&gt; &#xA;&lt;p&gt;To enable, please first set your certificate and private key. This will add &lt;code&gt;&amp;lt;md:KeyDescriptor use=&#34;signing&#34;&amp;gt;&lt;/code&gt; to your SP Metadata XML, to be read by the IdP.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.certificate = &#34;CERTIFICATE TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;  settings.private_key = &#34;PRIVATE KEY TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, you may specify the specific SP SAML messages you would like to sign:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.security[:authn_requests_signed]   = true  # Enable signature on AuthNRequest&#xA;  settings.security[:logout_requests_signed]  = true  # Enable signature on Logout Request&#xA;  settings.security[:logout_responses_signed] = true  # Enable signature on Logout Response&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Signatures will be handled automatically for both &lt;code&gt;HTTP-Redirect&lt;/code&gt; and &lt;code&gt;HTTP-Redirect&lt;/code&gt; Binding. Note that the RelayState parameter is used when creating the Signature on the &lt;code&gt;HTTP-Redirect&lt;/code&gt; Binding. Remember to provide it to the Signature builder if you are sending a &lt;code&gt;GET RelayState&lt;/code&gt; parameter or the signature validation process will fail at the Identity Provider.&lt;/p&gt; &#xA;&lt;h4&gt;Decrypting IdP SAML Assertions&lt;/h4&gt; &#xA;&lt;p&gt;Ruby SAML supports EncryptedAssertion. The Identity Provider will encrypt the Assertion with the public cert of the Service Provider. The Service Provider will decrypt the EncryptedAssertion with its private key.&lt;/p&gt; &#xA;&lt;p&gt;You may enable EncryptedAssertion as follows. This will add &lt;code&gt;&amp;lt;md:KeyDescriptor use=&#34;encryption&#34;&amp;gt;&lt;/code&gt; to your SP Metadata XML, to be read by the IdP.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.certificate = &#34;CERTIFICATE TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;  settings.private_key = &#34;PRIVATE KEY TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;&#xA;  settings.security[:want_assertions_encrypted] = true # Invalidate SAML messages without an EncryptedAssertion&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Verifying Signature on IdP Assertions&lt;/h4&gt; &#xA;&lt;p&gt;You may require the IdP to sign its SAML Assertions using the following setting. With will add &lt;code&gt;&amp;lt;md:SPSSODescriptor WantAssertionsSigned=&#34;true&#34;&amp;gt;&lt;/code&gt; to your SP Metadata XML. The signature will be checked against the &lt;code&gt;&amp;lt;md:KeyDescriptor use=&#34;signing&#34;&amp;gt;&lt;/code&gt; element present in the IdP&#39;s metadata.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.security[:want_assertions_signed]  = true  # Require the IdP to sign its SAML Assertions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Certificate and Signature Validation&lt;/h4&gt; &#xA;&lt;p&gt;You may require SP and IdP certificates to be non-expired using the following settings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.security[:check_idp_cert_expiration] = true  # Raise error if IdP X.509 cert is expired&#xA;  settings.security[:check_sp_cert_expiration] = true   # Raise error SP X.509 cert is expired&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, Ruby SAML will raise a &lt;code&gt;OneLogin::RubySaml::ValidationError&lt;/code&gt; if a signature or certificate validation fails. You may disable such exceptions using the &lt;code&gt;settings.security[:soft]&lt;/code&gt; parameter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.security[:soft] = true  # Do not raise error on failed signature/certificate validations&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Advanced SP Certificate Usage &amp;amp; Key Rollover&lt;/h4&gt; &#xA;&lt;p&gt;Ruby SAML provides the &lt;code&gt;settings.sp_cert_multi&lt;/code&gt; parameter to enable the following advanced usage scenarios:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Rotating SP certificates and private keys without disruption of service.&lt;/li&gt; &#xA; &lt;li&gt;Specifying separate SP certificates for signing and encryption.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;sp_cert_multi&lt;/code&gt; parameter replaces &lt;code&gt;certificate&lt;/code&gt; and &lt;code&gt;private_key&lt;/code&gt; (you may not specify both pparameters at the same time.) &lt;code&gt;sp_cert_multi&lt;/code&gt; has the following shape:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;settings.sp_cert_multi = {&#xA;  signing: [&#xA;    { certificate: cert1, private_key: private_key1 },&#xA;    { certificate: cert2, private_key: private_key2 }&#xA;  ],&#xA;  encryption: [&#xA;    { certificate: cert1, private_key: private_key1 },&#xA;    { certificate: cert3, private_key: private_key1 }&#xA;  ],&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Certificate rotation is acheived by inserting new certificates at the bottom of each list, and then removing the old certificates from the top of the list once your IdPs have migrated. A common practice is for apps to publish the current SP metadata at a URL endpoint and have the IdP regularly poll for updates.&lt;/p&gt; &#xA;&lt;p&gt;Note the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You may re-use the same certificate and/or private key in multiple places, including for both signing and encryption.&lt;/li&gt; &#xA; &lt;li&gt;The IdP should attempt to verify signatures with &lt;em&gt;all&lt;/em&gt; &lt;code&gt;:signing&lt;/code&gt; certificates, and permit if &lt;em&gt;any one&lt;/em&gt; succeeds. When signing, Ruby SAML will use the first SP certificate in the &lt;code&gt;sp_cert_multi[:signing]&lt;/code&gt; array. This will be the first active/non-expired certificate in the array if &lt;code&gt;settings.security[:check_sp_cert_expiration]&lt;/code&gt; is true.&lt;/li&gt; &#xA; &lt;li&gt;The IdP may encrypt with any of the SP certificates in the &lt;code&gt;sp_cert_multi[:encryption]&lt;/code&gt; array. When decrypting, Ruby SAML attempt to decrypt with each SP private key in &lt;code&gt;sp_cert_multi[:encryption]&lt;/code&gt; until the decryption is successful. This will skip private keys for inactive/expired certificates if &lt;code&gt;:check_sp_cert_expiration&lt;/code&gt; is true.&lt;/li&gt; &#xA; &lt;li&gt;If &lt;code&gt;:check_sp_cert_expiration&lt;/code&gt; is true, the generated SP metadata XML will not include inactive/expired certificates. This avoids validation errors when the IdP reads the SP metadata.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Audience Validation&lt;/h4&gt; &#xA;&lt;p&gt;A service provider should only consider a SAML response valid if the IdP includes an &#xA; &lt;audiencerestriction&gt;&#xA;   element containting an &#xA;  &lt;audience&gt;&#xA;    element that uniquely identifies the service provider. Unless you specify the &#xA;   &lt;code&gt;skip_audience&lt;/code&gt; option, Ruby SAML will validate that each SAML response includes an &#xA;   &lt;audience&gt;&#xA;     element whose contents matches &#xA;    &lt;code&gt;settings.sp_entity_id&lt;/code&gt;.&#xA;   &lt;/audience&gt;&#xA;  &lt;/audience&gt;&#xA; &lt;/audiencerestriction&gt;&lt;/p&gt; &#xA;&lt;p&gt;By default, Ruby SAML considers an &#xA; &lt;audiencerestriction&gt;&#xA;   element containing only empty &#xA;  &lt;audience&gt;&#xA;    elements to be valid. That means an otherwise valid SAML response with a condition like this would be valid:&#xA;  &lt;/audience&gt;&#xA; &lt;/audiencerestriction&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;AudienceRestriction&amp;gt;&#xA;  &amp;lt;Audience /&amp;gt;&#xA;&amp;lt;/AudienceRestriction&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may enforce that an &#xA; &lt;audiencerestriction&gt;&#xA;   element containing only empty &#xA;  &lt;audience&gt;&#xA;    elements is invalid using the &#xA;   &lt;code&gt;settings.security[:strict_audience_validation]&lt;/code&gt; parameter.&#xA;  &lt;/audience&gt;&#xA; &lt;/audiencerestriction&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;settings.security[:strict_audience_validation] = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Single Log Out&lt;/h2&gt; &#xA;&lt;p&gt;Ruby SAML supports SP-initiated Single Logout and IdP-Initiated Single Logout.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example that we could add to our previous controller to generate and send a SAML Logout Request to the IdP:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Create a SP initiated SLO&#xA;def sp_logout_request&#xA;  # LogoutRequest accepts plain browser requests w/o paramters&#xA;  settings = saml_settings&#xA;&#xA;  if settings.idp_slo_service_url.nil?&#xA;    logger.info &#34;SLO IdP Endpoint not found in settings, executing then a normal logout&#39;&#34;&#xA;    delete_session&#xA;  else&#xA;&#xA;    logout_request = OneLogin::RubySaml::Logoutrequest.new&#xA;    logger.info &#34;New SP SLO for userid &#39;#{session[:userid]}&#39; transactionid &#39;#{logout_request.uuid}&#39;&#34;&#xA;&#xA;    if settings.name_identifier_value.nil?&#xA;      settings.name_identifier_value = session[:userid]&#xA;    end&#xA;&#xA;    # Ensure user is logged out before redirect to IdP, in case anything goes wrong during single logout process (as recommended by saml2int [SDP-SP34])&#xA;    logged_user = session[:userid]&#xA;    logger.info &#34;Delete session for &#39;#{session[:userid]}&#39;&#34;&#xA;    delete_session&#xA;&#xA;    # Save the transaction_id to compare it with the response we get back&#xA;    session[:transaction_id] = logout_request.uuid&#xA;    session[:logged_out_user] = logged_user&#xA;&#xA;    relayState = url_for(controller: &#39;saml&#39;, action: &#39;index&#39;)&#xA;    redirect_to(logout_request.create(settings, :RelayState =&amp;gt; relayState))&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This method processes the SAML Logout Response sent by the IdP as the reply of the SAML Logout Request:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# After sending an SP initiated LogoutRequest to the IdP, we need to accept&#xA;# the LogoutResponse, verify it, then actually delete our session.&#xA;def process_logout_response&#xA;  settings = Account.get_saml_settings&#xA;&#xA;  if session.has_key? :transaction_id&#xA;    logout_response = OneLogin::RubySaml::Logoutresponse.new(params[:SAMLResponse], settings, :matches_request_id =&amp;gt; session[:transaction_id])&#xA;  else&#xA;    logout_response = OneLogin::RubySaml::Logoutresponse.new(params[:SAMLResponse], settings)&#xA;  end&#xA;&#xA;  logger.info &#34;LogoutResponse is: #{logout_response.to_s}&#34;&#xA;&#xA;  # Validate the SAML Logout Response&#xA;  if not logout_response.validate&#xA;    logger.error &#34;The SAML Logout Response is invalid&#34;&#xA;  else&#xA;    # Actually log out this session&#xA;    logger.info &#34;SLO completed for &#39;#{session[:logged_out_user]}&#39;&#34;&#xA;    delete_session&#xA;  end&#xA;end&#xA;&#xA;# Delete a user&#39;s session.&#xA;def delete_session&#xA;  session[:userid] = nil&#xA;  session[:attributes] = nil&#xA;  session[:transaction_id] = nil&#xA;  session[:logged_out_user] = nil&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is an example that we could add to our previous controller to process a SAML Logout Request from the IdP and reply with a SAML Logout Response to the IdP:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Method to handle IdP initiated logouts&#xA;def idp_logout_request&#xA;  settings = Account.get_saml_settings&#xA;  # ADFS URL-Encodes SAML data as lowercase, and the toolkit by default uses&#xA;  # uppercase. Turn it True for ADFS compatibility on signature verification&#xA;  settings.security[:lowercase_url_encoding] = true&#xA;&#xA;  logout_request = OneLogin::RubySaml::SloLogoutrequest.new(&#xA;    params[:SAMLRequest], settings: settings&#xA;  )&#xA;  if !logout_request.is_valid?&#xA;    logger.error &#34;IdP initiated LogoutRequest was not valid!&#34;&#xA;    return render :inline =&amp;gt; logger.error&#xA;  end&#xA;  logger.info &#34;IdP initiated Logout for #{logout_request.name_id}&#34;&#xA;&#xA;  # Actually log out this session&#xA;  delete_session&#xA;&#xA;  # Generate a response to the IdP.&#xA;  logout_request_id = logout_request.id&#xA;  logout_response = OneLogin::RubySaml::SloLogoutresponse.new.create(settings, logout_request_id, nil, :RelayState =&amp;gt; params[:RelayState])&#xA;  redirect_to logout_response&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All the mentioned methods could be handled in a unique view:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Trigger SP and IdP initiated Logout requests&#xA;def logout&#xA;  # If we&#39;re given a logout request, handle it in the IdP logout initiated method&#xA;  if params[:SAMLRequest]&#xA;    return idp_logout_request&#xA;  # We&#39;ve been given a response back from the IdP, process it&#xA;  elsif params[:SAMLResponse]&#xA;    return process_logout_response&#xA;  # Initiate SLO (send Logout Request)&#xA;  else&#xA;    return sp_logout_request&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Clock Drift&lt;/h2&gt; &#xA;&lt;p&gt;Server clocks tend to drift naturally. If during validation of the response you get the error &#34;Current time is earlier than NotBefore condition&#34;, this may be due to clock differences between your system and that of the Identity Provider.&lt;/p&gt; &#xA;&lt;p&gt;First, ensure that both systems synchronize their clocks, using for example the industry standard &lt;a href=&#34;http://en.wikipedia.org/wiki/Network_Time_Protocol&#34;&gt;Network Time Protocol (NTP)&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Even then you may experience intermittent issues, as the clock of the Identity Provider may drift slightly ahead of your system clocks. To allow for a small amount of clock drift, you can initialize the response by passing in an option named &lt;code&gt;:allowed_clock_drift&lt;/code&gt;. Its value must be given in a number (and/or fraction) of seconds. The value given is added to the current time at which the response is validated before it&#39;s tested against the &lt;code&gt;NotBefore&lt;/code&gt; assertion. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], :allowed_clock_drift =&amp;gt; 1.second)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure to keep the value as comfortably small as possible to keep security risks to a minimum.&lt;/p&gt; &#xA;&lt;h2&gt;Deflation Limit&lt;/h2&gt; &#xA;&lt;p&gt;To protect against decompression bombs (a form of DoS attack), SAML messages are limited to 250,000 bytes by default. Sometimes legitimate SAML messages will exceed this limit, for example due to custom claims like including groups a user is a member of. If you want to customize this limit, you need to provide a different setting when initializing the response object. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def consume&#xA;  response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], { settings: saml_settings })&#xA;  ...&#xA;end&#xA;&#xA;private&#xA;&#xA;def saml_settings&#xA;  OneLogin::RubySaml::Settings.new(message_max_bytesize: 500_000)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Attribute Service&lt;/h2&gt; &#xA;&lt;p&gt;To request attributes from the IdP the SP needs to provide an attribute service within it&#39;s metadata and reference the index in the assertion.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;settings = OneLogin::RubySaml::Settings.new&#xA;settings.attributes_index = 5&#xA;settings.attribute_consuming_service.configure do&#xA;  service_name &#34;Service&#34;&#xA;  service_index 5&#xA;  add_attribute :name =&amp;gt; &#34;Name&#34;, :name_format =&amp;gt; &#34;Name Format&#34;, :friendly_name =&amp;gt; &#34;Friendly Name&#34;&#xA;  add_attribute :name =&amp;gt; &#34;Another Attribute&#34;, :name_format =&amp;gt; &#34;Name Format&#34;, :friendly_name =&amp;gt; &#34;Friendly Name&#34;, :attribute_value =&amp;gt; &#34;Attribute Value&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;attribute_value&lt;/code&gt; option additionally accepts an array of possible values.&lt;/p&gt; &#xA;&lt;h2&gt;Custom Metadata Fields&lt;/h2&gt; &#xA;&lt;p&gt;Some IdPs may require to add SPs to add additional fields (Organization, ContactPerson, etc.) into the SP metadata. This can be achieved by extending the &lt;code&gt;OneLogin::RubySaml::Metadata&lt;/code&gt; class and overriding the &lt;code&gt;#add_extras&lt;/code&gt; method as per the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyMetadata &amp;lt; OneLogin::RubySaml::Metadata&#xA;  def add_extras(root, _settings)&#xA;    org = root.add_element(&#34;md:Organization&#34;)&#xA;    org.add_element(&#34;md:OrganizationName&#34;, &#39;xml:lang&#39; =&amp;gt; &#34;en-US&#34;).text = &#39;ACME Inc.&#39;&#xA;    org.add_element(&#34;md:OrganizationDisplayName&#34;, &#39;xml:lang&#39; =&amp;gt; &#34;en-US&#34;).text = &#39;ACME&#39;&#xA;    org.add_element(&#34;md:OrganizationURL&#34;, &#39;xml:lang&#39; =&amp;gt; &#34;en-US&#34;).text = &#39;https://www.acme.com&#39;&#xA;&#xA;    cp = root.add_element(&#34;md:ContactPerson&#34;, &#39;contactType&#39; =&amp;gt; &#39;technical&#39;)&#xA;    cp.add_element(&#34;md:GivenName&#34;).text = &#39;ACME SAML Team&#39;&#xA;    cp.add_element(&#34;md:EmailAddress&#34;).text = &#39;saml@acme.com&#39;&#xA;  end&#xA;end&#xA;&#xA;# Output XML with custom metadata&#xA;MyMetadata.new.generate(settings)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>