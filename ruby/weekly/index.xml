<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-10-27T01:42:47Z</updated>
  <subtitle>Weekly Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rails/solid_cache</title>
    <updated>2024-10-27T01:42:47Z</updated>
    <id>tag:github.com,2024-10-27:/rails/solid_cache</id>
    <link href="https://github.com/rails/solid_cache" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A database-backed ActiveSupport::Cache::Store&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Solid Cache&lt;/h1&gt; &#xA;&lt;p&gt;Solid Cache is a database-backed Active Support cache store that let&#39;s you keep a much larger cache than is typically possible with traditional memory-only Redis or Memcached stores. This is thanks to the speed of modern SSD drives, which make the access-time penalty of using disk vs RAM insignificant for most caching purposes. Simply put, you&#39;re now usually better off keeping a huge cache on disk rather than a small cache in memory.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Solid Cache is configured by default in new Rails 8 applications. But if you&#39;re running an earlier version, you can add it manually following these steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;bundle add solid_cache&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bin/rails solid_cache:install&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This will configure Solid Cache as the production cache store, create &lt;code&gt;config/cache.yml&lt;/code&gt;, and create &lt;code&gt;db/cache_schema.rb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You will then have to add the configuration for the cache database in &lt;code&gt;config/database.yml&lt;/code&gt;. If you&#39;re using sqlite, it&#39;ll look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;production:&#xA;  primary:&#xA;    &amp;lt;&amp;lt;: *default&#xA;    database: storage/production.sqlite3&#xA;  cache:&#xA;    &amp;lt;&amp;lt;: *default&#xA;    database: storage/production_cache.sqlite3&#xA;    migrations_paths: db/cache_migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...or if you&#39;re using MySQL/PostgreSQL/Trilogy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;production:&#xA;  primary: &amp;amp;primary_production&#xA;    &amp;lt;&amp;lt;: *default&#xA;    database: app_production&#xA;    username: app&#xA;    password: &amp;lt;%= ENV[&#34;APP_DATABASE_PASSWORD&#34;] %&amp;gt;&#xA;  cache:&#xA;    &amp;lt;&amp;lt;: *primary_production&#xA;    database: app_production_cache&#xA;    migrations_paths: db/cache_migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run &lt;code&gt;db:prepare&lt;/code&gt; in production to ensure the database is created and the schema is loaded.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Configuration will be read from &lt;code&gt;config/cache.yml&lt;/code&gt; or &lt;code&gt;config/solid_cache.yml&lt;/code&gt;. You can change the location of the config file by setting the &lt;code&gt;SOLID_CACHE_CONFIG&lt;/code&gt; env variable.&lt;/p&gt; &#xA;&lt;p&gt;The format of the file is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;default:&#xA;  store_options: &amp;amp;default_store_options&#xA;    max_age: &amp;lt;%= 60.days.to_i %&amp;gt;&#xA;    namespace: &amp;lt;%= Rails.env %&amp;gt;&#xA;  size_estimate_samples: 1000&#xA;&#xA;development: &amp;amp;development&#xA;  database: development_cache&#xA;  store_options:&#xA;    &amp;lt;&amp;lt;: *default_store_options&#xA;    max_size: &amp;lt;%= 256.gigabytes %&amp;gt;&#xA;&#xA;production: &amp;amp;production&#xA;  databases: [production_cache1, production_cache2]&#xA;  store_options:&#xA;    &amp;lt;&amp;lt;: *default_store_options&#xA;    max_entries: &amp;lt;%= 256.gigabytes %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For the full list of keys for &lt;code&gt;store_options&lt;/code&gt; see &lt;a href=&#34;https://raw.githubusercontent.com/rails/solid_cache/main/#cache-configuration&#34;&gt;Cache configuration&lt;/a&gt;. Any options passed to the cache lookup will overwrite those specified here.&lt;/p&gt; &#xA;&lt;p&gt;After running &lt;code&gt;solid_cache:install&lt;/code&gt;, &lt;code&gt;environments/production.rb&lt;/code&gt; will replace your cache store with Solid Cache, but you can also do this manually:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/environments/production.rb&#xA;config.cache_store = :solid_cache_store&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Connection configuration&lt;/h3&gt; &#xA;&lt;p&gt;You can set one of &lt;code&gt;database&lt;/code&gt;, &lt;code&gt;databases&lt;/code&gt; and &lt;code&gt;connects_to&lt;/code&gt; in the config file. They will be used to configure the cache databases in &lt;code&gt;SolidCache::Record#connects_to&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Setting &lt;code&gt;database&lt;/code&gt; to &lt;code&gt;cache_db&lt;/code&gt; will configure with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SolidCache::Record.connects_to database: { writing: :cache_db }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Setting &lt;code&gt;databases&lt;/code&gt; to &lt;code&gt;[cache_db, cache_db2]&lt;/code&gt; is the equivalent of:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SolidCache::Record.connects_to shards: { cache_db1: { writing: :cache_db1 },  cache_db2: { writing: :cache_db2 } }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;connects_to&lt;/code&gt; is set, it will be passed directly.&lt;/p&gt; &#xA;&lt;p&gt;If none of these are set, Solid Cache will use the &lt;code&gt;ActiveRecord::Base&lt;/code&gt; connection pool. This means that cache reads and writes will be part of any wrapping database transaction.&lt;/p&gt; &#xA;&lt;h3&gt;Engine configuration&lt;/h3&gt; &#xA;&lt;p&gt;There are five options that can be set on the engine:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;executor&lt;/code&gt; - the &lt;a href=&#34;https://guides.rubyonrails.org/threading_and_code_execution.html#executor&#34;&gt;Rails executor&lt;/a&gt; used to wrap asynchronous operations, defaults to the app executor&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;connects_to&lt;/code&gt; - a custom connects to value for the abstract &lt;code&gt;SolidCache::Record&lt;/code&gt; active record model. Required for sharding and/or using a separate cache database to the main app. This will overwrite any value set in &lt;code&gt;config/solid_cache.yml&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;size_estimate_samples&lt;/code&gt; - if &lt;code&gt;max_size&lt;/code&gt; is set on the cache, the number of the samples used to estimate the size.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;encrypted&lt;/code&gt; - whether cache values should be encrypted (see &lt;a href=&#34;https://raw.githubusercontent.com/rails/solid_cache/main/#enabling-encryption&#34;&gt;Enabling encryption&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;encryption_context_properties&lt;/code&gt; - custom encryption context properties&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These can be set in your Rails configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.application.configure do&#xA;  config.solid_cache.size_estimate_samples = 1000&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Cache configuration&lt;/h3&gt; &#xA;&lt;p&gt;Solid Cache supports these options in addition to the standard &lt;code&gt;ActiveSupport::Cache::Store&lt;/code&gt; options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;error_handler&lt;/code&gt; - a Proc to call to handle any transient database errors that are raised (default: log errors as warnings)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;expiry_batch_size&lt;/code&gt; - the batch size to use when deleting old records (default: &lt;code&gt;100&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;expiry_method&lt;/code&gt; - what expiry method to use &lt;code&gt;thread&lt;/code&gt; or &lt;code&gt;job&lt;/code&gt; (default: &lt;code&gt;thread&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;expiry_queue&lt;/code&gt; - which queue to add expiry jobs to (default: &lt;code&gt;default&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max_age&lt;/code&gt; - the maximum age of entries in the cache (default: &lt;code&gt;2.weeks.to_i&lt;/code&gt;). Can be set to &lt;code&gt;nil&lt;/code&gt;, but this is not recommended unless using &lt;code&gt;max_entries&lt;/code&gt; to limit the size of the cache.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max_entries&lt;/code&gt; - the maximum number of entries allowed in the cache (default: &lt;code&gt;nil&lt;/code&gt;, meaning no limit)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max_size&lt;/code&gt; - the maximum size of the cache entries (default &lt;code&gt;nil&lt;/code&gt;, meaning no limit)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cluster&lt;/code&gt; - (deprecated) a Hash of options for the cache database cluster, e.g &lt;code&gt;{ shards: [:database1, :database2, :database3] }&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clusters&lt;/code&gt; - (deprecated) an Array of Hashes for multiple cache clusters (ignored if &lt;code&gt;:cluster&lt;/code&gt; is set)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;shards&lt;/code&gt; - an Array of databases&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;active_record_instrumentation&lt;/code&gt; - whether to instrument the cache&#39;s queries (default: &lt;code&gt;true&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clear_with&lt;/code&gt; - clear the cache with &lt;code&gt;:truncate&lt;/code&gt; or &lt;code&gt;:delete&lt;/code&gt; (default &lt;code&gt;truncate&lt;/code&gt;, except for when &lt;code&gt;Rails.env.test?&lt;/code&gt; then &lt;code&gt;delete&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max_key_bytesize&lt;/code&gt; - the maximum size of a normalized key in bytes (default &lt;code&gt;1024&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more information on cache clusters, see &lt;a href=&#34;https://raw.githubusercontent.com/rails/solid_cache/main/#sharding-the-cache&#34;&gt;Sharding the cache&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Cache expiry&lt;/h2&gt; &#xA;&lt;p&gt;Solid Cache tracks writes to the cache. For every write it increments a counter by 1. Once the counter reaches 50% of the &lt;code&gt;expiry_batch_size&lt;/code&gt; it adds a task to run on a background thread. That task will:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Check if we have exceeded the &lt;code&gt;max_entries&lt;/code&gt; or &lt;code&gt;max_size&lt;/code&gt; values (if set). The current entries are estimated by subtracting the max and min IDs from the &lt;code&gt;SolidCache::Entry&lt;/code&gt; table. The current size is estimated by sampling the entry &lt;code&gt;byte_size&lt;/code&gt; columns.&lt;/li&gt; &#xA; &lt;li&gt;If we have, it will delete &lt;code&gt;expiry_batch_size&lt;/code&gt; entries.&lt;/li&gt; &#xA; &lt;li&gt;If not, it will delete up to &lt;code&gt;expiry_batch_size&lt;/code&gt; entries, provided they are all older than &lt;code&gt;max_age&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Expiring when we reach 50% of the batch size allows us to expire records from the cache faster than we write to it when we need to reduce the cache size.&lt;/p&gt; &#xA;&lt;p&gt;Only triggering expiry when we write means that if the cache is idle, the background thread is also idle.&lt;/p&gt; &#xA;&lt;p&gt;If you want the cache expiry to be run in a background job instead of a thread, you can set &lt;code&gt;expiry_method&lt;/code&gt; to &lt;code&gt;:job&lt;/code&gt;. This will enqueue a &lt;code&gt;SolidCache::ExpiryJob&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Sharding the cache&lt;/h2&gt; &#xA;&lt;p&gt;Solid Cache uses the &lt;a href=&#34;https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44824.pdf&#34;&gt;Maglev&lt;/a&gt; consistent hashing scheme to shard the cache across multiple databases.&lt;/p&gt; &#xA;&lt;p&gt;To shard:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add the configuration for the database shards to database.yml.&lt;/li&gt; &#xA; &lt;li&gt;Configure the shards via &lt;code&gt;config.solid_cache.connects_to&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Pass the shards for the cache to use via the cluster option.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# config/database.yml&#xA;production:&#xA;  cache_shard1:&#xA;    database: cache1_production&#xA;    host: cache1-db&#xA;  cache_shard2:&#xA;    database: cache2_production&#xA;    host: cache2-db&#xA;  cache_shard3:&#xA;    database: cache3_production&#xA;    host: cache3-db&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# config/cache.yml&#xA;production:&#xA;  databases: [cache_shard1, cache_shard2, cache_shard3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Enabling encryption&lt;/h2&gt; &#xA;&lt;p&gt;To encrypt the cache values, you can add the encrypt property.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# config/cache.yml&#xA;production:&#xA;  encrypt: true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# application.rb&#xA;config.solid_cache.encrypt = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will need to set up your application to &lt;a href=&#34;https://guides.rubyonrails.org/active_record_encryption.html&#34;&gt;use Active Record Encryption&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Solid Cache by default uses a custom encryptor and message serializer that are optimised for it.&lt;/p&gt; &#xA;&lt;p&gt;Firstly it disabled compression with the encryptor &lt;code&gt;ActiveRecord::Encryption::Encryptor.new(compress: false)&lt;/code&gt; - the cache already compresses the data. Secondly it uses &lt;code&gt;ActiveRecord::Encryption::MessagePackMessageSerializer.new&lt;/code&gt; as the serializer. This serializer can only be used for binary columns, but can store about 40% more data than the standard serializer.&lt;/p&gt; &#xA;&lt;p&gt;You can choose your own context properties instead if you prefer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# application.rb&#xA;config.solid_cache.encryption_context_properties = {&#xA;  encryptor: ActiveRecord::Encryption::Encryptor.new,&#xA;  message_serializer: ActiveRecord::Encryption::MessageSerializer.new&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Index size limits&lt;/h2&gt; &#xA;&lt;p&gt;The Solid Cache migrations try to create an index with 1024 byte entries. If that is too big for your database, you should:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Edit the index size in the migration.&lt;/li&gt; &#xA; &lt;li&gt;Set &lt;code&gt;max_key_bytesize&lt;/code&gt; on your cache to the new value.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;Run the tests with &lt;code&gt;bin/rake test&lt;/code&gt;. By default, these will run against SQLite.&lt;/p&gt; &#xA;&lt;p&gt;You can also run the tests against MySQL and PostgreSQL. First start up the databases:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker compose up -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, setup the database schema:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ TARGET_DB=mysql bin/rails db:setup&#xA;$ TARGET_DB=postgres bin/rails db:setup&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run the tests for the target database:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ TARGET_DB=mysql bin/rake test&#xA;$ TARGET_DB=postgres bin/rake test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Testing with multiple Rails versions&lt;/h3&gt; &#xA;&lt;p&gt;Solid Cache relies on &lt;a href=&#34;https://github.com/thoughtbot/appraisal/tree/main&#34;&gt;appraisal&lt;/a&gt; to test multiple Rails versions.&lt;/p&gt; &#xA;&lt;p&gt;To run a test for a specific version run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bundle exec appraisal rails-7-1 bin/rake test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After updating the dependencies in the &lt;code&gt;Gemfile&lt;/code&gt; please run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ bundle&#xA;$ appraisal update&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This ensures that all the Rails versions dependencies are updated.&lt;/p&gt; &#xA;&lt;h2&gt;Implementation&lt;/h2&gt; &#xA;&lt;p&gt;Solid Cache is a FIFO (first in, first out) cache. While this is not as efficient as an LRU (least recently used) cache, it is mitigated by the longer cache lifespan.&lt;/p&gt; &#xA;&lt;p&gt;A FIFO cache is much easier to manage:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;We don&#39;t need to track when items are read.&lt;/li&gt; &#xA; &lt;li&gt;We can estimate and control the cache size by comparing the maximum and minimum IDs.&lt;/li&gt; &#xA; &lt;li&gt;By deleting from one end of the table and adding at the other end we can avoid fragmentation (on MySQL at least).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Upgrading&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Upgrading from v0.3.0 or earlier? Please see &lt;a href=&#34;https://raw.githubusercontent.com/rails/solid_cache/main/upgrading_to_version_0.4.x.md&#34;&gt;upgrading to version v0.4.x and beyond&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Solid Cache is licensed under MIT.&lt;/p&gt;</summary>
  </entry>
</feed>