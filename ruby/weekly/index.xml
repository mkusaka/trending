<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-01T01:43:37Z</updated>
  <subtitle>Weekly Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>modelcontextprotocol/ruby-sdk</title>
    <updated>2025-06-01T01:43:37Z</updated>
    <id>tag:github.com,2025-06-01:/modelcontextprotocol/ruby-sdk</id>
    <link href="https://github.com/modelcontextprotocol/ruby-sdk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The official Ruby SDK for the Model Context Protocol. Maintained in collaboration with Shopify&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Model Context Protocol&lt;/h1&gt; &#xA;&lt;p&gt;A Ruby gem for implementing Model Context Protocol servers&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;mcp&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or install it yourself as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ gem install mcp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;MCP Server&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;MCP::Server&lt;/code&gt; class is the core component that handles JSON-RPC requests and responses. It implements the Model Context Protocol specification, handling model context requests and responses.&lt;/p&gt; &#xA;&lt;h3&gt;Key Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Implements JSON-RPC 2.0 message handling&lt;/li&gt; &#xA; &lt;li&gt;Supports protocol initialization and capability negotiation&lt;/li&gt; &#xA; &lt;li&gt;Manages tool registration and invocation&lt;/li&gt; &#xA; &lt;li&gt;Supports prompt registration and execution&lt;/li&gt; &#xA; &lt;li&gt;Supports resource registration and retrieval&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Supported Methods&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;initialize&lt;/code&gt; - Initializes the protocol and returns server capabilities&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ping&lt;/code&gt; - Simple health check&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tools/list&lt;/code&gt; - Lists all registered tools and their schemas&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tools/call&lt;/code&gt; - Invokes a specific tool with provided arguments&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;prompts/list&lt;/code&gt; - Lists all registered prompts and their schemas&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;prompts/get&lt;/code&gt; - Retrieves a specific prompt by name&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;resources/list&lt;/code&gt; - Lists all registered resources and their schemas&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;resources/read&lt;/code&gt; - Retrieves a specific resource by name&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;resources/templates/list&lt;/code&gt; - Lists all registered resource templates and their schemas&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Unsupported Features ( to be implemented in future versions )&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Notifications&lt;/li&gt; &#xA; &lt;li&gt;Log Level&lt;/li&gt; &#xA; &lt;li&gt;Resource subscriptions&lt;/li&gt; &#xA; &lt;li&gt;Completions&lt;/li&gt; &#xA; &lt;li&gt;Complete StreamableHTTP implementation with streaming responses&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;h4&gt;Rails Controller&lt;/h4&gt; &#xA;&lt;p&gt;When added to a Rails controller on a route that handles POST requests, your server will be compliant with non-streaming &lt;a href=&#34;https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#streamable-http&#34;&gt;StreamableHTTP&lt;/a&gt; transport requests.&lt;/p&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;Server#handle_json&lt;/code&gt; method to handle requests.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;&#xA;  def index&#xA;    server = MCP::Server.new(&#xA;      name: &#34;my_server&#34;,&#xA;      version: &#34;1.0.0&#34;,&#xA;      tools: [SomeTool, AnotherTool],&#xA;      prompts: [MyPrompt],&#xA;      server_context: { user_id: current_user.id },&#xA;    )&#xA;    render(json: server.handle_json(request.body.read))&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Stdio Transport&lt;/h4&gt; &#xA;&lt;p&gt;If you want to build a local command-line application, you can use the stdio transport:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby&#xA;require &#34;mcp&#34;&#xA;require &#34;mcp/transports/stdio&#34;&#xA;&#xA;# Create a simple tool&#xA;class ExampleTool &amp;lt; MCP::Tool&#xA;  description &#34;A simple example tool that echoes back its arguments&#34;&#xA;  input_schema(&#xA;    properties: {&#xA;      message: { type: &#34;string&#34; },&#xA;    },&#xA;    required: [&#34;message&#34;]&#xA;  )&#xA;&#xA;  class &amp;lt;&amp;lt; self&#xA;    def call(message:, server_context:)&#xA;      MCP::Tool::Response.new([{&#xA;        type: &#34;text&#34;,&#xA;        text: &#34;Hello from example tool! Message: #{message}&#34;,&#xA;      }])&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;# Set up the server&#xA;server = MCP::Server.new(&#xA;  name: &#34;example_server&#34;,&#xA;  tools: [ExampleTool],&#xA;)&#xA;&#xA;# Create and start the transport&#xA;transport = MCP::Transports::StdioTransport.new(server)&#xA;transport.open&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can run this script and then type in requests to the server at the command line.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./stdio_server.rb&#xA;{&#34;jsonrpc&#34;:&#34;2.0&#34;,&#34;id&#34;:&#34;1&#34;,&#34;result&#34;:&#34;pong&#34;}&#xA;{&#34;jsonrpc&#34;:&#34;2.0&#34;,&#34;id&#34;:&#34;2&#34;,&#34;result&#34;:[&#34;ExampleTool&#34;]}&#xA;{&#34;jsonrpc&#34;:&#34;2.0&#34;,&#34;id&#34;:&#34;3&#34;,&#34;result&#34;:[&#34;ExampleTool&#34;]}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;The gem can be configured using the &lt;code&gt;MCP.configure&lt;/code&gt; block:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MCP.configure do |config|&#xA;  config.exception_reporter = -&amp;gt;(exception, server_context) {&#xA;    # Your exception reporting logic here&#xA;    # For example with Bugsnag:&#xA;    Bugsnag.notify(exception) do |report|&#xA;      report.add_metadata(:model_context_protocol, server_context)&#xA;    end&#xA;  }&#xA;&#xA;  config.instrumentation_callback = -&amp;gt;(data) {&#xA;    puts &#34;Got instrumentation data #{data.inspect}&#34;&#xA;  }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or by creating an explicit configuration and passing it into the server. This is useful for systems where an application hosts more than one MCP server but they might require different instrumentation callbacks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;configuration = MCP::Configuration.new&#xA;configuration.exception_reporter = -&amp;gt;(exception, server_context) {&#xA;  # Your exception reporting logic here&#xA;  # For example with Bugsnag:&#xA;  Bugsnag.notify(exception) do |report|&#xA;    report.add_metadata(:model_context_protocol, server_context)&#xA;  end&#xA;}&#xA;&#xA;configuration.instrumentation_callback = -&amp;gt;(data) {&#xA;  puts &#34;Got instrumentation data #{data.inspect}&#34;&#xA;}&#xA;&#xA;server = MCP::Server.new(&#xA;  # ... all other options&#xA;  configuration:,&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Server Context and Configuration Block Data&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;code&gt;server_context&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;server_context&lt;/code&gt; is a user-defined hash that is passed into the server instance and made available to tools, prompts, and exception/instrumentation callbacks. It can be used to provide contextual information such as authentication state, user IDs, or request-specific data.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Type:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;server_context: { [String, Symbol] =&amp;gt; Any }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;server = MCP::Server.new(&#xA;  name: &#34;my_server&#34;,&#xA;  server_context: { user_id: current_user.id, request_id: request.uuid }&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This hash is then passed as the &lt;code&gt;server_context&lt;/code&gt; argument to tool and prompt calls, and is included in exception and instrumentation callbacks.&lt;/p&gt; &#xA;&lt;h4&gt;Configuration Block Data&lt;/h4&gt; &#xA;&lt;h5&gt;Exception Reporter&lt;/h5&gt; &#xA;&lt;p&gt;The exception reporter receives:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;exception&lt;/code&gt;: The Ruby exception object that was raised&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;server_context&lt;/code&gt;: The context hash provided to the server&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Signature:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;exception_reporter = -&amp;gt;(exception, server_context) { ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Instrumentation Callback&lt;/h5&gt; &#xA;&lt;p&gt;The instrumentation callback receives a hash with the following possible keys:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;method&lt;/code&gt;: (String) The protocol method called (e.g., &#34;ping&#34;, &#34;tools/list&#34;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tool_name&lt;/code&gt;: (String, optional) The name of the tool called&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;prompt_name&lt;/code&gt;: (String, optional) The name of the prompt called&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;resource_uri&lt;/code&gt;: (String, optional) The URI of the resource called&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;error&lt;/code&gt;: (String, optional) Error code if a lookup failed&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;duration&lt;/code&gt;: (Float) Duration of the call in seconds&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Type:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;instrumentation_callback = -&amp;gt;(data) { ... }&#xA;# where data is a Hash with keys as described above&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.instrumentation_callback = -&amp;gt;(data) {&#xA;  puts &#34;Instrumentation: #{data.inspect}&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Server Protocol Version&lt;/h3&gt; &#xA;&lt;p&gt;The server&#39;s protocol version can be overridden using the &lt;code&gt;protocol_version&lt;/code&gt; class method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MCP::Server.protocol_version = &#34;2024-11-05&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will make all new server instances use the specified protocol version instead of the default version. The protocol version can be reset to the default by setting it to &lt;code&gt;nil&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MCP::Server.protocol_version = nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Be sure to check the &lt;a href=&#34;https://spec.modelcontextprotocol.io/specification/2024-11-05/&#34;&gt;MCP spec&lt;/a&gt; for the protocol version to understand the supported features for the version being set.&lt;/p&gt; &#xA;&lt;h3&gt;Exception Reporting&lt;/h3&gt; &#xA;&lt;p&gt;The exception reporter receives two arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;exception&lt;/code&gt;: The Ruby exception object that was raised&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;server_context&lt;/code&gt;: A hash containing contextual information about where the error occurred&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The server_context hash includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For tool calls: &lt;code&gt;{ tool_name: &#34;name&#34;, arguments: { ... } }&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;For general request handling: &lt;code&gt;{ request: { ... } }&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When an exception occurs:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The exception is reported via the configured reporter&lt;/li&gt; &#xA; &lt;li&gt;For tool calls, a generic error response is returned to the client: &lt;code&gt;{ error: &#34;Internal error occurred&#34;, isError: true }&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;For other requests, the exception is re-raised after reporting&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If no exception reporter is configured, a default no-op reporter is used that silently ignores exceptions.&lt;/p&gt; &#xA;&lt;h2&gt;Tools&lt;/h2&gt; &#xA;&lt;p&gt;MCP spec includes &lt;a href=&#34;https://modelcontextprotocol.io/docs/concepts/tools&#34;&gt;Tools&lt;/a&gt; which provide functionality to LLM apps.&lt;/p&gt; &#xA;&lt;p&gt;This gem provides a &lt;code&gt;MCP::Tool&lt;/code&gt; class that can be used to create tools in two ways:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;As a class definition:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyTool &amp;lt; MCP::Tool&#xA;  description &#34;This tool performs specific functionality...&#34;&#xA;  input_schema(&#xA;    properties: {&#xA;      message: { type: &#34;string&#34; },&#xA;    },&#xA;    required: [&#34;message&#34;]&#xA;  )&#xA;  annotations(&#xA;    title: &#34;My Tool&#34;,&#xA;    read_only_hint: true,&#xA;    destructive_hint: false,&#xA;    idempotent_hint: true,&#xA;    open_world_hint: false&#xA;  )&#xA;&#xA;  def self.call(message:, server_context:)&#xA;    MCP::Tool::Response.new([{ type: &#34;text&#34;, text: &#34;OK&#34; }])&#xA;  end&#xA;end&#xA;&#xA;tool = MyTool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;By using the &lt;code&gt;MCP::Tool.define&lt;/code&gt; method with a block:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;tool = MCP::Tool.define(&#xA;  name: &#34;my_tool&#34;,&#xA;  description: &#34;This tool performs specific functionality...&#34;,&#xA;  annotations: {&#xA;    title: &#34;My Tool&#34;,&#xA;    read_only_hint: true&#xA;  }&#xA;) do |args, server_context|&#xA;  Tool::Response.new([{ type: &#34;text&#34;, text: &#34;OK&#34; }])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The server_context parameter is the server_context passed into the server and can be used to pass per request information, e.g. around authentication state.&lt;/p&gt; &#xA;&lt;h3&gt;Tool Annotations&lt;/h3&gt; &#xA;&lt;p&gt;Tools can include annotations that provide additional metadata about their behavior. The following annotations are supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;title&lt;/code&gt;: A human-readable title for the tool&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;read_only_hint&lt;/code&gt;: Indicates if the tool only reads data (doesn&#39;t modify state)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;destructive_hint&lt;/code&gt;: Indicates if the tool performs destructive operations&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;idempotent_hint&lt;/code&gt;: Indicates if the tool&#39;s operations are idempotent&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;open_world_hint&lt;/code&gt;: Indicates if the tool operates in an open world context&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Annotations can be set either through the class definition using the &lt;code&gt;annotations&lt;/code&gt; class method or when defining a tool using the &lt;code&gt;define&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;h2&gt;Prompts&lt;/h2&gt; &#xA;&lt;p&gt;MCP spec includes &lt;a href=&#34;https://modelcontextprotocol.io/docs/concepts/prompts&#34;&gt;Prompts&lt;/a&gt;, which enable servers to define reusable prompt templates and workflows that clients can easily surface to users and LLMs.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;MCP::Prompt&lt;/code&gt; class provides two ways to create prompts:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;As a class definition with metadata:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyPrompt &amp;lt; MCP::Prompt&#xA;  prompt_name &#34;my_prompt&#34;  # Optional - defaults to underscored class name&#xA;  description &#34;This prompt performs specific functionality...&#34;&#xA;  arguments [&#xA;    Prompt::Argument.new(&#xA;      name: &#34;message&#34;,&#xA;      description: &#34;Input message&#34;,&#xA;      required: true&#xA;    )&#xA;  ]&#xA;&#xA;  class &amp;lt;&amp;lt; self&#xA;    def template(args, server_context:)&#xA;      Prompt::Result.new(&#xA;        description: &#34;Response description&#34;,&#xA;        messages: [&#xA;          Prompt::Message.new(&#xA;            role: &#34;user&#34;,&#xA;            content: Content::Text.new(&#34;User message&#34;)&#xA;          ),&#xA;          Prompt::Message.new(&#xA;            role: &#34;assistant&#34;,&#xA;            content: Content::Text.new(args[&#34;message&#34;])&#xA;          )&#xA;        ]&#xA;      )&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;prompt = MyPrompt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Using the &lt;code&gt;MCP::Prompt.define&lt;/code&gt; method:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;prompt = MCP::Prompt.define(&#xA;  name: &#34;my_prompt&#34;,&#xA;  description: &#34;This prompt performs specific functionality...&#34;,&#xA;  arguments: [&#xA;    Prompt::Argument.new(&#xA;      name: &#34;message&#34;,&#xA;      description: &#34;Input message&#34;,&#xA;      required: true&#xA;    )&#xA;  ]&#xA;) do |args, server_context:|&#xA;  Prompt::Result.new(&#xA;    description: &#34;Response description&#34;,&#xA;    messages: [&#xA;      Prompt::Message.new(&#xA;        role: &#34;user&#34;,&#xA;        content: Content::Text.new(&#34;User message&#34;)&#xA;      ),&#xA;      Prompt::Message.new(&#xA;        role: &#34;assistant&#34;,&#xA;        content: Content::Text.new(args[&#34;message&#34;])&#xA;      )&#xA;    ]&#xA;  )&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The server_context parameter is the server_context passed into the server and can be used to pass per request information, e.g. around authentication state or user preferences.&lt;/p&gt; &#xA;&lt;h3&gt;Key Components&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Prompt::Argument&lt;/code&gt; - Defines input parameters for the prompt template&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Prompt::Message&lt;/code&gt; - Represents a message in the conversation with a role and content&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Prompt::Result&lt;/code&gt; - The output of a prompt template containing description and messages&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Content::Text&lt;/code&gt; - Text content for messages&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;Register prompts with the MCP server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;server = MCP::Server.new(&#xA;  name: &#34;my_server&#34;,&#xA;  prompts: [MyPrompt],&#xA;  server_context: { user_id: current_user.id },&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The server will handle prompt listing and execution through the MCP protocol methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;prompts/list&lt;/code&gt; - Lists all registered prompts and their schemas&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;prompts/get&lt;/code&gt; - Retrieves and executes a specific prompt with arguments&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Instrumentation&lt;/h3&gt; &#xA;&lt;p&gt;The server allows registering a callback to receive information about instrumentation. To register a handler pass a proc/lambda to as &lt;code&gt;instrumentation_callback&lt;/code&gt; into the server constructor.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MCP.configure do |config|&#xA;  config.instrumentation_callback = -&amp;gt;(data) {&#xA;    puts &#34;Got instrumentation data #{data.inspect}&#34;&#xA;  end&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The data contains the following keys: &lt;code&gt;method&lt;/code&gt;: the metod called, e.g. &lt;code&gt;ping&lt;/code&gt;, &lt;code&gt;tools/list&lt;/code&gt;, &lt;code&gt;tools/call&lt;/code&gt; etc &lt;code&gt;tool_name&lt;/code&gt;: the name of the tool called &lt;code&gt;prompt_name&lt;/code&gt;: the name of the prompt called &lt;code&gt;resource_uri&lt;/code&gt;: the uri of the resource called &lt;code&gt;error&lt;/code&gt;: if looking up tools/prompts etc failed, e.g. &lt;code&gt;tool_not_found&lt;/code&gt; &lt;code&gt;duration&lt;/code&gt;: the duration of the call in seconds&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;tool_name&lt;/code&gt;, &lt;code&gt;prompt_name&lt;/code&gt; and &lt;code&gt;resource_uri&lt;/code&gt; are only populated if a matching handler is registered. This is to avoid potential issues with metric cardinality&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;p&gt;MCP spec includes &lt;a href=&#34;https://modelcontextprotocol.io/docs/concepts/resources&#34;&gt;Resources&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;MCP::Resource&lt;/code&gt; class provides a way to register resources with the server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;resource = MCP::Resource.new(&#xA;  uri: &#34;example.com/my_resource&#34;,&#xA;  mime_type: &#34;text/plain&#34;,&#xA;  text: &#34;Lorem ipsum dolor sit amet&#34;&#xA;)&#xA;&#xA;server = MCP::Server.new(&#xA;  name: &#34;my_server&#34;,&#xA;  resources: [resource],&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The server must register a handler for the &lt;code&gt;resources/read&lt;/code&gt; method to retrieve a resource dynamically.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;server.resources_read_handler do |params|&#xA;  [{&#xA;    uri: params[:uri],&#xA;    mimeType: &#34;text/plain&#34;,&#xA;    text: &#34;Hello, world!&#34;,&#xA;  }]&#xA;end&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;otherwise &#39;resources/read&#39; requests will be a no-op.&lt;/p&gt; &#xA;&lt;h2&gt;Releases&lt;/h2&gt; &#xA;&lt;p&gt;This gem is published to &lt;a href=&#34;https://rubygems.org/gems/mcp&#34;&gt;RubyGems.org&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Releases are triggered by PRs to the &lt;code&gt;main&lt;/code&gt; branch updating the version number in &lt;code&gt;lib/mcp/version.rb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Update the version number&lt;/strong&gt; in &lt;code&gt;lib/mcp/version.rb&lt;/code&gt;, following &lt;a href=&#34;https://semver.org/&#34;&gt;semver&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Create A PR and get approval from a maintainer&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Merge your PR to the main branch&lt;/strong&gt; - This will automatically trigger the release workflow via GitHub Actions&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;When changes are merged to the &lt;code&gt;main&lt;/code&gt; branch, the GitHub Actions workflow (&lt;code&gt;.github/workflows/release.yml&lt;/code&gt;) is triggered and the gem is published to RubyGems.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>metanorma/metanorma</title>
    <updated>2025-06-01T01:43:37Z</updated>
    <id>tag:github.com,2025-06-01:/metanorma/metanorma</id>
    <link href="https://github.com/metanorma/metanorma" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Metanorma project: www.metanorma.org&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Metanorma: the standard for standards&lt;/h1&gt; &#xA;&lt;div id=&#34;preamble&#34;&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;&lt;span class=&#34;image&#34;&gt;&lt;a class=&#34;image&#34; href=&#34;https://rubygems.org/gems/metanorma&#34;&gt;&lt;img src=&#34;https://img.shields.io/gem/v/metanorma.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt;&lt;/span&gt; &lt;span class=&#34;image&#34;&gt;&lt;a class=&#34;image&#34; href=&#34;https://github.com/metanorma/metanorma/actions?workflow=rake&#34;&gt;&lt;img src=&#34;https://github.com/metanorma/metanorma/workflows/rake/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/span&gt; &lt;span class=&#34;image&#34;&gt;&lt;a class=&#34;image&#34; href=&#34;https://codeclimate.com/github/metanorma/metanorma&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/metanorma/metanorma/badges/gpa.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt;&lt;/span&gt; &lt;span class=&#34;image&#34;&gt;&lt;a class=&#34;image&#34; href=&#34;https://github.com/metanorma/metanorma/pulls&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/issues-pr-raw/metanorma/metanorma.svg?sanitize=true&#34; alt=&#34;Pull Requests&#34;&gt;&lt;/a&gt;&lt;/span&gt; &lt;span class=&#34;image&#34;&gt;&lt;a class=&#34;image&#34; href=&#34;https://github.com/metanorma/metanorma/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/commits-since/metanorma/metanorma/latest.svg?sanitize=true&#34; alt=&#34;Commits since latest&#34;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Metanorma is dedicated to harmonizing standard documents produced by different standard-setting bodies in a manner that maintains correct semantics while allowing each standard publisher to define appropriate semantic extensions.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Simply put, it allows standards bodies or any other organization to create their own standard or specification document in a best practices manner.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Metanorma is composed of a number of specifications and software implementations. The Metanorma document model is based on the SecureDoc document model.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;For more on Metanorma and who uses it, refer to &lt;a href=&#34;https://www.metanorma.org&#34; class=&#34;bare&#34;&gt;https://www.metanorma.org&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;div class=&#34;sect1&#34;&gt; &#xA; &lt;h2 id=&#34;_installation_on_supported_platforms&#34;&gt;Installation on supported platforms&lt;/h2&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;See &lt;a href=&#34;https://www.metanorma.org/install/&#34; class=&#34;bare&#34;&gt;https://www.metanorma.org/install/&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;sect2&#34;&gt; &#xA;   &lt;h3 id=&#34;_installing_individual_components&#34;&gt;Installing individual components&lt;/h3&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;The Metanorma workflow can be utilized via the &lt;code&gt;metanorma-cli&lt;/code&gt; Ruby gem.&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;listingblock&#34;&gt; &#xA;    &lt;div class=&#34;content&#34;&gt; &#xA;     &lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;gem install metanorma-cli&lt;/code&gt;&lt;/pre&gt; &#xA;    &lt;/div&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;div class=&#34;sect1&#34;&gt; &#xA; &lt;h2 id=&#34;_usage&#34;&gt;Usage&lt;/h2&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Refer to &lt;a href=&#34;https://www.metanorma.org/install/man/&#34;&gt;Metanorma man page&lt;/a&gt; and &lt;a href=&#34;https://www.metanorma.org/install/usage/&#34;&gt;Metanorma usage&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;sect2&#34;&gt; &#xA;   &lt;h3 id=&#34;_threaded_execution&#34;&gt;Threaded execution&lt;/h3&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;Metanorma has threaded execution, to generate output documents from the same Presentation XML input more quickly. Similar to &lt;a href=&#34;https://github.com/relaton/relaton&#34;&gt;relaton&lt;/a&gt;, the &lt;code&gt;METANORMA_PARALLEL&lt;/code&gt; environment variable can be used to override the default number of parallel fetches used.&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;div class=&#34;sect1&#34;&gt; &#xA; &lt;h2 id=&#34;_origin_of_name&#34;&gt;Origin of name&lt;/h2&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;&lt;strong&gt;Meta-&lt;/strong&gt; is a prefix of Greek origin (&#34;μετα&#34;) for “with” “after”. In English, it has ended up meaning &#34;about (its own category)&#34;; e.g. &lt;em&gt;meta-discussion&lt;/em&gt; (a discussion about discussion). (For the roundabout way it ended up with that meaning, see &lt;a href=&#34;https://en.wikipedia.org/wiki/Meta#Etymology&#34; class=&#34;bare&#34;&gt;https://en.wikipedia.org/wiki/Meta#Etymology&lt;/a&gt;.)&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;&lt;strong&gt;Norma&lt;/strong&gt; is Latin for “rule” and “standard”; hence English &lt;em&gt;norm&lt;/em&gt;, but also German &lt;em&gt;Norm&lt;/em&gt; &#34;standard&#34;.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;The Metanorma project is for setting a standard for standard documents created by standards-setting organizations (which is a meta thing to do); hence this name.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Metanorma seeks to embrace all standards documents standards, but not possess any: it can give rise to many &#34;standard&#34; standards, but not limit the extension of any of those standards.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;The motto of the project is &lt;a href=&#34;https://en.wikipedia.org/wiki/Aequitas&#34;&gt;&lt;em&gt;Aequitate&lt;/em&gt;&lt;/a&gt; &lt;em&gt;verum&lt;/em&gt;, &#34;Truth through equity&#34;. Dealing with all standards fairly (&lt;em&gt;aequitate&lt;/em&gt;), we seek not an abstract virtue (&lt;em&gt;veritas&lt;/em&gt;), but a practical reality on the ground (&lt;em&gt;verum&lt;/em&gt;), that can be used by stakeholders of multiple standards.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt;</summary>
  </entry>
</feed>