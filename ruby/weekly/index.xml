<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-10-13T01:50:09Z</updated>
  <subtitle>Weekly Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rails/mission_control-jobs</title>
    <updated>2024-10-13T01:50:09Z</updated>
    <id>tag:github.com,2024-10-13:/rails/mission_control-jobs</id>
    <link href="https://github.com/rails/mission_control-jobs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Dashboard and Active Job extensions to operate and troubleshoot background jobs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Mission Control — Jobs&lt;/h1&gt; &#xA;&lt;p&gt;This gem provides a Rails-based frontend to Active Job adapters. It currently supports &lt;a href=&#34;https://github.com/resque/resque/&#34;&gt;Resque&lt;/a&gt; and &lt;a href=&#34;https://github.com/rails/solid_queue&#34;&gt;Solid Queue&lt;/a&gt;. Its features depend on those offered by the adapter itself. At a minimum, it allows you to inspect job queues and jobs currently waiting in those queues and inspect and retry or discard failed jobs.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;mission_control-jobs&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Basic configuration&lt;/h2&gt; &#xA;&lt;p&gt;Mount Mission Control Job&#39;s engine where you wish to have it accessible from your app, in your &lt;code&gt;routes.rb&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.application.routes.draw do&#xA;  # ...&#xA;  mount MissionControl::Jobs::Engine, at: &#34;/jobs&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And that&#39;s it. With this alone, you should be able to access Mission Control Job&#39;s UI, where you can browse the existing queues, jobs pending in these queues, jobs in different statuses, and discard and retry failed jobs:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rails/mission_control-jobs/main/docs/images/queues-simple.png&#34; alt=&#34;Queues tab in a simple app&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rails/mission_control-jobs/main/docs/images/failed-jobs-simple.png&#34; alt=&#34;Failed jobs tab in a simple app&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Authentication and base controller class&lt;/h3&gt; &#xA;&lt;p&gt;By default, Mission Control&#39;s controllers will extend the host app&#39;s &lt;code&gt;ApplicationController&lt;/code&gt;. If no authentication is enforced, &lt;code&gt;/jobs&lt;/code&gt; will be available to everyone. You might want to implement some kind of authentication for this in your app. To make this easier, you can specify a different controller as the base class for Mission Control&#39;s controllers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.application.configure do&#xA;  MissionControl::Jobs.base_controller_class = &#34;AdminController&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, in your environment config or &lt;code&gt;application.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.mission_control.jobs.base_controller_class = &#34;AdminController&#34;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Other configuration settings&lt;/h3&gt; &#xA;&lt;p&gt;Besides &lt;code&gt;base_controller_class&lt;/code&gt;, you can also set the following for &lt;code&gt;MissionControl::Jobs&lt;/code&gt; or &lt;code&gt;config.mission_control.jobs&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;logger&lt;/code&gt;: the logger you want Mission Control Jobs to use. Defaults to &lt;code&gt;ActiveSupport::Logger.new(nil)&lt;/code&gt; (no logging). Notice that this is different from Active Job&#39;s logger or Active Job&#39;s backend&#39;s configured logger.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;delay_between_bulk_operation_batches&lt;/code&gt;: how long to wait between batches when performing bulk operations, such as &lt;em&gt;discard all&lt;/em&gt; or &lt;em&gt;retry all&lt;/em&gt; jobs—defaults to &lt;code&gt;0&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;adapters&lt;/code&gt;: a list of adapters that you want Mission Control to use and extend. By default this will be the adapter you have set for &lt;code&gt;active_job.queue_adapter&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;internal_query_count_limit&lt;/code&gt;: in count queries, the maximum number of records that will be counted if the adapter needs to limit these queries. True counts above this number will be returned as &lt;code&gt;INFINITY&lt;/code&gt;. This keeps count queries fast—defaults to &lt;code&gt;500,000&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;scheduled_job_delay_threshold&lt;/code&gt;: the time duration before a scheduled job is considered delayed. Defaults to &lt;code&gt;1.minute&lt;/code&gt; (a job is considered delayed if it hasn&#39;t transitioned from the &lt;code&gt;scheduled&lt;/code&gt; status 1 minute after the scheduled time).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;show_console_help&lt;/code&gt;: whether to show the console help. If you don&#39;t want the console help message, set this to &lt;code&gt;false&lt;/code&gt;—defaults to &lt;code&gt;true&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This library extends Active Job with a querying interface and the following setting:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;config.active_job.default_page_size&lt;/code&gt;: the internal batch size that Active Job will use when sending queries to the underlying adapter and the batch size for the bulk operations defined above—defaults to &lt;code&gt;1000&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Adapter Specifics&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Resque&lt;/strong&gt;: Queue pausing is supported only if you have &lt;code&gt;resque-pause&lt;/code&gt; installed in your project&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Solid Queue&lt;/strong&gt;: Requires version &amp;gt;= 0.9.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Advanced configuration&lt;/h2&gt; &#xA;&lt;p&gt;When we built Mission Control Jobs, we did it with the idea of managing multiple apps&#39; job backends from a single, centralized app that we used for monitoring, alerts and other tools that related to all our apps. Some of our apps run in more than one datacenter, and we run different Resque instances with different Redis configurations in each. Because of this, we added support for multiple apps and multiple adapters per app. Even when running Mission Control Job within the app it manages, and a single DC, as we migrated from Resque to Solid Queue, we needed to manage both adapters from Mission Control.&lt;/p&gt; &#xA;&lt;p&gt;Without adding any additional configuration to &lt;a href=&#34;https://raw.githubusercontent.com/rails/mission_control-jobs/main/#basic-configuration&#34;&gt;the one described before&lt;/a&gt;, Mission Control will be configured with one single app and a single server for your configured &lt;code&gt;active_job.queue_adapter&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to support multiple adapters, you need to add them to Mission Control configuration via the &lt;code&gt;adapters&lt;/code&gt; setting mentioned above. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.mission_control.jobs.adapters = [ :resque, :solid_queue ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, to configure the different apps and/or different servers, you can do so in an initializer like this (taken from our dummy app for testing purposes):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;resque&#34;&#xA;require &#34;resque_pause_helper&#34;&#xA;&#xA;require &#34;solid_queue&#34;&#xA;&#xA;Resque.redis = Redis::Namespace.new &#34;#{Rails.env}&#34;, redis: Redis.new(host: &#34;localhost&#34;, port: 6379)&#xA;&#xA;SERVERS_BY_APP = {&#xA;  BC4: %w[ resque_ashburn resque_chicago ],&#xA;  HEY: %w[ resque solid_queue ]&#xA;}&#xA;&#xA;def redis_connection_for(app, server)&#xA;  redis_namespace = Redis::Namespace.new &#34;#{app}:#{server}&#34;, redis: Resque.redis.instance_variable_get(&#34;@redis&#34;)&#xA;  Resque::DataStore.new redis_namespace&#xA;end&#xA;&#xA;SERVERS_BY_APP.each do |app, servers|&#xA;  queue_adapters_by_name = servers.collect do |server|&#xA;    queue_adapter = if server.start_with?(&#34;resque&#34;)&#xA;      ActiveJob::QueueAdapters::ResqueAdapter.new(redis_connection_for(app, server))&#xA;    else&#xA;      ActiveJob::QueueAdapters::SolidQueueAdapter.new&#xA;    end&#xA;&#xA;    [ server, queue_adapter ]&#xA;  end.to_h&#xA;&#xA;  MissionControl::Jobs.applications.add(app, queue_adapters_by_name)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is an example for two different apps, BC4 and HEY, each one with two servers. BC4 has two Resque servers with two different configurations, and HEY has one Resque server and one Solid Queue server.&lt;/p&gt; &#xA;&lt;p&gt;Currently, only one Solid Queue configuration is supported, but support for several Solid Queue backends (with different databases) &lt;a href=&#34;https://github.com/rails/mission_control-jobs/issues/35&#34;&gt;is planned&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is how we set Resque and Solid Queue together when we migrated from one to the other:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;queue_adapters_by_name = {&#xA;  resque: ActiveJob::QueueAdapters.lookup(:resque).new, # This will use Resque.redis as the redis client&#xA;  solid_queue: ActiveJob::QueueAdapters.lookup(:solid_queue).new&#xA;}&#xA;&#xA;MissionControl::Jobs.applications.add(&#34;hey&#34;, queue_adapters_by_name)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you have multiple apps and servers configured, you can choose between them with select and toggle menus:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rails/mission_control-jobs/main/docs/images/queues-multiple.png&#34; alt=&#34;Queues tab with multiple apps and servers&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Basic UI usage&lt;/h2&gt; &#xA;&lt;p&gt;As mentioned, the features available in Mission Control depend on the adapter you&#39;re using, as each adapter supports different features. Besides inspecting the queues and the jobs in them, and discarding and retrying failed jobs, you can inspect jobs in different statuses supported by each adapter, filter them by &lt;em&gt;queue name&lt;/em&gt; and &lt;em&gt;job class name&lt;/em&gt; (with the idea of &lt;a href=&#34;https://github.com/rails/mission_control-jobs/issues/30&#34;&gt;adding more filters in the future&lt;/a&gt;), pause and un-pause queues (if the adapter allows that), inspect workers, know which jobs are being run by what worker, checking a specific job or a specific worker...&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rails/mission_control-jobs/main/docs/images/default-queue.png&#34; alt=&#34;Default queue tab&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rails/mission_control-jobs/main/docs/images/in-progress-jobs.png&#34; alt=&#34;In-progress jobs tab&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rails/mission_control-jobs/main/docs/images/workers.png&#34; alt=&#34;Workers tab&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rails/mission_control-jobs/main/docs/images/single-job.png&#34; alt=&#34;Single job&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rails/mission_control-jobs/main/docs/images/single-worker.png&#34; alt=&#34;Single worker&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Console helpers, scripting and dealing with big sets of jobs&lt;/h2&gt; &#xA;&lt;p&gt;Besides the UI, Mission Control provides a light console helper to switch between applications and adapters. Some potentially destructive actions aren&#39;t exposed via the UI (for example, discarding jobs that aren&#39;t failed, although this might change in the future), but you can always perform these from the console if you know very well what you&#39;re doing.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s also possible that you need to deal with very big sets of jobs that are unmanageable via the UI or that you wish to write a script to deal with an incident, some cleanup or some data migration. The console helpers and the querying API with which we&#39;ve extended Active Job come in handy here.&lt;/p&gt; &#xA;&lt;p&gt;First, when connecting to the Rails console, you&#39;ll see this new message:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; bin/rails c&#xA;&#xA;&#xA;Type &#39;jobs_help&#39; to see how to connect to the available job servers to manage jobs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Typing &lt;code&gt;jobs_help&lt;/code&gt;, you&#39;ll get clear instructions about how to switch between applications and adapters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; jobs_help&#xA;You can connect to a job server with&#xA;  connect_to &#34;&amp;lt;app_id&amp;gt;:&amp;lt;server_id&amp;gt;&#34;&#xA;&#xA;Available job servers:&#xA;  * bc4:resque_ashburn&#xA;  * bc4:resque_chicago&#xA;  * hey:resque&#xA;  * hey:solid_queue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; connect_to &#34;hey:solid_queue&#34;&#xA;Connected to hey:solid_queue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you&#39;re ready to query and operate over jobs for this adapter via the API. Some examples of queries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#xA;# All jobs&#xA;ActiveJob.jobs&#xA;&#xA;# All failed jobs&#xA;ActiveJob.jobs.failed&#xA;&#xA;# All pending jobs in some queue&#xA;ActiveJob.jobs.pending.where(queue_name: &#34;some_queue&#34;)&#xA;&#xA;# All failed jobs of a given class&#xA;ActiveJob.jobs.failed.where(job_class_name: &#34;SomeJob&#34;)&#xA;&#xA;# All pending jobs of a given class with limit and offset&#xA;ActiveJob.jobs.pending.where(job_class_name: &#34;SomeJob&#34;).limit(10).offset(5)&#xA;&#xA;# For adapters that support these statuses:&#xA;# All scheduled/in-progress/finished jobs of a given class&#xA;ActiveJob.jobs.scheduled.where(job_class_name: &#34;SomeJob&#34;)&#xA;ActiveJob.jobs.in_progress.where(job_class_name: &#34;SomeJob&#34;)&#xA;ActiveJob.jobs.finished.where(job_class_name: &#34;SomeJob&#34;)&#xA;&#xA;# For adapters that support filtering by worker:&#xA;# All jobs in progress being run by a given worker&#xA;ActiveJob.jobs.in_progress.where(worker_id: 42)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some examples of bulk operations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Retry all the jobs (only possible for failed jobs)&#xA;ActiveJob.jobs.failed.retry_all&#xA;&#xA;# Retry all the jobs of a given class (only possible for failed jobs)&#xA;ActiveJob.jobs.failed.where(job_class_name: &#34;SomeJob&#34;).retry_all&#xA;&#xA;# Discard all failed jobs&#xA;ActiveJob.jobs.failed.discard_all&#xA;&#xA;# Discard all pending jobs of a given class&#xA;ActiveJob.jobs.pending.where(job_class_name: &#34;SomeJob&#34;).discard_all&#xA;# Or all pending jobs in a given queue:&#xA;ActiveJob.jobs.pending.where(queue_name: &#34;some-queue&#34;).discard_all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When performing these bulk operations in the console, a delay of 2 seconds between batches processed will be introduced, set via &lt;a href=&#34;https://raw.githubusercontent.com/rails/mission_control-jobs/main/#other-configuration-settings&#34;&gt;&lt;code&gt;delay_between_bulk_operation_batches&lt;/code&gt;&lt;/a&gt;. You can modify it as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MissionControl::Jobs.delay_between_bulk_operation_batches = 5.seconds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Thanks for your interest in contributing! To get the app running locally, just run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bin/setup&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will load a bunch of jobs as seeds.&lt;/p&gt; &#xA;&lt;p&gt;We have both unit and functional tests and system tests. If you want to run system tests, you&#39;d need to install &lt;a href=&#34;https://chromedriver.chromium.org/&#34;&gt;ChromeDriver&lt;/a&gt;. Then, you&#39;ll be able to run the tests as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bin/rails test test/system&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>