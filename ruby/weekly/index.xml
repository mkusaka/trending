<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-04-06T01:47:18Z</updated>
  <subtitle>Weekly Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mikel/mail</title>
    <updated>2025-04-06T01:47:18Z</updated>
    <id>tag:github.com,2025-04-06:/mikel/mail</id>
    <link href="https://github.com/mikel/mail" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Really Ruby Mail Library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Mail &lt;a href=&#34;https://github.com/mikel/mail/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/mikel/mail/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Mail is an internet library for Ruby that is designed to handle email generation, parsing and sending in a simple, rubyesque manner.&lt;/p&gt; &#xA;&lt;p&gt;The purpose of this library is to provide a single point of access to handle all email functions, including sending and receiving email. All network type actions are done through proxy methods to Net::SMTP, Net::POP3 etc.&lt;/p&gt; &#xA;&lt;p&gt;Built from my experience with TMail, it is designed to be a pure ruby implementation that makes generating, sending and parsing email a no brainer.&lt;/p&gt; &#xA;&lt;p&gt;It is also designed from the ground up to work with the more modern versions of Ruby. Modern Rubies handle text encodings much more wonderfully than before so these features have been taken full advantage of in this library allowing Mail to handle a lot more messages more cleanly than TMail.&lt;/p&gt; &#xA;&lt;p&gt;Finally, Mail has been designed with a very simple object oriented system that really opens up the email messages you are parsing, if you know what you are doing, you can fiddle with every last bit of your email directly.&lt;/p&gt; &#xA;&lt;h2&gt;You can contribute to this library&lt;/h2&gt; &#xA;&lt;p&gt;Yes, you! Mail is used in countless apps by people around the world. It is, like all open source software, a labour of love borne from our free time. If you would like to say thanks, please dig in and contribute alongside us! Triage and fix &lt;a href=&#34;https://github.com/mikel/mail/issues&#34;&gt;GitHub issues&lt;/a&gt;, improve our documentation, add new featuresâ€”up to you! Thank you for pitching in.&lt;/p&gt; &#xA;&lt;h1&gt;Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mikel/mail/master/#compatibility&#34;&gt;Compatibility&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mikel/mail/master/#discussion&#34;&gt;Discussion&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mikel/mail/master/#current-capabilities-of-mail&#34;&gt;Current Capabilities of Mail&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mikel/mail/master/#roadmap&#34;&gt;Roadmap&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mikel/mail/master/#testing-policy&#34;&gt;Testing Policy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mikel/mail/master/#api-policy&#34;&gt;API Policy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mikel/mail/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mikel/mail/master/#encodings&#34;&gt;Encodings&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mikel/mail/master/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mikel/mail/master/#usage&#34;&gt;Usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mikel/mail/master/#excerpts-from-trec-spam-corpus-2005&#34;&gt;Excerpts from TREC Spam Corpus 2005&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mikel/mail/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;Mail is tested against:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ruby: 2.5&lt;/li&gt; &#xA; &lt;li&gt;Ruby: 2.6&lt;/li&gt; &#xA; &lt;li&gt;Ruby: 2.7&lt;/li&gt; &#xA; &lt;li&gt;Ruby: 3.0&lt;/li&gt; &#xA; &lt;li&gt;Ruby: 3.1&lt;/li&gt; &#xA; &lt;li&gt;Ruby: 3.2&lt;/li&gt; &#xA; &lt;li&gt;JRuby: 9.2&lt;/li&gt; &#xA; &lt;li&gt;JRuby: 9.3&lt;/li&gt; &#xA; &lt;li&gt;JRuby: 9.4&lt;/li&gt; &#xA; &lt;li&gt;JRuby: stable&lt;/li&gt; &#xA; &lt;li&gt;JRuby: head&lt;/li&gt; &#xA; &lt;li&gt;Truffleruby: stable&lt;/li&gt; &#xA; &lt;li&gt;Truffleruby: head&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As new versions of Ruby are released, Mail will be compatible with support for the &#34;preview&#34; and all &#34;normal maintenance&#34;, &#34;security maintenance&#34; and the two most recent &#34;end of life&#34; versions listed at the &lt;a href=&#34;https://www.ruby-lang.org/en/downloads/branches/&#34;&gt;Ruby Maintenance Branches&lt;/a&gt; page. Pull requests to assist in adding support for new preview releases are more than welcome.&lt;/p&gt; &#xA;&lt;p&gt;Every Mail commit is tested by GitHub Actions on &lt;a href=&#34;https://github.com/mikel/mail/raw/master/.github/workflows/test.yml&#34;&gt;all supported Ruby versions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Discussion&lt;/h2&gt; &#xA;&lt;p&gt;If you want to discuss mail with like minded individuals, please subscribe to the &lt;a href=&#34;http://groups.google.com/group/mail-ruby&#34;&gt;Google Group&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Current Capabilities of Mail&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RFC5322 Support, Reading and Writing&lt;/li&gt; &#xA; &lt;li&gt;RFC6532 Support, reading UTF-8 headers&lt;/li&gt; &#xA; &lt;li&gt;RFC2045-2049 Support for multipart email&lt;/li&gt; &#xA; &lt;li&gt;Support for creating multipart alternate email&lt;/li&gt; &#xA; &lt;li&gt;Support for reading multipart/report email &amp;amp; getting details from such&lt;/li&gt; &#xA; &lt;li&gt;Wrappers for File, Net/POP3, Net/SMTP&lt;/li&gt; &#xA; &lt;li&gt;Auto-encoding of non-US-ASCII bodies and header fields&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Mail is RFC5322 and RFC6532 compliant now, that is, it can parse US-ASCII and UTF-8 email and generate US-ASCII email. There are a few obsoleted email syntax that it will have problems with, but it also is quite robust, meaning, if it finds something it doesn&#39;t understand it will not crash, instead, it will skip the problem and keep parsing. In the case of a header it doesn&#39;t understand, it will initialise the header as an optional unstructured field and continue parsing.&lt;/p&gt; &#xA;&lt;p&gt;This means Mail won&#39;t (ever) crunch your data (I think).&lt;/p&gt; &#xA;&lt;p&gt;You can also create MIME emails. There are helper methods for making a multipart/alternate email for text/plain and text/html (the most common pair) and you can manually create any other type of MIME email.&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;Next TODO:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Improve MIME support for character sets in headers, currently works, mostly, needs refinement.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Testing Policy&lt;/h2&gt; &#xA;&lt;p&gt;Basically... we do BDD on Mail. No method gets written in Mail without a corresponding or covering spec. We expect as a minimum 100% coverage measured by RCov. While this is not perfect by any measure, it is pretty good. Additionally, all functional tests from TMail are to be passing before the gem gets released.&lt;/p&gt; &#xA;&lt;p&gt;It also means you can be sure Mail will behave correctly.&lt;/p&gt; &#xA;&lt;p&gt;You can run tests locally by running &lt;code&gt;bundle exec rspec&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can run tests on all supported Ruby versions by using &lt;a href=&#34;https://github.com/nektos/act&#34;&gt;act&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;API Policy&lt;/h2&gt; &#xA;&lt;p&gt;No API removals within a single point release. All removals to be deprecated with warnings for at least one MINOR point release before removal.&lt;/p&gt; &#xA;&lt;p&gt;Also, all private or protected methods to be declared as such - though this is still I/P.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Installation is fairly simple, I host mail on rubygems, so you can just do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# gem install mail&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Encodings&lt;/h2&gt; &#xA;&lt;p&gt;If you didn&#39;t know, handling encodings in Emails is not as straight forward as you would hope.&lt;/p&gt; &#xA;&lt;p&gt;I have tried to simplify it some:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;All objects that can render into an email, have an &lt;code&gt;#encoded&lt;/code&gt; method. Encoded will return the object as a complete string ready to send in the mail system, that is, it will include the header field and value and CRLF at the end and wrapped as needed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;All objects that can render into an email, have a &lt;code&gt;#decoded&lt;/code&gt; method. Decoded will return the object&#39;s &#34;value&#34; only as a string. This means it will not include the header fields (like &#39;To:&#39; or &#39;Subject:&#39;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;By default, calling &lt;code&gt;#to_s&lt;/code&gt; on a container object will call its encoded method, while &lt;code&gt;#to_s&lt;/code&gt; on a field object will call its decoded method. So calling &lt;code&gt;#to_s&lt;/code&gt; on a Mail object will return the mail, all encoded ready to send, while calling &lt;code&gt;#to_s&lt;/code&gt; on the From field or the body will return the decoded value of the object. The header object of Mail is considered a container. If you are in doubt, call &lt;code&gt;#encoded&lt;/code&gt;, or &lt;code&gt;#decoded&lt;/code&gt; explicitly, this is safer if you are not sure.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Structured fields that have parameter values that can be encoded (e.g. Content-Type) will provide decoded parameter values when you call the parameter names as methods against the object.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Structured fields that have parameter values that can be encoded (e.g. Content-Type) will provide encoded parameter values when you call the parameter names through the &lt;code&gt;object.parameters[&#39;&amp;lt;parameter_name&amp;gt;&#39;]&lt;/code&gt; method call.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please do! Contributing is easy in Mail. Please read the &lt;a href=&#34;https://raw.githubusercontent.com/mikel/mail/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; document for more info.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;All major mail functions should be able to happen from the Mail module. So, you should be able to just &lt;code&gt;require &#39;mail&#39;&lt;/code&gt; to get started.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;mail&lt;/code&gt; is pretty well documented in its Ruby code. You can look it up e.g. at &lt;a href=&#34;https://www.rubydoc.info/gems/mail&#34;&gt;rubydoc.info&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Making an email&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mail = Mail.new do&#xA;  from    &#39;mikel@test.lindsaar.net&#39;&#xA;  to      &#39;you@test.lindsaar.net&#39;&#xA;  subject &#39;This is a test email&#39;&#xA;  body    File.read(&#39;body.txt&#39;)&#xA;end&#xA;&#xA;mail.to_s #=&amp;gt; &#34;From: mikel@test.lindsaar.net\r\nTo: you@...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Making an email, have it your way:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mail = Mail.new do&#xA;  body File.read(&#39;body.txt&#39;)&#xA;end&#xA;&#xA;mail[&#39;from&#39;] = &#39;mikel@test.lindsaar.net&#39;&#xA;mail[:to]    = &#39;you@test.lindsaar.net&#39;&#xA;mail.subject = &#39;This is a test email&#39;&#xA;&#xA;mail.header[&#39;X-Custom-Header&#39;] = &#39;custom value&#39;&#xA;&#xA;mail.to_s #=&amp;gt; &#34;From: mikel@test.lindsaar.net\r\nTo: you@...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Don&#39;t Worry About Message IDs:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mail = Mail.new do&#xA;  to   &#39;you@test.lindsaar.net&#39;&#xA;  body &#39;Some simple body&#39;&#xA;end&#xA;&#xA;mail.to_s =~ /Message\-ID: &amp;lt;[\d\w_]+@.+.mail/ #=&amp;gt; 27&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mail will automatically add a Message-ID field if it is missing and give it a unique, random Message-ID along the lines of:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;4a7ff76d7016_13a81ab802e1@local.host.mail&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Or do worry about Message-IDs:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mail = Mail.new do&#xA;  to         &#39;you@test.lindsaar.net&#39;&#xA;  message_id &#39;&amp;lt;ThisIsMyMessageId@some.domain.com&amp;gt;&#39;&#xA;  body       &#39;Some simple body&#39;&#xA;end&#xA;&#xA;mail.to_s =~ /Message\-ID: &amp;lt;ThisIsMyMessageId@some.domain.com&amp;gt;/ #=&amp;gt; 27&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mail will take the message_id you assign to it trusting that you know what you are doing.&lt;/p&gt; &#xA;&lt;h3&gt;Sending an email:&lt;/h3&gt; &#xA;&lt;p&gt;Mail defaults to sending via SMTP to local host port 25. If you have a sendmail or postfix daemon running on this port, sending email is as easy as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Mail.deliver do&#xA;  from     &#39;me@test.lindsaar.net&#39;&#xA;  to       &#39;you@test.lindsaar.net&#39;&#xA;  subject  &#39;Here is the image you wanted&#39;&#xA;  body     File.read(&#39;body.txt&#39;)&#xA;  add_file &#39;/full/path/to/somefile.png&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mail = Mail.new do&#xA;  from     &#39;me@test.lindsaar.net&#39;&#xA;  to       &#39;you@test.lindsaar.net&#39;&#xA;  subject  &#39;Here is the image you wanted&#39;&#xA;  body     File.read(&#39;body.txt&#39;)&#xA;  add_file :filename =&amp;gt; &#39;somefile.png&#39;, :content =&amp;gt; File.read(&#39;/somefile.png&#39;)&#xA;end&#xA;&#xA;mail.deliver!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sending via sendmail can be done like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mail = Mail.new do&#xA;  from     &#39;me@test.lindsaar.net&#39;&#xA;  to       &#39;you@test.lindsaar.net&#39;&#xA;  subject  &#39;Here is the image you wanted&#39;&#xA;  body     File.read(&#39;body.txt&#39;)&#xA;  add_file :filename =&amp;gt; &#39;somefile.png&#39;, :content =&amp;gt; File.read(&#39;/somefile.png&#39;)&#xA;end&#xA;&#xA;mail.delivery_method :sendmail&#xA;&#xA;mail.deliver&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sending via smtp (for example to &lt;a href=&#34;https://github.com/sj26/mailcatcher&#34;&gt;mailcatcher&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#xA;Mail.defaults do&#xA;  delivery_method :smtp, address: &#34;localhost&#34;, port: 1025&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Exim requires its own delivery manager, and can be used like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mail.delivery_method :exim, :location =&amp;gt; &#34;/usr/bin/exim&#34;&#xA;&#xA;mail.deliver&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mail may be &#34;delivered&#34; to a logfile, too, for development and testing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Delivers by logging the encoded message to $stdout&#xA;mail.delivery_method :logger&#xA;&#xA;# Delivers to an existing logger at :debug severity&#xA;mail.delivery_method :logger, logger: other_logger, severity: :debug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting Emails from a POP or IMAP Server:&lt;/h3&gt; &#xA;&lt;p&gt;You can configure Mail to receive email using &lt;code&gt;retriever_method&lt;/code&gt; within &lt;code&gt;Mail.defaults&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# e.g. POP3&#xA;Mail.defaults do&#xA;  retriever_method :pop3, :address    =&amp;gt; &#34;pop.gmail.com&#34;,&#xA;                          :port       =&amp;gt; 995,&#xA;                          :user_name  =&amp;gt; &#39;&amp;lt;username&amp;gt;&#39;,&#xA;                          :password   =&amp;gt; &#39;&amp;lt;password&amp;gt;&#39;,&#xA;                          :enable_ssl =&amp;gt; true&#xA;end&#xA;&#xA;# IMAP&#xA;Mail.defaults do&#xA;  retriever_method :imap, :address    =&amp;gt; &#34;imap.mailbox.org&#34;,&#xA;                          :port       =&amp;gt; 993,&#xA;                          :user_name  =&amp;gt; &#39;&amp;lt;username&amp;gt;&#39;,&#xA;                          :password   =&amp;gt; &#39;&amp;lt;password&amp;gt;&#39;,&#xA;                          :enable_ssl =&amp;gt; true&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can access incoming email in a number of ways.&lt;/p&gt; &#xA;&lt;p&gt;The most recent email:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Mail.all    #=&amp;gt; Returns an array of all emails&#xA;Mail.first  #=&amp;gt; Returns the first unread email&#xA;Mail.last   #=&amp;gt; Returns the last unread email&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first 10 emails sorted by date in ascending order:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;emails = Mail.find(:what =&amp;gt; :first, :count =&amp;gt; 10, :order =&amp;gt; :asc)&#xA;emails.length #=&amp;gt; 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or even all emails:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;emails = Mail.all&#xA;emails.length #=&amp;gt; LOTS!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reading an Email&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mail = Mail.read(&#39;/path/to/message.eml&#39;)&#xA;&#xA;mail.envelope_from   #=&amp;gt; &#39;mikel@test.lindsaar.net&#39;&#xA;mail.from.addresses  #=&amp;gt; [&#39;mikel@test.lindsaar.net&#39;, &#39;ada@test.lindsaar.net&#39;]&#xA;mail.sender.address  #=&amp;gt; &#39;mikel@test.lindsaar.net&#39;&#xA;mail.to              #=&amp;gt; &#39;bob@test.lindsaar.net&#39;&#xA;mail.cc              #=&amp;gt; &#39;sam@test.lindsaar.net&#39;&#xA;mail.subject         #=&amp;gt; &#34;This is the subject&#34;&#xA;mail.date.to_s       #=&amp;gt; &#39;21 Nov 1997 09:55:06 -0600&#39;&#xA;mail.message_id      #=&amp;gt; &#39;&amp;lt;4D6AA7EB.6490534@xxx.xxx&amp;gt;&#39;&#xA;mail.decoded         #=&amp;gt; &#39;This is the body of the email...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Many more methods available.&lt;/p&gt; &#xA;&lt;h3&gt;Reading a Multipart Email&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mail = Mail.read(&#39;multipart_email&#39;)&#xA;&#xA;mail.multipart?          #=&amp;gt; true&#xA;mail.parts.length        #=&amp;gt; 2&#xA;mail.body.preamble       #=&amp;gt; &#34;Text before the first part&#34;&#xA;mail.body.epilogue       #=&amp;gt; &#34;Text after the last part&#34;&#xA;mail.parts.map { |p| p.content_type }  #=&amp;gt; [&#39;text/plain&#39;, &#39;application/pdf&#39;]&#xA;mail.parts.map { |p| p.class }         #=&amp;gt; [Mail::Message, Mail::Message]&#xA;mail.parts[0].content_type_parameters  #=&amp;gt; {&#39;charset&#39; =&amp;gt; &#39;ISO-8859-1&#39;}&#xA;mail.parts[1].content_type_parameters  #=&amp;gt; {&#39;name&#39; =&amp;gt; &#39;my.pdf&#39;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mail generates a tree of parts. Each message has many or no parts. Each part is another message which can have many or no parts.&lt;/p&gt; &#xA;&lt;p&gt;A message will only have parts if it is a multipart/mixed or multipart/related content type and has a boundary defined.&lt;/p&gt; &#xA;&lt;h3&gt;Testing and Extracting Attachments&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mail.attachments.each do | attachment |&#xA;  # Attachments is an AttachmentsList object containing a&#xA;  # number of Part objects&#xA;  if (attachment.content_type.start_with?(&#39;image/&#39;))&#xA;    # extracting images for example...&#xA;    filename = attachment.filename&#xA;    begin&#xA;      File.open(images_dir + filename, &#34;w+b&#34;, 0644) {|f| f.write attachment.decoded}&#xA;    rescue =&amp;gt; e&#xA;      puts &#34;Unable to save data for #{filename} because #{e.message}&#34;&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Writing and Sending a Multipart/Alternative (HTML and Text) Email&lt;/h3&gt; &#xA;&lt;p&gt;Mail makes some basic assumptions and makes doing the common thing as simple as possible.... (asking a lot from a mail library)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mail = Mail.deliver do&#xA;  part :content_type =&amp;gt; &#34;multipart/mixed&#34; do |p1|&#xA;    p1.part :content_type =&amp;gt; &#34;multipart/related&#34; do |p2|&#xA;      p2.part :content_type =&amp;gt; &#34;multipart/alternative&#34;,&#xA;              :content_disposition =&amp;gt; &#34;inline&#34; do |p3|&#xA;        p3.part :content_type =&amp;gt; &#34;text/plain; charset=utf-8&#34;,&#xA;                :body =&amp;gt; &#34;Here is the attachment you wanted\n&#34;&#xA;        p3.part :content_type =&amp;gt; &#34;text/html; charset=utf-8&#34;,&#xA;                :body =&amp;gt; &#34;&amp;lt;h1&amp;gt;Funky Title&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;Here is the attachment you wanted&amp;lt;/p&amp;gt;\n&#34;&#xA;      end&#xA;    end&#xA;    add_file &#39;/path/to/myfile.pdf&#39;&#xA;  end&#xA;  from      &#34;Mikel Lindsaar &amp;lt;mikel@test.lindsaar.net.au&amp;gt;&#34;&#xA;  to        &#34;nicolas@test.lindsaar.net.au&#34;&#xA;  subject   &#34;First multipart email sent with Mail&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mail then delivers the email at the end of the block and returns the resulting Mail::Message object, which you can then inspect if you so desire...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;puts mail.to_s #=&amp;gt;&#xA;&#xA;Date: Tue, 26 Apr 2022 20:12:07 +0200&#xA;From: Mikel Lindsaar &amp;lt;mikel@test.lindsaar.net.au&amp;gt;&#xA;To: nicolas@test.lindsaar.net.au&#xA;Message-ID: &amp;lt;626835f736e19_10873fdfa3c2ffd4947a3@sender.at.mail&amp;gt;&#xA;Subject: First multipart email sent with Mail&#xA;MIME-Version: 1.0&#xA;Content-Type: multipart/mixed;&#xA; boundary=\&#34;--==_mimepart_626835f733867_10873fdfa3c2ffd494636\&#34;;&#xA; charset=UTF-8&#xA;Content-Transfer-Encoding: 7bit&#xA;&#xA;&#xA;----==_mimepart_626835f733867_10873fdfa3c2ffd494636&#xA;Content-Type: multipart/mixed;&#xA; boundary=\&#34;--==_mimepart_626835f73382a_10873fdfa3c2ffd494518\&#34;;&#xA; charset=UTF-8&#xA;Content-Transfer-Encoding: 7bit&#xA;&#xA;&#xA;----==_mimepart_626835f73382a_10873fdfa3c2ffd494518&#xA;Content-Type: multipart/related;&#xA; boundary=\&#34;--==_mimepart_626835f7337f5_10873fdfa3c2ffd494438\&#34;;&#xA; charset=UTF-8&#xA;Content-Transfer-Encoding: 7bit&#xA;&#xA;&#xA;----==_mimepart_626835f7337f5_10873fdfa3c2ffd494438&#xA;Content-Type: multipart/alternative;&#xA; boundary=\&#34;--==_mimepart_626835f733702_10873fdfa3c2ffd494376\&#34;;&#xA; charset=UTF-8&#xA;Content-Transfer-Encoding: 7bit&#xA;Content-Disposition: inline&#xA;Content-ID: &amp;lt;626835f738373_10873fdfa3c2ffd49488b@sender.at.mail&amp;gt;&#xA;&#xA;&#xA;----==_mimepart_626835f733702_10873fdfa3c2ffd494376&#xA;Content-Type: text/plain;&#xA; charset=utf-8&#xA;Content-Transfer-Encoding: 7bit&#xA;&#xA;Here is the attachment you wanted&#xA;&#xA;----==_mimepart_626835f733702_10873fdfa3c2ffd494376&#xA;Content-Type: text/html;&#xA; charset=utf-8&#xA;Content-Transfer-Encoding: 7bit&#xA;&#xA;&amp;lt;h1&amp;gt;Funky Title&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;Here is the attachment you wanted&amp;lt;/p&amp;gt;&#xA;&#xA;----==_mimepart_626835f733702_10873fdfa3c2ffd494376--&#xA;&#xA;----==_mimepart_626835f7337f5_10873fdfa3c2ffd494438--&#xA;&#xA;----==_mimepart_626835f73382a_10873fdfa3c2ffd494518--&#xA;&#xA;----==_mimepart_626835f733867_10873fdfa3c2ffd494636&#xA;Content-Type: text/plain;&#xA; charset=UTF-8;&#xA; filename=myfile.txt&#xA;Content-Transfer-Encoding: 7bit&#xA;Content-Disposition: attachment;&#xA; filename=myfile.txt&#xA;Content-ID: &amp;lt;6&#xA;26835f7386ab_10873fdfa3c2ffd4949b8@sender.at.mail&amp;gt;&#xA;&#xA;Hallo,&#xA;Test&#xA;End&#xA;&#xA;----==_mimepart_626835f733867_10873fdfa3c2ffd494636--&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mail inserts the content transfer encoding, the mime version, the content-IDs and handles the content-type and boundary.&lt;/p&gt; &#xA;&lt;p&gt;Mail assumes that if your text in the body is only us-ascii, that your transfer encoding is 7bit and it is text/plain. You can override this by explicitly declaring it.&lt;/p&gt; &#xA;&lt;h3&gt;Making Multipart/Alternate, Without a Block&lt;/h3&gt; &#xA;&lt;p&gt;You don&#39;t have to use a block with the text and html part included, you can just do it declaratively. However, you need to add Mail::Parts to an email, not Mail::Messages.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mail = Mail.new do&#xA;  to      &#39;nicolas@test.lindsaar.net.au&#39;&#xA;  from    &#39;Mikel Lindsaar &amp;lt;mikel@test.lindsaar.net.au&amp;gt;&#39;&#xA;  subject &#39;First multipart email sent with Mail&#39;&#xA;end&#xA;&#xA;text_part = Mail::Part.new do&#xA;  body &#39;This is plain text&#39;&#xA;end&#xA;&#xA;html_part = Mail::Part.new do&#xA;  content_type &#39;text/html; charset=UTF-8&#39;&#xA;  body &#39;&amp;lt;h1&amp;gt;This is HTML&amp;lt;/h1&amp;gt;&#39;&#xA;end&#xA;&#xA;mail.text_part = text_part&#xA;mail.html_part = html_part&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Results in the same email as done using the block form&lt;/p&gt; &#xA;&lt;h3&gt;Getting Error Reports from an Email:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@mail = Mail.read(&#39;/path/to/bounce_message.eml&#39;)&#xA;&#xA;@mail.bounced?         #=&amp;gt; true&#xA;@mail.final_recipient  #=&amp;gt; rfc822;mikel@dont.exist.com&#xA;@mail.action           #=&amp;gt; failed&#xA;@mail.error_status     #=&amp;gt; 5.5.0&#xA;@mail.diagnostic_code  #=&amp;gt; smtp;550 Requested action not taken: mailbox unavailable&#xA;@mail.retryable?       #=&amp;gt; false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Attaching and Detaching Files&lt;/h3&gt; &#xA;&lt;p&gt;You can just read the file off an absolute path, Mail will try to guess the mime_type and will encode the file in Base64 for you.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@mail = Mail.new&#xA;@mail.add_file(&#34;/path/to/file.jpg&#34;)&#xA;@mail.parts.first.attachment? #=&amp;gt; true&#xA;@mail.parts.first.content_transfer_encoding.to_s #=&amp;gt; &#39;base64&#39;&#xA;@mail.attachments.first.mime_type #=&amp;gt; &#39;image/jpg&#39;&#xA;@mail.attachments.first.filename #=&amp;gt; &#39;file.jpg&#39;&#xA;@mail.attachments.first.decoded == File.read(&#39;/path/to/file.jpg&#39;) #=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or You can pass in file_data and give it a filename, again, mail will try and guess the mime_type for you.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@mail = Mail.new&#xA;@mail.attachments[&#39;myfile.pdf&#39;] = File.read(&#39;path/to/myfile.pdf&#39;)&#xA;@mail.parts.first.attachment? #=&amp;gt; true&#xA;@mail.attachments.first.mime_type #=&amp;gt; &#39;application/pdf&#39;&#xA;@mail.attachments.first.decoded == File.read(&#39;path/to/myfile.pdf&#39;) #=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also override the guessed MIME media type if you really know better than mail (this should be rarely needed)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@mail = Mail.new&#xA;@mail.attachments[&#39;myfile.pdf&#39;] = { :mime_type =&amp;gt; &#39;application/x-pdf&#39;,&#xA;                                    :content =&amp;gt; File.read(&#39;path/to/myfile.pdf&#39;) }&#xA;@mail.parts.first.mime_type #=&amp;gt; &#39;application/x-pdf&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course... Mail will round trip an attachment as well&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@mail = Mail.new do&#xA;  to      &#39;nicolas@test.lindsaar.net.au&#39;&#xA;  from    &#39;Mikel Lindsaar &amp;lt;mikel@test.lindsaar.net.au&amp;gt;&#39;&#xA;  subject &#39;First multipart email sent with Mail&#39;&#xA;&#xA;  text_part do&#xA;    body &#39;Here is the attachment you wanted&#39;&#xA;  end&#xA;&#xA;  html_part do&#xA;    content_type &#39;text/html; charset=UTF-8&#39;&#xA;    body &#39;&amp;lt;h1&amp;gt;Funky Title&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;Here is the attachment you wanted&amp;lt;/p&amp;gt;&#39;&#xA;  end&#xA;&#xA;  add_file &#39;/path/to/myfile.pdf&#39;&#xA;end&#xA;&#xA;@round_tripped_mail = Mail.new(@mail.encoded)&#xA;&#xA;@round_tripped_mail.attachments.length #=&amp;gt; 1&#xA;@round_tripped_mail.attachments.first.filename #=&amp;gt; &#39;myfile.pdf&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &#34;Testing and extracting attachments&#34; above for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Using Mail with Testing or Spec&#39;ing Libraries&lt;/h2&gt; &#xA;&lt;p&gt;If mail is part of your system, you&#39;ll need a way to test it without actually sending emails, the TestMailer can do this for you.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;mail&#39;&#xA;=&amp;gt; true&#xA;Mail.defaults do&#xA;  delivery_method :test&#xA;end&#xA;=&amp;gt; #&amp;lt;Mail::Configuration:0x19345a8 @delivery_method=Mail::TestMailer&amp;gt;&#xA;Mail::TestMailer.deliveries&#xA;=&amp;gt; []&#xA;Mail.deliver do&#xA;  to &#39;mikel@me.com&#39;&#xA;  from &#39;you@you.com&#39;&#xA;  subject &#39;testing&#39;&#xA;  body &#39;hello&#39;&#xA;end&#xA;=&amp;gt; #&amp;lt;Mail::Message:0x19284ec ...&#xA;Mail::TestMailer.deliveries.length&#xA;=&amp;gt; 1&#xA;Mail::TestMailer.deliveries.first&#xA;=&amp;gt; #&amp;lt;Mail::Message:0x19284ec ...&#xA;Mail::TestMailer.deliveries.clear&#xA;=&amp;gt; []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is also a set of RSpec matchers stolen/inspired by Shoulda&#39;s ActionMailer matchers (you&#39;ll want to set &lt;code&gt;delivery_method&lt;/code&gt; as above too):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Mail.defaults do&#xA;  delivery_method :test # in practice you&#39;d do this in spec_helper.rb&#xA;end&#xA;&#xA;RSpec.describe &#34;sending an email&#34; do&#xA;  include Mail::Matchers&#xA;&#xA;  before(:each) do&#xA;    Mail::TestMailer.deliveries.clear&#xA;&#xA;    Mail.deliver do&#xA;      to [&#39;mikel@me.com&#39;, &#39;mike2@me.com&#39;]&#xA;      from &#39;you@you.com&#39;&#xA;      subject &#39;testing&#39;&#xA;      body &#39;hello&#39;&#xA;    end&#xA;  end&#xA;&#xA;  it { is_expected.to have_sent_email } # passes if any email at all was sent&#xA;&#xA;  it { is_expected.to have_sent_email.from(&#39;you@you.com&#39;) }&#xA;  it { is_expected.to have_sent_email.to(&#39;mike1@me.com&#39;) }&#xA;&#xA;  # can specify a list of recipients...&#xA;  it { is_expected.to have_sent_email.to([&#39;mike1@me.com&#39;, &#39;mike2@me.com&#39;]) }&#xA;&#xA;  # ...or chain recipients together&#xA;  it { is_expected.to have_sent_email.to(&#39;mike1@me.com&#39;).to(&#39;mike2@me.com&#39;) }&#xA;&#xA;  it { is_expected.to have_sent_email.with_subject(&#39;testing&#39;) }&#xA;&#xA;  it { is_expected.to have_sent_email.with_body(&#39;hello&#39;) }&#xA;&#xA;  # Can match subject or body with a regex&#xA;  # (or anything that responds_to? :match)&#xA;&#xA;  it { is_expected.to have_sent_email.matching_subject(/test(ing)?/) }&#xA;  it { is_expected.to have_sent_email.matching_body(/h(a|e)llo/) }&#xA;&#xA;  # Can chain together modifiers&#xA;  # Note that apart from recipients, repeating a modifier overwrites old value.&#xA;&#xA;  it { is_expected.to have_sent_email.from(&#39;you@you.com&#39;).to(&#39;mike1@me.com&#39;).matching_body(/hell/)&#xA;&#xA;  # test for attachments&#xA;&#xA;  # ... by specific attachment&#xA;  it { is_expected.to have_sent_email.with_attachments(my_attachment) }&#xA;&#xA;  # ... or any attachment&#xA;  it { is_expected.to have_sent_email.with_attachments(any_attachment) }&#xA;&#xA;  # ... or attachment with filename&#xA;  it { is_expected.to have_sent_email.with_attachments(an_attachment_with_filename(&#39;file.txt&#39;)) }&#xA;&#xA;  # ... or attachment with mime_type&#xA;  it { is_expected.to have_sent_email.with_attachments(an_attachment_with_mime_type(&#39;application/pdf&#39;)) }&#xA;&#xA;  # ... by array of attachments&#xA;  it { is_expected.to have_sent_email.with_attachments([my_attachment1, my_attachment2]) } #note that order is important&#xA;&#xA;  #... by presence&#xA;  it { is_expected.to have_sent_email.with_any_attachments }&#xA;&#xA;  #... or by absence&#xA;  it { is_expected.to have_sent_email.with_no_attachments }&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Excerpts from TREC Spam Corpus 2005&lt;/h2&gt; &#xA;&lt;p&gt;The spec fixture files in spec/fixtures/emails/from_trec_2005 are from the 2005 TREC Public Spam Corpus. They remain copyrighted under the terms of that project and license agreement. They are used in this project to verify and describe the development of this email parser implementation.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://plg.uwaterloo.ca/~gvcormac/treccorpus/&#34;&gt;http://plg.uwaterloo.ca/~gvcormac/treccorpus/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;They are used as allowed by &#39;Permitted Uses, Clause 3&#39;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;Small excerpts of the information may be displayed to others&#xA; or published in a scientific or technical context, solely for&#xA; the purpose of describing the research and development and&#xA; related issues.&#34;&#xA;&#xA; -- http://plg.uwaterloo.ca/~gvcormac/treccorpus/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;(The MIT License)&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2009-2016 Mikel Lindsaar&lt;/p&gt; &#xA;&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &#39;Software&#39;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:&lt;/p&gt; &#xA;&lt;p&gt;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&lt;/p&gt; &#xA;&lt;p&gt;THE SOFTWARE IS PROVIDED &#39;AS IS&#39;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&lt;/p&gt;</summary>
  </entry>
</feed>