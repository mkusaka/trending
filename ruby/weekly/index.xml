<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-14T02:02:40Z</updated>
  <subtitle>Weekly Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bblimke/webmock</title>
    <updated>2022-08-14T02:02:40Z</updated>
    <id>tag:github.com,2022-08-14:/bblimke/webmock</id>
    <link href="https://github.com/bblimke/webmock" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Library for stubbing and setting expectations on HTTP requests in Ruby.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;WebMock&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://badge.fury.io/rb/webmock&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/webmock.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bblimke/webmock/actions&#34;&gt;&lt;img src=&#34;https://github.com/bblimke/webmock/workflows/CI/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/bblimke/webmock&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/bblimke/webmock/badges/gpa.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/markets/awesome-ruby&#34;&gt;&lt;img src=&#34;https://awesome.re/mentioned-badge.svg?sanitize=true&#34; alt=&#34;Mentioned in Awesome Ruby&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://inch-ci.org/github/bblimke/webmock&#34;&gt;&lt;img src=&#34;http://inch-ci.org/github/bblimke/webmock.svg?branch=master&#34; alt=&#34;Inline docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://dependabot.com/compatibility-score.html?dependency-name=webmock&amp;amp;package-manager=bundler&amp;amp;version-scheme=semver&#34;&gt;&lt;img src=&#34;https://api.dependabot.com/badges/compatibility_score?dependency-name=webmock&amp;amp;package-manager=bundler&amp;amp;version-scheme=semver&#34; alt=&#34;SemVer&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Library for stubbing and setting expectations on HTTP requests in Ruby.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Stubbing HTTP requests at low http client lib level (no need to change tests when you change HTTP library)&lt;/li&gt; &#xA; &lt;li&gt;Setting and verifying expectations on HTTP requests&lt;/li&gt; &#xA; &lt;li&gt;Matching requests based on method, URI, headers and body&lt;/li&gt; &#xA; &lt;li&gt;Smart matching of the same URIs in different representations (also encoded and non encoded forms)&lt;/li&gt; &#xA; &lt;li&gt;Smart matching of the same headers in different representations.&lt;/li&gt; &#xA; &lt;li&gt;Support for Test::Unit&lt;/li&gt; &#xA; &lt;li&gt;Support for RSpec&lt;/li&gt; &#xA; &lt;li&gt;Support for MiniTest&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Supported HTTP libraries&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/socketry/async-http&#34;&gt;Async::HTTP::Client&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/taf2/curb&#34;&gt;Curb&lt;/a&gt; (currently only Curb::Easy)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/igrigorik/em-http-request&#34;&gt;EM-HTTP-Request&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/excon/excon&#34;&gt;Excon&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nahi/httpclient&#34;&gt;HTTPClient&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/httprb/http&#34;&gt;HTTP Gem (also known as http.rb)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://honeyryderchuck.gitlab.io/httpx/wiki/Webmock-Adapter&#34;&gt;httpx&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cheald/manticore&#34;&gt;Manticore&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ruby-doc.org/stdlib-2.7.0/libdoc/net/http/rdoc/Net/HTTP.html&#34;&gt;Net::HTTP&lt;/a&gt; and other libraries based on Net::HTTP, e.g.: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/jnunemaker/httparty&#34;&gt;HTTParty&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/rest-client/rest-client&#34;&gt;REST Client&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/toland/patron&#34;&gt;Patron&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/typhoeus/typhoeus&#34;&gt;Typhoeus&lt;/a&gt; (currently only Typhoeus::Hydra)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Supported Ruby Interpreters&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MRI 2.5&lt;/li&gt; &#xA; &lt;li&gt;MRI 2.6&lt;/li&gt; &#xA; &lt;li&gt;MRI 2.7&lt;/li&gt; &#xA; &lt;li&gt;JRuby&lt;/li&gt; &#xA; &lt;li&gt;Rubinius&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    gem install webmock&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or alternatively:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    # add to your Gemfile&#xA;    group :test do&#xA;        gem &#34;webmock&#34;&#xA;    end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;or to install the latest development version from github master&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone http://github.com/bblimke/webmock.git&#xA;cd webmock&#xA;rake install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Upgrading from v1.x to v2.x&lt;/h2&gt; &#xA;&lt;p&gt;WebMock 2.x has changed somewhat since version 1.x. Changes are listed in &lt;a href=&#34;https://raw.githubusercontent.com/bblimke/webmock/master/CHANGELOG.md&#34;&gt;CHANGELOG.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Cucumber&lt;/h3&gt; &#xA;&lt;p&gt;Create a file &lt;code&gt;features/support/webmock.rb&lt;/code&gt; with the following contents:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock/cucumber&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MiniTest&lt;/h3&gt; &#xA;&lt;p&gt;Add the following code to &lt;code&gt;test/test_helper&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock/minitest&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;RSpec&lt;/h3&gt; &#xA;&lt;p&gt;Add the following code to &lt;code&gt;spec/spec_helper&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock/rspec&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Test::Unit&lt;/h3&gt; &#xA;&lt;p&gt;Add the following code to &lt;code&gt;test/test_helper.rb&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock/test_unit&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Outside a test framework&lt;/h3&gt; &#xA;&lt;p&gt;You can also use WebMock outside a test framework:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock&#39;&#xA;include WebMock::API&#xA;&#xA;WebMock.enable!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;h2&gt;Stubbing&lt;/h2&gt; &#xA;&lt;h3&gt;Stubbed request based on uri only and with the default response&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#34;www.example.com&#34;)&#xA;&#xA;Net::HTTP.get(&#34;www.example.com&#34;, &#34;/&#34;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stubbing requests based on method, uri, body and headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:post, &#34;www.example.com&#34;).&#xA;  with(body: &#34;abc&#34;, headers: { &#39;Content-Length&#39; =&amp;gt; 3 })&#xA;&#xA;uri = URI.parse(&#34;http://www.example.com/&#34;)&#xA;req = Net::HTTP::Post.new(uri.path)&#xA;req[&#39;Content-Length&#39;] = 3&#xA;&#xA;res = Net::HTTP.start(uri.host, uri.port) do |http|&#xA;  http.request(req, &#34;abc&#34;)&#xA;end    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching request body and headers against regular expressions&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:post, &#34;www.example.com&#34;).&#xA;  with(body: /world$/, headers: {&#34;Content-Type&#34; =&amp;gt; /image\/.+/}).&#xA;  to_return(body: &#34;abc&#34;)&#xA;&#xA;uri = URI.parse(&#39;http://www.example.com/&#39;)&#xA;req = Net::HTTP::Post.new(uri.path)&#xA;req[&#39;Content-Type&#39;] = &#39;image/png&#39;&#xA;&#xA;res = Net::HTTP.start(uri.host, uri.port) do |http|&#xA;  http.request(req, &#39;hello world&#39;)&#xA;end    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching request body against a hash. Body can be URL-Encoded, JSON or XML.&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:post, &#34;www.example.com&#34;).&#xA;  with(body: {data: {a: &#39;1&#39;, b: &#39;five&#39;}})&#xA;&#xA;RestClient.post(&#39;www.example.com&#39;, &#34;data[a]=1&amp;amp;data[b]=five&#34;,&#xA;  content_type: &#39;application/x-www-form-urlencoded&#39;)    # ===&amp;gt; Success&#xA;&#xA;RestClient.post(&#39;www.example.com&#39;, &#39;{&#34;data&#34;:{&#34;a&#34;:&#34;1&#34;,&#34;b&#34;:&#34;five&#34;}}&#39;,&#xA;  content_type: &#39;application/json&#39;)    # ===&amp;gt; Success&#xA;&#xA;RestClient.post(&#39;www.example.com&#39;, &#39;&amp;lt;data a=&#34;1&#34; b=&#34;five&#34; /&amp;gt;&#39;,&#xA;  content_type: &#39;application/xml&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching request body against partial hash.&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:post, &#34;www.example.com&#34;).&#xA;  with(body: hash_including({data: {a: &#39;1&#39;, b: &#39;five&#39;}}))&#xA;&#xA;RestClient.post(&#39;www.example.com&#39;, &#34;data[a]=1&amp;amp;data[b]=five&amp;amp;x=1&#34;,&#xA;:content_type =&amp;gt; &#39;application/x-www-form-urlencoded&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching custom request headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#34;www.example.com&#34;).&#xA;  with(headers:{ &#39;Header-Name&#39; =&amp;gt; &#39;Header-Value&#39; })&#xA;&#xA;uri = URI.parse(&#39;http://www.example.com/&#39;)&#xA;req = Net::HTTP::Post.new(uri.path)&#xA;req[&#39;Header-Name&#39;] = &#39;Header-Value&#39;&#xA;&#xA;res = Net::HTTP.start(uri.host, uri.port) do |http|&#xA;  http.request(req, &#39;abc&#39;)&#xA;end    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching multiple headers with the same name&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#39;www.example.com&#39;).&#xA;  with(headers: {&#39;Accept&#39; =&amp;gt; [&#39;image/jpeg&#39;, &#39;image/png&#39;] })&#xA;&#xA;req = Net::HTTP::Get.new(&#34;/&#34;)&#xA;req[&#39;Accept&#39;] = [&#39;image/png&#39;]&#xA;req.add_field(&#39;Accept&#39;, &#39;image/jpeg&#39;)&#xA;Net::HTTP.start(&#34;www.example.com&#34;) {|http| http.request(req) }    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching requests against provided block&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:post, &#34;www.example.com&#34;).with { |request| request.body == &#34;abc&#34; }&#xA;RestClient.post(&#39;www.example.com&#39;, &#39;abc&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Request with basic authentication header&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).with(basic_auth: [&#39;user&#39;, &#39;pass&#39;])&#xA;# or&#xA;# stub_request(:get, &#34;www.example.com&#34;).&#xA;#   with(headers: {&#39;Authorization&#39; =&amp;gt; &#34;Basic #{ Base64.strict_encode64(&#39;user:pass&#39;).chomp}&#34;})&#xA;&#xA;Net::HTTP.start(&#39;www.example.com&#39;) do |http|&#xA;  req = Net::HTTP::Get.new(&#39;/&#39;)&#xA;  req.basic_auth &#39;user&#39;, &#39;pass&#39;&#xA;  http.request(req)&#xA;end    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Important! Since version 2.0.0, WebMock does not match credentials provided in Authorization header and credentials provided in the userinfo of a url. I.e. &lt;code&gt;stub_request(:get, &#34;user:pass@www.example.com&#34;)&lt;/code&gt; does not match a request with credentials provided in the Authorization header.&lt;/h5&gt; &#xA;&lt;h3&gt;Request with basic authentication in the url&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;user:pass@www.example.com&#34;)&#xA;&#xA;RestClient.get(&#39;user:pass@www.example.com&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching uris using regular expressions&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, /example/)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching uris using lambda&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, -&amp;gt;(uri) { true })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching uris using RFC 6570 - Basic Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;uri_template = Addressable::Template.new &#34;www.example.com/{id}/&#34;&#xA;stub_request(:any, uri_template)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/webmock/&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching uris using RFC 6570 - Advanced Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;uri_template =&#xA;  Addressable::Template.new &#34;www.example.com/thing/{id}.json{?x,y,z}{&amp;amp;other*}&#34;&#xA;stub_request(:any, uri_template)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;,&#xA;  &#39;/thing/5.json?x=1&amp;amp;y=2&amp;amp;z=3&amp;amp;anyParam=4&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching query params using hash&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).with(query: {&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]})&#xA;&#xA;RestClient.get(&#34;http://www.example.com/?a[]=b&amp;amp;a[]=c&#34;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching partial query params using hash&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).&#xA;  with(query: hash_including({&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]}))&#xA;&#xA;RestClient.get(&#34;http://www.example.com/?a[]=b&amp;amp;a[]=c&amp;amp;x=1&#34;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching partial query params using hash_excluding&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).&#xA;  with(query: hash_excluding({&#34;a&#34; =&amp;gt; &#34;b&#34;}))&#xA;&#xA;RestClient.get(&#34;http://www.example.com/?a=b&#34;)    # ===&amp;gt; Failure&#xA;RestClient.get(&#34;http://www.example.com/?a=c&#34;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stubbing with custom response&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#34;www.example.com&#34;).&#xA;  to_return(body: &#34;abc&#34;, status: 200,&#xA;    headers: { &#39;Content-Length&#39; =&amp;gt; 3 })&#xA;&#xA;Net::HTTP.get(&#34;www.example.com&#34;, &#39;/&#39;)    # ===&amp;gt; &#34;abc&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set appropriate Content-Type for HTTParty&#39;s &lt;code&gt;parsed_response&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#34;www.example.com&#34;).to_return body: &#39;{}&#39;, headers: {content_type: &#39;application/json&#39;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Response with body specified as IO object&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;File.open(&#39;/tmp/response_body.txt&#39;, &#39;w&#39;) { |f| f.puts &#39;abc&#39; }&#xA;&#xA;stub_request(:any, &#34;www.example.com&#34;).&#xA;  to_return(body: File.new(&#39;/tmp/response_body.txt&#39;), status: 200)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Response with custom status message&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#34;www.example.com&#34;).&#xA;  to_return(status: [500, &#34;Internal Server Error&#34;])&#xA;&#xA;req = Net::HTTP::Get.new(&#34;/&#34;)&#xA;Net::HTTP.start(&#34;www.example.com&#34;) { |http| http.request(req) }.&#xA;  message    # ===&amp;gt; &#34;Internal Server Error&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Replaying raw responses recorded with &lt;code&gt;curl -is&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl -is www.example.com &amp;gt; /tmp/example_curl_-is_output.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;raw_response_file = File.new(&#34;/tmp/example_curl_-is_output.txt&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;from file&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).to_return(raw_response_file)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or string&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).to_return(raw_response_file.read)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Responses dynamically evaluated from block&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).&#xA;  to_return { |request| {body: request.body} }&#xA;&#xA;RestClient.post(&#39;www.example.net&#39;, &#39;abc&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Responses dynamically evaluated from lambda&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).&#xA;  to_return(lambda { |request| {body: request.body} })&#xA;&#xA;RestClient.post(&#39;www.example.net&#39;, &#39;abc&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dynamically evaluated raw responses recorded with &lt;code&gt;curl -is&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;`curl -is www.example.com &amp;gt; /tmp/www.example.com.txt`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).&#xA;  to_return(lambda { |request| File.new(&#34;/tmp/#{request.uri.host.to_s}.txt&#34;) })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Responses with dynamically evaluated parts&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).&#xA;  to_return(body: lambda { |request| request.body })&#xA;&#xA;RestClient.post(&#39;www.example.net&#39;, &#39;abc&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rack responses&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyRackApp&#xA;  def self.call(env)&#xA;    [200, {}, [&#34;Hello&#34;]]&#xA;  end&#xA;end&#xA;&#xA;stub_request(:get, &#34;www.example.com&#34;).to_rack(MyRackApp)&#xA;&#xA;RestClient.post(&#39;www.example.com&#39;)    # ===&amp;gt; &#34;Hello&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Raising errors&lt;/h3&gt; &#xA;&lt;h4&gt;Exception declared by class&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).to_raise(StandardError)&#xA;&#xA;RestClient.post(&#39;www.example.net&#39;, &#39;abc&#39;)    # ===&amp;gt; StandardError&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;or by exception instance&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).to_raise(StandardError.new(&#34;some error&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;or by string&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).to_raise(&#34;some error&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Raising timeout errors&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).to_timeout&#xA;&#xA;RestClient.post(&#39;www.example.net&#39;, &#39;abc&#39;)    # ===&amp;gt; RestClient::RequestTimeout&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiple responses for repeated requests&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).&#xA;  to_return({body: &#34;abc&#34;}, {body: &#34;def&#34;})&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;def\n&#34;&#xA;&#xA;#after all responses are used the last response will be returned infinitely&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;def\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiple responses using chained &lt;code&gt;to_return()&lt;/code&gt;, &lt;code&gt;to_raise()&lt;/code&gt; or &lt;code&gt;to_timeout&lt;/code&gt; declarations&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).&#xA;  to_return({body: &#34;abc&#34;}).then.  #then() is just a syntactic sugar&#xA;  to_return({body: &#34;def&#34;}).then.&#xA;  to_raise(MyException)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;def\n&#34;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; MyException raised&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying number of times given response should be returned&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).&#xA;  to_return({body: &#34;abc&#34;}).times(2).then.&#xA;  to_return({body: &#34;def&#34;})&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;def\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Removing unused stubs&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_get = stub_request(:get, &#34;www.example.com&#34;)&#xA;remove_request_stub(stub_get)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Real requests to network can be allowed or disabled&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.allow_net_connect!&#xA;&#xA;stub_request(:any, &#34;www.example.com&#34;).to_return(body: &#34;abc&#34;)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;abc&#34;&#xA;&#xA;Net::HTTP.get(&#39;www.something.com&#39;, &#39;/&#39;)    # ===&amp;gt; /.+Something.+/&#xA;&#xA;WebMock.disable_net_connect!&#xA;&#xA;Net::HTTP.get(&#39;www.something.com&#39;, &#39;/&#39;)    # ===&amp;gt; Failure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;External requests can be disabled while allowing localhost&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.disable_net_connect!(allow_localhost: true)&#xA;&#xA;Net::HTTP.get(&#39;www.something.com&#39;, &#39;/&#39;)    # ===&amp;gt; Failure&#xA;&#xA;Net::HTTP.get(&#39;localhost:9887&#39;, &#39;/&#39;)    # ===&amp;gt; Allowed. Perhaps to Selenium?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;External requests can be disabled while allowing specific requests&lt;/h3&gt; &#xA;&lt;p&gt;Allowed requests can be specified in a number of ways.&lt;/p&gt; &#xA;&lt;p&gt;With a &lt;code&gt;String&lt;/code&gt; specifying a host name:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.disable_net_connect!(allow: &#39;www.example.org&#39;)&#xA;&#xA;RestClient.get(&#39;www.something.com&#39;, &#39;/&#39;)    # ===&amp;gt; Failure&#xA;RestClient.get(&#39;www.example.org&#39;, &#39;/&#39;)      # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;www.example.org:8080&#39;, &#39;/&#39;) # ===&amp;gt; Allowed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With a &lt;code&gt;String&lt;/code&gt; specifying a host name and a port:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.disable_net_connect!(allow: &#39;www.example.org:8080&#39;)&#xA;&#xA;RestClient.get(&#39;www.something.com&#39;, &#39;/&#39;)    # ===&amp;gt; Failure&#xA;RestClient.get(&#39;www.example.org&#39;, &#39;/&#39;)      # ===&amp;gt; Failure&#xA;RestClient.get(&#39;www.example.org:8080&#39;, &#39;/&#39;) # ===&amp;gt; Allowed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With a &lt;code&gt;Regexp&lt;/code&gt; matching the URI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.disable_net_connect!(allow: %r{ample.org/foo})&#xA;&#xA;RestClient.get(&#39;www.example.org&#39;, &#39;/foo/bar&#39;) # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;sample.org&#39;, &#39;/foo&#39;)          # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;sample.org&#39;, &#39;/bar&#39;)          # ===&amp;gt; Failure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With an object that responds to &lt;code&gt;#call&lt;/code&gt;, receiving a &lt;code&gt;URI&lt;/code&gt; object and returning a boolean:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;denylist = [&#39;google.com&#39;, &#39;facebook.com&#39;, &#39;apple.com&#39;]&#xA;allowed_sites = lambda{|uri|&#xA;  denylist.none?{|site| uri.host.include?(site) }&#xA;}&#xA;WebMock.disable_net_connect!(allow: allowed_sites)&#xA;&#xA;RestClient.get(&#39;www.example.org&#39;, &#39;/&#39;)  # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;www.facebook.com&#39;, &#39;/&#39;) # ===&amp;gt; Failure&#xA;RestClient.get(&#39;apple.com&#39;, &#39;/&#39;)        # ===&amp;gt; Failure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With an &lt;code&gt;Array&lt;/code&gt; of any of the above:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.disable_net_connect!(allow: [&#xA;  lambda{|uri| uri.host.length % 2 == 0 },&#xA;  /ample.org/,&#xA;  &#39;bbc.co.uk&#39;,&#xA;])&#xA;&#xA;RestClient.get(&#39;www.example.org&#39;, &#39;/&#39;) # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;bbc.co.uk&#39;, &#39;/&#39;)       # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;bbc.com&#39;, &#39;/&#39;)         # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;www.bbc.com&#39;, &#39;/&#39;)     # ===&amp;gt; Failure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Connecting on Net::HTTP.start&lt;/h2&gt; &#xA;&lt;p&gt;HTTP protocol has 3 steps: connect, request and response (or 4 with close). Most Ruby HTTP client libraries treat connect as a part of request step, with the exception of &lt;code&gt;Net::HTTP&lt;/code&gt; which allows opening connection to the server separately to the request, by using &lt;code&gt;Net::HTTP.start&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;WebMock API was also designed with connect being part of request step, and it only allows stubbing requests, not connections. When &lt;code&gt;Net::HTTP.start&lt;/code&gt; is called, WebMock doesn&#39;t know yet whether a request is stubbed or not. WebMock by default delays a connection until the request is invoked, so when there is no request, &lt;code&gt;Net::HTTP.start&lt;/code&gt; doesn&#39;t do anything. &lt;strong&gt;This means that WebMock breaks the Net::HTTP behaviour by default!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;To workaround this issue, WebMock offers &lt;code&gt;:net_http_connect_on_start&lt;/code&gt; option, which can be passed to &lt;code&gt;WebMock.allow_net_connect!&lt;/code&gt; and &lt;code&gt;WebMock.disable_net_connect!&lt;/code&gt; methods, i.e.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.allow_net_connect!(net_http_connect_on_start: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This forces WebMock Net::HTTP adapter to always connect on &lt;code&gt;Net::HTTP.start&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Setting Expectations&lt;/h2&gt; &#xA;&lt;h3&gt;Setting expectations in Test::Unit&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock/test_unit&#39;&#xA;&#xA;stub_request(:any, &#34;www.example.com&#34;)&#xA;&#xA;uri = URI.parse(&#39;http://www.example.com/&#39;)&#xA;req = Net::HTTP::Post.new(uri.path)&#xA;req[&#39;Content-Length&#39;] = 3&#xA;&#xA;res = Net::HTTP.start(uri.host, uri.port) do |http|&#xA;  http.request(req, &#39;abc&#39;)&#xA;end&#xA;&#xA;assert_requested :post, &#34;http://www.example.com&#34;,&#xA;  headers: {&#39;Content-Length&#39; =&amp;gt; 3}, body: &#34;abc&#34;,&#xA;  times: 1    # ===&amp;gt; Success&#xA;&#xA;assert_not_requested :get, &#34;http://www.something.com&#34;    # ===&amp;gt; Success&#xA;&#xA;assert_requested(:post, &#34;http://www.example.com&#34;,&#xA;  times: 1) { |req| req.body == &#34;abc&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Expecting real (not stubbed) requests&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.allow_net_connect!&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; Success&#xA;&#xA;assert_requested :get, &#34;http://www.example.com&#34;    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setting expectations in Test::Unit on the stub&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_get = stub_request(:get, &#34;www.example.com&#34;)&#xA;stub_post = stub_request(:post, &#34;www.example.com&#34;)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)&#xA;&#xA;assert_requested(stub_get)&#xA;assert_not_requested(stub_post)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setting expectations in RSpec on &lt;code&gt;WebMock&lt;/code&gt; module&lt;/h3&gt; &#xA;&lt;p&gt;This style is borrowed from &lt;a href=&#34;http://github.com/pat/fakeweb-matcher&#34;&gt;fakeweb-matcher&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock/rspec&#39;&#xA;&#xA;expect(WebMock).to have_requested(:get, &#34;www.example.com&#34;).&#xA;  with(body: &#34;abc&#34;, headers: {&#39;Content-Length&#39; =&amp;gt; 3}).twice&#xA;&#xA;expect(WebMock).not_to have_requested(:get, &#34;www.something.com&#34;)&#xA;&#xA;expect(WebMock).to have_requested(:post, &#34;www.example.com&#34;).&#xA;  with { |req| req.body == &#34;abc&#34; }&#xA;# Note that the block with `do ... end` instead of curly brackets won&#39;t work!&#xA;# Why? See this comment https://github.com/bblimke/webmock/issues/174#issuecomment-34908908&#xA;&#xA;expect(WebMock).to have_requested(:get, &#34;www.example.com&#34;).&#xA;  with(query: {&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]})&#xA;&#xA;expect(WebMock).to have_requested(:get, &#34;www.example.com&#34;).&#xA;  with(query: hash_including({&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]}))&#xA;&#xA;expect(WebMock).to have_requested(:get, &#34;www.example.com&#34;).&#xA;  with(body: {&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]},&#xA;    headers: {&#39;Content-Type&#39; =&amp;gt; &#39;application/json&#39;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setting expectations in RSpec with &lt;code&gt;a_request&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect(a_request(:post, &#34;www.example.com&#34;).&#xA;  with(body: &#34;abc&#34;, headers: {&#39;Content-Length&#39; =&amp;gt; 3})).&#xA;  to have_been_made.once&#xA;&#xA;expect(a_request(:post, &#34;www.something.com&#34;)).to have_been_made.times(3)&#xA;&#xA;expect(a_request(:post, &#34;www.something.com&#34;)).to have_been_made.at_least_once&#xA;&#xA;expect(a_request(:post, &#34;www.something.com&#34;)).&#xA;  to have_been_made.at_least_times(3)&#xA;&#xA;expect(a_request(:post, &#34;www.something.com&#34;)).to have_been_made.at_most_twice&#xA;&#xA;expect(a_request(:post, &#34;www.something.com&#34;)).to have_been_made.at_most_times(3)&#xA;&#xA;expect(a_request(:any, &#34;www.example.com&#34;)).not_to have_been_made&#xA;&#xA;expect(a_request(:post, &#34;www.example.com&#34;).with { |req| req.body == &#34;abc&#34; }).&#xA;  to have_been_made&#xA;&#xA;expect(a_request(:get, &#34;www.example.com&#34;).with(query: {&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]})).&#xA;  to have_been_made&#xA;&#xA;expect(a_request(:get, &#34;www.example.com&#34;).&#xA;  with(query: hash_including({&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]}))).to have_been_made&#xA;&#xA;expect(a_request(:post, &#34;www.example.com&#34;).&#xA;  with(body: {&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]},&#xA;    headers: {&#39;Content-Type&#39; =&amp;gt; &#39;application/json&#39;})).to have_been_made&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setting expectations in RSpec on the stub&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub = stub_request(:get, &#34;www.example.com&#34;)&#xA;# ... make requests ...&#xA;expect(stub).to have_been_requested&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Clearing stubs and request history&lt;/h2&gt; &#xA;&lt;p&gt;If you want to reset all current stubs and history of requests use &lt;code&gt;WebMock.reset!&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#34;www.example.com&#34;)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; Success&#xA;&#xA;WebMock.reset!&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; Failure&#xA;&#xA;assert_not_requested :get, &#34;www.example.com&#34;    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Clearing request counters&lt;/h2&gt; &#xA;&lt;p&gt;If you want to reset &lt;strong&gt;only&lt;/strong&gt; the counters of the executed requests use &lt;code&gt;WebMock.reset_executed_requests!&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub  = stub_request(:get, &#34;www.example.com&#34;)&#xA;stub2 = stub_request(:get, &#34;www.example2.com&#34;)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)&#xA;&#xA;Net::HTTP.get(&#39;www.example2.com&#39;, &#39;/&#39;)&#xA;&#xA;expect(stub).to have_been_requested.times(2)&#xA;expect(stub2).to have_been_requested.times(1)&#xA;&#xA;WebMock.reset_executed_requests!&#xA;&#xA;expect(stub).not_to have_been_requested&#xA;expect(stub2).not_to have_been_requested&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Disabling and enabling WebMock or only some http client adapters&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Disable WebMock (all adapters)&#xA;WebMock.disable!&#xA;&#xA;# Disable WebMock for all libs except Net::HTTP&#xA;WebMock.disable!(except: [:net_http])&#xA;&#xA;# Enable WebMock (all adapters)&#xA;WebMock.enable!&#xA;&#xA;# Enable WebMock for all libs except Patron&#xA;WebMock.enable!(except: [:patron])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Matching requests&lt;/h2&gt; &#xA;&lt;p&gt;An executed request matches stubbed request if it passes following criteria:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When request URI matches stubbed request URI string, Regexp pattern or RFC 6570 URI Template&lt;/li&gt; &#xA; &lt;li&gt;And request method is the same as stubbed request method or stubbed request method is :any&lt;/li&gt; &#xA; &lt;li&gt;And request body is the same as stubbed request body or stubbed request body is not specified&lt;/li&gt; &#xA; &lt;li&gt;And request headers match stubbed request headers, or stubbed request headers match a subset of request headers, or stubbed request headers are not specified&lt;/li&gt; &#xA; &lt;li&gt;And request matches provided block or block is not provided&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Precedence of stubs&lt;/h2&gt; &#xA;&lt;p&gt;Always the last declared stub matching the request will be applied i.e:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).to_return(body: &#34;abc&#34;)&#xA;stub_request(:get, &#34;www.example.com&#34;).to_return(body: &#34;def&#34;)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ====&amp;gt; &#34;def&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Matching URIs&lt;/h2&gt; &#xA;&lt;p&gt;WebMock will match all different representations of the same URI.&lt;/p&gt; &#xA;&lt;p&gt;I.e all the following representations of the URI are equal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#34;www.example.com&#34;&#xA;&#34;www.example.com/&#34;&#xA;&#34;www.example.com:80&#34;&#xA;&#34;www.example.com:80/&#34;&#xA;&#34;http://www.example.com&#34;&#xA;&#34;http://www.example.com/&#34;&#xA;&#34;http://www.example.com:80&#34;&#xA;&#34;http://www.example.com:80/&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following URIs with userinfo are also equal for WebMock&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#34;a b:pass@www.example.com&#34;&#xA;&#34;a b:pass@www.example.com/&#34;&#xA;&#34;a b:pass@www.example.com:80&#34;&#xA;&#34;a b:pass@www.example.com:80/&#34;&#xA;&#34;http://a b:pass@www.example.com&#34;&#xA;&#34;http://a b:pass@www.example.com/&#34;&#xA;&#34;http://a b:pass@www.example.com:80&#34;&#xA;&#34;http://a b:pass@www.example.com:80/&#34;&#xA;&#34;a%20b:pass@www.example.com&#34;&#xA;&#34;a%20b:pass@www.example.com/&#34;&#xA;&#34;a%20b:pass@www.example.com:80&#34;&#xA;&#34;a%20b:pass@www.example.com:80/&#34;&#xA;&#34;http://a%20b:pass@www.example.com&#34;&#xA;&#34;http://a%20b:pass@www.example.com/&#34;&#xA;&#34;http://a%20b:pass@www.example.com:80&#34;&#xA;&#34;http://a%20b:pass@www.example.com:80/&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or these&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#34;www.example.com/my path/?a=my param&amp;amp;b=c&#34;&#xA;&#34;www.example.com/my%20path/?a=my%20param&amp;amp;b=c&#34;&#xA;&#34;www.example.com:80/my path/?a=my param&amp;amp;b=c&#34;&#xA;&#34;www.example.com:80/my%20path/?a=my%20param&amp;amp;b=c&#34;&#xA;&#34;http://www.example.com/my path/?a=my param&amp;amp;b=c&#34;&#xA;&#34;http://www.example.com/my%20path/?a=my%20param&amp;amp;b=c&#34;&#xA;&#34;http://www.example.com:80/my path/?a=my param&amp;amp;b=c&#34;&#xA;&#34;http://www.example.com:80/my%20path/?a=my%20param&amp;amp;b=c&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you provide Regexp to match URI, WebMock will try to match it against every valid form of the same url.&lt;/p&gt; &#xA;&lt;p&gt;I.e &lt;code&gt;/my path/&lt;/code&gt; will match &lt;code&gt;www.example.com/my%20path&lt;/code&gt; because it is equivalent of &lt;code&gt;www.example.com/my path&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Matching with URI Templates&lt;/h2&gt; &#xA;&lt;p&gt;If you use &lt;a href=&#34;https://github.com/sporkmonger/addressable#uri-templates&#34;&gt;Addressable::Template&lt;/a&gt; for matching, then WebMock will defer the matching rules to Addressable, which complies with &lt;a href=&#34;http://tools.ietf.org/html/rfc6570&#34;&gt;RFC 6570&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you use any of the WebMock methods for matching query params, then Addressable will be used to match the base URI and WebMock will match the query params. If you do not, then WebMock will let Addressable match the full URI.&lt;/p&gt; &#xA;&lt;h2&gt;Matching headers&lt;/h2&gt; &#xA;&lt;p&gt;WebMock will match request headers against stubbed request headers in the following situations:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Stubbed request has headers specified and request headers are the same as stubbed headers &lt;br&gt; i.e stubbed headers: &lt;code&gt;{ &#39;Header1&#39; =&amp;gt; &#39;Value1&#39;, &#39;Header2&#39; =&amp;gt; &#39;Value2&#39; }&lt;/code&gt;, requested: &lt;code&gt;{ &#39;Header1&#39; =&amp;gt; &#39;Value1&#39;, &#39;Header2&#39; =&amp;gt; &#39;Value2&#39; }&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Stubbed request has headers specified and stubbed request headers are a subset of request headers &lt;br&gt; i.e stubbed headers: &lt;code&gt;{ &#39;Header1&#39; =&amp;gt; &#39;Value1&#39; }&lt;/code&gt;, requested: &lt;code&gt;{ &#39;Header1&#39; =&amp;gt; &#39;Value1&#39;, &#39;Header2&#39; =&amp;gt; &#39;Value2&#39; }&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Stubbed request has no headers &lt;br&gt; i.e stubbed headers: &lt;code&gt;nil&lt;/code&gt;, requested: &lt;code&gt;{ &#39;Header1&#39; =&amp;gt; &#39;Value1&#39;, &#39;Header2&#39; =&amp;gt; &#39;Value2&#39; }&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;WebMock normalises headers and treats all forms of same headers as equal: i.e the following two sets of headers are equal:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;{ &#34;Header1&#34; =&amp;gt; &#34;value1&#34;, content_length: 123, X_CuStOm_hEAder: :value }&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;{ header1: &#34;value1&#34;, &#34;Content-Length&#34; =&amp;gt; 123, &#34;x-cuSTOM-HeAder&#34; =&amp;gt; &#34;value&#34; }&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Recording real requests and responses and replaying them later&lt;/h2&gt; &#xA;&lt;p&gt;To record your application&#39;s real HTTP interactions and replay them later in tests you can use &lt;a href=&#34;https://github.com/vcr/vcr&#34;&gt;VCR&lt;/a&gt; with WebMock.&lt;/p&gt; &#xA;&lt;h2&gt;Request callbacks&lt;/h2&gt; &#xA;&lt;h4&gt;WebMock can invoke callbacks stubbed or real requests:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.after_request do |request_signature, response|&#xA;  puts &#34;Request #{request_signature} was made and #{response} was returned&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;invoke callbacks for real requests only and except requests made with Patron&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.after_request(except: [:patron],&#xA;                      real_requests_only: true) do |req_signature, response|&#xA;  puts &#34;Request #{req_signature} was made and #{response} was returned&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Bugs and Issues&lt;/h2&gt; &#xA;&lt;p&gt;Please submit them here &lt;a href=&#34;http://github.com/bblimke/webmock/issues&#34;&gt;http://github.com/bblimke/webmock/issues&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Issue triage &lt;a href=&#34;https://www.codetriage.com/bblimke/webmock&#34;&gt;&lt;img src=&#34;https://www.codetriage.com/bblimke/webmock/badges/users.svg?sanitize=true&#34; alt=&#34;Open Source Helpers&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;You can contribute by triaging issues which may include reproducing bug reports or asking for vital information, such as version numbers or reproduction instructions. If you would like to start triaging issues, one easy way to get started is to &lt;a href=&#34;https://www.codetriage.com/bblimke/webmock&#34;&gt;subscribe to webmock on CodeTriage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Suggestions&lt;/h2&gt; &#xA;&lt;p&gt;If you have any suggestions on how to improve WebMock please send an email to the mailing list &lt;a href=&#34;http://groups.google.com/group/webmock-users&#34;&gt;groups.google.com/group/webmock-users&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m particularly interested in how the DSL could be improved.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;In order to work on Webmock you first need to fork and clone the repo. Please do any work on a dedicated branch and rebase against master before sending a pull request.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;The initial lines of this project were written during New Bamboo &lt;a href=&#34;http://blog.new-bamboo.co.uk/2009/11/13/hackday-results&#34;&gt;Hack Day&lt;/a&gt; Thanks to my fellow &lt;a href=&#34;http://new-bamboo.co.uk/&#34;&gt;Bambinos&lt;/a&gt; for all the great suggestions!&lt;/p&gt; &#xA;&lt;p&gt;People who submitted patches and new features or suggested improvements. Many thanks to these people:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ben Pickles&lt;/li&gt; &#xA; &lt;li&gt;Mark Evans&lt;/li&gt; &#xA; &lt;li&gt;Ivan Vega&lt;/li&gt; &#xA; &lt;li&gt;Piotr Usewicz&lt;/li&gt; &#xA; &lt;li&gt;Nick Plante&lt;/li&gt; &#xA; &lt;li&gt;Nick Quaranto&lt;/li&gt; &#xA; &lt;li&gt;Diego E. &#34;Flameeyes&#34; Pettenò&lt;/li&gt; &#xA; &lt;li&gt;Niels Meersschaert&lt;/li&gt; &#xA; &lt;li&gt;Mack Earnhardt&lt;/li&gt; &#xA; &lt;li&gt;Arvicco&lt;/li&gt; &#xA; &lt;li&gt;Sergio Gil&lt;/li&gt; &#xA; &lt;li&gt;Jeffrey Jones&lt;/li&gt; &#xA; &lt;li&gt;Tekin Suleyman&lt;/li&gt; &#xA; &lt;li&gt;Tom Ward&lt;/li&gt; &#xA; &lt;li&gt;Nadim Bitar&lt;/li&gt; &#xA; &lt;li&gt;Myron Marston&lt;/li&gt; &#xA; &lt;li&gt;Sam Phillips&lt;/li&gt; &#xA; &lt;li&gt;Jose Angel Cortinas&lt;/li&gt; &#xA; &lt;li&gt;Razic&lt;/li&gt; &#xA; &lt;li&gt;Steve Tooke&lt;/li&gt; &#xA; &lt;li&gt;Nathaniel Bibler&lt;/li&gt; &#xA; &lt;li&gt;Martyn Loughran&lt;/li&gt; &#xA; &lt;li&gt;Muness Alrubaie&lt;/li&gt; &#xA; &lt;li&gt;Charles Li&lt;/li&gt; &#xA; &lt;li&gt;Ryan Bigg&lt;/li&gt; &#xA; &lt;li&gt;Pete Higgins&lt;/li&gt; &#xA; &lt;li&gt;Hans de Graaff&lt;/li&gt; &#xA; &lt;li&gt;Alastair Brunton&lt;/li&gt; &#xA; &lt;li&gt;Sam Stokes&lt;/li&gt; &#xA; &lt;li&gt;Eugene Bolshakov&lt;/li&gt; &#xA; &lt;li&gt;James Conroy-Finn&lt;/li&gt; &#xA; &lt;li&gt;Salvador Fuentes Jr&lt;/li&gt; &#xA; &lt;li&gt;Alex Rothenberg&lt;/li&gt; &#xA; &lt;li&gt;Aidan Feldman&lt;/li&gt; &#xA; &lt;li&gt;Steve Hull&lt;/li&gt; &#xA; &lt;li&gt;Jay Adkisson&lt;/li&gt; &#xA; &lt;li&gt;Zach Dennis&lt;/li&gt; &#xA; &lt;li&gt;Nikita Fedyashev&lt;/li&gt; &#xA; &lt;li&gt;Lin Jen-Shin&lt;/li&gt; &#xA; &lt;li&gt;David Yeu&lt;/li&gt; &#xA; &lt;li&gt;Andreas Garnæs&lt;/li&gt; &#xA; &lt;li&gt;Roman Shterenzon&lt;/li&gt; &#xA; &lt;li&gt;Chris McGrath&lt;/li&gt; &#xA; &lt;li&gt;Stephen Celis&lt;/li&gt; &#xA; &lt;li&gt;Eugene Pimenov&lt;/li&gt; &#xA; &lt;li&gt;Albert Llop&lt;/li&gt; &#xA; &lt;li&gt;Christopher Pickslay&lt;/li&gt; &#xA; &lt;li&gt;Tammer Saleh&lt;/li&gt; &#xA; &lt;li&gt;Nicolas Fouché&lt;/li&gt; &#xA; &lt;li&gt;Joe Van Dyk&lt;/li&gt; &#xA; &lt;li&gt;Mark Abramov&lt;/li&gt; &#xA; &lt;li&gt;Frank Schumacher&lt;/li&gt; &#xA; &lt;li&gt;Dimitrij Denissenko&lt;/li&gt; &#xA; &lt;li&gt;Marnen Laibow-Koser&lt;/li&gt; &#xA; &lt;li&gt;Evgeniy Dolzhenko&lt;/li&gt; &#xA; &lt;li&gt;Nick Recobra&lt;/li&gt; &#xA; &lt;li&gt;Jordan Elver&lt;/li&gt; &#xA; &lt;li&gt;Joe Karayusuf&lt;/li&gt; &#xA; &lt;li&gt;Paul Cortens&lt;/li&gt; &#xA; &lt;li&gt;jugyo&lt;/li&gt; &#xA; &lt;li&gt;aindustries&lt;/li&gt; &#xA; &lt;li&gt;Eric Oestrich&lt;/li&gt; &#xA; &lt;li&gt;erwanlr&lt;/li&gt; &#xA; &lt;li&gt;Ben Bleything&lt;/li&gt; &#xA; &lt;li&gt;Jon Leighton&lt;/li&gt; &#xA; &lt;li&gt;Ryan Schlesinger&lt;/li&gt; &#xA; &lt;li&gt;Julien Boyer&lt;/li&gt; &#xA; &lt;li&gt;Kevin Glowacz&lt;/li&gt; &#xA; &lt;li&gt;Hans Hasselberg&lt;/li&gt; &#xA; &lt;li&gt;Andrew France&lt;/li&gt; &#xA; &lt;li&gt;Jonathan Hyman&lt;/li&gt; &#xA; &lt;li&gt;Rex Feng&lt;/li&gt; &#xA; &lt;li&gt;Pavel Forkert&lt;/li&gt; &#xA; &lt;li&gt;Jordi Massaguer Pla&lt;/li&gt; &#xA; &lt;li&gt;Jake Benilov&lt;/li&gt; &#xA; &lt;li&gt;Tom Beauvais&lt;/li&gt; &#xA; &lt;li&gt;Mokevnin Kirill&lt;/li&gt; &#xA; &lt;li&gt;Alex Grant&lt;/li&gt; &#xA; &lt;li&gt;Lucas Dohmen&lt;/li&gt; &#xA; &lt;li&gt;Bastien Vaucher&lt;/li&gt; &#xA; &lt;li&gt;Joost Baaij&lt;/li&gt; &#xA; &lt;li&gt;Joel Chippindale&lt;/li&gt; &#xA; &lt;li&gt;Murahashi Sanemat Kenichi&lt;/li&gt; &#xA; &lt;li&gt;Tim Kurvers&lt;/li&gt; &#xA; &lt;li&gt;Ilya Vassilevsky&lt;/li&gt; &#xA; &lt;li&gt;gotwalt&lt;/li&gt; &#xA; &lt;li&gt;Leif Bladt&lt;/li&gt; &#xA; &lt;li&gt;Alex Tomlins&lt;/li&gt; &#xA; &lt;li&gt;Mitsutaka Mimura&lt;/li&gt; &#xA; &lt;li&gt;Tomy Kaira&lt;/li&gt; &#xA; &lt;li&gt;Daniel van Hoesel&lt;/li&gt; &#xA; &lt;li&gt;Ian Asaff&lt;/li&gt; &#xA; &lt;li&gt;Ian Lesperance&lt;/li&gt; &#xA; &lt;li&gt;Matthew Horan&lt;/li&gt; &#xA; &lt;li&gt;Dmitry Gutov&lt;/li&gt; &#xA; &lt;li&gt;Florian Dütsch&lt;/li&gt; &#xA; &lt;li&gt;Manuel Meurer&lt;/li&gt; &#xA; &lt;li&gt;Brian D. Burns&lt;/li&gt; &#xA; &lt;li&gt;Riley Strong&lt;/li&gt; &#xA; &lt;li&gt;Tamir Duberstein&lt;/li&gt; &#xA; &lt;li&gt;Stefano Uliari&lt;/li&gt; &#xA; &lt;li&gt;Alex Stupakov&lt;/li&gt; &#xA; &lt;li&gt;Karen Wang&lt;/li&gt; &#xA; &lt;li&gt;Matt Burke&lt;/li&gt; &#xA; &lt;li&gt;Jon Rowe&lt;/li&gt; &#xA; &lt;li&gt;Aleksey V. Zapparov&lt;/li&gt; &#xA; &lt;li&gt;Praveen Arimbrathodiyil&lt;/li&gt; &#xA; &lt;li&gt;Bo Jeanes&lt;/li&gt; &#xA; &lt;li&gt;Matthew Conway&lt;/li&gt; &#xA; &lt;li&gt;Rob Olson&lt;/li&gt; &#xA; &lt;li&gt;Max Lincoln&lt;/li&gt; &#xA; &lt;li&gt;Oleg Gritsenko&lt;/li&gt; &#xA; &lt;li&gt;Hwan-Joon Choi&lt;/li&gt; &#xA; &lt;li&gt;SHIBATA Hiroshi&lt;/li&gt; &#xA; &lt;li&gt;Caleb Thompson&lt;/li&gt; &#xA; &lt;li&gt;Theo Hultberg&lt;/li&gt; &#xA; &lt;li&gt;Pablo Jairala&lt;/li&gt; &#xA; &lt;li&gt;Insoo Buzz Jung&lt;/li&gt; &#xA; &lt;li&gt;Carlos Alonso Pérez&lt;/li&gt; &#xA; &lt;li&gt;trlorenz&lt;/li&gt; &#xA; &lt;li&gt;Alexander Simonov&lt;/li&gt; &#xA; &lt;li&gt;Thorbjørn Hermanse&lt;/li&gt; &#xA; &lt;li&gt;Mark Lorenz&lt;/li&gt; &#xA; &lt;li&gt;tjsousa&lt;/li&gt; &#xA; &lt;li&gt;Tasos Stathopoulos&lt;/li&gt; &#xA; &lt;li&gt;Dan Buettner&lt;/li&gt; &#xA; &lt;li&gt;Sven Riedel&lt;/li&gt; &#xA; &lt;li&gt;Mark Lorenz&lt;/li&gt; &#xA; &lt;li&gt;Dávid Kovács&lt;/li&gt; &#xA; &lt;li&gt;fishermand46&lt;/li&gt; &#xA; &lt;li&gt;Franky Wahl&lt;/li&gt; &#xA; &lt;li&gt;ChaYoung You&lt;/li&gt; &#xA; &lt;li&gt;Simon Russell&lt;/li&gt; &#xA; &lt;li&gt;Steve Mitchell&lt;/li&gt; &#xA; &lt;li&gt;Mattias Putman&lt;/li&gt; &#xA; &lt;li&gt;Zachary Anker&lt;/li&gt; &#xA; &lt;li&gt;Emmanuel Sambo&lt;/li&gt; &#xA; &lt;li&gt;Ramon Tayag&lt;/li&gt; &#xA; &lt;li&gt;Johannes Schlumberger&lt;/li&gt; &#xA; &lt;li&gt;Siôn Le Roux&lt;/li&gt; &#xA; &lt;li&gt;Matt Palmer&lt;/li&gt; &#xA; &lt;li&gt;Zhao Wen&lt;/li&gt; &#xA; &lt;li&gt;Krzysztof Rygielski&lt;/li&gt; &#xA; &lt;li&gt;Magne Land&lt;/li&gt; &#xA; &lt;li&gt;yurivm&lt;/li&gt; &#xA; &lt;li&gt;Mike Knepper&lt;/li&gt; &#xA; &lt;li&gt;Charles Pence&lt;/li&gt; &#xA; &lt;li&gt;Alexey Zapparov&lt;/li&gt; &#xA; &lt;li&gt;Pablo Brasero&lt;/li&gt; &#xA; &lt;li&gt;Cedric Pimenta&lt;/li&gt; &#xA; &lt;li&gt;Michiel Karnebeek&lt;/li&gt; &#xA; &lt;li&gt;Alex Kestner&lt;/li&gt; &#xA; &lt;li&gt;Manfred Stienstra&lt;/li&gt; &#xA; &lt;li&gt;Tim Diggins&lt;/li&gt; &#xA; &lt;li&gt;Gabriel Chaney&lt;/li&gt; &#xA; &lt;li&gt;Chris Griego&lt;/li&gt; &#xA; &lt;li&gt;Taiki Ono&lt;/li&gt; &#xA; &lt;li&gt;Jonathan Schatz&lt;/li&gt; &#xA; &lt;li&gt;Jose Luis Honorato&lt;/li&gt; &#xA; &lt;li&gt;Aaron Kromer&lt;/li&gt; &#xA; &lt;li&gt;Pavel Jurašek&lt;/li&gt; &#xA; &lt;li&gt;Jake Worth&lt;/li&gt; &#xA; &lt;li&gt;Gabe Martin-Dempesy&lt;/li&gt; &#xA; &lt;li&gt;Michael Grosser&lt;/li&gt; &#xA; &lt;li&gt;Aleksei Maridashvili&lt;/li&gt; &#xA; &lt;li&gt;Ville Lautanala&lt;/li&gt; &#xA; &lt;li&gt;Koichi ITO&lt;/li&gt; &#xA; &lt;li&gt;Jordan Harband&lt;/li&gt; &#xA; &lt;li&gt;Tarmo Tänav&lt;/li&gt; &#xA; &lt;li&gt;Joe Marty&lt;/li&gt; &#xA; &lt;li&gt;Chris Thomson&lt;/li&gt; &#xA; &lt;li&gt;Vít Ondruch&lt;/li&gt; &#xA; &lt;li&gt;George Ulmer&lt;/li&gt; &#xA; &lt;li&gt;Christof Koenig&lt;/li&gt; &#xA; &lt;li&gt;Chung-Yi Chi&lt;/li&gt; &#xA; &lt;li&gt;Olexandr Hoshylyk&lt;/li&gt; &#xA; &lt;li&gt;Janko Marohnić&lt;/li&gt; &#xA; &lt;li&gt;Pat Allan&lt;/li&gt; &#xA; &lt;li&gt;Rick Song&lt;/li&gt; &#xA; &lt;li&gt;NARUSE, Yui&lt;/li&gt; &#xA; &lt;li&gt;Piotr Boniecki&lt;/li&gt; &#xA; &lt;li&gt;Olia Kremmyda&lt;/li&gt; &#xA; &lt;li&gt;Michał Matyas&lt;/li&gt; &#xA; &lt;li&gt;Matt Brictson&lt;/li&gt; &#xA; &lt;li&gt;Kenny Ortmann&lt;/li&gt; &#xA; &lt;li&gt;redbar0n&lt;/li&gt; &#xA; &lt;li&gt;Lukas Pokorny&lt;/li&gt; &#xA; &lt;li&gt;Arkadiy Tetelman&lt;/li&gt; &#xA; &lt;li&gt;Kazato Sugimoto&lt;/li&gt; &#xA; &lt;li&gt;Olle Jonsson&lt;/li&gt; &#xA; &lt;li&gt;Pavel Rosický&lt;/li&gt; &#xA; &lt;li&gt;Geremia Taglialatela&lt;/li&gt; &#xA; &lt;li&gt;Koichi Sasada&lt;/li&gt; &#xA; &lt;li&gt;Yusuke Endoh&lt;/li&gt; &#xA; &lt;li&gt;Grey Baker&lt;/li&gt; &#xA; &lt;li&gt;SoonKhen OwYong&lt;/li&gt; &#xA; &lt;li&gt;Pavel Valena&lt;/li&gt; &#xA; &lt;li&gt;Adam Sokolnicki&lt;/li&gt; &#xA; &lt;li&gt;Jeff Felchner&lt;/li&gt; &#xA; &lt;li&gt;Eike Send&lt;/li&gt; &#xA; &lt;li&gt;Claudio Poli&lt;/li&gt; &#xA; &lt;li&gt;Csaba Apagyi&lt;/li&gt; &#xA; &lt;li&gt;Frederick Cheung&lt;/li&gt; &#xA; &lt;li&gt;Fábio D. Batista&lt;/li&gt; &#xA; &lt;li&gt;Andriy Yanko&lt;/li&gt; &#xA; &lt;li&gt;y-yagi&lt;/li&gt; &#xA; &lt;li&gt;Rafael França&lt;/li&gt; &#xA; &lt;li&gt;George Claghorn&lt;/li&gt; &#xA; &lt;li&gt;Alex Junger&lt;/li&gt; &#xA; &lt;li&gt;Orien Madgwick&lt;/li&gt; &#xA; &lt;li&gt;Andrei Sidorov&lt;/li&gt; &#xA; &lt;li&gt;Marco Costa&lt;/li&gt; &#xA; &lt;li&gt;Ryan Davis&lt;/li&gt; &#xA; &lt;li&gt;Brandur&lt;/li&gt; &#xA; &lt;li&gt;Samuel Williams&lt;/li&gt; &#xA; &lt;li&gt;Patrik Ragnarsson&lt;/li&gt; &#xA; &lt;li&gt;Alex Coomans&lt;/li&gt; &#xA; &lt;li&gt;Vesa Laakso&lt;/li&gt; &#xA; &lt;li&gt;John Hawthorn&lt;/li&gt; &#xA; &lt;li&gt;guppy0356&lt;/li&gt; &#xA; &lt;li&gt;Thilo Rusche&lt;/li&gt; &#xA; &lt;li&gt;Andrew Stuntz&lt;/li&gt; &#xA; &lt;li&gt;Lucas Uyezu&lt;/li&gt; &#xA; &lt;li&gt;Bruno Sutic&lt;/li&gt; &#xA; &lt;li&gt;Ryan Kerr&lt;/li&gt; &#xA; &lt;li&gt;Adam Harwood&lt;/li&gt; &#xA; &lt;li&gt;Ben Koshy&lt;/li&gt; &#xA; &lt;li&gt;Jesse Bowes&lt;/li&gt; &#xA; &lt;li&gt;Marek Kasztelnik&lt;/li&gt; &#xA; &lt;li&gt;ce07c3&lt;/li&gt; &#xA; &lt;li&gt;Jun Jiang&lt;/li&gt; &#xA; &lt;li&gt;Oleksiy Kovyrin&lt;/li&gt; &#xA; &lt;li&gt;Matt Larraz&lt;/li&gt; &#xA; &lt;li&gt;Tony Schneider&lt;/li&gt; &#xA; &lt;li&gt;Niklas Hösl&lt;/li&gt; &#xA; &lt;li&gt;Johanna Hartmann&lt;/li&gt; &#xA; &lt;li&gt;Alex Vondrak&lt;/li&gt; &#xA; &lt;li&gt;Will Storey&lt;/li&gt; &#xA; &lt;li&gt;Eduardo Hernandez&lt;/li&gt; &#xA; &lt;li&gt;ojab&lt;/li&gt; &#xA; &lt;li&gt;Giorgio Gambino&lt;/li&gt; &#xA; &lt;li&gt;Timmitry&lt;/li&gt; &#xA; &lt;li&gt;Michael Fairley&lt;/li&gt; &#xA; &lt;li&gt;Ray Zane&lt;/li&gt; &#xA; &lt;li&gt;Go Sueyoshi&lt;/li&gt; &#xA; &lt;li&gt;Cedric Sohrauer&lt;/li&gt; &#xA; &lt;li&gt;Akira Matsuda&lt;/li&gt; &#xA; &lt;li&gt;Mark Spangler&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For a full list of contributors you can visit the &lt;a href=&#34;https://github.com/bblimke/webmock/contributors&#34;&gt;contributors&lt;/a&gt; page.&lt;/p&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;Thank you Fakeweb! This library was inspired by &lt;a href=&#34;http://fakeweb.rubyforge.org&#34;&gt;FakeWeb&lt;/a&gt;. I imported some solutions from that project to WebMock. I also copied some code i.e Net:HTTP adapter. Fakeweb architecture unfortunately didn&#39;t allow me to extend it easily with the features I needed. I also preferred some things to work differently i.e request stub precedence.&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2009-2010 Bartosz Blimke. See LICENSE for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>instructure/canvas-lms</title>
    <updated>2022-08-14T02:02:40Z</updated>
    <id>tag:github.com,2022-08-14:/instructure/canvas-lms</id>
    <link href="https://github.com/instructure/canvas-lms" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The open LMS by Instructure, Inc.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Canvas LMS&lt;/h1&gt; &#xA;&lt;p&gt;Canvas is a modern, open-source &lt;a href=&#34;https://en.wikipedia.org/wiki/Learning_management_system&#34;&gt;LMS&lt;/a&gt; developed and maintained by &lt;a href=&#34;https://www.instructure.com/&#34;&gt;Instructure Inc.&lt;/a&gt; It is released under the AGPLv3 license for use by anyone interested in learning more about or using learning management systems.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://github.com/instructure/canvas-lms/wiki&#34;&gt;Please see our main wiki page for more information&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;Detailed instructions for installation and configuration of Canvas are provided on our wiki.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/instructure/canvas-lms/wiki/Quick-Start&#34;&gt;Quick Start&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/instructure/canvas-lms/wiki/Production-Start&#34;&gt;Production Start&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>varvet/pundit</title>
    <updated>2022-08-14T02:02:40Z</updated>
    <id>tag:github.com,2022-08-14:/varvet/pundit</id>
    <link href="https://github.com/varvet/pundit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Minimal authorization through OO design and pure Ruby classes&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Pundit&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/varvet/pundit&#34;&gt;&lt;img src=&#34;https://secure.travis-ci.org/varvet/pundit.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/varvet/pundit&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/varvet/pundit.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://inch-ci.org/github/varvet/pundit&#34;&gt;&lt;img src=&#34;http://inch-ci.org/github/varvet/pundit.svg?branch=master&#34; alt=&#34;Inline docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://badge.fury.io/rb/pundit&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/pundit.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Pundit provides a set of helpers which guide you in leveraging regular Ruby classes and object oriented design patterns to build a simple, robust and scalable authorization system.&lt;/p&gt; &#xA;&lt;p&gt;Links:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.rubydoc.info/gems/pundit&#34;&gt;API documentation for the most recent version&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit&#34;&gt;Source Code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit/raw/master/CONTRIBUTING.md&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit/raw/master/CODE_OF_CONDUCT.md&#34;&gt;Code of Conduct&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Sponsored by:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.varvet.com&#34;&gt;&lt;img src=&#34;https://www.varvet.com/images/wordmark-red.svg?sanitize=true&#34; alt=&#34;Varvet&#34; height=&#34;50px&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Please note&lt;/strong&gt; that the README on GitHub is accurate with the &lt;em&gt;latest code on GitHub&lt;/em&gt;. You are most likely using a released version of Pundit, so please refer to the &lt;a href=&#34;https://www.rubydoc.info/gems/pundit&#34;&gt;documentation for the latest released version of Pundit&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;bundle add pundit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Include &lt;code&gt;Pundit::Authorization&lt;/code&gt; in your application controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include Pundit::Authorization&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Optionally, you can run the generator, which will set up an application policy with some useful defaults for you:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rails g pundit:install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After generating your application policy, restart the Rails server so that Rails can pick up any classes in the new &lt;code&gt;app/policies/&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Policies&lt;/h2&gt; &#xA;&lt;p&gt;Pundit is focused around the notion of policy classes. We suggest that you put these classes in &lt;code&gt;app/policies&lt;/code&gt;. This is a simple example that allows updating a post if the user is an admin, or if the post is unpublished:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy&#xA;  attr_reader :user, :post&#xA;&#xA;  def initialize(user, post)&#xA;    @user = user&#xA;    @post = post&#xA;  end&#xA;&#xA;  def update?&#xA;    user.admin? || !post.published?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, this is just a plain Ruby class. Pundit makes the following assumptions about this class:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The class has the same name as some kind of model class, only suffixed with the word &#34;Policy&#34;.&lt;/li&gt; &#xA; &lt;li&gt;The first argument is a user. In your controller, Pundit will call the &lt;code&gt;current_user&lt;/code&gt; method to retrieve what to send into this argument&lt;/li&gt; &#xA; &lt;li&gt;The second argument is some kind of model object, whose authorization you want to check. This does not need to be an ActiveRecord or even an ActiveModel object, it can be anything really.&lt;/li&gt; &#xA; &lt;li&gt;The class implements some kind of query method, in this case &lt;code&gt;update?&lt;/code&gt;. Usually, this will map to the name of a particular controller action.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;That&#39;s it really.&lt;/p&gt; &#xA;&lt;p&gt;Usually you&#39;ll want to inherit from the application policy created by the generator, or set up your own base class to inherit from:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  def update?&#xA;    user.admin? or not record.published?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the generated &lt;code&gt;ApplicationPolicy&lt;/code&gt;, the model object is called &lt;code&gt;record&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Supposing that you have an instance of class &lt;code&gt;Post&lt;/code&gt;, Pundit now lets you do this in your controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def update&#xA;  @post = Post.find(params[:id])&#xA;  authorize @post&#xA;  if @post.update(post_params)&#xA;    redirect_to @post&#xA;  else&#xA;    render :edit&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The authorize method automatically infers that &lt;code&gt;Post&lt;/code&gt; will have a matching &lt;code&gt;PostPolicy&lt;/code&gt; class, and instantiates this class, handing in the current user and the given record. It then infers from the action name, that it should call &lt;code&gt;update?&lt;/code&gt; on this instance of the policy. In this case, you can imagine that &lt;code&gt;authorize&lt;/code&gt; would have done something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;unless PostPolicy.new(current_user, @post).update?&#xA;  raise Pundit::NotAuthorizedError, &#34;not allowed to update? this #{@post.inspect}&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can pass a second argument to &lt;code&gt;authorize&lt;/code&gt; if the name of the permission you want to check doesn&#39;t match the action name. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def publish&#xA;  @post = Post.find(params[:id])&#xA;  authorize @post, :update?&#xA;  @post.publish!&#xA;  redirect_to @post&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can pass an argument to override the policy class if necessary. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def create&#xA;  @publication = find_publication # assume this method returns any model that behaves like a publication&#xA;  # @publication.class =&amp;gt; Post&#xA;  authorize @publication, policy_class: PublicationPolicy&#xA;  @publication.publish!&#xA;  redirect_to @publication&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t have an instance for the first argument to &lt;code&gt;authorize&lt;/code&gt;, then you can pass the class. For example:&lt;/p&gt; &#xA;&lt;p&gt;Policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  def admin_list?&#xA;    user.admin?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def admin_list&#xA;  authorize Post # we don&#39;t have a particular post to authorize&#xA;  # Rest of controller action&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;authorize&lt;/code&gt; returns the instance passed to it, so you can chain it like this:&lt;/p&gt; &#xA;&lt;p&gt;Controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def show&#xA;  @user = authorize User.find(params[:id])&#xA;end&#xA;&#xA;# return the record even for namespaced policies&#xA;def show&#xA;  @user = authorize [:admin, User.find(params[:id])]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can easily get a hold of an instance of the policy through the &lt;code&gt;policy&lt;/code&gt; method in both the view and controller. This is especially useful for conditionally showing links or buttons in the view:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;% if policy(@post).update? %&amp;gt;&#xA;  &amp;lt;%= link_to &#34;Edit post&#34;, edit_post_path(@post) %&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Headless policies&lt;/h2&gt; &#xA;&lt;p&gt;Given there is a policy without a corresponding model / ruby class, you can retrieve it by passing a symbol.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/policies/dashboard_policy.rb&#xA;class DashboardPolicy&#xA;  attr_reader :user&#xA;&#xA;  # _record in this example will just be :dashboard&#xA;  def initialize(user, _record)&#xA;    @user = user&#xA;  end&#xA;&#xA;  def show?&#xA;    user.admin?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the headless policy still needs to accept two arguments. The second argument will just be the symbol &lt;code&gt;:dashboard&lt;/code&gt; in this case which is what is passed as the record to &lt;code&gt;authorize&lt;/code&gt; below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# In controllers&#xA;def show&#xA;  authorize :dashboard, :show?&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;# In views&#xA;&amp;lt;% if policy(:dashboard).show? %&amp;gt;&#xA;  &amp;lt;%= link_to &#39;Dashboard&#39;, dashboard_path %&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Scopes&lt;/h2&gt; &#xA;&lt;p&gt;Often, you will want to have some kind of view listing records which a particular user has access to. When using Pundit, you are expected to define a class called a policy scope. It can look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  class Scope&#xA;    def initialize(user, scope)&#xA;      @user  = user&#xA;      @scope = scope&#xA;    end&#xA;&#xA;    def resolve&#xA;      if user.admin?&#xA;        scope.all&#xA;      else&#xA;        scope.where(published: true)&#xA;      end&#xA;    end&#xA;&#xA;    private&#xA;&#xA;    attr_reader :user, :scope&#xA;  end&#xA;&#xA;  def update?&#xA;    user.admin? or not record.published?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pundit makes the following assumptions about this class:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The class has the name &lt;code&gt;Scope&lt;/code&gt; and is nested under the policy class.&lt;/li&gt; &#xA; &lt;li&gt;The first argument is a user. In your controller, Pundit will call the &lt;code&gt;current_user&lt;/code&gt; method to retrieve what to send into this argument.&lt;/li&gt; &#xA; &lt;li&gt;The second argument is a scope of some kind on which to perform some kind of query. It will usually be an ActiveRecord class or a &lt;code&gt;ActiveRecord::Relation&lt;/code&gt;, but it could be something else entirely.&lt;/li&gt; &#xA; &lt;li&gt;Instances of this class respond to the method &lt;code&gt;resolve&lt;/code&gt;, which should return some kind of result which can be iterated over. For ActiveRecord classes, this would usually be an &lt;code&gt;ActiveRecord::Relation&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You&#39;ll probably want to inherit from the application policy scope generated by the generator, or create your own base class to inherit from:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  class Scope &amp;lt; Scope&#xA;    def resolve&#xA;      if user.admin?&#xA;        scope.all&#xA;      else&#xA;        scope.where(published: true)&#xA;      end&#xA;    end&#xA;  end&#xA;&#xA;  def update?&#xA;    user.admin? or not record.published?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now use this class from your controller via the &lt;code&gt;policy_scope&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def index&#xA;  @posts = policy_scope(Post)&#xA;end&#xA;&#xA;def show&#xA;  @post = policy_scope(Post).find(params[:id])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Like with the authorize method, you can also override the policy scope class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def index&#xA;  # publication_class =&amp;gt; Post&#xA;  @publications = policy_scope(publication_class, policy_scope_class: PublicationPolicy::Scope)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case it is a shortcut for doing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def index&#xA;  @publications = PublicationPolicy::Scope.new(current_user, Post).resolve&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can, and are encouraged to, use this method in views:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;% policy_scope(@user.posts).each do |post| %&amp;gt;&#xA;  &amp;lt;p&amp;gt;&amp;lt;%= link_to post.title, post_path(post) %&amp;gt;&amp;lt;/p&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Ensuring policies and scopes are used&lt;/h2&gt; &#xA;&lt;p&gt;When you are developing an application with Pundit it can be easy to forget to authorize some action. People are forgetful after all. Since Pundit encourages you to add the &lt;code&gt;authorize&lt;/code&gt; call manually to each controller action, it&#39;s really easy to miss one.&lt;/p&gt; &#xA;&lt;p&gt;Thankfully, Pundit has a handy feature which reminds you in case you forget. Pundit tracks whether you have called &lt;code&gt;authorize&lt;/code&gt; anywhere in your controller action. Pundit also adds a method to your controllers called &lt;code&gt;verify_authorized&lt;/code&gt;. This method will raise an exception if &lt;code&gt;authorize&lt;/code&gt; has not yet been called. You should run this method in an &lt;code&gt;after_action&lt;/code&gt; hook to ensure that you haven&#39;t forgotten to authorize the action. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include Pundit::Authorization&#xA;  after_action :verify_authorized&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Likewise, Pundit also adds &lt;code&gt;verify_policy_scoped&lt;/code&gt; to your controller. This will raise an exception similar to &lt;code&gt;verify_authorized&lt;/code&gt;. However, it tracks if &lt;code&gt;policy_scope&lt;/code&gt; is used instead of &lt;code&gt;authorize&lt;/code&gt;. This is mostly useful for controller actions like &lt;code&gt;index&lt;/code&gt; which find collections with a scope and don&#39;t authorize individual instances.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include Pundit::Authorization&#xA;  after_action :verify_authorized, except: :index&#xA;  after_action :verify_policy_scoped, only: :index&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;This verification mechanism only exists to aid you while developing your application, so you don&#39;t forget to call &lt;code&gt;authorize&lt;/code&gt;. It is not some kind of failsafe mechanism or authorization mechanism. You should be able to remove these filters without affecting how your app works in any way.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Some people have found this feature confusing, while many others find it extremely helpful. If you fall into the category of people who find it confusing then you do not need to use it. Pundit will work just fine without using &lt;code&gt;verify_authorized&lt;/code&gt; and &lt;code&gt;verify_policy_scoped&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Conditional verification&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re using &lt;code&gt;verify_authorized&lt;/code&gt; in your controllers but need to conditionally bypass verification, you can use &lt;code&gt;skip_authorization&lt;/code&gt;. For bypassing &lt;code&gt;verify_policy_scoped&lt;/code&gt;, use &lt;code&gt;skip_policy_scope&lt;/code&gt;. These are useful in circumstances where you don&#39;t want to disable verification for the entire action, but have some cases where you intend to not authorize.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def show&#xA;  record = Record.find_by(attribute: &#34;value&#34;)&#xA;  if record.present?&#xA;    authorize record&#xA;  else&#xA;    skip_authorization&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Manually specifying policy classes&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes you might want to explicitly declare which policy to use for a given class, instead of letting Pundit infer it. This can be done like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Post&#xA;  def self.policy_class&#xA;    PostablePolicy&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can declare an instance method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Post&#xA;  def policy_class&#xA;    PostablePolicy&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Just plain old Ruby&lt;/h2&gt; &#xA;&lt;p&gt;As you can see, Pundit doesn&#39;t do anything you couldn&#39;t have easily done yourself. It&#39;s a very small library, it just provides a few neat helpers. Together these give you the power of building a well structured, fully working authorization system without using any special DSLs or funky syntax or anything.&lt;/p&gt; &#xA;&lt;p&gt;Remember that all of the policy and scope classes are just plain Ruby classes, which means you can use the same mechanisms you always use to DRY things up. Encapsulate a set of permissions into a module and include them in multiple policies. Use &lt;code&gt;alias_method&lt;/code&gt; to make some permissions behave the same as others. Inherit from a base set of permissions. Use metaprogramming if you really have to.&lt;/p&gt; &#xA;&lt;h2&gt;Generator&lt;/h2&gt; &#xA;&lt;p&gt;Use the supplied generator to generate policies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rails g pundit:policy post&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Closed systems&lt;/h2&gt; &#xA;&lt;p&gt;In many applications, only logged in users are really able to do anything. If you&#39;re building such a system, it can be kind of cumbersome to check that the user in a policy isn&#39;t &lt;code&gt;nil&lt;/code&gt; for every single permission. Aside from policies, you can add this check to the base class for scopes.&lt;/p&gt; &#xA;&lt;p&gt;We suggest that you define a filter that redirects unauthenticated users to the login page. As a secondary defence, if you&#39;ve defined an ApplicationPolicy, it might be a good idea to raise an exception if somehow an unauthenticated user got through. This way you can fail more gracefully.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationPolicy&#xA;  def initialize(user, record)&#xA;    raise Pundit::NotAuthorizedError, &#34;must be logged in&#34; unless user&#xA;    @user   = user&#xA;    @record = record&#xA;  end&#xA;&#xA;  class Scope&#xA;    attr_reader :user, :scope&#xA;&#xA;    def initialize(user, scope)&#xA;      raise Pundit::NotAuthorizedError, &#34;must be logged in&#34; unless user&#xA;      @user = user&#xA;      @scope = scope&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;NilClassPolicy&lt;/h2&gt; &#xA;&lt;p&gt;To support a &lt;a href=&#34;https://en.wikipedia.org/wiki/Null_Object_pattern&#34;&gt;null object pattern&lt;/a&gt; you may find that you want to implement a &lt;code&gt;NilClassPolicy&lt;/code&gt;. This might be useful where you want to extend your ApplicationPolicy to allow some tolerance of, for example, associations which might be &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NilClassPolicy &amp;lt; ApplicationPolicy&#xA;  class Scope &amp;lt; Scope&#xA;    def resolve&#xA;      raise Pundit::NotDefinedError, &#34;Cannot scope NilClass&#34;&#xA;    end&#xA;  end&#xA;&#xA;  def show?&#xA;    false # Nobody can see nothing&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Rescuing a denied Authorization in Rails&lt;/h2&gt; &#xA;&lt;p&gt;Pundit raises a &lt;code&gt;Pundit::NotAuthorizedError&lt;/code&gt; you can &lt;a href=&#34;http://guides.rubyonrails.org/action_controller_overview.html#rescue-from&#34;&gt;rescue_from&lt;/a&gt; in your &lt;code&gt;ApplicationController&lt;/code&gt;. You can customize the &lt;code&gt;user_not_authorized&lt;/code&gt; method in every controller.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include Pundit::Authorization&#xA;&#xA;  rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized&#xA;&#xA;  private&#xA;&#xA;  def user_not_authorized&#xA;    flash[:alert] = &#34;You are not authorized to perform this action.&#34;&#xA;    redirect_back(fallback_location: root_path)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can globally handle Pundit::NotAuthorizedError&#39;s by having rails handle them as a 403 error and serving a 403 error page. Add the following to application.rb:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;config.action_dispatch.rescue_responses[&#34;Pundit::NotAuthorizedError&#34;] = :forbidden&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Creating custom error messages&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;NotAuthorizedError&lt;/code&gt;s provide information on what query (e.g. &lt;code&gt;:create?&lt;/code&gt;), what record (e.g. an instance of &lt;code&gt;Post&lt;/code&gt;), and what policy (e.g. an instance of &lt;code&gt;PostPolicy&lt;/code&gt;) caused the error to be raised.&lt;/p&gt; &#xA;&lt;p&gt;One way to use these &lt;code&gt;query&lt;/code&gt;, &lt;code&gt;record&lt;/code&gt;, and &lt;code&gt;policy&lt;/code&gt; properties is to connect them with &lt;code&gt;I18n&lt;/code&gt; to generate error messages. Here&#39;s how you might go about doing that.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA; rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized&#xA;&#xA; private&#xA;&#xA; def user_not_authorized(exception)&#xA;   policy_name = exception.policy.class.to_s.underscore&#xA;&#xA;   flash[:error] = t &#34;#{policy_name}.#{exception.query}&#34;, scope: &#34;pundit&#34;, default: :default&#xA;   redirect_back(fallback_url: root_path)&#xA; end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;en:&#xA; pundit:&#xA;   default: &#39;You cannot perform this action.&#39;&#xA;   post_policy:&#xA;     update?: &#39;You cannot edit this post!&#39;&#xA;     create?: &#39;You cannot create posts!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course, this is just an example. Pundit is agnostic as to how you implement your error messaging.&lt;/p&gt; &#xA;&lt;h2&gt;Manually retrieving policies and scopes&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes you want to retrieve a policy for a record outside the controller or view. For example when you delegate permissions from one policy to another.&lt;/p&gt; &#xA;&lt;p&gt;You can easily retrieve policies and scopes like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Pundit.policy!(user, post)&#xA;Pundit.policy(user, post)&#xA;&#xA;Pundit.policy_scope!(user, Post)&#xA;Pundit.policy_scope(user, Post)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The bang methods will raise an exception if the policy does not exist, whereas those without the bang will return nil.&lt;/p&gt; &#xA;&lt;h2&gt;Customize Pundit user&lt;/h2&gt; &#xA;&lt;p&gt;In some cases your controller might not have access to &lt;code&gt;current_user&lt;/code&gt;, or your &lt;code&gt;current_user&lt;/code&gt; is not the method that should be invoked by Pundit. Simply define a method in your controller called &lt;code&gt;pundit_user&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def pundit_user&#xA;  User.find_by_other_means&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Policy Namespacing&lt;/h2&gt; &#xA;&lt;p&gt;In some cases it might be helpful to have multiple policies that serve different contexts for a resource. A prime example of this is the case where User policies differ from Admin policies. To authorize with a namespaced policy, pass the namespace into the &lt;code&gt;authorize&lt;/code&gt; helper in an array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;authorize(post)                   # =&amp;gt; will look for a PostPolicy&#xA;authorize([:admin, post])         # =&amp;gt; will look for an Admin::PostPolicy&#xA;authorize([:foo, :bar, post])     # =&amp;gt; will look for a Foo::Bar::PostPolicy&#xA;&#xA;policy_scope(Post)                # =&amp;gt; will look for a PostPolicy::Scope&#xA;policy_scope([:admin, Post])      # =&amp;gt; will look for an Admin::PostPolicy::Scope&#xA;policy_scope([:foo, :bar, Post])  # =&amp;gt; will look for a Foo::Bar::PostPolicy::Scope&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are using namespaced policies for something like Admin views, it can be useful to override the &lt;code&gt;policy_scope&lt;/code&gt; and &lt;code&gt;authorize&lt;/code&gt; helpers in your &lt;code&gt;AdminController&lt;/code&gt; to automatically apply the namespacing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AdminController &amp;lt; ApplicationController&#xA;  def policy_scope(scope)&#xA;    super([:admin, scope])&#xA;  end&#xA;&#xA;  def authorize(record, query = nil)&#xA;    super([:admin, record], query)&#xA;  end&#xA;end&#xA;&#xA;class Admin::PostController &amp;lt; AdminController&#xA;  def index&#xA;    policy_scope(Post)&#xA;  end&#xA;&#xA;  def show&#xA;    post = authorize Post.find(params[:id])&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Additional context&lt;/h2&gt; &#xA;&lt;p&gt;Pundit strongly encourages you to model your application in such a way that the only context you need for authorization is a user object and a domain model that you want to check authorization for. If you find yourself needing more context than that, consider whether you are authorizing the right domain model, maybe another domain model (or a wrapper around multiple domain models) can provide the context you need.&lt;/p&gt; &#xA;&lt;p&gt;Pundit does not allow you to pass additional arguments to policies for precisely this reason.&lt;/p&gt; &#xA;&lt;p&gt;However, in very rare cases, you might need to authorize based on more context than just the currently authenticated user. Suppose for example that authorization is dependent on IP address in addition to the authenticated user. In that case, one option is to create a special class which wraps up both user and IP and passes it to the policy.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UserContext&#xA;  attr_reader :user, :ip&#xA;&#xA;  def initialize(user, ip)&#xA;    @user = user&#xA;    @ip   = ip&#xA;  end&#xA;end&#xA;&#xA;class ApplicationController&#xA;  include Pundit::Authorization&#xA;&#xA;  def pundit_user&#xA;    UserContext.new(current_user, request.ip)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Strong parameters&lt;/h2&gt; &#xA;&lt;p&gt;In Rails, mass-assignment protection is handled in the controller. With Pundit you can control which attributes a user has access to update via your policies. You can set up a &lt;code&gt;permitted_attributes&lt;/code&gt; method in your policy like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/policies/post_policy.rb&#xA;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  def permitted_attributes&#xA;    if user.admin? || user.owner_of?(post)&#xA;      [:title, :body, :tag_list]&#xA;    else&#xA;      [:tag_list]&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now retrieve these attributes from the policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/posts_controller.rb&#xA;class PostsController &amp;lt; ApplicationController&#xA;  def update&#xA;    @post = Post.find(params[:id])&#xA;    if @post.update(post_params)&#xA;      redirect_to @post&#xA;    else&#xA;      render :edit&#xA;    end&#xA;  end&#xA;&#xA;  private&#xA;&#xA;  def post_params&#xA;    params.require(:post).permit(policy(@post).permitted_attributes)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, this is a bit cumbersome, so Pundit provides a convenient helper method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/posts_controller.rb&#xA;class PostsController &amp;lt; ApplicationController&#xA;  def update&#xA;    @post = Post.find(params[:id])&#xA;    if @post.update(permitted_attributes(@post))&#xA;      redirect_to @post&#xA;    else&#xA;      render :edit&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to permit different attributes based on the current action, you can define a &lt;code&gt;permitted_attributes_for_#{action}&lt;/code&gt; method on your policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/policies/post_policy.rb&#xA;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  def permitted_attributes_for_create&#xA;    [:title, :body]&#xA;  end&#xA;&#xA;  def permitted_attributes_for_edit&#xA;    [:body]&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have defined an action-specific method on your policy for the current action, the &lt;code&gt;permitted_attributes&lt;/code&gt; helper will call it instead of calling &lt;code&gt;permitted_attributes&lt;/code&gt; on your controller.&lt;/p&gt; &#xA;&lt;p&gt;If you need to fetch parameters based on namespaces different from the suggested one, override the below method, in your controller, and return an instance of &lt;code&gt;ActionController::Parameters&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def pundit_params_for(record)&#xA;  params.require(PolicyFinder.new(record).param_key)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# If you don&#39;t want to use require&#xA;def pundit_params_for(record)&#xA;  params.fetch(PolicyFinder.new(record).param_key, {})&#xA;end&#xA;&#xA;# If you are using something like the JSON API spec&#xA;def pundit_params_for(_record)&#xA;  params.fetch(:data, {}).fetch(:attributes, {})&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;RSpec&lt;/h2&gt; &#xA;&lt;h3&gt;Policy Specs&lt;/h3&gt; &#xA;&lt;p&gt;Pundit includes a mini-DSL for writing expressive tests for your policies in RSpec. Require &lt;code&gt;pundit/rspec&lt;/code&gt; in your &lt;code&gt;spec_helper.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;pundit/rspec&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then put your policy specs in &lt;code&gt;spec/policies&lt;/code&gt;, and make them look somewhat like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;describe PostPolicy do&#xA;  subject { described_class }&#xA;&#xA;  permissions :update?, :edit? do&#xA;    it &#34;denies access if post is published&#34; do&#xA;      expect(subject).not_to permit(User.new(admin: false), Post.new(published: true))&#xA;    end&#xA;&#xA;    it &#34;grants access if post is published and user is an admin&#34; do&#xA;      expect(subject).to permit(User.new(admin: true), Post.new(published: true))&#xA;    end&#xA;&#xA;    it &#34;grants access if post is unpublished&#34; do&#xA;      expect(subject).to permit(User.new(admin: false), Post.new(published: false))&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An alternative approach to Pundit policy specs is scoping them to a user context as outlined in this &lt;a href=&#34;http://thunderboltlabs.com/blog/2013/03/27/testing-pundit-policies-with-rspec/&#34;&gt;excellent post&lt;/a&gt; and implemented in the third party &lt;a href=&#34;https://github.com/chrisalley/pundit-matchers&#34;&gt;pundit-matchers&lt;/a&gt; gem.&lt;/p&gt; &#xA;&lt;h3&gt;Scope Specs&lt;/h3&gt; &#xA;&lt;p&gt;Pundit does not provide a DSL for testing scopes. Just test it like a regular Ruby class!&lt;/p&gt; &#xA;&lt;h1&gt;External Resources&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/RailsApps/rails-devise-pundit&#34;&gt;RailsApps Example Application: Pundit and Devise&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://blog.carbonfive.com/2013/10/21/migrating-to-pundit-from-cancan/&#34;&gt;Migrating to Pundit from CanCan&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://thunderboltlabs.com/blog/2013/03/27/testing-pundit-policies-with-rspec/&#34;&gt;Testing Pundit Policies with RSpec&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit/issues/204#issuecomment-60166450&#34;&gt;Testing Pundit with Minitest&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit/pull/136&#34;&gt;Using Pundit outside of a Rails controller&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.sitepoint.com/straightforward-rails-authorization-with-pundit/&#34;&gt;Straightforward Rails Authorization with Pundit&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Other implementations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/anurag90x/flask-pundit&#34;&gt;Flask-Pundit&lt;/a&gt; (Python) is a &lt;a href=&#34;http://flask.pocoo.org/&#34;&gt;Flask&lt;/a&gt; extension &#34;heavily inspired by&#34; Pundit&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Licensed under the MIT license, see the separate LICENSE.txt file.&lt;/p&gt;</summary>
  </entry>
</feed>