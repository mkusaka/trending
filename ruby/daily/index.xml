<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-20T01:45:32Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jeremyevans/by</title>
    <updated>2023-02-20T01:45:32Z</updated>
    <id>tag:github.com,2023-02-20:/jeremyevans/by</id>
    <link href="https://github.com/jeremyevans/by" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ruby Library Preloader&lt;/p&gt;&lt;hr&gt;&lt;p&gt;= by&lt;/p&gt; &#xA;&lt;p&gt;by is a library preloader for Ruby designed to speed up process startup. It uses a client/server approach, where the server loads the libraries and listens on a UNIX socket, and the client connects to that socket to run a process. For each client connection, the server forks a worker process, which uses the current directory, stdin, stdout, stderr, and environment of the client process. The worker process then processes the arguments provided by the client. The client process waits until the worker process returns an exit code and closes the socket, and uses exit code 0 (normal exit) if the worker process indicates success, or exit code 1 (error) if the worker process indicates an error.&lt;/p&gt; &#xA;&lt;p&gt;== Installation&lt;/p&gt; &#xA;&lt;p&gt;gem install by&lt;/p&gt; &#xA;&lt;p&gt;== Source Code&lt;/p&gt; &#xA;&lt;p&gt;Source code is available on GitHub at &lt;a href=&#34;https://github.com/jeremyevans/by&#34;&gt;https://github.com/jeremyevans/by&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;== Usage&lt;/p&gt; &#xA;&lt;p&gt;To use +by+, you first start &lt;tt&gt;by-server&lt;/tt&gt;, passing in libraries you would like to preload.&lt;/p&gt; &#xA;&lt;p&gt;$ by-server sequel roda capybara&lt;/p&gt; &#xA;&lt;p&gt;Then you can run ruby with the libraries preloaded using +by+:&lt;/p&gt; &#xA;&lt;p&gt;$ by -e &#39;p [Sequel, Roda, Capybara]&#39; [Sequel, Roda, Capybara]&lt;/p&gt; &#xA;&lt;p&gt;The advantage of using +by+ is that the libraries are already loaded, so Ruby doesn&#39;t have to find the libraries and parse the files in each library on process startup. Here&#39;s a performance comparison:&lt;/p&gt; &#xA;&lt;p&gt;$ /usr/bin/time ruby -e &#39;require &#34;sequel&#34;; require &#34;roda&#34;; require &#34;capybara&#34;&#39; 1.67 real 0.93 user 0.66 sys&lt;/p&gt; &#xA;&lt;p&gt;$ /usr/bin/time by -e &#39;require &#34;sequel&#34;; require &#34;roda&#34;; require &#34;capybara&#34;&#39; 0.37 real 0.20 user 0.15 sys&lt;/p&gt; &#xA;&lt;p&gt;The more libraries your program uses that you can preload in the server program, the greater the speedup this offers.&lt;/p&gt; &#xA;&lt;p&gt;== Speeding Things Up Even More By Avoiding Rubygems&lt;/p&gt; &#xA;&lt;p&gt;Loading Rubygems is by far the slowest thing that Ruby does during process initialization:&lt;/p&gt; &#xA;&lt;p&gt;$ /usr/bin/time ruby -e &#39;&#39; 0.25 real 0.11 user 0.14 sys&lt;/p&gt; &#xA;&lt;p&gt;$ /usr/bin/time ruby --disable-gems -e &#39;&#39; 0.03 real 0.02 user 0.01 sys&lt;/p&gt; &#xA;&lt;p&gt;You can speedup +by+ by making it not require rubygems, since it only needs the +socket+ standard library. The only issue with that is that +by+ is distributed as a gem. There are a few workarounds.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a shell alias. How you create the alias will depend on the shell you are using, but here&#39;s some Ruby code that will output an alias command that will work for most shells:&lt;/p&gt; &lt;p&gt;require &#39;rbconfig&#39; by = Gem.activate_bin_path(&#34;by&#34;, &#34;by&#34;) puts &#34;alias by=&#39;#{RbConfig.ruby} --disable-gems #{by}&#39;&#34;&lt;/p&gt; &lt;p&gt;Note that one issue with using a shell alias is that it only works when loaded and used by the shell, it won&#39;t work if executed by another program.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Copy the +by+ program and modify the shebang line to use the path to your +ruby+ binary and &lt;tt&gt;--disable-gems&lt;/tt&gt;. You can get the path to the +by+ program with the following Ruby code.&lt;/p&gt; &lt;p&gt;puts Gem.activate_bin_path(&#34;by&#34;, &#34;by&#34;)&lt;/p&gt; &lt;p&gt;You would copy that file to somewhere in your &lt;tt&gt;$PATH&lt;/tt&gt; before where the rubygems wrapper is installed, and then modify the shebang.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add your own shell wrapper program that calls +by+. Here&#39;s some example Ruby code that may work, though whether it does depends on your shell.&lt;/p&gt; &lt;p&gt;require &#39;rbconfig&#39; by = Gem.activate_bin_path(&#34;by&#34;, &#34;by&#34;) File.binwrite(&#34;by&#34;, &#34;#!/bin/sh\nexec #{RbConfig.ruby} --disable-gems #{by} &#34;$@&#34;\n&#34;) File.chmod(0755, &#34;by&#34;)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;With each of these approaches, you can get much faster program execution:&lt;/p&gt; &#xA;&lt;p&gt;$ /usr/bin/time ./by -e &#39;require &#34;sequel&#34;; require &#34;roda&#34;; require &#34;capybara&#34;&#39; 0.08 real 0.05 user 0.03 sys&lt;/p&gt; &#xA;&lt;p&gt;As you can see, by avoiding Rubygems, using +by+ to require the three libraries executes three times faster than Ruby itself starts if you are using Rubygems.&lt;/p&gt; &#xA;&lt;p&gt;With each of these approaches, you need to update the alias/wrapper any time you update the +by+ gem when the +by+ program itself has changed. However, the +by+ program itself is quite small and simple and unlikely to change.&lt;/p&gt; &#xA;&lt;p&gt;== Argument Handling&lt;/p&gt; &#xA;&lt;p&gt;&lt;tt&gt;by-server&lt;/tt&gt; treats all arguments provided on the command line as arguments to &lt;tt&gt;Kernel#require&lt;/tt&gt;.&lt;/p&gt; &#xA;&lt;p&gt;+by+ passes all arguments to the worker process over the UNIX socket.&lt;/p&gt; &#xA;&lt;p&gt;The worker process handles arguments passed by the client in the following way:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If first argument is +m+ or matches &lt;tt&gt;/.rb:\d+\z&lt;/tt&gt;, uses the +m+ gem to run a single minitest test by line number, waiting until after the test is run so that it can return the correct exit code.&lt;/li&gt; &#xA; &lt;li&gt;If first argument is +irb+, starts an IRB shell with remaining arguments in ARGV.&lt;/li&gt; &#xA; &lt;li&gt;If first argument is &lt;tt&gt;-e&lt;/tt&gt;, evaluates second argument as Ruby code, with remaining arguments in ARGV.&lt;/li&gt; &#xA; &lt;li&gt;If no arguments are given, evaluates Ruby code provided on stdin.&lt;/li&gt; &#xA; &lt;li&gt;Otherwise, treats first argument as a file name, expands the file path, and then requires that. If Minitest is loaded and set to autorun, waits until after Minitest runs tests, so it can return the correct exit code. If Minitest is not loaded or not set to autorun, exits after the file is required.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=== Restarting the Server&lt;/p&gt; &#xA;&lt;p&gt;If &lt;tt&gt;by-server&lt;/tt&gt; is already running, running &lt;tt&gt;by-server&lt;/tt&gt; will shutdown the existing server and start a new server with the arguments it is given.&lt;/p&gt; &#xA;&lt;p&gt;=== Stopping the Server&lt;/p&gt; &#xA;&lt;p&gt;Running &lt;tt&gt;by-server stop&lt;/tt&gt; will stop an existing server without starting a new server. If no server is running, &lt;tt&gt;by-server stop&lt;/tt&gt; will exit without doing anything.&lt;/p&gt; &#xA;&lt;p&gt;You can also send a +TERM+ signal to the &lt;tt&gt;by-server&lt;/tt&gt; process to shut the server down gracefully. Be aware that by default, &lt;tt&gt;by-server&lt;/tt&gt; daemonizes, so the pid of the started &lt;tt&gt;by-server&lt;/tt&gt; will not be the pid &lt;tt&gt;by-server&lt;/tt&gt; uses to run. For that reason, it is recommended to use &lt;tt&gt;by-server stop&lt;/tt&gt; to stop the server.&lt;/p&gt; &#xA;&lt;p&gt;=== Running Multiple Servers&lt;/p&gt; &#xA;&lt;p&gt;==== Manually&lt;/p&gt; &#xA;&lt;p&gt;You can run multiple +by-server+ processes concurrently by making sure they each use a separate UNIX socket, which you can configure with the +BY_SOCKET+ environment variable:&lt;/p&gt; &#xA;&lt;p&gt;$ BY_SOCKET=&lt;del&gt;/.by_sequel_socket by-server sequel $ BY_SOCKET=&lt;/del&gt;/.by_roda_socket by-server roda $ BY_SOCKET=&lt;del&gt;/.by_sequel_socket by -e &#39;p [defined?(Sequel), defined?(Roda)]&#39; [&#34;constant&#34;, nil] $ BY_SOCKET=&lt;/del&gt;/.by_roda_socket by -e &#39;p [defined?(Sequel), defined?(Roda)]&#39; [nil, &#34;constant&#34;]&lt;/p&gt; &#xA;&lt;p&gt;==== Using &lt;tt&gt;by-session&lt;/tt&gt;&lt;/p&gt; &#xA;&lt;p&gt;In many cases, it can be helpful to have a separate server process for each application directory. &lt;tt&gt;by-session&lt;/tt&gt; exists to make this easier. &lt;tt&gt;by-session&lt;/tt&gt; will call &lt;tt&gt;by-server&lt;/tt&gt; with the arguments it is given, using a socket in the current directory by default, and then open a new shell. When the shell exits, &lt;tt&gt;by-session&lt;/tt&gt; will stop the &lt;tt&gt;by-server&lt;/tt&gt; it spawned.&lt;/p&gt; &#xA;&lt;p&gt;If the directory in which you are running &lt;tt&gt;by-session&lt;/tt&gt; has a +Gemfile+, you could add a file named &lt;tt&gt;.by-session-setup.rb&lt;/tt&gt; in your home directory, which contains:&lt;/p&gt; &#xA;&lt;p&gt;require &#39;bundler/setup&#39; Bundler.require(:default)&lt;/p&gt; &#xA;&lt;p&gt;When you to startup a &lt;tt&gt;by-session&lt;/tt&gt; shell for the directory using the +Gemfile+, you can use:&lt;/p&gt; &#xA;&lt;p&gt;$ by-session ~/.by-session-setup&lt;/p&gt; &#xA;&lt;p&gt;This will load all gems in the +Gemfile+ into the &lt;tt&gt;by-server&lt;/tt&gt; process. If you are doing this, you must be careful to only run this in a directory that you trust.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t want to specify the &lt;tt&gt;~/.by-session-setup&lt;/tt&gt; argument every time you start &lt;tt&gt;by-session&lt;/tt&gt;, you can use the +BY_SERVER_AUTO_REQUIRE+ environment variable.&lt;/p&gt; &#xA;&lt;p&gt;=== Environment Variables&lt;/p&gt; &#xA;&lt;p&gt;+BY_SOCKET+ :: The path to the UNIX socket to listen on (&lt;tt&gt;by-server&lt;/tt&gt;) or connect to (+by+). +DEBUG+ :: If set to +log+, logs &lt;tt&gt;$LOADED_FEATURES&lt;/tt&gt; to stdout after requiring libraries (&lt;tt&gt;by-server&lt;/tt&gt;) or before worker process shutdown (+by+).&lt;/p&gt; &#xA;&lt;p&gt;==== &lt;tt&gt;by-server&lt;/tt&gt;-Specific Environment Variables&lt;/p&gt; &#xA;&lt;p&gt;+BY_SERVER_AUTO_REQUIRE+ :: Whitespace separated list of libraries for &lt;tt&gt;by-server&lt;/tt&gt; to require, before it requires command line arguments. +BY_SERVER_NO_DAEMON+ :: Do not daemonize if set. +BY_SERVER_DAEMON_NO_CHDIR+ :: Do not change directory to &lt;tt&gt;/&lt;/tt&gt; when daemonizing if set. +BY_SERVER_DAEMON_NO_REDIR_STDIO+ :: Do not redirect stdio to &lt;tt&gt;/dev/null&lt;/tt&gt; when daemonizing if set.&lt;/p&gt; &#xA;&lt;p&gt;== &lt;tt&gt;by-server&lt;/tt&gt; Signals&lt;/p&gt; &#xA;&lt;p&gt;+QUIT+ :: Close the socket (this is what &lt;tt&gt;by-server stop&lt;/tt&gt; uses). +TERM+ :: Delete the socket path and then close the socket.&lt;/p&gt; &#xA;&lt;p&gt;== Internals&lt;/p&gt; &#xA;&lt;p&gt;There are two classes, &lt;tt&gt;By::Server&lt;/tt&gt; and &lt;tt&gt;By::Worker&lt;/tt&gt;. &lt;tt&gt;By::Server&lt;/tt&gt; listens on the UNIX socket, forking worker processes for each connection. &lt;tt&gt;By::Worker&lt;/tt&gt; is run in each worker process handling receiving data from the +by+ command line program.&lt;/p&gt; &#xA;&lt;p&gt;The +by+ command line program is self-contained, there is no Ruby class for the behavior, to make sure startup is as fast as possible. &lt;tt&gt;by-session&lt;/tt&gt; is also self-contained.&lt;/p&gt; &#xA;&lt;p&gt;== Customization&lt;/p&gt; &#xA;&lt;p&gt;For custom handling of arguments, you can require &lt;tt&gt;by/server&lt;/tt&gt; and use the &lt;tt&gt;By::Server.with_argument_handler&lt;/tt&gt; method. For example, if you wanted to add support for an initial &lt;tt&gt;-I&lt;/tt&gt; option to modify the load path, and then use the standard argument handling:&lt;/p&gt; &#xA;&lt;p&gt;require &#39;by/server&#39;&lt;/p&gt; &#xA;&lt;p&gt;By::Server.with_argument_handler do |args| if args[0] == &#39;-I&#39; args.shift $LOAD_PATH.unshift(args.shift) end super(args) end.new.run&lt;/p&gt; &#xA;&lt;p&gt;Note that if you do this, you are responsible for making sure to correctly communicate with the client socket. Otherwise, it&#39;s possible the client socket may hang waiting on a response. Please review the default argument handling in &lt;tt&gt;lib/by/worker.rb&lt;/tt&gt; before writing your own argument handler.&lt;/p&gt; &#xA;&lt;p&gt;== Security&lt;/p&gt; &#xA;&lt;p&gt;As with any program that forks without executing, the memory layout is shared by the client and the server program, which can lead to Blind Return Oriented Programming (BROP) attacks. You should avoid using +by+ to run a program that deals with any untrusted input. +by+ makes a deliberate choice to trade security to make process startup as fast as possible.&lt;/p&gt; &#xA;&lt;p&gt;The server socket is set to mode 0600, so it is only readable and writable by the same user.&lt;/p&gt; &#xA;&lt;p&gt;== Name&lt;/p&gt; &#xA;&lt;p&gt;The name +by+ was chosen because it is +ruby+ with the +ru+ preloaded.&lt;/p&gt; &#xA;&lt;p&gt;== Similar Projects&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Spring: &lt;a href=&#34;https://github.com/rails/spring&#34;&gt;https://github.com/rails/spring&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Spin: &lt;a href=&#34;https://github.com/jstorimer/spin&#34;&gt;https://github.com/jstorimer/spin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Spinoff: &lt;a href=&#34;https://github.com/bernd/spinoff&#34;&gt;https://github.com/bernd/spinoff&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;== License&lt;/p&gt; &#xA;&lt;p&gt;MIT&lt;/p&gt; &#xA;&lt;p&gt;== Author&lt;/p&gt; &#xA;&lt;p&gt;Jeremy Evans &lt;a href=&#34;mailto:code@jeremyevans.net&#34;&gt;code@jeremyevans.net&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>digininja/CeWL</title>
    <updated>2023-02-20T01:45:32Z</updated>
    <id>tag:github.com,2023-02-20:/digininja/CeWL</id>
    <link href="https://github.com/digininja/CeWL" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CeWL is a Custom Word List Generator&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CeWL - Custom Word List generator&lt;/h1&gt; &#xA;&lt;p&gt;Copyright(c) 2022, Robin Wood &lt;a href=&#34;mailto:robin@digi.ninja&#34;&gt;robin@digi.ninja&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Based on a discussion on PaulDotCom (episode 129) about creating custom word lists spidering a targets website and collecting unique words I decided to write CeWL, the Custom Word List generator. CeWL is a ruby app which spiders a given URL to a specified depth, optionally following external links, and returns a list of words which can then be used for password crackers such as John the Ripper.&lt;/p&gt; &#xA;&lt;p&gt;By default, CeWL sticks to just the site you have specified and will go to a depth of 2 links, this behaviour can be changed by passing arguments. Be careful if setting a large depth and allowing it to go offsite, you could end up drifting on to a lot of other domains. All words of three characters and over are output to stdout. This length can be increased and the words can be written to a file rather than screen so the app can be automated.&lt;/p&gt; &#xA;&lt;p&gt;CeWL also has an associated command line app, FAB (Files Already Bagged) which uses the same meta data extraction techniques to create author/creator lists from already downloaded.&lt;/p&gt; &#xA;&lt;p&gt;For anyone running CeWL with Ruby 2.7, you might get some warnings in the style:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;.../ruby-2.7.0/gems/mime-types-3.2.2/lib/mime/types/logger.rb:30: warning: `_1&#39; is reserved for numbered parameter; consider another name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is due to a new feature introduced in 2.7 which conflices with one line of code in the logger script from the mime-types gem. There is an update for it in the &lt;a href=&#34;https://github.com/mime-types/ruby-mime-types/commit/c44673179d24e495e5fb93282a87d37f09925d25#diff-f0a644249326afd54e7a0b90c807f8a6&#34;&gt;gem&#39;s repo&lt;/a&gt; so hopefully that will be released soon. Till then, as far as I can tell, the warning does not affect CeWL in any way. If, for asthetics, you want to hide the warning, you can run the script as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ruby -W0 ./cewl.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Homepage: &lt;a href=&#34;https://digi.ninja/projects/cewl.php&#34;&gt;https://digi.ninja/projects/cewl.php&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;GitHub: &lt;a href=&#34;https://github.com/digininja/CeWL&#34;&gt;https://github.com/digininja/CeWL&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Pronunciation&lt;/h2&gt; &#xA;&lt;p&gt;Seeing as I was asked, CeWL is pronounced &#34;cool&#34;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;CeWL needs the following gems to be installed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;mime&lt;/li&gt; &#xA; &lt;li&gt;mime-types&lt;/li&gt; &#xA; &lt;li&gt;mini_exiftool&lt;/li&gt; &#xA; &lt;li&gt;nokogiri&lt;/li&gt; &#xA; &lt;li&gt;rubyzip&lt;/li&gt; &#xA; &lt;li&gt;spider&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The easiest way to install these gems is with Bundler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gem install bundler&#xA;bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can install them manually with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gem install xxx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The gem &lt;code&gt;mini_exiftool&lt;/code&gt; gem also requires the exiftool application to be installed.&lt;/p&gt; &#xA;&lt;p&gt;Assuming you cloned the GitHub repo, the script should by executable by default, but if not, you can make it executable with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;chmod u+x ./cewl.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The project page on my site gives some tips on solving common problems people have encountered while running CeWL - &lt;a href=&#34;https://digi.ninja/projects/cewl.php&#34;&gt;https://digi.ninja/projects/cewl.php&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;./cewl.rb&#xA;&#xA;CeWL 5.5.2 (Grouping) Robin Wood (robin@digi.ninja) (https://digi.ninja/)&#xA;Usage: cewl [OPTIONS] ... &amp;lt;url&amp;gt;&#xA;&#xA;    OPTIONS:&#xA;&#x9;-h, --help: Show help.&#xA;&#x9;-k, --keep: Keep the downloaded file.&#xA;&#x9;-d &amp;lt;x&amp;gt;,--depth &amp;lt;x&amp;gt;: Depth to spider to, default 2.&#xA;&#x9;-m, --min_word_length: Minimum word length, default 3.&#xA;&#x9;-o, --offsite: Let the spider visit other sites.&#xA;&#x9;-w, --write: Write the output to the file.&#xA;&#x9;-u, --ua &amp;lt;agent&amp;gt;: User agent to send.&#xA;&#x9;-n, --no-words: Don&#39;t output the wordlist.&#xA;&#x9;-a, --meta: include meta data.&#xA;&#x9;--meta_file file: Output file for meta data.&#xA;&#x9;-e, --email: Include email addresses.&#xA;&#x9;--email_file &amp;lt;file&amp;gt;: Output file for email addresses.&#xA;&#x9;--meta-temp-dir &amp;lt;dir&amp;gt;: The temporary directory used by exiftool when parsing files, default /tmp.&#xA;&#x9;-c, --count: Show the count for each word found.&#xA;&#x9;-v, --verbose: Verbose.&#xA;&#x9;--debug: Extra debug information.&#xA;&#xA;&#x9;Authentication&#xA;&#x9;--auth_type: Digest or basic.&#xA;&#x9;--auth_user: Authentication username.&#xA;&#x9;--auth_pass: Authentication password.&#xA;&#xA;&#x9;Proxy Support&#xA;&#x9;--proxy_host: Proxy host.&#xA;&#x9;--proxy_port: Proxy port, default 8080.&#xA;&#x9;--proxy_username: Username for proxy, if required.&#xA;&#x9;--proxy_password: Password for proxy, if required.&#xA;&#xA;&#x9;Headers&#xA;&#x9;--header, -H: In format name:value - can pass multiple.&#xA;&#xA;    &amp;lt;url&amp;gt;: The site to spider.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Running CeWL in a Docker container&lt;/h3&gt; &#xA;&lt;p&gt;To quickly use CeWL on your machine with Docker, you have to build it :&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Build the container : &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker build -t cewl .&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Container usage without interacting with local files : &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run -it --rm cewl [OPTIONS] ... &amp;lt;url&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Container usage with local files as input or output : &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# you have to mount the current directory when calling the container &#xA;docker run -it --rm -v &#34;${PWD}:/host&#34; cewl [OPTIONS] ... &amp;lt;url&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;I am going to stress here, I am not going to be offering any support for this. The work was done by &lt;a href=&#34;https://github.com/loris-intergalactique&#34;&gt;@loris-intergalactique&lt;/a&gt; who has offered to field any questions on it and give support. I don&#39;t use or know Docker, so please, don&#39;t ask me for help.&lt;/p&gt; &#xA;&lt;h2&gt;Licence&lt;/h2&gt; &#xA;&lt;p&gt;This project released under the Creative Commons Attribution-Share Alike 2.0 UK: England &amp;amp; Wales&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://creativecommons.org/licenses/by-sa/2.0/uk/&#34;&gt;http://creativecommons.org/licenses/by-sa/2.0/uk/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can use GPL-3+ instead the of the original license.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://opensource.org/licenses/GPL-3.0&#34;&gt;http://opensource.org/licenses/GPL-3.0&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>buo/homebrew-cask-upgrade</title>
    <updated>2023-02-20T01:45:32Z</updated>
    <id>tag:github.com,2023-02-20:/buo/homebrew-cask-upgrade</id>
    <link href="https://github.com/buo/homebrew-cask-upgrade" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A command line tool for upgrading every outdated app installed by Homebrew Cask&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/buo/homebrew-cask-upgrade/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/buo/homebrew-cask-upgrade/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;brew-cask-upgrade&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;brew-cask-upgrade&lt;/code&gt; is a command-line tool for upgrading every outdated app installed by &lt;a href=&#34;https://github.com/Homebrew/homebrew-cask&#34;&gt;Homebrew Cask&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Homebrew Cask extends &lt;a href=&#34;http://brew.sh&#34;&gt;Homebrew&lt;/a&gt; and brings its elegance, simplicity, and speed to the installation and management of GUI macOS applications and large binaries alike.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;brew-cask-upgrade&lt;/code&gt; is an external command to replace the native &lt;code&gt;upgrade&lt;/code&gt; by offering interactivity, an improved interface, and higher granularity of what to upgrade.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;brew tap buo/cask-upgrade&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Verification of installation&lt;/h3&gt; &#xA;&lt;p&gt;In order to simply verify that &lt;code&gt;brew cu&lt;/code&gt; is correctly installed, you can simply run &lt;code&gt;brew tap&lt;/code&gt; command and see if the repo is included:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; brew tap&#xA;buo/cask-upgrade&#xA;homebrew/bundle&#xA;homebrew/cask&#xA;homebrew/core&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Uninstallation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew untap buo/cask-upgrade&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Upgrade outdated apps:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;brew cu&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Upgrade a specific app:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;brew cu [CASK]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While running the &lt;code&gt;brew cu&lt;/code&gt; command without any other further options, the script automatically runs &lt;code&gt;brew update&lt;/code&gt; to get latest versions of all the installed casks (this can be disabled, see options below).&lt;/p&gt; &#xA;&lt;p&gt;It is also possible to use &lt;code&gt;*&lt;/code&gt; to install multiple casks at once, i.e. &lt;code&gt;brew cu flash-*&lt;/code&gt; to install all casks starting with &lt;code&gt;flash-&lt;/code&gt; prefix.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/DlXUmiFFVnDhIDe2tCGo3ecLW&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/DlXUmiFFVnDhIDe2tCGo3ecLW.png&#34; alt=&#34;asciicast&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Apps with auto-update&lt;/h3&gt; &#xA;&lt;p&gt;If the app has the auto update functionality (i.e. they ask you themselves if you want to upgrade them), they are not upgraded while running &lt;code&gt;brew cu&lt;/code&gt; and will display a &lt;code&gt;PASS&lt;/code&gt; result. If you want to upgrade them, pass the &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--all&lt;/code&gt; option to include also those kind of apps.&lt;/p&gt; &#xA;&lt;p&gt;Please note, that if you update the apps using their auto-update functionality, that change will not reflect in the &lt;code&gt;brew cu&lt;/code&gt; script! Tracked version gets only updated, when the app is upgraded through &lt;code&gt;brew cu --all&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Options&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: brew cu [command=run] [CASK] [options]&#xA;Commands:&#xA;    run         Default command, doesn&#39;t have to be specified. Executes cask upgrades.&#xA;    pin         Pin the current app version, preventing it from being &#xA;                upgraded when issuing the `brew cu` command. See also `unpin`.&#xA;    unpin       Unpin the current app version, allowing them to be &#xA;                upgraded by `brew cu` command. See also `pin`.&#xA;    pinned      Print all pinned apps and its version. See also `pin`.&#xA;&#xA;Options:&#xA;    -a, --all             Include apps that auto-update in the upgrade.&#xA;        --cleanup         Cleans up cached downloads and tracker symlinks after&#xA;                          updating.&#xA;    -f  --force           Include apps that are marked as latest&#xA;                          (i.e. force-reinstall them).&#xA;        --no-brew-update  Prevent auto-update of Homebrew, taps, and formulae&#xA;                          before checking outdated apps.&#xA;    -y, --yes             Update all outdated apps; answer yes to updating packages.&#xA;    -q, --quiet           Do not show information about installed apps or current options.&#xA;    -v, --verbose         Make output more verbose.&#xA;        --no-quarantine   Pass --no-quarantine option to `brew cask install`.&#xA;    -i, --interactive     Running update in interactive mode&#xA;        --include-mas     (Experimental) Include applications from Mac App Store.    &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Display usage instructions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew help cu&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Mac App Store applications (Experimental)&lt;/h3&gt; &#xA;&lt;p&gt;By adding &lt;code&gt;--include-mas&lt;/code&gt; parameter to the &lt;code&gt;brew cu&lt;/code&gt; command, we use &lt;a href=&#34;https://github.com/mas-cli/mas/&#34;&gt;mas&lt;/a&gt; cli tool to manage upgrades for Mac App Store applications as well.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This feature is highly experimental and we don&#39;t guarantee it&#39;s functionality. Use at your own risk.&lt;/p&gt; &#xA;&lt;h3&gt;Interactive mode&lt;/h3&gt; &#xA;&lt;p&gt;When using interactive mode (by adding &lt;code&gt;--interactive&lt;/code&gt; argument or confirming app installation with &lt;code&gt;i&lt;/code&gt;) will trigger per-cask confirmation. For every cask it is then possible to use following options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;y&lt;/code&gt; will install the current cask update&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;N&lt;/code&gt; will skip the installation of current cask&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;p&lt;/code&gt; will pin the current version of the cask (see &lt;a href=&#34;https://raw.githubusercontent.com/buo/homebrew-cask-upgrade/master/#version-pinning&#34;&gt;version pinning&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version pinning&lt;/h3&gt; &#xA;&lt;p&gt;Pinned apps will not be updated by &lt;code&gt;brew cu&lt;/code&gt; until they are unpinned. NB: version pinning in &lt;code&gt;brew cu&lt;/code&gt; will not prevent &lt;code&gt;brew cask upgrade&lt;/code&gt; from updating pinned apps.&lt;/p&gt; &#xA;&lt;h3&gt;Export / Import pinned apps&lt;/h3&gt; &#xA;&lt;p&gt;In order to export backup of your pinned casks into a file, simply pass &lt;code&gt;--export&lt;/code&gt; option to the &lt;code&gt;pinned&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew cu pinned --export my-backup-filename.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Versions, in which were casks pinned, are not exported as it isn’t possible to install a specific version afterwards.&lt;/p&gt; &#xA;&lt;p&gt;In order to load the configuration back, use &lt;code&gt;--load&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew cu pinned --load my-backup-filename.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Loading the configuration will &lt;strong&gt;replace&lt;/strong&gt; current values.&lt;/p&gt;</summary>
  </entry>
</feed>