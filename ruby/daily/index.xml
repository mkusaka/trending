<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-10T01:39:22Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>gocardless/statesman</title>
    <updated>2023-10-10T01:39:22Z</updated>
    <id>tag:github.com,2023-10-10:/gocardless/statesman</id>
    <link href="https://github.com/gocardless/statesman" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A statesmanlike state machine library.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/110275/106792848-96e4ee80-664e-11eb-8fd1-16ff24b41eb2.png&#34; alt=&#34;Statesman&#34; width=&#34;512&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A statesmanlike state machine library.&lt;/p&gt; &#xA;&lt;p&gt;For our policy on compatibility with Ruby and Rails versions, see &lt;a href=&#34;https://raw.githubusercontent.com/gocardless/statesman/master/docs/COMPATIBILITY.md&#34;&gt;COMPATIBILITY.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://badge.fury.io/rb/statesman&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/statesman.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/gocardless/statesman&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/gocardless/statesman.svg?style=shield&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/gocardless/statesman&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/gocardless/statesman.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/gocardless/statesman?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/join.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://dependabot.com/compatibility-score.html?dependency-name=statesman&amp;amp;package-manager=bundler&amp;amp;version-scheme=semver&#34;&gt;&lt;img src=&#34;https://api.dependabot.com/badges/compatibility_score?dependency-name=statesman&amp;amp;package-manager=bundler&amp;amp;version-scheme=semver&#34; alt=&#34;SemVer&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Statesman is an opinionated state machine library designed to provide a robust audit trail and data integrity. It decouples the state machine logic from the underlying model and allows for easy composition with one or more model classes.&lt;/p&gt; &#xA;&lt;p&gt;As such, the design of statesman is a little different from other state machine libraries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;State behaviour is defined in a separate, &#34;state machine&#34; class, rather than added directly onto a model. State machines are then instantiated with the model to which they should apply.&lt;/li&gt; &#xA; &lt;li&gt;State transitions are also modelled as a class, which can optionally be persisted to the database for a full audit history. This audit history can include JSON metadata set during a transition.&lt;/li&gt; &#xA; &lt;li&gt;Database indices are used to offer database-level transaction duplication protection.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;To get started, just add Statesman to your &lt;code&gt;Gemfile&lt;/code&gt;, and then run &lt;code&gt;bundle&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;statesman&#39;, &#39;~&amp;gt; 10.0.0&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;First, create a state machine based on &lt;code&gt;Statesman::Machine&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class OrderStateMachine&#xA;  include Statesman::Machine&#xA;&#xA;  state :pending, initial: true&#xA;  state :checking_out&#xA;  state :purchased&#xA;  state :shipped&#xA;  state :cancelled&#xA;  state :failed&#xA;  state :refunded&#xA;&#xA;  transition from: :pending,      to: [:checking_out, :cancelled]&#xA;  transition from: :checking_out, to: [:purchased, :cancelled]&#xA;  transition from: :purchased,    to: [:shipped, :failed]&#xA;  transition from: :shipped,      to: :refunded&#xA;&#xA;  guard_transition(to: :checking_out) do |order|&#xA;    order.products_in_stock?&#xA;  end&#xA;&#xA;  before_transition(from: :checking_out, to: :cancelled) do |order, transition|&#xA;    order.reallocate_stock&#xA;  end&#xA;&#xA;  before_transition(to: :purchased) do |order, transition|&#xA;    PaymentService.new(order).submit&#xA;  end&#xA;&#xA;  after_transition(to: :purchased) do |order, transition|&#xA;    MailerService.order_confirmation(order).deliver&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, link it to your model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Order &amp;lt; ActiveRecord::Base&#xA;  has_many :order_transitions, autosave: false&#xA;&#xA;  include Statesman::Adapters::ActiveRecordQueries[&#xA;    transition_class: OrderTransition,&#xA;    initial_state: :pending&#xA;  ]&#xA;&#xA;  def state_machine&#xA;    @state_machine ||= OrderStateMachine.new(self, transition_class: OrderTransition)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, you&#39;ll need to create a further model to represent state transitions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class OrderTransition &amp;lt; ActiveRecord::Base&#xA;  include Statesman::Adapters::ActiveRecordTransition&#xA;&#xA;  validates :to_state, inclusion: { in: OrderStateMachine.states }&#xA;&#xA;  belongs_to :order, inverse_of: :order_transitions&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, you can start working with your state machine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Order.first.state_machine.current_state # =&amp;gt; &#34;pending&#34;&#xA;Order.first.state_machine.allowed_transitions # =&amp;gt; [&#34;checking_out&#34;, &#34;cancelled&#34;]&#xA;Order.first.state_machine.can_transition_to?(:cancelled) # =&amp;gt; true/false&#xA;Order.first.state_machine.transition_to(:cancelled, optional: :metadata) # =&amp;gt; true/false&#xA;Order.first.state_machine.transition_to!(:cancelled) # =&amp;gt; true/exception&#xA;Order.first.state_machine.last_transition # =&amp;gt; transition model or nil&#xA;Order.first.state_machine.last_transition_to(:pending) # =&amp;gt; transition model or nil&#xA;&#xA;Order.in_state(:cancelled) # =&amp;gt; [#&amp;lt;Order id: &#34;123&#34;&amp;gt;]&#xA;Order.not_in_state(:checking_out) # =&amp;gt; [#&amp;lt;Order id: &#34;123&#34;&amp;gt;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;d like, you can also define a template for a generic state machine, then alter classes which extend it as required:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module Template&#xA;  def define_states&#xA;    state :a, initial: true&#xA;    state :b&#xA;    state :c&#xA;  end&#xA;&#xA;  def define_transitions&#xA;    transition from: :a, to: :b&#xA;    transition from: :b, to: :c&#xA;    transition from: :c, to: :a&#xA;  end&#xA;end&#xA;&#xA;class Circular&#xA;  include Statesman::Machine&#xA;  extend Template&#xA;  &#xA;  define_states&#xA;  define_transitions&#xA;end&#xA;&#xA;class Linear&#xA;  include Statesman::Machine&#xA;  extend Template&#xA;  &#xA;  define_states&#xA;  define_transitions&#xA;  &#xA;  remove_transitions from: :c, to: :a&#xA;end&#xA;&#xA;class Shorter&#xA;  include Statesman::Machine&#xA;  extend Template&#xA;&#xA;  define_states&#xA;  define_transitions&#xA;&#xA;  remove_state :c&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Persistence&lt;/h2&gt; &#xA;&lt;p&gt;By default Statesman stores transition history in memory only. It can be persisted by configuring Statesman to use a different adapter. For example, for ActiveRecord within Rails:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;config/initializers/statesman.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Statesman.configure do&#xA;  storage_adapter(Statesman::Adapters::ActiveRecord)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Generate the transition model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rails g statesman:active_record_transition Order OrderTransition&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Your transition class should &lt;code&gt;include Statesman::Adapters::ActiveRecordTransition&lt;/code&gt; if you&#39;re using the ActiveRecord adapter.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re using the ActiveRecord adapter and decide not to include the default &lt;code&gt;updated_at&lt;/code&gt; column in your transition table, you&#39;ll need to configure the &lt;code&gt;updated_timestamp_column&lt;/code&gt; option on the transition class, setting it to another column name (e.g. &lt;code&gt;:updated_on&lt;/code&gt;) or &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;And add an association from the parent model:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;app/models/order.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Order &amp;lt; ActiveRecord::Base&#xA;  has_many :transitions, class_name: &#34;OrderTransition&#34;, autosave: false&#xA;&#xA;  # Initialize the state machine&#xA;  def state_machine&#xA;    @state_machine ||= OrderStateMachine.new(self, transition_class: OrderTransition,&#xA;                                                   association_name: :transitions)&#xA;  end&#xA;&#xA;  # Optionally delegate some methods&#xA;&#xA;  delegate :can_transition_to?,&#xA;           :current_state, :history, :last_transition, :last_transition_to,&#xA;           :transition_to!, :transition_to, :in_state?, to: :state_machine&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Using PostgreSQL JSON column&lt;/h4&gt; &#xA;&lt;p&gt;By default, Statesman uses &lt;code&gt;serialize&lt;/code&gt; to store the metadata in JSON format. It is also possible to use the PostgreSQL JSON column if you are using Rails 4 or 5. To do that&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Change &lt;code&gt;metadata&lt;/code&gt; column type in the transition model migration to &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Before&#xA;t.text :metadata, default: &#34;{}&#34;&#xA;# After (Rails 4)&#xA;t.json :metadata, default: &#34;{}&#34;&#xA;# After (Rails 5)&#xA;t.json :metadata, default: {}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Remove the &lt;code&gt;include Statesman::Adapters::ActiveRecordTransition&lt;/code&gt; statement from your transition model. (If you want to customise your transition class&#39;s &#34;updated timestamp column&#34;, as described above, you should define a &lt;code&gt;.updated_timestamp_column&lt;/code&gt; method on your class and return the name of the column as a symbol, or &lt;code&gt;nil&lt;/code&gt; if you don&#39;t want to record an updated timestamp on transitions.)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;code&gt;storage_adapter&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Statesman.configure do&#xA;  storage_adapter(Statesman::Adapters::ActiveRecord)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Statesman defaults to storing transitions in memory. If you&#39;re using rails, you can instead configure it to persist transitions to the database by using the ActiveRecord adapter.&lt;/p&gt; &#xA;&lt;p&gt;Statesman will fallback to memory unless you specify a transition_class when instantiating your state machine. This allows you to only persist transitions on certain state machines in your app.&lt;/p&gt; &#xA;&lt;h2&gt;Class methods&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine.state&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Machine.state(:some_state, initial: true)&#xA;Machine.state(:another_state)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Define a new state and optionally mark as the initial state.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine.transition&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Machine.transition(from: :some_state, to: :another_state)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Define a transition rule. Both method parameters are required, &lt;code&gt;to&lt;/code&gt; can also be an array of states (&lt;code&gt;.transition(from: :some_state, to: [:another_state, :some_other_state])&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine.guard_transition&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Machine.guard_transition(from: :some_state, to: :another_state) do |object|&#xA;  object.some_boolean?&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Define a guard. &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;from&lt;/code&gt; parameters are optional, a nil parameter means guard all transitions. The passed block should evaluate to a boolean and must be idempotent as it could be called many times. The guard will pass when it evaluates to a truthy value and fail when it evaluates to a falsey value (&lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine.before_transition&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Machine.before_transition(from: :some_state, to: :another_state) do |object|&#xA;  object.side_effect&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Define a callback to run before a transition. &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;from&lt;/code&gt; parameters are optional, a nil parameter means run before all transitions. This callback can have side-effects as it will only be run once immediately before the transition.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine.after_transition&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Machine.after_transition(from: :some_state, to: :another_state) do |object, transition|&#xA;  object.side_effect&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Define a callback to run after a successful transition. &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;from&lt;/code&gt; parameters are optional, a nil parameter means run after all transitions. The model object and transition object are passed as arguments to the callback. This callback can have side-effects as it will only be run once immediately after the transition.&lt;/p&gt; &#xA;&lt;p&gt;If you specify &lt;code&gt;after_commit: true&lt;/code&gt;, the callback will be executed once the transition has been committed to the database.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine.after_transition_failure&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Machine.after_transition_failure(from: :some_state, to: :another_state) do |object, exception|&#xA;  Logger.info(&#34;transition to #{exception.to} failed for #{object.id}&#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Define a callback to run if &lt;code&gt;Statesman::TransitionFailedError&lt;/code&gt; is raised during the execution of transition callbacks. &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;from&lt;/code&gt; parameters are optional, a nil parameter means run after all transitions. The model object, and exception are passed as arguments to the callback. This is executed outside of the transaction wrapping other callbacks. If using &lt;code&gt;transition!&lt;/code&gt; the exception is re-raised after these callbacks are executed.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine.after_guard_failure&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Machine.after_guard_failure(from: :some_state, to: :another_state) do |object, exception|&#xA;  Logger.info(&#34;guard failed during transition to #{exception.to} for #{object.id}&#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Define a callback to run if &lt;code&gt;Statesman::GuardFailedError&lt;/code&gt; is raised during the execution of guard callbacks. &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;from&lt;/code&gt; parameters are optional, a nil parameter means run after all transitions. The model object, and exception are passed as arguments to the callback. This is executed outside of the transaction wrapping other callbacks. If using &lt;code&gt;transition!&lt;/code&gt; the exception is re-raised after these callbacks are executed.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine.new&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;my_machine = Machine.new(my_model, transition_class: MyTransitionModel)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Initialize a new state machine instance. &lt;code&gt;my_model&lt;/code&gt; is required. If using the ActiveRecord adapter &lt;code&gt;my_model&lt;/code&gt; should have a &lt;code&gt;has_many&lt;/code&gt; association with &lt;code&gt;MyTransitionModel&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine.retry_conflicts&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Machine.retry_conflicts { instance.transition_to(:new_state) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Automatically retry the given block if a &lt;code&gt;TransitionConflictError&lt;/code&gt; is raised. If you know you want to retry a transition if it fails due to a race condition call it from within this block. Takes an (optional) argument for the maximum number of retry attempts (defaults to 1).&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine.states&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns an array of all possible state names as strings.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine.successors&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns a hash of states and the states it is valid for them to transition to.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Machine.successors&#xA;&#xA;{&#xA;  &#34;pending&#34; =&amp;gt; [&#34;checking_out&#34;, &#34;cancelled&#34;],&#xA;  &#34;checking_out&#34; =&amp;gt; [&#34;purchased&#34;, &#34;cancelled&#34;],&#xA;  &#34;purchased&#34; =&amp;gt; [&#34;shipped&#34;, &#34;failed&#34;],&#xA;  &#34;shipped&#34; =&amp;gt; [&#34;refunded&#34;]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Instance methods&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine#current_state&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns the current state based on existing transition objects.&lt;/p&gt; &#xA;&lt;p&gt;Takes an optional keyword argument to force a reload of data from the database. e.g &lt;code&gt;current_state(force_reload: true)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine#in_state?(:state_1, :state_2, ...)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns true if the machine is in any of the given states.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine#history&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns a sorted array of all transition objects.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine#last_transition&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns the most recent transition object.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine#last_transition_to(:state)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns the most recent transition object to a given state.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine#allowed_transitions&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns an array of states you can &lt;code&gt;transition_to&lt;/code&gt; from current state.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine#can_transition_to?(:state)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns true if the current state can transition to the passed state and all applicable guards pass.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine#transition_to!(:state)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Transition to the passed state, returning &lt;code&gt;true&lt;/code&gt; on success. Raises &lt;code&gt;Statesman::GuardFailedError&lt;/code&gt; or &lt;code&gt;Statesman::TransitionFailedError&lt;/code&gt; on failure.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Machine#transition_to(:state)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Transition to the passed state, returning &lt;code&gt;true&lt;/code&gt; on success. Swallows all Statesman exceptions and returns false on failure. (NB. if your guard or callback code throws an exception, it will not be caught.)&lt;/p&gt; &#xA;&lt;h2&gt;Errors&lt;/h2&gt; &#xA;&lt;h3&gt;Initialization errors&lt;/h3&gt; &#xA;&lt;p&gt;These errors are raised when the Machine and/or Model is initialized. A simple spec like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect { OrderStateMachine.new(Order.new, transition_class: OrderTransition) }.to_not raise_error&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will expose these errors as part of your test suite&lt;/p&gt; &#xA;&lt;h4&gt;InvalidStateError&lt;/h4&gt; &#xA;&lt;p&gt;Raised if:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Attempting to define a transition without a &lt;code&gt;to&lt;/code&gt; state.&lt;/li&gt; &#xA; &lt;li&gt;Attempting to define a transition with a non-existent state.&lt;/li&gt; &#xA; &lt;li&gt;Attempting to define multiple states as &lt;code&gt;initial&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;InvalidTransitionError&lt;/h4&gt; &#xA;&lt;p&gt;Raised if:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Attempting to define a callback &lt;code&gt;from&lt;/code&gt; a state that has no valid transitions (A terminal state).&lt;/li&gt; &#xA; &lt;li&gt;Attempting to define a callback &lt;code&gt;to&lt;/code&gt; the &lt;code&gt;initial&lt;/code&gt; state if that state has no transitions to it.&lt;/li&gt; &#xA; &lt;li&gt;Attempting to define a callback with &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; where any of the pairs have no transition between them.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;InvalidCallbackError&lt;/h4&gt; &#xA;&lt;p&gt;Raised if:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Attempting to define a callback without a block.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;UnserializedMetadataError&lt;/h4&gt; &#xA;&lt;p&gt;Raised if:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ActiveRecord is configured to not serialize the &lt;code&gt;metadata&lt;/code&gt; attribute into to Database column backing it. See the &lt;code&gt;Using PostgreSQL JSON column&lt;/code&gt; section.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;IncompatibleSerializationError&lt;/h4&gt; &#xA;&lt;p&gt;Raised if:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;There is a mismatch between the column type of the &lt;code&gt;metadata&lt;/code&gt; in the Database and the model. See the &lt;code&gt;Using PostgreSQL JSON column&lt;/code&gt; section.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;MissingTransitionAssociation&lt;/h4&gt; &#xA;&lt;p&gt;Raised if:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The model that &lt;code&gt;Statesman::Adapters::ActiveRecordQueries&lt;/code&gt; is included in does not have a &lt;code&gt;has_many&lt;/code&gt; association to the &lt;code&gt;transition_class&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Runtime errors&lt;/h3&gt; &#xA;&lt;p&gt;These errors are raised by &lt;code&gt;transition_to!&lt;/code&gt;. Using &lt;code&gt;transition_to&lt;/code&gt; will supress &lt;code&gt;GuardFailedError&lt;/code&gt; and &lt;code&gt;TransitionFailedError&lt;/code&gt; and return &lt;code&gt;false&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;h4&gt;GuardFailedError&lt;/h4&gt; &#xA;&lt;p&gt;Raised if:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A guard callback between &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; state returned a falsey value.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;TransitionFailedError&lt;/h4&gt; &#xA;&lt;p&gt;Raised if:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A transition is attempted but &lt;code&gt;current_state -&amp;gt; new_state&lt;/code&gt; is not a valid pair.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;TransitionConflictError&lt;/h4&gt; &#xA;&lt;p&gt;Raised if:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A database conflict affecting the &lt;code&gt;sort_key&lt;/code&gt; or &lt;code&gt;most_recent&lt;/code&gt; columns occurs when attempting a transition. Retried automatically if it occurs wrapped in &lt;code&gt;retry_conflicts&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Model scopes&lt;/h2&gt; &#xA;&lt;p&gt;A mixin is provided for the ActiveRecord adapter which adds scopes to easily find all models currently in (or not in) a given state. Include it into your model and passing in &lt;code&gt;transition_class&lt;/code&gt; and &lt;code&gt;initial_state&lt;/code&gt; as options.&lt;/p&gt; &#xA;&lt;p&gt;In 4.1.2 and below, these two options had to be defined as methods on the model, but 5.0.0 and above allow this style of configuration as well. The old method pollutes the model with extra class methods, and is deprecated, to be removed in 6.0.0.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Order &amp;lt; ActiveRecord::Base&#xA;  has_many :order_transitions, autosave: false&#xA;  include Statesman::Adapters::ActiveRecordQueries[&#xA;    transition_class: OrderTransition,&#xA;    initial_state: OrderStateMachine.initial_state&#xA;  ]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the transition class-name differs from the association name, you will also need to pass &lt;code&gt;transition_name&lt;/code&gt; as an option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Order &amp;lt; ActiveRecord::Base&#xA;  has_many :transitions, class_name: &#34;OrderTransition&#34;, autosave: false&#xA;  include Statesman::Adapters::ActiveRecordQueries[&#xA;    transition_class: OrderTransition,&#xA;    initial_state: OrderStateMachine.initial_state,&#xA;    transition_name: :transitions&#xA;  ]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;Model.in_state(:state_1, :state_2, etc)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns all models currently in any of the supplied states.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Model.not_in_state(:state_1, :state_2, etc)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns all models not currently in any of the supplied states.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;Model.most_recent_transition_join&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;This joins the model to its most recent transition whatever that may be. We expose this method to ease use of ActiveRecord&#39;s &lt;code&gt;or&lt;/code&gt; e.g&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Model.in_state(:state_1).or(&#xA;  Model.most_recent_transition_join.where(model_field: 123)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Frequently Asked Questions&lt;/h2&gt; &#xA;&lt;h4&gt;Storing the state on the model object&lt;/h4&gt; &#xA;&lt;p&gt;If you wish to store the model state on the model directly, you can keep it up to date using an &lt;code&gt;after_transition&lt;/code&gt; hook. Combine it with the &lt;code&gt;after_commit&lt;/code&gt; option to ensure the model state will only be saved once the transition has made it irreversibly to the database:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;after_transition(after_commit: true) do |model, transition|&#xA;  model.state = transition.to_state&#xA;  model.save!&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You could also use a calculated column or view in your database.&lt;/p&gt; &#xA;&lt;h4&gt;Accessing metadata from the last transition&lt;/h4&gt; &#xA;&lt;p&gt;Given a field &lt;code&gt;foo&lt;/code&gt; that was stored in the metadata, you can access it like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;model_instance.state_machine.last_transition.metadata[&#34;foo&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Events&lt;/h4&gt; &#xA;&lt;p&gt;Used to using a state machine with &#34;events&#34;? Support for events is provided by the &lt;a href=&#34;https://github.com/gocardless/statesman-events&#34;&gt;statesman-events&lt;/a&gt; gem. Once that&#39;s included in your Gemfile you can include event functionality in your state machine as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class OrderStateMachine&#xA;  include Statesman::Machine&#xA;  include Statesman::Events&#xA;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Deleting records.&lt;/h4&gt; &#xA;&lt;p&gt;If you need to delete the Parent model regularly you will need to change either the association deletion behaviour or add a &lt;code&gt;DELETE CASCADE&lt;/code&gt; condition to foreign key in your database.&lt;/p&gt; &#xA;&lt;p&gt;E.g&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;has_many :order_transitions, autosave: false, dependent: :destroy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or when migrating the transition model&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;add_foreign_key :order_transitions, :orders, on_delete: :cascade&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing Statesman Implementations&lt;/h2&gt; &#xA;&lt;p&gt;This answer was abstracted from &lt;a href=&#34;https://github.com/gocardless/statesman/issues/77&#34;&gt;this issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;At GoCardless we focus on testing that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;guards correctly prevent / allow transitions&lt;/li&gt; &#xA; &lt;li&gt;callbacks execute when expected and perform the expected actions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Testing Guards&lt;/h4&gt; &#xA;&lt;p&gt;Guards can be tested by asserting that &lt;code&gt;transition_to!&lt;/code&gt; does or does not raise a &lt;code&gt;Statesman::GuardFailedError&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;describe &#34;guards&#34; do&#xA;  it &#34;cannot transition from state foo to state bar&#34; do&#xA;    expect { some_model.transition_to!(:bar) }.to raise_error(Statesman::GuardFailedError)&#xA;  end&#xA;&#xA;  it &#34;can transition from state foo to state baz&#34; do&#xA;    expect { some_model.transition_to!(:baz) }.to_not raise_error&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Testing Callbacks&lt;/h4&gt; &#xA;&lt;p&gt;Callbacks are tested by asserting that the action they perform occurs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;describe &#34;some callback&#34; do&#xA;  it &#34;adds one to the count property on the model&#34; do&#xA;    expect { some_model.transition_to!(:some_state) }.&#xA;      to change { some_model.reload.count }.&#xA;      by(1)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compatibility with type checkers&lt;/h2&gt; &#xA;&lt;p&gt;Including ActiveRecordQueries to your model can cause issues with type checkers such as Sorbet, this is because this technically is using a dynamic include, which is not supported by Sorbet.&lt;/p&gt; &#xA;&lt;p&gt;To avoid these issues you can instead include the TypeSafeActiveRecordQueries module and pass in configuration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Order &amp;lt; ActiveRecord::Base&#xA;  has_many :order_transitions, autosave: false&#xA;&#xA;  include Statesman::Adapters::TypeSafeActiveRecordQueries&#xA;&#xA;  configure_state_machine transition_class: OrderTransition,&#xA;                          initial_state: :pending&#xA;&#xA;  def state_machine&#xA;    @state_machine ||= OrderStateMachine.new(self, transition_class: OrderTransition)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Third-party extensions&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/badosu/statesman-sequel&#34;&gt;statesman-sequel&lt;/a&gt; - An adapter to make Statesman work with &lt;a href=&#34;https://github.com/jeremyevans/sequel&#34;&gt;Sequel&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;GoCardless ♥ open source. If you do too, come &lt;a href=&#34;https://gocardless.com/about/careers/&#34;&gt;join us&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>rubocop/rubocop-minitest</title>
    <updated>2023-10-10T01:39:22Z</updated>
    <id>tag:github.com,2023-10-10:/rubocop/rubocop-minitest</id>
    <link href="https://github.com/rubocop/rubocop-minitest" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Code style checking for Minitest files.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;RuboCop Minitest&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://badge.fury.io/rb/rubocop-minitest&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/rubocop-minitest.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/rubocop/rubocop-minitest&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/rubocop/rubocop-minitest.svg?style=svg&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://github.com/rubocop/rubocop&#34;&gt;RuboCop&lt;/a&gt; extension focused on enforcing &lt;a href=&#34;https://github.com/minitest/minitest&#34;&gt;Minitest&lt;/a&gt; best practices and coding conventions. The library is based on the guidelines outlined in the community &lt;a href=&#34;https://minitest.rubystyle.guide&#34;&gt;Minitest Style Guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Just install the &lt;code&gt;rubocop-minitest&lt;/code&gt; gem&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gem install rubocop-minitest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or if you use bundler put this in your &lt;code&gt;Gemfile&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;rubocop-minitest&#39;, require: false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;You need to tell RuboCop to load the Minitest extension. There are three ways to do this:&lt;/p&gt; &#xA;&lt;h3&gt;RuboCop configuration file&lt;/h3&gt; &#xA;&lt;p&gt;Put this into your &lt;code&gt;.rubocop.yml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;require: rubocop-minitest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, use the following array notation when specifying multiple extensions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;require:&#xA;  - rubocop-other-extension&#xA;  - rubocop-minitest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can run &lt;code&gt;rubocop&lt;/code&gt; and it will automatically load the RuboCop Minitest cops together with the standard cops.&lt;/p&gt; &#xA;&lt;h3&gt;Command line&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ rubocop --require rubocop-minitest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rake task&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;RuboCop::RakeTask.new do |task|&#xA;  task.requires &amp;lt;&amp;lt; &#39;rubocop-minitest&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;The Cops&lt;/h2&gt; &#xA;&lt;p&gt;All cops are located under &lt;a href=&#34;https://raw.githubusercontent.com/rubocop/rubocop-minitest/master/lib/rubocop/cop/minitest&#34;&gt;&lt;code&gt;lib/rubocop/cop/minitest&lt;/code&gt;&lt;/a&gt;, and contain examples/documentation. The documentation is published &lt;a href=&#34;https://docs.rubocop.org/rubocop-minitest/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In your &lt;code&gt;.rubocop.yml&lt;/code&gt;, you may treat the Minitest cops just like any other cop. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;Minitest/AssertNil:&#xA;  Exclude:&#xA;    - test/my_file_to_ignore_test.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;You can read a lot more about RuboCop Minitest in its &lt;a href=&#34;https://docs.rubocop.org/rubocop-minitest/&#34;&gt;official docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Readme Badge&lt;/h2&gt; &#xA;&lt;p&gt;If you use RuboCop Minitest in your project, you can include one of these badges in your readme to let people know that your code is written following the community Minitest Style Guide.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rubocop/rubocop-minitest&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/code_style-rubocop-brightgreen.svg?sanitize=true&#34; alt=&#34;Minitest Style Guide&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://minitest.rubystyle.guide&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/code_style-community-brightgreen.svg?sanitize=true&#34; alt=&#34;Minitest Style Guide&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here are the Markdown snippets for the two badges:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[![Minitest Style Guide](https://img.shields.io/badge/code_style-rubocop-brightgreen.svg)](https://github.com/rubocop/rubocop-minitest)&#xA;&#xA;[![Minitest Style Guide](https://img.shields.io/badge/code_style-community-brightgreen.svg)](https://minitest.rubystyle.guide)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Checkout the &lt;a href=&#34;https://raw.githubusercontent.com/rubocop/rubocop-minitest/master/CONTRIBUTING.md&#34;&gt;contribution guidelines&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;rubocop-minitest&lt;/code&gt; is MIT licensed. &lt;a href=&#34;https://raw.githubusercontent.com/rubocop/rubocop-minitest/master/LICENSE.txt&#34;&gt;See the accompanying file&lt;/a&gt; for the full text.&lt;/p&gt;</summary>
  </entry>
</feed>