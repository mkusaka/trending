<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-14T01:36:31Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>learn-co-curriculum/phase-4-rails-resources-update</title>
    <updated>2023-08-14T01:36:31Z</updated>
    <id>tag:github.com,2023-08-14:/learn-co-curriculum/phase-4-rails-resources-update</id>
    <link href="https://github.com/learn-co-curriculum/phase-4-rails-resources-update" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rails Resource Routing: Update&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update a resource using Rails&lt;/li&gt; &#xA; &lt;li&gt;Define custom routes in addition to &lt;code&gt;resources&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;In this lesson, we&#39;ll continue working on our Bird API by adding an &lt;code&gt;update&lt;/code&gt; action, so that clients can use our API to update birds. To get set up, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle install&#xA;$ rails db:migrate db:seed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will download all the dependencies for our app and set up the database.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;HTTP Verb&lt;/th&gt; &#xA;   &lt;th&gt;Path&lt;/th&gt; &#xA;   &lt;th&gt;Controller#Action&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GET&lt;/td&gt; &#xA;   &lt;td&gt;/birds&lt;/td&gt; &#xA;   &lt;td&gt;birds#index&lt;/td&gt; &#xA;   &lt;td&gt;Show all birds&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;POST&lt;/td&gt; &#xA;   &lt;td&gt;/birds&lt;/td&gt; &#xA;   &lt;td&gt;birds#create&lt;/td&gt; &#xA;   &lt;td&gt;Create a new bird&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GET&lt;/td&gt; &#xA;   &lt;td&gt;/birds/:id&lt;/td&gt; &#xA;   &lt;td&gt;birds#show&lt;/td&gt; &#xA;   &lt;td&gt;Show a specific bird&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;PATCH or PUT&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;/birds/:id&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;birds#update&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Update a specific bird&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DELETE&lt;/td&gt; &#xA;   &lt;td&gt;/birds/:id&lt;/td&gt; &#xA;   &lt;td&gt;birds#destroy&lt;/td&gt; &#xA;   &lt;td&gt;Delete a specific bird&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;!-- ## Video Walkthrough --&gt; &#xA;&lt;!-- &amp;lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/Q_ddDjw1hQ8?rel=0&amp;amp;showinfo=0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&amp;lt;/iframe&gt; --&gt; &#xA;&lt;h2&gt;Adding Features&lt;/h2&gt; &#xA;&lt;p&gt;Our birding app has grown wildly in popularity, which means it&#39;s time to add a new feature to keep our users happy! Market research suggests we can increase user engagement by adding a &#34;like&#34; feature to our application. To do this, we&#39;ll need to update our &lt;code&gt;Bird&lt;/code&gt; model to keep track of the number of likes.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ll also need to create a new API endpoint so that users can update the number of likes for a specific bird.&lt;/p&gt; &#xA;&lt;h2&gt;Changing Our Model With Migrations&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s start by creating a new migration to update our &lt;code&gt;Bird&lt;/code&gt; model and the associated &lt;code&gt;birds&lt;/code&gt; table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ rails g migration AddLikesToBird likes:integer --no-test-framework&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: the &lt;code&gt;--no-test-framework&lt;/code&gt; argument isn&#39;t actually needed in this case because the Rails migration generator does not create tests. However, it doesn&#39;t hurt to include it so we do so to encourage the habit.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This will create a new migration file for updating our &lt;code&gt;birds&lt;/code&gt; table with a new column for &lt;code&gt;likes&lt;/code&gt;. Let&#39;s also add a default value of 0 likes, and ensure we&#39;re not permitting null values to be saved to the likes column:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class AddLikesToBird &amp;lt; ActiveRecord::Migration[6.1]&#xA;  def change&#xA;    add_column :birds, :likes, :integer, null: false, default: 0&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;For a refresher on migrations, check out the &lt;a href=&#34;https://guides.rubyonrails.org/active_record_migrations.html&#34;&gt;Active Record docs&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Next, run the migration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ rails db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;ll also want to re-seed our database. You can do so with this command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ rails db:reset&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will drop our old development database, and re-create it from scratch based on our schema and seed file.&lt;/p&gt; &#xA;&lt;p&gt;With our data set up, let&#39;s turn to the next action: updating likes!&lt;/p&gt; &#xA;&lt;h2&gt;Updating Existing Birds&lt;/h2&gt; &#xA;&lt;p&gt;To start, we&#39;ll need to create a new route and controller action to give our clients the ability to update birds. Recall that following RESTful conventions, we&#39;ll want to set up a &lt;code&gt;PATCH /birds/:id&lt;/code&gt; route. Just like for our &lt;code&gt;show&lt;/code&gt; route, we need the ID in the URL to identify &lt;strong&gt;which&lt;/strong&gt; bird is being updated.&lt;/p&gt; &#xA;&lt;p&gt;We can use &lt;code&gt;resources&lt;/code&gt; to add this route by adding the &lt;code&gt;:update&lt;/code&gt; action in our &lt;code&gt;routes.rb&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;resources :birds, only: [:index, :show, :create, :update]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, add an &lt;code&gt;update&lt;/code&gt; action in our controller. Our goal in this action is to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;find the bird that matches the ID from the route params&lt;/li&gt; &#xA; &lt;li&gt;update the bird using the params from the body of the request&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class BirdsController &amp;lt; ApplicationController&#xA;&#xA;  # rest of actions here...&#xA;&#xA;  # PATCH /birds/:id&#xA;  def update&#xA;    bird = Bird.find_by(id: params[:id])&#xA;    if bird&#xA;      bird.update(bird_params)&#xA;      render json: bird&#xA;    else&#xA;      render json: { error: &#34;Bird not found&#34; }, status: :not_found&#xA;    end&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Just like in the &lt;code&gt;create&lt;/code&gt; action, we are using strong params when updating the bird. We can modify the strong params in the &lt;code&gt;bird_params&lt;/code&gt; method to allow the &lt;code&gt;likes&lt;/code&gt; as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def bird_params&#xA;  params.permit(:name, :species, :likes)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run &lt;code&gt;rails s&lt;/code&gt; and test out this route in Postman. Try updating the likes for one specific bird:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;PATCH /birds/1&#xA;&#xA;&#xA;Headers&#xA;-------&#xA;Content-Type: application/json&#xA;&#xA;&#xA;Request Body&#xA;------&#xA;{&#xA;  &#34;likes&#34;: 1&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we had the client application built out, to implement this feature, we would add a &#34;Like&#34; button to each bird&#39;s information. When the button is clicked, the frontend code would access the current value of &lt;code&gt;likes&lt;/code&gt;, add 1 to it, then send that information in the request body of a &lt;code&gt;PUT&lt;/code&gt; OR &lt;code&gt;PATCH&lt;/code&gt; request. But responsibility for keeping track of and updating the likes doesn&#39;t really belong in the frontend. To fix this, we can use a custom route.&lt;/p&gt; &#xA;&lt;h2&gt;Creating Custom Routes&lt;/h2&gt; &#xA;&lt;p&gt;To take the responsibility for handling likes off of the frontend, we can provide a &lt;strong&gt;custom route&lt;/strong&gt; that will do the work of calculating the number of likes and incrementing it. With this approach, all the frontend has to do is send a request to our new custom route, without worrying about sending any data in the body of the request.&lt;/p&gt; &#xA;&lt;p&gt;Update the &lt;code&gt;routes.rb&lt;/code&gt; file like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;Rails.application.routes.draw do&#xA;  resources :birds, only: [:index, :show, :create, :update]&#xA;  patch &#34;/birds/:id/like&#34;, to: &#34;birds#increment_likes&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then create the &lt;code&gt;increment_likes&lt;/code&gt; controller action:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def increment_likes&#xA;  bird = Bird.find_by(id: params[:id])&#xA;  if bird&#xA;    bird.update(likes: bird.likes + 1)&#xA;    render json: bird&#xA;  else&#xA;    render json: { error: &#34;Bird not found&#34; }, status: :not_found&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that in this action, the only information we need from &lt;code&gt;params&lt;/code&gt; is the &lt;code&gt;id&lt;/code&gt;; we&#39;re able to use the bird&#39;s current number of likes to calculate the next number of likes! Our client app no longer needs to concern itself with sending that data or performing that calculation.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;A note on breaking convention: by creating this custom route, we are breaking the REST conventions we had been following up to this point. One alternate way to structure this kind of feature and keep our routes and controllers RESTful would be to create a new controller, such as Birds::LikesController, and add an &lt;code&gt;update&lt;/code&gt; action in this controller. The creator of Rails, DHH, advocates for &lt;a href=&#34;http://jeromedalbert.com/how-dhh-organizes-his-rails-controllers/&#34;&gt;this approach for managing sub-resources&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;Continuing on our journey with REST and CRUD, we&#39;ve seen how to update a record, using &lt;code&gt;PATCH /birds/:id&lt;/code&gt;. We also saw how to break RESTful conventions and create a custom route.&lt;/p&gt; &#xA;&lt;h2&gt;Check For Understanding&lt;/h2&gt; &#xA;&lt;p&gt;Before you move on, make sure you can answer the following questions:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Under what circumstances does it make sense to create a custom route?&lt;/li&gt; &#xA; &lt;li&gt;What are the advantages and disadvantages of using custom routes?&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://guides.rubyonrails.org/active_record_migrations.html&#34;&gt;Active Record Migrations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://jeromedalbert.com/how-dhh-organizes-his-rails-controllers/&#34;&gt;How DHH Organizes His Rails Controllers&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>