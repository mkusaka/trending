<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-27T01:42:20Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pawurb/rails-brotli-cache</title>
    <updated>2023-05-27T01:42:20Z</updated>
    <id>tag:github.com,2023-05-27:/pawurb/rails-brotli-cache</id>
    <link href="https://github.com/pawurb/rails-brotli-cache" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Drop-in enhancement for Rails cache, offering better performance and compression with Brotli algorithm&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rails Brotli Cache &lt;a href=&#34;https://badge.fury.io/rb/rails-brotli-cache&#34;&gt;&lt;img src=&#34;https://img.shields.io/gem/v/rails-brotli-cache&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/pawurb/rails-brotli-cache&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/pawurb/rails-brotli-cache.svg?style=svg&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;This gem enables support for compressing Ruby on Rails cache entries using the &lt;a href=&#34;https://github.com/google/brotli&#34;&gt;Brotli compression algorithm&lt;/a&gt;. &lt;code&gt;RailsBrotliCache::Store&lt;/code&gt; offers better compression and performance compared to the default &lt;code&gt;Rails.cache&lt;/code&gt; Gzip, regardless of the underlying data store. The gem also allows specifying any custom compression algorithm instead of Brotli.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m currently working on a post describing the gem in more detail. You can subscribe to &lt;a href=&#34;https://eepurl.com/dhuFg5&#34;&gt;my blog&#39;s mailing list&lt;/a&gt; or &lt;a href=&#34;https://twitter.com/_pawurb&#34;&gt;follow me on Twitter&lt;/a&gt; to get notified when it&#39;s out.&lt;/p&gt; &#xA;&lt;h2&gt;Benchmarks&lt;/h2&gt; &#xA;&lt;p&gt;Brotli cache works as a proxy layer wrapping the standard cache data store. It applies Brotli compression instead of the default Gzip before storing cache entries.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis_cache = ActiveSupport::Cache::RedisCacheStore.new(&#xA;  url: &#34;redis://localhost:6379&#34;&#xA;)&#xA;brotli_redis_cache = RailsBrotliCache::Store.new(redis_cache)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;~25%&lt;/strong&gt; better compression of a sample JSON object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;json = File.read(&#34;sample.json&#34;) # sample 435kb JSON text&#xA;json.size # =&amp;gt; 435662&#xA;redis_cache.write(&#34;json&#34;, json)&#xA;brotli_redis_cache.write(&#34;json&#34;, json)&#xA;&#xA;## Check the size of cache entries stored in Redis&#xA;redis = Redis.new(url: &#34;redis://localhost:6379&#34;)&#xA;redis.get(&#34;json&#34;).size # =&amp;gt; 31698 ~31kb&#xA;redis.get(&#34;br-json&#34;).size # =&amp;gt; 24058 ~24kb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;~20%&lt;/strong&gt; better compression of a sample ActiveRecord objects array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;users = User.limit(100).to_a # 100 ActiveRecord objects&#xA;redis_cache.write(&#34;users&#34;, users)&#xA;brotli_redis_cache.write(&#34;users&#34;, users)&#xA;&#xA;redis.get(&#34;users&#34;).size # =&amp;gt; 12331 ~12kb&#xA;redis.get(&#34;br-users&#34;).size # =&amp;gt; 10299 ~10kb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;~25%&lt;/strong&gt; faster performance for reading/writing a larger JSON file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;json = File.read(&#34;sample.json&#34;) # sample ~1mb JSON text&#xA;&#xA;Benchmark.bm do |x|&#xA;  x.report(&#34;redis_cache&#34;) do&#xA;    100.times do&#xA;      redis_cache.write(&#34;test&#34;, json)&#xA;      redis_cache.read(&#34;test&#34;)&#xA;    end&#xA;  end&#xA;&#xA;  x.report(&#34;brotli_redis_cache&#34;) do&#xA;    100.times do&#xA;      brotli_redis_cache.write(&#34;test&#34;, json)&#xA;      brotli_redis_cache.read(&#34;test&#34;)&#xA;    end&#xA;  end&#xA;&#xA;  # ...&#xA;end&#xA;&#xA;# redis_cache  1.782225   0.049936   1.832161 (  2.523317)&#xA;# brotli_redis_cache  1.218365   0.051084   1.269449 (  1.850894)&#xA;# memcached_cache  1.766268   0.045351   1.811619 (  2.504233)&#xA;# brotli_memcached_cache  1.194646   0.051750   1.246396 (  1.752982)&#xA;# file_cache  1.727967   0.071138   1.799105 (  1.799229)&#xA;# brotli_file_cache  1.128514   0.044308   1.172822 (  1.172983)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Regardless of the underlying data store, Brotli cache offers 20%-40% performance improvement.&lt;/p&gt; &#xA;&lt;p&gt;You can run the benchmarks by executing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;cp docker-compose.yml.sample docker-compose.yml&#xA;docker compose up -d&#xA;cd benchmarks&#xA;bundle install&#xA;bundle exec ruby main.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Gem works as a drop-in replacement for a standard Rails cache store. You can configure it with different store types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.cache_store = RailsBrotliCache::Store.new(&#xA;  ActiveSupport::Cache::RedisCacheStore.new(url: &#34;redis://localhost:6379&#34;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.cache_store = RailsBrotliCache::Store.new(&#xA;  ActiveSupport::Cache::MemCacheStore.new(&#34;localhost:11211&#34;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.cache_store = RailsBrotliCache::Store.new(&#xA;  ActiveSupport::Cache::FileStore.new(&#39;/tmp&#39;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should avoid using it with &lt;code&gt;ActiveSupport::Cache::MemoryStore&lt;/code&gt;. This type of cache store does not serialize or compress objects but keeps them directly in the RAM. In this case, adding this gem would reduce RAM usage but add huge performance overhead.&lt;/p&gt; &#xA;&lt;p&gt;Gem appends &lt;code&gt;br-&lt;/code&gt; to the cache key names to prevent conflicts with previously saved entries. You can disable this behavior by passing &lt;code&gt;{ prefix: nil }&lt;/code&gt; during initialization:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.cache_store = RailsBrotliCache::Store.new(&#xA;  ActiveSupport::Cache::RedisCacheStore.new,&#xA;  { prefix: nil }&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Addition of the prefix means that you can safely add the Brotli the cache config and avoid compression algorithm conflicts between old and new entries. After configuring the Brotli cache you should run &lt;code&gt;Rails.cache.clear&lt;/code&gt; to remove the outdated (gzipped) entries.&lt;/p&gt; &#xA;&lt;h3&gt;Use a custom compressor class&lt;/h3&gt; &#xA;&lt;p&gt;By default gem uses a Brotli compression, but you can customize the algorithm. You can pass a &lt;code&gt;compressor_class&lt;/code&gt; object as a store configuration argument or directly to &lt;code&gt;read/write/fetch&lt;/code&gt; methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.cache_store = RailsBrotliCache::Store.new(&#xA;  ActiveSupport::Cache::RedisCacheStore.new,&#xA;  { compressor_class: Snappy }&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.cache.write(&#39;test-key&#39;, json, compressor_class: Snappy)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This config expects a class which defines two class methods &lt;code&gt;inflate&lt;/code&gt; and &lt;code&gt;deflate&lt;/code&gt;. It allows you to instead use for example a &lt;a href=&#34;https://github.com/miyucy/snappy&#34;&gt;Google Snappy algorithm&lt;/a&gt; offering even better performance for the cost of worse compresion ratios. Optionally, you can define a custom class wrapping any compression library.&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp docker-compose.yml.sample docker-compose.yml&#xA;docker compose up -d&#xA;rake test_all&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>