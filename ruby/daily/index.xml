<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-05T01:32:47Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bblimke/webmock</title>
    <updated>2022-08-05T01:32:47Z</updated>
    <id>tag:github.com,2022-08-05:/bblimke/webmock</id>
    <link href="https://github.com/bblimke/webmock" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Library for stubbing and setting expectations on HTTP requests in Ruby.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;WebMock&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://badge.fury.io/rb/webmock&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/webmock.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bblimke/webmock/actions&#34;&gt;&lt;img src=&#34;https://github.com/bblimke/webmock/workflows/CI/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/bblimke/webmock&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/bblimke/webmock/badges/gpa.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/markets/awesome-ruby&#34;&gt;&lt;img src=&#34;https://awesome.re/mentioned-badge.svg?sanitize=true&#34; alt=&#34;Mentioned in Awesome Ruby&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://inch-ci.org/github/bblimke/webmock&#34;&gt;&lt;img src=&#34;http://inch-ci.org/github/bblimke/webmock.svg?branch=master&#34; alt=&#34;Inline docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://dependabot.com/compatibility-score.html?dependency-name=webmock&amp;amp;package-manager=bundler&amp;amp;version-scheme=semver&#34;&gt;&lt;img src=&#34;https://api.dependabot.com/badges/compatibility_score?dependency-name=webmock&amp;amp;package-manager=bundler&amp;amp;version-scheme=semver&#34; alt=&#34;SemVer&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Library for stubbing and setting expectations on HTTP requests in Ruby.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Stubbing HTTP requests at low http client lib level (no need to change tests when you change HTTP library)&lt;/li&gt; &#xA; &lt;li&gt;Setting and verifying expectations on HTTP requests&lt;/li&gt; &#xA; &lt;li&gt;Matching requests based on method, URI, headers and body&lt;/li&gt; &#xA; &lt;li&gt;Smart matching of the same URIs in different representations (also encoded and non encoded forms)&lt;/li&gt; &#xA; &lt;li&gt;Smart matching of the same headers in different representations.&lt;/li&gt; &#xA; &lt;li&gt;Support for Test::Unit&lt;/li&gt; &#xA; &lt;li&gt;Support for RSpec&lt;/li&gt; &#xA; &lt;li&gt;Support for MiniTest&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Supported HTTP libraries&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/socketry/async-http&#34;&gt;Async::HTTP::Client&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/taf2/curb&#34;&gt;Curb&lt;/a&gt; (currently only Curb::Easy)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/igrigorik/em-http-request&#34;&gt;EM-HTTP-Request&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/excon/excon&#34;&gt;Excon&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nahi/httpclient&#34;&gt;HTTPClient&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/httprb/http&#34;&gt;HTTP Gem (also known as http.rb)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://honeyryderchuck.gitlab.io/httpx/wiki/Webmock-Adapter&#34;&gt;httpx&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cheald/manticore&#34;&gt;Manticore&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ruby-doc.org/stdlib-2.7.0/libdoc/net/http/rdoc/Net/HTTP.html&#34;&gt;Net::HTTP&lt;/a&gt; and other libraries based on Net::HTTP, e.g.: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/jnunemaker/httparty&#34;&gt;HTTParty&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/rest-client/rest-client&#34;&gt;REST Client&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/toland/patron&#34;&gt;Patron&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/typhoeus/typhoeus&#34;&gt;Typhoeus&lt;/a&gt; (currently only Typhoeus::Hydra)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Supported Ruby Interpreters&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MRI 2.5&lt;/li&gt; &#xA; &lt;li&gt;MRI 2.6&lt;/li&gt; &#xA; &lt;li&gt;MRI 2.7&lt;/li&gt; &#xA; &lt;li&gt;JRuby&lt;/li&gt; &#xA; &lt;li&gt;Rubinius&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    gem install webmock&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or alternatively:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    # add to your Gemfile&#xA;    group :test do&#xA;        gem &#34;webmock&#34;&#xA;    end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;or to install the latest development version from github master&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone http://github.com/bblimke/webmock.git&#xA;cd webmock&#xA;rake install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Upgrading from v1.x to v2.x&lt;/h2&gt; &#xA;&lt;p&gt;WebMock 2.x has changed somewhat since version 1.x. Changes are listed in &lt;a href=&#34;https://raw.githubusercontent.com/bblimke/webmock/master/CHANGELOG.md&#34;&gt;CHANGELOG.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Cucumber&lt;/h3&gt; &#xA;&lt;p&gt;Create a file &lt;code&gt;features/support/webmock.rb&lt;/code&gt; with the following contents:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock/cucumber&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MiniTest&lt;/h3&gt; &#xA;&lt;p&gt;Add the following code to &lt;code&gt;test/test_helper&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock/minitest&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;RSpec&lt;/h3&gt; &#xA;&lt;p&gt;Add the following code to &lt;code&gt;spec/spec_helper&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock/rspec&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Test::Unit&lt;/h3&gt; &#xA;&lt;p&gt;Add the following code to &lt;code&gt;test/test_helper.rb&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock/test_unit&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Outside a test framework&lt;/h3&gt; &#xA;&lt;p&gt;You can also use WebMock outside a test framework:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock&#39;&#xA;include WebMock::API&#xA;&#xA;WebMock.enable!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;h2&gt;Stubbing&lt;/h2&gt; &#xA;&lt;h3&gt;Stubbed request based on uri only and with the default response&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#34;www.example.com&#34;)&#xA;&#xA;Net::HTTP.get(&#34;www.example.com&#34;, &#34;/&#34;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stubbing requests based on method, uri, body and headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:post, &#34;www.example.com&#34;).&#xA;  with(body: &#34;abc&#34;, headers: { &#39;Content-Length&#39; =&amp;gt; 3 })&#xA;&#xA;uri = URI.parse(&#34;http://www.example.com/&#34;)&#xA;req = Net::HTTP::Post.new(uri.path)&#xA;req[&#39;Content-Length&#39;] = 3&#xA;&#xA;res = Net::HTTP.start(uri.host, uri.port) do |http|&#xA;  http.request(req, &#34;abc&#34;)&#xA;end    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching request body and headers against regular expressions&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:post, &#34;www.example.com&#34;).&#xA;  with(body: /world$/, headers: {&#34;Content-Type&#34; =&amp;gt; /image\/.+/}).&#xA;  to_return(body: &#34;abc&#34;)&#xA;&#xA;uri = URI.parse(&#39;http://www.example.com/&#39;)&#xA;req = Net::HTTP::Post.new(uri.path)&#xA;req[&#39;Content-Type&#39;] = &#39;image/png&#39;&#xA;&#xA;res = Net::HTTP.start(uri.host, uri.port) do |http|&#xA;  http.request(req, &#39;hello world&#39;)&#xA;end    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching request body against a hash. Body can be URL-Encoded, JSON or XML.&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:post, &#34;www.example.com&#34;).&#xA;  with(body: {data: {a: &#39;1&#39;, b: &#39;five&#39;}})&#xA;&#xA;RestClient.post(&#39;www.example.com&#39;, &#34;data[a]=1&amp;amp;data[b]=five&#34;,&#xA;  content_type: &#39;application/x-www-form-urlencoded&#39;)    # ===&amp;gt; Success&#xA;&#xA;RestClient.post(&#39;www.example.com&#39;, &#39;{&#34;data&#34;:{&#34;a&#34;:&#34;1&#34;,&#34;b&#34;:&#34;five&#34;}}&#39;,&#xA;  content_type: &#39;application/json&#39;)    # ===&amp;gt; Success&#xA;&#xA;RestClient.post(&#39;www.example.com&#39;, &#39;&amp;lt;data a=&#34;1&#34; b=&#34;five&#34; /&amp;gt;&#39;,&#xA;  content_type: &#39;application/xml&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching request body against partial hash.&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:post, &#34;www.example.com&#34;).&#xA;  with(body: hash_including({data: {a: &#39;1&#39;, b: &#39;five&#39;}}))&#xA;&#xA;RestClient.post(&#39;www.example.com&#39;, &#34;data[a]=1&amp;amp;data[b]=five&amp;amp;x=1&#34;,&#xA;:content_type =&amp;gt; &#39;application/x-www-form-urlencoded&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching custom request headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#34;www.example.com&#34;).&#xA;  with(headers:{ &#39;Header-Name&#39; =&amp;gt; &#39;Header-Value&#39; })&#xA;&#xA;uri = URI.parse(&#39;http://www.example.com/&#39;)&#xA;req = Net::HTTP::Post.new(uri.path)&#xA;req[&#39;Header-Name&#39;] = &#39;Header-Value&#39;&#xA;&#xA;res = Net::HTTP.start(uri.host, uri.port) do |http|&#xA;  http.request(req, &#39;abc&#39;)&#xA;end    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching multiple headers with the same name&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#39;www.example.com&#39;).&#xA;  with(headers: {&#39;Accept&#39; =&amp;gt; [&#39;image/jpeg&#39;, &#39;image/png&#39;] })&#xA;&#xA;req = Net::HTTP::Get.new(&#34;/&#34;)&#xA;req[&#39;Accept&#39;] = [&#39;image/png&#39;]&#xA;req.add_field(&#39;Accept&#39;, &#39;image/jpeg&#39;)&#xA;Net::HTTP.start(&#34;www.example.com&#34;) {|http| http.request(req) }    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching requests against provided block&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:post, &#34;www.example.com&#34;).with { |request| request.body == &#34;abc&#34; }&#xA;RestClient.post(&#39;www.example.com&#39;, &#39;abc&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Request with basic authentication header&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).with(basic_auth: [&#39;user&#39;, &#39;pass&#39;])&#xA;# or&#xA;# stub_request(:get, &#34;www.example.com&#34;).&#xA;#   with(headers: {&#39;Authorization&#39; =&amp;gt; &#34;Basic #{ Base64.strict_encode64(&#39;user:pass&#39;).chomp}&#34;})&#xA;&#xA;Net::HTTP.start(&#39;www.example.com&#39;) do |http|&#xA;  req = Net::HTTP::Get.new(&#39;/&#39;)&#xA;  req.basic_auth &#39;user&#39;, &#39;pass&#39;&#xA;  http.request(req)&#xA;end    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Important! Since version 2.0.0, WebMock does not match credentials provided in Authorization header and credentials provided in the userinfo of a url. I.e. &lt;code&gt;stub_request(:get, &#34;user:pass@www.example.com&#34;)&lt;/code&gt; does not match a request with credentials provided in the Authorization header.&lt;/h5&gt; &#xA;&lt;h3&gt;Request with basic authentication in the url&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;user:pass@www.example.com&#34;)&#xA;&#xA;RestClient.get(&#39;user:pass@www.example.com&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching uris using regular expressions&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, /example/)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching uris using lambda&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, -&amp;gt;(uri) { true })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching uris using RFC 6570 - Basic Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;uri_template = Addressable::Template.new &#34;www.example.com/{id}/&#34;&#xA;stub_request(:any, uri_template)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/webmock/&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching uris using RFC 6570 - Advanced Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;uri_template =&#xA;  Addressable::Template.new &#34;www.example.com/thing/{id}.json{?x,y,z}{&amp;amp;other*}&#34;&#xA;stub_request(:any, uri_template)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;,&#xA;  &#39;/thing/5.json?x=1&amp;amp;y=2&amp;amp;z=3&amp;amp;anyParam=4&#39;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching query params using hash&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).with(query: {&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]})&#xA;&#xA;RestClient.get(&#34;http://www.example.com/?a[]=b&amp;amp;a[]=c&#34;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching partial query params using hash&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).&#xA;  with(query: hash_including({&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]}))&#xA;&#xA;RestClient.get(&#34;http://www.example.com/?a[]=b&amp;amp;a[]=c&amp;amp;x=1&#34;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Matching partial query params using hash_excluding&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).&#xA;  with(query: hash_excluding({&#34;a&#34; =&amp;gt; &#34;b&#34;}))&#xA;&#xA;RestClient.get(&#34;http://www.example.com/?a=b&#34;)    # ===&amp;gt; Failure&#xA;RestClient.get(&#34;http://www.example.com/?a=c&#34;)    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stubbing with custom response&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#34;www.example.com&#34;).&#xA;  to_return(body: &#34;abc&#34;, status: 200,&#xA;    headers: { &#39;Content-Length&#39; =&amp;gt; 3 })&#xA;&#xA;Net::HTTP.get(&#34;www.example.com&#34;, &#39;/&#39;)    # ===&amp;gt; &#34;abc&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set appropriate Content-Type for HTTParty&#39;s &lt;code&gt;parsed_response&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#34;www.example.com&#34;).to_return body: &#39;{}&#39;, headers: {content_type: &#39;application/json&#39;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Response with body specified as IO object&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;File.open(&#39;/tmp/response_body.txt&#39;, &#39;w&#39;) { |f| f.puts &#39;abc&#39; }&#xA;&#xA;stub_request(:any, &#34;www.example.com&#34;).&#xA;  to_return(body: File.new(&#39;/tmp/response_body.txt&#39;), status: 200)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Response with custom status message&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#34;www.example.com&#34;).&#xA;  to_return(status: [500, &#34;Internal Server Error&#34;])&#xA;&#xA;req = Net::HTTP::Get.new(&#34;/&#34;)&#xA;Net::HTTP.start(&#34;www.example.com&#34;) { |http| http.request(req) }.&#xA;  message    # ===&amp;gt; &#34;Internal Server Error&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Replaying raw responses recorded with &lt;code&gt;curl -is&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl -is www.example.com &amp;gt; /tmp/example_curl_-is_output.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;raw_response_file = File.new(&#34;/tmp/example_curl_-is_output.txt&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;from file&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).to_return(raw_response_file)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or string&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).to_return(raw_response_file.read)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Responses dynamically evaluated from block&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).&#xA;  to_return { |request| {body: request.body} }&#xA;&#xA;RestClient.post(&#39;www.example.net&#39;, &#39;abc&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Responses dynamically evaluated from lambda&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).&#xA;  to_return(lambda { |request| {body: request.body} })&#xA;&#xA;RestClient.post(&#39;www.example.net&#39;, &#39;abc&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dynamically evaluated raw responses recorded with &lt;code&gt;curl -is&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;`curl -is www.example.com &amp;gt; /tmp/www.example.com.txt`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).&#xA;  to_return(lambda { |request| File.new(&#34;/tmp/#{request.uri.host.to_s}.txt&#34;) })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Responses with dynamically evaluated parts&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).&#xA;  to_return(body: lambda { |request| request.body })&#xA;&#xA;RestClient.post(&#39;www.example.net&#39;, &#39;abc&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rack responses&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyRackApp&#xA;  def self.call(env)&#xA;    [200, {}, [&#34;Hello&#34;]]&#xA;  end&#xA;end&#xA;&#xA;stub_request(:get, &#34;www.example.com&#34;).to_rack(MyRackApp)&#xA;&#xA;RestClient.post(&#39;www.example.com&#39;)    # ===&amp;gt; &#34;Hello&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Raising errors&lt;/h3&gt; &#xA;&lt;h4&gt;Exception declared by class&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).to_raise(StandardError)&#xA;&#xA;RestClient.post(&#39;www.example.net&#39;, &#39;abc&#39;)    # ===&amp;gt; StandardError&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;or by exception instance&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).to_raise(StandardError.new(&#34;some error&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;or by string&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).to_raise(&#34;some error&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Raising timeout errors&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#39;www.example.net&#39;).to_timeout&#xA;&#xA;RestClient.post(&#39;www.example.net&#39;, &#39;abc&#39;)    # ===&amp;gt; RestClient::RequestTimeout&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiple responses for repeated requests&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).&#xA;  to_return({body: &#34;abc&#34;}, {body: &#34;def&#34;})&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;def\n&#34;&#xA;&#xA;#after all responses are used the last response will be returned infinitely&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;def\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiple responses using chained &lt;code&gt;to_return()&lt;/code&gt;, &lt;code&gt;to_raise()&lt;/code&gt; or &lt;code&gt;to_timeout&lt;/code&gt; declarations&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).&#xA;  to_return({body: &#34;abc&#34;}).then.  #then() is just a syntactic sugar&#xA;  to_return({body: &#34;def&#34;}).then.&#xA;  to_raise(MyException)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;def\n&#34;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; MyException raised&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying number of times given response should be returned&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).&#xA;  to_return({body: &#34;abc&#34;}).times(2).then.&#xA;  to_return({body: &#34;def&#34;})&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;abc\n&#34;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;def\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Removing unused stubs&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_get = stub_request(:get, &#34;www.example.com&#34;)&#xA;remove_request_stub(stub_get)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Real requests to network can be allowed or disabled&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.allow_net_connect!&#xA;&#xA;stub_request(:any, &#34;www.example.com&#34;).to_return(body: &#34;abc&#34;)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; &#34;abc&#34;&#xA;&#xA;Net::HTTP.get(&#39;www.something.com&#39;, &#39;/&#39;)    # ===&amp;gt; /.+Something.+/&#xA;&#xA;WebMock.disable_net_connect!&#xA;&#xA;Net::HTTP.get(&#39;www.something.com&#39;, &#39;/&#39;)    # ===&amp;gt; Failure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;External requests can be disabled while allowing localhost&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.disable_net_connect!(allow_localhost: true)&#xA;&#xA;Net::HTTP.get(&#39;www.something.com&#39;, &#39;/&#39;)    # ===&amp;gt; Failure&#xA;&#xA;Net::HTTP.get(&#39;localhost:9887&#39;, &#39;/&#39;)    # ===&amp;gt; Allowed. Perhaps to Selenium?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;External requests can be disabled while allowing specific requests&lt;/h3&gt; &#xA;&lt;p&gt;Allowed requests can be specified in a number of ways.&lt;/p&gt; &#xA;&lt;p&gt;With a &lt;code&gt;String&lt;/code&gt; specifying a host name:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.disable_net_connect!(allow: &#39;www.example.org&#39;)&#xA;&#xA;RestClient.get(&#39;www.something.com&#39;, &#39;/&#39;)    # ===&amp;gt; Failure&#xA;RestClient.get(&#39;www.example.org&#39;, &#39;/&#39;)      # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;www.example.org:8080&#39;, &#39;/&#39;) # ===&amp;gt; Allowed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With a &lt;code&gt;String&lt;/code&gt; specifying a host name and a port:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.disable_net_connect!(allow: &#39;www.example.org:8080&#39;)&#xA;&#xA;RestClient.get(&#39;www.something.com&#39;, &#39;/&#39;)    # ===&amp;gt; Failure&#xA;RestClient.get(&#39;www.example.org&#39;, &#39;/&#39;)      # ===&amp;gt; Failure&#xA;RestClient.get(&#39;www.example.org:8080&#39;, &#39;/&#39;) # ===&amp;gt; Allowed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With a &lt;code&gt;Regexp&lt;/code&gt; matching the URI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.disable_net_connect!(allow: %r{ample.org/foo})&#xA;&#xA;RestClient.get(&#39;www.example.org&#39;, &#39;/foo/bar&#39;) # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;sample.org&#39;, &#39;/foo&#39;)          # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;sample.org&#39;, &#39;/bar&#39;)          # ===&amp;gt; Failure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With an object that responds to &lt;code&gt;#call&lt;/code&gt;, receiving a &lt;code&gt;URI&lt;/code&gt; object and returning a boolean:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;denylist = [&#39;google.com&#39;, &#39;facebook.com&#39;, &#39;apple.com&#39;]&#xA;allowed_sites = lambda{|uri|&#xA;  denylist.none?{|site| uri.host.include?(site) }&#xA;}&#xA;WebMock.disable_net_connect!(allow: allowed_sites)&#xA;&#xA;RestClient.get(&#39;www.example.org&#39;, &#39;/&#39;)  # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;www.facebook.com&#39;, &#39;/&#39;) # ===&amp;gt; Failure&#xA;RestClient.get(&#39;apple.com&#39;, &#39;/&#39;)        # ===&amp;gt; Failure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With an &lt;code&gt;Array&lt;/code&gt; of any of the above:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.disable_net_connect!(allow: [&#xA;  lambda{|uri| uri.host.length % 2 == 0 },&#xA;  /ample.org/,&#xA;  &#39;bbc.co.uk&#39;,&#xA;])&#xA;&#xA;RestClient.get(&#39;www.example.org&#39;, &#39;/&#39;) # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;bbc.co.uk&#39;, &#39;/&#39;)       # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;bbc.com&#39;, &#39;/&#39;)         # ===&amp;gt; Allowed&#xA;RestClient.get(&#39;www.bbc.com&#39;, &#39;/&#39;)     # ===&amp;gt; Failure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Connecting on Net::HTTP.start&lt;/h2&gt; &#xA;&lt;p&gt;HTTP protocol has 3 steps: connect, request and response (or 4 with close). Most Ruby HTTP client libraries treat connect as a part of request step, with the exception of &lt;code&gt;Net::HTTP&lt;/code&gt; which allows opening connection to the server separately to the request, by using &lt;code&gt;Net::HTTP.start&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;WebMock API was also designed with connect being part of request step, and it only allows stubbing requests, not connections. When &lt;code&gt;Net::HTTP.start&lt;/code&gt; is called, WebMock doesn&#39;t know yet whether a request is stubbed or not. WebMock by default delays a connection until the request is invoked, so when there is no request, &lt;code&gt;Net::HTTP.start&lt;/code&gt; doesn&#39;t do anything. &lt;strong&gt;This means that WebMock breaks the Net::HTTP behaviour by default!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;To workaround this issue, WebMock offers &lt;code&gt;:net_http_connect_on_start&lt;/code&gt; option, which can be passed to &lt;code&gt;WebMock.allow_net_connect!&lt;/code&gt; and &lt;code&gt;WebMock.disable_net_connect!&lt;/code&gt; methods, i.e.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.allow_net_connect!(net_http_connect_on_start: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This forces WebMock Net::HTTP adapter to always connect on &lt;code&gt;Net::HTTP.start&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Setting Expectations&lt;/h2&gt; &#xA;&lt;h3&gt;Setting expectations in Test::Unit&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock/test_unit&#39;&#xA;&#xA;stub_request(:any, &#34;www.example.com&#34;)&#xA;&#xA;uri = URI.parse(&#39;http://www.example.com/&#39;)&#xA;req = Net::HTTP::Post.new(uri.path)&#xA;req[&#39;Content-Length&#39;] = 3&#xA;&#xA;res = Net::HTTP.start(uri.host, uri.port) do |http|&#xA;  http.request(req, &#39;abc&#39;)&#xA;end&#xA;&#xA;assert_requested :post, &#34;http://www.example.com&#34;,&#xA;  headers: {&#39;Content-Length&#39; =&amp;gt; 3}, body: &#34;abc&#34;,&#xA;  times: 1    # ===&amp;gt; Success&#xA;&#xA;assert_not_requested :get, &#34;http://www.something.com&#34;    # ===&amp;gt; Success&#xA;&#xA;assert_requested(:post, &#34;http://www.example.com&#34;,&#xA;  times: 1) { |req| req.body == &#34;abc&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Expecting real (not stubbed) requests&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.allow_net_connect!&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; Success&#xA;&#xA;assert_requested :get, &#34;http://www.example.com&#34;    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setting expectations in Test::Unit on the stub&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_get = stub_request(:get, &#34;www.example.com&#34;)&#xA;stub_post = stub_request(:post, &#34;www.example.com&#34;)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)&#xA;&#xA;assert_requested(stub_get)&#xA;assert_not_requested(stub_post)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setting expectations in RSpec on &lt;code&gt;WebMock&lt;/code&gt; module&lt;/h3&gt; &#xA;&lt;p&gt;This style is borrowed from &lt;a href=&#34;http://github.com/pat/fakeweb-matcher&#34;&gt;fakeweb-matcher&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;webmock/rspec&#39;&#xA;&#xA;expect(WebMock).to have_requested(:get, &#34;www.example.com&#34;).&#xA;  with(body: &#34;abc&#34;, headers: {&#39;Content-Length&#39; =&amp;gt; 3}).twice&#xA;&#xA;expect(WebMock).not_to have_requested(:get, &#34;www.something.com&#34;)&#xA;&#xA;expect(WebMock).to have_requested(:post, &#34;www.example.com&#34;).&#xA;  with { |req| req.body == &#34;abc&#34; }&#xA;# Note that the block with `do ... end` instead of curly brackets won&#39;t work!&#xA;# Why? See this comment https://github.com/bblimke/webmock/issues/174#issuecomment-34908908&#xA;&#xA;expect(WebMock).to have_requested(:get, &#34;www.example.com&#34;).&#xA;  with(query: {&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]})&#xA;&#xA;expect(WebMock).to have_requested(:get, &#34;www.example.com&#34;).&#xA;  with(query: hash_including({&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]}))&#xA;&#xA;expect(WebMock).to have_requested(:get, &#34;www.example.com&#34;).&#xA;  with(body: {&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]},&#xA;    headers: {&#39;Content-Type&#39; =&amp;gt; &#39;application/json&#39;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setting expectations in RSpec with &lt;code&gt;a_request&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect(a_request(:post, &#34;www.example.com&#34;).&#xA;  with(body: &#34;abc&#34;, headers: {&#39;Content-Length&#39; =&amp;gt; 3})).&#xA;  to have_been_made.once&#xA;&#xA;expect(a_request(:post, &#34;www.something.com&#34;)).to have_been_made.times(3)&#xA;&#xA;expect(a_request(:post, &#34;www.something.com&#34;)).to have_been_made.at_least_once&#xA;&#xA;expect(a_request(:post, &#34;www.something.com&#34;)).&#xA;  to have_been_made.at_least_times(3)&#xA;&#xA;expect(a_request(:post, &#34;www.something.com&#34;)).to have_been_made.at_most_twice&#xA;&#xA;expect(a_request(:post, &#34;www.something.com&#34;)).to have_been_made.at_most_times(3)&#xA;&#xA;expect(a_request(:any, &#34;www.example.com&#34;)).not_to have_been_made&#xA;&#xA;expect(a_request(:post, &#34;www.example.com&#34;).with { |req| req.body == &#34;abc&#34; }).&#xA;  to have_been_made&#xA;&#xA;expect(a_request(:get, &#34;www.example.com&#34;).with(query: {&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]})).&#xA;  to have_been_made&#xA;&#xA;expect(a_request(:get, &#34;www.example.com&#34;).&#xA;  with(query: hash_including({&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]}))).to have_been_made&#xA;&#xA;expect(a_request(:post, &#34;www.example.com&#34;).&#xA;  with(body: {&#34;a&#34; =&amp;gt; [&#34;b&#34;, &#34;c&#34;]},&#xA;    headers: {&#39;Content-Type&#39; =&amp;gt; &#39;application/json&#39;})).to have_been_made&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setting expectations in RSpec on the stub&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub = stub_request(:get, &#34;www.example.com&#34;)&#xA;# ... make requests ...&#xA;expect(stub).to have_been_requested&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Clearing stubs and request history&lt;/h2&gt; &#xA;&lt;p&gt;If you want to reset all current stubs and history of requests use &lt;code&gt;WebMock.reset!&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:any, &#34;www.example.com&#34;)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; Success&#xA;&#xA;WebMock.reset!&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ===&amp;gt; Failure&#xA;&#xA;assert_not_requested :get, &#34;www.example.com&#34;    # ===&amp;gt; Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Clearing request counters&lt;/h2&gt; &#xA;&lt;p&gt;If you want to reset &lt;strong&gt;only&lt;/strong&gt; the counters of the executed requests use &lt;code&gt;WebMock.reset_executed_requests!&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub  = stub_request(:get, &#34;www.example.com&#34;)&#xA;stub2 = stub_request(:get, &#34;www.example2.com&#34;)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)&#xA;&#xA;Net::HTTP.get(&#39;www.example2.com&#39;, &#39;/&#39;)&#xA;&#xA;expect(stub).to have_been_requested.times(2)&#xA;expect(stub2).to have_been_requested.times(1)&#xA;&#xA;WebMock.reset_executed_requests!&#xA;&#xA;expect(stub).not_to have_been_requested&#xA;expect(stub2).not_to have_been_requested&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Disabling and enabling WebMock or only some http client adapters&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Disable WebMock (all adapters)&#xA;WebMock.disable!&#xA;&#xA;# Disable WebMock for all libs except Net::HTTP&#xA;WebMock.disable!(except: [:net_http])&#xA;&#xA;# Enable WebMock (all adapters)&#xA;WebMock.enable!&#xA;&#xA;# Enable WebMock for all libs except Patron&#xA;WebMock.enable!(except: [:patron])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Matching requests&lt;/h2&gt; &#xA;&lt;p&gt;An executed request matches stubbed request if it passes following criteria:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When request URI matches stubbed request URI string, Regexp pattern or RFC 6570 URI Template&lt;/li&gt; &#xA; &lt;li&gt;And request method is the same as stubbed request method or stubbed request method is :any&lt;/li&gt; &#xA; &lt;li&gt;And request body is the same as stubbed request body or stubbed request body is not specified&lt;/li&gt; &#xA; &lt;li&gt;And request headers match stubbed request headers, or stubbed request headers match a subset of request headers, or stubbed request headers are not specified&lt;/li&gt; &#xA; &lt;li&gt;And request matches provided block or block is not provided&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Precedence of stubs&lt;/h2&gt; &#xA;&lt;p&gt;Always the last declared stub matching the request will be applied i.e:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stub_request(:get, &#34;www.example.com&#34;).to_return(body: &#34;abc&#34;)&#xA;stub_request(:get, &#34;www.example.com&#34;).to_return(body: &#34;def&#34;)&#xA;&#xA;Net::HTTP.get(&#39;www.example.com&#39;, &#39;/&#39;)    # ====&amp;gt; &#34;def&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Matching URIs&lt;/h2&gt; &#xA;&lt;p&gt;WebMock will match all different representations of the same URI.&lt;/p&gt; &#xA;&lt;p&gt;I.e all the following representations of the URI are equal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#34;www.example.com&#34;&#xA;&#34;www.example.com/&#34;&#xA;&#34;www.example.com:80&#34;&#xA;&#34;www.example.com:80/&#34;&#xA;&#34;http://www.example.com&#34;&#xA;&#34;http://www.example.com/&#34;&#xA;&#34;http://www.example.com:80&#34;&#xA;&#34;http://www.example.com:80/&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following URIs with userinfo are also equal for WebMock&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#34;a b:pass@www.example.com&#34;&#xA;&#34;a b:pass@www.example.com/&#34;&#xA;&#34;a b:pass@www.example.com:80&#34;&#xA;&#34;a b:pass@www.example.com:80/&#34;&#xA;&#34;http://a b:pass@www.example.com&#34;&#xA;&#34;http://a b:pass@www.example.com/&#34;&#xA;&#34;http://a b:pass@www.example.com:80&#34;&#xA;&#34;http://a b:pass@www.example.com:80/&#34;&#xA;&#34;a%20b:pass@www.example.com&#34;&#xA;&#34;a%20b:pass@www.example.com/&#34;&#xA;&#34;a%20b:pass@www.example.com:80&#34;&#xA;&#34;a%20b:pass@www.example.com:80/&#34;&#xA;&#34;http://a%20b:pass@www.example.com&#34;&#xA;&#34;http://a%20b:pass@www.example.com/&#34;&#xA;&#34;http://a%20b:pass@www.example.com:80&#34;&#xA;&#34;http://a%20b:pass@www.example.com:80/&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or these&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#34;www.example.com/my path/?a=my param&amp;amp;b=c&#34;&#xA;&#34;www.example.com/my%20path/?a=my%20param&amp;amp;b=c&#34;&#xA;&#34;www.example.com:80/my path/?a=my param&amp;amp;b=c&#34;&#xA;&#34;www.example.com:80/my%20path/?a=my%20param&amp;amp;b=c&#34;&#xA;&#34;http://www.example.com/my path/?a=my param&amp;amp;b=c&#34;&#xA;&#34;http://www.example.com/my%20path/?a=my%20param&amp;amp;b=c&#34;&#xA;&#34;http://www.example.com:80/my path/?a=my param&amp;amp;b=c&#34;&#xA;&#34;http://www.example.com:80/my%20path/?a=my%20param&amp;amp;b=c&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you provide Regexp to match URI, WebMock will try to match it against every valid form of the same url.&lt;/p&gt; &#xA;&lt;p&gt;I.e &lt;code&gt;/my path/&lt;/code&gt; will match &lt;code&gt;www.example.com/my%20path&lt;/code&gt; because it is equivalent of &lt;code&gt;www.example.com/my path&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Matching with URI Templates&lt;/h2&gt; &#xA;&lt;p&gt;If you use &lt;a href=&#34;https://github.com/sporkmonger/addressable#uri-templates&#34;&gt;Addressable::Template&lt;/a&gt; for matching, then WebMock will defer the matching rules to Addressable, which complies with &lt;a href=&#34;http://tools.ietf.org/html/rfc6570&#34;&gt;RFC 6570&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you use any of the WebMock methods for matching query params, then Addressable will be used to match the base URI and WebMock will match the query params. If you do not, then WebMock will let Addressable match the full URI.&lt;/p&gt; &#xA;&lt;h2&gt;Matching headers&lt;/h2&gt; &#xA;&lt;p&gt;WebMock will match request headers against stubbed request headers in the following situations:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Stubbed request has headers specified and request headers are the same as stubbed headers &lt;br&gt; i.e stubbed headers: &lt;code&gt;{ &#39;Header1&#39; =&amp;gt; &#39;Value1&#39;, &#39;Header2&#39; =&amp;gt; &#39;Value2&#39; }&lt;/code&gt;, requested: &lt;code&gt;{ &#39;Header1&#39; =&amp;gt; &#39;Value1&#39;, &#39;Header2&#39; =&amp;gt; &#39;Value2&#39; }&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Stubbed request has headers specified and stubbed request headers are a subset of request headers &lt;br&gt; i.e stubbed headers: &lt;code&gt;{ &#39;Header1&#39; =&amp;gt; &#39;Value1&#39; }&lt;/code&gt;, requested: &lt;code&gt;{ &#39;Header1&#39; =&amp;gt; &#39;Value1&#39;, &#39;Header2&#39; =&amp;gt; &#39;Value2&#39; }&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Stubbed request has no headers &lt;br&gt; i.e stubbed headers: &lt;code&gt;nil&lt;/code&gt;, requested: &lt;code&gt;{ &#39;Header1&#39; =&amp;gt; &#39;Value1&#39;, &#39;Header2&#39; =&amp;gt; &#39;Value2&#39; }&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;WebMock normalises headers and treats all forms of same headers as equal: i.e the following two sets of headers are equal:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;{ &#34;Header1&#34; =&amp;gt; &#34;value1&#34;, content_length: 123, X_CuStOm_hEAder: :value }&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;{ header1: &#34;value1&#34;, &#34;Content-Length&#34; =&amp;gt; 123, &#34;x-cuSTOM-HeAder&#34; =&amp;gt; &#34;value&#34; }&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Recording real requests and responses and replaying them later&lt;/h2&gt; &#xA;&lt;p&gt;To record your application&#39;s real HTTP interactions and replay them later in tests you can use &lt;a href=&#34;https://github.com/vcr/vcr&#34;&gt;VCR&lt;/a&gt; with WebMock.&lt;/p&gt; &#xA;&lt;h2&gt;Request callbacks&lt;/h2&gt; &#xA;&lt;h4&gt;WebMock can invoke callbacks stubbed or real requests:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.after_request do |request_signature, response|&#xA;  puts &#34;Request #{request_signature} was made and #{response} was returned&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;invoke callbacks for real requests only and except requests made with Patron&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;WebMock.after_request(except: [:patron],&#xA;                      real_requests_only: true) do |req_signature, response|&#xA;  puts &#34;Request #{req_signature} was made and #{response} was returned&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Bugs and Issues&lt;/h2&gt; &#xA;&lt;p&gt;Please submit them here &lt;a href=&#34;http://github.com/bblimke/webmock/issues&#34;&gt;http://github.com/bblimke/webmock/issues&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Issue triage &lt;a href=&#34;https://www.codetriage.com/bblimke/webmock&#34;&gt;&lt;img src=&#34;https://www.codetriage.com/bblimke/webmock/badges/users.svg?sanitize=true&#34; alt=&#34;Open Source Helpers&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;You can contribute by triaging issues which may include reproducing bug reports or asking for vital information, such as version numbers or reproduction instructions. If you would like to start triaging issues, one easy way to get started is to &lt;a href=&#34;https://www.codetriage.com/bblimke/webmock&#34;&gt;subscribe to webmock on CodeTriage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Suggestions&lt;/h2&gt; &#xA;&lt;p&gt;If you have any suggestions on how to improve WebMock please send an email to the mailing list &lt;a href=&#34;http://groups.google.com/group/webmock-users&#34;&gt;groups.google.com/group/webmock-users&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m particularly interested in how the DSL could be improved.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;In order to work on Webmock you first need to fork and clone the repo. Please do any work on a dedicated branch and rebase against master before sending a pull request.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;The initial lines of this project were written during New Bamboo &lt;a href=&#34;http://blog.new-bamboo.co.uk/2009/11/13/hackday-results&#34;&gt;Hack Day&lt;/a&gt; Thanks to my fellow &lt;a href=&#34;http://new-bamboo.co.uk/&#34;&gt;Bambinos&lt;/a&gt; for all the great suggestions!&lt;/p&gt; &#xA;&lt;p&gt;People who submitted patches and new features or suggested improvements. Many thanks to these people:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ben Pickles&lt;/li&gt; &#xA; &lt;li&gt;Mark Evans&lt;/li&gt; &#xA; &lt;li&gt;Ivan Vega&lt;/li&gt; &#xA; &lt;li&gt;Piotr Usewicz&lt;/li&gt; &#xA; &lt;li&gt;Nick Plante&lt;/li&gt; &#xA; &lt;li&gt;Nick Quaranto&lt;/li&gt; &#xA; &lt;li&gt;Diego E. &#34;Flameeyes&#34; Pettenò&lt;/li&gt; &#xA; &lt;li&gt;Niels Meersschaert&lt;/li&gt; &#xA; &lt;li&gt;Mack Earnhardt&lt;/li&gt; &#xA; &lt;li&gt;Arvicco&lt;/li&gt; &#xA; &lt;li&gt;Sergio Gil&lt;/li&gt; &#xA; &lt;li&gt;Jeffrey Jones&lt;/li&gt; &#xA; &lt;li&gt;Tekin Suleyman&lt;/li&gt; &#xA; &lt;li&gt;Tom Ward&lt;/li&gt; &#xA; &lt;li&gt;Nadim Bitar&lt;/li&gt; &#xA; &lt;li&gt;Myron Marston&lt;/li&gt; &#xA; &lt;li&gt;Sam Phillips&lt;/li&gt; &#xA; &lt;li&gt;Jose Angel Cortinas&lt;/li&gt; &#xA; &lt;li&gt;Razic&lt;/li&gt; &#xA; &lt;li&gt;Steve Tooke&lt;/li&gt; &#xA; &lt;li&gt;Nathaniel Bibler&lt;/li&gt; &#xA; &lt;li&gt;Martyn Loughran&lt;/li&gt; &#xA; &lt;li&gt;Muness Alrubaie&lt;/li&gt; &#xA; &lt;li&gt;Charles Li&lt;/li&gt; &#xA; &lt;li&gt;Ryan Bigg&lt;/li&gt; &#xA; &lt;li&gt;Pete Higgins&lt;/li&gt; &#xA; &lt;li&gt;Hans de Graaff&lt;/li&gt; &#xA; &lt;li&gt;Alastair Brunton&lt;/li&gt; &#xA; &lt;li&gt;Sam Stokes&lt;/li&gt; &#xA; &lt;li&gt;Eugene Bolshakov&lt;/li&gt; &#xA; &lt;li&gt;James Conroy-Finn&lt;/li&gt; &#xA; &lt;li&gt;Salvador Fuentes Jr&lt;/li&gt; &#xA; &lt;li&gt;Alex Rothenberg&lt;/li&gt; &#xA; &lt;li&gt;Aidan Feldman&lt;/li&gt; &#xA; &lt;li&gt;Steve Hull&lt;/li&gt; &#xA; &lt;li&gt;Jay Adkisson&lt;/li&gt; &#xA; &lt;li&gt;Zach Dennis&lt;/li&gt; &#xA; &lt;li&gt;Nikita Fedyashev&lt;/li&gt; &#xA; &lt;li&gt;Lin Jen-Shin&lt;/li&gt; &#xA; &lt;li&gt;David Yeu&lt;/li&gt; &#xA; &lt;li&gt;Andreas Garnæs&lt;/li&gt; &#xA; &lt;li&gt;Roman Shterenzon&lt;/li&gt; &#xA; &lt;li&gt;Chris McGrath&lt;/li&gt; &#xA; &lt;li&gt;Stephen Celis&lt;/li&gt; &#xA; &lt;li&gt;Eugene Pimenov&lt;/li&gt; &#xA; &lt;li&gt;Albert Llop&lt;/li&gt; &#xA; &lt;li&gt;Christopher Pickslay&lt;/li&gt; &#xA; &lt;li&gt;Tammer Saleh&lt;/li&gt; &#xA; &lt;li&gt;Nicolas Fouché&lt;/li&gt; &#xA; &lt;li&gt;Joe Van Dyk&lt;/li&gt; &#xA; &lt;li&gt;Mark Abramov&lt;/li&gt; &#xA; &lt;li&gt;Frank Schumacher&lt;/li&gt; &#xA; &lt;li&gt;Dimitrij Denissenko&lt;/li&gt; &#xA; &lt;li&gt;Marnen Laibow-Koser&lt;/li&gt; &#xA; &lt;li&gt;Evgeniy Dolzhenko&lt;/li&gt; &#xA; &lt;li&gt;Nick Recobra&lt;/li&gt; &#xA; &lt;li&gt;Jordan Elver&lt;/li&gt; &#xA; &lt;li&gt;Joe Karayusuf&lt;/li&gt; &#xA; &lt;li&gt;Paul Cortens&lt;/li&gt; &#xA; &lt;li&gt;jugyo&lt;/li&gt; &#xA; &lt;li&gt;aindustries&lt;/li&gt; &#xA; &lt;li&gt;Eric Oestrich&lt;/li&gt; &#xA; &lt;li&gt;erwanlr&lt;/li&gt; &#xA; &lt;li&gt;Ben Bleything&lt;/li&gt; &#xA; &lt;li&gt;Jon Leighton&lt;/li&gt; &#xA; &lt;li&gt;Ryan Schlesinger&lt;/li&gt; &#xA; &lt;li&gt;Julien Boyer&lt;/li&gt; &#xA; &lt;li&gt;Kevin Glowacz&lt;/li&gt; &#xA; &lt;li&gt;Hans Hasselberg&lt;/li&gt; &#xA; &lt;li&gt;Andrew France&lt;/li&gt; &#xA; &lt;li&gt;Jonathan Hyman&lt;/li&gt; &#xA; &lt;li&gt;Rex Feng&lt;/li&gt; &#xA; &lt;li&gt;Pavel Forkert&lt;/li&gt; &#xA; &lt;li&gt;Jordi Massaguer Pla&lt;/li&gt; &#xA; &lt;li&gt;Jake Benilov&lt;/li&gt; &#xA; &lt;li&gt;Tom Beauvais&lt;/li&gt; &#xA; &lt;li&gt;Mokevnin Kirill&lt;/li&gt; &#xA; &lt;li&gt;Alex Grant&lt;/li&gt; &#xA; &lt;li&gt;Lucas Dohmen&lt;/li&gt; &#xA; &lt;li&gt;Bastien Vaucher&lt;/li&gt; &#xA; &lt;li&gt;Joost Baaij&lt;/li&gt; &#xA; &lt;li&gt;Joel Chippindale&lt;/li&gt; &#xA; &lt;li&gt;Murahashi Sanemat Kenichi&lt;/li&gt; &#xA; &lt;li&gt;Tim Kurvers&lt;/li&gt; &#xA; &lt;li&gt;Ilya Vassilevsky&lt;/li&gt; &#xA; &lt;li&gt;gotwalt&lt;/li&gt; &#xA; &lt;li&gt;Leif Bladt&lt;/li&gt; &#xA; &lt;li&gt;Alex Tomlins&lt;/li&gt; &#xA; &lt;li&gt;Mitsutaka Mimura&lt;/li&gt; &#xA; &lt;li&gt;Tomy Kaira&lt;/li&gt; &#xA; &lt;li&gt;Daniel van Hoesel&lt;/li&gt; &#xA; &lt;li&gt;Ian Asaff&lt;/li&gt; &#xA; &lt;li&gt;Ian Lesperance&lt;/li&gt; &#xA; &lt;li&gt;Matthew Horan&lt;/li&gt; &#xA; &lt;li&gt;Dmitry Gutov&lt;/li&gt; &#xA; &lt;li&gt;Florian Dütsch&lt;/li&gt; &#xA; &lt;li&gt;Manuel Meurer&lt;/li&gt; &#xA; &lt;li&gt;Brian D. Burns&lt;/li&gt; &#xA; &lt;li&gt;Riley Strong&lt;/li&gt; &#xA; &lt;li&gt;Tamir Duberstein&lt;/li&gt; &#xA; &lt;li&gt;Stefano Uliari&lt;/li&gt; &#xA; &lt;li&gt;Alex Stupakov&lt;/li&gt; &#xA; &lt;li&gt;Karen Wang&lt;/li&gt; &#xA; &lt;li&gt;Matt Burke&lt;/li&gt; &#xA; &lt;li&gt;Jon Rowe&lt;/li&gt; &#xA; &lt;li&gt;Aleksey V. Zapparov&lt;/li&gt; &#xA; &lt;li&gt;Praveen Arimbrathodiyil&lt;/li&gt; &#xA; &lt;li&gt;Bo Jeanes&lt;/li&gt; &#xA; &lt;li&gt;Matthew Conway&lt;/li&gt; &#xA; &lt;li&gt;Rob Olson&lt;/li&gt; &#xA; &lt;li&gt;Max Lincoln&lt;/li&gt; &#xA; &lt;li&gt;Oleg Gritsenko&lt;/li&gt; &#xA; &lt;li&gt;Hwan-Joon Choi&lt;/li&gt; &#xA; &lt;li&gt;SHIBATA Hiroshi&lt;/li&gt; &#xA; &lt;li&gt;Caleb Thompson&lt;/li&gt; &#xA; &lt;li&gt;Theo Hultberg&lt;/li&gt; &#xA; &lt;li&gt;Pablo Jairala&lt;/li&gt; &#xA; &lt;li&gt;Insoo Buzz Jung&lt;/li&gt; &#xA; &lt;li&gt;Carlos Alonso Pérez&lt;/li&gt; &#xA; &lt;li&gt;trlorenz&lt;/li&gt; &#xA; &lt;li&gt;Alexander Simonov&lt;/li&gt; &#xA; &lt;li&gt;Thorbjørn Hermanse&lt;/li&gt; &#xA; &lt;li&gt;Mark Lorenz&lt;/li&gt; &#xA; &lt;li&gt;tjsousa&lt;/li&gt; &#xA; &lt;li&gt;Tasos Stathopoulos&lt;/li&gt; &#xA; &lt;li&gt;Dan Buettner&lt;/li&gt; &#xA; &lt;li&gt;Sven Riedel&lt;/li&gt; &#xA; &lt;li&gt;Mark Lorenz&lt;/li&gt; &#xA; &lt;li&gt;Dávid Kovács&lt;/li&gt; &#xA; &lt;li&gt;fishermand46&lt;/li&gt; &#xA; &lt;li&gt;Franky Wahl&lt;/li&gt; &#xA; &lt;li&gt;ChaYoung You&lt;/li&gt; &#xA; &lt;li&gt;Simon Russell&lt;/li&gt; &#xA; &lt;li&gt;Steve Mitchell&lt;/li&gt; &#xA; &lt;li&gt;Mattias Putman&lt;/li&gt; &#xA; &lt;li&gt;Zachary Anker&lt;/li&gt; &#xA; &lt;li&gt;Emmanuel Sambo&lt;/li&gt; &#xA; &lt;li&gt;Ramon Tayag&lt;/li&gt; &#xA; &lt;li&gt;Johannes Schlumberger&lt;/li&gt; &#xA; &lt;li&gt;Siôn Le Roux&lt;/li&gt; &#xA; &lt;li&gt;Matt Palmer&lt;/li&gt; &#xA; &lt;li&gt;Zhao Wen&lt;/li&gt; &#xA; &lt;li&gt;Krzysztof Rygielski&lt;/li&gt; &#xA; &lt;li&gt;Magne Land&lt;/li&gt; &#xA; &lt;li&gt;yurivm&lt;/li&gt; &#xA; &lt;li&gt;Mike Knepper&lt;/li&gt; &#xA; &lt;li&gt;Charles Pence&lt;/li&gt; &#xA; &lt;li&gt;Alexey Zapparov&lt;/li&gt; &#xA; &lt;li&gt;Pablo Brasero&lt;/li&gt; &#xA; &lt;li&gt;Cedric Pimenta&lt;/li&gt; &#xA; &lt;li&gt;Michiel Karnebeek&lt;/li&gt; &#xA; &lt;li&gt;Alex Kestner&lt;/li&gt; &#xA; &lt;li&gt;Manfred Stienstra&lt;/li&gt; &#xA; &lt;li&gt;Tim Diggins&lt;/li&gt; &#xA; &lt;li&gt;Gabriel Chaney&lt;/li&gt; &#xA; &lt;li&gt;Chris Griego&lt;/li&gt; &#xA; &lt;li&gt;Taiki Ono&lt;/li&gt; &#xA; &lt;li&gt;Jonathan Schatz&lt;/li&gt; &#xA; &lt;li&gt;Jose Luis Honorato&lt;/li&gt; &#xA; &lt;li&gt;Aaron Kromer&lt;/li&gt; &#xA; &lt;li&gt;Pavel Jurašek&lt;/li&gt; &#xA; &lt;li&gt;Jake Worth&lt;/li&gt; &#xA; &lt;li&gt;Gabe Martin-Dempesy&lt;/li&gt; &#xA; &lt;li&gt;Michael Grosser&lt;/li&gt; &#xA; &lt;li&gt;Aleksei Maridashvili&lt;/li&gt; &#xA; &lt;li&gt;Ville Lautanala&lt;/li&gt; &#xA; &lt;li&gt;Koichi ITO&lt;/li&gt; &#xA; &lt;li&gt;Jordan Harband&lt;/li&gt; &#xA; &lt;li&gt;Tarmo Tänav&lt;/li&gt; &#xA; &lt;li&gt;Joe Marty&lt;/li&gt; &#xA; &lt;li&gt;Chris Thomson&lt;/li&gt; &#xA; &lt;li&gt;Vít Ondruch&lt;/li&gt; &#xA; &lt;li&gt;George Ulmer&lt;/li&gt; &#xA; &lt;li&gt;Christof Koenig&lt;/li&gt; &#xA; &lt;li&gt;Chung-Yi Chi&lt;/li&gt; &#xA; &lt;li&gt;Olexandr Hoshylyk&lt;/li&gt; &#xA; &lt;li&gt;Janko Marohnić&lt;/li&gt; &#xA; &lt;li&gt;Pat Allan&lt;/li&gt; &#xA; &lt;li&gt;Rick Song&lt;/li&gt; &#xA; &lt;li&gt;NARUSE, Yui&lt;/li&gt; &#xA; &lt;li&gt;Piotr Boniecki&lt;/li&gt; &#xA; &lt;li&gt;Olia Kremmyda&lt;/li&gt; &#xA; &lt;li&gt;Michał Matyas&lt;/li&gt; &#xA; &lt;li&gt;Matt Brictson&lt;/li&gt; &#xA; &lt;li&gt;Kenny Ortmann&lt;/li&gt; &#xA; &lt;li&gt;redbar0n&lt;/li&gt; &#xA; &lt;li&gt;Lukas Pokorny&lt;/li&gt; &#xA; &lt;li&gt;Arkadiy Tetelman&lt;/li&gt; &#xA; &lt;li&gt;Kazato Sugimoto&lt;/li&gt; &#xA; &lt;li&gt;Olle Jonsson&lt;/li&gt; &#xA; &lt;li&gt;Pavel Rosický&lt;/li&gt; &#xA; &lt;li&gt;Geremia Taglialatela&lt;/li&gt; &#xA; &lt;li&gt;Koichi Sasada&lt;/li&gt; &#xA; &lt;li&gt;Yusuke Endoh&lt;/li&gt; &#xA; &lt;li&gt;Grey Baker&lt;/li&gt; &#xA; &lt;li&gt;SoonKhen OwYong&lt;/li&gt; &#xA; &lt;li&gt;Pavel Valena&lt;/li&gt; &#xA; &lt;li&gt;Adam Sokolnicki&lt;/li&gt; &#xA; &lt;li&gt;Jeff Felchner&lt;/li&gt; &#xA; &lt;li&gt;Eike Send&lt;/li&gt; &#xA; &lt;li&gt;Claudio Poli&lt;/li&gt; &#xA; &lt;li&gt;Csaba Apagyi&lt;/li&gt; &#xA; &lt;li&gt;Frederick Cheung&lt;/li&gt; &#xA; &lt;li&gt;Fábio D. Batista&lt;/li&gt; &#xA; &lt;li&gt;Andriy Yanko&lt;/li&gt; &#xA; &lt;li&gt;y-yagi&lt;/li&gt; &#xA; &lt;li&gt;Rafael França&lt;/li&gt; &#xA; &lt;li&gt;George Claghorn&lt;/li&gt; &#xA; &lt;li&gt;Alex Junger&lt;/li&gt; &#xA; &lt;li&gt;Orien Madgwick&lt;/li&gt; &#xA; &lt;li&gt;Andrei Sidorov&lt;/li&gt; &#xA; &lt;li&gt;Marco Costa&lt;/li&gt; &#xA; &lt;li&gt;Ryan Davis&lt;/li&gt; &#xA; &lt;li&gt;Brandur&lt;/li&gt; &#xA; &lt;li&gt;Samuel Williams&lt;/li&gt; &#xA; &lt;li&gt;Patrik Ragnarsson&lt;/li&gt; &#xA; &lt;li&gt;Alex Coomans&lt;/li&gt; &#xA; &lt;li&gt;Vesa Laakso&lt;/li&gt; &#xA; &lt;li&gt;John Hawthorn&lt;/li&gt; &#xA; &lt;li&gt;guppy0356&lt;/li&gt; &#xA; &lt;li&gt;Thilo Rusche&lt;/li&gt; &#xA; &lt;li&gt;Andrew Stuntz&lt;/li&gt; &#xA; &lt;li&gt;Lucas Uyezu&lt;/li&gt; &#xA; &lt;li&gt;Bruno Sutic&lt;/li&gt; &#xA; &lt;li&gt;Ryan Kerr&lt;/li&gt; &#xA; &lt;li&gt;Adam Harwood&lt;/li&gt; &#xA; &lt;li&gt;Ben Koshy&lt;/li&gt; &#xA; &lt;li&gt;Jesse Bowes&lt;/li&gt; &#xA; &lt;li&gt;Marek Kasztelnik&lt;/li&gt; &#xA; &lt;li&gt;ce07c3&lt;/li&gt; &#xA; &lt;li&gt;Jun Jiang&lt;/li&gt; &#xA; &lt;li&gt;Oleksiy Kovyrin&lt;/li&gt; &#xA; &lt;li&gt;Matt Larraz&lt;/li&gt; &#xA; &lt;li&gt;Tony Schneider&lt;/li&gt; &#xA; &lt;li&gt;Niklas Hösl&lt;/li&gt; &#xA; &lt;li&gt;Johanna Hartmann&lt;/li&gt; &#xA; &lt;li&gt;Alex Vondrak&lt;/li&gt; &#xA; &lt;li&gt;Will Storey&lt;/li&gt; &#xA; &lt;li&gt;Eduardo Hernandez&lt;/li&gt; &#xA; &lt;li&gt;ojab&lt;/li&gt; &#xA; &lt;li&gt;Giorgio Gambino&lt;/li&gt; &#xA; &lt;li&gt;Timmitry&lt;/li&gt; &#xA; &lt;li&gt;Michael Fairley&lt;/li&gt; &#xA; &lt;li&gt;Ray Zane&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For a full list of contributors you can visit the &lt;a href=&#34;https://github.com/bblimke/webmock/contributors&#34;&gt;contributors&lt;/a&gt; page.&lt;/p&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;Thank you Fakeweb! This library was inspired by &lt;a href=&#34;http://fakeweb.rubyforge.org&#34;&gt;FakeWeb&lt;/a&gt;. I imported some solutions from that project to WebMock. I also copied some code i.e Net:HTTP adapter. Fakeweb architecture unfortunately didn&#39;t allow me to extend it easily with the features I needed. I also preferred some things to work differently i.e request stub precedence.&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2009-2010 Bartosz Blimke. See LICENSE for details.&lt;/p&gt;</summary>
  </entry>
</feed>