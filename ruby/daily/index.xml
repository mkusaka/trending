<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-05T01:42:32Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>evait-security/envizon</title>
    <updated>2023-03-05T01:42:32Z</updated>
    <id>tag:github.com,2023-03-05:/evait-security/envizon</id>
    <link href="https://github.com/evait-security/envizon" rel="alternate"></link>
    <summary type="html">&lt;p&gt;network visualization &amp; pentest reporting&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;envizon - by evait security&lt;/h1&gt; &#xA;&lt;h2&gt;network visualization &amp;amp; pentest reporting&lt;/h2&gt; &#xA;&lt;p&gt;Version 5.0&lt;/p&gt; &#xA;&lt;img src=&#34;https://evait-security.github.io/envizon/envizon-wide-export-blue.svg?sanitize=true&#34; width=&#34;400px&#34;&gt; &#xA;&lt;p&gt;This tool is designed, developed and supported by evait security. In order to give something back to the security community, we publish our internally used and developed, state of the art network visualization and vulnerability reporting tool, &#39;envizon&#39;. We hope your feedback will help to improve and hone it even further.&lt;/p&gt; &#xA;&lt;h2&gt;Website&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://evait-security.github.io/envizon/&#34;&gt;https://evait-security.github.io/envizon/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Wiki&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/evait-security/envizon/wiki&#34;&gt;https://github.com/evait-security/envizon/wiki&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;This is not a low-resource application. It is not recommended to run this software on embedded devices such as a raspberry pi. You should use a 64-bit architecture and at least 8 GB of RAM to get full experience (e.g. screenshotting multiple web services).&lt;/p&gt; &#xA;&lt;h2&gt;Use Case&lt;/h2&gt; &#xA;&lt;p&gt;We use envizon for our pentests in order to get an overview of a network and quickly identify the most promising targets. The version 3.0 introduce new features such as screenshotting web services, organizing vulnerabilities or generating reports with custom docx templates.&lt;/p&gt; &#xA;&lt;h2&gt;Core Features:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Scan&lt;/strong&gt; networks with predefined or custom nmap queries&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Order&lt;/strong&gt; clients with preconfigured or custom groups&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Search&lt;/strong&gt; through all attributes of clients and create complex linked queries&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Get&lt;/strong&gt; an overview of your targets during pentests with predefined security labels or the subnet view&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Screenshot&lt;/strong&gt; Visualize all http-like applications of your targets using chrome-headless (selenium) - VNC soonâ„¢&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Save&lt;/strong&gt; and reuse your most used nmap scans&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Collaborate&lt;/strong&gt; with your team on the project in realtime (all users share the same password / workspace)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Export&lt;/strong&gt; selected clients in a text file to connect other tools fast&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Manage&lt;/strong&gt; issue template and create vulnerabilities linked to hosts in the database&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Create&lt;/strong&gt; customer pentest reports with docx templates&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Take&lt;/strong&gt; notes no nearly any object (WIP)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Okay, i will use this tool - how to start?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/evait-security/envizon/wiki/How-to-start&#34;&gt;https://github.com/evait-security/envizon/wiki/How-to-start&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage instructions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/evait-security/envizon/wiki/Usage&#34;&gt;https://github.com/evait-security/envizon/wiki/Usage&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>SAML-Toolkits/ruby-saml</title>
    <updated>2023-03-05T01:42:32Z</updated>
    <id>tag:github.com,2023-03-05:/SAML-Toolkits/ruby-saml</id>
    <link href="https://github.com/SAML-Toolkits/ruby-saml" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SAML SSO for Ruby&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ruby SAML&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/SAML-Toolkits/ruby-saml/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/SAML-Toolkits/ruby-saml/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;ruby-saml CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/github/SAML-Toolkits/ruby-saml?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/SAML-Toolkits/ruby-saml/badge.svg?branch=master&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://badge.fury.io/rb/ruby-saml&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/ruby-saml.svg?sanitize=true&#34; alt=&#34;Rubygem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://badge.fury.io/gh/SAML-Toolkits%2Fruby-saml&#34;&gt;&lt;img src=&#34;https://badge.fury.io/gh/SAML-Toolkits%2Fruby-saml.svg?sanitize=true&#34; alt=&#34;GitHub version&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/license/SAML-Toolkits/ruby-saml&#34; alt=&#34;GitHub&#34;&gt; &lt;img src=&#34;https://img.shields.io/gem/dtv/ruby-saml?label=gem%20downloads%20latest&#34; alt=&#34;Gem&#34;&gt; &lt;img src=&#34;https://img.shields.io/gem/dt/ruby-saml?label=gem%20total%20downloads&#34; alt=&#34;Gem&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ruby SAML minor and tiny versions may introduce breaking changes. Please read &lt;a href=&#34;https://raw.githubusercontent.com/SAML-Toolkits/ruby-saml/master/UPGRADING.md&#34;&gt;UPGRADING.md&lt;/a&gt; for guidance on upgrading to new Ruby SAML versions.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;The Ruby SAML library is for implementing the client side of a SAML authorization, i.e. it provides a means for managing authorization initialization and confirmation requests from identity providers.&lt;/p&gt; &#xA;&lt;p&gt;SAML authorization is a two step process and you are expected to implement support for both.&lt;/p&gt; &#xA;&lt;p&gt;We created a demo project for Rails 4 that uses the latest version of this library: &lt;a href=&#34;https://github.com/saml-toolkits/ruby-saml-example&#34;&gt;ruby-saml-example&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Supported Ruby Versions&lt;/h3&gt; &#xA;&lt;p&gt;The following Ruby versions are covered by CI testing:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;2.1.x&lt;/li&gt; &#xA; &lt;li&gt;2.2.x&lt;/li&gt; &#xA; &lt;li&gt;2.3.x&lt;/li&gt; &#xA; &lt;li&gt;2.4.x&lt;/li&gt; &#xA; &lt;li&gt;2.5.x&lt;/li&gt; &#xA; &lt;li&gt;2.6.x&lt;/li&gt; &#xA; &lt;li&gt;2.7.x&lt;/li&gt; &#xA; &lt;li&gt;3.0.x&lt;/li&gt; &#xA; &lt;li&gt;3.1&lt;/li&gt; &#xA; &lt;li&gt;3.2&lt;/li&gt; &#xA; &lt;li&gt;JRuby 9.1.x&lt;/li&gt; &#xA; &lt;li&gt;JRuby 9.2.x&lt;/li&gt; &#xA; &lt;li&gt;JRuby 9.3.X&lt;/li&gt; &#xA; &lt;li&gt;JRuby 9.4.0&lt;/li&gt; &#xA; &lt;li&gt;TruffleRuby (latest)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition, the following may work but are untested:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;1.8.7&lt;/li&gt; &#xA; &lt;li&gt;1.9.x&lt;/li&gt; &#xA; &lt;li&gt;2.0.x&lt;/li&gt; &#xA; &lt;li&gt;JRuby 1.7.x&lt;/li&gt; &#xA; &lt;li&gt;JRuby 9.0.x&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Adding Features, Pull Requests&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fork the repository&lt;/li&gt; &#xA; &lt;li&gt;Make your feature addition or bug fix&lt;/li&gt; &#xA; &lt;li&gt;Add tests for your new features. This is important so we don&#39;t break any features in a future version unintentionally.&lt;/li&gt; &#xA; &lt;li&gt;Ensure all tests pass by running &lt;code&gt;bundle exec rake test&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Do not change rakefile, version, or history.&lt;/li&gt; &#xA; &lt;li&gt;Open a pull request, following &lt;a href=&#34;https://gist.github.com/Lordnibbler/11002759&#34;&gt;this template&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Security Guidelines&lt;/h2&gt; &#xA;&lt;p&gt;If you believe you have discovered a security vulnerability in this gem, please report it by mail to the maintainer: &lt;a href=&#34;mailto:sixto.martin.garcia+security@gmail.com&#34;&gt;sixto.martin.garcia+security@gmail.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Security Warning&lt;/h3&gt; &#xA;&lt;p&gt;Some tools may incorrectly report ruby-saml is a potential security vulnerability. ruby-saml depends on Nokogiri, and it&#39;s possible to use Nokogiri in a dangerous way (by enabling its DTDLOAD option and disabling its NONET option). This dangerous Nokogiri configuration, which is sometimes used by other components, can create an XML External Entity (XXE) vulnerability if the XML data is not trusted. However, ruby-saml never enables this dangerous Nokogiri configuration; ruby-saml never enables DTDLOAD, and it never disables NONET.&lt;/p&gt; &#xA;&lt;p&gt;The OneLogin::RubySaml::IdpMetadataParser class does not validate in any way the URL that is introduced in order to be parsed.&lt;/p&gt; &#xA;&lt;p&gt;Usually the same administrator that handles the Service Provider also sets the URL to the IdP, which should be a trusted resource.&lt;/p&gt; &#xA;&lt;p&gt;But there are other scenarios, like a SAAS app where the administrator of the app delegates this functionality to other users. In this case, extra precaution should be taken in order to validate such URL inputs and avoid attacks like SSRF.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;In order to use Ruby SAML you will need to install the gem (either manually or using Bundler), and require the library in your Ruby application:&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;code&gt;Gemfile&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# latest stable&#xA;gem &#39;ruby-saml&#39;, &#39;~&amp;gt; 1.11.0&#39;&#xA;&#xA;# or track master for bleeding-edge&#xA;gem &#39;ruby-saml&#39;, :github =&amp;gt; &#39;saml-toolkit/ruby-saml&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using RubyGems&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gem install ruby-saml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may require the entire Ruby SAML gem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;onelogin/ruby-saml&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or just the required components individually:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;onelogin/ruby-saml/authrequest&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Installation on Ruby 1.8.7&lt;/h3&gt; &#xA;&lt;p&gt;This gem uses Nokogiri as a dependency, which dropped support for Ruby 1.8.x in Nokogiri 1.6. When installing this gem on Ruby 1.8.7, you will need to make sure a version of Nokogiri prior to 1.6 is installed or specified if it hasn&#39;t been already.&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;code&gt;Gemfile&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;nokogiri&#39;, &#39;~&amp;gt; 1.5.10&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using RubyGems&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gem install nokogiri --version &#39;~&amp;gt; 1.5.10&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuring Logging&lt;/h3&gt; &#xA;&lt;p&gt;When troubleshooting SAML integration issues, you will find it extremely helpful to examine the output of this gem&#39;s business logic. By default, log messages are emitted to RAILS_DEFAULT_LOGGER when the gem is used in a Rails context, and to STDOUT when the gem is used outside of Rails.&lt;/p&gt; &#xA;&lt;p&gt;To override the default behavior and control the destination of log messages, provide a ruby Logger object to the gem&#39;s logging singleton:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;OneLogin::RubySaml::Logging.logger = Logger.new(&#39;/var/log/ruby-saml.log&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;The Initialization Phase&lt;/h2&gt; &#xA;&lt;p&gt;This is the first request you will get from the identity provider. It will hit your application at a specific URL that you&#39;ve announced as your SAML initialization point. The response to this initialization is a redirect back to the identity provider, which can look something like this (ignore the saml_settings method call for now):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def init&#xA;  request = OneLogin::RubySaml::Authrequest.new&#xA;  redirect_to(request.create(saml_settings))&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the SP knows who should be authenticated in the IdP, then can provide that info as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def init&#xA;  request = OneLogin::RubySaml::Authrequest.new&#xA;  saml_settings.name_identifier_value_requested = &#34;testuser@example.com&#34;&#xA;  saml_settings.name_identifier_format = &#34;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#34;&#xA;  redirect_to(request.create(saml_settings))&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you&#39;ve redirected back to the identity provider, it will ensure that the user has been authorized and redirect back to your application for final consumption. This can look something like this (the &lt;code&gt;authorize_success&lt;/code&gt; and &lt;code&gt;authorize_failure&lt;/code&gt; methods are specific to your application):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def consume&#xA;  response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], :settings =&amp;gt; saml_settings)&#xA;&#xA;  # We validate the SAML Response and check if the user already exists in the system&#xA;  if response.is_valid?&#xA;     # authorize_success, log the user&#xA;     session[:userid] = response.nameid&#xA;     session[:attributes] = response.attributes&#xA;  else&#xA;    authorize_failure  # This method shows an error message&#xA;    # List of errors is available in response.errors array&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above there are a few assumptions, one being that &lt;code&gt;response.nameid&lt;/code&gt; is an email address. This is all handled with how you specify the settings that are in play via the &lt;code&gt;saml_settings&lt;/code&gt; method. That could be implemented along the lines of this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse])&#xA;response.settings = saml_settings&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the assertion of the SAMLResponse is not encrypted, you can initialize the Response without the &lt;code&gt;:settings&lt;/code&gt; parameter and set it later. If the SAMLResponse contains an encrypted assertion, you need to provide the settings in the initialize method in order to obtain the decrypted assertion, using the service provider private key in order to decrypt. If you don&#39;t know what expect, always use the former (set the settings on initialize).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def saml_settings&#xA;  settings = OneLogin::RubySaml::Settings.new&#xA;&#xA;  settings.assertion_consumer_service_url = &#34;http://#{request.host}/saml/consume&#34;&#xA;  settings.sp_entity_id                   = &#34;http://#{request.host}/saml/metadata&#34;&#xA;  settings.idp_entity_id                  = &#34;https://app.onelogin.com/saml/metadata/#{OneLoginAppId}&#34;&#xA;  settings.idp_sso_service_url            = &#34;https://app.onelogin.com/trust/saml2/http-post/sso/#{OneLoginAppId}&#34;&#xA;  settings.idp_sso_service_binding        = &#34;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&#34; # or :post, :redirect&#xA;  settings.idp_slo_service_url            = &#34;https://app.onelogin.com/trust/saml2/http-redirect/slo/#{OneLoginAppId}&#34;&#xA;  settings.idp_slo_service_binding        = &#34;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect&#34; # or :post, :redirect&#xA;  settings.idp_cert_fingerprint           = OneLoginAppCertFingerPrint&#xA;  settings.idp_cert_fingerprint_algorithm = &#34;http://www.w3.org/2000/09/xmldsig#sha1&#34;&#xA;  settings.name_identifier_format         = &#34;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#34;&#xA;&#xA;  # Optional for most SAML IdPs&#xA;  settings.authn_context = &#34;urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport&#34;&#xA;  # or as an array&#xA;  settings.authn_context = [&#xA;    &#34;urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport&#34;,&#xA;    &#34;urn:oasis:names:tc:SAML:2.0:ac:classes:Password&#34;&#xA;  ]&#xA;&#xA;  # Optional bindings (defaults to Redirect for logout POST for ACS)&#xA;  settings.single_logout_service_binding      = &#34;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect&#34; # or :post, :redirect&#xA;  settings.assertion_consumer_service_binding = &#34;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&#34; # or :post, :redirect&#xA;&#xA;  settings&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The use of settings.issuer is deprecated in favour of settings.sp_entity_id since version 1.11.0&lt;/p&gt; &#xA;&lt;p&gt;Some assertion validations can be skipped by passing parameters to &lt;code&gt;OneLogin::RubySaml::Response.new()&lt;/code&gt;. For example, you can skip the &lt;code&gt;AuthnStatement&lt;/code&gt;, &lt;code&gt;Conditions&lt;/code&gt;, &lt;code&gt;Recipient&lt;/code&gt;, or the &lt;code&gt;SubjectConfirmation&lt;/code&gt; validations by initializing the response with different options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], {skip_authnstatement: true}) # skips AuthnStatement&#xA;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], {skip_conditions: true}) # skips conditions&#xA;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], {skip_subject_confirmation: true}) # skips subject confirmation&#xA;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], {skip_recipient_check: true}) # doesn&#39;t skip subject confirmation, but skips the recipient check which is a sub check of the subject_confirmation check&#xA;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], {skip_audience: true}) # skips audience check&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All that&#39;s left is to wrap everything in a controller and reference it in the initialization and consumption URLs in OneLogin. A full controller example could look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# This controller expects you to use the URLs /saml/init and /saml/consume in your OneLogin application.&#xA;class SamlController &amp;lt; ApplicationController&#xA;  def init&#xA;    request = OneLogin::RubySaml::Authrequest.new&#xA;    redirect_to(request.create(saml_settings))&#xA;  end&#xA;&#xA;  def consume&#xA;    response          = OneLogin::RubySaml::Response.new(params[:SAMLResponse])&#xA;    response.settings = saml_settings&#xA;&#xA;    # We validate the SAML Response and check if the user already exists in the system&#xA;    if response.is_valid?&#xA;       # authorize_success, log the user&#xA;       session[:userid] = response.nameid&#xA;       session[:attributes] = response.attributes&#xA;    else&#xA;      authorize_failure  # This method shows an error message&#xA;      # List of errors is available in response.errors array&#xA;    end&#xA;  end&#xA;&#xA;  private&#xA;&#xA;  def saml_settings&#xA;    settings = OneLogin::RubySaml::Settings.new&#xA;&#xA;    settings.assertion_consumer_service_url = &#34;http://#{request.host}/saml/consume&#34;&#xA;    settings.sp_entity_id                   = &#34;http://#{request.host}/saml/metadata&#34;&#xA;    settings.idp_sso_service_url             = &#34;https://app.onelogin.com/saml/signon/#{OneLoginAppId}&#34;&#xA;    settings.idp_cert_fingerprint           = OneLoginAppCertFingerPrint&#xA;    settings.name_identifier_format         = &#34;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#34;&#xA;&#xA;    # Optional for most SAML IdPs&#xA;    settings.authn_context = &#34;urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport&#34;&#xA;&#xA;    # Optional. Describe according to IdP specification (if supported) which attributes the SP desires to receive in SAMLResponse.&#xA;    settings.attributes_index = 5&#xA;    # Optional. Describe an attribute consuming service for support of additional attributes.&#xA;    settings.attribute_consuming_service.configure do&#xA;      service_name &#34;Service&#34;&#xA;      service_index 5&#xA;      add_attribute :name =&amp;gt; &#34;Name&#34;, :name_format =&amp;gt; &#34;Name Format&#34;, :friendly_name =&amp;gt; &#34;Friendly Name&#34;&#xA;    end&#xA;&#xA;    settings&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Signature Validation&lt;/h2&gt; &#xA;&lt;p&gt;Ruby SAML allows different ways to validate the signature of the SAMLResponse:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can provide the IdP X.509 public certificate at the &lt;code&gt;idp_cert&lt;/code&gt; setting.&lt;/li&gt; &#xA; &lt;li&gt;You can provide the IdP X.509 public certificate in fingerprint format using the &lt;code&gt;idp_cert_fingerprint&lt;/code&gt; setting parameter and additionally the &lt;code&gt;idp_cert_fingerprint_algorithm&lt;/code&gt; parameter.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When validating the signature of redirect binding, the fingerprint is useless and the certificate of the IdP is required in order to execute the validation. You can pass the option &lt;code&gt;:relax_signature_validation&lt;/code&gt; to &lt;code&gt;SloLogoutrequest&lt;/code&gt; and &lt;code&gt;Logoutresponse&lt;/code&gt; if want to avoid signature validation if no certificate of the IdP is provided.&lt;/p&gt; &#xA;&lt;p&gt;In production also we highly recommend to register on the settings the IdP certificate instead of using the fingerprint method. The fingerprint, is a hash, so at the end is open to a collision attack that can end on a signature validation bypass. Other SAML toolkits deprecated that mechanism, we maintain it for compatibility and also to be used on test environment.&lt;/p&gt; &#xA;&lt;h2&gt;Handling Multiple IdP Certificates&lt;/h2&gt; &#xA;&lt;p&gt;If the IdP metadata XML includes multiple certificates, you may specify the &lt;code&gt;idp_cert_multi&lt;/code&gt; parameter. When used, the &lt;code&gt;idp_cert&lt;/code&gt; and &lt;code&gt;idp_cert_fingerprint&lt;/code&gt; parameters are ignored. This is useful in the following scenarios:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The IdP uses different certificates for signing versus encryption.&lt;/li&gt; &#xA; &lt;li&gt;The IdP is undergoing a key rollover and is publishing the old and new certificates in parallel.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;idp_cert_multi&lt;/code&gt; must be a &lt;code&gt;Hash&lt;/code&gt; as follows. The &lt;code&gt;:signing&lt;/code&gt; and &lt;code&gt;:encryption&lt;/code&gt; arrays below, add the IdP X.509 public certificates which were published in the IdP metadata.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;{&#xA;  :signing =&amp;gt; [],&#xA;  :encryption =&amp;gt; []&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Metadata Based Configuration&lt;/h2&gt; &#xA;&lt;p&gt;The method above requires a little extra work to manually specify attributes about both the IdP and your SP application. There&#39;s an easier method: use a metadata exchange. Metadata is an XML file that defines the capabilities of both the IdP and the SP application. It also contains the X.509 public key certificates which add to the trusted relationship. The IdP administrator can also configure custom settings for an SP based on the metadata.&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;code&gt;IdpMetadataParser#parse_remote&lt;/code&gt;, the IdP metadata will be added to the settings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def saml_settings&#xA;&#xA;  idp_metadata_parser = OneLogin::RubySaml::IdpMetadataParser.new&#xA;  # Returns OneLogin::RubySaml::Settings pre-populated with IdP metadata&#xA;  settings = idp_metadata_parser.parse_remote(&#34;https://example.com/auth/saml2/idp/metadata&#34;)&#xA;&#xA;  settings.assertion_consumer_service_url = &#34;http://#{request.host}/saml/consume&#34;&#xA;  settings.sp_entity_id                   = &#34;http://#{request.host}/saml/metadata&#34;&#xA;  settings.name_identifier_format         = &#34;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#34;&#xA;  # Optional for most SAML IdPs&#xA;  settings.authn_context = &#34;urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport&#34;&#xA;&#xA;  settings&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following attributes are set:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;idp_entity_id&lt;/li&gt; &#xA; &lt;li&gt;name_identifier_format&lt;/li&gt; &#xA; &lt;li&gt;idp_sso_service_url&lt;/li&gt; &#xA; &lt;li&gt;idp_slo_service_url&lt;/li&gt; &#xA; &lt;li&gt;idp_attribute_names&lt;/li&gt; &#xA; &lt;li&gt;idp_cert&lt;/li&gt; &#xA; &lt;li&gt;idp_cert_fingerprint&lt;/li&gt; &#xA; &lt;li&gt;idp_cert_multi&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Retrieve one Entity Descriptor when many exist in Metadata&lt;/h3&gt; &#xA;&lt;p&gt;If the Metadata contains several entities, the relevant Entity Descriptor can be specified when retrieving the settings from the IdpMetadataParser by its Entity Id value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  validate_cert = true&#xA;  settings = idp_metadata_parser.parse_remote(&#xA;               &#34;https://example.com/auth/saml2/idp/metadata&#34;,&#xA;               validate_cert,&#xA;               entity_id: &#34;http//example.com/target/entity&#34;&#xA;             )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieve one Entity Descriptor with an specific binding and nameid format when several are available&lt;/h3&gt; &#xA;&lt;p&gt;If the Metadata contains several bindings and nameids, the relevant ones also can be specified when retrieving the settings from the IdpMetadataParser by the values of binding and nameid:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  validate_cert = true&#xA;  options = {&#xA;    entity_id: &#34;http//example.com/target/entity&#34;,&#xA;    name_id_format: &#34;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#34;,&#xA;    sso_binding: &#34;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&#34;,&#xA;    slo_binding: &#34;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&#34;&#xA;  }&#xA;  settings = idp_metadata_parser.parse_remote(&#xA;               &#34;https://example.com/auth/saml2/idp/metadata&#34;,&#xA;               validate_cert,&#xA;               options&#xA;             )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parsing Metadata into an Hash&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;OneLogin::RubySaml::IdpMetadataParser&lt;/code&gt; also provides the methods &lt;code&gt;#parse_to_hash&lt;/code&gt; and &lt;code&gt;#parse_remote_to_hash&lt;/code&gt;. Those return an Hash instead of a &lt;code&gt;Settings&lt;/code&gt; object, which may be useful for configuring &lt;a href=&#34;https://github.com/omniauth/omniauth-saml&#34;&gt;omniauth-saml&lt;/a&gt;, for instance.&lt;/p&gt; &#xA;&lt;h3&gt;Validating Signature of Metadata and retrieve settings&lt;/h3&gt; &#xA;&lt;p&gt;Right now there is no method at ruby_saml to validate the signature of the metadata that gonna be parsed, but it can be done as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download the XML.&lt;/li&gt; &#xA; &lt;li&gt;Validate the Signature, providing the cert.&lt;/li&gt; &#xA; &lt;li&gt;Provide the XML to the parse method if the signature was validated&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;xml_security&#34;&#xA;require &#34;onelogin/ruby-saml/utils&#34;&#xA;require &#34;onelogin/ruby-saml/idp_metadata_parser&#34;&#xA;&#xA;url = &#34;&amp;lt;url_to_the_metadata&amp;gt;&#34;&#xA;idp_metadata_parser = OneLogin::RubySaml::IdpMetadataParser.new&#xA;&#xA;uri = URI.parse(url)&#xA;raise ArgumentError.new(&#34;url must begin with http or https&#34;) unless /^https?/ =~ uri.scheme&#xA;http = Net::HTTP.new(uri.host, uri.port)&#xA;if uri.scheme == &#34;https&#34;&#xA;    http.use_ssl = true&#xA;    http.verify_mode = OpenSSL::SSL::VERIFY_PEER&#xA;end&#xA;&#xA;get = Net::HTTP::Get.new(uri.request_uri)&#xA;get.basic_auth uri.user, uri.password if uri.user&#xA;response = http.request(get)&#xA;xml = response.body&#xA;errors = []&#xA;doc = XMLSecurity::SignedDocument.new(xml, errors)&#xA;cert_str = &#34;&amp;lt;include_cert_here&amp;gt;&#34;&#xA;cert = OneLogin::RubySaml::Utils.format_cert(&#34;cert_str&#34;)&#xA;metadata_sign_cert = OpenSSL::X509::Certificate.new(cert)&#xA;valid = doc.validate_document_with_cert(metadata_sign_cert, true)&#xA;if valid&#xA;  settings = idp_metadata_parser.parse(&#xA;    xml,&#xA;    entity_id: &#34;&amp;lt;entity_id_of_the_entity_to_be_retrieved&amp;gt;&#34;&#xA;  )&#xA;else&#xA;  print &#34;Metadata Signarture failed to be verified with the cert provided&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Retrieving Attributes&lt;/h2&gt; &#xA;&lt;p&gt;If you are using &lt;code&gt;saml:AttributeStatement&lt;/code&gt; to transfer data like the username, you can access all the attributes through &lt;code&gt;response.attributes&lt;/code&gt;. It contains all the &lt;code&gt;saml:AttributeStatement&lt;/code&gt;s with its &#39;Name&#39; as an indifferent key and one or more &lt;code&gt;saml:AttributeValue&lt;/code&gt;s as values. The value returned depends on the value of the &lt;code&gt;single_value_compatibility&lt;/code&gt; (when activated, only the first value is returned)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse])&#xA;response.settings = saml_settings&#xA;&#xA;response.attributes[:username]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Imagine this &lt;code&gt;saml:AttributeStatement&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;saml:AttributeStatement&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;uid&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:type=&#34;xs:string&#34;&amp;gt;demo&amp;lt;/saml:AttributeValue&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;another_value&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:type=&#34;xs:string&#34;&amp;gt;value1&amp;lt;/saml:AttributeValue&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:type=&#34;xs:string&#34;&amp;gt;value2&amp;lt;/saml:AttributeValue&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;role&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:type=&#34;xs:string&#34;&amp;gt;role1&amp;lt;/saml:AttributeValue&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;role&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:type=&#34;xs:string&#34;&amp;gt;role2&amp;lt;/saml:AttributeValue&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:type=&#34;xs:string&#34;&amp;gt;role3&amp;lt;/saml:AttributeValue&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;attribute_with_nil_value&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:nil=&#34;true&#34;/&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;attribute_with_nils_and_empty_strings&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue/&amp;gt;&#xA;      &amp;lt;saml:AttributeValue&amp;gt;valuePresent&amp;lt;/saml:AttributeValue&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:nil=&#34;true&#34;/&amp;gt;&#xA;      &amp;lt;saml:AttributeValue xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:nil=&#34;1&#34;/&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;    &amp;lt;saml:Attribute Name=&#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname&#34;&amp;gt;&#xA;      &amp;lt;saml:AttributeValue&amp;gt;usersName&amp;lt;/saml:AttributeValue&amp;gt;&#xA;    &amp;lt;/saml:Attribute&amp;gt;&#xA;  &amp;lt;/saml:AttributeStatement&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pp(response.attributes)   # is an OneLogin::RubySaml::Attributes object&#xA;# =&amp;gt; @attributes=&#xA;  {&#34;uid&#34;=&amp;gt;[&#34;demo&#34;],&#xA;   &#34;another_value&#34;=&amp;gt;[&#34;value1&#34;, &#34;value2&#34;],&#xA;   &#34;role&#34;=&amp;gt;[&#34;role1&#34;, &#34;role2&#34;, &#34;role3&#34;],&#xA;   &#34;attribute_with_nil_value&#34;=&amp;gt;[nil],&#xA;   &#34;attribute_with_nils_and_empty_strings&#34;=&amp;gt;[&#34;&#34;, &#34;valuePresent&#34;, nil, nil]&#xA;   &#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname&#34;=&amp;gt;[&#34;usersName&#34;]}&amp;gt;&#xA;&#xA;# Active single_value_compatibility&#xA;OneLogin::RubySaml::Attributes.single_value_compatibility = true&#xA;&#xA;pp(response.attributes[:uid])&#xA;# =&amp;gt; &#34;demo&#34;&#xA;&#xA;pp(response.attributes[:role])&#xA;# =&amp;gt; &#34;role1&#34;&#xA;&#xA;pp(response.attributes.single(:role))&#xA;# =&amp;gt; &#34;role1&#34;&#xA;&#xA;pp(response.attributes.multi(:role))&#xA;# =&amp;gt; [&#34;role1&#34;, &#34;role2&#34;, &#34;role3&#34;]&#xA;&#xA;pp(response.attributes.fetch(:role))&#xA;# =&amp;gt; &#34;role1&#34;&#xA;&#xA;pp(response.attributes[:attribute_with_nil_value])&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes[:attribute_with_nils_and_empty_strings])&#xA;# =&amp;gt; &#34;&#34;&#xA;&#xA;pp(response.attributes[:not_exists])&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes.single(:not_exists))&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes.multi(:not_exists))&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes.fetch(/givenname/))&#xA;# =&amp;gt; &#34;usersName&#34;&#xA;&#xA;# Deprecated single_value_compatibility&#xA;OneLogin::RubySaml::Attributes.single_value_compatibility = false&#xA;&#xA;pp(response.attributes[:uid])&#xA;# =&amp;gt; [&#34;demo&#34;]&#xA;&#xA;pp(response.attributes[:role])&#xA;# =&amp;gt; [&#34;role1&#34;, &#34;role2&#34;, &#34;role3&#34;]&#xA;&#xA;pp(response.attributes.single(:role))&#xA;# =&amp;gt; &#34;role1&#34;&#xA;&#xA;pp(response.attributes.multi(:role))&#xA;# =&amp;gt; [&#34;role1&#34;, &#34;role2&#34;, &#34;role3&#34;]&#xA;&#xA;pp(response.attributes.fetch(:role))&#xA;# =&amp;gt; [&#34;role1&#34;, &#34;role2&#34;, &#34;role3&#34;]&#xA;&#xA;pp(response.attributes[:attribute_with_nil_value])&#xA;# =&amp;gt; [nil]&#xA;&#xA;pp(response.attributes[:attribute_with_nils_and_empty_strings])&#xA;# =&amp;gt; [&#34;&#34;, &#34;valuePresent&#34;, nil, nil]&#xA;&#xA;pp(response.attributes[:not_exists])&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes.single(:not_exists))&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes.multi(:not_exists))&#xA;# =&amp;gt; nil&#xA;&#xA;pp(response.attributes.fetch(/givenname/))&#xA;# =&amp;gt; [&#34;usersName&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;saml:AuthnContextClassRef&lt;/code&gt; of the AuthNRequest can be provided by &lt;code&gt;settings.authn_context&lt;/code&gt;; possible values are described at [SAMLAuthnCxt]. The comparison method can be set using &lt;code&gt;settings.authn_context_comparison&lt;/code&gt; parameter. Possible values include: &#39;exact&#39;, &#39;better&#39;, &#39;maximum&#39; and &#39;minimum&#39; (default value is &#39;exact&#39;). To add a &lt;code&gt;saml:AuthnContextDeclRef&lt;/code&gt;, define &lt;code&gt;settings.authn_context_decl_ref&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In a SP-initiated flow, the SP can indicate to the IdP the subject that should be authenticated. This is done by defining the &lt;code&gt;settings.name_identifier_value_requested&lt;/code&gt; before building the authrequest object.&lt;/p&gt; &#xA;&lt;h2&gt;Service Provider Metadata&lt;/h2&gt; &#xA;&lt;p&gt;To form a trusted pair relationship with the IdP, the SP (you) need to provide metadata XML to the IdP for various good reasons. (Caching, certificate lookups, relaying party permissions, etc)&lt;/p&gt; &#xA;&lt;p&gt;The class &lt;code&gt;OneLogin::RubySaml::Metadata&lt;/code&gt; takes care of this by reading the Settings and returning XML. All you have to do is add a controller to return the data, then give this URL to the IdP administrator.&lt;/p&gt; &#xA;&lt;p&gt;The metadata will be polled by the IdP every few minutes, so updating your settings should propagate to the IdP settings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SamlController &amp;lt; ApplicationController&#xA;  # ... the rest of your controller definitions ...&#xA;  def metadata&#xA;    settings = Account.get_saml_settings&#xA;    meta = OneLogin::RubySaml::Metadata.new&#xA;    render :xml =&amp;gt; meta.generate(settings), :content_type =&amp;gt; &#34;application/samlmetadata+xml&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can add &lt;code&gt;ValidUntil&lt;/code&gt; and &lt;code&gt;CacheDuration&lt;/code&gt; to the SP Metadata XML using instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  # Valid until =&amp;gt; 2 days from now&#xA;  # Cache duration = 604800s = 1 week&#xA;  valid_until = Time.now + 172800&#xA;  cache_duration = 604800&#xA;  meta.generate(settings, false, valid_until, cache_duration)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Signing and Decryption&lt;/h2&gt; &#xA;&lt;p&gt;Ruby SAML supports the following functionality:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Signing your SP Metadata XML&lt;/li&gt; &#xA; &lt;li&gt;Signing your SP SAML messages&lt;/li&gt; &#xA; &lt;li&gt;Decrypting IdP Assertion messages upon receipt (EncryptedAssertion)&lt;/li&gt; &#xA; &lt;li&gt;Verifying signatures on SAML messages and IdP Assertions&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;In order to use functions 1-3 above, you must first define your SP public certificate and private key:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.certificate = &#34;CERTIFICATE TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;  settings.private_key = &#34;PRIVATE KEY TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the same certificate (and its associated private key) are used to perform all decryption and signing-related functions (1-4) above. Ruby SAML does not currently allow to specify different certificates for each function.&lt;/p&gt; &#xA;&lt;p&gt;You may also globally set the SP signature and digest method, to be used in SP signing (functions 1 and 2 above):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.security[:digest_method]    = XMLSecurity::Document::SHA1&#xA;  settings.security[:signature_method] = XMLSecurity::Document::RSA_SHA1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Signing SP Metadata&lt;/h4&gt; &#xA;&lt;p&gt;You may add a &lt;code&gt;&amp;lt;ds:Signature&amp;gt;&lt;/code&gt; digital signature element to your SP Metadata XML using the following setting:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.certificate = &#34;CERTIFICATE TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;  settings.private_key = &#34;PRIVATE KEY TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;&#xA;  settings.security[:metadata_signed] = true # Enable signature on Metadata&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Signing SP SAML Messages&lt;/h4&gt; &#xA;&lt;p&gt;Ruby SAML supports SAML request signing. The Service Provider will sign the request/responses with its private key. The Identity Provider will then validate the signature of the received request/responses with the public X.509 cert of the Service Provider.&lt;/p&gt; &#xA;&lt;p&gt;To enable, please first set your certificate and private key. This will add &lt;code&gt;&amp;lt;md:KeyDescriptor use=&#34;signing&#34;&amp;gt;&lt;/code&gt; to your SP Metadata XML, to be read by the IdP.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.certificate = &#34;CERTIFICATE TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;  settings.private_key = &#34;PRIVATE KEY TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, you may specify the specific SP SAML messages you would like to sign:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.security[:authn_requests_signed]   = true  # Enable signature on AuthNRequest&#xA;  settings.security[:logout_requests_signed]  = true  # Enable signature on Logout Request&#xA;  settings.security[:logout_responses_signed] = true  # Enable signature on Logout Response&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Signatures will be handled automatically for both &lt;code&gt;HTTP-Redirect&lt;/code&gt; and &lt;code&gt;HTTP-Redirect&lt;/code&gt; Binding. Note that the RelayState parameter is used when creating the Signature on the &lt;code&gt;HTTP-Redirect&lt;/code&gt; Binding. Remember to provide it to the Signature builder if you are sending a &lt;code&gt;GET RelayState&lt;/code&gt; parameter or the signature validation process will fail at the Identity Provider.&lt;/p&gt; &#xA;&lt;h4&gt;Decrypting IdP SAML Assertions&lt;/h4&gt; &#xA;&lt;p&gt;Ruby SAML supports EncryptedAssertion. The Identity Provider will encrypt the Assertion with the public cert of the Service Provider. The Service Provider will decrypt the EncryptedAssertion with its private key.&lt;/p&gt; &#xA;&lt;p&gt;You may enable EncryptedAssertion as follows. This will add &lt;code&gt;&amp;lt;md:KeyDescriptor use=&#34;encrytion&#34;&amp;gt;&lt;/code&gt; to your SP Metadata XML, to be read by the IdP.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.certificate = &#34;CERTIFICATE TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;  settings.private_key = &#34;PRIVATE KEY TEXT WITH BEGIN/END HEADER AND FOOTER&#34;&#xA;&#xA;  settings.security[:want_assertions_encrypted] = true # Invalidate SAML messages without an EncryptedAssertion&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Verifying Signature on IdP Assertions&lt;/h4&gt; &#xA;&lt;p&gt;You may require the IdP to sign its SAML Assertions using the following setting. With will add &lt;code&gt;&amp;lt;md:SPSSODescriptor WantAssertionsSigned=&#34;true&#34;&amp;gt;&lt;/code&gt; to your SP Metadata XML. The signature will be checked against the &lt;code&gt;&amp;lt;md:KeyDescriptor use=&#34;signing&#34;&amp;gt;&lt;/code&gt; element present in the IdP&#39;s metadata.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.security[:want_assertions_signed]  = true  # Require the IdP to sign its SAML Assertions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Certificate and Signature Validation&lt;/h4&gt; &#xA;&lt;p&gt;You may require SP and IdP certificates to be non-expired using the following settings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.security[:check_idp_cert_expiration] = true  # Raise error if IdP X.509 cert is expired&#xA;  settings.security[:check_sp_cert_expiration] = true   # Raise error SP X.509 cert is expired&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, Ruby SAML will raise a &lt;code&gt;OneLogin::RubySaml::ValidationError&lt;/code&gt; if a signature or certificate validation fails. You may disable such exceptions using the &lt;code&gt;settings.security[:soft]&lt;/code&gt; parameter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.security[:soft] = true  # Do not raise error on failed signature/certificate validations&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Audience Validation&lt;/h4&gt; &#xA;&lt;p&gt;A service provider should only consider a SAML response valid if the IdP includes an &#xA; &lt;audiencerestriction&gt;&#xA;   element containting an &#xA;  &lt;audience&gt;&#xA;    element that uniquely identifies the service provider. Unless you specify the &#xA;   &lt;code&gt;skip_audience&lt;/code&gt; option, Ruby SAML will validate that each SAML response includes an &#xA;   &lt;audience&gt;&#xA;     element whose contents matches &#xA;    &lt;code&gt;settings.sp_entity_id&lt;/code&gt;.&#xA;   &lt;/audience&gt;&#xA;  &lt;/audience&gt;&#xA; &lt;/audiencerestriction&gt;&lt;/p&gt; &#xA;&lt;p&gt;By default, Ruby SAML considers an &#xA; &lt;audiencerestriction&gt;&#xA;   element containing only empty &#xA;  &lt;audience&gt;&#xA;    elements to be valid. That means an otherwise valid SAML response with a condition like this would be valid:&#xA;  &lt;/audience&gt;&#xA; &lt;/audiencerestriction&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;AudienceRestriction&amp;gt;&#xA;  &amp;lt;Audience /&amp;gt;&#xA;&amp;lt;/AudienceRestriction&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may enforce that an &#xA; &lt;audiencerestriction&gt;&#xA;   element containing only empty &#xA;  &lt;audience&gt;&#xA;    elements is invalid using the &#xA;   &lt;code&gt;settings.security[:strict_audience_validation]&lt;/code&gt; parameter.&#xA;  &lt;/audience&gt;&#xA; &lt;/audiencerestriction&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;settings.security[:strict_audience_validation] = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Key Rollover&lt;/h4&gt; &#xA;&lt;p&gt;To update the SP X.509 certificate and private key without disruption of service, you may define the parameter &lt;code&gt;settings.certificate_new&lt;/code&gt;. This will publish the new SP certificate in your metadata so that your IdP counterparties may cache it in preparation for rollover.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you to rollover from &lt;code&gt;CERT A&lt;/code&gt; to &lt;code&gt;CERT B&lt;/code&gt;. Before rollover, your settings should look as follows. Both &lt;code&gt;CERT A&lt;/code&gt; and &lt;code&gt;CERT B&lt;/code&gt; will now appear in your SP metadata, however &lt;code&gt;CERT A&lt;/code&gt; will still be used for signing and encryption at this time.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.certificate = &#34;CERT A&#34;&#xA;  settings.private_key = &#34;PRIVATE KEY FOR CERT A&#34;&#xA;  settings.certificate_new = &#34;CERT B&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After the IdP has cached &lt;code&gt;CERT B&lt;/code&gt;, you may then change your settings as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  settings.certificate = &#34;CERT B&#34;&#xA;  settings.private_key = &#34;PRIVATE KEY FOR CERT B&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Single Log Out&lt;/h2&gt; &#xA;&lt;p&gt;Ruby SAML supports SP-initiated Single Logout and IdP-Initiated Single Logout.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example that we could add to our previous controller to generate and send a SAML Logout Request to the IdP:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Create a SP initiated SLO&#xA;def sp_logout_request&#xA;  # LogoutRequest accepts plain browser requests w/o paramters&#xA;  settings = saml_settings&#xA;&#xA;  if settings.idp_slo_service_url.nil?&#xA;    logger.info &#34;SLO IdP Endpoint not found in settings, executing then a normal logout&#39;&#34;&#xA;    delete_session&#xA;  else&#xA;&#xA;    logout_request = OneLogin::RubySaml::Logoutrequest.new&#xA;    logger.info &#34;New SP SLO for userid &#39;#{session[:userid]}&#39; transactionid &#39;#{logout_request.uuid}&#39;&#34;&#xA;&#xA;    if settings.name_identifier_value.nil?&#xA;      settings.name_identifier_value = session[:userid]&#xA;    end&#xA;&#xA;    # Ensure user is logged out before redirect to IdP, in case anything goes wrong during single logout process (as recommended by saml2int [SDP-SP34])&#xA;    logged_user = session[:userid]&#xA;    logger.info &#34;Delete session for &#39;#{session[:userid]}&#39;&#34;&#xA;    delete_session&#xA;&#xA;    # Save the transaction_id to compare it with the response we get back&#xA;    session[:transaction_id] = logout_request.uuid&#xA;    session[:logged_out_user] = logged_user&#xA;&#xA;    relayState = url_for(controller: &#39;saml&#39;, action: &#39;index&#39;)&#xA;    redirect_to(logout_request.create(settings, :RelayState =&amp;gt; relayState))&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This method processes the SAML Logout Response sent by the IdP as the reply of the SAML Logout Request:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# After sending an SP initiated LogoutRequest to the IdP, we need to accept&#xA;# the LogoutResponse, verify it, then actually delete our session.&#xA;def process_logout_response&#xA;  settings = Account.get_saml_settings&#xA;&#xA;  if session.has_key? :transaction_id&#xA;    logout_response = OneLogin::RubySaml::Logoutresponse.new(params[:SAMLResponse], settings, :matches_request_id =&amp;gt; session[:transaction_id])&#xA;  else&#xA;    logout_response = OneLogin::RubySaml::Logoutresponse.new(params[:SAMLResponse], settings)&#xA;  end&#xA;&#xA;  logger.info &#34;LogoutResponse is: #{logout_response.to_s}&#34;&#xA;&#xA;  # Validate the SAML Logout Response&#xA;  if not logout_response.validate&#xA;    logger.error &#34;The SAML Logout Response is invalid&#34;&#xA;  else&#xA;    # Actually log out this session&#xA;    logger.info &#34;SLO completed for &#39;#{session[:logged_out_user]}&#39;&#34;&#xA;    delete_session&#xA;  end&#xA;end&#xA;&#xA;# Delete a user&#39;s session.&#xA;def delete_session&#xA;  session[:userid] = nil&#xA;  session[:attributes] = nil&#xA;  session[:transaction_id] = nil&#xA;  session[:logged_out_user] = nil&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is an example that we could add to our previous controller to process a SAML Logout Request from the IdP and reply with a SAML Logout Response to the IdP:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Method to handle IdP initiated logouts&#xA;def idp_logout_request&#xA;  settings = Account.get_saml_settings&#xA;  # ADFS URL-Encodes SAML data as lowercase, and the toolkit by default uses&#xA;  # uppercase. Turn it True for ADFS compatibility on signature verification&#xA;  settings.security[:lowercase_url_encoding] = true&#xA;&#xA;  logout_request = OneLogin::RubySaml::SloLogoutrequest.new(&#xA;    params[:SAMLRequest], settings: settings&#xA;  )&#xA;  if !logout_request.is_valid?&#xA;    logger.error &#34;IdP initiated LogoutRequest was not valid!&#34;&#xA;    return render :inline =&amp;gt; logger.error&#xA;  end&#xA;  logger.info &#34;IdP initiated Logout for #{logout_request.name_id}&#34;&#xA;&#xA;  # Actually log out this session&#xA;  delete_session&#xA;&#xA;  # Generate a response to the IdP.&#xA;  logout_request_id = logout_request.id&#xA;  logout_response = OneLogin::RubySaml::SloLogoutresponse.new.create(settings, logout_request_id, nil, :RelayState =&amp;gt; params[:RelayState])&#xA;  redirect_to logout_response&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All the mentioned methods could be handled in a unique view:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Trigger SP and IdP initiated Logout requests&#xA;def logout&#xA;  # If we&#39;re given a logout request, handle it in the IdP logout initiated method&#xA;  if params[:SAMLRequest]&#xA;    return idp_logout_request&#xA;  # We&#39;ve been given a response back from the IdP, process it&#xA;  elsif params[:SAMLResponse]&#xA;    return process_logout_response&#xA;  # Initiate SLO (send Logout Request)&#xA;  else&#xA;    return sp_logout_request&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Clock Drift&lt;/h2&gt; &#xA;&lt;p&gt;Server clocks tend to drift naturally. If during validation of the response you get the error &#34;Current time is earlier than NotBefore condition&#34;, this may be due to clock differences between your system and that of the Identity Provider.&lt;/p&gt; &#xA;&lt;p&gt;First, ensure that both systems synchronize their clocks, using for example the industry standard &lt;a href=&#34;http://en.wikipedia.org/wiki/Network_Time_Protocol&#34;&gt;Network Time Protocol (NTP)&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Even then you may experience intermittent issues, as the clock of the Identity Provider may drift slightly ahead of your system clocks. To allow for a small amount of clock drift, you can initialize the response by passing in an option named &lt;code&gt;:allowed_clock_drift&lt;/code&gt;. Its value must be given in a number (and/or fraction) of seconds. The value given is added to the current time at which the response is validated before it&#39;s tested against the &lt;code&gt;NotBefore&lt;/code&gt; assertion. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], :allowed_clock_drift =&amp;gt; 1.second)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure to keep the value as comfortably small as possible to keep security risks to a minimum.&lt;/p&gt; &#xA;&lt;h2&gt;Deflation Limit&lt;/h2&gt; &#xA;&lt;p&gt;To protect against decompression bombs (a form of DoS attack), SAML messages are limited to 250,000 bytes by default. Sometimes legitimate SAML messages will exceed this limit, for example due to custom claims like including groups a user is a member of. If you want to customize this limit, you need to provide a different setting when initializing the response object. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def consume&#xA;  response = OneLogin::RubySaml::Response.new(params[:SAMLResponse], { settings: saml_settings })&#xA;  ...&#xA;end&#xA;&#xA;private&#xA;&#xA;def saml_settings&#xA;  OneLogin::RubySaml::Settings.new(message_max_bytesize: 500_000)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Attribute Service&lt;/h2&gt; &#xA;&lt;p&gt;To request attributes from the IdP the SP needs to provide an attribute service within it&#39;s metadata and reference the index in the assertion.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;settings = OneLogin::RubySaml::Settings.new&#xA;settings.attributes_index = 5&#xA;settings.attribute_consuming_service.configure do&#xA;  service_name &#34;Service&#34;&#xA;  service_index 5&#xA;  add_attribute :name =&amp;gt; &#34;Name&#34;, :name_format =&amp;gt; &#34;Name Format&#34;, :friendly_name =&amp;gt; &#34;Friendly Name&#34;&#xA;  add_attribute :name =&amp;gt; &#34;Another Attribute&#34;, :name_format =&amp;gt; &#34;Name Format&#34;, :friendly_name =&amp;gt; &#34;Friendly Name&#34;, :attribute_value =&amp;gt; &#34;Attribute Value&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;attribute_value&lt;/code&gt; option additionally accepts an array of possible values.&lt;/p&gt; &#xA;&lt;h2&gt;Custom Metadata Fields&lt;/h2&gt; &#xA;&lt;p&gt;Some IdPs may require to add SPs to add additional fields (Organization, ContactPerson, etc.) into the SP metadata. This can be achieved by extending the &lt;code&gt;OneLogin::RubySaml::Metadata&lt;/code&gt; class and overriding the &lt;code&gt;#add_extras&lt;/code&gt; method as per the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyMetadata &amp;lt; OneLogin::RubySaml::Metadata&#xA;  def add_extras(root, _settings)&#xA;    org = root.add_element(&#34;md:Organization&#34;)&#xA;    org.add_element(&#34;md:OrganizationName&#34;, &#39;xml:lang&#39; =&amp;gt; &#34;en-US&#34;).text = &#39;ACME Inc.&#39;&#xA;    org.add_element(&#34;md:OrganizationDisplayName&#34;, &#39;xml:lang&#39; =&amp;gt; &#34;en-US&#34;).text = &#39;ACME&#39;&#xA;    org.add_element(&#34;md:OrganizationURL&#34;, &#39;xml:lang&#39; =&amp;gt; &#34;en-US&#34;).text = &#39;https://www.acme.com&#39;&#xA;&#xA;    cp = root.add_element(&#34;md:ContactPerson&#34;, &#39;contactType&#39; =&amp;gt; &#39;technical&#39;)&#xA;    cp.add_element(&#34;md:GivenName&#34;).text = &#39;ACME SAML Team&#39;&#xA;    cp.add_element(&#34;md:EmailAddress&#34;).text = &#39;saml@acme.com&#39;&#xA;  end&#xA;end&#xA;&#xA;# Output XML with custom metadata&#xA;MyMetadata.new.generate(settings)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>