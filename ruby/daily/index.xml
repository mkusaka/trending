<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-01T01:39:08Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>learn-co-curriculum/phase-3-orms-mapping-classes-to-database-tables</title>
    <updated>2022-11-01T01:39:08Z</updated>
    <id>tag:github.com,2022-11-01:/learn-co-curriculum/phase-3-orms-mapping-classes-to-database-tables</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-orms-mapping-classes-to-database-tables" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Mapping Ruby Classes to a Database&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Write code that maps a Ruby class to a database table&lt;/li&gt; &#xA; &lt;li&gt;Write code that inserts data regarding an instance of a class into a database table row&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;When building an ORM to connect our Ruby program to a database, we equate a &lt;strong&gt;class&lt;/strong&gt; with a database &lt;strong&gt;table&lt;/strong&gt; and the &lt;strong&gt;instances&lt;/strong&gt; that the class produces to &lt;strong&gt;rows&lt;/strong&gt; in that table.&lt;/p&gt; &#xA;&lt;p&gt;Why map classes to tables? Our end goal is to persist information regarding our objects to a database. In order to persist that data efficiently and in an organized manner, we need to first map or equate our Ruby class to a database table.&lt;/p&gt; &#xA;&lt;h2&gt;Writing an ORM&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s say we are building a music player app that allows users to store their music and browse their songs by song.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE: Remember to run &lt;code&gt;bundle install&lt;/code&gt; to install the dependencies before running your code&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;This program will have a &lt;code&gt;Song&lt;/code&gt; class. Each song instance will have a name and an album attribute. The starter code for this class is in the &lt;code&gt;lib/song.rb&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Song&#xA;&#xA;  attr_accessor :name, :album&#xA;&#xA;  def initialize(name:, album:)&#xA;    @name = name&#xA;    @album = album&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we have an &lt;code&gt;attr_accessor&lt;/code&gt; for &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;album&lt;/code&gt;. In order to &#34;map&#34; this &lt;code&gt;Song&lt;/code&gt; class to a songs database table, we need to create our database, then we need to create our songs table. In building an ORM, it is conventional to pluralize the name of the class to create the name of the table. Therefore, the &lt;code&gt;Song&lt;/code&gt; class equals the &#34;songs&#34; table.&lt;/p&gt; &#xA;&lt;h3&gt;Creating the Database&lt;/h3&gt; &#xA;&lt;p&gt;Before we can create a songs table we need to create our music database. Whose responsibility is it to create the database? It is not the responsibility of our &lt;code&gt;Song&lt;/code&gt; class. Remember, classes are mapped to &lt;em&gt;tables inside a database&lt;/em&gt;, not to the database as a whole. We may want to build other classes that we equate with other database tables later on.&lt;/p&gt; &#xA;&lt;p&gt;It is the responsibility of our program as a whole to create and establish the database. Accordingly, you&#39;ll see our Ruby programs set up such that they have a &lt;code&gt;config&lt;/code&gt; directory that contains an &lt;code&gt;environment.rb&lt;/code&gt; file. In our application, the file looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;bundler&#39;&#xA;Bundler.require&#xA;&#xA;require_relative &#39;../lib/song&#39;&#xA;&#xA;DB = { conn: SQLite3::Database.new(&#34;db/music.db&#34;) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we set up a constant, &lt;code&gt;DB&lt;/code&gt;, that is equal to a hash that contains our connection to the database. In our &lt;code&gt;lib/song.rb&lt;/code&gt; file, we can therefore access the &lt;code&gt;DB&lt;/code&gt; constant and the database connection it holds like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;DB[:conn]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The starter code for these files is set up, so you can explore it and code along with the rest of this lesson.&lt;/p&gt; &#xA;&lt;h3&gt;Creating the Table&lt;/h3&gt; &#xA;&lt;p&gt;According to the ORM convention in which a class is mapped to or equated with a database table, we need to create a songs table. We will accomplish this by writing a class method in our &lt;code&gt;Song&lt;/code&gt; class that creates this table.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;To &#34;map&#34; our class to a database table, we will create a table with the same name, pluralized, as our class, and give that table column names that match the &lt;code&gt;attr_accessor&lt;/code&gt;s of our class.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Update the &lt;code&gt;Song&lt;/code&gt; class as follows so that it maps instance attributes to table columns:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Song&#xA;&#xA;  attr_accessor :name, :album, :id&#xA;&#xA;  def initialize(name:, album:, id: nil)&#xA;    @id = id&#xA;    @name = name&#xA;    @album = album&#xA;  end&#xA;&#xA;  def self.create_table&#xA;    sql =  &amp;lt;&amp;lt;-SQL&#xA;      CREATE TABLE IF NOT EXISTS songs (&#xA;        id INTEGER PRIMARY KEY,&#xA;        name TEXT,&#xA;        album TEXT&#xA;      )&#xA;      SQL&#xA;    DB[:conn].execute(sql)&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s break down this code.&lt;/p&gt; &#xA;&lt;h4&gt;The &lt;code&gt;id&lt;/code&gt; Attribute&lt;/h4&gt; &#xA;&lt;p&gt;Notice that we are initializing an individual &lt;code&gt;Song&lt;/code&gt; instance with an &lt;code&gt;id&lt;/code&gt; attribute that has a default value of &lt;code&gt;nil&lt;/code&gt;. Why are we doing this? First of all, songs need an &lt;code&gt;id&lt;/code&gt; attribute only because they will be saved into the database and we know that each table row needs an &lt;code&gt;id&lt;/code&gt; value which is the primary key.&lt;/p&gt; &#xA;&lt;p&gt;When we create a new song with the &lt;code&gt;Song.new&lt;/code&gt; method, we &lt;em&gt;do not set that song&#39;s id&lt;/em&gt;. A song gets an &lt;code&gt;id&lt;/code&gt; only when it gets saved into the database (more on inserting songs into the database later). We therefore set the default value of the &lt;code&gt;id&lt;/code&gt; argument for the &lt;code&gt;#initialize&lt;/code&gt; equal to &lt;code&gt;nil&lt;/code&gt;, so that we can create new song instances that do not have an &lt;code&gt;id&lt;/code&gt; value. We&#39;ll leave that up to the database to handle later on.&lt;/p&gt; &#xA;&lt;p&gt;Why leave it up to the database? Remember that in the world of relational database, the &lt;code&gt;id&lt;/code&gt; of a given record must be unique. If we could replicate a record&#39;s &lt;code&gt;id&lt;/code&gt;, we would have a very disorganized database. Only the database itself, through the magic of SQL, can ensure that the &lt;code&gt;id&lt;/code&gt; of each record is unique.&lt;/p&gt; &#xA;&lt;h4&gt;The &lt;code&gt;.create_table&lt;/code&gt; Method&lt;/h4&gt; &#xA;&lt;p&gt;Above, we created a class method, &lt;code&gt;.create_table&lt;/code&gt;, that crafts a SQL statement to create a songs table and give that table column names that match the attributes of an individual instance of &lt;code&gt;Song&lt;/code&gt;. Why is the &lt;code&gt;.create_table&lt;/code&gt; method a class method? Well, it is &lt;em&gt;not&lt;/em&gt; the responsibility of an individual song to create the table it will eventually be saved into. It is the job of the class as a whole to create the table that it is mapped to.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Top-Tip:&lt;/strong&gt; For strings that will take up multiple lines in your text editor, use a &lt;a href=&#34;https://en.wikipedia.org/wiki/Here_document&#34;&gt;heredoc&lt;/a&gt; to create a string that runs on to multiple lines. &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; + &lt;code&gt;special word meaning &#34;End of Document&#34;&lt;/code&gt; + &lt;code&gt;the string, on multiple lines&lt;/code&gt; + &lt;code&gt;special word meaning &#34;End of Document&#34;&lt;/code&gt;. You don&#39;t have to use a heredoc, it&#39;s just a helpful tool for crafting long strings in Ruby. Back to our regularly scheduled programming...&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Now that our songs table exists, we can learn how to save data regarding individual songs into that table.&lt;/p&gt; &#xA;&lt;p&gt;You can try out this code now to create the table in the &lt;code&gt;db/music.db&lt;/code&gt; file. Check out the code in the &lt;code&gt;bin/run&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;#!/usr/bin/env ruby&#xA;&#xA;require &#39;pry&#39;&#xA;require_relative &#39;../config/environment&#39;&#xA;&#xA;binding.pry&#xA;&#34;pls&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this file, we&#39;re requiring in the &lt;code&gt;environment.rb&lt;/code&gt; file (which loads the code for our database connection, as well as the &lt;code&gt;Song&lt;/code&gt; class), and has a &lt;code&gt;binding.pry&lt;/code&gt; to set a breakpoint where you can enter a Pry session.&lt;/p&gt; &#xA;&lt;p&gt;Run &lt;code&gt;ruby bin/run&lt;/code&gt; to enter Pry, then run the &lt;code&gt;Song.create_table&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;Song.create_table&#xA;# =&amp;gt; []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Creating a table doesn&#39;t return any data, so SQLite returns an empty array from the last line of our method (&lt;code&gt;DB[:conn].execute(sql)&lt;/code&gt;). If you&#39;d like to confirm that the table was created successfully, you can run a special &lt;code&gt;PRAGMA&lt;/code&gt; command to show the information about the &lt;code&gt;songs&lt;/code&gt; table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;DB[:conn].execute(&#34;PRAGMA table_info(songs)&#34;)&#xA;# =&amp;gt; [[0, &#34;id&#34;, &#34;INTEGER&#34;, 0, nil, 1], [1, &#34;name&#34;, &#34;TEXT&#34;, 0, nil, 0], [2, &#34;album&#34;, &#34;TEXT&#34;, 0, nil, 0]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output isn&#39;t easy to read, but you&#39;ll see the different column names (&lt;code&gt;id&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;album&lt;/code&gt;) along with their data types (&lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;TEXT&lt;/code&gt;, &lt;code&gt;TEXT&lt;/code&gt;). Success!&lt;/p&gt; &#xA;&lt;h2&gt;Mapping Class Instances to Table Rows&lt;/h2&gt; &#xA;&lt;p&gt;When we say that we are saving data to our database, what data are we referring to? If individual instances of a class are &#34;mapped&#34; to rows in a table, does that mean that the instances themselves, these individual Ruby objects, are saved into the database?&lt;/p&gt; &#xA;&lt;p&gt;Actually, &lt;strong&gt;we are not saving Ruby objects in our database.&lt;/strong&gt; We are going to take the individual attributes of a given instance, in this case a song&#39;s name and album, and save &lt;em&gt;those attributes that describe an individual song&lt;/em&gt; to the database as one, single row.&lt;/p&gt; &#xA;&lt;p&gt;For example, let&#39;s say we have a song:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gold_digger = Song.new(name: &#34;Gold Digger&#34;, album: &#34;Late Registration&#34;)&#xA;&#xA;gold_digger.name&#xA;# =&amp;gt; &#34;Gold Digger&#34;&#xA;&#xA;gold_digger.album&#xA;# =&amp;gt; &#34;Late Registration&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This song has its two attributes, &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;album&lt;/code&gt;, set equal to the above values. In order to save the song &lt;code&gt;gold_digger&lt;/code&gt; into the songs table, we will use the name and album of the song to create a new row in that table. The SQL statement we want to execute would look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO songs (name, album)&#xA;VALUES (&#34;Gold Digger&#34;, &#34;Late Registration&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What if we had another song that we wanted to save?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;hello = Song.new(name: &#34;Hello&#34;, album: &#34;25&#34;)&#xA;&#xA;hello.name&#xA;# =&amp;gt; &#34;Hello&#34;&#xA;&#xA;hello.album&#xA;# =&amp;gt; &#34;25&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to save &lt;code&gt;hello&lt;/code&gt; into our database, we do not insert the Ruby object stored in the &lt;code&gt;hello&lt;/code&gt; variable. Instead, we use &lt;code&gt;hello&lt;/code&gt;&#39;s name and album values to create a new row in the songs table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO songs (name, album)&#xA;VALUES (&#34;Hello&#34;, &#34;25&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can see that the operation of saving the attributes of a particular song into a database table is common enough. Every time we want to save a record, though, we are repeating the same exact steps and using the same code. The only things that are different are the values that we are inserting into our songs table. Let&#39;s abstract this functionality into an instance method, &lt;code&gt;#save&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Inserting Data into a table with the &lt;code&gt;#save&lt;/code&gt; Method&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s build an instance method, &lt;code&gt;#save&lt;/code&gt;, that saves a given instance of our &lt;code&gt;Song&lt;/code&gt; class into the songs table of our database.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Song&#xA;&#xA;  # ... rest of song methods&#xA;&#xA;  def save&#xA;    sql = &amp;lt;&amp;lt;-SQL&#xA;      INSERT INTO songs (name, album)&#xA;      VALUES (?, ?)&#xA;    SQL&#xA;&#xA;    DB[:conn].execute(sql, self.name, self.album)&#xA;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s break down the code in this method.&lt;/p&gt; &#xA;&lt;h4&gt;The &lt;code&gt;#save&lt;/code&gt; Method&lt;/h4&gt; &#xA;&lt;p&gt;In order to &lt;code&gt;INSERT&lt;/code&gt; data into our songs table, we need to craft a SQL &lt;code&gt;INSERT&lt;/code&gt; statement. Ideally, it would look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO songs (name, album)&#xA;VALUES songs_name, songs_album&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Above, we used the heredoc to craft our multi-line SQL statement. How are we going to pass in, or interpolate, the name and album of a given song into our heredoc?&lt;/p&gt; &#xA;&lt;p&gt;We use something called &lt;strong&gt;bound parameters&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Bound Parameters&lt;/h4&gt; &#xA;&lt;p&gt;Bound parameters protect our program from getting confused by &lt;a href=&#34;https://en.wikipedia.org/wiki/SQL_injection&#34;&gt;SQL injections&lt;/a&gt; and special characters. Instead of interpolating variables into a string of SQL, we are using the &lt;code&gt;?&lt;/code&gt; characters as placeholders. Then, the special magic provided to us by the SQLite3-Ruby gem&#39;s &lt;code&gt;#execute&lt;/code&gt; method will take the values we pass in as an argument and apply them as the values of the question marks.&lt;/p&gt; &#xA;&lt;h4&gt;How it works&lt;/h4&gt; &#xA;&lt;p&gt;So, our &lt;code&gt;#save&lt;/code&gt; method inserts a record into our database that has the name and album values of the song instance we are trying to save. We are not saving the Ruby object itself. We are creating a new row in our songs table that has the values that characterize that song instance.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important:&lt;/strong&gt; Notice that we &lt;em&gt;didn&#39;t&lt;/em&gt; insert an ID number into the table with the above statement. Remember that the &lt;code&gt;INTEGER PRIMARY KEY&lt;/code&gt; datatype will assign and auto-increment the id attribute of each record that gets saved.&lt;/p&gt; &#xA;&lt;h2&gt;Creating Instances vs. Creating Table Rows&lt;/h2&gt; &#xA;&lt;p&gt;The moment in which we create a new &lt;code&gt;Song&lt;/code&gt; instance with the &lt;code&gt;#initialize&lt;/code&gt; method is &lt;em&gt;different than the moment in which we save a representation of that song to our database&lt;/em&gt;. The &lt;code&gt;#initialize&lt;/code&gt; method creates a new instance of the song class, a new Ruby object. The &lt;code&gt;#save&lt;/code&gt; method takes the attributes that characterize a given song and saves them in a new row of the songs table in our database.&lt;/p&gt; &#xA;&lt;p&gt;At what point in time should we actually save a new record? While it is possible to save the record right at the moment the new object is created, i.e. in the &lt;code&gt;#initialize&lt;/code&gt; method, this is not a great idea. We don&#39;t want to force our objects to be saved every time they are created, or make the creation of an object dependent upon/always coupled with saving a record to the database. As our program grows and changes, we may find the need to create objects and not save them. A dependency between instantiating an object and saving that record to the database would preclude this or, at the very least, make it harder to implement.&lt;/p&gt; &#xA;&lt;p&gt;So, we&#39;ll keep our &lt;code&gt;#initialize&lt;/code&gt; and &lt;code&gt;#save&lt;/code&gt; methods separate:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Song&#xA;&#xA;  attr_accessor :name, :album, :id&#xA;&#xA;  def initialize(name:, album:, id: nil)&#xA;    @id = id&#xA;    @name = name&#xA;    @album = album&#xA;  end&#xA;&#xA;  def self.create_table&#xA;    sql =  &amp;lt;&amp;lt;-SQL&#xA;      CREATE TABLE IF NOT EXISTS songs (&#xA;        id INTEGER PRIMARY KEY,&#xA;        name TEXT,&#xA;        album TEXT&#xA;        )&#xA;        SQL&#xA;    DB[:conn].execute(sql)&#xA;  end&#xA;&#xA;  def save&#xA;    sql = &amp;lt;&amp;lt;-SQL&#xA;      INSERT INTO songs (name, album)&#xA;      VALUES (?, ?)&#xA;    SQL&#xA;&#xA;    DB[:conn].execute(sql, self.name, self.album)&#xA;&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, we can create and save songs like this. Try this out by running &lt;code&gt;ruby bin/run&lt;/code&gt; and running this code in the Pry session (make sure to exit out of Pry in order to reload the code if you left it open earlier):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;hello = Song.new(name: &#34;Hello&#34;, album: &#34;25&#34;)&#xA;# =&amp;gt; #&amp;lt;Song:0x00007fed21935128 @album=&#34;25&#34;, @id=nil, @name=&#34;Hello&#34;&amp;gt;&#xA;hello.save&#xA;# =&amp;gt; []&#xA;ninety_nine_problems = Song.new(name: &#34;99 Problems&#34;, album: &#34;The Black Album&#34;)&#xA;# =&amp;gt; #&amp;lt;Song:0x00007fed218c6200 @album=&#34;The Black Album&#34;, @id=nil, @name=&#34;99 Problems&#34;&amp;gt;&#xA;ninety_nine_problems.save&#xA;# =&amp;gt; []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That last line of the &lt;code&gt;#save&lt;/code&gt; method returns an empty array once more since &lt;code&gt;INSERT&lt;/code&gt;ing new rows in a database doesn&#39;t return any data, but you can check if all the records were indeed saved by running this in your Pry session:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;pry(main)&amp;gt; DB[:conn].execute(&#34;SELECT * FROM songs;&#34;)&#xA;# =&amp;gt; [[1, &#34;Hello&#34;, &#34;25&#34;], [2, &#34;99 Problems&#34;, &#34;The Black Album&#34;]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Giving Our &lt;code&gt;Song&lt;/code&gt; Instance an &lt;code&gt;id&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;When we &lt;code&gt;INSERT&lt;/code&gt; the data concerning a particular &lt;code&gt;Song&lt;/code&gt; instance into our database table, we create a new row in that table. That row would look something like this:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;id&lt;/th&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;album&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;Hello&lt;/td&gt; &#xA;   &lt;td&gt;25&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Notice that the database table&#39;s row has a column for &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;album&lt;/code&gt; and also &lt;code&gt;id&lt;/code&gt;. Recall that we created our table to have a column for the primary key, ID, of a given record. So, as each record gets inserted into the database, it is given an ID number automatically.&lt;/p&gt; &#xA;&lt;p&gt;In this way, our &lt;code&gt;hello&lt;/code&gt; instance is stored in the database with the name and album that we gave it, &lt;em&gt;plus&lt;/em&gt; an ID number that the database assigns to it.&lt;/p&gt; &#xA;&lt;p&gt;We want our &lt;code&gt;hello&lt;/code&gt; instance to completely reflect the database row it is associated with so that we can retrieve it from the table later on with ease. So, once the new row with &lt;code&gt;hello&lt;/code&gt;&#39;s data is inserted into the table, let&#39;s grab the &lt;code&gt;ID&lt;/code&gt; of that newly inserted row and assign it to be the value of &lt;code&gt;hello&lt;/code&gt;&#39;s &lt;code&gt;id&lt;/code&gt; attribute.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Song&#xA;&#xA;  attr_accessor :name, :album, :id&#xA;&#xA;  def initialize(name:, album:, id: nil)&#xA;    @id = id&#xA;    @name = name&#xA;    @album = album&#xA;  end&#xA;&#xA;  # ... rest of song methods&#xA;&#xA;  def save&#xA;    sql = &amp;lt;&amp;lt;-SQL&#xA;      INSERT INTO songs (name, album)&#xA;      VALUES (?, ?)&#xA;    SQL&#xA;&#xA;    # insert the song&#xA;    DB[:conn].execute(sql, self.name, self.album)&#xA;&#xA;    # get the song ID from the database and save it to the Ruby instance&#xA;    self.id = DB[:conn].execute(&#34;SELECT last_insert_rowid() FROM songs&#34;)[0][0]&#xA;&#xA;    # return the Ruby instance&#xA;    self&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;At the end of our &lt;code&gt;#save&lt;/code&gt; method, we use a SQL query to grab the value of the &lt;code&gt;id&lt;/code&gt; column of the last inserted row, and set that equal to the given song instance&#39;s &lt;code&gt;id&lt;/code&gt; attribute. Don&#39;t worry too much about how that SQL query works for now, we&#39;ll learn more about it later. The important thing to understand is the process of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Instantiating a new instance of the &lt;code&gt;Song&lt;/code&gt; class.&lt;/li&gt; &#xA; &lt;li&gt;Inserting a new row into the database table that contains the information regarding that instance.&lt;/li&gt; &#xA; &lt;li&gt;Grabbing the &lt;code&gt;id&lt;/code&gt; of that newly inserted row and assigning the given &lt;code&gt;Song&lt;/code&gt; instance&#39;s &lt;code&gt;id&lt;/code&gt; attribute equal to the &lt;code&gt;id&lt;/code&gt; of its associated database table row.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Let&#39;s revisit our code that instantiated and saved some songs by running &lt;code&gt;ruby bin/run&lt;/code&gt; again and entering this in Pry:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;hello = Song.new(name: &#34;Hello&#34;, album: &#34;25&#34;)&#xA;# =&amp;gt; #&amp;lt;Song:0x00007fed21935128 @album=&#34;25&#34;, @id=nil, @name=&#34;Hello&#34;&amp;gt;&#xA;hello.save&#xA;# =&amp;gt; #&amp;lt;Song:0x00007fb61d202a58 @album=&#34;25&#34;, @id=3, @name=&#34;Hello&#34;&amp;gt;&#xA;ninety_nine_problems = Song.new(name: &#34;99 Problems&#34;, album: &#34;The Black Album&#34;)&#xA;# =&amp;gt; #&amp;lt;Song:0x00007fed218c6200 @album=&#34;The Black Album&#34;, @id=nil, @name=&#34;99 Problems&#34;&amp;gt;&#xA;ninety_nine_problems.save&#xA;# =&amp;gt; #&amp;lt;Song:0x00007fb61d14c820 @album=&#34;The Black Album&#34;, @id=4, @name=&#34;99 Problems&#34;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create the songs table.&lt;/li&gt; &#xA; &lt;li&gt;Create two new song instances.&lt;/li&gt; &#xA; &lt;li&gt;Use the &lt;code&gt;Song#save&lt;/code&gt; method to persist them to the database.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This approach still leaves a little to be desired, however. Here, we have to first create the new song and then save it, every time we want to create and save a song. This is repetitive and tedious. As programmers (you might remember), we are lazy. If we can accomplish something with fewer lines of code we do it. &lt;strong&gt;Any time we see the same code being used again and again, we think about abstracting that code into a method.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Since first creating an object and then saving a record representing that object is so common, let&#39;s write a method that does just that.&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;.create&lt;/code&gt; Method&lt;/h3&gt; &#xA;&lt;p&gt;This method will wrap the code we used above to create a new &lt;code&gt;Song&lt;/code&gt; instance and save it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Song&#xA;  # ... rest of song methods&#xA;&#xA;  def self.create(name:, album:)&#xA;    song = Song.new(name: name, album: album)&#xA;    song.save&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, we use keyword arguments to pass a name and album into our &lt;code&gt;.create&lt;/code&gt; method. We use that name and album to instantiate a new song. Then, we use the &lt;code&gt;#save&lt;/code&gt; method to persist that song to the database.&lt;/p&gt; &#xA;&lt;p&gt;Notice that at the end of the method, we are returning the &lt;code&gt;song&lt;/code&gt; instance that we instantiated. The return value of &lt;code&gt;.create&lt;/code&gt; should always be the object that we created. Why? Imagine you are working with your program and you create a new song:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Song.create(name: &#34;Hello&#34;, album: &#34;25&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, we would have to run a separate query on our database to grab the record that we just created. That is way too much work for us. It would be much easier for our &lt;code&gt;.create&lt;/code&gt; method to simply return the new object for us to work with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;song = Song.create(name: &#34;Hello&#34;, album: &#34;25&#34;)&#xA;# =&amp;gt; #&amp;lt;Song:0x007f94f2c28ee8 @id=1, @name=&#34;Hello&#34;, @album=&#34;25&#34;&amp;gt;&#xA;&#xA;song.name&#xA;# =&amp;gt; &#34;Hello&#34;&#xA;&#xA;song.album&#xA;# =&amp;gt; &#34;25&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Excellent! Run &lt;code&gt;learn test&lt;/code&gt; now to pass the tests and submit the assignment.&lt;/p&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;The important concept to grasp here is the idea that we are &lt;em&gt;not&lt;/em&gt; saving Ruby objects into our database. We are using the attributes of a given Ruby object to create a new row in our database table.&lt;/p&gt; &#xA;&lt;p&gt;Think of it like making butter cookies. You have a cookie cutter, which in our case would be our class. It describes what a cookie should look like. Then you use it to cut out a cookie, or instantiate a class object. But that&#39;s not enough, you have to show it to your friends. So you take a picture of it and post to your MyFace account and share it with everybody else, like how your database can share information with other parts of your program.&lt;/p&gt; &#xA;&lt;p&gt;The picture doesn&#39;t do anything to the cookie itself, but merely captures certain aspects of it. It&#39;s a butter cookie, it looks fresh and delicious, and it has little sprinkles on it. Those aspects are captured in the picture, but the cookie and the picture are still two different things. After you eat the cookie, or in our case after you delete the Ruby object, the database will not change at all until the record is deleted, and vice versa.&lt;/p&gt;</summary>
  </entry>
</feed>