<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-02T01:36:49Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Shopify/statsd-instrument</title>
    <updated>2022-09-02T01:36:49Z</updated>
    <id>tag:github.com,2022-09-02:/Shopify/statsd-instrument</id>
    <link href="https://github.com/Shopify/statsd-instrument" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A StatsD client for Ruby apps. Provides metaprogramming methods to inject StatsD instrumentation into your code.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;StatsD client for Ruby apps&lt;/h1&gt; &#xA;&lt;p&gt;This is a ruby client for statsd (&lt;a href=&#34;https://github.com/statsd/statsd&#34;&gt;https://github.com/statsd/statsd&lt;/a&gt;). It provides a lightweight way to track and measure metrics in your application.&lt;/p&gt; &#xA;&lt;p&gt;We call out to statsd by sending data over a UDP socket. UDP sockets are fast, but unreliable, there is no guarantee that your data will ever arrive at its location. In other words, fire and forget. This is perfect for this use case because it means your code doesn&#39;t get bogged down trying to log statistics. We send data to statsd several times per request and haven&#39;t noticed a performance hit.&lt;/p&gt; &#xA;&lt;p&gt;For more information about StatsD, see the &lt;a href=&#34;https://github.com/statsd/statsd&#34;&gt;README of the StatsD project&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s recommended to configure this library by setting environment variables. The following environment variables are supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;STATSD_ADDR&lt;/code&gt;: (default &lt;code&gt;localhost:8125&lt;/code&gt;) The address to send the StatsD UDP datagrams to.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;STATSD_IMPLEMENTATION&lt;/code&gt;: (default: &lt;code&gt;datadog&lt;/code&gt;). The StatsD implementation you are using. &lt;code&gt;statsd&lt;/code&gt; and &lt;code&gt;datadog&lt;/code&gt; are supported. Some features are only available on certain implementations,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;STATSD_ENV&lt;/code&gt;: The environment StatsD will run in. If this is not set explicitly, this will be determined based on other environment variables, like &lt;code&gt;RAILS_ENV&lt;/code&gt; or &lt;code&gt;ENV&lt;/code&gt;. The library will behave differently:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;In the &lt;strong&gt;production&lt;/strong&gt; and &lt;strong&gt;staging&lt;/strong&gt; environment, the library will actually send UDP packets.&lt;/li&gt; &#xA;   &lt;li&gt;In the &lt;strong&gt;test&lt;/strong&gt; environment, it will swallow all calls, but allows you to capture them for testing purposes. See below for notes on writing tests.&lt;/li&gt; &#xA;   &lt;li&gt;In &lt;strong&gt;development&lt;/strong&gt; and all other environments, it will write all calls to the log (&lt;code&gt;StatsD.logger&lt;/code&gt;, which by default writes to STDOUT).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;STATSD_SAMPLE_RATE&lt;/code&gt;: (default: &lt;code&gt;1.0&lt;/code&gt;) The default sample rate to use for all metrics. This can be used to reduce the amount of network traffic and CPU overhead the usage of this library generates. This can be overridden in a metric method call.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;STATSD_PREFIX&lt;/code&gt;: The prefix to apply to all metric names. This can be overridden in a metric method call.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;STATSD_DEFAULT_TAGS&lt;/code&gt;: A comma-separated list of tags to apply to all metrics. (Note: tags are not supported by all implementations.)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;STATSD_BUFFER_CAPACITY&lt;/code&gt;: (default: &lt;code&gt;5000&lt;/code&gt;) The maximum amount of events that may be buffered before emitting threads will start to block. Increasing this value may help for application generating spikes of events. However if the application emit events faster than they can be sent, increasing it won&#39;t help. If set to &lt;code&gt;0&lt;/code&gt;, batching will be disabled, and events will be sent in individual UDP packets, which is much slower.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;STATSD_FLUSH_INTERVAL&lt;/code&gt;: (default: &lt;code&gt;1&lt;/code&gt;) Deprecated. Setting this to &lt;code&gt;0&lt;/code&gt; is equivalent to setting &lt;code&gt;STATSD_BUFFER_CAPACITY&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;STATSD_MAX_PACKET_SIZE&lt;/code&gt;: (default: &lt;code&gt;1472&lt;/code&gt;) The maximum size of UDP packets. If your network is properly configured to handle larger packets you may try to increase this value for better performance, but most network can&#39;t handle larger packets.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;StatsD keys&lt;/h2&gt; &#xA;&lt;p&gt;StatsD keys look like &#39;admin.logins.api.success&#39;. Dots are used as namespace separators.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;You can either use the basic methods to submit stats over StatsD, or you can use the metaprogramming methods to instrument your methods with some basic stats (call counts, successes &amp;amp; failures, and timings).&lt;/p&gt; &#xA;&lt;h4&gt;StatsD.measure&lt;/h4&gt; &#xA;&lt;p&gt;Lets you benchmark how long the execution of a specific method takes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# You can pass a key and a ms value&#xA;StatsD.measure(&#39;GoogleBase.insert&#39;, 2.55)&#xA;&#xA;# or more commonly pass a block that calls your code&#xA;StatsD.measure(&#39;GoogleBase.insert&#39;) do&#xA;  GoogleBase.insert(product)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;StatsD.increment&lt;/h4&gt; &#xA;&lt;p&gt;Lets you increment a key in statsd to keep a count of something. If the specified key doesn&#39;t exist it will create it for you.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# increments default to +1&#xA;StatsD.increment(&#39;GoogleBase.insert&#39;)&#xA;# you can also specify how much to increment the key by&#xA;StatsD.increment(&#39;GoogleBase.insert&#39;, 10)&#xA;# you can also specify a sample rate, so only 1/10 of events&#xA;# actually get to statsd. Useful for very high volume data&#xA;StatsD.increment(&#39;GoogleBase.insert&#39;, sample_rate: 0.1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;StatsD.gauge&lt;/h4&gt; &#xA;&lt;p&gt;A gauge is a single numerical value that tells you the state of the system at a point in time. A good example would be the number of messages in a queue.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;StatsD.gauge(&#39;GoogleBase.queued&#39;, 12, sample_rate: 1.0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Normally, you shouldn&#39;t update this value too often, and therefore there is no need to sample this kind metric.&lt;/p&gt; &#xA;&lt;h4&gt;StatsD.set&lt;/h4&gt; &#xA;&lt;p&gt;A set keeps track of the number of unique values that have been seen. This is a good fit for keeping track of the number of unique visitors. The value can be a string.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Submit the customer ID to the set. It will only be counted if it hasn&#39;t been seen before.&#xA;StatsD.set(&#39;GoogleBase.customers&#39;, &#34;12345&#34;, sample_rate: 1.0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because you are counting unique values, the results of using a sampling value less than 1.0 can lead to unexpected, hard to interpret results.&lt;/p&gt; &#xA;&lt;h4&gt;StatsD.histogram&lt;/h4&gt; &#xA;&lt;p&gt;Builds a histogram of numeric values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#xA;StatsD.histogram(&#39;Order.value&#39;, order.value_in_usd.to_f, tags: { source: &#39;POS&#39; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because you are counting unique values, the results of using a sampling value less than 1.0 can lead to unexpected, hard to interpret results.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: This is only supported by the beta datadog implementation.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;StatsD.distribution&lt;/h4&gt; &#xA;&lt;p&gt;A modified gauge that submits a distribution of values over a sample period. Arithmetic and statistical calculations (percentiles, average, etc.) on the data set are performed server side rather than client side like a histogram.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;StatsD.distribution(&#39;shipit.redis_connection&#39;, 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: This is only supported by the beta datadog implementation.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;StatsD.event&lt;/h4&gt; &#xA;&lt;p&gt;An event is a (title, text) tuple that can be used to correlate metrics with something that occurred within the system. This is a good fit for instance to correlate response time variation with a deploy of the new code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;StatsD.event(&#39;shipit.deploy&#39;, &#39;started&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: This is only supported by the &lt;a href=&#34;https://docs.datadoghq.com/guides/dogstatsd/#events&#34;&gt;datadog implementation&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Events support additional metadata such as &lt;code&gt;date_happened&lt;/code&gt;, &lt;code&gt;hostname&lt;/code&gt;, &lt;code&gt;aggregation_key&lt;/code&gt;, &lt;code&gt;priority&lt;/code&gt;, &lt;code&gt;source_type_name&lt;/code&gt;, &lt;code&gt;alert_type&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;StatsD.service_check&lt;/h4&gt; &#xA;&lt;p&gt;An event is a (check_name, status) tuple that can be used to monitor the status of services your application depends on.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;StatsD.service_check(&#39;shipit.redis_connection&#39;, &#39;ok&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: This is only supported by the &lt;a href=&#34;https://docs.datadoghq.com/guides/dogstatsd/#service-checks&#34;&gt;datadog implementation&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Service checks support additional metadata such as &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;hostname&lt;/code&gt;, &lt;code&gt;message&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Metaprogramming Methods&lt;/h3&gt; &#xA;&lt;p&gt;As mentioned, it&#39;s most common to use the provided metaprogramming methods. This lets you define all of your instrumentation in one file and not litter your code with instrumentation details. You should enable a class for instrumentation by extending it with the &lt;code&gt;StatsD::Instrument&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;GoogleBase.extend StatsD::Instrument&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then use the methods provided below to instrument methods in your class.&lt;/p&gt; &#xA;&lt;h4&gt;statsd_measure&lt;/h4&gt; &#xA;&lt;p&gt;This will measure how long a method takes to run, and submits the result to the given key.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;GoogleBase.statsd_measure :insert, &#39;GoogleBase.insert&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;statsd_count&lt;/h4&gt; &#xA;&lt;p&gt;This will increment the given key even if the method doesn&#39;t finish (ie. raises).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;GoogleBase.statsd_count :insert, &#39;GoogleBase.insert&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note how I used the &#39;GoogleBase.insert&#39; key above when measuring this method, and I reused here when counting the method calls. StatsD automatically separates these two kinds of stats into namespaces so there won&#39;t be a key collision here.&lt;/p&gt; &#xA;&lt;h4&gt;statsd_count_if&lt;/h4&gt; &#xA;&lt;p&gt;This will only increment the given key if the method executes successfully.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;GoogleBase.statsd_count_if :insert, &#39;GoogleBase.insert&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So now, if GoogleBase#insert raises an exception or returns false (ie. result == false), we won&#39;t increment the key. If you want to define what success means for a given method you can pass a block that takes the result of the method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;GoogleBase.statsd_count_if :insert, &#39;GoogleBase.insert&#39; do |response|&#xA;  response.code == 200&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above example we will only increment the key in statsd if the result of the block returns true. So the method is returning a Net::HTTP response and we&#39;re checking the status code.&lt;/p&gt; &#xA;&lt;h4&gt;statsd_count_success&lt;/h4&gt; &#xA;&lt;p&gt;Similar to statsd_count_if, except this will increment one key in the case of success and another key in the case of failure.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;GoogleBase.statsd_count_success :insert, &#39;GoogleBase.insert&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So if this method fails execution (raises or returns false) we&#39;ll increment the failure key (&#39;GoogleBase.insert.failure&#39;), otherwise we&#39;ll increment the success key (&#39;GoogleBase.insert.success&#39;). Notice that we&#39;re modifying the given key before sending it to statsd.&lt;/p&gt; &#xA;&lt;p&gt;Again you can pass a block to define what success means.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;GoogleBase.statsd_count_success :insert, &#39;GoogleBase.insert&#39; do |response|&#xA;  response.code == 200&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Instrumenting Class Methods&lt;/h3&gt; &#xA;&lt;p&gt;You can instrument class methods, just like instance methods, using the metaprogramming methods. You simply have to configure the instrumentation on the singleton class of the Class you want to instrument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;AWS::S3::Base.singleton_class.statsd_measure :request, &#39;S3.request&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dynamic Metric Names&lt;/h3&gt; &#xA;&lt;p&gt;You can use a lambda function instead of a string dynamically set the name of the metric. The lambda function must accept two arguments: the object the function is being called on and the array of arguments passed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;GoogleBase.statsd_count :insert, lambda{|object, args| object.class.to_s.downcase + &#34;.&#34; + args.first.to_s + &#34;.insert&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tags&lt;/h3&gt; &#xA;&lt;p&gt;The Datadog implementation supports tags, which you can use to slice and dice metrics in their UI. You can specify a list of tags as an option, either standalone tag (e.g. &lt;code&gt;&#34;mytag&#34;&lt;/code&gt;), or key value based, separated by a colon: &lt;code&gt;&#34;env:production&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;StatsD.increment(&#39;my.counter&#39;, tags: [&#39;env:production&#39;, &#39;unicorn&#39;])&#xA;GoogleBase.statsd_count :insert, &#39;GoogleBase.insert&#39;, tags: [&#39;env:production&#39;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If implementation is not set to &lt;code&gt;:datadog&lt;/code&gt;, tags will not be included in the UDP packets, and a warning is logged to &lt;code&gt;StatsD.logger&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;This library comes with a module called &lt;code&gt;StatsD::Instrument::Assertions&lt;/code&gt; and &lt;code&gt;StatsD::Instrument::Matchers&lt;/code&gt; to help you write tests to verify StatsD is called properly.&lt;/p&gt; &#xA;&lt;h3&gt;minitest&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyTestcase &amp;lt; Minitest::Test&#xA;  include StatsD::Instrument::Assertions&#xA;&#xA;  def test_some_metrics&#xA;    # This will pass if there is exactly one matching StatsD call&#xA;    # it will ignore any other, non matching calls.&#xA;    assert_statsd_increment(&#39;counter.name&#39;, sample_rate: 1.0) do&#xA;      StatsD.increment(&#39;unrelated&#39;) # doesn&#39;t match&#xA;      StatsD.increment(&#39;counter.name&#39;, sample_rate: 1.0) # matches&#xA;      StatsD.increment(&#39;counter.name&#39;, sample_rate: 0.1) # doesn&#39;t match&#xA;    end&#xA;&#xA;    # Set `times` if there will be multiple matches:&#xA;    assert_statsd_increment(&#39;counter.name&#39;, times: 2) do&#xA;      StatsD.increment(&#39;unrelated&#39;) # doesn&#39;t match&#xA;      StatsD.increment(&#39;counter.name&#39;, sample_rate: 1.0) # matches&#xA;      StatsD.increment(&#39;counter.name&#39;, sample_rate: 0.1) # matches too&#xA;    end&#xA;  end&#xA;&#xA;  def test_no_udp_traffic&#xA;    # Verifies no StatsD calls occurred at all.&#xA;    assert_no_statsd_calls do&#xA;      do_some_work&#xA;    end&#xA;&#xA;    # Verifies no StatsD calls occurred for the given metric.&#xA;    assert_no_statsd_calls(&#39;metric_name&#39;) do&#xA;      do_some_work&#xA;    end&#xA;  end&#xA;&#xA;  def test_more_complicated_stuff&#xA;    # capture_statsd_calls will capture all the StatsD calls in the&#xA;    # given block, and returns them as an array. You can then run your&#xA;    # own assertions on it.&#xA;    metrics = capture_statsd_calls do&#xA;      StatsD.increment(&#39;mycounter&#39;, sample_rate: 0.01)&#xA;    end&#xA;&#xA;    assert_equal 1, metrics.length&#xA;    assert_equal &#39;mycounter&#39;, metrics[0].name&#xA;    assert_equal :c, metrics[0].type&#xA;    assert_equal 1, metrics[0].value&#xA;    assert_equal 0.01, metrics[0].sample_rate&#xA;  end&#xA;end&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;RSpec&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;RSpec.configure do |config|&#xA;  config.include StatsD::Instrument::Matchers&#xA;end&#xA;&#xA;RSpec.describe &#39;Matchers&#39; do&#xA;  context &#39;trigger_statsd_increment&#39; do&#xA;    it &#39;will pass if there is exactly one matching StatsD call&#39; do&#xA;      expect { StatsD.increment(&#39;counter&#39;) }.to trigger_statsd_increment(&#39;counter&#39;)&#xA;    end&#xA;&#xA;    it &#39;will pass if it matches the correct number of times&#39; do&#xA;      expect {&#xA;        2.times do&#xA;          StatsD.increment(&#39;counter&#39;)&#xA;        end&#xA;      }.to trigger_statsd_increment(&#39;counter&#39;, times: 2)&#xA;    end&#xA;&#xA;    it &#39;will pass if it matches argument&#39; do&#xA;      expect {&#xA;        StatsD.measure(&#39;counter&#39;, 0.3001)&#xA;      }.to trigger_statsd_measure(&#39;counter&#39;, value: be_between(0.29, 0.31))&#xA;    end&#xA;&#xA;    it &#39;will pass if there is no matching StatsD call on negative expectation&#39; do&#xA;      expect { StatsD.increment(&#39;other_counter&#39;) }.not_to trigger_statsd_increment(&#39;counter&#39;)&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Notes&lt;/h2&gt; &#xA;&lt;h3&gt;Compatibility&lt;/h3&gt; &#xA;&lt;p&gt;The library is tested against Ruby 2.3 and higher. We are not testing on different Ruby implementations besides MRI, but we expect it to work on other implementations as well.&lt;/p&gt; &#xA;&lt;h3&gt;Reliance on DNS&lt;/h3&gt; &#xA;&lt;p&gt;Out of the box StatsD is set up to be unidirectional fire-and-forget over UDP. Configuring the StatsD host to be a non-ip will trigger a DNS lookup (i.e. a synchronous TCP round trip). This can be particularly problematic in clouds that have a shared DNS infrastructure such as AWS.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Using a hardcoded IP avoids the DNS lookup but generally requires an application deploy to change.&lt;/li&gt; &#xA; &lt;li&gt;Hardcoding the DNS/IP pair in /etc/hosts allows the IP to change without redeploying your application but fails to scale as the number of servers increases.&lt;/li&gt; &#xA; &lt;li&gt;Installing caching software such as nscd that uses the DNS TTL avoids most DNS lookups but makes the exact moment of change indeterminate.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Links&lt;/h2&gt; &#xA;&lt;p&gt;This library was developed for shopify.com and is MIT licensed.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.rubydoc.info/gems/statsd-instrument&#34;&gt;API documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/statsd-instrument/master/CHANGELOG.md&#34;&gt;The changelog&lt;/a&gt; covers the changes between releases.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/statsd-instrument/master/CONTRIBUTING.md&#34;&gt;Contributing notes&lt;/a&gt; if you are interested in contributing to this library.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>Shopify/shipit-engine</title>
    <updated>2022-09-02T01:36:49Z</updated>
    <id>tag:github.com,2022-09-02:/Shopify/shipit-engine</id>
    <link href="https://github.com/Shopify/shipit-engine" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Deployment coordination&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Shipit - Documentation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/Shopify/shipit-engine&#34;&gt;&lt;img src=&#34;https://travis-ci.org/Shopify/shipit-engine.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://badge.fury.io/rb/shipit-engine&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/shipit-engine.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Shipit&lt;/strong&gt; is a deployment tool that makes shipping code better for everyone. It&#39;s especially great for large teams of developers and designers who work together to build and deploy GitHub repos. You can use it to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;add new applications to your deployment environment without having to change core configuration files repeatedly — &lt;code&gt;shipit.yml&lt;/code&gt; is basically plug and play&lt;/li&gt; &#xA; &lt;li&gt;control the pace of development by pushing, locking, and rolling back deploys from within Shipit&lt;/li&gt; &#xA; &lt;li&gt;enforce checklists and provide monitoring right at the point of deployment.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Shipit is compatible with just about anything that you can deploy using a script. It natively detects stacks using &lt;a href=&#34;http://bundler.io/&#34;&gt;bundler&lt;/a&gt; and &lt;a href=&#34;http://capistranorb.com/&#34;&gt;Capistrano&lt;/a&gt;, and it has tools that make it easy to deploy to &lt;a href=&#34;https://www.heroku.com/&#34;&gt;Heroku&lt;/a&gt; or &lt;a href=&#34;https://rubygems.org/&#34;&gt;RubyGems&lt;/a&gt;. At Shopify, we&#39;ve used Shipit to synchronize and deploy hundreds of projects across dozens of teams, using Python, Rails, RubyGems, Java, and Go.&lt;/p&gt; &#xA;&lt;p&gt;This guide aims to help you &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#installation-and-setup&#34;&gt;set up&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#using-shipit&#34;&gt;use&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#reference&#34;&gt;understand&lt;/a&gt; Shipit.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Shipit requires a database (MySQL, PostgreSQL or SQLite3), redis, and Ruby 2.6 or superior.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2 id=&#34;toc&#34;&gt;Table of contents&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;I. INSTALLATION &amp;amp; SETUP&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#updating-shipit&#34;&gt;Updating an existing installation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;II. USING SHIPIT&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#adding-stacks&#34;&gt;Adding stacks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#working-on-stacks&#34;&gt;Working on stacks&lt;/a&gt;,&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#configuring-stacks&#34;&gt;Configuring stacks&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;III. REFERENCE&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#configuring-shipit&#34;&gt;Format and content of shipit.yml&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#script-parameters&#34;&gt;Script parameters&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#configuring-providers&#34;&gt;Configuring providers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/examples/shipit.yml&#34;&gt;Free samples&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;IV. INTEGRATING&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#integrating-webhooks&#34;&gt;Registering webhooks&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;V. CONTRIBUTING&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#contributing-instructions&#34;&gt;Instructions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#contributing-local-dev&#34;&gt;Local development&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2 id=&#34;installation-and-setup&#34;&gt;I. INSTALLATION &amp;amp; SETUP&lt;/h2&gt; &#xA;&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;To create a new Shipit installation you can follow the &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/docs/setup.md&#34;&gt;setup guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3 id=&#34;updating-shipit&#34;&gt;Updating an existing installation&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;If you locked the gem to a specific version in your Gemfile, update it there.&lt;/li&gt; &#xA; &lt;li&gt;Update the &lt;code&gt;shipit-engine&lt;/code&gt; gem with &lt;code&gt;bundle update shipit-engine&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Install new migrations with &lt;code&gt;rake shipit:install:migrations db:migrate&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3 id=&#34;special-update&#34;&gt;Specific updates requiring more steps&lt;/h3&gt; &#xA;&lt;p&gt;If you are upgrading from &lt;code&gt;0.21&lt;/code&gt; or older, you will have to update the configuration. Please follow &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/docs/updates/0.22.md&#34;&gt;the dedicated upgrade guide&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2 id=&#34;using-shipit&#34;&gt;II. USING SHIPIT&lt;/h2&gt; &#xA;&lt;p&gt;The main workflows in Shipit are &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#adding-stacks&#34;&gt;adding stacks&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#working-on-stacks&#34;&gt;working on stacks&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#configuring-stacks&#34;&gt;configuring stacks&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;strong&gt;stack&lt;/strong&gt; is composed of a GitHub repository, a branch, and a deployment environment. Shipit tracks the commits made to the branch, and then displays them in the stack overview. From there, you can deploy the branch to whatever environment you&#39;ve chosen (some typical environments include &lt;em&gt;production&lt;/em&gt;, &lt;em&gt;staging&lt;/em&gt;, &lt;em&gt;performance&lt;/em&gt;, etc.).&lt;/p&gt; &#xA;&lt;h3 id=&#34;adding-stacks&#34;&gt;Add a new stack&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;From the main page in Shipit, click &lt;strong&gt;Add a stack&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;On the &lt;strong&gt;Create a stack&lt;/strong&gt; page, enter the required information: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Repo&lt;/li&gt; &#xA;   &lt;li&gt;Branch&lt;/li&gt; &#xA;   &lt;li&gt;Environment&lt;/li&gt; &#xA;   &lt;li&gt;Deploy URL&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;When you&#39;re finished, click &lt;strong&gt;Create stack&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3 id=&#34;working-on-stacks&#34;&gt;Work on an existing stack&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;If you want to browse the list of available stacks, click &lt;strong&gt;Show all stacks&lt;/strong&gt; on the main page in Shipit. If you know the name of the stack you&#39;re looking for, enter it in the search field.&lt;/li&gt; &#xA; &lt;li&gt;Click the name of the stack you want to open.&lt;/li&gt; &#xA; &lt;li&gt;From a stack&#39;s overview page, you can: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;review previous deploys&lt;/li&gt; &#xA;   &lt;li&gt;deploy any undeployed commits by clicking &lt;strong&gt;Deploy&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;rollback to an earlier build by clicking &lt;strong&gt;Rollback to this deploy&lt;/strong&gt;&lt;/li&gt; &#xA;   &lt;li&gt;adjust the stack&#39;s settings by clicking the gear icon in the page header&lt;/li&gt; &#xA;   &lt;li&gt;perform any custom tasks that are defined in the &lt;code&gt;shipit.yml&lt;/code&gt; file&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;When you&#39;re ready to deploy an undeployed commit, click the relevant &lt;strong&gt;Deploy&lt;/strong&gt; button on the stack&#39;s overview page.&lt;/li&gt; &#xA; &lt;li&gt;From the &lt;strong&gt;Deploy&lt;/strong&gt; page, complete the checklist, then click &lt;strong&gt;Create deploy&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3 id=&#34;configuring-stacks&#34;&gt;Edit stack settings&lt;/h3&gt; &#xA;&lt;p&gt;To edit a stack&#39;s settings, open the stack in Shipit, then click the gear icon in the page header.&lt;/p&gt; &#xA;&lt;p&gt;From a stack&#39;s &lt;strong&gt;Settings&lt;/strong&gt; page, you can:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;change the deploy URL&lt;/li&gt; &#xA; &lt;li&gt;enable and disable continuous deployment&lt;/li&gt; &#xA; &lt;li&gt;lock and unlock deploys through Shipit&lt;/li&gt; &#xA; &lt;li&gt;resynchronize the stack with GitHub&lt;/li&gt; &#xA; &lt;li&gt;delete the stack from Shipit&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2 id=&#34;reference&#34;&gt;III. REFERENCE&lt;/h2&gt; &#xA;&lt;h3 id=&#34;configuring-shipit&#34;&gt;Configuring &lt;code&gt;shipit.yml&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The settings in the &lt;code&gt;shipit.yml&lt;/code&gt; file relate to the different things you can do with Shipit:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#installing-dependencies&#34;&gt;Installing Dependencies&lt;/a&gt; (&lt;code&gt;dependencies&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#deployment&#34;&gt;Deployment&lt;/a&gt; (&lt;code&gt;deploy&lt;/code&gt;, &lt;code&gt;rollback&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#environment&#34;&gt;Environment&lt;/a&gt; (&lt;code&gt;machine.environment&lt;/code&gt;, &lt;code&gt;machine.directory&lt;/code&gt;, &lt;code&gt;machine.cleanup&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#ci&#34;&gt;CI&lt;/a&gt; (&lt;code&gt;ci.require&lt;/code&gt;, &lt;code&gt;ci.hide&lt;/code&gt;, &lt;code&gt;ci.allow_failures&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#merge-queue&#34;&gt;Merge Queue&lt;/a&gt; (&lt;code&gt;merge.revalidate_after&lt;/code&gt;, &lt;code&gt;merge.require&lt;/code&gt;, &lt;code&gt;merge.ignore&lt;/code&gt;, &lt;code&gt;merge.max_divergence&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#custom-tasks&#34;&gt;Custom Tasks&lt;/a&gt; (&lt;code&gt;tasks&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#custom-links&#34;&gt;Custom links&lt;/a&gt; (&lt;code&gt;links&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/#review-process&#34;&gt;Review Process&lt;/a&gt; (&lt;code&gt;review.checklist&lt;/code&gt;, &lt;code&gt;review.monitoring&lt;/code&gt;, &lt;code&gt;review.checks&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All the settings in &lt;code&gt;shipit.yml&lt;/code&gt; are optional. Most applications can be deployed from Shipit without any configuration.&lt;/p&gt; &#xA;&lt;p&gt;Also, if your repository is deployed different ways depending on the environment, you can have an alternative &lt;code&gt;shipit.yml&lt;/code&gt; by including the environment name.&lt;/p&gt; &#xA;&lt;p&gt;For example for a stack like: &lt;code&gt;my-org/my-repo/staging&lt;/code&gt;, &lt;code&gt;shipit.staging.yml&lt;/code&gt; will have priority over &lt;code&gt;shipit.yml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Lastly, if you override the &lt;code&gt;app_name&lt;/code&gt; configuration in your Shipit deployment, &lt;code&gt;yourapp.yml&lt;/code&gt; and &lt;code&gt;yourapp.staging.yml&lt;/code&gt; will work.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3 id=&#34;respecting-bare-files&#34;&gt;Respecting bare &lt;code&gt;shipit.yml&lt;/code&gt; files&lt;/h3&gt; &#xA;&lt;p&gt;Shipit will, by default, respect the &#34;bare&#34; &lt;code&gt;shipit.yml&lt;/code&gt; file as a fallback option if no more specifically-named file exists (such as &lt;code&gt;shipit.staging.yml&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;You can configure this behavior via the attribute &lt;code&gt;Shipit.respect_bare_shipit_file&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The value &lt;code&gt;false&lt;/code&gt; will disable this behavior and instead cause Shipit to emit an error upon deploy if Shipit cannot find a more specifically-named file.&lt;/li&gt; &#xA; &lt;li&gt;Setting this attribute to any other value (&lt;strong&gt;including &lt;code&gt;nil&lt;/code&gt;&lt;/strong&gt;), or not setting this attribute, will cause Shipit to use the default behavior of respecting bare &lt;code&gt;shipit.yml&lt;/code&gt; files.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can determine if Shipit is configured to respect bare files using &lt;code&gt;Shipit.respect_bare_shipit_file?&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3 id=&#34;installing-dependencies&#34;&gt;Installing dependencies&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;strong&gt;&lt;code&gt;dependencies&lt;/code&gt;&lt;/strong&gt; step allows you to install all the packages your deploy script needs.&lt;/p&gt; &#xA;&lt;h4 id=&#34;bundler-support&#34;&gt;Bundler&lt;/h4&gt; &#xA;&lt;p&gt;If your application uses Bundler, Shipit will detect it automatically and take care of the &lt;code&gt;bundle install&lt;/code&gt; and prefix your commands with &lt;code&gt;bundle exec&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By default, the following gem groups will be ignored:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;default&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;production&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;development&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;test&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;staging&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;benchmark&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;debug&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The gems you need in order to deploy should be in a different group, such as &lt;code&gt;deploy&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;dependencies:&#xA;  bundler:&#xA;    without:&#xA;      - development&#xA;      - test&#xA;      - debug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4 id=&#34;other-dependencies&#34;&gt;Other dependencies&lt;/h4&gt; &#xA;&lt;p&gt;If your deploy script uses another tool to install dependencies, you can install them manually via &lt;code&gt;dependencies.override&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;dependencies:&#xA;  override:&#xA;    - npm install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;dependencies.pre&lt;/code&gt;&lt;/strong&gt; If you wish to execute commands before Shipit installs the dependencies, you can specify them here.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;dependencies:&#xA;  pre:&#xA;    - mkdir tmp/&#xA;    - cp -R /var/cache/ tmp/cache&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;dependencies.post&lt;/code&gt;&lt;/strong&gt; If you wish to execute commands after Shipit installed the dependencies, you can specify them here:&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;dependencies:&#xA;  post:&#xA;    - cp -R tmp/cache /var/cache/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;h3 id=&#34;deployment&#34;&gt;Deployment&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;deploy&lt;/code&gt; and &lt;code&gt;rollback&lt;/code&gt; sections are the core of Shipit:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;deploy.override&lt;/code&gt;&lt;/strong&gt; contains an array of the shell commands required to deploy the application. Shipit will try to infer it from the repository structure, but you can change the default inference.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;deploy:&#xA;  override:&#xA;    - ./script/deploy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;deploy.pre&lt;/code&gt;&lt;/strong&gt; If you wish to execute commands before Shipit executes your deploy script, you can specify them here.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;deploy:&#xA;  pre:&#xA;    - ./script/notify_deploy_start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;deploy.post&lt;/code&gt;&lt;/strong&gt; If you wish to execute commands after Shipit executed your deploy script, you can specify them here.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;deploy:&#xA;  post:&#xA;    - ./script/notify_deploy_end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;You can also accept custom environment variables defined by the user that triggers the deploy:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;deploy.variables&lt;/code&gt;&lt;/strong&gt; contains an array of variable definitions.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;deploy:&#xA;  variables:&#xA;    -&#xA;      name: RUN_MIGRATIONS&#xA;      title: Run database migrations on deploy&#xA;      default: 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;deploy.variables.select&lt;/code&gt;&lt;/strong&gt; will turn the input into a &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; of values.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;deploy:&#xA;  variables:&#xA;    -&#xA;      name: REGION&#xA;      title: Run a deploy in a given region&#xA;      select:&#xA;        - east&#xA;        - west&#xA;        - north&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;deploy.max_commits&lt;/code&gt;&lt;/strong&gt; defines the maximum number of commits that should be shipped per deploy. Defaults to &lt;code&gt;8&lt;/code&gt; if no value is provided.&lt;/p&gt; &#xA;&lt;p&gt;To disable this limit, you can use use an explicit null value: &lt;code&gt;max_commits: null&lt;/code&gt;. Continuous Delivery will then deploy any number of commits.&lt;/p&gt; &#xA;&lt;p&gt;Human users will be warned that they are not respecting the recommendation, but allowed to continue. However continuous delivery will respect this limit. If there is no deployable commits in this range, a human intervention will be required.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;deploy:&#xA;  max_commits: 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;deploy.interval&lt;/code&gt;&lt;/strong&gt; defines the interval between the end of a deploy and the next deploy, when continuous delivery is enabled. You can use s, m, h, d as units for seconds, minutes, hours, and days. Defaults to 0, which means a new deploy will start as soon as the current one finishes.&lt;/p&gt; &#xA;&lt;p&gt;For example, this will wait 5 minutes after the end of a deploy before starting a new one:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;deploy:&#xA;  interval: 5m&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;deploy.retries&lt;/code&gt;&lt;/strong&gt; enables retries for a stack, and defines the maximum amount of times that Shipit will retry a deploy that finished with a &lt;code&gt;failed&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;timedout&lt;/code&gt; status.&lt;/p&gt; &#xA;&lt;p&gt;For example, this will retry a deploy twice if it fails.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;deploy:&#xA;  retries: 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;rollback.override&lt;/code&gt;&lt;/strong&gt; contains an array of the shell commands required to rollback the application to a previous state. Shipit will try to infer it from the repository structure, but you can change the default inference. This key defaults to &lt;code&gt;disabled&lt;/code&gt; unless Capistrano is detected.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;rollback:&#xA;  override:&#xA;    - ./script/rollback&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;rollback.pre&lt;/code&gt;&lt;/strong&gt; If you wish to execute commands before Shipit executes your rollback script, you can specify them here:&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;rollback:&#xA;  pre:&#xA;    - ./script/notify_rollback_start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;rollback.post&lt;/code&gt;&lt;/strong&gt; If you wish to execute commands after Shipit executed your rollback script, you can specify them here:&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;rollback:&#xA;  post:&#xA;    - ./script/notify_rollback_end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;fetch&lt;/code&gt;&lt;/strong&gt; contains an array of the shell commands that Shipit executes to check the revision of the currently-deployed version. This key defaults to &lt;code&gt;disabled&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;fetch:&#xA;  curl --silent https://app.example.com/services/ping/version&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3 id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;kubernetes&lt;/code&gt;&lt;/strong&gt; allows to specify a Kubernetes namespace and context to deploy to.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;kubernetes:&#xA;  namespace: my-app-production&#xA;  context: tier4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;kubernetes.template_dir&lt;/code&gt;&lt;/strong&gt; allows to specify a Kubernetes template directory. It defaults to &lt;code&gt;./config/deploy/$ENVIRONMENT&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3 id=&#34;environment&#34;&gt;Environment&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;machine.environment&lt;/code&gt;&lt;/strong&gt; contains the extra environment variables that you want to provide during task execution.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;machine:&#xA;  environment:&#xA;    key: val # things added as environment variables&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3 id=&#34;directory&#34;&gt;Directory&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;machine.directory&lt;/code&gt;&lt;/strong&gt; specifies a subfolder in which to execute all tasks. Useful for repositories containing multiple applications or if you don&#39;t want your deploy scripts to be located at the root.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;machine:&#xA;  directory: scripts/deploy/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3 id=&#34;cleanup&#34;&gt;Cleanup&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;machine.cleanup&lt;/code&gt;&lt;/strong&gt; specifies whether or not the deploy working directory should be cleaned up once the deploy completed. Defaults to &lt;code&gt;true&lt;/code&gt;, but can be useful to disable temporarily to investigate bugs.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;machine:&#xA;  cleanup: false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3 id=&#34;ci&#34;&gt;CI&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;ci.require&lt;/code&gt;&lt;/strong&gt; contains an array of the &lt;a href=&#34;https://docs.github.com/en/rest/reference/commits#commit-statuses&#34;&gt;statuses context&lt;/a&gt; you want Shipit to disallow deploys if any of them is missing on the commit being deployed.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;ci:&#xA;  require:&#xA;    - ci/circleci&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;ci.hide&lt;/code&gt;&lt;/strong&gt; contains an array of the &lt;a href=&#34;https://docs.github.com/en/rest/reference/commits#commit-statuses&#34;&gt;statuses context&lt;/a&gt; you want Shipit to ignore.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;ci:&#xA;  hide:&#xA;    - ci/circleci&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;ci.allow_failures&lt;/code&gt;&lt;/strong&gt; contains an array of the &lt;a href=&#34;https://docs.github.com/en/rest/reference/commits#commit-statuses&#34;&gt;statuses context&lt;/a&gt; you want to be visible but not to required for deploy.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;ci:&#xA;  allow_failures:&#xA;    - ci/circleci&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;ci.blocking&lt;/code&gt;&lt;/strong&gt; contains an array of the &lt;a href=&#34;https://docs.github.com/en/rest/reference/commits#commit-statuses&#34;&gt;statuses context&lt;/a&gt; you want to disallow deploys if any of them is missing or failing on any of the commits being deployed.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;ci:&#xA;  blocking:&#xA;    - soc/compliance&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3 id=&#34;merge-queue&#34;&gt;Merge Queue&lt;/h3&gt; &#xA;&lt;p&gt;The merge queue allows developers to register pull requests which will be merged by Shipit once the stack is clear (no lock, no failing CI, no backlog). It can be enabled on a per stack basis via the settings page.&lt;/p&gt; &#xA;&lt;p&gt;It can be customized via several &lt;code&gt;shipit.yml&lt;/code&gt; properties:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;merge.revalidate_after&lt;/code&gt;&lt;/strong&gt; a duration after which pull requests that couldn&#39;t be merged are rejected from the queue. Defaults to unlimited.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;merge:&#xA;  revalidate_after: 12m30s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;merge.require&lt;/code&gt;&lt;/strong&gt; contains an array of the &lt;a href=&#34;https://docs.github.com/en/rest/reference/commits#commit-statuses&#34;&gt;statuses context&lt;/a&gt; that you want Shipit to consider as failing if they aren&#39;t present on the pull request. Defaults to &lt;code&gt;ci.require&lt;/code&gt; if present, or empty otherwise.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;merge:&#xA;  require:&#xA;    - continuous-integration/travis-ci/push&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;merge.ignore&lt;/code&gt;&lt;/strong&gt; contains an array of the &lt;a href=&#34;https://docs.github.com/en/rest/reference/commits#commit-statuses&#34;&gt;statuses context&lt;/a&gt; that you want Shipit not to consider when merging pull requests. Defaults to the union of &lt;code&gt;ci.allow_failures&lt;/code&gt; and &lt;code&gt;ci.hide&lt;/code&gt; if any is present or empty otherwise.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;merge:&#xA;  ignore:&#xA;    - codeclimate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;merge.method&lt;/code&gt;&lt;/strong&gt; the &lt;a href=&#34;https://docs.github.com/en/rest/reference/pulls#merge-a-pull-request--parameters&#34;&gt;merge method&lt;/a&gt; to use for this stack. If it&#39;s not set the default merge method will be used. Can be either &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;squash&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;merge:&#xA;  method: squash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;merge.max_divergence.commits&lt;/code&gt;&lt;/strong&gt; the maximum number of commits a pull request can be behind its merge base, after which pull requests are rejected from the merge queue.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;merge:&#xA;  max_divergence:&#xA;    commits: 50&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;merge.max_divergence.age&lt;/code&gt;&lt;/strong&gt; a duration after the commit date of the merge base, after which pull requests will be rejected from the merge queue.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;merge:&#xA;  max_divergence:&#xA;    age: 72h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3 id=&#34;custom-tasks&#34;&gt;Custom tasks&lt;/h3&gt; &#xA;&lt;p&gt;You can create custom tasks that users execute directly from a stack&#39;s overview page in Shipit. To create a new custom task, specify its parameters in the &lt;code&gt;tasks&lt;/code&gt; section of the &lt;code&gt;shipit.yml&lt;/code&gt; file. For example:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;tasks.restart&lt;/code&gt;&lt;/strong&gt; restarts the application.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;tasks:&#xA;  restart:&#xA;    action: &#34;Restart Application&#34;&#xA;    description: &#34;Sometimes needed if you want the application to restart but don&#39;t want to ship any new code.&#34;&#xA;    steps:&#xA;      - ssh deploy@myserver.example.com &#39;touch myapp/restart.txt&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, custom tasks are not allowed to be triggered while a deploy is running. But if it&#39;s safe for that specific task, you can change that behavior with the &lt;code&gt;allow_concurrency&lt;/code&gt; attribute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;tasks:&#xA;  flush_cache:&#xA;    action: &#34;Flush Cache&#34;&#xA;    steps:&#xA;      - ssh deploy@myserver.example.com &#39;myapp/flush_cache.sh&#39;&#xA;    allow_concurrency: true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Tasks like deploys can prompt for user defined environment variables:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;tasks:&#xA;  restart:&#xA;    action: &#34;Restart Application&#34;&#xA;    description: &#34;Sometimes needed if you want the application to restart but don&#39;t want to ship any new code.&#34;&#xA;    steps:&#xA;      - ssh deploy@myserver.example.com &#39;touch myapp/restart.txt&#39;&#xA;    variables:&#xA;      -&#xA;        name: FORCE&#xA;        title: Restart server without waiting for in-flight requests to complete (Dangerous).&#xA;        default: 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also make these variables appear in the task title:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;tasks:&#xA;  failover:&#xA;    action: &#34;Failover a pod&#34;&#xA;    title: &#34;Failover Pod %{POD_ID}&#34;&#xA;    steps:&#xA;      - script/failover $POD_ID&#xA;    variables:&#xA;      - name: POD_ID&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3 id=&#34;custom-links&#34;&gt;Custom Links&lt;/h3&gt; &#xA;&lt;p&gt;You can add custom links to the header of a stacks overview page in Shipit. To create a new custom link, specify its parameters in the links section of the shipit.yml file. The link title is a humanized version of the key. For example:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;links.monitoring_dashboard&lt;/code&gt;&lt;/strong&gt; creates a link in the header of of the page titled &#34;Monitoring dashboard&#34;&lt;/p&gt; &#xA;&lt;p&gt;You can specify multiple custom links:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;links:&#xA;  monitoring_dashboard: https://example.com/monitoring.html&#xA;  other_link: https://example.com/something_else.html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3 id=&#34;review-process&#34;&gt;Review process&lt;/h3&gt; &#xA;&lt;p&gt;You can display review elements, such as monitoring data or a pre-deployment checklist, on the deployment page in Shipit:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;review.checklist&lt;/code&gt;&lt;/strong&gt; contains a pre-deploy checklist that appears on the deployment page in Shipit, with each item in the checklist as a separate string in the array. It can contain &lt;code&gt;strong&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; HTML tags. Users cannot deploy from Shipit until they have checked each item in the checklist.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;review:&#xA;  checklist:&#xA;    - &amp;gt;&#xA;      Do you know if it is safe to revert the code being shipped? What happens if we need to undo this deploy?&#xA;    - Has the Docs team been notified of any major changes to the app?&#xA;    - Is the app stable right now?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;review.monitoring&lt;/code&gt;&lt;/strong&gt; contains a list of inclusions that appear on the deployment page in Shipit. Inclusions can either be images or iframes.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;review:&#xA;  monitoring:&#xA;    - image: https://example.com/monitoring.png&#xA;    - iframe: https://example.com/monitoring.html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;review.checks&lt;/code&gt;&lt;/strong&gt; contains a list of commands that will be executed during the pre-deploy review step. Their output appears on the deployment page in Shipit, and if continuous delivery is enabled, deploys will only be triggered if those commands are successful.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;review:&#xA;  checks:&#xA;    - bundle exec rake db:migrate:status&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3 id=&#34;shell-commands-timeout&#34;&gt;Shell commands timeout&lt;/h3&gt; &#xA;&lt;p&gt;All the shell commands can take an optional &lt;code&gt;timeout&lt;/code&gt; parameter to limit their duration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;deploy:&#xA;  override:&#xA;    - ./script/deploy:&#xA;        timeout: 30&#xA;  post:&#xA;    - ./script/notify_deploy_end: { timeout: 15 }&#xA;review:&#xA;  checks:&#xA;    - bundle exec rake db:migrate:status:&#xA;        timeout: 60&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See also &lt;code&gt;commands_inactivity_timeout&lt;/code&gt; in &lt;code&gt;secrets.yml&lt;/code&gt; for a global timeout setting.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2 id=&#34;script-parameters&#34;&gt;Script parameters&lt;/h2&gt; &#xA;&lt;p&gt;Your deploy scripts have access to the following environment variables:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;SHIPIT&lt;/code&gt;: Set to &lt;code&gt;1&lt;/code&gt; to allow your script to know it&#39;s executed by Shipit&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SHIPIT_LINK&lt;/code&gt;: URL to the task output, useful to broadcast it in an IRC channel&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SHIPIT_USER&lt;/code&gt;: Full name of the user that triggered the deploy/task&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;GITHUB_REPO_NAME&lt;/code&gt;: Name of the GitHub repository being used for the current deploy/task.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;GITHUB_REPO_OWNER&lt;/code&gt;: The GitHub username of the repository owner for the current deploy/task.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;EMAIL&lt;/code&gt;: Email of the user that triggered the deploy/task (if available)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ENVIRONMENT&lt;/code&gt;: The stack environment (e.g &lt;code&gt;production&lt;/code&gt; / &lt;code&gt;staging&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;BRANCH&lt;/code&gt;: The stack branch (e.g &lt;code&gt;master&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;LAST_DEPLOYED_SHA&lt;/code&gt;: The git SHA of the last deployed commit&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DIFF_LINK&lt;/code&gt;: URL to the diff on GitHub.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TASK_ID&lt;/code&gt;: ID of the task that is running&lt;/li&gt; &#xA; &lt;li&gt;All the content of the &lt;code&gt;secrets.yml&lt;/code&gt; &lt;code&gt;env&lt;/code&gt; key&lt;/li&gt; &#xA; &lt;li&gt;All the content of the &lt;code&gt;shipit.yml&lt;/code&gt; &lt;code&gt;machine.environment&lt;/code&gt; key&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These variables are accessible only during deploys and rollback:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;REVISION&lt;/code&gt;: the git SHA of the revision that must be deployed in production&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SHA&lt;/code&gt;: alias for REVISION&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2 id=&#34;configuring-providers&#34;&gt;Configuring providers&lt;/h2&gt; &#xA;&lt;h3&gt;Heroku&lt;/h3&gt; &#xA;&lt;p&gt;To use Heroku integration (&lt;code&gt;lib/snippets/push-to-heroku&lt;/code&gt;), make sure that the environment has &lt;a href=&#34;https://devcenter.heroku.com/articles/heroku-cli&#34;&gt;Heroku CLI&lt;/a&gt; available.&lt;/p&gt; &#xA;&lt;h3&gt;Kubernetes&lt;/h3&gt; &#xA;&lt;p&gt;For Kubernetes, you have to provision Shipit environment with the following tools:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;kubectl&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;kubernetes-deploy&lt;/code&gt; &lt;a href=&#34;https://github.com/Shopify/kubernetes-deploy&#34;&gt;gem&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2 id=&#34;integrating&#34;&gt;IV. INTEGRATING&lt;/h2&gt; &#xA;&lt;h3 id=&#34;integrating-webhooks&#34;&gt;Registering webhooks&lt;/h3&gt; &#xA;&lt;p&gt;Shipit handles several webhook types by default, listed in &lt;code&gt;Shipit::Wehbooks::DEFAULT_HANDLERS&lt;/code&gt;, in order to implement default behaviours. Extra handler blocks can be registered via &lt;code&gt;Shipit::Webhooks.register_handler&lt;/code&gt;. Valid handlers need only implement the &lt;code&gt;call&lt;/code&gt; method - meaning any object which implements &lt;code&gt;call&lt;/code&gt; - blocks, procs, or lambdas are valid. The webhooks controller will pass a &lt;code&gt;params&lt;/code&gt; argument to the handler. Some examples:&lt;/p&gt; &#xA;&lt;h4&gt;Registering a Plain old Ruby Object as a handler&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PullRequestHandler&#xA;  def call(params)&#xA;    # do something with pull request webhook events&#xA;  end&#xA;end&#xA;&#xA;Shipit::Webhooks.register_handler(&#39;pull_request&#39;, PullRequestHandler)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Registering a Block as a handler&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Shipit::Webhooks.register_handler(&#39;pull_request&#39;) do |params|&#xA;  # do something with pull request webhook events&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Multiple handler blocks can be registered. If any raise errors, execution will be halted and the request will be reported failed to github.&lt;/p&gt; &#xA;&lt;h2 id=&#34;contributing&#34;&gt;V. CONTRIBUTING&lt;/h2&gt; &#xA;&lt;h3 id=&#34;contributing-instructions&#34;&gt;Instructions&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork it ( &lt;a href=&#34;https://github.com/shopify/shipit-engine/fork&#34;&gt;https://github.com/shopify/shipit-engine/fork&lt;/a&gt; )&lt;/li&gt; &#xA; &lt;li&gt;Create your feature branch (git checkout -b my-new-feature)&lt;/li&gt; &#xA; &lt;li&gt;Commit your changes (git commit -am &#39;Add some feature&#39;)&lt;/li&gt; &#xA; &lt;li&gt;Push to the branch (git push origin my-new-feature)&lt;/li&gt; &#xA; &lt;li&gt;Create a new Pull Request&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3 id=&#34;contributing-local-dev&#34;&gt;Local development&lt;/h3&gt; &#xA;&lt;p&gt;This repository has a &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/shipit-engine/master/test/dummy&#34;&gt;test/dummy&lt;/a&gt; app in it which can be used for local development without having to setup a new rails application.&lt;/p&gt; &#xA;&lt;p&gt;Run &lt;code&gt;./bin/bootstrap&lt;/code&gt; in order to bootstrap the dummy application. The bootstrap script is going to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Copy &lt;code&gt;config/secrets.development.example.yml&lt;/code&gt; to &lt;code&gt;config/secrets.development.yml&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;Make sure all dependencies are installed;&lt;/li&gt; &#xA; &lt;li&gt;Create and seed database (recreate database if already available);&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Run &lt;code&gt;./test/dummy/bin/rails server&lt;/code&gt; to run the rails dummy application.&lt;/p&gt; &#xA;&lt;p&gt;Set the environment variable &lt;code&gt;SHIPIT_DISABLE_AUTH=1&lt;/code&gt; in order to disable authentication.&lt;/p&gt; &#xA;&lt;p&gt;If you need to test caching behaviour in the dummy application, use &lt;code&gt;bin/rails dev:cache&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Shopify/homebrew-shopify</title>
    <updated>2022-09-02T01:36:49Z</updated>
    <id>tag:github.com,2022-09-02:/Shopify/homebrew-shopify</id>
    <link href="https://github.com/Shopify/homebrew-shopify" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Shopify&#39;s Public Homebrew Tap&lt;/h1&gt; &#xA;&lt;p&gt;To add it to your taps:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ brew tap shopify/shopify&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>