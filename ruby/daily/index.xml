<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-18T01:31:45Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rmosolgo/graphql-ruby</title>
    <updated>2022-06-18T01:31:45Z</updated>
    <id>tag:github.com,2022-06-18:/rmosolgo/graphql-ruby</id>
    <link href="https://github.com/rmosolgo/graphql-ruby" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ruby implementation of GraphQL&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;graphql &lt;img src=&#34;https://cloud.githubusercontent.com/assets/2231765/9094460/cb43861e-3b66-11e5-9fbf-71066ff3ab13.png&#34; height=&#34;40&#34; alt=&#34;graphql-ruby&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rmosolgo/graphql-ruby/actions/workflows/ci.yaml&#34;&gt;&lt;img src=&#34;https://github.com/rmosolgo/graphql-ruby/actions/workflows/ci.yaml/badge.svg?sanitize=true&#34; alt=&#34;CI Suite&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://rubygems.org/gems/graphql&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/graphql.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A Ruby implementation of &lt;a href=&#34;https://graphql.org/&#34;&gt;GraphQL&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://graphql-ruby.org/&#34;&gt;Website&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.rubydoc.info/github/rmosolgo/graphql-ruby&#34;&gt;API Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://tinyletter.com/graphql-ruby&#34;&gt;Newsletter&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install from RubyGems by adding it to your &lt;code&gt;Gemfile&lt;/code&gt;, then bundling.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Gemfile&#xA;gem &#39;graphql&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ rails generate graphql:install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After this, you may need to run &lt;code&gt;bundle install&lt;/code&gt; again, as by default graphiql-rails is added on installation.&lt;/p&gt; &#xA;&lt;p&gt;Or, see &lt;a href=&#34;https://graphql-ruby.org/getting_started.html&#34;&gt;&#34;Getting Started&#34;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Upgrade&lt;/h2&gt; &#xA;&lt;p&gt;I also sell &lt;a href=&#34;https://graphql.pro&#34;&gt;GraphQL::Pro&lt;/a&gt; which provides several features on top of the GraphQL runtime, including &lt;a href=&#34;https://graphql-ruby.org/authorization/pundit_integration&#34;&gt;Pundit authorization&lt;/a&gt;, &lt;a href=&#34;https://graphql-ruby.org/authorization/can_can_integration&#34;&gt;CanCan authorization&lt;/a&gt;, &lt;a href=&#34;https://graphql-ruby.org/subscriptions/pusher_implementation&#34;&gt;Pusher-based subscriptions&lt;/a&gt; and &lt;a href=&#34;https://graphql-ruby.org/operation_store/overview&#34;&gt;persisted queries&lt;/a&gt;. Besides that, Pro customers get email support and an opportunity to support graphql-ruby&#39;s development!&lt;/p&gt; &#xA;&lt;h2&gt;Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Implement the GraphQL spec &amp;amp; support a Relay front end&lt;/li&gt; &#xA; &lt;li&gt;Provide idiomatic, plain-Ruby API with similarities to reference implementation where possible&lt;/li&gt; &#xA; &lt;li&gt;Support Ruby on Rails and Relay&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Involved&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Say hi &amp;amp; ask questions&lt;/strong&gt; in the #graphql-ruby channel on &lt;a href=&#34;https://discord.com/invite/xud7bH9&#34;&gt;Discord&lt;/a&gt; or &lt;a href=&#34;https://twitter.com/rmosolgo&#34;&gt;on Twitter&lt;/a&gt;!&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Report bugs&lt;/strong&gt; by posting a description, full stack trace, and all relevant code in a &lt;a href=&#34;https://github.com/rmosolgo/graphql-ruby/issues&#34;&gt;GitHub issue&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Start hacking&lt;/strong&gt; with the &lt;a href=&#34;https://graphql-ruby.org/development&#34;&gt;Development guide&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>jsonapi-serializer/jsonapi-serializer</title>
    <updated>2022-06-18T01:31:45Z</updated>
    <id>tag:github.com,2022-06-18:/jsonapi-serializer/jsonapi-serializer</id>
    <link href="https://github.com/jsonapi-serializer/jsonapi-serializer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fast JSON:API serializer for Ruby (fork of Netflix/fast_jsonapi)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;JSON:API Serialization Library&lt;/h1&gt; &#xA;&lt;h2&gt;&lt;span&gt;⚠&lt;/span&gt; &lt;span&gt;🚧&lt;/span&gt; v2 (the &lt;code&gt;master&lt;/code&gt; branch) is in maintenance mode! &lt;span&gt;🚧&lt;/span&gt; &lt;span&gt;⚠&lt;/span&gt;&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;ll gladly accept bugfixes and security-related fixes for v2 (the &lt;code&gt;master&lt;/code&gt; branch), but at this stage, contributions for new features/improvements are welcome only for v3. Please feel free to leave comments in the &lt;a href=&#34;https://github.com/jsonapi-serializer/jsonapi-serializer/pull/141&#34;&gt;v3 Pull Request&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;A fast &lt;a href=&#34;https://jsonapi.org/&#34;&gt;JSON:API&lt;/a&gt; serializer for Ruby Objects.&lt;/p&gt; &#xA;&lt;p&gt;Previously this project was called &lt;strong&gt;fast_jsonapi&lt;/strong&gt;, we forked the project and renamed it to &lt;strong&gt;jsonapi/serializer&lt;/strong&gt; in order to keep it alive.&lt;/p&gt; &#xA;&lt;p&gt;We would like to thank the Netflix team for the initial work and to all our contributors and users for the continuous support!&lt;/p&gt; &#xA;&lt;h1&gt;Performance Comparison&lt;/h1&gt; &#xA;&lt;p&gt;We compare serialization times with &lt;code&gt;ActiveModelSerializer&lt;/code&gt; and alternative implementations as part of performance tests available at &lt;a href=&#34;https://github.com/jsonapi-serializer/comparisons&#34;&gt;jsonapi-serializer/comparisons&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We want to ensure that with every change on this library, serialization time stays significantly faster than the performance provided by the alternatives. Please read the performance article in the &lt;code&gt;docs&lt;/code&gt; folder for any questions related to methodology.&lt;/p&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#rails-generator&#34;&gt;Rails Generator&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#model-definition&#34;&gt;Model Definition&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#serializer-definition&#34;&gt;Serializer Definition&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#object-serialization&#34;&gt;Object Serialization&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#compound-document&#34;&gt;Compound Document&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#key-transforms&#34;&gt;Key Transforms&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#collection-serialization&#34;&gt;Collection Serialization&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#caching&#34;&gt;Caching&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#params&#34;&gt;Params&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#conditional-attributes&#34;&gt;Conditional Attributes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#conditional-relationships&#34;&gt;Conditional Relationships&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#specifying-a-relationship-serializer&#34;&gt;Specifying a Relationship Serializer&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#sparse-fieldsets&#34;&gt;Sparse Fieldsets&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#using-helper-methods&#34;&gt;Using helper methods&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#performance-instrumentation&#34;&gt;Performance Instrumentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#deserialization&#34;&gt;Deserialization&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#migrating-from-netflixfast_jsonapi&#34;&gt;Migrating from Netflix/fast_jsonapi&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jsonapi-serializer/jsonapi-serializer/master/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Declaration syntax similar to Active Model Serializer&lt;/li&gt; &#xA; &lt;li&gt;Support for &lt;code&gt;belongs_to&lt;/code&gt;, &lt;code&gt;has_many&lt;/code&gt; and &lt;code&gt;has_one&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Support for compound documents (included)&lt;/li&gt; &#xA; &lt;li&gt;Optimized serialization of compound documents&lt;/li&gt; &#xA; &lt;li&gt;Caching&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;jsonapi-serializer&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Rails Generator&lt;/h3&gt; &#xA;&lt;p&gt;You can use the bundled generator if you are using the library inside of a Rails project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rails g serializer Movie name year&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create a new serializer in &lt;code&gt;app/serializers/movie_serializer.rb&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Model Definition&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Movie&#xA;  attr_accessor :id, :name, :year, :actor_ids, :owner_id, :movie_type_id&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Serializer Definition&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  set_type :movie  # optional&#xA;  set_id :owner_id # optional&#xA;  attributes :name, :year&#xA;  has_many :actors&#xA;  belongs_to :owner, record_type: :user&#xA;  belongs_to :movie_type&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sample Object&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;movie = Movie.new&#xA;movie.id = 232&#xA;movie.name = &#39;test movie&#39;&#xA;movie.actor_ids = [1, 2, 3]&#xA;movie.owner_id = 3&#xA;movie.movie_type_id = 1&#xA;movie&#xA;&#xA;movies =&#xA;  2.times.map do |i|&#xA;    m = Movie.new&#xA;    m.id = i + 1&#xA;    m.name = &#34;test movie #{i}&#34;&#xA;    m.actor_ids = [1, 2, 3]&#xA;    m.owner_id = 3&#xA;    m.movie_type_id = 1&#xA;    m&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Object Serialization&lt;/h3&gt; &#xA;&lt;h4&gt;Return a hash&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;hash = MovieSerializer.new(movie).serializable_hash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Return Serialized JSON&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;json_string = MovieSerializer.new(movie).serializable_hash.to_json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Serialized Output&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;data&#34;: {&#xA;    &#34;id&#34;: &#34;3&#34;,&#xA;    &#34;type&#34;: &#34;movie&#34;,&#xA;    &#34;attributes&#34;: {&#xA;      &#34;name&#34;: &#34;test movie&#34;,&#xA;      &#34;year&#34;: null&#xA;    },&#xA;    &#34;relationships&#34;: {&#xA;      &#34;actors&#34;: {&#xA;        &#34;data&#34;: [&#xA;          {&#xA;            &#34;id&#34;: &#34;1&#34;,&#xA;            &#34;type&#34;: &#34;actor&#34;&#xA;          },&#xA;          {&#xA;            &#34;id&#34;: &#34;2&#34;,&#xA;            &#34;type&#34;: &#34;actor&#34;&#xA;          }&#xA;        ]&#xA;      },&#xA;      &#34;owner&#34;: {&#xA;        &#34;data&#34;: {&#xA;          &#34;id&#34;: &#34;3&#34;,&#xA;          &#34;type&#34;: &#34;user&#34;&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;The Optionality of &lt;code&gt;set_type&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;By default fast_jsonapi will try to figure the type based on the name of the serializer class. For example &lt;code&gt;class MovieSerializer&lt;/code&gt; will automatically have a type of &lt;code&gt;:movie&lt;/code&gt;. If your serializer class name does not follow this format, you have to manually state the &lt;code&gt;set_type&lt;/code&gt; at the serializer.&lt;/p&gt; &#xA;&lt;h3&gt;Key Transforms&lt;/h3&gt; &#xA;&lt;p&gt;By default fast_jsonapi underscores the key names. It supports the same key transforms that are supported by AMS. Here is the syntax of specifying a key transform&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  # Available options :camel, :camel_lower, :dash, :underscore(default)&#xA;  set_key_transform :camel&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here are examples of how these options transform the keys&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;set_key_transform :camel # &#34;some_key&#34; =&amp;gt; &#34;SomeKey&#34;&#xA;set_key_transform :camel_lower # &#34;some_key&#34; =&amp;gt; &#34;someKey&#34;&#xA;set_key_transform :dash # &#34;some_key&#34; =&amp;gt; &#34;some-key&#34;&#xA;set_key_transform :underscore # &#34;some_key&#34; =&amp;gt; &#34;some_key&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Attributes&lt;/h3&gt; &#xA;&lt;p&gt;Attributes are defined using the &lt;code&gt;attributes&lt;/code&gt; method. This method is also aliased as &lt;code&gt;attribute&lt;/code&gt;, which is useful when defining a single attribute.&lt;/p&gt; &#xA;&lt;p&gt;By default, attributes are read directly from the model property of the same name. In this example, &lt;code&gt;name&lt;/code&gt; is expected to be a property of the object being serialized:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  attribute :name&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Custom attributes that must be serialized but do not exist on the model can be declared using Ruby block syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  attributes :name, :year&#xA;&#xA;  attribute :name_with_year do |object|&#xA;    &#34;#{object.name} (#{object.year})&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The block syntax can also be used to override the property on the object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  attribute :name do |object|&#xA;    &#34;#{object.name} Part 2&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Attributes can also use a different name by passing the original method or accessor with a proc shortcut:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  attributes :name&#xA;&#xA;  attribute :released_in_year, &amp;amp;:year&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Links Per Object&lt;/h3&gt; &#xA;&lt;p&gt;Links are defined using the &lt;code&gt;link&lt;/code&gt; method. By default, links are read directly from the model property of the same name. In this example, &lt;code&gt;public_url&lt;/code&gt; is expected to be a property of the object being serialized.&lt;/p&gt; &#xA;&lt;p&gt;You can configure the method to use on the object for example a link with key &lt;code&gt;self&lt;/code&gt; will get set to the value returned by a method called &lt;code&gt;url&lt;/code&gt; on the movie object.&lt;/p&gt; &#xA;&lt;p&gt;You can also use a block to define a url as shown in &lt;code&gt;custom_url&lt;/code&gt;. You can access params in these blocks as well as shown in &lt;code&gt;personalized_url&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  link :public_url&#xA;&#xA;  link :self, :url&#xA;&#xA;  link :custom_url do |object|&#xA;    &#34;https://movies.com/#{object.name}-(#{object.year})&#34;&#xA;  end&#xA;&#xA;  link :personalized_url do |object, params|&#xA;    &#34;https://movies.com/#{object.name}-#{params[:user].reference_code}&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Links on a Relationship&lt;/h4&gt; &#xA;&lt;p&gt;You can specify &lt;a href=&#34;https://jsonapi.org/format/#document-resource-object-relationships&#34;&gt;relationship links&lt;/a&gt; by using the &lt;code&gt;links:&lt;/code&gt; option on the serializer. Relationship links in JSON API are useful if you want to load a parent document and then load associated documents later due to size constraints (see &lt;a href=&#34;https://jsonapi.org/format/#document-resource-object-related-resource-links&#34;&gt;related resource links&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  has_many :actors, links: {&#xA;    self: :url,&#xA;    related: -&amp;gt; (object) {&#xA;      &#34;https://movies.com/#{object.id}/actors&#34;&#xA;    }&#xA;  }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Relationship links can also be configured to be defined as a method on the object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  has_many :actors, links: :actor_relationship_links&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create a &lt;code&gt;self&lt;/code&gt; reference for the relationship, and a &lt;code&gt;related&lt;/code&gt; link for loading the actors relationship later. NB: This will not automatically disable loading the data in the relationship, you&#39;ll need to do that using the &lt;code&gt;lazy_load_data&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  has_many :actors, lazy_load_data: true, links: {&#xA;    self: :url,&#xA;    related: -&amp;gt; (object) {&#xA;      &#34;https://movies.com/#{object.id}/actors&#34;&#xA;    }&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Meta Per Resource&lt;/h3&gt; &#xA;&lt;p&gt;For every resource in the collection, you can include a meta object containing non-standard meta-information about a resource that can not be represented as an attribute or relationship.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  meta do |movie|&#xA;    {&#xA;      years_since_release: Date.current.year - movie.year&#xA;    }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Meta on a Relationship&lt;/h4&gt; &#xA;&lt;p&gt;You can specify &lt;a href=&#34;https://jsonapi.org/format/#document-resource-object-relationships&#34;&gt;relationship meta&lt;/a&gt; by using the &lt;code&gt;meta:&lt;/code&gt; option on the serializer. Relationship meta in JSON API is useful if you wish to provide non-standard meta-information about the relationship.&lt;/p&gt; &#xA;&lt;p&gt;Meta can be defined either by passing a static hash or by using Proc to the &lt;code&gt;meta&lt;/code&gt; key. In the latter case, the record and any params passed to the serializer are available inside the Proc as the first and second parameters, respectively.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  has_many :actors, meta: Proc.new do |movie_record, params|&#xA;    { count: movie_record.actors.length }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compound Document&lt;/h3&gt; &#xA;&lt;p&gt;Support for top-level and nested included associations through &lt;code&gt;options[:include]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;options = {}&#xA;options[:meta] = { total: 2 }&#xA;options[:links] = {&#xA;  self: &#39;...&#39;,&#xA;  next: &#39;...&#39;,&#xA;  prev: &#39;...&#39;&#xA;}&#xA;options[:include] = [:actors, :&#39;actors.agency&#39;, :&#39;actors.agency.state&#39;]&#xA;MovieSerializer.new(movies, options).serializable_hash.to_json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Collection Serialization&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;options[:meta] = { total: 2 }&#xA;options[:links] = {&#xA;  self: &#39;...&#39;,&#xA;  next: &#39;...&#39;,&#xA;  prev: &#39;...&#39;&#xA;}&#xA;hash = MovieSerializer.new(movies, options).serializable_hash&#xA;json_string = MovieSerializer.new(movies, options).serializable_hash.to_json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Control Over Collection Serialization&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;is_collection&lt;/code&gt; option to have better control over collection serialization.&lt;/p&gt; &#xA;&lt;p&gt;If this option is not provided or &lt;code&gt;nil&lt;/code&gt; autodetect logic is used to try understand if provided resource is a single object or collection.&lt;/p&gt; &#xA;&lt;p&gt;Autodetect logic is compatible with most DB toolkits (ActiveRecord, Sequel, etc.) but &lt;strong&gt;cannot&lt;/strong&gt; guarantee that single vs collection will be always detected properly.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;options[:is_collection]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;was introduced to be able to have precise control this behavior&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;nil&lt;/code&gt; or not provided: will try to autodetect single vs collection (please, see notes above)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;true&lt;/code&gt; will always treat input resource as &lt;em&gt;collection&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;false&lt;/code&gt; will always treat input resource as &lt;em&gt;single object&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Caching&lt;/h3&gt; &#xA;&lt;p&gt;To enable caching, use &lt;code&gt;cache_options store: &amp;lt;cache_store&amp;gt;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  # use rails cache with a separate namespace and fixed expiry&#xA;  cache_options store: Rails.cache, namespace: &#39;jsonapi-serializer&#39;, expires_in: 1.hour&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;store&lt;/code&gt; is required can be anything that implements a &lt;code&gt;#fetch(record, **options, &amp;amp;block)&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;record&lt;/code&gt; is the record that is currently serialized&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; is everything that was passed to &lt;code&gt;cache_options&lt;/code&gt; except &lt;code&gt;store&lt;/code&gt;, so it can be everyhing the cache store supports&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;amp;block&lt;/code&gt; should be executed to fetch new data if cache is empty&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;So for the example above it will call the cache instance like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.cache.fetch(record, namespace: &#39;jsonapi-serializer&#39;, expires_in: 1.hour) { ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Caching and Sparse Fieldsets&lt;/h4&gt; &#xA;&lt;p&gt;If caching is enabled and fields are provided to the serializer, the fieldset will be appended to the cache key&#39;s namespace.&lt;/p&gt; &#xA;&lt;p&gt;For example, given the following serializer definition and instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ActorSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  attributes :first_name, :last_name&#xA;&#xA;  cache_options store: Rails.cache, namespace: &#39;jsonapi-serializer&#39;, expires_in: 1.hour&#xA;end&#xA;&#xA;serializer = ActorSerializer.new(actor, { fields: { actor: [:first_name] } })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following cache namespace will be generated: &lt;code&gt;&#39;jsonapi-serializer-fieldset:first_name&#39;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Params&lt;/h3&gt; &#xA;&lt;p&gt;In some cases, attribute values might require more information than what is available on the record, for example, access privileges or other information related to a current authenticated user. The &lt;code&gt;options[:params]&lt;/code&gt; value covers these cases by allowing you to pass in a hash of additional parameters necessary for your use case.&lt;/p&gt; &#xA;&lt;p&gt;Leveraging the new params is easy, when you define a custom id, attribute or relationship with a block you opt-in to using params by adding it as a block parameter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  set_id do |movie, params|&#xA;    # in here, params is a hash containing the `:admin` key&#xA;    params[:admin] ? movie.owner_id : &#34;movie-#{movie.id}&#34;&#xA;  end&#xA;&#xA;  attributes :name, :year&#xA;  attribute :can_view_early do |movie, params|&#xA;    # in here, params is a hash containing the `:current_user` key&#xA;    params[:current_user].is_employee? ? true : false&#xA;  end&#xA;&#xA;  belongs_to :primary_agent do |movie, params|&#xA;    # in here, params is a hash containing the `:current_user` key&#xA;    params[:current_user]&#xA;  end&#xA;end&#xA;&#xA;# ...&#xA;current_user = User.find(cookies[:current_user_id])&#xA;serializer = MovieSerializer.new(movie, {params: {current_user: current_user}})&#xA;serializer.serializable_hash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Custom attributes and relationships that only receive the resource are still possible by defining the block to only receive one argument.&lt;/p&gt; &#xA;&lt;h3&gt;Conditional Attributes&lt;/h3&gt; &#xA;&lt;p&gt;Conditional attributes can be defined by passing a Proc to the &lt;code&gt;if&lt;/code&gt; key on the &lt;code&gt;attribute&lt;/code&gt; method. Return &lt;code&gt;true&lt;/code&gt; if the attribute should be serialized, and &lt;code&gt;false&lt;/code&gt; if not. The record and any params passed to the serializer are available inside the Proc as the first and second parameters, respectively.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  attributes :name, :year&#xA;  attribute :release_year, if: Proc.new { |record|&#xA;    # Release year will only be serialized if it&#39;s greater than 1990&#xA;    record.release_year &amp;gt; 1990&#xA;  }&#xA;&#xA;  attribute :director, if: Proc.new { |record, params|&#xA;    # The director will be serialized only if the :admin key of params is true&#xA;    params &amp;amp;&amp;amp; params[:admin] == true&#xA;  }&#xA;&#xA;  # Custom attribute `name_year` will only be serialized if both `name` and `year` fields are present&#xA;  attribute :name_year, if: Proc.new { |record|&#xA;    record.name.present? &amp;amp;&amp;amp; record.year.present?&#xA;  } do |object|&#xA;    &#34;#{object.name} - #{object.year}&#34;&#xA;  end&#xA;end&#xA;&#xA;# ...&#xA;current_user = User.find(cookies[:current_user_id])&#xA;serializer = MovieSerializer.new(movie, { params: { admin: current_user.admin? }})&#xA;serializer.serializable_hash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Conditional Relationships&lt;/h3&gt; &#xA;&lt;p&gt;Conditional relationships can be defined by passing a Proc to the &lt;code&gt;if&lt;/code&gt; key. Return &lt;code&gt;true&lt;/code&gt; if the relationship should be serialized, and &lt;code&gt;false&lt;/code&gt; if not. The record and any params passed to the serializer are available inside the Proc as the first and second parameters, respectively.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  # Actors will only be serialized if the record has any associated actors&#xA;  has_many :actors, if: Proc.new { |record| record.actors.any? }&#xA;&#xA;  # Owner will only be serialized if the :admin key of params is true&#xA;  belongs_to :owner, if: Proc.new { |record, params| params &amp;amp;&amp;amp; params[:admin] == true }&#xA;end&#xA;&#xA;# ...&#xA;current_user = User.find(cookies[:current_user_id])&#xA;serializer = MovieSerializer.new(movie, { params: { admin: current_user.admin? }})&#xA;serializer.serializable_hash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying a Relationship Serializer&lt;/h3&gt; &#xA;&lt;p&gt;In many cases, the relationship can automatically detect the serializer to use.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  # resolves to StudioSerializer&#xA;  belongs_to :studio&#xA;  # resolves to ActorSerializer&#xA;  has_many :actors&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;At other times, such as when a property name differs from the class name, you may need to explicitly state the serializer to use. You can do so by specifying a different symbol or the serializer class itself (which is the recommended usage):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  # resolves to MovieStudioSerializer&#xA;  belongs_to :studio, serializer: :movie_studio&#xA;  # resolves to PerformerSerializer&#xA;  has_many :actors, serializer: PerformerSerializer&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced cases, such as polymorphic relationships and Single Table Inheritance, you may need even greater control to select the serializer based on the specific object or some specified serialization parameters. You can do by defining the serializer as a &lt;code&gt;Proc&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  has_many :actors, serializer: Proc.new do |record, params|&#xA;    if record.comedian?&#xA;      ComedianSerializer&#xA;    elsif params[:use_drama_serializer]&#xA;      DramaSerializer&#xA;    else&#xA;      ActorSerializer&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sparse Fieldsets&lt;/h3&gt; &#xA;&lt;p&gt;Attributes and relationships can be selectively returned per record type by using the &lt;code&gt;fields&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  attributes :name, :year&#xA;end&#xA;&#xA;serializer = MovieSerializer.new(movie, { fields: { movie: [:name] } })&#xA;serializer.serializable_hash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using helper methods&lt;/h3&gt; &#xA;&lt;p&gt;You can mix-in code from another ruby module into your serializer class to reuse functions across your app.&lt;/p&gt; &#xA;&lt;p&gt;Since a serializer is evaluated in a the context of a &lt;code&gt;class&lt;/code&gt; rather than an &lt;code&gt;instance&lt;/code&gt; of a class, you need to make sure that your methods act as &lt;code&gt;class&lt;/code&gt; methods when mixed in.&lt;/p&gt; &#xA;&lt;h5&gt;Using ActiveSupport::Concern&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#xA;module AvatarHelper&#xA;  extend ActiveSupport::Concern&#xA;&#xA;  class_methods do&#xA;    def avatar_url(user)&#xA;      user.image.url&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;class UserSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  include AvatarHelper # mixes in your helper method as class method&#xA;&#xA;  set_type :user&#xA;&#xA;  attributes :name, :email&#xA;&#xA;  attribute :avatar do |user|&#xA;    avatar_url(user)&#xA;  end&#xA;end&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Using Plain Old Ruby&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module AvatarHelper&#xA;  def avatar_url(user)&#xA;    user.image.url&#xA;  end&#xA;end&#xA;&#xA;class UserSerializer&#xA;  include JSONAPI::Serializer&#xA;&#xA;  extend AvatarHelper # mixes in your helper method as class method&#xA;&#xA;  set_type :user&#xA;&#xA;  attributes :name, :email&#xA;&#xA;  attribute :avatar do |user|&#xA;    avatar_url(user)&#xA;  end&#xA;end&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Customizable Options&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Option&lt;/th&gt; &#xA;   &lt;th&gt;Purpose&lt;/th&gt; &#xA;   &lt;th&gt;Example&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;set_type&lt;/td&gt; &#xA;   &lt;td&gt;Type name of Object&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;set_type :movie&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;key&lt;/td&gt; &#xA;   &lt;td&gt;Key of Object&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;belongs_to :owner, key: :user&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;set_id&lt;/td&gt; &#xA;   &lt;td&gt;ID of Object&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;set_id :owner_id&lt;/code&gt; or &lt;code&gt;set_id { |record, params| params[:admin] ? record.id : &#34;#{record.name.downcase}-#{record.id}&#34; }&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;cache_options&lt;/td&gt; &#xA;   &lt;td&gt;Hash with store to enable caching and optional further cache options&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;cache_options store: ActiveSupport::Cache::MemoryStore.new, expires_in: 5.minutes&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;id_method_name&lt;/td&gt; &#xA;   &lt;td&gt;Set custom method name to get ID of an object (If block is provided for the relationship, &lt;code&gt;id_method_name&lt;/code&gt; is invoked on the return value of the block instead of the resource object)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;has_many :locations, id_method_name: :place_ids&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;object_method_name&lt;/td&gt; &#xA;   &lt;td&gt;Set custom method name to get related objects&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;has_many :locations, object_method_name: :places&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;record_type&lt;/td&gt; &#xA;   &lt;td&gt;Set custom Object Type for a relationship&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;belongs_to :owner, record_type: :user&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;serializer&lt;/td&gt; &#xA;   &lt;td&gt;Set custom Serializer for a relationship&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;has_many :actors, serializer: :custom_actor&lt;/code&gt;, &lt;code&gt;has_many :actors, serializer: MyApp::Api::V1::ActorSerializer&lt;/code&gt;, or &lt;code&gt;has_many :actors, serializer -&amp;gt; (object, params) { (return a serializer class) }&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;polymorphic&lt;/td&gt; &#xA;   &lt;td&gt;Allows different record types for a polymorphic association&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;has_many :targets, polymorphic: true&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;polymorphic&lt;/td&gt; &#xA;   &lt;td&gt;Sets custom record types for each object class in a polymorphic association&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;has_many :targets, polymorphic: { Person =&amp;gt; :person, Group =&amp;gt; :group }&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Performance Instrumentation&lt;/h3&gt; &#xA;&lt;p&gt;Performance instrumentation is available by using the &lt;code&gt;active_support/notifications&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To enable it, include the module in your serializer class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;jsonapi/serializer&#39;&#xA;require &#39;jsonapi/serializer/instrumentation&#39;&#xA;&#xA;class MovieSerializer&#xA;  include JSONAPI::Serializer&#xA;  include JSONAPI::Serializer::Instrumentation&#xA;&#xA;  # ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.skylight.io/&#34;&gt;Skylight&lt;/a&gt; integration is also available and supported by us, follow the Skylight documentation to enable it.&lt;/p&gt; &#xA;&lt;h3&gt;Running Tests&lt;/h3&gt; &#xA;&lt;p&gt;The project has and requires unit tests, functional tests and performance tests. To run tests use the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rspec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Deserialization&lt;/h2&gt; &#xA;&lt;p&gt;We currently do not support deserialization, but we recommend to use any of the next gems:&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/stas/jsonapi.rb&#34;&gt;JSONAPI.rb&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This gem provides the next features alongside deserialization:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Collection meta&lt;/li&gt; &#xA; &lt;li&gt;Error handling&lt;/li&gt; &#xA; &lt;li&gt;Includes and sparse fields&lt;/li&gt; &#xA; &lt;li&gt;Filtering and sorting&lt;/li&gt; &#xA; &lt;li&gt;Pagination&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Migrating from Netflix/fast_jsonapi&lt;/h2&gt; &#xA;&lt;p&gt;If you come from &lt;a href=&#34;https://github.com/Netflix/fast_jsonapi&#34;&gt;Netflix/fast_jsonapi&lt;/a&gt;, here is the instructions to switch.&lt;/p&gt; &#xA;&lt;h3&gt;Modify your Gemfile&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- gem &#39;fast_jsonapi&#39;&#xA;+ gem &#39;jsonapi-serializer&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Replace all constant references&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;class MovieSerializer&#xA;- include FastJsonapi::ObjectSerializer&#xA;+ include JSONAPI::Serializer&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Replace removed methods&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- json_string = MovieSerializer.new(movie).serialized_json&#xA;+ json_string = MovieSerializer.new(movie).serializable_hash.to_json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Replace require references&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- require &#39;fast_jsonapi&#39;&#xA;+ require &#39;jsonapi/serializer&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Update your cache options&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/jsonapi-serializer/jsonapi-serializer#caching&#34;&gt;docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- cache_options enabled: true, cache_length: 12.hours&#xA;+ cache_options store: Rails.cache, namespace: &#39;jsonapi-serializer&#39;, expires_in: 1.hour&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please follow the instructions we provide as part of the issue and pull request creation processes.&lt;/p&gt; &#xA;&lt;p&gt;This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the &lt;a href=&#34;https://contributor-covenant.org&#34;&gt;Contributor Covenant&lt;/a&gt; code of conduct.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>postalserver/postal</title>
    <updated>2022-06-18T01:31:45Z</updated>
    <id>tag:github.com,2022-06-18:/postalserver/postal</id>
    <link href="https://github.com/postalserver/postal" rel="alternate"></link>
    <summary type="html">&lt;p&gt;✉️ A fully featured open source mail delivery platform for incoming &amp; outgoing e-mail&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://share.adam.ac/21/logo-g3hWemROTemCYbWlmL.svg?sanitize=true&#34; width=&#34;250&#34;&gt; &#xA;&lt;p&gt;&lt;strong&gt;Postal&lt;/strong&gt; is a complete and fully featured mail server for use by websites &amp;amp; web servers. Think Sendgrid, Mailgun or Postmark but open source and ready for you to run on your own servers. Postal is developed by &lt;a href=&#34;https://k.io&#34;&gt;Krystal&lt;/a&gt; to serve its own mail processing requirements and we have since decided that it should be released as an open source project for the community.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://share.adam.ac/17/k4lA5OuPlU2.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.postalserver.io&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.postalserver.io/install/prerequisites&#34;&gt;Installation Instructions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.postalserver.io/welcome/faqs&#34;&gt;FAQs&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://docs.postalserver.io/welcome/feature-list&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/postalserver/postal/discussions&#34;&gt;Ask for help&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>