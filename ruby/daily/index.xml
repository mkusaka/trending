<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-12-10T01:36:59Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>instacart/makara</title>
    <updated>2024-12-10T01:36:59Z</updated>
    <id>tag:github.com,2024-12-10:/instacart/makara</id>
    <link href="https://github.com/instacart/makara" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Read-Write Proxy for Connections; Also provides an ActiveRecord adapter.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;We are looking for maintainers to oversee the support and development of Makara. We are no longer using Makara at Instacart and we are unable to dedicate the time and resources to maintain it.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re interested in maintaining Makara, please respond to &lt;a href=&#34;https://github.com/instacart/makara/issues/393&#34;&gt;this issue&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Makara&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/instacart/makara/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt; &lt;a href=&#34;https://badge.fury.io/rb/makara&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/makara.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/repos/526886a7f3ea00679b00cae6/feed&#34;&gt;&lt;img src=&#34;https://codeclimate.com/repos/526886a7f3ea00679b00cae6/badges/7905f7a000492a1078f7/gpa.png&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Makara is generic primary/replica proxy. It handles the heavy lifting of managing, choosing, blacklisting, and cycling through connections. It comes with an ActiveRecord database adapter implementation.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Use the current version of the gem from &lt;a href=&#34;https://rubygems.org/gems/makara&#34;&gt;rubygems&lt;/a&gt; in your &lt;code&gt;Gemfile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;makara&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Basic Usage&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re only interested in the ActiveRecord database adapter... &lt;a href=&#34;https://raw.githubusercontent.com/instacart/makara/master/#activerecord-database-adapter&#34;&gt;here you go.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Makara provides a base proxy class which you should inherit from. Your proxy connection class should implement a &lt;code&gt;connection_for&lt;/code&gt; instance method which will be provided with an individual configuration and expect a real connection back.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyAwesomeSqlProxy &amp;lt; ::Makara::Proxy&#xA;  def connection_for(config)&#xA;    ::Sql::Client.new(config)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, you need to decide which methods are proxied and which methods should be sent to all underlying connections:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  # within MyAwesomeSqlProxy&#xA;  hijack_method :select, :ping&#xA;  send_to_all :connect, :reconnect, :disconnect, :clear_cache&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Assuming you don&#39;t need to split requests between a primary and a replica, you&#39;re done. If you do need to, implement the &lt;code&gt;needs_primary?&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  # within MyAwesomeSqlProxy&#xA;  def needs_primary?(method_name, args)&#xA;    return false if args.empty?&#xA;    sql = args.first&#xA;    sql !~ /^select/i&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This implementation will send any request not like &#34;SELECT...&#34; to a primary connection. There are more methods you can override and more control over blacklisting - check out the &lt;a href=&#34;https://raw.githubusercontent.com/instacart/makara/master/lib/active_record/connection_adapters/makara_abstract_adapter.rb&#34;&gt;makara database adapter&lt;/a&gt; for examples of advanced usage.&lt;/p&gt; &#xA;&lt;h3&gt;Config Parsing&lt;/h3&gt; &#xA;&lt;p&gt;Makara comes with a config parser which will handle providing subconfigs to the &lt;code&gt;connection_for&lt;/code&gt; method. Check out the ActiveRecord database.yml example below for more info.&lt;/p&gt; &#xA;&lt;h3&gt;Stickiness Context&lt;/h3&gt; &#xA;&lt;p&gt;Makara handles stickiness by keeping track of which proxies are stuck at any given moment. The context is basically a mapping of proxy ids to the timestamp until which they are stuck.&lt;/p&gt; &#xA;&lt;p&gt;To handle persistence of context across requests in a Rack app, makara provides a middleware. It lays a cookie named &lt;code&gt;_mkra_stck&lt;/code&gt; which contains the current context. If the next request is executed before the cookie expires, that given context will be used. If something occurs which naturally requires the primary on the second request, the context is updated and stored again.&lt;/p&gt; &#xA;&lt;h4&gt;Stickiness Impact&lt;/h4&gt; &#xA;&lt;p&gt;When &lt;code&gt;sticky:true&lt;/code&gt;, once a query as been sent to the primary, all queries for the rest of the request will also be sent to the primary. In addition, the cookie described above will be set client side with an expiration defined by time at end of original request + &lt;code&gt;primary_ttl&lt;/code&gt;. As long as the cookie is valid, all requests will send queries to primary.&lt;/p&gt; &#xA;&lt;p&gt;When &lt;code&gt;sticky:false&lt;/code&gt;, only queries that need to go to the primary will go there. Subsequent read queries in the same request will go to replicas.&lt;/p&gt; &#xA;&lt;h4&gt;Releasing stuck connections (clearing context)&lt;/h4&gt; &#xA;&lt;p&gt;If you need to clear the current context, releasing any stuck connections, all you have to do is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Makara::Context.release_all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also clear stuck connections for a specific proxy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Makara::Context.release(proxy_id)&#xA;Makara::Context.release(&#39;mysql_main&#39;)&#xA;Makara::Context.release(&#39;redis&#39;)&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A context is local to the curent thread of execution. This will allow you to stick to the primary safely in a single thread in systems such as sidekiq, for instance.&lt;/p&gt; &#xA;&lt;h4&gt;Forcing Primary&lt;/h4&gt; &#xA;&lt;p&gt;If you need to force the primary in your app then you can simply invoke stick_to_primary! on your connection:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;persist = true # or false, it&#39;s true by default&#xA;proxy.stick_to_primary!(persist)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;ll keep the proxy stuck to the primary for the current request, and if &lt;code&gt;persist = true&lt;/code&gt; (default), it&#39;ll be also stored in the context for subsequent requests, keeping the proxy stuck up to the duration of &lt;code&gt;primary_ttl&lt;/code&gt; configured for the proxy.&lt;/p&gt; &#xA;&lt;h4&gt;Skipping the Stickiness&lt;/h4&gt; &#xA;&lt;p&gt;If you&#39;re using the &lt;code&gt;sticky: true&lt;/code&gt; configuration and you find yourself in a situation where you need to write information through the proxy but you don&#39;t want the context to be stuck to the primary, you should use a &lt;code&gt;without_sticking&lt;/code&gt; block:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;proxy.without_sticking do&#xA;  # do my stuff that would normally cause the proxy to stick to the primary&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Logging&lt;/h3&gt; &#xA;&lt;p&gt;You can set a logger instance to ::Makara::Logging::Logger.logger and Makara will log how it handles errors at the Proxy level.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Makara::Logging::Logger.logger = ::Logger.new(STDOUT)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;ActiveRecord Database Adapter&lt;/h2&gt; &#xA;&lt;p&gt;So you&#39;ve found yourself with an ActiveRecord-based project which is starting to get some traffic and you realize 95% of you DB load is from reads. Well you&#39;ve come to the right spot. Makara is a great solution to break up that load not only between primary and replica but potentially multiple primaries and/or multiple replicas.&lt;/p&gt; &#xA;&lt;p&gt;By creating a makara database adapter which simply acts as a proxy we avoid any major complexity surrounding specific database implementations. The makara adapter doesn&#39;t care if the underlying connection is mysql, postgresql, etc it simply cares about the sql string being executed.&lt;/p&gt; &#xA;&lt;h3&gt;What goes where?&lt;/h3&gt; &#xA;&lt;p&gt;In general: Any &lt;code&gt;SELECT&lt;/code&gt; statements will execute against your replica(s), anything else will go to the primary.&lt;/p&gt; &#xA;&lt;p&gt;There are some edge cases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;SET&lt;/code&gt; operations will be sent to all connections&lt;/li&gt; &#xA; &lt;li&gt;Execution of specific methods such as &lt;code&gt;connect!&lt;/code&gt;, &lt;code&gt;disconnect!&lt;/code&gt;, and &lt;code&gt;clear_cache!&lt;/code&gt; are invoked on all underlying connections&lt;/li&gt; &#xA; &lt;li&gt;Calls inside a transaction will always be sent to the primary (otherwise changes from within the transaction could not be read back on most transaction isolation levels)&lt;/li&gt; &#xA; &lt;li&gt;Locking reads (e.g. &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;) will always be sent to the primary&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Errors / blacklisting&lt;/h3&gt; &#xA;&lt;p&gt;Whenever a node fails an operation due to a connection issue, it is blacklisted for the amount of time specified in your database.yml. After that amount of time has passed, the connection will begin receiving queries again. If all replica nodes are blacklisted, the primary connection will begin receiving read queries as if it were a replica. Once all nodes are blacklisted the error is raised to the application and all nodes are whitelisted.&lt;/p&gt; &#xA;&lt;h3&gt;Database.yml&lt;/h3&gt; &#xA;&lt;p&gt;Your database.yml should contain the following structure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;production:&#xA;  adapter: &#39;mysql2_makara&#39;&#xA;  database: &#39;MyAppProduction&#39;&#xA;  # any other standard AR configurations&#xA;&#xA;  # add a makara subconfig&#xA;  makara:&#xA;&#xA;    # optional id to identify the proxy with this configuration for stickiness&#xA;    id: mysql&#xA;    # the following are default values&#xA;    blacklist_duration: 5&#xA;    primary_ttl: 5&#xA;    primary_strategy: round_robin&#xA;    sticky: true&#xA;&#xA;    # list your connections with the override values (they&#39;re merged into the top-level config)&#xA;    # be sure to provide the role if primary, role is assumed to be a replica if not provided&#xA;    connections:&#xA;      - role: primary&#xA;        host: primary.sql.host&#xA;      - role: replica&#xA;        host: replica1.sql.host&#xA;      - role: replica&#xA;        host: replica2.sql.host&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s break this down a little bit. At the top level of your config you have the standard &lt;code&gt;adapter&lt;/code&gt; choice. Currently the available adapters are listed in &lt;a href=&#34;https://raw.githubusercontent.com/instacart/makara/master/lib/active_record/connection_adapters/&#34;&gt;lib/active_record/connection_adapters/&lt;/a&gt;. They are in the form of &lt;code&gt;#{db_type}_makara&lt;/code&gt; where db_type is mysql, postgresql, etc.&lt;/p&gt; &#xA;&lt;p&gt;Following the adapter choice is all the standard configurations (host, port, retry, database, username, password, etc). With all the standard configurations provided, you can now provide the makara subconfig.&lt;/p&gt; &#xA;&lt;p&gt;The makara subconfig sets up the proxy with a few of its own options, then provides the connection list. The makara options are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;id - an identifier for the proxy, used for sticky behaviour and context. The default is to use a MD5 hash of the configuration contents, so if you are setting &lt;code&gt;sticky&lt;/code&gt; to true, it&#39;s a good idea to also set an &lt;code&gt;id&lt;/code&gt;. Otherwise any stuck connections will be cleared if the configuration changes (as the default MD5 hash id would change as well)&lt;/li&gt; &#xA; &lt;li&gt;blacklist_duration - the number of seconds a node is blacklisted when a connection failure occurs&lt;/li&gt; &#xA; &lt;li&gt;disable_blacklist - do not blacklist node at any error, useful in case of one primary&lt;/li&gt; &#xA; &lt;li&gt;sticky - if a node should be stuck to once it&#39;s used during a specific context&lt;/li&gt; &#xA; &lt;li&gt;primary_ttl - how long the primary context is persisted. generally, this needs to be longer than any replication lag&lt;/li&gt; &#xA; &lt;li&gt;primary_strategy - use a different strategy for picking the &#34;current&#34; primary node: &lt;code&gt;failover&lt;/code&gt; will try to keep the same one until it is blacklisted. The default is &lt;code&gt;round_robin&lt;/code&gt; which will cycle through available ones.&lt;/li&gt; &#xA; &lt;li&gt;replica_strategy - use a different strategy for picking the &#34;current&#34; replica node: &lt;code&gt;failover&lt;/code&gt; will try to keep the same one until it is blacklisted. The default is &lt;code&gt;round_robin&lt;/code&gt; which will cycle through available ones.&lt;/li&gt; &#xA; &lt;li&gt;connection_error_matchers - array of custom error matchers you want to be handled gracefully by Makara (as in, errors matching these regexes will result in blacklisting the connection as opposed to raising directly).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Connection definitions contain any extra node-specific configurations. If the node should behave as a primary you must provide &lt;code&gt;role: primary&lt;/code&gt;. Any previous configurations can be overridden within a specific node&#39;s config. Nodes can also contain weights if you&#39;d like to balance usage based on hardware specifications. Optionally, you can provide a name attribute which will be used in sql logging.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;connections:&#xA;  - role: primary&#xA;    host: myprimary.sql.host&#xA;    blacklist_duration: 0&#xA;&#xA;  # implicit role: replica&#xA;  - host: mybigreplica.sql.host&#xA;    weight: 8&#xA;    name: Big Replica&#xA;  - host: mysmallreplica.sql.host&#xA;    weight: 2&#xA;    name: Small Replica&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the previous config the &#34;Big Replica&#34; would receive ~80% of traffic.&lt;/p&gt; &#xA;&lt;h4&gt;DATABASE_URL&lt;/h4&gt; &#xA;&lt;p&gt;Connections may specify a &lt;code&gt;url&lt;/code&gt; parameter in place of host, username, password, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;connections:&#xA;  - role: primary&#xA;    blacklist_duration: 0&#xA;    url: &#39;mysql2://db_username:db_password@localhost:3306/db_name&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We recommend, if using environmental variables, to interpolate them via ERb.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;connections:&#xA;  - role: primary&#xA;    blacklist_duration: 0&#xA;    url: &amp;lt;%= ENV[&#39;DATABASE_URL_PRIMARY&#39;] %&amp;gt;&#xA;  - role: replica&#xA;    url: &amp;lt;%= ENV[&#39;DATABASE_URL_REPLICA&#39;] %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt;: &lt;em&gt;Do NOT use &lt;code&gt;ENV[&#39;DATABASE_URL&#39;]&lt;/code&gt;&lt;/em&gt;, as it inteferes with the the database configuration initialization and may cause Makara not to complete the configuration. For the moment, it is easier to use a different ENV variable than to hook into the database initialization in all the supported Rails.&lt;/p&gt; &#xA;&lt;p&gt;For more information on url parsing, as used in &lt;a href=&#34;https://github.com/taskrabbit/makara/raw/master/lib/makara/config_parser.rb&#34;&gt;ConfigParser&lt;/a&gt;, see:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;3.0 &lt;a href=&#34;https://github.com/rails/rails/raw/3-0-stable/activerecord/lib/active_record/connection_adapters/abstract/connection_specification.rb#L3-L7&#34;&gt;ActiveRecord::Base::ConnectionSpecification.new&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;3.0 &lt;a href=&#34;https://github.com/rails/rails/raw/3-1-stable/activerecord/lib/active_record/connection_adapters/abstract/connection_specification.rb#L3-L7&#34;&gt;ActiveRecord::Base::ConnectionSpecification.new&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;3.2 &lt;a href=&#34;https://github.com/rails/rails/raw/3-2-stable/activerecord/lib/active_record/connection_adapters/abstract/connection_specification.rb#L60-L77&#34;&gt;ActiveRecord::Base::ConnectionSpecification::Resolver.send(:connection_url_to_hash, url_config[:url])&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;4.0 &lt;a href=&#34;https://github.com/rails/rails/raw/4-0-stable/activerecord/lib/active_record/connection_adapters/connection_specification.rb#L68-L92&#34;&gt;ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver.send(:connection_url_to_hash, url_config[:url])&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/rails/rails/raw/4-0-stable/activerecord/lib/active_record/connection_handling.rb&#34;&gt;ActiveRecord::ConnectionHandling::MergeAndResolveDefaultUrlConfig&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;4.1 &lt;a href=&#34;https://github.com/rails/rails/raw/4-1-stable/activerecord/lib/active_record/connection_adapters/connection_specification.rb#L17-L121&#34;&gt;ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver.new(url).to_hash&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;ActiveRecord::ConnectionHandling::MergeAndResolveDefaultUrlConfig.new(url_config).resolve&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;4.2 &lt;a href=&#34;https://github.com/rails/rails/raw/4-2-stable/activerecord/lib/active_record/connection_handling.rb#L60-L81&#34;&gt;ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver.new(url).to_hash&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;primary &lt;a href=&#34;https://github.com/rails/rails/raw/97b980b4e61aea3cee429bdee4b2eae2329905cd/activerecord/lib/active_record/connection_handling.rb#L60-L81&#34;&gt;ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver.new(url).to_hash&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Custom error matchers:&lt;/h2&gt; &#xA;&lt;p&gt;To enable Makara to catch and handle custom errors gracefully (blacklist the connection instead of raising directly), you must add your custom matchers to the &lt;code&gt;connection_error_matchers&lt;/code&gt; setting of your config file, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;production:&#xA;  adapter: &#39;mysql2_makara&#39;&#xA;&#xA;  makara:&#xA;    blacklist_duration: 5&#xA;    connection_error_matchers:&#xA;      - !ruby/regexp &#39;/^ActiveRecord::StatementInvalid: Mysql2::Error: Unknown command:/&#39;&#xA;      - &#39;/Sql Server Has Gone Away/&#39;&#xA;      - &#39;Mysql2::Error: Duplicate entry&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can provide strings or regexes. In the case of strings, if they start with &lt;code&gt;/&lt;/code&gt; and end with &lt;code&gt;/&lt;/code&gt; they will be converted to regexes when evaluated. Strings that don&#39;t start and end with &lt;code&gt;/&lt;/code&gt; will get evaluated with standard comparison.&lt;/p&gt; &#xA;&lt;h2&gt;Common Problems / Solutions&lt;/h2&gt; &#xA;&lt;p&gt;On occasion your app may deal with a situation where makara is not present during a write but a read should use primary. In the generic proxy details above you are encouraged to use &lt;code&gt;stick_to_primary!&lt;/code&gt; to accomplish this. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# some third party creates a resource in your db, replication may not have completed yet&#xA;# ...&#xA;# then your app is told to read the resource.&#xA;def handle_request_after_third_party_record_creation&#xA;  CreatedResourceClass.connection.stick_to_primary!&#xA;  CreatedResourceClass.find(params[:id]) # will go to the primary&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Todo&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for providing context as query param&lt;/li&gt; &#xA; &lt;li&gt;More real world examples&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>