<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-10T01:32:57Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>varvet/pundit</title>
    <updated>2022-06-10T01:32:57Z</updated>
    <id>tag:github.com,2022-06-10:/varvet/pundit</id>
    <link href="https://github.com/varvet/pundit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Minimal authorization through OO design and pure Ruby classes&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Pundit&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/varvet/pundit&#34;&gt;&lt;img src=&#34;https://secure.travis-ci.org/varvet/pundit.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/varvet/pundit&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/varvet/pundit.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://inch-ci.org/github/varvet/pundit&#34;&gt;&lt;img src=&#34;http://inch-ci.org/github/varvet/pundit.svg?branch=master&#34; alt=&#34;Inline docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://badge.fury.io/rb/pundit&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/pundit.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Pundit provides a set of helpers which guide you in leveraging regular Ruby classes and object oriented design patterns to build a simple, robust and scalable authorization system.&lt;/p&gt; &#xA;&lt;p&gt;Links:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.rubydoc.info/gems/pundit&#34;&gt;API documentation for the most recent version&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit&#34;&gt;Source Code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit/raw/master/CONTRIBUTING.md&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit/raw/master/CODE_OF_CONDUCT.md&#34;&gt;Code of Conduct&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Sponsored by:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.varvet.com&#34;&gt;&lt;img src=&#34;https://www.varvet.com/images/wordmark-red.svg?sanitize=true&#34; alt=&#34;Varvet&#34; height=&#34;50px&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Please note&lt;/strong&gt; that the README on GitHub is accurate with the &lt;em&gt;latest code on GitHub&lt;/em&gt;. You are most likely using a released version of Pundit, so please refer to the &lt;a href=&#34;https://www.rubydoc.info/gems/pundit&#34;&gt;documentation for the latest released version of Pundit&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;bundle add pundit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Include &lt;code&gt;Pundit::Authorization&lt;/code&gt; in your application controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include Pundit::Authorization&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Optionally, you can run the generator, which will set up an application policy with some useful defaults for you:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rails g pundit:install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After generating your application policy, restart the Rails server so that Rails can pick up any classes in the new &lt;code&gt;app/policies/&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Policies&lt;/h2&gt; &#xA;&lt;p&gt;Pundit is focused around the notion of policy classes. We suggest that you put these classes in &lt;code&gt;app/policies&lt;/code&gt;. This is a simple example that allows updating a post if the user is an admin, or if the post is unpublished:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy&#xA;  attr_reader :user, :post&#xA;&#xA;  def initialize(user, post)&#xA;    @user = user&#xA;    @post = post&#xA;  end&#xA;&#xA;  def update?&#xA;    user.admin? || !post.published?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, this is just a plain Ruby class. Pundit makes the following assumptions about this class:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The class has the same name as some kind of model class, only suffixed with the word &#34;Policy&#34;.&lt;/li&gt; &#xA; &lt;li&gt;The first argument is a user. In your controller, Pundit will call the &lt;code&gt;current_user&lt;/code&gt; method to retrieve what to send into this argument&lt;/li&gt; &#xA; &lt;li&gt;The second argument is some kind of model object, whose authorization you want to check. This does not need to be an ActiveRecord or even an ActiveModel object, it can be anything really.&lt;/li&gt; &#xA; &lt;li&gt;The class implements some kind of query method, in this case &lt;code&gt;update?&lt;/code&gt;. Usually, this will map to the name of a particular controller action.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;That&#39;s it really.&lt;/p&gt; &#xA;&lt;p&gt;Usually you&#39;ll want to inherit from the application policy created by the generator, or set up your own base class to inherit from:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  def update?&#xA;    user.admin? or not record.published?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the generated &lt;code&gt;ApplicationPolicy&lt;/code&gt;, the model object is called &lt;code&gt;record&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Supposing that you have an instance of class &lt;code&gt;Post&lt;/code&gt;, Pundit now lets you do this in your controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def update&#xA;  @post = Post.find(params[:id])&#xA;  authorize @post&#xA;  if @post.update(post_params)&#xA;    redirect_to @post&#xA;  else&#xA;    render :edit&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The authorize method automatically infers that &lt;code&gt;Post&lt;/code&gt; will have a matching &lt;code&gt;PostPolicy&lt;/code&gt; class, and instantiates this class, handing in the current user and the given record. It then infers from the action name, that it should call &lt;code&gt;update?&lt;/code&gt; on this instance of the policy. In this case, you can imagine that &lt;code&gt;authorize&lt;/code&gt; would have done something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;unless PostPolicy.new(current_user, @post).update?&#xA;  raise Pundit::NotAuthorizedError, &#34;not allowed to update? this #{@post.inspect}&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can pass a second argument to &lt;code&gt;authorize&lt;/code&gt; if the name of the permission you want to check doesn&#39;t match the action name. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def publish&#xA;  @post = Post.find(params[:id])&#xA;  authorize @post, :update?&#xA;  @post.publish!&#xA;  redirect_to @post&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can pass an argument to override the policy class if necessary. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def create&#xA;  @publication = find_publication # assume this method returns any model that behaves like a publication&#xA;  # @publication.class =&amp;gt; Post&#xA;  authorize @publication, policy_class: PublicationPolicy&#xA;  @publication.publish!&#xA;  redirect_to @publication&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t have an instance for the first argument to &lt;code&gt;authorize&lt;/code&gt;, then you can pass the class. For example:&lt;/p&gt; &#xA;&lt;p&gt;Policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  def admin_list?&#xA;    user.admin?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def admin_list&#xA;  authorize Post # we don&#39;t have a particular post to authorize&#xA;  # Rest of controller action&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;authorize&lt;/code&gt; returns the instance passed to it, so you can chain it like this:&lt;/p&gt; &#xA;&lt;p&gt;Controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def show&#xA;  @user = authorize User.find(params[:id])&#xA;end&#xA;&#xA;# return the record even for namespaced policies&#xA;def show&#xA;  @user = authorize [:admin, User.find(params[:id])]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can easily get a hold of an instance of the policy through the &lt;code&gt;policy&lt;/code&gt; method in both the view and controller. This is especially useful for conditionally showing links or buttons in the view:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;% if policy(@post).update? %&amp;gt;&#xA;  &amp;lt;%= link_to &#34;Edit post&#34;, edit_post_path(@post) %&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Headless policies&lt;/h2&gt; &#xA;&lt;p&gt;Given there is a policy without a corresponding model / ruby class, you can retrieve it by passing a symbol.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/policies/dashboard_policy.rb&#xA;class DashboardPolicy&#xA;  attr_reader :user&#xA;&#xA;  # _record in this example will just be :dashboard&#xA;  def initialize(user, _record)&#xA;    @user = user&#xA;  end&#xA;&#xA;  def show?&#xA;    user.admin?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the headless policy still needs to accept two arguments. The second argument will just be the symbol &lt;code&gt;:dashboard&lt;/code&gt; in this case which is what is passed as the record to &lt;code&gt;authorize&lt;/code&gt; below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# In controllers&#xA;def show&#xA;  authorize :dashboard, :show?&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;# In views&#xA;&amp;lt;% if policy(:dashboard).show? %&amp;gt;&#xA;  &amp;lt;%= link_to &#39;Dashboard&#39;, dashboard_path %&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Scopes&lt;/h2&gt; &#xA;&lt;p&gt;Often, you will want to have some kind of view listing records which a particular user has access to. When using Pundit, you are expected to define a class called a policy scope. It can look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  class Scope&#xA;    def initialize(user, scope)&#xA;      @user  = user&#xA;      @scope = scope&#xA;    end&#xA;&#xA;    def resolve&#xA;      if user.admin?&#xA;        scope.all&#xA;      else&#xA;        scope.where(published: true)&#xA;      end&#xA;    end&#xA;&#xA;    private&#xA;&#xA;    attr_reader :user, :scope&#xA;  end&#xA;&#xA;  def update?&#xA;    user.admin? or not record.published?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pundit makes the following assumptions about this class:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The class has the name &lt;code&gt;Scope&lt;/code&gt; and is nested under the policy class.&lt;/li&gt; &#xA; &lt;li&gt;The first argument is a user. In your controller, Pundit will call the &lt;code&gt;current_user&lt;/code&gt; method to retrieve what to send into this argument.&lt;/li&gt; &#xA; &lt;li&gt;The second argument is a scope of some kind on which to perform some kind of query. It will usually be an ActiveRecord class or a &lt;code&gt;ActiveRecord::Relation&lt;/code&gt;, but it could be something else entirely.&lt;/li&gt; &#xA; &lt;li&gt;Instances of this class respond to the method &lt;code&gt;resolve&lt;/code&gt;, which should return some kind of result which can be iterated over. For ActiveRecord classes, this would usually be an &lt;code&gt;ActiveRecord::Relation&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You&#39;ll probably want to inherit from the application policy scope generated by the generator, or create your own base class to inherit from:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  class Scope &amp;lt; Scope&#xA;    def resolve&#xA;      if user.admin?&#xA;        scope.all&#xA;      else&#xA;        scope.where(published: true)&#xA;      end&#xA;    end&#xA;  end&#xA;&#xA;  def update?&#xA;    user.admin? or not record.published?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now use this class from your controller via the &lt;code&gt;policy_scope&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def index&#xA;  @posts = policy_scope(Post)&#xA;end&#xA;&#xA;def show&#xA;  @post = policy_scope(Post).find(params[:id])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Like with the authorize method, you can also override the policy scope class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def index&#xA;  # publication_class =&amp;gt; Post&#xA;  @publications = policy_scope(publication_class, policy_scope_class: PublicationPolicy::Scope)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case it is a shortcut for doing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def index&#xA;  @publications = PublicationPolicy::Scope.new(current_user, Post).resolve&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can, and are encouraged to, use this method in views:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;% policy_scope(@user.posts).each do |post| %&amp;gt;&#xA;  &amp;lt;p&amp;gt;&amp;lt;%= link_to post.title, post_path(post) %&amp;gt;&amp;lt;/p&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Ensuring policies and scopes are used&lt;/h2&gt; &#xA;&lt;p&gt;When you are developing an application with Pundit it can be easy to forget to authorize some action. People are forgetful after all. Since Pundit encourages you to add the &lt;code&gt;authorize&lt;/code&gt; call manually to each controller action, it&#39;s really easy to miss one.&lt;/p&gt; &#xA;&lt;p&gt;Thankfully, Pundit has a handy feature which reminds you in case you forget. Pundit tracks whether you have called &lt;code&gt;authorize&lt;/code&gt; anywhere in your controller action. Pundit also adds a method to your controllers called &lt;code&gt;verify_authorized&lt;/code&gt;. This method will raise an exception if &lt;code&gt;authorize&lt;/code&gt; has not yet been called. You should run this method in an &lt;code&gt;after_action&lt;/code&gt; hook to ensure that you haven&#39;t forgotten to authorize the action. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include Pundit::Authorization&#xA;  after_action :verify_authorized&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Likewise, Pundit also adds &lt;code&gt;verify_policy_scoped&lt;/code&gt; to your controller. This will raise an exception similar to &lt;code&gt;verify_authorized&lt;/code&gt;. However, it tracks if &lt;code&gt;policy_scope&lt;/code&gt; is used instead of &lt;code&gt;authorize&lt;/code&gt;. This is mostly useful for controller actions like &lt;code&gt;index&lt;/code&gt; which find collections with a scope and don&#39;t authorize individual instances.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include Pundit::Authorization&#xA;  after_action :verify_authorized, except: :index&#xA;  after_action :verify_policy_scoped, only: :index&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;This verification mechanism only exists to aid you while developing your application, so you don&#39;t forget to call &lt;code&gt;authorize&lt;/code&gt;. It is not some kind of failsafe mechanism or authorization mechanism. You should be able to remove these filters without affecting how your app works in any way.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Some people have found this feature confusing, while many others find it extremely helpful. If you fall into the category of people who find it confusing then you do not need to use it. Pundit will work just fine without using &lt;code&gt;verify_authorized&lt;/code&gt; and &lt;code&gt;verify_policy_scoped&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Conditional verification&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re using &lt;code&gt;verify_authorized&lt;/code&gt; in your controllers but need to conditionally bypass verification, you can use &lt;code&gt;skip_authorization&lt;/code&gt;. For bypassing &lt;code&gt;verify_policy_scoped&lt;/code&gt;, use &lt;code&gt;skip_policy_scope&lt;/code&gt;. These are useful in circumstances where you don&#39;t want to disable verification for the entire action, but have some cases where you intend to not authorize.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def show&#xA;  record = Record.find_by(attribute: &#34;value&#34;)&#xA;  if record.present?&#xA;    authorize record&#xA;  else&#xA;    skip_authorization&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Manually specifying policy classes&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes you might want to explicitly declare which policy to use for a given class, instead of letting Pundit infer it. This can be done like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Post&#xA;  def self.policy_class&#xA;    PostablePolicy&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can declare an instance method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Post&#xA;  def policy_class&#xA;    PostablePolicy&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Just plain old Ruby&lt;/h2&gt; &#xA;&lt;p&gt;As you can see, Pundit doesn&#39;t do anything you couldn&#39;t have easily done yourself. It&#39;s a very small library, it just provides a few neat helpers. Together these give you the power of building a well structured, fully working authorization system without using any special DSLs or funky syntax or anything.&lt;/p&gt; &#xA;&lt;p&gt;Remember that all of the policy and scope classes are just plain Ruby classes, which means you can use the same mechanisms you always use to DRY things up. Encapsulate a set of permissions into a module and include them in multiple policies. Use &lt;code&gt;alias_method&lt;/code&gt; to make some permissions behave the same as others. Inherit from a base set of permissions. Use metaprogramming if you really have to.&lt;/p&gt; &#xA;&lt;h2&gt;Generator&lt;/h2&gt; &#xA;&lt;p&gt;Use the supplied generator to generate policies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rails g pundit:policy post&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Closed systems&lt;/h2&gt; &#xA;&lt;p&gt;In many applications, only logged in users are really able to do anything. If you&#39;re building such a system, it can be kind of cumbersome to check that the user in a policy isn&#39;t &lt;code&gt;nil&lt;/code&gt; for every single permission. Aside from policies, you can add this check to the base class for scopes.&lt;/p&gt; &#xA;&lt;p&gt;We suggest that you define a filter that redirects unauthenticated users to the login page. As a secondary defence, if you&#39;ve defined an ApplicationPolicy, it might be a good idea to raise an exception if somehow an unauthenticated user got through. This way you can fail more gracefully.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationPolicy&#xA;  def initialize(user, record)&#xA;    raise Pundit::NotAuthorizedError, &#34;must be logged in&#34; unless user&#xA;    @user   = user&#xA;    @record = record&#xA;  end&#xA;&#xA;  class Scope&#xA;    attr_reader :user, :scope&#xA;&#xA;    def initialize(user, scope)&#xA;      raise Pundit::NotAuthorizedError, &#34;must be logged in&#34; unless user&#xA;      @user = user&#xA;      @scope = scope&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;NilClassPolicy&lt;/h2&gt; &#xA;&lt;p&gt;To support a &lt;a href=&#34;https://en.wikipedia.org/wiki/Null_Object_pattern&#34;&gt;null object pattern&lt;/a&gt; you may find that you want to implement a &lt;code&gt;NilClassPolicy&lt;/code&gt;. This might be useful where you want to extend your ApplicationPolicy to allow some tolerance of, for example, associations which might be &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NilClassPolicy &amp;lt; ApplicationPolicy&#xA;  class Scope &amp;lt; Scope&#xA;    def resolve&#xA;      raise Pundit::NotDefinedError, &#34;Cannot scope NilClass&#34;&#xA;    end&#xA;  end&#xA;&#xA;  def show?&#xA;    false # Nobody can see nothing&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Rescuing a denied Authorization in Rails&lt;/h2&gt; &#xA;&lt;p&gt;Pundit raises a &lt;code&gt;Pundit::NotAuthorizedError&lt;/code&gt; you can &lt;a href=&#34;http://guides.rubyonrails.org/action_controller_overview.html#rescue-from&#34;&gt;rescue_from&lt;/a&gt; in your &lt;code&gt;ApplicationController&lt;/code&gt;. You can customize the &lt;code&gt;user_not_authorized&lt;/code&gt; method in every controller.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include Pundit::Authorization&#xA;&#xA;  rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized&#xA;&#xA;  private&#xA;&#xA;  def user_not_authorized&#xA;    flash[:alert] = &#34;You are not authorized to perform this action.&#34;&#xA;    redirect_back(fallback_location: root_path)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can globally handle Pundit::NotAuthorizedError&#39;s by having rails handle them as a 403 error and serving a 403 error page. Add the following to application.rb:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;config.action_dispatch.rescue_responses[&#34;Pundit::NotAuthorizedError&#34;] = :forbidden&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Creating custom error messages&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;NotAuthorizedError&lt;/code&gt;s provide information on what query (e.g. &lt;code&gt;:create?&lt;/code&gt;), what record (e.g. an instance of &lt;code&gt;Post&lt;/code&gt;), and what policy (e.g. an instance of &lt;code&gt;PostPolicy&lt;/code&gt;) caused the error to be raised.&lt;/p&gt; &#xA;&lt;p&gt;One way to use these &lt;code&gt;query&lt;/code&gt;, &lt;code&gt;record&lt;/code&gt;, and &lt;code&gt;policy&lt;/code&gt; properties is to connect them with &lt;code&gt;I18n&lt;/code&gt; to generate error messages. Here&#39;s how you might go about doing that.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA; rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized&#xA;&#xA; private&#xA;&#xA; def user_not_authorized(exception)&#xA;   policy_name = exception.policy.class.to_s.underscore&#xA;&#xA;   flash[:error] = t &#34;#{policy_name}.#{exception.query}&#34;, scope: &#34;pundit&#34;, default: :default&#xA;   redirect_back(fallback_url: root_path)&#xA; end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;en:&#xA; pundit:&#xA;   default: &#39;You cannot perform this action.&#39;&#xA;   post_policy:&#xA;     update?: &#39;You cannot edit this post!&#39;&#xA;     create?: &#39;You cannot create posts!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course, this is just an example. Pundit is agnostic as to how you implement your error messaging.&lt;/p&gt; &#xA;&lt;h2&gt;Manually retrieving policies and scopes&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes you want to retrieve a policy for a record outside the controller or view. For example when you delegate permissions from one policy to another.&lt;/p&gt; &#xA;&lt;p&gt;You can easily retrieve policies and scopes like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Pundit.policy!(user, post)&#xA;Pundit.policy(user, post)&#xA;&#xA;Pundit.policy_scope!(user, Post)&#xA;Pundit.policy_scope(user, Post)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The bang methods will raise an exception if the policy does not exist, whereas those without the bang will return nil.&lt;/p&gt; &#xA;&lt;h2&gt;Customize Pundit user&lt;/h2&gt; &#xA;&lt;p&gt;In some cases your controller might not have access to &lt;code&gt;current_user&lt;/code&gt;, or your &lt;code&gt;current_user&lt;/code&gt; is not the method that should be invoked by Pundit. Simply define a method in your controller called &lt;code&gt;pundit_user&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def pundit_user&#xA;  User.find_by_other_means&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Policy Namespacing&lt;/h2&gt; &#xA;&lt;p&gt;In some cases it might be helpful to have multiple policies that serve different contexts for a resource. A prime example of this is the case where User policies differ from Admin policies. To authorize with a namespaced policy, pass the namespace into the &lt;code&gt;authorize&lt;/code&gt; helper in an array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;authorize(post)                   # =&amp;gt; will look for a PostPolicy&#xA;authorize([:admin, post])         # =&amp;gt; will look for an Admin::PostPolicy&#xA;authorize([:foo, :bar, post])     # =&amp;gt; will look for a Foo::Bar::PostPolicy&#xA;&#xA;policy_scope(Post)                # =&amp;gt; will look for a PostPolicy::Scope&#xA;policy_scope([:admin, Post])      # =&amp;gt; will look for an Admin::PostPolicy::Scope&#xA;policy_scope([:foo, :bar, Post])  # =&amp;gt; will look for a Foo::Bar::PostPolicy::Scope&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are using namespaced policies for something like Admin views, it can be useful to override the &lt;code&gt;policy_scope&lt;/code&gt; and &lt;code&gt;authorize&lt;/code&gt; helpers in your &lt;code&gt;AdminController&lt;/code&gt; to automatically apply the namespacing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AdminController &amp;lt; ApplicationController&#xA;  def policy_scope(scope)&#xA;    super([:admin, scope])&#xA;  end&#xA;&#xA;  def authorize(record, query = nil)&#xA;    super([:admin, record], query)&#xA;  end&#xA;end&#xA;&#xA;class Admin::PostController &amp;lt; AdminController&#xA;  def index&#xA;    policy_scope(Post)&#xA;  end&#xA;&#xA;  def show&#xA;    post = authorize Post.find(params[:id])&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Additional context&lt;/h2&gt; &#xA;&lt;p&gt;Pundit strongly encourages you to model your application in such a way that the only context you need for authorization is a user object and a domain model that you want to check authorization for. If you find yourself needing more context than that, consider whether you are authorizing the right domain model, maybe another domain model (or a wrapper around multiple domain models) can provide the context you need.&lt;/p&gt; &#xA;&lt;p&gt;Pundit does not allow you to pass additional arguments to policies for precisely this reason.&lt;/p&gt; &#xA;&lt;p&gt;However, in very rare cases, you might need to authorize based on more context than just the currently authenticated user. Suppose for example that authorization is dependent on IP address in addition to the authenticated user. In that case, one option is to create a special class which wraps up both user and IP and passes it to the policy.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UserContext&#xA;  attr_reader :user, :ip&#xA;&#xA;  def initialize(user, ip)&#xA;    @user = user&#xA;    @ip   = ip&#xA;  end&#xA;end&#xA;&#xA;class ApplicationController&#xA;  include Pundit::Authorization&#xA;&#xA;  def pundit_user&#xA;    UserContext.new(current_user, request.ip)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Strong parameters&lt;/h2&gt; &#xA;&lt;p&gt;In Rails, mass-assignment protection is handled in the controller. With Pundit you can control which attributes a user has access to update via your policies. You can set up a &lt;code&gt;permitted_attributes&lt;/code&gt; method in your policy like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/policies/post_policy.rb&#xA;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  def permitted_attributes&#xA;    if user.admin? || user.owner_of?(post)&#xA;      [:title, :body, :tag_list]&#xA;    else&#xA;      [:tag_list]&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now retrieve these attributes from the policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/posts_controller.rb&#xA;class PostsController &amp;lt; ApplicationController&#xA;  def update&#xA;    @post = Post.find(params[:id])&#xA;    if @post.update_attributes(post_params)&#xA;      redirect_to @post&#xA;    else&#xA;      render :edit&#xA;    end&#xA;  end&#xA;&#xA;  private&#xA;&#xA;  def post_params&#xA;    params.require(:post).permit(policy(@post).permitted_attributes)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, this is a bit cumbersome, so Pundit provides a convenient helper method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/posts_controller.rb&#xA;class PostsController &amp;lt; ApplicationController&#xA;  def update&#xA;    @post = Post.find(params[:id])&#xA;    if @post.update_attributes(permitted_attributes(@post))&#xA;      redirect_to @post&#xA;    else&#xA;      render :edit&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to permit different attributes based on the current action, you can define a &lt;code&gt;permitted_attributes_for_#{action}&lt;/code&gt; method on your policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/policies/post_policy.rb&#xA;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  def permitted_attributes_for_create&#xA;    [:title, :body]&#xA;  end&#xA;&#xA;  def permitted_attributes_for_edit&#xA;    [:body]&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have defined an action-specific method on your policy for the current action, the &lt;code&gt;permitted_attributes&lt;/code&gt; helper will call it instead of calling &lt;code&gt;permitted_attributes&lt;/code&gt; on your controller.&lt;/p&gt; &#xA;&lt;p&gt;If you need to fetch parameters based on namespaces different from the suggested one, override the below method, in your controller, and return an instance of &lt;code&gt;ActionController::Parameters&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def pundit_params_for(record)&#xA;  params.require(PolicyFinder.new(record).param_key)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# If you don&#39;t want to use require&#xA;def pundit_params_for(record)&#xA;  params.fetch(PolicyFinder.new(record).param_key, {})&#xA;end&#xA;&#xA;# If you are using something like the JSON API spec&#xA;def pundit_params_for(_record)&#xA;  params.fetch(:data, {}).fetch(:attributes, {})&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;RSpec&lt;/h2&gt; &#xA;&lt;h3&gt;Policy Specs&lt;/h3&gt; &#xA;&lt;p&gt;Pundit includes a mini-DSL for writing expressive tests for your policies in RSpec. Require &lt;code&gt;pundit/rspec&lt;/code&gt; in your &lt;code&gt;spec_helper.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;pundit/rspec&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then put your policy specs in &lt;code&gt;spec/policies&lt;/code&gt;, and make them look somewhat like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;describe PostPolicy do&#xA;  subject { described_class }&#xA;&#xA;  permissions :update?, :edit? do&#xA;    it &#34;denies access if post is published&#34; do&#xA;      expect(subject).not_to permit(User.new(admin: false), Post.new(published: true))&#xA;    end&#xA;&#xA;    it &#34;grants access if post is published and user is an admin&#34; do&#xA;      expect(subject).to permit(User.new(admin: true), Post.new(published: true))&#xA;    end&#xA;&#xA;    it &#34;grants access if post is unpublished&#34; do&#xA;      expect(subject).to permit(User.new(admin: false), Post.new(published: false))&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An alternative approach to Pundit policy specs is scoping them to a user context as outlined in this &lt;a href=&#34;http://thunderboltlabs.com/blog/2013/03/27/testing-pundit-policies-with-rspec/&#34;&gt;excellent post&lt;/a&gt; and implemented in the third party &lt;a href=&#34;https://github.com/chrisalley/pundit-matchers&#34;&gt;pundit-matchers&lt;/a&gt; gem.&lt;/p&gt; &#xA;&lt;h3&gt;Scope Specs&lt;/h3&gt; &#xA;&lt;p&gt;Pundit does not provide a DSL for testing scopes. Just test it like a regular Ruby class!&lt;/p&gt; &#xA;&lt;h1&gt;External Resources&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/RailsApps/rails-devise-pundit&#34;&gt;RailsApps Example Application: Pundit and Devise&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://blog.carbonfive.com/2013/10/21/migrating-to-pundit-from-cancan/&#34;&gt;Migrating to Pundit from CanCan&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://thunderboltlabs.com/blog/2013/03/27/testing-pundit-policies-with-rspec/&#34;&gt;Testing Pundit Policies with RSpec&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit/issues/204#issuecomment-60166450&#34;&gt;Testing Pundit with Minitest&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit/pull/136&#34;&gt;Using Pundit outside of a Rails controller&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.sitepoint.com/straightforward-rails-authorization-with-pundit/&#34;&gt;Straightforward Rails Authorization with Pundit&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Other implementations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/anurag90x/flask-pundit&#34;&gt;Flask-Pundit&lt;/a&gt; (Python) is a &lt;a href=&#34;http://flask.pocoo.org/&#34;&gt;Flask&lt;/a&gt; extension &#34;heavily inspired by&#34; Pundit&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Licensed under the MIT license, see the separate LICENSE.txt file.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-3-nested-hash-iteration</title>
    <updated>2022-06-10T01:32:57Z</updated>
    <id>tag:github.com,2022-06-10:/learn-co-curriculum/phase-3-nested-hash-iteration</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-nested-hash-iteration" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Enumerables: Iterating Over Nested Hashes&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Iterate over a nested hash&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Iterating Over Nested Hashes&lt;/h2&gt; &#xA;&lt;p&gt;In Ruby, it&#39;s possible to use enumerable methods to iterate over key-value pairs in hashes. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;jon_snow = {&#xA;  name: &#34;Jon&#34;,&#xA;  email: &#34;jon_snow@thewall.we&#34;&#xA;}&#xA;&#xA;jon_snow.each do |key, value|&#xA;  puts &#34;Key: #{key}&#34;&#xA;  puts &#34;Value: #{value}&#34;&#xA;end&#xA;&#xA;# Key: name&#xA;# Value: Jon&#xA;# Key: email&#xA;# Value: jon_snow@thewall.we&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What happens when we want to iterate over a nested hash like the one below? Let&#39;s iterate over our nested hash one level at a time; iterating over the first level of our hash would look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;contacts = {&#xA;  &#34;Jon Snow&#34; =&amp;gt; {&#xA;    name: &#34;Jon&#34;,&#xA;    email: &#34;jon_snow@thewall.we&#34;,&#xA;    favorite_ice_cream_flavors: [&#34;chocolate&#34;, &#34;vanilla&#34;, &#34;mint chip&#34;],&#xA;    knows: nil&#xA;  },&#xA;  &#34;Freddy Mercury&#34; =&amp;gt; {&#xA;    name: &#34;Freddy&#34;,&#xA;    email: &#34;freddy@mercury.com&#34;,&#xA;    favorite_ice_cream_flavors: [&#34;strawberry&#34;, &#34;cookie dough&#34;, &#34;mint chip&#34;]&#xA;  }&#xA;}&#xA;&#xA;contacts.each do |person, data|&#xA;  puts &#34;#{person}: #{data}&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This should return:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Jon Snow: {&#xA;  :name=&amp;gt;&#34;Jon&#34;,&#xA;  :email=&amp;gt;&#34;jon_snow@thewall.we&#34;,&#xA;  :favorite_ice_cream_flavors=&amp;gt;[&#34;chocolate&#34;, &#34;vanilla&#34;, &#34;mint chip&#34;],&#xA;  :knows=&amp;gt;nil&#xA;}&#xA;Freddy Mercury: {&#xA;  :name=&amp;gt;&#34;Freddy&#34;,&#xA;  :email=&amp;gt;&#34;freddy@mercury.com&#34;,&#xA;  :favorite_ice_cream_flavors=&amp;gt;[&#34;strawberry&#34;, &#34;cookie dough&#34;, &#34;mint chip&#34;]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On the first level, the &lt;strong&gt;keys&lt;/strong&gt; are our contacts&#39; names, &#34;Jon Snow&#34; and &#34;Freddy Mercury&#34;, and our &lt;strong&gt;values&lt;/strong&gt; are the hashes that contain a series of key/value pairs describing them.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s iterate over the second level of our &lt;code&gt;contacts&lt;/code&gt; hash. In order to access the key/value pairs of the second tier (i.e. the name, email, and other data about each contact), we need to iterate &lt;em&gt;down into&lt;/em&gt; that level. So, we pick up where we left off with the previous iteration and we keep going:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;contacts.each do |person, data|&#xA;  #at this level, &#34;person&#34; is Jon Snow or Freddy Mercury and &#34;data&#34; is a hash of&#xA;  #key/value pairs to iterate over the &#34;data&#34; hash, we can use the following line:&#xA;&#xA;  data.each do |attribute, value|&#xA;    puts &#34;#{attribute}: #{value}&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That should output the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;name: Jon&#xA;email: jon_snow@thewall.we&#xA;favorite_ice_cream_flavors: [&#34;chocolate&#34;, &#34;vanilla&#34;, &#34;mint chip&#34;]&#xA;knows:&#xA;name: Freddy&#xA;email: freddy@mercury.com&#xA;favorite_ice_cream_flavors: [&#34;strawberry&#34;, &#34;cookie dough&#34;, &#34;mint chip&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s take it one step further and print out &lt;em&gt;just the favorite ice cream flavors&lt;/em&gt;. Once again, we&#39;ll need to iterate down into that level of the hash, then we can access the favorite ice cream array and print out the flavors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;contacts.each do |person, data|&#xA;  #at this level, &#34;person&#34; is Jon Snow or Freddy and &#34;data&#34; is a hash of&#xA;  #key/value pairs to iterate over the &#34;data&#34; hash, we can use the following&#xA;  #line:&#xA;&#xA;  data.each do |attribute, value|&#xA;    #at this level, &#34;attribute&#34; describes the key of :name, :email,&#xA;    #:favorite_ice_cream_flavors, or :knows we need to first check and see if&#xA;    #the key is :favorite_ice_cream_flavors, if it is, that means the VALUE is&#xA;    #an array that we can iterate over to print out each element&#xA;&#xA;    if attribute == :favorite_ice_cream_flavors&#xA;      value.each do |flavor|&#xA;        # here, each index element in an ice cream flavor string&#xA;        puts &#34;#{flavor}&#34;&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This should output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;chocolate&#xA;vanilla&#xA;mint chip&#xA;strawberry&#xA;cookie dough&#xA;mint chip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Being able to access data from a nested hash like this gives us a lot of ways to work with this complex data structure and derive insights. What if instead of printing out the favorite ice creams of our contacts, we wanted to collect their email addresses in an array? Well, we could do something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;emails = []&#xA;&#xA;contacts.each do |person, data|&#xA;  data.each do |attribute, value|&#xA;    if attribute == :email&#xA;      emails &amp;lt;&amp;lt; value&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;emails&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Code Along Exercise&lt;/h2&gt; &#xA;&lt;p&gt;Fork and clone this exercise to code along!&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s do an exercise to get some practice iterating through nested arrays. You&#39;ll be coding your solution in &lt;code&gt;contacts.rb&lt;/code&gt;. You&#39;ll be manipulating the hash that is returned by the &lt;code&gt;#contacts&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def contacts&#xA;  {&#xA;    &#34;Jon Snow&#34; =&amp;gt; {&#xA;      name: &#34;Jon&#34;,&#xA;      email: &#34;jon_snow@thewall.we&#34;,&#xA;      favorite_ice_cream_flavors: [&#34;chocolate&#34;, &#34;vanilla&#34;]&#xA;    },&#xA;    &#34;Freddy Mercury&#34; =&amp;gt; {&#xA;      name: &#34;Freddy&#34;,&#xA;      email: &#34;freddy@mercury.com&#34;,&#xA;      favorite_ice_cream_flavors: [&#34;strawberry&#34;, &#34;cookie dough&#34;, &#34;mint chip&#34;]&#xA;    }&#xA;  }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Your good buddy Freddy Mercury has recently developed a strawberry allergy! You need to delete &lt;code&gt;&#34;strawberry&#34;&lt;/code&gt; from his list of favorite ice cream flavors in the &lt;code&gt;remove_strawberry&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;Iterate over the &lt;code&gt;contacts&lt;/code&gt; hash and when you reach the key &lt;code&gt;:favorite_ice_cream_flavors&lt;/code&gt;, remove &lt;code&gt;&#34;strawberry&#34;&lt;/code&gt; from the Array of Freddy&#39;s favorite ice cream flavors.&lt;/p&gt; &#xA;&lt;p&gt;There are at least two ways you can accomplish this, and for this code along, we&#39;ll work with the second way.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;You can directly iterate over the hash that is the value of the &lt;code&gt;&#34;Freddy Mercury&#34;&lt;/code&gt; key by calling an enumerator method in &lt;code&gt;contacts[&#34;Freddy Mercury&#34;]&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can set a iterate through the hash and check for &lt;code&gt;Freddy Mercury&lt;/code&gt; only; when you reach the appropriate level, check to see if the key &lt;code&gt;==&lt;/code&gt; (&#34;is equal to&#34;) &lt;code&gt;:favorite_ice_cream_flavors&lt;/code&gt;. If it is, check to see if the array of flavors contains &lt;code&gt;&#34;strawberry&#34;&lt;/code&gt;. If it does, then delete it from the array.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Step 1: Iterate over the first level&lt;/h3&gt; &#xA;&lt;p&gt;Inside the &lt;code&gt;#remove_strawberry&lt;/code&gt; method, let&#39;s take our first dive into the contacts hash. Then we&#39;ll use &lt;code&gt;binding.pry&lt;/code&gt; to see where we are.&lt;/p&gt; &#xA;&lt;p&gt;We are going to first iterate over the top level of the hash where the keys should be the person and the values should be a hash of details about the person.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note on variable naming:&lt;/strong&gt; This process will be remarkably easier if you name your variables to accurately reflect the data they represent. For now, when the value we&#39;re iterating over is another hash, we will explicitly add a &lt;code&gt;_hash&lt;/code&gt; to the end of the variable name (like &lt;code&gt;contact_details_hash&lt;/code&gt; below).&lt;/p&gt; &#xA;&lt;p&gt;Add this code inside the &lt;code&gt;#remove_strawberry&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;contacts.each do |person, contact_details_hash|&#xA;  binding.pry&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can enter the Pry session in one of two ways: by running &lt;code&gt;learn test&lt;/code&gt; or by running &lt;code&gt;ruby contacts.rb&lt;/code&gt;. We&#39;ll use &lt;code&gt;learn test&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Run &lt;code&gt;learn test&lt;/code&gt; in the terminal and, at the Pry prompt, check that our defined variables (&lt;code&gt;person&lt;/code&gt; and &lt;code&gt;contact_details_hash&lt;/code&gt;) match our expectations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;person&#xA;# =&amp;gt; &#34;Jon Snow&#34;&#xA;&#xA;contact_details_hash&#xA;# =&amp;gt; {:name=&amp;gt;&#34;Jon&#34;, :email=&amp;gt;&#34;jon_snow@thewall.we&#34;, :favorite_ice_cream_flavors=&amp;gt;[&#34;chocolate&#34;, &#34;vanilla&#34;]}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Excellent! They do!&lt;/p&gt; &#xA;&lt;p&gt;Type &lt;code&gt;exit&lt;/code&gt; while in Pry to continue. The &lt;code&gt;binding.pry&lt;/code&gt; breakpoint should trigger a second time because we have &lt;em&gt;two&lt;/em&gt; contacts. You can verify that we&#39;re in the second loop through our hash by checking the values of &lt;code&gt;person&lt;/code&gt; and &lt;code&gt;contact_details_hash&lt;/code&gt; at the Pry prompt.&lt;/p&gt; &#xA;&lt;p&gt;Typing &lt;code&gt;exit&lt;/code&gt; now will end the loop and exit Pry since we&#39;ve finished iterating through our contacts. It will also display the results of the test, which we haven&#39;t passed just yet.&lt;/p&gt; &#xA;&lt;h3&gt;Step 2. Iterate over the second level&lt;/h3&gt; &#xA;&lt;p&gt;Update your code to match the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def remove_strawberry(contacts)&#xA;  contacts.each do |person, contact_details_hash|&#xA;    if person == &#34;Freddy Mercury&#34;&#xA;      contact_details_hash.each do |attribute, data|&#xA;        binding.pry&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Again, let&#39;s jump into our &lt;code&gt;binding.pry&lt;/code&gt; using &lt;code&gt;learn test&lt;/code&gt;. We can verify that we&#39;ve found the record for Freddy Mercury by checking the values of our variables:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;attribute&#xA;# =&amp;gt; :name&#xA;&#xA;data&#xA;# =&amp;gt; &#34;Freddy&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Remember, if you get stuck and can&#39;t enter text in Pry, hit &lt;code&gt;q&lt;/code&gt; to continue!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Before we move on, you will need to exit &lt;code&gt;pry&lt;/code&gt; again so you can see the results of the new code we&#39;ll be writing in Step 3. We are now inside the loop through the attributes. Because there are three of them, we will need to run &lt;code&gt;exit&lt;/code&gt; three times to finish the loop and exit &lt;code&gt;pry&lt;/code&gt;. Alternatively, you can run &lt;code&gt;exit-program&lt;/code&gt; or &lt;code&gt;!!!&lt;/code&gt; at any time to exit out of &lt;code&gt;pry&lt;/code&gt; entirely.&lt;/p&gt; &#xA;&lt;h3&gt;Step 3. Locate the element we&#39;re looking for&lt;/h3&gt; &#xA;&lt;p&gt;Update your code to match the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def remove_strawberry(contacts)&#xA;  contacts.each do |person, contact_details_hash|&#xA;    if person == &#34;Freddy Mercury&#34;&#xA;      contact_details_hash.each do |attribute, data|&#xA;        if attribute == :favorite_ice_cream_flavors&#xA;          binding.pry&#xA;        end&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This time we are still iterating through the attributes but we&#39;ve added a conditional so the &lt;code&gt;pry&lt;/code&gt; will only hit when the attribute is equal to &lt;code&gt;:favorite_ice_cream_flavors&lt;/code&gt;. If we check the value of &lt;code&gt;data&lt;/code&gt; in our binding, we should see the array containing Freddy&#39;s favorite flavors.&lt;/p&gt; &#xA;&lt;h4&gt;Step 4. Update the hash&lt;/h4&gt; &#xA;&lt;p&gt;Lastly, we will use the &lt;code&gt;#delete_if&lt;/code&gt; array method to iterate through the ice cream array and remove any element that matches &#34;strawberry&#34;. Recall that &lt;code&gt;data&lt;/code&gt; is the array containing Freddy&#39;s favorite ice cream flavors. &lt;code&gt;#delete_if&lt;/code&gt; will iterate through the array, check each element to see if it is equal to &#34;strawberry&#34;, and delete the element if the block returns &lt;code&gt;true&lt;/code&gt;. &lt;a href=&#34;https://docs.ruby-lang.org/en/2.7.0/Hash.html#method-i-delete_if&#34;&gt;Learn more about &lt;code&gt;#delete_if&lt;/code&gt; in the ruby docs.&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The full method should now be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def remove_strawberry(contacts)&#xA;  contacts.each do |person, contact_details_hash|&#xA;    if person == &#34;Freddy Mercury&#34;&#xA;      contact_details_hash.each do |attribute, data|&#xA;        if attribute == :favorite_ice_cream_flavors&#xA;          data.delete_if {|ice_cream| ice_cream == &#34;strawberry&#34;}&#xA;        end&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Congrats! You made it. Test that your method works by running &lt;code&gt;ruby contacts.rb&lt;/code&gt; in the terminal. It should output the hash without strawberry ice cream. Also, be sure to run the specs to make sure they pass.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jwt/ruby-jwt</title>
    <updated>2022-06-10T01:32:57Z</updated>
    <id>tag:github.com,2022-06-10:/jwt/ruby-jwt</id>
    <link href="https://github.com/jwt/ruby-jwt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A ruby implementation of the RFC 7519 OAuth JSON Web Token (JWT) standard.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;JWT&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://badge.fury.io/rb/jwt&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/jwt.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/jwt/ruby-jwt/actions&#34;&gt;&lt;img src=&#34;https://github.com/jwt/ruby-jwt/workflows/test/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/jwt/ruby-jwt&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/jwt/ruby-jwt/badges/gpa.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/jwt/ruby-jwt/coverage&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/jwt/ruby-jwt/badges/coverage.svg?sanitize=true&#34; alt=&#34;Test Coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/jwt/ruby-jwt&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/jwt/ruby-jwt/badges/issue_count.svg?sanitize=true&#34; alt=&#34;Issue Count&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://app.sourcelevel.io/github/jwt/-/ruby-jwt&#34;&gt;&lt;img src=&#34;https://app.sourcelevel.io/github/jwt/-/ruby-jwt.svg?sanitize=true&#34; alt=&#34;SourceLevel&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A ruby implementation of the &lt;a href=&#34;https://tools.ietf.org/html/rfc7519&#34;&gt;RFC 7519 OAuth JSON Web Token (JWT)&lt;/a&gt; standard.&lt;/p&gt; &#xA;&lt;p&gt;If you have further questions related to development or usage, join us: &lt;a href=&#34;https://groups.google.com/forum/#!forum/ruby-jwt&#34;&gt;ruby-jwt google group&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Announcements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ruby 2.4 support is going to be dropped in version 2.4.0&lt;/li&gt; &#xA; &lt;li&gt;Ruby 1.9.3 support was dropped at December 31st, 2016.&lt;/li&gt; &#xA; &lt;li&gt;Version 1.5.3 yanked. See: &lt;a href=&#34;https://github.com/jwt/ruby-jwt/issues/132&#34;&gt;#132&lt;/a&gt; and &lt;a href=&#34;https://github.com/jwt/ruby-jwt/issues/133&#34;&gt;#133&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/jwt/ruby-jwt/master/CHANGELOG.md&#34;&gt;CHANGELOG.md&lt;/a&gt; for a complete set of changes.&lt;/p&gt; &#xA;&lt;h2&gt;Sponsors&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Logo&lt;/th&gt; &#xA;   &lt;th&gt;Message&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/83319/31722733-de95bbde-b3ea-11e7-96bf-4f4e8f915588.png&#34; alt=&#34;auth0 logo&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;If you want to quickly add secure token-based authentication to Ruby projects, feel free to check Auth0&#39;s Ruby SDK and free plan at &lt;a href=&#34;https://auth0.com/developers?utm_source=GHsponsor&amp;amp;utm_medium=GHsponsor&amp;amp;utm_campaign=rubyjwt&amp;amp;utm_content=auth&#34;&gt;auth0.com/developers&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;h3&gt;Using Rubygems:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gem install jwt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using Bundler:&lt;/h3&gt; &#xA;&lt;p&gt;Add the following to your Gemfile&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gem &#39;jwt&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And run &lt;code&gt;bundle install&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Algorithms and Usage&lt;/h2&gt; &#xA;&lt;p&gt;The JWT spec supports NONE, HMAC, RSASSA, ECDSA and RSASSA-PSS algorithms for cryptographic signing. Currently the jwt gem supports NONE, HMAC, RSASSA and ECDSA. If you are using cryptographic signing, you need to specify the algorithm in the options hash whenever you call JWT.decode to ensure that an attacker &lt;a href=&#34;https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/&#34;&gt;cannot bypass the algorithm verification step&lt;/a&gt;. &lt;strong&gt;It is strongly recommended that you hard code the algorithm, as you may leave yourself vulnerable by dynamically picking the algorithm&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;See: &lt;a href=&#34;https://tools.ietf.org/html/rfc7518#section-3.1&#34;&gt; JSON Web Algorithms (JWA) 3.1. &#34;alg&#34; (Algorithm) Header Parameter Values for JWS&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;strong&gt;NONE&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;none - unsigned token&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;jwt&#39;&#xA;&#xA;payload = { data: &#39;test&#39; }&#xA;&#xA;# IMPORTANT: set nil as password parameter&#xA;token = JWT.encode payload, nil, &#39;none&#39;&#xA;&#xA;# eyJhbGciOiJub25lIn0.eyJkYXRhIjoidGVzdCJ9.&#xA;puts token&#xA;&#xA;# Set password to nil and validation to false otherwise this won&#39;t work&#xA;decoded_token = JWT.decode token, nil, false&#xA;&#xA;# Array&#xA;# [&#xA;#   {&#34;data&#34;=&amp;gt;&#34;test&#34;}, # payload&#xA;#   {&#34;alg&#34;=&amp;gt;&#34;none&#34;} # header&#xA;# ]&#xA;puts decoded_token&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;strong&gt;HMAC&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;HS256 - HMAC using SHA-256 hash algorithm&lt;/li&gt; &#xA; &lt;li&gt;HS512256 - HMAC using SHA-512-256 hash algorithm (only available with RbNaCl; see note below)&lt;/li&gt; &#xA; &lt;li&gt;HS384 - HMAC using SHA-384 hash algorithm&lt;/li&gt; &#xA; &lt;li&gt;HS512 - HMAC using SHA-512 hash algorithm&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# The secret must be a string. A JWT::DecodeError will be raised if it isn&#39;t provided.&#xA;hmac_secret = &#39;my$ecretK3y&#39;&#xA;&#xA;token = JWT.encode payload, hmac_secret, &#39;HS256&#39;&#xA;&#xA;# eyJhbGciOiJIUzI1NiJ9.eyJkYXRhIjoidGVzdCJ9.pNIWIL34Jo13LViZAJACzK6Yf0qnvT_BuwOxiMCPE-Y&#xA;puts token&#xA;&#xA;decoded_token = JWT.decode token, hmac_secret, true, { algorithm: &#39;HS256&#39; }&#xA;&#xA;# Array&#xA;# [&#xA;#   {&#34;data&#34;=&amp;gt;&#34;test&#34;}, # payload&#xA;#   {&#34;alg&#34;=&amp;gt;&#34;HS256&#34;} # header&#xA;# ]&#xA;puts decoded_token&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: If &lt;a href=&#34;https://github.com/cryptosphere/rbnacl&#34;&gt;RbNaCl&lt;/a&gt; is loadable, ruby-jwt will use it for HMAC-SHA256, HMAC-SHA512-256, and HMAC-SHA512. RbNaCl enforces a maximum key size of 32 bytes for these algorithms.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/cryptosphere/rbnacl&#34;&gt;RbNaCl&lt;/a&gt; requires &lt;a href=&#34;https://github.com/jedisct1/libsodium&#34;&gt;libsodium&lt;/a&gt;, it can be installed on MacOS with &lt;code&gt;brew install libsodium&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;strong&gt;RSA&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RS256 - RSA using SHA-256 hash algorithm&lt;/li&gt; &#xA; &lt;li&gt;RS384 - RSA using SHA-384 hash algorithm&lt;/li&gt; &#xA; &lt;li&gt;RS512 - RSA using SHA-512 hash algorithm&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;rsa_private = OpenSSL::PKey::RSA.generate 2048&#xA;rsa_public = rsa_private.public_key&#xA;&#xA;token = JWT.encode payload, rsa_private, &#39;RS256&#39;&#xA;&#xA;# eyJhbGciOiJSUzI1NiJ9.eyJkYXRhIjoidGVzdCJ9.GplO4w1spRgvEJQ3-FOtZr-uC8L45Jt7SN0J4woBnEXG_OZBSNcZjAJWpjadVYEe2ev3oUBFDYM1N_-0BTVeFGGYvMewu8E6aMjSZvOpf1cZBew-Vt4poSq7goG2YRI_zNPt3af2lkPqXD796IKC5URrEvcgF5xFQ-6h07XRDpSRx1ECrNsUOt7UM3l1IB4doY11GzwQA5sHDTmUZ0-kBT76ZMf12Srg_N3hZwphxBtudYtN5VGZn420sVrQMdPE_7Ni3EiWT88j7WCr1xrF60l8sZT3yKCVleG7D2BEXacTntB7GktBv4Xo8OKnpwpqTpIlC05dMowMkz3rEAAYbQ&#xA;puts token&#xA;&#xA;decoded_token = JWT.decode token, rsa_public, true, { algorithm: &#39;RS256&#39; }&#xA;&#xA;# Array&#xA;# [&#xA;#   {&#34;data&#34;=&amp;gt;&#34;test&#34;}, # payload&#xA;#   {&#34;alg&#34;=&amp;gt;&#34;RS256&#34;} # header&#xA;# ]&#xA;puts decoded_token&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;strong&gt;ECDSA&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ES256 - ECDSA using P-256 and SHA-256&lt;/li&gt; &#xA; &lt;li&gt;ES384 - ECDSA using P-384 and SHA-384&lt;/li&gt; &#xA; &lt;li&gt;ES512 - ECDSA using P-521 and SHA-512&lt;/li&gt; &#xA; &lt;li&gt;ES256K - ECDSA using P-256K and SHA-256&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ecdsa_key = OpenSSL::PKey::EC.new &#39;prime256v1&#39;&#xA;ecdsa_key.generate_key&#xA;ecdsa_public = OpenSSL::PKey::EC.new ecdsa_key&#xA;ecdsa_public.private_key = nil&#xA;&#xA;token = JWT.encode payload, ecdsa_key, &#39;ES256&#39;&#xA;&#xA;# eyJhbGciOiJFUzI1NiJ9.eyJkYXRhIjoidGVzdCJ9.AlLW--kaF7EX1NMX9WJRuIW8NeRJbn2BLXHns7Q5TZr7Hy3lF6MOpMlp7GoxBFRLISQ6KrD0CJOrR8aogEsPeg&#xA;puts token&#xA;&#xA;decoded_token = JWT.decode token, ecdsa_public, true, { algorithm: &#39;ES256&#39; }&#xA;&#xA;# Array&#xA;# [&#xA;#    {&#34;test&#34;=&amp;gt;&#34;data&#34;}, # payload&#xA;#    {&#34;alg&#34;=&amp;gt;&#34;ES256&#34;} # header&#xA;# ]&#xA;puts decoded_token&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;strong&gt;EDDSA&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;In order to use this algorithm you need to add the &lt;code&gt;RbNaCl&lt;/code&gt; gem to you &lt;code&gt;Gemfile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;rbnacl&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more detailed installation instruction check the official &lt;a href=&#34;https://github.com/cryptosphere/rbnacl&#34;&gt;repository&lt;/a&gt; on GitHub.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ED25519&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;private_key = RbNaCl::Signatures::Ed25519::SigningKey.new(&#39;abcdefghijklmnopqrstuvwxyzABCDEF&#39;)&#xA;public_key = private_key.verify_key&#xA;token = JWT.encode payload, private_key, &#39;ED25519&#39;&#xA;&#xA;# eyJhbGciOiJFRDI1NTE5In0.eyJkYXRhIjoidGVzdCJ9.6xIztXyOupskddGA_RvKU76V9b2dCQUYhoZEVFnRimJoPYIzZ2Fm47CWw8k2NTCNpgfAuxg9OXjaiVK7MvrbCQ&#xA;puts token&#xA;&#xA;decoded_token = JWT.decode token, public_key, true, { algorithm: &#39;ED25519&#39; }&#xA;# Array&#xA;# [&#xA;#  {&#34;test&#34;=&amp;gt;&#34;data&#34;}, # payload&#xA;#  {&#34;alg&#34;=&amp;gt;&#34;ED25519&#34;} # header&#xA;# ]&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;strong&gt;RSASSA-PSS&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;In order to use this algorithm you need to add the &lt;code&gt;openssl&lt;/code&gt; gem to you &lt;code&gt;Gemfile&lt;/code&gt; with a version greater or equal to &lt;code&gt;2.1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;openssl&#39;, &#39;~&amp;gt; 2.1&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;PS256 - RSASSA-PSS using SHA-256 hash algorithm&lt;/li&gt; &#xA; &lt;li&gt;PS384 - RSASSA-PSS using SHA-384 hash algorithm&lt;/li&gt; &#xA; &lt;li&gt;PS512 - RSASSA-PSS using SHA-512 hash algorithm&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;rsa_private = OpenSSL::PKey::RSA.generate 2048&#xA;rsa_public = rsa_private.public_key&#xA;&#xA;token = JWT.encode payload, rsa_private, &#39;PS256&#39;&#xA;&#xA;# eyJhbGciOiJQUzI1NiJ9.eyJkYXRhIjoidGVzdCJ9.KEmqagMUHM-NcmXo6818ZazVTIAkn9qU9KQFT1c5Iq91n0KRpAI84jj4ZCdkysDlWokFs3Dmn4MhcXP03oJKLFgnoPL40_Wgg9iFr0jnIVvnMUp1kp2RFUbL0jqExGTRA3LdAhuvw6ZByGD1bkcWjDXygjQw-hxILrT1bENjdr0JhFd-cB0-ps5SB0mwhFNcUw-OM3Uu30B1-mlFaelUY8jHJYKwLTZPNxHzndt8RGXF8iZLp7dGb06HSCKMcVzhASGMH4ZdFystRe2hh31cwcvnl-Eo_D4cdwmpN3Abhk_8rkxawQJR3duh8HNKc4AyFPo7SabEaSu2gLnLfN3yfg&#xA;puts token&#xA;&#xA;decoded_token = JWT.decode token, rsa_public, true, { algorithm: &#39;PS256&#39; }&#xA;&#xA;# Array&#xA;# [&#xA;#   {&#34;data&#34;=&amp;gt;&#34;test&#34;}, # payload&#xA;#   {&#34;alg&#34;=&amp;gt;&#34;PS256&#34;} # header&#xA;# ]&#xA;puts decoded_token&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Support for reserved claim names&lt;/h2&gt; &#xA;&lt;p&gt;JSON Web Token defines some reserved claim names and defines how they should be used. JWT supports these reserved claim names:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#39;exp&#39; (Expiration Time) Claim&lt;/li&gt; &#xA; &lt;li&gt;&#39;nbf&#39; (Not Before Time) Claim&lt;/li&gt; &#xA; &lt;li&gt;&#39;iss&#39; (Issuer) Claim&lt;/li&gt; &#xA; &lt;li&gt;&#39;aud&#39; (Audience) Claim&lt;/li&gt; &#xA; &lt;li&gt;&#39;jti&#39; (JWT ID) Claim&lt;/li&gt; &#xA; &lt;li&gt;&#39;iat&#39; (Issued At) Claim&lt;/li&gt; &#xA; &lt;li&gt;&#39;sub&#39; (Subject) Claim&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Add custom header fields&lt;/h2&gt; &#xA;&lt;p&gt;Ruby-jwt gem supports custom &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-5&#34;&gt;header fields&lt;/a&gt; To add custom header fields you need to pass &lt;code&gt;header_fields&lt;/code&gt; parameter&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;token = JWT.encode payload, key, algorithm=&#39;HS256&#39;, header_fields={}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;jwt&#39;&#xA;&#xA;payload = { data: &#39;test&#39; }&#xA;&#xA;# IMPORTANT: set nil as password parameter&#xA;token = JWT.encode payload, nil, &#39;none&#39;, { typ: &#39;JWT&#39; }&#xA;&#xA;# eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJkYXRhIjoidGVzdCJ9.&#xA;puts token&#xA;&#xA;# Set password to nil and validation to false otherwise this won&#39;t work&#xA;decoded_token = JWT.decode token, nil, false&#xA;&#xA;# Array&#xA;# [&#xA;#   {&#34;data&#34;=&amp;gt;&#34;test&#34;}, # payload&#xA;#   {&#34;typ&#34;=&amp;gt;&#34;JWT&#34;, &#34;alg&#34;=&amp;gt;&#34;none&#34;} # header&#xA;# ]&#xA;puts decoded_token&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Expiration Time Claim&lt;/h3&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.4&#34;&gt;Oauth JSON Web Token 4.1.4. &#34;exp&#34; (Expiration Time) Claim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;exp&lt;/code&gt; (expiration time) claim identifies the expiration time on or after which the JWT MUST NOT be accepted for processing. The processing of the &lt;code&gt;exp&lt;/code&gt; claim requires that the current date/time MUST be before the expiration date/time listed in the &lt;code&gt;exp&lt;/code&gt; claim. Implementers MAY provide for some small &lt;code&gt;leeway&lt;/code&gt;, usually no more than a few minutes, to account for clock skew. Its value MUST be a number containing a &lt;em&gt;&lt;strong&gt;NumericDate&lt;/strong&gt;&lt;/em&gt; value. Use of this claim is OPTIONAL.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;Handle Expiration Claim&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;exp = Time.now.to_i + 4 * 3600&#xA;exp_payload = { data: &#39;data&#39;, exp: exp }&#xA;&#xA;token = JWT.encode exp_payload, hmac_secret, &#39;HS256&#39;&#xA;&#xA;begin&#xA;  decoded_token = JWT.decode token, hmac_secret, true, { algorithm: &#39;HS256&#39; }&#xA;rescue JWT::ExpiredSignature&#xA;  # Handle expired token, e.g. logout user or deny access&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Expiration Claim verification can be disabled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Decode token without raising JWT::ExpiredSignature error&#xA;JWT.decode token, hmac_secret, true, { verify_expiration: false, algorithm: &#39;HS256&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Adding Leeway&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;exp = Time.now.to_i - 10&#xA;leeway = 30 # seconds&#xA;&#xA;exp_payload = { data: &#39;data&#39;, exp: exp }&#xA;&#xA;# build expired token&#xA;token = JWT.encode exp_payload, hmac_secret, &#39;HS256&#39;&#xA;&#xA;begin&#xA;  # add leeway to ensure the token is still accepted&#xA;  decoded_token = JWT.decode token, hmac_secret, true, { exp_leeway: leeway, algorithm: &#39;HS256&#39; }&#xA;rescue JWT::ExpiredSignature&#xA;  # Handle expired token, e.g. logout user or deny access&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Not Before Time Claim&lt;/h3&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.5&#34;&gt;Oauth JSON Web Token 4.1.5. &#34;nbf&#34; (Not Before) Claim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;nbf&lt;/code&gt; (not before) claim identifies the time before which the JWT MUST NOT be accepted for processing. The processing of the &lt;code&gt;nbf&lt;/code&gt; claim requires that the current date/time MUST be after or equal to the not-before date/time listed in the &lt;code&gt;nbf&lt;/code&gt; claim. Implementers MAY provide for some small &lt;code&gt;leeway&lt;/code&gt;, usually no more than a few minutes, to account for clock skew. Its value MUST be a number containing a &lt;em&gt;&lt;strong&gt;NumericDate&lt;/strong&gt;&lt;/em&gt; value. Use of this claim is OPTIONAL.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;Handle Not Before Claim&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;nbf = Time.now.to_i - 3600&#xA;nbf_payload = { data: &#39;data&#39;, nbf: nbf }&#xA;&#xA;token = JWT.encode nbf_payload, hmac_secret, &#39;HS256&#39;&#xA;&#xA;begin&#xA;  decoded_token = JWT.decode token, hmac_secret, true, { algorithm: &#39;HS256&#39; }&#xA;rescue JWT::ImmatureSignature&#xA;  # Handle invalid token, e.g. logout user or deny access&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Not Before Claim verification can be disabled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Decode token without raising JWT::ImmatureSignature error&#xA;JWT.decode token, hmac_secret, true, { verify_not_before: false, algorithm: &#39;HS256&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Adding Leeway&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;nbf = Time.now.to_i + 10&#xA;leeway = 30&#xA;&#xA;nbf_payload = { data: &#39;data&#39;, nbf: nbf }&#xA;&#xA;# build expired token&#xA;token = JWT.encode nbf_payload, hmac_secret, &#39;HS256&#39;&#xA;&#xA;begin&#xA;  # add leeway to ensure the token is valid&#xA;  decoded_token = JWT.decode token, hmac_secret, true, { nbf_leeway: leeway, algorithm: &#39;HS256&#39; }&#xA;rescue JWT::ImmatureSignature&#xA;  # Handle invalid token, e.g. logout user or deny access&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Issuer Claim&lt;/h3&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.1&#34;&gt;Oauth JSON Web Token 4.1.1. &#34;iss&#34; (Issuer) Claim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;iss&lt;/code&gt; (issuer) claim identifies the principal that issued the JWT. The processing of this claim is generally application specific. The &lt;code&gt;iss&lt;/code&gt; value is a case-sensitive string containing a &lt;em&gt;&lt;strong&gt;StringOrURI&lt;/strong&gt;&lt;/em&gt; value. Use of this claim is OPTIONAL.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;You can pass multiple allowed issuers as an Array, verification will pass if one of them matches the &lt;code&gt;iss&lt;/code&gt; value in the payload.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;iss = &#39;My Awesome Company Inc. or https://my.awesome.website/&#39;&#xA;iss_payload = { data: &#39;data&#39;, iss: iss }&#xA;&#xA;token = JWT.encode iss_payload, hmac_secret, &#39;HS256&#39;&#xA;&#xA;begin&#xA;  # Add iss to the validation to check if the token has been manipulated&#xA;  decoded_token = JWT.decode token, hmac_secret, true, { iss: iss, verify_iss: true, algorithm: &#39;HS256&#39; }&#xA;rescue JWT::InvalidIssuerError&#xA;  # Handle invalid token, e.g. logout user or deny access&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also pass a Regexp or Proc (with arity 1), verification will pass if the regexp matches or the proc returns truthy. On supported ruby versions (&amp;gt;= 2.5) you can also delegate to methods, on older versions you will have to convert them to proc (using &lt;code&gt;to_proc&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;JWT.decode token, hmac_secret, true,&#xA;           iss: %r&#39;https://my.awesome.website/&#39;,&#xA;           verify_iss: true,&#xA;           algorithm: &#39;HS256&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;JWT.decode token, hmac_secret, true,&#xA;           iss: -&amp;gt;(issuer) { issuer.start_with?(&#39;My Awesome Company Inc&#39;) },&#xA;           verify_iss: true,&#xA;           algorithm: &#39;HS256&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;JWT.decode token, hmac_secret, true,&#xA;           iss: method(:valid_issuer?),&#xA;           verify_iss: true,&#xA;           algorithm: &#39;HS256&#39;&#xA;&#xA;# somewhere in the same class:&#xA;def valid_issuer?(issuer)&#xA;  # custom validation&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Audience Claim&lt;/h3&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.3&#34;&gt;Oauth JSON Web Token 4.1.3. &#34;aud&#34; (Audience) Claim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;aud&lt;/code&gt; (audience) claim identifies the recipients that the JWT is intended for. Each principal intended to process the JWT MUST identify itself with a value in the audience claim. If the principal processing the claim does not identify itself with a value in the &lt;code&gt;aud&lt;/code&gt; claim when this claim is present, then the JWT MUST be rejected. In the general case, the &lt;code&gt;aud&lt;/code&gt; value is an array of case-sensitive strings, each containing a &lt;em&gt;&lt;strong&gt;StringOrURI&lt;/strong&gt;&lt;/em&gt; value. In the special case when the JWT has one audience, the &lt;code&gt;aud&lt;/code&gt; value MAY be a single case-sensitive string containing a &lt;em&gt;&lt;strong&gt;StringOrURI&lt;/strong&gt;&lt;/em&gt; value. The interpretation of audience values is generally application specific. Use of this claim is OPTIONAL.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;aud = [&#39;Young&#39;, &#39;Old&#39;]&#xA;aud_payload = { data: &#39;data&#39;, aud: aud }&#xA;&#xA;token = JWT.encode aud_payload, hmac_secret, &#39;HS256&#39;&#xA;&#xA;begin&#xA;  # Add aud to the validation to check if the token has been manipulated&#xA;  decoded_token = JWT.decode token, hmac_secret, true, { aud: aud, verify_aud: true, algorithm: &#39;HS256&#39; }&#xA;rescue JWT::InvalidAudError&#xA;  # Handle invalid token, e.g. logout user or deny access&#xA;  puts &#39;Audience Error&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;JWT ID Claim&lt;/h3&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.7&#34;&gt;Oauth JSON Web Token 4.1.7. &#34;jti&#34; (JWT ID) Claim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;jti&lt;/code&gt; (JWT ID) claim provides a unique identifier for the JWT. The identifier value MUST be assigned in a manner that ensures that there is a negligible probability that the same value will be accidentally assigned to a different data object; if the application uses multiple issuers, collisions MUST be prevented among values produced by different issuers as well. The &lt;code&gt;jti&lt;/code&gt; claim can be used to prevent the JWT from being replayed. The &lt;code&gt;jti&lt;/code&gt; value is a case-sensitive string. Use of this claim is OPTIONAL.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Use the secret and iat to create a unique key per request to prevent replay attacks&#xA;jti_raw = [hmac_secret, iat].join(&#39;:&#39;).to_s&#xA;jti = Digest::MD5.hexdigest(jti_raw)&#xA;jti_payload = { data: &#39;data&#39;, iat: iat, jti: jti }&#xA;&#xA;token = JWT.encode jti_payload, hmac_secret, &#39;HS256&#39;&#xA;&#xA;begin&#xA;  # If :verify_jti is true, validation will pass if a JTI is present&#xA;  #decoded_token = JWT.decode token, hmac_secret, true, { verify_jti: true, algorithm: &#39;HS256&#39; }&#xA;  # Alternatively, pass a proc with your own code to check if the JTI has already been used&#xA;  decoded_token = JWT.decode token, hmac_secret, true, { verify_jti: proc { |jti| my_validation_method(jti) }, algorithm: &#39;HS256&#39; }&#xA;  # or&#xA;  decoded_token = JWT.decode token, hmac_secret, true, { verify_jti: proc { |jti, payload| my_validation_method(jti, payload) }, algorithm: &#39;HS256&#39; }&#xA;rescue JWT::InvalidJtiError&#xA;  # Handle invalid token, e.g. logout user or deny access&#xA;  puts &#39;Error&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Issued At Claim&lt;/h3&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.6&#34;&gt;Oauth JSON Web Token 4.1.6. &#34;iat&#34; (Issued At) Claim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;iat&lt;/code&gt; (issued at) claim identifies the time at which the JWT was issued. This claim can be used to determine the age of the JWT. The &lt;code&gt;leeway&lt;/code&gt; option is not taken into account when verifying this claim. The &lt;code&gt;iat_leeway&lt;/code&gt; option was removed in version 2.2.0. Its value MUST be a number containing a &lt;em&gt;&lt;strong&gt;NumericDate&lt;/strong&gt;&lt;/em&gt; value. Use of this claim is OPTIONAL.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;Handle Issued At Claim&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;iat = Time.now.to_i&#xA;iat_payload = { data: &#39;data&#39;, iat: iat }&#xA;&#xA;token = JWT.encode iat_payload, hmac_secret, &#39;HS256&#39;&#xA;&#xA;begin&#xA;  # Add iat to the validation to check if the token has been manipulated&#xA;  decoded_token = JWT.decode token, hmac_secret, true, { verify_iat: true, algorithm: &#39;HS256&#39; }&#xA;rescue JWT::InvalidIatError&#xA;  # Handle invalid token, e.g. logout user or deny access&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Subject Claim&lt;/h3&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.2&#34;&gt;Oauth JSON Web Token 4.1.2. &#34;sub&#34; (Subject) Claim&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The &lt;code&gt;sub&lt;/code&gt; (subject) claim identifies the principal that is the subject of the JWT. The Claims in a JWT are normally statements about the subject. The subject value MUST either be scoped to be locally unique in the context of the issuer or be globally unique. The processing of this claim is generally application specific. The sub value is a case-sensitive string containing a &lt;em&gt;&lt;strong&gt;StringOrURI&lt;/strong&gt;&lt;/em&gt; value. Use of this claim is OPTIONAL.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sub = &#39;Subject&#39;&#xA;sub_payload = { data: &#39;data&#39;, sub: sub }&#xA;&#xA;token = JWT.encode sub_payload, hmac_secret, &#39;HS256&#39;&#xA;&#xA;begin&#xA;  # Add sub to the validation to check if the token has been manipulated&#xA;  decoded_token = JWT.decode token, hmac_secret, true, { sub: sub, verify_sub: true, algorithm: &#39;HS256&#39; }&#xA;rescue JWT::InvalidSubError&#xA;  # Handle invalid token, e.g. logout user or deny access&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Finding a Key&lt;/h3&gt; &#xA;&lt;p&gt;To dynamically find the key for verifying the JWT signature, pass a block to the decode block. The block receives headers and the original payload as parameters. It should return with the key to verify the signature that was used to sign the JWT.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;issuers = %w[My_Awesome_Company1 My_Awesome_Company2]&#xA;iss_payload = { data: &#39;data&#39;, iss: issuers.first }&#xA;&#xA;secrets = { issuers.first =&amp;gt; hmac_secret, issuers.last =&amp;gt; &#39;hmac_secret2&#39; }&#xA;&#xA;token = JWT.encode iss_payload, hmac_secret, &#39;HS256&#39;&#xA;&#xA;begin&#xA;  # Add iss to the validation to check if the token has been manipulated&#xA;  decoded_token = JWT.decode(token, nil, true, { iss: issuers, verify_iss: true, algorithm: &#39;HS256&#39; }) do |_headers, payload|&#xA;    secrets[payload[&#39;iss&#39;]]&#xA;  end&#xA;rescue JWT::InvalidIssuerError&#xA;  # Handle invalid token, e.g. logout user or deny access&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Required Claims&lt;/h3&gt; &#xA;&lt;p&gt;You can specify claims that must be present for decoding to be successful. JWT::MissingRequiredClaim will be raised if any are missing&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Will raise a JWT::MissingRequiredClaim error if the &#39;exp&#39; claim is absent&#xA;JWT.decode token, hmac_secret, true, { required_claims: [&#39;exp&#39;], algorithm: &#39;HS256&#39; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;X.509 certificates in x5c header&lt;/h3&gt; &#xA;&lt;p&gt;A JWT signature can be verified using certificate(s) given in the &lt;code&gt;x5c&lt;/code&gt; header. Before doing that, the trustworthiness of these certificate(s) must be established. This is done in accordance with RFC 5280 which (among other things) verifies the certificate(s) are issued by a trusted root certificate, the timestamps are valid, and none of the certificate(s) are revoked (i.e. being present in the root certificate&#39;s Certificate Revocation List).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;root_certificates = [] # trusted `OpenSSL::X509::Certificate` objects&#xA;crl_uris = root_certificates.map(&amp;amp;:crl_uris)&#xA;crls = crl_uris.map do |uri|&#xA;  # look up cached CRL by `uri` and return it if found, otherwise continue&#xA;  crl = Net::HTTP.get(uri)&#xA;  crl = OpenSSL::X509::CRL.new(crl)&#xA;  # cache `crl` using `uri` as the key, expiry set to `crl.next_update` timestamp&#xA;end&#xA;&#xA;begin&#xA;  JWT.decode(token, nil, true, { x5c: { root_certificates: root_certificates, crls: crls })&#xA;rescue JWT::DecodeError&#xA;  # Handle error, e.g. x5c header certificate revoked or expired&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;JSON Web Key (JWK)&lt;/h3&gt; &#xA;&lt;p&gt;JWK is a JSON structure representing a cryptographic key. Currently only supports RSA, EC and HMAC keys.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;jwk = JWT::JWK.new(OpenSSL::PKey::RSA.new(2048), &#34;optional-kid&#34;)&#xA;payload, headers = { data: &#39;data&#39; }, { kid: jwk.kid }&#xA;&#xA;token = JWT.encode(payload, jwk.keypair, &#39;RS512&#39;, headers)&#xA;&#xA;# The jwk loader would fetch the set of JWKs from a trusted source&#xA;jwk_loader = -&amp;gt;(options) do&#xA;  @cached_keys = nil if options[:invalidate] # need to reload the keys&#xA;  @cached_keys ||= { keys: [jwk.export] }&#xA;end&#xA;&#xA;begin&#xA;  JWT.decode(token, nil, true, { algorithms: [&#39;RS512&#39;], jwks: jwk_loader})&#xA;rescue JWT::JWKError&#xA;  # Handle problems with the provided JWKs&#xA;rescue JWT::DecodeError&#xA;  # Handle other decode related issues e.g. no kid in header, no matching public key found etc.&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or by passing JWK as a simple Hash&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;jwks = { keys: [{ ... }] } # keys accepts both of string and symbol&#xA;JWT.decode(token, nil, true, { algorithms: [&#39;RS512&#39;], jwks: jwks})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Importing and exporting JSON Web Keys&lt;/h3&gt; &#xA;&lt;p&gt;The ::JWT::JWK class can be used to import and export both the public key (default behaviour) and the private key. To include the private key in the export pass the &lt;code&gt;include_private&lt;/code&gt; parameter to the export method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;jwk = JWT::JWK.new(OpenSSL::PKey::RSA.new(2048))&#xA;&#xA;jwk_hash = jwk.export&#xA;jwk_hash_with_private_key = jwk.export(include_private: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How to contribute&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/jwt/ruby-jwt/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/jwt/ruby-jwt/master/AUTHORS&#34;&gt;AUTHORS&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/jwt/ruby-jwt/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>