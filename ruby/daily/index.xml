<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-15T01:33:14Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rubysherpas/paranoia</title>
    <updated>2022-07-15T01:33:14Z</updated>
    <id>tag:github.com,2022-07-15:/rubysherpas/paranoia</id>
    <link href="https://github.com/rubysherpas/paranoia" rel="alternate"></link>
    <summary type="html">&lt;p&gt;acts_as_paranoid for Rails 5, 6 and 7&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://badge.fury.io/rb/paranoia&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/paranoia.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/rubysherpas/paranoia/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/rubysherpas/paranoia/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;paranoia&lt;/code&gt; has some surprising behaviour (like overriding ActiveRecord&#39;s &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt;) and is not recommended for new projects. See &lt;a href=&#34;https://github.com/jhawthorn/discard#why-not-paranoia-or-acts_as_paranoid&#34;&gt;&lt;code&gt;discard&lt;/code&gt;&#39;s README&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;Paranoia will continue to accept bug fixes and support new versions of Rails but isn&#39;t accepting new features.&lt;/p&gt; &#xA;&lt;h1&gt;Paranoia&lt;/h1&gt; &#xA;&lt;p&gt;Paranoia is a re-implementation of &lt;a href=&#34;http://github.com/ActsAsParanoid/acts_as_paranoid&#34;&gt;acts_as_paranoid&lt;/a&gt; for Rails 3/4/5, using much, much, much less code.&lt;/p&gt; &#xA;&lt;p&gt;When your app is using Paranoia, calling &lt;code&gt;destroy&lt;/code&gt; on an ActiveRecord object doesn&#39;t actually destroy the database record, but just &lt;em&gt;hides&lt;/em&gt; it. Paranoia does this by setting a &lt;code&gt;deleted_at&lt;/code&gt; field to the current time when you &lt;code&gt;destroy&lt;/code&gt; a record, and hides it by scoping all queries on your model to only include records which do not have a &lt;code&gt;deleted_at&lt;/code&gt; field.&lt;/p&gt; &#xA;&lt;p&gt;If you wish to actually destroy an object you may call &lt;code&gt;really_destroy!&lt;/code&gt;. &lt;strong&gt;WARNING&lt;/strong&gt;: This will also &lt;em&gt;really destroy&lt;/em&gt; all &lt;code&gt;dependent: :destroy&lt;/code&gt; records, so please aim this method away from face when using.&lt;/p&gt; &#xA;&lt;p&gt;If a record has &lt;code&gt;has_many&lt;/code&gt; associations defined AND those associations have &lt;code&gt;dependent: :destroy&lt;/code&gt; set on them, then they will also be soft-deleted if &lt;code&gt;acts_as_paranoid&lt;/code&gt; is set, otherwise the normal destroy will be called. &lt;em&gt;&lt;strong&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/rubysherpas/paranoia/core/#destroying-through-association-callbacks&#34;&gt;Destroying through association callbacks&lt;/a&gt; for clarifying examples.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started Video&lt;/h2&gt; &#xA;&lt;p&gt;Setup and basic usage of the paranoia gem &lt;a href=&#34;https://gorails.com/episodes/soft-delete-with-paranoia&#34;&gt;GoRails #41&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation &amp;amp; Usage&lt;/h2&gt; &#xA;&lt;p&gt;For Rails 3, please use version 1 of Paranoia:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;paranoia&#34;, &#34;~&amp;gt; 1.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Rails 4 and 5, please use version 2 of Paranoia (2.2 or greater required for rails 5):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;paranoia&#34;, &#34;~&amp;gt; 2.2&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course you can install this from GitHub as well from one of these examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;paranoia&#34;, github: &#34;rubysherpas/paranoia&#34;, branch: &#34;rails3&#34;&#xA;gem &#34;paranoia&#34;, github: &#34;rubysherpas/paranoia&#34;, branch: &#34;rails4&#34;&#xA;gem &#34;paranoia&#34;, github: &#34;rubysherpas/paranoia&#34;, branch: &#34;rails5&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Updating is as simple as &lt;code&gt;bundle update paranoia&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Run your migrations for the desired models&lt;/h4&gt; &#xA;&lt;p&gt;Run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bin/rails generate migration AddDeletedAtToClients deleted_at:datetime:index&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and now you have a migration&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AddDeletedAtToClients &amp;lt; ActiveRecord::Migration&#xA;  def change&#xA;    add_column :clients, :deleted_at, :datetime&#xA;    add_index :clients, :deleted_at&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;h4&gt;In your model:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Client &amp;lt; ActiveRecord::Base&#xA;  acts_as_paranoid&#xA;&#xA;  # ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hey presto, it&#39;s there! Calling &lt;code&gt;destroy&lt;/code&gt; will now set the &lt;code&gt;deleted_at&lt;/code&gt; column:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt;&amp;gt; client.deleted_at&#xA;# =&amp;gt; nil&#xA;&amp;gt;&amp;gt; client.destroy&#xA;# =&amp;gt; client&#xA;&amp;gt;&amp;gt; client.deleted_at&#xA;# =&amp;gt; [current timestamp]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you really want it gone &lt;em&gt;gone&lt;/em&gt;, call &lt;code&gt;really_destroy!&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt;&amp;gt; client.deleted_at&#xA;# =&amp;gt; nil&#xA;&amp;gt;&amp;gt; client.really_destroy!&#xA;# =&amp;gt; client&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use a column other than &lt;code&gt;deleted_at&lt;/code&gt;, you can pass it as an option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Client &amp;lt; ActiveRecord::Base&#xA;  acts_as_paranoid column: :destroyed_at&#xA;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to skip adding the default scope:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Client &amp;lt; ActiveRecord::Base&#xA;  acts_as_paranoid without_default_scope: true&#xA;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to access soft-deleted associations, override the getter method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def product&#xA;  Product.unscoped { super }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to include associated soft-deleted objects, you can (un)scope the association:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Person &amp;lt; ActiveRecord::Base&#xA;  belongs_to :group, -&amp;gt; { with_deleted }&#xA;end&#xA;&#xA;Person.includes(:group).all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to find all records, even those which are deleted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Client.with_deleted&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to exclude deleted records, when not able to use the default_scope (e.g. when using without_default_scope):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Client.without_deleted&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to find only the deleted records:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Client.only_deleted&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to check if a record is soft-deleted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;client.paranoia_destroyed?&#xA;# or&#xA;client.deleted?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to restore a record:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Client.restore(id)&#xA;# or&#xA;client.restore&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to restore a whole bunch of records:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Client.restore([id1, id2, ..., idN])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to restore a record and their dependently destroyed associated records:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Client.restore(id, :recursive =&amp;gt; true)&#xA;# or&#xA;client.restore(:recursive =&amp;gt; true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to restore a record and only those dependently destroyed associated records that were deleted within 2 minutes of the object upon which they depend:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Client.restore(id, :recursive =&amp;gt; true, :recovery_window =&amp;gt; 2.minutes)&#xA;# or&#xA;client.restore(:recursive =&amp;gt; true, :recovery_window =&amp;gt; 2.minutes)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that by default paranoia will not prevent that a soft destroyed object can&#39;t be associated with another object of a different model. A Rails validator is provided should you require this functionality:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;validates :some_assocation, association_not_soft_destroyed: true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This validator makes sure that &lt;code&gt;some_assocation&lt;/code&gt; is not soft destroyed. If the object is soft destroyed the main object is rendered invalid and an validation error is added.&lt;/p&gt; &#xA;&lt;p&gt;For more information, please look at the tests.&lt;/p&gt; &#xA;&lt;h4&gt;About indexes:&lt;/h4&gt; &#xA;&lt;p&gt;Beware that you should adapt all your indexes for them to work as fast as previously. For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;add_index :clients, :group_id&#xA;add_index :clients, [:group_id, :other_id]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;should be replaced with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;add_index :clients, :group_id, where: &#34;deleted_at IS NULL&#34;&#xA;add_index :clients, [:group_id, :other_id], where: &#34;deleted_at IS NULL&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course, this is not necessary for the indexes you always use in association with &lt;code&gt;with_deleted&lt;/code&gt; or &lt;code&gt;only_deleted&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;Unique Indexes&lt;/h5&gt; &#xA;&lt;p&gt;Because NULL != NULL in standard SQL, we can not simply create a unique index on the deleted_at column and expect it to enforce that there only be one record with a certain combination of values.&lt;/p&gt; &#xA;&lt;p&gt;If your database supports them, good alternatives include partial indexes (above) and indexes on computed columns. E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;add_index :clients, [:group_id, &#39;COALESCE(deleted_at, false)&#39;], unique: true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If not, an alternative is to create a separate column which is maintained alongside deleted_at for the sake of enforcing uniqueness. To that end, paranoia makes use of two method to make its destroy and restore actions: paranoia_restore_attributes and paranoia_destroy_attributes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;add_column :clients, :active, :boolean&#xA;add_index :clients, [:group_id, :active], unique: true&#xA;&#xA;class Client &amp;lt; ActiveRecord::Base&#xA;  # optionally have paranoia make use of your unique column, so that&#xA;  # your lookups will benefit from the unique index&#xA;  acts_as_paranoid column: :active, sentinel_value: true&#xA;&#xA;  def paranoia_restore_attributes&#xA;    {&#xA;      deleted_at: nil,&#xA;      active: true&#xA;    }&#xA;  end&#xA;&#xA;  def paranoia_destroy_attributes&#xA;    {&#xA;      deleted_at: current_time_from_proper_timezone,&#xA;      active: nil&#xA;    }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Destroying through association callbacks&lt;/h5&gt; &#xA;&lt;p&gt;When dealing with &lt;code&gt;dependent: :destroy&lt;/code&gt; associations and &lt;code&gt;acts_as_paranoid&lt;/code&gt;, it&#39;s important to remember that whatever method is called on the parent model will be called on the child model. For example, given both models of an association have &lt;code&gt;acts_as_paranoid&lt;/code&gt; defined:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Client &amp;lt; ActiveRecord::Base&#xA;  acts_as_paranoid&#xA;&#xA;  has_many :emails, dependent: :destroy&#xA;end&#xA;&#xA;class Email &amp;lt; ActiveRecord::Base&#xA;  acts_as_paranoid&#xA;&#xA;  belongs_to :client&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When we call &lt;code&gt;destroy&lt;/code&gt; on the parent &lt;code&gt;client&lt;/code&gt;, it will call &lt;code&gt;destroy&lt;/code&gt; on all of its associated children &lt;code&gt;emails&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt;&amp;gt; client.emails.count&#xA;# =&amp;gt; 5&#xA;&amp;gt;&amp;gt; client.destroy&#xA;# =&amp;gt; client&#xA;&amp;gt;&amp;gt; client.deleted_at&#xA;# =&amp;gt; [current timestamp]&#xA;&amp;gt;&amp;gt; Email.where(client_id: client.id).count&#xA;# =&amp;gt; 0&#xA;&amp;gt;&amp;gt; Email.with_deleted.where(client_id: client.id).count&#xA;# =&amp;gt; 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, when we call &lt;code&gt;really_destroy!&lt;/code&gt; on the parent &lt;code&gt;client&lt;/code&gt;, then each child &lt;code&gt;email&lt;/code&gt; will also have &lt;code&gt;really_destroy!&lt;/code&gt; called:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt;&amp;gt; client.emails.count&#xA;# =&amp;gt; 5&#xA;&amp;gt;&amp;gt; client.id&#xA;# =&amp;gt; 12345&#xA;&amp;gt;&amp;gt; client.really_destroy!&#xA;# =&amp;gt; client&#xA;&amp;gt;&amp;gt; Client.find 12345&#xA;# =&amp;gt; ActiveRecord::RecordNotFound&#xA;&amp;gt;&amp;gt; Email.with_deleted.where(client_id: client.id).count&#xA;# =&amp;gt; 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, if the child model &lt;code&gt;Email&lt;/code&gt; does not have &lt;code&gt;acts_as_paranoid&lt;/code&gt; set, then calling &lt;code&gt;destroy&lt;/code&gt; on the parent &lt;code&gt;client&lt;/code&gt; will also call &lt;code&gt;destroy&lt;/code&gt; on each child &lt;code&gt;email&lt;/code&gt;, thereby actually destroying them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Client &amp;lt; ActiveRecord::Base&#xA;  acts_as_paranoid&#xA;&#xA;  has_many :emails, dependent: :destroy&#xA;end&#xA;&#xA;class Email &amp;lt; ActiveRecord::Base&#xA;  belongs_to :client&#xA;end&#xA;&#xA;&amp;gt;&amp;gt; client.emails.count&#xA;# =&amp;gt; 5&#xA;&amp;gt;&amp;gt; client.destroy&#xA;# =&amp;gt; client&#xA;&amp;gt;&amp;gt; Email.where(client_id: client.id).count&#xA;# =&amp;gt; 0&#xA;&amp;gt;&amp;gt; Email.with_deleted.where(client_id: client.id).count&#xA;# =&amp;gt; NoMethodError: undefined method `with_deleted&#39; for #&amp;lt;Class:0x0123456&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Acts As Paranoid Migration&lt;/h2&gt; &#xA;&lt;p&gt;You can replace the older &lt;code&gt;acts_as_paranoid&lt;/code&gt; methods as follows:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Old Syntax&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;New Syntax&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;find_with_deleted(:all)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;Client.with_deleted&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;find_with_deleted(:first)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;Client.with_deleted.first&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;find_with_deleted(id)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;Client.with_deleted.find(id)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The &lt;code&gt;recover&lt;/code&gt; method in &lt;code&gt;acts_as_paranoid&lt;/code&gt; runs &lt;code&gt;update&lt;/code&gt; callbacks. Paranoia&#39;s &lt;code&gt;restore&lt;/code&gt; method does not do this.&lt;/p&gt; &#xA;&lt;h2&gt;Callbacks&lt;/h2&gt; &#xA;&lt;p&gt;Paranoia provides several callbacks. It triggers &lt;code&gt;destroy&lt;/code&gt; callback when the record is marked as deleted and &lt;code&gt;real_destroy&lt;/code&gt; when the record is completely removed from database. It also calls &lt;code&gt;restore&lt;/code&gt; callback when the record is restored via paranoia&lt;/p&gt; &#xA;&lt;p&gt;For example if you want to index your records in some search engine you can go like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Product &amp;lt; ActiveRecord::Base&#xA;  acts_as_paranoid&#xA;&#xA;  after_destroy      :update_document_in_search_engine&#xA;  after_restore      :update_document_in_search_engine&#xA;  after_real_destroy :remove_document_from_search_engine&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use these events just like regular Rails callbacks with before, after and around hooks.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This gem is released under the MIT license.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>resque/resque</title>
    <updated>2022-07-15T01:33:14Z</updated>
    <id>tag:github.com,2022-07-15:/resque/resque</id>
    <link href="https://github.com/resque/resque" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Resque is a Redis-backed Ruby library for creating background jobs, placing them on multiple queues, and processing them later.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Resque&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://rubygems.org/gems/resque&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/resque.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/resque/resque/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/resque/resque/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Resque (pronounced like &#34;rescue&#34;) is a Redis-backed library for creating background jobs, placing those jobs on multiple queues, and processing them later.&lt;/p&gt; &#xA;&lt;p&gt;For the backstory, philosophy, and history of Resque&#39;s beginnings, please see &lt;a href=&#34;http://github.com/blog/542-introducing-resque&#34;&gt;the blog post&lt;/a&gt; (2009).&lt;/p&gt; &#xA;&lt;p&gt;Background jobs can be any Ruby class or module that responds to &lt;code&gt;perform&lt;/code&gt;. Your existing classes can easily be converted to background jobs or you can create new classes specifically to do work. Or, you can do both.&lt;/p&gt; &#xA;&lt;p&gt;Resque is heavily inspired by DelayedJob (which rocks) and comprises three parts:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;A Ruby library for creating, querying, and processing jobs&lt;/li&gt; &#xA; &lt;li&gt;A Rake task for starting a worker which processes jobs&lt;/li&gt; &#xA; &lt;li&gt;A Sinatra app for monitoring queues, jobs, and workers.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Resque workers can be given multiple queues (a &#34;queue list&#34;), distributed between multiple machines, run anywhere with network access to the Redis server, support priorities, are resilient to memory bloat / &#34;leaks,&#34; tell you what they&#39;re doing, and expect failure.&lt;/p&gt; &#xA;&lt;p&gt;Resque queues are persistent; support constant time, atomic push and pop (thanks to Redis); provide visibility into their contents; and store jobs as simple JSON packages.&lt;/p&gt; &#xA;&lt;p&gt;The Resque frontend tells you what workers are doing, what workers are not doing, what queues you&#39;re using, what&#39;s in those queues, provides general usage stats, and helps you track failures.&lt;/p&gt; &#xA;&lt;p&gt;Resque now supports Ruby 2.3.0 and above. We will also only be supporting Redis 3.0 and above going forward.&lt;/p&gt; &#xA;&lt;h3&gt;Note on the future of Resque&lt;/h3&gt; &#xA;&lt;p&gt;Would you like to be involved in Resque? Do you have thoughts about what Resque should be and do going forward? There&#39;s currently an &lt;a href=&#34;https://github.com/resque/resque/issues/1759&#34;&gt;open discussion here&lt;/a&gt; on just that topic, so please feel free to join in. We&#39;d love to hear your thoughts and/or have people volunteer to be a part of the project!&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;Resque jobs are Ruby classes (or modules) which respond to the &lt;code&gt;perform&lt;/code&gt; method. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Archive&#xA;  @queue = :file_serve&#xA;&#xA;  def self.perform(repo_id, branch = &#39;master&#39;)&#xA;    repo = Repository.find(repo_id)&#xA;    repo.create_archive(branch)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;@queue&lt;/code&gt; class instance variable determines which queue &lt;code&gt;Archive&lt;/code&gt; jobs will be placed in. Queues are arbitrary and created on the fly - you can name them whatever you want and have as many as you want.&lt;/p&gt; &#xA;&lt;p&gt;To place an &lt;code&gt;Archive&lt;/code&gt; job on the &lt;code&gt;file_serve&lt;/code&gt; queue, we might add this to our application&#39;s pre-existing &lt;code&gt;Repository&lt;/code&gt; class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Repository&#xA;  def async_create_archive(branch)&#xA;    Resque.enqueue(Archive, self.id, branch)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now when we call &lt;code&gt;repo.async_create_archive(&#39;masterbrew&#39;)&lt;/code&gt; in our application, a job will be created and placed on the &lt;code&gt;file_serve&lt;/code&gt; queue.&lt;/p&gt; &#xA;&lt;p&gt;Later, a worker will run something like this code to process the job:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;klass, args = Resque.reserve(:file_serve)&#xA;klass.perform(*args) if klass.respond_to? :perform&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which translates to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Archive.perform(44, &#39;masterbrew&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s start a worker to run &lt;code&gt;file_serve&lt;/code&gt; jobs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd app_root&#xA;$ QUEUE=file_serve rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This starts one Resque worker and tells it to work off the &lt;code&gt;file_serve&lt;/code&gt; queue. As soon as it&#39;s ready it&#39;ll try to run the &lt;code&gt;Resque.reserve&lt;/code&gt; code snippet above and process jobs until it can&#39;t find any more, at which point it will sleep for a small period and repeatedly poll the queue for more jobs.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add the gem to your Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gem &#39;resque&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, install it with Bundler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bundle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Rack&lt;/h4&gt; &#xA;&lt;p&gt;In your Rakefile, or some other file in &lt;code&gt;lib/tasks&lt;/code&gt; (ex: &lt;code&gt;lib/tasks/resque.rake&lt;/code&gt;), load the resque rake tasks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;resque&#39;&#xA;require &#39;resque/tasks&#39;&#xA;require &#39;your/app&#39; # Include this line if you want your workers to have access to your application&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Rails&lt;/h4&gt; &#xA;&lt;p&gt;To make resque specific changes, you can override the &lt;code&gt;resque:setup&lt;/code&gt; job in &lt;code&gt;lib/tasks&lt;/code&gt; (ex: &lt;code&gt;lib/tasks/resque.rake&lt;/code&gt;). GitHub&#39;s setup task looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;task &#34;resque:setup&#34; =&amp;gt; :environment do&#xA;  Grit::Git.git_timeout = 10.minutes&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We don&#39;t want the &lt;code&gt;git_timeout&lt;/code&gt; as high as 10 minutes in our web app, but in the Resque workers it&#39;s fine.&lt;/p&gt; &#xA;&lt;h2&gt;Running Workers&lt;/h2&gt; &#xA;&lt;p&gt;Resque workers are rake tasks that run forever. They basically do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;start&#xA;loop do&#xA;  if job = reserve&#xA;    job.process&#xA;  else&#xA;    sleep 5 # Polling frequency = 5&#xA;  end&#xA;end&#xA;shutdown&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Starting a worker is simple:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ QUEUE=* rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, you can start multiple workers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ COUNT=2 QUEUE=* rake resque:workers&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will spawn two Resque workers, each in its own process. Hitting ctrl-c should be sufficient to stop them all.&lt;/p&gt; &#xA;&lt;h4&gt;Priorities and Queue Lists&lt;/h4&gt; &#xA;&lt;p&gt;Resque doesn&#39;t support numeric priorities but instead uses the order of queues you give it. We call this list of queues the &#34;queue list.&#34;&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s say we add a &lt;code&gt;warm_cache&lt;/code&gt; queue in addition to our &lt;code&gt;file_serve&lt;/code&gt; queue. We&#39;d now start a worker like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ QUEUES=file_serve,warm_cache rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When the worker looks for new jobs, it will first check &lt;code&gt;file_serve&lt;/code&gt;. If it finds a job, it&#39;ll process it then check &lt;code&gt;file_serve&lt;/code&gt; again. It will keep checking &lt;code&gt;file_serve&lt;/code&gt; until no more jobs are available. At that point, it will check &lt;code&gt;warm_cache&lt;/code&gt;. If it finds a job it&#39;ll process it then check &lt;code&gt;file_serve&lt;/code&gt; (repeating the whole process).&lt;/p&gt; &#xA;&lt;p&gt;In this way you can prioritize certain queues. At GitHub we start our workers with something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ QUEUES=critical,archive,high,low rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice the &lt;code&gt;archive&lt;/code&gt; queue - it is specialized and in our future architecture will only be run from a single machine.&lt;/p&gt; &#xA;&lt;p&gt;At that point we&#39;ll start workers on our generalized background machines with this command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ QUEUES=critical,high,low rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And workers on our specialized archive machine with this command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ QUEUE=archive rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Running All Queues&lt;/h4&gt; &#xA;&lt;p&gt;If you want your workers to work off of every queue, including new queues created on the fly, you can use a splat:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ QUEUE=* rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Queues will be processed in alphabetical order.&lt;/p&gt; &#xA;&lt;p&gt;Or, prioritize some queues above &lt;code&gt;*&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# QUEUE=critical,* rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Running All Queues Except for Some&lt;/h4&gt; &#xA;&lt;p&gt;If you want your workers to work off of all queues except for some, you can use negation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ QUEUE=*,!low rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Negated globs also work. The following will instruct workers to work off of all queues except those beginning with &lt;code&gt;file_&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ QUEUE=*,!file_* rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the order in which negated queues are specified does not matter, so &lt;code&gt;QUEUE=*,!file_*&lt;/code&gt; and &lt;code&gt;QUEUE=!file_*,*&lt;/code&gt; will have the same effect.&lt;/p&gt; &#xA;&lt;h4&gt;Process IDs (PIDs)&lt;/h4&gt; &#xA;&lt;p&gt;There are scenarios where it&#39;s helpful to record the PID of a resque worker process. Use the PIDFILE option for easy access to the PID:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ PIDFILE=./resque.pid QUEUE=file_serve rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Running in the background&lt;/h4&gt; &#xA;&lt;p&gt;There are scenarios where it&#39;s helpful for the resque worker to run itself in the background (usually in combination with PIDFILE). Use the BACKGROUND option so that rake will return as soon as the worker is started.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ PIDFILE=./resque.pid BACKGROUND=yes QUEUE=file_serve rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Polling frequency&lt;/h4&gt; &#xA;&lt;p&gt;You can pass an INTERVAL option which is a float representing the polling frequency. The default is 5 seconds, but for a semi-active app you may want to use a smaller value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ INTERVAL=0.1 QUEUE=file_serve rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;The Front End&lt;/h2&gt; &#xA;&lt;p&gt;Resque comes with a Sinatra-based front end for seeing what&#39;s up with your queue.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/64d150a243987ffbc33f588bd6d7722a0bb8d69a/687474703a2f2f7475746f7269616c732e6a756d7073746172746c61622e636f6d2f696d616765732f7265737175655f6f766572766965772e706e67&#34; alt=&#34;The Front End&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Standalone&lt;/h4&gt; &#xA;&lt;p&gt;If you&#39;ve installed Resque as a gem running the front end standalone is easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ resque-web&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s a thin layer around &lt;code&gt;rackup&lt;/code&gt; so it&#39;s configurable as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ resque-web -p 8282&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have a Resque config file you want evaluated just pass it to the script as the final argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ resque-web -p 8282 rails_root/config/initializers/resque.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also set the namespace directly using &lt;code&gt;resque-web&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ resque-web -p 8282 -N myapp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or set the Redis connection string if you need to do something like select a different database:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ resque-web -p 8282 -r localhost:6379:2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Passenger&lt;/h4&gt; &#xA;&lt;p&gt;Using Passenger? Resque ships with a &lt;code&gt;config.ru&lt;/code&gt; you can use. See Phusion&#39;s guide:&lt;/p&gt; &#xA;&lt;p&gt;Apache: &lt;a href=&#34;https://www.phusionpassenger.com/library/deploy/apache/deploy/ruby/&#34;&gt;https://www.phusionpassenger.com/library/deploy/apache/deploy/ruby/&lt;/a&gt; Nginx: &lt;a href=&#34;https://www.phusionpassenger.com/library/deploy/nginx/deploy/ruby/&#34;&gt;https://www.phusionpassenger.com/library/deploy/nginx/deploy/ruby/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Rack::URLMap&lt;/h4&gt; &#xA;&lt;p&gt;If you want to load Resque on a subpath, possibly alongside other apps, it&#39;s easy to do with Rack&#39;s &lt;code&gt;URLMap&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;resque/server&#39;&#xA;&#xA;run Rack::URLMap.new \&#xA;  &#34;/&#34;       =&amp;gt; Your::App.new,&#xA;  &#34;/resque&#34; =&amp;gt; Resque::Server.new&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check &lt;code&gt;examples/demo/config.ru&lt;/code&gt; for a functional example (including HTTP basic auth).&lt;/p&gt; &#xA;&lt;h4&gt;Rails&lt;/h4&gt; &#xA;&lt;p&gt;You can also mount Resque on a subpath in your existing Rails app by adding &lt;code&gt;require &#39;resque/server&#39;&lt;/code&gt; to the top of your routes file or in an initializer then adding this to &lt;code&gt;routes.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mount Resque::Server.new, :at =&amp;gt; &#34;/resque&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Jobs&lt;/h2&gt; &#xA;&lt;p&gt;What should you run in the background? Anything that takes any time at all. Slow INSERT statements, disk manipulating, data processing, etc.&lt;/p&gt; &#xA;&lt;p&gt;At GitHub we use Resque to process the following types of jobs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Warming caches&lt;/li&gt; &#xA; &lt;li&gt;Counting disk usage&lt;/li&gt; &#xA; &lt;li&gt;Building tarballs&lt;/li&gt; &#xA; &lt;li&gt;Building Rubygems&lt;/li&gt; &#xA; &lt;li&gt;Firing off web hooks&lt;/li&gt; &#xA; &lt;li&gt;Creating events in the db and pre-caching them&lt;/li&gt; &#xA; &lt;li&gt;Building graphs&lt;/li&gt; &#xA; &lt;li&gt;Deleting users&lt;/li&gt; &#xA; &lt;li&gt;Updating our search index&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As of writing we have about 35 different types of background jobs.&lt;/p&gt; &#xA;&lt;p&gt;Keep in mind that you don&#39;t need a web app to use Resque - we just mention &#34;foreground&#34; and &#34;background&#34; because they make conceptual sense. You could easily be spidering sites and sticking data which needs to be crunched later into a queue.&lt;/p&gt; &#xA;&lt;h4&gt;Persistence&lt;/h4&gt; &#xA;&lt;p&gt;Jobs are persisted to queues as JSON objects. Let&#39;s take our &lt;code&gt;Archive&lt;/code&gt; example from above. We&#39;ll run the following code to create a job:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;repo = Repository.find(44)&#xA;repo.async_create_archive(&#39;masterbrew&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following JSON will be stored in the &lt;code&gt;file_serve&lt;/code&gt; queue:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;    &#39;class&#39;: &#39;Archive&#39;,&#xA;    &#39;args&#39;: [ 44, &#39;masterbrew&#39; ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because of this your jobs must only accept arguments that can be JSON encoded.&lt;/p&gt; &#xA;&lt;p&gt;So instead of doing this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Resque.enqueue(Archive, self, branch)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Resque.enqueue(Archive, self.id, branch)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is why our above example (and all the examples in &lt;code&gt;examples/&lt;/code&gt;) uses object IDs instead of passing around the objects.&lt;/p&gt; &#xA;&lt;p&gt;While this is less convenient than just sticking a marshaled object in the database, it gives you a slight advantage: your jobs will be run against the most recent version of an object because they need to pull from the DB or cache.&lt;/p&gt; &#xA;&lt;p&gt;If your jobs were run against marshaled objects, they could potentially be operating on a stale record with out-of-date information.&lt;/p&gt; &#xA;&lt;h4&gt;send_later / async&lt;/h4&gt; &#xA;&lt;p&gt;Want something like DelayedJob&#39;s &lt;code&gt;send_later&lt;/code&gt; or the ability to use instance methods instead of just methods for jobs? See the &lt;code&gt;examples/&lt;/code&gt; directory for goodies.&lt;/p&gt; &#xA;&lt;p&gt;We plan to provide first class &lt;code&gt;async&lt;/code&gt; support in a future release.&lt;/p&gt; &#xA;&lt;h4&gt;Failure&lt;/h4&gt; &#xA;&lt;p&gt;If a job raises an exception, it is logged and handed off to the &lt;code&gt;Resque::Failure&lt;/code&gt; module. Failures are logged either locally in Redis or using some different backend. To see exceptions while developing, see details below under Logging.&lt;/p&gt; &#xA;&lt;p&gt;For example, Resque ships with Airbrake support. To configure it, put the following into an initialisation file or into your rake job:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# send errors which occur in background jobs to redis and airbrake&#xA;require &#39;resque/failure/multiple&#39;&#xA;require &#39;resque/failure/redis&#39;&#xA;require &#39;resque/failure/airbrake&#39;&#xA;&#xA;Resque::Failure::Multiple.classes = [Resque::Failure::Redis, Resque::Failure::Airbrake]&#xA;Resque::Failure.backend = Resque::Failure::Multiple&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Keep this in mind when writing your jobs: you may want to throw exceptions you would not normally throw in order to assist debugging.&lt;/p&gt; &#xA;&lt;h4&gt;Rails example&lt;/h4&gt; &#xA;&lt;p&gt;If you are using ActiveJob here&#39;s how your job definition will look:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArchiveJob &amp;lt; ApplicationJob&#xA;  queue_as :file_serve&#xA;&#xA;  def perform(repo_id, branch = &#39;master&#39;)&#xA;    repo = Repository.find(repo_id)&#xA;    repo.create_archive(branch)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Repository&#xA;  def async_create_archive(branch)&#xA;    ArchiveJob.perform_later(self.id, branch)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is important to run &lt;code&gt;ArchiveJob.perform_later(self.id, branch)&lt;/code&gt; rather than &lt;code&gt;Resque.enqueue(Archive, self.id, branch)&lt;/code&gt;. Otherwise Resque will process the job without actually doing anything. Even if you put an obviously buggy line like &lt;code&gt;0/0&lt;/code&gt; in the &lt;code&gt;perform&lt;/code&gt; method, the job will still succeed.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h4&gt;Redis&lt;/h4&gt; &#xA;&lt;p&gt;You may want to change the Redis host and port Resque connects to, or set various other options at startup.&lt;/p&gt; &#xA;&lt;p&gt;Resque has a &lt;code&gt;redis&lt;/code&gt; setter which can be given a string or a Redis object. This means if you&#39;re already using Redis in your app, Resque can re-use the existing connection.&lt;/p&gt; &#xA;&lt;p&gt;String: &lt;code&gt;Resque.redis = &#39;localhost:6379&#39;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Redis: &lt;code&gt;Resque.redis = $redis&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;For our rails app we have a &lt;code&gt;config/initializers/resque.rb&lt;/code&gt; file where we load &lt;code&gt;config/resque.yml&lt;/code&gt; by hand and set the Redis information appropriately.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s our &lt;code&gt;config/resque.yml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;development: localhost:6379&#xA;test: localhost:6379&#xA;staging: redis1.se.github.com:6379&#xA;fi: localhost:6379&#xA;production: &amp;lt;%= ENV[&#39;REDIS_URL&#39;] %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And our initializer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;rails_root = ENV[&#39;RAILS_ROOT&#39;] || File.dirname(__FILE__) + &#39;/../..&#39;&#xA;rails_env = ENV[&#39;RAILS_ENV&#39;] || &#39;development&#39;&#xA;config_file = rails_root + &#39;/config/resque.yml&#39;&#xA;&#xA;resque_config = YAML::load(ERB.new(IO.read(config_file)).result)&#xA;Resque.redis = resque_config[rails_env]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Easy peasy! Why not just use &lt;code&gt;RAILS_ROOT&lt;/code&gt; and &lt;code&gt;RAILS_ENV&lt;/code&gt;? Because this way we can tell our Sinatra app about the config file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ RAILS_ENV=production resque-web rails_root/config/initializers/resque.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now everyone is on the same page.&lt;/p&gt; &#xA;&lt;p&gt;Also, you could disable jobs queueing by setting &#39;inline&#39; attribute. For example, if you want to run all jobs in the same process for cucumber, try:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Resque.inline = ENV[&#39;RAILS_ENV&#39;] == &#34;cucumber&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Logging&lt;/h4&gt; &#xA;&lt;p&gt;Workers support basic logging to STDOUT.&lt;/p&gt; &#xA;&lt;p&gt;You can control the logging threshold using &lt;code&gt;Resque.logger.level&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/resque.rb&#xA;Resque.logger.level = Logger::DEBUG&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want Resque to log to a file, in Rails do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/resque.rb&#xA;Resque.logger = Logger.new(Rails.root.join(&#39;log&#39;, &#34;#{Rails.env}_resque.log&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Namespaces&lt;/h4&gt; &#xA;&lt;p&gt;If you&#39;re running multiple, separate instances of Resque you may want to namespace the keyspaces so they do not overlap. This is not unlike the approach taken by many memcached clients.&lt;/p&gt; &#xA;&lt;p&gt;This feature is provided by the &lt;a href=&#34;http://github.com/resque/redis-namespace&#34;&gt;redis-namespace&lt;/a&gt; library, which Resque uses by default to separate the keys it manages from other keys in your Redis server.&lt;/p&gt; &#xA;&lt;p&gt;Simply use the &lt;code&gt;Resque.redis.namespace&lt;/code&gt; accessor:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Resque.redis.namespace = &#34;resque:GitHub&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We recommend sticking this in your initializer somewhere after Redis is configured.&lt;/p&gt; &#xA;&lt;h4&gt;Storing Statistics&lt;/h4&gt; &#xA;&lt;p&gt;Resque allows to store count of processed and failed jobs.&lt;/p&gt; &#xA;&lt;p&gt;By default it will store it in Redis using the keys &lt;code&gt;stats:processed&lt;/code&gt; and &lt;code&gt;stats:failed&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Some apps would want another stats store, or even a null store:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/resque.rb&#xA;class NullDataStore&#xA; def stat(stat)&#xA;   0&#xA; end&#xA;&#xA; def increment_stat(stat, by)&#xA; end&#xA;&#xA; def decrement_stat(stat, by)&#xA; end&#xA;&#xA; def clear_stat(stat)&#xA; end&#xA;end&#xA;&#xA;Resque.stat_data_store = NullDataStore.new&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Plugins and Hooks&lt;/h2&gt; &#xA;&lt;p&gt;For a list of available plugins see &lt;a href=&#34;https://github.com/resque/resque/wiki/plugins&#34;&gt;https://github.com/resque/resque/wiki/plugins&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;d like to write your own plugin, or want to customize Resque using hooks (such as &lt;code&gt;Resque.after_fork&lt;/code&gt;), see &lt;a href=&#34;http://github.com/resque/resque/blob/master/docs/HOOKS.md&#34;&gt;docs/HOOKS.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Additional Information&lt;/h2&gt; &#xA;&lt;h4&gt;Resque vs DelayedJob&lt;/h4&gt; &#xA;&lt;p&gt;How does Resque compare to DelayedJob, and why would you choose one over the other?&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Resque supports multiple queues&lt;/li&gt; &#xA; &lt;li&gt;DelayedJob supports finer grained priorities&lt;/li&gt; &#xA; &lt;li&gt;Resque workers are resilient to memory leaks / bloat&lt;/li&gt; &#xA; &lt;li&gt;DelayedJob workers are extremely simple and easy to modify&lt;/li&gt; &#xA; &lt;li&gt;Resque requires Redis&lt;/li&gt; &#xA; &lt;li&gt;DelayedJob requires ActiveRecord&lt;/li&gt; &#xA; &lt;li&gt;Resque can only place JSONable Ruby objects on a queue as arguments&lt;/li&gt; &#xA; &lt;li&gt;DelayedJob can place &lt;em&gt;any&lt;/em&gt; Ruby object on its queue as arguments&lt;/li&gt; &#xA; &lt;li&gt;Resque includes a Sinatra app for monitoring what&#39;s going on&lt;/li&gt; &#xA; &lt;li&gt;DelayedJob can be queried from within your Rails app if you want to add an interface&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you&#39;re doing Rails development, you already have a database and ActiveRecord. DelayedJob is super easy to setup and works great. GitHub used it for many months to process almost 200 million jobs.&lt;/p&gt; &#xA;&lt;p&gt;Choose Resque if:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You need multiple queues&lt;/li&gt; &#xA; &lt;li&gt;You don&#39;t care / dislike numeric priorities&lt;/li&gt; &#xA; &lt;li&gt;You don&#39;t need to persist every Ruby object ever&lt;/li&gt; &#xA; &lt;li&gt;You have potentially huge queues&lt;/li&gt; &#xA; &lt;li&gt;You want to see what&#39;s going on&lt;/li&gt; &#xA; &lt;li&gt;You expect a lot of failure / chaos&lt;/li&gt; &#xA; &lt;li&gt;You can setup Redis&lt;/li&gt; &#xA; &lt;li&gt;You&#39;re not running short on RAM&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Choose DelayedJob if:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You like numeric priorities&lt;/li&gt; &#xA; &lt;li&gt;You&#39;re not doing a gigantic amount of jobs each day&lt;/li&gt; &#xA; &lt;li&gt;Your queue stays small and nimble&lt;/li&gt; &#xA; &lt;li&gt;There is not a lot failure / chaos&lt;/li&gt; &#xA; &lt;li&gt;You want to easily throw anything on the queue&lt;/li&gt; &#xA; &lt;li&gt;You don&#39;t want to setup Redis&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In no way is Resque a &#34;better&#34; DelayedJob, so make sure you pick the tool that&#39;s best for your app.&lt;/p&gt; &#xA;&lt;h4&gt;Forking&lt;/h4&gt; &#xA;&lt;p&gt;On certain platforms, when a Resque worker reserves a job it immediately forks a child process. The child processes the job then exits. When the child has exited successfully, the worker reserves another job and repeats the process.&lt;/p&gt; &#xA;&lt;p&gt;Why?&lt;/p&gt; &#xA;&lt;p&gt;Because Resque assumes chaos.&lt;/p&gt; &#xA;&lt;p&gt;Resque assumes your background workers will lock up, run too long, or have unwanted memory growth.&lt;/p&gt; &#xA;&lt;p&gt;If Resque workers processed jobs themselves, it&#39;d be hard to whip them into shape. Let&#39;s say one is using too much memory: you send it a signal that says &#34;shutdown after you finish processing the current job,&#34; and it does so. It then starts up again - loading your entire application environment. This adds useless CPU cycles and causes a delay in queue processing.&lt;/p&gt; &#xA;&lt;p&gt;Plus, what if it&#39;s using too much memory and has stopped responding to signals?&lt;/p&gt; &#xA;&lt;p&gt;Thanks to Resque&#39;s parent / child architecture, jobs that use too much memory release that memory upon completion. No unwanted growth.&lt;/p&gt; &#xA;&lt;p&gt;And what if a job is running too long? You&#39;d need to &lt;code&gt;kill -9&lt;/code&gt; it then start the worker again. With Resque&#39;s parent / child architecture you can tell the parent to forcefully kill the child then immediately start processing more jobs. No startup delay or wasted cycles.&lt;/p&gt; &#xA;&lt;p&gt;The parent / child architecture helps us keep tabs on what workers are doing, too. By eliminating the need to &lt;code&gt;kill -9&lt;/code&gt; workers we can have parents remove themselves from the global listing of workers. If we just ruthlessly killed workers, we&#39;d need a separate watchdog process to add and remove them to the global listing - which becomes complicated.&lt;/p&gt; &#xA;&lt;p&gt;Workers instead handle their own state.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;at_exit&lt;/code&gt; Callbacks&lt;/h4&gt; &#xA;&lt;p&gt;Resque uses &lt;code&gt;Kernel#exit!&lt;/code&gt; for exiting its workers&#39; child processes. So any &lt;code&gt;at_exit&lt;/code&gt; callback defined in your application won&#39;t be executed when the job is finished and the child process exits.&lt;/p&gt; &#xA;&lt;p&gt;You can alter this behavior by setting the &lt;code&gt;RUN_AT_EXIT_HOOKS&lt;/code&gt; environment variable.&lt;/p&gt; &#xA;&lt;h4&gt;Parents and Children&lt;/h4&gt; &#xA;&lt;p&gt;Here&#39;s a parent / child pair doing some work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ps -e -o pid,command | grep [r]esque&#xA;92099 resque: Forked 92102 at 1253142769&#xA;92102 resque: Processing file_serve since 1253142769&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can clearly see that process 92099 forked 92102, which has been working since 1253142769.&lt;/p&gt; &#xA;&lt;p&gt;(By advertising the time they began processing you can easily use monit or god to kill stale workers.)&lt;/p&gt; &#xA;&lt;p&gt;When a parent process is idle, it lets you know what queues it is waiting for work on:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ps -e -o pid,command | grep [r]esque&#xA;92099 resque: Waiting for file_serve,warm_cache&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Signals&lt;/h4&gt; &#xA;&lt;p&gt;Resque workers respond to a few different signals:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;QUIT&lt;/code&gt; - Wait for child to finish processing then exit&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TERM&lt;/code&gt; / &lt;code&gt;INT&lt;/code&gt; - Immediately kill child then exit&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;USR1&lt;/code&gt; - Immediately kill child but don&#39;t exit&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;USR2&lt;/code&gt; - Don&#39;t start to process any new jobs&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CONT&lt;/code&gt; - Start to process new jobs again after a USR2&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to gracefully shutdown a Resque worker, use &lt;code&gt;QUIT&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to kill a stale or stuck child, use &lt;code&gt;USR1&lt;/code&gt;. Processing will continue as normal unless the child was not found. In that case Resque assumes the parent process is in a bad state and shuts down.&lt;/p&gt; &#xA;&lt;p&gt;If you want to kill a stale or stuck child and shutdown, use &lt;code&gt;TERM&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you want to stop processing jobs, but want to leave the worker running (for example, to temporarily alleviate load), use &lt;code&gt;USR2&lt;/code&gt; to stop processing, then &lt;code&gt;CONT&lt;/code&gt; to start it again. It&#39;s also possible to &lt;a href=&#34;https://raw.githubusercontent.com/resque/resque/master/#pausing-all-workers&#34;&gt;pause all workers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Heroku&lt;/h4&gt; &#xA;&lt;p&gt;When shutting down processes, Heroku sends every process a TERM signal at the same time. By default this causes an immediate shutdown of any running job leading to frequent &lt;code&gt;Resque::TermException&lt;/code&gt; errors. For short running jobs, a simple solution is to give a small amount of time for the job to finish before killing it.&lt;/p&gt; &#xA;&lt;p&gt;Resque doesn&#39;t handle this out of the box (for both cedar-14 and heroku-16), you need to install the &lt;a href=&#34;https://github.com/iloveitaly/resque-heroku-signals&#34;&gt;&lt;code&gt;resque-heroku-signals&lt;/code&gt;&lt;/a&gt; addon which adds the required signal handling to make the behavior described above work. Related issue: &lt;a href=&#34;https://github.com/resque/resque/issues/1559&#34;&gt;https://github.com/resque/resque/issues/1559&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To accomplish this set the following environment variables:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RESQUE_PRE_SHUTDOWN_TIMEOUT&lt;/code&gt; - The time between the parent receiving a shutdown signal (TERM by default) and it sending that signal on to the child process. Designed to give the child process time to complete before being forced to die.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;TERM_CHILD&lt;/code&gt; - Must be set for &lt;code&gt;RESQUE_PRE_SHUTDOWN_TIMEOUT&lt;/code&gt; to be used. After the timeout, if the child is still running it will raise a &lt;code&gt;Resque::TermException&lt;/code&gt; and exit.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RESQUE_TERM_TIMEOUT&lt;/code&gt; - By default you have a few seconds to handle &lt;code&gt;Resque::TermException&lt;/code&gt; in your job. &lt;code&gt;RESQUE_TERM_TIMEOUT&lt;/code&gt; and &lt;code&gt;RESQUE_PRE_SHUTDOWN_TIMEOUT&lt;/code&gt; must be lower than the &lt;a href=&#34;https://devcenter.heroku.com/articles/limits#exit-timeout&#34;&gt;heroku dyno timeout&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Pausing all workers&lt;/h4&gt; &#xA;&lt;p&gt;Workers will not process pending jobs if the Redis key &lt;code&gt;pause-all-workers&lt;/code&gt; is set with the string value &#34;true&#34;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Resque.redis.set(&#39;pause-all-workers&#39;, &#39;true&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Nothing happens to jobs that are already being processed by workers.&lt;/p&gt; &#xA;&lt;p&gt;Unpause by removing the Redis key &lt;code&gt;pause-all-workers&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Resque.redis.del(&#39;pause-all-workers&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Monitoring&lt;/h4&gt; &#xA;&lt;h5&gt;god&lt;/h5&gt; &#xA;&lt;p&gt;If you&#39;re using god to monitor Resque, we have provided example configs in &lt;code&gt;examples/god/&lt;/code&gt;. One is for starting / stopping workers, the other is for killing workers that have been running too long.&lt;/p&gt; &#xA;&lt;h5&gt;monit&lt;/h5&gt; &#xA;&lt;p&gt;If you&#39;re using monit, &lt;code&gt;examples/monit/resque.monit&lt;/code&gt; is provided free of charge. This is &lt;strong&gt;not&lt;/strong&gt; used by GitHub in production, so please send patches for any tweaks or improvements you can make to it.&lt;/p&gt; &#xA;&lt;h4&gt;Mysql::Error: MySQL server has gone away&lt;/h4&gt; &#xA;&lt;p&gt;If your workers remain idle for too long they may lose their MySQL connection. Depending on your version of Rails, we recommend the following:&lt;/p&gt; &#xA;&lt;h5&gt;Rails&lt;/h5&gt; &#xA;&lt;p&gt;In your &lt;code&gt;perform&lt;/code&gt; method, add the following line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyTask&#xA;  def self.perform&#xA;    ActiveRecord::Base.verify_active_connections!&#xA;    # rest of your code&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Rails doc says the following about &lt;code&gt;verify_active_connections!&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Verify active connections and remove and disconnect connections associated with stale threads.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Rails 4.x&lt;/h5&gt; &#xA;&lt;p&gt;In your &lt;code&gt;perform&lt;/code&gt; method, instead of &lt;code&gt;verify_active_connections!&lt;/code&gt;, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyTask&#xA;  def self.perform&#xA;    ActiveRecord::Base.clear_active_connections!&#xA;    # rest of your code&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From the Rails docs on &lt;a href=&#34;http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/ConnectionHandler.html#method-i-clear_active_connections-21&#34;&gt;&lt;code&gt;clear_active_connections!&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Returns any connections in use by the current thread back to the pool, and also returns connections to the pool cached by threads that are no longer alive.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;Want to hack on Resque?&lt;/p&gt; &#xA;&lt;p&gt;First clone the repo and run the tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone git://github.com/resque/resque.git&#xA;cd resque&#xA;rake test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the tests do not pass make sure you have Redis installed correctly (though we make an effort to tell you if we feel this is the case). The tests attempt to start an isolated instance of Redis to run against.&lt;/p&gt; &#xA;&lt;p&gt;Also make sure you&#39;ve installed all the dependencies correctly. For example, try loading the &lt;code&gt;redis-namespace&lt;/code&gt; gem after you&#39;ve installed it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ irb&#xA;&amp;gt;&amp;gt; require &#39;rubygems&#39;&#xA;=&amp;gt; true&#xA;&amp;gt;&amp;gt; require &#39;redis/namespace&#39;&#xA;=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you get an error requiring any of the dependencies, you may have failed to install them or be seeing load path issues.&lt;/p&gt; &#xA;&lt;h4&gt;Demo&lt;/h4&gt; &#xA;&lt;p&gt;Resque ships with a demo Sinatra app for creating jobs that are later processed in the background.&lt;/p&gt; &#xA;&lt;p&gt;Try it out by looking at the README, found at &lt;code&gt;examples/demo/README.markdown&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Contributing&lt;/h4&gt; &#xA;&lt;p&gt;Read &lt;a href=&#34;https://raw.githubusercontent.com/resque/resque/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; first.&lt;/p&gt; &#xA;&lt;p&gt;Once you&#39;ve made your great commits:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://help.github.com/forking/&#34;&gt;Fork&lt;/a&gt; Resque&lt;/li&gt; &#xA; &lt;li&gt;Create a topic branch - &lt;code&gt;git checkout -b my_branch&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Push to your branch - &lt;code&gt;git push origin my_branch&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Create a &lt;a href=&#34;http://help.github.com/pull-requests/&#34;&gt;Pull Request&lt;/a&gt; from your branch&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Questions&lt;/h2&gt; &#xA;&lt;p&gt;Please add them to the &lt;a href=&#34;https://github.com/resque/resque/wiki/FAQ&#34;&gt;FAQ&lt;/a&gt; or open an issue on this repo.&lt;/p&gt; &#xA;&lt;h2&gt;Meta&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Code: &lt;code&gt;git clone git://github.com/resque/resque.git&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Home: &lt;a href=&#34;http://github.com/resque/resque&#34;&gt;http://github.com/resque/resque&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Docs: &lt;a href=&#34;http://rubydoc.info/gems/resque&#34;&gt;http://rubydoc.info/gems/resque&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Bugs: &lt;a href=&#34;http://github.com/resque/resque/issues&#34;&gt;http://github.com/resque/resque/issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Gems: &lt;a href=&#34;https://rubygems.org/gems/resque&#34;&gt;https://rubygems.org/gems/resque&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This project uses &lt;a href=&#34;http://semver.org/&#34;&gt;Semantic Versioning&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;Chris Wanstrath :: &lt;a href=&#34;mailto:chris@ozmm.org&#34;&gt;chris@ozmm.org&lt;/a&gt; :: @defunkt&lt;/p&gt;</summary>
  </entry>
</feed>