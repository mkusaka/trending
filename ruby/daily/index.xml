<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-25T01:36:37Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>attr-encrypted/attr_encrypted</title>
    <updated>2022-09-25T01:36:37Z</updated>
    <id>tag:github.com,2022-09-25:/attr-encrypted/attr_encrypted</id>
    <link href="https://github.com/attr-encrypted/attr_encrypted" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Generates attr_accessors that encrypt and decrypt attributes&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Maintainer(s) wanted!!!&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;If you have an interest in maintaining this project... please see &lt;a href=&#34;https://github.com/attr-encrypted/attr_encrypted/issues/379&#34;&gt;https://github.com/attr-encrypted/attr_encrypted/issues/379&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h1&gt;attr_encrypted&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/attr-encrypted/attr_encrypted&#34;&gt;&lt;img src=&#34;https://secure.travis-ci.org/attr-encrypted/attr_encrypted.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/attr-encrypted/attr_encrypted/coverage&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/attr-encrypted/attr_encrypted/badges/coverage.svg?sanitize=true&#34; alt=&#34;Test Coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/attr-encrypted/attr_encrypted&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/attr-encrypted/attr_encrypted/badges/gpa.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://badge.fury.io/rb/attr_encrypted&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/attr_encrypted.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hakiri.io/github/attr-encrypted/attr_encrypted/master&#34;&gt;&lt;img src=&#34;https://hakiri.io/github/attr-encrypted/attr_encrypted/master.svg?sanitize=true&#34; alt=&#34;security&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Generates attr_accessors that transparently encrypt and decrypt attributes.&lt;/p&gt; &#xA;&lt;p&gt;It works with ANY class, however, you get a few extra features when you&#39;re using it with &lt;code&gt;ActiveRecord&lt;/code&gt;, &lt;code&gt;DataMapper&lt;/code&gt;, or &lt;code&gt;Sequel&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add attr_encrypted to your gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  gem &#34;attr_encrypted&#34;, &#34;~&amp;gt; 3.1.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then install the gem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re using an ORM like &lt;code&gt;ActiveRecord&lt;/code&gt;, &lt;code&gt;DataMapper&lt;/code&gt;, or &lt;code&gt;Sequel&lt;/code&gt;, using attr_encrypted is easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :ssn, key: &#39;This is a key that is 256 bits!!&#39;&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;re using a PORO, you have to do a little bit more work by extending the class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    extend AttrEncrypted&#xA;    attr_accessor :name&#xA;    attr_encrypted :ssn, key: &#39;This is a key that is 256 bits!!&#39;&#xA;&#xA;    def load&#xA;      # loads the stored data&#xA;    end&#xA;&#xA;    def save&#xA;      # saves the :name and :encrypted_ssn attributes somewhere (e.g. filesystem, database, etc)&#xA;    end&#xA;  end&#xA;&#xA;  user = User.new&#xA;  user.ssn = &#39;123-45-6789&#39;&#xA;  user.ssn # returns the unencrypted object ie. &#39;123-45-6789&#39;&#xA;  user.encrypted_ssn # returns the encrypted version of :ssn&#xA;  user.save&#xA;&#xA;  user = User.load&#xA;  user.ssn # decrypts :encrypted_ssn and returns &#39;123-45-6789&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Encrypt/decrypt attribute class methods&lt;/h3&gt; &#xA;&lt;p&gt;Two class methods are available for each attribute: &lt;code&gt;User.encrypt_email&lt;/code&gt; and &lt;code&gt;User.decrypt_email&lt;/code&gt;. They accept as arguments the same options that the &lt;code&gt;attr_encrypted&lt;/code&gt; class method accepts. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  key = SecureRandom.random_bytes(32)&#xA;  iv = SecureRandom.random_bytes(12)&#xA;  encrypted_email = User.encrypt_email(&#39;test@test.com&#39;, iv: iv, key: key)&#xA;  email = User.decrypt_email(encrypted_email, iv: iv, key: key)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;attr_encrypted&lt;/code&gt; class method is also aliased as &lt;code&gt;attr_encryptor&lt;/code&gt; to conform to Ruby&#39;s &lt;code&gt;attr_&lt;/code&gt; naming conventions. I should have called this project &lt;code&gt;attr_encryptor&lt;/code&gt; but it was too late when I realized it =&#39;(.&lt;/p&gt; &#xA;&lt;h3&gt;attr_encrypted with database persistence&lt;/h3&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;attr_encrypted&lt;/code&gt; uses the &lt;code&gt;:per_attribute_iv&lt;/code&gt; encryption mode. This mode requires a column to store your cipher text and a column to store your IV (initialization vector).&lt;/p&gt; &#xA;&lt;p&gt;Create or modify the table that your model uses to add a column with the &lt;code&gt;encrypted_&lt;/code&gt; prefix (which can be modified, see below), e.g. &lt;code&gt;encrypted_ssn&lt;/code&gt; via a migration like the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  create_table :users do |t|&#xA;    t.string :name&#xA;    t.string :encrypted_ssn&#xA;    t.string :encrypted_ssn_iv&#xA;    t.timestamps&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use a string or binary column type. (See the encode option section below for more info)&lt;/p&gt; &#xA;&lt;p&gt;If you use the same key for each record, add a unique index on the IV. Repeated IVs with AES-GCM (the default algorithm) allow an attacker to recover the key.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  add_index :users, :encrypted_ssn_iv, unique: true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying the encrypted attribute name&lt;/h3&gt; &#xA;&lt;p&gt;By default, the encrypted attribute name is &lt;code&gt;encrypted_#{attribute}&lt;/code&gt; (e.g. &lt;code&gt;attr_encrypted :email&lt;/code&gt; would create an attribute named &lt;code&gt;encrypted_email&lt;/code&gt;). So, if you&#39;re storing the encrypted attribute in the database, you need to make sure the &lt;code&gt;encrypted_#{attribute}&lt;/code&gt; field exists in your table. You have a couple of options if you want to name your attribute or db column something else, see below for more details.&lt;/p&gt; &#xA;&lt;h2&gt;attr_encrypted options&lt;/h2&gt; &#xA;&lt;h4&gt;Options are evaluated&lt;/h4&gt; &#xA;&lt;p&gt;All options will be evaluated at the instance level. If you pass in a symbol it will be passed as a message to the instance of your class. If you pass a proc or any object that responds to &lt;code&gt;:call&lt;/code&gt; it will be called. You can pass in the instance of your class as an argument to the proc. Anything else will be returned. For example:&lt;/p&gt; &#xA;&lt;h5&gt;Symbols representing instance methods&lt;/h5&gt; &#xA;&lt;p&gt;Here is an example class that uses an instance method to determines the encryption key to use.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :email, key: :encryption_key&#xA;&#xA;    def encryption_key&#xA;      # does some fancy logic and returns an encryption key&#xA;    end&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Procs&lt;/h5&gt; &#xA;&lt;p&gt;Here is an example of passing a proc/lambda object as the &lt;code&gt;:key&lt;/code&gt; option as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :email, key: proc { |user| user.key }&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Default options&lt;/h3&gt; &#xA;&lt;p&gt;The following are the default options used by &lt;code&gt;attr_encrypted&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  prefix:            &#39;encrypted_&#39;,&#xA;  suffix:            &#39;&#39;,&#xA;  if:                true,&#xA;  unless:            false,&#xA;  encode:            false,&#xA;  encode_iv:         true,&#xA;  encode_salt:       true,&#xA;  default_encoding:  &#39;m&#39;,&#xA;  marshal:           false,&#xA;  marshaler:         Marshal,&#xA;  dump_method:       &#39;dump&#39;,&#xA;  load_method:       &#39;load&#39;,&#xA;  encryptor:         Encryptor,&#xA;  encrypt_method:    &#39;encrypt&#39;,&#xA;  decrypt_method:    &#39;decrypt&#39;,&#xA;  mode:              :per_attribute_iv,&#xA;  algorithm:         &#39;aes-256-gcm&#39;,&#xA;  allow_empty_value: false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All of the aforementioned options are explained in depth below.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, you can specify default options for all encrypted attributes in your class. Instead of having to define your class like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :email, key: &#39;This is a key that is 256 bits!!&#39;, prefix: &#39;&#39;, suffix: &#39;_crypted&#39;&#xA;    attr_encrypted :ssn, key: &#39;a different secret key&#39;, prefix: &#39;&#39;, suffix: &#39;_crypted&#39;&#xA;    attr_encrypted :credit_card, key: &#39;another secret key&#39;, prefix: &#39;&#39;, suffix: &#39;_crypted&#39;&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can simply define some default options like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted_options.merge!(prefix: &#39;&#39;, :suffix =&amp;gt; &#39;_crypted&#39;)&#xA;    attr_encrypted :email, key: &#39;This is a key that is 256 bits!!&#39;&#xA;    attr_encrypted :ssn, key: &#39;a different secret key&#39;&#xA;    attr_encrypted :credit_card, key: &#39;another secret key&#39;&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This should help keep your classes clean and DRY.&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;:attribute&lt;/code&gt; option&lt;/h3&gt; &#xA;&lt;p&gt;You can simply pass the name of the encrypted attribute as the &lt;code&gt;:attribute&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :email, key: &#39;This is a key that is 256 bits!!&#39;, attribute: &#39;email_encrypted&#39;&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This would generate an attribute named &lt;code&gt;email_encrypted&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;:prefix&lt;/code&gt; and &lt;code&gt;:suffix&lt;/code&gt; options&lt;/h3&gt; &#xA;&lt;p&gt;If you don&#39;t like the &lt;code&gt;encrypted_#{attribute}&lt;/code&gt; naming convention then you can specify your own:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :email, key: &#39;This is a key that is 256 bits!!&#39;, prefix: &#39;secret_&#39;, suffix: &#39;_crypted&#39;&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This would generate the following attribute: &lt;code&gt;secret_email_crypted&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;:key&lt;/code&gt; option&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:key&lt;/code&gt; option is used to pass in a data encryption key to be used with whatever encryption class you use. If you&#39;re using &lt;code&gt;Encryptor&lt;/code&gt;, the key must meet minimum length requirements respective to the algorithm that you use; aes-256 requires a 256 bit key, etc. The &lt;code&gt;:key&lt;/code&gt; option is not required (see custom encryptor below).&lt;/p&gt; &#xA;&lt;h5&gt;Unique keys for each attribute&lt;/h5&gt; &#xA;&lt;p&gt;You can specify unique keys for each attribute if you&#39;d like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :email, key: &#39;This is a key that is 256 bits!!&#39;&#xA;    attr_encrypted :ssn, key: &#39;a different secret key&#39;&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is recommended to use a symbol or a proc for the key and to store information regarding what key was used to encrypt your data. (See below for more details.)&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;:if&lt;/code&gt; and &lt;code&gt;:unless&lt;/code&gt; options&lt;/h3&gt; &#xA;&lt;p&gt;There may be times that you want to only encrypt when certain conditions are met. For example maybe you&#39;re using rails and you don&#39;t want to encrypt attributes when you&#39;re in development mode. You can specify conditions like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User &amp;lt; ActiveRecord::Base&#xA;    attr_encrypted :email, key: &#39;This is a key that is 256 bits!!&#39;, unless: Rails.env.development?&#xA;    attr_encrypted :ssn, key: &#39;This is a key that is 256 bits!!&#39;, if: Rails.env.development?&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can specify both &lt;code&gt;:if&lt;/code&gt; and &lt;code&gt;:unless&lt;/code&gt; options.&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;:encryptor&lt;/code&gt;, &lt;code&gt;:encrypt_method&lt;/code&gt;, and &lt;code&gt;:decrypt_method&lt;/code&gt; options&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Encryptor&lt;/code&gt; class is used by default. You may use your own custom encryptor by specifying the &lt;code&gt;:encryptor&lt;/code&gt;, &lt;code&gt;:encrypt_method&lt;/code&gt;, and &lt;code&gt;:decrypt_method&lt;/code&gt; options.&lt;/p&gt; &#xA;&lt;p&gt;Lets suppose you&#39;d like to use this custom encryptor class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class SillyEncryptor&#xA;    def self.silly_encrypt(options)&#xA;      (options[:value] + options[:secret_key]).reverse&#xA;    end&#xA;&#xA;    def self.silly_decrypt(options)&#xA;      options[:value].reverse.gsub(/#{options[:secret_key]}$/, &#39;&#39;)&#xA;    end&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Simply set up your class like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :email, secret_key: &#39;This is a key that is 256 bits!!&#39;, encryptor: SillyEncryptor, encrypt_method: :silly_encrypt, decrypt_method: :silly_decrypt&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any options that you pass to &lt;code&gt;attr_encrypted&lt;/code&gt; will be passed to the encryptor class along with the &lt;code&gt;:value&lt;/code&gt; option which contains the string to encrypt/decrypt. Notice that the above example uses &lt;code&gt;:secret_key&lt;/code&gt; instead of &lt;code&gt;:key&lt;/code&gt;. See &lt;a href=&#34;https://github.com/attr-encrypted/encryptor&#34;&gt;encryptor&lt;/a&gt; for more info regarding the default encryptor class.&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;:mode&lt;/code&gt; option&lt;/h3&gt; &#xA;&lt;p&gt;The mode options allows you to specify in what mode your data will be encrypted. There are currently three modes: &lt;code&gt;:per_attribute_iv&lt;/code&gt;, &lt;code&gt;:per_attribute_iv_and_salt&lt;/code&gt;, and &lt;code&gt;:single_iv_and_salt&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE: &lt;code&gt;:per_attribute_iv_and_salt&lt;/code&gt; and &lt;code&gt;:single_iv_and_salt&lt;/code&gt; modes are deprecated and will be removed in the next major release.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;:algorithm&lt;/code&gt; option&lt;/h3&gt; &#xA;&lt;p&gt;The default &lt;code&gt;Encryptor&lt;/code&gt; class uses the standard ruby OpenSSL library. Its default algorithm is &lt;code&gt;aes-256-gcm&lt;/code&gt;. You can modify this by passing the &lt;code&gt;:algorithm&lt;/code&gt; option to the &lt;code&gt;attr_encrypted&lt;/code&gt; call like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :email, key: &#39;This is a key that is 256 bits!!&#39;, algorithm: &#39;aes-256-cbc&#39;&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To view a list of all cipher algorithms that are supported on your platform, run the following code in your favorite Ruby REPL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  require &#39;openssl&#39;&#xA;  puts OpenSSL::Cipher.ciphers&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/attr-encrypted/encryptor#algorithms&#34;&gt;Encryptor&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;:encode&lt;/code&gt;, &lt;code&gt;:encode_iv&lt;/code&gt;, &lt;code&gt;:encode_salt&lt;/code&gt;, and &lt;code&gt;:default_encoding&lt;/code&gt; options&lt;/h3&gt; &#xA;&lt;p&gt;You&#39;re probably going to be storing your encrypted attributes somehow (e.g. filesystem, database, etc). You can simply pass the &lt;code&gt;:encode&lt;/code&gt; option to automatically encode/decode when encrypting/decrypting. The default behavior assumes that you&#39;re using a string column type and will base64 encode your cipher text. If you choose to use the binary column type then encoding is not required, but be sure to pass in &lt;code&gt;false&lt;/code&gt; with the &lt;code&gt;:encode&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :email, key: &#39;some secret key&#39;, encode: true, encode_iv: true, encode_salt: true&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default encoding is &lt;code&gt;m&lt;/code&gt; (base64). You can change this by setting &lt;code&gt;encode: &#39;some encoding&#39;&lt;/code&gt;. See &lt;a href=&#34;http://ruby-doc.org/core-2.3.0/Array.html#method-i-pack&#34;&gt;&lt;code&gt;Array#pack&lt;/code&gt;&lt;/a&gt; for more encoding options.&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;:marshal&lt;/code&gt;, &lt;code&gt;:dump_method&lt;/code&gt;, and &lt;code&gt;:load_method&lt;/code&gt; options&lt;/h3&gt; &#xA;&lt;p&gt;You may want to encrypt objects other than strings (e.g. hashes, arrays, etc). If this is the case, simply pass the &lt;code&gt;:marshal&lt;/code&gt; option to automatically marshal when encrypting/decrypting.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :credentials, key: &#39;some secret key&#39;, marshal: true&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may also optionally specify &lt;code&gt;:marshaler&lt;/code&gt;, &lt;code&gt;:dump_method&lt;/code&gt;, and &lt;code&gt;:load_method&lt;/code&gt; if you want to use something other than the default &lt;code&gt;Marshal&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;:allow_empty_value&lt;/code&gt; option&lt;/h3&gt; &#xA;&lt;p&gt;You may want to encrypt empty strings or nil so as to not reveal which records are populated and which records are not.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :credentials, key: &#39;some secret key&#39;, marshal: true, allow_empty_value: true&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;ORMs&lt;/h2&gt; &#xA;&lt;h3&gt;ActiveRecord&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re using this gem with &lt;code&gt;ActiveRecord&lt;/code&gt;, you get a few extra features:&lt;/p&gt; &#xA;&lt;h4&gt;Default options&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;:encode&lt;/code&gt; option is set to true by default.&lt;/p&gt; &#xA;&lt;h4&gt;Dynamic &lt;code&gt;find_by_&lt;/code&gt; and &lt;code&gt;scoped_by_&lt;/code&gt; methods&lt;/h4&gt; &#xA;&lt;p&gt;Let&#39;s say you&#39;d like to encrypt your user&#39;s email addresses, but you also need a way for them to login. Simply set up your class like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User &amp;lt; ActiveRecord::Base&#xA;    attr_encrypted :email, key: &#39;This is a key that is 256 bits!!&#39;&#xA;    attr_encrypted :password, key: &#39;some other secret key&#39;&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now lookup and login users like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  User.find_by_email_and_password(&#39;test@example.com&#39;, &#39;testing&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The call to &lt;code&gt;find_by_email_and_password&lt;/code&gt; is intercepted and modified to &lt;code&gt;find_by_encrypted_email_and_encrypted_password(&#39;ENCRYPTED EMAIL&#39;, &#39;ENCRYPTED PASSWORD&#39;)&lt;/code&gt;. The dynamic scope methods like &lt;code&gt;scoped_by_email_and_password&lt;/code&gt; work the same way.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: This only works if all records are encrypted with the same encryption key (per attribute).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE: This feature is deprecated and will be removed in the next major release.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;DataMapper and Sequel&lt;/h3&gt; &#xA;&lt;h4&gt;Default options&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;:encode&lt;/code&gt; option is set to true by default.&lt;/p&gt; &#xA;&lt;h2&gt;Deprecations&lt;/h2&gt; &#xA;&lt;p&gt;attr_encrypted v2.0.0 now depends on encryptor v2.0.0. As part of both major releases many insecure defaults and behaviors have been deprecated. The new default behavior is as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Default &lt;code&gt;:mode&lt;/code&gt; is now &lt;code&gt;:per_attribute_iv&lt;/code&gt;, the default &lt;code&gt;:mode&lt;/code&gt; in attr_encrypted v1.x was &lt;code&gt;:single_iv_and_salt&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Default &lt;code&gt;:algorithm&lt;/code&gt; is now &#39;aes-256-gcm&#39;, the default &lt;code&gt;:algorithm&lt;/code&gt; in attr_encrypted v1.x was &#39;aes-256-cbc&#39;.&lt;/li&gt; &#xA; &lt;li&gt;The encryption key provided must be of appropriate length respective to the algorithm used. Previously, encryptor did not verify minimum key length.&lt;/li&gt; &#xA; &lt;li&gt;The dynamic finders available in ActiveRecord will only work with &lt;code&gt;:single_iv_and_salt&lt;/code&gt; mode. It is strongly advised that you do not use this mode. If you can search the encrypted data, it wasn&#39;t encrypted securely. This functionality will be deprecated in the next major release.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:per_attribute_iv_and_salt&lt;/code&gt; and &lt;code&gt;:single_iv_and_salt&lt;/code&gt; modes are deprecated and will be removed in the next major release.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Backwards compatibility is supported by providing a special option that is passed to encryptor, namely, &lt;code&gt;:insecure_mode&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :email, key: &#39;a secret key&#39;, algorithm: &#39;aes-256-cbc&#39;, mode: :single_iv_and_salt, insecure_mode: true&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;:insecure_mode&lt;/code&gt; option will allow encryptor to ignore the new security requirements. It is strongly advised that if you use this older insecure behavior that you migrate to the newer more secure behavior.&lt;/p&gt; &#xA;&lt;h2&gt;Upgrading from attr_encrypted v1.x to v3.x&lt;/h2&gt; &#xA;&lt;p&gt;Modify your gemfile to include the new version of attr_encrypted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  gem attr_encrypted, &#34;~&amp;gt; 3.0.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The update attr_encrypted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  bundle update attr_encrypted&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then modify your models using attr_encrypted to account for the changes in default options. Specifically, pass in the &lt;code&gt;:mode&lt;/code&gt; and &lt;code&gt;:algorithm&lt;/code&gt; options that you were using if you had not previously done so. If your key is insufficient length relative to the algorithm that you use, you should also pass in &lt;code&gt;insecure_mode: true&lt;/code&gt;; this will prevent Encryptor from raising an exception regarding insufficient key length. Please see the Deprecations sections for more details including an example of how to specify your model with default options from attr_encrypted v1.x.&lt;/p&gt; &#xA;&lt;h2&gt;Upgrading from attr_encrypted v2.x to v3.x&lt;/h2&gt; &#xA;&lt;p&gt;A bug was discovered in Encryptor v2.0.0 that inccorectly set the IV when using an AES-*-GCM algorithm. Unfornately fixing this major security issue results in the inability to decrypt records encrypted using an AES-*-GCM algorithm from Encryptor v2.0.0. Please see &lt;a href=&#34;https://github.com/attr-encrypted/encryptor#upgrading-from-v200-to-v300&#34;&gt;Upgrading to Encryptor v3.0.0&lt;/a&gt; for more info.&lt;/p&gt; &#xA;&lt;p&gt;It is strongly advised that you re-encrypt your data encrypted with Encryptor v2.0.0. However, you&#39;ll have to take special care to re-encrypt. To decrypt data encrypted with Encryptor v2.0.0 using an AES-*-GCM algorithm you can use the &lt;code&gt;:v2_gcm_iv&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;p&gt;It is recommended that you implement a strategy to insure that you do not mix the encryption implementations of Encryptor. One way to do this is to re-encrypt everything while your application is offline.Another way is to add a column that keeps track of what implementation was used. The path that you choose will depend on your situtation. Below is an example of how you might go about re-encrypting your data.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class User&#xA;    attr_encrypted :ssn, key: :encryption_key, v2_gcm_iv: is_decrypting?(:ssn)&#xA;&#xA;    def is_decrypting?(attribute)&#xA;      encrypted_attributes[attribute][:operation] == :decrypting&#xA;    end&#xA;  end&#xA;&#xA;  User.all.each do |user|&#xA;    old_ssn = user.ssn&#xA;    user.ssn= old_ssn&#xA;    user.save&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Things to consider before using attr_encrypted&lt;/h2&gt; &#xA;&lt;h4&gt;Searching, joining, etc&lt;/h4&gt; &#xA;&lt;p&gt;While choosing to encrypt at the attribute level is the most secure solution, it is not without drawbacks. Namely, you cannot search the encrypted data, and because you can&#39;t search it, you can&#39;t index it either. You also can&#39;t use joins on the encrypted data. Data that is securely encrypted is effectively noise. So any operations that rely on the data not being noise will not work. If you need to do any of the aforementioned operations, please consider using database and file system encryption along with transport encryption as it moves through your stack.&lt;/p&gt; &#xA;&lt;h4&gt;Data leaks&lt;/h4&gt; &#xA;&lt;p&gt;Please also consider where your data leaks. If you&#39;re using attr_encrypted with Rails, it&#39;s highly likely that this data will enter your app as a request parameter. You&#39;ll want to be sure that you&#39;re filtering your request params from you logs or else your data is sitting in the clear in your logs. &lt;a href=&#34;http://apidock.com/rails/ActionDispatch/Http/FilterParameters&#34;&gt;Parameter Filtering in Rails&lt;/a&gt; Please also consider other possible leak points.&lt;/p&gt; &#xA;&lt;h4&gt;Storage requirements&lt;/h4&gt; &#xA;&lt;p&gt;When storing your encrypted data, please consider the length requirements of the db column that you&#39;re storing the cipher text in. Older versions of Mysql attempt to &#39;help&#39; you by truncating strings that are too large for the column. When this happens, you will not be able to decrypt your data. &lt;a href=&#34;http://www.davidpashley.com/2009/02/15/silently-truncated/&#34;&gt;MySQL Strict Trans&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Metadata regarding your crypto implementation&lt;/h4&gt; &#xA;&lt;p&gt;It is advisable to also store metadata regarding the circumstances of your encrypted data. Namely, you should store information about the key used to encrypt your data, as well as the algorithm. Having this metadata with every record will make key rotation and migrating to a new algorithm signficantly easier. It will allow you to continue to decrypt old data using the information provided in the metadata and new data can be encrypted using your new key and algorithm of choice.&lt;/p&gt; &#xA;&lt;h4&gt;Enforcing the IV as a nonce&lt;/h4&gt; &#xA;&lt;p&gt;On a related note, most algorithms require that your IV be unique for every record and key combination. You can enforce this using composite unique indexes on your IV and encryption key name/id column. &lt;a href=&#34;https://tools.ietf.org/html/rfc5084#section-1.5&#34;&gt;RFC 5084&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Unique key per record&lt;/h4&gt; &#xA;&lt;p&gt;Lastly, while the &lt;code&gt;:per_attribute_iv_and_salt&lt;/code&gt; mode is more secure than &lt;code&gt;:per_attribute_iv&lt;/code&gt; mode because it uses a unique key per record, it uses a PBKDF function which introduces a huge performance hit (175x slower by my benchmarks). There are other ways of deriving a unique key per record that would be much faster.&lt;/p&gt; &#xA;&lt;h2&gt;Note on Patches/Pull Requests&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fork the project.&lt;/li&gt; &#xA; &lt;li&gt;Make your feature addition or bug fix.&lt;/li&gt; &#xA; &lt;li&gt;Add tests for it. This is important so I don&#39;t break it in a future version unintentionally.&lt;/li&gt; &#xA; &lt;li&gt;Commit, do not mess with rakefile, version, changelog, or history.&lt;/li&gt; &#xA; &lt;li&gt;Send me a pull request. Bonus points for topic branches.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>