<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-10T01:36:33Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>oracle/truffleruby</title>
    <updated>2022-12-10T01:36:33Z</updated>
    <id>tag:github.com,2022-12-10:/oracle/truffleruby</id>
    <link href="https://github.com/oracle/truffleruby" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A high performance implementation of the Ruby programming language, built on GraalVM.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/logo/png/truffleruby_logo_horizontal_medium_outlined.png&#34; alt=&#34;TruffleRuby logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;TruffleRuby is the &lt;a href=&#34;http://graalvm.org/&#34;&gt;GraalVM&lt;/a&gt; high-performance implementation of the &lt;a href=&#34;https://www.ruby-lang.org/en/&#34;&gt;Ruby programming language&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;TruffleRuby comes in two distributions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Standalone: This only contains TruffleRuby in the &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/#truffleruby-runtime-configurations&#34;&gt;Native configuration&lt;/a&gt;, making it a smaller download.&lt;/li&gt; &#xA; &lt;li&gt;GraalVM: This includes support for other languages such as JavaScript, Python and R, and supports both the &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/#truffleruby-runtime-configurations&#34;&gt;Native and JVM configurations&lt;/a&gt;. We recommend that you use a &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/ruby-managers.md#configuring-ruby-managers-for-the-full-graalvm-distribution&#34;&gt;Ruby manager&lt;/a&gt; to use TruffleRuby inside GraalVM.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can install either of those:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Via your &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/ruby-managers.md&#34;&gt;Ruby manager/installer&lt;/a&gt; (RVM, rbenv, chruby, asdf, ruby-build, ruby-install). We recommend trying TruffleRuby dev builds which contain the latest fixes and improvements (replace &lt;code&gt;VERSION&lt;/code&gt; by &lt;code&gt;dev&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Standalone:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;RVM:    $ rvm install truffleruby&#xA;rbenv:  $ rbenv install truffleruby-VERSION&#xA;asdf:   $ asdf install ruby truffleruby-VERSION&#xA;chruby: $ ruby-install truffleruby&#xA;        $ ruby-build truffleruby-VERSION ~/.rubies/truffleruby-VERSION&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;GraalVM:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rbenv:  $ rbenv install truffleruby+graalvm-VERSION&#xA;asdf:   $ asdf install ruby truffleruby+graalvm-VERSION&#xA;chruby: $ ruby-install truffleruby-graalvm&#xA;        $ ruby-build truffleruby+graalvm-VERSION ~/.rubies/truffleruby+graalvm-VERSION&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;In CI with GitHub Actions, see &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/standalone-distribution.md&#34;&gt;Testing TruffleRuby in CI&lt;/a&gt; for more details and other CIs.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- uses: ruby/setup-ruby@v1&#xA;  with:&#xA;    ruby-version: truffleruby # or truffleruby-head, or truffleruby+graalvm or truffleruby+graalvm-head&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Via Docker. For Standalone see &lt;a href=&#34;https://github.com/graalvm/container/raw/master/truffleruby/README.md&#34;&gt;official release images&lt;/a&gt; and &lt;a href=&#34;https://github.com/flavorjones/truffleruby/pkgs/container/truffleruby&#34;&gt;nightly images&lt;/a&gt;. For GraalVM see &lt;a href=&#34;https://github.com/graalvm/container/raw/master/community/README.md&#34;&gt;official release images&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Manually, by following the documentation: &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/standalone-distribution.md&#34;&gt;Standalone&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/installing-graalvm.md&#34;&gt;GraalVM&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;gem&lt;/code&gt; and &lt;code&gt;bundle&lt;/code&gt; to install gems, as usual.&lt;/p&gt; &#xA;&lt;p&gt;Please report any issues you might find on &lt;a href=&#34;https://github.com/oracle/truffleruby/issues&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Aim&lt;/h2&gt; &#xA;&lt;p&gt;TruffleRuby aims to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Run idiomatic Ruby code faster. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;TruffleRuby is the &lt;a href=&#34;https://eregon.me/blog/2022/01/06/benchmarking-cruby-mjit-yjit-jruby-truffleruby.html&#34;&gt;fastest Ruby implementation&lt;/a&gt; for many CPU-intensive benchmarks.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Run Ruby code in parallel. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;TruffleRuby does not have a global interpreter lock and runs Ruby code in parallel.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Support C extensions. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Many C extensions work out of the box, including database drivers.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Add fast and low-overhead interoperability with languages like Java, JavaScript, Python, and R. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Provided by GraalVM, see the &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/polyglot.md&#34;&gt;Polyglot documentation&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Provide new tooling, such as debuggers and monitoring, that works across languages. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Includes a profiler, debugger, VisualVM, and more. See the &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/tools.md&#34;&gt;Tools documentation&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Provide all of the above while maintaining very high compatibility with the standard implementation of Ruby.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;TruffleRuby Runtime Configurations&lt;/h2&gt; &#xA;&lt;p&gt;There are two main runtime configurations of TruffleRuby, Native and JVM, which have different trade-offs.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Configuration:&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Native (&lt;code&gt;--native&lt;/code&gt;, default)&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;JVM (&lt;code&gt;--jvm&lt;/code&gt;)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Time to start TruffleRuby&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;about as fast as MRI startup&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;slower&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Time to reach peak performance&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;faster&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;slower&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Peak performance (also considering GC)&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;good&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;best&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Java host interoperability&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;needs reflection configuration&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;just works&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;To find out which runtime configuration is being used, run &lt;code&gt;ruby --version&lt;/code&gt; on the command line, or check the value of &lt;code&gt;RUBY_DESCRIPTION&lt;/code&gt; or &lt;code&gt;TruffleRuby.native?&lt;/code&gt; in Ruby code. Runtime configurations are further detailed in &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/deploying.md&#34;&gt;Deploying TruffleRuby&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;System Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;TruffleRuby is actively tested on the following systems:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Oracle Linux 7, 8&lt;/li&gt; &#xA; &lt;li&gt;Ubuntu 16.04, 18.04, 20.04, 22.04 (all LTS)&lt;/li&gt; &#xA; &lt;li&gt;Fedora 35, 36&lt;/li&gt; &#xA; &lt;li&gt;macOS 10.14 (Mojave), 12 (Monterey)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Architectures:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;AMD64 (aka &lt;code&gt;x86_64&lt;/code&gt;): Supported&lt;/li&gt; &#xA; &lt;li&gt;AArch64 (aka &lt;code&gt;arm64&lt;/code&gt;): Supported on Linux (from 21.2) and on macOS (from 22.2)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You may find that TruffleRuby will not work if you severely restrict the environment, for example, by unmounting system filesystems such as &lt;code&gt;/dev/shm&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/installing-llvm.md&#34;&gt;make and gcc&lt;/a&gt; for building C and C++ extensions&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/installing-libssl.md&#34;&gt;libssl&lt;/a&gt; for the &lt;code&gt;openssl&lt;/code&gt; C extension&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/installing-zlib.md&#34;&gt;zlib&lt;/a&gt; for the &lt;code&gt;zlib&lt;/code&gt; C extension&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Without these dependencies, many libraries including RubyGems will not work. TruffleRuby will try to print a nice error message if a dependency is missing, but this can only be done on a best effort basis.&lt;/p&gt; &#xA;&lt;p&gt;You also need to set up a &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/utf8-locale.md&#34;&gt;UTF-8 locale&lt;/a&gt; if not already done.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/contributor/workflow.md&#34;&gt;contributor workflow&lt;/a&gt; document if you wish to build TruffleRuby from source.&lt;/p&gt; &#xA;&lt;h2&gt;Current Status&lt;/h2&gt; &#xA;&lt;p&gt;We recommend that people trying TruffleRuby on their gems and applications &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/#contact&#34;&gt;get in touch with us&lt;/a&gt; for any help they might need.&lt;/p&gt; &#xA;&lt;p&gt;TruffleRuby runs Rails and is compatible with many gems, including C extensions. TruffleRuby is not 100% compatible with MRI 3.1 yet. Please &lt;a href=&#34;https://github.com/oracle/truffleruby/issues&#34;&gt;report&lt;/a&gt; any compatibility issues you might find. TruffleRuby &lt;a href=&#34;https://eregon.me/rubyspec-stats/&#34;&gt;passes around 97% of ruby/spec&lt;/a&gt;, more than any other alternative Ruby implementation.&lt;/p&gt; &#xA;&lt;p&gt;Regarding performance, TruffleRuby is &lt;a href=&#34;https://eregon.me/blog/2022/01/06/benchmarking-cruby-mjit-yjit-jruby-truffleruby.html&#34;&gt;by far&lt;/a&gt; the fastest Ruby implementation on the &lt;a href=&#34;https://github.com/Shopify/yjit-bench&#34;&gt;yjit-bench&lt;/a&gt; benchmark suite which includes &lt;code&gt;railsbench&lt;/code&gt;, etc. To achieve this performance TruffleRuby needs a fair amount of warmup, as other advanced JIT compilers do. If you find any performance issue, please see &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/reporting-performance-problems.md&#34;&gt;this guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Releases&lt;/h2&gt; &#xA;&lt;p&gt;TruffleRuby has the same version, and is released at the same time as GraalVM. There is a release every 3 months. See the &lt;a href=&#34;https://www.graalvm.org/release-notes/version-roadmap/&#34;&gt;release roadmap&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Migration from MRI&lt;/h2&gt; &#xA;&lt;p&gt;TruffleRuby should in most cases work as a drop-in replacement for MRI, but you should read about our &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/compatibility.md&#34;&gt;compatibility&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Migration from JRuby&lt;/h2&gt; &#xA;&lt;p&gt;For many use cases TruffleRuby should work as a drop-in replacement for JRuby. However, our approach to integration with Java is different to JRuby so you should read our &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/jruby-migration.md&#34;&gt;migration guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Extensive user documentation is available in &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user&#34;&gt;&lt;code&gt;doc/user&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See our &lt;a href=&#34;https://github.com/oracle/truffleruby&#34;&gt;source code repository&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/CONTRIBUTING.md&#34;&gt;contributor documentation&lt;/a&gt; to contribute to TruffleRuby. In particular, see the &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/contributor/workflow.md&#34;&gt;contributor workflow&lt;/a&gt; document for how to build and run TruffleRuby.&lt;/p&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;The best way to get in touch with us is to join the &lt;code&gt;#truffleruby&lt;/code&gt; channel on &lt;a href=&#34;https://www.graalvm.org/community/#community-support&#34;&gt;GraalVM Slack&lt;/a&gt;. You can also Tweet to &lt;a href=&#34;https://twitter.com/truffleruby&#34;&gt;@TruffleRuby&lt;/a&gt;, or email &lt;em&gt;&lt;a href=&#34;mailto:benoit.daloze@oracle.com&#34;&gt;benoit.daloze@oracle.com&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Please report security vulnerabilities via the process outlined in the &lt;a href=&#34;https://www.oracle.com/corporate/security-practices/assurance/vulnerability/reporting.html&#34;&gt;reporting vulnerabilities guide&lt;/a&gt;, rather than by something public such as a GitHub issue or a Gitter conversation.&lt;/p&gt; &#xA;&lt;h2&gt;Mailing List&lt;/h2&gt; &#xA;&lt;p&gt;Announcements about GraalVM, including TruffleRuby, are made on the &lt;a href=&#34;http://mail.openjdk.java.net/mailman/listinfo/graal-dev&#34;&gt;graal-dev&lt;/a&gt; mailing list.&lt;/p&gt; &#xA;&lt;h2&gt;Authors&lt;/h2&gt; &#xA;&lt;p&gt;The main authors of TruffleRuby ordered by first contribution are: Chris Seaton, Benoit Daloze, Kevin Menard, Petr Chalupa, Brandon Fish, Duncan MacGregor, Christian Wirth, Rafael França, Alan Wu, Nicolas Laurent, Carol Chen, Nikolay Sverchkov, Lillian Zhang, Tom Stuart, and Maple Ong.&lt;/p&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/SECURITY.md&#34;&gt;SECURITY&lt;/a&gt; for how to report security vulnerabilities to Oracle. For known vulnerabilities in Ruby, please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/user/known-cves.md&#34;&gt;known-cves&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;h2&gt;Licence&lt;/h2&gt; &#xA;&lt;p&gt;TruffleRuby is copyright (c) 2013-2022 Oracle and/or its affiliates, and is made available to you under the terms of any one of the following three licenses:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Eclipse Public License version 2.0, or&lt;/li&gt; &#xA; &lt;li&gt;GNU General Public License version 2, or&lt;/li&gt; &#xA; &lt;li&gt;GNU Lesser General Public License version 2.1.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For further licensing information, see &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/LICENCE.md&#34;&gt;LICENCE&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/3rd_party_licenses.txt&#34;&gt;3rd_party_licenses&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/oracle/truffleruby/master/doc/legal/legal.md&#34;&gt;doc/legal/legal&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Attribution&lt;/h2&gt; &#xA;&lt;p&gt;TruffleRuby includes infrastructure code from &lt;a href=&#34;https://github.com/jruby/jruby&#34;&gt;JRuby&lt;/a&gt; (e.g. parser, JCodings, Joni), core library code from the &lt;a href=&#34;https://github.com/rubinius/rubinius&#34;&gt;Rubinius&lt;/a&gt; project, as well as code from the standard implementation of Ruby, &lt;a href=&#34;https://github.com/ruby/ruby&#34;&gt;MRI&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mhenrixon/sidekiq-unique-jobs</title>
    <updated>2022-12-10T01:36:33Z</updated>
    <id>tag:github.com,2022-12-10:/mhenrixon/sidekiq-unique-jobs</id>
    <link href="https://github.com/mhenrixon/sidekiq-unique-jobs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Prevents duplicate Sidekiq jobs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SidekiqUniqueJobs&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/mhenrixon/sidekiq-unique-jobs?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/mhenrixon/sidekiq-unique-jobs.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/mhenrixon/sidekiq-unique-jobs&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/actions/workflows/rspec.yml/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt; &lt;a href=&#34;https://codeclimate.com/github/mhenrixon/sidekiq-unique-jobs&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/mhenrixon/sidekiq-unique-jobs.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/mhenrixon/sidekiq-unique-jobs/coverage&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/mhenrixon/sidekiq-unique-jobs/badges/coverage.svg?sanitize=true&#34; alt=&#34;Test Coverage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Support Me&lt;/h2&gt; &#xA;&lt;p&gt;Want to show me some ❤️ for the hard work I do on this gem? You can use the following PayPal link: &lt;a href=&#34;https://paypal.me/mhenrixon1&#34;&gt;https://paypal.me/mhenrixon1&lt;/a&gt;. Any amount is welcome and let me tell you it feels good to be appreciated. Even a dollar makes me super excited about all of this.&lt;/p&gt; &#xA;&lt;!-- MarkdownTOC --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#add-the-middleware&#34;&gt;Add the middleware&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#your-first-worker&#34;&gt;Your first worker&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#requirements&#34;&gt;Requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#locks&#34;&gt;Locks&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#until-executing&#34;&gt;Until Executing&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#example-worker&#34;&gt;Example worker&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#until-executed&#34;&gt;Until Executed&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#example-worker-1&#34;&gt;Example worker&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#until-expired&#34;&gt;Until Expired&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#example-worker-2&#34;&gt;Example worker&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#until-and-while-executing&#34;&gt;Until And While Executing&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#example-worker-3&#34;&gt;Example worker&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#while-executing&#34;&gt;While Executing&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#example-worker-4&#34;&gt;Example worker&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#custom-locks&#34;&gt;Custom Locks&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#conflict-strategy&#34;&gt;Conflict Strategy&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#log&#34;&gt;log&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#raise&#34;&gt;raise&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#reject&#34;&gt;reject&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#replace&#34;&gt;replace&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#reschedule&#34;&gt;reschedule&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#custom-strategies&#34;&gt;Custom Strategies&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#3-cleanup-dead-locks&#34;&gt;3 Cleanup Dead Locks&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#debugging&#34;&gt;Debugging&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#sidekiq-web&#34;&gt;Sidekiq Web&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#reflections-metrics-logging-etc&#34;&gt;Reflections (metrics, logging, etc.)&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#after_unlock_callback_failed&#34;&gt;after_unlock_callback_failed&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#error&#34;&gt;error&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#execution_failed&#34;&gt;execution_failed&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#lock_failed&#34;&gt;lock_failed&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#locked&#34;&gt;locked&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#reschedule_failed&#34;&gt;reschedule_failed&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#rescheduled&#34;&gt;rescheduled&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#timeout&#34;&gt;timeout&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#unlock_failed&#34;&gt;unlock_failed&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#unlocked&#34;&gt;unlocked&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#unknown_sidekiq_worker&#34;&gt;unknown_sidekiq_worker&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#show-locks&#34;&gt;Show Locks&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#show-lock&#34;&gt;Show Lock&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#testing&#34;&gt;Testing&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#validating-worker-configuration&#34;&gt;Validating Worker Configuration&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#uniqueness&#34;&gt;Uniqueness&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#configuration&#34;&gt;Configuration&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#other-sidekiq-gems&#34;&gt;Other Sidekiq gems&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#apartment-sidekiq&#34;&gt;apartment-sidekiq&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#sidekiq-global_id&#34;&gt;sidekiq-global_id&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#sidekiq-status&#34;&gt;sidekiq-status&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#global-configuration&#34;&gt;Global Configuration&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#debug_lua&#34;&gt;debug_lua&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#lock_timeout&#34;&gt;lock_timeout&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#lock_ttl&#34;&gt;lock_ttl&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#enabled&#34;&gt;enabled&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#logger&#34;&gt;logger&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#max_history&#34;&gt;max_history&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#reaper&#34;&gt;reaper&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#reaper_count&#34;&gt;reaper_count&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#reaper_interval&#34;&gt;reaper_interval&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#reaper_timeout&#34;&gt;reaper_timeout&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#lock_prefix&#34;&gt;lock_prefix&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#lock_info&#34;&gt;lock_info&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#worker-configuration&#34;&gt;Worker Configuration&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#lock_info-1&#34;&gt;lock_info&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#lock_prefix-1&#34;&gt;lock_prefix&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#lock_ttl-1&#34;&gt;lock_ttl&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#lock_timeout-1&#34;&gt;lock_timeout&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#unique_across_queues&#34;&gt;unique_across_queues&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#unique_across_workers&#34;&gt;unique_across_workers&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#finer-control-over-uniqueness&#34;&gt;Finer Control over Uniqueness&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#after-unlock-callback&#34;&gt;After Unlock Callback&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#communication&#34;&gt;Communication&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#contributors&#34;&gt;Contributors&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- /MarkdownTOC --&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;This gem adds unique constraints to sidekiq jobs. The uniqueness is achieved by creating a set of keys in redis based off of &lt;code&gt;queue&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;args&lt;/code&gt; (in the sidekiq job hash).&lt;/p&gt; &#xA;&lt;p&gt;By default, only one lock for a given hash can be acquired. What happens when a lock can&#39;t be acquired is governed by a chosen &lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#conflict-strategy&#34;&gt;Conflict Strategy&lt;/a&gt; strategy. Unless a conflict strategy is chosen (?)&lt;/p&gt; &#xA;&lt;p&gt;This is the documentation for the &lt;code&gt;main&lt;/code&gt; branch. You can find the documentation for each release by navigating to its tag.&lt;/p&gt; &#xA;&lt;p&gt;Here are links to some of the old versions&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/tree/v7.0.12&#34;&gt;v7.0.12&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/tree/v6.0.25&#34;&gt;v6.0.25&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/tree/v5.0.10&#34;&gt;v5.0.10&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/tree/v4.0.18&#34;&gt;v4.0.18&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;sidekiq-unique-jobs&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Add the middleware&lt;/h3&gt; &#xA;&lt;p&gt;Before v7, the middleware was configured automatically. Since some people reported issues with other gems (see &lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#other-sidekiq-gems&#34;&gt;Other Sidekiq Gems&lt;/a&gt;) it was decided to give full control over to the user.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt; if you want to use the reaper you also need to configure the server middleware.&lt;/p&gt; &#xA;&lt;p&gt;The following shows how to modify your &lt;code&gt;config/initializers/sidekiq.rb&lt;/code&gt; file to use the middleware. &lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/raw/master/myapp/config/initializers/sidekiq.rb#L12&#34;&gt;Here is a full example.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;sidekiq-unique-jobs&#34;&#xA;&#xA;Sidekiq.configure_server do |config|&#xA;  config.redis = { url: ENV[&#34;REDIS_URL&#34;], driver: :hiredis }&#xA;&#xA;  config.client_middleware do |chain|&#xA;    chain.add SidekiqUniqueJobs::Middleware::Client&#xA;  end&#xA;&#xA;  config.server_middleware do |chain|&#xA;    chain.add SidekiqUniqueJobs::Middleware::Server&#xA;  end&#xA;&#xA;  SidekiqUniqueJobs::Server.configure(config)&#xA;end&#xA;&#xA;Sidekiq.configure_client do |config|&#xA;  config.redis = { url: ENV[&#34;REDIS_URL&#34;], driver: :hiredis }&#xA;&#xA;  config.client_middleware do |chain|&#xA;    chain.add SidekiqUniqueJobs::Middleware::Client&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Your first worker&lt;/h3&gt; &#xA;&lt;p&gt;The lock type most likely to be is &lt;code&gt;:until_executed&lt;/code&gt;. This type of lock creates a lock from when &lt;code&gt;UntilExecutedWorker.perform_async&lt;/code&gt; is called until right after &lt;code&gt;UntilExecutedWorker.new.perform&lt;/code&gt; has been called.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# frozen_string_literal: true&#xA;&#xA;class UntilExecutedWorker&#xA;  include Sidekiq::Worker&#xA;&#xA;  sidekiq_options lock: :until_executed&#xA;&#xA;  def perform&#xA;    logger.info(&#34;cowboy&#34;)&#xA;    sleep(1) # hardcore processing&#xA;    logger.info(&#34;beebop&#34;)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can read more about the worker configuration in &lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#worker-configuration&#34;&gt;Worker Configuration&lt;/a&gt; below.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sidekiq &lt;code&gt;&amp;gt;= 5.0&lt;/code&gt; (&lt;code&gt;&amp;gt;= 5.2&lt;/code&gt; recommended)&lt;/li&gt; &#xA; &lt;li&gt;Ruby: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;MRI &lt;code&gt;&amp;gt;= 2.5&lt;/code&gt; (&lt;code&gt;&amp;gt;= 2.6&lt;/code&gt; recommended)&lt;/li&gt; &#xA;   &lt;li&gt;JRuby &lt;code&gt;&amp;gt;= 9.0&lt;/code&gt; (&lt;code&gt;&amp;gt;= 9.2&lt;/code&gt; recommended)&lt;/li&gt; &#xA;   &lt;li&gt;Truffleruby&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Redis Server &lt;code&gt;&amp;gt;= 3.2&lt;/code&gt; (&lt;code&gt;&amp;gt;= 5.0&lt;/code&gt; recommended)&lt;/li&gt; &#xA; &lt;li&gt;[ActiveJob officially not supported][48]&lt;/li&gt; &#xA; &lt;li&gt;[redis-namespace officially not supported][49]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See [Sidekiq requirements][24] for detailed requirements of Sidekiq itself (be sure to check the right sidekiq version).&lt;/p&gt; &#xA;&lt;h2&gt;Locks&lt;/h2&gt; &#xA;&lt;h3&gt;Until Executing&lt;/h3&gt; &#xA;&lt;p&gt;A lock is created when &lt;code&gt;UntilExecuting.perform_async&lt;/code&gt; is called. Then it is either unlocked when &lt;code&gt;lock_ttl&lt;/code&gt; is hit or before Sidekiq calls the &lt;code&gt;perform&lt;/code&gt; method on your worker.&lt;/p&gt; &#xA;&lt;h4&gt;Example worker&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UntilExecuting&#xA;  include Sidekiq::Workers&#xA;&#xA;  sidekiq_options lock: :until_executing&#xA;&#xA;  def perform(id)&#xA;    # Do work&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt; this is probably not so good for jobs that shouldn&#39;t be running simultaneously (aka slow jobs).&lt;/p&gt; &#xA;&lt;p&gt;The reason this type of lock exists is to fix the following problem: &lt;a href=&#34;https://github.com/mperham/sidekiq/issues/3471#issuecomment-300866335&#34;&gt;sidekiq/issues/3471&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Until Executed&lt;/h3&gt; &#xA;&lt;p&gt;A lock is created when &lt;code&gt;UntilExecuted.perform_async&lt;/code&gt; is called. Then it is either unlocked when &lt;code&gt;lock_ttl&lt;/code&gt; is hit or when Sidekiq has called the &lt;code&gt;perform&lt;/code&gt; method on your worker.&lt;/p&gt; &#xA;&lt;h4&gt;Example worker&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UntilExecuted&#xA;  include Sidekiq::Workers&#xA;&#xA;  sidekiq_options lock: :until_executed&#xA;&#xA;  def perform(id)&#xA;    # Do work&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Until Expired&lt;/h3&gt; &#xA;&lt;p&gt;This lock behaves identically to the &lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#until-executed&#34;&gt;Until Executed&lt;/a&gt; except for one thing. This job won&#39;t be unlocked until the expiration is hit. For jobs that need to run only once per day, this would be the perfect lock. This way, we can&#39;t create more jobs until one day after this job was first pushed.&lt;/p&gt; &#xA;&lt;h4&gt;Example worker&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UntilExpired&#xA;  include Sidekiq::Workers&#xA;&#xA;  sidekiq_options lock: :until_expired, lock_ttl: 1.day&#xA;&#xA;  def perform&#xA;    # Do work&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Until And While Executing&lt;/h3&gt; &#xA;&lt;p&gt;This lock is a combination of two locks (&lt;code&gt;:until_executing&lt;/code&gt; and &lt;code&gt;:while_executing&lt;/code&gt;). Please see the configuration for &lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#until-executing&#34;&gt;Until Executing&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#while-executing&#34;&gt;While Executing&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Example worker&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UntilAndWhileExecutingWorker&#xA;  include Sidekiq::Workers&#xA;&#xA;  sidekiq_options lock: :until_and_while_executing,&#xA;                  lock_timeout: 2,&#xA;                  on_conflict: {&#xA;                    client: :log,&#xA;                    server: :raise&#xA;                  }&#xA;  def perform(id)&#xA;    # Do work&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;While Executing&lt;/h3&gt; &#xA;&lt;p&gt;These locks are put on a queue without any type of locking mechanism, the locking doesn&#39;t happen until Sidekiq pops the job from the queue and starts processing it.&lt;/p&gt; &#xA;&lt;h4&gt;Example worker&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class WhileExecutingWorker&#xA;  include Sidekiq::Workers&#xA;&#xA;  sidekiq_options lock: :while_executing,&#xA;                  lock_timeout: 2,&#xA;                  on_conflict: {&#xA;                    server: :raise&#xA;                  }&#xA;  def perform(id)&#xA;    # Do work&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt; Unless a conflict strategy of &lt;code&gt;:raise&lt;/code&gt; is specified, if lock fails, the job will be dropped without notice. When told to raise, the job will be put back and retried. It would also be possible to use &lt;code&gt;:reschedule&lt;/code&gt; with this lock.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt; Unless this job is configured with a &lt;code&gt;lock_timeout: nil&lt;/code&gt; or &lt;code&gt;lock_timeout: &amp;gt; 0&lt;/code&gt; then all jobs that are attempted to be executed will just be dropped without waiting.&lt;/p&gt; &#xA;&lt;p&gt;There is an example of this to try it out in the &lt;code&gt;myapp&lt;/code&gt; application. Run &lt;code&gt;foreman start&lt;/code&gt; in the root of the directory and open the url: &lt;code&gt;localhost:5000/work/duplicate_while_executing&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In the console you should see something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;0:32:24 worker.1 | 2017-04-23T08:32:24.955Z 84404 TID-ougq4thko WhileExecutingWorker JID-400ec51c9523f41cd4a35058 INFO: start&#xA;10:32:24 worker.1 | 2017-04-23T08:32:24.956Z 84404 TID-ougq8csew WhileExecutingWorker JID-8d6d9168368eedaed7f75763 INFO: start&#xA;10:32:24 worker.1 | 2017-04-23T08:32:24.957Z 84404 TID-ougq8crt8 WhileExecutingWorker JID-affcd079094c9b26e8b9ba60 INFO: start&#xA;10:32:24 worker.1 | 2017-04-23T08:32:24.959Z 84404 TID-ougq8cs8s WhileExecutingWorker JID-9e197460c067b22eb1b5d07f INFO: start&#xA;10:32:24 worker.1 | 2017-04-23T08:32:24.959Z 84404 TID-ougq4thko WhileExecutingWorker JID-400ec51c9523f41cd4a35058 WhileExecutingWorker INFO: perform(1, 2)&#xA;10:32:34 worker.1 | 2017-04-23T08:32:34.964Z 84404 TID-ougq4thko WhileExecutingWorker JID-400ec51c9523f41cd4a35058 INFO: done: 10.009 sec&#xA;10:32:34 worker.1 | 2017-04-23T08:32:34.965Z 84404 TID-ougq8csew WhileExecutingWorker JID-8d6d9168368eedaed7f75763 WhileExecutingWorker INFO: perform(1, 2)&#xA;10:32:44 worker.1 | 2017-04-23T08:32:44.965Z 84404 TID-ougq8crt8 WhileExecutingWorker JID-affcd079094c9b26e8b9ba60 WhileExecutingWorker INFO: perform(1, 2)&#xA;10:32:44 worker.1 | 2017-04-23T08:32:44.965Z 84404 TID-ougq8csew WhileExecutingWorker JID-8d6d9168368eedaed7f75763 INFO: done: 20.009 sec&#xA;10:32:54 worker.1 | 2017-04-23T08:32:54.970Z 84404 TID-ougq8cs8s WhileExecutingWorker JID-9e197460c067b22eb1b5d07f WhileExecutingWorker INFO: perform(1, 2)&#xA;10:32:54 worker.1 | 2017-04-23T08:32:54.969Z 84404 TID-ougq8crt8 WhileExecutingWorker JID-affcd079094c9b26e8b9ba60 INFO: done: 30.012 sec&#xA;10:33:04 worker.1 | 2017-04-23T08:33:04.973Z 84404 TID-ougq8cs8s WhileExecutingWorker JID-9e197460c067b22eb1b5d07f INFO: done: 40.014 sec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom Locks&lt;/h3&gt; &#xA;&lt;p&gt;You may need to define some custom lock. You can define it in one project folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# lib/locks/my_custom_lock.rb&#xA;module Locks&#xA;  class MyCustomLock &amp;lt; SidekiqUniqueJobs::Lock::BaseLock&#xA;    def execute&#xA;      # Do something ...&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can refer on all the locks defined in &lt;code&gt;lib/sidekiq_unique_jobs/lock/*.rb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In order to make it available, you should call in your project startup:&lt;/p&gt; &#xA;&lt;p&gt;(For rails application config/initializers/sidekiq_unique_jobs.rb or other projects, wherever you prefer)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.configure do |config|&#xA;  config.add_lock :my_custom_lock, Locks::MyCustomLock&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then you can use it in the jobs definition:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sidekiq_options lock: :my_custom_lock, on_conflict: :log&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Please not that if you try to override a default lock, an &lt;code&gt;ArgumentError&lt;/code&gt; will be raised.&lt;/p&gt; &#xA;&lt;h2&gt;Conflict Strategy&lt;/h2&gt; &#xA;&lt;p&gt;Decides how we handle conflict. We can either &lt;code&gt;reject&lt;/code&gt; the job to the dead queue or &lt;code&gt;reschedule&lt;/code&gt; it. Both are useful for jobs that absolutely need to run and have been configured to use the lock &lt;code&gt;WhileExecuting&lt;/code&gt; that is used only by the sidekiq server process.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore, &lt;code&gt;log&lt;/code&gt; can be be used with the lock &lt;code&gt;UntilExecuted&lt;/code&gt; and &lt;code&gt;UntilExpired&lt;/code&gt;. Now we write a log entry saying the job could not be pushed because it is a duplicate of another job with the same arguments.&lt;/p&gt; &#xA;&lt;p&gt;It is possible for locks to have different conflict strategy for the client and server. This is useful for &lt;code&gt;:until_and_while_executing&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sidekiq_options lock: :until_and_while_executing,&#xA;                on_conflict: { client: :log, server: :reject }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;log&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sidekiq_options on_conflict: :log&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This strategy is intended to be used with &lt;code&gt;UntilExecuted&lt;/code&gt; and &lt;code&gt;UntilExpired&lt;/code&gt;. It will log a line that this job is a duplicate of another.&lt;/p&gt; &#xA;&lt;h3&gt;raise&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sidekiq_options on_conflict: :raise&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This strategy is intended to be used with &lt;code&gt;WhileExecuting&lt;/code&gt;. Basically it will allow us to let the server process crash with a specific error message and be retried without messing up the Sidekiq stats.&lt;/p&gt; &#xA;&lt;h3&gt;reject&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sidekiq_options on_conflict: :reject&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This strategy is intended to be used with &lt;code&gt;WhileExecuting&lt;/code&gt; and will push the job to the dead queue on conflict.&lt;/p&gt; &#xA;&lt;h3&gt;replace&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sidekiq_options on_conflict: :replace&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This strategy is intended to be used with client locks like &lt;code&gt;UntilExecuted&lt;/code&gt;. It will delete any existing job for these arguments from retry, schedule and queue and retry the lock again.&lt;/p&gt; &#xA;&lt;p&gt;This is slightly dangerous and should probably only be used for jobs that are always scheduled in the future. Currently only attempting to retry one time.&lt;/p&gt; &#xA;&lt;h3&gt;reschedule&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sidekiq_options on_conflict: :reschedule&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This strategy is intended to be used with &lt;code&gt;WhileExecuting&lt;/code&gt; and will delay the job to be tried again in 5 seconds. This will mess up the sidekiq stats but will prevent exceptions from being logged and confuse your sysadmins.&lt;/p&gt; &#xA;&lt;h3&gt;Custom Strategies&lt;/h3&gt; &#xA;&lt;p&gt;You may need to define some custom strategy. You can define it in one project folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# lib/strategies/my_custom_strategy.rb&#xA;module Strategies&#xA;  class MyCustomStrategy &amp;lt; SidekiqUniqueJobs::OnConflict::Strategy&#xA;    def call&#xA;      # Do something ...&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can refer to all the strategies defined in &lt;code&gt;lib/sidekiq_unique_jobs/on_conflict&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In order to make it available, you should call in your project startup:&lt;/p&gt; &#xA;&lt;p&gt;(For rails application config/initializers/sidekiq_unique_jobs.rb for other projects, wherever you prefer)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.configure do |config|&#xA;  config.add_strategy :my_custom_strategy, Strategies::MyCustomStrategy&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then you can use it in the jobs definition:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sidekiq_options lock: :while_executing, on_conflict: :my_custom_strategy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please not that if you try to override a default lock, an &lt;code&gt;ArgumentError&lt;/code&gt; will be raised.&lt;/p&gt; &#xA;&lt;h3&gt;3 Cleanup Dead Locks&lt;/h3&gt; &#xA;&lt;p&gt;For sidekiq versions &amp;lt; 5.1 a &lt;code&gt;sidekiq_retries_exhausted&lt;/code&gt; block is required per worker class. This is deprecated in Sidekiq 6.0&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyWorker&#xA;  sidekiq_retries_exhausted do |msg, _ex|&#xA;    digest = msg[&#39;lock_digest&#39;]&#xA;    SidekiqUniqueJobs::Digests.new.delete_by_digest(digest) if digest&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Starting in v5.1, Sidekiq can also fire a global callback when a job dies: In version 7, this is handled automatically for you. You don&#39;t need to add a death handler, if you configure v7 like in &lt;a href=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/#add-the-middleware&#34;&gt;Add the middleware&lt;/a&gt; you don&#39;t have to worry about the below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Sidekiq.configure_server do |config|&#xA;  config.death_handlers &amp;lt;&amp;lt; -&amp;gt;(job, _ex) do&#xA;    digest = job[&#39;lock_digest&#39;]&#xA;    SidekiqUniqueJobs::Digests.new.delete_by_digest(digest) if digest&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Debugging&lt;/h2&gt; &#xA;&lt;p&gt;There are several ways of removing keys that are stuck. The prefered way is by using the unique extension to &lt;code&gt;Sidekiq::Web&lt;/code&gt;. The old console and command line versions still work but might be deprecated in the future. It is better to search for the digest itself and delete the keys matching that digest.&lt;/p&gt; &#xA;&lt;h3&gt;Sidekiq Web&lt;/h3&gt; &#xA;&lt;p&gt;To use the web extension you need to require it in your routes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#app/config/routes.rb&#xA;require &#39;sidekiq_unique_jobs/web&#39;&#xA;mount Sidekiq::Web, at: &#39;/sidekiq&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is no need to &lt;code&gt;require &#39;sidekiq/web&#39;&lt;/code&gt; since &lt;code&gt;sidekiq_unique_jobs/web&lt;/code&gt; already does this.&lt;/p&gt; &#xA;&lt;p&gt;To filter/search for keys we can use the wildcard &lt;code&gt;*&lt;/code&gt;. If we have a unique digest &lt;code&gt;&#39;uniquejobs:9e9b5ce5d423d3ea470977004b50ff84&lt;/code&gt; we can search for it by enter &lt;code&gt;*ff84&lt;/code&gt; and it should return all digests that end with &lt;code&gt;ff84&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Reflections (metrics, logging, etc.)&lt;/h3&gt; &#xA;&lt;p&gt;To be able to gather some insights on what is going on inside this gem. I provide a reflection API that can be used.&lt;/p&gt; &#xA;&lt;p&gt;To setup reflections for logging or metrics, use the following API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#xA;def extract_log_from_job(message, job_hash)&#xA;  worker    = job_hash[&#39;class&#39;]&#xA;  args      = job_hash[&#39;args&#39;]&#xA;  lock_args = job_hash[&#39;lock_args&#39;]&#xA;  queue     = job_hash[&#39;queue&#39;]&#xA;  {&#xA;    message: message,&#xA;    worker: worker,&#xA;    args: args,&#xA;    lock_args: lock_args,&#xA;    queue: queue&#xA;  }&#xA;end&#xA;&#xA;SidekiqUniqueJobs.reflect do |on|&#xA;  on.lock_failed do |job_hash|&#xA;    message = extract_log_from_job(&#39;Lock Failed&#39;, job_hash)&#xA;    Sidekiq.logger.warn(message)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;after_unlock_callback_failed&lt;/h4&gt; &#xA;&lt;p&gt;This is called when you have configured a custom callback for when a lock has been released.&lt;/p&gt; &#xA;&lt;h4&gt;error&lt;/h4&gt; &#xA;&lt;p&gt;Not in use yet but will be used deep into the stack to provide a means to catch and report errors inside the gem.&lt;/p&gt; &#xA;&lt;h4&gt;execution_failed&lt;/h4&gt; &#xA;&lt;p&gt;When the sidekiq processor picks the job of the queue for certain jobs but your job raised an error to the middleware. This will be the reflection. It is probably nothing to worry about. When your worker raises an error, we need to handle some edge cases for until and while executing.&lt;/p&gt; &#xA;&lt;h4&gt;lock_failed&lt;/h4&gt; &#xA;&lt;p&gt;If we can&#39;t achieve a lock, this will be the reflection. It most likely is nothing to worry about. We just couldn&#39;t retrieve a lock in a timely fashion.&lt;/p&gt; &#xA;&lt;p&gt;The biggest reason for this reflection would be to gather metrics on which workers fail the most at the locking step for example.&lt;/p&gt; &#xA;&lt;h4&gt;locked&lt;/h4&gt; &#xA;&lt;p&gt;For when a lock has been successful. Again, mostly useful for metrics I suppose.&lt;/p&gt; &#xA;&lt;h4&gt;reschedule_failed&lt;/h4&gt; &#xA;&lt;p&gt;For when the reschedule strategy failed to reschedule the job.&lt;/p&gt; &#xA;&lt;h4&gt;rescheduled&lt;/h4&gt; &#xA;&lt;p&gt;For when a job was successfully rescheduled&lt;/p&gt; &#xA;&lt;h4&gt;timeout&lt;/h4&gt; &#xA;&lt;p&gt;This is also mostly useful for reporting/metrics purposes. What this reflection does is signal that the job was configured to wait (&lt;code&gt;lock_timeout&lt;/code&gt; was configured), but we couldn&#39;t retrieve a lock even though we waited for some time.&lt;/p&gt; &#xA;&lt;h3&gt;unlock_failed&lt;/h3&gt; &#xA;&lt;p&gt;This is not got, this is worth&lt;/p&gt; &#xA;&lt;h3&gt;unlocked&lt;/h3&gt; &#xA;&lt;p&gt;Also mostly useful for reporting purposes. The job was successfully unlocked.&lt;/p&gt; &#xA;&lt;h3&gt;unknown_sidekiq_worker&lt;/h3&gt; &#xA;&lt;p&gt;The reason this happens is that the server couldn&#39;t find a valid sidekiq worker class. Most likely, that worker isn&#39;t intended to be processed by this sidekiq server instance.&lt;/p&gt; &#xA;&lt;h4&gt;Show Locks&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/assets/unique_digests_1.png&#34; alt=&#34;Locks&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Show Lock&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mhenrixon/sidekiq-unique-jobs/main/assets/unique_digests_2.png&#34; alt=&#34;Lock&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;h3&gt;Validating Worker Configuration&lt;/h3&gt; &#xA;&lt;p&gt;Since v7 it is possible to perform some simple validation against your workers &lt;code&gt;sidekiq_options&lt;/code&gt;. What it does is scan for some issues that are known to cause problems in production.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s take a &lt;em&gt;bad&lt;/em&gt; worker:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#app/workers/bad_worker.rb&#xA;class BadWorker&#xA;  sidekiq_options lock: :while_executing, on_conflict: :replace&#xA;end&#xA;&#xA;#spec/workers/bad_worker_spec.rb&#xA;&#xA;require &#34;sidekiq_unique_jobs/testing&#34;&#xA;#OR&#xA;require &#34;sidekiq_unique_jobs/rspec/matchers&#34;&#xA;&#xA;RSpec.describe BadWorker do&#xA;  specify { expect(described_class).to have_valid_sidekiq_options }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This gives us a helpful error message for a wrongly configured worker:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Expected BadWorker to have valid sidekiq options but found the following problems:&#xA;    on_server_conflict: :replace is incompatible with the server process&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are not using RSpec (a lot of people prefer minitest or test unit) you can do something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;assert_raise(InvalidWorker){ SidekiqUniqueJobs.validate_worker!(BadWorker.get_sidekiq_options) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Uniqueness&lt;/h3&gt; &#xA;&lt;p&gt;This has been probably the most confusing part of this gem. People get really confused with how unreliable the unique jobs have been. I there for decided to do what Mike is doing for sidekiq enterprise. Read the section about unique jobs: &lt;a href=&#34;https://github.com/mperham/sidekiq/wiki/Ent-Unique-Jobs&#34;&gt;Enterprise unique jobs&lt;/a&gt;(?)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.configure do |config|&#xA;  config.enabled = !Rails.env.test?&#xA;  config.logger_enabled = !Rails.env.test?&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you truly wanted to test the sidekiq client push you could do something like below. Note that it will only work for the jobs that lock when the client pushes the job to redis (UntilExecuted, UntilAndWhileExecuting and UntilExpired).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;sidekiq_unique_jobs/testing&#34;&#xA;&#xA;RSpec.describe Workers::CoolOne do&#xA;  before do&#xA;    SidekiqUniqueJobs.config.enabled = false&#xA;  end&#xA;&#xA;  # ... your tests that don&#39;t test uniqueness&#xA;&#xA;  context &#39;when Sidekiq::Testing.disabled?&#39; do&#xA;    before do&#xA;      Sidekiq::Testing.disable!&#xA;      Sidekiq.redis(&amp;amp;:flushdb)&#xA;    end&#xA;&#xA;    after do&#xA;      Sidekiq.redis(&amp;amp;:flushdb)&#xA;    end&#xA;&#xA;    it &#39;prevents duplicate jobs from being scheduled&#39; do&#xA;      SidekiqUniqueJobs.use_config(enabled: true) do&#xA;        expect(described_class.perform_in(3600, 1)).not_to eq(nil)&#xA;        expect(described_class.perform_async(1)).to eq(nil)&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is recommended to leave the uniqueness testing to the gem maintainers. If you care about how the gem is integration tested have a look at the following specs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/raw/master/spec/sidekiq_unique_jobs/lock/until_and_while_executing_spec.rb&#34;&gt;spec/sidekiq_unique_jobs/lock/until_and_while_executing_spec.rb&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/raw/master/spec/sidekiq_unique_jobs/lock/until_executed_spec.rb&#34;&gt;spec/sidekiq_unique_jobs/lock/until_executed_spec.rb&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/raw/master/spec/sidekiq_unique_jobs/lock/until_expired_spec.rb&#34;&gt;spec/sidekiq_unique_jobs/lock/until_expired_spec.rb&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/raw/master/spec/sidekiq_unique_jobs/lock/while_executing_reject_spec.rb&#34;&gt;spec/sidekiq_unique_jobs/lock/while_executing_reject_spec.rb&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/raw/master/spec/sidekiq_unique_jobs/lock/while_executing_spec.rb&#34;&gt;spec/sidekiq_unique_jobs/lock/while_executing_spec.rb&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h3&gt;Other Sidekiq gems&lt;/h3&gt; &#xA;&lt;h4&gt;apartment-sidekiq&lt;/h4&gt; &#xA;&lt;p&gt;It was reported in &lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/issues/536&#34;&gt;#536&lt;/a&gt; that the order of the Sidekiq middleware needs to be as follows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Sidekiq.client_middleware do |chain|&#xA;  chain.add Apartment::Sidekiq::Middleware::Client&#xA;  chain.add SidekiqUniqueJobs::Middleware::Client&#xA;end&#xA;&#xA;Sidekiq.server_middleware do |chain|&#xA;  chain.add Apartment::Sidekiq::Middleware::Server&#xA;  chain.add SidekiqUniqueJobs::Middleware::Server&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reason being that this gem needs to be configured AFTER the apartment gem or the apartment will not be able to be considered for uniqueness&lt;/p&gt; &#xA;&lt;h4&gt;sidekiq-global_id&lt;/h4&gt; &#xA;&lt;p&gt;It was reported in &lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/issues/235&#34;&gt;#235&lt;/a&gt; that the order of the Sidekiq middleware needs to be as follows.&lt;/p&gt; &#xA;&lt;p&gt;For a working setup check the following &lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/raw/master/myapp/config/sidekiq.rb#L12&#34;&gt;file&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Sidekiq.client_middleware do |chain|&#xA;  chain.add Sidekiq::GlobalId::ClientMiddleware&#xA;  chain.add SidekiqUniqueJobs::Middleware::Client&#xA;end&#xA;&#xA;Sidekiq.server_middleware do |chain|&#xA;  chain.add Sidekiq::GlobalId::ServerMiddleware&#xA;  chain.add SidekiqUniqueJobs::Middleware::Server&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reason for this is that the global id needs to be set before the unique jobs middleware runs. Otherwise that won&#39;t be available for uniqueness.&lt;/p&gt; &#xA;&lt;h4&gt;sidekiq-status&lt;/h4&gt; &#xA;&lt;p&gt;It was reported in &lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/issues/564&#34;&gt;#564&lt;/a&gt; that the order of the middleware needs to be as follows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Thanks to @ArturT for the correction&#xA;&#xA;Sidekiq.configure_server do |config|&#xA;  config.client_middleware do |chain|&#xA;    chain.add SidekiqUniqueJobs::Middleware::Client&#xA;    chain.add Sidekiq::Status::ClientMiddleware, expiration: 30.minutes&#xA;  end&#xA;&#xA;  config.server_middleware do |chain|&#xA;    chain.add Sidekiq::Status::ServerMiddleware, expiration: 30.minutes&#xA;    chain.add SidekiqUniqueJobs::Middleware::Server&#xA;  end&#xA;&#xA;  SidekiqUniqueJobs::Server.configure(config)&#xA;end&#xA;&#xA;&#xA;Sidekiq.configure_client do |config|&#xA;  config.client_middleware do |chain|&#xA;    chain.add SidekiqUniqueJobs::Middleware::Client&#xA;    chain.add Sidekiq::Status::ClientMiddleware, expiration: 30.minutes&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reason for this is that if a job is duplicated it shouldn&#39;t end up with the status middleware at all. Status is just a monitor so to prevent clashes, leftovers and ensure cleanup. The status middleware should run after uniqueness on client and before on server. This will lead to less surprises.&lt;/p&gt; &#xA;&lt;h3&gt;Global Configuration&lt;/h3&gt; &#xA;&lt;p&gt;The gem supports a few different configuration options that might be of interest if you run into some weird issues.&lt;/p&gt; &#xA;&lt;p&gt;Configure SidekiqUniqueJobs in an initializer or the sidekiq initializer on application startup.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.configure do |config|&#xA;  config.logger = Sidekiq.logger # default, change at your own discretion&#xA;  config.logger_enabled  = true # default, disable for test environments&#xA;  config.debug_lua       = false # Turn on when debugging&#xA;  config.lock_info       = false # Turn on when debugging&#xA;  config.lock_ttl        = 600   # Expire locks after 10 minutes&#xA;  config.lock_timeout    = nil   # turn off lock timeout&#xA;  config.max_history     = 0     # Turn on when debugging&#xA;  config.reaper          = :ruby # :ruby, :lua or :none/nil&#xA;  config.reaper_count    = 1000  # Stop reaping after this many keys&#xA;  config.reaper_interval = 600   # Reap orphans every 10 minutes&#xA;  config.reaper_timeout  = 150   # Timeout reaper after 2.5 minutes&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;debug_lua&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.config.debug_lua #=&amp;gt; false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Turning on debug_lua will allow the lua scripts to output debug information about what the lua scripts do. It will log all redis commands that are executed and also some helpful messages about what is going on inside the lua script.&lt;/p&gt; &#xA;&lt;h4&gt;lock_timeout&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.config.lock_timeout #=&amp;gt; 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set a global lock_timeout to use for all jobs that don&#39;t otherwise specify a lock_timeout.&lt;/p&gt; &#xA;&lt;p&gt;Lock timeout decides how long to wait for acquiring the lock. A value of nil means to wait indefinitely for a lock resource to become available.&lt;/p&gt; &#xA;&lt;h4&gt;lock_ttl&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.config.lock_ttl #=&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set a global lock_ttl to use for all jobs that don&#39;t otherwise specify a lock_ttl.&lt;/p&gt; &#xA;&lt;p&gt;Lock TTL decides how long to wait at most before considering a lock to be expired and making it possible to reuse that lock.&lt;/p&gt; &#xA;&lt;h4&gt;enabled&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.config.enabled #=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Globally turn the locking mechanism on or off.&lt;/p&gt; &#xA;&lt;h4&gt;logger&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.config.logger #=&amp;gt; #&amp;lt;Sidekiq::Logger:0x00007fdc1f96d180&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default this gem piggybacks on the Sidekiq logger. It is not recommended to change this as the gem uses some features in the Sidekiq logger and you might run into problems. If you need a different logger and you do run into problems then get in touch and we&#39;ll see what we can do about it.&lt;/p&gt; &#xA;&lt;h4&gt;max_history&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.config.max_history #=&amp;gt; 1_000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The max_history setting can be used to tweak the number of changelogs generated. It can also be completely turned off if performance suffers or if you are just not interested in using the changelog.&lt;/p&gt; &#xA;&lt;p&gt;This is a log that can be accessed by a lock to see what happened for that lock. Any items after the configured &lt;code&gt;max_history&lt;/code&gt; will be automatically deleted as new items are added.&lt;/p&gt; &#xA;&lt;h4&gt;reaper&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.config.reaper #=&amp;gt; :ruby&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If using the orphans cleanup process it is critical to be aware of the following. The &lt;code&gt;:ruby&lt;/code&gt; job is much slower but the &lt;code&gt;:lua&lt;/code&gt; job locks redis while executing. While doing intense processing it is best to avoid locking redis with a lua script. There for the batch size (controlled by the &lt;code&gt;reaper_count&lt;/code&gt; setting) needs to be reduced.&lt;/p&gt; &#xA;&lt;p&gt;In my benchmarks deleting 1000 orphaned locks with lua performs around 65% faster than deleting 1000 keys in ruby.&lt;/p&gt; &#xA;&lt;p&gt;On the other hand if I increase it to 10 000 orphaned locks per cleanup (&lt;code&gt;reaper_count: 10_0000&lt;/code&gt;) then redis starts throwing:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE. (Redis::CommandError)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If you want to disable the reaper set it to &lt;code&gt;:none&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Actually, any value that isn&#39;t &lt;code&gt;:ruby&lt;/code&gt; or &lt;code&gt;:lua&lt;/code&gt; will disable the reaping.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.config.reaper = :none&#xA;SidekiqUniqueJobs.config.reaper = nil&#xA;SidekiqUniqueJobs.config.reaper = false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;reaper_count&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.config.reaper_count #=&amp;gt; 1_000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reaper_count setting configures how many orphans at a time will be cleaned up by the orphan cleanup job. This might have to be tweaked depending on which orphan job is running.&lt;/p&gt; &#xA;&lt;h4&gt;reaper_interval&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.config.reaper_interval #=&amp;gt; 600&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The number of seconds between reaping.&lt;/p&gt; &#xA;&lt;h4&gt;reaper_timeout&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.config.reaper_timeout #=&amp;gt; 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The number of seconds to wait for the reaper to finish before raising a TimeoutError. This is done to ensure that the next time we reap isn&#39;t getting stuck due to the previous process already running.&lt;/p&gt; &#xA;&lt;h4&gt;lock_prefix&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.config.lock_prefix #=&amp;gt; &#34;uniquejobs&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use if you want a different key prefix for the keys in redis.&lt;/p&gt; &#xA;&lt;h3&gt;lock_info&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SidekiqUniqueJobs.config.lock_info #=&amp;gt; false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using lock info will create an additional key for the lock with a json object containing information about the lock. This will be presented in the web interface and might help track down why some jobs are getting stuck.&lt;/p&gt; &#xA;&lt;h3&gt;Worker Configuration&lt;/h3&gt; &#xA;&lt;h4&gt;lock_info&lt;/h4&gt; &#xA;&lt;p&gt;Lock info gathers information about a specific lock. It collects things like which &lt;code&gt;lock_args&lt;/code&gt; where used to compute the &lt;code&gt;lock_digest&lt;/code&gt; that is used for maintaining uniqueness.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sidekiq_options lock_info: false # this is the default, set to true to turn on&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;lock_prefix&lt;/h4&gt; &#xA;&lt;p&gt;Use if you want a different key prefix for the keys in redis.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sidekiq_options lock_prefix: &#34;uniquejobs&#34; # this is the default value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;lock_ttl&lt;/h4&gt; &#xA;&lt;p&gt;Lock TTL decides how long to wait at most before considering a lock to be expired and making it possible to reuse that lock.&lt;/p&gt; &#xA;&lt;p&gt;Starting from &lt;code&gt;v7&lt;/code&gt; the expiration will take place when the job is pushed to the queue.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sidekiq_options lock_ttl: nil # default - don&#39;t expire keys&#xA;sidekiq_options lock_ttl: 20.days.to_i # expire this lock in 20 days&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;lock_timeout&lt;/h4&gt; &#xA;&lt;p&gt;This is the timeout (how long to wait) when creating the lock. By default we don&#39;t use a timeout so we won&#39;t wait for the lock to be created. If you want it is possible to set this like below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sidekiq_options lock_timeout: 0 # default - don&#39;t wait at all&#xA;sidekiq_options lock_timeout: 5 # wait 5 seconds&#xA;sidekiq_options lock_timeout: nil # lock indefinitely, this process won&#39;t continue until it gets a lock. VERY DANGEROUS!!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;unique_across_queues&lt;/h4&gt; &#xA;&lt;p&gt;This configuration option is slightly misleading. It doesn&#39;t disregard the queue on other jobs. Just on itself, this means that a worker that might schedule jobs into multiple queues will be able to have uniqueness enforced on all queues it is pushed to.&lt;/p&gt; &#xA;&lt;p&gt;This is mainly intended for &lt;code&gt;Worker.set(queue: :another).perform_async&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Worker&#xA;  include Sidekiq::Worker&#xA;&#xA;  sidekiq_options unique_across_queues: true, queue: &#39;default&#39;&#xA;&#xA;  def perform(args); end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now if you push override the queue with &lt;code&gt;Worker.set(queue: &#39;another&#39;).perform_async(1)&lt;/code&gt; it will still be considered unique when compared to &lt;code&gt;Worker.perform_async(1)&lt;/code&gt; (that was actually pushed to the queue &lt;code&gt;default&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;unique_across_workers&lt;/h4&gt; &#xA;&lt;p&gt;This configuration option is slightly misleading. It doesn&#39;t disregard the worker class on other jobs. Just on itself, this means that the worker class won&#39;t be used for generating the unique digest. The only way this option really makes sense is when you want to have uniqueness between two different worker classes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class WorkerOne&#xA;  include Sidekiq::Worker&#xA;&#xA;  sidekiq_options unique_across_workers: true, queue: &#39;default&#39;&#xA;&#xA;  def perform(args); end&#xA;end&#xA;&#xA;class WorkerTwo&#xA;  include Sidekiq::Worker&#xA;&#xA;  sidekiq_options unique_across_workers: true, queue: &#39;default&#39;&#xA;&#xA;  def perform(args); end&#xA;end&#xA;&#xA;&#xA;WorkerOne.perform_async(1)&#xA;# =&amp;gt; &#39;the jobs unique id&#39;&#xA;&#xA;WorkerTwo.perform_async(1)&#xA;# =&amp;gt; nil because WorkerOne just stole the lock&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Finer Control over Uniqueness&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes it is desired to have a finer control over which arguments are used in determining uniqueness of the job, and others may be &lt;em&gt;transient&lt;/em&gt;. For this use-case, you need to define either a &lt;code&gt;lock_args&lt;/code&gt; method, or a ruby proc.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE:&lt;/em&gt; The lock_args method need to return an array of values to use for uniqueness check.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE:&lt;/em&gt; The arguments passed to the proc or the method is always an array. If your method takes a single array as argument the value of args will be &lt;code&gt;[[...]]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The method or the proc can return a modified version of args without the transient arguments included, as shown below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UniqueJobWithFilterMethod&#xA;  include Sidekiq::Worker&#xA;  sidekiq_options lock: :until_and_while_executing,&#xA;                  lock_args_method: :lock_args # this is default and will be used if such a method is defined&#xA;&#xA;  def self.lock_args(args)&#xA;    [ args[0], args[2][:type] ]&#xA;  end&#xA;&#xA;  ...&#xA;&#xA;end&#xA;&#xA;class UniqueJobWithFilterProc&#xA;  include Sidekiq::Worker&#xA;  sidekiq_options lock: :until_executed,&#xA;                  lock_args_method: -&amp;gt;(args) { [ args.first ] }&#xA;&#xA;  ...&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is possible to ensure different types of unique args based on context. I can&#39;t vouch for the below example but see &lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/issues/203&#34;&gt;#203&lt;/a&gt; for the discussion.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UniqueJobWithFilterMethod&#xA;  include Sidekiq::Worker&#xA;  sidekiq_options lock: :until_and_while_executing, lock_args_method: :lock_args&#xA;&#xA;  def self.lock_args(args)&#xA;    if Sidekiq::ProcessSet.new.size &amp;gt; 1&#xA;      # sidekiq runtime; uniqueness for the object (first arg)&#xA;      args.first&#xA;    else&#xA;      # queuing from the app; uniqueness for all params&#xA;      args&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;After Unlock Callback&lt;/h3&gt; &#xA;&lt;p&gt;If you need to perform any additional work after the lock has been released you can provide an &lt;code&gt;#after_unlock&lt;/code&gt; instance method. The method will be called when the lock has been unlocked. Most times this means after yield but there are two exceptions to that.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Exception 1:&lt;/strong&gt; UntilExecuting unlocks and uses callback before yielding. &lt;strong&gt;Exception 2:&lt;/strong&gt; UntilExpired expires eventually, no after_unlock hook is called.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; &lt;em&gt;It is also possible to write this code as a class method.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UniqueJobWithFilterMethod&#xA;  include Sidekiq::Worker&#xA;  sidekiq_options lock: :while_executing,&#xA;&#xA;  def self.after_unlock&#xA;   # block has yielded and lock is released&#xA;  end&#xA;&#xA;  def after_unlock&#xA;   # block has yielded and lock is released&#xA;  end&#xA;  ...&#xA;end.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Communication&lt;/h2&gt; &#xA;&lt;p&gt;There is a &lt;a href=&#34;https://gitter.im/mhenrixon/sidekiq-unique-jobs?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/mhenrixon/sidekiq-unique-jobs.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/mhenrixon/sidekiq-unique-jobs&#34;&gt;&lt;/a&gt; for praise or scorn. This would be a good place to have lengthy discuss or brilliant suggestions or simply just nudge me if I forget about anything.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork it&lt;/li&gt; &#xA; &lt;li&gt;Create your feature branch (&lt;code&gt;git checkout -b my-new-feature&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Commit your changes (&lt;code&gt;git commit -am &#39;Add some feature&#39;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Push to the branch (&lt;code&gt;git push origin my-new-feature&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Create new Pull Request&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;You can find a list of contributors over on &lt;a href=&#34;https://github.com/mhenrixon/sidekiq-unique-jobs/graphs/contributors&#34;&gt;Contributors&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>