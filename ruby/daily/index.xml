<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-17T01:39:01Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>postrank-labs/goliath</title>
    <updated>2023-10-17T01:39:01Z</updated>
    <id>tag:github.com,2023-10-17:/postrank-labs/goliath</id>
    <link href="https://github.com/postrank-labs/goliath" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Goliath is a non-blocking Ruby web server framework&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Goliath&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://travis-ci.org/postrank-labs/goliath&#34;&gt;&lt;img src=&#34;https://secure.travis-ci.org/postrank-labs/goliath.png?travis&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gemnasium.com/postrank-labs/goliath&#34;&gt;&lt;img src=&#34;https://gemnasium.com/postrank-labs/goliath.png?travis&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Goliath is an open source version of the non-blocking (asynchronous) Ruby web server framework. It is a lightweight framework designed to meet the following goals: bare metal performance, Rack API and middleware support, simple configuration, fully asynchronous processing, and readable and maintainable code (read: no callbacks).&lt;/p&gt; &#xA;&lt;p&gt;The framework is powered by an EventMachine reactor, a high-performance HTTP parser and Ruby 1.9+ runtime. The one major advantage Goliath has over other asynchronous frameworks is the fact that by leveraging Ruby fibers introduced in Ruby 1.9+, it can untangle the complicated callback-based code into a format we are all familiar and comfortable with: linear execution, which leads to more maintainable and readable code.&lt;/p&gt; &#xA;&lt;p&gt;Each HTTP request within Goliath is executed within its own Ruby fiber and all asynchronous I/O operations can transparently suspend and later resume the processing without requiring the developer to write any additional code. Both request processing and response processing can be done in fully asynchronous fashion: streaming uploads, firehose API&#39;s, request/response, websockets, and so on.&lt;/p&gt; &#xA;&lt;h2&gt;Installation &amp;amp; Prerequisites&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install Ruby 1.9 (via RVM or natively)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$&amp;gt; gem install rvm&#xA;$&amp;gt; rvm install 1.9.3&#xA;$&amp;gt; rvm use 1.9.3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install Goliath:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$&amp;gt; gem install goliath&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Started: Hello World&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;goliath&#39;&#xA;&#xA;class Hello &amp;lt; Goliath::API&#xA;  def response(env)&#xA;    [200, {}, &#34;Hello World&#34;]&#xA;  end&#xA;end&#xA;&#xA;&amp;gt; ruby hello.rb -sv&#xA;&amp;gt; [97570:INFO] 2011-02-15 00:33:51 :: Starting server on 0.0.0.0:9000 in development mode. Watch out for stones.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See examples directory for more hands-on examples of building Goliath powered web-services.&lt;/p&gt; &#xA;&lt;h2&gt;Performance: MRI, JRuby, Rubinius&lt;/h2&gt; &#xA;&lt;p&gt;Goliath is not tied to a single Ruby runtime - it is able to run on MRI Ruby, JRuby and Rubinius today. Depending on which platform you are working with, you will see different performance characteristics. At the moment, we recommend MRI Ruby 1.9.3+ as the best performing VM: a roundtrip through the full Goliath stack on MRI 1.9.3 takes ~0.33ms (~3000 req/s).&lt;/p&gt; &#xA;&lt;p&gt;Goliath has been used in production environments for 2+ years, across many different companies: PostRank (now Google), &lt;a href=&#34;https://raw.githubusercontent.com/postrank-labs/goliath/master/OMGPOP&#34;&gt;OMGPOP&lt;/a&gt; (now Zynga), &lt;a href=&#34;http://www.poweredbygamespy.com/2011/09/09/growing-pains-they-hurt-so-good/&#34;&gt;GameSpy&lt;/a&gt;, and many others.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;How does Goliath compare to other Ruby async app-servers like Thin?&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;They are similar (both use Eventmachine reactor), but also very different. Goliath is able to run on different Ruby platforms (see above), uses a different HTTP parser, supports HTTP keepalive &amp;amp; pipelining, and offers a fully asynchronous API for both request and response processing.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;How does Goliath compare to Mongrel, Passenger, Unicorn?&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Mongrel is a threaded web-server, and both Passenger and Unicorn fork an entire VM to isolate each request from each other. By contrast, Goliath builds a single instance of the Rack app and runs all requests in parallel through a single VM, which leads to a much smaller memory footprint and less overhead.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;How do I deploy Goliath in production?&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;We recommend deploying Goliath behind a reverse proxy such as HAProxy (&lt;a href=&#34;https://github.com/postrank-labs/goliath/wiki/HAProxy&#34;&gt;sample config&lt;/a&gt;), Nginx or equivalent. Using one of the above, you can easily run multiple instances of the same application and load balance between them within the reverse proxy.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Guides&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/postrank-labs/goliath/wiki/Server&#34;&gt;Server Options&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/postrank-labs/goliath/wiki/Middleware&#34;&gt;Middleware&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/postrank-labs/goliath/wiki/Configuration&#34;&gt;Configuration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/postrank-labs/goliath/wiki/Plugins&#34;&gt;Plugins&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/postrank-labs/goliath/wiki/Zero-downtime-restart&#34;&gt;Zero Downtime Restart&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Hands-on applications:&lt;/h3&gt; &#xA;&lt;p&gt;If you are you new to EventMachine, or want a detailed walk-through of building a Goliath powered API? You&#39;re in luck, a super-awesome Pluralsight screencast which will teach you all you need to know:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.pluralsight.com/courses/meet-eventmachine&#34;&gt;Meet EventMachine&lt;/a&gt; - introduction to EM, Fibers, building an API with Goliath&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Additionally, you can also watch this presentation from GoGaRuCo 2011, which describes the design and motivation behind Goliath:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://confreaks.com/videos/653-gogaruco2011-0-60-with-goliath-building-high-performance-ruby-web-services&#34;&gt;0-60 with Goliath: Building high performance web services&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Other resources:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/postrank-labs/goliath/wiki/Asynchronous-Processing&#34;&gt;Asynchronous HTTP, MySQL, etc&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/postrank-labs/goliath/wiki/Streaming&#34;&gt;Response streaming with Goliath&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/postrank-labs/goliath/tree/master/examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Discussion and Support&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/postrank-labs/goliath&#34;&gt;Source&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/postrank-labs/goliath/issues&#34;&gt;Issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://groups.google.com/group/goliath-io&#34;&gt;Mailing List&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License &amp;amp; Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;Goliath is distributed under the MIT license, for full details please see the LICENSE file.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>heartcombo/responders</title>
    <updated>2023-10-17T01:39:01Z</updated>
    <id>tag:github.com,2023-10-17:/heartcombo/responders</id>
    <link href="https://github.com/heartcombo/responders" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A set of Rails responders to dry up your application&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Responders&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://badge.fury.io/rb/responders&#34;&gt;&lt;img src=&#34;https://fury-badge.herokuapp.com/rb/responders.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A set of responders modules to dry up your Rails app.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add the responders gem to your Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gem &#34;responders&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Update your bundle and run the install generator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bundle install&#xA;$ rails g responders:install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are including this gem to support backwards compatibilty for responders in previous releases of Rails, you only need to include the gem and bundle.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Responders Types&lt;/h2&gt; &#xA;&lt;h3&gt;FlashResponder&lt;/h3&gt; &#xA;&lt;p&gt;Sets the flash based on the controller action and resource status. For instance, if you do: &lt;code&gt;respond_with(@post)&lt;/code&gt; on a POST request and the resource &lt;code&gt;@post&lt;/code&gt; does not contain errors, it will automatically set the flash message to &lt;code&gt;&#34;Post was successfully created&#34;&lt;/code&gt; as long as you configure your I18n file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  flash:&#xA;    actions:&#xA;      create:&#xA;        notice: &#34;%{resource_name} was successfully created.&#34;&#xA;      update:&#xA;        notice: &#34;%{resource_name} was successfully updated.&#34;&#xA;      destroy:&#xA;        notice: &#34;%{resource_name} was successfully destroyed.&#34;&#xA;        alert: &#34;%{resource_name} could not be destroyed.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case the resource contains errors, you should use the failure key on I18n. This is useful to dry up flash messages from your controllers. Note: by default alerts for &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt; actions are commented in generated I18n file. If you need a specific message for a controller, let&#39;s say, for &lt;code&gt;PostsController&lt;/code&gt;, you can also do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  flash:&#xA;    posts:&#xA;      create:&#xA;        notice: &#34;Your post was created and will be published soon&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This responder is activated in all non get requests. By default it will use the keys &lt;code&gt;:notice&lt;/code&gt; and &lt;code&gt;:alert&lt;/code&gt;, but they can be changed in your application:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.responders.flash_keys = [ :success, :failure ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also have embedded HTML. Just create a &lt;code&gt;_html&lt;/code&gt; scope.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  flash:&#xA;    actions:&#xA;      create:&#xA;        alert_html: &#34;&amp;lt;strong&amp;gt;OH NOES!&amp;lt;/strong&amp;gt; You did it wrong!&#34;&#xA;    posts:&#xA;      create:&#xA;        notice_html: &#34;&amp;lt;strong&amp;gt;Yay!&amp;lt;/strong&amp;gt; You did it!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See also the &lt;code&gt;namespace_lookup&lt;/code&gt; option to search the full hierarchy of possible keys.&lt;/p&gt; &#xA;&lt;h3&gt;HttpCacheResponder&lt;/h3&gt; &#xA;&lt;p&gt;Automatically adds Last-Modified headers to API requests. This allows clients to easily query the server if a resource changed and if the client tries to retrieve a resource that has not been modified, it returns not_modified status.&lt;/p&gt; &#xA;&lt;h3&gt;CollectionResponder&lt;/h3&gt; &#xA;&lt;p&gt;Makes your create and update action redirect to the collection on success.&lt;/p&gt; &#xA;&lt;h3&gt;LocationResponder&lt;/h3&gt; &#xA;&lt;p&gt;This responder allows you to use callable objects as the redirect location. Useful when you want to use the &lt;code&gt;respond_with&lt;/code&gt; method with a custom route that requires persisted objects, but the validation may fail.&lt;/p&gt; &#xA;&lt;p&gt;Note: this responder is included by default, and doesn&#39;t need to be included on the top of your controller (including it will issue a deprecation warning).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ThingsController &amp;lt; ApplicationController&#xA;  respond_to :html&#xA;&#xA;  def create&#xA;    @thing = Thing.create(params[:thing])&#xA;    respond_with @thing, location: -&amp;gt; { thing_path(@thing) }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Dealing with namespaced routes&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;In order for the LocationResponder to find the correct route helper for namespaced routes you need to pass the namespaces to &lt;code&gt;respond_with&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Api::V1::ThingsController &amp;lt; ApplicationController&#xA;  respond_to :json&#xA;&#xA;  # POST /api/v1/things&#xA;  def create&#xA;    @thing = Thing.create(thing_params)&#xA;    respond_with :api, :v1, @thing&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuring your own responder&lt;/h2&gt; &#xA;&lt;p&gt;Responders only provides a set of modules and to use them you have to create your own responder. After you run the install command, the following responder will be generated in your application:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# lib/application_responder.rb&#xA;class ApplicationResponder &amp;lt; ActionController::Responder&#xA;  include Responders::FlashResponder&#xA;  include Responders::HttpCacheResponder&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Your application also needs to be configured to use it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/application_controller.rb&#xA;require &#34;application_responder&#34;&#xA;&#xA;class ApplicationController &amp;lt; ActionController::Base&#xA;  self.responder = ApplicationResponder&#xA;  respond_to :html&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Controller method&lt;/h2&gt; &#xA;&lt;p&gt;This gem also includes the controller method &lt;code&gt;responders&lt;/code&gt;, which allows you to cherry-pick which responders you want included in your controller.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class InvitationsController &amp;lt; ApplicationController&#xA;  responders :flash, :http_cache&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Interpolation Options&lt;/h2&gt; &#xA;&lt;p&gt;You can pass in extra interpolation options for the translation by adding an &lt;code&gt;flash_interpolation_options&lt;/code&gt; method to your controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class InvitationsController &amp;lt; ApplicationController&#xA;  responders :flash, :http_cache&#xA;&#xA;  def create&#xA;    @invitation = Invitation.create(params[:invitation])&#xA;    respond_with @invitation&#xA;  end&#xA;&#xA;  private&#xA;&#xA;  def flash_interpolation_options&#xA;    { resource_name: @invitation.email }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you would see the message &lt;code&gt;&#34;name@example.com was successfully created&#34;&lt;/code&gt; instead of the default &lt;code&gt;&#34;Invitation was successfully created.&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Generator&lt;/h2&gt; &#xA;&lt;p&gt;This gem also includes a responders controller generator, so your scaffold can be customized to use &lt;code&gt;respond_with&lt;/code&gt; instead of default &lt;code&gt;respond_to&lt;/code&gt; blocks. From 2.1, you need to explicitly opt-in to use this generator by adding the following to your &lt;code&gt;config/application.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.app_generators.scaffold_controller :responders_controller&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Failure handling&lt;/h2&gt; &#xA;&lt;p&gt;Responders don&#39;t use &lt;code&gt;valid?&lt;/code&gt; to check for errors in models to figure out if the request was successful or not, and relies on your controllers to call &lt;code&gt;save&lt;/code&gt; or &lt;code&gt;create&lt;/code&gt; to trigger the validations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def create&#xA;  @widget = Widget.new(widget_params)&#xA;  # @widget will be a valid record for responders, as we haven&#39;t called `save`&#xA;  # on it, and will always redirect to the `widgets_path`.&#xA;  respond_with @widget, location: -&amp;gt; { widgets_path }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Responders will check if the &lt;code&gt;errors&lt;/code&gt; object in your model is empty or not. Take this in consideration when implementing different actions or writing test assertions on this behavior for your controllers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def create&#xA;  @widget = Widget.new(widget_params)&#xA;  @widget.errors.add(:base, :invalid)&#xA;  # `respond_with` will render the `new` template again,&#xA;  # and set the status based on the configured `error_status`.&#xA;  respond_with @widget&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Verifying request formats&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;respond_with&lt;/code&gt; will raise an &lt;code&gt;ActionController::UnknownFormat&lt;/code&gt; if the request MIME type was not configured through the class level &lt;code&gt;respond_to&lt;/code&gt;, but the action will still be executed and any side effects (like creating a new record) will still occur. To raise the &lt;code&gt;UnknownFormat&lt;/code&gt; exception before your action is invoked you can set the &lt;code&gt;verify_requested_format!&lt;/code&gt; method as a &lt;code&gt;before_action&lt;/code&gt; on your controller.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class WidgetsController &amp;lt; ApplicationController&#xA;  respond_to :json&#xA;  before_action :verify_requested_format!&#xA;&#xA;  # POST /widgets.html won&#39;t reach the `create` action.&#xA;  def create&#xA;    widget = Widget.create(widget_params)&#xA;    respond_with widget&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuring error and redirect statuses&lt;/h2&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;respond_with&lt;/code&gt; will respond to errors on &lt;code&gt;HTML&lt;/code&gt; &amp;amp; &lt;code&gt;JS&lt;/code&gt; requests using the HTTP status code &lt;code&gt;200 OK&lt;/code&gt;, and perform redirects using the HTTP status code &lt;code&gt;302 Found&lt;/code&gt;, both for backwards compatibility reasons.&lt;/p&gt; &#xA;&lt;p&gt;You can configure this behavior by setting &lt;code&gt;config.responders.error_status&lt;/code&gt; and &lt;code&gt;config.responders.redirect_status&lt;/code&gt; to the desired status codes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.responders.error_status = :unprocessable_entity&#xA;config.responders.redirect_status = :see_other&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These can also be set in your custom &lt;code&gt;ApplicationResponder&lt;/code&gt; if you have generated one: (see install instructions)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationResponder &amp;lt; ActionController::Responder&#xA;  self.error_status = :unprocessable_entity&#xA;  self.redirect_status = :see_other&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: the application responder generated for new apps already configures a different set of defaults: &lt;code&gt;422 Unprocessable Entity&lt;/code&gt; for errors, and &lt;code&gt;303 See Other&lt;/code&gt; for redirects. &lt;em&gt;Responders may change the defaults to match these in a future major release.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Hotwire/Turbo and fetch APIs&lt;/h3&gt; &#xA;&lt;p&gt;Hotwire/Turbo expects successful redirects after form submissions to respond with HTTP status &lt;code&gt;303 See Other&lt;/code&gt;, and error responses to be 4xx or 5xx statuses, for example &lt;code&gt;422 Unprocessable Entity&lt;/code&gt; for displaying form validation errors and &lt;code&gt;500 Internal Server Error&lt;/code&gt; for other server errors. &lt;a href=&#34;https://turbo.hotwired.dev/handbook/drive#redirecting-after-a-form-submission&#34;&gt;Turbo documentation: Redirecting After a Form Submission&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The example configuration showed above matches the statuses that better integrate with Hotwire/Turbo.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Want more examples ? Check out these blog posts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://blog.plataformatec.com.br/2009/08/embracing-rest-with-mind-body-and-soul/&#34;&gt;Embracing REST with mind, body and soul&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://weblog.rubyonrails.org/2009/8/31/three-reasons-love-responder/&#34;&gt;Three reasons to love ActionController::Responder&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://web.archive.org/web/20201109041436/https://blog.engineyard.com/my-five-favorite-things-about-rails-3&#34;&gt;My five favorite things about Rails 3&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Supported Ruby / Rails versions&lt;/h2&gt; &#xA;&lt;p&gt;We intend to maintain support for all Ruby / Rails versions that haven&#39;t reached end-of-life.&lt;/p&gt; &#xA;&lt;p&gt;For more information about specific versions please check &lt;a href=&#34;https://www.ruby-lang.org/en/downloads/branches/&#34;&gt;Ruby&lt;/a&gt; and &lt;a href=&#34;https://guides.rubyonrails.org/maintenance_policy.html&#34;&gt;Rails&lt;/a&gt; maintenance policies, and our test matrix.&lt;/p&gt; &#xA;&lt;h2&gt;Bugs and Feedback&lt;/h2&gt; &#xA;&lt;p&gt;If you discover any bugs or want to drop a line, feel free to create an issue on GitHub.&lt;/p&gt; &#xA;&lt;p&gt;MIT License. Copyright 2020-2023 Rafael França, Carlos Antônio da Silva. Copyright 2009-2019 Plataformatec.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>yshmarov/hotwire-cookbook</title>
    <updated>2023-10-17T01:39:01Z</updated>
    <id>tag:github.com,2023-10-17:/yshmarov/hotwire-cookbook</id>
    <link href="https://github.com/yshmarov/hotwire-cookbook" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rails World Hotwire Cookbook. VIEW THE PULL REQUESTS&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;README&lt;/h1&gt; &#xA;&lt;p&gt;This README would normally document whatever steps are necessary to get the application up and running.&lt;/p&gt; &#xA;&lt;p&gt;Things you may want to cover:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Ruby version&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;System dependencies&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Configuration&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Database creation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Database initialization&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;How to run the test suite&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Services (job queues, cache servers, search engines, etc.)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Deployment instructions&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;...&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>