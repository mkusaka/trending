<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-17T01:44:23Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>testdouble/mocktail</title>
    <updated>2023-07-17T01:44:23Z</updated>
    <id>tag:github.com,2023-07-17:/testdouble/mocktail</id>
    <link href="https://github.com/testdouble/mocktail" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/79303/134366631-9c6cfe67-a9c0-4096-bbea-ba1698a85b0b.png&#34; width=&#34;90%&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Mocktail üç∏&lt;/h1&gt; &#xA;&lt;p&gt;Mocktail is a &lt;a href=&#34;https://github.com/testdouble/contributing-tests/wiki/Test-Double&#34;&gt;test double&lt;/a&gt; library for Ruby that provides a terse and robust API for creating mocks, getting them in the hands of the code you&#39;re testing, stub &amp;amp; verify behavior, and even safely override class methods.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;d prefer a voice &amp;amp; video introduction to Mocktail aside from this README, you might enjoy this ‚ö°Ô∏è&lt;a href=&#34;https://blog.testdouble.com/talks/2022-05-18-please-mock-me?utm_source=twitter&amp;amp;utm_medium=organic-social&amp;amp;utm_campaign=conf-talk&#34;&gt;Lightning Talk&lt;/a&gt;‚ö°Ô∏è from RailsConf 2022.&lt;/p&gt; &#xA;&lt;h2&gt;An aperitif&lt;/h2&gt; &#xA;&lt;p&gt;Before getting into the details, let&#39;s demonstrate what Mocktail&#39;s API looks like. Suppose you want to test a &lt;code&gt;Bartender&lt;/code&gt; class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Bartender&#xA;  def initialize&#xA;    @shaker = Shaker.new&#xA;    @glass = Glass.new&#xA;    @bar = Bar.new&#xA;  end&#xA;&#xA;  def make_drink(name, customer:)&#xA;    if name == :negroni&#xA;      drink = @shaker.combine(:gin, :campari, :sweet_vermouth)&#xA;      @glass.pour!(drink)&#xA;      @bar.pass(@glass, to: customer)&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You could write an isolated unit test with Mocktail like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;shaker = Mocktail.of_next(Shaker)&#xA;glass = Mocktail.of_next(Glass)&#xA;bar = Mocktail.of_next(Bar)&#xA;subject = Bartender.new&#xA;stubs { shaker.combine(:gin, :campari, :sweet_vermouth) }.with { :a_drink }&#xA;stubs { bar.pass(glass, to: &#34;Eileen&#34;) }.with { &#34;üéâ&#34; }&#xA;&#xA;result = subject.make_drink(:negroni, customer: &#34;Eileen&#34;)&#xA;&#xA;assert_equal &#34;üéâ&#34;, result&#xA;# Oh yeah, and make sure the drink got poured! Silly side effects!&#xA;verify { glass.pour!(:a_drink) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Why Mocktail?&lt;/h2&gt; &#xA;&lt;p&gt;Besides helping you avoid a hangover, Mocktail offers several advantages over Ruby&#39;s other mocking libraries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Simpler test recipes&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/testdouble/mocktail/main/#mocktailof_next&#34;&gt;Mocktail.of_next(type)&lt;/a&gt; both creates your mock and supplies to your subject under test in a single one-liner. No more forcing dependency injection for the sake of your tests&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;WYSIWYG API&lt;/strong&gt;: Want to know how to stub a call to &lt;code&gt;phone.dial(911)&lt;/code&gt;? You just demonstrate the call with &lt;code&gt;stubs { phone.dial(911) }.with { :operator }&lt;/code&gt;. Because stubbing &amp;amp; verifying looks just like the actual call, your tests becomes a sounding board for your APIs as you invent them&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Argument validation&lt;/strong&gt;: Ever see a test pass after a change to a mocked method should have broken it? Not with Mocktail, you haven&#39;t&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Mocked class methods&lt;/strong&gt;: Singleton methods on modules and classes can be faked out using &lt;a href=&#34;https://raw.githubusercontent.com/testdouble/mocktail/main/#mocktailreplace&#34;&gt;&lt;code&gt;Mocktail.replace(type)&lt;/code&gt;&lt;/a&gt; without sacrificing thread safety&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Super-duper detailed error messages&lt;/strong&gt; A good mocking library should make coding feel like &lt;a href=&#34;https://en.wikipedia.org/wiki/Paint_by_number&#34;&gt;paint-by-number&lt;/a&gt;, thoughtfully guiding you from one step to the next. Calling a method that doesn&#39;t exist will print a sample definition you can copy-paste. Verification failures will print every call that &lt;em&gt;did&lt;/em&gt; occur. And &lt;a href=&#34;https://raw.githubusercontent.com/testdouble/mocktail/main/#mocktailexplain&#34;&gt;Mocktail.explain()&lt;/a&gt; provides even more introspection&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Expressive&lt;/strong&gt;: Built-in &lt;a href=&#34;https://raw.githubusercontent.com/testdouble/mocktail/main/#mocktailmatchers&#34;&gt;argument matchers&lt;/a&gt; and a simple API for adding &lt;a href=&#34;https://raw.githubusercontent.com/testdouble/mocktail/main/#custom-matchers&#34;&gt;custom matchers&lt;/a&gt; allow you to tune your stubbing configuration and call verification to match &lt;em&gt;exactly&lt;/em&gt; what your test intends&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Powerful&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/testdouble/mocktail/main/#mocktailcaptor&#34;&gt;Argument captors&lt;/a&gt; for assertions of very complex arguments, as well as advanced configuration options for stubbing &amp;amp; verification&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Ready to order?&lt;/h2&gt; &#xA;&lt;h3&gt;Install the gem&lt;/h3&gt; &#xA;&lt;p&gt;The main ingredient to add to your Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;mocktail&#34;, group: :test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sprinkle in the DSL&lt;/h3&gt; &#xA;&lt;p&gt;Then, in each of your tests or in a test helper, you&#39;ll probably want to include Mocktail&#39;s DSL. (This is optional, however, as every method in the DSL is also available as a singleton method on &lt;code&gt;Mocktail&lt;/code&gt;.)&lt;/p&gt; &#xA;&lt;p&gt;In Minitest, you might add the DSL with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Minitest::Test&#xA;  include Mocktail::DSL&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, in RSpec:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;RSpec.configure do |config|&#xA;  config.include Mocktail::DSL&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Clean up when you&#39;re done&lt;/h3&gt; &#xA;&lt;p&gt;To reset Mocktail&#39;s internal state between tests and avoid test pollution, you should also call &lt;code&gt;Mocktail.reset&lt;/code&gt; after each test:&lt;/p&gt; &#xA;&lt;p&gt;In Minitest:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Minitest::Test&#xA;  # Or, if in a Rails test, in a `teardown do‚Ä¶end` block&#xA;  def teardown&#xA;    Mocktail.reset&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And RSpec:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;RSpec.configure do |config|&#xA;  config.after(:each) do&#xA;    Mocktail.reset&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;p&gt;The entire public API is listed in the &lt;a href=&#34;https://raw.githubusercontent.com/testdouble/mocktail/main/lib/mocktail.rb&#34;&gt;top-level module&#39;s source&lt;/a&gt;. Below is a longer menu to explain what goes into each feature.&lt;/p&gt; &#xA;&lt;h3&gt;Mocktail.of&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Mocktail.of(module_or_class)&lt;/code&gt; takes a module or class and returns an instance of an object with fake methods in place of all its instance methods which can then be stubbed or verified.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Clothes; end;&#xA;class Shoe &amp;lt; Clothes&#xA;  def tie(laces)&#xA;  end&#xA;end&#xA;&#xA;shoe = Mocktail.of(Shoe)&#xA;shoe.instance_of?(Shoe) # =&amp;gt; true&#xA;shoe.is_a?(Clothes) # =&amp;gt; true&#xA;shoe.class == Shoe # =&amp;gt; false!&#xA;shoe.to_s # =&amp;gt; #&amp;lt;Mocktail of Shoe:0x00000001343b57b0&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Mocktail.of_next&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Mocktail.of_next(klass, [count: 1])&lt;/code&gt; takes a class and returns one mock (the default) or an array of multiple mocks. It also effectively overrides the behavior of that class&#39;s constructor to return those mock(s) in order and finally restoring its previous behavior.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you wanted to test the &lt;code&gt;Notifier&lt;/code&gt; class below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Notifier&#xA;  def initialize&#xA;    @mailer = Mailer.new&#xA;  end&#xA;&#xA;  def notify(name)&#xA;    @mailer.deliver!(&#34;Hello, #{name}&#34;)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You could write a test like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def test_notifier&#xA;  mailer = Mocktail.of_next(Mailer)&#xA;  subject = Notifier.new&#xA;&#xA;  subject.notify(&#34;Pants&#34;)&#xA;&#xA;  verify { mailer.deliver!(&#34;Hello, Pants&#34;) }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;s nothing wrong with creating mocks using &lt;code&gt;Mocktail.of&lt;/code&gt; and passing them to your subject some other way, but this approach allows you to write very terse isolation tests without foisting additional indirection or dependency injection in for your tests&#39; sake.&lt;/p&gt; &#xA;&lt;h3&gt;Mocktail.stubs&lt;/h3&gt; &#xA;&lt;p&gt;Configuring a fake method to take a certain action or return a particular value is called &#34;stubbing&#34;. To stub a call with a value, you can call &lt;code&gt;Mocktail.stubs&lt;/code&gt; (or just &lt;code&gt;stubs&lt;/code&gt; if you&#39;ve included &lt;code&gt;Mocktail::DSL&lt;/code&gt;) and then specify an effect that will be invoked whenever that call configuration is satisfied using &lt;code&gt;with&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The API is very simple in the simple case:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UserRepository&#xA;  def find(id, debug: false); end&#xA;&#xA;  def transaction(&amp;amp;blk); end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You could stub responses to a mock of the &lt;code&gt;UserRepository&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;user_repository = Mocktail.of(UserRepository)&#xA;&#xA;stubs { user_repository.find(42) }.with { :a_user }&#xA;user_repository.find(42) # =&amp;gt; :a_user&#xA;user_repository.find(43) # =&amp;gt; nil&#xA;user_repository.find # =&amp;gt; ArgumentError: wrong number of arguments (given 0, expected 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The block passed to &lt;code&gt;stubs&lt;/code&gt; is called the &#34;demonstration&#34;, because it represents an example of the kind of calls that Mocktail should match.&lt;/p&gt; &#xA;&lt;p&gt;If you want to get fancy, you can use matchers to make your demonstration more dynamic. For example, you could match any number with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stubs { |m| user_repository.find(m.numeric) }.with { :another_user }&#xA;user_repository.find(41) # =&amp;gt; :another_user&#xA;user_repository.find(42) # =&amp;gt; :another_user&#xA;user_repository.find(43) # =&amp;gt; :another_user&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Stubbings are last-in-wins, which is why the stubbing above would have overridden the earlier-but-more-specific stubbing of &lt;code&gt;find(42)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A stubbing&#39;s effect can also be changed dynamically based on the actual call that satisfied the demonstration by looking at the &lt;code&gt;call&lt;/code&gt; block argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stubs { |m| user_repository.find(m.is_a(Integer)) }.with { |call|&#xA;  {id: call.args.first}&#xA;}&#xA;user_repository.find(41) # =&amp;gt; {id: 41}&#xA;# Since 42.5 is a Float, the earlier stubbing will win here:&#xA;user_repository.find(42.5) # =&amp;gt; :another_user&#xA;user_repository.find(43) # =&amp;gt; {id: 43}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s certainly more complex to think through, but if your stubbed method takes a block, your demonstration can pass a block of its own and inspect or invoke it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stubs {&#xA;  user_repository.transaction { |block| block.call == {id: 41} }&#xA;}.with { :successful_transaction }&#xA;&#xA;user_repository.transaction {&#xA;  user_repository.find(41)&#xA;} # =&amp;gt; :successful_transaction&#xA;user_repository.transaction {&#xA;  user_repository.find(40)&#xA;} # =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are also several advanced options you can pass to &lt;code&gt;stubs&lt;/code&gt; to control its behavior.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;times&lt;/code&gt; will limit the number of times a satisfied stubbing can have its effect:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stubs { |m| user_repository.find(m.any) }.with { :not_found }&#xA;stubs(times: 2) { |m| user_repository.find(1) }.with { :someone }&#xA;&#xA;user_repository.find(1) # =&amp;gt; :someone&#xA;user_repository.find(1) # =&amp;gt; :someone&#xA;user_repository.find(1) # =&amp;gt; :not_found&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;ignore_extra_args&lt;/code&gt; will allow a demonstration to be considered satisfied even if it fails to specify arguments and keyword arguments made by the actual call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stubs { user_repository.find(4) }.with { :a_person }&#xA;user_repository.find(4, debug: true) # =&amp;gt; nil&#xA;&#xA;stubs(ignore_extra_args: true) { user_repository.find(4) }.with { :b_person }&#xA;user_repository.find(4, debug: true) # =&amp;gt; :b_person&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And &lt;code&gt;ignore_block&lt;/code&gt; will similarly allow a demonstration to not concern itself with whether an actual call passed the method a block‚Äîit&#39;s satisfied either way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stubs { user_repository.transaction }.with { :transaction }&#xA;user_repository.transaction {} # =&amp;gt; nil&#xA;&#xA;stubs(ignore_block: true) { user_repository.transaction }.with { :transaction }&#xA;user_repository.transaction {} # =&amp;gt; :transaction&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Mocktail.verify&lt;/h3&gt; &#xA;&lt;p&gt;In practice, we&#39;ve found that we stub far more responses than we explicitly verify a particular call took place. That&#39;s because our code normally returns some observable value that is &lt;em&gt;influenced&lt;/em&gt; by our dependencies&#39; behavior, so adding additional assertions that they be called would be redundant. That said, for cases where a dependency doesn&#39;t return a value but just has a necessary side effect, the &lt;code&gt;verify&lt;/code&gt; method exists (and like &lt;code&gt;stubs&lt;/code&gt; is included in &lt;code&gt;Mocktail::DSL&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Once you&#39;ve gotten the hang of stubbing, you&#39;ll find that the &lt;code&gt;verify&lt;/code&gt; method is intentionally very similar. They almost rhyme.&lt;/p&gt; &#xA;&lt;p&gt;For this example, consider an &lt;code&gt;Auditor&lt;/code&gt; class that our code might need to call to record that certain actions took place.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Auditor&#xA;  def record!(message, user_id:, action: nil); end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you&#39;ve created a mock of the &lt;code&gt;Auditor&lt;/code&gt;, you can start verifying basic calls:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;auditor = Mocktail.of(Auditor)&#xA;&#xA;verify { auditor.record!(&#34;hello&#34;, user_id: 42) }&#xA;# =&amp;gt; raised Mocktail::VerificationError&#xA;# Expected mocktail of Auditor#record! to be called like:&#xA;#&#xA;#   record!(&#34;hello&#34;, user_id: 42)&#xA;#&#xA;# But it was never called.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Wups! Verify will blow up whenever a matching call hasn&#39;t occurred, so it should be called after you&#39;ve invoked your subject under test along with any other assertions you have.&lt;/p&gt; &#xA;&lt;p&gt;If we make a call that satisfies the &lt;code&gt;verify&lt;/code&gt; call&#39;s demonstration, however, you won&#39;t see that error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;auditor.record!(&#34;hello&#34;, user_id: 42)&#xA;&#xA;verify { auditor.record!(&#34;hello&#34;, user_id: 42) } # =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There, nothing happened! Just like any other assertion library, you only hear from &lt;code&gt;verify&lt;/code&gt; when verification fails.&lt;/p&gt; &#xA;&lt;p&gt;Just like with &lt;code&gt;stubs&lt;/code&gt;, you can any built-in or custom matchers can serve as garnishes for your demonstration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;auditor.record!(&#34;hello&#34;, user_id: 42)&#xA;&#xA;verify { |m| auditor.record!(m.is_a(String), user_id: m.numeric) } # =&amp;gt; nil&#xA;# But this will raise a VerificationError:&#xA;verify { |m| auditor.record!(m.is_a(String), user_id: m.that { |arg| arg &amp;gt; 50}) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you pass a block to your demonstration, it will be invoked with any block that was passed to the actual call to the mock. Truthy responses will satisfy the verification and falsey ones will fail:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;auditor.record!(&#34;ok&#34;, user_id: 1) { Time.new }&#xA;&#xA;verify { |m| auditor.record!(&#34;ok&#34;, user_id: 1) { |block| block.call.is_a?(Time) } } # =&amp;gt; nil&#xA;# But this will raise a VerificationError:&#xA;verify { |m| auditor.record!(&#34;ok&#34;, user_id: 1) { |block| block.call.is_a?(Date) } }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;verify&lt;/code&gt; supports the same options as &lt;code&gt;stubs&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;times&lt;/code&gt; will require the demonstrated call happened exactly &lt;code&gt;times&lt;/code&gt; times (by default, the call has to happen 1 or more times)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_extra_args&lt;/code&gt; will allow the demonstration to forego specifying optional arguments while still being considered satisfied&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_block&lt;/code&gt; will similarly allow the demonstration to forego specifying a block, even if the actual call receives one&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that if you want to verify a method &lt;em&gt;wasn&#39;t&lt;/em&gt; called at all or called a specific number of times‚Äîespecially if you don&#39;t care about the parameters, you may want to look at the &lt;a href=&#34;https://raw.githubusercontent.com/testdouble/mocktail/main/#mocktailcalls&#34;&gt;Mocktail.calls()&lt;/a&gt; API.&lt;/p&gt; &#xA;&lt;h3&gt;Mocktail.matchers&lt;/h3&gt; &#xA;&lt;p&gt;You&#39;ll probably never need to call &lt;code&gt;Mocktail.matchers&lt;/code&gt; directly, because it&#39;s the object that is passed to every demonstration block passed to &lt;code&gt;stubs&lt;/code&gt; and &lt;code&gt;verify&lt;/code&gt;. By default, a stubbing (e.g. &lt;code&gt;stubs { email.send(&#34;text&#34;) }&lt;/code&gt;) is only considered satisfied if every argument passed to an actual call was passed an &lt;code&gt;==&lt;/code&gt; check. Matchers allow us to relax or change that constraint for both regular arguments and keyword arguments so that our demonstrations can match more kinds of method invocations.&lt;/p&gt; &#xA;&lt;p&gt;Matchers allow you to specify stubbings and verifications that look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stubs { |m| email.send(m.is_a(String)) }.with { &#34;I&#39;m an email&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Built-in matchers&lt;/h4&gt; &#xA;&lt;p&gt;These matchers come out of the box:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;any&lt;/code&gt; - Will match any value (even nil) in the given argument position or keyword&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;is_a(type)&lt;/code&gt; - Will match when its &lt;code&gt;type&lt;/code&gt; passes an &lt;code&gt;is_a?&lt;/code&gt; check against the actual argument&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;includes(thing, [**more_things])&lt;/code&gt; - Will match when all of its arguments are contained by the corresponding argument‚Äîbe it a string, array, hash, or anything that responds to &lt;code&gt;includes?&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;matches(pattern)&lt;/code&gt; - Will match when the provided string or pattern passes a &lt;code&gt;match?&lt;/code&gt; test on the corresponding argument; usually used to match strings that contain a particular substring or pattern, but will work with any argument that responds to &lt;code&gt;match?&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;not(thing)&lt;/code&gt; - Will only match when its argument &lt;em&gt;does not&lt;/em&gt; equal (via &lt;code&gt;!=&lt;/code&gt;) the actual argument&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;numeric&lt;/code&gt; - Will match when the actual argument is an instance of &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, or (if loaded) &lt;code&gt;BigDecimal&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;that { |arg| ‚Ä¶ }&lt;/code&gt; - Takes a block that will receive the actual argument. If the block returns truthy, it&#39;s considered a match; otherwise, it&#39;s not a match.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Custom matchers&lt;/h4&gt; &#xA;&lt;p&gt;If you want to write your own matchers, check out &lt;a href=&#34;https://raw.githubusercontent.com/testdouble/mocktail/main/lib/mocktail/matchers/includes.rb&#34;&gt;the source for examples&lt;/a&gt;. Once you&#39;ve implemented a class, just pass it to &lt;code&gt;Mocktail.register_matcher&lt;/code&gt; in your test helper.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyAwesomeMatcher &amp;lt; Mocktail::Matchers::Base&#xA;  def self.matcher_name&#xA;    :awesome&#xA;  end&#xA;&#xA;  def match?(actual)&#xA;    &#34;#{@expected}‚ú®&#34; == actual&#xA;  end&#xA;end&#xA;&#xA;Mocktail.register_matcher(MyAwesomeMatcher)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, a stubbing like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;stubs { |m| user_repository.find(m.awesome(11)) }.with { :awesome_user }&#xA;&#xA;user_repository.find(&#34;11&#34;)) # =&amp;gt; nil&#xA;user_repository.find(&#34;11‚ú®&#34;)) # =&amp;gt; :awesome_user&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Mocktail.captor&lt;/h3&gt; &#xA;&lt;p&gt;An argument captor is a special kind of matcher‚Ä¶ really, it&#39;s a matcher factory. Suppose you have a &lt;code&gt;verify&lt;/code&gt; call for which one of the expected arguments is &lt;em&gt;really&lt;/em&gt; complicated. Since &lt;code&gt;verify&lt;/code&gt; tends to be paired with fire-and-forget APIs that are being invoked for the side effect, this is a pretty common case. You want to be able to effectively snag that value and then run any number of specific assertions against it.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s what &lt;code&gt;Mocktail.captor&lt;/code&gt; is for. It&#39;s easiest to make sense of this by example. Given this &lt;code&gt;BigApi&lt;/code&gt; class that&#39;s presumably being called by your subject at the end of a lot of other work building up a payload:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class BigApi&#xA;  def send(payload); end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You could capture the value of that payload as part of the verification of the call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;big_api = Mocktail.of(BigApi)&#xA;&#xA;big_api.send({imagine: &#34;that&#34;, this: &#34;is&#34;, a: &#34;huge&#34;, object: &#34;!&#34;})&#xA;&#xA;payload_captor = Mocktail.captor&#xA;verify { big_api.send(payload_captor.capture) } # =&amp;gt; nil!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;verify&lt;/code&gt; above will pass because &lt;em&gt;a&lt;/em&gt; call did happen, but we haven&#39;t asserted anything beyond that yet. What really happened is that &lt;code&gt;payload_captor.capture&lt;/code&gt; actually returned a matcher that will return true for any argument &lt;em&gt;while also sneakily storing a copy of the argument value&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s why we instantiated &lt;code&gt;payload_captor&lt;/code&gt; with &lt;code&gt;Mocktail.captor&lt;/code&gt; outside the demonstration block, so we can inspect its &lt;code&gt;value&lt;/code&gt; after the &lt;code&gt;verify&lt;/code&gt; call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;payload_captor = Mocktail.captor&#xA;verify { big_api.send(payload_captor.capture) } # =&amp;gt; nil!&#xA;&#xA;payload = payload_captor.value # {:imagine=&amp;gt;&#34;that&#34;, :this=&amp;gt;&#34;is&#34;, :a=&amp;gt;&#34;huge&#34;, :object=&amp;gt;&#34;!&#34;}&#xA;assert_equal &#34;huge&#34;, payload[:a]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Mocktail.replace&lt;/h3&gt; &#xA;&lt;p&gt;Mocktail was written to support isolated test-driven development, which usually results in a lot of boring classes and instance methods. But sometimes you need to mock singleton methods on classes or modules, and we support that too.&lt;/p&gt; &#xA;&lt;p&gt;When you call &lt;code&gt;Mocktail.replace(type)&lt;/code&gt;, all of the singleton methods on the provided type are replaced with fake methods available for stubbing and verification. It&#39;s really that simple.&lt;/p&gt; &#xA;&lt;p&gt;For example, if our &lt;code&gt;Bartender&lt;/code&gt; class has a class method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Bartender&#xA;  def self.cliche_greeting&#xA;    [&#34;It&#39;s 5 o&#39;clock somewhere!&#34;, &#34;Norm!&#34;].sample&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can replace the behavior of the overall class, and then stub how we&#39;d like it to respond, in our test:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Mocktail.replace(Bartender)&#xA;stubs { Bartender.cliche_greeting }.with { &#34;Norm!&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;strong&gt;Obligatory warning:&lt;/strong&gt; Mocktail does its best to ensure that other threads won&#39;t be affected when you replace the singleton methods on a type, but your mileage may very! Singleton methods are global and code that introspects or invokes a replaced method in a peculiar-enough way could lead to hard-to-track down bugs. (If this concerns you, then the fact that class methods are effectively global state may be a great reason not to rely too heavily on them!)]&lt;/p&gt; &#xA;&lt;h3&gt;Mocktail.explain&lt;/h3&gt; &#xA;&lt;p&gt;Test debugging is hard enough when there &lt;em&gt;aren&#39;t&lt;/em&gt; fake objects flying every which way, so Mocktail tries to make it a little easier on you. In addition to returning useful messages throughout the API, the gem also includes an introspection method &lt;code&gt;Mocktail.explain(thing)&lt;/code&gt;, which returns a human-readable &lt;code&gt;message&lt;/code&gt; and a &lt;code&gt;reference&lt;/code&gt; object with useful attributes (that vary depending on the type of fake &lt;code&gt;thing&lt;/code&gt; you pass in. Below are some things &lt;code&gt;explain()&lt;/code&gt; can do.&lt;/p&gt; &#xA;&lt;h4&gt;Fake instances created by Mocktail&lt;/h4&gt; &#xA;&lt;p&gt;Any instances created by &lt;code&gt;Mocktail.of&lt;/code&gt; or &lt;code&gt;Mocktail.of_next&lt;/code&gt; can be passed to &lt;code&gt;Mocktail.explain&lt;/code&gt;, and they will list out all the calls and stubbings made for each of their fake methods.&lt;/p&gt; &#xA;&lt;p&gt;Suppose these interactions have occurred:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ice_tray = Mocktail.of(IceTray)&#xA;&#xA;Mocktail.stubs { ice_tray.fill(:tap_water, 30) }.with { :some_ice }&#xA;&#xA;ice_tray.fill(:tap_water, 50)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can interrogate what&#39;s going on with the fake instance by passing it to &lt;code&gt;explain&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;explanation = Mocktail.explain(ice_tray)&#xA;&#xA;explanation.reference.type      #=&amp;gt; IceTray&#xA;explanation.reference.double    #=&amp;gt; The ice_tray instance&#xA;explanation.reference.calls     #=&amp;gt; details on each invocation of each method&#xA;explanation.reference.stubbings #=&amp;gt; all stubbings configured for each method&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Calling &lt;code&gt;explanation.message&lt;/code&gt; will return:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This is a fake `IceTray&#39; instance.&#xA;&#xA;It has these mocked methods:&#xA;  - fill&#xA;&#xA;`IceTray#fill&#39; stubbings:&#xA;&#xA;  fill(:tap_water, 30)&#xA;&#xA;`IceTray#fill&#39; calls:&#xA;&#xA;  fill(:tap_water, 50)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Modules and classes with singleton methods replaced&lt;/h4&gt; &#xA;&lt;p&gt;If you&#39;ve called &lt;code&gt;Mocktail.replace()&lt;/code&gt; on a class or module, it can also be passed to &lt;code&gt;Mocktail.explain()&lt;/code&gt; for a summary of all the stubbing configurations and calls made against its faked singleton methods for the currently running thread.&lt;/p&gt; &#xA;&lt;p&gt;Imagine a &lt;code&gt;Shop&lt;/code&gt; class with &lt;code&gt;self.open!&lt;/code&gt; and &lt;code&gt;self.close!&lt;/code&gt; singleton methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Mocktail.replace(Shop)&#xA;&#xA;stubs { |m| Shop.open!(m.numeric) }.with { :a_bar }&#xA;&#xA;Shop.open!(42)&#xA;&#xA;Shop.close!(42)&#xA;&#xA;explanation = Mocktail.explain(Shop)&#xA;&#xA;explanation.reference.type      #=&amp;gt; Shop&#xA;explanation.reference.replaced_method_names #=&amp;gt; [:close!, :open!]&#xA;explanation.reference.calls     #=&amp;gt; details on each invocation of each method&#xA;explanation.reference.stubbings #=&amp;gt; all stubbings configured for each method&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And &lt;code&gt;explanation.message&lt;/code&gt; will return:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;`Shop&#39; is a class that has had its singleton methods faked.&#xA;&#xA;It has these mocked methods:&#xA;  - close!&#xA;  - open!&#xA;&#xA;`Shop.close!&#39; has no stubbings.&#xA;&#xA;`Shop.close!&#39; calls:&#xA;&#xA;  close!(42)&#xA;&#xA;  close!(42)&#xA;&#xA;`Shop.open!&#39; stubbings:&#xA;&#xA;  open!(numeric)&#xA;&#xA;  open!(numeric)&#xA;&#xA;`Shop.open!&#39; calls:&#xA;&#xA;  open!(42)&#xA;&#xA;  open!(42)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Methods on faked instances and replaced types&lt;/h4&gt; &#xA;&lt;p&gt;In addition to passing the test double, you can also pass a reference to any fake method created by Mocktail to &lt;code&gt;Mocktail.explain&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ice_tray = Mocktail.of(IceTray)&#xA;&#xA;ice_tray.fill(:chilled, 50)&#xA;&#xA;explanation = Mocktail.explain(ice_tray.method(:fill))&#xA;&#xA;explanation.reference.receiver  #=&amp;gt; a reference to the `ice_tray` instance&#xA;explanation.reference.calls     #=&amp;gt; details on each invocation of the method&#xA;explanation.reference.stubbings #=&amp;gt; all stubbings configured for the method&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above may be handy in cases where you want to assert the number of calls of a method outside the &lt;code&gt;Mocktail.verify&lt;/code&gt; API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;assert_equal 1, explanation.reference.calls.size&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The explanation will also contain a &lt;code&gt;message&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;`IceTray#fill&#39; has no stubbings.&#xA;&#xA;`IceTray#fill&#39; calls:&#xA;&#xA;  fill(:chilled, 50)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Replaced singleton methods can also be passed to &lt;code&gt;explain()&lt;/code&gt;, so something like &lt;code&gt;Mocktail.explain(Shop.method(:open!))&lt;/code&gt; from the earlier example would also work (with &lt;code&gt;Shop&lt;/code&gt; being the &lt;code&gt;receiver&lt;/code&gt; on the explanation&#39;s &lt;code&gt;reference&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;Undefined methods&lt;/h4&gt; &#xA;&lt;p&gt;There&#39;s no API for this one, but Mocktail also offers explanations for methods that don&#39;t exist yet. You&#39;ll see this error message whenever you try to call a method that doesn&#39;t exist on a test double. The message is designed to facilitate &#34;paint-by-numbers&#34; TDD, by including a sample definition of the method you had attempted to call that can be copy-pasted into a source listing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class IceTray&#xA;end&#xA;&#xA;ice_tray = Mocktail.of(IceTray)&#xA;&#xA;ice_tray.fill(:water_type, 30)&#xA;# =&amp;gt; No method `IceTray#fill&#39; exists for call: (NoMethodError)&#xA;#&#xA;#      fill(:water_type, 30)&#xA;#&#xA;#    Need to define the method? Here&#39;s a sample definition:&#xA;#&#xA;#      def fill(water_type, arg)&#xA;#      end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From there, you can just copy-paste the provided method stub as a starting point for your new method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class IceTray&#xA;  def fill(water_type, amount)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Mocktail.explain_nils&lt;/h3&gt; &#xA;&lt;p&gt;Is a faked method returning &lt;code&gt;nil&lt;/code&gt; and you don&#39;t understand why?&lt;/p&gt; &#xA;&lt;p&gt;By default, methods faked by Mocktail will return &lt;code&gt;nil&lt;/code&gt; when no stubbing is satisfied. A frequent frustration, therefore, is when the way &lt;code&gt;stubs {}.with {}&lt;/code&gt; is configured does not satisfy a call the way you expected. To try to make debugging this a little bit easier, the gem provides a top-level &lt;code&gt;Mocktail.explain_nils&lt;/code&gt; method that will return an array of summaries of every call to a faked method that failed to satisfy any stubbings.&lt;/p&gt; &#xA;&lt;p&gt;For example, suppose you stub this &lt;code&gt;fill&lt;/code&gt; method like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ice_tray = Mocktail.of(IceTray)&#xA;&#xA;stubs { ice_tray.fill(:tap_water, 30) }.with { :normal_ice }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But then you find that your subject under test is just getting &lt;code&gt;nil&lt;/code&gt; back and you don&#39;t understand why:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def prep&#xA;  ice = ice_tray.fill(:tap_water, 50)&#xA;  glass.add(ice) # =&amp;gt; why is `ice` nil?!&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Whenever you&#39;re confused by a nil, you can call &lt;code&gt;Mocktail.explain_nils&lt;/code&gt; for an array containing &lt;code&gt;UnsatisfyingCallExplanation&lt;/code&gt; objects (one for each call to a faked method that did not satisfy any configured stubbings).&lt;/p&gt; &#xA;&lt;p&gt;The returned explanation objects will include both a &lt;code&gt;reference&lt;/code&gt; object to explore as well a summary &lt;code&gt;message&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def prep&#xA;  ice = ice_tray.fill(:tap_water, 50)&#xA;  puts Mocktail.explain_nils.first.message&#xA;  glass.add(ice)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which will print:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This `nil&#39; was returned by a mocked `IceTray#fill&#39; method&#xA;because none of its configured stubbings were satisfied.&#xA;&#xA;The actual call:&#xA;&#xA;  fill(:tap_water, 50)&#xA;&#xA;The call site:&#xA;&#xA;  /path/to/your/code.rb:42:in `prep&#39;&#xA;&#xA;Stubbings configured prior to this call but not satisfied by it:&#xA;&#xA;  fill(:tap_water, 30)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;reference&lt;/code&gt; object will have details of the &lt;code&gt;call&lt;/code&gt; itself, an array of &lt;code&gt;other_stubbings&lt;/code&gt; defined on the faked method, and a &lt;code&gt;backtrace&lt;/code&gt; to determine which call site produced the unexpected &lt;code&gt;nil&lt;/code&gt; value.&lt;/p&gt; &#xA;&lt;h3&gt;Mocktail.calls&lt;/h3&gt; &#xA;&lt;p&gt;When practicing test-driven development, you may want to ensure that a dependency wasn&#39;t called at all. To provide a terse way to express this, Mocktail offers a top-level &lt;code&gt;calls(double, method_name = nil)&lt;/code&gt; method that returns an array of the calls to the mock (optionally filtered to a particular method name) in the order they were called.&lt;/p&gt; &#xA;&lt;p&gt;Suppose you were writing a test of this method for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def import_users&#xA;  users_response = @gets_users.get&#xA;  if users_response.success?&#xA;    @upserts_users.upsert(users_response.data)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A test case of the negative branch of that &lt;code&gt;if&lt;/code&gt; statement (when &lt;code&gt;success?&lt;/code&gt; is false) might simply want to assert that &lt;code&gt;@upserts_users.upsert&lt;/code&gt; wasn&#39;t called at all, regardless of its parameters.&lt;/p&gt; &#xA;&lt;p&gt;The easiest way to do this is to use &lt;code&gt;Mocktail.calls()&lt;/code&gt; method, which is an alias of &lt;a href=&#34;https://raw.githubusercontent.com/testdouble/mocktail/main/#mocktailexplain&#34;&gt;Mocktail.explain(double).reference.calls&lt;/a&gt; that can filter to a specific method name. In the case of a test of the above method, you could assert:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Assert that the `upsert` method on the mock was never called&#xA;assert_equal 0, Mocktail.calls(@upserts_users, :upsert).size&#xA;&#xA;# Assert that NO METHODS on the mock were called at all:&#xA;assert_equal 0, Mocktail.calls(@upserts_users).size&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;re interested in doing more complicated introspection in the nature of the calls, their ordering, and so forth, the &lt;code&gt;calls&lt;/code&gt; method will return &lt;code&gt;Mocktail::Call&lt;/code&gt; values with the args, kwargs, block, and information about the original class and method being mocked.&lt;/p&gt; &#xA;&lt;p&gt;(While this behavior can technically be accomplished with &lt;code&gt;verify(times: 0) { ‚Ä¶ }&lt;/code&gt;, it&#39;s verbose and error prone to do so. Because &lt;code&gt;verify&lt;/code&gt; is careful to only assert exact argument matches, it can get pretty confusing to remember to tack on &lt;code&gt;ignore_extra_args: true&lt;/code&gt; and to call the method with zero args to cover all cases.)&lt;/p&gt; &#xA;&lt;h3&gt;Mocktail.reset&lt;/h3&gt; &#xA;&lt;p&gt;This one&#39;s simple: you probably want to call &lt;code&gt;Mocktail.reset&lt;/code&gt; after each test, but you &lt;em&gt;definitely&lt;/em&gt; want to call it if you&#39;re using &lt;code&gt;Mocktail.replace&lt;/code&gt; or &lt;code&gt;Mocktail.of_next&lt;/code&gt; anywhere, since those will affect state that is shared across tests.&lt;/p&gt; &#xA;&lt;p&gt;Calling reset in a &lt;code&gt;teardown&lt;/code&gt; or &lt;code&gt;after(:each)&lt;/code&gt; hook will also improve the usefulness of messages returned by &lt;code&gt;Mocktail.explain&lt;/code&gt; and &lt;code&gt;Mocktail.explain_nils&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;p&gt;Mocktail is designed following a somewhat academic understanding of what mocking is and how it should be used. Below are several references on this topic.&lt;/p&gt; &#xA;&lt;p&gt;Blog Posts and Papers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[Endo-Testing: Unit Testing with Mock Objects](&lt;a href=&#34;https://www2.ccs.neu.edu/research/demeter/related-work/extreme-programming/MockObjectsFinal.PDF&#34;&gt;https://www2.ccs.neu.edu/research/demeter/related-work/extreme-programming/MockObjectsFinal.PDF&lt;/a&gt; by Tim Mackinnon, Steve Freeman, and Philip Craig, the paper that introduced mocking presented by the creators of mocking.&lt;/li&gt; &#xA; &lt;li&gt;Michael Feathers&#39; &lt;a href=&#34;https://michaelfeathers.typepad.com/michael_feathers_blog/2008/06/the-flawed-theo.html&#34;&gt;The Flawed Theory Behind Unit Testing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Books:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://bookshop.org/books/growing-object-oriented-software-guided-by-tests/9780321503626&#34;&gt;&lt;em&gt;Growing Object-Oriented Software, Guided by Tests&lt;/em&gt;&lt;/a&gt; by Steve Freeman and Nat Price&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Talks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Af4M8GMoxi4&#34;&gt;Please don‚Äôt mock me&lt;/a&gt; by Justin Searls&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;Mocktail is created &amp;amp; maintained by the software agency &lt;a href=&#34;https://testdouble.com&#34;&gt;Test Double&lt;/a&gt;. If you&#39;ve ever come across our eponymously-named &lt;a href=&#34;https://github.com/testdouble/testdouble.js/&#34;&gt;testdouble.js&lt;/a&gt;, you might find Mocktail&#39;s API to be quite similar. The term &#34;test double&#34; was originally coined by Gerard Meszaros in his book &lt;a href=&#34;http://xunitpatterns.com/Test%20Double.html&#34;&gt;xUnit Test Patterns&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The name is inspired by the innovative Java mocking library &lt;a href=&#34;https://site.mockito.org&#34;&gt;Mockito&lt;/a&gt;. Mocktail also the spiritual successor to &lt;a href=&#34;https://github.com/searls/gimme&#34;&gt;gimme&lt;/a&gt;, which offers a similar API but which fell victim to the limitations of Ruby 1.8.7 (and &lt;a href=&#34;https://twitter.com/searls&#34;&gt;@searls&lt;/a&gt;&#39;s Ruby chops). Gimme was also one of the final projects we collaborated with &lt;a href=&#34;https://github.com/jimweirich&#34;&gt;Jim Weirich&lt;/a&gt; on, so this approach to isolated unit testing holds a special significance to us.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;This project follows Test Double&#39;s &lt;a href=&#34;https://testdouble.com/code-of-conduct&#34;&gt;code of conduct&lt;/a&gt; for all community interactions, including (but not limited to) one-on-one communications, public posts/comments, code reviews, pull requests, and GitHub issues. If violations occur, Test Double will take any action they deem appropriate for the infraction, up to and including blocking a user from the organization&#39;s repositories.&lt;/p&gt;</summary>
  </entry>
</feed>