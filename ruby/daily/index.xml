<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-05T01:38:42Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rage-rb/rage</title>
    <updated>2023-10-05T01:38:42Z</updated>
    <id>tag:github.com,2023-10-05:/rage-rb/rage</id>
    <link href="https://github.com/rage-rb/rage" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fast web framework compatible with Rails.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt;&lt;img height=&#34;200&#34; src=&#34;https://github.com/rage-rb/rage/assets/2270393/9d06e0a4-5c20-49c7-b51d-e16ce8f1e1b7&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Rage&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://badge.fury.io/rb/rage-rb&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/rage-rb.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/rage-rb/rage/actions/workflows/main.yml/badge.svg?sanitize=true&#34; alt=&#34;Tests&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Inspired by &lt;a href=&#34;https://deno.com&#34;&gt;Deno&lt;/a&gt; and built on top of &lt;a href=&#34;https://github.com/rage-rb/iodine&#34;&gt;Iodine&lt;/a&gt;, this is a Ruby web framework that is based on the following design principles:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Rails compatible API&lt;/strong&gt; - Rails&#39; API is clean, straightforward, and simply makes sense. It was one of the reasons why Rails was so successful in the past.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;High performance&lt;/strong&gt; - some think performance is not a major metric for a framework, but it&#39;s not true. Poor performance is a risk, and in today&#39;s world, companies refuse to use risky technologies.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;API-only&lt;/strong&gt; - the only technology we should be using to create web UI is JavaScript. Check out &lt;a href=&#34;https://vitejs.dev&#34;&gt;Vite&lt;/a&gt; if you don&#39;t know where to start.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Acceptance of modern Ruby&lt;/strong&gt; - the framework includes a fiber scheduler, which means your code never blocks while waiting on IO.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install the gem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install rage-rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create a new app:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ rage new my_app&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Switch to your new application and install dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd my_app&#xA;$ bundle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Start up the server and visit &lt;a href=&#34;http://localhost:3000&#34;&gt;http://localhost:3000&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ rage s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Start coding!&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;This gem is designed to be a drop-in replacement for Rails in API mode. Public API is mostly expected to match Rails, however, sometimes it&#39;s a little bit more strict.&lt;/p&gt; &#xA;&lt;p&gt;Check out in-depth API docs for more information:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://rage-rb.github.io/rage/RageController/API.html&#34;&gt;Controller API&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://rage-rb.github.io/rage/Rage/Router/DSL/Handler.html&#34;&gt;Routing API&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://rage-rb.github.io/rage/Fiber.html&#34;&gt;Fiber API&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also, see the &lt;a href=&#34;https://github.com/rage-rb/rage/raw/master/CHANGELOG.md&#34;&gt;changelog&lt;/a&gt; and &lt;a href=&#34;https://github.com/rage-rb/rage#upcoming-releases&#34;&gt;upcoming-releases&lt;/a&gt; for currently supported and planned features.&lt;/p&gt; &#xA;&lt;h3&gt;Example&lt;/h3&gt; &#xA;&lt;p&gt;A sample controller could look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;net/http&#34;&#xA;&#xA;class PagesController &amp;lt; RageController::API&#xA;  rescue_from SocketError do |_|&#xA;    render json: { message: &#34;error&#34; }, status: 500&#xA;  end&#xA;&#xA;  before_action :set_metadata&#xA;&#xA;  def show&#xA;    page = Net::HTTP.get(URI(&#34;https://httpbin.org/json&#34;))&#xA;    render json: { page: page, metadata: @metadata }&#xA;  end&#xA;&#xA;  private&#xA;&#xA;  def set_metadata&#xA;    @metadata = { format: &#34;json&#34;, time: Time.now.to_i }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Apart from &lt;code&gt;RageController::API&lt;/code&gt; as a parent class, this is mostly a regular Rails controller. However, the main difference is under the hood - Rage runs every request in a separate fiber. During the call to &lt;code&gt;Net::HTTP.get&lt;/code&gt;, the fiber is automatically paused, enabling the server to process other requests. Once the HTTP request is finished, the fiber will be resumed, potentially allowing to process hundreds of requests simultaneously.&lt;/p&gt; &#xA;&lt;p&gt;To make this controller work, we would also need to update &lt;code&gt;config/routes.rb&lt;/code&gt;. In this case, the file would look the following way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rage.routes.draw do&#xA;  get &#34;page&#34;, to: &#34;pages#show&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;ℹ&lt;/span&gt; &lt;strong&gt;Note&lt;/strong&gt;: Rage will automatically pause a fiber and continue to process other fibers on HTTP, PostgreSQL, and MySQL calls. Calls to &lt;code&gt;Thread.join&lt;/code&gt; and &lt;code&gt;Ractor.join&lt;/code&gt; will also automatically pause the current fiber.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, &lt;code&gt;Fiber.await&lt;/code&gt; can be used to run several requests in parallel:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;net/http&#34;&#xA;&#xA;class PagesController &amp;lt; RageController::API&#xA;  def index&#xA;    pages = Fiber.await(&#xA;      Fiber.schedule { Net::HTTP.get(URI(&#34;https://httpbin.org/json&#34;)) },&#xA;      Fiber.schedule { Net::HTTP.get(URI(&#34;https://httpbin.org/html&#34;)) },&#xA;    )&#xA;&#xA;    render json: { pages: pages }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;span&gt;ℹ&lt;/span&gt; &lt;strong&gt;Note&lt;/strong&gt;: When using &lt;code&gt;Fiber.await&lt;/code&gt;, it is important to wrap any instance of IO into a fiber using &lt;code&gt;Fiber.schedule&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Benchmarks&lt;/h2&gt; &#xA;&lt;h4&gt;hello world&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArticlesController &amp;lt; ApplicationController&#xA;  def index&#xA;    render json: { hello: &#34;world&#34; }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/rage-rb/rage/assets/2270393/6c221903-e265-4c94-80e1-041f266c8f47&#34; alt=&#34;Requests per second&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;waiting on IO&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;net/http&#34;&#xA;&#xA;class ArticlesController &amp;lt; ApplicationController&#xA;  def index&#xA;    Net::HTTP.get(URI(&#34;&amp;lt;endpoint-that-responds-in-one-second&amp;gt;&#34;))&#xA;    head :ok&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/rage-rb/rage/assets/2270393/007044e9-efe0-4675-9cab-8a4868154118&#34; alt=&#34;Time to complete 100 requests&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Upcoming releases&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Version&lt;/th&gt; &#xA;   &lt;th&gt;Changes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.2 &lt;span&gt;✅&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;del&gt;Gem configuration by env.&lt;br&gt;Add &lt;code&gt;skip_before_action&lt;/code&gt;.&lt;br&gt;Add &lt;code&gt;rescue_from&lt;/code&gt;.&lt;br&gt;Router updates:&lt;br&gt; • make the &lt;code&gt;root&lt;/code&gt; helper work correctly with &lt;code&gt;scope&lt;/code&gt;;&lt;br&gt; • support the &lt;code&gt;defaults&lt;/code&gt; option;&lt;/del&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.3&lt;/td&gt; &#xA;   &lt;td&gt;CLI updates:&lt;br&gt; • &lt;code&gt;routes&lt;/code&gt; task;&lt;br&gt; • &lt;code&gt;console&lt;/code&gt; task;&lt;br&gt;Support the &lt;code&gt;:if&lt;/code&gt; and &lt;code&gt;:unless&lt;/code&gt; options in &lt;code&gt;before_action&lt;/code&gt;.&lt;br&gt;Allow to set response headers.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.4&lt;/td&gt; &#xA;   &lt;td&gt;Expose the &lt;code&gt;params&lt;/code&gt; object.&lt;br&gt;Support header authentication with &lt;code&gt;authenticate_with_http_token&lt;/code&gt;.&lt;br&gt;Router updates:&lt;br&gt; • add the &lt;code&gt;resources&lt;/code&gt; route helper;&lt;br&gt; • add the &lt;code&gt;namespace&lt;/code&gt; route helper;&lt;br&gt; • support regexp constraints;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.5&lt;/td&gt; &#xA;   &lt;td&gt;Implement Iodine-based equivalent of &lt;code&gt;ActionController::Live&lt;/code&gt;.&lt;br&gt;Use &lt;code&gt;ActionDispatch::RemoteIp&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.6&lt;/td&gt; &#xA;   &lt;td&gt;Expose the &lt;code&gt;cookies&lt;/code&gt; object.&lt;br&gt;Expose the &lt;code&gt;send_data&lt;/code&gt; and &lt;code&gt;send_file&lt;/code&gt; methods.&lt;br&gt;Support conditional get with &lt;code&gt;etag&lt;/code&gt; and &lt;code&gt;last_modified&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.7&lt;/td&gt; &#xA;   &lt;td&gt;Add request logging.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.8&lt;/td&gt; &#xA;   &lt;td&gt;Collect app metrics.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.9&lt;/td&gt; &#xA;   &lt;td&gt;Automatic code reloading in development.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;After checking out the repo, run &lt;code&gt;bin/setup&lt;/code&gt; to install dependencies. Then, run &lt;code&gt;rake spec&lt;/code&gt; to run the tests. You can also run &lt;code&gt;bin/console&lt;/code&gt; for an interactive prompt that will allow you to experiment.&lt;/p&gt; &#xA;&lt;p&gt;To install this gem onto your local machine, run &lt;code&gt;bundle exec rake install&lt;/code&gt;. To release a new version, update the version number in &lt;code&gt;version.rb&lt;/code&gt;, and then run &lt;code&gt;bundle exec rake release&lt;/code&gt;, which will create a git tag for the version, push git commits and the created tag, and push the &lt;code&gt;.gem&lt;/code&gt; file to &lt;a href=&#34;https://rubygems.org&#34;&gt;rubygems.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Bug reports and pull requests are welcome on GitHub at &lt;a href=&#34;https://github.com/rage-rb/rage&#34;&gt;https://github.com/rage-rb/rage&lt;/a&gt;. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the &lt;a href=&#34;https://github.com/rage-rb/rage/raw/master/CODE_OF_CONDUCT.md&#34;&gt;code of conduct&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;Everyone interacting in the Rage project&#39;s codebases, issue trackers, chat rooms and mailing lists is expected to follow the &lt;a href=&#34;https://github.com/rage-rb/rage/raw/master/CODE_OF_CONDUCT.md&#34;&gt;code of conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>rails/solid_cache</title>
    <updated>2023-10-05T01:38:42Z</updated>
    <id>tag:github.com,2023-10-05:/rails/solid_cache</id>
    <link href="https://github.com/rails/solid_cache" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A database-backed ActiveSupport::Cache::Store&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Solid Cache&lt;/h1&gt; &#xA;&lt;p&gt;Solid Cache is a database-backed Active Support cache store implementation.&lt;/p&gt; &#xA;&lt;p&gt;Using SQL databases backed by SSDs we can have caches that are much larger and cheaper than traditional memory only Redis or Memcached backed caches.&lt;/p&gt; &#xA;&lt;p&gt;Testing on &lt;a href=&#34;https://hey.com&#34;&gt;HEY&lt;/a&gt; shows that reads and writes are 25%-50% slower than with a Redis cache (1.2ms vs 0.8-1ms per single-key read), but this is not a significant percentage of the overall request time.&lt;/p&gt; &#xA;&lt;p&gt;If cache misses are expensive (up to 50x the cost of a hit on HEY), then there are big advantages to caches that can hold months rather than days of data.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;To set Solid Cache as your Rails cache, you should add this to your environment config:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.cache_store = :solid_cache_store&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Solid Cache is a FIFO (first in, first out) cache. While this is not as efficient as an LRU cache, this is mitigated by the longer cache lifespans.&lt;/p&gt; &#xA;&lt;p&gt;A FIFO cache is much easier to manage:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;We don&#39;t need to track when items are read&lt;/li&gt; &#xA; &lt;li&gt;We can estimate and control the cache size by comparing the maximum and minimum IDs.&lt;/li&gt; &#xA; &lt;li&gt;By deleting from one end of the table and adding at the other end we can avoid fragmentation (on MySQL at least).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;solid_cache&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or install it yourself as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ gem install solid_cache&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add the migration to your app:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bin/rails solid_cache:install:migrations&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bin/rails db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;h4&gt;Engine configuration&lt;/h4&gt; &#xA;&lt;p&gt;There are two options that can be set on the engine:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;executor&lt;/code&gt; - the &lt;a href=&#34;https://guides.rubyonrails.org/threading_and_code_execution.html#executor&#34;&gt;Rails executor&lt;/a&gt; used to wrap asynchronous operations, defaults to the app executor&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;connects_to&lt;/code&gt; - a custom connects to value for the abstract &lt;code&gt;SolidCache::Record&lt;/code&gt; active record model. Requires for sharding and/or using a separate cache database to the main app.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These can be set in your Rails configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.application.configure do&#xA;  config.solid_cache.connects_to = {&#xA;    shards: {&#xA;      shard1: { writing: :cache_primary_shard1 },&#xA;      shard2: { writing: :cache_primary_shard2 }&#xA;    }&#xA;  }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Cache configuration&lt;/h4&gt; &#xA;&lt;p&gt;Solid Cache supports these options in addition to the standard &lt;code&gt;ActiveSupport::Cache::Store&lt;/code&gt; options.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;error_handler&lt;/code&gt; - a Proc to call to handle any &lt;code&gt;ActiveRecord::ActiveRecordError&lt;/code&gt;s that are raises (default: log errors as warnings)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;expiry_batch_size&lt;/code&gt; - the batch size to use when deleting old records (default: &lt;code&gt;100&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;expiry_method&lt;/code&gt; - what expiry method to use &lt;code&gt;thread&lt;/code&gt; or &lt;code&gt;job&lt;/code&gt; (default: &lt;code&gt;thread&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max_age&lt;/code&gt; - the maximum age of entries in the cache (default: &lt;code&gt;2.weeks.to_i&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max_entries&lt;/code&gt; - the maximum number of entries allowed in the cache (default: &lt;code&gt;nil&lt;/code&gt;, meaning no limit)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cluster&lt;/code&gt; - a Hash of options for the cache database cluster, e.g &lt;code&gt;{ shards: [:database1, :database2, :database3] }&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clusters&lt;/code&gt; - and Array of Hashes for multiple cache clusters (ignored if &lt;code&gt;:cluster&lt;/code&gt; is set)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;active_record_instrumentation&lt;/code&gt; - whether to instrument the cache&#39;s queries (default: &lt;code&gt;true&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clear_with&lt;/code&gt; - clear the cache with &lt;code&gt;:truncate&lt;/code&gt; or &lt;code&gt;:delete&lt;/code&gt; (default &lt;code&gt;truncate&lt;/code&gt;, except for when Rails.env.test? then &lt;code&gt;delete&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max_key_bytesize&lt;/code&gt; - the maximum size of a normalized key in bytes (default &lt;code&gt;1024&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more information on cache clusters see &lt;a href=&#34;https://raw.githubusercontent.com/rails/solid_cache/main/#sharding-the-cache&#34;&gt;Sharding the cache&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Cache expiry&lt;/h3&gt; &#xA;&lt;p&gt;Solid Cache tracks writes to the cache. For every write it increments a counter by 1. Once the counter reaches 80% of the &lt;code&gt;expiry_batch_size&lt;/code&gt; it adds a task to run on a background thread. That task will:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Check if we have exceeded the &lt;code&gt;max_entries&lt;/code&gt; value (if set) by subtracting the max and min IDs from the &lt;code&gt;SolidCache::Entry&lt;/code&gt; table (this is an estimate that ignores any gaps).&lt;/li&gt; &#xA; &lt;li&gt;If we have it will delete &lt;code&gt;expiry_batch_size&lt;/code&gt; entries&lt;/li&gt; &#xA; &lt;li&gt;If not it will delete up to &lt;code&gt;expiry_batch_size&lt;/code&gt; entries, provided they are all older than &lt;code&gt;max_age&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Expiring when we reach 80% of the batch size allows us to expire records from the cache faster than we write to it when we need to reduce the cache size.&lt;/p&gt; &#xA;&lt;p&gt;Only triggering expiry when we write means that the if the cache is idle, the background thread is also idle.&lt;/p&gt; &#xA;&lt;p&gt;If you want the cache expiry to be run in a background job instead of a thread, you can set &lt;code&gt;expiry_method&lt;/code&gt; to &lt;code&gt;:job&lt;/code&gt;. This will enqueue a &lt;code&gt;SolidCache::ExpiryJob&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Using a dedicated cache database&lt;/h3&gt; &#xA;&lt;p&gt;Add database configuration to database.yml, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;development:&#xA;  cache:&#xA;    database: cache_development&#xA;    host: 127.0.0.1&#xA;    migrations_paths: &#34;db/cache/migrate&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create database:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bin/rails db:create&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install migrations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bin/rails solid_cache:install:migrations&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Move migrations to custom migrations folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ mkdir -p db/cache/migrate&#xA;$ mv db/migrate/*.solid_cache.rb db/cache/migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set the engine configuration to point to the new database:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Rails.application.configure do&#xA;  config.solid_cache.connects_to = { default: { writing: :cache } }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run migrations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bin/rails db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sharding the cache&lt;/h3&gt; &#xA;&lt;p&gt;Solid Cache uses the &lt;a href=&#34;https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44824.pdf&#34;&gt;Maglev&lt;/a&gt; consistent hashing scheme to shard the cache across multiple databases.&lt;/p&gt; &#xA;&lt;p&gt;To shard:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add the configuration for the database shards to database.yml&lt;/li&gt; &#xA; &lt;li&gt;Configure the shards via &lt;code&gt;config.solid_cache.connects_to&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Pass the shards for the cache to use via the cluster option&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/database.yml&#xA;production:&#xA;  cache_shard1:&#xA;    database: cache1_production&#xA;    host: cache1-db&#xA;  cache_shard2:&#xA;    database: cache2_production&#xA;    host: cache2-db&#xA;  cache_shard3:&#xA;    database: cache3_production&#xA;    host: cache3-db&#xA;&#xA;&#xA;# config/environment/production.rb&#xA;Rails.application.configure do&#xA;  config.solid_cache.connects_to = {&#xA;    shards: {&#xA;      cache_shard1: { writing: :cache_shard1 },&#xA;      cache_shard2: { writing: :cache_shard2 },&#xA;      cache_shard3: { writing: :cache_shard3 },&#xA;    }&#xA;  }&#xA;&#xA;  config.cache_store = [ :solid_cache_store, cluster: { shards: [ :cache_shard1, :cache_shard2, :cache_shard3 ] } ]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Secondary cache clusters&lt;/h3&gt; &#xA;&lt;p&gt;You can add secondary cache clusters. Reads will only be sent to the primary cluster (i.e. the first one listed).&lt;/p&gt; &#xA;&lt;p&gt;Writes will go to all clusters. The writes to the primary cluster are synchronous, but asyncronous to the secondary clusters.&lt;/p&gt; &#xA;&lt;p&gt;To specific multiple clusters you can do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.application.configure do&#xA;  config.solid_cache.connects_to = {&#xA;    shards: {&#xA;      cache_primary_shard1: { writing: :cache_primary_shard1 },&#xA;      cache_primary_shard2: { writing: :cache_primary_shard2 },&#xA;      cache_secondary_shard1: { writing: :cache_secondary_shard1 },&#xA;      cache_secondary_shard2: { writing: :cache_secondary_shard2 },&#xA;    }&#xA;  }&#xA;&#xA;  primary_cluster = { shards: [ :cache_primary_shard1, :cache_primary_shard2 ] }&#xA;  secondary_cluster = { shards: [ :cache_primary_shard1, :cache_primary_shard2 ] }&#xA;  config.cache_store = [ :solid_cache_store, clusters: [ primary_cluster, secondary_cluster ] ]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Named shard destinations&lt;/h3&gt; &#xA;&lt;p&gt;By default, the node key used for sharding is the name of the database in &lt;code&gt;database.yml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is possible to add names for the shards in the cluster config. This will allow you to shuffle or remove shards without breaking consistent hashing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.application.configure do&#xA;  config.solid_cache.connects_to = {&#xA;    shards: {&#xA;      cache_primary_shard1: { writing: :cache_primary_shard1 },&#xA;      cache_primary_shard2: { writing: :cache_primary_shard2 },&#xA;      cache_secondary_shard1: { writing: :cache_secondary_shard1 },&#xA;      cache_secondary_shard2: { writing: :cache_secondary_shard2 },&#xA;    }&#xA;  }&#xA;&#xA;  primary_cluster = { shards: { cache_primary_shard1: :node1, cache_primary_shard2: :node2 } }&#xA;  secondary_cluster = { shards: { cache_primary_shard1: :node3, cache_primary_shard2: :node4 } }&#xA;  config.cache_store = [ :solid_cache_store, clusters: [ primary_cluster, secondary_cluster ] ]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Enabling encryption&lt;/h3&gt; &#xA;&lt;p&gt;Add this to an initializer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ActiveSupport.on_load(:solid_cache_entry) do&#xA;  encrypts :value&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Index size limits&lt;/h3&gt; &#xA;&lt;p&gt;The Solid Cache migrations try to create an index with 1024 byte entries. If that is too big for your database, you should:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Edit the index size in the migration&lt;/li&gt; &#xA; &lt;li&gt;Set &lt;code&gt;max_key_bytesize&lt;/code&gt; on your cache to the new value&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;Run the tests with &lt;code&gt;bin/rails test&lt;/code&gt;. By default, these will run against SQLite.&lt;/p&gt; &#xA;&lt;p&gt;You can also run the tests against MySQL and PostgreSQL. First start up the databases:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker compose up -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, setup the database schema:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ TARGET_DB=mysql bin/rails db:setup&#xA;$ TARGET_DB=postgres bin/rails db:setup&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run the tests for the target database:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ TARGET_DB=mysql bin/rails test&#xA;$ TARGET_DB=postgres bin/rails test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Solid Cache is licensed under MIT.&lt;/p&gt;</summary>
  </entry>
</feed>