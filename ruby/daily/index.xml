<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-30T01:33:13Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>puppetlabs/puppet</title>
    <updated>2022-06-30T01:33:13Z</updated>
    <id>tag:github.com,2022-06-30:/puppetlabs/puppet</id>
    <link href="https://github.com/puppetlabs/puppet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Server automation framework and application&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Puppet&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/puppetlabs/puppet/workflows/RSpec%20tests/badge.svg?sanitize=true&#34; alt=&#34;RSpec tests&#34;&gt; &lt;a href=&#34;https://badge.fury.io/rb/puppet&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/puppet.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://inch-ci.org/github/puppetlabs/puppet&#34;&gt;&lt;img src=&#34;https://inch-ci.org/github/puppetlabs/puppet.svg?sanitize=true&#34; alt=&#34;Inline docs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Puppet, an automated administrative engine for your Linux, Unix, and Windows systems, performs administrative tasks (such as adding users, installing packages, and updating server configurations) based on a centralized specification.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Documentation for Puppet and related projects can be found online at the &lt;a href=&#34;https://puppet.com/docs&#34;&gt;Puppet Docs site&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;HTTP API&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://puppet.com/docs/puppet/latest/http_api/http_api_index.html&#34;&gt;HTTP API Index&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;The best way to run Puppet is with &lt;a href=&#34;https://puppet.com/products/puppet-enterprise/&#34;&gt;Puppet Enterprise (PE)&lt;/a&gt;, which also includes orchestration features, a web console, and professional support. The PE documentation is &lt;a href=&#34;https://puppet.com/docs/pe/latest&#34;&gt;available here.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To install an open source release of Puppet, &lt;a href=&#34;https://puppet.com/docs/puppet/latest/installing_and_upgrading.html&#34;&gt;see the installation guide on the docs site.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you need to run Puppet from source as a tester or developer, see the &lt;a href=&#34;https://raw.githubusercontent.com/puppetlabs/puppet/main/docs/quickstart.md&#34;&gt;Quick Start to Developing on Puppet&lt;/a&gt; guide.&lt;/p&gt; &#xA;&lt;h2&gt;Developing and Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;d love to get contributions from you! For a quick guide to getting your system setup for developing, take a look at our &lt;a href=&#34;https://github.com/puppetlabs/puppet/raw/main/docs/quickstart.md&#34;&gt;Quickstart Guide&lt;/a&gt;. Once you are up and running, take a look at the &lt;a href=&#34;https://github.com/puppetlabs/puppet/raw/main/CONTRIBUTING.md&#34;&gt;Contribution Documents&lt;/a&gt; to see how to get your changes merged in.&lt;/p&gt; &#xA;&lt;p&gt;For more complete docs on developing with Puppet, take a look at the rest of the &lt;a href=&#34;https://github.com/puppetlabs/puppet/raw/main/docs/index.md&#34;&gt;developer documents&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Licensing&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/puppetlabs/puppet/raw/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file. Puppet is licensed by Puppet, Inc. under the Apache license. Puppet, Inc. can be contacted at: &lt;a href=&#34;mailto:info@puppet.com&#34;&gt;info@puppet.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;Please log tickets and issues at our &lt;a href=&#34;https://tickets.puppetlabs.com&#34;&gt;JIRA tracker&lt;/a&gt;. A &lt;a href=&#34;https://groups.google.com/forum/?fromgroups#!forum/puppet-users&#34;&gt;mailing list&lt;/a&gt; is available for asking questions and getting help from others, or if you prefer chat, we also have a &lt;a href=&#34;https://puppetcommunity.slack.com/&#34;&gt;Puppet Community slack.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;We use semantic version numbers for our releases and recommend that users stay as up-to-date as possible by upgrading to patch releases and minor releases as they become available.&lt;/p&gt; &#xA;&lt;p&gt;Bug fixes and ongoing development will occur in minor releases for the current major version. Security fixes will be backported to a previous major version on a best-effort basis, until the previous major version is no longer maintained.&lt;/p&gt; &#xA;&lt;p&gt;For example: If a security vulnerability is discovered in Puppet 6.1.1, we would fix it in the 6 series, most likely as 6.1.2. Maintainers would then make a best effort to backport that fix onto the latest Puppet 5 release.&lt;/p&gt; &#xA;&lt;p&gt;Long-term support, including security patches and bug fixes, is available for commercial customers. Please see the following page for more details:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://puppet.com/docs/puppet-enterprise/product-support-lifecycle/&#34;&gt;Puppet Enterprise Support Lifecycle&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-3-enumerables-debugging</title>
    <updated>2022-06-30T01:33:13Z</updated>
    <id>tag:github.com,2022-06-30:/learn-co-curriculum/phase-3-enumerables-debugging</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-enumerables-debugging" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Enumerables: Debugging with Pry&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use Pry to debug code running in enumerable method blocks&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Methods using enumerables and loops can be a bit more challenging to debug than other methods. In this lesson, you&#39;ll practice using &lt;code&gt;binding.pry&lt;/code&gt; to pause the execution of your code inside a loop so you can inspect variables in enumerable methods.&lt;/p&gt; &#xA;&lt;h2&gt;Code Along&lt;/h2&gt; &#xA;&lt;p&gt;Fork and clone this lesson to code along!&lt;/p&gt; &#xA;&lt;p&gt;In this lesson, we&#39;ll be writing a method called &lt;code&gt;#reverse_each_word&lt;/code&gt; that takes in a argument of a sentence as a string, and returns that same sentence with each word reversed in place.&lt;/p&gt; &#xA;&lt;p&gt;The input will be a sentence, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;&#34;Hello there, and how are you?&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And calling our method will produce an output like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;reverse_each_word(&#34;Hello there, and how are you?&#34;)&#xA;  #=&amp;gt; &#34;olleH ,ereht dna woh era ?uoy&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Before writing this method out, let&#39;s do a bit of pseudocoding, and decide how we need to approach this problem:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Split the string on &#34; &#34; to get access to each word in the sentence&lt;/li&gt; &#xA; &lt;li&gt;Reverse each word, and add it to a new array&lt;/li&gt; &#xA; &lt;li&gt;Join the array of words on &#34; &#34; to create one string&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;With that plan of attack in mind, let&#39;s start writing the method, and use &lt;code&gt;pry&lt;/code&gt; to check our work on each step of this pseudocode.&lt;/p&gt; &#xA;&lt;h3&gt;Step 1: Splitting the String&lt;/h3&gt; &#xA;&lt;p&gt;To start, add the following code to your &lt;code&gt;reverse_each_word.rb&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;pry&#39;&#xA;&#xA;def reverse_each_word(sentence)&#xA;  binding.pry&#xA;end&#xA;&#xA;reverse_each_word(&#34;Hello there, and how are you?&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run the file with &lt;code&gt;ruby reverse_each_word.rb&lt;/code&gt;. From the Pry session in your terminal, inspect the &lt;code&gt;sentence&lt;/code&gt; variable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;sentence&#xA;# =&amp;gt; &#34;Hello there, and how are you?&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, let&#39;s try getting the first step of our pseudocode working from the Pry session:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Split the string on &#34; &#34; to get access to each word in the sentence&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We can use the &lt;code&gt;#split&lt;/code&gt; method for this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;sentence.split(&#34; &#34;)&#xA;# =&amp;gt; [&#34;Hello&#34;, &#34;there,&#34;, &#34;and&#34;, &#34;how&#34;, &#34;are&#34;, &#34;you?&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also use &lt;code&gt;#split&lt;/code&gt; with no arguments, since the default argument is a space:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;sentence.split&#xA;# =&amp;gt; [&#34;Hello&#34;, &#34;there,&#34;, &#34;and&#34;, &#34;how&#34;, &#34;are&#34;, &#34;you?&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Great! Now that we know this method works in Pry, exit out of Pry in the terminal by typing &lt;code&gt;exit&lt;/code&gt; or &lt;code&gt;control + d&lt;/code&gt;. Then, back in the &lt;code&gt;reverse_each_word.rb&lt;/code&gt; file, add this code to the method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Step 2: Reverse Each Word&lt;/h3&gt; &#xA;&lt;p&gt;For the next step of our pseudocode, we&#39;ll need to tackle this problem:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Reverse each word, and add it to a new array&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We can break this step down a bit further:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create a new array&lt;/li&gt; &#xA; &lt;li&gt;Iterate over the array of words&lt;/li&gt; &#xA; &lt;li&gt;Reverse each word, and add it to the new array&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Let&#39;s start by creating a variable for the new array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, we&#39;ll need iterate over each word in the array and reverse it. You might know what do to from here, but to get some practice with Pry, let&#39;s add a &lt;code&gt;binding.pry&lt;/code&gt; breakpoint inside the &lt;code&gt;#each&lt;/code&gt; loop:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    binding.pry&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the program again with &lt;code&gt;ruby reverse_each_word.rb&lt;/code&gt;. You&#39;ll now enter a Pry session within the &lt;code&gt;#each&lt;/code&gt; loop! This makes it easy to see what&#39;s happening as you iterate over the array.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Depending on the size of your terminal window, Pry might not be able to fit your entire method on the screen, in which case you&#39;ll see a screen like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;     5: def reverse_each_word(sentence)&#xA;     6:   words = sentence.split&#xA;     7:   reversed_words = []&#xA;     8:&#xA;     9:   words.each do |word|&#xA;    10:     binding.pry&#xA;    11:   end&#xA;:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you ever get into this situation, just type the letter &lt;code&gt;q&lt;/code&gt; in the terminal to exit out.&lt;/p&gt; &#xA;&lt;p&gt;From here, our goal from the pseudocode is to:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Reverse each word, and add it to the new array&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We can try this out in the Pry session:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;word&#xA;# =&amp;gt; &#34;Hello&#34;&#xA;word.reverse&#xA;# =&amp;gt; &#34;olleH&#34;&#xA;reversed_words &amp;lt;&amp;lt; word.reverse&#xA;# =&amp;gt; [&#34;olleH&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Success! Type &lt;code&gt;exit&lt;/code&gt; now. This will exit the current breakpoint, but since our code is running in a loop, we&#39;ll hit the same breakpoint again, with the next word in the array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;word&#xA;# =&amp;gt; &#34;there,&#34;&#xA;reversed_words &amp;lt;&amp;lt; word.reverse&#xA;# =&amp;gt; [&#34;olleH&#34;, &#34;,ereht&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can type &lt;code&gt;exit&lt;/code&gt; again to see the next word, but if you&#39;re confident your code is working as expected, you can exit from Pry entirely by typing &lt;code&gt;exit-program&lt;/code&gt; or &lt;code&gt;!!!&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;You can also see a list of all Pry commands by typing &lt;code&gt;help&lt;/code&gt; from your Pry session.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Add the working code to your method. All together, your files should look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;pry&#39;&#xA;&#xA;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    reversed_words &amp;lt;&amp;lt; word.reverse&#xA;  end&#xA;end&#xA;&#xA;reverse_each_word(&#34;Hello there, and how are you?&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Step 3: Join the Reversed Array&lt;/h3&gt; &#xA;&lt;p&gt;We&#39;re onto the last step of our pseudocode:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Join the array of words on &#34; &#34; to create one string&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Let&#39;s use Pry one more time to check our work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    reversed_words &amp;lt;&amp;lt; word.reverse&#xA;  end&#xA;&#xA;  binding.pry&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the program again. From the Pry session, we can use the &lt;code&gt;#join&lt;/code&gt; method to create a string from our array of reversed words.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Remember: hit the &lt;code&gt;q&lt;/code&gt; key if you&#39;re unable to interact with the terminal in Pry!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;reversed_words.join&#xA;# =&amp;gt; &#34;olleH,erehtdnawohera?uoy&#34;&#xA;reversed_words.join(&#34; &#34;)&#xA;# =&amp;gt; &#34;olleH ,ereht dna woh era ?uoy&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;ve done it! Exit the Pry session, and add that final bit of code in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;pry&#39;&#xA;&#xA;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    reversed_words &amp;lt;&amp;lt; word.reverse&#xA;  end&#xA;&#xA;  reversed_words.join(&#34; &#34;)&#xA;end&#xA;&#xA;reverse_each_word(&#34;Hello there, and how are you?&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, let&#39;s test out our method by running the file once more with &lt;code&gt;ruby reverse_each_word.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ruby reverse_each_word.rb&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hmmm... There&#39;s no output, and there are no tests to run! How can we tell if the program is doing what we expect? One way would be to use &lt;code&gt;puts&lt;/code&gt; to inspect the output of running the method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;pry&#39;&#xA;&#xA;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    reversed_words &amp;lt;&amp;lt; word.reverse&#xA;  end&#xA;&#xA;  reversed_words.join(&#34; &#34;)&#xA;end&#xA;&#xA;puts reverse_each_word(&#34;Hello there, and how are you?&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now that we&#39;ve got some terminal output, we can see if the method does indeed produce the desired return value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ruby reverse_each_word.rb&#xA;olleH ,ereht dna woh era ?uoy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pry is also useful in this situation. Add a &lt;code&gt;binding.pry&lt;/code&gt; at the bottom of the file, followed by a 0:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;pry&#39;&#xA;&#xA;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    reversed_words &amp;lt;&amp;lt; word.reverse&#xA;  end&#xA;&#xA;  reversed_words.join(&#34; &#34;)&#xA;end&#xA;&#xA;binding.pry&#xA;0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The 0 is necessary because of some &lt;a href=&#34;https://github.com/deivid-rodriguez/pry-byebug/issues/45&#34;&gt;quirky behavior&lt;/a&gt; with &lt;code&gt;binding.pry&lt;/code&gt;: you can&#39;t use a breakpoint as the last line of code in a program. So adding any arbitrary data on the line below ensures our breakpoint will be hit.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Then run &lt;code&gt;ruby reverse_each_word.rb&lt;/code&gt; again to run the program, and enter a Pry session. From this Pry session, you can test your method with any data you like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;reverse_each_word(&#34;does it work?&#34;)&#xA;# =&amp;gt; &#34;seod ti ?krow&#34;&#xA;reverse_each_word(&#34;i think it does&#34;)&#xA;# =&amp;gt; &#34;i kniht ti seod&#34;&#xA;reverse_each_word(&#34;racecar madam wow&#34;)&#xA;# =&amp;gt; &#34;racecar madam wow&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Bonus: Refactor&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;ve had enough, feel free to skip ahead to the conclusion; for those interested in refactoring our &lt;code&gt;reverse_each_word&lt;/code&gt; method, stick around!&lt;/p&gt; &#xA;&lt;p&gt;Take a moment to review the code from the final version of our method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;  reversed_words = []&#xA;&#xA;  words.each do |word|&#xA;    reversed_words &amp;lt;&amp;lt; word.reverse&#xA;  end&#xA;&#xA;  reversed_words.join(&#34; &#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It works as intended, but are there any ways we could make this code a bit cleaner? In particular, think about our use of the &lt;code&gt;#each&lt;/code&gt; method: are there any other methods that might be better suited for the task at hand? We&#39;re trying to iterate over every element of an array, transform it in some way, and return a new array.&lt;/p&gt; &#xA;&lt;p&gt;Sounds like the perfect job for &lt;code&gt;#map&lt;/code&gt;! Try updating the method using the code below, and run &lt;code&gt;ruby reverse_each_word.rb&lt;/code&gt; to check that the refactor still produces the expected result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;&#xA;  reversed_words = words.map do |word|&#xA;    word.reverse&#xA;  end&#xA;&#xA;  reversed_words.join(&#34; &#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We could also write out &lt;code&gt;#map&lt;/code&gt; using the &lt;a href=&#34;https://www.honeybadger.io/blog/how-ruby-ampersand-colon-works/&#34;&gt;Proc shorthand&lt;/a&gt; syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  words = sentence.split&#xA;&#xA;  reversed_words = words.map(&amp;amp;:reverse)&#xA;&#xA;  reversed_words.join(&#34; &#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also take advantage of some method chaining to combine all this on one line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_each_word(sentence)&#xA;  sentence.split.map(&amp;amp;:reverse).join(&#34; &#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;You&#39;ve now had a chance to use Pry for breakpoint debugging in a few scenarios. This kind of debugging is a great way to gain confidence in what your code is doing, so make sure to practice using &lt;code&gt;binding.pry&lt;/code&gt; in the lessons to come!&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pry/pry/wiki&#34;&gt;Pry wiki&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>bensheldon/good_job</title>
    <updated>2022-06-30T01:33:13Z</updated>
    <id>tag:github.com,2022-06-30:/bensheldon/good_job</id>
    <link href="https://github.com/bensheldon/good_job" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Multithreaded, Postgres-based, ActiveJob backend for Ruby on Rails.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GoodJob&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://rubygems.org/gems/good_job&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/good_job.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bensheldon/good_job/actions&#34;&gt;&lt;img src=&#34;https://github.com/bensheldon/good_job/workflows/Test/badge.svg?sanitize=true&#34; alt=&#34;Test Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.ruby-toolbox.com/projects/good_job&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/dynamic/json?color=blue&amp;amp;label=Ruby%20Toolbox&amp;amp;query=%24.projects%5B0%5D.score&amp;amp;url=https%3A%2F%2Fwww.ruby-toolbox.com%2Fapi%2Fprojects%2Fcompare%2Fgood_job&amp;amp;logo=data:image/svg+xml;base64,PHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgZm9jdXNhYmxlPSJmYWxzZSIgZGF0YS1wcmVmaXg9ImZhcyIgZGF0YS1pY29uPSJmbGFzayIgY2xhc3M9InN2Zy1pbmxpbmUtLWZhIGZhLWZsYXNrIGZhLXctMTQiIHJvbGU9ImltZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgNDQ4IDUxMiI+PHBhdGggZmlsbD0id2hpdGUiIGQ9Ik00MzcuMiA0MDMuNUwzMjAgMjE1VjY0aDhjMTMuMyAwIDI0LTEwLjcgMjQtMjRWMjRjMC0xMy4zLTEwLjctMjQtMjQtMjRIMTIwYy0xMy4zIDAtMjQgMTAuNy0yNCAyNHYxNmMwIDEzLjMgMTAuNyAyNCAyNCAyNGg4djE1MUwxMC44IDQwMy41Qy0xOC41IDQ1MC42IDE1LjMgNTEyIDcwLjkgNTEyaDMwNi4yYzU1LjcgMCA4OS40LTYxLjUgNjAuMS0xMDguNXpNMTM3LjkgMzIwbDQ4LjItNzcuNmMzLjctNS4yIDUuOC0xMS42IDUuOC0xOC40VjY0aDY0djE2MGMwIDYuOSAyLjIgMTMuMiA1LjggMTguNGw0OC4yIDc3LjZoLTE3MnoiPjwvcGF0aD48L3N2Zz4=&#34; alt=&#34;Ruby Toolbox&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;GoodJob is a multithreaded, Postgres-based, ActiveJob backend for Ruby on Rails.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Inspired by &lt;a href=&#34;https://github.com/collectiveidea/delayed_job&#34;&gt;Delayed::Job&lt;/a&gt; and &lt;a href=&#34;https://github.com/que-rb/que&#34;&gt;Que&lt;/a&gt;, GoodJob is designed for maximum compatibility with Ruby on Rails, ActiveJob, and Postgres to be simple and performant for most workloads.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Designed for ActiveJob.&lt;/strong&gt; Complete support for &lt;a href=&#34;https://edgeguides.rubyonrails.org/active_job_basics.html&#34;&gt;async, queues, delays, priorities, timeouts, and retries&lt;/a&gt; with near-zero configuration.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Built for Rails.&lt;/strong&gt; Fully adopts Ruby on Rails &lt;a href=&#34;https://guides.rubyonrails.org/threading_and_code_execution.html&#34;&gt;threading and code execution guidelines&lt;/a&gt; with &lt;a href=&#34;https://github.com/ruby-concurrency/concurrent-ruby&#34;&gt;Concurrent::Ruby&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Backed by Postgres.&lt;/strong&gt; Relies upon Postgres integrity, session-level Advisory Locks to provide run-once safety and stay within the limits of &lt;code&gt;schema.rb&lt;/code&gt;, and LISTEN/NOTIFY to reduce queuing latency.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;For most workloads.&lt;/strong&gt; Targets full-stack teams, economy-minded solo developers, and applications that enqueue 1-million jobs/day and more.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more of the story of GoodJob, read the &lt;a href=&#34;https://island94.org/2020/07/introducing-goodjob-1-0&#34;&gt;introductory blog post&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;details markdown=&#34;1&#34;&gt; &#xA; &lt;summary&gt;&lt;strong&gt;üìä Comparison of GoodJob with other job queue backends (click to expand)&lt;/strong&gt;&lt;/summary&gt; &#xA; &lt;table&gt; &#xA;  &lt;thead&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;th&gt;&lt;/th&gt; &#xA;    &lt;th&gt;Queues, priority, retries&lt;/th&gt; &#xA;    &lt;th&gt;Database&lt;/th&gt; &#xA;    &lt;th&gt;Concurrency&lt;/th&gt; &#xA;    &lt;th&gt;Reliability/Integrity&lt;/th&gt; &#xA;    &lt;th&gt;Latency&lt;/th&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/thead&gt; &#xA;  &lt;tbody&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;strong&gt;GoodJob&lt;/strong&gt;&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Yes&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Postgres&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Multithreaded&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ ACID, Advisory Locks&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Postgres LISTEN/NOTIFY&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;strong&gt;Que&lt;/strong&gt;&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Yes&lt;/td&gt; &#xA;    &lt;td&gt;üî∂Ô∏è Postgres, requires &lt;code&gt;structure.sql&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Multithreaded&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ ACID, Advisory Locks&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Postgres LISTEN/NOTIFY&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;strong&gt;Delayed Job&lt;/strong&gt;&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Yes&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Postgres&lt;/td&gt; &#xA;    &lt;td&gt;üî¥ Single-threaded&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ ACID, record-based&lt;/td&gt; &#xA;    &lt;td&gt;üî∂ Polling&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;strong&gt;Sidekiq&lt;/strong&gt;&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Yes&lt;/td&gt; &#xA;    &lt;td&gt;üî¥ Redis&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Multithreaded&lt;/td&gt; &#xA;    &lt;td&gt;üî¥ Crashes lose jobs&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Redis BRPOP&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td&gt;&lt;strong&gt;Sidekiq Pro&lt;/strong&gt;&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Yes&lt;/td&gt; &#xA;    &lt;td&gt;üî¥ Redis&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Multithreaded&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Redis RPOPLPUSH&lt;/td&gt; &#xA;    &lt;td&gt;‚úÖ Redis RPOPLPUSH&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/tbody&gt; &#xA; &lt;/table&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#set-up&#34;&gt;Set up&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#compatibility&#34;&gt;Compatibility&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#configuration&#34;&gt;Configuration&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#command-line-options&#34;&gt;Command-line options&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#good_job-start&#34;&gt;&lt;code&gt;good_job start&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#good_job-cleanup_preserved_jobs&#34;&gt;&lt;code&gt;good_job cleanup_preserved_jobs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#configuration-options&#34;&gt;Configuration options&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#global-options&#34;&gt;Global options&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#dashboard&#34;&gt;Dashboard&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#api-only-rails-applications&#34;&gt;API-only Rails applications&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#live-polling&#34;&gt;Live Polling&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#activejob-concurrency&#34;&gt;ActiveJob concurrency&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#how-concurrency-controls-work&#34;&gt;How concurrency controls work&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#cron-style-repeatingrecurring-jobs&#34;&gt;Cron-style repeating/recurring jobs&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#updating&#34;&gt;Updating&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#upgrading-minor-versions&#34;&gt;Upgrading minor versions&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#upgrading-v2-to-v3&#34;&gt;Upgrading v2 to v3&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#upgrading-v1-to-v2&#34;&gt;Upgrading v1 to v2&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#go-deeper&#34;&gt;Go deeper&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#exceptions-retries-and-reliability&#34;&gt;Exceptions, retries, and reliability&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#exceptions&#34;&gt;Exceptions&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#retries&#34;&gt;Retries&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#actionmailer-retries&#34;&gt;ActionMailer retries&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#timeouts&#34;&gt;Timeouts&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#optimize-queues-threads-and-processes&#34;&gt;Optimize queues, threads, and processes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#database-connections&#34;&gt;Database connections&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#production-setup&#34;&gt;Production setup&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#execute-jobs-async--in-process&#34;&gt;Execute jobs async / in-process&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#migrate-to-goodjob-from-a-different-activejob-backend&#34;&gt;Migrate to GoodJob from a different ActiveJob backend&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#monitor-and-preserve-worked-jobs&#34;&gt;Monitor and preserve worked jobs&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#write-tests&#34;&gt;Write tests&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#pgbouncer-compatibility&#34;&gt;PgBouncer compatibility&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#cli-http-health-check-probes&#34;&gt;CLI HTTP health check probes&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#contribute&#34;&gt;Contribute&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#gem-development&#34;&gt;Gem development&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#development-setup&#34;&gt;Development setup&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#rails-development-harness&#34;&gt;Rails development harness&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#running-tests&#34;&gt;Running tests&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#release&#34;&gt;Release&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Set up&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Add &lt;code&gt;good_job&lt;/code&gt; to your application&#39;s Gemfile and install the gem:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;bundle add good_job&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run the GoodJob install generator. This will generate a database migration to create a table for GoodJob&#39;s job records:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g good_job:install&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Run the migration:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Optional: If using Rails&#39; multiple databases with the &lt;code&gt;migrations_paths&lt;/code&gt; configuration option, use the &lt;code&gt;--database&lt;/code&gt; option:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g good_job:install --database animals&#xA;bin/rails db:migrate:animals&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Configure the ActiveJob adapter:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/application.rb or config/environments/{RAILS_ENV}.rb&#xA;config.active_job.queue_adapter = :good_job&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Inside of your application, queue your job üéâ:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;YourJob.perform_later&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;GoodJob supports all ActiveJob features:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;YourJob.set(queue: :some_queue, wait: 5.minutes, priority: 10).perform_later&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In development, GoodJob executes jobs immediately in a separate thread (async mode). In production, GoodJob provides different options:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;By default, GoodJob separates job enqueuing from job execution so that jobs can be scaled independently of the web server. Use the GoodJob command-line tool to execute jobs:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec good_job start&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Ideally the command-line tool should be run on a separate machine or container from the web process. For example, on Heroku:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-Procfile&#34;&gt;web: rails server&#xA;worker: bundle exec good_job start&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The command-line tool supports a variety of options, see the reference below for command-line configuration.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;GoodJob can also be configured to execute jobs within the web server process to save on resources. This is useful for low-workloads when economy is paramount.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;GOOD_JOB_EXECUTION_MODE=async rails server&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Additional configuration is likely necessary, see the reference below for configuration.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ruby on Rails:&lt;/strong&gt; 6.0+&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ruby:&lt;/strong&gt; Ruby 2.5+. JRuby 9.2.13+&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Postgres:&lt;/strong&gt; 10.0+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h3&gt;Command-line options&lt;/h3&gt; &#xA;&lt;p&gt;There several top-level commands available through the &lt;code&gt;good_job&lt;/code&gt; command-line tool.&lt;/p&gt; &#xA;&lt;p&gt;Configuration options are available with &lt;code&gt;help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;good_job start&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;good_job start&lt;/code&gt; executes queued jobs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle exec good_job help start&#xA;&#xA;Usage:&#xA;  good_job start&#xA;&#xA;Options:&#xA;  [--queues=QUEUE_LIST]        # Queues or pools to work from. (env var: GOOD_JOB_QUEUES, default: *)&#xA;  [--max-threads=COUNT]        # Default number of threads per pool to use for working jobs. (env var: GOOD_JOB_MAX_THREADS, default: 5)&#xA;  [--poll-interval=SECONDS]    # Interval between polls for available jobs in seconds (env var: GOOD_JOB_POLL_INTERVAL, default: 1)&#xA;  [--max-cache=COUNT]          # Maximum number of scheduled jobs to cache in memory (env var: GOOD_JOB_MAX_CACHE, default: 10000)&#xA;  [--shutdown-timeout=SECONDS] # Number of seconds to wait for jobs to finish when shutting down before stopping the thread. (env var: GOOD_JOB_SHUTDOWN_TIMEOUT, default: -1 (forever))&#xA;  [--enable-cron]              # Whether to run cron process (default: false)&#xA;  [--daemonize]                # Run as a background daemon (default: false)&#xA;  [--pidfile=PIDFILE]          # Path to write daemonized Process ID (env var: GOOD_JOB_PIDFILE, default: tmp/pids/good_job.pid)&#xA;  [--probe-port=PORT]          # Port for http health check (env var: GOOD_JOB_PROBE_PORT, default: nil)&#xA;&#xA;Executes queued jobs.&#xA;&#xA;All options can be configured with environment variables.&#xA;See option descriptions for the matching environment variable name.&#xA;&#xA;== Configuring queues&#xA;&#xA;Separate multiple queues with commas; exclude queues with a leading minus;&#xA;separate isolated execution pools with semicolons and threads with colons.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;good_job cleanup_preserved_jobs&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;good_job cleanup_preserved_jobs&lt;/code&gt; destroys preserved job records. See &lt;code&gt;GoodJob.preserve_job_records&lt;/code&gt; for when this command is useful.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle exec good_job help cleanup_preserved_jobs&#xA;&#xA;Usage:&#xA;  good_job cleanup_preserved_jobs&#xA;&#xA;Options:&#xA;  [--before-seconds-ago=SECONDS] # Destroy records finished more than this many seconds ago (env var:  GOOD_JOB_CLEANUP_PRESERVED_JOBS_BEFORE_SECONDS_AGO, default: 86400)&#xA;&#xA;Destroys preserved job records.&#xA;&#xA;By default, GoodJob destroys job records when the job is performed and this&#xA;command is not necessary.&#xA;&#xA;However, when `GoodJob.preserve_job_records = true`, the jobs will be&#xA;preserved in the database. This is useful when wanting to analyze or&#xA;inspect job performance.&#xA;&#xA;If you are preserving job records this way, use this command regularly&#xA;to destroy old records and preserve space in your database.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuration options&lt;/h3&gt; &#xA;&lt;p&gt;ActiveJob configuration depends on where the code is placed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;config.active_job.queue_adapter = :good_job&lt;/code&gt; within &lt;code&gt;config/application.rb&lt;/code&gt; or &lt;code&gt;config/environments/*.rb&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ActiveJob::Base.queue_adapter = :good_job&lt;/code&gt; within an initializer (e.g. &lt;code&gt;config/initializers/active_job.rb&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;GoodJob configuration can be placed within Rails &lt;code&gt;config&lt;/code&gt; directory for all environments (&lt;code&gt;config/application.rb&lt;/code&gt;), within a particular environment (e.g. &lt;code&gt;config/environments/development.rb&lt;/code&gt;), or within an initializer (e.g. &lt;code&gt;config/initializers/good_job.rb&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Configuration examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.application.configure do&#xA;  # Configure options individually...&#xA;  config.good_job.preserve_job_records = true&#xA;  config.good_job.retry_on_unhandled_error = false&#xA;  config.good_job.on_thread_error = -&amp;gt; (exception) { Raven.capture_exception(exception) }&#xA;  config.good_job.execution_mode = :async&#xA;  config.good_job.queues = &#39;*&#39;&#xA;  config.good_job.max_threads = 5&#xA;  config.good_job.poll_interval = 30 # seconds&#xA;  config.good_job.shutdown_timeout = 25 # seconds&#xA;  config.good_job.enable_cron = true&#xA;  config.good_job.cron = { example: { cron: &#39;0 * * * *&#39;, class: &#39;ExampleJob&#39;  } }&#xA;&#xA;  # ...or all at once.&#xA;  config.good_job = {&#xA;    preserve_job_records: true,&#xA;    retry_on_unhandled_error: false,&#xA;    on_thread_error: -&amp;gt; (exception) { Raven.capture_exception(exception) },&#xA;    execution_mode: :async,&#xA;    queues: &#39;*&#39;,&#xA;    max_threads: 5,&#xA;    poll_interval: 30,&#xA;    shutdown_timeout: 25,&#xA;    enable_cron: true,&#xA;    cron: {&#xA;      example: {&#xA;        cron: &#39;0 * * * *&#39;,&#xA;        class: &#39;ExampleJob&#39;&#xA;      },&#xA;    },&#xA;  }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Available configuration options are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;execution_mode&lt;/code&gt; (symbol) specifies how and where jobs should be executed. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_EXECUTION_MODE&lt;/code&gt;. It can be any one of:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;:inline&lt;/code&gt; executes jobs immediately in whatever process queued them (usually the web server process). This should only be used in test and development environments.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:external&lt;/code&gt; causes the adapter to enqueue jobs, but not execute them. When using this option (the default for production environments), you‚Äôll need to use the command-line tool to actually execute your jobs.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:async&lt;/code&gt; (or &lt;code&gt;:async_server&lt;/code&gt;) executes jobs in separate threads within the Rails web server process (&lt;code&gt;bundle exec rails server&lt;/code&gt;). It can be more economical for small workloads because you don‚Äôt need a separate machine or environment for running your jobs, but if your web server is under heavy load or your jobs require a lot of resources, you should choose &lt;code&gt;:external&lt;/code&gt; instead. When not in the Rails web server, jobs will execute in &lt;code&gt;:external&lt;/code&gt; mode to ensure jobs are not executed within &lt;code&gt;rails console&lt;/code&gt;, &lt;code&gt;rails db:migrate&lt;/code&gt;, &lt;code&gt;rails assets:prepare&lt;/code&gt;, etc.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:async_all&lt;/code&gt; executes jobs in separate threads in &lt;em&gt;any&lt;/em&gt; Rails process.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;queues&lt;/code&gt; (string) sets queues or pools to execute jobs. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_QUEUES&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;max_threads&lt;/code&gt; (integer) sets the default number of threads per pool to use for working jobs. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_MAX_THREADS&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;poll_interval&lt;/code&gt; (integer) sets the number of seconds between polls for jobs when &lt;code&gt;execution_mode&lt;/code&gt; is set to &lt;code&gt;:async&lt;/code&gt;. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_POLL_INTERVAL&lt;/code&gt;. A poll interval of &lt;code&gt;-1&lt;/code&gt; disables polling completely.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;max_cache&lt;/code&gt; (integer) sets the maximum number of scheduled jobs that will be stored in memory to reduce execution latency when also polling for scheduled jobs. Caching 10,000 scheduled jobs uses approximately 20MB of memory. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_MAX_CACHE&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;shutdown_timeout&lt;/code&gt; (float) number of seconds to wait for jobs to finish when shutting down before stopping the thread. Defaults to forever: &lt;code&gt;-1&lt;/code&gt;. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_SHUTDOWN_TIMEOUT&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;enable_cron&lt;/code&gt; (boolean) whether to run cron process. Defaults to &lt;code&gt;false&lt;/code&gt;. You can also set this with the environment variable &lt;code&gt;GOOD_JOB_ENABLE_CRON&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cron&lt;/code&gt; (hash) cron configuration. Defaults to &lt;code&gt;{}&lt;/code&gt;. You can also set this as a JSON string with the environment variable &lt;code&gt;GOOD_JOB_CRON&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cleanup_discarded_jobs&lt;/code&gt; (boolean) whether to destroy discarded jobs when cleaning up preserved jobs using the &lt;code&gt;$ good_job cleanup_preserved_jobs&lt;/code&gt; CLI command or calling &lt;code&gt;GoodJob.cleanup_preserved_jobs&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;. Can also be set with the environment variable &lt;code&gt;GOOD_JOB_CLEANUP_DISCARDED_JOBS&lt;/code&gt;. &lt;em&gt;This configuration is only used when {GoodJob.preserve_job_records} is &lt;code&gt;true&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cleanup_preserved_jobs_before_seconds_ago&lt;/code&gt; (integer) number of seconds to preserve jobs when using the &lt;code&gt;$ good_job cleanup_preserved_jobs&lt;/code&gt; CLI command or calling &lt;code&gt;GoodJob.cleanup_preserved_jobs&lt;/code&gt;. Defaults to &lt;code&gt;86400&lt;/code&gt; (1 day). Can also be set with the environment variable &lt;code&gt;GOOD_JOB_CLEANUP_PRESERVED_JOBS_BEFORE_SECONDS_AGO&lt;/code&gt;. &lt;em&gt;This configuration is only used when {GoodJob.preserve_job_records} is &lt;code&gt;true&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cleanup_interval_jobs&lt;/code&gt; (integer) Number of jobs a Scheduler will execute before cleaning up preserved jobs. Defaults to &lt;code&gt;nil&lt;/code&gt;. Can also be set with the environment variable &lt;code&gt;GOOD_JOB_CLEANUP_INTERVAL_JOBS&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;cleanup_interval_seconds&lt;/code&gt; (integer) Number of seconds a Scheduler will wait before cleaning up preserved jobs. Defaults to &lt;code&gt;nil&lt;/code&gt;. Can also be set with the environment variable &lt;code&gt;GOOD_JOB_CLEANUP_INTERVAL_SECONDS&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;inline_execution_respects_schedule&lt;/code&gt; (boolean) Opt-in to future behavior of inline execution respecting scheduled jobs. Defaults to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;logger&lt;/code&gt; (&lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveSupport/Logger.html&#34;&gt;Rails Logger&lt;/a&gt;) lets you set a custom logger for GoodJob. It should be an instance of a Rails &lt;code&gt;Logger&lt;/code&gt; (Default: &lt;code&gt;Rails.logger&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;preserve_job_records&lt;/code&gt; (boolean) keeps job records in your database even after jobs are completed. (Default: &lt;code&gt;true&lt;/code&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;retry_on_unhandled_error&lt;/code&gt; (boolean) causes jobs to be re-queued and retried if they raise an instance of &lt;code&gt;StandardError&lt;/code&gt;. Be advised this may lead to jobs being repeated infinitely (&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#retries&#34;&gt;see below for more on retries&lt;/a&gt;). Instances of &lt;code&gt;Exception&lt;/code&gt;, like SIGINT, will &lt;em&gt;always&lt;/em&gt; be retried, regardless of this attribute‚Äôs value. (Default: &lt;code&gt;true&lt;/code&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;on_thread_error&lt;/code&gt; (proc, lambda, or callable) will be called when an Exception. It can be useful for logging errors to bug tracking services, like Sentry or Airbrake. Example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.good_job.on_thread_error = -&amp;gt; (exception) { Raven.capture_exception(exception) }&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default, GoodJob configures the following execution modes per environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#xA;# config/environments/development.rb&#xA;config.active_job.queue_adapter = :good_job&#xA;config.good_job.execution_mode = :async&#xA;&#xA;# config/environments/test.rb&#xA;config.active_job.queue_adapter = :good_job&#xA;config.good_job.execution_mode = :inline&#xA;&#xA;# config/environments/production.rb&#xA;config.active_job.queue_adapter = :good_job&#xA;config.good_job.execution_mode = :external&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Global options&lt;/h3&gt; &#xA;&lt;p&gt;Good Job‚Äôs general behavior can also be configured via attributes directly on the &lt;code&gt;GoodJob&lt;/code&gt; module:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;GoodJob.active_record_parent_class&lt;/code&gt;&lt;/strong&gt; (string) The ActiveRecord parent class inherited by GoodJob&#39;s ActiveRecord model &lt;code&gt;GoodJob::Job&lt;/code&gt; (defaults to &lt;code&gt;&#34;ActiveRecord::Base&#34;&lt;/code&gt;). Configure this when using &lt;a href=&#34;https://guides.rubyonrails.org/active_record_multiple_databases.html&#34;&gt;multiple databases with ActiveRecord&lt;/a&gt; or when other custom configuration is necessary for the ActiveRecord model to connect to the Postgres database. &lt;em&gt;The value must be a String to avoid premature initialization of ActiveRecord.&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;GoodJob.logger&lt;/code&gt;&lt;/strong&gt; (&lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveSupport/Logger.html&#34;&gt;Rails Logger&lt;/a&gt;) lets you set a custom logger for GoodJob. It should be an instance of a Rails &lt;code&gt;Logger&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;GoodJob.preserve_job_records&lt;/code&gt;&lt;/strong&gt; (boolean) keeps job records in your database even after jobs are completed. (Default: &lt;code&gt;true&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;GoodJob.retry_on_unhandled_error&lt;/code&gt;&lt;/strong&gt; (boolean) causes jobs to be re-queued and retried if they raise an instance of &lt;code&gt;StandardError&lt;/code&gt;. Be advised this may lead to jobs being repeated infinitely (&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#retries&#34;&gt;see below for more on retries&lt;/a&gt;). Instances of &lt;code&gt;Exception&lt;/code&gt;, like SIGINT, will &lt;em&gt;always&lt;/em&gt; be retried, regardless of this attribute‚Äôs value. (Default: &lt;code&gt;false&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;GoodJob.on_thread_error&lt;/code&gt;&lt;/strong&gt; (proc, lambda, or callable) will be called when an Exception. It can be useful for logging errors to bug tracking services, like Sentry or Airbrake.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You‚Äôll generally want to configure these in &lt;code&gt;config/initializers/good_job.rb&lt;/code&gt;, like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;GoodJob.active_record_parent_class = &#34;ApplicationRecord&#34;&#xA;GoodJob.preserve_job_records = true&#xA;GoodJob.retry_on_unhandled_error = false&#xA;GoodJob.on_thread_error = -&amp;gt; (exception) { Raven.capture_exception(exception) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dashboard&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/bensheldon/good_job/raw/main/SCREENSHOT.png&#34; alt=&#34;Dashboard UI&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;üöß GoodJob&#39;s dashboard is a work in progress. Please contribute ideas and code on &lt;a href=&#34;https://github.com/bensheldon/good_job/issues&#34;&gt;Github&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;GoodJob includes a Dashboard as a mountable &lt;code&gt;Rails::Engine&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Mount the engine in your &lt;code&gt;config/routes.rb&lt;/code&gt; file. The following will mount it at &lt;code&gt;http://example.com/good_job&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/routes.rb&#xA;# ...&#xA;mount GoodJob::Engine =&amp;gt; &#39;good_job&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Configure authentication. Because jobs can potentially contain sensitive information, you should authorize access. For example, using Devise&#39;s &lt;code&gt;authenticate&lt;/code&gt; helper, that might look like:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/routes.rb&#xA;# ...&#xA;authenticate :user, -&amp;gt;(user) { user.admin? } do&#xA;  mount GoodJob::Engine =&amp;gt; &#39;good_job&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Another option is using basic auth like this:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;GoodJob::Engine.middleware.use(Rack::Auth::Basic) do |username, password|&#xA;  ActiveSupport::SecurityUtils.secure_compare(Rails.application.credentials.good_job_username, username) &amp;amp;&amp;amp;&#xA;    ActiveSupport::SecurityUtils.secure_compare(Rails.application.credentials.good_job_password, password)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you want to see finished (successful) and discarded (failed) jobs on the dashboard, you will have to configure job records to be preserved:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# eg in config/initializers/good_job.rb&#xA;GoodJob.preserve_job_records = true&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;See more at &lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#monitor-and-preserve-worked-jobs&#34;&gt;Monitor and preserve worked jobs&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;API-only Rails applications&lt;/h4&gt; &#xA;&lt;p&gt;API-only Rails applications may not have all of the required Rack middleware for the GoodJob Dashboard to function. To re-add the middlware:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/application.rb&#xA;module MyApp&#xA;  class Application &amp;lt; Rails::Application&#xA;    #...&#xA;    config.middleware.use Rack::MethodOverride&#xA;    config.middleware.use ActionDispatch::Flash&#xA;    config.middleware.use ActionDispatch::Cookies&#xA;    config.middleware.use ActionDispatch::Session::CookieStore&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Live Polling&lt;/h4&gt; &#xA;&lt;p&gt;The Dashboard can be set to automatically refresh by checking &#34;Live Poll&#34; in the Dashboard header, or by setting &lt;code&gt;?poll=10&lt;/code&gt; with the interval in seconds (default 30 seconds).&lt;/p&gt; &#xA;&lt;h3&gt;ActiveJob concurrency&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob can extend ActiveJob to provide limits on concurrently running jobs, either at time of &lt;em&gt;enqueue&lt;/em&gt; or at &lt;em&gt;perform&lt;/em&gt;. Limiting concurrency can help prevent duplicate, double or unecessary jobs from being enqueued, or race conditions when performing, for example when interacting with 3rd-party APIs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyJob &amp;lt; ApplicationJob&#xA;  include GoodJob::ActiveJobExtensions::Concurrency&#xA;&#xA;  good_job_control_concurrency_with(&#xA;    # Maximum number of unfinished jobs to allow with the concurrency key&#xA;    total_limit: 1,&#xA;&#xA;    # Or, if more control is needed:&#xA;    # Maximum number of jobs with the concurrency key to be&#xA;    # concurrently enqueued (excludes performing jobs)&#xA;    enqueue_limit: 2,&#xA;&#xA;    # Maximum number of jobs with the concurrency key to be&#xA;    # concurrently performed (excludes enqueued jobs)&#xA;    perform_limit: 1,&#xA;&#xA;    # Note: Under heavy load, the total number of jobs may exceed the&#xA;    # sum of `enqueue_limit` and `perform_limit` because of race conditions&#xA;    # caused by imperfectly disjunctive states. If you need to constrain&#xA;    # the total number of jobs, use `total_limit` instead. See #378.&#xA;&#xA;    # A unique key to be globally locked against.&#xA;    # Can be String or Lambda/Proc that is invoked in the context of the job.&#xA;    # Note: Arguments passed to #perform_later can be accessed through ActiveJob&#39;s `arguments` method&#xA;    # which is an array containing positional arguments and, optionally, a kwarg hash.&#xA;    key: -&amp;gt; { &#34;Unique-#{arguments.first}-#{arguments.last[:version]}&#34; } #  MyJob.perform_later(&#34;Alice&#34;, version: &#39;v2&#39;) =&amp;gt; &#34;Unique-Alice-v2&#34;&#xA;  )&#xA;&#xA;  def perform(first_name)&#xA;    # do work&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When testing, the resulting concurrency key value can be inspected:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;job = MyJob.perform_later(&#34;Alice&#34;)&#xA;job.good_job_concurrency_key #=&amp;gt; &#34;Unique-Alice&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;How concurrency controls work&lt;/h4&gt; &#xA;&lt;p&gt;GoodJob&#39;s concurrency control strategy for &lt;code&gt;perform_limit&lt;/code&gt; is &#34;optimistic retry with an incremental backoff&#34;. The &lt;a href=&#34;https://github.com/bensheldon/good_job/raw/main/lib/good_job/active_job_extensions/concurrency.rb&#34;&gt;code is readable&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;Optimistic&#34; meaning that the implementation&#39;s performance trade-off assumes that collisions are atypical (e.g. two users enqueue the same job at the same time) rather than regular (e.g. the system enqueues thousands of colliding jobs at the same time).&lt;/li&gt; &#xA; &lt;li&gt;&#34;Retry with an incremental backoff&#34; means that when &lt;code&gt;perform_limit&lt;/code&gt; is exceeded, the job will raise a &lt;code&gt;GoodJob::ActiveJobExtensions::Concurrency::ConcurrencyExceededError&lt;/code&gt; which is caught by a &lt;code&gt;retry_on&lt;/code&gt; handler which re-schedules the job to execute in the near future with an incremental backoff.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Cron-style repeating/recurring jobs&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob can enqueue jobs on a recurring basis that can be used as a replacement for cron.&lt;/p&gt; &#xA;&lt;p&gt;Cron-style jobs are run on every GoodJob process (e.g. CLI or &lt;code&gt;async&lt;/code&gt; execution mode) when &lt;code&gt;config.good_job.enable_cron = true&lt;/code&gt;, but GoodJob&#39;s cron uses unique indexes to ensure that only a single job is enqeued at the given time interval.&lt;/p&gt; &#xA;&lt;p&gt;Cron-format is parsed by the &lt;a href=&#34;https://github.com/floraison/fugit&#34;&gt;&lt;code&gt;fugit&lt;/code&gt;&lt;/a&gt; gem, which has support for seconds-level resolution (e.g. &lt;code&gt;* * * * * *&lt;/code&gt;) and natural language parsing (e.g. &lt;code&gt;every second&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/environments/application.rb or a specific environment e.g. production.rb&#xA;&#xA;# Enable cron in this process; e.g. only run on the first Heroku worker process&#xA;config.good_job.enable_cron = ENV[&#39;DYNO&#39;] == &#39;worker.1&#39; # or `true` or via $GOOD_JOB_ENABLE_CRON&#xA;&#xA;# Configure cron with a hash that has a unique key for each recurring job&#xA;config.good_job.cron = {&#xA;  # Every 15 minutes, enqueue `ExampleJob.set(priority: -10).perform_later(42, name: &#34;Alice&#34;)`&#xA;  frequent_task: { # each recurring job must have a unique key&#xA;    cron: &#34;*/15 * * * *&#34;, # cron-style scheduling format by fugit gem&#xA;    class: &#34;ExampleJob&#34;, # reference the Job class with a string&#xA;    args: [42, &#34;life&#34;], # positional arguments to pass; can also be a proc e.g. `-&amp;gt; { [Time.now] }`&#xA;    kwargs: { name: &#34;Alice&#34; }, # keyword arguments to pass; can also be a proc e.g. `-&amp;gt; { { name: NAMES.sample } }`&#xA;    set: { priority: -10 }, # additional ActiveJob properties; can also be a lambda/proc e.g. `-&amp;gt; { { priority: [1,2].sample } }`&#xA;    description: &#34;Something helpful&#34;, # optional description that appears in Dashboard (coming soon!)&#xA;  },&#xA;  another_task: {&#xA;    cron: &#34;0 0,12 * * *&#34;,&#xA;    class: &#34;AnotherJob&#34;,&#xA;  },&#xA;  # etc.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Updating&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob follows semantic versioning, though updates may be encouraged through deprecation warnings in minor versions.&lt;/p&gt; &#xA;&lt;h4&gt;Upgrading minor versions&lt;/h4&gt; &#xA;&lt;p&gt;Upgrading between minor versions (e.g. v1.4 to v1.5) should not introduce breaking changes, but can introduce new deprecation warnings and database migration notices.&lt;/p&gt; &#xA;&lt;p&gt;To perform upgrades to the GoodJob database tables:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Generate new database migration files:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g good_job:update&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Optional: If using Rails&#39; multiple databases with the &lt;code&gt;migrations_paths&lt;/code&gt; configuration option, use the &lt;code&gt;--database&lt;/code&gt; option:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails g good_job:update --database animals&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run the database migration locally&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rails db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Commit the migration files and resulting &lt;code&gt;db/schema.rb&lt;/code&gt; changes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Deploy the code, run the migrations against the production database, and restart server/worker processes.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Upgrading v2 to v3&lt;/h4&gt; &#xA;&lt;p&gt;GoodJob v3 is operationally identical to v2; upgrading to GoodJob v3 should be simple. If you are already using &lt;code&gt;&amp;gt;= v2.9+&lt;/code&gt; no other changes are necessary.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Upgrade to &lt;code&gt;v2.99.x&lt;/code&gt;, following the minor version upgrade process, running any remaining database migrations (&lt;code&gt;rails g good_job:update&lt;/code&gt;) and addressing deprecation warnings.&lt;/li&gt; &#xA; &lt;li&gt;Upgrade from &lt;code&gt;v2.99.x&lt;/code&gt; to &lt;code&gt;v3.x&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Notable changes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Defaults to preserve job records, and automatically delete them after 14 days.&lt;/li&gt; &#xA; &lt;li&gt;Defaults to discarding failed jobs, instead of immediately retrying them.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:inline&lt;/code&gt; execution mode respects job schedules. Tests can invoke &lt;code&gt;GoodJob.perform_inline&lt;/code&gt; to execute jobs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;GoodJob::Adapter&lt;/code&gt; can no longer can be initialized with custom execution options (&lt;code&gt;queues:&lt;/code&gt;, &lt;code&gt;max_threads:&lt;/code&gt;, &lt;code&gt;poll_interval:&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Renames &lt;code&gt;GoodJob::ActiveJobJob&lt;/code&gt; to &lt;code&gt;GoodJob::Job&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Removes support for Rails 5.2.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Upgrading v1 to v2&lt;/h4&gt; &#xA;&lt;p&gt;GoodJob v2 introduces a new Advisory Lock key format that is operationally different than the v1 advisory lock key format; it&#39;s therefore necessary to perform a simple, but staged production upgrade. If you are already using &lt;code&gt;&amp;gt;= v1.12+&lt;/code&gt; no other changes are necessary.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Upgrade your production environment to &lt;code&gt;v1.99.x&lt;/code&gt; following the minor version upgrade process, including database migrations. &lt;code&gt;v1.99&lt;/code&gt; is a transitional release that is safely compatible with both &lt;code&gt;v1.x&lt;/code&gt; and &lt;code&gt;v2.0.0&lt;/code&gt; because it uses both &lt;code&gt;v1&lt;/code&gt;- and &lt;code&gt;v2&lt;/code&gt;-formatted advisory locks.&lt;/li&gt; &#xA; &lt;li&gt;Address any deprecation warnings generated by &lt;code&gt;v1.99&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Upgrade your production environment to &lt;code&gt;v1.99.x&lt;/code&gt; to &lt;code&gt;v2.0.x&lt;/code&gt; again following the &lt;em&gt;minor&lt;/em&gt; upgrade process.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Notable changes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Renames &lt;code&gt;:async_server&lt;/code&gt; execution mode to &lt;code&gt;:async&lt;/code&gt;; renames prior &lt;code&gt;:async&lt;/code&gt; execution mode to &lt;code&gt;:async_all&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Sets default Development environment&#39;s execution mode to &lt;code&gt;:async&lt;/code&gt; with disabled polling.&lt;/li&gt; &#xA; &lt;li&gt;Excludes performing jobs from &lt;code&gt;enqueue_limit&lt;/code&gt;&#39;s count in &lt;code&gt;GoodJob::ActiveJobExtensions::Concurrency&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Triggers &lt;code&gt;GoodJob.on_thread_error&lt;/code&gt; for unhandled ActiveJob exceptions.&lt;/li&gt; &#xA; &lt;li&gt;Renames &lt;code&gt;GoodJob.reperform_jobs_on_standard_error&lt;/code&gt; accessor to &lt;code&gt;GoodJob.retry_on_unhandled_error&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Renames &lt;code&gt;GoodJob::Adapter.shutdown(wait:)&lt;/code&gt; argument to &lt;code&gt;GoodJob::Adapter.shutdown(timeout:)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Changes Advisory Lock key format from &lt;code&gt;good_jobs[ROW_ID]&lt;/code&gt; to &lt;code&gt;good_jobs-[ACTIVE_JOB_ID]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Expects presence of columns &lt;code&gt;good_jobs.active_job_id&lt;/code&gt;, &lt;code&gt;good_jobs.concurrency_key&lt;/code&gt;, &lt;code&gt;good_jobs.concurrency_key&lt;/code&gt;, and &lt;code&gt;good_jobs.retried_good_job_id&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Go deeper&lt;/h2&gt; &#xA;&lt;h3&gt;Exceptions, retries, and reliability&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob guarantees that a completely-performed job will run once and only once. GoodJob fully supports ActiveJob&#39;s built-in functionality for error handling, retries and timeouts.&lt;/p&gt; &#xA;&lt;h4&gt;Exceptions&lt;/h4&gt; &#xA;&lt;p&gt;ActiveJob provides &lt;a href=&#34;https://guides.rubyonrails.org/active_job_basics.html#exceptions&#34;&gt;tools for rescuing and retrying exceptions&lt;/a&gt;, including &lt;code&gt;retry_on&lt;/code&gt;, &lt;code&gt;discard_on&lt;/code&gt;, &lt;code&gt;rescue_from&lt;/code&gt; that will rescue exceptions before they get to GoodJob.&lt;/p&gt; &#xA;&lt;p&gt;If errors do reach GoodJob, you can assign a callable to &lt;code&gt;GoodJob.on_thread_error&lt;/code&gt; to be notified. For example, to log errors to an exception monitoring service like Sentry (or Bugsnag, Airbrake, Honeybadger, etc.):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;GoodJob.on_thread_error = -&amp;gt; (exception) { Raven.capture_exception(exception) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Retries&lt;/h4&gt; &#xA;&lt;p&gt;By default, GoodJob relies on ActiveJob&#39;s retry functionality.&lt;/p&gt; &#xA;&lt;p&gt;ActiveJob can be configured to retry an infinite number of times, with an exponential backoff. Using ActiveJob&#39;s &lt;code&gt;retry_on&lt;/code&gt; prevents exceptions from reaching GoodJob:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationJob &amp;lt; ActiveJob::Base&#xA;  retry_on StandardError, wait: :exponentially_longer, attempts: Float::INFINITY&#xA;  # ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using &lt;code&gt;retry_on&lt;/code&gt; with &lt;em&gt;a limited number of retries&lt;/em&gt;, the final exception will not be rescued and will raise to GoodJob&#39;s error handler. To avoid this, pass a block to &lt;code&gt;retry_on&lt;/code&gt; to handle the final exception instead of raising it to GoodJob:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationJob &amp;lt; ActiveJob::Base&#xA;  retry_on StandardError, attempts: 5 do |_job, _exception|&#xA;    # Log error, do nothing, etc.&#xA;  end&#xA;  # ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using &lt;code&gt;retry_on&lt;/code&gt; with an infinite number of retries, exceptions will never be raised to GoodJob, which means &lt;code&gt;GoodJob.on_thread_error&lt;/code&gt; will never be called. To report log or report exceptions to an exception monitoring service (e.g. Sentry, Bugsnag, Airbrake, Honeybadger, etc), create an explicit exception wrapper. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationJob &amp;lt; ActiveJob::Base&#xA;  retry_on StandardError, wait: :exponentially_longer, attempts: Float::INFINITY&#xA;&#xA;  retry_on SpecialError, attempts: 5 do |_job, exception|&#xA;    Raven.capture_exception(exception)&#xA;  end&#xA;&#xA;  around_perform do |_job, block|&#xA;    block.call&#xA;  rescue StandardError =&amp;gt; e&#xA;    Raven.capture_exception(e)&#xA;    raise&#xA;  end&#xA;  # ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, jobs will not be retried unless &lt;code&gt;retry_on&lt;/code&gt; is configured. This can be overridden by setting &lt;code&gt;GoodJob.retry_on_unhandled_error&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;; GoodJob will then retry the failing job immediately and infinitely, potentially causing high load.&lt;/p&gt; &#xA;&lt;h4&gt;ActionMailer retries&lt;/h4&gt; &#xA;&lt;p&gt;Any configuration in &lt;code&gt;ApplicationJob&lt;/code&gt; will have to be duplicated on &lt;code&gt;ActionMailer::MailDeliveryJob&lt;/code&gt; because ActionMailer uses that custom class which inherits from &lt;code&gt;ActiveJob::Base&lt;/code&gt;, rather than your application&#39;s &lt;code&gt;ApplicationJob&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can use an initializer to configure &lt;code&gt;ActionMailer::MailDeliveryJob&lt;/code&gt;, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;ActionMailer::MailDeliveryJob.retry_on StandardError, wait: :exponentially_longer, attempts: Float::INFINITY&#xA;&#xA;# With Sentry (or Bugsnag, Airbrake, Honeybadger, etc.)&#xA;ActionMailer::MailDeliveryJob.around_perform do |_job, block|&#xA;  block.call&#xA;rescue StandardError =&amp;gt; e&#xA;  Raven.capture_exception(e)&#xA;  raise&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note, that &lt;code&gt;ActionMailer::MailDeliveryJob&lt;/code&gt; is a default since Rails 6.0. Be sure that your app is using that class, as it might also be configured to use (deprecated now) &lt;code&gt;ActionMailer::DeliveryJob&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Timeouts&lt;/h3&gt; &#xA;&lt;p&gt;Job timeouts can be configured with an &lt;code&gt;around_perform&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationJob &amp;lt; ActiveJob::Base&#xA;  JobTimeoutError = Class.new(StandardError)&#xA;&#xA;  around_perform do |_job, block|&#xA;    # Timeout jobs after 10 minutes&#xA;    Timeout.timeout(10.minutes, JobTimeoutError) do&#xA;      block.call&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Optimize queues, threads, and processes&lt;/h3&gt; &#xA;&lt;p&gt;By default, GoodJob creates a single thread execution pool that will execute jobs from any queue. Depending on your application&#39;s workload, job types, and service level objectives, you may wish to optimize execution resources. For example, providing dedicated execution resources for transactional emails so they are not delayed by long-running batch jobs. Some options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Multiple isolated execution pools within a single process:&lt;/p&gt; &lt;p&gt;For moderate workloads, multiple isolated thread execution pools offers a good balance between congestion management and economy.&lt;/p&gt; &lt;p&gt;A pool is configured with the following syntax &lt;code&gt;&amp;lt;participating_queues&amp;gt;:&amp;lt;thread_count&amp;gt;&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;&amp;lt;participating_queues&amp;gt;&lt;/code&gt;: either &lt;code&gt;queue1,queue2&lt;/code&gt; (only those queues), &lt;code&gt;*&lt;/code&gt; (all) or &lt;code&gt;-queue1,queue2&lt;/code&gt; (all except those queues).&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;&amp;lt;thread_count&amp;gt;&lt;/code&gt;: a count overriding for this specific pool the global &lt;code&gt;max-threads&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Pool configurations are separated with a semicolon (;) in the &lt;code&gt;queues&lt;/code&gt; configuration&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle exec good_job \&#xA;    --queues=&#34;transactional_messages:2;batch_processing:1;-transactional_messages,batch_processing:2;*&#34; \&#xA;    --max-threads=5&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This configuration will result in a single process with 4 isolated thread execution pools.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;transactional_messages:2&lt;/code&gt;: execute jobs enqueued on &lt;code&gt;transactional_messages&lt;/code&gt;, with up to 2 threads.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;batch_processing:1&lt;/code&gt; execute jobs enqueued on &lt;code&gt;batch_processing&lt;/code&gt;, with a single thread.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;-transactional_messages,batch_processing&lt;/code&gt;: execute jobs enqueued on &lt;em&gt;any&lt;/em&gt; queue &lt;em&gt;excluding&lt;/em&gt; &lt;code&gt;transactional_messages&lt;/code&gt; or &lt;code&gt;batch_processing&lt;/code&gt;, with up to 2 threads.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;*&lt;/code&gt;: execute jobs on any queue, with up to 5 threads (as configured by &lt;code&gt;--max-threads=5&lt;/code&gt;).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Configuration can be injected by environment variables too:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ GOOD_JOB_QUEUES=&#34;transactional_messages:2;batch_processing:1;-transactional_messages,batch_processing:2;*&#34; \&#xA;  GOOD_JOB_MAX_THREADS=5 \&#xA;  bundle exec good_job&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Multiple processes:&lt;/p&gt; &lt;p&gt;While multiple isolated thread execution pools offer a way to provide dedicated execution resources, those resources are bound to a single machine. To scale them independently, define several processes.&lt;/p&gt; &lt;p&gt;For example, this configuration on Heroku allows to customize the dyno count (instances), or type (CPU/RAM), per process type:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-procfile&#34;&gt;# Procfile&#xA;&#xA;# Separate process types&#xA;worker: bundle exec good_job --max-threads=5&#xA;transactional_worker: bundle exec good_job --queues=&#34;transactional_messages&#34; --max-threads=2&#xA;batch_worker: bundle exec good_job --queues=&#34;batch_processing&#34; --max-threads=1&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;To optimize for CPU performance at the expense of greater memory and system resource usage, while keeping a single process type (and thus a single dyno), combine several processes and wait for them:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-procfile&#34;&gt;# Procfile&#xA;&#xA;# Combined multi-process&#xA;combined_worker: bundle exec good_job --max-threads=5 &amp;amp; bundle exec good_job --queues=&#34;transactional_messages&#34; --max-threads=2 &amp;amp; bundle exec good_job --queues=&#34;batch_processing&#34; --max-threads=1 &amp;amp; wait -n&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Keep in mind, queue operations and management is an advanced discipline. This stuff is complex, especially for heavy workloads and unique processing requirements. Good job üëç&lt;/p&gt; &#xA;&lt;h3&gt;Database connections&lt;/h3&gt; &#xA;&lt;p&gt;Each GoodJob execution thread requires its own database connection that is automatically checked out from Rails‚Äô connection pool. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# config/database.yml&#xA;pool: &amp;lt;%= ENV.fetch(&#34;RAILS_MAX_THREADS&#34;, 5).to_i + 3 + (ENV.fetch(&#34;GOOD_JOB_MAX_THREADS&#34;, 5).to_i %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To calculate the total number of the database connections you&#39;ll need:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;1 connection dedicated to the scheduler aka &lt;code&gt;LISTEN/NOTIFY&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;1 connection per query pool thread e.g. &lt;code&gt;--queues=mice:2;elephants:1&lt;/code&gt; is 3 threads. Pool thread size defaults to &lt;code&gt;--max-threads&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;(optional) 2 connections for Cron scheduler if you&#39;re running it&lt;/li&gt; &#xA; &lt;li&gt;(optional) 1 connection per subthread, if your application makes multithreaded database queries within a job&lt;/li&gt; &#xA; &lt;li&gt;When running &lt;code&gt;:async&lt;/code&gt;, you must also add the number of threads by the webserver&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The queue process will not crash if the connections pool is exhausted, instead it will report an exception (eg. &lt;code&gt;ActiveRecord::ConnectionTimeoutError&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;Production setup&lt;/h4&gt; &#xA;&lt;p&gt;When running GoodJob in a production environment, you should be mindful of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/execute-jobs-async--in-process&#34;&gt;Execution mode&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#database-connections&#34;&gt;Database connection pool size&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#cli-http-health-check-probes&#34;&gt;Health check probes&lt;/a&gt; and potentially the &lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/#monitor-and-preserve-worked-jobs&#34;&gt;instrumentation support&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The recommended way to monitor the queue in production is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;have an exception notifier callback (see &lt;code&gt;on_thread_error&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;if possible, run the queue as a dedicated instance and use available HTTP health check probes instead of pid-based monitoring&lt;/li&gt; &#xA; &lt;li&gt;keep an eye on the number of jobs in the queue (abnormal high number of unscheduled jobs means the queue could be underperforming)&lt;/li&gt; &#xA; &lt;li&gt;consider performance monitoring services which support the built-in Rails instrumentation (eg. Sentry, Skylight, etc.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Execute jobs async / in-process&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob can execute jobs &#34;async&#34; in the same process as the web server (e.g. &lt;code&gt;bin/rails s&lt;/code&gt;). GoodJob&#39;s async execution mode offers benefits of economy by not requiring a separate job worker process, but with the tradeoff of increased complexity. Async mode can be configured in two ways:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Via Rails configuration:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/environments/production.rb&#xA;config.active_job.queue_adapter = :good_job&#xA;&#xA;# To change the execution mode&#xA;config.good_job.execution_mode = :async&#xA;&#xA;# Or with more configuration&#xA;config.good_job = {&#xA;  execution_mode: :async,&#xA;  max_threads: 4,&#xA;  poll_interval: 30&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Or, with environment variables:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;GOOD_JOB_EXECUTION_MODE=async GOOD_JOB_MAX_THREADS=4 GOOD_JOB_POLL_INTERVAL=30 bin/rails server&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Depending on your application configuration, you may need to take additional steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Ensure that you have enough database connections for both web and job execution threads:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# config/database.yml&#xA;pool: &amp;lt;%= ENV.fetch(&#34;RAILS_MAX_THREADS&#34;, 5).to_i + ENV.fetch(&#34;GOOD_JOB_MAX_THREADS&#34;, 4).to_i %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;When running Puma with workers (&lt;code&gt;WEB_CONCURRENCY &amp;gt; 0&lt;/code&gt;) or another process-forking web server, GoodJob&#39;s threadpool schedulers should be stopped before forking, restarted after fork, and cleanly shut down on exit. Stopping GoodJob&#39;s scheduler pre-fork is recommended to ensure that GoodJob does not continue executing jobs in the parent/controller process. For example, with Puma:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/puma.rb&#xA;&#xA;before_fork do&#xA;  GoodJob.shutdown&#xA;end&#xA;&#xA;on_worker_boot do&#xA;  GoodJob.restart&#xA;end&#xA;&#xA;on_worker_shutdown do&#xA;  GoodJob.shutdown&#xA;end&#xA;&#xA;MAIN_PID = Process.pid&#xA;at_exit do&#xA;  GoodJob.shutdown if Process.pid == MAIN_PID&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;GoodJob is compatible with Puma&#39;s &lt;code&gt;preload_app!&lt;/code&gt; method.&lt;/p&gt; &lt;p&gt;For Passenger:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-Ruby&#34;&gt;if defined? PhusionPassenger&#xA;  PhusionPassenger.on_event :starting_worker_process do |forked|&#xA;    # If `forked` is true, we&#39;re in smart spawning mode.&#xA;    # https://www.phusionpassenger.com/docs/advanced_guides/in_depth/ruby/spawn_methods.html#smart-spawning-hooks&#xA;    if forked&#xA;      GoodJob.logger.info { &#39;Starting Passenger worker process.&#39; }&#xA;      GoodJob.restart&#xA;    end&#xA;  end&#xA;&#xA;  PhusionPassenger.on_event :stopping_worker_process do&#xA;    GoodJob.logger.info { &#39;Stopping Passenger worker process.&#39; }&#xA;    GoodJob.shutdown&#xA;  end&#xA;end&#xA;&#xA;# GoodJob also starts in the Passenger preloader process. This one does not&#xA;# trigger the above events, thus we catch it with `Kernel#at_exit`.&#xA;PRELOADER_PID = Process.pid&#xA;at_exit do&#xA;  if Process.pid == PRELOADER_PID&#xA;    GoodJob.logger.info { &#39;Passenger AppPreloader shutting down.&#39; }&#xA;    GoodJob.shutdown&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;If you are using cron-style jobs, you might also want to look at your Passenger configuration, especially at &lt;a href=&#34;https://www.phusionpassenger.com/library/config/nginx/reference/#passenger_pool_idle_time&#34;&gt;&lt;code&gt;passenger_pool_idle_time&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://www.phusionpassenger.com/library/config/nginx/reference/#passenger_min_instances&#34;&gt;&lt;code&gt;passenger_min_instances&lt;/code&gt;&lt;/a&gt; to make sure there&#39;s always at least once process running that can execute cron-style scheduled jobs. See also &lt;a href=&#34;https://www.phusionpassenger.com/library/config/nginx/optimization/#minimizing-process-spawning&#34;&gt;Passenger&#39;s optimization guide&lt;/a&gt; for more information.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Migrate to GoodJob from a different ActiveJob backend&lt;/h3&gt; &#xA;&lt;p&gt;If your application is already using an ActiveJob backend, you will need to install GoodJob to enqueue and perform newly created jobs &lt;em&gt;and&lt;/em&gt; finish performing pre-existing jobs on the previous backend.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Enqueue newly created jobs on GoodJob either entirely by setting &lt;code&gt;ActiveJob::Base.queue_adapter = :good_job&lt;/code&gt; or progressively via individual job classes:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# jobs/specific_job.rb&#xA;class SpecificJob &amp;lt; ApplicationJob&#xA;  self.queue_adapter = :good_job&#xA;  # ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Continue running executors for both backends. For example, on Heroku it&#39;s possible to run &lt;a href=&#34;https://help.heroku.com/CTFS2TJK/how-do-i-run-multiple-processes-on-a-dyno&#34;&gt;two processes&lt;/a&gt; within the same dyno:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-procfile&#34;&gt; # Procfile&#xA; # ...&#xA; worker: bundle exec que ./config/environment.rb &amp;amp; bundle exec good_job &amp;amp; wait -n&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Once you are confident that no unperformed jobs remain in the previous ActiveJob backend, code and configuration for that backend can be completely removed.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Monitor and preserve worked jobs&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob is fully instrumented with &lt;a href=&#34;https://edgeguides.rubyonrails.org/active_support_instrumentation.html#introduction-to-instrumentation&#34;&gt;&lt;code&gt;ActiveSupport::Notifications&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By default, GoodJob will preserve job records for 14 days after they are run, regardless of whether they succeed or not (raising a kind of &lt;code&gt;StandardError&lt;/code&gt;), unless they are interrupted (raising a kind of &lt;code&gt;Exception&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;To not preserve job records for later inspection, set an initializer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;GoodJob.preserve_job_records = false # defaults to true, or `false` or `:on_unhandled_error`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;GoodJob will automatically delete these job records after 14 days. The retention period, as well as the frequency GoodJob checks for deletable records can be configured:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#xA;config.cleanup_preserved_jobs_before_seconds_ago = 14.days.to_i&#xA;config.cleanup_interval_jobs = 1_000 # Number of executed jobs between deletion sweeps.&#xA;config.cleanup_interval_seconds = 10.minutes.to_i # Number of seconds between deletion sweeps.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is also possible to manually trigger a cleanup:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;For example, in a Rake task:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;GoodJob.cleanup_preserved_jobs # Will use default retention period&#xA;GoodJob.cleanup_preserved_jobs(older_than: 7.days) # custom retention period&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For example, using the &lt;code&gt;good_job&lt;/code&gt; command-line utility:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec good_job cleanup_preserved_jobs --before-seconds-ago=86400&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Write tests&lt;/h3&gt; &#xA;&lt;p&gt;By default, GoodJob uses its inline adapter in the test environment; the inline adapter is designed for the test environment. When enquing a job with GoodJob&#39;s inline adapter, the job will be executed immediately on the current thread; unhandled exceptions will be raised.&lt;/p&gt; &#xA;&lt;p&gt;In GoodJob 2.0, the inline adapter will execute future scheduled jobs immediately. In the next major release, GoodJob 3.0, the inline adapter will not execute future scheduled jobs and instead enqueue them in the database.&lt;/p&gt; &#xA;&lt;p&gt;To opt into this behavior immediately set: &lt;code&gt;config.good_job.inline_execution_respects_schedule = true&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;To perform jobs inline at any time, use &lt;code&gt;GoodJob.perform_inline&lt;/code&gt;. For example, using time helpers within an integration test:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MyJob.set(wait: 10.minutes).perform_later&#xA;travel_to(15.minutes.from_now) { GoodJob.perform_inline }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: Rails &lt;code&gt;travel&lt;/code&gt;/&lt;code&gt;travel_to&lt;/code&gt; time helpers do not have millisecond precision, so you must leave at least 1 second between the schedule and time traveling for the job to be executed. This &lt;a href=&#34;https://github.com/rails/rails/pull/44088&#34;&gt;behavior may change in Rails 7.1&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;PgBouncer compatibility&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob is not compatible with PgBouncer in &lt;em&gt;transaction&lt;/em&gt; mode, but is compatible with PgBouncer&#39;s &lt;em&gt;connection&lt;/em&gt; mode. GoodJob uses connection-based advisory locks and LISTEN/NOTIFY, both of which require full database connections.&lt;/p&gt; &#xA;&lt;p&gt;A workaround to this limitation is to make a direct database connection available to GoodJob. With Rails 6.0&#39;s support for &lt;a href=&#34;https://guides.rubyonrails.org/active_record_multiple_databases.html&#34;&gt;multiple databases&lt;/a&gt;, a direct connection to the database can be configured:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Define a direct connection to your database that is not proxied through PgBouncer, for example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# config/database.yml&#xA;&#xA;production:&#xA;  primary:&#xA;    url: postgres://pgbouncer_host/my_database&#xA;  primary_direct:&#xA;    url: postgres://database_host/my_database&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a new ActiveRecord base class that uses the direct database connection&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/models/application_direct_record.rb&#xA;&#xA;class ApplicationDirectRecord &amp;lt; ActiveRecord::Base&#xA;  self.abstract_class = true&#xA;  connects_to database: :primary_direct&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Configure GoodJob to use the newly created ActiveRecord base class:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/good_job.rb&#xA;&#xA;GoodJob.active_record_parent_class = &#34;ApplicationDirectRecord&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;CLI HTTP health check probes&lt;/h3&gt; &#xA;&lt;p&gt;GoodJob&#39;s CLI offers an http health check probe to better manage process lifecycle in containerized environments like Kubernetes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Run the CLI with a health check on port 7001&#xA;good_job start --probe-port=7001&#xA;&#xA;# or via an environment variable&#xA;GOOD_JOB_PROBE_PORT=7001 good_job start&#xA;&#xA;# Probe the status&#xA;curl localhost:7001/status&#xA;curl localhost:7001/status/started&#xA;curl localhost:7001/status/connected&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Multiple health checks are available at different paths:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;/&lt;/code&gt; or &lt;code&gt;/status&lt;/code&gt;: the CLI process is running&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/status/started&lt;/code&gt;: the multithreaded job executor is running&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/status/connected&lt;/code&gt;: the database connection is established&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This can be configured, for example with Kubernetes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spec:&#xA;  containers:&#xA;    - name: good_job&#xA;      image: my_app:latest&#xA;      env:&#xA;        - name: RAILS_ENV&#xA;          value: production&#xA;        - name: GOOD_JOB_PROBE_PORT&#xA;          value: 7001&#xA;      command:&#xA;          - good_job&#xA;          - start&#xA;      ports:&#xA;        - name: probe-port&#xA;          containerPort: 7001&#xA;      startupProbe:&#xA;        httpGet:&#xA;          path: &#34;/status/started&#34;&#xA;          port: probe-port&#xA;        failureThreshold: 30&#xA;        periodSeconds: 10&#xA;      livenessProbe:&#xA;        httpGet:&#xA;          path: &#34;/status/connected&#34;&#xA;          port: probe-port&#xA;        failureThreshold: 1&#xA;        periodSeconds: 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;!-- Please keep this section in sync with CONTRIBUTING.md --&gt; &#xA;&lt;p&gt;All contributions, from feedback to code and beyond, are welcomed and appreciated üôè&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Review the &lt;a href=&#34;https://github.com/bensheldon/good_job/projects/1&#34;&gt;Prioritized Project Backlog&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Open a new Issue or contribute to an &lt;a href=&#34;https://github.com/bensheldon/good_job/issues&#34;&gt;existing Issue&lt;/a&gt;. Questions or suggestions are fantastic.&lt;/li&gt; &#xA; &lt;li&gt;Participate according to our &lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/CODE_OF_CONDUCT.md&#34;&gt;Code of Conduct&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Financially support the project via &lt;a href=&#34;https://github.com/sponsors/bensheldon&#34;&gt;Sponsorship&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For gem development and debugging information, please review the &lt;a href=&#34;https://raw.githubusercontent.com/bensheldon/good_job/main/README.md#gem-development&#34;&gt;README&#39;s Gem Development section&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Gem development&lt;/h3&gt; &#xA;&lt;h4&gt;Development setup&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Clone the repository locally&#xA;git clone git@github.com:bensheldon/good_job.git&#xA;&#xA;# Set up the local environment&#xA;bin/setup&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Rails development harness&lt;/h4&gt; &#xA;&lt;p&gt;A Rails application exists within &lt;code&gt;spec/test_app&lt;/code&gt; that is used for development, test, and GoodJob Demo environments.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Run a local development webserver&#xA;bin/rails s&#xA;&#xA;# Disable job execution and cron for cleaner console output&#xA;GOOD_JOB_ENABLE_CRON=0 GOOD_JOB_EXECUTION_MODE=external bin/rails s&#xA;&#xA;# Open the Rails console&#xA;bin/rails c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For developing locally within another Ruby on Rails project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Within Ruby on Rails project directory&#xA;# Ensure that the Gemfile is set to git with a branch e.g.&#xA;# gem &#34;good_job&#34;, git: &#34;https://github.com/bensheldon/good_job.git&#34;, branch: &#34;main&#34;&#xA;# Then, override the Bundle config to point to the local filesystem&#39;s good_job repository&#xA;bundle config local.good_job /path/to/local/good_job/repository&#xA;&#xA;# Confirm that the local copy is used&#xA;bundle install&#xA;&#xA;# =&amp;gt; Using good_job 0.1.0 from https://github.com/bensheldon/good_job.git (at /Users/You/Projects/good_job@dc57fb0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Running tests&lt;/h4&gt; &#xA;&lt;p&gt;Tests can be run against the primary development environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bin/rspec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Environment variables that may help with debugging:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;LOUD=1&lt;/code&gt;: display all stdout/stderr output from all sources. This is helpful because GoodJob wraps some tests with &lt;code&gt;quiet { }&lt;/code&gt; for cleaner test output, but it can hinder debugging.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SHOW_BROWSER=1&lt;/code&gt;: Run system tests headfully with Chrome/Chromedriver. Use &lt;code&gt;binding.irb&lt;/code&gt; in the system tests to pause.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Appraisal can be used to run a test matrix of multiple versions of Rails:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install Appraisal matrix of gemfiles&#xA;bin/appraisal&#xA;&#xA;# Run tests against matrix&#xA;bin/appraisal bin/rspec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Release&lt;/h3&gt; &#xA;&lt;p&gt;Package maintainers can release this gem by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Sign into rubygems&#xA;$ gem signin&#xA;&#xA;# Add a .env file with the following:&#xA;# CHANGELOG_GITHUB_TOKEN= # Github Personal Access Token&#xA;&#xA;# Update version number, changelog, and create git commit:&#xA;$ bundle exec rake release_good_job[minor] # major,minor,patch&#xA;&#xA;# ..and follow subsequent directions.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>