<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-31T01:35:21Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zdennis/activerecord-import</title>
    <updated>2022-07-31T01:35:21Z</updated>
    <id>tag:github.com,2022-07-31:/zdennis/activerecord-import</id>
    <link href="https://github.com/zdennis/activerecord-import" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A library for bulk insertion of data into your database using ActiveRecord.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Activerecord-Import &lt;img src=&#34;https://github.com/zdennis/activerecord-import/actions/workflows/test.yaml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Activerecord-Import is a library for bulk inserting data using ActiveRecord.&lt;/p&gt; &#xA;&lt;p&gt;One of its major features is following activerecord associations and generating the minimal number of SQL insert statements required, avoiding the N+1 insert problem. An example probably explains it best. Say you had a schema like this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Publishers have Books&lt;/li&gt; &#xA; &lt;li&gt;Books have Reviews&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;and you wanted to bulk insert 100 new publishers with 10K books and 3 reviews per book. This library will follow the associations down and generate only 3 SQL insert statements - one for the publishers, one for the books, and one for the reviews.&lt;/p&gt; &#xA;&lt;p&gt;In contrast, the standard ActiveRecord save would generate 100 insert statements for the publishers, then it would visit each publisher and save all the books: 100 * 10,000 = 1,000,000 SQL insert statements and then the reviews: 100 * 10,000 * 3 = 3M SQL insert statements,&lt;/p&gt; &#xA;&lt;p&gt;That would be about 4M SQL insert statements vs 3, which results in vastly improved performance. In our case, it converted an 18 hour batch process to &amp;lt;2 hrs.&lt;/p&gt; &#xA;&lt;p&gt;The gem provides the following high-level features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Works with raw columns and arrays of values (fastest)&lt;/li&gt; &#xA; &lt;li&gt;Works with model objects (faster)&lt;/li&gt; &#xA; &lt;li&gt;Performs validations (fast)&lt;/li&gt; &#xA; &lt;li&gt;Performs on duplicate key updates (requires MySQL, SQLite 3.24.0+, or Postgres 9.5+)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#examples&#34;&gt;Examples&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#columns-and-arrays&#34;&gt;Columns and Arrays&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#hashes&#34;&gt;Hashes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#activerecord-models&#34;&gt;ActiveRecord Models&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#batching&#34;&gt;Batching&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#recursive&#34;&gt;Recursive&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#options&#34;&gt;Options&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#duplicate-key-ignore&#34;&gt;Duplicate Key Ignore&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#duplicate-key-update&#34;&gt;Duplicate Key Update&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#return-info&#34;&gt;Return Info&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#counter-cache&#34;&gt;Counter Cache&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#activerecord-timestamps&#34;&gt;ActiveRecord Timestamps&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#callbacks&#34;&gt;Callbacks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#supported-adapters&#34;&gt;Supported Adapters&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#additional-adapters&#34;&gt;Additional Adapters&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#requiring&#34;&gt;Requiring&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#autoloading-via-bundler&#34;&gt;Autoloading via Bundler&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#manually-loading&#34;&gt;Manually Loading&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#load-path-setup&#34;&gt;Load Path Setup&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#conflicts-with-other-gems&#34;&gt;Conflicts With Other Gems&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#more-information&#34;&gt;More Information&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#contributing&#34;&gt;Contributing&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#running-tests&#34;&gt;Running Tests&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#issue-triage&#34;&gt;Issue Triage&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;h4&gt;Introduction&lt;/h4&gt; &#xA;&lt;p&gt;This gem adds an &lt;code&gt;import&lt;/code&gt; method (or &lt;code&gt;bulk_import&lt;/code&gt;, for compatibility with gems like &lt;code&gt;elasticsearch-model&lt;/code&gt;; see &lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#conflicts-with-other-gems&#34;&gt;Conflicts With Other Gems&lt;/a&gt;) to ActiveRecord classes.&lt;/p&gt; &#xA;&lt;p&gt;Without &lt;code&gt;activerecord-import&lt;/code&gt;, you&#39;d write something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;10.times do |i|&#xA;  Book.create! name: &#34;book #{i}&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This would end up making 10 SQL calls. YUCK! With &lt;code&gt;activerecord-import&lt;/code&gt;, you can instead do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;books = []&#xA;10.times do |i|&#xA;  books &amp;lt;&amp;lt; Book.new(name: &#34;book #{i}&#34;)&#xA;end&#xA;Book.import books    # or use import!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and only have 1 SQL call. Much better!&lt;/p&gt; &#xA;&lt;h4&gt;Columns and Arrays&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;import&lt;/code&gt; method can take an array of column names (string or symbols) and an array of arrays. Each child array represents an individual record and its list of values in the same order as the columns. This is the fastest import mechanism and also the most primitive.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;columns = [ :title, :author ]&#xA;values = [ [&#39;Book1&#39;, &#39;George Orwell&#39;], [&#39;Book2&#39;, &#39;Bob Jones&#39;] ]&#xA;&#xA;# Importing without model validations&#xA;Book.import columns, values, validate: false&#xA;&#xA;# Import with model validations&#xA;Book.import columns, values, validate: true&#xA;&#xA;# when not specified :validate defaults to true&#xA;Book.import columns, values&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Hashes&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;import&lt;/code&gt; method can take an array of hashes. The keys map to the column names in the database.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;values = [{ title: &#39;Book1&#39;, author: &#39;George Orwell&#39; }, { title: &#39;Book2&#39;, author: &#39;Bob Jones&#39;}]&#xA;&#xA;# Importing without model validations&#xA;Book.import values, validate: false&#xA;&#xA;# Import with model validations&#xA;Book.import values, validate: true&#xA;&#xA;# when not specified :validate defaults to true&#xA;Book.import values&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Import Using Hashes and Explicit Column Names&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;import&lt;/code&gt; method can take an array of column names and an array of hash objects. The column names are used to determine what fields of data should be imported. The following example will only import books with the &lt;code&gt;title&lt;/code&gt; field:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;books = [&#xA;  { title: &#34;Book 1&#34;, author: &#34;George Orwell&#34; },&#xA;  { title: &#34;Book 2&#34;, author: &#34;Bob Jones&#34; }&#xA;]&#xA;columns = [ :title ]&#xA;&#xA;# without validations&#xA;Book.import columns, books, validate: false&#xA;&#xA;# with validations&#xA;Book.import columns, books, validate: true&#xA;&#xA;# when not specified :validate defaults to true&#xA;Book.import columns, books&#xA;&#xA;# result in table books&#xA;# title  | author&#xA;#--------|--------&#xA;# Book 1 | NULL&#xA;# Book 2 | NULL&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using hashes will only work if the columns are consistent in every hash of the array. If this does not hold, an exception will be raised. There are two workarounds: use the array to instantiate an array of ActiveRecord objects and then pass that into &lt;code&gt;import&lt;/code&gt; or divide the array into multiple ones with consistent columns and import each one separately.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/zdennis/activerecord-import/issues/507&#34;&gt;https://github.com/zdennis/activerecord-import/issues/507&lt;/a&gt; for discussion.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;arr = [&#xA;  { bar: &#39;abc&#39; },&#xA;  { baz: &#39;xyz&#39; },&#xA;  { bar: &#39;123&#39;, baz: &#39;456&#39; }&#xA;]&#xA;&#xA;# An exception will be raised&#xA;Foo.import arr&#xA;&#xA;# better&#xA;arr.map! { |args| Foo.new(args) }&#xA;Foo.import arr&#xA;&#xA;# better&#xA;arr.group_by(&amp;amp;:keys).each_value do |v|&#xA; Foo.import v&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ActiveRecord Models&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;import&lt;/code&gt; method can take an array of models. The attributes will be pulled off from each model by looking at the columns available on the model.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;books = [&#xA;  Book.new(title: &#34;Book 1&#34;, author: &#34;George Orwell&#34;),&#xA;  Book.new(title: &#34;Book 2&#34;, author: &#34;Bob Jones&#34;)&#xA;]&#xA;&#xA;# without validations&#xA;Book.import books, validate: false&#xA;&#xA;# with validations&#xA;Book.import books, validate: true&#xA;&#xA;# when not specified :validate defaults to true&#xA;Book.import books&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;import&lt;/code&gt; method can take an array of column names and an array of models. The column names are used to determine what fields of data should be imported. The following example will only import books with the &lt;code&gt;title&lt;/code&gt; field:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;books = [&#xA;  Book.new(title: &#34;Book 1&#34;, author: &#34;George Orwell&#34;),&#xA;  Book.new(title: &#34;Book 2&#34;, author: &#34;Bob Jones&#34;)&#xA;]&#xA;columns = [ :title ]&#xA;&#xA;# without validations&#xA;Book.import columns, books, validate: false&#xA;&#xA;# with validations&#xA;Book.import columns, books, validate: true&#xA;&#xA;# when not specified :validate defaults to true&#xA;Book.import columns, books&#xA;&#xA;# result in table books&#xA;# title  | author&#xA;#--------|--------&#xA;# Book 1 | NULL&#xA;# Book 2 | NULL&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Batching&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;import&lt;/code&gt; method can take a &lt;code&gt;batch_size&lt;/code&gt; option to control the number of rows to insert per INSERT statement. The default is the total number of records being inserted so there is a single INSERT statement.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;books = [&#xA;  Book.new(title: &#34;Book 1&#34;, author: &#34;George Orwell&#34;),&#xA;  Book.new(title: &#34;Book 2&#34;, author: &#34;Bob Jones&#34;),&#xA;  Book.new(title: &#34;Book 1&#34;, author: &#34;John Doe&#34;),&#xA;  Book.new(title: &#34;Book 2&#34;, author: &#34;Richard Wright&#34;)&#xA;]&#xA;columns = [ :title ]&#xA;&#xA;# 2 INSERT statements for 4 records&#xA;Book.import columns, books, batch_size: 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your import is particularly large or slow (possibly due to &lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#callbacks&#34;&gt;callbacks&lt;/a&gt;) whilst batch importing, you might want a way to report back on progress. This is supported by passing a callable as the &lt;code&gt;batch_progress&lt;/code&gt; option. e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;my_proc = -&amp;gt;(rows_size, num_batches, current_batch_number, batch_duration_in_secs) {&#xA;  # Using the arguments provided to the callable, you can&#xA;  # send an email, post to a websocket,&#xA;  # update slack, alert if import is taking too long, etc.&#xA;}&#xA;&#xA;Book.import columns, books, batch_size: 2, batch_progress: my_proc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Recursive&lt;/h4&gt; &#xA;&lt;p&gt;NOTE: This only works with PostgreSQL and ActiveRecord objects. This won&#39;t work with hashes or arrays as recursive inputs.&lt;/p&gt; &#xA;&lt;p&gt;Assume that Books &lt;code&gt;has_many&lt;/code&gt; Reviews.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;books = []&#xA;10.times do |i|&#xA;  book = Book.new(name: &#34;book #{i}&#34;)&#xA;  book.reviews.build(title: &#34;Excellent&#34;)&#xA;  books &amp;lt;&amp;lt; book&#xA;end&#xA;Book.import books, recursive: true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Options&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Key&lt;/th&gt; &#xA;   &lt;th&gt;Options&lt;/th&gt; &#xA;   &lt;th&gt;Default&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:validate&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Whether or not to run &lt;code&gt;ActiveRecord&lt;/code&gt; validations (uniqueness skipped). This option will always be true when using &lt;code&gt;import!&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:validate_uniqueness&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Whether or not to run uniqueness validations, has potential pitfalls, use with caution (requires &lt;code&gt;&amp;gt;= v0.27.0&lt;/code&gt;).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:validate_with_context&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;:create&lt;/code&gt;/&lt;code&gt;:update&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Allows passing an ActiveModel validation context for each model. Default is &lt;code&gt;:create&lt;/code&gt; for new records and &lt;code&gt;:update&lt;/code&gt; for existing ones.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:track_validation_failures&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;When this is set to true, &lt;code&gt;failed_instances&lt;/code&gt; will be an array of arrays, with each inner array having the form &lt;code&gt;[:index_in_dataset, :object_with_errors]&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:on_duplicate_key_ignore&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Allows skipping records with duplicate keys. See &lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#duplicate-key-ignore&#34;&gt;here&lt;/a&gt; for more details.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:ignore&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Alias for :on_duplicate_key_ignore.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:on_duplicate_key_update&lt;/td&gt; &#xA;   &lt;td&gt;:all, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Hash&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;   &lt;td&gt;Allows upsert logic to be used. See &lt;a href=&#34;https://raw.githubusercontent.com/zdennis/activerecord-import/master/#duplicate-key-update&#34;&gt;here&lt;/a&gt; for more details.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:synchronize&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;   &lt;td&gt;An array of ActiveRecord instances. This synchronizes existing instances in memory with updates from the import.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:timestamps&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Enables/disables timestamps on imported records.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:recursive&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Imports has_many/has_one associations (PostgreSQL only).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:batch_size&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;total # of records&lt;/td&gt; &#xA;   &lt;td&gt;Max number of records to insert per import&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:raise_error&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Raises an exception at the first invalid record. This means there will not be a result object returned. The &lt;code&gt;import!&lt;/code&gt; method is a shortcut for this.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;:all_or_none&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Will not import any records if there is a record with validation errors.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Duplicate Key Ignore&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://dev.mysql.com/doc/refman/5.0/en/insert-on-duplicate.html&#34;&gt;MySQL&lt;/a&gt;, &lt;a href=&#34;https://www.sqlite.org/lang_insert.html&#34;&gt;SQLite&lt;/a&gt;, and &lt;a href=&#34;https://www.postgresql.org/docs/current/static/sql-insert.html#SQL-ON-CONFLICT&#34;&gt;PostgreSQL&lt;/a&gt; (9.5+) support &lt;code&gt;on_duplicate_key_ignore&lt;/code&gt; which allows you to skip records if a primary or unique key constraint is violated.&lt;/p&gt; &#xA;&lt;p&gt;For Postgres 9.5+ it adds &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt;, for MySQL it uses &lt;code&gt;INSERT IGNORE&lt;/code&gt;, and for SQLite it uses &lt;code&gt;INSERT OR IGNORE&lt;/code&gt;. Cannot be enabled on a recursive import. For database adapters that normally support setting primary keys on imported objects, this option prevents that from occurring.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;book = Book.create! title: &#34;Book1&#34;, author: &#34;George Orwell&#34;&#xA;book.title = &#34;Updated Book Title&#34;&#xA;book.author = &#34;Bob Barker&#34;&#xA;&#xA;Book.import [book], on_duplicate_key_ignore: true&#xA;&#xA;book.reload.title  # =&amp;gt; &#34;Book1&#34;     (stayed the same)&#xA;book.reload.author # =&amp;gt; &#34;George Orwell&#34; (stayed the same)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The option &lt;code&gt;:on_duplicate_key_ignore&lt;/code&gt; is bypassed when &lt;code&gt;:recursive&lt;/code&gt; is enabled for &lt;a href=&#34;https://github.com/zdennis/activerecord-import/wiki#recursive-example-postgresql-only&#34;&gt;PostgreSQL imports&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Duplicate Key Update&lt;/h4&gt; &#xA;&lt;p&gt;MySQL, PostgreSQL (9.5+), and SQLite (3.24.0+) support &lt;code&gt;on duplicate key update&lt;/code&gt; (also known as &#34;upsert&#34;) which allows you to specify fields whose values should be updated if a primary or unique key constraint is violated.&lt;/p&gt; &#xA;&lt;p&gt;One big difference between MySQL and PostgreSQL support is that MySQL will handle any conflict that happens, but PostgreSQL requires that you specify which columns the conflict would occur over. SQLite models its upsert support after PostgreSQL.&lt;/p&gt; &#xA;&lt;p&gt;This will use MySQL&#39;s &lt;code&gt;ON DUPLICATE KEY UPDATE&lt;/code&gt; or Postgres/SQLite &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; to do upsert.&lt;/p&gt; &#xA;&lt;p&gt;Basic Update&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;book = Book.create! title: &#34;Book1&#34;, author: &#34;George Orwell&#34;&#xA;book.title = &#34;Updated Book Title&#34;&#xA;book.author = &#34;Bob Barker&#34;&#xA;&#xA;# MySQL version&#xA;Book.import [book], on_duplicate_key_update: [:title]&#xA;&#xA;# PostgreSQL version&#xA;Book.import [book], on_duplicate_key_update: {conflict_target: [:id], columns: [:title]}&#xA;&#xA;# PostgreSQL shorthand version (conflict target must be primary key)&#xA;Book.import [book], on_duplicate_key_update: [:title]&#xA;&#xA;book.reload.title  # =&amp;gt; &#34;Updated Book Title&#34; (changed)&#xA;book.reload.author # =&amp;gt; &#34;George Orwell&#34;          (stayed the same)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using the value from another column&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;book = Book.create! title: &#34;Book1&#34;, author: &#34;George Orwell&#34;&#xA;book.title = &#34;Updated Book Title&#34;&#xA;&#xA;# MySQL version&#xA;Book.import [book], on_duplicate_key_update: {author: :title}&#xA;&#xA;# PostgreSQL version (no shorthand version)&#xA;Book.import [book], on_duplicate_key_update: {&#xA;  conflict_target: [:id], columns: {author: :title}&#xA;}&#xA;&#xA;book.reload.title  # =&amp;gt; &#34;Book1&#34;              (stayed the same)&#xA;book.reload.author # =&amp;gt; &#34;Updated Book Title&#34; (changed)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using Custom SQL&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;book = Book.create! title: &#34;Book1&#34;, author: &#34;George Orwell&#34;&#xA;book.author = &#34;Bob Barker&#34;&#xA;&#xA;# MySQL version&#xA;Book.import [book], on_duplicate_key_update: &#34;author = values(author)&#34;&#xA;&#xA;# PostgreSQL version&#xA;Book.import [book], on_duplicate_key_update: {&#xA;  conflict_target: [:id], columns: &#34;author = excluded.author&#34;&#xA;}&#xA;&#xA;# PostgreSQL shorthand version (conflict target must be primary key)&#xA;Book.import [book], on_duplicate_key_update: &#34;author = excluded.author&#34;&#xA;&#xA;book.reload.title  # =&amp;gt; &#34;Book1&#34;      (stayed the same)&#xA;book.reload.author # =&amp;gt; &#34;Bob Barker&#34; (changed)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;PostgreSQL Using constraints&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;book = Book.create! title: &#34;Book1&#34;, author: &#34;George Orwell&#34;, edition: 3, published_at: nil&#xA;book.published_at = Time.now&#xA;&#xA;# in migration&#xA;execute &amp;lt;&amp;lt;-SQL&#xA;      ALTER TABLE books&#xA;        ADD CONSTRAINT for_upsert UNIQUE (title, author, edition);&#xA;    SQL&#xA;&#xA;# PostgreSQL version&#xA;Book.import [book], on_duplicate_key_update: {constraint_name: :for_upsert, columns: [:published_at]}&#xA;&#xA;&#xA;book.reload.title  # =&amp;gt; &#34;Book1&#34;          (stayed the same)&#xA;book.reload.author # =&amp;gt; &#34;George Orwell&#34;      (stayed the same)&#xA;book.reload.edition # =&amp;gt; 3               (stayed the same)&#xA;book.reload.published_at # =&amp;gt; 2017-10-09 (changed)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Book.import books, validate_uniqueness: true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Return Info&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;import&lt;/code&gt; method returns a &lt;code&gt;Result&lt;/code&gt; object that responds to &lt;code&gt;failed_instances&lt;/code&gt; and &lt;code&gt;num_inserts&lt;/code&gt;. Additionally, for users of Postgres, there will be two arrays &lt;code&gt;ids&lt;/code&gt; and &lt;code&gt;results&lt;/code&gt; that can be accessed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;articles = [&#xA;  Article.new(author_id: 1, title: &#39;First Article&#39;, content: &#39;This is the first article&#39;),&#xA;  Article.new(author_id: 2, title: &#39;Second Article&#39;, content: &#39;&#39;),&#xA;  Article.new(author_id: 3, content: &#39;&#39;)&#xA;]&#xA;&#xA;demo = Article.import(articles, returning: :title) # =&amp;gt; #&amp;lt;struct ActiveRecord::Import::Result&#xA;&#xA;demo.failed_instances&#xA;=&amp;gt; [#&amp;lt;Article id: 3, author_id: 3, title: nil, content: &#34;&#34;, created_at: nil, updated_at: nil&amp;gt;]&#xA;&#xA;demo.num_inserts&#xA;=&amp;gt; 1,&#xA;&#xA;demo.ids&#xA;=&amp;gt; [&#34;1&#34;, &#34;2&#34;] # for Postgres&#xA;=&amp;gt; [] # for other DBs&#xA;&#xA;demo.results&#xA;=&amp;gt; [&#34;First Article&#34;, &#34;Second Article&#34;] # for Postgres&#xA;=&amp;gt; [] # for other DBs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Counter Cache&lt;/h3&gt; &#xA;&lt;p&gt;When running &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;activerecord-import&lt;/code&gt; does not automatically update counter cache columns. To update these columns, you will need to do one of the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Provide values to the column as an argument on your object that is passed in.&lt;/li&gt; &#xA; &lt;li&gt;Manually update the column after the record has been imported.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;ActiveRecord Timestamps&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re familiar with ActiveRecord you&#39;re probably familiar with its timestamp columns: created_at, created_on, updated_at, updated_on, etc. When importing data the timestamp fields will continue to work as expected and each timestamp column will be set.&lt;/p&gt; &#xA;&lt;p&gt;Should you wish to specify those columns, you may use the option &lt;code&gt;timestamps: false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, it is also possible to set just &lt;code&gt;:created_at&lt;/code&gt; in specific records. In this case despite using &lt;code&gt;timestamps: true&lt;/code&gt;, &lt;code&gt;:created_at&lt;/code&gt; will be updated only in records where that field is &lt;code&gt;nil&lt;/code&gt;. Same rule applies for record associations when enabling the option &lt;code&gt;recursive: true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you are using custom time zones, these will be respected when performing imports as well as long as &lt;code&gt;ActiveRecord::Base.default_timezone&lt;/code&gt; is set, which for practically all Rails apps it is. NOTE: If you are using ActiveRecord 7.0 or later, please use &lt;code&gt;ActiveRecord.default_timezone&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;h3&gt;Callbacks&lt;/h3&gt; &#xA;&lt;p&gt;ActiveRecord callbacks related to &lt;a href=&#34;http://guides.rubyonrails.org/active_record_callbacks.html#creating-an-object&#34;&gt;creating&lt;/a&gt;, &lt;a href=&#34;http://guides.rubyonrails.org/active_record_callbacks.html#updating-an-object&#34;&gt;updating&lt;/a&gt;, or &lt;a href=&#34;http://guides.rubyonrails.org/active_record_callbacks.html#destroying-an-object&#34;&gt;destroying&lt;/a&gt; records (other than &lt;code&gt;before_validation&lt;/code&gt; and &lt;code&gt;after_validation&lt;/code&gt;) will NOT be called when calling the import method. This is because it is mass importing rows of data and doesn&#39;t necessarily have access to in-memory ActiveRecord objects.&lt;/p&gt; &#xA;&lt;p&gt;If you do have a collection of in-memory ActiveRecord objects you can do something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;books.each do |book|&#xA;  book.run_callbacks(:save) { false }&#xA;  book.run_callbacks(:create) { false }&#xA;end&#xA;Book.import(books)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will run before_create and before_save callbacks on each item. The &lt;code&gt;false&lt;/code&gt; argument is needed to prevent after_save being run, which wouldn&#39;t make sense prior to bulk import. Something to note in this example is that the before_create and before_save callbacks will run before the validation callbacks.&lt;/p&gt; &#xA;&lt;p&gt;If that is an issue, another possible approach is to loop through your models first to do validations and then only run callbacks on and import the valid models.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;valid_books = []&#xA;invalid_books = []&#xA;&#xA;books.each do |book|&#xA;  if book.valid?&#xA;    valid_books &amp;lt;&amp;lt; book&#xA;  else&#xA;    invalid_books &amp;lt;&amp;lt; book&#xA;  end&#xA;end&#xA;&#xA;valid_books.each do |book|&#xA;  book.run_callbacks(:save) { false }&#xA;  book.run_callbacks(:create) { false }&#xA;end&#xA;&#xA;Book.import valid_books, validate: false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Supported Adapters&lt;/h3&gt; &#xA;&lt;p&gt;The following database adapters are currently supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MySQL - supports core import functionality plus on duplicate key update support (included in activerecord-import 0.1.0 and higher)&lt;/li&gt; &#xA; &lt;li&gt;MySQL2 - supports core import functionality plus on duplicate key update support (included in activerecord-import 0.2.0 and higher)&lt;/li&gt; &#xA; &lt;li&gt;PostgreSQL - supports core import functionality (included in activerecord-import 0.1.0 and higher)&lt;/li&gt; &#xA; &lt;li&gt;SQLite3 - supports core import functionality (included in activerecord-import 0.1.0 and higher)&lt;/li&gt; &#xA; &lt;li&gt;Oracle - supports core import functionality through DML trigger (available as an external gem: &lt;a href=&#34;https://github.com/keeguon/activerecord-import-oracle_enhanced&#34;&gt;activerecord-import-oracle_enhanced&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;SQL Server - supports core import functionality (available as an external gem: &lt;a href=&#34;https://github.com/keeguon/activerecord-import-sqlserver&#34;&gt;activerecord-import-sqlserver&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If your adapter isn&#39;t listed here, please consider creating an external gem as described in the README to provide support. If you do, feel free to update this wiki to include a link to the new adapter&#39;s repository!&lt;/p&gt; &#xA;&lt;p&gt;To test which features are supported by your adapter, use the following methods on a model class:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;supports_import?(*args)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;supports_on_duplicate_key_update?&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;supports_setting_primary_key_of_imported_objects?&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Additional Adapters&lt;/h3&gt; &#xA;&lt;p&gt;Additional adapters can be provided by gems external to activerecord-import by providing an adapter that matches the naming convention setup by activerecord-import (and subsequently activerecord) for dynamically loading adapters. This involves also providing a folder on the load path that follows the activerecord-import naming convention to allow activerecord-import to dynamically load the file.&lt;/p&gt; &#xA;&lt;p&gt;When &lt;code&gt;ActiveRecord::Import.require_adapter(&#34;fake_name&#34;)&lt;/code&gt; is called the require will be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;activerecord-import/active_record/adapters/fake_name_adapter&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This allows an external gem to dynamically add an adapter without the need to add any file/code to the core activerecord-import gem.&lt;/p&gt; &#xA;&lt;h3&gt;Requiring&lt;/h3&gt; &#xA;&lt;p&gt;Note: These instructions will only work if you are using version 0.2.0 or higher.&lt;/p&gt; &#xA;&lt;h4&gt;Autoloading via Bundler&lt;/h4&gt; &#xA;&lt;p&gt;If you are using Rails or otherwise autoload your dependencies via Bundler, all you need to do add the gem to your &lt;code&gt;Gemfile&lt;/code&gt; like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;activerecord-import&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Manually Loading&lt;/h4&gt; &#xA;&lt;p&gt;You may want to manually load activerecord-import for one reason or another. First, add the &lt;code&gt;require: false&lt;/code&gt; argument like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;activerecord-import&#39;, require: false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will allow you to load up activerecord-import in the file or files where you are using it and only load the parts you need. If you are doing this within Rails and ActiveRecord has established a database connection (such as within a controller), you will need to do extra initialization work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;activerecord-import/base&#39;&#xA;# load the appropriate database adapter (postgresql, mysql2, sqlite3, etc)&#xA;require &#39;activerecord-import/active_record/adapters/postgresql_adapter&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your gem dependencies aren’t autoloaded, and your script will be establishing a database connection, then simply require activerecord-import after ActiveRecord has been loaded, i.e.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;active_record&#39;&#xA;require &#39;activerecord-import&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Load Path Setup&lt;/h3&gt; &#xA;&lt;p&gt;To understand how rubygems loads code you can reference the following:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://guides.rubygems.org/patterns/#loading-code&#34;&gt;http://guides.rubygems.org/patterns/#loading-code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;And an example of how active_record dynamically load adapters:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rails/rails/raw/master/activerecord/lib/active_record/connection_adapters/connection_specification.rb&#34;&gt;https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/connection_specification.rb&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;In summary, when a gem is loaded rubygems adds the &lt;code&gt;lib&lt;/code&gt; folder of the gem to the global load path &lt;code&gt;$LOAD_PATH&lt;/code&gt; so that all &lt;code&gt;require&lt;/code&gt; lookups will not propagate through all of the folders on the load path. When a &lt;code&gt;require&lt;/code&gt; is issued each folder on the &lt;code&gt;$LOAD_PATH&lt;/code&gt; is checked for the file and/or folder referenced. This allows a gem (like activerecord-import) to define push the activerecord-import folder (or namespace) on the &lt;code&gt;$LOAD_PATH&lt;/code&gt; and any adapters provided by activerecord-import will be found by rubygems when the require is issued.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;fake_name&lt;/code&gt; adapter is needed by a gem (potentially called &lt;code&gt;activerecord-import-fake_name&lt;/code&gt;) then the folder structure should look as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;activerecord-import-fake_name/&#xA;|-- activerecord-import-fake_name.gemspec&#xA;|-- lib&#xA;|   |-- activerecord-import-fake_name.rb&#xA;|   |-- activerecord-import-fake_name&#xA;|   |   |-- version.rb&#xA;|   |-- activerecord-import&#xA;|   |   |-- active_record&#xA;|   |   |   |-- adapters&#xA;|   |   |       |-- fake_name_adapter.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When rubygems pushes the &lt;code&gt;lib&lt;/code&gt; folder onto the load path a &lt;code&gt;require&lt;/code&gt; will now find &lt;code&gt;activerecord-import/active_record/adapters/fake_name_adapter&lt;/code&gt; as it runs through the lookup process for a ruby file under that path in &lt;code&gt;$LOAD_PATH&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Conflicts With Other Gems&lt;/h3&gt; &#xA;&lt;p&gt;Activerecord-Import adds the &lt;code&gt;.import&lt;/code&gt; method onto &lt;code&gt;ActiveRecord::Base&lt;/code&gt;. There are other gems, such as &lt;code&gt;elasticsearch-rails&lt;/code&gt;, that do the same thing. In conflicts such as this, there is an aliased method named &lt;code&gt;.bulk_import&lt;/code&gt; that can be used interchangeably.&lt;/p&gt; &#xA;&lt;p&gt;If you are using the &lt;code&gt;apartment&lt;/code&gt; gem, there is a weird triple interaction between that gem, &lt;code&gt;activerecord-import&lt;/code&gt;, and &lt;code&gt;activerecord&lt;/code&gt; involving caching of the &lt;code&gt;sequence_name&lt;/code&gt; of a model. This can be worked around by explicitly setting this value within the model. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Post &amp;lt; ActiveRecord::Base&#xA;  self.sequence_name = &#34;posts_seq&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Another way to work around the issue is to call &lt;code&gt;.reset_sequence_name&lt;/code&gt; on the model. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;schemas.all.each do |schema|&#xA;  Apartment::Tenant.switch! schema.name&#xA;  ActiveRecord::Base.transaction do&#xA;    Post.reset_sequence_name&#xA;&#xA;    Post.import posts&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/zdennis/activerecord-import/issues/233&#34;&gt;https://github.com/zdennis/activerecord-import/issues/233&lt;/a&gt; for further discussion.&lt;/p&gt; &#xA;&lt;h3&gt;More Information&lt;/h3&gt; &#xA;&lt;p&gt;For more information on Activerecord-Import please see its wiki: &lt;a href=&#34;https://github.com/zdennis/activerecord-import/wiki&#34;&gt;https://github.com/zdennis/activerecord-import/wiki&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To document new information, please add to the README instead of the wiki. See &lt;a href=&#34;https://github.com/zdennis/activerecord-import/issues/397&#34;&gt;https://github.com/zdennis/activerecord-import/issues/397&lt;/a&gt; for discussion.&lt;/p&gt; &#xA;&lt;h3&gt;Contributing&lt;/h3&gt; &#xA;&lt;h4&gt;Running Tests&lt;/h4&gt; &#xA;&lt;p&gt;The first thing you need to do is set up your database(s):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;copy &lt;code&gt;test/database.yml.sample&lt;/code&gt; to &lt;code&gt;test/database.yml&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;modify &lt;code&gt;test/database.yml&lt;/code&gt; for your database settings&lt;/li&gt; &#xA; &lt;li&gt;create databases as needed&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After that, you can run the tests. They run against multiple tests and ActiveRecord versions.&lt;/p&gt; &#xA;&lt;p&gt;This is one example of how to run the tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rm Gemfile.lock&#xA;AR_VERSION=7.0 bundle install&#xA;AR_VERSION=7.0 bundle exec rake test:postgresql test:sqlite3 test:mysql2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you have pushed up your changes, you can find your CI results &lt;a href=&#34;https://github.com/zdennis/activerecord-import/actions&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Issue Triage &lt;a href=&#34;https://www.codetriage.com/zdennis/activerecord-import&#34;&gt;&lt;img src=&#34;https://www.codetriage.com/zdennis/activerecord-import/badges/users.svg?sanitize=true&#34; alt=&#34;Open Source Helpers&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;You can triage issues which may include reproducing bug reports or asking for vital information, such as version numbers or reproduction instructions. If you would like to start triaging issues, one easy way to get started is to &lt;a href=&#34;https://www.codetriage.com/zdennis/activerecord-import&#34;&gt;subscribe to activerecord-import on CodeTriage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;This is licensed under the MIT license.&lt;/p&gt; &#xA;&lt;h1&gt;Author&lt;/h1&gt; &#xA;&lt;p&gt;Zach Dennis (&lt;a href=&#34;mailto:zach.dennis@gmail.com&#34;&gt;zach.dennis@gmail.com&lt;/a&gt;)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>simplecov-ruby/simplecov</title>
    <updated>2022-07-31T01:35:21Z</updated>
    <id>tag:github.com,2022-07-31:/simplecov-ruby/simplecov</id>
    <link href="https://github.com/simplecov-ruby/simplecov" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Code coverage for Ruby with a powerful configuration library and automatic merging of coverage across test suites&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SimpleCov &lt;a href=&#34;https://badge.fury.io/rb/simplecov&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/simplecov.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/actions?query=workflow%3Astable&#34; title=&#34;SimpleCov is built around the clock by github.com&#34;&gt;&lt;img src=&#34;https://github.com/simplecov-ruby/simplecov/workflows/stable/badge.svg?branch=main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/simplecov-ruby/simplecov/maintainability&#34;&gt;&lt;img src=&#34;https://api.codeclimate.com/v1/badges/c071d197d61953a7e482/maintainability&#34; alt=&#34;Maintainability&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://inch-ci.org/github/simplecov-ruby/simplecov&#34;&gt;&lt;img src=&#34;http://inch-ci.org/github/simplecov-ruby/simplecov.svg?branch=main&#34; alt=&#34;Inline docs&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Code coverage for Ruby&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/simplecov-ruby/simplecov&#34; title=&#34;Source Code @ GitHub&#34;&gt;Source Code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubydoc.info/gems/simplecov/frames&#34; title=&#34;RDoc API Documentation at Rubydoc.info&#34;&gt;API documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/raw/main/CHANGELOG.md&#34; title=&#34;Project Changelog&#34;&gt;Changelog&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubygems.org/gems/simplecov&#34; title=&#34;SimpleCov @ rubygems.org&#34;&gt;Rubygem&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/actions?query=workflow%3Astable&#34; title=&#34;SimpleCov is built around the clock by github.com&#34;&gt;Continuous Integration&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;SimpleCov is a code coverage analysis tool for Ruby. It uses &lt;a href=&#34;https://ruby-doc.org/stdlib/libdoc/coverage/rdoc/Coverage.html&#34; title=&#34;API doc for Ruby&#39;s Coverage library&#34;&gt;Ruby&#39;s built-in Coverage&lt;/a&gt; library to gather code coverage data, but makes processing its results much easier by providing a clean API to filter, group, merge, format, and display those results, giving you a complete code coverage suite that can be set up with just a couple lines of code. SimpleCov/Coverage track covered ruby code, gathering coverage for common templating solutions like erb, slim and haml is not supported.&lt;/p&gt; &#xA;&lt;p&gt;In most cases, you&#39;ll want overall coverage results for your projects, including all types of tests, Cucumber features, etc. SimpleCov automatically takes care of this by caching and merging results when generating reports, so your report actually includes coverage across your test suites and thereby gives you a better picture of blank spots.&lt;/p&gt; &#xA;&lt;p&gt;The official formatter of SimpleCov is packaged as a separate gem called &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov-html&#34; title=&#34;SimpleCov HTML Formatter Source Code @ GitHub&#34;&gt;simplecov-html&lt;/a&gt;, but will be installed and configured automatically when you launch SimpleCov. If you&#39;re curious, you can find it &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov-html&#34; title=&#34;SimpleCov HTML Formatter Source Code @ GitHub&#34;&gt;on GitHub, too&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Code and Bug Reports&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/issues&#34;&gt;Issue Tracker&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;See &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/raw/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING&lt;/a&gt; for how to contribute along with some common problems to check out before creating an issue.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Questions, Problems, Suggestions, etc.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!forum/simplecov&#34;&gt;Mailing List&lt;/a&gt; &#34;Open mailing list for discussion and announcements on Google Groups&#34;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Add SimpleCov to your &lt;code&gt;Gemfile&lt;/code&gt; and &lt;code&gt;bundle install&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;simplecov&#39;, require: false, group: :test&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Load and launch SimpleCov &lt;strong&gt;at the very top&lt;/strong&gt; of your &lt;code&gt;test/test_helper.rb&lt;/code&gt; (&lt;em&gt;or &lt;code&gt;spec_helper.rb&lt;/code&gt;, &lt;code&gt;rails_helper&lt;/code&gt;, cucumber &lt;code&gt;env.rb&lt;/code&gt;, or whatever your preferred test framework uses&lt;/em&gt;):&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;simplecov&#39;&#xA;SimpleCov.start&#xA;&#xA;# Previous content of test helper now starts here&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If SimpleCov starts after your application code is already loaded (via &lt;code&gt;require&lt;/code&gt;), it won&#39;t be able to track your files and their coverage! The &lt;code&gt;SimpleCov.start&lt;/code&gt; &lt;strong&gt;must&lt;/strong&gt; be issued &lt;strong&gt;before any of your application code is required!&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;This is especially true if you use anything that keeps your tests application loaded like spring, check out the &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/simplecov-ruby/simplecov/main/#want-to-use-spring-with-simplecov&#34;&gt;spring section&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;SimpleCov must be running in the process that you want the code coverage analysis to happen on. When testing a server process (e.g. a JSON API endpoint) via a separate test process (e.g. when using Selenium) where you want to see all code executed by the &lt;code&gt;rails server&lt;/code&gt;, and not just code executed in your actual test files, you need to require SimpleCov in the server process. For rails for instance, you&#39;ll want to add something like this to the top of &lt;code&gt;bin/rails&lt;/code&gt;, but below the &#34;shebang&#34; line (&lt;code&gt;#! /usr/bin/env ruby&lt;/code&gt;) and after config/boot is required:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if ENV[&#39;RAILS_ENV&#39;] == &#39;test&#39;&#xA;  require &#39;simplecov&#39;&#xA;  SimpleCov.start &#39;rails&#39;&#xA;  puts &#34;required simplecov&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run your full test suite to see the percent coverage that your application has.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;After running your tests, open &lt;code&gt;coverage/index.html&lt;/code&gt; in the browser of your choice. For example, in a Mac Terminal, run the following command from your application&#39;s root directory:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;open coverage/index.html&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;in a debian/ubuntu Terminal,&lt;/p&gt; &lt;pre&gt;&lt;code&gt;xdg-open coverage/index.html&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;a href=&#34;https://dwheeler.com/essays/open-files-urls.html&#34;&gt;This guide&lt;/a&gt; can help if you&#39;re unsure which command your particular operating system requires.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add the following to your &lt;code&gt;.gitignore&lt;/code&gt; file to ensure that coverage results are not tracked by Git (optional):&lt;/p&gt; &lt;pre&gt;&lt;code&gt;echo coverage &amp;gt;&amp;gt; .gitignore&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;If you&#39;re making a Rails application, SimpleCov comes with built-in configurations (see below for information on profiles) that will get you started with groups for your Controllers, Models and Helpers. To use it, the first two lines of your test_helper should be like this:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;simplecov&#39;&#xA;SimpleCov.start &#39;rails&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Example output&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Coverage results report, fully browsable locally with sorting and much more:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/137793/17071162/db6f253e-502d-11e6-9d84-e40c3d75f333.png&#34; alt=&#34;SimpleCov coverage report&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Source file coverage details view:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/137793/17071163/db6f9f0a-502d-11e6-816c-edb2c66fad8d.png&#34; alt=&#34;SimpleCov source file detail view&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Use it with any framework!&lt;/h2&gt; &#xA;&lt;p&gt;Similarly to the usage with Test::Unit described above, the only thing you have to do is to add the SimpleCov config to the very top of your Cucumber/RSpec/whatever setup file.&lt;/p&gt; &#xA;&lt;p&gt;Add the setup code to the &lt;strong&gt;top&lt;/strong&gt; of &lt;code&gt;features/support/env.rb&lt;/code&gt; (for Cucumber) or &lt;code&gt;spec/spec_helper.rb&lt;/code&gt; (for RSpec). Other test frameworks should work accordingly, whatever their setup file may be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;simplecov&#39;&#xA;SimpleCov.start &#39;rails&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You could even track what kind of code your UI testers are touching if you want to go overboard with things. SimpleCov does not care what kind of framework it is running in; it just looks at what code is being executed and generates a report about it.&lt;/p&gt; &#xA;&lt;h3&gt;Notes on specific frameworks and test utilities&lt;/h3&gt; &#xA;&lt;p&gt;For some frameworks and testing tools there are quirks and problems you might want to know about if you want to use SimpleCov with them. Here&#39;s an overview of the known ones:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt;&#xA;   &lt;th&gt;Framework&lt;/th&gt;&#xA;   &lt;th&gt;Notes&lt;/th&gt;&#xA;   &lt;th&gt;Issue&lt;/th&gt;&#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt; parallel_tests &lt;/th&gt; &#xA;   &lt;td&gt; As of 0.8.0, SimpleCov should correctly recognize parallel_tests and supplement your test suite names with their corresponding test env numbers. SimpleCov locks the resultset cache while merging, ensuring no race conditions occur when results are merged. &lt;/td&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/issues/64&#34;&gt;#64&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/pull/185&#34;&gt;#185&lt;/a&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt; knapsack_pro &lt;/th&gt; &#xA;   &lt;td&gt; To make SimpleCov work with Knapsack Pro Queue Mode to split tests in parallel on CI jobs you need to provide CI node index number to the &lt;code&gt;SimpleCov.command_name&lt;/code&gt; in &lt;code&gt;KnapsackPro::Hooks::Queue.before_queue&lt;/code&gt; hook. &lt;/td&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://knapsackpro.com/faq/question/how-to-use-simplecov-in-queue-mode&#34;&gt;Tip&lt;/a&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt; RubyMine &lt;/th&gt; &#xA;   &lt;td&gt; The &lt;a href=&#34;https://www.jetbrains.com/ruby/&#34;&gt;RubyMine IDE&lt;/a&gt; has built-in support for SimpleCov&#39;s coverage reports, though you might need to explicitly set the output root using `SimpleCov.root(&#39;foo/bar/baz&#39;)` &lt;/td&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/issues/95&#34;&gt;#95&lt;/a&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt; Spork &lt;/th&gt; &#xA;   &lt;td&gt; Because of how Spork works internally (using preforking), there used to be trouble when using SimpleCov with it, but that has apparently been resolved with a specific configuration strategy. See &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/issues/42#issuecomment-4440284&#34;&gt;this&lt;/a&gt; comment. &lt;/td&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/issues/42#issuecomment-4440284&#34;&gt;#42&lt;/a&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt; Spring &lt;/th&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://raw.githubusercontent.com/simplecov-ruby/simplecov/main/#want-to-use-spring-with-simplecov&#34;&gt;See section below.&lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/issues/381&#34;&gt;#381&lt;/a&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt; Test/Unit &lt;/th&gt; &#xA;   &lt;td&gt; Test Unit 2 used to mess with ARGV, leading to a failure to detect the test process name in SimpleCov. &lt;code&gt;test-unit&lt;/code&gt; releases 2.4.3+ (Dec 11th, 2011) should have this problem resolved. &lt;/td&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/issues/45&#34;&gt;#45&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/test-unit/test-unit/pull/12&#34;&gt;test-unit/test-unit#12&lt;/a&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Configuring SimpleCov&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://rubydoc.info/gems/simplecov/SimpleCov/Configuration&#34; title=&#34;Configuration options API documentation&#34;&gt;Configuration&lt;/a&gt; settings can be applied in three formats, which are completely equivalent:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The most common way is to configure it directly in your start block:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.start do&#xA;  some_config_option &#39;foo&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can also set all configuration options directly:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.some_config_option &#39;foo&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you do not want to start coverage immediately after launch or want to add additional configuration later on in a concise way, use:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.configure do&#xA;  some_config_option &#39;foo&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please check out the &lt;a href=&#34;http://rubydoc.info/gems/simplecov/SimpleCov/Configuration&#34; title=&#34;Configuration options API documentation&#34;&gt;Configuration&lt;/a&gt; API documentation to find out what you can customize.&lt;/p&gt; &#xA;&lt;h2&gt;Using .simplecov for centralized config&lt;/h2&gt; &#xA;&lt;p&gt;If you use SimpleCov to merge multiple test suite results (e.g. Test/Unit and Cucumber) into a single report, you&#39;d normally have to set up all your config options twice, once in &lt;code&gt;test_helper.rb&lt;/code&gt; and once in &lt;code&gt;env.rb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To avoid this, you can place a file called &lt;code&gt;.simplecov&lt;/code&gt; in your project root. You can then just leave the &lt;code&gt;require &#39;simplecov&#39;&lt;/code&gt; in each test setup helper (&lt;strong&gt;at the top&lt;/strong&gt;) and move the &lt;code&gt;SimpleCov.start&lt;/code&gt; code with all your custom config options into &lt;code&gt;.simplecov&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# test/test_helper.rb&#xA;require &#39;simplecov&#39;&#xA;&#xA;# features/support/env.rb&#xA;require &#39;simplecov&#39;&#xA;&#xA;# .simplecov&#xA;SimpleCov.start &#39;rails&#39; do&#xA;  # any custom configs like groups and filters can be here at a central place&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using &lt;code&gt;.simplecov&lt;/code&gt; rather than separately requiring SimpleCov multiple times is recommended if you are merging multiple test frameworks like Cucumber and RSpec that rely on each other, as invoking SimpleCov multiple times can cause coverage information to be lost.&lt;/p&gt; &#xA;&lt;h2&gt;Branch coverage (ruby &#34;~&amp;gt; 2.5&#34;)&lt;/h2&gt; &#xA;&lt;p&gt;Add branch coverage measurement statistics to your results. Supported in CRuby versions 2.5+.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.start do&#xA;  enable_coverage :branch&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Branch coverage is a feature introduced in Ruby 2.5 concerning itself with whether a particular branch of a condition had been executed. Line coverage on the other hand is only interested in whether a line of code has been executed.&lt;/p&gt; &#xA;&lt;p&gt;This comes in handy for instance for one line conditionals:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;number.odd? ? &#34;odd&#34; : &#34;even&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In line coverage this line would always be marked as executed but you&#39;d never know if both conditions were met. Guard clauses have a similar story:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;return if number.odd?&#xA;&#xA;# more code&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If all the code in that method was covered you&#39;d never know if the guard clause was ever triggered! With line coverage as just evaluating the condition marks it as covered.&lt;/p&gt; &#xA;&lt;p&gt;In the HTML report the lines of code will be annotated like &lt;code&gt;branch_type: hit_count&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;then: 2&lt;/code&gt; - the then branch (of an &lt;code&gt;if&lt;/code&gt;) was executed twice&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;else: 0&lt;/code&gt; - the else branch (of an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;case&lt;/code&gt;) was never executed&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Not that even if you don&#39;t declare an &lt;code&gt;else&lt;/code&gt; branch it will still show up in the coverage reports meaning that the condition of the &lt;code&gt;if&lt;/code&gt; was not hit or that no &lt;code&gt;when&lt;/code&gt; of &lt;code&gt;case&lt;/code&gt; was hit during the test runs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Is branch coverage strictly better?&lt;/strong&gt; No. Branch coverage really only concerns itself with conditionals - meaning coverage of sequential code is of no interest to it. A file without conditional logic will have no branch coverage data and SimpleCov will report 0 of 0 branches covered as 100% (as everything that can be covered was covered).&lt;/p&gt; &#xA;&lt;p&gt;Hence, we recommend looking at both metrics together. Branch coverage might also be a good overall metric to look at - while you might be missing only 10% of your lines that might account for 50% of your branches for instance.&lt;/p&gt; &#xA;&lt;h2&gt;Primary Coverage&lt;/h2&gt; &#xA;&lt;p&gt;By default, the primary coverage type is &lt;code&gt;line&lt;/code&gt;. To set the primary coverage to something else, use the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# or in configure SimpleCov.primary_coverage :branch&#xA;SimpleCov.start do&#xA;  enable_coverage :branch&#xA;  primary_coverage :branch&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Primary coverage determines what will come in first all output, and the type of coverage to check if you don&#39;t specify the type of coverage when customizing exit behavior (&lt;code&gt;SimpleCov.minimum_coverage 90&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Note that coverage must first be enabled for non-default coverage types.&lt;/p&gt; &#xA;&lt;h2&gt;Filters&lt;/h2&gt; &#xA;&lt;p&gt;Filters can be used to remove selected files from your coverage data. By default, a filter is applied that removes all files OUTSIDE of your project&#39;s root directory - otherwise you&#39;d end up with billions of coverage reports for source files in the gems you are using.&lt;/p&gt; &#xA;&lt;p&gt;You can define your own to remove things like configuration files, tests or whatever you don&#39;t need in your coverage report.&lt;/p&gt; &#xA;&lt;h3&gt;Defining custom filters&lt;/h3&gt; &#xA;&lt;p&gt;You can currently define a filter using either a String or Regexp (that will then be Regexp-matched against each source file&#39;s path), a block or by passing in your own Filter class.&lt;/p&gt; &#xA;&lt;h4&gt;String filter&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.start do&#xA;  add_filter &#34;/test/&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This simple string filter will remove all files that match &#34;/test/&#34; in their path.&lt;/p&gt; &#xA;&lt;h4&gt;Regex filter&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.start do&#xA;  add_filter %r{^/test/}&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This simple regex filter will remove all files that start with /test/ in their path.&lt;/p&gt; &#xA;&lt;h4&gt;Block filter&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.start do&#xA;  add_filter do |source_file|&#xA;    source_file.lines.count &amp;lt; 5&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Block filters receive a SimpleCov::SourceFile instance and expect your block to return either true (if the file is to be removed from the result) or false (if the result should be kept). Please check out the RDoc for SimpleCov::SourceFile to learn about the methods available to you. In the above example, the filter will remove all files that have less than 5 lines of code.&lt;/p&gt; &#xA;&lt;h4&gt;Custom filter class&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class LineFilter &amp;lt; SimpleCov::Filter&#xA;  def matches?(source_file)&#xA;    source_file.lines.count &amp;lt; filter_argument&#xA;  end&#xA;end&#xA;&#xA;SimpleCov.add_filter LineFilter.new(5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Defining your own filters is pretty easy: Just inherit from SimpleCov::Filter and define a method &#39;matches?(source_file)&#39;. When running the filter, a true return value from this method will result in the removal of the given source_file. The filter_argument method is being set in the SimpleCov::Filter initialize method and thus is set to 5 in this example.&lt;/p&gt; &#xA;&lt;h4&gt;Array filter&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.start do&#xA;  proc = Proc.new { |source_file| false }&#xA;  add_filter [&#34;string&#34;, /regex/, proc, LineFilter.new(5)]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can pass in an array containing any of the other filter types.&lt;/p&gt; &#xA;&lt;h4&gt;Ignoring/skipping code&lt;/h4&gt; &#xA;&lt;p&gt;You can exclude code from the coverage report by wrapping it in &lt;code&gt;# :nocov:&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# :nocov:&#xA;def skip_this_method&#xA;  never_reached&#xA;end&#xA;# :nocov:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The name of the token can be changed to your liking. &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/raw/main/features/config_nocov_token.feature&#34;&gt;Learn more about the nocov feature.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You shouldn&#39;t have to use the nocov token to skip private methods that are being included in your coverage. If you appropriately test the public interface of your classes and objects you should automatically get full coverage of your private methods.&lt;/p&gt; &#xA;&lt;h2&gt;Default root filter and coverage for things outside of it&lt;/h2&gt; &#xA;&lt;p&gt;By default, SimpleCov filters everything outside of the &lt;code&gt;SimpleCov.root&lt;/code&gt; directory. However, sometimes you may want to include coverage reports for things you include as a gem, for example a Rails Engine.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example by &lt;a href=&#34;https://github.com/lsaffie&#34;&gt;@lsaffie&lt;/a&gt; from &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/issues/221&#34;&gt;#221&lt;/a&gt; that shows how you can achieve just that:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.start :rails do&#xA;  filters.clear # This will remove the :root_filter and :bundler_filter that come via simplecov&#39;s defaults&#xA;  add_filter do |src|&#xA;    !(src.filename =~ /^#{SimpleCov.root}/) unless src.filename =~ /my_engine/&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Groups&lt;/h2&gt; &#xA;&lt;p&gt;You can separate your source files into groups. For example, in a Rails app, you&#39;ll want to have separate listings for Models, Controllers, Helpers, and Libs. Group definition works similarly to Filters (and also accepts custom filter classes), but source files end up in a group when the filter passes (returns true), as opposed to filtering results, which exclude files from results when the filter results in a true value.&lt;/p&gt; &#xA;&lt;p&gt;Add your groups with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.start do&#xA;  add_group &#34;Models&#34;, &#34;app/models&#34;&#xA;  add_group &#34;Controllers&#34;, &#34;app/controllers&#34;&#xA;  add_group &#34;Long files&#34; do |src_file|&#xA;    src_file.lines.count &amp;gt; 100&#xA;  end&#xA;  add_group &#34;Multiple Files&#34;, [&#34;app/models&#34;, &#34;app/controllers&#34;] # You can also pass in an array&#xA;  add_group &#34;Short files&#34;, LineFilter.new(5) # Using the LineFilter class defined in Filters section above&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Merging results&lt;/h2&gt; &#xA;&lt;p&gt;You normally want to have your coverage analyzed across ALL of your test suites, right?&lt;/p&gt; &#xA;&lt;p&gt;Simplecov automatically caches coverage results in your (coverage_path)/.resultset.json, and will merge or override those with subsequent runs, depending on whether simplecov considers those subsequent runs as different test suites or as the same test suite as the cached results. To make this distinction, simplecov has the concept of &#34;test suite names&#34;.&lt;/p&gt; &#xA;&lt;h3&gt;Test suite names&lt;/h3&gt; &#xA;&lt;p&gt;SimpleCov tries to guess the name of the currently running test suite based upon the shell command the tests are running on. This should work fine for Unit Tests, RSpec, and Cucumber. If it fails, it will use the shell command that invoked the test suite as a command name.&lt;/p&gt; &#xA;&lt;p&gt;If you have some non-standard setup and still want nicely labeled test suites, you have to give Simplecov a cue as to what the name of the currently running test suite is. You can do so by specifying &lt;code&gt;SimpleCov.command_name&lt;/code&gt; in one test file that is part of your specific suite.&lt;/p&gt; &#xA;&lt;p&gt;To customize the suite names on a Rails app (yeah, sorry for being Rails-biased, but everyone knows what the structure of those projects is. You can apply this accordingly to the RSpecs in your Outlook-WebDAV-Calendar-Sync gem), you could do something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# test/unit/some_test.rb&#xA;SimpleCov.command_name &#39;test:units&#39;&#xA;&#xA;# test/functionals/some_controller_test.rb&#xA;SimpleCov.command_name &#34;test:functionals&#34;&#xA;&#xA;# test/integration/some_integration_test.rb&#xA;SimpleCov.command_name &#34;test:integration&#34;&#xA;&#xA;# features/support/env.rb&#xA;SimpleCov.command_name &#34;features&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that this only has to be invoked ONCE PER TEST SUITE, so even if you have 200 unit test files, specifying it in &lt;code&gt;some_test.rb&lt;/code&gt; is enough.&lt;/p&gt; &#xA;&lt;p&gt;Last but not least &lt;strong&gt;if multiple suites resolve to the same &lt;code&gt;command_name&lt;/code&gt;&lt;/strong&gt; be aware that the coverage results &lt;strong&gt;will clobber each other instead of being merged&lt;/strong&gt;. SimpleCov is smart enough to detect unique names for the most common setups, but if you have more than one test suite that doesn&#39;t follow a common pattern then you will want to manually ensure that each suite gets a unique &lt;code&gt;command_name&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you are running tests in parallel each process has the potential to clobber results from the other test processes. If you are relying on the default &lt;code&gt;command_name&lt;/code&gt; then SimpleCov will attempt to detect and avoid parallel test suite &lt;code&gt;command_name&lt;/code&gt; collisions based on the presence of &lt;code&gt;ENV[&#39;PARALLEL_TEST_GROUPS&#39;]&lt;/code&gt; and &lt;code&gt;ENV[&#39;TEST_ENV_NUMBER&#39;]&lt;/code&gt;. If your parallel test runner does not set one or both of these then &lt;em&gt;you must&lt;/em&gt; set a &lt;code&gt;command_name&lt;/code&gt; and ensure that it is unique per process (eg. &lt;code&gt;command_name &#34;Unit Tests PID #{$$}&#34;&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;If you are using parallel_tests, you must incorporate &lt;code&gt;TEST_ENV_NUMBER&lt;/code&gt; into the command name yourself, in order for SimpleCov to merge the results correctly. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/spec_helper.rb&#xA;SimpleCov.command_name &#34;features&#34; + (ENV[&#39;TEST_ENV_NUMBER&#39;] || &#39;&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/simplecov-ruby/simplecov-html&#34; title=&#34;SimpleCov HTML Formatter Source Code @ GitHub&#34;&gt;simplecov-html&lt;/a&gt; prints the used test suites in the footer of the generated coverage report.&lt;/p&gt; &#xA;&lt;h3&gt;Merging test runs under the same execution environment&lt;/h3&gt; &#xA;&lt;p&gt;Test results are automatically merged with previous runs in the same execution environment when generating the result, so when coverage is set up properly for Cucumber and your unit / functional / integration tests, all of those test suites will be taken into account when building the coverage report.&lt;/p&gt; &#xA;&lt;h4&gt;Timeout for merge&lt;/h4&gt; &#xA;&lt;p&gt;Of course, your cached coverage data is likely to become invalid at some point. Thus, when automatically merging subsequent test runs, result sets that are older than &lt;code&gt;SimpleCov.merge_timeout&lt;/code&gt; will not be used any more. By default, the timeout is 600 seconds (10 minutes), and you can raise (or lower) it by specifying &lt;code&gt;SimpleCov.merge_timeout 3600&lt;/code&gt; (1 hour), or, inside a configure/start block, with just &lt;code&gt;merge_timeout 3600&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can deactivate this automatic merging altogether with &lt;code&gt;SimpleCov.use_merging false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Merging test runs under different execution environments&lt;/h3&gt; &#xA;&lt;p&gt;If your tests are done in parallel across multiple build machines, you can fetch them all and merge them into a single result set using the &lt;code&gt;SimpleCov.collate&lt;/code&gt; method. This can be added to a Rakefile or script file, having downloaded a set of &lt;code&gt;.resultset.json&lt;/code&gt; files from each parallel test run.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# lib/tasks/coverage_report.rake&#xA;namespace :coverage do&#xA;  desc &#34;Collates all result sets generated by the different test runners&#34;&#xA;  task :report do&#xA;    require &#39;simplecov&#39;&#xA;&#xA;    SimpleCov.collate Dir[&#34;simplecov-resultset-*/.resultset.json&#34;]&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;SimpleCov.collate&lt;/code&gt; also takes an optional simplecov profile and an optional block for configuration, just the same as &lt;code&gt;SimpleCov.start&lt;/code&gt; or &lt;code&gt;SimpleCov.configure&lt;/code&gt;. This means you can configure a separate formatter for the collated output. For instance, you can make the formatter in &lt;code&gt;SimpleCov.start&lt;/code&gt; the &lt;code&gt;SimpleCov::Formatter::SimpleFormatter&lt;/code&gt;, and only use more complex formatters in the final &lt;code&gt;SimpleCov.collate&lt;/code&gt; run.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/spec_helper.rb&#xA;require &#39;simplecov&#39;&#xA;&#xA;SimpleCov.start &#39;rails&#39; do&#xA;  # Disambiguates individual test runs&#xA;  command_name &#34;Job #{ENV[&#34;TEST_ENV_NUMBER&#34;]}&#34; if ENV[&#34;TEST_ENV_NUMBER&#34;]&#xA;&#xA;  if ENV[&#39;CI&#39;]&#xA;    formatter SimpleCov::Formatter::SimpleFormatter&#xA;  else&#xA;    formatter SimpleCov::Formatter::MultiFormatter.new([&#xA;      SimpleCov::Formatter::SimpleFormatter,&#xA;      SimpleCov::Formatter::HTMLFormatter&#xA;    ])&#xA;  end&#xA;&#xA;  track_files &#34;**/*.rb&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# lib/tasks/coverage_report.rake&#xA;namespace :coverage do&#xA;  task :report do&#xA;    require &#39;simplecov&#39;&#xA;&#xA;    SimpleCov.collate Dir[&#34;simplecov-resultset-*/.resultset.json&#34;], &#39;rails&#39; do&#xA;      formatter SimpleCov::Formatter::MultiFormatter.new([&#xA;        SimpleCov::Formatter::SimpleFormatter,&#xA;        SimpleCov::Formatter::HTMLFormatter&#xA;      ])&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running simplecov against subprocesses&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;SimpleCov.enable_for_subprocesses&lt;/code&gt; will allow SimpleCov to observe subprocesses starting using &lt;code&gt;Process.fork&lt;/code&gt;. This modifies ruby&#39;s core Process.fork method so that SimpleCov can see into it, appending &lt;code&gt;&#34; (subprocess #{pid})&#34;&lt;/code&gt; to the &lt;code&gt;SimpleCov.command_name&lt;/code&gt;, with results that can be merged together using SimpleCov&#39;s merging feature.&lt;/p&gt; &#xA;&lt;p&gt;To configure this, use &lt;code&gt;.at_fork&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.enable_for_subprocesses true&#xA;SimpleCov.at_fork do |pid|&#xA;  # This needs a unique name so it won&#39;t be ovewritten&#xA;  SimpleCov.command_name &#34;#{SimpleCov.command_name} (subprocess: #{pid})&#34;&#xA;  # be quiet, the parent process will be in charge of output and checking coverage totals&#xA;  SimpleCov.print_error_status = false&#xA;  SimpleCov.formatter SimpleCov::Formatter::SimpleFormatter&#xA;  SimpleCov.minimum_coverage 0&#xA;  # start&#xA;  SimpleCov.start&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: SimpleCov must have already been started before &lt;code&gt;Process.fork&lt;/code&gt; was called.&lt;/p&gt; &#xA;&lt;h3&gt;Running simplecov against spawned subprocesses&lt;/h3&gt; &#xA;&lt;p&gt;Perhaps you&#39;re testing a ruby script with &lt;code&gt;PTY.spawn&lt;/code&gt; or &lt;code&gt;Open3.popen&lt;/code&gt;, or &lt;code&gt;Process.spawn&lt;/code&gt; or etc. SimpleCov can cover this too.&lt;/p&gt; &#xA;&lt;p&gt;Add a .simplecov_spawn.rb file to your project root&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# .simplecov_spawn.rb&#xA;require &#39;simplecov&#39; # this will also pick up whatever config is in .simplecov&#xA;                    # so ensure it just contains configuration, and doesn&#39;t call SimpleCov.start.&#xA;SimpleCov.command_name &#39;spawn&#39; # As this is not for a test runner directly, script doesn&#39;t have a pre-defined base command_name&#xA;SimpleCov.at_fork.call(Process.pid) # Use the per-process setup described previously&#xA;SimpleCov.start # only now can we start.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, instead of calling your script directly, like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;PTY.spawn(&#39;my_script.rb&#39;) do # ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use bin/ruby to require the new .simplecov_spawn file, then your script&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;PTY.spawn(&#39;ruby -r./.simplecov_spawn my_script.rb&#39;) do # ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running coverage only on demand&lt;/h2&gt; &#xA;&lt;p&gt;The Ruby STDLIB Coverage library that SimpleCov builds upon is &lt;em&gt;very&lt;/em&gt; fast (on a ~10 min Rails test suite, the speed drop was only a couple seconds for me), and therefore it&#39;s SimpleCov&#39;s policy to just generate coverage every time you run your tests because it doesn&#39;t do your test speed any harm and you&#39;re always equipped with the latest and greatest coverage results.&lt;/p&gt; &#xA;&lt;p&gt;Because of this, SimpleCov has no explicit built-in mechanism to run coverage only on demand.&lt;/p&gt; &#xA;&lt;p&gt;However, you can still accomplish this very easily by introducing an ENV variable conditional into your SimpleCov setup block, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.start if ENV[&#34;COVERAGE&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, SimpleCov will only run if you execute your tests like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;COVERAGE=true rake test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Errors and exit statuses&lt;/h2&gt; &#xA;&lt;p&gt;To aid in debugging issues, if an error is raised, SimpleCov will print a message to &lt;code&gt;STDERR&lt;/code&gt; with the exit status of the error, like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SimpleCov failed with exit 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This &lt;code&gt;STDERR&lt;/code&gt; message can be disabled with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SimpleCov.print_error_status = false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Profiles&lt;/h2&gt; &#xA;&lt;p&gt;By default, SimpleCov&#39;s only config assumption is that you only want coverage reports for files inside your project root. To save yourself from repetitive configuration, you can use predefined blocks of configuration, called &#39;profiles&#39;, or define your own.&lt;/p&gt; &#xA;&lt;p&gt;You can then pass the name of the profile to be used as the first argument to SimpleCov.start. For example, simplecov comes bundled with a &#39;rails&#39; profile. It looks somewhat like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.profiles.define &#39;rails&#39; do&#xA;  add_filter &#39;/test/&#39;&#xA;  add_filter &#39;/config/&#39;&#xA;&#xA;  add_group &#39;Controllers&#39;, &#39;app/controllers&#39;&#xA;  add_group &#39;Models&#39;, &#39;app/models&#39;&#xA;  add_group &#39;Helpers&#39;, &#39;app/helpers&#39;&#xA;  add_group &#39;Libraries&#39;, &#39;lib&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, it&#39;s just a SimpleCov.configure block. In your test_helper.rb, launch SimpleCov with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.start &#39;rails&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.start &#39;rails&#39; do&#xA;  # additional config here&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom profiles&lt;/h3&gt; &#xA;&lt;p&gt;You can load additional profiles with the SimpleCov.load_profile(&#39;xyz&#39;) method. This allows you to build upon an existing profile and customize it so you can reuse it in unit tests and Cucumber features. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# lib/simplecov_custom_profile.rb&#xA;require &#39;simplecov&#39;&#xA;SimpleCov.profiles.define &#39;myprofile&#39; do&#xA;  load_profile &#39;rails&#39;&#xA;  add_filter &#39;vendor&#39; # Don&#39;t include vendored stuff&#xA;end&#xA;&#xA;# features/support/env.rb&#xA;require &#39;simplecov_custom_profile&#39;&#xA;SimpleCov.start &#39;myprofile&#39;&#xA;&#xA;# test/test_helper.rb&#xA;require &#39;simplecov_custom_profile&#39;&#xA;SimpleCov.start &#39;myprofile&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Customizing exit behaviour&lt;/h2&gt; &#xA;&lt;p&gt;You can define what SimpleCov should do when your test suite finishes by customizing the at_exit hook:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.at_exit do&#xA;  SimpleCov.result.format!&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Above is the default behaviour. Do whatever you like instead!&lt;/p&gt; &#xA;&lt;h3&gt;Minimum coverage&lt;/h3&gt; &#xA;&lt;p&gt;You can define the minimum coverage percentage expected. SimpleCov will return non-zero if unmet.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.minimum_coverage 90&#xA;# same as above (the default is to check line coverage)&#xA;SimpleCov.minimum_coverage line: 90&#xA;# check for a minimum line coverage of 90% and minimum 80% branch coverage&#xA;SimpleCov.minimum_coverage line: 90, branch: 80&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Minimum coverage by file&lt;/h3&gt; &#xA;&lt;p&gt;You can define the minimum coverage by file percentage expected. SimpleCov will return non-zero if unmet. This is useful to help ensure coverage is relatively consistent, rather than being skewed by particularly good or bad areas of the code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.minimum_coverage_by_file 80&#xA;# same as above (the default is to check line coverage by file)&#xA;SimpleCov.minimum_coverage_by_file line: 80&#xA;# check for a minimum line coverage by file of 90% and minimum 80% branch coverage&#xA;SimpleCov.minimum_coverage_by_file line: 90, branch: 80&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Maximum coverage drop&lt;/h3&gt; &#xA;&lt;p&gt;You can define the maximum coverage drop percentage at once. SimpleCov will return non-zero if exceeded.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.maximum_coverage_drop 5&#xA;# same as above (the default is to check line drop)&#xA;SimpleCov.maximum_coverage_drop line: 5&#xA;# check for a maximum line drop of 5% and maximum 10% branch drop&#xA;SimpleCov.maximum_coverage_drop line: 5, branch: 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Refuse dropping coverage&lt;/h3&gt; &#xA;&lt;p&gt;You can also entirely refuse dropping coverage between test runs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.refuse_coverage_drop&#xA;# same as above (the default is to only refuse line drop)&#xA;SimpleCov.refuse_coverage_drop :line&#xA;# refuse drop for line and branch&#xA;SimpleCov.refuse_coverage_drop :line, :branch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using your own formatter&lt;/h2&gt; &#xA;&lt;p&gt;You can use your own formatter with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleCov.formatter = SimpleCov::Formatter::HTMLFormatter&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Calling &lt;code&gt;SimpleCov.result.format!&lt;/code&gt; will be invoked with &lt;code&gt;SimpleCov::Formatter::YourFormatter.new.format(result)&lt;/code&gt;, and &lt;code&gt;result&lt;/code&gt; is an instance of &lt;code&gt;SimpleCov::Result&lt;/code&gt;. Do whatever your wish with that!&lt;/p&gt; &#xA;&lt;h2&gt;Using multiple formatters&lt;/h2&gt; &#xA;&lt;p&gt;As of SimpleCov 0.9, you can specify multiple result formats. Formatters besides the default HTML formatter require separate gems, however.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;simplecov-html&#34;&#xA;&#xA;SimpleCov.formatters = SimpleCov::Formatter::MultiFormatter.new([&#xA;  SimpleCov::Formatter::HTMLFormatter,&#xA;  SimpleCov::Formatter::CSVFormatter,&#xA;])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;JSON formatter&lt;/h2&gt; &#xA;&lt;p&gt;SimpleCov is packaged with a separate gem called &lt;a href=&#34;https://github.com/codeclimate-community/simplecov_json_formatter&#34;&gt;simplecov_json_formatter&lt;/a&gt; that provides you with a JSON formatter, this formatter could be useful for different use cases, such as for CI consumption or for reporting to external services.&lt;/p&gt; &#xA;&lt;p&gt;In order to use it you will need to manually load the installed gem like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;simplecov_json_formatter&#34;&#xA;SimpleCov.formatter = SimpleCov::Formatter::JSONFormatter&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; In case you plan to report your coverage results to CodeClimate services, know that SimpleCov will automatically use the JSON formatter along with the HTML formatter when the &lt;code&gt;CC_TEST_REPORTER_ID&lt;/code&gt; variable is present in the environment.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Available formatters, editor integrations and hosted services&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/simplecov-ruby/simplecov/main/doc/alternate-formatters.md&#34;&gt;Open Source formatter and integration plugins for SimpleCov&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/simplecov-ruby/simplecov/main/doc/editor-integration.md&#34;&gt;Editor Integration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/simplecov-ruby/simplecov/main/doc/commercial-services.md&#34;&gt;Hosted (commercial) services&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Ruby version compatibility&lt;/h2&gt; &#xA;&lt;p&gt;SimpleCov is built in &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/actions?query=workflow%3Astable&#34; title=&#34;SimpleCov is built around the clock by github.com&#34;&gt;Continuous Integration&lt;/a&gt; on Ruby 2.5+ as well as JRuby 9.2+.&lt;/p&gt; &#xA;&lt;p&gt;Note for JRuby =&amp;gt; You need to pass JRUBY_OPTS=&#34;--debug&#34; or create .jrubyrc and add debug.fullTrace=true&lt;/p&gt; &#xA;&lt;h2&gt;Want to find dead code in production?&lt;/h2&gt; &#xA;&lt;p&gt;Try &lt;a href=&#34;https://github.com/danmayer/coverband&#34;&gt;Coverband&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Want to use Spring with SimpleCov?&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re using &lt;a href=&#34;https://github.com/rails/spring&#34;&gt;Spring&lt;/a&gt; to speed up test suite runs and want to run SimpleCov along with them, you&#39;ll find that it often misreports coverage with the default config due to some sort of eager loading issue. Don&#39;t despair!&lt;/p&gt; &#xA;&lt;p&gt;One solution is to &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/issues/381#issuecomment-347651728&#34;&gt;explicitly call eager load&lt;/a&gt; in your &lt;code&gt;test_helper.rb&lt;/code&gt; / &lt;code&gt;spec_helper.rb&lt;/code&gt; after calling &lt;code&gt;SimpleCov.start&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;simplecov&#39;&#xA;SimpleCov.start &#39;rails&#39;&#xA;Rails.application.eager_load!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you could disable Spring while running SimpleCov:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;DISABLE_SPRING=1 rake test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you could remove &lt;code&gt;gem &#39;spring&#39;&lt;/code&gt; from your &lt;code&gt;Gemfile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;strong&gt;most common problem is that simplecov isn&#39;t required and started before everything else&lt;/strong&gt;. In order to track coverage for your whole application &lt;strong&gt;simplecov needs to be the first one&lt;/strong&gt; so that it (and the underlying coverage library) can subsequently track loaded files and their usage.&lt;/p&gt; &#xA;&lt;p&gt;If you are missing coverage for some code a simple trick is to put a puts statement in there and right after &lt;code&gt;SimpleCov.start&lt;/code&gt; so you can see if the file really was loaded after simplecov was started.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# my_code.rb&#xA;class MyCode&#xA;&#xA;  puts &#34;MyCode is being loaded!&#34;&#xA;&#xA;  def my_method&#xA;    # ...&#xA;  end&#xA;end&#xA;&#xA;# spec_helper.rb/rails_helper.rb/test_helper.rb/.simplecov whatever&#xA;&#xA;SimpleCov.start&#xA;puts &#34;SimpleCov started successfully!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now when you run your test suite and you see:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SimpleCov started successfully!&#xA;MyCode is being loaded!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then it&#39;s good otherwise you likely have a problem :)&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;Everyone participating in this project&#39;s development, issue trackers and other channels is expected to follow our &lt;a href=&#34;https://raw.githubusercontent.com/simplecov-ruby/simplecov/main/CODE_OF_CONDUCT.md&#34;&gt;Code of Conduct&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/simplecov-ruby/simplecov/raw/main/CONTRIBUTING.md&#34;&gt;contributing guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Kudos&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to Aaron Patterson for the original idea for this!&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2010-2017 Christoph Olszowka. See MIT-LICENSE for details.&lt;/p&gt;</summary>
  </entry>
</feed>