<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-28T01:48:02Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rails/kredis</title>
    <updated>2023-06-28T01:48:02Z</updated>
    <id>tag:github.com,2023-06-28:/rails/kredis</id>
    <link href="https://github.com/rails/kredis" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Higher-level data structures built on Redis&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Kredis&lt;/h1&gt; &#xA;&lt;p&gt;Kredis (Keyed Redis) encapsulates higher-level types and data structures around a single key, so you can interact with them as coherent objects rather than isolated procedural commands. These higher-level structures can be configured as attributes within Active Models and Active Records using a declarative DSL.&lt;/p&gt; &#xA;&lt;p&gt;Kredis is configured using env-aware YAML files, using &lt;code&gt;Rails.application.config_for&lt;/code&gt;, so you can locate the data structures on separate Redis instances, if you&#39;ve reached a scale where a single shared instance is no longer sufficient.&lt;/p&gt; &#xA;&lt;p&gt;Kredis provides namespacing support for keys such that you can safely run parallel testing against the data structures without different tests trampling each others data.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Kredis provides typed scalars for strings, integers, decimals, floats, booleans, datetimes, and JSON hashes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;string = Kredis.string &#34;mystring&#34;&#xA;string.value = &#34;hello world!&#34;  # =&amp;gt; SET mystring &#34;hello world&#34;&#xA;&#34;hello world!&#34; == string.value # =&amp;gt; GET mystring&#xA;&#xA;integer = Kredis.integer &#34;myinteger&#34;&#xA;integer.value = 5  # =&amp;gt; SET myinteger &#34;5&#34;&#xA;5 == integer.value # =&amp;gt; GET myinteger&#xA;&#xA;decimal = Kredis.decimal &#34;mydecimal&#34; # accuracy!&#xA;decimal.value = &#34;%.47f&#34; % (1.0/10) # =&amp;gt; SET mydecimal &#34;0.10000000000000000555111512312578270211815834045&#34;&#xA;BigDecimal(&#34;0.10000000000000000555111512312578270211815834045e0&#34;) == decimal.value # =&amp;gt; GET mydecimal&#xA;&#xA;float = Kredis.float &#34;myfloat&#34; # speed!&#xA;float.value = 1.0/10 # =&amp;gt; SET myfloat &#34;0.1&#34;&#xA;0.1 == float.value # =&amp;gt; GET myfloat&#xA;&#xA;boolean = Kredis.boolean &#34;myboolean&#34;&#xA;boolean.value = true # =&amp;gt; SET myboolean &#34;t&#34;&#xA;true == boolean.value # =&amp;gt; GET myboolean&#xA;&#xA;datetime = Kredis.datetime &#34;mydatetime&#34;&#xA;memoized_midnight = Time.zone.now.midnight&#xA;datetime.value = memoized_midnight # SET mydatetime &#34;2021-07-27T00:00:00.000000000Z&#34;&#xA;memoized_midnight == datetime.value # =&amp;gt; GET mydatetime&#xA;&#xA;json = Kredis.json &#34;myjson&#34;&#xA;json.value = { &#34;one&#34; =&amp;gt; 1, &#34;two&#34; =&amp;gt; &#34;2&#34; }  # =&amp;gt; SET myjson &#34;{\&#34;one\&#34;:1,\&#34;two\&#34;:\&#34;2\&#34;}&#34;&#xA;{ &#34;one&#34; =&amp;gt; 1, &#34;two&#34; =&amp;gt; &#34;2&#34; } == json.value  # =&amp;gt; GET myjson&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are data structures for counters, enums, flags, lists, unique lists, sets, and slots:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;list = Kredis.list &#34;mylist&#34;&#xA;list &amp;lt;&amp;lt; &#34;hello world!&#34;               # =&amp;gt; RPUSH mylist &#34;hello world!&#34;&#xA;[ &#34;hello world!&#34; ] == list.elements  # =&amp;gt; LRANGE mylist 0, -1&#xA;&#xA;integer_list = Kredis.list &#34;myintegerlist&#34;, typed: :integer&#xA;integer_list.append([ 1, 2, 3 ])        # =&amp;gt; RPUSH myintegerlist &#34;1&#34; &#34;2&#34; &#34;3&#34;&#xA;integer_list &amp;lt;&amp;lt; 4                       # =&amp;gt; RPUSH myintegerlist &#34;4&#34;&#xA;[ 1, 2, 3, 4 ] == integer_list.elements # =&amp;gt; LRANGE myintegerlist 0 -1&#xA;&#xA;unique_list = Kredis.unique_list &#34;myuniquelist&#34;&#xA;unique_list.append(%w[ 2 3 4 ])                # =&amp;gt; LREM myuniquelist 0, &#34;2&#34; + LREM myuniquelist 0, &#34;3&#34; + LREM myuniquelist 0, &#34;4&#34;  + RPUSH myuniquelist &#34;2&#34;, &#34;3&#34;, &#34;4&#34;&#xA;unique_list.prepend(%w[ 1 2 3 4 ])             # =&amp;gt; LREM myuniquelist 0, &#34;1&#34;  + LREM myuniquelist 0, &#34;2&#34; + LREM myuniquelist 0, &#34;3&#34; + LREM myuniquelist 0, &#34;4&#34;  + LPUSH myuniquelist &#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;&#xA;unique_list.append([])&#xA;unique_list &amp;lt;&amp;lt; &#34;5&#34;                             # =&amp;gt; LREM myuniquelist 0, &#34;5&#34; + RPUSH myuniquelist &#34;5&#34;&#xA;unique_list.remove(3)                          # =&amp;gt; LREM myuniquelist 0, &#34;3&#34;&#xA;[ &#34;4&#34;, &#34;2&#34;, &#34;1&#34;, &#34;5&#34; ] == unique_list.elements # =&amp;gt; LRANGE myuniquelist 0, -1&#xA;&#xA;ordered_set = Kredis.ordered_set &#34;myorderedset&#34;&#xA;ordered_set.append(%w[ 2 3 4 ])                # =&amp;gt; ZADD myorderedset 1646131025.4953232 2 1646131025.495326 3 1646131025.4953272 4&#xA;ordered_set.prepend(%w[ 1 2 3 4 ])             # =&amp;gt; ZADD myorderedset -1646131025.4957051 1 -1646131025.495707 2 -1646131025.4957082 3 -1646131025.4957092 4&#xA;ordered_set.append([])&#xA;ordered_set &amp;lt;&amp;lt; &#34;5&#34;                             # =&amp;gt; ZADD myorderedset 1646131025.4960442 5&#xA;ordered_set.remove(3)                          # =&amp;gt; ZREM myorderedset 3&#xA;[ &#34;4&#34;, &#34;2&#34;, &#34;1&#34;, &#34;5&#34; ] == ordered_set.elements # =&amp;gt; ZRANGE myorderedset 0 -1&#xA;&#xA;set = Kredis.set &#34;myset&#34;, typed: :datetime&#xA;set.add(DateTime.tomorrow, DateTime.yesterday)           # =&amp;gt; SADD myset &#34;2021-02-03 00:00:00 +0100&#34; &#34;2021-02-01 00:00:00 +0100&#34;&#xA;set &amp;lt;&amp;lt; DateTime.tomorrow                                 # =&amp;gt; SADD myset &#34;2021-02-03 00:00:00 +0100&#34;&#xA;2 == set.size                                            # =&amp;gt; SCARD myset&#xA;[ DateTime.tomorrow, DateTime.yesterday ] == set.members # =&amp;gt; SMEMBERS myset&#xA;&#xA;hash = Kredis.hash &#34;myhash&#34;&#xA;hash.update(&#34;key&#34; =&amp;gt; &#34;value&#34;, &#34;key2&#34; =&amp;gt; &#34;value2&#34;)     # =&amp;gt; HSET myhash &#34;key&#34;, &#34;value&#34;, &#34;key2&#34;, &#34;value2&#34;&#xA;{ &#34;key&#34; =&amp;gt; &#34;value&#34;, &#34;key2&#34; =&amp;gt; &#34;value2&#34; } == hash.to_h # =&amp;gt; HGETALL myhash&#xA;&#34;value2&#34; == hash[&#34;key2&#34;]                              # =&amp;gt; HMGET myhash &#34;key2&#34;&#xA;%w[ key key2 ] == hash.keys                           # =&amp;gt; HKEYS myhash&#xA;%w[ value value2 ] == hash.values                     # =&amp;gt; HVALS myhash&#xA;hash.remove                                           # =&amp;gt; DEL myhash&#xA;&#xA;high_scores = Kredis.hash &#34;high_scores&#34;, typed: :integer&#xA;high_scores.update(space_invaders: 100, pong: 42)             # HSET high_scores &#34;space_invaders&#34;, &#34;100&#34;, &#34;pong&#34;, &#34;42&#34;&#xA;%w[ space_invaders pong ] == high_scores.keys                 # HKEYS high_scores&#xA;[ 100, 42 ] == high_scores.values                             # HVALS high_scores&#xA;{ &#34;space_invaders&#34; =&amp;gt; 100, &#34;pong&#34; =&amp;gt; 42 } == high_scores.to_h # HGETALL high_scores&#xA;&#xA;head_count = Kredis.counter &#34;headcount&#34;&#xA;0 == head_count.value              # =&amp;gt; GET &#34;headcount&#34;&#xA;head_count.increment               # =&amp;gt; SET headcount 0 NX + INCRBY headcount 1&#xA;head_count.increment               # =&amp;gt; SET headcount 0 NX + INCRBY headcount 1&#xA;head_count.decrement               # =&amp;gt; SET headcount 0 NX + DECRBY headcount 1&#xA;1 == head_count.value              # =&amp;gt; GET &#34;headcount&#34;&#xA;&#xA;counter = Kredis.counter &#34;mycounter&#34;, expires_in: 5.seconds&#xA;counter.increment by: 2         # =&amp;gt; SET mycounter 0 EX 5 NX + INCRBY &#34;mycounter&#34; 2&#xA;2 == counter.value              # =&amp;gt; GET &#34;mycounter&#34;&#xA;sleep 6.seconds&#xA;0 == counter.value              # =&amp;gt; GET &#34;mycounter&#34;&#xA;&#xA;cycle = Kredis.cycle &#34;mycycle&#34;, values: %i[ one two three ]&#xA;:one == cycle.value             # =&amp;gt; GET mycycle&#xA;cycle.next                      # =&amp;gt; GET mycycle + SET mycycle 1&#xA;:two == cycle.value             # =&amp;gt; GET mycycle&#xA;cycle.next                      # =&amp;gt; GET mycycle + SET mycycle 2&#xA;:three == cycle.value           # =&amp;gt; GET mycycle&#xA;cycle.next                      # =&amp;gt; GET mycycle + SET mycycle 0&#xA;:one == cycle.value             # =&amp;gt; GET mycycle&#xA;&#xA;enum = Kredis.enum &#34;myenum&#34;, values: %w[ one two three ], default: &#34;one&#34;&#xA;&#34;one&#34; == enum.value             # =&amp;gt; GET myenum&#xA;true == enum.one?               # =&amp;gt; GET myenum&#xA;enum.value = &#34;two&#34;              # =&amp;gt; SET myenum &#34;two&#34;&#xA;&#34;two&#34; == enum.value             # =&amp;gt; GET myenum&#xA;enum.three!                     # =&amp;gt; SET myenum &#34;three&#34;&#xA;&#34;three&#34; == enum.value           # =&amp;gt; GET myenum&#xA;enum.value = &#34;four&#34;&#xA;&#34;three&#34; == enum.value           # =&amp;gt; GET myenum&#xA;enum.reset                      # =&amp;gt; DEL myenum&#xA;&#34;one&#34; == enum.value             # =&amp;gt; GET myenum&#xA;&#xA;slots = Kredis.slots &#34;myslots&#34;, available: 3&#xA;true == slots.available?        # =&amp;gt; GET myslots&#xA;slots.reserve                   # =&amp;gt; INCR myslots&#xA;true == slots.available?        # =&amp;gt; GET myslots&#xA;slots.reserve                   # =&amp;gt; INCR myslots&#xA;true == slots.available?        # =&amp;gt; GET myslots&#xA;slots.reserve                   # =&amp;gt; INCR myslots&#xA;false == slots.available?       # =&amp;gt; GET myslots&#xA;slots.reserve                   # =&amp;gt; INCR myslots + DECR myslots&#xA;false == slots.available?       # =&amp;gt; GET myslots&#xA;slots.release                   # =&amp;gt; DECR myslots&#xA;true == slots.available?        # =&amp;gt; GET myslots&#xA;slots.reset                     # =&amp;gt; DEL myslots&#xA;&#xA;&#xA;slot = Kredis.slot &#34;myslot&#34;&#xA;true == slot.available?        # =&amp;gt; GET myslot&#xA;slot.reserve                   # =&amp;gt; INCR myslot&#xA;false == slot.available?       # =&amp;gt; GET myslot&#xA;slot.release                   # =&amp;gt; DECR myslot&#xA;true == slot.available?        # =&amp;gt; GET myslot&#xA;slot.reset                     # =&amp;gt; DEL myslot&#xA;&#xA;flag = Kredis.flag &#34;myflag&#34;&#xA;false == flag.marked?           # =&amp;gt; EXISTS myflag&#xA;flag.mark                       # =&amp;gt; SET myflag 1&#xA;true == flag.marked?            # =&amp;gt; EXISTS myflag&#xA;flag.remove                     # =&amp;gt; DEL myflag&#xA;false == flag.marked?           # =&amp;gt; EXISTS myflag&#xA;&#xA;true == flag.mark(expires_in: 1.second, force: false)    #=&amp;gt; SET myflag 1 EX 1 NX&#xA;false == flag.mark(expires_in: 10.seconds, force: false) #=&amp;gt; SET myflag 10 EX 1 NX&#xA;true == flag.marked?            #=&amp;gt; EXISTS myflag&#xA;sleep 0.5.seconds&#xA;true == flag.marked?            #=&amp;gt; EXISTS myflag&#xA;sleep 0.6.seconds&#xA;false == flag.marked?           #=&amp;gt; EXISTS myflag&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And using structures on a different than the default &lt;code&gt;shared&lt;/code&gt; redis instance, relying on &lt;code&gt;config/redis/secondary.yml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;one_string = Kredis.string &#34;mystring&#34;&#xA;two_string = Kredis.string &#34;mystring&#34;, config: :secondary&#xA;&#xA;one_string.value = &#34;just on shared&#34;&#xA;two_string.value != one_string.value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use all these structures in models:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Person &amp;lt; ApplicationRecord&#xA;  kredis_list :names&#xA;  kredis_list :names_with_custom_key_via_lambda, key: -&amp;gt;(p) { &#34;person:#{p.id}:names_customized&#34; }&#xA;  kredis_list :names_with_custom_key_via_method, key: :generate_names_key&#xA;  kredis_unique_list :skills, limit: 2&#xA;  kredis_enum :morning, values: %w[ bright blue black ], default: &#34;bright&#34;&#xA;  kredis_counter :steps, expires_in: 1.hour&#xA;&#xA;  private&#xA;    def generate_names_key&#xA;      &#34;key-generated-from-private-method&#34;&#xA;    end&#xA;end&#xA;&#xA;person = Person.find(5)&#xA;person.names.append &#34;David&#34;, &#34;Heinemeier&#34;, &#34;Hansson&#34; # =&amp;gt; RPUSH people:5:names &#34;David&#34; &#34;Heinemeier&#34; &#34;Hansson&#34;&#xA;true == person.morning.bright?                       # =&amp;gt; GET people:5:morning&#xA;person.morning.value = &#34;blue&#34;                        # =&amp;gt; SET people:5:morning&#xA;true == person.morning.blue?                         # =&amp;gt; GET people:5:morning&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also define &lt;code&gt;after_change&lt;/code&gt; callbacks that trigger on mutations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Person &amp;lt; ApplicationRecord&#xA;  kredis_list :names, after_change: -&amp;gt;(p) {  }&#xA;  kredis_unique_list :skills, limit: 2, after_change: :skillset_changed&#xA;&#xA;  def skillset_changed&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run &lt;code&gt;./bin/bundle add kredis&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;./bin/rails kredis:install&lt;/code&gt; to add a default configuration at &lt;a href=&#34;https://raw.githubusercontent.com/rails/kredis/main/lib/install/shared.yml&#34;&gt;&lt;code&gt;config/redis/shared.yml&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Additional configurations can be added under &lt;code&gt;config/redis/*.yml&lt;/code&gt; and referenced when a type is created. For example, &lt;code&gt;Kredis.string(&#34;mystring&#34;, config: :strings)&lt;/code&gt; would lookup &lt;code&gt;config/redis/strings.yml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Kredis passes the configuration to &lt;code&gt;Redis.new&lt;/code&gt; to establish the connection. See the &lt;a href=&#34;https://github.com/redis/redis-rb&#34;&gt;Redis documentation&lt;/a&gt; for other configuration options.&lt;/p&gt; &#xA;&lt;h3&gt;Redis support&lt;/h3&gt; &#xA;&lt;p&gt;Kredis works with Redis server 4.0+, with the &lt;a href=&#34;https://github.com/redis/redis-rb&#34;&gt;Redis Ruby&lt;/a&gt; client version 4.2+.&lt;/p&gt; &#xA;&lt;h3&gt;Setting SSL options on Redis Connections&lt;/h3&gt; &#xA;&lt;p&gt;If you need to connect to Redis with SSL, the recommended approach is to set your Redis instance manually by adding an entry to the &lt;code&gt;Kredis::Connections.connections&lt;/code&gt; hash. Below an example showing how to connect to Redis using Client Authentication:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Kredis::Connections.connections[:shared] = Redis.new(&#xA;  url: ENV[&#39;REDIS_URL&#39;],&#xA;  ssl_params: {&#xA;    cert_store: OpenSSL::X509::Store.new.tap { |store|&#xA;      store.add_file(Rails.root.join(&#39;config&#39;, &#39;ca_cert.pem&#39;).to_s)&#xA;    },&#xA;&#xA;    cert: OpenSSL::X509::Certificate.new(File.read(&#xA;      Rails.root.join(&#39;config&#39;, &#39;client.crt&#39;)&#xA;    )),&#xA;&#xA;    key: OpenSSL::PKey::RSA.new(&#xA;      Rails.application.credentials.redis[:client_key]&#xA;    ),&#xA;&#xA;    verify_mode: OpenSSL::SSL::VERIFY_PEER&#xA;  }&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above code could be added to either &lt;code&gt;config/environments/production.rb&lt;/code&gt; or an initializer. Please ensure that your client private key, if used, is stored your credentials file or another secure location.&lt;/p&gt; &#xA;&lt;h3&gt;Configure how the redis client is created&lt;/h3&gt; &#xA;&lt;p&gt;You can configure how the redis client is created by setting &lt;code&gt;config.kredis.connector&lt;/code&gt; in your &lt;code&gt;application.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.kredis.connector = -&amp;gt;(config) { SomeRedisProxy.new(config) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default Kredis will use &lt;code&gt;Redis.new(config)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Kredis is released under the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>