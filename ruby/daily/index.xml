<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-09T01:42:32Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>camertron/rux</title>
    <updated>2023-03-09T01:42:32Z</updated>
    <id>tag:github.com,2023-03-09:/camertron/rux</id>
    <link href="https://github.com/camertron/rux" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A jsx-inspired way to render view components in Ruby.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;rux&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/camertron/rux/actions/workflows/unit_tests.yml/badge.svg?branch=master&#34; alt=&#34;Unit Tests&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Rux is a JSX-inspired way to write HTML tags in your Ruby code. It can be used to render view components in Rails via the &lt;a href=&#34;https://github.com/camertron/rux-rails&#34;&gt;rux-rails gem&lt;/a&gt;. This repo however contains only the rux parser itself.&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;A bit of background before we dive into how to use rux.&lt;/p&gt; &#xA;&lt;h3&gt;React and JSX&lt;/h3&gt; &#xA;&lt;p&gt;React mainstreamed the idea of composing websites from a series of components. To make it conceptually easier to transition from HTML templates to Javascript components, React also introduced an HTML-based syntax called JSX that allows developers to embed HTML into their Javascript code.&lt;/p&gt; &#xA;&lt;h3&gt;Rails View Components&lt;/h3&gt; &#xA;&lt;p&gt;For a long time, Rails didn&#39;t really have any support for components, preferring to rely on HTML template languages like ERB and HAML. The fine folks at Github however decided components could work well in Rails and released their &lt;a href=&#34;https://github.com/github/view_component&#34;&gt;view_component framework&lt;/a&gt;. There was even some talk about merging view_component into Rails core as &lt;code&gt;ActionView::Component&lt;/code&gt;, but unfortunately it looks like that won&#39;t be happening.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: I&#39;m going to be focusing on Rails examples here using the view_component gem, but rendering views from a series of components is a framework-agnostic idea.&lt;/p&gt; &#xA;&lt;h3&gt;View Component Example&lt;/h3&gt; &#xA;&lt;p&gt;A view component is just a class. The actual view portion is usually stored in a secondary template file that the component renders in the context of an instance of that class. For example, here&#39;s a very basic view component that displays a person&#39;s name on the page:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/components/name_component.rb&#xA;class NameComponent &amp;lt; ViewComponent::Base&#xA;  def initialize(first_name:, last_name:)&#xA;    @first_name = first_name&#xA;    @last_name = last_name&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html+erb&#34;&gt;&amp;lt;%# app/components/name_component.html.erb %&amp;gt;&#xA;&amp;lt;span&amp;gt;&amp;lt;%= @first_name %&amp;gt; &amp;lt;%= last_name %&amp;gt;&amp;lt;/span&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;View components have a number of very nice properties. Read about them on &lt;a href=&#34;https://viewcomponent.org/&#34;&gt;viewcomponent.org&lt;/a&gt; or watch Joel Hawksley&#39;s excellent 2019 &lt;a href=&#34;https://www.youtube.com/watch?v=y5Z5a6QdA-M&#34;&gt;Railsconf talk&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;HTML in Your Ruby&lt;/h2&gt; &#xA;&lt;p&gt;Rux does one thing: it lets you write HTML in your Ruby code. Here&#39;s the name component example from earlier rewritten in rux (sorry about the syntax highlighting, Github doesn&#39;t know about rux yet).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/components/name_component.rux&#xA;class NameComponent &amp;lt; ViewComponent::Base&#xA;  def initialize(first_name:, last_name:)&#xA;    @first_name = first_name&#xA;    @last_name = last_name&#xA;  end&#xA;&#xA;  def call&#xA;    &amp;lt;span&amp;gt;&#xA;      {@first_name} {@last_name}&#xA;    &amp;lt;/span&amp;gt;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The example above takes advantage of a feature of the view_component gem that lets you define a &lt;code&gt;call&lt;/code&gt; method instead of creating a separate template file.&lt;/p&gt; &#xA;&lt;p&gt;Next, we&#39;ll run the &lt;code&gt;ruxc&lt;/code&gt; tool to translate the rux code into Ruby code, eg. &lt;code&gt;ruxc app/components/name_component.rux&lt;/code&gt;. Here&#39;s the result:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NameComponent &amp;lt; ViewComponent::Base&#xA;  def initialize(first_name:, last_name:)&#xA;    @first_name = first_name&#xA;    @last_name = last_name&#xA;  end&#xA;&#xA;  def call&#xA;    Rux.tag(&#34;span&#34;) {&#xA;      Rux.create_buffer.tap { |_rux_buf_,|&#xA;        _rux_buf_ &amp;lt;&amp;lt; @first_name&#xA;        _rux_buf_ &amp;lt;&amp;lt; &#34; &#34;&#xA;        _rux_buf_ &amp;lt;&amp;lt; @last_name&#xA;      }.to_s&#xA;    }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, the span tag was converted to a &lt;code&gt;Rux.tag&lt;/code&gt; call. The instance variables containing the first and last names are concatenated together and rendered inside the span.&lt;/p&gt; &#xA;&lt;h2&gt;Composing Components&lt;/h2&gt; &#xA;&lt;p&gt;Things get even more interesting when it comes to rendering components inside other components. Let&#39;s create a greeting component that makes use of the name component:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/components/greeting_component.rux&#xA;class GreetingComponent &amp;lt; ViewComponent::Base&#xA;  def call&#xA;    &amp;lt;div&amp;gt;&#xA;      Hey there &amp;lt;NameComponent first-name=&#34;Homer&#34; last-name=&#34;Simpson&#34; /&amp;gt;!&#xA;    &amp;lt;/div&amp;gt;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;ruxc&lt;/code&gt; tool produces:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class GreetingComponent &amp;lt; ViewComponent::Base&#xA;  def call&#xA;    Rux.tag(&#34;div&#34;) {&#xA;      Rux.create_buffer.tap { |_rux_buf_,|&#xA;        _rux_buf_ &amp;lt;&amp;lt; &#34; Hey there &#34;&#xA;        _rux_buf_ &amp;lt;&amp;lt; render(NameComponent.new(first_name: &#34;Homer&#34;, last_name: &#34;Simpson&#34;))&#xA;        _rux_buf_ &amp;lt;&amp;lt; &#34;! &#34;&#xA;      }.to_s&#xA;    }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;&amp;lt;NameComponent&amp;gt;&lt;/code&gt; tag was translated into an instance of the &lt;code&gt;NameComponent&lt;/code&gt; class and the attributes into its keyword arguments.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The &lt;code&gt;render&lt;/code&gt; method is provided by &lt;code&gt;ViewComponent::Base&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Embedding Ruby&lt;/h2&gt; &#xA;&lt;p&gt;Since rux code is translated into Ruby code, anything goes. You&#39;re free to put any valid Ruby statements inside the curly braces.&lt;/p&gt; &#xA;&lt;p&gt;For example, let&#39;s say we want to change our greeting component to greet a variable number of people:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/components/greeting_component.rux&#xA;class GreetingComponent &amp;lt; ViewComponent::Base&#xA;  def initialize(people:)&#xA;    # people is an array of hashes containing :first_name and :last_name keys&#xA;    @people = people&#xA;  end&#xA;&#xA;  def call&#xA;    &amp;lt;div&amp;gt;&#xA;      {@people.map do |person|&#xA;        &amp;lt;NameComponent&#xA;          first-name={person[:first_name]}&#xA;          last-name={person[:last_name]}&#xA;        /&amp;gt;&#xA;      end}&#xA;    &amp;lt;/div&amp;gt;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice we were able to embed Ruby within rux within Ruby within rux. Within Ruby. The rux parser supports unlimited levels of nesting, although you&#39;ll probably not want to go &lt;em&gt;too&lt;/em&gt; crazy.&lt;/p&gt; &#xA;&lt;h2&gt;Keyword Arguments Only&lt;/h2&gt; &#xA;&lt;p&gt;Any view component that will be rendered by rux must &lt;em&gt;only&lt;/em&gt; accept keyword arguments in its constructor. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyComponent &amp;lt; ViewComponent::Base&#xA;  # GOOD&#xA;  def initialize(first_name:, last_name:)&#xA;  end&#xA;&#xA;  # BAD&#xA;  def initialize(first_name, last_name)&#xA;  end&#xA;&#xA;  # BAD&#xA;  def initialize(first_name, last_name = &#39;Simpson&#39;)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In other words, positional arguments are not allowed. This is because there&#39;s no such thing as a positional HTML attribute - all HTML attributes are key/value pairs. So, in order to match up with HTML, rux components are written with keyword arguments.&lt;/p&gt; &#xA;&lt;p&gt;Note also that the rux parser will replace dashes with underscores in rux tag attributes to adhere to both HTML and Ruby syntax conventions, since HTML attributes use dashes while Ruby keyword arguments use underscores. For example, here&#39;s how to write a rux tag for &lt;code&gt;MyComponent&lt;/code&gt; above:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;lt;MyComponent first-name=&#34;Homer&#34; last-name=&#34;Simpson&#34; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that the rux attribute &#34;first-name&#34; is passed to &lt;code&gt;MyComponent#initialize&lt;/code&gt; as &#34;first_name&#34;.&lt;/p&gt; &#xA;&lt;h2&gt;How it Works&lt;/h2&gt; &#xA;&lt;p&gt;Translating rux code (Ruby + HTML tags) into Ruby code happens in three phases: lexing, parsing, and emitting. The lexer phase is implemented as a wrapper around the lexer from the &lt;a href=&#34;https://github.com/whitequark/parser&#34;&gt;Parser gem&lt;/a&gt; that looks for specific patterns in the token stream. When it finds an opening HTML tag, it hands off lexing to the rux lexer. When the tag ends, the lexer continues emitting Ruby tokens, and so on.&lt;/p&gt; &#xA;&lt;p&gt;In the parsing phase, the token stream is transformed into an intermediate representation of the code known as an abstract syntax tree, or AST. It&#39;s the parser&#39;s job to work out which tags are children of other tags, associate attributes with tags, etc.&lt;/p&gt; &#xA;&lt;p&gt;Finally it&#39;s time to generate Ruby code in the emitting phase. The rux gem makes use of the visitor pattern and the excellent &lt;a href=&#34;https://github.com/mbj/unparser&#34;&gt;unparser gem&lt;/a&gt; to walk over all the nodes in the AST and generate a big string of Ruby code. This big string is the final product that can be written to a file and executed by the Ruby interpreter.&lt;/p&gt; &#xA;&lt;h2&gt;Transpiling Rux to Ruby&lt;/h2&gt; &#xA;&lt;p&gt;While the &lt;code&gt;ruxc&lt;/code&gt; tool is a convenient way to transpile rux to Ruby via the command line, it&#39;s also possible to do so programmatically.&lt;/p&gt; &#xA;&lt;h3&gt;Transpiling Strings&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s say you have a string containing a bunch of rux code. You can transpile it to Ruby like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;rux&#39;&#xA;&#xA;str = &#39;some rux code&#39;&#xA;Rux.to_ruby(str)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The &lt;code&gt;to_ruby&lt;/code&gt; method accepts a visitor instance as its second argument (see below for more information about creating custom visitors). It uses the default visitor if no second argument is provided.&lt;/p&gt; &#xA;&lt;h3&gt;Transpiling Files&lt;/h3&gt; &#xA;&lt;p&gt;Rux comes with a handy &lt;code&gt;File&lt;/code&gt; class to make transpiling files easier:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;rux&#39;&#xA;&#xA;f = Rux::File.new(&#39;path/to/some/file.rux&#39;)&#xA;&#xA;# get result as a string, same as calling Rux.to_ruby&#xA;f.to_ruby&#xA;&#xA;# write result to path/to/some/file.rb&#xA;f.write&#xA;&#xA;# write result to the given file&#xA;f.write(&#39;somewhere/else/file.rb&#39;)&#xA;&#xA;# the default file the result will be written, i.e. the location&#xA;# #write will write to&#xA;f.default_outfile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom Visitors&lt;/h2&gt; &#xA;&lt;p&gt;Rux comes with a default visitor capable of emitting Ruby code that is mostly compatible with the view_component gem discussed earlier. A little bit of extra work is required to render rux components in Rails, which is why the rux-rails gem uses a modified version of the default visitor to emit Ruby code that will render correctly in Rails views. It&#39;s likely other frameworks that want to render rux components will need a custom visitor as well.&lt;/p&gt; &#xA;&lt;p&gt;Visitors should inherit from the &lt;code&gt;Rux::Visitor&lt;/code&gt; class and implement the various methods. See lib/rux/visitor.rb for details. If you&#39;re looking to tweak the default visitor, inherit from &lt;code&gt;Rux::DefaultVisitor&lt;/code&gt; instead, and see lib/rux/default_visitor.rb for details.&lt;/p&gt; &#xA;&lt;h2&gt;Custom Tag Builders&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;Rux.tag&lt;/code&gt; method emits HTML tags via the configured tag builder. You can configure a custom tag builder by setting &lt;code&gt;Rux.tag_builder&lt;/code&gt; to any object that responds to the &lt;code&gt;call&lt;/code&gt; method (and accepts three arguments). For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyTagBuilder&#xA;  def call(tag_name, attributes = {}, &amp;amp;block)&#xA;    # Should return a string, eg. &#39;&amp;lt;div foo=&#34;bar&#34;&amp;gt;&amp;lt;/div&amp;gt;&#39;.&#xA;    # When called, the block should return the tag&#39;s body contents.&#xA;  end&#xA;end&#xA;&#xA;Rux.tag_builder = MyTagBuilder.new&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, since the only requirement is that the tag builder respond to &lt;code&gt;#call&lt;/code&gt;, you could pass a lambda:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rux.tag_builder = -&amp;gt; (tag_name, attributes = {}, &amp;amp;block) do&#xA;  # Should return a string, eg. &#39;&amp;lt;div foo=&#34;bar&#34;&amp;gt;&amp;lt;/div&amp;gt;&#39;.&#xA;  # When called, the block should return the tag&#39;s body contents.&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom Buffers&lt;/h2&gt; &#xA;&lt;p&gt;You may have noticed calls to &lt;code&gt;Rux.create_buffer&lt;/code&gt; in the code examples above. Rux comes with a default buffer implementation, but you can configure a custom one as well. The rux-rails gem for example configures rux to use &lt;code&gt;ActiveSupport::SafeBuffer&lt;/code&gt; in order to be compatible with Rails view rendering. Buffer implementations only need to define two methods: &lt;code&gt;#&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;#to_s&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyBuffer&#xA;  def initialize&#xA;    @buffer = &#39;&#39;&#xA;  end&#xA;&#xA;  def &amp;lt;&amp;lt;(thing)&#xA;    # it&#39;s important to handle nils here&#xA;    @buffer &amp;lt;&amp;lt; (thing || &#39;&#39;)&#xA;  end&#xA;&#xA;  def to_s&#xA;    @buffer&#xA;  end&#xA;end&#xA;&#xA;Rux.buffer = MyBuffer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;The Library Path&lt;/h2&gt; &#xA;&lt;p&gt;It is my hope that, in the future, Ruby and Rails devs will publish collections of view components in gem form that other devs can use in their own projects. Maybe some of those view component libraries will even be written in rux. Accordingly, I wanted a way of adding rux components to Rails&#39; eager load system, but without actually depending on Rails.&lt;/p&gt; &#xA;&lt;p&gt;The rux library path is a way for libraries written in rux to register themselves. The rux-rails gem automatically appends every entry in the library path to the Rails eager load and autoload paths so .rux files are automatically reloaded in development mode. Hopefully the library path enables other frameworks to do something similar.&lt;/p&gt; &#xA;&lt;p&gt;Adding a path is done like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rux.library_paths &amp;lt;&amp;lt; &#39;path/to/dir/with/rux/files&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Editor Support&lt;/h2&gt; &#xA;&lt;p&gt;Sublime Text: &lt;a href=&#34;https://github.com/camertron/rux-SublimeText&#34;&gt;https://github.com/camertron/rux-SublimeText&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Atom: &lt;a href=&#34;https://github.com/camertron/rux-atom&#34;&gt;https://github.com/camertron/rux-atom&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;VSCode: &lt;a href=&#34;https://github.com/camertron/rux-vscode&#34;&gt;https://github.com/camertron/rux-vscode&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Running Tests&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;bundle exec rspec&lt;/code&gt; should do the trick.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under the MIT license. See LICENSE for details.&lt;/p&gt; &#xA;&lt;h2&gt;Authors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Cameron C. Dutro: &lt;a href=&#34;http://github.com/camertron&#34;&gt;http://github.com/camertron&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>