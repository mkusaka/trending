<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-09T01:38:55Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>charkost/prosopite</title>
    <updated>2023-10-09T01:38:55Z</updated>
    <id>tag:github.com,2023-10-09:/charkost/prosopite</id>
    <link href="https://github.com/charkost/prosopite" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üîç Rails N+1 queries auto-detection with zero false positives / false negatives&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Prosopite &lt;img src=&#34;https://github.com/charkost/prosopite/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt; &lt;a href=&#34;https://badge.fury.io/rb/prosopite&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/prosopite.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Prosopite is able to auto-detect Rails N+1 queries with zero false positives / false negatives.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;N+1 queries detected:&#xA;  SELECT `users`.* FROM `users` WHERE `users`.`id` = 20 LIMIT 1&#xA;  SELECT `users`.* FROM `users` WHERE `users`.`id` = 21 LIMIT 1&#xA;  SELECT `users`.* FROM `users` WHERE `users`.`id` = 22 LIMIT 1&#xA;  SELECT `users`.* FROM `users` WHERE `users`.`id` = 23 LIMIT 1&#xA;  SELECT `users`.* FROM `users` WHERE `users`.`id` = 24 LIMIT 1&#xA;Call stack:&#xA;  app/controllers/thank_you_controller.rb:4:in `block in index&#39;&#xA;  app/controllers/thank_you_controller.rb:3:in `each&#39;&#xA;  app/controllers/thank_you_controller.rb:3:in `index&#39;:&#xA;  app/controllers/application_controller.rb:8:in `block in &amp;lt;class:ApplicationController&amp;gt;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The need for prosopite emerged after dealing with various false positives / negatives using the &lt;a href=&#34;https://github.com/flyerhzm/bullet&#34;&gt;bullet&lt;/a&gt; gem.&lt;/p&gt; &#xA;&lt;h2&gt;Compared to Bullet&lt;/h2&gt; &#xA;&lt;p&gt;Prosopite can auto-detect the following extra cases of N+1 queries:&lt;/p&gt; &#xA;&lt;h4&gt;N+1 queries after record creations (usually in tests)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;FactoryBot.create_list(:leg, 10)&#xA;&#xA;Leg.last(10).each do |l|&#xA;  l.chair&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Not triggered by ActiveRecord associations&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Leg.last(4).each do |l|&#xA;  Chair.find(l.chair_id)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;First/last/pluck of collection associations&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Chair.last(20).each do |c|&#xA;  c.legs.first&#xA;  c.legs.last&#xA;  c.legs.pluck(:id)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Changing the ActiveRecord class with #becomes&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Chair.last(20).map{ |c| c.becomes(ArmChair) }.each do |ac|&#xA;  ac.legs.map(&amp;amp;:id)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Mongoid models calling ActiveRecord&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Leg::Design&#xA;  include Mongoid::Document&#xA;  ...&#xA;  field :cid, as: :chair_id, type: Integer&#xA;  ...&#xA;  def chair&#xA;    @chair ||= Chair.where(id: chair_id).first!&#xA;  end&#xA;end&#xA;&#xA;Leg::Design.last(20) do |l|&#xA;  l.chair&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Why a new gem&lt;/h2&gt; &#xA;&lt;p&gt;Creating a new gem makes more sense since bullet&#39;s core mechanism is completely different from prosopite&#39;s.&lt;/p&gt; &#xA;&lt;h2&gt;How it works&lt;/h2&gt; &#xA;&lt;p&gt;Prosopite monitors all SQL queries using the Active Support instrumentation and looks for the following pattern which is present in all N+1 query cases:&lt;/p&gt; &#xA;&lt;p&gt;More than one queries have the same call stack and the same query fingerprint.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;prosopite&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;re &lt;strong&gt;not&lt;/strong&gt; using MySQL/MariaDB, you should also add:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;pg_query&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or install it yourself as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install prosopite&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;The preferred type of notifications can be configured with:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Prosopite.min_n_queries&lt;/code&gt;: Minimum number of N queries to report per N+1 case. Defaults to 2.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Prosopite.raise = true&lt;/code&gt;: Raise warnings as exceptions&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Prosopite.rails_logger = true&lt;/code&gt;: Send warnings to the Rails log&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Prosopite.prosopite_logger = true&lt;/code&gt;: Send warnings to &lt;code&gt;log/prosopite.log&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Prosopite.stderr_logger = true&lt;/code&gt;: Send warnings to STDERR&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Prosopite.backtrace_cleaner = my_custom_backtrace_cleaner&lt;/code&gt;: use a different &lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveSupport/BacktraceCleaner.html&#34;&gt;ActiveSupport::BacktraceCleaner&lt;/a&gt;. Defaults to &lt;code&gt;Rails.backtrace_cleaner&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Prosopite.custom_logger = my_custom_logger&lt;/code&gt;:&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Prosopite.enabled = true&lt;/code&gt;: Enables or disables the gem. Defaults to &lt;code&gt;true&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Custom Logging Configuration&lt;/h3&gt; &#xA;&lt;p&gt;You can supply a custom logger with the &lt;code&gt;Prosopite.custom_logger&lt;/code&gt; setting.&lt;/p&gt; &#xA;&lt;p&gt;This is useful for circumstances where you don&#39;t want your logs to be highlighted with red, or you want logs sent to a custom location.&lt;/p&gt; &#xA;&lt;p&gt;One common scenario is that you may be generating json logs and sending them to Datadog, ELK stack, or similar, and don&#39;t want to have to remove the default red escaping data from messages sent to the Rails logger, or want to tag them differently with your own custom logger.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Turns off logging with red highlights, but still sends them to the Rails logger&#xA;Prosopite.custom_logger = Rails.logger&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Use a completely custom logging instance&#xA;Prosopite.custom_logger = MyLoggerClass.new&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development Environment Usage&lt;/h2&gt; &#xA;&lt;p&gt;Prosopite auto-detection can be enabled on all controllers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  unless Rails.env.production?&#xA;    around_action :n_plus_one_detection&#xA;&#xA;    def n_plus_one_detection&#xA;      Prosopite.scan&#xA;      yield&#xA;    ensure&#xA;      Prosopite.finish&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And the preferred notification channel should be configured:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/environments/development.rb&#xA;&#xA;config.after_initialize do&#xA;  Prosopite.rails_logger = true&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Test Environment Usage&lt;/h2&gt; &#xA;&lt;p&gt;Tests with N+1 queries can be configured to fail with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/environments/test.rb&#xA;&#xA;config.after_initialize do&#xA;  Prosopite.rails_logger = true&#xA;  Prosopite.raise = true&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And each test can be scanned with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/spec_helper.rb&#xA;&#xA;config.before(:each) do&#xA;  Prosopite.scan&#xA;end&#xA;&#xA;config.after(:each) do&#xA;  Prosopite.finish&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;WARNING: scan/finish should run before/after &lt;strong&gt;each&lt;/strong&gt; test and NOT before/after the whole suite.&lt;/p&gt; &#xA;&lt;h2&gt;Middleware&lt;/h2&gt; &#xA;&lt;h3&gt;Rack&lt;/h3&gt; &#xA;&lt;p&gt;Instead of using an &lt;code&gt;around_action&lt;/code&gt; hook in a Rails Controller, you can also use the rack middleware instead implementing auto detect for all controllers.&lt;/p&gt; &#xA;&lt;p&gt;Add the following line into your &lt;code&gt;config/initializers/prosopite.rb&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;unless Rails.env.production?&#xA;  require &#39;prosopite/middleware/rack&#39;&#xA;  Rails.configuration.middleware.use(Prosopite::Middleware::Rack)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sidekiq&lt;/h3&gt; &#xA;&lt;p&gt;We also provide a middleware for sidekiq so that you can auto detect n+1 queries that may occur in a sidekiq job. You just need to add the following to your sidekiq initializer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Sidekiq.configure_server do |config|&#xA;  unless Rails.production?&#xA;    config.server_middleware do |chain|&#xA;      require &#39;prosopite/middleware/sidekiq&#39;&#xA;      chain.add(Prosopite::Middleware::Sidekiq)&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Allow list&lt;/h2&gt; &#xA;&lt;p&gt;Ignore notifications for call stacks containing one or more substrings / regex:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Prosopite.allow_stack_paths = [&#39;substring_in_call_stack&#39;, /regex/]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Ignore notifications matching a specific SQL query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Prosopite.ignore_queries = [/regex_match/, &#34;SELECT * from EXACT_STRING_MATCH&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Scanning code outside controllers or tests&lt;/h2&gt; &#xA;&lt;p&gt;All you have to do is to wrap the code with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Prosopite.scan&#xA;&amp;lt;code to scan&amp;gt;&#xA;Prosopite.finish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In block form the &lt;code&gt;Prosopite.finish&lt;/code&gt; is called automatically for you at the end of the block:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Prosopite.scan do&#xA;  &amp;lt;code to scan&amp;gt;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result of the code block is also returned by &lt;code&gt;Prosopite.scan&lt;/code&gt;, so you can wrap calls as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;my_object = Prosopite.scan do&#xA;  MyObjectFactory.create(params)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Pausing and resuming scans&lt;/h2&gt; &#xA;&lt;p&gt;Scans can be paused:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Prosopite.scan&#xA;# &amp;lt;code to scan&amp;gt;&#xA;Prosopite.pause&#xA;# &amp;lt;code that has n+1s&amp;gt;&#xA;Prosopite.resume&#xA;# &amp;lt;code to scan&amp;gt;&#xA;Prosopite.finish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also pause items in a block, and the &lt;code&gt;Prosopite.resume&lt;/code&gt; will be done for you automatically:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Prosopite.scan&#xA;# &amp;lt;code to scan&amp;gt;&#xA;&#xA;result = Prosopite.pause do&#xA;  # &amp;lt;code that has n+1s&amp;gt;&#xA;end&#xA;&#xA;Prosopite.finish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pauses can be ignored with &lt;code&gt;Prosopite.ignore_pauses = true&lt;/code&gt; in case you want to remember their N+1 queries.&lt;/p&gt; &#xA;&lt;p&gt;An example of when you might use this is if you are &lt;a href=&#34;https://guides.rubyonrails.org/testing.html#testing-jobs&#34;&gt;testing Active Jobs inline&lt;/a&gt;, and don&#39;t want to run Prosopite on background job code, just foreground app code. In that case you could write an &lt;a href=&#34;https://edgeguides.rubyonrails.org/active_job_basics.html#callbacks&#34;&gt;Active Job callback&lt;/a&gt; that pauses the scan while the job is running.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Bug reports and pull requests are welcome on GitHub at &lt;a href=&#34;https://github.com/charkost/prosopite&#34;&gt;https://github.com/charkost/prosopite&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Prosopite is licensed under the Apache License, Version 2.0. See LICENSE.txt for the full license text.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>rubycdp/cuprite</title>
    <updated>2023-10-09T01:38:55Z</updated>
    <id>tag:github.com,2023-10-09:/rubycdp/cuprite</id>
    <link href="https://github.com/rubycdp/cuprite" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Headless Chrome/Chromium driver for Capybara&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cuprite - Headless Chrome driver for Capybara&lt;/h1&gt; &#xA;&lt;p&gt;Cuprite is a pure Ruby driver (read as &lt;em&gt;no&lt;/em&gt; Selenium/WebDriver/ChromeDriver dependency) for &lt;a href=&#34;https://github.com/teamcapybara/capybara&#34;&gt;Capybara&lt;/a&gt;. It allows you to run Capybara tests on a headless Chrome or Chromium. Under the hood it uses &lt;a href=&#34;https://github.com/rubycdp/ferrum#index&#34;&gt;Ferrum&lt;/a&gt; which is high-level API to the browser by CDP protocol. The design of the driver is as close to &lt;a href=&#34;https://github.com/teampoltergeist/poltergeist&#34;&gt;Poltergeist&lt;/a&gt; as possible though it&#39;s not a goal.&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;Add this to your &lt;code&gt;Gemfile&lt;/code&gt; and run &lt;code&gt;bundle install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;group :test do&#xA;  gem &#34;cuprite&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In your test setup add:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;capybara/cuprite&#34;&#xA;Capybara.javascript_driver = :cuprite&#xA;Capybara.register_driver(:cuprite) do |app|&#xA;  Capybara::Cuprite::Driver.new(app, window_size: [1200, 800])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;if you use &lt;code&gt;Docker&lt;/code&gt; don&#39;t forget to pass &lt;code&gt;no-sandbox&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Capybara::Cuprite::Driver.new(app, browser_options: { &#39;no-sandbox&#39;: nil })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since Cuprite uses &lt;a href=&#34;https://github.com/rubycdp/ferrum#examples&#34;&gt;Ferrum&lt;/a&gt; there are many useful methods you can call even using this driver:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;browser = page.driver.browser&#xA;browser.mouse.move(x: 123, y: 456).down.up&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you already have tests on Poltergeist then it should simply work, for Selenium you better check your code for &lt;code&gt;manage&lt;/code&gt; calls because it works differently in Cuprite, see the documentation below.&lt;/p&gt; &#xA;&lt;h2&gt;Customization&lt;/h2&gt; &#xA;&lt;p&gt;See the full list of options for &lt;a href=&#34;https://github.com/rubycdp/ferrum#customization&#34;&gt;Ferrum&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can pass options with the following code in your test setup:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Capybara.register_driver(:cuprite) do |app|&#xA;  Capybara::Cuprite::Driver.new(app, options)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Cuprite&lt;/code&gt;-specific options are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;options &lt;code&gt;Hash&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;:url_blacklist&lt;/code&gt; (Array) - array of strings to match against requested URLs&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:url_whitelist&lt;/code&gt; (Array) - array of strings to match against requested URLs&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Debugging&lt;/h2&gt; &#xA;&lt;p&gt;If you pass &lt;code&gt;inspector&lt;/code&gt; option, remote debugging will be enabled if you run tests with &lt;code&gt;INSPECTOR=true&lt;/code&gt;. Then you can put &lt;code&gt;page.driver.debug&lt;/code&gt; or &lt;code&gt;page.driver.debug(binding)&lt;/code&gt; in your test to pause it. This will launch the browser where you can inspect the content.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Capybara.register_driver :cuprite do |app|&#xA;  Capybara::Cuprite::Driver.new(app, inspector: ENV[&#39;INSPECTOR&#39;])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then somewhere in the test:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;it &#34;does something useful&#34; do&#xA;  visit root_path&#xA;&#xA;  fill_in &#34;field&#34;, with: &#34;value&#34;&#xA;  page.driver.debug(binding)&#xA;&#xA;  expect(page).to have_content(&#34;value&#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the middle of the execution Chrome will open a new tab where you can inspect the content and also if you passed &lt;code&gt;binding&lt;/code&gt; an &lt;code&gt;irb&lt;/code&gt; or &lt;code&gt;pry&lt;/code&gt; console will be opened where you can further experiment with the test.&lt;/p&gt; &#xA;&lt;h2&gt;Clicking/Scrolling&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;page.driver.click(x, y)&lt;/code&gt; Click a very specific area of the screen.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;page.driver.scroll_to(left, top)&lt;/code&gt; Scroll to a given position.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;element.send_keys(*keys)&lt;/code&gt; Send keys to a given node.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Request headers&lt;/h2&gt; &#xA;&lt;p&gt;Manipulate HTTP request headers like a boss:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;page.driver.headers # =&amp;gt; {}&#xA;page.driver.headers = { &#34;User-Agent&#34; =&amp;gt; &#34;Cuprite&#34; }&#xA;page.driver.add_headers(&#34;Referer&#34; =&amp;gt; &#34;https://example.com&#34;)&#xA;page.driver.headers # =&amp;gt; { &#34;User-Agent&#34; =&amp;gt; &#34;Cuprite&#34;, &#34;Referer&#34; =&amp;gt; &#34;https://example.com&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that &lt;code&gt;headers=&lt;/code&gt; will overwrite already set headers. You should use &lt;code&gt;add_headers&lt;/code&gt; if you want to add a few more. These headers will apply to all subsequent HTTP requests (including requests for assets, AJAX, etc). They will be automatically cleared at the end of the test.&lt;/p&gt; &#xA;&lt;h2&gt;Network traffic&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;page.driver.network_traffic&lt;/code&gt; Inspect network traffic (loaded resources) on the current page. This returns an array of request objects.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;page.driver.network_traffic # =&amp;gt; [Request, ...]&#xA;request = page.driver.network_traffic.first&#xA;request.response&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;page.driver.wait_for_network_idle&lt;/code&gt; Natively waits for network idle and if there are no active connections returns or raises &lt;code&gt;TimeoutError&lt;/code&gt; error. Accepts the same options as &lt;a href=&#34;https://github.com/rubycdp/ferrum#wait_for_idleoptions&#34;&gt;&lt;code&gt;wait_for_idle&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;page.driver.wait_for_network_idle&#xA;page.driver.refresh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please note that network traffic is not cleared when you visit new page. You can manually clear the network traffic by calling &lt;code&gt;page.driver.clear_network_traffic&lt;/code&gt; or &lt;code&gt;page.driver.reset&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;page.driver.wait_for_reload&lt;/code&gt; unlike &lt;code&gt;wait_for_network_idle&lt;/code&gt; will wait until the whole page is reloaded or raise a timeout error. It&#39;s useful when you know that for example after clicking autocomplete suggestion you expect page to be reloaded, you have a few choices - put sleep or wait for network idle, but both are bad. Sleep makes you wait longer or less than needed, network idle can return earlier even before the whole page is started to reload. Here&#39;s the rescue.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Manipulating cookies&lt;/h2&gt; &#xA;&lt;p&gt;The following methods are used to inspect and manipulate cookies:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;page.driver.cookies&lt;/code&gt; - a hash of cookies accessible to the current page. The keys are cookie names. The values are &lt;code&gt;Cookie&lt;/code&gt; objects, with the following methods: &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;domain&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, &lt;code&gt;secure?&lt;/code&gt;, &lt;code&gt;httponly?&lt;/code&gt;, &lt;code&gt;session?&lt;/code&gt;, &lt;code&gt;expires&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;page.driver.set_cookie(name, value, options = {})&lt;/code&gt; - set a cookie. The options hash can take the following keys: &lt;code&gt;:domain&lt;/code&gt;, &lt;code&gt;:path&lt;/code&gt;, &lt;code&gt;:secure&lt;/code&gt;, &lt;code&gt;:httponly&lt;/code&gt;, &lt;code&gt;:expires&lt;/code&gt;. &lt;code&gt;:expires&lt;/code&gt; should be a &lt;code&gt;Time&lt;/code&gt; object.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;page.driver.remove_cookie(name)&lt;/code&gt; - remove a cookie&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;page.driver.clear_cookies&lt;/code&gt; - clear all cookies&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Screenshot&lt;/h2&gt; &#xA;&lt;p&gt;Besides capybara screenshot method you can get image as Base64:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;page.driver.render_base64(format, options)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Authorization&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;page.driver.basic_authorize(user, password)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Proxy&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;page.driver.set_proxy(ip, port, type, user, password)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;URL Blacklisting &amp;amp; Whitelisting&lt;/h2&gt; &#xA;&lt;p&gt;Cuprite supports URL blacklisting, which allows you to prevent scripts from running on designated domains:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;page.driver.browser.url_blacklist = %r{http://www.example.com}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and also URL whitelisting, which allows scripts to only run on designated domains:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;page.driver.browser.url_whitelist = %r{http://www.example.com}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are experiencing slower run times, consider creating a URL whitelist of domains that are essential or a blacklist of domains that are not essential, such as ad networks or analytics, to your testing environment.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>faye/websocket-driver-ruby</title>
    <updated>2023-10-09T01:38:55Z</updated>
    <id>tag:github.com,2023-10-09:/faye/websocket-driver-ruby</id>
    <link href="https://github.com/faye/websocket-driver-ruby" rel="alternate"></link>
    <summary type="html">&lt;p&gt;WebSocket protocol handler with pluggable I/O&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;websocket-driver&lt;/h1&gt; &#xA;&lt;p&gt;This module provides a complete implementation of the WebSocket protocols that can be hooked up to any TCP library. It aims to simplify things by decoupling the protocol details from the I/O layer, such that users only need to implement code to stream data in and out of it without needing to know anything about how the protocol actually works. Think of it as a complete WebSocket system with pluggable I/O.&lt;/p&gt; &#xA;&lt;p&gt;Due to this design, you get a lot of things for free. In particular, if you hook this module up to some I/O object, it will do all of this for you:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Select the correct server-side driver to talk to the client&lt;/li&gt; &#xA; &lt;li&gt;Generate and send both server- and client-side handshakes&lt;/li&gt; &#xA; &lt;li&gt;Recognize when the handshake phase completes and the WS protocol begins&lt;/li&gt; &#xA; &lt;li&gt;Negotiate subprotocol selection based on &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Negotiate and use extensions via the &lt;a href=&#34;https://github.com/faye/websocket-extensions-ruby&#34;&gt;websocket-extensions&lt;/a&gt; module&lt;/li&gt; &#xA; &lt;li&gt;Buffer sent messages until the handshake process is finished&lt;/li&gt; &#xA; &lt;li&gt;Deal with proxies that defer delivery of the draft-76 handshake body&lt;/li&gt; &#xA; &lt;li&gt;Notify you when the socket is open and closed and when messages arrive&lt;/li&gt; &#xA; &lt;li&gt;Recombine fragmented messages&lt;/li&gt; &#xA; &lt;li&gt;Dispatch text, binary, ping, pong and close frames&lt;/li&gt; &#xA; &lt;li&gt;Manage the socket-closing handshake process&lt;/li&gt; &#xA; &lt;li&gt;Automatically reply to ping frames with a matching pong&lt;/li&gt; &#xA; &lt;li&gt;Apply masking to messages sent by the client&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This library was originally extracted from the &lt;a href=&#34;http://faye.jcoglan.com&#34;&gt;Faye&lt;/a&gt; project but now aims to provide simple WebSocket support for any Ruby server or I/O system.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install websocket-driver&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;To build either a server-side or client-side socket, the only requirement is that you supply a &lt;code&gt;socket&lt;/code&gt; object with these methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;socket.url&lt;/code&gt; - returns the full URL of the socket as a string.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;socket.write(string)&lt;/code&gt; - writes the given string to a TCP stream.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Server-side sockets require one additional method:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;socket.env&lt;/code&gt; - returns a Rack-style env hash that will contain some of the following fields. Their values are strings containing the value of the named header, unless stated otherwise. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;HTTP_CONNECTION&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;HTTP_HOST&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;HTTP_ORIGIN&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;HTTP_SEC_WEBSOCKET_EXTENSIONS&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;HTTP_SEC_WEBSOCKET_KEY&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;HTTP_SEC_WEBSOCKET_KEY1&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;HTTP_SEC_WEBSOCKET_KEY2&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;HTTP_SEC_WEBSOCKET_PROTOCOL&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;HTTP_SEC_WEBSOCKET_VERSION&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;HTTP_UPGRADE&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;rack.input&lt;/code&gt;, an &lt;code&gt;IO&lt;/code&gt; object representing the request body&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;REQUEST_METHOD&lt;/code&gt;, the request&#39;s HTTP verb&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Server-side with Rack&lt;/h3&gt; &#xA;&lt;p&gt;To handle a server-side WebSocket connection, you need to check whether the request is a WebSocket handshake, and if so create a protocol driver for it. You must give the driver an object with the &lt;code&gt;env&lt;/code&gt;, &lt;code&gt;url&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt; methods. A simple example might be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;websocket/driver&#39;&#xA;require &#39;eventmachine&#39;&#xA;&#xA;class WS&#xA;  attr_reader :env, :url&#xA;&#xA;  def initialize(env)&#xA;    @env = env&#xA;&#xA;    secure = Rack::Request.new(env).ssl?&#xA;    scheme = secure ? &#39;wss:&#39; : &#39;ws:&#39;&#xA;    @url = scheme + &#39;//&#39; + env[&#39;HTTP_HOST&#39;] + env[&#39;REQUEST_URI&#39;]&#xA;&#xA;    @driver = WebSocket::Driver.rack(self)&#xA;&#xA;    env[&#39;rack.hijack&#39;].call&#xA;    @io = env[&#39;rack.hijack_io&#39;]&#xA;&#xA;    EM.attach(@io, Reader) { |conn| conn.driver = @driver }&#xA;&#xA;    @driver.start&#xA;  end&#xA;&#xA;  def write(string)&#xA;    @io.write(string)&#xA;  end&#xA;&#xA;  module Reader&#xA;    attr_writer :driver&#xA;&#xA;    def receive_data(string)&#xA;      @driver.parse(string)&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To explain what&#39;s going on here: the &lt;code&gt;WS&lt;/code&gt; class implements the &lt;code&gt;env&lt;/code&gt;, &lt;code&gt;url&lt;/code&gt; and &lt;code&gt;write(string)&lt;/code&gt; methods as required. When instantiated with a Rack environment, it stores the environment and infers the complete URL from it. Having set up the &lt;code&gt;env&lt;/code&gt; and &lt;code&gt;url&lt;/code&gt;, it asks &lt;code&gt;WebSocket::Driver&lt;/code&gt; for a server-side driver for the socket. Then it uses the Rack hijack API to gain access to the TCP stream, and uses EventMachine to stream in incoming data from the client, handing incoming data off to the driver for parsing. Finally, we tell the driver to &lt;code&gt;start&lt;/code&gt;, which will begin sending the handshake response. This will invoke the &lt;code&gt;WS#write&lt;/code&gt; method, which will send the response out over the TCP socket.&lt;/p&gt; &#xA;&lt;p&gt;Having defined this class we could use it like this when handling a request:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if WebSocket::Driver.websocket?(env)&#xA;  socket = WS.new(env)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The driver API is described in full below.&lt;/p&gt; &#xA;&lt;h3&gt;Server-side with TCP&lt;/h3&gt; &#xA;&lt;p&gt;You can also handle WebSocket connections in a bare TCP server, if you&#39;re not using Rack and don&#39;t want to implement HTTP parsing yourself. For this, your socket object only needs a &lt;code&gt;write&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;The driver will emit a &lt;code&gt;:connect&lt;/code&gt; event when a request is received, and at this point you can detect whether it&#39;s a WebSocket and handle it as such. Here&#39;s an example using an EventMachine TCP server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module Connection&#xA;  def initialize&#xA;    @driver = WebSocket::Driver.server(self)&#xA;&#xA;    @driver.on :connect, -&amp;gt; (event) do&#xA;      if WebSocket::Driver.websocket?(@driver.env)&#xA;        @driver.start&#xA;      else&#xA;        # handle other HTTP requests, for example&#xA;        body = &#39;&amp;lt;h1&amp;gt;hello&amp;lt;/h1&amp;gt;&#39;&#xA;        response = [&#xA;          &#39;HTTP/1.1 200 OK&#39;,&#xA;          &#39;Content-Type: text/plain&#39;,&#xA;          &#34;Content-Length: #{body.bytesize}&#34;,&#xA;          &#39;&#39;,&#xA;          body&#xA;        ]&#xA;        send_data response.join(&#34;\r\n&#34;)&#xA;      end&#xA;    end&#xA;&#xA;    @driver.on :message, -&amp;gt; (e) { @driver.text(e.data) }&#xA;    @driver.on :close,   -&amp;gt; (e) { close_connection_after_writing }&#xA;  end&#xA;&#xA;  def receive_data(data)&#xA;    @driver.parse(data)&#xA;  end&#xA;&#xA;  def write(data)&#xA;    send_data(data)&#xA;  end&#xA;end&#xA;&#xA;EM.run {&#xA;  EM.start_server(&#39;127.0.0.1&#39;, 4180, Connection)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the &lt;code&gt;:connect&lt;/code&gt; event, &lt;code&gt;@driver.env&lt;/code&gt; is a Rack env representing the request. If the request has a body, it will be in the &lt;code&gt;@driver.env[&#39;rack.input&#39;]&lt;/code&gt; stream, but only as much of the body as you have so far routed to it using the &lt;code&gt;parse&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;h3&gt;Client-side&lt;/h3&gt; &#xA;&lt;p&gt;Similarly, to implement a WebSocket client you need an object with &lt;code&gt;url&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt; methods. Once you have one such object, you ask for a driver for it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;driver = WebSocket::Driver.client(socket)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After this you use the driver API as described below to process incoming data and send outgoing data.&lt;/p&gt; &#xA;&lt;p&gt;Client drivers have two additional methods for reading the HTTP data that was sent back by the server:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;driver.status&lt;/code&gt; - the integer value of the HTTP status code&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;driver.headers&lt;/code&gt; - a hash-like object containing the response headers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;HTTP Proxies&lt;/h3&gt; &#xA;&lt;p&gt;The client driver supports connections via HTTP proxies using the &lt;code&gt;CONNECT&lt;/code&gt; method. Instead of sending the WebSocket handshake immediately, it will send a &lt;code&gt;CONNECT&lt;/code&gt; request, wait for a &lt;code&gt;200&lt;/code&gt; response, and then proceed as normal.&lt;/p&gt; &#xA;&lt;p&gt;To use this feature, call &lt;code&gt;proxy = driver.proxy(url)&lt;/code&gt; where &lt;code&gt;url&lt;/code&gt; is the origin of the proxy, including a username and password if required. This produces an object that manages the process of connecting via the proxy. You should call &lt;code&gt;proxy.start&lt;/code&gt; to begin the connection process, and pass data you receive via the socket to &lt;code&gt;proxy.parse(data)&lt;/code&gt;. When the proxy emits &lt;code&gt;:connect&lt;/code&gt;, you should then start sending incoming data to &lt;code&gt;driver.parse(data)&lt;/code&gt; as normal, and call &lt;code&gt;driver.start&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;proxy = driver.proxy(&#39;http://username:password@proxy.example.com&#39;)&#xA;&#xA;proxy.on :connect, -&amp;gt; (event) do&#xA;  driver.start&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The proxy&#39;s &lt;code&gt;:connect&lt;/code&gt; event is also where you should perform a TLS handshake on your TCP stream, if you are connecting to a &lt;code&gt;wss:&lt;/code&gt; endpoint.&lt;/p&gt; &#xA;&lt;p&gt;In the event that proxy connection fails, &lt;code&gt;proxy&lt;/code&gt; will emit an &lt;code&gt;:error&lt;/code&gt;. You can inspect the proxy&#39;s response via &lt;code&gt;proxy.status&lt;/code&gt; and &lt;code&gt;proxy.headers&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;proxy.on :error, -&amp;gt; (error) do&#xA;  puts error.message&#xA;  puts proxy.status&#xA;  puts proxy.headers.inspect&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Before calling &lt;code&gt;proxy.start&lt;/code&gt; you can set custom headers using &lt;code&gt;proxy.set_header&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;proxy.set_header(&#39;User-Agent&#39;, &#39;ruby&#39;)&#xA;proxy.start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Driver API&lt;/h3&gt; &#xA;&lt;p&gt;Drivers are created using one of the following methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;driver = WebSocket::Driver.rack(socket, options)&#xA;driver = WebSocket::Driver.server(socket, options)&#xA;driver = WebSocket::Driver.client(socket, options)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;rack&lt;/code&gt; method returns a driver chosen using the socket&#39;s &lt;code&gt;env&lt;/code&gt;. The &lt;code&gt;server&lt;/code&gt; method returns a driver that will parse an HTTP request and then decide which driver to use for it using the &lt;code&gt;rack&lt;/code&gt; method. The &lt;code&gt;client&lt;/code&gt; method always returns a driver for the RFC version of the protocol with masking enabled on outgoing frames.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;options&lt;/code&gt; argument is optional, and is a hash. It may contain the following keys:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:max_length&lt;/code&gt; - the maximum allowed size of incoming message frames, in bytes. The default value is &lt;code&gt;2^26 - 1&lt;/code&gt;, or 1 byte short of 64 MiB.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:protocols&lt;/code&gt; - an array of strings representing acceptable subprotocols for use over the socket. The driver will negotiate one of these to use via the &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header if supported by the other peer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All drivers respond to the following API methods, but some of them are no-ops depending on whether the client supports the behaviour.&lt;/p&gt; &#xA;&lt;p&gt;Note that most of these methods are commands: if they produce data that should be sent over the socket, they will give this to you by calling &lt;code&gt;socket.write(string)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.on :open, -&amp;gt; (event) {}&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Adds a callback block to execute when the socket becomes open.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.on :message, -&amp;gt; (event) {}&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Adds a callback block to execute when a message is received. &lt;code&gt;event&lt;/code&gt; will have a &lt;code&gt;data&lt;/code&gt; attribute containing either a string in the case of a text message or an array of integers in the case of a binary message.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.on :error, -&amp;gt; (event) {}&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Adds a callback to execute when a protocol error occurs due to the other peer sending an invalid byte sequence. &lt;code&gt;event&lt;/code&gt; will have a &lt;code&gt;message&lt;/code&gt; attribute describing the error.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.on :close, -&amp;gt; (event) {}&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Adds a callback block to execute when the socket becomes closed. The &lt;code&gt;event&lt;/code&gt; object has &lt;code&gt;code&lt;/code&gt; and &lt;code&gt;reason&lt;/code&gt; attributes.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.on :ping, -&amp;gt; (event) {}&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Adds a callback block to execute when a ping is received. You do not need to handle this by sending a pong frame yourself; the driver handles this for you.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.on :pong, -&amp;gt; (event) {}&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Adds a callback block to execute when a pong is received. If this was in response to a ping you sent, you can also handle this event via the &lt;code&gt;driver.ping(message) { ... }&lt;/code&gt; callback.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.add_extension(extension)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Registers a protocol extension whose operation will be negotiated via the &lt;code&gt;Sec-WebSocket-Extensions&lt;/code&gt; header. &lt;code&gt;extension&lt;/code&gt; is any extension compatible with the &lt;a href=&#34;https://github.com/faye/websocket-extensions-ruby&#34;&gt;websocket-extensions&lt;/a&gt; framework.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.set_header(name, value)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sets a custom header to be sent as part of the handshake response, either from the server or from the client. Must be called before &lt;code&gt;start&lt;/code&gt;, since this is when the headers are serialized and sent.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.start&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Initiates the protocol by sending the handshake - either the response for a server-side driver or the request for a client-side one. This should be the first method you invoke. Returns &lt;code&gt;true&lt;/code&gt; if and only if a handshake was sent.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.parse(string)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Takes a string and parses it, potentially resulting in message events being emitted (see &lt;code&gt;on(&#39;message&#39;)&lt;/code&gt; above) or in data being sent to &lt;code&gt;socket.write&lt;/code&gt;. You should send all data you receive via I/O to this method.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.text(string)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sends a text message over the socket. If the socket handshake is not yet complete, the message will be queued until it is. Returns &lt;code&gt;true&lt;/code&gt; if the message was sent or queued, and &lt;code&gt;false&lt;/code&gt; if the socket can no longer send messages.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.binary(array)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Takes an array of byte-sized integers and sends them as a binary message. Will queue and return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; the same way as the &lt;code&gt;text&lt;/code&gt; method. It will also return &lt;code&gt;false&lt;/code&gt; if the driver does not support binary messages.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.ping(string = &#39;&#39;, &amp;amp;callback)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sends a ping frame over the socket, queueing it if necessary. &lt;code&gt;string&lt;/code&gt; and the &lt;code&gt;callback&lt;/code&gt; block are both optional. If a callback is given, it will be invoked when the socket receives a pong frame whose content matches &lt;code&gt;string&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if frames can no longer be sent, or if the driver does not support ping/pong.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.pong(string = &#39;&#39;)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sends a pong frame over the socket, queueing it if necessary. &lt;code&gt;string&lt;/code&gt; is optional. Returns &lt;code&gt;false&lt;/code&gt; if frames can no longer be sent, or if the driver does not support ping/pong.&lt;/p&gt; &#xA;&lt;p&gt;You don&#39;t need to call this when a ping frame is received; pings are replied to automatically by the driver. This method is for sending unsolicited pongs.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.close&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Initiates the closing handshake if the socket is still open. For drivers with no closing handshake, this will result in the immediate execution of the &lt;code&gt;on(&#39;close&#39;)&lt;/code&gt; callback. For drivers with a closing handshake, this sends a closing frame and &lt;code&gt;emit(&#39;close&#39;)&lt;/code&gt; will execute when a response is received or a protocol error occurs.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.version&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns the WebSocket version in use as a string. Will either be &lt;code&gt;hixie-75&lt;/code&gt;, &lt;code&gt;hixie-76&lt;/code&gt; or &lt;code&gt;hybi-$version&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;driver.protocol&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns a string containing the selected subprotocol, if any was agreed upon using the &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; mechanism. This value becomes available after &lt;code&gt;emit(&#39;open&#39;)&lt;/code&gt; has fired.&lt;/p&gt;</summary>
  </entry>
</feed>