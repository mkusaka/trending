<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-14T01:38:30Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rspec/rspec-expectations</title>
    <updated>2022-09-14T01:38:30Z</updated>
    <id>tag:github.com,2022-09-14:/rspec/rspec-expectations</id>
    <link href="https://github.com/rspec/rspec-expectations" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Provides a readable API to express expected outcomes of a code example&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;RSpec Expectations &lt;a href=&#34;https://github.com/rspec/rspec-expectations/actions&#34;&gt;&lt;img src=&#34;https://github.com/rspec/rspec-expectations/workflows/RSpec%20CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/rspec/rspec-expectations&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/rspec/rspec-expectations.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;RSpec::Expectations lets you express expected outcomes on an object in an example.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect(account.balance).to eq(Money.new(37.42, :USD))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;If you want to use rspec-expectations with rspec, just install the rspec gem and RubyGems will also install rspec-expectations for you (along with rspec-core and rspec-mocks):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gem install rspec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Want to run against the &lt;code&gt;main&lt;/code&gt; branch? You&#39;ll need to include the dependent RSpec repos as well. Add the following to your &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;%w[rspec-core rspec-expectations rspec-mocks rspec-support].each do |lib|&#xA;  gem lib, :git =&amp;gt; &#34;https://github.com/rspec/#{lib}.git&#34;, :branch =&amp;gt; &#39;main&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use rspec-expectations with another tool, like Test::Unit, Minitest, or Cucumber, you can install it directly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gem install rspec-expectations&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Once you&#39;ve set up the environment, you&#39;ll need to cd into the working directory of whichever repo you want to work in. From there you can run the specs and cucumber features, and make patches.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: You do not need to use rspec-dev to work on a specific RSpec repo. You can treat each RSpec repo as an independent project.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rspec/rspec-expectations/main/BUILD_DETAIL.md&#34;&gt;Build details&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rspec/rspec-expectations/main/CODE_OF_CONDUCT.md&#34;&gt;Code of Conduct&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rspec/rspec-expectations/main/CONTRIBUTING.md&#34;&gt;Detailed contributing guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rspec/rspec-expectations/main/DEVELOPMENT.md&#34;&gt;Development setup guide&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Basic usage&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s an example using rspec-core:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;RSpec.describe Order do&#xA;  it &#34;sums the prices of the items in its line items&#34; do&#xA;    order = Order.new&#xA;    order.add_entry(LineItem.new(:item =&amp;gt; Item.new(&#xA;      :price =&amp;gt; Money.new(1.11, :USD)&#xA;    )))&#xA;    order.add_entry(LineItem.new(:item =&amp;gt; Item.new(&#xA;      :price =&amp;gt; Money.new(2.22, :USD),&#xA;      :quantity =&amp;gt; 2&#xA;    )))&#xA;    expect(order.total).to eq(Money.new(5.55, :USD))&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;describe&lt;/code&gt; and &lt;code&gt;it&lt;/code&gt; methods come from rspec-core. The &lt;code&gt;Order&lt;/code&gt;, &lt;code&gt;LineItem&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; and &lt;code&gt;Money&lt;/code&gt; classes would be from &lt;em&gt;your&lt;/em&gt; code. The last line of the example expresses an expected outcome. If &lt;code&gt;order.total == Money.new(5.55, :USD)&lt;/code&gt;, then the example passes. If not, it fails with a message like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;expected: #&amp;lt;Money @value=5.55 @currency=:USD&amp;gt;&#xA;     got: #&amp;lt;Money @value=1.11 @currency=:USD&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Built-in matchers&lt;/h2&gt; &#xA;&lt;h3&gt;Equivalence&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect(actual).to eq(expected)  # passes if actual == expected&#xA;expect(actual).to eql(expected) # passes if actual.eql?(expected)&#xA;expect(actual).not_to eql(not_expected) # passes if not(actual.eql?(expected))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: The new &lt;code&gt;expect&lt;/code&gt; syntax no longer supports the &lt;code&gt;==&lt;/code&gt; matcher.&lt;/p&gt; &#xA;&lt;h3&gt;Identity&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect(actual).to be(expected)    # passes if actual.equal?(expected)&#xA;expect(actual).to equal(expected) # passes if actual.equal?(expected)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Comparisons&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect(actual).to be &amp;gt;  expected&#xA;expect(actual).to be &amp;gt;= expected&#xA;expect(actual).to be &amp;lt;= expected&#xA;expect(actual).to be &amp;lt;  expected&#xA;expect(actual).to be_within(delta).of(expected)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Regular expressions&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect(actual).to match(/expression/)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: The new &lt;code&gt;expect&lt;/code&gt; syntax no longer supports the &lt;code&gt;=~&lt;/code&gt; matcher.&lt;/p&gt; &#xA;&lt;h3&gt;Types/classes&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect(actual).to be_an_instance_of(expected) # passes if actual.class == expected&#xA;expect(actual).to be_a(expected)              # passes if actual.kind_of?(expected)&#xA;expect(actual).to be_an(expected)             # an alias for be_a&#xA;expect(actual).to be_a_kind_of(expected)      # another alias&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Truthiness&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect(actual).to be_truthy   # passes if actual is truthy (not nil or false)&#xA;expect(actual).to be true     # passes if actual == true&#xA;expect(actual).to be_falsy    # passes if actual is falsy (nil or false)&#xA;expect(actual).to be false    # passes if actual == false&#xA;expect(actual).to be_nil      # passes if actual is nil&#xA;expect(actual).to_not be_nil  # passes if actual is not nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Expecting errors&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect { ... }.to raise_error&#xA;expect { ... }.to raise_error(ErrorClass)&#xA;expect { ... }.to raise_error(&#34;message&#34;)&#xA;expect { ... }.to raise_error(ErrorClass, &#34;message&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Expecting throws&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect { ... }.to throw_symbol&#xA;expect { ... }.to throw_symbol(:symbol)&#xA;expect { ... }.to throw_symbol(:symbol, &#39;value&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Yielding&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect { |b| 5.tap(&amp;amp;b) }.to yield_control # passes regardless of yielded args&#xA;&#xA;expect { |b| yield_if_true(true, &amp;amp;b) }.to yield_with_no_args # passes only if no args are yielded&#xA;&#xA;expect { |b| 5.tap(&amp;amp;b) }.to yield_with_args(5)&#xA;expect { |b| 5.tap(&amp;amp;b) }.to yield_with_args(Integer)&#xA;expect { |b| &#34;a string&#34;.tap(&amp;amp;b) }.to yield_with_args(/str/)&#xA;&#xA;expect { |b| [1, 2, 3].each(&amp;amp;b) }.to yield_successive_args(1, 2, 3)&#xA;expect { |b| { :a =&amp;gt; 1, :b =&amp;gt; 2 }.each(&amp;amp;b) }.to yield_successive_args([:a, 1], [:b, 2])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Predicate matchers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect(actual).to be_xxx         # passes if actual.xxx?&#xA;expect(actual).to have_xxx(:arg) # passes if actual.has_xxx?(:arg)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Ranges (Ruby &amp;gt;= 1.9 only)&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect(1..10).to cover(3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Collection membership&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# exact order, entire collection&#xA;expect(actual).to eq(expected)&#xA;&#xA;# exact order, partial collection (based on an exact position)&#xA;expect(actual).to start_with(expected)&#xA;expect(actual).to end_with(expected)&#xA;&#xA;# any order, entire collection&#xA;expect(actual).to match_array(expected)&#xA;&#xA;# You can also express this by passing the expected elements&#xA;# as individual arguments&#xA;expect(actual).to contain_exactly(expected_element1, expected_element2)&#xA;&#xA; # any order, partial collection&#xA;expect(actual).to include(expected)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Examples&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect([1, 2, 3]).to eq([1, 2, 3])            # Order dependent equality check&#xA;expect([1, 2, 3]).to include(1)               # Exact ordering, partial collection matches&#xA;expect([1, 2, 3]).to include(2, 3)            #&#xA;expect([1, 2, 3]).to start_with(1)            # As above, but from the start of the collection&#xA;expect([1, 2, 3]).to start_with(1, 2)         #&#xA;expect([1, 2, 3]).to end_with(3)              # As above but from the end of the collection&#xA;expect([1, 2, 3]).to end_with(2, 3)           #&#xA;expect({:a =&amp;gt; &#39;b&#39;}).to include(:a =&amp;gt; &#39;b&#39;)     # Matching within hashes&#xA;expect(&#34;this string&#34;).to include(&#34;is str&#34;)    # Matching within strings&#xA;expect(&#34;this string&#34;).to start_with(&#34;this&#34;)   #&#xA;expect(&#34;this string&#34;).to end_with(&#34;ring&#34;)     #&#xA;expect([1, 2, 3]).to contain_exactly(2, 3, 1) # Order independent matches&#xA;expect([1, 2, 3]).to match_array([3, 2, 1])   #&#xA;&#xA;# Order dependent compound matchers&#xA;expect(&#xA;  [{:a =&amp;gt; &#39;hash&#39;},{:a =&amp;gt; &#39;another&#39;}]&#xA;).to match([a_hash_including(:a =&amp;gt; &#39;hash&#39;), a_hash_including(:a =&amp;gt; &#39;another&#39;)])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;should&lt;/code&gt; syntax&lt;/h2&gt; &#xA;&lt;p&gt;In addition to the &lt;code&gt;expect&lt;/code&gt; syntax, rspec-expectations continues to support the &lt;code&gt;should&lt;/code&gt; syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;actual.should eq expected&#xA;actual.should be &amp;gt; 3&#xA;[1, 2, 3].should_not include 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/rspec/rspec-expectations/raw/main/Should.md&#34;&gt;detailed information on the &lt;code&gt;should&lt;/code&gt; syntax and its usage.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Compound Matcher Expressions&lt;/h2&gt; &#xA;&lt;p&gt;You can also create compound matcher expressions using &lt;code&gt;and&lt;/code&gt; or &lt;code&gt;or&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect(alphabet).to start_with(&#34;a&#34;).and end_with(&#34;z&#34;)&#xA;expect(stoplight.color).to eq(&#34;red&#34;).or eq(&#34;green&#34;).or eq(&#34;yellow&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Composing Matchers&lt;/h2&gt; &#xA;&lt;p&gt;Many of the built-in matchers are designed to take matchers as arguments, to allow you to flexibly specify only the essential aspects of an object or data structure. In addition, all of the built-in matchers have one or more aliases that provide better phrasing for when they are used as arguments to another matcher.&lt;/p&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;expect { k += 1.05 }.to change { k }.by( a_value_within(0.1).of(1.0) )&#xA;&#xA;expect { s = &#34;barn&#34; }.to change { s }&#xA;  .from( a_string_matching(/foo/) )&#xA;  .to( a_string_matching(/bar/) )&#xA;&#xA;expect([&#34;barn&#34;, 2.45]).to contain_exactly(&#xA;  a_value_within(0.1).of(2.5),&#xA;  a_string_starting_with(&#34;bar&#34;)&#xA;)&#xA;&#xA;expect([&#34;barn&#34;, &#34;food&#34;, 2.45]).to end_with(&#xA;  a_string_matching(&#34;foo&#34;),&#xA;  a_value &amp;gt; 2&#xA;)&#xA;&#xA;expect([&#34;barn&#34;, 2.45]).to include( a_string_starting_with(&#34;bar&#34;) )&#xA;&#xA;expect(:a =&amp;gt; &#34;food&#34;, :b =&amp;gt; &#34;good&#34;).to include(:a =&amp;gt; a_string_matching(/foo/))&#xA;&#xA;hash = {&#xA;  :a =&amp;gt; {&#xA;    :b =&amp;gt; [&#34;foo&#34;, 5],&#xA;    :c =&amp;gt; { :d =&amp;gt; 2.05 }&#xA;  }&#xA;}&#xA;&#xA;expect(hash).to match(&#xA;  :a =&amp;gt; {&#xA;    :b =&amp;gt; a_collection_containing_exactly(&#xA;      a_string_starting_with(&#34;f&#34;),&#xA;      an_instance_of(Integer)&#xA;    ),&#xA;    :c =&amp;gt; { :d =&amp;gt; (a_value &amp;lt; 3) }&#xA;  }&#xA;)&#xA;&#xA;expect { |probe|&#xA;  [1, 2, 3].each(&amp;amp;probe)&#xA;}.to yield_successive_args( a_value &amp;lt; 2, 2, a_value &amp;gt; 2 )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage outside rspec-core&lt;/h2&gt; &#xA;&lt;p&gt;You always need to load &lt;code&gt;rspec/expectations&lt;/code&gt; even if you only want to use one part of the library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;rspec/expectations&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then simply include &lt;code&gt;RSpec::Matchers&lt;/code&gt; in any class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyClass&#xA;  include RSpec::Matchers&#xA;&#xA;  def do_something(arg)&#xA;    expect(arg).to be &amp;gt; 0&#xA;    # do other stuff&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Also see&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rspec/rspec&#34;&gt;https://github.com/rspec/rspec&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rspec/rspec-core&#34;&gt;https://github.com/rspec/rspec-core&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rspec/rspec-mocks&#34;&gt;https://github.com/rspec/rspec-mocks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rspec/rspec-rails&#34;&gt;https://github.com/rspec/rspec-rails&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>