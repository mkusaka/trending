<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-17T01:42:59Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Shopify/job-iteration</title>
    <updated>2023-03-17T01:42:59Z</updated>
    <id>tag:github.com,2023-03-17:/Shopify/job-iteration</id>
    <link href="https://github.com/Shopify/job-iteration" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Makes your background jobs interruptible and resumable by design.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Job Iteration API&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Shopify/job-iteration/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/Shopify/job-iteration/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Meet Iteration, an extension for &lt;a href=&#34;https://github.com/rails/rails/tree/main/activejob&#34;&gt;ActiveJob&lt;/a&gt; that makes your jobs interruptible and resumable, saving all progress that the job has made (aka checkpoint for jobs).&lt;/p&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;Imagine the following job:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SimpleJob &amp;lt; ApplicationJob&#xA;  def perform&#xA;    User.find_each do |user|&#xA;      user.notify_about_something&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The job would run fairly quickly when you only have a hundred &lt;code&gt;User&lt;/code&gt; records. But as the number of records grows, it will take longer for a job to iterate over all Users. Eventually, there will be millions of records to iterate and the job will end up taking hours or even days.&lt;/p&gt; &#xA;&lt;p&gt;With frequent deploys and worker restarts, it would mean that a job will be either lost or restarted from the beginning. Some records (especially those in the beginning of the relation) will be processed more than once.&lt;/p&gt; &#xA;&lt;p&gt;Cloud environments are also unpredictable, and there&#39;s no way to guarantee that a single job will have reserved hardware to run for hours and days. What if AWS diagnosed the instance as unhealthy and will restart it in 5 minutes? What if a Kubernetes pod is getting &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/disruptions/&#34;&gt;evicted&lt;/a&gt;? Again, all job progress will be lost. At Shopify, we also use it to interrupt workloads safely when moving tenants between shards and move shards between regions.&lt;/p&gt; &#xA;&lt;p&gt;Software that is designed for high availability &lt;a href=&#34;https://12factor.net/disposability&#34;&gt;must be resilient&lt;/a&gt; to interruptions that come from the infrastructure. That&#39;s exactly what Iteration brings to ActiveJob. It&#39;s been developed at Shopify to safely process long-running jobs, in Cloud, and has been working in production since May 2017.&lt;/p&gt; &#xA;&lt;p&gt;We recommend that you watch one of our &lt;a href=&#34;https://www.youtube.com/watch?v=XvnWjsmAl60&#34;&gt;conference talks&lt;/a&gt; about the ideas and history behind Iteration API.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;job-iteration&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bundle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the job, include &lt;code&gt;JobIteration::Iteration&lt;/code&gt; module and start describing the job with two methods (&lt;code&gt;build_enumerator&lt;/code&gt; and &lt;code&gt;each_iteration&lt;/code&gt;) instead of &lt;code&gt;perform&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NotifyUsersJob &amp;lt; ApplicationJob&#xA;  include JobIteration::Iteration&#xA;&#xA;  def build_enumerator(cursor:)&#xA;    enumerator_builder.active_record_on_records(&#xA;      User.all,&#xA;      cursor: cursor,&#xA;    )&#xA;  end&#xA;&#xA;  def each_iteration(user)&#xA;    user.notify_about_something&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;each_iteration&lt;/code&gt; will be called for each &lt;code&gt;User&lt;/code&gt; model in &lt;code&gt;User.all&lt;/code&gt; relation. The relation will be ordered by primary key, exactly like &lt;code&gt;find_each&lt;/code&gt; does.&lt;/p&gt; &#xA;&lt;p&gt;Check out more examples of Iterations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class BatchesJob &amp;lt; ApplicationJob&#xA;  include JobIteration::Iteration&#xA;&#xA;  def build_enumerator(product_id, cursor:)&#xA;    enumerator_builder.active_record_on_batches(&#xA;      Comment.where(product_id: product_id).select(:id),&#xA;      cursor: cursor,&#xA;      batch_size: 100,&#xA;    )&#xA;  end&#xA;&#xA;  def each_iteration(batch_of_comments, product_id)&#xA;    comment_ids = batch_of_comments.map(&amp;amp;:id)&#xA;    CommentService.call(comment_ids: comment_ids)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class BatchesAsRelationJob &amp;lt; ApplicationJob&#xA;  include JobIteration::Iteration&#xA;&#xA;  def build_enumerator(product_id, cursor:)&#xA;    enumerator_builder.active_record_on_batch_relations(&#xA;      Product.find(product_id).comments,&#xA;      cursor: cursor,&#xA;      batch_size: 100,&#xA;    )&#xA;  end&#xA;&#xA;  def each_iteration(batch_of_comments, product_id)&#xA;    # batch_of_comments will be a Comment::ActiveRecord_Relation&#xA;    batch_of_comments.update_all(deleted: true)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArrayJob &amp;lt; ApplicationJob&#xA;  include JobIteration::Iteration&#xA;&#xA;  def build_enumerator(cursor:)&#xA;    enumerator_builder.array([&#39;build&#39;, &#39;enumerator&#39;, &#39;from&#39;, &#39;any&#39;, &#39;array&#39;], cursor: cursor)&#xA;  end&#xA;&#xA;  def each_iteration(array_element)&#xA;    # use array_element&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class CsvJob &amp;lt; ApplicationJob&#xA;  include JobIteration::Iteration&#xA;&#xA;  def build_enumerator(import_id, cursor:)&#xA;    import = Import.find(import_id)&#xA;    enumerator_builder.csv(import.csv, cursor: cursor)&#xA;  end&#xA;&#xA;  def each_iteration(csv_row, import_id)&#xA;    # insert csv_row to database&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Iteration hooks into Sidekiq and Resque out of the box to support graceful interruption. No extra configuration is required.&lt;/p&gt; &#xA;&lt;h2&gt;Guides&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/job-iteration/main/guides/iteration-how-it-works.md&#34;&gt;Iteration: how it works&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/job-iteration/main/guides/best-practices.md&#34;&gt;Best practices&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/job-iteration/main/guides/custom-enumerator.md&#34;&gt;Writing custom enumerator&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/job-iteration/main/guides/throttling.md&#34;&gt;Throttling&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more detailed documentation, see &lt;a href=&#34;https://www.rubydoc.info/github/Shopify/job-iteration&#34;&gt;rubydoc&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;ActiveJob is the primary requirement for Iteration. While there&#39;s nothing that prevents it, Iteration is not yet compatible with &lt;a href=&#34;https://github.com/mperham/sidekiq/wiki/Active-Job&#34;&gt;vanilla&lt;/a&gt; Sidekiq API.&lt;/p&gt; &#xA;&lt;h3&gt;API&lt;/h3&gt; &#xA;&lt;p&gt;Iteration job must respond to &lt;code&gt;build_enumerator&lt;/code&gt; and &lt;code&gt;each_iteration&lt;/code&gt; methods. &lt;code&gt;build_enumerator&lt;/code&gt; must return &lt;a href=&#34;http://ruby-doc.org/core-2.5.1/Enumerator.html&#34;&gt;Enumerator&lt;/a&gt; object that respects the &lt;code&gt;cursor&lt;/code&gt; value.&lt;/p&gt; &#xA;&lt;h3&gt;Sidekiq adapter&lt;/h3&gt; &#xA;&lt;p&gt;Unless you are running on Heroku, we recommend you to tune Sidekiq&#39;s &lt;a href=&#34;https://github.com/mperham/sidekiq/wiki/Deployment#overview&#34;&gt;timeout&lt;/a&gt; option from the default 8 seconds to 25-30 seconds, to allow the last &lt;code&gt;each_iteration&lt;/code&gt; to complete and gracefully shutdown.&lt;/p&gt; &#xA;&lt;h3&gt;Resque adapter&lt;/h3&gt; &#xA;&lt;p&gt;There a few configuration assumptions that are required for Iteration to work with Resque. &lt;code&gt;GRACEFUL_TERM&lt;/code&gt; must be enabled (giving the job ability to gracefully interrupt), and &lt;code&gt;FORK_PER_JOB&lt;/code&gt; is recommended to be disabled (set to &lt;code&gt;false&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Why can&#39;t I just iterate in &lt;code&gt;#perform&lt;/code&gt; method and do whatever I want?&lt;/strong&gt; You can, but then your job has to comply with a long list of requirements, such as the ones above. This creates leaky abstractions more easily, when instead we can expose a more powerful abstraction for developers--without exposing the underlying infrastructure.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;What happens when my job is interrupted?&lt;/strong&gt; A checkpoint will be persisted to Redis after the current &lt;code&gt;each_iteration&lt;/code&gt;, and the job will be re-enqueued. Once it&#39;s popped off the queue, the worker will work off from the next iteration.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;What happens with retries?&lt;/strong&gt; An interruption of a job does not count as a retry. The iteration of job that caused the job to fail will be retried and progress will continue from there on.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;What happens if my iteration takes a long time?&lt;/strong&gt; We recommend that a single &lt;code&gt;each_iteration&lt;/code&gt; should take no longer than 30 seconds. In the future, this may raise an exception.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Why is it important that &lt;code&gt;each_iteration&lt;/code&gt; takes less than 30 seconds?&lt;/strong&gt; When the job worker is scheduled for restart or shutdown, it gets a notice to finish remaining unit of work. To guarantee that no progress is lost we need to make sure that &lt;code&gt;each_iteration&lt;/code&gt; completes within a reasonable amount of time.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;What do I do if each iteration takes a long time, because it&#39;s doing nested operations?&lt;/strong&gt; If your &lt;code&gt;each_iteration&lt;/code&gt; is complex, we recommend enqueuing another job, which will run your nested business logic. We may expose primitives in the future to do this more effectively, but this is not terribly common today.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Why do I use have to use this ugly helper in &lt;code&gt;build_enumerator&lt;/code&gt;? Why can&#39;t you automatically infer it?&lt;/strong&gt; This is how the first version of the API worked. We checked the type of object returned by &lt;code&gt;build_enumerable&lt;/code&gt;, and whether it was ActiveRecord Relation or an Array, we used the matching adapter. This caused opaque type branching in Iteration internals and it didn’t allow developers to craft their own Enumerators and control the cursor value. We made a decision to &lt;em&gt;always&lt;/em&gt; return Enumerator instance from &lt;code&gt;build_enumerator&lt;/code&gt;. Now we provide explicit helpers to convert ActiveRecord Relation or an Array to Enumerator, and for more complex iteration flows developers can build their own &lt;code&gt;Enumerator&lt;/code&gt; objects.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;What is the difference between Enumerable and Enumerator?&lt;/strong&gt; We recomend &lt;a href=&#34;http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/&#34;&gt;this post&lt;/a&gt; to learn more about Enumerators in Ruby.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;My job has a complex flow. How do I write my own Enumerator?&lt;/strong&gt; Iteration API takes care of persisting the cursor (that you may use to calculate an offset) and controlling the job state. The power of Enumerator object is that you can use the cursor in any way you want. One example is a cursorless job that pops records from a datastore until the job is interrupted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyJob &amp;lt; ApplicationJob&#xA;  include JobIteration::Iteration&#xA;&#xA;  def build_enumerator(cursor:)&#xA;    Enumerator.new do&#xA;      Redis.lpop(&#34;mylist&#34;) # or: Kafka.poll(timeout: 10.seconds)&#xA;    end&#xA;  end&#xA;&#xA;  def each_iteration(element_from_redis)&#xA;    # ...&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;This project would not be possible without these individuals (in alphabetical order):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Daniella Niyonkuru&lt;/li&gt; &#xA; &lt;li&gt;Emil Stolarsky&lt;/li&gt; &#xA; &lt;li&gt;Florian Weingarten&lt;/li&gt; &#xA; &lt;li&gt;Guillaume Malette&lt;/li&gt; &#xA; &lt;li&gt;Hormoz Kheradmand&lt;/li&gt; &#xA; &lt;li&gt;Mohamed-Adam Chaieb&lt;/li&gt; &#xA; &lt;li&gt;Simon Eskildsen&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;After checking out the repo, run &lt;code&gt;bin/setup&lt;/code&gt; to install dependencies and create mysql database. Then, run &lt;code&gt;bundle exec rake test&lt;/code&gt; to run the tests.&lt;/p&gt; &#xA;&lt;p&gt;To install this gem onto your local machine, run &lt;code&gt;bundle exec rake install&lt;/code&gt;. To release a new version, update the version number in &lt;code&gt;version.rb&lt;/code&gt;, and then run &lt;code&gt;bundle exec rake release&lt;/code&gt;, which will create a git tag for the version, push git commits and tags, and push the &lt;code&gt;.gem&lt;/code&gt; file to &lt;a href=&#34;https://rubygems.org&#34;&gt;rubygems.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Bug reports and pull requests are welcome on GitHub at &lt;a href=&#34;https://github.com/Shopify/job-iteration&#34;&gt;https://github.com/Shopify/job-iteration&lt;/a&gt;. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the &lt;a href=&#34;http://contributor-covenant.org&#34;&gt;Contributor Covenant&lt;/a&gt; code of conduct.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;Everyone interacting in the Job::Iteration project’s codebases, issue trackers, chat rooms and mailing lists is expected to follow the &lt;a href=&#34;https://github.com/Shopify/job-iteration/raw/main/CODE_OF_CONDUCT.md&#34;&gt;code of conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>