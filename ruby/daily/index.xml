<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-23T01:45:59Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>learn-co-curriculum/phase-3-ruby-building-applications-requiring-files</title>
    <updated>2022-08-23T01:45:59Z</updated>
    <id>tag:github.com,2022-08-23:/learn-co-curriculum/phase-3-ruby-building-applications-requiring-files</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-ruby-building-applications-requiring-files" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Requiring Files&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Recognize how code in different files can be loaded when running a single file&lt;/li&gt; &#xA; &lt;li&gt;Understand how to require files when running a Ruby application&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;So far, most of the labs we&#39;ve seen have a similar file structure — they typically have a &lt;code&gt;lib&lt;/code&gt; folder and a &lt;code&gt;spec&lt;/code&gt; folder and some files like &lt;code&gt;README.md&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;├── lib&#xA;│   └── ruby_file.rb&#xA;├── spec&#xA;│   ├── ruby_file_spec.rb&#xA;│   └── spec_helper.rb&#xA;└── README.md&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As we expand our understanding of programming in Ruby and start to work with larger, more complex applications, we&#39;ll start to see more pieces and components being added — run files and environment files, to start. Then, we&#39;ll start seeing things like database folders and before long, we&#39;ll see many files in many folders, all doing their small part for the application.&lt;/p&gt; &#xA;&lt;p&gt;With all these files separated out into different folders, how is it that they are able to work together? In this lesson, we&#39;re going to provide an answer to this question and take a deeper look at requiring files.&lt;/p&gt; &#xA;&lt;h2&gt;Classes Defined in the Same File&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s take a look at a pair of example classes to get started. If we define two classes in the same file, we can interact with both classes immediately after they are defined. Consider the following &lt;code&gt;Garden&lt;/code&gt; and &lt;code&gt;Plant&lt;/code&gt; classes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Garden&#xA;  attr_accessor :name&#xA;&#xA;  def initialize(name:)&#xA;    @name = name&#xA;  end&#xA;&#xA;  def plants&#xA;    Plant.all.select do |plant|&#xA;      plant.garden == self&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;class Plant&#xA;  attr_accessor :garden, :name&#xA;&#xA;  @@all = []&#xA;&#xA;  def initialize(name:)&#xA;    @name = name&#xA;    @@all &amp;lt;&amp;lt; self&#xA;  end&#xA;&#xA;  def self.all&#xA;    @@all&#xA;  end&#xA;end&#xA;&#xA;lawn = Garden.new(name: &#39;Front Lawn&#39;) # we can call Garden.new because Garden is defined above&#xA;&#xA;basil = Plant.new(name: &#39;Basil&#39;) # we can call Plant.new because Plant is defined above&#xA;basil.garden = lawn&#xA;&#xA;cucumber = Plant.new(name: &#39;Cucumber&#39;)&#xA;cucumber.garden = lawn # we can associate a plant and a garden because both are defined above&#xA;&#xA;p lawn.plants&#xA;# =&amp;gt; [#&amp;lt;Plant:0x00007fa4440ab0c8 @name=&#34;Basil&#34;, @garden=#&amp;lt;Garden:0x00007fa4440997b0 @name=&#34;Front Lawn&#34;&amp;gt;&amp;gt;, #&amp;lt;Plant:0x00007fa4440b8bd8 @name=&#34;Cucumber&#34;, @garden=#&amp;lt;Garden:0x00007fa4440997b0 @name=&#34;Front Lawn&#34;&amp;gt;&amp;gt;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: This code is available in &lt;code&gt;lib/example.rb&lt;/code&gt; and can be viewed by running &lt;code&gt;ruby lib/example.rb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;In the above code, we can call both &lt;code&gt;Garden&lt;/code&gt; and &lt;code&gt;Plant&lt;/code&gt; at the end because both classes have been defined in the same file. Notice, too, that &lt;code&gt;Garden&lt;/code&gt; includes a method, &lt;code&gt;plants&lt;/code&gt;, that calls &lt;code&gt;Plant.all&lt;/code&gt;. &lt;code&gt;Garden&lt;/code&gt; &lt;em&gt;needs&lt;/em&gt; to know about the &lt;code&gt;Plant&lt;/code&gt; class, and with the setup above, it does.&lt;/p&gt; &#xA;&lt;h2&gt;Classes Defined in Different Files&lt;/h2&gt; &#xA;&lt;p&gt;If we define the example classes in separate files, they won&#39;t automatically know about each other or have access to one another. In the &lt;code&gt;lib&lt;/code&gt; folder, &lt;code&gt;Plant&lt;/code&gt; and &lt;code&gt;Garden&lt;/code&gt; are separated into their own files, &lt;code&gt;plant.rb&lt;/code&gt; and &lt;code&gt;garden.rb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;├── lib&#xA;│   ├── example.rb&#xA;│   ├── garden.rb&#xA;│   └── plant.rb&#xA;├── CONTRIBUTING.md&#xA;├── LICENSE.md&#xA;└── README.md&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In &lt;code&gt;lib/garden.rb&lt;/code&gt;, below the &lt;code&gt;Garden&lt;/code&gt; class, the same code from the previous example is written:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# lib/garden.rb&#xA;&#xA;lawn = Garden.new(name: &#39;Front Lawn&#39;)&#xA;&#xA;basil = Plant.new(name: &#39;Basil&#39;)&#xA;basil.garden = lawn&#xA;&#xA;cucumber = Plant.new(name: &#39;Cucumber&#39;)&#xA;cucumber.garden = lawn&#xA;&#xA;p lawn.plants&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;At the moment, if we try to run the file (&lt;code&gt;ruby lib/garden.rb&lt;/code&gt;), we get an error regarding an &lt;code&gt;uninitialized constant Plant (NameError)&lt;/code&gt;. For one file to have access to code written in another file, we need to tell Ruby to &lt;em&gt;require&lt;/em&gt; that other file.&lt;/p&gt; &#xA;&lt;h2&gt;Define &lt;code&gt;require_relative&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;By requiring a file, we are telling Ruby, &#39;go load the code that exists in this file.&#39; We have two ways to tell Ruby to do this: &lt;code&gt;require_relative&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;require&lt;/code&gt; and &lt;code&gt;require_relative&lt;/code&gt; are similar to the &lt;code&gt;import&lt;/code&gt; keyword in JavaScript. There are a few key distinctions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Unlike with the &lt;code&gt;import&lt;/code&gt; keyword in JavaScript, when you &lt;code&gt;require&lt;/code&gt; a file, you don&#39;t specify any variables. Instead, you&#39;re essentially loading in &lt;em&gt;all&lt;/em&gt; the methods and class definitions defined in that file.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;require&lt;/code&gt; and &lt;code&gt;require_relative&lt;/code&gt; aren&#39;t keywords — they&#39;re actually both &lt;em&gt;methods&lt;/em&gt; defined in Ruby&#39;s &lt;a href=&#34;https://ruby-doc.org/core-2.7.3/Kernel.html#method-i-require&#34;&gt;Kernel module&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;require_relative&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The [&lt;code&gt;require_relative&lt;/code&gt;][] method accepts a &lt;em&gt;relative file path&lt;/em&gt; to the file we want to require. This means we&#39;re providing a file path that starts from the file in which the &lt;code&gt;require_relative&lt;/code&gt; statement is called.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require_relative &#39;../lib/ruby_file.rb&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the example above, &lt;code&gt;..&lt;/code&gt; would mean that inside the &lt;em&gt;parent folder&lt;/em&gt; of the &lt;em&gt;current file&lt;/em&gt; being run, there should be a &lt;code&gt;lib&lt;/code&gt; folder with a file inside it, &lt;code&gt;ruby_file.rb&lt;/code&gt;. When dealing with applications that have many neighboring files, we&#39;ll be using &lt;code&gt;require_relative&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;.rb&lt;/code&gt; file extension is optional with &lt;code&gt;require_relative&lt;/code&gt;, so using &lt;code&gt;require_relative &#39;../lib/ruby_file&#39;&lt;/code&gt; would also work.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Since an application can be installed in many places on a computer, any internal file requirements should be &lt;em&gt;relative&lt;/em&gt; to each other rather, than specifying an &lt;em&gt;absolute&lt;/em&gt; path to the location.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;require&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The [&lt;code&gt;require&lt;/code&gt;][] method accepts an &lt;em&gt;absolute file path&lt;/em&gt;, meaning a file location relative to the &lt;em&gt;root&lt;/em&gt; directory. &lt;code&gt;require&lt;/code&gt; will also accept shortened names, and checks if any matches are found in the directories located in your shell&#39;s &lt;a href=&#34;http://www.linfo.org/path_env_var.html&#34;&gt;PATH variable&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We don&#39;t often require files using their absolute path, but we will frequently require libraries using a shortened name. You have already seen this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;pry&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pry is a Ruby gem, a bundle of preexisting code that we can install on our computers. When we write &lt;code&gt;require &#39;pry&#39;&lt;/code&gt;, we are telling Ruby to load that bundle of code up before continuing. Once loaded, we will have access to whatever classes and modules are defined in &lt;code&gt;pry&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;require &#39;pry&#39;&lt;/code&gt; because when you installed Pry on your computer using &lt;code&gt;gem install pry&lt;/code&gt;, the &lt;code&gt;gem install&lt;/code&gt; command placed all the Ruby code for Pry in a special directory in your computer that is available in your shell&#39;s &lt;a href=&#34;http://www.linfo.org/path_env_var.html&#34;&gt;PATH&lt;/a&gt;. You can view more information about where your Ruby gems are installed by running &lt;code&gt;gem env&lt;/code&gt;. &lt;a href=&#34;https://www.justinweiss.com/articles/how-do-gems-work/&#34;&gt;This article&lt;/a&gt; has some excellent information about how Ruby gems work, if you&#39;re curious to learn more.&lt;/p&gt; &#xA;&lt;h2&gt;Requiring &lt;code&gt;plant.rb&lt;/code&gt; from &lt;code&gt;garden.rb&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Now that we know the syntax for requiring files, we can apply it to our example of &lt;code&gt;lib/garden.rb&lt;/code&gt; and &lt;code&gt;lib/plant.rb&lt;/code&gt;. At the top of &lt;code&gt;lib/garden.rb&lt;/code&gt;, add the following line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require_relative &#39;./plant&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, we&#39;re indicating to Ruby that there is a file, &lt;code&gt;plant.rb&lt;/code&gt; located in the same folder relative to the current file. With this added, if you try &lt;code&gt;ruby lib/garden.rb&lt;/code&gt; again, you should see it print out the expected &lt;code&gt;Plant&lt;/code&gt; instances.&lt;/p&gt; &#xA;&lt;p&gt;In this example, we only have two classes, but with &lt;code&gt;require_relative&lt;/code&gt;, we can have as many classes as we want, each in a separate file. As long as they are all required in the file that we run, they&#39;ll get loaded.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Top-Tip&lt;/strong&gt;: Since &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;require_relative&lt;/code&gt; are both Ruby methods, you can use them to load code from specific files in an IRB session as well! Try running IRB and using &lt;code&gt;require_relative&lt;/code&gt; to load in the code from the &lt;code&gt;lib/garden&lt;/code&gt; file and use some of the &lt;code&gt;Garden&lt;/code&gt; methods.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Local Variables&lt;/h3&gt; &#xA;&lt;p&gt;It is important to note that both &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;require_relative&lt;/code&gt; will not load local variables — &lt;em&gt;only&lt;/em&gt; methods, modules, and classes.&lt;/p&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;Ruby applications are often divided up among many files, and when an application runs, it typically needs a way to &lt;em&gt;load&lt;/em&gt; those various files so it has access to all the code.&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ve experienced this many times already — every time you work on a Ruby lab and run the tests, the files where you write your solution are being loaded into the files that are running the tests. This is done through a file called &lt;code&gt;spec_helper.rb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The exact workings of RSpec and the &lt;code&gt;spec_helper.rb&lt;/code&gt; file are beyond the scope of this lesson, but the underlying premise is the same as what we did in this lesson.&lt;/p&gt; &#xA;&lt;p&gt;The process of requiring files is so common and so critical to Ruby applications that it is common to include a file dedicated to the task of requiring files and loading up any needed code when an application is run. In the next lesson, we&#39;ll take a closer look at this file, typically known as &lt;code&gt;environment.rb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.justinweiss.com/articles/how-do-gems-work/&#34;&gt;How Do Gems Work?&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-3-ruby-building-applications-setting-up-the-environment</title>
    <updated>2022-08-23T01:45:59Z</updated>
    <id>tag:github.com,2022-08-23:/learn-co-curriculum/phase-3-ruby-building-applications-setting-up-the-environment</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-ruby-building-applications-setting-up-the-environment" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Setting up an Application Environment&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Recognize common Ruby application conventions&lt;/li&gt; &#xA; &lt;li&gt;Understand how to set up a &lt;code&gt;bin&lt;/code&gt; file to run a Ruby application&lt;/li&gt; &#xA; &lt;li&gt;Understand how to set up an environment file to load things when a Ruby application starts&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Most Ruby applications we&#39;ll be dealing with in this phase will use the command line. Don&#39;t be fooled though — command-line apps may seem simple and less fancy than a fully developed computer program with a graphical user interface, but CLI apps can be just as robust and powerful, if not more so.&lt;/p&gt; &#xA;&lt;p&gt;For the most part, Ruby CLI apps tend to start the same way — typing &lt;code&gt;ruby&lt;/code&gt; followed by a relative path to a Ruby file. In a complex application, though, which file should be run? In addition to this, when we run the file, how do we ensure all our necessary files are required?&lt;/p&gt; &#xA;&lt;p&gt;There are two common conventions we&#39;re going to look at in this lesson that address these questions: using a &#34;run&#34; file, and setting up the environment in &lt;code&gt;environment.rb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Using a Run File&lt;/h2&gt; &#xA;&lt;p&gt;In the previous lesson, we had Ruby code in two separate files, &lt;code&gt;lib/garden.rb&lt;/code&gt; and &lt;code&gt;lib/plant.rb&lt;/code&gt;. We were able to require &lt;code&gt;plant.rb&lt;/code&gt; from inside &lt;code&gt;garden.rb&lt;/code&gt;. This allowed us to run &lt;code&gt;ruby lib/garden.rb&lt;/code&gt; without error. Doing it this way works, but is a little sloppy. The &lt;code&gt;lib/garden.rb&lt;/code&gt; file should only contain the &lt;code&gt;Garden&lt;/code&gt; class. It doesn&#39;t make sense to also make it the file that &lt;em&gt;runs&lt;/em&gt; everything.&lt;/p&gt; &#xA;&lt;p&gt;Running an application is its own process and deserves its own file. This way, we have a single place to start the application every time.&lt;/p&gt; &#xA;&lt;p&gt;Sticking to conventions, a run file has already been created in this example, &lt;code&gt;bin/run&lt;/code&gt;, that has the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby&#xA;&#xA;require_relative &#39;../lib/garden&#39;&#xA;require_relative &#39;../lib/plant&#39;&#xA;&#xA;lawn = Garden.new(name: &#39;Front Lawn&#39;)&#xA;&#xA;basil = Plant.new(name: &#39;Basil&#39;)&#xA;basil.garden = lawn&#xA;&#xA;cucumber = Plant.new(name: &#39;Cucumber&#39;)&#xA;cucumber.garden = lawn&#xA;&#xA;p lawn.plants&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With the run file set up, we can run &lt;code&gt;ruby bin/run&lt;/code&gt; and see the run file in action. Let&#39;s step through this file briefly.&lt;/p&gt; &#xA;&lt;h3&gt;The Shebang Line&lt;/h3&gt; &#xA;&lt;p&gt;The very first line of &lt;code&gt;bin/run&lt;/code&gt; can be broadly ignored for our purposes. It is known as a &lt;a href=&#34;https://en.wikipedia.org/wiki/Shebang_(Unix)&#34;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; and is used to indicate what interpreter should be used to read the code in this file. On Unix systems, with the proper configuration, this file can run without having to write &lt;code&gt;ruby&lt;/code&gt; before it in the command line. Don&#39;t worry if this does not work for you, though. We can still run the file using &lt;code&gt;ruby bin/run&lt;/code&gt;. The shebang is just an optional line that makes this file more functional.&lt;/p&gt; &#xA;&lt;p&gt;Notice that the file &lt;em&gt;doesn&#39;t&lt;/em&gt; have the &lt;code&gt;.rb&lt;/code&gt; extension. This file is designed to be an executable and the lack of file extension indicates this. Some runner files will still have the &lt;code&gt;.rb&lt;/code&gt; extension — they may not be meant as an executable file, but are still designed to be the point of entry into the application.&lt;/p&gt; &#xA;&lt;h3&gt;Loading Files and Running Code&lt;/h3&gt; &#xA;&lt;p&gt;Run files act in some way to start an application. Before that, though, they typically need to load up any necessary files. We can see this in &lt;code&gt;bin/run&lt;/code&gt;. In the first lines of recognizable Ruby code, we require both our local files located in &lt;code&gt;lib&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require_relative &#39;../lib/garden&#39;&#xA;require_relative &#39;../lib/plant&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With &lt;code&gt;Garden&lt;/code&gt; and &lt;code&gt;Plant&lt;/code&gt; loaded, we can proceed to run our very simple application — relating a few &lt;code&gt;Plant&lt;/code&gt; instances to a &lt;code&gt;Garden&lt;/code&gt; instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;lawn = Garden.new(name: &#39;Front Lawn&#39;)&#xA;&#xA;basil = Plant.new(name: &#39;Basil&#39;)&#xA;basil.garden = lawn&#xA;&#xA;cucumber = Plant.new(name: &#39;Cucumber&#39;)&#xA;cucumber.garden = lawn&#xA;&#xA;p lawn.plants&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this particular example, the run file does a few different things to show how the setup works. Commonly, though, run files can have very little in them. A run file may load up the necessary support files, then just call a class to handle the logic of running the actual application.&lt;/p&gt; &#xA;&lt;h2&gt;Using an Environment File&lt;/h2&gt; &#xA;&lt;p&gt;Whenever we run our simple application, we load the two files in &lt;code&gt;lib&lt;/code&gt;. If we wanted to add a third class in a new file, once created, we&#39;d have to add a &lt;em&gt;third&lt;/em&gt; &lt;code&gt;require_relative&lt;/code&gt; for it in the run file. Seems easy enough so far.&lt;/p&gt; &#xA;&lt;p&gt;With more complex applications, there may be multiple places where we need to load the same application files. For example, if we added tests to this application, we would load files like &lt;code&gt;lib/garden.rb&lt;/code&gt; and &lt;code&gt;lib/plant.rb&lt;/code&gt; into our test files. That means we would need a &lt;em&gt;second set&lt;/em&gt; of &lt;code&gt;require_relative&lt;/code&gt; statements somewhere in the tests. Now, it isn&#39;t &lt;em&gt;terribly&lt;/em&gt; difficult to maintain two sets of the same code, but why should we repeat ourselves? Better if we can avoid doing that.&lt;/p&gt; &#xA;&lt;p&gt;The common solution to this is to create one file that has all the &lt;code&gt;require_relative&lt;/code&gt; statements. Then, in the run file, we just require &lt;em&gt;that&lt;/em&gt; file. If we had tests, we could also &lt;em&gt;just require that file&lt;/em&gt;. If we add more classes, we only need to modify a single file, and any place in our application requiring that file will automatically receive the updates!&lt;/p&gt; &#xA;&lt;p&gt;In Ruby frameworks like Rails, this file is called &lt;code&gt;environment.rb&lt;/code&gt; and is located in the &lt;code&gt;config&lt;/code&gt; folder. We&#39;ll follow this convention — a file with this name already exists, all we need to do is copy the &lt;code&gt;require_relative&lt;/code&gt; statements from &lt;code&gt;bin/run&lt;/code&gt; to &lt;code&gt;config/environment.rb&lt;/code&gt;, then replace them, requiring &lt;code&gt;config/environment.rb&lt;/code&gt; in our run file.&lt;/p&gt; &#xA;&lt;p&gt;For &lt;code&gt;config/environment.rb&lt;/code&gt;, that would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require_relative &#39;../lib/garden&#39;&#xA;require_relative &#39;../lib/plant&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And for &lt;code&gt;bin/run&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby&#xA;&#xA;require_relative &#39;../config/environment&#39;&#xA;&#xA;lawn = Garden.new(name: &#39;Front Lawn&#39;)&#xA;&#xA;basil = Plant.new(name: &#39;Basil&#39;)&#xA;basil.garden = lawn&#xA;&#xA;cucumber = Plant.new(name: &#39;Cucumber&#39;)&#xA;cucumber.garden = lawn&#xA;&#xA;p lawn.plants&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition to requiring all necessary files, &lt;code&gt;config/environment.rb&lt;/code&gt; is also a common place for configuring application settings. This is an ideal location, for instance, for configuring access to a database that an application can use.&lt;/p&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;To recap, in this lesson, we looked at two components commonly found in Ruby applications. The first is the run file, something that acts as the starting point of the application. The second is the &lt;code&gt;environment.rb&lt;/code&gt; file. Typically loaded when an application is started or tests are run, this file loads any required application files and handles any configuration that has to happen every time the application starts.&lt;/p&gt; &#xA;&lt;p&gt;Combining the two, we have a multi-file application that is starting to show some complexity! With our set up, we can add whatever files we want to &lt;code&gt;lib&lt;/code&gt;, require those files in &lt;code&gt;config/environment.rb&lt;/code&gt;, and they will be loaded every time we run &lt;code&gt;bin/run&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-3-metaprogramming-mass-assignment-lab</title>
    <updated>2022-08-23T01:45:59Z</updated>
    <id>tag:github.com,2022-08-23:/learn-co-curriculum/phase-3-metaprogramming-mass-assignment-lab</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-metaprogramming-mass-assignment-lab" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Mass Assignment Lab&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use keyword arguments to define an initialize method&lt;/li&gt; &#xA; &lt;li&gt;Use mass assignment to metaprogram an initialize method&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Instructions&lt;/h2&gt; &#xA;&lt;p&gt;Create a Person class that accepts a hash upon initialization. The keys of the hash should conform to the attributes below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;:name, :birthday, :hair_color, :eye_color, :height,&#xA;:weight, :handed, :complexion, :t_shirt_size,&#xA;:wrist_size, :glove_size, :pant_length, :pant_width&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each key in the attributes hash will become a property of an initialized Person instance. So, you should make an &lt;code&gt;attr_accessor&lt;/code&gt; for each of the above properties&lt;/p&gt; &#xA;&lt;p&gt;ex:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;bob_attributes = { name: &#34;Bob&#34;, hair_color: &#34;Brown&#34; }&#xA;&#xA;bob = Person.new(bob_attributes)&#xA;bob.name       # =&amp;gt; &#34;Bob&#34;&#xA;bob.hair_color # =&amp;gt; &#34;Brown&#34;&#xA;&#xA;susan_attributes = { name: &#34;Susan&#34;, height: &#34;5&#39;11\&#34;&#34;, eye_color: &#34;Green&#34; }&#xA;&#xA;susan = Person.new(susan_attributes)&#xA;susan.name      # =&amp;gt; &#34;Susan&#34;&#xA;susan.height    # =&amp;gt; &#34;5&#39;11&#34;&#34;&#xA;susan.eye_color # =&amp;gt; &#34;Green&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Your &lt;code&gt;#initialize&lt;/code&gt; method should use iteration and the &lt;code&gt;#send&lt;/code&gt; method to mass assign the value of each key/value pair to its associated key (i.e. method). Refer to the previous reading to help you solve this one.&lt;/p&gt;</summary>
  </entry>
</feed>