<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-24T01:33:24Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>redis/redis-rb</title>
    <updated>2022-07-24T01:33:24Z</updated>
    <id>tag:github.com,2022-07-24:/redis/redis-rb</id>
    <link href="https://github.com/redis/redis-rb" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Ruby client library for Redis&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;redis-rb &lt;a href=&#34;https://github.com/redis/redis-rb/actions&#34;&gt;&lt;img src=&#34;https://github.com/redis/redis-rb/workflows/Test/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://inch-ci.org/github/redis/redis-rb&#34;&gt;&lt;img src=&#34;https://inch-ci.org/github/redis/redis-rb.svg?sanitize=true&#34; alt=&#34;Inline docs&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;A Ruby client that tries to match &lt;a href=&#34;https://redis.io&#34;&gt;Redis&lt;/a&gt;&#39; API one-to-one, while still providing an idiomatic interface.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://www.rubydoc.info/gems/redis&#34;&gt;RubyDoc.info&lt;/a&gt; for the API docs of the latest published gem.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;Install with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install redis&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can connect to Redis by instantiating the &lt;code&gt;Redis&lt;/code&gt; class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;redis&#34;&#xA;&#xA;redis = Redis.new&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This assumes Redis was started with a default configuration, and is listening on &lt;code&gt;localhost&lt;/code&gt;, port 6379. If you need to connect to a remote server or a different port, try:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis = Redis.new(host: &#34;10.0.1.1&#34;, port: 6380, db: 15)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also specify connection options as a &lt;a href=&#34;http://www.iana.org/assignments/uri-schemes/prov/redis&#34;&gt;&lt;code&gt;redis://&lt;/code&gt; URL&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis = Redis.new(url: &#34;redis://:p4ssw0rd@10.0.1.1:6380/15&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The client expects passwords with special chracters to be URL-encoded (i.e. &lt;code&gt;CGI.escape(password)&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;By default, the client will try to read the &lt;code&gt;REDIS_URL&lt;/code&gt; environment variable and use that as URL to connect to. The above statement is therefore equivalent to setting this environment variable and calling &lt;code&gt;Redis.new&lt;/code&gt; without arguments.&lt;/p&gt; &#xA;&lt;p&gt;To connect to Redis listening on a Unix socket, try:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis = Redis.new(path: &#34;/tmp/redis.sock&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To connect to a password protected Redis instance, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis = Redis.new(password: &#34;mysecret&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To connect a Redis instance using &lt;a href=&#34;https://redis.io/topics/acl&#34;&gt;ACL&lt;/a&gt;, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis = Redis.new(username: &#39;myname&#39;, password: &#39;mysecret&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Redis class exports methods that are named identical to the commands they execute. The arguments these methods accept are often identical to the arguments specified on the &lt;a href=&#34;https://redis.io/commands&#34;&gt;Redis website&lt;/a&gt;. For instance, the &lt;code&gt;SET&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; commands can be called like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis.set(&#34;mykey&#34;, &#34;hello world&#34;)&#xA;# =&amp;gt; &#34;OK&#34;&#xA;&#xA;redis.get(&#34;mykey&#34;)&#xA;# =&amp;gt; &#34;hello world&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All commands, their arguments, and return values are documented and available on &lt;a href=&#34;http://www.rubydoc.info/gems/redis&#34;&gt;RubyDoc.info&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Sentinel support&lt;/h2&gt; &#xA;&lt;p&gt;The client is able to perform automatic failover by using &lt;a href=&#34;http://redis.io/topics/sentinel&#34;&gt;Redis Sentinel&lt;/a&gt;. Make sure to run Redis 2.8+ if you want to use this feature.&lt;/p&gt; &#xA;&lt;p&gt;To connect using Sentinel, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SENTINELS = [{ host: &#34;127.0.0.1&#34;, port: 26380 },&#xA;             { host: &#34;127.0.0.1&#34;, port: 26381 }]&#xA;&#xA;redis = Redis.new(url: &#34;redis://mymaster&#34;, sentinels: SENTINELS, role: :master)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The master name identifies a group of Redis instances composed of a master and one or more slaves (&lt;code&gt;mymaster&lt;/code&gt; in the example).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;It is possible to optionally provide a role. The allowed roles are &lt;code&gt;master&lt;/code&gt; and &lt;code&gt;slave&lt;/code&gt;. When the role is &lt;code&gt;slave&lt;/code&gt;, the client will try to connect to a random slave of the specified master. If a role is not specified, the client will connect to the master.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;When using the Sentinel support you need to specify a list of sentinels to connect to. The list does not need to enumerate all your Sentinel instances, but a few so that if one is down the client will try the next one. The client is able to remember the last Sentinel that was able to reply correctly and will use it for the next requests.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to &lt;a href=&#34;https://redis.io/topics/sentinel#configuring-sentinel-instances-with-authentication&#34;&gt;authenticate&lt;/a&gt; Sentinel itself, you must specify the &lt;code&gt;password&lt;/code&gt; option per instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SENTINELS = [{ host: &#39;127.0.0.1&#39;, port: 26380, password: &#39;mysecret&#39; },&#xA;             { host: &#39;127.0.0.1&#39;, port: 26381, password: &#39;mysecret&#39; }]&#xA;&#xA;redis = Redis.new(host: &#39;mymaster&#39;, sentinels: SENTINELS, role: :master)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Cluster support&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;redis-rb&lt;/code&gt; supports &lt;a href=&#34;https://redis.io/topics/cluster-spec&#34;&gt;clustering&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Nodes can be passed to the client as an array of connection URLs.&#xA;nodes = (7000..7005).map { |port| &#34;redis://127.0.0.1:#{port}&#34; }&#xA;redis = Redis.new(cluster: nodes)&#xA;&#xA;# You can also specify the options as a Hash. The options are the same as for a single server connection.&#xA;(7000..7005).map { |port| { host: &#39;127.0.0.1&#39;, port: port } }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also specify only a subset of the nodes, and the client will discover the missing ones using the &lt;a href=&#34;https://redis.io/commands/cluster-nodes&#34;&gt;CLUSTER NODES&lt;/a&gt; command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Redis.new(cluster: %w[redis://127.0.0.1:7000])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want &lt;a href=&#34;https://redis.io/commands/readonly&#34;&gt;the connection to be able to read from any replica&lt;/a&gt;, you must pass the &lt;code&gt;replica: true&lt;/code&gt;. Note that this connection won&#39;t be usable to write keys.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Redis.new(cluster: nodes, replica: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The calling code is responsible for &lt;a href=&#34;https://redis.io/topics/cluster-spec#keys-distribution-model&#34;&gt;avoiding cross slot commands&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis = Redis.new(cluster: %w[redis://127.0.0.1:7000])&#xA;&#xA;redis.mget(&#39;key1&#39;, &#39;key2&#39;)&#xA;#=&amp;gt; Redis::CommandError (CROSSSLOT Keys in request don&#39;t hash to the same slot)&#xA;&#xA;redis.mget(&#39;{key}1&#39;, &#39;{key}2&#39;)&#xA;#=&amp;gt; [nil, nil]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The client automatically reconnects after a failover occurred, but the caller is responsible for handling errors while it is happening.&lt;/li&gt; &#xA; &lt;li&gt;The client support permanent node failures, and will reroute requests to promoted slaves.&lt;/li&gt; &#xA; &lt;li&gt;The client supports &lt;code&gt;MOVED&lt;/code&gt; and &lt;code&gt;ASK&lt;/code&gt; redirections transparently.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Cluster mode with SSL/TLS&lt;/h2&gt; &#xA;&lt;p&gt;Since Redis can return FQDN of nodes in reply to client since &lt;code&gt;7.*&lt;/code&gt; with CLUSTER commands, we can use cluster feature with SSL/TLS connection like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Redis.new(cluster: %w[rediss://foo.example.com:6379])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On the other hand, in Redis versions prior to &lt;code&gt;6.*&lt;/code&gt;, you can specify options like the following if cluster mode is enabled and client has to connect to nodes via single endpoint with SSL/TLS.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Redis.new(cluster: %w[rediss://foo-endpoint.example.com:6379], fixed_hostname: &#39;foo-endpoint.example.com&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case of the above architecture, if you don&#39;t pass the &lt;code&gt;fixed_hostname&lt;/code&gt; option to the client and servers return IP addresses of nodes, the client may fail to verify certificates.&lt;/p&gt; &#xA;&lt;h2&gt;Storing objects&lt;/h2&gt; &#xA;&lt;p&gt;Redis &#34;string&#34; types can be used to store serialized Ruby objects, for example with JSON:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;json&#34;&#xA;&#xA;redis.set &#34;foo&#34;, [1, 2, 3].to_json&#xA;# =&amp;gt; OK&#xA;&#xA;JSON.parse(redis.get(&#34;foo&#34;))&#xA;# =&amp;gt; [1, 2, 3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Pipelining&lt;/h2&gt; &#xA;&lt;p&gt;When multiple commands are executed sequentially, but are not dependent, the calls can be &lt;em&gt;pipelined&lt;/em&gt;. This means that the client doesn&#39;t wait for reply of the first command before sending the next command. The advantage is that multiple commands are sent at once, resulting in faster overall execution.&lt;/p&gt; &#xA;&lt;p&gt;The client can be instructed to pipeline commands by using the &lt;code&gt;#pipelined&lt;/code&gt; method. After the block is executed, the client sends all commands to Redis and gathers their replies. These replies are returned by the &lt;code&gt;#pipelined&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis.pipelined do |pipeline|&#xA;  pipeline.set &#34;foo&#34;, &#34;bar&#34;&#xA;  pipeline.incr &#34;baz&#34;&#xA;end&#xA;# =&amp;gt; [&#34;OK&#34;, 1]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Executing commands atomically&lt;/h3&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;MULTI/EXEC&lt;/code&gt; to run a number of commands in an atomic fashion. This is similar to executing a pipeline, but the commands are preceded by a call to &lt;code&gt;MULTI&lt;/code&gt;, and followed by a call to &lt;code&gt;EXEC&lt;/code&gt;. Like the regular pipeline, the replies to the commands are returned by the &lt;code&gt;#multi&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis.multi do |transaction|&#xA;  transaction.set &#34;foo&#34;, &#34;bar&#34;&#xA;  transaction.incr &#34;baz&#34;&#xA;end&#xA;# =&amp;gt; [&#34;OK&#34;, 1]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Futures&lt;/h3&gt; &#xA;&lt;p&gt;Replies to commands in a pipeline can be accessed via the &lt;em&gt;futures&lt;/em&gt; they emit (since redis-rb 3.0). All calls on the pipeline object return a &lt;code&gt;Future&lt;/code&gt; object, which responds to the &lt;code&gt;#value&lt;/code&gt; method. When the pipeline has successfully executed, all futures are assigned their respective replies and can be used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis.pipelined do |pipeline|&#xA;  @set = pipeline.set &#34;foo&#34;, &#34;bar&#34;&#xA;  @incr = pipeline.incr &#34;baz&#34;&#xA;end&#xA;&#xA;@set.value&#xA;# =&amp;gt; &#34;OK&#34;&#xA;&#xA;@incr.value&#xA;# =&amp;gt; 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Error Handling&lt;/h2&gt; &#xA;&lt;p&gt;In general, if something goes wrong you&#39;ll get an exception. For example, if it can&#39;t connect to the server a &lt;code&gt;Redis::CannotConnectError&lt;/code&gt; error will be raised.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;begin&#xA;  redis.ping&#xA;rescue StandardError =&amp;gt; e&#xA;  e.inspect&#xA;# =&amp;gt; #&amp;lt;Redis::CannotConnectError: Timed out connecting to Redis on 10.0.1.1:6380&amp;gt;&#xA;&#xA;  e.message&#xA;# =&amp;gt; Timed out connecting to Redis on 10.0.1.1:6380&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See lib/redis/errors.rb for information about what exceptions are possible.&lt;/p&gt; &#xA;&lt;h2&gt;Timeouts&lt;/h2&gt; &#xA;&lt;p&gt;The client allows you to configure connect, read, and write timeouts. Passing a single &lt;code&gt;timeout&lt;/code&gt; option will set all three values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Redis.new(:timeout =&amp;gt; 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But you can use specific values for each of them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Redis.new(&#xA;  :connect_timeout =&amp;gt; 0.2,&#xA;  :read_timeout    =&amp;gt; 1.0,&#xA;  :write_timeout   =&amp;gt; 0.5&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All timeout values are specified in seconds.&lt;/p&gt; &#xA;&lt;p&gt;When using pub/sub, you can subscribe to a channel using a timeout as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis = Redis.new(reconnect_attempts: 0)&#xA;redis.subscribe_with_timeout(5, &#34;news&#34;) do |on|&#xA;  on.message do |channel, message|&#xA;    # ...&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If no message is received after 5 seconds, the client will unsubscribe.&lt;/p&gt; &#xA;&lt;h2&gt;Reconnections&lt;/h2&gt; &#xA;&lt;p&gt;The client allows you to configure how many &lt;code&gt;reconnect_attempts&lt;/code&gt; it should complete before declaring a connection as failed. Furthermore, you may want to control the maximum duration between reconnection attempts with &lt;code&gt;reconnect_delay&lt;/code&gt; and &lt;code&gt;reconnect_delay_max&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Redis.new(&#xA;  :reconnect_attempts =&amp;gt; 10,&#xA;  :reconnect_delay =&amp;gt; 1.5,&#xA;  :reconnect_delay_max =&amp;gt; 10.0,&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The delay values are specified in seconds. With the above configuration, the client would attempt 10 reconnections, exponentially increasing the duration between each attempt but it never waits longer than &lt;code&gt;reconnect_delay_max&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is the retry algorithm:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;attempt_wait_time = [(reconnect_delay * 2**(attempt-1)), reconnect_delay_max].min&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;By default&lt;/strong&gt;, this gem will only &lt;strong&gt;retry a connection once&lt;/strong&gt; and then fail, but with the above configuration the reconnection attempt would look like this:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;#&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Attempt wait time&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Total wait time&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.5s&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.5s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;3.0s&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;4.5s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;3&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;6.0s&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;10.5s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;10.0s&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;20.5s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;5&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;10.0s&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;30.5s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;6&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;10.0s&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;40.5s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;7&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;10.0s&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;50.5s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;10.0s&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;60.5s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;9&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;10.0s&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;70.5s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;10&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;10.0s&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;80.5s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;So if the reconnection attempt #10 succeeds 70 seconds have elapsed trying to reconnect, this is likely fine in long-running background processes, but if you use Redis to drive your website you might want to have a lower &lt;code&gt;reconnect_delay_max&lt;/code&gt; or have less &lt;code&gt;reconnect_attempts&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;SSL/TLS Support&lt;/h2&gt; &#xA;&lt;p&gt;This library supports natively terminating client side SSL/TLS connections when talking to Redis via a server-side proxy such as &lt;a href=&#34;https://www.stunnel.org/&#34;&gt;stunnel&lt;/a&gt;, &lt;a href=&#34;https://hitch-tls.org/&#34;&gt;hitch&lt;/a&gt;, or &lt;a href=&#34;https://github.com/square/ghostunnel&#34;&gt;ghostunnel&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To enable SSL support, pass the &lt;code&gt;:ssl =&amp;gt; true&lt;/code&gt; option when configuring the Redis client, or pass in &lt;code&gt;:url =&amp;gt; &#34;rediss://...&#34;&lt;/code&gt; (like HTTPS for Redis). You will also need to pass in an &lt;code&gt;:ssl_params =&amp;gt; { ... }&lt;/code&gt; hash used to configure the &lt;code&gt;OpenSSL::SSL::SSLContext&lt;/code&gt; object used for the connection:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis = Redis.new(&#xA;  :url        =&amp;gt; &#34;rediss://:p4ssw0rd@10.0.1.1:6381/15&#34;,&#xA;  :ssl_params =&amp;gt; {&#xA;    :ca_file =&amp;gt; &#34;/path/to/ca.crt&#34;&#xA;  }&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The options given to &lt;code&gt;:ssl_params&lt;/code&gt; are passed directly to the &lt;code&gt;OpenSSL::SSL::SSLContext#set_params&lt;/code&gt; method and can be any valid attribute of the SSL context. Please see the &lt;a href=&#34;http://ruby-doc.org/stdlib-2.3.0/libdoc/openssl/rdoc/OpenSSL/SSL/SSLContext.html&#34;&gt;OpenSSL::SSL::SSLContext documentation&lt;/a&gt; for all of the available attributes.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example of passing in params that can be used for SSL client certificate authentication (a.k.a. mutual TLS):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis = Redis.new(&#xA;  :url        =&amp;gt; &#34;rediss://:p4ssw0rd@10.0.1.1:6381/15&#34;,&#xA;  :ssl_params =&amp;gt; {&#xA;    :ca_file =&amp;gt; &#34;/path/to/ca.crt&#34;,&#xA;    :cert    =&amp;gt; OpenSSL::X509::Certificate.new(File.read(&#34;client.crt&#34;)),&#xA;    :key     =&amp;gt; OpenSSL::PKey::RSA.new(File.read(&#34;client.key&#34;))&#xA;  }&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE:&lt;/em&gt; SSL is only supported by the default &#34;Ruby&#34; driver&lt;/p&gt; &#xA;&lt;h2&gt;Expert-Mode Options&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;inherit_socket: true&lt;/code&gt;: disable safety check that prevents a forked child from sharing a socket with its parent; this is potentially useful in order to mitigate connection churn when:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;many short-lived forked children of one process need to talk to redis, AND&lt;/li&gt; &#xA;   &lt;li&gt;your own code prevents the parent process from using the redis connection while a child is alive&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Improper use of &lt;code&gt;inherit_socket&lt;/code&gt; will result in corrupted and/or incorrect responses.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Alternate drivers&lt;/h2&gt; &#xA;&lt;p&gt;By default, redis-rb uses Ruby&#39;s socket library to talk with Redis. To use an alternative connection driver it should be specified as option when instantiating the client object. These instructions are only valid for &lt;strong&gt;redis-rb 3.0&lt;/strong&gt;. For instructions on how to use alternate drivers from &lt;strong&gt;redis-rb 2.2&lt;/strong&gt;, please refer to an &lt;a href=&#34;https://github.com/redis/redis-rb/raw/v2.2.2/README.md&#34;&gt;older README&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;hiredis&lt;/h3&gt; &#xA;&lt;p&gt;The hiredis driver uses the connection facility of hiredis-rb. In turn, hiredis-rb is a binding to the official hiredis client library. It optimizes for speed, at the cost of portability. Because it is a C extension, JRuby is not supported (by default).&lt;/p&gt; &#xA;&lt;p&gt;It is best to use hiredis when you have large replies (for example: &lt;code&gt;LRANGE&lt;/code&gt;, &lt;code&gt;SMEMBERS&lt;/code&gt;, &lt;code&gt;ZRANGE&lt;/code&gt;, etc.) and/or use big pipelines.&lt;/p&gt; &#xA;&lt;p&gt;In your Gemfile, include hiredis:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;redis&#34;, &#34;~&amp;gt; 3.0.1&#34;&#xA;gem &#34;hiredis&#34;, &#34;~&amp;gt; 0.4.5&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When instantiating the client object, specify hiredis:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis = Redis.new(:driver =&amp;gt; :hiredis)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;synchrony&lt;/h3&gt; &#xA;&lt;p&gt;The synchrony driver adds support for &lt;a href=&#34;https://github.com/igrigorik/em-synchrony&#34;&gt;em-synchrony&lt;/a&gt;. This makes redis-rb work with EventMachine&#39;s asynchronous I/O, while not changing the exposed API. The hiredis gem needs to be available as well, because the synchrony driver uses hiredis for parsing the Redis protocol.&lt;/p&gt; &#xA;&lt;p&gt;In your Gemfile, include em-synchrony and hiredis:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;redis&#34;, &#34;~&amp;gt; 3.0.1&#34;&#xA;gem &#34;hiredis&#34;, &#34;~&amp;gt; 0.4.5&#34;&#xA;gem &#34;em-synchrony&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When instantiating the client object, specify synchrony:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis = Redis.new(:driver =&amp;gt; :synchrony)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;This library is tested against recent Ruby and Redis versions. Check &lt;a href=&#34;https://github.com/redis/redis-rb/actions&#34;&gt;Github Actions&lt;/a&gt; for the exact versions supported.&lt;/p&gt; &#xA;&lt;h2&gt;See Also&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/socketry/async-redis&#34;&gt;async-redis&lt;/a&gt; — An &lt;a href=&#34;https://github.com/socketry/async&#34;&gt;async&lt;/a&gt; compatible Redis client.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;Several people contributed to redis-rb, but we would like to especially mention Ezra Zygmuntowicz. Ezra introduced the Ruby community to many new cool technologies, like Redis. He wrote the first version of this client and evangelized Redis in Rubyland. Thank you, Ezra.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/redis/redis-rb&#34;&gt;Fork the project&lt;/a&gt; and send pull requests.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>contribsys/einhorn</title>
    <updated>2022-07-24T01:33:24Z</updated>
    <id>tag:github.com,2022-07-24:/contribsys/einhorn</id>
    <link href="https://github.com/contribsys/einhorn" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Einhorn: the language-independent shared socket manager&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Einhorn: the language-independent shared socket manager&lt;/h1&gt; &#xA;&lt;p&gt;Einhorn makes it easy to run (and keep alive) multiple copies of a single long-lived process. If that process is a server listening on some socket, Einhorn will open the socket in the master process so that it&#39;s shared among the workers.&lt;/p&gt; &#xA;&lt;p&gt;Einhorn is designed to be compatible with arbitrary languages and frameworks, requiring minimal modification of your application. Einhorn is simple to configure and run.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install from Rubygems as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install einhorn&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or build from source by:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem build einhorn.gemspec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then install the built gem.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Einhorn is the language-independent shared socket manager. Run &lt;code&gt;einhorn -h&lt;/code&gt; to see detailed usage. At a high level, usage looks like the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;einhorn [options] program&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Einhorn will open one or more shared sockets and run multiple copies of your process. You can seamlessly reload your code, dynamically reconfigure Einhorn, and more.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;To set Einhorn up as a master process running 3 copies of &lt;code&gt;sleep 5&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ einhorn -n 3 sleep 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can communicate your running Einhorn process via &lt;code&gt;einhornsh&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ einhornsh&#xA;Welcome gdb! You are speaking to Einhorn Master Process 11902&#xA;Enter &#39;help&#39; if you&#39;re not sure what to do.&#xA;&#xA;Type &#34;quit&#34; or &#34;exit&#34; to quit at any time&#xA;&amp;gt; help&#xA;You are speaking to the Einhorn command socket. You can run the following commands:&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Server sockets&lt;/h3&gt; &#xA;&lt;p&gt;If your process is a server and listens on one or more sockets, Einhorn can open these sockets and pass them to the workers. You can specify the addresses to bind by passing one or more &lt;code&gt;-b ADDR&lt;/code&gt; arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;einhorn -b 127.0.0.1:1234 my-command&#xA;einhorn -b 127.0.0.1:1234,r -b 127.0.0.1:1235 my-command&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each address is specified as an ip/port pair, possibly accompanied by options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ADDR := (IP:PORT)[&amp;lt;,OPT&amp;gt;...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the worker process, the opened file descriptors will be represented as file descriptor numbers in a series of environment variables named EINHORN_FD_0, EINHORN_FD_1, etc. (respecting the order that the &lt;code&gt;-b&lt;/code&gt; options were provided in), with the total number of file descriptors in the EINHORN_FD_COUNT environment variable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;EINHORN_FD_0=&#34;6&#34; # 127.0.0.1:1234&#xA;EINHORN_FD_COUNT=&#34;1&#34;&#xA;&#xA;EINHORN_FD_0=&#34;6&#34; # 127.0.0.1:1234,r&#xA;EINHORN_FD_1=&#34;7&#34; # 127.0.0.1:1235&#xA;EINHORN_FD_COUNT=&#34;2&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Valid opts are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;r, so_reuseaddr: set SO_REUSEADDR on the server socket&#xA;n, o_nonblock: set O_NONBLOCK on the server socket&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can for example run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ einhorn -b 127.0.0.1:2345,r -m manual -n 4 -- example/time_server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which will run 4 copies of&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;EINHORN_FD_0=6 EINHORN_FD_COUNT=1 example/time_server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where file descriptor 6 is a server socket bound to &lt;code&gt;127.0.0.1:2345&lt;/code&gt; and with &lt;code&gt;SO_REUSEADDR&lt;/code&gt; set. It is then your application&#39;s job to figure out how to &lt;code&gt;accept()&lt;/code&gt; on this file descriptor.&lt;/p&gt; &#xA;&lt;h3&gt;Command socket&lt;/h3&gt; &#xA;&lt;p&gt;Einhorn opens a UNIX socket to which you can send commands (run &lt;code&gt;help&lt;/code&gt; in &lt;code&gt;einhornsh&lt;/code&gt; to see what admin commands you can run). Einhorn relies on file permissions to ensure that no malicious users can gain access. Run with a &lt;code&gt;-d DIRECTORY&lt;/code&gt; to change the directory where the socket will live.&lt;/p&gt; &#xA;&lt;p&gt;Note that the command socket uses a line-oriented YAML protocol, and you should ensure you trust clients to send arbitrary YAML messages into your process.&lt;/p&gt; &#xA;&lt;h3&gt;Seamless upgrades&lt;/h3&gt; &#xA;&lt;p&gt;You can cause your code to be seamlessly reloaded by upgrading the worker code on disk and running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ einhornsh&#xA;...&#xA;&amp;gt; upgrade&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once the new workers have been spawned, Einhorn will send each old worker a SIGUSR2. SIGUSR2 should be interpreted as a request for a graceful shutdown.&lt;/p&gt; &#xA;&lt;h3&gt;ACKs&lt;/h3&gt; &#xA;&lt;p&gt;After Einhorn spawns a worker, it will only consider the worker up once it has received an ACK. Currently two ACK mechanisms are supported: manual and timer.&lt;/p&gt; &#xA;&lt;h4&gt;Manual ACK&lt;/h4&gt; &#xA;&lt;p&gt;A manual ACK (configured by providing a &lt;code&gt;-m manual&lt;/code&gt;) requires your application to send a command to the command socket once it&#39;s ready. This is the safest ACK mechanism. If you&#39;re writing in Ruby, just do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;require &#39;einhorn/worker&#39;&#xA;Einhorn::Worker.ack!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in your worker code. If you&#39;re writing in a different language, or don&#39;t want to include Einhorn in your namespace, you can send the string&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#34;command&#34;:&#34;worker:ack&#34;, &#34;pid&#34;:PID}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to the UNIX socket pointed to by the environment variable &lt;code&gt;EINHORN_SOCK_PATH&lt;/code&gt;. (Be sure to include a trailing newline.)&lt;/p&gt; &#xA;&lt;p&gt;To make things even easier, you can pass a &lt;code&gt;-g&lt;/code&gt; to Einhorn, in which case you just need to &lt;code&gt;write()&lt;/code&gt; the above message to the open file descriptor pointed to by &lt;code&gt;EINHORN_SOCK_FD&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;(See &lt;code&gt;lib/einhorn/worker.rb&lt;/code&gt; for details of these and other socket discovery mechanisms.)&lt;/p&gt; &#xA;&lt;h4&gt;Timer ACK [default]&lt;/h4&gt; &#xA;&lt;p&gt;By default, Einhorn will use a timer ACK of 1 second. That means that if your process hasn&#39;t exited after 1 second, it is considered ACK&#39;d and healthy. You can modify this timeout to be more appropriate for your application (and even set to 0 if desired). Just pass a &lt;code&gt;-m FLOAT&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Preloading&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re running a Ruby process, Einhorn can optionally preload its code, so it only has to load the code once per upgrade rather than once per worker process. This also saves on memory overhead, since all of the code in these processes will be stored only once using your operating system&#39;s copy-on-write features.&lt;/p&gt; &#xA;&lt;p&gt;To use preloading, just give Einhorn a &lt;code&gt;-p PATH_TO_CODE&lt;/code&gt;, and make sure you&#39;ve defined an &lt;code&gt;einhorn_main&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;In order to maximize compatibility, we&#39;ve worked to minimize Einhorn&#39;s dependencies. It has no dependencies outside of the Ruby standard library.&lt;/p&gt; &#xA;&lt;h3&gt;Command name&lt;/h3&gt; &#xA;&lt;p&gt;You can set the name that Einhorn and your workers show in PS. Just pass &lt;code&gt;-c &amp;lt;name&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Re exec&lt;/h3&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;--reexec-as&lt;/code&gt; option to replace the &lt;code&gt;einhorn&lt;/code&gt; command with a command or script of your own. This might be useful for those with a Capistrano like deploy process that has changing symlinks. To ensure that you are following the symlinks you could use a bash script like this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;&#xA;cd &amp;lt;symlinked directory&amp;gt;&#xA;exec /usr/local/bin/einhorn &#34;$@&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you could set &lt;code&gt;--reexec-as=&lt;/code&gt; to the name of your bash script and it will run in place of the plain einhorn command.&lt;/p&gt; &#xA;&lt;h3&gt;Options&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;-b, --bind ADDR                  Bind an address and add the corresponding FD via the environment&#xA;-c, --command-name CMD_NAME      Set the command name in ps to this value&#xA;-d, --socket-path PATH           Where to open the Einhorn command socket&#xA;-e, --pidfile PIDFILE            Where to write out the Einhorn pidfile&#xA;-f, --lockfile LOCKFILE          Where to store the Einhorn lockfile&#xA;-g, --command-socket-as-fd       Leave the command socket open as a file descriptor, passed in the EINHORN_SOCK_FD environment variable. This allows your worker processes to ACK without needing to know where on the filesystem the command socket lives.&#xA;-h, --help                       Display this message&#xA;-k, --kill-children-on-exit      If Einhorn exits unexpectedly, gracefully kill all its children&#xA;-l, --backlog N                  Connection backlog (assuming this is a server)&#xA;-m, --ack-mode MODE              What kinds of ACK to expect from workers. Choices: FLOAT (number of seconds until assumed alive), manual (process will speak to command socket when ready). Default is MODE=1.&#xA;-n, --number N                   Number of copies to spin up&#xA;-p, --preload PATH               Load this code into memory, and fork but do not exec upon spawn. Must define an &#34;einhorn_main&#34; method&#xA;-q, --quiet                      Make output quiet (can be reconfigured on the fly)&#xA;-s, --seconds N                  Number of seconds to wait until respawning&#xA;-v, --verbose                    Make output verbose (can be reconfigured on the fly)&#xA;    --drop-env-var VAR_NAME      Delete VAR_NAME from the environment that is restored on upgrade&#xA;    --reexec-as=CMDLINE          Substitute CMDLINE for \&#34;einhorn\&#34; when upgrading&#xA;    --nice MASTER[:WORKER=0][:RENICE_CMD=/usr/bin/renice]&#xA;                                 Unix nice level at which to run the einhorn processes. If not running as root, make sure to ulimit -e as appopriate.&#xA;    --with-state-fd STATE        [Internal option] With file descriptor containing state&#xA;    --upgrade-check              [Internal option] Check if Einhorn can exec itself and exit with status 0 before loading code&#xA;-t, --signal-timeout=T           If children do not react to signals after T seconds, escalate to SIGKILL&#xA;    --version                    Show version&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;p&gt;Einhorn came about when Stripe was investigating seamless code upgrading solutions for our API worker processes. We really liked the process model of &lt;a href=&#34;http://unicorn.bogomips.org/&#34;&gt;Unicorn&lt;/a&gt;, but didn&#39;t want to use its HTTP functionality. So Einhorn was born, providing the master process functionality of Unicorn (and similar preforking servers) to a wider array of applications.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://stripe.com/blog/meet-einhorn&#34;&gt;https://stripe.com/blog/meet-einhorn&lt;/a&gt; for more background.&lt;/p&gt; &#xA;&lt;p&gt;Stripe currently uses Einhorn in production for a number of services. You can use Conrad Irwin&#39;s thin-attach_socket gem along with EventMachine-LE to support file-descriptor passing. Check out &lt;code&gt;example/thin_example&lt;/code&gt; for an example of running Thin under Einhorn.&lt;/p&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;Einhorn runs in Ruby 2.5+.&lt;/p&gt; &#xA;&lt;p&gt;The following libraries ease integration with Einhorn with languages other than Ruby:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/stripe/go-einhorn&#34;&gt;go-einhorn&lt;/a&gt;&lt;/strong&gt;: Stripe&#39;s own library for &lt;em&gt;talking&lt;/em&gt; to an einhorn master (doesn&#39;t wrap socket code).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/zenazn/goji/&#34;&gt;goji&lt;/a&gt;&lt;/strong&gt;: Go (golang) server framework. The &lt;a href=&#34;https://godoc.org/github.com/zenazn/goji/bind&#34;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://godoc.org/github.com/zenazn/goji/graceful&#34;&gt;&lt;code&gt;graceful&lt;/code&gt;&lt;/a&gt; packages provide helpers and HTTP/TCP connection wrappers for Einhorn integration.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/CHH/einhorn&#34;&gt;github.com/CHH/einhorn&lt;/a&gt;&lt;/strong&gt;: PHP library&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/ConradIrwin/thin-attach_socket&#34;&gt;thin-attach_socket&lt;/a&gt;&lt;/strong&gt;: run &lt;code&gt;thin&lt;/code&gt; behind Einhorn&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://reddit.github.io/baseplate/cli/serve.html&#34;&gt;baseplate&lt;/a&gt;&lt;/strong&gt;: a collection of Python helpers and libraries, with support for running behind Einhorn&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;NB: this list should not imply any official endorsement or vetting!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;Einhorn was a project of &lt;a href=&#34;https://stripe.com&#34;&gt;Stripe&lt;/a&gt;. It is now maintained by &lt;a href=&#34;https://contribsys.com&#34;&gt;Contributed Systems&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>aasm/aasm</title>
    <updated>2022-07-24T01:33:24Z</updated>
    <id>tag:github.com,2022-07-24:/aasm/aasm</id>
    <link href="https://github.com/aasm/aasm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;AASM - State machines for Ruby classes (plain Ruby, ActiveRecord, Mongoid, NoBrainer, Dynamoid)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;AASM - Ruby state machines&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://badge.fury.io/rb/aasm&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/aasm.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/aasm/aasm&#34;&gt;&lt;img src=&#34;https://travis-ci.org/aasm/aasm.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/aasm/aasm&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/aasm/aasm/badges/gpa.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/aasm/aasm&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/aasm/aasm/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Index&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#upgrade-from-version-3-to-4&#34;&gt;Upgrade from version 3 to 4&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#callbacks&#34;&gt;Callbacks&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#lifecycle&#34;&gt;Lifecycle&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#the-current-event-triggered&#34;&gt;The current event triggered&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#guards&#34;&gt;Guards&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#transitions&#34;&gt;Transitions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#multiple-state-machines-per-class&#34;&gt;Multiple state machines per class&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#handling-naming-conflicts-between-multiple-state-machines&#34;&gt;Handling naming conflicts between multiple state machines&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#binding-event&#34;&gt;Binding event&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#auto-generated-status-constants&#34;&gt;Auto-generated Status Constants&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#extending-aasm&#34;&gt;Extending AASM&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#activerecord&#34;&gt;ActiveRecord&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#bang-events&#34;&gt;Bang events&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#timestamps&#34;&gt;Timestamps&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#activerecord-enums&#34;&gt;ActiveRecord enums&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#sequel&#34;&gt;Sequel&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#dynamoid&#34;&gt;Dynamoid&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#mongoid&#34;&gt;Mongoid&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#nobrainer&#34;&gt;Nobrainer&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#redis&#34;&gt;Redis&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#automatic-scopes&#34;&gt;Automatic Scopes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#transaction-support&#34;&gt;Transaction support&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#pessimistic-locking&#34;&gt;Pessimistic Locking&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#column-name--migration&#34;&gt;Column name &amp;amp; migration&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#log-state-changes&#34;&gt;Log State Changes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#inspection&#34;&gt;Inspection&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#warning-output&#34;&gt;Warning output&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#rubymotion-support&#34;&gt;RubyMotion support&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#testing&#34;&gt;Testing&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#rspec&#34;&gt;RSpec&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#minitest&#34;&gt;Minitest&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#assertions&#34;&gt;Assertions&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#expectations&#34;&gt;Expectations&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#manually-from-rubygemsorg&#34;&gt;Manually from RubyGems.org&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#or-if-you-are-using-bundler&#34;&gt;Bundler&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#building-your-own-gems&#34;&gt;Building your own gems&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#generators&#34;&gt;Generators&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#docker&#34;&gt;Test suite with Docker&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#latest-changes&#34;&gt;Latest changes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#questions&#34;&gt;Questions?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#maintainers&#34;&gt;Maintainers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/CONTRIBUTING.md&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#warranty&#34;&gt;Warranty&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This package contains AASM, a library for adding finite state machines to Ruby classes.&lt;/p&gt; &#xA;&lt;p&gt;AASM started as the &lt;em&gt;acts_as_state_machine&lt;/em&gt; plugin but has evolved into a more generic library that no longer targets only ActiveRecord models. It currently provides adapters for many ORMs but it can be used for any Ruby class, no matter what parent class it has (if any).&lt;/p&gt; &#xA;&lt;h2&gt;Upgrade from version 3 to 4&lt;/h2&gt; &#xA;&lt;p&gt;Take a look at the &lt;a href=&#34;https://github.com/aasm/aasm/raw/master/README_FROM_VERSION_3_TO_4.md&#34;&gt;README_FROM_VERSION_3_TO_4&lt;/a&gt; for details how to switch from version 3.x to 4.0 of &lt;em&gt;AASM&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Adding a state machine is as simple as including the AASM module and start defining &lt;strong&gt;states&lt;/strong&gt; and &lt;strong&gt;events&lt;/strong&gt; together with their &lt;strong&gt;transitions&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job&#xA;  include AASM&#xA;&#xA;  aasm do&#xA;    state :sleeping, initial: true&#xA;    state :running, :cleaning&#xA;&#xA;    event :run do&#xA;      transitions from: :sleeping, to: :running&#xA;    end&#xA;&#xA;    event :clean do&#xA;      transitions from: :running, to: :cleaning&#xA;    end&#xA;&#xA;    event :sleep do&#xA;      transitions from: [:running, :cleaning], to: :sleeping&#xA;    end&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This provides you with a couple of public methods for instances of the class &lt;code&gt;Job&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;job = Job.new&#xA;job.sleeping? # =&amp;gt; true&#xA;job.may_run?  # =&amp;gt; true&#xA;job.run&#xA;job.running?  # =&amp;gt; true&#xA;job.sleeping? # =&amp;gt; false&#xA;job.may_run?  # =&amp;gt; false&#xA;job.run       # =&amp;gt; raises AASM::InvalidTransition&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t like exceptions and prefer a simple &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; as response, tell AASM not to be &lt;em&gt;whiny&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job&#xA;  ...&#xA;  aasm whiny_transitions: false do&#xA;    ...&#xA;  end&#xA;end&#xA;&#xA;job.running?  # =&amp;gt; true&#xA;job.may_run?  # =&amp;gt; false&#xA;job.run       # =&amp;gt; false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When firing an event, you can pass a block to the method, it will be called only if the transition succeeds :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  job.run do&#xA;    job.user.notify_job_ran # Will be called if job.may_run? is true&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Callbacks&lt;/h3&gt; &#xA;&lt;p&gt;You can define a number of callbacks for your events, transitions and states. These methods, Procs or classes will be called when certain criteria are met, like entering a particular state:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job&#xA;  include AASM&#xA;&#xA;  aasm do&#xA;    state :sleeping, initial: true, before_enter: :do_something&#xA;    state :running, before_enter: Proc.new { do_something &amp;amp;&amp;amp; notify_somebody }&#xA;    state :finished&#xA;&#xA;    after_all_transitions :log_status_change&#xA;&#xA;    event :run, after: :notify_somebody do&#xA;      before do&#xA;        log(&#39;Preparing to run&#39;)&#xA;      end&#xA;&#xA;      transitions from: :sleeping, to: :running, after: Proc.new {|*args| set_process(*args) }&#xA;      transitions from: :running, to: :finished, after: LogRunTime&#xA;    end&#xA;&#xA;    event :sleep do&#xA;      after do&#xA;        ...&#xA;      end&#xA;      error do |e|&#xA;        ...&#xA;      end&#xA;      transitions from: :running, to: :sleeping&#xA;    end&#xA;  end&#xA;&#xA;  def log_status_change&#xA;    puts &#34;changing from #{aasm.from_state} to #{aasm.to_state} (event: #{aasm.current_event})&#34;&#xA;  end&#xA;&#xA;  def set_process(name)&#xA;    ...&#xA;  end&#xA;&#xA;  def do_something&#xA;    ...&#xA;  end&#xA;&#xA;  def notify_somebody&#xA;    ...&#xA;  end&#xA;&#xA;end&#xA;&#xA;class LogRunTime&#xA;  def call&#xA;    log &#34;Job was running for X seconds&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case &lt;code&gt;do_something&lt;/code&gt; is called before actually entering the state &lt;code&gt;sleeping&lt;/code&gt;, while &lt;code&gt;notify_somebody&lt;/code&gt; is called after the transition &lt;code&gt;run&lt;/code&gt; (from &lt;code&gt;sleeping&lt;/code&gt; to &lt;code&gt;running&lt;/code&gt;) is finished.&lt;/p&gt; &#xA;&lt;p&gt;AASM will also initialize &lt;code&gt;LogRunTime&lt;/code&gt; and run the &lt;code&gt;call&lt;/code&gt; method for you after the transition from &lt;code&gt;running&lt;/code&gt; to &lt;code&gt;finished&lt;/code&gt; in the example above. You can pass arguments to the class by defining an initialize method on it, like this:&lt;/p&gt; &#xA;&lt;p&gt;Note that Procs are executed in the context of a record, it means that you don&#39;t need to expect the record as an argument, just call the methods you need.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class LogRunTime&#xA;  # optional args parameter can be omitted, but if you define initialize&#xA;  # you must accept the model instance as the first parameter to it.&#xA;  def initialize(job, args = {})&#xA;    @job = job&#xA;  end&#xA;&#xA;  def call&#xA;    log &#34;Job was running for #{@job.run_time} seconds&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Parameters&lt;/h4&gt; &#xA;&lt;p&gt;You can pass parameters to events:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  job = Job.new&#xA;  job.run(:defragmentation)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All guards and after callbacks will receive these parameters. In this case &lt;code&gt;set_process&lt;/code&gt; would be called with &lt;code&gt;:defragmentation&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;p&gt;If the first argument to the event is a state (e.g. &lt;code&gt;:running&lt;/code&gt; or &lt;code&gt;:finished&lt;/code&gt;), the first argument is consumed and the state machine will attempt to transition to that state. Add comma separated parameter for guards and callbacks&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  job = Job.new&#xA;  job.run(:running, :defragmentation)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case &lt;code&gt;set_process&lt;/code&gt; won&#39;t be called, job will transition to running state and callback will receive &lt;code&gt;:defragmentation&lt;/code&gt; as parameter&lt;/p&gt; &#xA;&lt;h4&gt;Error Handling&lt;/h4&gt; &#xA;&lt;p&gt;In case of an error during the event processing the error is rescued and passed to &lt;code&gt;:error&lt;/code&gt; callback, which can handle it or re-raise it for further propagation.&lt;/p&gt; &#xA;&lt;p&gt;Also, you can define a method that will be called if any event fails:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def aasm_event_failed(event_name, old_state_name)&#xA;  # use custom exception/messages, report metrics, etc&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;During the transition&#39;s &lt;code&gt;:after&lt;/code&gt; callback (and reliably only then, or in the global &lt;code&gt;after_all_transitions&lt;/code&gt; callback) you can access the originating state (the from-state) and the target state (the to state), like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def set_process(name)&#xA;    logger.info &#34;from #{aasm.from_state} to #{aasm.to_state}&#34;&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Lifecycle&lt;/h4&gt; &#xA;&lt;p&gt;Here you can see a list of all possible callbacks, together with their order of calling:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;begin&#xA;  event           before_all_events&#xA;  event           before&#xA;  event           guards&#xA;  transition      guards&#xA;  old_state       before_exit&#xA;  old_state       exit&#xA;                  after_all_transitions&#xA;  transition      after&#xA;  new_state       before_enter&#xA;  new_state       enter&#xA;  ...update state...&#xA;  event           before_success      # if persist successful&#xA;  transition      success             # if persist successful, database update not guaranteed&#xA;  event           success             # if persist successful, database update not guaranteed&#xA;  old_state       after_exit&#xA;  new_state       after_enter&#xA;  event           after&#xA;  event           after_all_events&#xA;rescue&#xA;  event           error&#xA;  event           error_on_all_events&#xA;ensure&#xA;  event           ensure&#xA;  event           ensure_on_all_events&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use event&#39;s &lt;code&gt;after_commit&lt;/code&gt; callback if it should be fired after database update.&lt;/p&gt; &#xA;&lt;h4&gt;The current event triggered&lt;/h4&gt; &#xA;&lt;p&gt;While running the callbacks you can easily retrieve the name of the event triggered by using &lt;code&gt;aasm.current_event&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  # taken the example callback from above&#xA;  def do_something&#xA;    puts &#34;triggered #{aasm.current_event}&#34;&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and then&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  job = Job.new&#xA;&#xA;  # without bang&#xA;  job.sleep # =&amp;gt; triggered :sleep&#xA;&#xA;  # with bang&#xA;  job.sleep! # =&amp;gt; triggered :sleep!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Guards&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s assume you want to allow particular transitions only if a defined condition is given. For this you can set up a guard per transition, which will run before actually running the transition. If the guard returns &lt;code&gt;false&lt;/code&gt; the transition will be denied (raising &lt;code&gt;AASM::InvalidTransition&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Cleaner&#xA;  include AASM&#xA;&#xA;  aasm do&#xA;    state :idle, initial: true&#xA;    state :cleaning&#xA;&#xA;    event :clean do&#xA;      transitions from: :idle, to: :cleaning, guard: :cleaning_needed?&#xA;    end&#xA;&#xA;    event :clean_if_needed do&#xA;      transitions from: :idle, to: :cleaning do&#xA;        guard do&#xA;          cleaning_needed?&#xA;        end&#xA;      end&#xA;      transitions from: :idle, to: :idle&#xA;    end&#xA;&#xA;    event :clean_if_dirty do&#xA;      transitions from: :idle, to: :cleaning, guard: :if_dirty?&#xA;    end&#xA;  end&#xA;&#xA;  def cleaning_needed?&#xA;    false&#xA;  end&#xA;&#xA;  def if_dirty?(status)&#xA;    status == :dirty&#xA;  end&#xA;end&#xA;&#xA;job = Cleaner.new&#xA;job.may_clean?            # =&amp;gt; false&#xA;job.clean                 # =&amp;gt; raises AASM::InvalidTransition&#xA;job.may_clean_if_needed?  # =&amp;gt; true&#xA;job.clean_if_needed!      # idle&#xA;&#xA;job.clean_if_dirty(:clean) # =&amp;gt; raises AASM::InvalidTransition&#xA;job.clean_if_dirty(:dirty) # =&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can even provide a number of guards, which all have to succeed to proceed&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    def walked_the_dog?; ...; end&#xA;&#xA;    event :sleep do&#xA;      transitions from: :running, to: :sleeping, guards: [:cleaning_needed?, :walked_the_dog?]&#xA;    end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to provide guards for all transitions within an event, you can use event guards&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    event :sleep, guards: [:walked_the_dog?] do&#xA;      transitions from: :running, to: :sleeping, guards: [:cleaning_needed?]&#xA;      transitions from: :cleaning, to: :sleeping&#xA;    end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you prefer a more Ruby-like guard syntax, you can use &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt; as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    event :clean do&#xA;      transitions from: :running, to: :cleaning, if: :cleaning_needed?&#xA;    end&#xA;&#xA;    event :sleep do&#xA;      transitions from: :running, to: :sleeping, unless: :cleaning_needed?&#xA;    end&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can invoke a Class instead of a method if the Class responds to &lt;code&gt;call&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    event :sleep do&#xA;      transitions from: :running, to: :sleeping, guards: Dog&#xA;    end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  class Dog&#xA;    def call&#xA;      cleaning_needed? &amp;amp;&amp;amp; walked?&#xA;    end&#xA;    ...&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Transitions&lt;/h3&gt; &#xA;&lt;p&gt;In the event of having multiple transitions for an event, the first transition that successfully completes will stop other transitions in the same event from being processed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;aasm&#39;&#xA;&#xA;class Job&#xA;  include AASM&#xA;&#xA;  aasm do&#xA;    state :stage1, initial: true&#xA;    state :stage2&#xA;    state :stage3&#xA;    state :completed&#xA;&#xA;    event :stage1_completed do&#xA;      transitions from: :stage1, to: :stage3, guard: :stage2_completed?&#xA;      transitions from: :stage1, to: :stage2&#xA;    end&#xA;  end&#xA;&#xA;  def stage2_completed?&#xA;    true&#xA;  end&#xA;end&#xA;&#xA;job = Job.new&#xA;job.stage1_completed&#xA;job.aasm.current_state # stage3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can define transition from any defined state by omitting &lt;code&gt;from&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;event :abort do&#xA;  transitions to: :aborted&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Display name for state&lt;/h3&gt; &#xA;&lt;p&gt;You can define display name for state using :display option&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job&#xA;  include AASM&#xA;&#xA;  aasm do&#xA;    state :stage1, initial: true, display: &#39;First Stage&#39;&#xA;    state :stage2&#xA;    state :stage3&#xA;  end&#xA;end&#xA;&#xA;job = Job.new&#xA;job.aasm.human_state&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiple state machines per class&lt;/h3&gt; &#xA;&lt;p&gt;Multiple state machines per class are supported. Be aware though that &lt;em&gt;AASM&lt;/em&gt; has been built with one state machine per class in mind. Nonetheless, here&#39;s how to do it (see below). Please note that you will need to specify database columns for where your pertinent states will be stored - we have specified two columns &lt;code&gt;move_state&lt;/code&gt; and &lt;code&gt;work_state&lt;/code&gt; in the example below. See the &lt;a href=&#34;https://github.com/aasm/aasm#column-name--migration&#34;&gt;Column name &amp;amp; migration&lt;/a&gt; section for further info.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SimpleMultipleExample&#xA;  include AASM&#xA;  aasm(:move, column: &#39;move_state&#39;) do&#xA;    state :standing, initial: true&#xA;    state :walking&#xA;    state :running&#xA;&#xA;    event :walk do&#xA;      transitions from: :standing, to: :walking&#xA;    end&#xA;    event :run do&#xA;      transitions from: [:standing, :walking], to: :running&#xA;    end&#xA;    event :hold do&#xA;      transitions from: [:walking, :running], to: :standing&#xA;    end&#xA;  end&#xA;&#xA;  aasm(:work, column: &#39;work_state&#39;) do&#xA;    state :sleeping, initial: true&#xA;    state :processing&#xA;&#xA;    event :start do&#xA;      transitions from: :sleeping, to: :processing&#xA;    end&#xA;    event :stop do&#xA;      transitions from: :processing, to: :sleeping&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;simple = SimpleMultipleExample.new&#xA;&#xA;simple.aasm(:move).current_state&#xA;# =&amp;gt; :standing&#xA;simple.aasm(:work).current_state&#xA;# =&amp;gt; :sleeping&#xA;&#xA;simple.start&#xA;simple.aasm(:move).current_state&#xA;# =&amp;gt; :standing&#xA;simple.aasm(:work).current_state&#xA;# =&amp;gt; :processing&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Handling naming conflicts between multiple state machines&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;AASM&lt;/em&gt; doesn&#39;t prohibit to define the same event in more than one state machine. If no namespace is provided, the latest definition &#34;wins&#34; and overrides previous definitions. Nonetheless, a warning is issued: &lt;code&gt;SimpleMultipleExample: overriding method &#39;run&#39;!&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can provide a namespace for each state machine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NamespacedMultipleExample&#xA;  include AASM&#xA;  aasm(:status) do&#xA;    state :unapproved, initial: true&#xA;    state :approved&#xA;&#xA;    event :approve do&#xA;      transitions from: :unapproved, to: :approved&#xA;    end&#xA;&#xA;    event :unapprove do&#xA;      transitions from: :approved, to: :unapproved&#xA;    end&#xA;  end&#xA;&#xA;  aasm(:review_status, namespace: :review) do&#xA;    state :unapproved, initial: true&#xA;    state :approved&#xA;&#xA;    event :approve do&#xA;      transitions from: :unapproved, to: :approved&#xA;    end&#xA;&#xA;    event :unapprove do&#xA;      transitions from: :approved, to: :unapproved&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;namespaced = NamespacedMultipleExample.new&#xA;&#xA;namespaced.aasm(:status).current_state&#xA;# =&amp;gt; :unapproved&#xA;namespaced.aasm(:review_status).current_state&#xA;# =&amp;gt; :unapproved&#xA;namespaced.approve_review&#xA;namespaced.aasm(:review_status).current_state&#xA;# =&amp;gt; :approved&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All &lt;em&gt;AASM&lt;/em&gt; class- and instance-level &lt;code&gt;aasm&lt;/code&gt; methods accept a state machine selector. So, for example, to use inspection on a class level, you have to use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SimpleMultipleExample.aasm(:move).states.map(&amp;amp;:name)&#xA;# =&amp;gt; [:standing, :walking, :running]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Binding event&lt;/h3&gt; &#xA;&lt;p&gt;Allow an event to be bound to another&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Example&#xA;  include AASM&#xA;&#xA;  aasm(:work) do&#xA;    state :sleeping, initial: true&#xA;    state :processing&#xA;&#xA;    event :start do&#xA;      transitions from: :sleeping, to: :processing&#xA;    end&#xA;    event :stop do&#xA;      transitions from: :processing, to: :sleeping&#xA;    end&#xA;  end&#xA;&#xA;  aasm(:question) do&#xA;    state :answered, initial: true&#xA;    state :asked&#xA;&#xA;    event :ask, binding_event: :start do&#xA;      transitions from: :answered, to: :asked&#xA;    end&#xA;    event :answer, binding_event: :stop do&#xA;      transitions from: :asked, to: :answered&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;example = Example.new&#xA;example.aasm(:work).current_state #=&amp;gt; :sleeping&#xA;example.aasm(:question).current_state #=&amp;gt; :answered&#xA;example.ask&#xA;example.aasm(:work).current_state #=&amp;gt; :processing&#xA;example.aasm(:question).current_state #=&amp;gt; :asked&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Auto-generated Status Constants&lt;/h3&gt; &#xA;&lt;p&gt;AASM automatically &lt;a href=&#34;https://github.com/aasm/aasm/pull/60&#34;&gt;generates constants&lt;/a&gt; for each status so you don&#39;t have to explicitly define them.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Foo&#xA;  include AASM&#xA;&#xA;  aasm do&#xA;    state :initialized&#xA;    state :calculated&#xA;    state :finalized&#xA;  end&#xA;end&#xA;&#xA;&amp;gt; Foo::STATE_INITIALIZED&#xA;#=&amp;gt; :initialized&#xA;&amp;gt; Foo::STATE_CALCULATED&#xA;#=&amp;gt; :calculated&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Extending AASM&lt;/h3&gt; &#xA;&lt;p&gt;AASM allows you to easily extend &lt;code&gt;AASM::Base&lt;/code&gt; for your own application purposes.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s suppose we have common logic across many AASM models. We can embody this logic in a sub-class of &lt;code&gt;AASM::Base&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class CustomAASMBase &amp;lt; AASM::Base&#xA;  # A custom transiton that we want available across many AASM models.&#xA;  def count_transitions!&#xA;    klass.class_eval do&#xA;      aasm with_klass: CustomAASMBase do&#xA;        after_all_transitions :increment_transition_count&#xA;      end&#xA;    end&#xA;  end&#xA;&#xA;  # A custom annotation that we want available across many AASM models.&#xA;  def requires_guards!&#xA;    klass.class_eval do&#xA;      attr_reader :authorizable_called,&#xA;        :transition_count,&#xA;        :fillable_called&#xA;&#xA;      def authorizable?&#xA;        @authorizable_called = true&#xA;      end&#xA;&#xA;      def fillable?&#xA;        @fillable_called = true&#xA;      end&#xA;&#xA;      def increment_transition_count&#xA;        @transition_count ||= 0&#xA;        @transition_count += 1&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When we declare our model that has an AASM state machine, we simply declare the AASM block with a &lt;code&gt;:with_klass&lt;/code&gt; key to our own class.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SimpleCustomExample&#xA;  include AASM&#xA;&#xA;  # Let&#39;s build an AASM state machine with our custom class.&#xA;  aasm with_klass: CustomAASMBase do&#xA;    requires_guards!&#xA;    count_transitions!&#xA;&#xA;    state :initialised, initial: true&#xA;    state :filled_out&#xA;    state :authorised&#xA;&#xA;    event :fill_out do&#xA;      transitions from: :initialised, to: :filled_out, guard: :fillable?&#xA;    end&#xA;    event :authorise do&#xA;      transitions from: :filled_out, to: :authorised, guard: :authorizable?&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ActiveRecord&lt;/h3&gt; &#xA;&lt;p&gt;AASM comes with support for ActiveRecord and allows automatic persisting of the object&#39;s state in the database.&lt;/p&gt; &#xA;&lt;p&gt;Add &lt;code&gt;gem &#39;after_commit_everywhere&#39;, &#39;~&amp;gt; 1.0&#39;&lt;/code&gt; to your Gemfile.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; ActiveRecord::Base&#xA;  include AASM&#xA;&#xA;  aasm do # default column: aasm_state&#xA;    state :sleeping, initial: true&#xA;    state :running&#xA;&#xA;    event :run do&#xA;      transitions from: :sleeping, to: :running&#xA;    end&#xA;&#xA;    event :sleep do&#xA;      transitions from: :running, to: :sleeping&#xA;    end&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Bang events&lt;/h3&gt; &#xA;&lt;p&gt;You can tell AASM to auto-save the object or leave it unsaved&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;job = Job.new&#xA;job.run   # not saved&#xA;job.run!  # saved&#xA;&#xA;# or&#xA;job.aasm.fire(:run) # not saved&#xA;job.aasm.fire!(:run) # saved&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Saving includes running all validations on the &lt;code&gt;Job&lt;/code&gt; class. If &lt;code&gt;whiny_persistence&lt;/code&gt; flag is set to &lt;code&gt;true&lt;/code&gt;, exception is raised in case of failure. If &lt;code&gt;whiny_persistence&lt;/code&gt; flag is set to &lt;code&gt;false&lt;/code&gt;, methods with a bang return &lt;code&gt;true&lt;/code&gt; if the state transition is successful or &lt;code&gt;false&lt;/code&gt; if an error occurs.&lt;/p&gt; &#xA;&lt;p&gt;If you want make sure the state gets saved without running validations (and thereby maybe persisting an invalid object state), simply tell AASM to skip the validations. Be aware that when skipping validations, only the state column will be updated in the database (just like ActiveRecord &lt;code&gt;update_column&lt;/code&gt; is working).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; ActiveRecord::Base&#xA;  include AASM&#xA;&#xA;  aasm skip_validation_on_save: true do&#xA;    state :sleeping, initial: true&#xA;    state :running&#xA;&#xA;    event :run do&#xA;      transitions from: :sleeping, to: :running&#xA;    end&#xA;&#xA;    event :sleep do&#xA;      transitions from: :running, to: :sleeping&#xA;    end&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, you can skip the validation at instance level with &lt;code&gt;some_event_name_without_validation!&lt;/code&gt; method. With this you have the flexibility of having validation for all your transitions by default and then skip it wherever required. Please note that only state column will be updated as mentioned in the above example.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;job.run_without_validation!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to make sure that the &lt;em&gt;AASM&lt;/em&gt; column for storing the state is not directly assigned, configure &lt;em&gt;AASM&lt;/em&gt; to not allow direct assignment, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; ActiveRecord::Base&#xA;  include AASM&#xA;&#xA;  aasm no_direct_assignment: true do&#xA;    state :sleeping, initial: true&#xA;    state :running&#xA;&#xA;    event :run do&#xA;      transitions from: :sleeping, to: :running&#xA;    end&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;resulting in this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;job = Job.create&#xA;job.aasm_state # =&amp;gt; &#39;sleeping&#39;&#xA;job.aasm_state = :running # =&amp;gt; raises AASM::NoDirectAssignmentError&#xA;job.aasm_state # =&amp;gt; &#39;sleeping&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Timestamps&lt;/h3&gt; &#xA;&lt;p&gt;You can tell &lt;em&gt;AASM&lt;/em&gt; to try to write a timestamp whenever a new state is entered. If &lt;code&gt;timestamps: true&lt;/code&gt; is set, &lt;em&gt;AASM&lt;/em&gt; will look for a field named like the new state plus &lt;code&gt;_at&lt;/code&gt; and try to fill it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; ActiveRecord::Base&#xA;  include AASM&#xA;&#xA;  aasm timestamps: true do&#xA;    state :sleeping, initial: true&#xA;    state :running&#xA;&#xA;    event :run do&#xA;      transitions from: :sleeping, to: :running&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;resulting in this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;job = Job.create&#xA;job.running_at # =&amp;gt; nil&#xA;job.run!&#xA;job.running_at # =&amp;gt; 2020-02-20 20:00:00&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Missing timestamp fields are silently ignored, so it is not necessary to have setters (such as ActiveRecord columns) for &lt;em&gt;all&lt;/em&gt; states when using this option.&lt;/p&gt; &#xA;&lt;h4&gt;ActiveRecord enums&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;a href=&#34;http://edgeapi.rubyonrails.org/classes/ActiveRecord/Enum.html&#34;&gt;enumerations&lt;/a&gt; in Rails 4.1+ for your state column:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; ActiveRecord::Base&#xA;  include AASM&#xA;&#xA;  enum state: {&#xA;    sleeping: 5,&#xA;    running: 99&#xA;  }&#xA;&#xA;  aasm column: :state, enum: true do&#xA;    state :sleeping, initial: true&#xA;    state :running&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can explicitly pass the name of the method which provides access to the enumeration mapping as a value of &lt;code&gt;enum&lt;/code&gt;, or you can simply set it to &lt;code&gt;true&lt;/code&gt;. In the latter case AASM will try to use pluralized column name to access possible enum states.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore, if your column has integer type (which is normally the case when you&#39;re working with Rails enums), you can omit &lt;code&gt;:enum&lt;/code&gt; setting --- AASM auto-detects this situation and enabled enum support. If anything goes wrong, you can disable enum functionality and fall back to the default behavior by setting &lt;code&gt;:enum&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Sequel&lt;/h3&gt; &#xA;&lt;p&gt;AASM also supports &lt;a href=&#34;http://sequel.jeremyevans.net/&#34;&gt;Sequel&lt;/a&gt; besides &lt;em&gt;ActiveRecord&lt;/em&gt;, and &lt;em&gt;Mongoid&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; Sequel::Model&#xA;  include AASM&#xA;&#xA;  aasm do # default column: aasm_state&#xA;    ...&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However it&#39;s not yet as feature complete as &lt;em&gt;ActiveRecord&lt;/em&gt;. For example, there are scopes defined yet. See &lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/#automatic-scopes&#34;&gt;Automatic Scopes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Dynamoid&lt;/h3&gt; &#xA;&lt;p&gt;Since version &lt;code&gt;4.8.0&lt;/code&gt; &lt;em&gt;AASM&lt;/em&gt; also supports &lt;a href=&#34;http://joshsymonds.com/Dynamoid/&#34;&gt;Dynamoid&lt;/a&gt; as persistence ORM.&lt;/p&gt; &#xA;&lt;h3&gt;Mongoid&lt;/h3&gt; &#xA;&lt;p&gt;AASM also supports persistence to Mongodb if you&#39;re using Mongoid. Make sure to include Mongoid::Document before you include AASM.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job&#xA;  include Mongoid::Document&#xA;  include AASM&#xA;  field :aasm_state&#xA;  aasm do&#xA;    ...&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;NoBrainer&lt;/h3&gt; &#xA;&lt;p&gt;AASM also supports persistence to &lt;a href=&#34;https://www.rethinkdb.com/&#34;&gt;RethinkDB&lt;/a&gt; if you&#39;re using &lt;a href=&#34;http://nobrainer.io/&#34;&gt;Nobrainer&lt;/a&gt;. Make sure to include NoBrainer::Document before you include AASM.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job&#xA;  include NoBrainer::Document&#xA;  include AASM&#xA;  field :aasm_state&#xA;  aasm do&#xA;    ...&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Redis&lt;/h3&gt; &#xA;&lt;p&gt;AASM also supports persistence in Redis via &lt;a href=&#34;https://github.com/nateware/redis-objects&#34;&gt;Redis::Objects&lt;/a&gt;. Make sure to include Redis::Objects before you include AASM. Note that non-bang events will work as bang events, persisting the changes on every call.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User&#xA;  include Redis::Objects&#xA;  include AASM&#xA;&#xA;  aasm do&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Automatic Scopes&lt;/h3&gt; &#xA;&lt;p&gt;AASM will automatically create scope methods for each state in the model.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; ActiveRecord::Base&#xA;  include AASM&#xA;&#xA;  aasm do&#xA;    state :sleeping, initial: true&#xA;    state :running&#xA;    state :cleaning&#xA;  end&#xA;&#xA;  def self.sleeping&#xA;    &#34;This method name is already in use&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class JobsController &amp;lt; ApplicationController&#xA;  def index&#xA;    @running_jobs = Job.running&#xA;    @recent_cleaning_jobs = Job.cleaning.where(&#39;created_at &amp;gt;=  ?&#39;, 3.days.ago)&#xA;&#xA;    # @sleeping_jobs = Job.sleeping   #=&amp;gt; &#34;This method name is already in use&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t need scopes (or simply don&#39;t want them), disable their creation when defining the &lt;code&gt;AASM&lt;/code&gt; states, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; ActiveRecord::Base&#xA;  include AASM&#xA;&#xA;  aasm create_scopes: false do&#xA;    state :sleeping, initial: true&#xA;    state :running&#xA;    state :cleaning&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Transaction support&lt;/h3&gt; &#xA;&lt;p&gt;Since version &lt;em&gt;3.0.13&lt;/em&gt; AASM supports ActiveRecord transactions. So whenever a transition callback or the state update fails, all changes to any database record are rolled back. Mongodb does not support transactions.&lt;/p&gt; &#xA;&lt;p&gt;There are currently 3 transactional callbacks that can be handled on the event, and 2 transactional callbacks for all events.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  event           before_all_transactions&#xA;  event           before_transaction&#xA;  event           aasm_fire_event (within transaction)&#xA;  event           after_commit (if event successful)&#xA;  event           after_transaction&#xA;  event           after_all_transactions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to make sure a depending action happens only after the transaction is committed, use the &lt;code&gt;after_commit&lt;/code&gt; callback along with the auto-save (bang) methods, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; ActiveRecord::Base&#xA;  include AASM&#xA;&#xA;  aasm do&#xA;    state :sleeping, initial: true&#xA;    state :running&#xA;&#xA;    event :run, after_commit: :notify_about_running_job do&#xA;      transitions from: :sleeping, to: :running&#xA;    end&#xA;  end&#xA;&#xA;  def notify_about_running_job&#xA;    ...&#xA;  end&#xA;end&#xA;&#xA;job = Job.where(state: &#39;sleeping&#39;).first!&#xA;job.run! # Saves the model and triggers the after_commit callback&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the following will not run the &lt;code&gt;after_commit&lt;/code&gt; callbacks because the auto-save method is not used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;job = Job.where(state: &#39;sleeping&#39;).first!&#xA;job.run&#xA;job.save! #notify_about_running_job is not run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please note that &lt;code&gt;:after_commit&lt;/code&gt; AASM callbacks behaves around custom implementation of transaction pattern rather than a real-life DB transaction. This fact still causes the race conditions and redundant callback calls within nested transaction. In order to fix that it&#39;s highly recommended to add &lt;code&gt;gem &#39;after_commit_everywhere&#39;, &#39;~&amp;gt; 1.0&#39;&lt;/code&gt; to your &lt;code&gt;Gemfile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to encapsulate state changes within an own transaction, the behavior of this nested transaction might be confusing. Take a look at &lt;a href=&#34;http://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html&#34;&gt;ActiveRecord Nested Transactions&lt;/a&gt; if you want to know more about this. Nevertheless, AASM by default requires a new transaction &lt;code&gt;transaction(requires_new: true)&lt;/code&gt;. You can override this behavior by changing the configuration&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; ActiveRecord::Base&#xA;  include AASM&#xA;&#xA;  aasm requires_new_transaction: false do&#xA;    ...&#xA;  end&#xA;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which then leads to &lt;code&gt;transaction(requires_new: false)&lt;/code&gt;, the Rails default.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, if you do not want any of your ActiveRecord actions to be wrapped in a transaction, you can specify the &lt;code&gt;use_transactions&lt;/code&gt; flag. This can be useful if you want want to persist things to the database that happen as a result of a transaction or callback, even when some error occurs. The &lt;code&gt;use_transactions&lt;/code&gt; flag is true by default.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; ActiveRecord::Base&#xA;  include AASM&#xA;&#xA;  aasm use_transactions: false do&#xA;    ...&#xA;  end&#xA;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Pessimistic Locking&lt;/h3&gt; &#xA;&lt;p&gt;AASM supports &lt;a href=&#34;http://api.rubyonrails.org/classes/ActiveRecord/Locking/Pessimistic.html#method-i-with_lock&#34;&gt;ActiveRecord pessimistic locking via &lt;code&gt;with_lock&lt;/code&gt;&lt;/a&gt; for database persistence layers.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Option&lt;/th&gt; &#xA;   &lt;th&gt;Purpose&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt; (default)&lt;/td&gt; &#xA;   &lt;td&gt;No lock is obtained&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Obtain a blocking pessimistic lock e.g. &lt;code&gt;FOR UPDATE&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;String&lt;/td&gt; &#xA;   &lt;td&gt;Obtain a lock based on the SQL string e.g. &lt;code&gt;FOR UPDATE NOWAIT&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; ActiveRecord::Base&#xA;  include AASM&#xA;&#xA;  aasm requires_lock: true do&#xA;    ...&#xA;  end&#xA;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; ActiveRecord::Base&#xA;  include AASM&#xA;&#xA;  aasm requires_lock: &#39;FOR UPDATE NOWAIT&#39; do&#xA;    ...&#xA;  end&#xA;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Column name &amp;amp; migration&lt;/h3&gt; &#xA;&lt;p&gt;As a default AASM uses the column &lt;code&gt;aasm_state&lt;/code&gt; to store the states. You can override this by defining your favorite column name, using &lt;code&gt;:column&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job &amp;lt; ActiveRecord::Base&#xA;  include AASM&#xA;&#xA;  aasm column: :my_state do&#xA;    ...&#xA;  end&#xA;&#xA;  aasm :another_state_machine, column: :second_state do&#xA;    ...&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Whatever column name is used, make sure to add a migration to provide this column (of type &lt;code&gt;string&lt;/code&gt;). Do not add default value for column at the database level. If you add default value in database then AASM callbacks on the initial state will not be fired upon instantiation of the model.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AddJobState &amp;lt; ActiveRecord::Migration&#xA;  def self.up&#xA;    add_column :jobs, :aasm_state, :string&#xA;  end&#xA;&#xA;  def self.down&#xA;    remove_column :jobs, :aasm_state&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Log State Changes&lt;/h3&gt; &#xA;&lt;p&gt;Logging state change can be done using &lt;a href=&#34;https://github.com/paper-trail-gem/paper_trail&#34;&gt;paper_trail&lt;/a&gt; gem&lt;/p&gt; &#xA;&lt;p&gt;Example of implementation can be found here &lt;a href=&#34;https://github.com/nitsujri/aasm-papertrail-example&#34;&gt;https://github.com/nitsujri/aasm-papertrail-example&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Inspection&lt;/h3&gt; &#xA;&lt;p&gt;AASM supports query methods for states and events&lt;/p&gt; &#xA;&lt;p&gt;Given the following &lt;code&gt;Job&lt;/code&gt; class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job&#xA;  include AASM&#xA;&#xA;  aasm do&#xA;    state :sleeping, initial: true&#xA;    state :running, :cleaning&#xA;&#xA;    event :run do&#xA;      transitions from: :sleeping, to: :running&#xA;    end&#xA;&#xA;    event :clean do&#xA;      transitions from: :running, to: :cleaning, guard: :cleaning_needed?&#xA;    end&#xA;&#xA;    event :sleep do&#xA;      transitions from: [:running, :cleaning], to: :sleeping&#xA;    end&#xA;  end&#xA;&#xA;  def cleaning_needed?&#xA;    false&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# show all states&#xA;Job.aasm.states.map(&amp;amp;:name)&#xA;#=&amp;gt; [:sleeping, :running, :cleaning]&#xA;&#xA;job = Job.new&#xA;&#xA;# show all permitted states (from initial state)&#xA;job.aasm.states(permitted: true).map(&amp;amp;:name)&#xA;#=&amp;gt; [:running]&#xA;&#xA;# List all the permitted transitions(event and state pairs) from initial state&#xA;job.aasm.permitted_transitions&#xA;#=&amp;gt; [{ :event =&amp;gt; :run, :state =&amp;gt; :running }]&#xA;&#xA;job.run&#xA;job.aasm.states(permitted: true).map(&amp;amp;:name)&#xA;#=&amp;gt; [:sleeping]&#xA;&#xA;# show all non permitted states&#xA;job.aasm.states(permitted: false).map(&amp;amp;:name)&#xA;#=&amp;gt; [:cleaning]&#xA;&#xA;# show all possible (triggerable) events from the current state&#xA;job.aasm.events.map(&amp;amp;:name)&#xA;#=&amp;gt; [:clean, :sleep]&#xA;&#xA;# show all permitted events&#xA;job.aasm.events(permitted: true).map(&amp;amp;:name)&#xA;#=&amp;gt; [:sleep]&#xA;&#xA;# show all non permitted events&#xA;job.aasm.events(permitted: false).map(&amp;amp;:name)&#xA;#=&amp;gt; [:clean]&#xA;&#xA;# show all possible events except a specific one&#xA;job.aasm.events(reject: :sleep).map(&amp;amp;:name)&#xA;#=&amp;gt; [:clean]&#xA;&#xA;# list states for select&#xA;Job.aasm.states_for_select&#xA;#=&amp;gt; [[&#34;Sleeping&#34;, &#34;sleeping&#34;], [&#34;Running&#34;, &#34;running&#34;], [&#34;Cleaning&#34;, &#34;cleaning&#34;]]&#xA;&#xA;# show permitted states with guard parameter&#xA;job.aasm.states({permitted: true}, guard_parameter).map(&amp;amp;:name)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Warning output&lt;/h3&gt; &#xA;&lt;p&gt;Warnings are by default printed to &lt;code&gt;STDERR&lt;/code&gt;. If you want to log those warnings to another output, use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Job&#xA;  include AASM&#xA;&#xA;  aasm logger: Rails.logger do&#xA;    ...&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can hide warnings by setting &lt;code&gt;AASM::Configuration.hide_warnings = true&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;RubyMotion support&lt;/h3&gt; &#xA;&lt;p&gt;Now supports &lt;a href=&#34;https://github.com/infinitered/cdq.git&#34;&gt;CodeDataQuery&lt;/a&gt; ! However I&#39;m still in the process of submitting my compatibility updates to their repository. In the meantime you can use &lt;a href=&#34;https://github.com/Infotaku/cdq.git&#34;&gt;my fork&lt;/a&gt;, there may still be some minor issues but I intend to extensively use it myself, so fixes should come fast.&lt;/p&gt; &#xA;&lt;p&gt;Warnings:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Due to RubyMotion Proc&#39;s lack of &#39;source_location&#39; method, it may be harder to find out the origin of a &#34;cannot transition from&#34; error. I would recommend using the &#39;instance method symbol / string&#39; way whenever possible when defining guardians and callbacks.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Testing&lt;/h3&gt; &#xA;&lt;h4&gt;RSpec&lt;/h4&gt; &#xA;&lt;p&gt;AASM provides some matchers for &lt;a href=&#34;http://rspec.info&#34;&gt;RSpec&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;transition_from&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;have_state&lt;/code&gt;, &lt;code&gt;allow_event&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;and &lt;code&gt;allow_transition_to&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Installation Instructions:&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add &lt;code&gt;require &#39;aasm/rspec&#39;&lt;/code&gt; to your &lt;code&gt;spec_helper.rb&lt;/code&gt; file.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Examples Of Usage in Rspec:&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# classes with only the default state machine&#xA;job = Job.new&#xA;expect(job).to transition_from(:sleeping).to(:running).on_event(:run)&#xA;expect(job).not_to transition_from(:sleeping).to(:cleaning).on_event(:run)&#xA;expect(job).to have_state(:sleeping)&#xA;expect(job).not_to have_state(:running)&#xA;expect(job).to allow_event :run&#xA;expect(job).to_not allow_event :clean&#xA;expect(job).to allow_transition_to(:running)&#xA;expect(job).to_not allow_transition_to(:cleaning)&#xA;# on_event also accept multiple arguments&#xA;expect(job).to transition_from(:sleeping).to(:running).on_event(:run, :defragmentation)&#xA;&#xA;# classes with multiple state machine&#xA;multiple = SimpleMultipleExample.new&#xA;expect(multiple).to transition_from(:standing).to(:walking).on_event(:walk).on(:move)&#xA;expect(multiple).to_not transition_from(:standing).to(:running).on_event(:walk).on(:move)&#xA;expect(multiple).to have_state(:standing).on(:move)&#xA;expect(multiple).not_to have_state(:walking).on(:move)&#xA;expect(multiple).to allow_event(:walk).on(:move)&#xA;expect(multiple).to_not allow_event(:hold).on(:move)&#xA;expect(multiple).to allow_transition_to(:walking).on(:move)&#xA;expect(multiple).to_not allow_transition_to(:running).on(:move)&#xA;expect(multiple).to transition_from(:sleeping).to(:processing).on_event(:start).on(:work)&#xA;expect(multiple).to_not transition_from(:sleeping).to(:sleeping).on_event(:start).on(:work)&#xA;expect(multiple).to have_state(:sleeping).on(:work)&#xA;expect(multiple).not_to have_state(:processing).on(:work)&#xA;expect(multiple).to allow_event(:start).on(:move)&#xA;expect(multiple).to_not allow_event(:stop).on(:move)&#xA;expect(multiple).to allow_transition_to(:processing).on(:move)&#xA;expect(multiple).to_not allow_transition_to(:sleeping).on(:move)&#xA;# allow_event also accepts arguments&#xA;expect(job).to allow_event(:run).with(:defragmentation)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Minitest&lt;/h4&gt; &#xA;&lt;p&gt;AASM provides assertions and rspec-like expectations for &lt;a href=&#34;https://github.com/seattlerb/minitest&#34;&gt;Minitest&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;Assertions&lt;/h5&gt; &#xA;&lt;p&gt;List of supported assertions: &lt;code&gt;assert_have_state&lt;/code&gt;, &lt;code&gt;refute_have_state&lt;/code&gt;, &lt;code&gt;assert_transitions_from&lt;/code&gt;, &lt;code&gt;refute_transitions_from&lt;/code&gt;, &lt;code&gt;assert_event_allowed&lt;/code&gt;, &lt;code&gt;refute_event_allowed&lt;/code&gt;, &lt;code&gt;assert_transition_to_allowed&lt;/code&gt;, &lt;code&gt;refute_transition_to_allowed&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;Examples Of Usage (Minitest):&lt;/h5&gt; &#xA;&lt;p&gt;Add &lt;code&gt;require &#39;aasm/minitest&#39;&lt;/code&gt; to your &lt;code&gt;test_helper.rb&lt;/code&gt; file and use them like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# classes with only the default state machine&#xA;job = Job.new&#xA;assert_transitions_from job, :sleeping, to: :running, on_event: :run&#xA;refute_transitions_from job, :sleeping, to: :cleaning, on_event: :run&#xA;assert_have_state job, :sleeping&#xA;refute_have_state job, :running&#xA;assert_event_allowed job, :run&#xA;refute_event_allowed job, :clean&#xA;assert_transition_to_allowed job, :running&#xA;refute_transition_to_allowed job, :cleaning&#xA;# on_event also accept arguments&#xA;assert_transitions_from job, :sleeping, :defragmentation, to: :running, on_event: :run&#xA;&#xA;# classes with multiple state machine&#xA;multiple = SimpleMultipleExample.new&#xA;assert_transitions_from multiple, :standing, to: :walking, on_event: :walk, on: :move&#xA;refute_transitions_from multiple, :standing, to: :running, on_event: :walk, on: :move&#xA;assert_have_state multiple, :standing, on: :move&#xA;refute_have_state multiple, :walking, on: :move&#xA;assert_event_allowed multiple, :walk, on: :move&#xA;refute_event_allowed multiple, :hold, on: :move&#xA;assert_transition_to_allowed multiple, :walking, on: :move&#xA;refute_transition_to_allowed multiple, :running, on: :move&#xA;assert_transitions_from multiple, :sleeping, to: :processing, on_event: :start, on: :work&#xA;refute_transitions_from multiple, :sleeping, to: :sleeping, on_event: :start, on: :work&#xA;assert_have_state multiple, :sleeping, on: :work&#xA;refute_have_state multiple, :processing, on: :work&#xA;assert_event_allowed multiple, :start, on: :move&#xA;refute_event_allowed multiple, :stop, on: :move&#xA;assert_transition_to_allowed multiple, :processing, on: :move&#xA;refute_transition_to_allowed multiple, :sleeping, on: :move&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Expectations&lt;/h5&gt; &#xA;&lt;p&gt;List of supported expectations: &lt;code&gt;must_transition_from&lt;/code&gt;, &lt;code&gt;wont_transition_from&lt;/code&gt;, &lt;code&gt;must_have_state&lt;/code&gt;, &lt;code&gt;wont_have_state&lt;/code&gt;, &lt;code&gt;must_allow_event&lt;/code&gt;, &lt;code&gt;wont_allow_event&lt;/code&gt;, &lt;code&gt;must_allow_transition_to&lt;/code&gt;, &lt;code&gt;wont_allow_transition_to&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Add &lt;code&gt;require &#39;aasm/minitest_spec&#39;&lt;/code&gt; to your &lt;code&gt;test_helper.rb&lt;/code&gt; file and use them like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# classes with only the default state machine&#xA;job = Job.new&#xA;job.must_transition_from :sleeping, to: :running, on_event: :run&#xA;job.wont_transition_from :sleeping, to: :cleaning, on_event: :run&#xA;job.must_have_state :sleeping&#xA;job.wont_have_state :running&#xA;job.must_allow_event :run&#xA;job.wont_allow_event :clean&#xA;job.must_allow_transition_to :running&#xA;job.wont_allow_transition_to :cleaning&#xA;# on_event also accept arguments&#xA;job.must_transition_from :sleeping, :defragmentation, to: :running, on_event: :run&#xA;&#xA;# classes with multiple state machine&#xA;multiple = SimpleMultipleExample.new&#xA;multiple.must_transition_from :standing, to: :walking, on_event: :walk, on: :move&#xA;multiple.wont_transition_from :standing, to: :running, on_event: :walk, on: :move&#xA;multiple.must_have_state :standing, on: :move&#xA;multiple.wont_have_state :walking, on: :move&#xA;multiple.must_allow_event :walk, on: :move&#xA;multiple.wont_allow_event :hold, on: :move&#xA;multiple.must_allow_transition_to :walking, on: :move&#xA;multiple.wont_allow_transition_to :running, on: :move&#xA;multiple.must_transition_from :sleeping, to: :processing, on_event: :start, on: :work&#xA;multiple.wont_transition_from :sleeping, to: :sleeping, on_event: :start, on: :work&#xA;multiple.must_have_state :sleeping, on: :work&#xA;multiple.wont_have_state :processing, on: :work&#xA;multiple.must_allow_event :start, on: :move&#xA;multiple.wont_allow_event :stop, on: :move&#xA;multiple.must_allow_transition_to :processing, on: :move&#xA;multiple.wont_allow_transition_to :sleeping, on: :move&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;installation&#34;&gt;Installation&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;a id=&#34;installation&#34;&gt; &lt;h3&gt;Manually from RubyGems.org&lt;/h3&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;% gem install aasm&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;Or if you are using Bundler&lt;/h3&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Gemfile&#xA;gem &#39;aasm&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;Building your own gems&lt;/h3&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;% rake build&#xA;% sudo gem install pkg/aasm-x.y.z.gem&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;Generators&lt;/h3&gt; &lt;p&gt;After installing AASM you can run generator:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;% rails generate aasm NAME [COLUMN_NAME]&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Replace NAME with the Model name, COLUMN_NAME is optional(default is &#39;aasm_state&#39;). This will create a model (if one does not exist) and configure it with aasm block. For ActiveRecord orm a migration file is added to add aasm state column to table.&lt;/p&gt; &lt;h3&gt;Docker&lt;/h3&gt; &lt;p&gt;Run test suite easily on docker&lt;/p&gt; &lt;pre&gt;&lt;code&gt;1. docker-compose build aasm&#xA;2. docker-compose run --rm aasm&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Latest changes&lt;/h2&gt; &lt;/a&gt;&#xA;&lt;p&gt;&lt;a id=&#34;installation&#34;&gt;Take a look at the &lt;/a&gt;&lt;a href=&#34;https://github.com/aasm/aasm/raw/master/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt; for details about recent changes to the current version.&lt;/p&gt; &#xA;&lt;h2&gt;Questions?&lt;/h2&gt; &#xA;&lt;p&gt;Feel free to&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/aasm/aasm/issues&#34;&gt;create an issue on GitHub&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://stackoverflow.com&#34;&gt;ask a question on StackOverflow&lt;/a&gt; (tag with &lt;code&gt;aasm&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;send us a tweet &lt;a href=&#34;http://twitter.com/aasm&#34;&gt;@aasm&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Maintainers&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rubyist&#34;&gt;Scott Barron&lt;/a&gt; (2006–2009, original author)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ttilley&#34;&gt;Travis Tilley&lt;/a&gt; (2009–2011)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/alto&#34;&gt;Thorsten Böttger&lt;/a&gt; (since 2011)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/anilmaurya&#34;&gt;Anil Maurya&lt;/a&gt; (since 2016)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Stargazers over time&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://starchart.cc/aasm/aasm&#34;&gt;&lt;img src=&#34;https://starchart.cc/aasm/aasm.svg?sanitize=true&#34; alt=&#34;Stargazers over time&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://raw.githubusercontent.com/aasm/aasm/master/CONTRIBUTING.md&#34;&gt;Contributing&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;h2&gt;Warranty&lt;/h2&gt; &#xA;&lt;p&gt;This software is provided &#34;as is&#34; and without any express or implied warranties, including, without limitation, the implied warranties of merchantibility and fitness for a particular purpose.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2006-2017 Scott Barron&lt;/p&gt; &#xA;&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &#34;Software&#34;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:&lt;/p&gt; &#xA;&lt;p&gt;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&lt;/p&gt; &#xA;&lt;p&gt;THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&lt;/p&gt;</summary>
  </entry>
</feed>