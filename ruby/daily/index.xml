<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-09T01:43:15Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bryanp/goru</title>
    <updated>2023-04-09T01:43:15Z</updated>
    <id>tag:github.com,2023-04-09:/bryanp/goru</id>
    <link href="https://github.com/bryanp/goru" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Concurrent routines for Ruby.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;Concurrent routines for Ruby.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Goru is an experimental concurrency library for Ruby.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Lightweight:&lt;/strong&gt; Goru routines are not backed by fibers or threads. Each routine creates only ~345 bytes of memory overhead.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Explicit:&lt;/strong&gt; Goru requires you to describe exactly how a routine behaves. Less magic makes for fewer bugs when writing concurrent programs.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Goru was intended for low-level programs like http servers and not for direct use in user-facing code.&lt;/p&gt; &#xA;&lt;h2&gt;How It Works&lt;/h2&gt; &#xA;&lt;p&gt;Routines are defined with initial state and a block that does work and (optionally) updates the state of the routine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;3.times do&#xA;  Goru::Scheduler.go(:running) { |routine|&#xA;    case routine.state&#xA;    when :running&#xA;      routine.update(:sleeping)&#xA;      routine.sleep(rand)&#xA;    when :sleeping&#xA;      puts &#34;[#{object_id}] woke up at #{Time.now.to_f}&#34;&#xA;      routine.update(:running)&#xA;    end&#xA;  }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Routines run concurrently within a reactor, each reactor running in a dedicated thread. Each eligible routine is called once on every tick of the reactor it is scheduled to run in. In the example above, the three routines sleep for a random interval before waking up and printing the current time. Here is some example output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[1840] woke up at 1677939216.379147&#xA;[1860] woke up at 1677939217.059535&#xA;[1920] woke up at 1677939217.190349&#xA;[1860] woke up at 1677939217.6196458&#xA;[1920] woke up at 1677939217.935916&#xA;[1840] woke up at 1677939218.033243&#xA;[1860] woke up at 1677939218.532908&#xA;[1920] woke up at 1677939218.8669178&#xA;[1840] woke up at 1677939219.379714&#xA;[1860] woke up at 1677939219.522777&#xA;[1920] woke up at 1677939220.0475688&#xA;[1840] woke up at 1677939220.253979&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each reactor can only run one routine at any given point in time, but if a routine blocks (e.g. by sleeping or performing i/o) the reactor calls another eligible routine before returning to the previously blocked routine on the next tick.&lt;/p&gt; &#xA;&lt;h2&gt;Scheduler&lt;/h2&gt; &#xA;&lt;p&gt;By default Goru routines are scheduled in a global scheduler that waits at the end of the program for all routines to finish. While this is useful for small scripts, most use-cases will involve creating your own scheduler and registering routines directly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;scheduler = Goru::Scheduler.new&#xA;scheduler.go { |routine|&#xA;  ...&#xA;}&#xA;scheduler.wait&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Routines are scheduled to run immediately after registration.&lt;/p&gt; &#xA;&lt;h3&gt;Tuning&lt;/h3&gt; &#xA;&lt;p&gt;Schedulers default to running a number of reactors matching the number of processors on the current system. Tune this to your needs with the &lt;code&gt;count&lt;/code&gt; option when creating a scheduler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;scheduler = Goru::Scheduler.new(count: 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;State&lt;/h2&gt; &#xA;&lt;p&gt;Routines are initialized with default state that is useful for coordination between ticks. This is perhaps the oddest part of Goru but the explicitness can make it easier to understand exactly how your routines will behave.&lt;/p&gt; &#xA;&lt;p&gt;Take a look at the &lt;a href=&#34;https://raw.githubusercontent.com/bryanp/goru/main/examples&#34;&gt;examples&lt;/a&gt; to get some ideas.&lt;/p&gt; &#xA;&lt;h2&gt;Finishing&lt;/h2&gt; &#xA;&lt;p&gt;Routines will run forever until you say they are finished:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Goru::Scheduler.go { |routine|&#xA;  routine.finished&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Results&lt;/h3&gt; &#xA;&lt;p&gt;When finishing a routine you can provide a final result:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;routines = []&#xA;scheduler = Goru::Scheduler.new&#xA;routines &amp;lt;&amp;lt; scheduler.go { |routine| routine.finished(true) }&#xA;routines &amp;lt;&amp;lt; scheduler.go { |routine| routine.finished(false) }&#xA;routines &amp;lt;&amp;lt; scheduler.go { |routine| routine.finished(true) }&#xA;scheduler.wait&#xA;&#xA;pp routines.map(&amp;amp;:result)&#xA;# [true, false, true]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Error Handling&lt;/h2&gt; &#xA;&lt;p&gt;Unhandled errors within a routine cause the routine to enter an &lt;code&gt;:errored&lt;/code&gt; state. Calling &lt;code&gt;result&lt;/code&gt; on an errored routine causes the error to be re-raised. Routines can handle errors elegantly using the &lt;code&gt;handle&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Goru::Scheduler.go { |routine|&#xA;  routine.handle(StandardError) do |event:|&#xA;    # do something with `event`&#xA;  end&#xA;&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Sleeping&lt;/h2&gt; &#xA;&lt;p&gt;Goru implements a non-blocking version of &lt;code&gt;sleep&lt;/code&gt; that makes the routine ineligible to be called until the sleep time has elapsed. It is important to note that Ruby&#39;s built-in sleep method will block the reactor and should not be used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Goru::Scheduler.go { |routine|&#xA;  routine.sleep(3)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unlike &lt;code&gt;Kernel#sleep&lt;/code&gt; Goru&#39;s sleep method requires a duration.&lt;/p&gt; &#xA;&lt;h2&gt;Channels&lt;/h2&gt; &#xA;&lt;p&gt;Goru offers buffered reading and writing through channels:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;channel = Goru::Channel.new&#xA;&#xA;Goru::Scheduler.go(channel: channel, intent: :w) { |routine|&#xA;  routine &amp;lt;&amp;lt; SecureRandom.hex&#xA;}&#xA;&#xA;# This routine is not invoked unless the channel contains data for reading.&#xA;#&#xA;Goru::Scheduler.go(channel: channel, intent: :r) { |routine|&#xA;  value = routine.read&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Channels are unbounded by default, meaning they can hold an unlimited amount of data. This behavior can be changed by initializing a channel with a specific size. Routines with the intent to write will not be invoked unless the channel has space available for writing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;channel = Goru::Channel.new(size: 3)&#xA;&#xA;# This routine is not invoked if the channel is full.&#xA;#&#xA;Goru::Scheduler.go(channel: channel, intent: :w) { |routine|&#xA;  routine &amp;lt;&amp;lt; SecureRandom.hex&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;IO&lt;/h2&gt; &#xA;&lt;p&gt;Goru includes a pattern for non-blocking io. With it you can implement non-blocking servers, clients, etc.&lt;/p&gt; &#xA;&lt;p&gt;Routines that involve io must be created with an io object and an intent. Possible intents include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:r&lt;/code&gt; for reading&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:w&lt;/code&gt; for writing&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:rw&lt;/code&gt; for reading and writing&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here is the beginning of an http server in Goru:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Goru::Scheduler.go(io: TCPServer.new(&#34;localhost&#34;, 4242), intent: :r) { |server_routine|&#xA;  next unless client = server_routine.accept&#xA;&#xA;  Goru::Scheduler.go(io: client, intent: :r) { |client_routine|&#xA;    next unless data = client_routine.read(16384)&#xA;&#xA;    # do something with `data`&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Changing Intents&lt;/h3&gt; &#xA;&lt;p&gt;Intents can be changed after a routine is created, e.g. to switch a routine from reading to writing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Goru::Scheduler.go(io: io, intent: :r) { |routine|&#xA;  routine.intent = :w&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;Goru was designed while writing a project in Go and imagining what Go-like concurrency might look like in Ruby.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tenderlove/rails_autolink</title>
    <updated>2023-04-09T01:43:15Z</updated>
    <id>tag:github.com,2023-04-09:/tenderlove/rails_autolink</id>
    <link href="https://github.com/tenderlove/rails_autolink" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The auto_link function from Rails&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;rails_autolink&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/tenderlove/rails_autolink&#34;&gt;http://github.com/tenderlove/rails_autolink&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;This is an extraction of the &lt;code&gt;auto_link&lt;/code&gt; method from rails. The &lt;code&gt;auto_link&lt;/code&gt; method was removed from Rails in version Rails 3.1. This gem is meant to bridge the gap for people migrating.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;By default auto_link returns sanitized html_safe strings. This behaviour can be overridden by setting the &lt;code&gt;:sanitize&lt;/code&gt; option to false (thus making it insecure if you don&#39;t have the content under control).&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;rails_autolink&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Synopsis&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;rails_autolink&#39;&#xA;&#xA;auto_link(&#34;Go to http://www.rubyonrails.org and say hello to david@loudthinking.com&#34;)&#xA;# =&amp;gt; &#34;Go to &amp;lt;a href=\&#34;http://www.rubyonrails.org\&#34;&amp;gt;http://www.rubyonrails.org&amp;lt;/a&amp;gt; and&#xA;#     say hello to &amp;lt;a href=\&#34;mailto:david@loudthinking.com\&#34;&amp;gt;david@loudthinking.com&amp;lt;/a&amp;gt;&#34;&#xA;&#xA;auto_link(&#34;Visit http://www.loudthinking.com/ or e-mail david@loudthinking.com&#34;, :link =&amp;gt; :urls)&#xA;# =&amp;gt; &#34;Visit &amp;lt;a href=\&#34;http://www.loudthinking.com/\&#34;&amp;gt;http://www.loudthinking.com/&amp;lt;/a&amp;gt;&#xA;#     or e-mail david@loudthinking.com&#34;&#xA;&#xA;auto_link(&#34;Visit http://www.loudthinking.com/ or e-mail david@loudthinking.com&#34;, :link =&amp;gt; :email_addresses)&#xA;# =&amp;gt; &#34;Visit http://www.loudthinking.com/ or e-mail &amp;lt;a href=\&#34;mailto:david@loudthinking.com\&#34;&amp;gt;david@loudthinking.com&amp;lt;/a&amp;gt;&#34;&#xA;&#xA;auto_link(&#34;Go to http://www.rubyonrails.org &amp;lt;script&amp;gt;Malicious code!&amp;lt;/script&amp;gt;&#34;)&#xA;# =&amp;gt; &#34;Go to &amp;lt;a href=\&#34;http://www.rubyonrails.org\&#34;&amp;gt;http://www.rubyonrails.org&amp;lt;/a&amp;gt; &#34;&#xA;&#xA;auto_link(&#34;Go to http://www.rubyonrails.org &amp;lt;script&amp;gt;alert(&#39;Script!&#39;)&amp;lt;/script&amp;gt;&#34;, :sanitize =&amp;gt; false)&#xA;# =&amp;gt; &#34;Go to &amp;lt;a href=\&#34;http://www.rubyonrails.org\&#34;&amp;gt;http://www.rubyonrails.org&amp;lt;/a&amp;gt; &amp;lt;script&amp;gt;alert(&#39;Script!&#39;)&amp;lt;/script&amp;gt;&#34;&#xA;&#xA;post_body = &#34;Welcome to my new blog at http://www.myblog.com/.  Please e-mail me at me@email.com.&#34;&#xA;auto_link(post_body, :html =&amp;gt; { :target =&amp;gt; &#39;_blank&#39; }) do |text|&#xA;  truncate(text, :length =&amp;gt; 15)&#xA;end&#xA;# =&amp;gt; &#34;Welcome to my new blog at &amp;lt;a href=\&#34;http://www.myblog.com/\&#34; target=\&#34;_blank\&#34;&amp;gt;http://www.m...&amp;lt;/a&amp;gt;.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;rails&lt;/code&gt; &amp;gt; &lt;code&gt;3.1&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>pengxiaofeng/webistrano</title>
    <updated>2023-04-09T01:43:15Z</updated>
    <id>tag:github.com,2023-04-09:/pengxiaofeng/webistrano</id>
    <link href="https://github.com/pengxiaofeng/webistrano" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Webistrano - Capistrano deployment the easy way&lt;/p&gt; &#xA;&lt;p&gt;About: Webistrano is a Web UI for managing Capistrano deployments. It lets you manage projects and their stages like test, production, and staging with different settings. Those stages can then be deployed with Capistrano through Webistrano.&lt;/p&gt; &#xA;&lt;p&gt;Installation:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Configuration&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copy config/webistrano_config.rb.sample to config/webistrano_config.rb&#xA;and edit appropriatly. In this configuration file you can set the mail&#xA;settings of Webistrano.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Database&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copy config/database.yml.sample to config/database.yml and edit to&#xA;resemble your setting. You need at least the production database.&#xA;The others are optional entries for development and testing.&#xA;&#xA;Then create the database structure with Rake:&#xA;&#xA;&amp;gt; cd webistrano&#xA;&amp;gt; RAILS_ENV=production rake db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Start Webistrano&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; cd webistrano&#xA;&amp;gt; ruby script/server -d -p 3000 -e production&#xA;&#xA;Webistrano is then available at http://host:3000/&#xA;&#xA;The default user is `admin`, the password is `admin`. Please change the password&#xA;after the first login.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Author: Jonathan Weiss &lt;a href=&#34;mailto:jw@innerewut.de&#34;&gt;jw@innerewut.de&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;License: Code: BSD, see LICENSE.txt Images: Right to use in their provided form in Webistrano installations. No other right granted.&lt;/p&gt;</summary>
  </entry>
</feed>