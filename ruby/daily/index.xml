<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-04T01:37:21Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sidekiq-cron/sidekiq-cron</title>
    <updated>2022-12-04T01:37:21Z</updated>
    <id>tag:github.com,2022-12-04:/sidekiq-cron/sidekiq-cron</id>
    <link href="https://github.com/sidekiq-cron/sidekiq-cron" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Scheduler / Cron for Sidekiq jobs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Sidekiq-Cron&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://badge.fury.io/rb/sidekiq-cron&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/sidekiq-cron.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/sidekiq-cron/sidekiq-cron/actions&#34;&gt;&lt;img src=&#34;https://github.com/sidekiq-cron/sidekiq-cron/workflows/CI/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/github/ondrejbartas/sidekiq-cron?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/ondrejbartas/sidekiq-cron/badge.svg?branch=master&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;A scheduling add-on for &lt;a href=&#34;https://sidekiq.org/&#34;&gt;Sidekiq&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;ðŸŽ¬ &lt;a href=&#34;https://www.driftingruby.com/episodes/periodic-tasks-with-sidekiq-cron&#34;&gt;Introduction video about Sidekiq-Cron by Drifting Ruby&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Sidekiq-Cron runs a thread alongside Sidekiq workers to schedule jobs at specified times (using cron notation &lt;code&gt;* * * * *&lt;/code&gt; parsed by &lt;a href=&#34;https://github.com/floraison/fugit&#34;&gt;Fugit&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Checks for new jobs to schedule every 30 seconds and doesn&#39;t schedule the same job multiple times when more than one Sidekiq worker is running.&lt;/p&gt; &#xA;&lt;p&gt;Scheduling jobs are added only when at least one Sidekiq process is running, but it is safe to use Sidekiq-Cron in environments where multiple Sidekiq processes or nodes are running.&lt;/p&gt; &#xA;&lt;p&gt;If you want to know how scheduling work, check out &lt;a href=&#34;https://raw.githubusercontent.com/sidekiq-cron/sidekiq-cron/master/#under-the-hood&#34;&gt;under the hood&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Works with ActiveJob (Rails 4.2+).&lt;/p&gt; &#xA;&lt;p&gt;You don&#39;t need Sidekiq PRO, you can use this gem with plain Sidekiq.&lt;/p&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;Before upgrading to a new version, please read our &lt;a href=&#34;https://raw.githubusercontent.com/sidekiq-cron/sidekiq-cron/master/CHANGELOG.md&#34;&gt;Changelog&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Redis 2.8 or greater is required (Redis 3.0.3 or greater is recommended for large scale use)&lt;/li&gt; &#xA; &lt;li&gt;Sidekiq 4.2 or greater is required (for Sidekiq &amp;lt; 4 use version sidekiq-cron 0.3.1)&lt;/li&gt; &#xA; &lt;li&gt;Sidekiq 6.5 requires Sidekiq-Cron 1.5+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Install the gem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install sidekiq-cron&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or add to your &lt;code&gt;Gemfile&lt;/code&gt; and run &lt;code&gt;bundle install&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;sidekiq-cron&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt; If you are not using Rails, you need to add &lt;code&gt;require &#39;sidekiq-cron&#39;&lt;/code&gt; somewhere after &lt;code&gt;require &#39;sidekiq&#39;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Job properties&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;{&#xA;  # MANDATORY&#xA;  &#39;name&#39; =&amp;gt; &#39;name_of_job&#39;, # must be uniq!&#xA;  &#39;cron&#39; =&amp;gt; &#39;1 * * * *&#39;,  # execute at 1 minute of every hour, ex: 12:01, 13:01, 14:01, ...&#xA;  &#39;class&#39; =&amp;gt; &#39;MyClass&#39;,&#xA;  # OPTIONAL&#xA;  &#39;queue&#39; =&amp;gt; &#39;name of queue&#39;,&#xA;  &#39;args&#39; =&amp;gt; &#39;[Array or Hash] of arguments which will be passed to perform method&#39;,&#xA;  &#39;date_as_argument&#39; =&amp;gt; true, # add the time of execution as last argument of the perform method&#xA;  &#39;active_job&#39; =&amp;gt; true,  # enqueue job through Rails 4.2+ Active Job interface&#xA;  &#39;queue_name_prefix&#39; =&amp;gt; &#39;prefix&#39;, # Rails 4.2+ Active Job queue with prefix&#xA;  &#39;queue_name_delimiter&#39; =&amp;gt; &#39;.&#39;, # Rails 4.2+ Active Job queue with custom delimiter&#xA;  &#39;description&#39; =&amp;gt; &#39;A sentence describing what work this job performs&#39;&#xA;  &#39;status&#39; =&amp;gt; &#39;disabled&#39; # default: enabled&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Time, cron and Sidekiq-Cron&lt;/h3&gt; &#xA;&lt;p&gt;For testing your cron notation you can use &lt;a href=&#34;https://crontab.guru&#34;&gt;crontab.guru&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Sidekiq-Cron uses &lt;a href=&#34;https://github.com/floraison/fugit&#34;&gt;Fugit&lt;/a&gt; to parse the cronline. So please, check Fugit documentation for further information about allowed formats.&lt;/p&gt; &#xA;&lt;p&gt;If using Rails, this is evaluated against the timezone configured in Rails, otherwise the default is UTC.&lt;/p&gt; &#xA;&lt;p&gt;If you want to have your jobs enqueued based on a different time zone you can specify a timezone in the cronline, like this &lt;code&gt;&#39;0 22 * * 1-5 America/Chicago&#39;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Natural-language formats&lt;/h4&gt; &#xA;&lt;p&gt;Since sidekiq-cron &lt;code&gt;v1.7.0&lt;/code&gt;, you can use the natural-language formats supported by Fugit, such as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;&#34;every day at five&#34; # =&amp;gt; &#39;0 5 * * *&#39;&#xA;&#34;every 3 hours&#34;     # =&amp;gt; &#39;0 */3 * * *&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/floraison/fugit#fugitnat&#34;&gt;the relevant part of Fugit documentation&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h4&gt;Second-precision (sub-minute) cronlines&lt;/h4&gt; &#xA;&lt;p&gt;In addition to the standard 5-parameter cronline format, sidekiq-cron supports scheduling jobs with second-precision using a modified 6-parameter cronline format:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Seconds Minutes Hours Days Months DayOfWeek&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;For example: &lt;code&gt;&#34;*/30 * * * * *&#34;&lt;/code&gt; would schedule a job to run every 30 seconds.&lt;/p&gt; &#xA;&lt;p&gt;Note that if you plan to schedule jobs with second precision you may need to override the default schedule poll interval so it is lower than the interval of your jobs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Sidekiq::Options[:cron_poll_interval] = 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default value at time of writing is 30 seconds. See &lt;a href=&#34;https://raw.githubusercontent.com/sidekiq-cron/sidekiq-cron/master/#under-the-hood&#34;&gt;under the hood&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h3&gt;What objects/classes can be scheduled&lt;/h3&gt; &#xA;&lt;h4&gt;Sidekiq Worker&lt;/h4&gt; &#xA;&lt;p&gt;In this example, we are using &lt;code&gt;HardWorker&lt;/code&gt; which looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class HardWorker&#xA;  include Sidekiq::Worker&#xA;&#xA;  def perform(*args)&#xA;    # do something&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Active Job Worker&lt;/h4&gt; &#xA;&lt;p&gt;You can schedule &lt;code&gt;ExampleJob&lt;/code&gt; which looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ExampleJob &amp;lt; ActiveJob::Base&#xA;  queue_as :default&#xA;&#xA;  def perform(*args)&#xA;    # Do something&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Active jobs you can use &lt;code&gt;symbolize_args: true&lt;/code&gt; in &lt;code&gt;Sidekiq::Cron::Job.create&lt;/code&gt; or in Hash configuration, which will ensure that arguments you are passing to it will be symbolized when passed back to &lt;code&gt;perform&lt;/code&gt; method in worker.&lt;/p&gt; &#xA;&lt;h4&gt;Adding Cron job&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class HardWorker&#xA;  include Sidekiq::Worker&#xA;&#xA;  def perform(name, count)&#xA;    # do something&#xA;  end&#xA;end&#xA;&#xA;Sidekiq::Cron::Job.create(name: &#39;Hard worker - every 5min&#39;, cron: &#39;*/5 * * * *&#39;, class: &#39;HardWorker&#39;) # execute at every 5 minutes&#xA;# =&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;create&lt;/code&gt; method will return only true/false if job was saved or not.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;job = Sidekiq::Cron::Job.new(name: &#39;Hard worker - every 5min&#39;, cron: &#39;*/5 * * * *&#39;, class: &#39;HardWorker&#39;)&#xA;&#xA;if job.valid?&#xA;  job.save&#xA;else&#xA;  puts job.errors&#xA;end&#xA;&#xA;# or simple&#xA;unless job.save&#xA;  puts job.errors # will return array of errors&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Load more jobs from hash:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;hash = {&#xA;  &#39;name_of_job&#39; =&amp;gt; {&#xA;    &#39;class&#39; =&amp;gt; &#39;MyClass&#39;,&#xA;    &#39;cron&#39;  =&amp;gt; &#39;1 * * * *&#39;,&#xA;    &#39;args&#39;  =&amp;gt; &#39;(OPTIONAL) [Array or Hash]&#39;&#xA;  },&#xA;  &#39;My super iber cool job&#39; =&amp;gt; {&#xA;    &#39;class&#39; =&amp;gt; &#39;SecondClass&#39;,&#xA;    &#39;cron&#39;  =&amp;gt; &#39;*/5 * * * *&#39;&#xA;  }&#xA;}&#xA;&#xA;Sidekiq::Cron::Job.load_from_hash hash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Load more jobs from array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;array = [&#xA;  {&#xA;    &#39;name&#39;  =&amp;gt; &#39;name_of_job&#39;,&#xA;    &#39;class&#39; =&amp;gt; &#39;MyClass&#39;,&#xA;    &#39;cron&#39;  =&amp;gt; &#39;1 * * * *&#39;,&#xA;    &#39;args&#39;  =&amp;gt; &#39;(OPTIONAL) [Array or Hash]&#39;&#xA;  },&#xA;  {&#xA;    &#39;name&#39;  =&amp;gt; &#39;Cool Job for Second Class&#39;,&#xA;    &#39;class&#39; =&amp;gt; &#39;SecondClass&#39;,&#xA;    &#39;cron&#39;  =&amp;gt; &#39;*/5 * * * *&#39;&#xA;  }&#xA;]&#xA;&#xA;Sidekiq::Cron::Job.load_from_array array&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Bang-suffixed methods will remove jobs that are not present in the given hash/array, update jobs that have the same names, and create new ones when the names are previously unknown.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Sidekiq::Cron::Job.load_from_hash! hash&#xA;Sidekiq::Cron::Job.load_from_array! array&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or from YAML (same notation as Resque-scheduler):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# config/schedule.yml&#xA;&#xA;my_first_job:&#xA;  cron: &#34;*/5 * * * *&#34;&#xA;  class: &#34;HardWorker&#34;&#xA;  queue: hard_worker&#xA;&#xA;second_job:&#xA;  cron: &#34;*/30 * * * *&#34; # execute at every 30 minutes&#xA;  class: &#34;HardWorker&#34;&#xA;  queue: hard_worker_long&#xA;  args:&#xA;    hard: &#34;stuff&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are multiple ways to load the jobs from a YAML file&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The gem will automatically load the jobs mentioned in &lt;code&gt;config/schedule.yml&lt;/code&gt; file (it supports ERB)&lt;/li&gt; &#xA; &lt;li&gt;When you want to load jobs from a different filename, mention the filename in sidekiq configuration, i.e. &lt;code&gt;cron_schedule_file: &#34;config/users_schedule.yml&#34;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Load the file manually as follows:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/sidekiq.rb&#xA;&#xA;Sidekiq.configure_server do |config|&#xA;  config.on(:startup) do&#xA;    schedule_file = &#34;config/users_schedule.yml&#34;&#xA;&#xA;    if File.exist?(schedule_file)&#xA;      Sidekiq::Cron::Job.load_from_hash YAML.load_file(schedule_file)&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Finding jobs&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# return array of all jobs&#xA;Sidekiq::Cron::Job.all&#xA;&#xA;# return one job by its unique name - case sensitive&#xA;Sidekiq::Cron::Job.find &#34;Job Name&#34;&#xA;&#xA;# return one job by its unique name - you can use hash with &#39;name&#39; key&#xA;Sidekiq::Cron::Job.find name: &#34;Job Name&#34;&#xA;&#xA;# if job can&#39;t be found nil is returned&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Destroy jobs&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# destroy all jobs&#xA;Sidekiq::Cron::Job.destroy_all!&#xA;&#xA;# destroy job by its name&#xA;Sidekiq::Cron::Job.destroy &#34;Job Name&#34;&#xA;&#xA;# destroy found job&#xA;Sidekiq::Cron::Job.find(&#39;Job name&#39;).destroy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Work with job&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;job = Sidekiq::Cron::Job.find(&#39;Job name&#39;)&#xA;&#xA;# disable cron scheduling&#xA;job.disable!&#xA;&#xA;# enable cron scheduling&#xA;job.enable!&#xA;&#xA;# get status of job:&#xA;job.status&#xA;# =&amp;gt; enabled/disabled&#xA;&#xA;# enqueue job right now!&#xA;job.enque!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to start scheduling?&lt;/h3&gt; &#xA;&lt;p&gt;Just start Sidekiq workers by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bundle exec sidekiq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Web UI for Cron Jobs&lt;/h3&gt; &#xA;&lt;p&gt;If you are using Sidekiq&#39;s web UI and you would like to add cron jobs too to this web UI, add &lt;code&gt;require &#39;sidekiq/cron/web&#39;&lt;/code&gt; after &lt;code&gt;require &#39;sidekiq/web&#39;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;With this, you will get:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sidekiq-cron/sidekiq-cron/master/examples/web-cron-ui.jpeg&#34; alt=&#34;Web UI&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Under the hood&lt;/h2&gt; &#xA;&lt;p&gt;When you start the Sidekiq process, it starts one thread with &lt;code&gt;Sidekiq::Poller&lt;/code&gt; instance, which perform the adding of scheduled jobs to queues, retries etc.&lt;/p&gt; &#xA;&lt;p&gt;Sidekiq-Cron adds itself into this start procedure and starts another thread with &lt;code&gt;Sidekiq::Cron::Poller&lt;/code&gt; which checks all enabled Sidekiq cron jobs every 30 seconds, if they should be added to queue (their cronline matches time of check).&lt;/p&gt; &#xA;&lt;p&gt;Sidekiq-Cron is checking jobs to be enqueued every 30s by default, you can change it by setting:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Sidekiq::Options[:cron_poll_interval] = 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sidekiq-Cron is safe to use with multiple Sidekiq processes or nodes. It uses a Redis sorted set to determine that only the first process who asks can enqueue scheduled jobs into the queue.&lt;/p&gt; &#xA;&lt;p&gt;When running with many Sidekiq processes, the polling can add significant load to Redis. You can disable polling on some processes by setting &lt;code&gt;Sidekiq::Options[:cron_poll_interval] = 0&lt;/code&gt; on these processes.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Thanks to all &lt;a href=&#34;https://github.com/sidekiq-cron/sidekiq-cron/graphs/contributors&#34;&gt;contributors&lt;/a&gt;, youâ€™re awesome and this wouldnâ€™t be possible without you!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Check out the latest master to make sure the feature hasn&#39;t been implemented or the bug hasn&#39;t been fixed yet.&lt;/li&gt; &#xA; &lt;li&gt;Check out the issue tracker to make sure someone already hasn&#39;t requested it and/or contributed it.&lt;/li&gt; &#xA; &lt;li&gt;Fork the project.&lt;/li&gt; &#xA; &lt;li&gt;Start a feature/bugfix branch.&lt;/li&gt; &#xA; &lt;li&gt;Commit and push until you are happy with your contribution.&lt;/li&gt; &#xA; &lt;li&gt;Make sure to add tests for it. This is important so we don&#39;t break it in a future version unintentionally.&lt;/li&gt; &#xA; &lt;li&gt;Open a pull request!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Testing&lt;/h3&gt; &#xA;&lt;p&gt;You can execute the test suite by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bundle exec rake test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2013 Ondrej Bartas. See &lt;a href=&#34;https://raw.githubusercontent.com/sidekiq-cron/sidekiq-cron/master/LICENSE.txt&#34;&gt;LICENSE&lt;/a&gt; for further details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ruby/rbs</title>
    <updated>2022-12-04T01:37:21Z</updated>
    <id>tag:github.com,2022-12-04:/ruby/rbs</id>
    <link href="https://github.com/ruby/rbs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Type Signature for Ruby&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;RBS&lt;/h1&gt; &#xA;&lt;p&gt;RBS is a language to describe the structure of Ruby programs. You can write down the definition of a class or module: methods defined in the class, instance variables and their types, and inheritance/mix-in relations. It also allows declaring constants and global variables.&lt;/p&gt; &#xA;&lt;p&gt;The following is a small example of RBS for a chat app.&lt;/p&gt; &#xA;&lt;!-- run-start:a.rbs:bundle exec rbs -I a.rbs validate --&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;module ChatApp&#xA;  VERSION: String&#xA;&#xA;  class User&#xA;    attr_reader login: String&#xA;    attr_reader email: String&#xA;&#xA;    def initialize: (login: String, email: String) -&amp;gt; void&#xA;  end&#xA;&#xA;  class Bot&#xA;    attr_reader name: String&#xA;    attr_reader email: String&#xA;    attr_reader owner: User&#xA;&#xA;    def initialize: (name: String, owner: User) -&amp;gt; void&#xA;  end&#xA;&#xA;  class Message&#xA;    attr_reader id: String&#xA;    attr_reader string: String&#xA;    attr_reader from: User | Bot                     # `|` means union types: `#from` can be `User` or `Bot`&#xA;    attr_reader reply_to: Message?                   # `?` means optional type: `#reply_to` can be `nil`&#xA;&#xA;    def initialize: (from: User | Bot, string: String) -&amp;gt; void&#xA;&#xA;    def reply: (from: User | Bot, string: String) -&amp;gt; Message&#xA;  end&#xA;&#xA;  class Channel&#xA;    attr_reader name: String&#xA;    attr_reader messages: Array[Message]&#xA;    attr_reader users: Array[User]&#xA;    attr_reader bots: Array[Bot]&#xA;&#xA;    def initialize: (name: String) -&amp;gt; void&#xA;&#xA;    def each_member: () { (User | Bot) -&amp;gt; void } -&amp;gt; void  # `{` and `}` means block.&#xA;                   | () -&amp;gt; Enumerator[User | Bot, void]   # Method can be overloaded.&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;!-- run-end --&gt; &#xA;&lt;h2&gt;The Target Version&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The standard library signatures targets Ruby 3.1. (The latest release of Ruby.)&lt;/li&gt; &#xA; &lt;li&gt;The library code targets Ruby 3.1, 3.0, and 2.7. (It runs on 2.6 in fact.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install the &lt;code&gt;rbs&lt;/code&gt; gem. &lt;code&gt;$ gem install rbs&lt;/code&gt; from the command line, or add a line in your &lt;code&gt;Gemfile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;gem &#34;rbs&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;CLI&lt;/h2&gt; &#xA;&lt;p&gt;The gem ships with the &lt;code&gt;rbs&lt;/code&gt; command line tool to demonstrate what it can do and help develop RBS.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rbs version&#xA;$ rbs list&#xA;$ rbs ancestors ::Object&#xA;$ rbs methods ::Object&#xA;$ rbs method Object then&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Library&lt;/h2&gt; &#xA;&lt;p&gt;There are two important concepts, &lt;em&gt;environment&lt;/em&gt; and &lt;em&gt;definition&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;An &lt;em&gt;environment&lt;/em&gt; is a dictionary that keeps track of all declarations. What is the declaration associated with &lt;code&gt;String&lt;/code&gt; class? An &lt;em&gt;environment&lt;/em&gt; will give you the answer.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;em&gt;definition&lt;/em&gt; gives you the detail of the class. What is the type of the return value of &lt;code&gt;gsub&lt;/code&gt; method of the &lt;code&gt;String&lt;/code&gt; class? The &lt;em&gt;definition&lt;/em&gt; for &lt;code&gt;String&lt;/code&gt; class knows the list of methods it provides and their types.&lt;/p&gt; &#xA;&lt;p&gt;The following is a small code to retrieve the definition of the &lt;code&gt;String#gsub&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;!-- run-start:a.rb:bundle exec ruby a.rb --&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#34;rbs&#34;&#xA;&#xA;loader = RBS::EnvironmentLoader.new()&#xA;&#xA;# loader.add(path: Pathname(&#34;sig&#34;))   # Load .rbs files from `sig` directory&#xA;# loader.add(library: &#34;pathname&#34;)     # Load pathname library&#xA;&#xA;environment = RBS::Environment.from_loader(loader).resolve_type_names&#xA;&#xA;# ::String&#xA;string = RBS::TypeName.new(name: :String, namespace: RBS::Namespace.root)&#xA;&#xA;# Class declaration for ::String&#xA;decl = environment.class_decls[string]&#xA;&#xA;# Builder provides the translation from `declaration` to `definition`&#xA;builder = RBS::DefinitionBuilder.new(env: environment)&#xA;&#xA;# Definition of instance of String&#xA;instance = builder.build_instance(string)&#xA;&#xA;# Print the types of `gsub` method:&#xA;puts instance.methods[:gsub].method_types.join(&#34;\n&#34;)&#xA;# Outputs =&amp;gt;&#xA;#  (::Regexp | ::string pattern, ::string replacement) -&amp;gt; ::String&#xA;#  (::Regexp | ::string pattern, ::Hash[::String, ::String] hash) -&amp;gt; ::String&#xA;#  (::Regexp | ::string pattern) { (::String match) -&amp;gt; ::_ToS } -&amp;gt; ::String&#xA;#  (::Regexp | ::string pattern) -&amp;gt; ::Enumerator[::String, self]&#xA;&#xA;# Definition of singleton of String&#xA;singleton = builder.build_singleton(string)&#xA;# No `gsub` method for String singleton&#xA;puts singleton.methods[:gsub]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;!-- run-end --&gt; &#xA;&lt;h2&gt;Guides&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/rbs/master/docs/CONTRIBUTING.md&#34;&gt;Core and standard library signature contribution guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/rbs/master/docs/sigs.md&#34;&gt;Writing signatures guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/rbs/master/docs/stdlib.md&#34;&gt;Stdlib signatures guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/rbs/master/docs/syntax.md&#34;&gt;Syntax&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;After checking out the repo, run &lt;code&gt;bin/setup&lt;/code&gt; to install dependencies. Then, run &lt;code&gt;bundle exec rake test&lt;/code&gt; to run the tests. You can also run &lt;code&gt;bin/console&lt;/code&gt; for an interactive prompt that will allow you to experiment.&lt;/p&gt; &#xA;&lt;p&gt;To install this gem onto your local machine, run &lt;code&gt;bundle exec rake install&lt;/code&gt;. To release a new version, update the version number in &lt;code&gt;version.rb&lt;/code&gt;, and then run &lt;code&gt;bundle exec rake release&lt;/code&gt;, which will create a git tag for the version, push git commits and tags, and push the &lt;code&gt;.gem&lt;/code&gt; file to &lt;a href=&#34;https://rubygems.org&#34;&gt;rubygems.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Bug reports and pull requests are welcome on GitHub at &lt;a href=&#34;https://github.com/ruby/rbs&#34;&gt;https://github.com/ruby/rbs&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>