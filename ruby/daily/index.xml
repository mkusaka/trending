<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-09-16T01:34:32Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jamesgolick/resource_controller</title>
    <updated>2024-09-16T01:34:32Z</updated>
    <id>tag:github.com,2024-09-16:/jamesgolick/resource_controller</id>
    <link href="https://github.com/jamesgolick/resource_controller" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rails RESTful controller abstraction plugin.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;= Resource Controller&lt;/p&gt; &#xA;&lt;p&gt;resource_controller makes RESTful controllers easier, more maintainable, and super readable. With the RESTful controller pattern hidden away, you can focus on what makes your controller special.&lt;/p&gt; &#xA;&lt;p&gt;== Get It&lt;/p&gt; &#xA;&lt;p&gt;Install it as a plugin:&lt;/p&gt; &#xA;&lt;p&gt;script/plugin install git://github.com/giraffesoft/resource_controller.git&lt;/p&gt; &#xA;&lt;p&gt;Or grab the source&lt;/p&gt; &#xA;&lt;p&gt;git clone git://github.com/giraffesoft/resource_controller.git&lt;/p&gt; &#xA;&lt;p&gt;= Usage&lt;/p&gt; &#xA;&lt;p&gt;Creating a basic RESTful controller is as easy as...&lt;/p&gt; &#xA;&lt;p&gt;class PostsController &amp;lt; ResourceController::Base end&lt;/p&gt; &#xA;&lt;p&gt;...or if you prefer, you can use the method-call syntax. If you need to inherit from some other class, this syntax is definitely for you:&lt;/p&gt; &#xA;&lt;p&gt;class PostsController &amp;lt; ApplicationController resource_controller end&lt;/p&gt; &#xA;&lt;p&gt;Both syntaxes are identical in their behavior. Just make sure you call resource_controller before you use any other r_c functionality in your controller.&lt;/p&gt; &#xA;&lt;p&gt;Nobody just uses the default RESTful controller, though. resource_controller provides a simple API for customizations.&lt;/p&gt; &#xA;&lt;p&gt;== Action Lifecycle&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s really easy to make changes to the lifecycle of your actions.&lt;/p&gt; &#xA;&lt;p&gt;Note: We had to call the new accessor &#34;new_action&#34;, since new is somewhat reserved in ruby.&lt;/p&gt; &#xA;&lt;p&gt;=== Before and After&lt;/p&gt; &#xA;&lt;p&gt;class ProjectsController &amp;lt; ResourceController::Base&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;new_action.before do&#xA;  3.times { object.tasks.build }&#xA;end&#xA;&#xA;create.after do&#xA;  object.creator = current_user&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;end&lt;/p&gt; &#xA;&lt;p&gt;=== Flash&lt;/p&gt; &#xA;&lt;p&gt;class ProjectsController &amp;lt; ResourceController::Base create.flash &#34;Can you believe how easy it is to use resource_controller? Neither could I!&#34; end&lt;/p&gt; &#xA;&lt;p&gt;=== respond_to&lt;/p&gt; &#xA;&lt;p&gt;You can add to what&#39;s already there...&lt;/p&gt; &#xA;&lt;p&gt;class ProjectsController &amp;lt; ResourceController::Base&lt;br&gt; create.wants.js { render :template =&amp;gt; &#34;show.rjs&#34; } end&lt;/p&gt; &#xA;&lt;p&gt;Or you can create a whole new block. This syntax destroys everything that&#39;s there, and starts again...&lt;/p&gt; &#xA;&lt;p&gt;class ProjectsController &amp;lt; ResourceController::Base&lt;br&gt; create.response do |wants| wants.html wants.js { render :template =&amp;gt; &#34;show.rjs&#34; } end end&lt;/p&gt; &#xA;&lt;p&gt;If you have a nested resource and want to redirect to the parent after create/update and destroy you can do this in the object controller&lt;/p&gt; &#xA;&lt;p&gt;class CommentsController &amp;lt; ResourceController::Base belongs_to :post&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;create.wants.html { redirect_to smart_url(parent_url_options) } &#xA;update.wants.html { redirect_to smart_url(parent_url_options) } &#xA;destroy.wants.html { redirect_to smart_url(parent_url_options) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;end&lt;/p&gt; &#xA;&lt;p&gt;=== Scoping&lt;/p&gt; &#xA;&lt;p&gt;Because sometimes you want to make a bunch of customizations at once, most of the helpers accept blocks that make grouping calls really easy. Is it a DSL? Maybe; maybe not. But, it&#39;s definitely awesome.&lt;/p&gt; &#xA;&lt;p&gt;With actions that can fail, the scoping defaults to success. That means that create.flash == create.success.flash.&lt;/p&gt; &#xA;&lt;p&gt;class ProjectsController &amp;lt; ResourceController::Base&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;create do&#xA;  flash &#34;Object successfully created!&#34;&#xA;  wants.js { render :template =&amp;gt; &#34;show.rjs&#34; }&#xA;  &#xA;  failure.wants.js { render :template =&amp;gt; &#34;display_errors.rjs&#34; }&#xA;end&#xA;&#xA;destroy do&#xA;  flash &#34;You destroyed your project.  Good work.&#34;&#xA;  &#xA;  failure do&#xA;    flash &#34;You cannot destroy that project.  Stop trying!&#34;&#xA;    wants.js { render :template =&amp;gt; &#34;display_errors.rjs&#34; }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;end&lt;/p&gt; &#xA;&lt;p&gt;== Singleton Resource&lt;/p&gt; &#xA;&lt;p&gt;If you want to create a singleton RESTful controller inherit from ResourceController::Singleton.&lt;/p&gt; &#xA;&lt;p&gt;class AccountsController &amp;lt; ResourceController::Singleton end&lt;/p&gt; &#xA;&lt;p&gt;...or if need to inherit from some other class:&lt;/p&gt; &#xA;&lt;p&gt;class AccountsController &amp;lt; ApplicationController resource_controller :singleton end&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This type of controllers handle a single resource only so the index action and all the collection helpers (collection_url, collection_path...) are not available for them.&lt;/p&gt; &#xA;&lt;p&gt;Loading objects in singletons is similar to plural controllers with one exception. For non-nested singleton controllers you should override the object method as it defaults to nil for them.&lt;/p&gt; &#xA;&lt;p&gt;class AccountsController &amp;lt; ResourceController::Singleton private def object @object ||= Account.find(session[:account_id]) end end&lt;/p&gt; &#xA;&lt;p&gt;In other cases you can use the default logic and override it only if you use permalinks or anything special.&lt;/p&gt; &#xA;&lt;p&gt;Singleton nesting with both :has_many and :has_one associations is provided...&lt;/p&gt; &#xA;&lt;p&gt;map.resource :account, :has_many =&amp;gt; :options # /account/options, account is a singleton parent map.resources :users, :has_one =&amp;gt; :image # /users/1/image, image is a singleton child&lt;/p&gt; &#xA;&lt;p&gt;If you have the :has_many association with a singleton parent remember to override parent_object for your :has_many controller as it returns nil by default in this case.&lt;/p&gt; &#xA;&lt;p&gt;class OptionsController &amp;lt; ResourceController::Base belongs_to :account&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;protected&#xA;def parent_object&#xA;  Account.find(session[:account_id])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;end&lt;/p&gt; &#xA;&lt;p&gt;== Helpers (ResourceController::Helpers)&lt;/p&gt; &#xA;&lt;p&gt;=== Loading objects&lt;/p&gt; &#xA;&lt;p&gt;You want to add something like pagination to your controller...&lt;/p&gt; &#xA;&lt;p&gt;class PostsController &amp;lt; ResourceController::Base private def collection @collection ||= end_of_association_chain.find(:all, :page =&amp;gt; {:size =&amp;gt; 10, :current =&amp;gt; params[:page]}) end end&lt;/p&gt; &#xA;&lt;p&gt;Or maybe you used a permalink...&lt;/p&gt; &#xA;&lt;p&gt;class PostsController &amp;lt; ResourceController::Base private def object @object ||= end_of_association_chain.find_by_permalink(param) end end&lt;/p&gt; &#xA;&lt;p&gt;=== Building objects&lt;/p&gt; &#xA;&lt;p&gt;Maybe you have some alternative way of building objects...&lt;/p&gt; &#xA;&lt;p&gt;class PostsController &amp;lt; ResourceController::Base private def build_object @object ||= end_of_association_chain.build_my_object_some_funky_way object_params end end&lt;/p&gt; &#xA;&lt;p&gt;...and there are tons more helpers in the ResourceController::Helpers&lt;/p&gt; &#xA;&lt;p&gt;== Nested Resources&lt;/p&gt; &#xA;&lt;p&gt;Nested controllers can be a pain, especially if routing is such that you may or may not have a parent. Not so with Resource Controller.&lt;/p&gt; &#xA;&lt;p&gt;class CommentsController &amp;lt; ResourceController::Base belongs_to :post end&lt;/p&gt; &#xA;&lt;p&gt;All of the finding, and creation, and everything will be done at the scope of the post automatically.&lt;/p&gt; &#xA;&lt;p&gt;== Namespaced Resources&lt;/p&gt; &#xA;&lt;p&gt;...are handled automatically, and any namespaces are always available, symbolized, in array form @ ResourceController::Helpers#namespaces&lt;/p&gt; &#xA;&lt;p&gt;== Polymorphic Resources&lt;/p&gt; &#xA;&lt;p&gt;Everything, including url generation is handled completely automatically. Take this example...&lt;/p&gt; &#xA;&lt;h2&gt;comment.rb&lt;/h2&gt; &#xA;&lt;p&gt;class Comment belongs_to :commentable, :polymorphic =&amp;gt; true end&lt;/p&gt; &#xA;&lt;h2&gt;comments_controller.rb&lt;/h2&gt; &#xA;&lt;p&gt;class CommentsController &amp;lt; ResourceController::Base belongs_to :post, :product, :user end &lt;em&gt;Note:&lt;/em&gt; Your model doesn&#39;t have to be polymorphic in the ActiveRecord sense. It can be associated in whichever way you want.&lt;/p&gt; &#xA;&lt;h2&gt;routes.rb&lt;/h2&gt; &#xA;&lt;p&gt;map.resources :posts, :has_many =&amp;gt; :comments map.resources :products, :has_many =&amp;gt; :comments map.resources :users, :has_many =&amp;gt; :comments&lt;/p&gt; &#xA;&lt;p&gt;All you have to do is that, and r_c will infer whichever relationship is present, and perform all the actions at the scope of the parent object.&lt;/p&gt; &#xA;&lt;p&gt;=== Parent Helpers&lt;/p&gt; &#xA;&lt;p&gt;You also get some helpers for reflecting on your parent.&lt;/p&gt; &#xA;&lt;p&gt;parent? # =&amp;gt; true/false is there a parent present? parent_type # =&amp;gt; :post parent_model # =&amp;gt; Post parent_object # =&amp;gt; @post&lt;/p&gt; &#xA;&lt;p&gt;=== Non-standard resource names&lt;/p&gt; &#xA;&lt;p&gt;resource_controller supports overrides for every non-standard configuration of resources.&lt;/p&gt; &#xA;&lt;p&gt;The most common example is where the resource has a different name than the associated model. Simply overriding the model_name helper will get resource_controller working with your model.&lt;/p&gt; &#xA;&lt;p&gt;map.resources :tags ... class PhotoTag &amp;lt; ActiveRecord::Base ... class TagsController &amp;lt; ResourceController::Base private def model_name &#39;photo_tag&#39; end end&lt;/p&gt; &#xA;&lt;p&gt;In the above example, the variable, and params will be set to @tag, @tags, and params[:tag]. If you&#39;d like to change that, override object_name.&lt;/p&gt; &#xA;&lt;p&gt;def object_name &#39;photo_tag&#39; end&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re using a non-standard controller name, but everything else is standard, overriding resource_name will propagate through all of the other helpers.&lt;/p&gt; &#xA;&lt;p&gt;map.resources :tags, :controller =&amp;gt; &#34;somethings&#34; ... class Tag &amp;lt; ActiveRecord::Base ... class SomethingsController &amp;lt; ResourceController::Base private def resource_name &#39;tag&#39; end end&lt;/p&gt; &#xA;&lt;p&gt;Finally, the route_name helper is used by Urligence to determine which url helper to call, so if you have non-standard route names, override it.&lt;/p&gt; &#xA;&lt;p&gt;map.resources :tags, :controller =&amp;gt; &#34;taggings&#34; ... class Taggings &amp;lt; ActiveRecord::Base ... class TaggingsController &amp;lt; ResourceController::Base private def route_name &#39;tag&#39; end end&lt;/p&gt; &#xA;&lt;p&gt;== Url Helpers&lt;/p&gt; &#xA;&lt;p&gt;Thanks to Urligence, you also get some free url helpers.&lt;/p&gt; &#xA;&lt;p&gt;No matter what your controller looks like...&lt;/p&gt; &#xA;&lt;p&gt;[edit_|new_]object_url # is the equivalent of saying [edit_|new_]post_url(@post) [edit_|new_]object_url(some_other_object) # allows you to specify an object, but still maintain any paths or namespaces that are present&lt;/p&gt; &#xA;&lt;p&gt;collection_url # is like saying posts_url&lt;/p&gt; &#xA;&lt;p&gt;Url helpers are especially useful when working with polymorphic controllers.&lt;/p&gt; &#xA;&lt;h1&gt;/posts/1/comments&lt;/h1&gt; &#xA;&lt;p&gt;object_url # =&amp;gt; /posts/1/comments/#{@comment.to_param} object_url(comment) # =&amp;gt; /posts/1/comments/#{comment.to_param} edit_object_url # =&amp;gt; /posts/1/comments/#{@comment.to_param}/edit collection_url # =&amp;gt; /posts/1/comments&lt;/p&gt; &#xA;&lt;h1&gt;/products/1/comments&lt;/h1&gt; &#xA;&lt;p&gt;object_url # =&amp;gt; /products/1/comments/#{@comment.to_param} object_url(comment) # =&amp;gt; /products/1/comments/#{comment.to_param} edit_object_url # =&amp;gt; /products/1/comments/#{@comment.to_param}/edit collection_url # =&amp;gt; /products/1/comments&lt;/p&gt; &#xA;&lt;h1&gt;/comments&lt;/h1&gt; &#xA;&lt;p&gt;object_url # =&amp;gt; /comments/#{@comment.to_param} object_url(comment) # =&amp;gt; /comments/#{comment.to_param} edit_object_url # =&amp;gt; /comments/#{@comment.to_param}/edit collection_url # =&amp;gt; /comments&lt;/p&gt; &#xA;&lt;p&gt;Or with namespaced, nested controllers...&lt;/p&gt; &#xA;&lt;h1&gt;/admin/products/1/options&lt;/h1&gt; &#xA;&lt;p&gt;object_url # =&amp;gt; /admin/products/1/options/#{@option.to_param} object_url(option) # =&amp;gt; /admin/products/1/options/#{option.to_param} edit_object_url # =&amp;gt; /admin/products/1/options/#{@option.to_param}/edit collection_url # =&amp;gt; /admin/products/1/options&lt;/p&gt; &#xA;&lt;p&gt;You get the idea. Everything is automagical! All parameters are inferred.&lt;/p&gt; &#xA;&lt;p&gt;== Credits&lt;/p&gt; &#xA;&lt;p&gt;resource_controller was created, and is maintained by {James Golick}[http://jamesgolick.com].&lt;/p&gt; &#xA;&lt;p&gt;== License&lt;/p&gt; &#xA;&lt;p&gt;resource_controller is available under the {MIT License}[http://en.wikipedia.org/wiki/MIT_License]&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>technoweenie/attachment_fu</title>
    <updated>2024-09-16T01:34:32Z</updated>
    <id>tag:github.com,2024-09-16:/technoweenie/attachment_fu</id>
    <link href="https://github.com/technoweenie/attachment_fu" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Treat an ActiveRecord model as a file attachment, storing its patch, size, content type, etc.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;attachment-fu&lt;/h1&gt; &#xA;&lt;p&gt;attachment_fu is a plugin by Rick Olson (aka technoweenie &lt;a href=&#34;http://techno-weenie.net&#34;&gt;http://techno-weenie.net&lt;/a&gt;) and is the successor to acts_as_attachment. To get a basic run-through of its capabilities, check out Mike Clark&#39;s tutorial &lt;a href=&#34;http://clarkware.com/cgi/blosxom/2007/02/24#FileUploadFu&#34;&gt;http://clarkware.com/cgi/blosxom/2007/02/24#FileUploadFu&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;attachment_fu functionality&lt;/h1&gt; &#xA;&lt;p&gt;attachment_fu facilitates file uploads in Ruby on Rails. There are a few storage options for the actual file data, but the plugin always at a minimum stores metadata for each file in the database.&lt;/p&gt; &#xA;&lt;p&gt;There are four storage options for files uploaded through attachment_fu: File system Database file Amazon S3 Rackspace (Mosso) Cloud Files&lt;/p&gt; &#xA;&lt;p&gt;Each method of storage many options associated with it that will be covered in the following section. Something to note, however, is that the Amazon S3 storage requires you to modify config/amazon_s3.yml, the Rackspace Cloud Files storage requires you to modify config/rackspace_cloudfiles.yml, and the Database file storage requires an extra table.&lt;/p&gt; &#xA;&lt;h1&gt;attachment_fu models&lt;/h1&gt; &#xA;&lt;p&gt;For all three of these storage options a table of metadata is required. This table will contain information about the file (hence the &#39;meta&#39;) and its location. This table has no restrictions on naming, unlike the extra table required for database storage, which must have a table name of db_files (and by convention a model of DbFile).&lt;/p&gt; &#xA;&lt;p&gt;In the model there are two methods made available by this plugins: has_attachment and validates_as_attachment.&lt;/p&gt; &#xA;&lt;p&gt;has_attachment(options = {}) This method accepts the options in a hash: :content_type # Allowed content types. # Allows all by default. Use :image to allow all standard image types. :min_size # Minimum size allowed. # 1 byte is the default. :max_size # Maximum size allowed. # 1.megabyte is the default. :size # Range of sizes allowed. # (1..1.megabyte) is the default. This overrides the :min_size and :max_size options. :resize_to # Used by RMagick to resize images. # Pass either an array of width/height, or a geometry string. :thumbnails # Specifies a set of thumbnails to generate. # This accepts a hash of filename suffixes and RMagick resizing options. # This option need only be included if you want thumbnailing. :thumbnail_class # Set which model class to use for thumbnails. # This current attachment class is used by default. :path_prefix # Path to store the uploaded files in. # Uses public/#{table_name} by default for the filesystem, and just #{table_name} for the S3 and Cloud Files backend.&lt;br&gt; # Setting this sets the :storage to :file_system. :partition # Whether to partiton files in directories like /0000/0001/image.jpg. Default is true. Only applicable to the :file_system backend. :storage # Specifies the storage system to use.. # Defaults to :db_file. Options are :file_system, :db_file, :s3, and :cloud_files. :cloudfront # If using S3 for storage, this option allows for serving the files via Amazon CloudFront. # Defaults to false. :processor # Sets the image processor to use for resizing of the attached image. # Options include ImageScience, Rmagick, and MiniMagick. Default is whatever is installed. :uuid_primary_key # If your model&#39;s primary key is a 128-bit UUID in hexadecimal format, then set this to true. :association_options # attachment_fu automatically defines associations with thumbnails with has_many and belongs_to. If there are any additional options that you want to pass to these methods, then specify them here.&lt;/p&gt; &#xA;&lt;p&gt;Examples: has_attachment :max_size =&amp;gt; 1.kilobyte has_attachment :size =&amp;gt; 1.megabyte..2.megabytes has_attachment :content_type =&amp;gt; &#39;application/pdf&#39; has_attachment :content_type =&amp;gt; [&#39;application/pdf&#39;, &#39;application/msword&#39;, &#39;text/plain&#39;] has_attachment :content_type =&amp;gt; :image, :resize_to =&amp;gt; [50,50] has_attachment :content_type =&amp;gt; [&#39;application/pdf&#39;, :image], :resize_to =&amp;gt; &#39;x50&#39; has_attachment :thumbnails =&amp;gt; { :thumb =&amp;gt; [50, 50], :geometry =&amp;gt; &#39;x50&#39; } has_attachment :storage =&amp;gt; :file_system, :path_prefix =&amp;gt; &#39;public/files&#39; has_attachment :storage =&amp;gt; :file_system, :path_prefix =&amp;gt; &#39;public/files&#39;, :content_type =&amp;gt; :image, :resize_to =&amp;gt; [50,50], :partition =&amp;gt; false has_attachment :storage =&amp;gt; :file_system, :path_prefix =&amp;gt; &#39;public/files&#39;, :thumbnails =&amp;gt; { :thumb =&amp;gt; [50, 50], :geometry =&amp;gt; &#39;x50&#39; } has_attachment :storage =&amp;gt; :s3 has_attachment :store =&amp;gt; :s3, :cloudfront =&amp;gt; true has_attachment :storage =&amp;gt; :cloud_files&lt;/p&gt; &#xA;&lt;p&gt;validates_as_attachment This method prevents files outside of the valid range (:min_size to :max_size, or the :size range) from being saved. It does not however, halt the upload of such files. They will be uploaded into memory regardless of size before validation.&lt;/p&gt; &#xA;&lt;p&gt;Example: validates_as_attachment&lt;/p&gt; &#xA;&lt;h1&gt;attachment_fu migrations&lt;/h1&gt; &#xA;&lt;p&gt;Fields for attachment_fu metadata tables... in general: size, :integer # file size in bytes content_type, :string # mime type, ex: application/mp3 filename, :string # sanitized filename that reference images: height, :integer # in pixels width, :integer # in pixels that reference images that will be thumbnailed: parent_id, :integer # id of parent image (on the same table, a self-referencing foreign-key). # Only populated if the current object is a thumbnail. thumbnail, :string # the &#39;type&#39; of thumbnail this attachment record describes.&lt;br&gt; # Only populated if the current object is a thumbnail. # Usage: # [ In Model &#39;Avatar&#39; ] # has_attachment :content_type =&amp;gt; :image, # :storage =&amp;gt; :file_system, # :max_size =&amp;gt; 500.kilobytes, # :resize_to =&amp;gt; &#39;320x200&amp;gt;&#39;, # :thumbnails =&amp;gt; { :small =&amp;gt; &#39;10x10&amp;gt;&#39;, # :thumb =&amp;gt; &#39;100x100&amp;gt;&#39; } # [ Elsewhere ] # @user.avatar.thumbnails.first.thumbnail #=&amp;gt; &#39;small&#39; that reference files stored in the database (:db_file): db_file_id, :integer # id of the file in the database (foreign key)&lt;/p&gt; &#xA;&lt;p&gt;Field for attachment_fu db_files table: data, :binary # binary file data, for use in database file storage&lt;/p&gt; &#xA;&lt;h1&gt;attachment_fu views&lt;/h1&gt; &#xA;&lt;p&gt;There are two main views tasks that will be directly affected by attachment_fu: upload forms and displaying uploaded images.&lt;/p&gt; &#xA;&lt;p&gt;There are two parts of the upload form that differ from typical usage.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Include &#39;:multipart =&amp;gt; true&#39; in the html options of the form_for tag. Example: &amp;lt;% form_for(:attachment_metadata, :url =&amp;gt; { :action =&amp;gt; &#34;create&#34; }, :html =&amp;gt; { :multipart =&amp;gt; true }) do |form| %&amp;gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Use the file_field helper with :uploaded_data as the field name. Example: &amp;lt;%= form.file_field :uploaded_data %&amp;gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Displaying uploaded images is made easy by the public_filename method of the ActiveRecord attachment objects using file system, s3, and Cloud Files storage.&lt;/p&gt; &#xA;&lt;p&gt;public_filename(thumbnail = nil) Returns the public path to the file. If a thumbnail prefix is specified it will return the public file path to the corresponding thumbnail. Examples: attachment_obj.public_filename #=&amp;gt; /attachments/2/file.jpg attachment_obj.public_filename(:thumb) #=&amp;gt; /attachments/2/file_thumb.jpg attachment_obj.public_filename(:small) #=&amp;gt; /attachments/2/file_small.jpg&lt;/p&gt; &#xA;&lt;p&gt;When serving files from database storage, doing more than simply downloading the file is beyond the scope of this document.&lt;/p&gt; &#xA;&lt;h1&gt;attachment_fu controllers&lt;/h1&gt; &#xA;&lt;p&gt;There are two considerations to take into account when using attachment_fu in controllers.&lt;/p&gt; &#xA;&lt;p&gt;The first is when the files have no publicly accessible path and need to be downloaded through an action.&lt;/p&gt; &#xA;&lt;p&gt;Example: def readme send_file &#39;/path/to/readme.txt&#39;, :type =&amp;gt; &#39;plain/text&#39;, :disposition =&amp;gt; &#39;inline&#39; end&lt;/p&gt; &#xA;&lt;p&gt;See the possible values for send_file for reference.&lt;/p&gt; &#xA;&lt;p&gt;The second is when saving the file when submitted from a form. Example in view: &amp;lt;%= form.file_field :attachable, :uploaded_data %&amp;gt;&lt;/p&gt; &#xA;&lt;p&gt;Example in controller: def create @attachable_file = AttachmentMetadataModel.new(params[:attachable]) if @attachable_file.save flash[:notice] = &#39;Attachment was successfully created.&#39; redirect_to attachable_url(@attachable_file)&lt;br&gt; else render :action =&amp;gt; :new end end&lt;/p&gt; &#xA;&lt;h1&gt;attachement_fu scripting&lt;/h1&gt; &#xA;&lt;p&gt;You may wish to import a large number of images or attachments. The following example shows how to upload a file from a script.&lt;/p&gt; &#xA;&lt;p&gt;#!/usr/bin/env ./script/runner&lt;/p&gt; &#xA;&lt;h1&gt;required to use ActionController::TestUploadedFile&lt;/h1&gt; &#xA;&lt;p&gt;require &#39;action_controller&#39; require &#39;action_controller/test_process.rb&#39;&lt;/p&gt; &#xA;&lt;p&gt;path = &#34;./public/images/x.jpg&#34;&lt;/p&gt; &#xA;&lt;h1&gt;mimetype is a string like &#34;image/jpeg&#34;. One way to get the mimetype for a given file on a UNIX system&lt;/h1&gt; &#xA;&lt;h1&gt;mimetype = &lt;code&gt;file -ib #{path}&lt;/code&gt;.gsub(/\n/,&#34;&#34;)&lt;/h1&gt; &#xA;&lt;p&gt;mimetype = &#34;image/jpeg&#34;&lt;/p&gt; &#xA;&lt;h1&gt;This will &#34;upload&#34; the file at path and create the new model.&lt;/h1&gt; &#xA;&lt;p&gt;@attachable = AttachmentMetadataModel.new(:uploaded_data =&amp;gt; ActionController::TestUploadedFile.new(path, mimetype)) @attachable.save&lt;/p&gt;</summary>
  </entry>
</feed>