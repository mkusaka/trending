<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-04T01:43:28Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>learn-co-curriculum/phase-4-cookies-and-sessions-lab</title>
    <updated>2023-07-04T01:43:28Z</updated>
    <id>tag:github.com,2023-07-04:/learn-co-curriculum/phase-4-cookies-and-sessions-lab</id>
    <link href="https://github.com/learn-co-curriculum/phase-4-cookies-and-sessions-lab" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cookies and Sessions Lab&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use the session hash to persist data across multiple requests&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;In this lab, you&#39;ll be building out a blog paywall feature by using the session hash to keep track of how many page views a user has made.&lt;/p&gt; &#xA;&lt;p&gt;There is some starter code in place for a Rails API backend and a React frontend. To get set up, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle install&#xA;$ rails db:migrate db:seed&#xA;$ npm install --prefix client&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can work on this lab by running the tests with &lt;code&gt;learn test&lt;/code&gt;. It will also be helpful to see what&#39;s happening during the request/response cycle by running the app in the browser. You can run the Rails server with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ rails s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And you can run React in another terminal with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ npm start --prefix client&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You don&#39;t have to make any changes to the React code to get this lab working.&lt;/p&gt; &#xA;&lt;h2&gt;Instructions&lt;/h2&gt; &#xA;&lt;p&gt;Our app will keep track of how many blog posts a user has viewed by using the &lt;code&gt;session&lt;/code&gt; hash. Each user can view a &lt;strong&gt;maximum of three articles&lt;/strong&gt; before seeing the paywall.&lt;/p&gt; &#xA;&lt;p&gt;When a user makes a &lt;code&gt;GET&lt;/code&gt; request to &lt;code&gt;/articles/:id&lt;/code&gt;, the following should happen:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If this is the first request this user has made, set &lt;code&gt;session[:page_views]&lt;/code&gt; to an initial value of 0. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Hint&lt;/strong&gt;: consider using &lt;code&gt;||=&lt;/code&gt; to set this initial value!&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;For every request to &lt;code&gt;/articles/:id&lt;/code&gt;, increment the value of &lt;code&gt;session[:page_views]&lt;/code&gt; by 1.&lt;/li&gt; &#xA; &lt;li&gt;If the user has viewed 3 or fewer pages, render a JSON response with the article data.&lt;/li&gt; &#xA; &lt;li&gt;If the user has viewed more than 3 pages, render a JSON response including an error message, and a status code of 401 unauthorized.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://guides.rubyonrails.org/v4.1.4/action_controller_overview.html#accessing-the-session&#34;&gt;Rails - Accessing the Session&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-4-authorizing-requests-lab</title>
    <updated>2023-07-04T01:43:28Z</updated>
    <id>tag:github.com,2023-07-04:/learn-co-curriculum/phase-4-authorizing-requests-lab</id>
    <link href="https://github.com/learn-co-curriculum/phase-4-authorizing-requests-lab" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Authorizing Requests Lab&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use the session hash to authorize a user to perform actions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;In this lab, we&#39;ll continue working on the blog site, and add some features that only logged in users have access to.&lt;/p&gt; &#xA;&lt;p&gt;There is some starter code in place for a Rails API backend and a React frontend. To get set up, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle install&#xA;$ rails db:migrate db:seed&#xA;$ npm install --prefix client&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can work on this lab by running the tests with &lt;code&gt;learn test&lt;/code&gt;. It will also be helpful to see what&#39;s happening during the request/response cycle by running the app in the browser. You can run the Rails server with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ rails s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And you can run React in another terminal with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ npm start --prefix client&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You don&#39;t have to make any changes to the React code to get this lab working.&lt;/p&gt; &#xA;&lt;h2&gt;Instructions&lt;/h2&gt; &#xA;&lt;p&gt;Now that we&#39;ve got the basic login feature working, let&#39;s reward our logged in users with some bonus content that only users who have logged in will be able to access!&lt;/p&gt; &#xA;&lt;p&gt;We added a new attribute to our articles, &lt;code&gt;is_member_only&lt;/code&gt;, to reflect whether the article should only be available to authorized users of the site. We also created a new &lt;code&gt;MembersOnlyArticlesController&lt;/code&gt; class to display these exclusive articles to our logged in users.&lt;/p&gt; &#xA;&lt;p&gt;Your goal is to add the following functionality to the &lt;code&gt;MembersOnlyArticlesController&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If a user is not signed in, the &lt;code&gt;#index&lt;/code&gt; and &lt;code&gt;#show&lt;/code&gt; actions should return a status code of 401 unauthorized, along with an error message&lt;/li&gt; &#xA; &lt;li&gt;If the user is signed in, the &lt;code&gt;#index&lt;/code&gt; and &lt;code&gt;#show&lt;/code&gt; actions should return the JSON data for the members-only articles.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://guides.rubyonrails.org/action_controller_overview.html#filters&#34;&gt;Action Controller Overview: Filters&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-4-jwt-auth</title>
    <updated>2023-07-04T01:43:28Z</updated>
    <id>tag:github.com,2023-07-04:/learn-co-curriculum/phase-4-jwt-auth</id>
    <link href="https://github.com/learn-co-curriculum/phase-4-jwt-auth" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;[Optional] JWT Auth in Redux and Rails&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Disclaimer&lt;/strong&gt;: This optional assignment shows an alternative approach to using the built-in session feature in Rails. It was originally written by an instructor some time ago, and doesn&#39;t follow the same application structure you&#39;ve seen in other labs in this phase. Depending on your application&#39;s architecture, this approach may be easier or more difficult to implement. The benefit to JWT authentication and not using cookies/sessions for authentication is that it allows you truly treat your React and Rails applications as separate applications that don&#39;t need to be hosted on the same domain. If you have separate repositories for your Rails API and React frontend, and plan on deploying to separate hosting services, this approach will be easier to implement. Otherwise, you&#39;re likely better off sticking with sessions and cookies!&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Second disclaimer&lt;/strong&gt;: This is a sample application and walks through &lt;em&gt;one&lt;/em&gt; possible auth implementation. It does not cover everything there is to know about auth and is intended as an introduction. Please do not blindly copy/paste the code here. Use this as a guide to get started.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Third disclaimer&lt;/strong&gt;: there are tradeoffs to every auth implementation. To secure our application further, we should set our tokens to expire and make sure our app is being served over &lt;a href=&#34;https://en.wikipedia.org/wiki/HTTPS&#34;&gt;HTTPS&lt;/a&gt;. Furthermore, there are some &lt;a href=&#34;https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage&#34;&gt;tradeoffs to storing JWTs in browser &lt;code&gt;localStorage&lt;/code&gt;&lt;/a&gt;. &lt;a href=&#34;https://stackoverflow.com/questions/35291573/csrf-protection-with-json-web-tokens/35347022#35347022&#34;&gt;This StackOverflow post has a concise summary of the benefits/tradeoffs about where/how to store tokens client-side&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;With that out of the way, here begins our journey:&lt;/p&gt; &#xA;&lt;h2&gt;RAILS BCrypt, JWT üîê&lt;/h2&gt; &#xA;&lt;h3&gt;Building Our Server&lt;/h3&gt; &#xA;&lt;p&gt;This section will walk through building a rails server. Let&#39;s create our app with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ rails new backend_project_name --api&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;re going to need a few gems in our &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/Gemfile&#34;&gt;Gemfile&lt;/a&gt; so let&#39;s go ahead and add them. &lt;code&gt;cd&lt;/code&gt; into your project directory and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle add jwt&#xA;$ bundle add active_model_serializers&#xA;$ bundle add faker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you get a gem not found error, try manually adding them to your &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/Gemfile&#34;&gt;Gemfile&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Don&#39;t forget to uncomment &lt;code&gt;rack-cors&lt;/code&gt; and &lt;code&gt;bcrypt&lt;/code&gt; from your &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/Gemfile&#34;&gt;Gemfile&lt;/a&gt; as well.&lt;/p&gt; &#xA;&lt;p&gt;Call &lt;code&gt;bundle install&lt;/code&gt;. Your &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/Gemfile&#34;&gt;Gemfile&lt;/a&gt; should look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;source &#39;https://rubygems.org&#39;&#xA;git_source(:github) { |repo| &#34;https://github.com/#{repo}.git&#34; }&#xA;&#xA;ruby &#39;2.7.4&#39;&#xA;&#xA;# Bundle edge Rails instead: gem &#39;rails&#39;, github: &#39;rails/rails&#39;, branch: &#39;main&#39;&#xA;gem &#39;rails&#39;, &#39;~&amp;gt; 6.1.4&#39;&#xA;# Use sqlite3 as the database for Active Record&#xA;gem &#39;sqlite3&#39;, &#39;~&amp;gt; 1.4&#39;&#xA;# Use Puma as the app server&#xA;gem &#39;puma&#39;, &#39;~&amp;gt; 5.0&#39;&#xA;# Build JSON APIs with ease. Read more: https://github.com/rails/jbuilder&#xA;# gem &#39;jbuilder&#39;, &#39;~&amp;gt; 2.7&#39;&#xA;# Use Redis adapter to run Action Cable in production&#xA;# gem &#39;redis&#39;, &#39;~&amp;gt; 4.0&#39;&#xA;# Use Active Model has_secure_password&#xA;# gem &#39;bcrypt&#39;, &#39;~&amp;gt; 3.1.7&#39;&#xA;&#xA;# Use Active Storage variant&#xA;# gem &#39;image_processing&#39;, &#39;~&amp;gt; 1.2&#39;&#xA;&#xA;# Reduces boot times through caching; required in config/boot.rb&#xA;gem &#39;bootsnap&#39;, &#39;&amp;gt;= 1.4.4&#39;, require: false&#xA;&#xA;# Use Rack CORS for handling Cross-Origin Resource Sharing (CORS), making cross-origin AJAX possible&#xA;# gem &#39;rack-cors&#39;&#xA;&#xA;group :development, :test do&#xA;  # Call &#39;byebug&#39; anywhere in the code to stop execution and get a debugger console&#xA;  gem &#39;byebug&#39;, platforms: [:mri, :mingw, :x64_mingw]&#xA;end&#xA;&#xA;group :development do&#xA;  gem &#39;listen&#39;, &#39;~&amp;gt; 3.3&#39;&#xA;  # Spring speeds up development by keeping your application running in the background. Read more: https://github.com/rails/spring&#xA;  gem &#39;spring&#39;&#xA;end&#xA;&#xA;# Windows does not include zoneinfo files, so bundle the tzinfo-data gem&#xA;gem &#39;tzinfo-data&#39;, platforms: [:mingw, :mswin, :x64_mingw, :jruby]&#xA;&#xA;gem &#34;jwt&#34;, &#34;~&amp;gt; 2.2&#34;&#xA;&#xA;gem &#34;active_model_serializers&#34;, &#34;~&amp;gt; 0.10.12&#34;&#xA;&#xA;gem &#34;faker&#34;, &#34;~&amp;gt; 2.19&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Don&#39;t forget to enable &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&#34;&gt;CORS&lt;/a&gt; in your app. Uncomment the following in &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/config/initializers/cors.rb&#34;&gt;&lt;code&gt;config/initializers/cors.rb&lt;/code&gt;&lt;/a&gt;. Don&#39;t forget to change the origins from &lt;code&gt;example.com&lt;/code&gt; to &lt;code&gt;*&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Depending on the use-case and needs of our API, we might want to limit access to our app. For example, if our React frontend is deployed to &lt;code&gt;myCoolReactApp.com&lt;/code&gt;, we might want to limit access to that domain only. If certain endpoints are meant to be public, we can make those available but limit to &lt;code&gt;GET&lt;/code&gt; requests, for example.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/cors.rb&#xA;Rails.application.config.middleware.insert_before 0, Rack::Cors do&#xA;  allow do&#xA;    origins &#39;*&#39;&#xA;&#xA;    resource &#39;*&#39;,&#xA;      headers: :any,&#xA;      methods: [:get, :post, :put, :patch, :delete, :options, :head]&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can refer to the &lt;a href=&#34;https://github.com/cyu/rack-cors&#34;&gt;rack-cors gem&lt;/a&gt; for more information about this file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Please don&#39;t forget to change these settings before deploying your app to the internet. &lt;em&gt;Please&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Creating Users&lt;/h3&gt; &#xA;&lt;p&gt;Run the following commands to set up the &lt;code&gt;User&lt;/code&gt; model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ rails g model User username password_digest bio avatar&#xA;$ rails g controller api/v1/users&#xA;$ rails g serializer user&#xA;$ rails db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add &lt;code&gt;has_secure_password&lt;/code&gt; to &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/models/user.rb&#34;&gt;&lt;code&gt;app/models/user.rb&lt;/code&gt;&lt;/a&gt;. Recall that &lt;code&gt;has_secure_password&lt;/code&gt; comes from &lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html#method-i-has_secure_password&#34;&gt;&lt;code&gt;ActiveModel&lt;/code&gt; and adds methods to set and authenticate against a BCrypt password&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ApplicationRecord&#xA;  has_secure_password&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You might also want to add some &lt;a href=&#34;https://guides.rubyonrails.org/active_record_validations.html&#34;&gt;validations&lt;/a&gt; to your users:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ApplicationRecord&#xA;  has_secure_password&#xA;  validates :username, uniqueness: { case_sensitive: false }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;A &lt;strong&gt;(Not So) Quick BCrypt Tangent&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;p&gt;Recall that &lt;code&gt;BCrypt&lt;/code&gt; allows us to &lt;a href=&#34;https://en.wikipedia.org/wiki/Salt_(cryptography)&#34;&gt;salt&lt;/a&gt; users&#39; plaintext passwords before running them through a &lt;a href=&#34;https://en.wikipedia.org/wiki/Cryptographic_hash_function&#34;&gt;hashing function&lt;/a&gt;. A hashing function is, basically, a &lt;em&gt;one way&lt;/em&gt; function. Similar to putting something in a meat grinder: we cannot &lt;em&gt;feasibly&lt;/em&gt; reconstruct something that&#39;s been ground up by a meat grinder. We then store these passwords that have been &#39;digested&#39; by &lt;code&gt;BCrypt&lt;/code&gt; in our database.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://blog.mozilla.org/webdev/2012/06/08/lets-talk-about-password-storage/&#34;&gt;Never ever ever store your users&#39; plaintext passwords in your database&lt;/a&gt;. It&#39;s bad form and should be avoided at all costs.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s take a look at some of the functionality provided by &lt;code&gt;BCrypt&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# in rails console&#xA;BCrypt::Password.create(&#39;P@ssw0rd&#39;)&#xA;# =&amp;gt; &#34;$2a$10$D0iXNNy/5r2YC5GC4ArGB.dNL6IpUzxH3WjCewb3FM8ciwsHBt0cq&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;BCrypt::Password&lt;/code&gt; &lt;a href=&#34;https://github.com/codahale/bcrypt-ruby/raw/master/lib/bcrypt/password.rb#L23&#34;&gt;inherits from the Ruby &lt;code&gt;String&lt;/code&gt; class&lt;/a&gt; and has its own &lt;a href=&#34;https://github.com/codahale/bcrypt-ruby/raw/master/lib/bcrypt/password.rb#L65&#34;&gt;== instance method&lt;/a&gt; that allows us to run a plaintext password through &lt;code&gt;BCrypt&lt;/code&gt; &lt;em&gt;using the same salt&lt;/em&gt; and compare it against an already digested password:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# in rails console&#xA;salted_pw = BCrypt::Password.create(&#39;P@ssw0rd&#39;)&#xA;# =&amp;gt; &#34;$2a$10$YQvJPemUzm8IdCCaHxiOOes6HMEHda/.Hl60cUoYb4X4fncgT8ubG&#34;&#xA;&#xA;salted_pw.class&#xA;# =&amp;gt; BCrypt::Password&#xA;&#xA;salted_pw == &#39;P@ssw0rd&#39;&#xA;# =&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;BCrypt&lt;/code&gt; also provides a method that will take a stringified &lt;code&gt;password_digest&lt;/code&gt; and turn it into an instance of &lt;code&gt;BCrypt::Password&lt;/code&gt;, allowing us to call the over-written &lt;code&gt;==&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# in rails console&#xA;sample_digest = User.last.password_digest&#xA;# =&amp;gt; &#34;$2a$10$SJiIJnmQJ/A4z4fFG5EuE.aOoCjacFuQMVpVzQnhPSJKYLFCoqmWy&#34;&#xA;&#xA;sample_digest.class&#xA;# =&amp;gt; String&#xA;&#xA;sample_digest == &#39;P@ssword&#39;&#xA;#  =&amp;gt; false&#xA;&#xA;bcrypt_sample_digest = BCrypt::Password.new(sample_digest)&#xA;# =&amp;gt; &#34;$2a$10$dw4sYcbLXc8XRX6YGc7ve.ot6LbYevMbSpFQZUaa8tm5NI8cxBPwa&#34;&#xA;&#xA;bcrypt_sample_digest.class&#xA;# =&amp;gt; BCrypt::Password&#xA;&#xA;bcrypt_sample_digest == &#39;P@ssw0rd&#39;&#xA;# =&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://media.giphy.com/media/26ufdipQqU2lhNA4g/giphy.gif&#34; alt=&#34;mind blown&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;We have no way of storing instances of &lt;code&gt;BCrypt::Password&lt;/code&gt; in our database. Instead, we&#39;re storing users&#39; password digests &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/db/schema.rb&#34;&gt;as strings&lt;/a&gt;&lt;/strong&gt;. If we were to build our own &lt;code&gt;User#authenticate&lt;/code&gt; method using &lt;code&gt;BCrypt&lt;/code&gt;, it might look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ApplicationRecord&#xA;  attr_accessor :password&#xA;&#xA;  def authenticate(plaintext_password)&#xA;    if BCrypt::Password.new(self.password_digest) == plaintext_password&#xA;      self&#xA;    else&#xA;      false&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# in rails console&#xA;&#xA;User.last.authenticate(&#39;not my password&#39;)&#xA;# =&amp;gt; false&#xA;&#xA;User.last.authenticate(&#39;P@ssw0rd&#39;)&#xA;# =&amp;gt; #&amp;lt;User id: 21, username: &#34;sylviawoods&#34;, password_digest: &#34;$2a$10$dw4sYcbLXc8XRX6YGc7ve.ot6LbYevMbSpFQZUaa8tm...&#34;, avatar: nil, created_at: &#34;2018-08-31 02:11:15&#34;, updated_at: &#34;2018-08-31 02:11:15&#34;, bio: &#34;&#39;Sylvia Woods was an American restaurateur who founded the sould food restaurant Sylvia&#39;s in Harlem on Lenox Avenue, New York City in 1962. She published two cookbooks and was an important figure in the community.&#34;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of creating our own &lt;code&gt;User#authenticate&lt;/code&gt; method, we can use &lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html#method-i-has_secure_password&#34;&gt;&lt;code&gt;ActiveModel#has_secure_password&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ApplicationRecord&#xA;  has_secure_password&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://media.giphy.com/media/l4Jz3a8jO92crUlWM/giphy.gif&#34; alt=&#34;salt bae&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;End of BCrypt Tangent&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Let&#39;s add a &lt;code&gt;create&lt;/code&gt; method to our &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/api/v1/users_controller.rb&#34;&gt;&lt;code&gt;UsersController&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Api::V1::UsersController &amp;lt; ApplicationController&#xA;  def create&#xA;    @user = User.create(user_params)&#xA;    if @user.valid?&#xA;      render json: { user: UserSerializer.new(@user) }, status: :created&#xA;    else&#xA;      render json: { error: &#39;failed to create user&#39; }, status: :unprocessable_entity&#xA;    end&#xA;  end&#xA;&#xA;  private&#xA;  def user_params&#xA;    params.require(:user).permit(:username, :password, :bio, :avatar)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can use the &lt;a href=&#34;https://gist.github.com/mlanett/a31c340b132ddefa9cca&#34;&gt;built in Rails HTTP status code symbols&lt;/a&gt; when sending responses to the client; &lt;code&gt;status: :unprocessable_entity&lt;/code&gt;, for instance.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Need a refresher on &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Status&#34;&gt;HTTP Status Codes&lt;/a&gt;? Check out &lt;a href=&#34;http://httpstatusrappers.com/&#34;&gt;http://httpstatusrappers.com/&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;And update our &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/serializers/user_serializer.rb&#34;&gt;&lt;code&gt;UserSerializer&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UserSerializer &amp;lt; ActiveModel::Serializer&#xA;  attributes :username, :avatar, :bio&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next let&#39;s add the routes we&#39;ll need for our server. In &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/config/routes.rb&#34;&gt;&lt;code&gt;config/routes.rb&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.application.routes.draw do&#xA;  namespace :api do&#xA;    namespace :v1 do&#xA;      resources :users, only: [:create]&#xA;      post &#39;/login&#39;, to: &#39;auth#create&#39;&#xA;      get &#39;/profile&#39;, to: &#39;users#profile&#39;&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Take some time to test this either in &lt;a href=&#34;https://www.getpostman.com/apps&#34;&gt;Postman&lt;/a&gt; or with JavaScript fetch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetch(&#34;http://localhost:3000/api/v1/users&#34;, {&#xA;  method: &#34;POST&#34;,&#xA;  headers: {&#xA;    &#34;Content-Type&#34;: &#34;application/json&#34;,&#xA;    Accept: &#34;application/json&#34;,&#xA;  },&#xA;  body: JSON.stringify({&#xA;    user: {&#xA;      username: &#34;sylviawoods&#34;,&#xA;      password: &#34;whatscooking&#34;,&#xA;      bio: &#34;Sylvia Woods was an American restaurateur who founded the sould food restaurant Sylvia&#39;s in Harlem on Lenox Avenue, New York City in 1962. She published two cookbooks and was an important figure in the community.&#34;,&#xA;      avatar:&#xA;        &#34;https://upload.wikimedia.org/wikipedia/commons/4/49/Syvia_of_Sylvia%27s_reaturant_N.Y.C_%28cropped%29.jpg&#34;,&#xA;    },&#xA;  }),&#xA;})&#xA;  .then((r) =&amp;gt; r.json())&#xA;  .then(console.log);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; if you&#39;re using Postman and your formatting is set to &#34;raw and JSON&#34;, remember to use double quotes (&#34;&#34;) in both keys and values in the request.&lt;/p&gt; &#xA;&lt;p&gt;Important! &lt;strong&gt;Make Sure You Can POST and Create a New User Before Proceeding&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://media.giphy.com/media/pcPs6v6fhE7Ru/giphy.gif&#34; alt=&#34;intermission&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JSON Web Tokens (JWT)&lt;/h3&gt; &#xA;&lt;p&gt;Token-based authentication is &lt;strong&gt;stateless&lt;/strong&gt;. &lt;em&gt;We are not storing any information about a logged in user on the server&lt;/em&gt; (which also means we don&#39;t need a model or table for our user sessions). No stored information means our application can scale and add more machines as necessary without worrying about where a user is logged in. Instead, the client (browser) stores a token and sends that token along with every authenticated request. Instead of storing a plaintext username, or user_id, we can encode user data with JSON Web Tokens (JWT) and store that encoded token client-side.&lt;/p&gt; &#xA;&lt;h4&gt;JWT Auth Flow&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.stack.imgur.com/f2ZhM.png&#34; alt=&#34;jwt&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here is the JWT authentication flow for logging in:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;An already existing user requests access with their username and password&lt;/li&gt; &#xA; &lt;li&gt;The app validates these credentials&lt;/li&gt; &#xA; &lt;li&gt;The app gives a signed token to the client&lt;/li&gt; &#xA; &lt;li&gt;The client stores the token and presents it with every request. This token is effectively the user&#39;s access pass‚Äì‚Äìit proves to our server that they are who they claim to be.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;JWTs are composed of three strings separated by periods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;aaaaaaaaaaaaaaa.bbbbbbbbbbbbbbbbbbbbb.ccccccccccccccccccc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The first part (&lt;code&gt;aaaaaaaaaaaa&lt;/code&gt;) is the header&lt;/li&gt; &#xA; &lt;li&gt;The second part (&lt;code&gt;bbbbbbbbbbbb&lt;/code&gt;) is the payload - the good stuff, like who this person is, and their id in our database.&lt;/li&gt; &#xA; &lt;li&gt;The third part (&lt;code&gt;ccccccccccccc&lt;/code&gt;) is the signature. The signature is a hash of the header and the payload. It is hashed with a secret key, that we will provide (and should store in an environment variable using a gem like &lt;a href=&#34;https://github.com/laserlemon/figaro#getting-started&#34;&gt;Figaro&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Head on over to &lt;a href=&#34;http://jwt.io/#debugger&#34;&gt;jwt.io&lt;/a&gt; and see for yourself:&lt;/p&gt; &#xA;&lt;img width=&#34;750&#34; alt=&#34;JWTs&#34; src=&#34;https://curriculum-content.s3.amazonaws.com/phase-4/phase-4-jwt-auth/jwt.png&#34;&gt; &#xA;&lt;h3&gt;Encoding and Decoding JWTs&lt;/h3&gt; &#xA;&lt;p&gt;Since we&#39;ve already added &lt;a href=&#34;https://github.com/jwt/ruby-jwt&#34;&gt;&lt;code&gt;gem jwt&lt;/code&gt;&lt;/a&gt; to our &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/Gemfile&#34;&gt;gemfile&lt;/a&gt;, let&#39;s explore some JWT methods by opening a &lt;code&gt;rails console&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;JWT.encode&lt;/code&gt; takes up to three arguments: a payload to encode, an application secret of the user&#39;s choice, and an optional third that can be used to specify the hashing algorithm used. Typically, we don&#39;t need to show the third. This method returns a JWT as a string.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;JWT.decode&lt;/code&gt; takes three arguments as well: a JWT as a string, an application secret, and (optionally) a hashing algorithm.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#in rails console&#xA;payload = { beef: &#39;steak&#39; }&#xA;&#xA;jwt = JWT.encode(payload, &#39;boeuf&#39;)&#xA;# =&amp;gt; &#34;eyJhbGciOiJIUzI1NiJ9.eyJiZWVmIjoic3RlYWsifQ._IBTHTLGX35ZJWTCcY30tLmwU9arwdpNVxtVU0NpAuI&#34;&#xA;&#xA;decoded_hash = JWT.decode(jwt, &#39;boeuf&#39;)&#xA;# =&amp;gt; [{&#34;beef&#34;=&amp;gt;&#34;steak&#34;}, {&#34;alg&#34;=&amp;gt;&#34;HS256&#34;}]&#xA;&#xA;data = decoded_hash[0]&#xA;# =&amp;gt; {&#34;beef&#34;=&amp;gt;&#34;steak&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building this functionality into our &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/application_controller.rb&#34;&gt;&lt;code&gt;ApplicationController&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Given that many different controllers will need to &lt;a href=&#34;https://en.wikipedia.org/wiki/Authentication&#34;&gt;authenticate&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Authorization&#34;&gt;authorize&lt;/a&gt; users‚Äì‚Äì&lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/api/v1/auth_controller.rb&#34;&gt;&lt;code&gt;AuthController&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/api/v1/users_controller.rb&#34;&gt;&lt;code&gt;UsersController&lt;/code&gt;&lt;/a&gt;, etc ‚Äî it makes sense to lift the functionality of encoding/decoding tokens to our top level &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/application_controller.rb&#34;&gt;&lt;code&gt;ApplicationController&lt;/code&gt;&lt;/a&gt;. Recall that &lt;strong&gt;all&lt;/strong&gt; controllers inherit from &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/application_controller.rb&#34;&gt;&lt;code&gt;ApplicationController&lt;/code&gt;&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::API&#xA;  def encode_token(payload)&#xA;    # payload =&amp;gt; { beef: &#39;steak&#39; }&#xA;    JWT.encode(payload, &#39;my_s3cr3t&#39;)&#xA;    # jwt string: &#34;eyJhbGciOiJIUzI1NiJ9.eyJiZWVmIjoic3RlYWsifQ._IBTHTLGX35ZJWTCcY30tLmwU9arwdpNVxtVU0NpAuI&#34;&#xA;  end&#xA;&#xA;  def decoded_token(token)&#xA;    # token =&amp;gt; &#34;eyJhbGciOiJIUzI1NiJ9.eyJiZWVmIjoic3RlYWsifQ._IBTHTLGX35ZJWTCcY30tLmwU9arwdpNVxtVU0NpAuI&#34;&#xA;&#xA;    JWT.decode(token, &#39;my_s3cr3t&#39;)[0]&#xA;    # JWT.decode =&amp;gt; [{ &#34;beef&#34;=&amp;gt;&#34;steak&#34; }, { &#34;alg&#34;=&amp;gt;&#34;HS256&#34; }]&#xA;    # [0] gives us the payload { &#34;beef&#34;=&amp;gt;&#34;steak&#34; }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://jwt.io/introduction/&#34;&gt;According to the JWT Documentation&lt;/a&gt;: Whenever the user wants to access a protected route or resource, the user agent (browser in our case) should send the JWT, typically in the Authorization header using the Bearer schema. The content of the header should look like the following:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Authorization: Bearer &amp;lt;token&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The corresponding &lt;code&gt;fetch&lt;/code&gt; request might look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fetch(&#34;http://localhost:3000/api/v1/profile&#34;, {&#xA;  method: &#34;GET&#34;,&#xA;  headers: {&#xA;    Authorization: `Bearer &amp;lt;token&amp;gt;`,&#xA;  },&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Knowing this, we can set up our server to anticipate a JWT sent along in request headers, &lt;em&gt;instead&lt;/em&gt; of passing the token directly to &lt;code&gt;ApplicationController#decoded_token&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::API&#xA;  def encode_token(payload)&#xA;    # payload =&amp;gt; { beef: &#39;steak&#39; }&#xA;    JWT.encode(payload, &#39;my_s3cr3t&#39;)&#xA;    # jwt string: &#34;eyJhbGciOiJIUzI1NiJ9.eyJiZWVmIjoic3RlYWsifQ._IBTHTLGX35ZJWTCcY30tLmwU9arwdpNVxtVU0NpAuI&#34;&#xA;  end&#xA;&#xA;  def auth_header&#xA;    # { &#39;Authorization&#39;: &#39;Bearer &amp;lt;token&amp;gt;&#39; }&#xA;    request.headers[&#39;Authorization&#39;]&#xA;  end&#xA;&#xA;  def decoded_token&#xA;    if auth_header&#xA;      token = auth_header.split(&#39; &#39;)[1]&#xA;      # headers: { &#39;Authorization&#39;: &#39;Bearer &amp;lt;token&amp;gt;&#39; }&#xA;      begin&#xA;        JWT.decode(token, &#39;my_s3cr3t&#39;, true, algorithm: &#39;HS256&#39;)&#xA;        # JWT.decode =&amp;gt; [{ &#34;beef&#34;=&amp;gt;&#34;steak&#34; }, { &#34;alg&#34;=&amp;gt;&#34;HS256&#34; }]&#xA;      rescue JWT::DecodeError&#xA;        nil&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A few things to note about the code above:&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://ruby-doc.org/core-2.2.0/doc/syntax/exceptions_rdoc.html&#34;&gt;&lt;code&gt;Begin/Rescue&lt;/code&gt; syntax&lt;/a&gt; allows us to &lt;strong&gt;rescue&lt;/strong&gt; out of an exception in Ruby. Let&#39;s see an example in a &lt;code&gt;rails console&lt;/code&gt;. In the event our server receives and attempts to decode an &lt;strong&gt;invalid token&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# in rails console&#xA;invalid_token = &#34;nnnnnnnooooooootttttt.vvvvvvaaaallliiiiidddddd.jjjjjjjwwwwwttttttt&#34;&#xA;&#xA;JWT.decode(invalid_token, &#39;my_s3cr3t&#39;, true, algorithm: &#39;HS256&#39;)&#xA;&#xA;# =&amp;gt; Traceback (most recent call last):&#xA;#         1: from (irb):6&#xA;# JWT::DecodeError (Invalid segment encoding)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In other words, if our server receives a bad token, this will raise an exception causing a &lt;a href=&#34;http://httpstatusrappers.com/500.html&#34;&gt;500 Internal Server Error&lt;/a&gt;. We can account for this by &lt;strong&gt;rescuing out of this exception&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# in rails console&#xA;invalid_token = &#34;nnnnnnnooooooootttttt.vvvvvvaaaallliiiiidddddd.jjjjjjjwwwwwttttttt&#34;&#xA;&#xA;begin&#xA;  JWT.decode(invalid_token, &#39;my_s3cr3t&#39;, true, algorithm: &#39;HS256&#39;)&#xA;rescue JWT::DecodeError&#xA;  nil&#xA;end&#xA;# =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of crashing our server, we simply return &lt;code&gt;nil&lt;/code&gt; and keep trucking along.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://media.giphy.com/media/3xb5V0fbxHXck/giphy.gif&#34; alt=&#34;keep trucking&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;We can then complete our &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/application_controller.rb&#34;&gt;&lt;code&gt;ApplicationController&lt;/code&gt;&lt;/a&gt; by automatically obtaining the user whenever an authorization header is present:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::API&#xA;&#xA;  def encode_token(payload)&#xA;    # don&#39;t forget to hide your secret in an environment variable&#xA;    JWT.encode(payload, &#39;my_s3cr3t&#39;)&#xA;  end&#xA;&#xA;  def auth_header&#xA;    request.headers[&#39;Authorization&#39;]&#xA;  end&#xA;&#xA;  def decoded_token&#xA;    if auth_header&#xA;      token = auth_header.split(&#39; &#39;)[1]&#xA;      begin&#xA;        JWT.decode(token, &#39;my_s3cr3t&#39;, true, algorithm: &#39;HS256&#39;)&#xA;      rescue JWT::DecodeError&#xA;        nil&#xA;      end&#xA;    end&#xA;  end&#xA;&#xA;  def current_user&#xA;    if decoded_token&#xA;      # decoded_token=&amp;gt; [{&#34;user_id&#34;=&amp;gt;2}, {&#34;alg&#34;=&amp;gt;&#34;HS256&#34;}]&#xA;      # or nil if we can&#39;t decode the token&#xA;      user_id = decoded_token[0][&#39;user_id&#39;]&#xA;      @user = User.find_by(id: user_id)&#xA;    end&#xA;  end&#xA;&#xA;  def logged_in?&#xA;    !!current_user&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Recall that a Ruby object/instance is &#39;truthy&#39;: &lt;code&gt;!!user_instance #=&amp;gt; true&lt;/code&gt; and nil is &#39;false-y&#39;: &lt;code&gt;!!nil #=&amp;gt; false&lt;/code&gt;. Therefore &lt;code&gt;logged_in?&lt;/code&gt; will just return a boolean depending on what our &lt;code&gt;current_user&lt;/code&gt; method returns.&lt;/p&gt; &#xA;&lt;p&gt;Finally, let&#39;s lock down our application to prevent unauthorized access:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::API&#xA;  before_action :authorized&#xA;&#xA;  def encode_token(payload)&#xA;    # should store secret in env variable&#xA;    JWT.encode(payload, &#39;my_s3cr3t&#39;)&#xA;  end&#xA;&#xA;  def auth_header&#xA;    # { Authorization: &#39;Bearer &amp;lt;token&amp;gt;&#39; }&#xA;    request.headers[&#39;Authorization&#39;]&#xA;  end&#xA;&#xA;  def decoded_token&#xA;    if auth_header&#xA;      token = auth_header.split(&#39; &#39;)[1]&#xA;      # header: { &#39;Authorization&#39;: &#39;Bearer &amp;lt;token&amp;gt;&#39; }&#xA;      begin&#xA;        JWT.decode(token, &#39;my_s3cr3t&#39;, true, algorithm: &#39;HS256&#39;)&#xA;      rescue JWT::DecodeError&#xA;        nil&#xA;      end&#xA;    end&#xA;  end&#xA;&#xA;  def current_user&#xA;    if decoded_token&#xA;      user_id = decoded_token[0][&#39;user_id&#39;]&#xA;      @user = User.find_by(id: user_id)&#xA;    end&#xA;  end&#xA;&#xA;  def logged_in?&#xA;    !!current_user&#xA;  end&#xA;&#xA;  def authorized&#xA;    render json: { message: &#39;Please log in&#39; }, status: :unauthorized unless logged_in?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A few things to note about the code above: &lt;code&gt;before_action :authorized&lt;/code&gt; will call the authorized method &lt;strong&gt;before anything else happens in our app&lt;/strong&gt;. This will effectively lock down the entire application. Next we&#39;ll augment our &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/api/v1/users_controller.rb&#34;&gt;&lt;code&gt;UsersController&lt;/code&gt;&lt;/a&gt; and build our &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/api/v1/auth_controller.rb&#34;&gt;&lt;code&gt;AuthController&lt;/code&gt;&lt;/a&gt; to allow signup/login.&lt;/p&gt; &#xA;&lt;h3&gt;Updating the &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/api/v1/users_controller.rb&#34;&gt;UsersController&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s update the &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/api/v1/users_controller.rb&#34;&gt;UsersController&lt;/a&gt; so that it issues a token when users register for our app:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Api::V1::UsersController &amp;lt; ApplicationController&#xA;  skip_before_action :authorized, only: [:create]&#xA;&#xA;  def create&#xA;    @user = User.create(user_params)&#xA;    if @user.valid?&#xA;      @token = encode_token(user_id: @user.id)&#xA;      render json: { user: UserSerializer.new(@user), jwt: @token }, status: :created&#xA;    else&#xA;      render json: { error: &#39;failed to create user&#39; }, status: :unprocessable_entity&#xA;    end&#xA;  end&#xA;&#xA;  private&#xA;&#xA;  def user_params&#xA;    params.require(:user).permit(:username, :password, :bio, :avatar)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We need to make sure to skip the &lt;code&gt;before_action :authorized&lt;/code&gt; coming from &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/application_controller.rb&#34;&gt;ApplicationController&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Api::V1::UsersController &amp;lt; ApplicationController&#xA;  skip_before_action :authorized, only: [:create]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It wouldn&#39;t make sense to ask our users to be logged in before they create an account. This circular logic will make it &lt;strong&gt;impossible&lt;/strong&gt; for users to authenticate into the app. How can a user create an account if our app asks them to be logged in or &lt;code&gt;authorized&lt;/code&gt; to do so? Skipping the before action &#39;unlocks&#39; this portion of our app.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://media.giphy.com/media/l1J9Jzcs9OHXa310k/giphy.gif&#34; alt=&#34;omg&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Try creating a new user again with either &lt;a href=&#34;https://www.getpostman.com/apps&#34;&gt;postman&lt;/a&gt; or fetch and confirm that your server successfully issues a token on signup.&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll also need to store that token somewhere when the response comes back so that you can use it for subsequent requests. &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&#34;&gt;&lt;code&gt;localStorage&lt;/code&gt;&lt;/a&gt; works for this, although there are some &lt;a href=&#34;https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage&#34;&gt;tradeoffs to storing JWTs in browser &lt;code&gt;localStorage&lt;/code&gt;&lt;/a&gt; that are out of the scope of this lesson. Here&#39;s how you could use &lt;code&gt;localStorage&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;fetch(&#34;http://localhost:3000/api/v1/users&#34;, {&#xA;  method: &#34;POST&#34;,&#xA;  headers: {&#xA;    &#34;Content-Type&#34;: &#34;application/json&#34;,&#xA;    Accept: &#34;application/json&#34;,&#xA;  },&#xA;  body: JSON.stringify(newUserData),&#xA;})&#xA;  .then((r) =&amp;gt; r.json())&#xA;  .then((data) =&amp;gt; {&#xA;    // save the token to localStorage for future access&#xA;    localStorage.setItem(&#34;jwt&#34;, data.jwt);&#xA;    // save the user somewhere (in state!) to log the user in&#xA;    setUser(data.user);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://media.giphy.com/media/fSkMuhRxstDi5g5dwo/giphy.gif&#34; alt=&#34;sign me up gif&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Implementing Login&lt;/h3&gt; &#xA;&lt;p&gt;A token should be issued in two different controller actions: &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/api/v1/users_controller.rb&#34;&gt;&lt;code&gt;UsersController#create&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/api/v1/auth_controller.rb&#34;&gt;&lt;code&gt;AuthController#create&lt;/code&gt;&lt;/a&gt;. Think about what these methods are responsible for‚Äì‚Äì&lt;strong&gt;a user signing up for our app for the first time&lt;/strong&gt; and &lt;strong&gt;an already existing user logging back in&lt;/strong&gt;. In both cases, our server needs to issue a new tokenü•á.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ll need to create a new controller to handle login: &lt;code&gt;rails g controller api/v1/auth&lt;/code&gt;. Next, let&#39;s add the following to this newly created &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/api/v1/auth_controller.rb&#34;&gt;AuthController&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Api::V1::AuthController &amp;lt; ApplicationController&#xA;  skip_before_action :authorized, only: [:create]&#xA;&#xA;  def create&#xA;    @user = User.find_by(username: user_login_params[:username])&#xA;    #User#authenticate comes from BCrypt&#xA;    if @user &amp;amp;&amp;amp; @user.authenticate(user_login_params[:password])&#xA;      # encode token comes from ApplicationController&#xA;      token = encode_token({ user_id: @user.id })&#xA;      render json: { user: UserSerializer.new(@user), jwt: token }, status: :accepted&#xA;    else&#xA;      render json: { message: &#39;Invalid username or password&#39; }, status: :unauthorized&#xA;    end&#xA;  end&#xA;&#xA;  private&#xA;&#xA;  def user_login_params&#xA;    # params { user: {username: &#39;Chandler Bing&#39;, password: &#39;hi&#39; } }&#xA;    params.require(:user).permit(:username, :password)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can simply call our &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/application_controller.rb&#34;&gt;&lt;code&gt;ApplicationController#encode_token&lt;/code&gt;&lt;/a&gt; method, passing the found user&#39;s ID in a payload. The newly created JWT can then be passed back along with the user&#39;s data. &lt;strong&gt;The user data can be stored in our application&#39;s state&lt;/strong&gt;, e.g., &lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt; or &lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;, while the token can be stored client-side (similar to our signup feature).&lt;/p&gt; &#xA;&lt;p&gt;A few things to keep in mind about the code above:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;User.find_by({ name: &#39;Chandler Bing&#39; })&lt;/code&gt; will either return a user instance if that user can be found &lt;strong&gt;OR&lt;/strong&gt; it will return &lt;code&gt;nil&lt;/code&gt; if that user is not found.&lt;/li&gt; &#xA; &lt;li&gt;In the event that the user is not found, &lt;code&gt;user = User.find_by(username: params[:username])&lt;/code&gt; will evaluate to &lt;code&gt;nil&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Can we call &lt;code&gt;.authenticate&lt;/code&gt; on &lt;code&gt;nil&lt;/code&gt;? NO!! &lt;code&gt;NoMethodError (undefined method &#39;authenticate&#39; for nil:NilClass)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Ruby, however, is &lt;strong&gt;lazy&lt;/strong&gt;. If Ruby encounters &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, both statements in the expression must evaluate to true. If the statement on the left side evaluates to false, Ruby will &lt;strong&gt;not even look at the statement on the right&lt;/strong&gt;. Let&#39;s see an example:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# in irb or a rails console&#xA;true &amp;amp;&amp;amp; true&#xA;# =&amp;gt; true&#xA;&#xA;true &amp;amp;&amp;amp; false&#xA;# =&amp;gt; false&#xA;&#xA;&#xA;true &amp;amp;&amp;amp; not_a_variable&#xA;# =&amp;gt; NameError (undefined local variable or method `not_a_variable` for main:Object)&#xA;&#xA;false &amp;amp;&amp;amp; not_a_variable&#xA;# =&amp;gt; false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s take another look at our previous example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@user = User.find_by(username: params[:username])&#xA;if @user &amp;amp;&amp;amp; @user.authenticate(params[:password])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;@user&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, which is false-y, &lt;strong&gt;ruby will not even attempt to call &lt;code&gt;@user.authenticate&lt;/code&gt;&lt;/strong&gt;. Without this catch, we&#39;d get a &lt;code&gt;NoMethodError (undefined method &#39;authenticate&#39; for nil:NilClass)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Again, the client should be sending a JWT along with every authenticated request. Refer to this diagram from &lt;a href=&#34;https://www.vaadata.com/blog/jwt-tokens-and-security-working-principles-and-use-cases/&#34;&gt;Vaadata&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://www.vaadata.com/blog/wp-content/uploads/2016/12/JWT_tokens_EN.png&#34; alt=&#34;Vaadata article on token auth&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A sample request might look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const token = localStorage.getItem(&#34;jwt&#34;);&#xA;&#xA;fetch(&#34;http://localhost:3000/api/v1/profile&#34;, {&#xA;  method: &#34;GET&#34;,&#xA;  headers: {&#xA;    Authorization: `Bearer ${token}`,&#xA;  },&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So, let&#39;s update our &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/api/v1/users_controller.rb&#34;&gt;&lt;code&gt;UsersController&lt;/code&gt;&lt;/a&gt; so that an authenticated user can access their profile information:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Api::V1::UsersController &amp;lt; ApplicationController&#xA;  skip_before_action :authorized, only: [:create]&#xA;&#xA;  def profile&#xA;    render json: { user: UserSerializer.new(current_user) }, status: :accepted&#xA;  end&#xA;&#xA;  def create&#xA;    @user = User.create(user_params)&#xA;    if @user.valid?&#xA;      @token = encode_token({ user_id: @user.id })&#xA;      render json: { user: UserSerializer.new(@user), jwt: @token }, status: :created&#xA;    else&#xA;      render json: { error: &#39;failed to create user&#39; }, status: :unprocessable_entity&#xA;    end&#xA;  end&#xA;&#xA;  private&#xA;&#xA;  def user_params&#xA;    params.require(:user).permit(:username, :password, :bio, :avatar)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One final note about the snippet above: &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/application_controller.rb&#34;&gt;&lt;code&gt;ApplicationController&lt;/code&gt;&lt;/a&gt; calls &lt;code&gt;authorized&lt;/code&gt; &lt;strong&gt;before any other controller methods are called&lt;/strong&gt;. If authorization fails, our server will never call &lt;a href=&#34;https://raw.githubusercontent.com/learn-co-curriculum/phase-4-jwt-auth/master/server/app/controllers/api/v1/users_controller.rb&#34;&gt;&lt;code&gt;UsersController#profile&lt;/code&gt;&lt;/a&gt; and will instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;render json: { message: &#39;Please log in&#39; }, status: :unauthorized&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it! You should now have a server set up to create a token when a user logs in or signs up, and authenticate the user using that token for future requests.&lt;/p&gt; &#xA;&lt;p&gt;The frontend implementation is up to you. Remember, the key to using JWT for authentication is to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Store the token in the browser when the user logs in (such as localStorage)&lt;/li&gt; &#xA; &lt;li&gt;Send the token along with every request the user makes using an &lt;code&gt;Authentication&lt;/code&gt; header&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;External Resources&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTPS&#34;&gt;HTTPS Wikipedia Article&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage&#34;&gt;Storing JWTs in Cookies vs HTML5 localStorage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/35291573/csrf-protection-with-json-web-tokens/35347022#35347022&#34;&gt;StackOverflow Post on Cookies vs localStorage for Storing Tokens&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/learn-co-curriculum/mod3-project-week-setup-example&#34;&gt;Mod3 API Setup Guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cyu/rack-cors&#34;&gt;rack-cors gem&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&#34;&gt;MDN article on CORS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/codahale/bcrypt-ruby&#34;&gt;Bcrypt gem&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/codahale/bcrypt-ruby/raw/master/lib/bcrypt/password.rb#L23&#34;&gt;Bcrypt::Password source code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Salt_(cryptography)&#34;&gt;What is a Salt in Cryptography&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cryptographic_hash_function&#34;&gt;What is a Cryptographic Hash Function&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html#method-i-has_secure_password&#34;&gt;ActiveModel has_secure_password docs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.mozilla.org/webdev/2012/06/08/lets-talk-about-password-storage/&#34;&gt;Mozilla Blog Post on Storing Passwords in a Database&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rails-api/active_model_serializers&#34;&gt;ActiveModelSerializers gem&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://guides.rubyonrails.org/active_record_validations.html&#34;&gt;ActiveRecord Validations Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.sitepoint.com/active-model-serializers-rails-and-json-oh-my/&#34;&gt;SitePoint Article on ActiveModelSerializers in Rails&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.getpostman.com/apps&#34;&gt;Postman App for making HTTP requests&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://jwt.io/introduction/&#34;&gt;JWT Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jwt/ruby-jwt&#34;&gt;JWT Ruby Gem on GitHub&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.angular-university.io/angular-jwt/&#34;&gt;JWT in Depth&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://scotch.io/tutorials/the-ins-and-outs-of-token-based-authentication&#34;&gt;Scotch.io: The Ins and Outs of Token Based Authentication&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Authentication&#34;&gt;Authentication&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Authorization&#34;&gt;Authorization&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/6556522/authentication-versus-authorization&#34;&gt;Authentication vs Authorization&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/laserlemon/figaro#getting-started&#34;&gt;Figaro Gem for hiding secrets in your app&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ruby-doc.org/core-2.2.0/doc/syntax/exceptions_rdoc.html&#34;&gt;Ruby Begin Rescue Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://httpstatusrappers.com&#34;&gt;HTTP Status Rappers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Status&#34;&gt;MDN Article on HTTP Status Codes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gist.github.com/mlanett/a31c340b132ddefa9cca&#34;&gt;Rails Status Code Symbols Cheat Sheet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux Documentation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- Markdown Variables --&gt;</summary>
  </entry>
</feed>