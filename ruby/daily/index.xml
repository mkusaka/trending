<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-06T01:41:09Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>discourse/discourse-ai</title>
    <updated>2023-11-06T01:41:09Z</updated>
    <id>tag:github.com,2023-11-06:/discourse/discourse-ai</id>
    <link href="https://github.com/discourse/discourse-ai" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;strong&gt;Discourse AI&lt;/strong&gt; Plugin&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Plugin Summary&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;For more information, please see: &lt;a href=&#34;https://meta.discourse.org/t/discourse-ai/259214?u=falco&#34;&gt;https://meta.discourse.org/t/discourse-ai/259214?u=falco&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Shopify/limiter</title>
    <updated>2023-11-06T01:41:09Z</updated>
    <id>tag:github.com,2023-11-06:/Shopify/limiter</id>
    <link href="https://github.com/Shopify/limiter" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple Ruby rate limiting mechanism.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Limiter &lt;a href=&#34;https://github.com/Shopify/limiter/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/Shopify/limiter/actions/workflows/ci.yml/badge.svg?branch=main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;This gem implements a simple mechanism to throttle or rate-limit operations in Ruby.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;ruby-limiter&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bundle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or install it yourself as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install ruby-limiter&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Basic Usage&lt;/h3&gt; &#xA;&lt;p&gt;To rate limit calling an instance method, a mixin is provided. Simply specify the method to be limited, and the maximum rate that the method can be called. This rate is (by default) a number of requests per minute.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Widget&#xA;  extend Limiter::Mixin&#xA;&#xA;  # limit the rate we can call tick to 300 times per minute&#xA;  # when the rate has been exceeded, a call to tick will block until the rate limit would not be exceeded&#xA;  limit_method :tick, rate: 300&#xA;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To specify the rate in terms of an interval shorter (or longer) than 1 minute, an optional &lt;code&gt;interval&lt;/code&gt; parameter can be provided to specify the throttling period in seconds.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Widget&#xA;  extend Limiter::Mixin&#xA;&#xA;  # limit the rate we can call tick to 5 times per second&#xA;  # when the rate has been exceeded, a call to tick will block until the rate limit would not be exceeded&#xA;  # and the provided block will be executed&#xA;  limit_method(:tick, rate: 5, interval: 1) do&#xA;    puts &#39;Limit reached&#39;&#xA;  end&#xA;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Load balancing&lt;/h4&gt; &#xA;&lt;p&gt;By default all calls to the &lt;code&gt;limit_method&lt;/code&gt; will be bursted, e.g. as quick as possible, until the rate is exceeded. Then we wait for the remainder of the interval to continue. To even out the burst, an optional &lt;code&gt;balanced&lt;/code&gt; parameter can be provided to enable interleaving between the method calls, e.g: &lt;code&gt;interleave = interval / size&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  ...&#xA;  limit_method :tick, rate: 60, balanced: true&#xA;  ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example: with an interval of 60 seconds and a rate of 60:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;balanced: false&lt;/code&gt; : As quickly as possible we call the method 60 times, then we wait for the remainder of the time.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;balanced: true&lt;/code&gt; : We interleave each call with 1 second so we call this method every second.&lt;/p&gt; &#xA;&lt;h4&gt;Resetting a rate-limited method&lt;/h4&gt; &#xA;&lt;p&gt;There are times when it may be necessary to reset the rate limiter for a method, for example during testing.&lt;/p&gt; &#xA;&lt;p&gt;This can be done by calling &lt;code&gt;reset_method_limit!&lt;/code&gt; on the class, where &#34;method&#34; is replaced with the name of the method being limited.&lt;/p&gt; &#xA;&lt;p&gt;Given the example above, the following would reset the rate limit for the &lt;code&gt;tick&lt;/code&gt; method during test setup:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class WidgetTest &amp;lt; Minitest::Test&#xA;  def setup&#xA;    Widget.reset_tick_limit!&#xA;  end&#xA;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Advanced Usage&lt;/h3&gt; &#xA;&lt;p&gt;In cases where the mixin is not appropriate the &lt;code&gt;RateQueue&lt;/code&gt; class can be used directly. As in the mixin examples above, the &lt;code&gt;interval&lt;/code&gt; parameter is optional (and defaults to 1 minute). It is also possible to provide the block to &lt;code&gt;RateQueue&lt;/code&gt;, which will be executed on each limit hit (useful for metrics).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Widget&#xA;  def initialize&#xA;    # create a rate-limited queue which allows 10000 operations per hour&#xA;    @queue = Limiter::RateQueue.new(10000, interval: 3600) do&#xA;      puts &#34;Hit the limit, waiting&#34;&#xA;    end&#xA;  end&#xA;&#xA;  def tick&#xA;    # this operation will block until less than 10000 shift calls have been made within the last hour&#xA;    @queue.shift&#xA;    # do something&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Resetting a RateQueue&lt;/h4&gt; &#xA;&lt;p&gt;In some circumstances it may be desirable to reset a rate queue, for example after invoking an API that resets an external rate limit.&lt;/p&gt; &#xA;&lt;p&gt;This can be done by calling &lt;code&gt;reset&lt;/code&gt; on the queue.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  ...&#xA;  @queue.reset&#xA;  ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;After checking out the repo, run &lt;code&gt;bin/setup&lt;/code&gt; to install dependencies. Then, run &lt;code&gt;rake test&lt;/code&gt; to run the tests. You can also run &lt;code&gt;bin/console&lt;/code&gt; for an interactive prompt that will allow you to experiment.&lt;/p&gt; &#xA;&lt;p&gt;To install this gem onto your local machine, run &lt;code&gt;bundle exec rake install&lt;/code&gt;. To release a new version, update the version number in &lt;code&gt;version.rb&lt;/code&gt;, and then run &lt;code&gt;bundle exec rake release&lt;/code&gt;, which will create a git tag for the version, push git commits and tags, and push the &lt;code&gt;.gem&lt;/code&gt; file to &lt;a href=&#34;https://rubygems.org&#34;&gt;rubygems.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Bug reports and pull requests are welcome on GitHub at &lt;a href=&#34;https://github.com/Shopify/limiter&#34;&gt;https://github.com/Shopify/limiter&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>