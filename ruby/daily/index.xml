<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-14T01:42:05Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>wouterken/crystalruby</title>
    <updated>2024-04-14T01:42:05Z</updated>
    <id>tag:github.com,2024-04-14:/wouterken/crystalruby</id>
    <link href="https://github.com/wouterken/crystalruby" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Embed Crystal code directly in Ruby&lt;/p&gt;&lt;hr&gt;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wouterken/crystalruby/main/logo.png&#34; alt=&#34;logo&#34; width=&#34;150&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt; &lt;h1 align=&#34;center&#34;&gt;crystalruby&lt;/h1&gt; &lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://rubygems.org/gems/crystalruby&#34;&gt; &lt;img alt=&#34;GEM Version&#34; src=&#34;https://img.shields.io/gem/v/crystalruby?color=168AFE&amp;amp;include_prereleases&amp;amp;logo=ruby&amp;amp;logoColor=FE1616&#34;&gt; &lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://rubygems.org/gems/crystalruby&#34;&gt; &lt;img alt=&#34;GEM Downloads&#34; src=&#34;https://img.shields.io/gem/dt/crystalruby?color=168AFE&amp;amp;logo=ruby&amp;amp;logoColor=FE1616&#34;&gt; &lt;/a&gt; &lt;/p&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;code&gt;crystalruby&lt;/code&gt; is a gem that allows you to write Crystal code, inlined in Ruby. All you need is a modern crystal compiler installed on your system.&lt;/p&gt; &#xA;&lt;p&gt;You can then turn simple methods into Crystal methods as easily as demonstrated below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;crystalruby&#39;&#xA;&#xA;module MyTestModule&#xA;  # The below method will be replaced by a compiled Crystal version&#xA;  # linked using FFI.&#xA;  crystalize [a: :int, b: :int] =&amp;gt; :int&#xA;  def add(a, b)&#xA;    a + b&#xA;  end&#xA;end&#xA;&#xA;# This method is run in Crystal, not Ruby!&#xA;MyTestModule.add(1, 2) # =&amp;gt; 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With as small a change as this, you should be able to see a significant increase in performance for some Ruby code. E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#xA;require &#39;crystalruby&#39;&#xA;require &#39;benchmark&#39;&#xA;&#xA;module Fibonnaci&#xA;  crystalize [n: :int32] =&amp;gt; :int32&#xA;  def fib_cr(n)&#xA;    a = 0&#xA;    b = 1&#xA;    n.times { a, b = b, a + b }&#xA;    a&#xA;  end&#xA;&#xA;  module_function&#xA;&#xA;  def fib_rb(n)&#xA;    a = 0&#xA;    b = 1&#xA;    n.times { a, b = b, a + b }&#xA;    a&#xA;  end&#xA;end&#xA;&#xA;puts(Benchmark.realtime { 1_000_000.times { Fibonnaci.fib_rb(30) } })&#xA;puts(Benchmark.realtime { 1_000_000.times { Fibonnaci.fib_cr(30) } })&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;3.193121999996947 # Ruby&#xA;0.29086600001028273 # Crystal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: The first run of the Crystal code will be slower, as it needs to compile the code first. The subsequent runs will be much faster.&lt;/p&gt; &#xA;&lt;p&gt;You can call embedded crystal code, from within other embedded crystal code. E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module Cache&#xA;&#xA;  crystalize [key: :string] =&amp;gt; :string&#xA;  def redis_get(key)&#xA;    rds = Redis::Client.new&#xA;    value = rds.get(key).to_s&#xA;  end&#xA;&#xA;  crystalize [key: :string, value: :string] =&amp;gt; :string&#xA;  def redis_set_and_return(key, value)&#xA;    redis = Redis::Client.new&#xA;    redis.set(key, value)&#xA;    Cache.redis_get(key)&#xA;  end&#xA;end&#xA;Cache.redis_set_and_return(&#39;test&#39;, &#39;abc&#39;)&#xA;puts Cache.redis_get(&#39;test&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ abc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Syntax&lt;/h2&gt; &#xA;&lt;h3&gt;Ruby Compatible&lt;/h3&gt; &#xA;&lt;p&gt;Where the Crystal syntax is also valid Ruby syntax, you can just write Ruby. It&#39;ll be compiled as Crystal automatically.&lt;/p&gt; &#xA;&lt;p&gt;E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;crystalize [a: :int, b: :int] =&amp;gt; :int&#xA;def add(a, b)&#xA;  puts &#34;Adding #{a} and #{b}&#34;&#xA;  a + b&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Crystal Compatible&lt;/h3&gt; &#xA;&lt;p&gt;Some Crystal syntax is not valid Ruby, for methods of this form, we need to define our functions using a :raw parameter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;crystalize :raw, [a: :int, b: :int] =&amp;gt; :int&#xA;def add(a, b)&#xA;  &amp;lt;&amp;lt;~CRYSTAL&#xA;    c = 0_u64&#xA;    a + b + c&#xA;  CRYSTAL&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;The below is a stand-alone one-file script that allows you to quickly see crystalruby in action.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# crystalrubytest.rb&#xA;require &#39;bundler/inline&#39;&#xA;&#xA;gemfile do&#xA;  source &#39;https://rubygems.org&#39;&#xA;  gem &#39;crystalruby&#39;&#xA;end&#xA;&#xA;require &#39;crystalruby&#39;&#xA;&#xA;module Adder&#xA;  crystalize [a: :int, b: :int] =&amp;gt; :int&#xA;  def add(a, b)&#xA;    a + b&#xA;  end&#xA;end&#xA;&#xA;puts Adder.add(1, 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Types&lt;/h2&gt; &#xA;&lt;p&gt;Currently primitive types are supported. Composite types are supported using JSON serialization. C-Structures are a WIP. To see the list of currently supported primitive type mappings of FFI types to crystal types, you can check: &lt;code&gt;CrystalRuby::Typemaps::CRYSTAL_TYPE_MAP&lt;/code&gt; E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CrystalRuby::Typemaps::CRYSTAL_TYPE_MAP&#xA;=&amp;gt; {:char=&amp;gt;&#34;Int8&#34;,&#xA; :uchar=&amp;gt;&#34;UInt8&#34;,&#xA; :int8=&amp;gt;&#34;Int8&#34;,&#xA; :uint8=&amp;gt;&#34;UInt8&#34;,&#xA; :short=&amp;gt;&#34;Int16&#34;,&#xA; :ushort=&amp;gt;&#34;UInt16&#34;,&#xA; :int16=&amp;gt;&#34;Int16&#34;,&#xA; :uint16=&amp;gt;&#34;UInt16&#34;,&#xA; :int=&amp;gt;&#34;Int32&#34;,&#xA; :uint=&amp;gt;&#34;UInt32&#34;,&#xA; :int32=&amp;gt;&#34;Int32&#34;,&#xA; :uint32=&amp;gt;&#34;UInt32&#34;,&#xA; :long=&amp;gt;&#34;Int32 | Int64&#34;,&#xA; :ulong=&amp;gt;&#34;UInt32 | UInt64&#34;,&#xA; :int64=&amp;gt;&#34;Int64&#34;,&#xA; :uint64=&amp;gt;&#34;UInt64&#34;,&#xA; :long_long=&amp;gt;&#34;Int64&#34;,&#xA; :ulong_long=&amp;gt;&#34;UInt64&#34;,&#xA; :float=&amp;gt;&#34;Float32&#34;,&#xA; :double=&amp;gt;&#34;Float64&#34;,&#xA; :bool=&amp;gt;&#34;Bool&#34;,&#xA; :void=&amp;gt;&#34;Void&#34;,&#xA; :string=&amp;gt;&#34;String&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Composite Types (using JSON serialization)&lt;/h2&gt; &#xA;&lt;p&gt;The library allows you to pass complex nested structures using JSON as a serialization format. The type signatures for composite types can use ordinary Crystal Type syntax. Type conversion is applied automatically.&lt;/p&gt; &#xA;&lt;p&gt;E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;crystalize [a: json{ Int64 | Float64 | Nil }, b: json{ String | Array(Bool)  } ] =&amp;gt; :void&#xA;def complex_argument_types&#xA;  puts &#34;Got #{a} and #{b}&#34;&#xA;end&#xA;&#xA;crystalize [] =&amp;gt; json{ Int32 | String | Hash(String, Array(NamedTuple(hello: Int32)) | Time)}&#xA;def complex_return_type&#xA;  return {&#xA;    &#34;hello&#34; =&amp;gt; [&#xA;      {&#xA;        hello: 1,&#xA;      },&#xA;    ],&#xA;    &#34;world&#34; =&amp;gt; Time.utc&#xA;  }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type signatures validations are applied to both arguments and return types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[1] pry(main)&amp;gt; Foo.complex_argument_types(nil, &#34;test&#34;)&#xA;Got  and test&#xA;=&amp;gt; nil&#xA;&#xA;[2] pry(main)&amp;gt; Foo.complex_argument_types(88, [true, false, true])&#xA;Got 88 and [true, false, true]&#xA;=&amp;gt; nil&#xA;&#xA;[3] pry(main)&amp;gt; Foo.complex_argument_types(88, [true, false, 88])&#xA;ArgumentError: Expected Bool but was Int at line 1, column 15&#xA;from crystalruby.rb:303:in `block in compile!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Named Types&lt;/h2&gt; &#xA;&lt;p&gt;You can name your types, for more succinct method signatures. The type names will be mirrored in the generated Crystal code. E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#xA;IntArrOrBoolArr = crtype{ Array(Bool) | Array(Int32) }&#xA;&#xA;crystalize [a: IntArrOrBoolArr] =&amp;gt; json{ IntArrOrBoolArr }&#xA;def method_with_named_types(a)&#xA;  return a&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Exceptions&lt;/h2&gt; &#xA;&lt;p&gt;Exceptions thrown in Crystal code can be caught in Ruby.&lt;/p&gt; &#xA;&lt;h2&gt;Installing shards and writing non-embedded Crystal code&lt;/h2&gt; &#xA;&lt;p&gt;You can use any Crystal shards and write ordinary, stand-alone Crystal code.&lt;/p&gt; &#xA;&lt;p&gt;The default entry point for the crystal shared library generated by the gem is inside &lt;code&gt;./crystalruby/src/main.cr&lt;/code&gt;. This file is not automatically overridden by the gem, and is safe for you to define and require new files relative to this location to write additional stand-alone Crystal code.&lt;/p&gt; &#xA;&lt;p&gt;You can define shards inside &lt;code&gt;./crystalruby/src/shard.yml&lt;/code&gt; Run the below to install new shards&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec crystalruby install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Remember to require these installed shards after installing them. E.g. inside &lt;code&gt;./crystalruby/src/main.cr&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can edit the default paths for crystal source and library files from within the &lt;code&gt;./crystalruby.yaml&lt;/code&gt; config file.&lt;/p&gt; &#xA;&lt;h2&gt;Wrapping Crystal code in Ruby&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes you may want to wrap a Crystal method in Ruby, so that you can use Ruby before the Crystal code to prepare arguments, or after the Crystal code, to apply transformations to the result. A real-life example of this might be an ActionController method, where you might want to use Ruby to parse the request, perform auth etc., and then use Crystal to perform some heavy computation, before returning the result from Ruby. To do this, you simply pass a block to the &lt;code&gt;crystalize&lt;/code&gt; method, which will serve as the Ruby entry point to the function. From within this block, you can invoke &lt;code&gt;super&lt;/code&gt; to call the Crystal method, and then apply any Ruby transformations to the result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module MyModule&#xA;  crystalize [a: :int32, b: :int32] =&amp;gt; :int32 do |a, b|&#xA;    # In this example, we perform automated conversion to integers inside Ruby.&#xA;    # Then add 1 to the result of the Crystal method.&#xA;    result = super(a.to_i, b.to_i)&#xA;    result + 1&#xA;  end&#xA;  def add(a, b)&#xA;    a + b&#xA;  end&#xA;end&#xA;&#xA;MyModule.add(&#34;1&#34;, &#34;2&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Inline Chunks&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;crystalruby&lt;/code&gt; also allows you to write inline Crystal code that does not require binding to Ruby. This can be useful for e.g. performing setup or teardown operations.&lt;/p&gt; &#xA;&lt;p&gt;Follow these steps for a toy example of how we can use crystalized ruby and inline chunks to expose the &lt;a href=&#34;https://github.com/stefanwille/crystal-redis&#34;&gt;crystal-redis&lt;/a&gt; library to Ruby.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Start our toy project&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir crystalredis&#xA;cd crystalredis&#xA;bundle init&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Add dependencies to our Gemfile and run &lt;code&gt;bundle install&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# frozen_string_literal: true&#xA;&#xA;source &#34;https://rubygems.org&#34;&#xA;&#xA;gem &#39;crystalruby&#39;&#xA;&#xA;# Let&#39;s see if performance is comparable to that of the redis gem.&#xA;gem &#39;benchmark-ips&#39;&#xA;gem &#39;redis&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Write our Redis client&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Filename: crystalredis.rb&#xA;require &#39;crystalruby&#39;&#xA;&#xA;module CrystalRedis&#xA;&#xA;  crystal do&#xA;    CLIENT = Redis.new&#xA;    def self.client&#xA;      CLIENT&#xA;    end&#xA;  end&#xA;&#xA;  crystalize [key: :string, value: :string] =&amp;gt; :void&#xA;  def set(key, value)&#xA;    client.set(key, value)&#xA;  end&#xA;&#xA;  crystalize [key: :string] =&amp;gt; :string&#xA;  def get(key)&#xA;    client.get(key).to_s&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Load the modules (without running them) to generate our Crystal project skeleton.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec ruby crystalredis.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;Add the missing Redis dependency to our shard.yml&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# filename:  crystalruby/src/shard.yml&#xA;dependencies:&#xA;  redis:&#xA;    github: stefanwille/crystal-redis&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# filename: main.cr&#xA;require &#34;redis&#34;&#xA;require &#34;./generated/index&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec crystalruby install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;Compile and benchmark our new module in Ruby&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Filename: benchmark.rb&#xA;# Let&#39;s compare the performance of our CrystalRedis module to the Ruby Redis gem&#xA;require_relative &#34;crystalredis&#34;&#xA;require &#39;redis&#39;&#xA;require &#39;benchmark/ips&#39;&#xA;&#xA;Benchmark.ips do |x|&#xA;  rbredis = Redis.new&#xA;&#xA;  x.report(:crredis) do&#xA;    CrystalRedis.set(&#34;hello&#34;, &#34;world&#34;)&#xA;    CrystalRedis.get(&#34;hello&#34;)&#xA;  end&#xA;&#xA;  x.report(:rbredis) do&#xA;    rbredis.set(&#34;hello&#34;, &#34;world&#34;)&#xA;    rbredis.get(&#34;hello&#34;)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;7&#34;&gt; &#xA; &lt;li&gt;Run the benchmark&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle exec ruby benchmark.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Output&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&#xA;#crystalredis wins! (Warm up during first run will be slow for crredis, due to first compilation)&#xA;&#xA;ruby 3.3.0 (2023-12-25 revision 5124f9ac75) [arm64-darwin22]&#xA;Warming up --------------------------------------&#xA;             crredis     1.946k i/100ms&#xA;             rbredis     1.749k i/100ms&#xA;Calculating -------------------------------------&#xA;             crredis     22.319k (± 1.7%) i/s -    112.868k in   5.058448s&#xA;             rbredis     16.861k (± 9.1%) i/s -     83.952k in   5.024941s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Release Builds&lt;/h2&gt; &#xA;&lt;p&gt;You can control whether CrystalRuby builds in debug or release mode by setting following config option&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CrystalRuby.configure do |config|&#xA;  config.debug = false&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, Crystal code is only JIT compiled. In production, you likely want to compile the Crystal code ahead of time. To do this, you can create a dedicated file which&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Preloads all files Ruby code with embedded crystal&lt;/li&gt; &#xA; &lt;li&gt;Forces compilation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# E.g. crystalruby_build.rb&#xA;require &#34;crystalruby&#34;&#xA;&#xA;CrystalRuby.configure do |config|&#xA;  config.debug = false&#xA;end&#xA;&#xA;require_relative &#34;foo&#34;&#xA;require_relative &#34;bar&#34;&#xA;&#xA;CrystalRuby.compile!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can run this file as part of your build step, to ensure all Crystal code is compiled ahead of time.&lt;/p&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;The logic to detect when to JIT recompile is not robust and can end up in an inconsistent state. To remedy this it is useful to clear out all generated assets and build from scratch.&lt;/p&gt; &#xA;&lt;p&gt;To do this execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec crystalruby clean&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Design Goals&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;crystalruby&lt;/code&gt;&#39;s primary purpose is to provide ergonomic access to Crystal from Ruby, over FFI. For simple usage, advanced knowledge of Crystal should not be required.&lt;/p&gt; &#xA;&lt;p&gt;However, the abstraction it provides should remain simple, transparent, and easy to hack on and it should not preclude users from supplementing its capabilities with a more direct integration using ffi primtives.&lt;/p&gt; &#xA;&lt;p&gt;It should support escape hatches to allow it to coexist with code that performs a more direct &lt;a href=&#34;https://github.com/ffi/ffi&#34;&gt;FFI&lt;/a&gt; integration to implement advanced functionality not supported by &lt;code&gt;crystalruby&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The library is currently in its infancy. Planned additions are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simple mixin/concern that utilises &lt;code&gt;FFI::Struct&lt;/code&gt; for bi-directional passing of Ruby objects and Crystal objects (by value).&lt;/li&gt; &#xA; &lt;li&gt;Install command to generate a sample build script, and supports build command (which simply verifies then invokes this script)&lt;/li&gt; &#xA; &lt;li&gt;Call Ruby from Crystal using FFI callbacks (implement &lt;code&gt;.expose_to_crystal&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Support long-lived synchronized objects (through use of synchronized memory arena to prevent GC).&lt;/li&gt; &#xA; &lt;li&gt;Support for passing &lt;code&gt;crystalruby&lt;/code&gt; types by reference (need to contend with GC).&lt;/li&gt; &#xA; &lt;li&gt;Explore mechanisms to safely expose true parallelism using &lt;a href=&#34;https://github.com/ffi/ffi/wiki/Ractors&#34;&gt;FFI over Ractors&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;To get started, add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;crystalruby&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or install it yourself as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ gem install crystalruby&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;crystalruby&lt;/code&gt; supports some basic configuration options, which can be specified inside a crystalruby.yaml file in the root of your project. You can run &lt;code&gt;crystalruby init&lt;/code&gt; to generate a configuration file with sane defaults.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;crystalruby init&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;crystal_src_dir: &#34;./crystalruby/src&#34;&#xA;crystal_lib_dir: &#34;./crystalruby/lib&#34;&#xA;crystal_main_file: &#34;main.cr&#34;&#xA;crystal_lib_name: &#34;crlib&#34;&#xA;crystal_codegen_dir: &#34;generated&#34;&#xA;debug: true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, these can be set programmatically:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CrystalRuby.configure do |config|&#xA;  config.crystal_src_dir = &#34;./crystalruby/src&#34;&#xA;  config.crystal_lib_dir = &#34;./crystalruby/lib&#34;&#xA;  config.crystal_main_file = &#34;main.cr&#34;&#xA;  config.crystal_lib_name = &#34;crlib&#34;&#xA;  config.crystal_codegen_dir = &#34;generated&#34;&#xA;  config.debug = true&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;After checking out the repo, run &lt;code&gt;bin/setup&lt;/code&gt; to install dependencies. Then, run &lt;code&gt;rake test&lt;/code&gt; to run the tests. You can also run &lt;code&gt;bin/console&lt;/code&gt; for an interactive prompt that will allow you to experiment.&lt;/p&gt; &#xA;&lt;p&gt;To install this gem onto your local machine, run &lt;code&gt;bundle exec rake install&lt;/code&gt;. To release a new version, update the version number in &lt;code&gt;version.rb&lt;/code&gt;, and then run &lt;code&gt;bundle exec rake release&lt;/code&gt;, which will create a git tag for the version, push git commits and the created tag, and push the &lt;code&gt;.gem&lt;/code&gt; file to &lt;a href=&#34;https://rubygems.org&#34;&gt;rubygems.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Bug reports and pull requests are welcome on GitHub at &lt;a href=&#34;https://github.com/wouterken/crystalruby&#34;&gt;https://github.com/wouterken/crystalruby&lt;/a&gt;. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the &lt;a href=&#34;https://github.com/wouterken/crystalruby/raw/master/CODE_OF_CONDUCT.md&#34;&gt;code of conduct&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;Everyone interacting in the &lt;code&gt;crystalruby&lt;/code&gt; project&#39;s codebases, issue trackers, chat rooms and mailing lists is expected to follow the &lt;a href=&#34;https://github.com/wouterken/crystalruby/raw/master/CODE_OF_CONDUCT.md&#34;&gt;code of conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>