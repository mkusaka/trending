<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-08T01:42:03Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ruby/irb</title>
    <updated>2024-01-08T01:42:03Z</updated>
    <id>tag:github.com,2024-01-08:/ruby/irb</id>
    <link href="https://github.com/ruby/irb" rel="alternate"></link>
    <summary type="html">&lt;p&gt;interactive Ruby&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;IRB&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://badge.fury.io/rb/irb&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/irb.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ruby/irb/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/ruby/irb/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;IRB stands for &#34;interactive Ruby&#34; and is a tool to interactively execute Ruby expressions read from the standard input.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;irb&lt;/code&gt; command from your shell will start the interpreter.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#the-irb-executable&#34;&gt;The &lt;code&gt;irb&lt;/code&gt; Executable&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#the-bindingirb-breakpoint&#34;&gt;The &lt;code&gt;binding.irb&lt;/code&gt; Breakpoint&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#commands&#34;&gt;Commands&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#debugging-with-irb&#34;&gt;Debugging with IRB&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#more-about-debuggem&#34;&gt;More about &lt;code&gt;debug.gem&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#advantages-over-debuggems-console&#34;&gt;Advantages Over &lt;code&gt;debug.gem&lt;/code&gt;&#39;s Console&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#type-based-completion&#34;&gt;Type Based Completion&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#how-to-enable-irbtypecompletor&#34;&gt;How to Enable IRB::TypeCompletor&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#advantage-over-default-irbregexpcompletor&#34;&gt;Advantage over Default IRB::RegexpCompletor&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#difference-between-steeps-completion&#34;&gt;Difference between Steep&#39;s Completion&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#configuration&#34;&gt;Configuration&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#environment-variables&#34;&gt;Environment Variables&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#extending-irb&#34;&gt;Extending IRB&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#development&#34;&gt;Development&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#releasing&#34;&gt;Releasing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruby/irb/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;IRB is a default gem of Ruby so you shouldn&#39;t need to install it separately.&lt;/p&gt; &#xA; &lt;p&gt;But if you&#39;re using Ruby 2.6 or later and want to upgrade/install a specific version of IRB, please follow these steps.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To install it with &lt;code&gt;bundler&lt;/code&gt;, add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;irb&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ bundle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or install it directly with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ gem install irb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;We&#39;re working hard to match Pry&#39;s variety of powerful features in IRB, and you can track our progress or find contribution ideas in &lt;a href=&#34;https://github.com/ruby/irb/raw/master/COMPARED_WITH_PRY.md&#34;&gt;this document&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;The &lt;code&gt;irb&lt;/code&gt; Executable&lt;/h3&gt; &#xA;&lt;p&gt;You can start a fresh IRB session by typing &lt;code&gt;irb&lt;/code&gt; in your terminal.&lt;/p&gt; &#xA;&lt;p&gt;In the session, you can evaluate Ruby expressions or even prototype a small Ruby script. An input is executed when it is syntactically complete.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ irb&#xA;irb(main):001&amp;gt; 1 + 2&#xA;=&amp;gt; 3&#xA;irb(main):002* class Foo&#xA;irb(main):003*   def foo&#xA;irb(main):004*     puts 1&#xA;irb(main):005*   end&#xA;irb(main):006&amp;gt; end&#xA;=&amp;gt; :foo&#xA;irb(main):007&amp;gt; Foo.new.foo&#xA;1&#xA;=&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;The &lt;code&gt;binding.irb&lt;/code&gt; Breakpoint&lt;/h3&gt; &#xA;&lt;p&gt;If you use Ruby 2.5 or later versions, you can also use &lt;code&gt;binding.irb&lt;/code&gt; in your program as breakpoints.&lt;/p&gt; &#xA;&lt;p&gt;Once a &lt;code&gt;binding.irb&lt;/code&gt; is evaluated, a new IRB session will be started with the surrounding context:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ruby test.rb&#xA;&#xA;From: test.rb @ line 2 :&#xA;&#xA;    1: def greet(word)&#xA; =&amp;gt; 2:   binding.irb&#xA;    3:   puts &#34;Hello #{word}&#34;&#xA;    4: end&#xA;    5:&#xA;    6: greet(&#34;World&#34;)&#xA;&#xA;irb(main):001:0&amp;gt; word&#xA;=&amp;gt; &#34;World&#34;&#xA;irb(main):002:0&amp;gt; exit&#xA;Hello World&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Commands&lt;/h2&gt; &#xA;&lt;p&gt;The following commands are available on IRB. You can get the same output from the &lt;code&gt;show_cmds&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;IRB&#xA;  exit           Exit the current irb session.&#xA;  irb_load       Load a Ruby file.&#xA;  irb_require    Require a Ruby file.&#xA;  source         Loads a given file in the current session.&#xA;  irb_info       Show information about IRB.&#xA;  show_cmds      List all available commands and their description.&#xA;  history        Shows the input history. `-g [query]` or `-G [query]` allows you to filter the output.&#xA;&#xA;Workspace&#xA;  cwws           Show the current workspace.&#xA;  chws           Change the current workspace to an object.&#xA;  workspaces     Show workspaces.&#xA;  pushws         Push an object to the workspace stack.&#xA;  popws          Pop a workspace from the workspace stack.&#xA;&#xA;Multi-irb (DEPRECATED)&#xA;  irb            Start a child IRB.&#xA;  jobs           List of current sessions.&#xA;  fg             Switches to the session of the given number.&#xA;  kill           Kills the session with the given number.&#xA;&#xA;Debugging&#xA;  debug          Start the debugger of debug.gem.&#xA;  break          Start the debugger of debug.gem and run its `break` command.&#xA;  catch          Start the debugger of debug.gem and run its `catch` command.&#xA;  next           Start the debugger of debug.gem and run its `next` command.&#xA;  delete         Start the debugger of debug.gem and run its `delete` command.&#xA;  step           Start the debugger of debug.gem and run its `step` command.&#xA;  continue       Start the debugger of debug.gem and run its `continue` command.&#xA;  finish         Start the debugger of debug.gem and run its `finish` command.&#xA;  backtrace      Start the debugger of debug.gem and run its `backtrace` command.&#xA;  info           Start the debugger of debug.gem and run its `info` command.&#xA;&#xA;Misc&#xA;  edit           Open a file with the editor command defined with `ENV[&#34;VISUAL&#34;]` or `ENV[&#34;EDITOR&#34;]`.&#xA;  measure        `measure` enables the mode to measure processing time. `measure :off` disables it.&#xA;&#xA;Context&#xA;  help           [DEPRECATED] Enter the mode to look up RI documents.&#xA;  show_doc       Enter the mode to look up RI documents.&#xA;  ls             Show methods, constants, and variables. `-g [query]` or `-G [query]` allows you to filter out the output.&#xA;  show_source    Show the source code of a given method or constant.&#xA;  whereami       Show the source code around binding.irb again.&#xA;&#xA;Aliases&#xA;  $              Alias for `show_source`&#xA;  @              Alias for `whereami`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Debugging with IRB&lt;/h2&gt; &#xA;&lt;p&gt;Starting from version 1.8.0, IRB boasts a powerful integration with &lt;code&gt;debug.gem&lt;/code&gt;, providing a debugging experience akin to &lt;code&gt;pry-byebug&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;After hitting a &lt;code&gt;binding.irb&lt;/code&gt; breakpoint, you can activate the debugger with the &lt;code&gt;debug&lt;/code&gt; command. Alternatively, if the &lt;code&gt;debug&lt;/code&gt; method happens to already be defined in the current scope, you can call &lt;code&gt;irb_debug&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;From: test.rb @ line 3 :&#xA;&#xA;    1:&#xA;    2: def greet(word)&#xA; =&amp;gt; 3:   binding.irb&#xA;    4:   puts &#34;Hello #{word}&#34;&#xA;    5: end&#xA;    6:&#xA;    7: greet(&#34;World&#34;)&#xA;&#xA;irb(main):001&amp;gt; debug&#xA;irb:rdbg(main):002&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once activated, the prompt&#39;s header changes from &lt;code&gt;irb&lt;/code&gt; to &lt;code&gt;irb:rdbg&lt;/code&gt;, enabling you to use any of &lt;code&gt;debug.gem&lt;/code&gt;&#39;s &lt;a href=&#34;https://github.com/ruby/debug#debug-command-on-the-debug-console&#34;&gt;commands&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;irb:rdbg(main):002&amp;gt; info # use info command to see available variables&#xA;%self = main&#xA;_ = nil&#xA;word = &#34;World&#34;&#xA;irb:rdbg(main):003&amp;gt; next # use next command to move to the next line&#xA;[1, 7] in test.rb&#xA;     1|&#xA;     2| def greet(word)&#xA;     3|   binding.irb&#xA;=&amp;gt;   4|   puts &#34;Hello #{word}&#34;&#xA;     5| end&#xA;     6|&#xA;     7| greet(&#34;World&#34;)&#xA;=&amp;gt;#0    Object#greet(word=&#34;World&#34;) at test.rb:4&#xA;  #1    &amp;lt;main&amp;gt; at test.rb:7&#xA;irb:rdbg(main):004&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Simultaneously, you maintain access to IRB&#39;s commands, such as &lt;code&gt;show_source&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;irb:rdbg(main):004&amp;gt; show_source greet&#xA;&#xA;From: test.rb:2&#xA;&#xA;def greet(word)&#xA;  binding.irb&#xA;  puts &#34;Hello #{word}&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;More about &lt;code&gt;debug.gem&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;debug.gem&lt;/code&gt; offers many advanced debugging features that simple REPLs can&#39;t provide, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Step-debugging&lt;/li&gt; &#xA; &lt;li&gt;Frame navigation&lt;/li&gt; &#xA; &lt;li&gt;Setting breakpoints with commands&lt;/li&gt; &#xA; &lt;li&gt;Thread control&lt;/li&gt; &#xA; &lt;li&gt;...and many more&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To learn about these features, please refer to &lt;code&gt;debug.gem&lt;/code&gt;&#39;s &lt;a href=&#34;https://github.com/ruby/debug#debug-command-on-the-debug-console&#34;&gt;commands list&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In the &lt;code&gt;irb:rdbg&lt;/code&gt; session, the &lt;code&gt;show_cmds&lt;/code&gt; command will also display all commands from &lt;code&gt;debug.gem&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Advantages Over &lt;code&gt;debug.gem&lt;/code&gt;&#39;s Console&lt;/h3&gt; &#xA;&lt;p&gt;This integration offers several benefits over &lt;code&gt;debug.gem&lt;/code&gt;&#39;s native console:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Access to handy IRB commands like &lt;code&gt;show_source&lt;/code&gt; or &lt;code&gt;show_doc&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Support for multi-line input.&lt;/li&gt; &#xA; &lt;li&gt;Symbol shortcuts such as &lt;code&gt;@&lt;/code&gt; (&lt;code&gt;whereami&lt;/code&gt;) and &lt;code&gt;$&lt;/code&gt; (&lt;code&gt;show_source&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Autocompletion.&lt;/li&gt; &#xA; &lt;li&gt;Customizable prompt.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;However, there are also some limitations to be aware of:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;binding.irb&lt;/code&gt; doesn&#39;t support &lt;code&gt;pre&lt;/code&gt; and &lt;code&gt;do&lt;/code&gt; arguments like &lt;a href=&#34;https://github.com/ruby/debug#bindingbreak-method&#34;&gt;&lt;code&gt;binding.break&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;As IRB &lt;a href=&#34;https://github.com/ruby/irb/issues/672&#34;&gt;doesn&#39;t currently support remote-connection&lt;/a&gt;, it can&#39;t be used with &lt;code&gt;debug.gem&lt;/code&gt;&#39;s remote debugging feature.&lt;/li&gt; &#xA; &lt;li&gt;Access to the previous return value via the underscore &lt;code&gt;_&lt;/code&gt; is not supported.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Type Based Completion&lt;/h2&gt; &#xA;&lt;p&gt;IRB&#39;s default completion &lt;code&gt;IRB::RegexpCompletor&lt;/code&gt; uses Regexp. IRB has another experimental completion &lt;code&gt;IRB::TypeCompletor&lt;/code&gt; that uses type analysis.&lt;/p&gt; &#xA;&lt;h3&gt;How to Enable IRB::TypeCompletor&lt;/h3&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://github.com/ruby/repl_type_completor/&#34;&gt;ruby/repl_type_completor&lt;/a&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install repl_type_completor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or add these lines to your project&#39;s Gemfile.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;irb&#39;&#xA;gem &#39;repl_type_completor&#39;, group: [:development, :test]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can use type based completion by:&lt;/p&gt; &#xA;&lt;p&gt;Running IRB with the &lt;code&gt;--type-completor&lt;/code&gt; option&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ irb --type-completor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or writing this line to IRB&#39;s rc-file (e.g. &lt;code&gt;~/.irbrc&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;IRB.conf[:COMPLETOR] = :type # default is :regexp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or setting the environment variable &lt;code&gt;IRB_COMPLETOR&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ENV[&#39;IRB_COMPLETOR&#39;] = &#39;type&#39;&#xA;IRB.start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To check if it&#39;s enabled, type &lt;code&gt;irb_info&lt;/code&gt; into IRB and see the &lt;code&gt;Completion&lt;/code&gt; section.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;irb(main):001&amp;gt; irb_info&#xA;...&#xA;# Enabled&#xA;Completion: Autocomplete, ReplTypeCompletor: 0.1.0, Prism: 0.18.0, RBS: 3.3.0&#xA;# Not enabled&#xA;Completion: Autocomplete, RegexpCompletor&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have &lt;code&gt;sig/&lt;/code&gt; directory or &lt;code&gt;rbs_collection.lock.yaml&lt;/code&gt; in current directory, IRB will load it.&lt;/p&gt; &#xA;&lt;h3&gt;Advantage over Default IRB::RegexpCompletor&lt;/h3&gt; &#xA;&lt;p&gt;IRB::TypeCompletor can autocomplete chained methods, block parameters and more if type information is available. These are some examples IRB::RegexpCompletor cannot complete.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;irb(main):001&amp;gt; &#39;Ruby&#39;.upcase.chars.s # Array methods (sample, select, shift, size)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;irb(main):001&amp;gt; 10.times.map(&amp;amp;:to_s).each do |s|&#xA;irb(main):002&amp;gt;   s.up # String methods (upcase, upcase!, upto)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;irb(main):001&amp;gt; class User &amp;lt; ApplicationRecord&#xA;irb(main):002&amp;gt;   def foo&#xA;irb(main):003&amp;gt;     sa # save, save!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As a trade-off, completion calculation takes more time than IRB::RegexpCompletor.&lt;/p&gt; &#xA;&lt;h3&gt;Difference between Steep&#39;s Completion&lt;/h3&gt; &#xA;&lt;p&gt;Compared with Steep, IRB::TypeCompletor has some difference and limitations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[0, &#39;a&#39;].sample.&#xA;# Steep completes intersection of Integer methods and String methods&#xA;# IRB::TypeCompletor completes both Integer and String methods&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some features like type narrowing is not implemented.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def f(arg = [0, &#39;a&#39;].sample)&#xA;  if arg.is_a?(String)&#xA;    arg. # Completes both Integer and String methods&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unlike other static type checker, IRB::TypeCompletor uses runtime information to provide better completion.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;irb(main):001&amp;gt; a = [1]&#xA;=&amp;gt; [1]&#xA;irb(main):002&amp;gt; a.first. # Completes Integer methods&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h3&gt;Environment Variables&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;NO_COLOR&lt;/code&gt;: Assigning a value to it disables IRB&#39;s colorization.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IRB_USE_AUTOCOMPLETE&lt;/code&gt;: Setting it to &lt;code&gt;false&lt;/code&gt; disables IRB&#39;s autocompletion.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IRB_COMPLETOR&lt;/code&gt;: Configures IRB&#39;s auto-completion behavior, allowing settings for either &lt;code&gt;regexp&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VISUAL&lt;/code&gt;: Its value would be used to open files by the &lt;code&gt;edit&lt;/code&gt; command.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;EDITOR&lt;/code&gt;: Its value would be used to open files by the &lt;code&gt;edit&lt;/code&gt; command if &lt;code&gt;VISUAL&lt;/code&gt; is unset.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IRBRC&lt;/code&gt;: The file specified would be evaluated as IRB&#39;s rc-file.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.ruby-lang.org/en/master/IRB.html&#34;&gt;https://docs.ruby-lang.org/en/master/IRB.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Extending IRB&lt;/h2&gt; &#xA;&lt;p&gt;IRB is currently going through some refactoring to bring in some cool improvements and make things more flexible for developers. We know that in the past, due to a lack of public APIs and documentation, many of you have had to use IRB&#39;s private APIs and components to extend it. We also know that changes can be a bit annoying and might mess with your current setup.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;re sorry if this causes a bit of a scramble. We&#39;re working hard to make IRB better and your input is super important to us. If you&#39;ve been using private APIs or components in your projects, we&#39;d love to hear about your use cases. Please feel free to file a new issue. Your feedback will be a massive help in guiding us on how to design and prioritize the development of official APIs in the future.&lt;/p&gt; &#xA;&lt;p&gt;Right now, we&#39;ve got command extension APIs on the drawing board, as you can see in &lt;a href=&#34;https://github.com/ruby/irb/issues/513&#34;&gt;#513&lt;/a&gt;. We&#39;ve also got a prototype for helper method extension APIs in the works, as shown in &lt;a href=&#34;https://github.com/ruby/irb/issues/588&#34;&gt;#588&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We really appreciate your understanding and patience during this transition. We&#39;re pretty excited about the improvements these changes will bring to the IRB ecosystem and we hope you are too!&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;After checking out the repo, run &lt;code&gt;bin/setup&lt;/code&gt; to install dependencies. Then, run &lt;code&gt;rake test&lt;/code&gt; to run the tests. You can also run &lt;code&gt;bin/console&lt;/code&gt; for an interactive prompt that will allow you to experiment.&lt;/p&gt; &#xA;&lt;p&gt;To install this gem onto your local machine, run &lt;code&gt;bundle exec rake install&lt;/code&gt;. To release a new version, update the version number in &lt;code&gt;version.rb&lt;/code&gt;, and then run &lt;code&gt;bundle exec rake release&lt;/code&gt;, which will create a git tag for the version, push git commits and tags, and push the &lt;code&gt;.gem&lt;/code&gt; file to &lt;a href=&#34;https://rubygems.org&#34;&gt;rubygems.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Bug reports and pull requests are welcome on GitHub at &lt;a href=&#34;https://github.com/ruby/irb&#34;&gt;https://github.com/ruby/irb&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Set up the environment&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork the project to your GithHub account&lt;/li&gt; &#xA; &lt;li&gt;Clone the fork with &lt;code&gt;git clone git@github.com:[your_username]/irb.git&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;bundle install&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;bundle exec rake&lt;/code&gt; to make sure tests pass locally&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Run integration tests&lt;/h3&gt; &#xA;&lt;p&gt;If your changes affect component rendering, such as the autocompletion&#39;s dialog/dropdown, you may need to run IRB&#39;s integration tests, known as &lt;code&gt;yamatanarroroti&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Before running these tests, ensure that you have &lt;code&gt;libvterm&lt;/code&gt; installed. If you&#39;re using Homebrew, you can install it by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install libvterm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After installing &lt;code&gt;libvterm&lt;/code&gt;, you can run the integration tests using the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;WITH_VTERM=1 bundle install&#xA;WITH_VTERM=1 bundle exec rake test test_yamatanooroti&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Releasing&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;rake release&#xA;gh release create vX.Y.Z --generate-notes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;https://opensource.org/licenses/BSD-2-Clause&#34;&gt;2-Clause BSD License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>abak-press/resque-integration</title>
    <updated>2024-01-08T01:42:03Z</updated>
    <id>tag:github.com,2024-01-08:/abak-press/resque-integration</id>
    <link href="https://github.com/abak-press/resque-integration" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Resque::Integration&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://dolly.railsc.ru/projects/47/builds/latest/?ref=master&#34;&gt;&lt;img src=&#34;http://dolly.railsc.ru/badges/abak-press/resque-integration/master&#34; height=&#34;18&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Интеграция Resque в Rails-приложения с поддержкой следующих плагинов:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/idris/resque-progress&#34;&gt;resque-progress&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/defunkt/resque-lock&#34;&gt;resque-lock&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/stulentsev/resque-multi-job-forks&#34;&gt;resque-multi-job-forks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/anandagrawal84/resque_failed_job_mailer&#34;&gt;resque-failed-job-mailer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/resque/resque-scheduler&#34;&gt;resque-scheduler&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/lantins/resque-retry&#34;&gt;resque-retry&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Этот гем существует затем, чтобы избежать повторения чужих ошибок и сократить время, необходимое для включения resque в проект.&lt;/p&gt; &#xA;&lt;h2&gt;Установка&lt;/h2&gt; &#xA;&lt;p&gt;Добавьте в &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;resque-integration&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Добавьте в &lt;code&gt;config/routes.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mount Resque::Integration::Application =&amp;gt; &#34;/_job_&#34;, :as =&amp;gt; &#34;job_status&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Вместо &lt;code&gt;_job_&lt;/code&gt; можно прописать любой другой адрес. По этому адресу прогресс-бар будет узнавать о состоянии джоба.&lt;/p&gt; &#xA;&lt;p&gt;Если вы до сих пор не используете sprockets, то сделайте что-то вроде этого:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rails generate resque:integration:install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(результат не гарантирован, т.к. не тестировалось)&lt;/p&gt; &#xA;&lt;h2&gt;Задачи&lt;/h2&gt; &#xA;&lt;p&gt;Создайте файл &lt;code&gt;app/jobs/resque_job_test.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ResqueJobTest&#xA;  include Resque::Integration&#xA;&#xA;  # это название очереди, в которой будет выполняться джоб&#xA;  queue :my_queue&#xA;&#xA;  # с помощью unique можно указать, что задача является уникальной, и какие аргументы определяют уникальность задачи.&#xA;  # в данном случае не может быть двух одновременных задач ResqueJobTest с одинаковым первым аргументом&#xA;  # (второй аргумент может быть любым)&#xA;  unique { |id, description| [id] }&#xA;&#xA;  # В отличие от обычных джобов resque, надо определять метод execute.&#xA;  #&#xA;  # Либо же вы можете определить метод perform, но первым аргументом должен быть указан meta_id (уникальный ID джоба):&#xA;  #   def self.perform(meta_id, id, description)&#xA;  #     ...&#xA;  #   end&#xA;  def self.execute(id, description)&#xA;    (1..100).each do |t|&#xA;      at(t, 100, &#34;Processing #{id}: at #{t} of 100&#34;)&#xA;      sleep 0.5&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Перезапуск задачи&lt;/h3&gt; &#xA;&lt;p&gt;Допустим, у вас есть очень длинная задача и вы не хотите, чтобы возникло переполнение очереди (или памяти). Тогда можно выполнить часть задачи, а потом заново поставить задачу в очередь.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ResqueJobTest&#xA;  include Resque::Integration&#xA;&#xA;  unique&#xA;  continuous # теперь вы можете перезапускать задачу&#xA;&#xA;  def self.execute(company_id)&#xA;    products = company.products.where(&#39;updated_at &amp;lt; ?&#39;, 1.day.ago)&#xA;&#xA;    products.limit(1000).each do |product|&#xA;      product.touch&#xA;    end&#xA;&#xA;    # В очередь поставится задача с теми же аргументами, что и текущая.&#xA;    # Можно передать другие аргументы: `continue(another_argument)`&#xA;    continue if products.count &amp;gt; 0&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Такая задача будет выполняться по частям, не потребляя много памяти. Еще один плюс: другие задачи из очереди тоже смогут выполниться. ОПАСНО! Избегайте бесконечных циклов, т.к. это в некотором роде &#34;рекурсия&#34;.&lt;/p&gt; &#xA;&lt;h2&gt;Конфигурация воркеров resque&lt;/h2&gt; &#xA;&lt;p&gt;Создайте файл &lt;code&gt;config/resque.yml&lt;/code&gt; с несколькими секциями:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# конфигурация redis&#xA;# секция не обязательная, вы сами можете настроить подключение через Resque.redis = Redis.new&#xA;redis:&#xA;  host: bz-redis&#xA;  port: 6379&#xA;  namespace: blizko&#xA;&#xA;resque:&#xA;  interval: 5 # частота, с которой resque берет задачи из очереди в секундах (по умолчанию 5)&#xA;  verbosity: 1 # &#34;шумность&#34; логера (0 - ничего не пишет, 1 - пишет о начале/конце задачи, 2 - пишет все)&#xA;  root: &#34;/home/pc/current&#34; # (production) абсолютный путь до корня проекта&#xA;  log_file: &#34;/home/pc/static/pulscen/local/log/resque.log&#34; # (production) абсолютный путь до лога&#xA;  config_file: &#34;/home/pc/static/pulscen/local/log/resque.god&#34; # (production) абсолютный путь до кофига god&#xA;  pids: &#34;/home/pc/static/pulscen/local/pids&#34; # (production) абсолютный путь до папки с пид файлами&#xA;&#xA;# переменные окружения, которые надобно передавать в resque&#xA;env:&#xA;  RUBY_HEAP_MIN_SLOTS: 2500000&#xA;  RUBY_HEAP_SLOTS_INCREMENT: 1000000&#xA;  RUBY_HEAP_SLOTS_GROWTH_FACTOR: 1&#xA;  RUBY_GC_MALLOC_LIMIT: 50000000&#xA;&#xA;# конфигурация воркеров (названия воркеров являются названиями очередей)&#xA;workers:&#xA;  kirby: 2 # 2 воркера в очереди kirby&#xA;  images:&#xA;    count: 8 # 8 воркеров в очереди images&#xA;    jobs_per_fork: 250 # каждый воркер обрабатывает 250 задач прежде, чем форкается заново&#xA;    minutes_per_fork: 30 # альтернатива предыдущей настройке - сколько минут должен работать воркер, прежде чем форкнуться заново&#xA;    stop_timeout: 5 # максимальное время, отпущенное воркеру для остановки/рестарта&#xA;    env: # переменные окружение, специфичные для данного воркера&#xA;      RUBY_HEAP_SLOTS_GROWTH_FACTOR: 0.5&#xA;  &#39;companies,images&#39;: 2 # совмещённая очередь, приоритет будет у companies&#xA;  &#39;xls,yml&#39;:&#xA;    shuffle: true # совмещённая очередь, приоритета не будет&#xA;&#xA;# конфигурация failure-бэкэндов&#xA;failure:&#xA;  # конфигурация отправщика отчетов об ошибках&#xA;  notifier:&#xA;    enabled: true&#xA;    # адреса, на которые надо посылать уведомления об ошибках&#xA;    to: [teamlead@apress.ru, pm@apress.ru, programmer@apress.ru]&#xA;    # необязательные настройки&#xA;    # от какого адреса слать&#xA;    from: no-reply@blizko.ru&#xA;    # включать в письмо payload (аргументы, с которыми вызвана задача)&#xA;    include_payload: true&#xA;    # класс отправщика (должен быть наследником ActionMailer::Base, по умолчанию ResqueFailedJobMailer::Mailer&#xA;    mailer: &#34;Blizko::ResqueMailer&#34;&#xA;    # метод, который вызывается у отправщика (по умолчанию alert)&#xA;    mail: alert&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Обратите внимание на параметр &lt;code&gt;stop_timeout&lt;/code&gt; в секции конфигурирования воркеров. Это очень важный параметр. По умолчанию воркеру отводится всего 10 секунд на то, чтобы остановиться. Если воркер не укладывается в это время, супервизор (мы используем &lt;a href=&#34;http://godrb.com/&#34;&gt;god&lt;/a&gt;) посылает воркеру сигнал &lt;code&gt;KILL&lt;/code&gt;, который &#34;прибьет&#34; задачу. Если у вас есть длинные задачи (навроде импорта из XML), то для таких воркеров лучше ставить &lt;code&gt;stop_timeout&lt;/code&gt; побольше.&lt;/p&gt; &#xA;&lt;p&gt;Для разработки можно (и нужно) создать файл &lt;code&gt;config/resque.local.yml&lt;/code&gt;, в котором можно переопределить любые параметры:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;redis:&#xA;  host: localhost&#xA;  port: 6379&#xA;&#xA;resque:&#xA;  verbosity: 2&#xA;&#xA;workers:&#xA;  &#39;*&#39;: 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Запуск воркеров&lt;/h2&gt; &#xA;&lt;p&gt;Ручной запуск воркера (см. &lt;a href=&#34;https://github.com/resque/resque/raw/1-x-stable/README.markdown&#34;&gt;официальную документацию resque&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ QUEUE=* rake resque:work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Запуск всех воркеров так, как они сконфигурированы в &lt;code&gt;config/resque.yml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rake resque:start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Останов всех воркеров:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rake resque:stop&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Перезапуск воркеров:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rake resque:restart&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Постановка задач в очередь&lt;/h2&gt; &#xA;&lt;h3&gt;Для задач, в который включен модуль &lt;code&gt;Resque::Integration&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;meta = ResqueJobTest.enqueue(id=2)&#xA;@job_id = meta.meta_id&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Вот так можно показать прогресс-бар:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-haml&#34;&gt;%div#progressbar&#xA;&#xA;:javascript&#xA;  $(&#39;#progressbar&#39;).progressBar({&#xA;    url: #{job_status_path.to_json}, // адрес джоб-бэкенда (определяется в ваших маршрутах)&#xA;    pid: #{@job_id.to_json}, // job id&#xA;    interval: 1100, // частота опроса джоб-бэкэнда в миллисекундах&#xA;    text: &#34;Initializing&#34; // initializing text appears on progress bar when job is already queued but not started yet&#xA;  }).show();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Для обычных задач Resque&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Resque.enqueue(ImageProcessingJob, id=2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Resque Scheduler&lt;/h2&gt; &#xA;&lt;p&gt;Расписание для cron-like заданий должно храниться здесь &lt;code&gt;config/resque_schedule.yml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Resque Retry&lt;/h2&gt; &#xA;&lt;p&gt;В силу несовместимостей почти всех плагинов с resque-meta (unique основан на нём) - объявить задание перезапускаемым в случае ошибки нужно ДО &lt;code&gt;unique&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ResqueJobTest&#xA;  include Resque::Integration&#xA;&#xA;  retrys delay: 10, limit: 2&#xA;  unique&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Resque Multi Job Forks&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;workers:&#xA;  &#39;high&#39;:&#xA;    count: 1&#xA;    jobs_per_fork: 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Resque Ordered&lt;/h2&gt; &#xA;&lt;p&gt;Уникальный по каким-то параметрам джоб может выполняться в одно и тоже время только на одном из воркеров&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ResqueJobTest&#xA;  include Resque::Integration&#xA;&#xA;  unique { |company_id, param1| [company_id] }&#xA;  ordered max_iterations: 20 # max_iterations - сколько раз запустится метод `execute` с аргументами в очереди,&#xA;                             # прежде чем джоб перепоставится&#xA;&#xA;  def self.execute(ordered_meta, company_id, param1)&#xA;    heavy_lifting_work&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;При необходимости, можно добиться уникальности упорядоченных джобов, указав параметры в опции &lt;code&gt;unique&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UniqueOrderedJob&#xA;  include Resque::Integration&#xA;&#xA;  unique { |company_id, param1| [company_id] }&#xA;  ordered max_iterations: 10, unique: -&amp;gt;(_company_id, param1) { [param1] }&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork it ( &lt;a href=&#34;https://github.com/abak-press/resque-integration/fork&#34;&gt;https://github.com/abak-press/resque-integration/fork&lt;/a&gt; )&lt;/li&gt; &#xA; &lt;li&gt;Create your feature branch (&lt;code&gt;git checkout -b my-new-feature&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Commit your changes (&lt;code&gt;git commit -am &#39;Add some feature&#39;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Push to the branch (&lt;code&gt;git push origin my-new-feature&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Create a new Pull Request&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>