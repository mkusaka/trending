<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-20T01:37:25Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kkuchta/css-only-chat</title>
    <updated>2022-12-20T01:37:25Z</updated>
    <id>tag:github.com,2022-12-20:/kkuchta/css-only-chat</id>
    <link href="https://github.com/kkuchta/css-only-chat" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A truly monstrous async web chat using no JS whatsoever on the frontend&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://media.giphy.com/media/dWkxAZTg9NbAhvRqOe/giphy.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;CSS-Only Chat&lt;/h1&gt; &#xA;&lt;p&gt;A truly monstrous async web chat using no JS whatsoever on the frontend.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://media.giphy.com/media/mCClSS6xbi8us/giphy.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Wait what&lt;/h1&gt; &#xA;&lt;p&gt;This is an asynchronous chat that sends + receives messages in the browser with no reloads and no javascript.&lt;/p&gt; &#xA;&lt;h2&gt;Ok so how&lt;/h2&gt; &#xA;&lt;p&gt;Background-images loaded via pseudoselectors + a forever-loading index page (remember &lt;a href=&#34;https://en.wikipedia.org/wiki/Comet_(programming)&#34;&gt;Comet&lt;/a&gt;?).&lt;/p&gt; &#xA;&lt;h2&gt;Say that again?&lt;/h2&gt; &#xA;&lt;p&gt;Ok, so there are two things we need the browser to do: send data and receive data. Let&#39;s start with the first.&lt;/p&gt; &#xA;&lt;h3&gt;Sending Data&lt;/h3&gt; &#xA;&lt;p&gt;CSS is really limited in what it can do. However, we &lt;em&gt;can&lt;/em&gt; use it to effectively detect button presses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;.some-button:active {&#xA;  background-image: url(&#39;some_image.jpg&#39;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What&#39;s cool is that a browser won&#39;t actually load that background image until this selector is used - that is, when this button is pressed. So now we have a way to trigger a request to a server of our choice on a button press. That sounds like data sending!&lt;/p&gt; &#xA;&lt;p&gt;Now, of course, this only works once per button (since a browser won&#39;t try to load that image twice), but it&#39;s a start.&lt;/p&gt; &#xA;&lt;h3&gt;Receiving Data&lt;/h3&gt; &#xA;&lt;p&gt;Since we can&#39;t use JS, it&#39;s really hard to change a page after it&#39;s already been loaded. But it &lt;em&gt;is&lt;/em&gt; possible.&lt;/p&gt; &#xA;&lt;p&gt;Back before websockets were widely supported, we had to use clever hacks if we wanted to push data from a server to a client in an ongoing basis. One such hack was just to make the page never finish loading. It turns out that you can tell the browser to start rendering a page before it&#39;s finished loading (using the &lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt; http header). And when you do that, you don&#39;t &lt;em&gt;actually&lt;/em&gt; have to stop loading the page. You can just keep adding stuff to the bottom of the html forever, at whatever rate you want.&lt;/p&gt; &#xA;&lt;p&gt;So, for example, you could start sending a normal html page, then just stop sending html (while still telling the client you&#39;re sending) until you&#39;re ready to deliver another message.&lt;/p&gt; &#xA;&lt;p&gt;Now, all this lets us do is periodically append html to the page. What can we do with that? How about, when you load the index page, this happens:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;We load up the first pile of html we want to show. A welcome message, etc.&lt;/li&gt; &#xA; &lt;li&gt;We stop loading html for a while until we want to send some sort of update.&lt;/li&gt; &#xA; &lt;li&gt;Now we load up a &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element that &lt;code&gt;display: none&lt;/code&gt;&#39;s all the previous html&lt;/li&gt; &#xA; &lt;li&gt;Then we load up whatever &lt;em&gt;new&lt;/em&gt; html we want to show&lt;/li&gt; &#xA; &lt;li&gt;Finally we wait until the next update we want to send and GOTO 3.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Single-use buttons?&lt;/h3&gt; &#xA;&lt;p&gt;Ok, so we have that problem earlier where each button is only single-use. It tries to send a get request once, then never will again.&lt;/p&gt; &#xA;&lt;p&gt;Thankfully, our method of receiving data fixes that for us. Here&#39;s what happens:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;We show an &#34;a&#34; button whose background image is like &#34;img/a&#34;.&lt;/li&gt; &#xA; &lt;li&gt;When you press it, the server receives the image request for &#34;a&#34;&lt;/li&gt; &#xA; &lt;li&gt;The server then pushes an update to the client to hide the current button and replace it with one whose background images is &#34;image/aa&#34;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If the buttons you pressed were &#34;h&#34;, &#34;e&#34;, and &#34;l&#34;, then the &#34;a&#34; button&#39;s background image url would be &#34;img/hela&#34;. And since we&#39;re replacing all buttons every time you press one, the single-use button problem goes away!&lt;/p&gt; &#xA;&lt;h3&gt;Misc other details&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We actually encode a bit more info into the button urls (like each client&#39;s id)&lt;/li&gt; &#xA; &lt;li&gt;Because the data-sending and data-receiving happens on different threads, we need inter-thread communication. That sounds like work, so we&#39;ll just use Redis pubsub for that.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;FAQ&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;What inspired this?&lt;/strong&gt; Chernobyl, Hindenburg, The Tacoma Narrows Bridge...&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Really?&lt;/strong&gt; No, it was this &lt;a href=&#34;https://twitter.com/davywtf/status/1124130932573839360&#34;&gt;clever tweet&lt;/a&gt; by davywtf.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Why&#39;s your code suck&lt;/strong&gt; Why do &lt;em&gt;you&lt;/em&gt; suck?&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;No but really&lt;/strong&gt; Because I was mostly making this up as I went. There&#39;s a lot of exploratory coding here that I only minimally cleaned up. If I rebuilt it I&#39;d store the UI state for a client in redis and just push it out in its entirety when needed via a single generic screen-updating mechanism.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;What could go wrong with this technique?&lt;/strong&gt; Broken by browser bg-image handling changes; long-request timeouts; running out of threads; fast-clicking bugs; generic concurrency headaches; poor handling by proxies; it&#39;s crazy inaccessible; etc etc&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Should I use this in real life?&lt;/strong&gt; Dear god yes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;I have an idea for how this could be made better/worse/hackier&lt;/strong&gt; &lt;a href=&#34;https://twitter.com/kkuchta&#34;&gt;Tweet at me (@kkuchta)&lt;/a&gt;. I&#39;m always down to see a terrible idea taken further!&lt;/p&gt; &#xA;&lt;h3&gt;Practical Details&lt;/h3&gt; &#xA;&lt;p&gt;If you want to install and use this locally you should:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Re-evaluate your life choices&lt;/li&gt; &#xA; &lt;li&gt;If you simply must continue, check out INSTALL.md&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you want to contribute, see number 1 above. After that, just fork this repo, make a change, and then open a PR against this repo.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>pivotal-cf/on-demand-service-broker-release</title>
    <updated>2022-12-20T01:37:25Z</updated>
    <id>tag:github.com,2022-12-20:/pivotal-cf/on-demand-service-broker-release</id>
    <link href="https://github.com/pivotal-cf/on-demand-service-broker-release" rel="alternate"></link>
    <summary type="html">&lt;p&gt;On-Demand Service Broker (ODB) BOSH Release, a BOSH-packaged-up framework for more easily developing OSBAPI-compliant service brokers that provision and deprovision new instances with BOSH&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;on-demand-service-broker-release&lt;/h1&gt; &#xA;&lt;p&gt;A BOSH release for a &lt;a href=&#34;https://github.com/pivotal-cf/on-demand-service-broker&#34;&gt;Cloud Foundry on-demand service broker&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The broker deploys any service release on demand. One service instance corresponds to one BOSH deployment.&lt;/p&gt; &#xA;&lt;p&gt;To create the release, ensure you are using the Bosh CLI v2.0.48+.&lt;/p&gt; &#xA;&lt;h2&gt;User Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Full user documentation can be found &lt;a href=&#34;https://docs.pivotal.io/svc-sdk/odb&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Getting Started with ODB&lt;/h3&gt; &#xA;&lt;p&gt;Follow &lt;a href=&#34;https://docs.pivotal.io/svc-sdk/odb/getting-started.html&#34;&gt;this guide&lt;/a&gt; to try out an example product.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a ODB Based Service&lt;/h3&gt; &#xA;&lt;p&gt;We have &lt;a href=&#34;https://github.com/pivotal-cf/on-demand-services-sdk&#34;&gt;an SDK&lt;/a&gt; to start you off building on demand services. This helps you create &lt;a href=&#34;https://docs.pivotal.io/svc-sdk/odb/creating.html&#34;&gt;service adapters&lt;/a&gt;, required by the ODB to deploy on demand instances of your &lt;a href=&#34;https://bosh.io/docs&#34;&gt;BOSH release&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Packaging for Pivotal Cloud Foundry (PCF)&lt;/h3&gt; &#xA;&lt;p&gt;Once you have an ODB integration completed for your service you may wish to create a tile for the PCF marketplace. You can &lt;a href=&#34;https://docs.pivotal.io/svc-sdk/odb/0-15/tile.html&#34;&gt;follow this guide to tile development&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/pivotal-cf/on-demand-service-broker-release/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Tests&lt;/h3&gt; &#xA;&lt;p&gt;You can run the bats tests for the release using these commands&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle install&#xA;bundle exec rake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Releases and versioning&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The on-demand services SDK is pre-1.0.0 and uses semantic versioning. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This means that we reserve the right to release breaking changes in minor versions.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Breaking changes will always be clearly flagged in release notes.&lt;/li&gt; &#xA; &lt;li&gt;We do not backwards apply patches, as no version other than the current is in support.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;A note on breaking changes&lt;/h3&gt; &#xA;&lt;p&gt;There are three different categories of breaking changes when talking about ODB&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Behavioural/Functional breaking changes&lt;/li&gt; &#xA; &lt;li&gt;Manifest breaking changes&lt;/li&gt; &#xA; &lt;li&gt;SDK Interface breaking changes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is safe to assume that, from version x to version x+1, ODB will not introduce Behavioural/Functional breaking changes. We may introduce new functionality, but it will be feature flagged and off by default (in most cases). Keep in mind that we might remove a feature flag (or most likely turn it on by default) from version x to version x+2.&lt;/p&gt; &#xA;&lt;p&gt;While we try our best to not introduce Manifest or SDK Interface breaking changes, they are the most likely to occur in a minor bump. It usually means that the service adapter author will need to update the signature of their functions to continue to use the SDK. Note that changing the signature doesn’t enable the feature, as it usually needs an updated manifest with the feature flag turned on.&lt;/p&gt; &#xA;&lt;h3&gt;Support&lt;/h3&gt; &#xA;&lt;p&gt;The on-demand services SDK is not an end customer-facing product, and as such we do not have an official support policy. Our unofficial policy is that only the current (latest) version is supported. We do not maintain pipelines or testing for any branch of our codebase other than master.&lt;/p&gt; &#xA;&lt;p&gt;There have been situations where we have released patch updates, e.g. 0.21.2 where we had to downgrade golang due to a cert validation issue, but this was classified as a patch due to the content of the release (small dependency change) and we did not backport the patch to any previous version.&lt;/p&gt; &#xA;&lt;h3&gt;Best practice for maintaining ODB in your tile&lt;/h3&gt; &#xA;&lt;p&gt;We recommend that you float ODB versions and bump all supported tiles whenever a new ODB version is available, in order to ensure all the latest security patches and bug fixes reach your end users (in case you want to know more about this strategy, RabbitMQ for PCF and Redis for PCF teams have been doing this successfully). In the vast majority of cases we use feature flags to ensure you stay in control of when you introduce new features to your users.&lt;/p&gt; &#xA;&lt;h3&gt;Availability of old versions&lt;/h3&gt; &#xA;&lt;p&gt;Whilst we have no official support policy, we remove all ODB versions released more than nine months ago from availability on pivnet. This is in keeping with Pivotal tiles’ official support policy. We remove docs for old versions accordingly, though they are still available in PDF format (e.g. 0.20).&lt;/p&gt;</summary>
  </entry>
</feed>