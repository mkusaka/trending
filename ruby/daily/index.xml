<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-28T01:37:18Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>learn-co-curriculum/phase-4-nested-resource-routing</title>
    <updated>2022-11-28T01:37:18Z</updated>
    <id>tag:github.com,2022-11-28:/learn-co-curriculum/phase-4-nested-resource-routing</id>
    <link href="https://github.com/learn-co-curriculum/phase-4-nested-resource-routing" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Nested Resource Routing&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Understand the value of nested routes&lt;/li&gt; &#xA; &lt;li&gt;Create nested routes&lt;/li&gt; &#xA; &lt;li&gt;Understand how nested resource params are named&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;re going to keep working on our AirBudNB application, augmenting it to filter reviews by listing in a user-friendly and RESTful way.&lt;/p&gt; &#xA;&lt;p&gt;To set up the app, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle install&#xA;$ rails db:migrate db:seed&#xA;$ rails s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;URL As Data&lt;/h3&gt; &#xA;&lt;p&gt;You&#39;ve encountered REST already, but, just to review, it stands for REpresentational State Transfer and encapsulates a way of structuring a URL so that access to specific resources is predictable and standardized.&lt;/p&gt; &#xA;&lt;p&gt;In practice, that means that, if we type &lt;code&gt;rails s&lt;/code&gt; and run our app, browsing to &lt;code&gt;/reviews&lt;/code&gt; will show us the index of all &lt;code&gt;Review&lt;/code&gt; objects. And if we want to view a specific &lt;code&gt;DogHouse&lt;/code&gt;, we can guess the URL for that (as long as we know the dog house&#39;s &lt;code&gt;id&lt;/code&gt;) by going to &lt;code&gt;/dog_houses/:id&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Why do we care?&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s imagine we added a filter feature to our reviews page:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://curriculum-content.s3.amazonaws.com/phase-4/phase-4-nested-resource-routing/reviews-filter.png&#34; alt=&#34;reviews filter&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;When the filter is active, we &lt;em&gt;could&lt;/em&gt; make a request to our backend, using query parameters, to retrieve only the reviews that match the selected dog house:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;http://localhost:3000/reviews?doghouse=1&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s the opposite of REST. That makes me &lt;em&gt;stressed&lt;/em&gt;. While using query params like in the link above could work, we can do better by following REST conventions.&lt;/p&gt; &#xA;&lt;h3&gt;Dynamic Route Segments&lt;/h3&gt; &#xA;&lt;p&gt;What we&#39;d love to end up with here is something like &lt;code&gt;/dog_houses/1/reviews&lt;/code&gt; for all of a dog house&#39;s reviews and &lt;code&gt;/dog_houses/1/reviews/5&lt;/code&gt; to see an individual review for that dog house.&lt;/p&gt; &#xA;&lt;p&gt;We know we can build out a route with dynamic segments, so our first instinct might be to just define these in &lt;code&gt;routes.rb&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# config/routes.rb&#xA;  ...&#xA;  get &#39;/dog_houses/:dog_house_id/reviews&#39;&#xA;  get &#39;/dog_houses/:dog_house_id/reviews/:review_id&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After adding those routes, let&#39;s check it out by browsing to &lt;code&gt;/dog_houses/1/reviews&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Oops. Error. Gotta tell those routes explicitly which controller actions will handle them. Okay, let&#39;s make it look more like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# config/routes.rb&#xA;  ...&#xA;  get &#39;/dog_houses/:dog_house_id/reviews&#39;, to: &#39;dog_houses#reviews_index&#39;&#xA;  get &#39;/dog_houses/:dog_house_id/reviews/:id&#39;, to: &#39;dog_houses#review&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And to handle our new filtering routes, we&#39;ll need to add some code in our &lt;code&gt;dog_houses_controller&lt;/code&gt; to actually do the work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;  # app/controllers/dog_houses_controller.rb&#xA;  ...&#xA;&#xA;  def reviews_index&#xA;    dog_house = DogHouse.find(params[:dog_house_id])&#xA;    reviews = dog_house.reviews&#xA;    render json: reviews, include: :dog_house&#xA;  end&#xA;&#xA;  def review&#xA;    review = Review.find(params[:id])&#xA;    render json: review, include: :dog_house&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If your IDs are different and you are having trouble with the URLs, try running &lt;code&gt;rails db:reset&lt;/code&gt; to reset your database.&lt;/p&gt; &#xA;&lt;p&gt;We did it! We have much nicer URLs now. Are we done? Of course not. While this setup will work, there are a couple of problems.&lt;/p&gt; &#xA;&lt;p&gt;First, if we look at our &lt;code&gt;routes.rb&lt;/code&gt;, we&#39;ve had to move away from using the preferred &lt;code&gt;resources&lt;/code&gt; option and are now specifying HTTP verbs, routes, and controller actions. Given that implementing a filter is a fairly common task, this is not ideal.&lt;/p&gt; &#xA;&lt;p&gt;Beyond that, note that our &lt;code&gt;dog_houses_controller&lt;/code&gt; is now responsible for rendering reviews, which shouldn&#39;t be its responsibility. Furthermore, the code to find all reviews and to find individual reviews by their ID is essentially repeated in both the &lt;code&gt;reviews_controller&lt;/code&gt; and the &lt;code&gt;dog_houses_controller&lt;/code&gt;. Our current code is violating both the DRY (Don&#39;t Repeat Yourself) and Separation of Concerns principles.&lt;/p&gt; &#xA;&lt;p&gt;Seems like Rails would have a way to bail us out of this mess.&lt;/p&gt; &#xA;&lt;h3&gt;Nested Resource Routes&lt;/h3&gt; &#xA;&lt;p&gt;Turns out, Rails &lt;em&gt;does&lt;/em&gt; give us a way to make this a lot nicer.&lt;/p&gt; &#xA;&lt;p&gt;If we look again at our models, we see that a dog house &lt;code&gt;has_many :reviews&lt;/code&gt; and a review &lt;code&gt;belongs_to :dog_house&lt;/code&gt;. Since a review can logically be considered a &lt;em&gt;child&lt;/em&gt; object of a dog house, it can also be considered a &lt;em&gt;nested resource&lt;/em&gt; of a dog house for routing purposes.&lt;/p&gt; &#xA;&lt;p&gt;Nested resources give us a way to document that parent/child relationship in our routes and, ultimately, our URLs.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s get back into &lt;code&gt;routes.rb&lt;/code&gt;, delete the two routes we just added, and recreate them as nested resources. We should end up with something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# config/routes.rb&#xA;&#xA;Rails.application.routes.draw do&#xA;&#xA;  resources :dog_houses, only: [:show] do&#xA;    # nested resource for reviews&#xA;    resources :reviews, only: [:show, :index]&#xA;  end&#xA;&#xA;  resources :reviews, only: [:show, :index, :create]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we have the resourced &lt;code&gt;:dog_houses&lt;/code&gt; route, but by adding the &lt;code&gt;do...end&lt;/code&gt; we can pass it a block of its nested routes.&lt;/p&gt; &#xA;&lt;p&gt;We can still do things to the nested resources that we do to a non-nested resource, like limit them to only certain actions. In this case, we only want to nest &lt;code&gt;:show&lt;/code&gt; and &lt;code&gt;:index&lt;/code&gt; under &lt;code&gt;:dog_houses&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Below that, we still have our regular resourced &lt;code&gt;:reviews&lt;/code&gt; routes because we still want to let people see all reviews or a single review, create reviews, etc., outside of the context of a dog house.&lt;/p&gt; &#xA;&lt;p&gt;You can see the routes available by running &lt;code&gt;rails routes&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Prefix            Verb  URI Pattern                                     Controller#Action&#xA;dog_house_reviews GET   /dog_houses/:dog_house_id/reviews(.:format)     reviews#index&#xA; dog_house_review GET   /dog_houses/:dog_house_id/reviews/:id(.:format) reviews#show&#xA;        dog_house GET   /dog_houses/:id(.:format)                       dog_houses#show&#xA;          reviews GET   /reviews(.:format)                              reviews#index&#xA;                  POST  /reviews(.:format)                              reviews#create&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice, in the &#39;Controller#Action&#39; column, how now we are dealing with the &lt;code&gt;reviews_controller&lt;/code&gt; rather than the &lt;code&gt;dog_houses_controller&lt;/code&gt; for our nested routes â€” our code once again reflects good Separation of Concerns. And, since we already have actions in &lt;code&gt;reviews_controller&lt;/code&gt; to handle &lt;code&gt;:show&lt;/code&gt; and &lt;code&gt;:index&lt;/code&gt;, we won&#39;t be repeating ourselves like we did in the &lt;code&gt;dog_houses_controller&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Now we just need to update our &lt;code&gt;reviews_controller&lt;/code&gt; to handle the nested resource. Let&#39;s update &lt;code&gt;index&lt;/code&gt; to account for the new routes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# app/controllers/reviews_controller.rb&#xA;&#xA;  def index&#xA;    if params[:dog_house_id]&#xA;      dog_house = DogHouse.find(params[:dog_house_id])&#xA;      reviews = dog_house.reviews&#xA;    else&#xA;      reviews = Review.all&#xA;    end&#xA;    render json: reviews, include: :dog_house&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We added a condition to the &lt;code&gt;reviews#index&lt;/code&gt; action to account for whether the user is trying to access the index of &lt;em&gt;all&lt;/em&gt; reviews (&lt;code&gt;Review.all&lt;/code&gt;) or just the index of all reviews &lt;em&gt;for a certain dog house&lt;/em&gt; (&lt;code&gt;dog_house.reviews&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The condition hinges on whether there&#39;s a &lt;code&gt;:dog_house_id&lt;/code&gt; key in the &lt;code&gt;params&lt;/code&gt; hash â€” in other words, whether the user navigated to &lt;code&gt;/dog_houses/:dog_house_id/reviews&lt;/code&gt; or simply &lt;code&gt;/reviews&lt;/code&gt;. We didn&#39;t have to create any new methods or make explicit calls to render new data. We just added a simple check for &lt;code&gt;params[:dog_house_id]&lt;/code&gt;, and we&#39;re good to go.&lt;/p&gt; &#xA;&lt;p&gt;Where is &lt;code&gt;params[:dog_house_id]&lt;/code&gt; coming from? Rails provides it for us through the nested route, so we don&#39;t have to worry about a collision with the &lt;code&gt;:id&lt;/code&gt; parameter that &lt;code&gt;reviews#show&lt;/code&gt; is looking for. Rails takes the parent resource&#39;s name and appends &lt;code&gt;_id&lt;/code&gt; to it for a nice, predictable way to find the parent resource&#39;s ID. Since some of our review routes are nested like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;resources :dog_houses, only: [:show] do&#xA;  resources :reviews, only: [:show, :index]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We end up with these routes for reviews (notice the dynamic portions of the URI Patterns):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Verb  URI Pattern                                     Controller#Action&#xA;GET   /dog_houses/:dog_house_id/reviews               reviews#index&#xA;GET   /dog_houses/:dog_house_id/reviews/:id           reviews#show&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll also notice we didn&#39;t make a single change to the &lt;code&gt;reviews#show&lt;/code&gt; action. What about the new &lt;code&gt;/dog_houses/:dog_house_id/reviews/:id&lt;/code&gt; route that we added?&lt;/p&gt; &#xA;&lt;p&gt;Remember, the point of nesting our resources is to DRY up our code. We had to create a conditional for the &lt;code&gt;reviews#index&lt;/code&gt; action because it renders &lt;em&gt;different&lt;/em&gt; sets of reviews depending on the path, &lt;code&gt;/dog_houses/:dog_house_id/reviews&lt;/code&gt; or &lt;code&gt;/reviews&lt;/code&gt;. Conversely, the &lt;code&gt;reviews#show&lt;/code&gt; route is going to render the &lt;em&gt;same&lt;/em&gt; information â€” data concerning a single review â€” regardless of whether it is accessed via &lt;code&gt;/dog_houses/:dog_house_id/reviews&lt;/code&gt; or &lt;code&gt;/reviews/:id&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For good measure, let&#39;s go into our &lt;code&gt;dog_houses_controller.rb&lt;/code&gt; and delete the two actions (&lt;code&gt;review&lt;/code&gt; and &lt;code&gt;reviews_index&lt;/code&gt;) that we added above so that it looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# app/controllers/dog_houses_controller.rb&#xA;class DogHousesController &amp;lt; ApplicationController&#xA;  rescue_from ActiveRecord::RecordNotFound, with: :render_not_found_response&#xA;&#xA;  def show&#xA;    dog_house = DogHouse.find(params[:id])&#xA;    render json: dog_house&#xA;  end&#xA;&#xA;  private&#xA;&#xA;  def render_not_found_response&#xA;    render json: { error: &#34;Dog house not found&#34; }, status: :not_found&#xA;  end&#xA;&#xA;end&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Top-tip:&lt;/strong&gt; Keep your application clean and easy to maintain by always removing unused code.&lt;/p&gt; &#xA;&lt;h3&gt;Caveat on Nesting Resources More Than One Level Deep&lt;/h3&gt; &#xA;&lt;p&gt;You can nest resources more than one level deep, but that is generally a bad idea.&lt;/p&gt; &#xA;&lt;p&gt;Imagine if we also had comments on a review. This would be a perfectly fine use of nesting:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;resources :reviews do&#xA;  resources :comments&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We could then access a reviews&#39;s comments with &lt;code&gt;/reviews/1/comments&lt;/code&gt;. That makes a lot of sense.&lt;/p&gt; &#xA;&lt;p&gt;But if we then tried to add to our already nested &lt;code&gt;reviews&lt;/code&gt; resource...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;resources :dog_houses do&#xA;  resources :reviews do&#xA;    resources :comments&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we&#39;re getting into messy territory. Our URL is &lt;code&gt;/dog_houses/1/reviews/1/comments&lt;/code&gt;, and we have to handle that filtering in our controller.&lt;/p&gt; &#xA;&lt;p&gt;But if we lean on our old friend Separation of Concerns, we can conclude that a reviews&#39;s comments are not the concern of a dog house and therefore don&#39;t belong nested two levels deep under the &lt;code&gt;:dog_houses&lt;/code&gt; resource.&lt;/p&gt; &#xA;&lt;p&gt;In addition, the reason to put the ID of the resource in the URL is so that we have access to it in the controller. If we know we have the review with an ID of &lt;code&gt;1&lt;/code&gt;, we can use our Active Record relationships to call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;  review = Review.find(params[:id])&#xA;  review.dog_house&#xA;  # This will tell us which dog house the review was for!&#xA;  # We don&#39;t need this information in the URL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;Nesting resources is a powerful tool that helps you keep your routes neat and tidy and is better than dynamic route segments for representing parent/child relationships in your system.&lt;/p&gt; &#xA;&lt;p&gt;However, as a general rule, you should only nest resources one level deep and ensure that you are considering Separation of Concerns in your routing.&lt;/p&gt; &#xA;&lt;h2&gt;Check For Understanding&lt;/h2&gt; &#xA;&lt;p&gt;Before you move on, make sure you can answer the following questions:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;What are the benefits of using nested routes?&lt;/li&gt; &#xA; &lt;li&gt;How do we distinguish nested routes from parent routes in our &lt;code&gt;routes.rb&lt;/code&gt; file?&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://guides.rubyonrails.org/routing.html#nested-resources&#34;&gt;Routing: Nested Resources&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-4-using-active-model-serializer</title>
    <updated>2022-11-28T01:37:18Z</updated>
    <id>tag:github.com,2022-11-28:/learn-co-curriculum/phase-4-using-active-model-serializer</id>
    <link href="https://github.com/learn-co-curriculum/phase-4-using-active-model-serializer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Active Model Serializer&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Understand the purpose of a serializer in a JSON API application&lt;/li&gt; &#xA; &lt;li&gt;Configure &lt;code&gt;ActiveModel::Serializer&lt;/code&gt; with a single model&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;So far, we&#39;ve learned how to create a Rails API and to set up our routes and controller actions to handle various requests and return the requested JSON. In this section, we&#39;ll learn how to customize the JSON that we return.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s start by taking a look at our movie app. To set up the app, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle install&#xA;$ rails db:migrate db:seed&#xA;$ rails s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We have two actions set up: index and show. If you navigate to &lt;code&gt;localhost:3000/movies/1&lt;/code&gt;, you should see:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;id&#34;: 1,&#xA;  &#34;title&#34;: &#34;The Color Purple&#34;,&#xA;  &#34;year&#34;: 1985,&#xA;  &#34;length&#34;: 154,&#xA;  &#34;director&#34;: &#34;Steven Spielberg&#34;,&#xA;  &#34;description&#34;: &#34;Whoopi Goldberg brings Alice Walker&#39;s Pulitzer Prize-winning feminist novel to life as Celie, a Southern woman who suffered abuse over decades. A project brought to a hesitant Steven Spielberg by producer Quincy Jones, the film marks Spielberg&#39;s first female lead.&#34;,&#xA;  &#34;poster_url&#34;: &#34;https://pisces.bbystatic.com/image2/BestBuy_US/images/products/3071/3071213_so.jpg&#34;,&#xA;  &#34;category&#34;: &#34;Drama&#34;,&#xA;  &#34;discount&#34;: false,&#xA;  &#34;female_director&#34;: false,&#xA;  &#34;created_at&#34;: &#34;2021-05-21T17:11:35.682Z&#34;,&#xA;  &#34;updated_at&#34;: &#34;2021-05-21T17:11:35.682Z&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Rails makes it very easy to provide this JSON: all we needed to do was set up a &lt;code&gt;show&lt;/code&gt; route in &lt;code&gt;routes.rb&lt;/code&gt;, and a &lt;code&gt;show&lt;/code&gt; action in our controller. But so far, we have no control over specifically what information is returned. For example, we might decide that we don&#39;t need to include the &lt;code&gt;created_at&lt;/code&gt; or &lt;code&gt;updated_at&lt;/code&gt; attributes in our list. One way we could do this is by using Active Record&#39;s built-in &lt;code&gt;to_json&lt;/code&gt; method in our controller. It might look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# app/controllers/movies_controller.rb&#xA;def show&#xA;  movie = Movie.find(params[:id])&#xA;  render json: movie.to_json(only: [:id, :title, :year, :length, :director, :description, :poster_url, :category, :discount, :female_director])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can simplify matters with the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def show&#xA;  movie = Movie.find(params[:id])&#xA;  render json: movie.to_json(except: [:created_at, :updated_at])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is fairly straightforward so far. But what if we also had a nested resource we wanted to include? For example, if we had a blogging app in which posts belong to authors, we might want to do something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def show&#xA;  post = Post.find(params[:id])&#xA;  render json: post.to_json(only: [:title, :description, :id], include: [author: { only: [:name]}])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Even in this very simple case, you can see how building out JSON strings by hand would get to be very cumbersome â€” and very error-prone â€” very quickly.&lt;/p&gt; &#xA;&lt;p&gt;But there&#39;s an additional problem with this approach: it does not exhibit good separation of concerns. Recall that, in a full-stack Rails app, the controller&#39;s job is to interact with the model to access whatever data is requested and then pass that data along to the View layer. The views are responsible for determining exactly how the information is presented to the user. The same should be true here: rather than depending on the controller to determine how the data is returned, that task should be handled elsewhere. Enter &lt;code&gt;ActiveModel::Serializer&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;ActiveModel::Serializer&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;ActiveModel::Serializer&lt;/code&gt; (or AMS) provides an easy way to customize how the JSON rendered by our controllers is structured. It is a very &#34;Rails-y&#34; tool, in that it uses a &#34;convention over configuration&#34; approach, and is consistent with separation of concerns. Let&#39;s take a look at how we can use it to render the JSON for our movie app.&lt;/p&gt; &#xA;&lt;h3&gt;Using AMS&lt;/h3&gt; &#xA;&lt;p&gt;First we need to add the gem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# Gemfile&#xA;#...&#xA;gem &#39;active_model_serializers&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run &lt;code&gt;bundle install&lt;/code&gt; to activate the gem. Now we need to generate an &lt;code&gt;ActiveModel::Serializer&lt;/code&gt; for our &lt;code&gt;Movie&lt;/code&gt; model. Thankfully, the gem provides a generator for that. Drop into your console and run:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;rails g serializer movie&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Take a look at the generated &lt;code&gt;movie_serializer.rb&lt;/code&gt; in the &lt;code&gt;app/serializers&lt;/code&gt; directory. It should look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# app/serializers/movie_serializer.rb&#xA;class MovieSerializer &amp;lt; ActiveModel::Serializer&#xA;  attributes :id&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To customize our JSON, we simply provide the list of &lt;code&gt;attributes&lt;/code&gt; that we want to be included:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class MovieSerializer &amp;lt; ActiveModel::Serializer&#xA;  attributes :id, :title, :year, :length, :director, :description, :poster_url, :category, :discount, :female_director&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With this in place, we can return our &lt;code&gt;movies_controller&lt;/code&gt; to its original state:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# app/controllers/movies_controller.rb&#xA;def show&#xA;  movie = Movie.find(params[:id])&#xA;  render json: movie&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Much better!&lt;/p&gt; &#xA;&lt;p&gt;AMS provides a convention-based approach to serializing our resources, which means that if we have a &lt;code&gt;Movie&lt;/code&gt; model, we can also have a &lt;code&gt;MovieSerializer&lt;/code&gt; serializer, and by default, Rails will use our serializer if we simply call &lt;code&gt;render json: movie&lt;/code&gt; in our controller.&lt;/p&gt; &#xA;&lt;p&gt;Now, if you return to the browser and navigate to &lt;code&gt;localhost:3000/movies&lt;/code&gt; or &lt;code&gt;localhost:3000/movies/:id&lt;/code&gt;, you&#39;ll see that we&#39;re rendering just the JSON we want.&lt;/p&gt; &#xA;&lt;h3&gt;Custom Methods&lt;/h3&gt; &#xA;&lt;p&gt;So far, we&#39;ve used AMS to return the values of the attributes for our &lt;code&gt;Movie&lt;/code&gt; instances. But AMS also allows us to customize the information returned using an instance method on the &lt;code&gt;MovieSerializer&lt;/code&gt; class. For example, say we wanted to create a movie summary that consisted of the movie&#39;s title and the first 50 characters of its description.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s start by adding &lt;code&gt;summary&lt;/code&gt; to the list of attributes. Next, we&#39;ll define our method. For now, Let&#39;s put a &lt;code&gt;byebug&lt;/code&gt; in the method&#39;s body:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class MovieSerializer &amp;lt; ActiveModel::Serializer&#xA;  attributes :id, :title, :year, :length, :director, :description, :poster_url, :category, :discount, :female_director, :summary&#xA;&#xA;  def summary&#xA;    byebug&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Refresh the page in the browser so you drop into &lt;code&gt;byebug&lt;/code&gt; and enter &lt;code&gt;self&lt;/code&gt; at the &lt;code&gt;byebug&lt;/code&gt; prompt. The &lt;code&gt;MovieSerializer&lt;/code&gt; instance that&#39;s returned includes an &lt;code&gt;object&lt;/code&gt; attribute which, in turn, contains the first movie instance. This means you can enter &lt;code&gt;self.object&lt;/code&gt; in &lt;code&gt;byebug&lt;/code&gt; to access the movie instance, and &lt;code&gt;self.object.&amp;lt;attribute_name&amp;gt;&lt;/code&gt; to access a specific attribute.&lt;/p&gt; &#xA;&lt;p&gt;With this information, let&#39;s enter &lt;code&gt;q&lt;/code&gt; to break out of the &lt;code&gt;byebug&lt;/code&gt;, and create our &lt;code&gt;summary&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def summary&#xA;  &#34;#{self.object.title} - #{self.object.description[0..49]}...&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Restart the server and navigate back to &lt;code&gt;localhost:3000/movies&lt;/code&gt; and you should see our new summary added at the end of the JSON.&lt;/p&gt; &#xA;&lt;h2&gt;Explicitly Specifying a Serializer&lt;/h2&gt; &#xA;&lt;p&gt;So far, we have depended on Rails naming conventions for our serializers. When we ran &lt;code&gt;rails g serializer movie&lt;/code&gt;, the AMS gem automatically created a &lt;code&gt;MovieSerializer&lt;/code&gt; class for us. Whenever we use &lt;code&gt;render json:&lt;/code&gt; with a &lt;code&gt;Movie&lt;/code&gt; instance or a collection of &lt;code&gt;Movie&lt;/code&gt; instances, Rails will follow naming conventions and &lt;strong&gt;implicitly&lt;/strong&gt; look for a serializer that matches the name of the model.&lt;/p&gt; &#xA;&lt;p&gt;Sometimes, however, we might want to create a custom serializer that doesn&#39;t follow Rails naming conventions; for example, we might have multiple different serializers for our &lt;code&gt;Movie&lt;/code&gt; class depending on what information our frontend application needs. In that case, we&#39;ll need to &lt;strong&gt;explicitly&lt;/strong&gt; specify the serializer to be used.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s say, for example, that we decided we wanted to create a custom serializer solely for displaying our movie summary. First, let&#39;s create a new file, &lt;code&gt;movie_summary_serializer.rb&lt;/code&gt;, and move our custom method into it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class MovieSummarySerializer &amp;lt; ActiveModel::Serializer&#xA;  attributes :summary&#xA;&#xA;  def summary&#xA;    &#34;#{self.object.title} - #{self.object.description[0..49]}...&#34;&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To use our summary, we&#39;ll add a new route to &lt;code&gt;routes.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# config/routes.rb&#xA;...&#xA;get &#39;/movies/:id/summary&#39;, to: &#39;movies#summary&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And, finally, add a &lt;code&gt;summary&lt;/code&gt; action to our controller. In it, we specify that we want to use our new serializer to render the requested information:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# app/controllers/movies_controller.rb&#xA;def summary&#xA;  movie = Movie.find(params[:id])&#xA;  render json: movie, serializer: MovieSummarySerializer&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now if you navigate to &lt;code&gt;localhost:3000/movies/1/summary&lt;/code&gt; in the browser, you should see:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;summary&#34;: &#34;The Color Purple - Whoopi Goldberg brings Alice Walker&#39;s Pulitzer Pri...&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The code above allows us to easily display just our movie summary for a single movie. If we wanted to use our new custom serializer to render the full collection of movies, we would need to create another route and action:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# config/routes.rb&#xA;...&#xA;get &#39;/movie_summaries&#39;, to: &#39;movies#summaries&#39;&#xA;&#xA;# app/controllers/movies_controller.rb&#xA;def summaries&#xA;  movies = Movie.all&#xA;  render json: movies, each_serializer: MovieSummarySerializer&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The use of &lt;code&gt;each_serializer: MovieSummarySerializer&lt;/code&gt; in our action tells the app to use our custom movie summary serializer to render each of the movies in the collection.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;A note on breaking convention: by creating these custom routes, we are breaking REST conventions. One alternate way to structure this kind of feature and keep our routes and controllers RESTful would be to create a new controller, such as Movies::SummaryController. The creator of Rails, DHH, advocates for &lt;a href=&#34;http://jeromedalbert.com/how-dhh-organizes-his-rails-controllers/&#34;&gt;this approach for managing sub-resources&lt;/a&gt;. Ultimately, it is up to you as the developer to decide which approach works best for a particular circumstance.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;In this lesson, we learned that the &lt;code&gt;ActiveModel::Serializer&lt;/code&gt; gem enables us to customize how we want our JSON to be rendered without sacrificing the Rails principles of &#34;convention over configuration&#34; and separation of concerns. We also learned how to implement AMS with a single model. In the next lesson, we&#39;ll look at using AMS to serialize associations.&lt;/p&gt; &#xA;&lt;h2&gt;Check For Understanding&lt;/h2&gt; &#xA;&lt;p&gt;Before you move on, make sure you can answer the following questions:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;What do we mean when we say Active Model Serializer uses a convention-based approach?&lt;/li&gt; &#xA; &lt;li&gt;What are some ways to break convention when using &lt;code&gt;ActiveModel::Serializer&lt;/code&gt;?&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rails-api/active_model_serializers/tree/v0.10.6/docs&#34;&gt;ActiveModel::Serializer Documentation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-4-debugging-network-requests-lab</title>
    <updated>2022-11-28T01:37:18Z</updated>
    <id>tag:github.com,2022-11-28:/learn-co-curriculum/phase-4-debugging-network-requests-lab</id>
    <link href="https://github.com/learn-co-curriculum/phase-4-debugging-network-requests-lab" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Putting it All Together: Client-Server Communication&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Understand how to communicate between client and server using fetch, and how the server will process the request based on the URL, HTTP verb, and request body&lt;/li&gt; &#xA; &lt;li&gt;Debug common problems that occur as part of the request-response cycle&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Just like the last lesson, we&#39;ve got code for a React frontend and Rails API backend set up. This time though, it&#39;s up to you to use your debugging skills to find and fix the errors!&lt;/p&gt; &#xA;&lt;p&gt;To get the backend set up, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle install&#xA;$ rails db:migrate db:seed&#xA;$ rails s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, in a new terminal, run the frontend:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ npm install --prefix client&#xA;$ npm start --prefix client&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Confirm both applications are up and running by visiting &lt;a href=&#34;http://localhost:4000&#34;&gt;&lt;code&gt;localhost:4000&lt;/code&gt;&lt;/a&gt; and viewing the list of toys in your React application.&lt;/p&gt; &#xA;&lt;h2&gt;Deliverables&lt;/h2&gt; &#xA;&lt;p&gt;In this application, we have the following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Display a list of all the toys&lt;/li&gt; &#xA; &lt;li&gt;Add a new toy when the toy form is submitted&lt;/li&gt; &#xA; &lt;li&gt;Update the number of likes for a toy&lt;/li&gt; &#xA; &lt;li&gt;Donate a toy to Goodwill (and delete it from our database)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The code is in place for all these features on our frontend, but there are some problems with our API! We&#39;re able to display all the toys, but the other three features are broken.&lt;/p&gt; &#xA;&lt;p&gt;Use your debugging tools to find and fix these issues.&lt;/p&gt; &#xA;&lt;p&gt;There are no tests for this lesson, so you&#39;ll need to do your debugging in the browser and using the Rails server logs and &lt;code&gt;byebug&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: You shouldn&#39;t need to modify any of the React code to get the application working. You should only need to change the code for the Rails API.&lt;/p&gt; &#xA;&lt;p&gt;As you work on debugging these issues, use the space in this README file to take notes about your debugging process. Being a strong debugger is all about developing a process, and it&#39;s helpful to document your steps as part of developing your own process.&lt;/p&gt; &#xA;&lt;h2&gt;Your Notes Here&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Add a new toy when the toy form is submitted&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;How I debugged:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Update the number of likes for a toy&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;How I debugged:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Donate a toy to Goodwill (and delete it from our database)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;How I debugged:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>