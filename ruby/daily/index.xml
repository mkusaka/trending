<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-08-03T01:36:12Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Shopify/roast</title>
    <updated>2025-08-03T01:36:12Z</updated>
    <id>tag:github.com,2025-08-03:/Shopify/roast</id>
    <link href="https://github.com/Shopify/roast" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Structured AI workflows made easy&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/user-attachments/assets/f9b1ace2-5478-4f4a-ac8e-5945ed75c5b4&#34; alt=&#34;roast-horiz-logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Roast&lt;/h1&gt; &#xA;&lt;p&gt;A convention-oriented framework for creating structured AI workflows, maintained by the Augmented Engineering team at Shopify.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ gem install roast-ai&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or add to your Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;roast-ai&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Why you should use Roast&lt;/h2&gt; &#xA;&lt;p&gt;Roast provides a structured, declarative approach to building AI workflows with:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Convention over configuration&lt;/strong&gt;: Define powerful workflows using simple YAML configuration files and prompts written in markdown (with ERB support)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Built-in tools&lt;/strong&gt;: Ready-to-use tools for file operations, search, and AI interactions&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ruby integration&lt;/strong&gt;: When prompts aren&#39;t enough, write custom steps in Ruby using a clean, extensible architecture&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Shared context&lt;/strong&gt;: Each step shares its conversation transcript with its parent workflow by default&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Step customization&lt;/strong&gt;: Steps can be fully configured with their own AI models and parameters.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Session replay&lt;/strong&gt;: Rerun previous sessions starting at a specified step to speed up development time&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Parallel execution&lt;/strong&gt;: Run multiple steps concurrently to speed up workflow execution&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Function caching&lt;/strong&gt;: Flexibly cache the results of tool function calls to speed up workflows&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Extensive instrumentation&lt;/strong&gt;: Monitor and track workflow execution, AI calls, and tool usage (&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/roast/main/docs/INSTRUMENTATION.md&#34;&gt;see instrumentation documentation&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What does it look like?&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s a simple workflow that analyzes test files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: analyze_tests&#xA;# Default model for all steps&#xA;model: gpt-4o-mini&#xA;tools:&#xA;  - Roast::Tools::ReadFile&#xA;  - Roast::Tools::Grep&#xA;&#xA;steps:&#xA;  - read_test_file&#xA;  - analyze_coverage&#xA;  - generate_report&#xA;&#xA;# Step-specific model overrides the global model&#xA;analyze_coverage:&#xA;  model: gpt-4-turbo&#xA;  json: true&#xA;&#xA;# Step-specific config that specifies a custom path, not in the current directory&#xA;generate_report:&#xA;  path: ../reporting/generate_report&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each step can have its own prompt file (e.g., &lt;code&gt;analyze_coverage/prompt.md&lt;/code&gt;) and configuration. Steps can be run in parallel by nesting them in arrays:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - prepare_data&#xA;  -&#xA;    - analyze_code_quality&#xA;    - check_test_coverage&#xA;    - verify_documentation&#xA;  - generate_final_report&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Workflows can include steps that run bash commands (wrap in &lt;code&gt;$()&lt;/code&gt;), use interpolation with &lt;code&gt;{{}}&lt;/code&gt; syntax, and even simple inlined prompts as a natural language string.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - analyze_spec&#xA;  - create_minitest&#xA;  - run_and_improve&#xA;  - $(bundle exec rubocop -A {{file}})&#xA;  - Summarize the changes made to {{File.basename(file)}}.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Try it&lt;/h2&gt; &#xA;&lt;p&gt;If you donâ€™t have one already, get an OpenAI key from &lt;a href=&#34;https://platform.openai.com/settings/organization/api-keys&#34;&gt;here&lt;/a&gt;. You will need an account with a credit card and credits applied to the associated project. Make sure that a basic completion works:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export OPENAI_API_KEY=sk-proj-....&#xA;&#xA;curl -H &#34;Content-Type: application/json&#34; \&#xA;    -H &#34;Authorization: Bearer $OPENAI_API_KEY&#34; \&#xA;    -d &#39;{&#34;model&#34;:&#34;gpt-4.1-mini&#34;,&#34;messages&#34;:[{&#34;role&#34;:&#34;user&#34;,&#34;content&#34;:&#34;What is 1+1?&#34;}]}&#39; \&#xA;    https://api.openai.com/v1/chat/completions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/roast/main/examples/grading/workflow.md&#34;&gt;test grading workflow&lt;/a&gt; in this repository is a senior software engineer and testing expert that evaluates the quality of a test based on guidelines.&lt;/p&gt; &#xA;&lt;p&gt;Try the workflow.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./exe/roast execute examples/grading/workflow.yml test/roast/resources_test.rb&#xA;&#xA;ðŸ”¥ðŸ”¥ðŸ”¥ Everyone loves a good roast ðŸ”¥ðŸ”¥ðŸ”¥&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will output a test grade.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;========== TEST GRADE REPORT ==========&#xA;Test file: test/roast/resources_test.rb&#xA;&#xA;FINAL GRADE:&#xA;  Score: 80/100&#xA;  Letter Grade: B&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that you may also need &lt;code&gt;shadowenv&lt;/code&gt; and &lt;code&gt;rg&lt;/code&gt;, on MacOS run &lt;code&gt;brew install shadowenv&lt;/code&gt; and &lt;code&gt;brew install rg&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How to use Roast&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a workflow YAML file defining your steps and tools&lt;/li&gt; &#xA; &lt;li&gt;Create prompt files for each step (e.g., &lt;code&gt;step_name/prompt.md&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Run the workflow:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# With a target file&#xA;roast execute workflow.yml target_file.rb&#xA;&#xA;# Or for a targetless workflow (API calls, data generation, etc.)&#xA;roast execute workflow.yml&#xA;&#xA;# Roast will automatically search in `project_root/roast/workflow_name` if the path is incomplete.&#xA;roast execute my_cool_workflow # Equivalent to `roast execute roast/my_cool_workflow/workflow.yml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Understanding Workflows&lt;/h3&gt; &#xA;&lt;p&gt;In Roast, workflows maintain a single conversation with the AI model throughout execution. Each step represents one or more user-assistant interactions within this conversation, with optional tool calls. Steps naturally build upon each other through the shared context.&lt;/p&gt; &#xA;&lt;h4&gt;Step Types&lt;/h4&gt; &#xA;&lt;p&gt;Roast supports several types of steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Standard step&lt;/strong&gt;: References a directory containing at least a &lt;code&gt;prompt.md&lt;/code&gt; and optional &lt;code&gt;output.txt&lt;/code&gt; template. This is the most common type of step.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - analyze_code&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As an alternative to a directory, you can also implement a custom step as a Ruby class, optionally extending &lt;code&gt;Roast::Workflow::BaseStep&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In the example given above, the script would live at &lt;code&gt;workflow/analyze_code.rb&lt;/code&gt; and should contain a class named &lt;code&gt;AnalyzeCode&lt;/code&gt; with an initializer that takes a workflow object as context, and a &lt;code&gt;call&lt;/code&gt; method that will be invoked to run the step. The result of the &lt;code&gt;call&lt;/code&gt; method will be stored in the &lt;code&gt;workflow.output&lt;/code&gt; hash.&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Parallel steps&lt;/strong&gt;: Groups of steps executed concurrently&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  -&#xA;    - analyze_code_quality&#xA;    - check_test_coverage&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Command execution step&lt;/strong&gt;: Executes shell commands directly, just wrap in &lt;code&gt;$(expr)&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - $(command line expr)&#xA;  - rubocop: $(bundle exec rubocop -A)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This will execute the command and store the result in the workflow output hash. Explicit key name is optional (&lt;code&gt;rubocop&lt;/code&gt; in the second line of the example).&lt;/p&gt; &lt;p&gt;By default, commands that exit with non-zero status will halt the workflow. You can configure steps to continue on error:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - lint_check: $(rubocop {{file}})&#xA;  - fix_issues&#xA;&#xA;# Step configuration&#xA;lint_check:&#xA;  exit_on_error: false  # Continue workflow even if command fails&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;When &lt;code&gt;exit_on_error: false&lt;/code&gt;, the command output will include the exit status, allowing subsequent steps to process error information.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Conditional steps&lt;/strong&gt;: Execute different steps based on conditions using &lt;code&gt;if/unless&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - check_environment:&#xA;      if: &#34;{{ENV[&#39;RAILS_ENV&#39;] == &#39;production&#39;}}&#34;&#xA;      then:&#xA;        - run_production_checks&#xA;        - notify_team&#xA;      else:&#xA;        - run_development_setup&#xA;&#xA;  - verify_dependencies:&#xA;      unless: &#34;$(bundle check)&#34;&#xA;      then:&#xA;        - bundle_install: &#34;$(bundle install)&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Conditions can be:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Ruby expressions: &lt;code&gt;if: &#34;{{output[&#39;count&#39;] &amp;gt; 5}}&#34;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Bash commands: &lt;code&gt;if: &#34;$(test -f config.yml &amp;amp;&amp;amp; echo true)&#34;&lt;/code&gt; (exit code 0 = true)&lt;/li&gt; &#xA;   &lt;li&gt;Step references: &lt;code&gt;if: &#34;previous_step_name&#34;&lt;/code&gt; (uses the step&#39;s output)&lt;/li&gt; &#xA;   &lt;li&gt;Direct values: &lt;code&gt;if: &#34;true&#34;&lt;/code&gt; or &lt;code&gt;if: &#34;false&#34;&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Iteration steps&lt;/strong&gt;: Loop over collections or repeat steps with conditions&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  # Loop over a collection&#xA;  - process_files:&#xA;      each: &#34;{{Dir.glob(&#39;**/*.rb&#39;)}}&#34;&#xA;      as: current_file&#xA;      steps:&#xA;        - analyze_file&#xA;        - Generate a report for {{current_file}}&#xA;&#xA;  # Repeat until a condition is met&#xA;  - improve_code:&#xA;      repeat:&#xA;        until: &#34;{{output[&#39;test_pass&#39;] == true}}&#34;&#xA;        max_iterations: 5&#xA;        steps:&#xA;          - run_tests&#xA;          - fix_issues&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Each loops support:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Collections from Ruby expressions: &lt;code&gt;each: &#34;{{[1, 2, 3]}}&#34;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Command output: &lt;code&gt;each: &#34;$(ls *.rb)&#34;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Step references: &lt;code&gt;each: &#34;file_list&#34;&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Repeat loops support:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Until conditions: &lt;code&gt;until: &#34;{{condition}}&#34;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Maximum iterations: &lt;code&gt;max_iterations: 10&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Case/when/else steps&lt;/strong&gt;: Select different execution paths based on a value (similar to Ruby&#39;s case statement)&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - detect_language&#xA;&#xA;  - case: &#34;{{ workflow.output.detect_language }}&#34;&#xA;    when:&#xA;      ruby:&#xA;        - lint_with_rubocop&#xA;        - test_with_rspec&#xA;      javascript:&#xA;        - lint_with_eslint&#xA;        - test_with_jest&#xA;      python:&#xA;        - lint_with_pylint&#xA;        - test_with_pytest&#xA;    else:&#xA;      - analyze_generic&#xA;      - generate_basic_report&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Case expressions can be:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Workflow outputs: &lt;code&gt;case: &#34;{{ workflow.output.variable }}&#34;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Ruby expressions: &lt;code&gt;case: &#34;{{ count &amp;gt; 10 ? &#39;high&#39; : &#39;low&#39; }}&#34;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Bash commands: &lt;code&gt;case: &#34;$(echo $ENVIRONMENT)&#34;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Direct values: &lt;code&gt;case: &#34;production&#34;&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;The value is compared against each key in the &lt;code&gt;when&lt;/code&gt; clause, and matching steps are executed. If no match is found, the &lt;code&gt;else&lt;/code&gt; steps are executed (if provided).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Raw prompt step&lt;/strong&gt;: Simple text prompts for the model without tools&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - Summarize the changes made to the codebase.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This creates a simple prompt-response interaction without tool calls or looping. It&#39;s detected by the presence of spaces in the step name and is useful for summarization or simple questions at the end of a workflow.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Agent step&lt;/strong&gt;: Direct pass-through to coding agents (e.g., Claude Code)&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - ^fix_linting_errors                                    # File-based agent prompt&#xA;  - ^Review the code and identify any performance issues   # Inline agent prompt&#xA;  - regular_analysis                                       # Normal step through LLM&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Agent steps are prefixed with &lt;code&gt;^&lt;/code&gt; and send the prompt content directly to the CodingAgent tool without LLM translation. This is useful when you want to give precise instructions to a coding agent without the intermediate interpretation layer. Agent steps support both file-based prompts (&lt;code&gt;fix_linting_errors/prompt.md&lt;/code&gt;) and inline prompts (text with spaces).&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Session continuity for agent steps:&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Agent steps support two options for maintaining Claude context across steps:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;&lt;strong&gt;&lt;code&gt;continue: true&lt;/code&gt;&lt;/strong&gt; - Continues from the immediately previous Claude Code session (note, if multiple Claude Code sessions are being run in parallel in the same working directory, this might not be the previous Claude Code session from this workflow)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;&lt;code&gt;resume: step_name&lt;/code&gt;&lt;/strong&gt; - Resumes from a specific earlier step&#39;s Claude Code session&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;p&gt;&lt;strong&gt;Continue option:&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;The &lt;code&gt;continue&lt;/code&gt; option allows sequential agent steps to maintain a continuous conversation:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - ^analyze_codebase&#xA;  - ^implement_feature&#xA;  - ^add_tests&#xA;&#xA;# Configuration&#xA;analyze_codebase:&#xA;  continue: false  # Start fresh (default)&#xA;&#xA;implement_feature:&#xA;  continue: true   # Continue from immediately previous analyze_codebase step&#xA;&#xA;add_tests:&#xA;  continue: true   # Continue from immediately previous implement_feature step&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;Resume functionality for agent steps:&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Agent steps can resume from specific previous Claude Code sessions:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - ^analyze_codebase&#xA;  - ^implement_feature&#xA;  - ^polish_implementation&#xA;&#xA;# Configuration&#xA;analyze_codebase:&#xA;  continue: false  # Start fresh&#xA;&#xA;implement_feature:&#xA;  continue: true   # Continue from previous conversation&#xA;&#xA;polish_implementation:&#xA;  resume: analyze_codebase  # Resume from a specific step&#39;s session not the immediately previous one&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Note: Session IDs are only available when the CodingAgent is configured to output JSON format (includes &lt;code&gt;--output-format stream-json&lt;/code&gt; in the command). If you are using a custom CodingAgent command that does not produce JSON output, resume functionality will not be available.&lt;/p&gt; &lt;p&gt;If &lt;code&gt;resume&lt;/code&gt; is specified but the step name given does not have CodingAgent session to resume from, the CodingAgent will start Claude Code with a fresh session.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Shell script step&lt;/strong&gt;: Execute shell scripts directly as workflow steps&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - setup_environment     # Executes setup_environment.sh&#xA;  - run_tests             # Executes run_tests.sh  &#xA;  - cleanup&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Shell script steps allow you to execute &lt;code&gt;.sh&lt;/code&gt; files directly as workflow steps alongside Ruby steps and AI prompts. Scripts are automatically discovered in the same locations as other step types.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Configuration options:&lt;/strong&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# Step configuration  &#xA;my_script:&#xA;  json: true              # Parse stdout as JSON&#xA;  exit_on_error: false    # Don&#39;t fail workflow on non-zero exit&#xA;  env:                    # Custom environment variables&#xA;    CUSTOM_VAR: &#34;value&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;Environment integration:&lt;/strong&gt; Shell scripts automatically receive workflow context:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;ROAST_WORKFLOW_RESOURCE&lt;/code&gt;: Current workflow resource&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;ROAST_STEP_NAME&lt;/code&gt;: Current step name&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;ROAST_WORKFLOW_OUTPUT&lt;/code&gt;: Previous step outputs as JSON&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;&lt;strong&gt;Example script (&lt;code&gt;setup_environment.sh&lt;/code&gt;):&lt;/strong&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash&#xA;echo &#34;Setting up environment for: $ROAST_WORKFLOW_RESOURCE&#34;&#xA;&#xA;# Create a config file that subsequent steps can use&#xA;mkdir -p tmp&#xA;echo &#34;DATABASE_URL=sqlite://test.db&#34; &amp;gt; tmp/config.env&#xA;&#xA;# Output data for the workflow (available via ROAST_WORKFLOW_OUTPUT in later steps)&#xA;echo &#39;{&#34;status&#34;: &#34;configured&#34;, &#34;database&#34;: &#34;sqlite://test.db&#34;, &#34;config_file&#34;: &#34;tmp/config.env&#34;}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Input step&lt;/strong&gt;: Interactive prompts for user input during workflow execution&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - analyze_code&#xA;  - get_user_feedback:&#xA;      prompt: &#34;Should we proceed with the refactoring? (yes/no)&#34;&#xA;      type: confirm&#xA;  - review_changes:&#xA;      prompt: &#34;Enter your review comments&#34;&#xA;      type: text&#xA;  - select_strategy:&#xA;      prompt: &#34;Choose optimization strategy&#34;&#xA;      type: select&#xA;      options:&#xA;        - &#34;Performance optimization&#34;&#xA;        - &#34;Memory optimization&#34;&#xA;        - &#34;Code clarity&#34;&#xA;  - api_configuration:&#xA;      prompt: &#34;Enter API key&#34;&#xA;      type: password&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Input steps pause workflow execution to collect user input. They support several types:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;text&lt;/code&gt;: Free-form text input (default if type not specified)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;confirm&lt;/code&gt;: Yes/No confirmation prompts&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;select&lt;/code&gt;: Choice from a list of options&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;password&lt;/code&gt;: Masked input for sensitive data&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;The user&#39;s input is stored in the workflow output using the step name as the key and can be accessed in subsequent steps via interpolation (e.g., &lt;code&gt;{{output.get_user_feedback}}&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Step Configuration&lt;/h4&gt; &#xA;&lt;p&gt;Steps can be configured with various options to control their behavior:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - analyze_code           # Simple step reference&#xA;  - generate_report:       # Step with configuration&#xA;      model: gpt-4o        # Override the global model for this step&#xA;      print_response: true # Explicitly control output printing&#xA;      json: true           # Request JSON-formatted response&#xA;      params:              # Additional parameters for the API call&#xA;        temperature: 0.8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Configuration options:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;model&lt;/code&gt;: Override the workflow&#39;s default model for this specific step&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;print_response&lt;/code&gt;: Control whether the step&#39;s response is included in the final output (default: &lt;code&gt;false&lt;/code&gt;, except for the last step which defaults to &lt;code&gt;true&lt;/code&gt; as of v0.3.1)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;json&lt;/code&gt;: Request a JSON-formatted response from the model&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;params&lt;/code&gt;: Additional parameters passed to the model API (temperature, max_tokens, etc.)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;path&lt;/code&gt;: Custom directory path for the step&#39;s prompt files&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;coerce_to&lt;/code&gt;: Type coercion for the step result (&lt;code&gt;:boolean&lt;/code&gt;, &lt;code&gt;:llm_boolean&lt;/code&gt;, &lt;code&gt;:iterable&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Automatic Last Step Output&lt;/strong&gt;: As of version 0.3.1, the last step in a workflow automatically has &lt;code&gt;print_response: true&lt;/code&gt; unless explicitly configured otherwise. This ensures that newcomers to Roast see output from their workflows by default.&lt;/p&gt; &#xA;&lt;h4&gt;Shared Configuration&lt;/h4&gt; &#xA;&lt;p&gt;Roast supports sharing common configuration and steps across multiple workflows using a &lt;code&gt;shared.yml&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Place a &lt;code&gt;shared.yml&lt;/code&gt; file one level above your workflow directory&lt;/li&gt; &#xA; &lt;li&gt;Define YAML anchors for common configurations like tools, models or steps&lt;/li&gt; &#xA; &lt;li&gt;Reference these anchors in your workflow files using YAML alias syntax&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example structure:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;my_project/&#xA;â”œâ”€â”€ shared.yml          # Common configuration anchors&#xA;â””â”€â”€ workflows/&#xA;    â”œâ”€â”€ analyze_code.yml&#xA;    â”œâ”€â”€ generate_docs.yml&#xA;    â””â”€â”€ test_suite.yml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example &lt;code&gt;shared.yml&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# Define common tools&#xA;standard_tools: &amp;amp;standard_tools&#xA;  - Roast::Tools::Grep&#xA;  - Roast::Tools::ReadFile&#xA;  - Roast::Tools::WriteFile&#xA;  - Roast::Tools::SearchFile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Using in workflows:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: Code Analysis Workflow&#xA;tools: *standard_tools         # Reference shared tools&#xA;&#xA;steps:&#xA;  ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Data Flow Between Steps&lt;/h4&gt; &#xA;&lt;p&gt;Roast handles data flow between steps in three primary ways:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Conversation Context (Implicit)&lt;/strong&gt;: The LLM naturally remembers the entire conversation history, including all previous prompts and responses. In most cases, this is all you need for a step to reference and build upon previous results. This is the preferred approach for most prompt-oriented workflows.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Output Hash (Explicit)&lt;/strong&gt;: Each step&#39;s result is automatically stored in the &lt;code&gt;workflow.output&lt;/code&gt; hash using the step name as the key. This programmatic access is mainly useful when:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You need to perform non-LLM transformations on data&lt;/li&gt; &#xA;   &lt;li&gt;You&#39;re writing custom output logic&lt;/li&gt; &#xA;   &lt;li&gt;You need to access specific values for presentation or logging&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Interpolation (Dynamic)&lt;/strong&gt;: You can use &lt;code&gt;{{expression}}&lt;/code&gt; syntax to inject values from the workflow context directly into step names, commands, or prompt text. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - analyze_file&#xA;  - $(rubocop -A {{file}})&#xA;  - Generate a summary for {{file}}&#xA;  - result_for_{{file}}: store_results&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Interpolation supports:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Simple variable access: &lt;code&gt;{{file}}&lt;/code&gt;, &lt;code&gt;{{resource.target}}&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Access to step outputs: &lt;code&gt;{{output[&#39;previous_step&#39;]}}&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Any valid Ruby expression evaluated in the workflow context: &lt;code&gt;{{File.basename(file)}}&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For typical AI workflows, the continuous conversation history provides seamless data flow without requiring explicit access to the output hash. Steps can simply refer to previous information in their prompts, and the AI model will use its memory of the conversation to provide context-aware responses. For more dynamic requirements, the interpolation syntax provides a convenient way to inject context-specific values into steps.&lt;/p&gt; &#xA;&lt;h3&gt;Command Line Options&lt;/h3&gt; &#xA;&lt;h4&gt;Basic Options&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-o, --output FILE&lt;/code&gt;: Save results to a file instead of outputting to STDOUT&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-c, --concise&lt;/code&gt;: Use concise output templates (exposed as a boolean flag on &lt;code&gt;workflow&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-v, --verbose&lt;/code&gt;: Show output from all steps as they execute&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-r, --replay STEP_NAME&lt;/code&gt;: Resume a workflow from a specific step, optionally with a specific session timestamp&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-f, --file-storage&lt;/code&gt;: Use filesystem storage for sessions instead of SQLite (default: SQLite)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Workflow Validation&lt;/h4&gt; &#xA;&lt;p&gt;Roast provides a &lt;code&gt;validate&lt;/code&gt; command to check workflow configuration files for errors and potential issues before execution:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Validate a specific workflow&#xA;roast validate workflow.yml&#xA;&#xA;# Validate a workflow in a subdirectory&#xA;roast validate my_workflow&#xA;&#xA;# Validate with strict mode (treats warnings as errors)&#xA;roast validate workflow.yml --strict&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The validator checks for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;YAML syntax errors&lt;/li&gt; &#xA; &lt;li&gt;Missing required fields&lt;/li&gt; &#xA; &lt;li&gt;Invalid step references&lt;/li&gt; &#xA; &lt;li&gt;Circular dependencies&lt;/li&gt; &#xA; &lt;li&gt;Tool availability&lt;/li&gt; &#xA; &lt;li&gt;Prompt file existence&lt;/li&gt; &#xA; &lt;li&gt;Configuration consistency&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This helps catch configuration errors early and ensures workflows will run smoothly.&lt;/p&gt; &#xA;&lt;h4&gt;Session Storage and Management&lt;/h4&gt; &#xA;&lt;p&gt;Roast uses SQLite by default for session storage, providing better performance and advanced querying capabilities. Sessions are automatically saved during workflow execution, capturing each step&#39;s state including conversation transcripts and outputs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Storage Options:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Use default SQLite storage (recommended)&#xA;roast execute workflow.yml&#xA;&#xA;# Use legacy filesystem storage&#xA;roast execute workflow.yml --file-storage&#xA;&#xA;# Set storage type via environment variable&#xA;ROAST_STATE_STORAGE=file roast execute workflow.yml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Session Management Commands:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# List all sessions&#xA;roast sessions&#xA;&#xA;# Filter sessions by status&#xA;roast sessions --status waiting&#xA;&#xA;# Filter sessions by workflow&#xA;roast sessions --workflow my_workflow&#xA;&#xA;# Show sessions older than 7 days&#xA;roast sessions --older-than 7d&#xA;&#xA;# Clean up old sessions&#xA;roast sessions --cleanup --older-than 30d&#xA;&#xA;# View detailed session information&#xA;roast session &amp;lt;session_id&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Session Replay&lt;/h4&gt; &#xA;&lt;p&gt;The session replay feature allows you to resume workflows from specific steps, saving time during development and debugging:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Resume from a specific step&#xA;roast execute workflow.yml -r step_name&#xA;&#xA;# Resume from a specific step in a specific session&#xA;roast execute workflow.yml -r 20250507_123456_789:step_name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This feature is particularly useful when:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Debugging specific steps in a long workflow&lt;/li&gt; &#xA; &lt;li&gt;Iterating on prompts without rerunning the entire workflow&lt;/li&gt; &#xA; &lt;li&gt;Resuming after failures in long-running workflows&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Storage Locations:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SQLite: &lt;code&gt;~/.roast/sessions.db&lt;/code&gt; (configurable via &lt;code&gt;ROAST_SESSIONS_DB&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Filesystem: &lt;code&gt;.roast/sessions/&lt;/code&gt; directory in your project&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Target Option (&lt;code&gt;-t, --target&lt;/code&gt;)&lt;/h4&gt; &#xA;&lt;p&gt;The target option is highly flexible and accepts several formats:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Single file path:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;roast execute workflow.yml -t path/to/file.rb&#xA;&#xA;# is equivalent to&#xA;roast execute workflow.yml path/to/file.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Directory path:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;roast execute workflow.yml -t path/to/directory&#xA;&#xA;# Roast will run on the directory as a resource&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Glob patterns:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;roast execute workflow.yml -t &#34;**/*_test.rb&#34;&#xA;&#xA;# Roast will run the workflow on each matching file&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;URL as target:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;roast execute workflow.yml -t &#34;https://api.example.com/data&#34;&#xA;&#xA;# Roast will run the workflow using the URL as a resource&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;API configuration (Fetch API-style):&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;roast execute workflow.yml -t &#39;{&#xA;  &#34;url&#34;: &#34;https://api.example.com/resource&#34;,&#xA;  &#34;options&#34;: {&#xA;    &#34;method&#34;: &#34;POST&#34;,&#xA;    &#34;headers&#34;: {&#xA;      &#34;Content-Type&#34;: &#34;application/json&#34;,&#xA;      &#34;Authorization&#34;: &#34;Bearer ${API_TOKEN}&#34;&#xA;    },&#xA;    &#34;body&#34;: {&#xA;      &#34;query&#34;: &#34;search term&#34;,&#xA;      &#34;limit&#34;: 10&#xA;    }&#xA;  }&#xA;}&#39;&#xA;&#xA;# Roast will recognize this as an API configuration with Fetch API-style format&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Shell command execution with $(...):&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;roast execute workflow.yml -t &#34;$(find . -name &#39;*.rb&#39; -mtime -1)&#34;&#xA;&#xA;# Roast will run the workflow on each file returned (expects one per line)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Git integration examples:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Process changed test files&#xA;roast execute workflow.yml -t &#34;$(git diff --name-only HEAD | grep _test.rb)&#34;&#xA;&#xA;# Process staged files&#xA;roast execute workflow.yml -t &#34;$(git diff --cached --name-only)&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Targetless Workflows&lt;/h4&gt; &#xA;&lt;p&gt;Roast also supports workflows that don&#39;t operate on a specific pre-defined set of target files:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;API-driven workflows:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: API Integration Workflow&#xA;tools:&#xA;  - Roast::Tools::ReadFile&#xA;  - Roast::Tools::WriteFile&#xA;&#xA;# Dynamic API token using shell command&#xA;api_token: $(cat ~/.my_token)&#xA;&#xA;# Option 1: Use a targetless workflow with API logic in steps&#xA;steps:&#xA;  - fetch_api_data  # Step will make API calls&#xA;  - transform_data&#xA;  - generate_report&#xA;&#xA;# Option 2: Specify an API target directly in the workflow&#xA;target: &#39;{&#xA;  &#34;url&#34;: &#34;https://api.example.com/resource&#34;,&#xA;  &#34;options&#34;: {&#xA;    &#34;method&#34;: &#34;GET&#34;,&#xA;    &#34;headers&#34;: {&#xA;      &#34;Authorization&#34;: &#34;Bearer ${API_TOKEN}&#34;&#xA;    }&#xA;  }&#xA;}&#39;&#xA;&#xA;steps:&#xA;  - process_api_response&#xA;  - generate_report&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Data generation workflows:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: Generate Documentation&#xA;tools:&#xA;  - Roast::Tools::WriteFile&#xA;steps:&#xA;  - generate_outline&#xA;  - write_documentation&#xA;  - create_examples&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These targetless workflows are ideal for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;API integrations&lt;/li&gt; &#xA; &lt;li&gt;Content generation&lt;/li&gt; &#xA; &lt;li&gt;Report creation&lt;/li&gt; &#xA; &lt;li&gt;Interactive tools&lt;/li&gt; &#xA; &lt;li&gt;Scheduled automation tasks&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Global Model Configuration&lt;/h4&gt; &#xA;&lt;p&gt;You can set a default model for all steps in your workflow by specifying the &lt;code&gt;model&lt;/code&gt; parameter at the top level:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: My Workflow&#xA;model: gpt-4o-mini  # Will be used for all steps unless overridden&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Individual steps can override this setting with their own model parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;analyze_data:&#xA;  model: anthropic/claude-3-haiku  # Takes precedence over the global model&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;API Provider Configuration&lt;/h4&gt; &#xA;&lt;p&gt;Roast supports both OpenAI and OpenRouter as API providers. By default, Roast uses OpenAI, but you can specify OpenRouter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: My Workflow&#xA;api_provider: openrouter&#xA;api_token: $(echo $OPENROUTER_API_KEY)&#xA;model: anthropic/claude-3-opus-20240229&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Benefits of using OpenRouter:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Access to multiple model providers through a single API&lt;/li&gt; &#xA; &lt;li&gt;Support for models from Anthropic, Meta, Mistral, and more&lt;/li&gt; &#xA; &lt;li&gt;Consistent API interface across different model providers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When using OpenRouter, specify fully qualified model names including the provider prefix (e.g., &lt;code&gt;anthropic/claude-3-opus-20240229&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;Dynamic API Tokens and URIs&lt;/h4&gt; &#xA;&lt;p&gt;Roast allows you to dynamically fetch attributes such as API token and URI base (to use with a proxy) via shell commands directly in your workflow configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# This will execute the shell command and use the result as the API token&#xA;api_token: $(print-token --key)&#xA;&#xA;# For OpenAI (default)&#xA;api_token: $(echo $OPENAI_API_KEY)&#xA;&#xA;# For OpenRouter (requires api_provider setting)&#xA;api_provider: openrouter&#xA;api_token: $(echo $OPENROUTER_API_KEY)&#xA;&#xA;# Static Proxy URI&#xA;uri_base: https://proxy.example.com/v1&#xA;&#xA;# Dynamic Proxy URI&#xA;uri_base: $(echo $AI_PROXY_URI_BASE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This makes it easy to use environment-specific tokens without hardcoding credentials, especially useful in development environments or CI/CD pipelines. Alternatively, Roast will fall back to &lt;code&gt;OPENROUTER_API_KEY&lt;/code&gt; or &lt;code&gt;OPENAI_API_KEY&lt;/code&gt; environment variables based on the specified provider.&lt;/p&gt; &#xA;&lt;h3&gt;Template Output with ERB&lt;/h3&gt; &#xA;&lt;p&gt;Each step can have an &lt;code&gt;output.txt&lt;/code&gt; file that uses ERB templating to format the final output. This allows you to customize how the AI&#39;s response is processed and displayed.&lt;/p&gt; &#xA;&lt;p&gt;Example &lt;code&gt;step_name/output.txt&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;% if workflow.verbose %&amp;gt;&#xA;Detailed Analysis:&#xA;&amp;lt;%= response %&amp;gt;&#xA;&amp;lt;% else %&amp;gt;&#xA;Summary: &amp;lt;%= response.lines.first %&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&#xA;Files analyzed: &amp;lt;%= workflow.file %&amp;gt;&#xA;Status: &amp;lt;%= workflow.output[&#39;status&#39;] || &#39;completed&#39; %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is an example of where the &lt;code&gt;workflow.output&lt;/code&gt; hash is useful - formatting output for display based on data from previous steps.&lt;/p&gt; &#xA;&lt;p&gt;Available in templates:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;response&lt;/code&gt;: The AI&#39;s response for this step&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;workflow&lt;/code&gt;: Access to the workflow object&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;workflow.output&lt;/code&gt;: The shared hash containing results from all steps when you need programmatic access&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;workflow.file&lt;/code&gt;: Current file being processed (or &lt;code&gt;nil&lt;/code&gt; for targetless workflows)&lt;/li&gt; &#xA; &lt;li&gt;All workflow configuration options&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For most workflows, you&#39;ll mainly use &lt;code&gt;response&lt;/code&gt; to access the current step&#39;s results. The &lt;code&gt;workflow.output&lt;/code&gt; hash becomes valuable when you need to reference specific data points from previous steps in your templates or for conditional display logic.&lt;/p&gt; &#xA;&lt;h2&gt;Advanced Features&lt;/h2&gt; &#xA;&lt;h3&gt;Workflow Metadata&lt;/h3&gt; &#xA;&lt;p&gt;Roast workflows maintain a metadata store that allows steps to share structured data beyond the standard output hash. This is particularly useful for tracking state that needs to persist across steps but shouldn&#39;t be part of the conversation context.&lt;/p&gt; &#xA;&lt;h4&gt;Setting Metadata&lt;/h4&gt; &#xA;&lt;p&gt;Metadata can be set by custom Ruby steps that extend &lt;code&gt;BaseStep&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# workflow/analyze_codebase.rb&#xA;class AnalyzeCodebase &amp;lt; Roast::Workflow::BaseStep&#xA;   include Roast::Helpers::MetadataAccess&#xA;   &#xA;  def call&#xA;    # Perform analysis&#xA;    analysis_results = perform_deep_analysis&#xA;    &#xA;    # Store metadata for other steps to use&#xA;    workflow.metadata[name.to_s] ||= {}&#xA;    workflow.metadata[name.to_s][&#34;total_files&#34;] = analysis_results[:file_count]&#xA;    workflow.metadata[name.to_s][&#34;complexity_score&#34;] = analysis_results[:complexity]&#xA;    workflow.metadata[name.to_s][&#34;analysis_id&#34;] = SecureRandom.uuid&#xA;    &#xA;    # Return the normal output for the conversation&#xA;    &#34;Analyzed #{analysis_results[:file_count]} files with average complexity of #{analysis_results[:complexity]}&#34;&#xA;  end&#xA;  &#xA;  private&#xA;  &#xA;  def perform_deep_analysis&#xA;    # Your analysis logic here&#xA;    { file_count: 42, complexity: 7.5 }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Accessing Metadata&lt;/h4&gt; &#xA;&lt;p&gt;Metadata from previous steps can be accessed in:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Custom Ruby steps:&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class GenerateReport &amp;lt; Roast::Workflow::BaseStep&#xA;  def call&#xA;    # Access metadata from a previous step&#xA;    total_files = workflow.metadata.dig(&#34;analyze_codebase&#34;, &#34;total_files&#34;)&#xA;    complexity = workflow.metadata.dig(&#34;analyze_codebase&#34;, &#34;complexity_score&#34;)&#xA;    &#xA;    &#34;Generated report for #{total_files} files with complexity score: #{complexity}&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Workflow configuration via interpolation:&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;steps:&#xA;  - analyze_codebase&#xA;  - validate_threshold&#xA;  - generate_report&#xA;&#xA;# Use metadata in step configuration&#xA;validate_threshold:&#xA;  if: &#34;{{metadata.analyze_codebase.complexity_score &amp;gt; 8.0}}&#34;&#xA;  then:&#xA;    - send_alert&#xA;    - create_ticket&#xA;  else:&#xA;    - mark_as_passed&#xA;&#xA;# Pass metadata to command steps&#xA;send_alert:&#xA;  $(slack-notify &#34;High complexity detected: {{metadata.analyze_codebase.complexity_score}}&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Prompt templates (ERB):&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;# In analyze_codebase/output.txt&#xA;Analysis Summary:&#xA;Files analyzed: &amp;lt;%= workflow.metadata.dig(name.to_s, &#34;total_files&#34;) %&amp;gt;&#xA;Complexity score: &amp;lt;%= workflow.metadata.dig(name.to_s, &#34;complexity_score&#34;) %&amp;gt;&#xA;Analysis ID: &amp;lt;%= workflow.metadata.dig(name.to_s, &#34;analysis_id&#34;) %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Metadata Best Practices&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Use metadata for data that shouldn&#39;t be in the conversation&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Don&#39;t duplicate output data:&lt;/strong&gt; Metadata complements the output hash, it doesn&#39;t replace it&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The metadata system is particularly useful for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tracking session or transaction IDs across multiple steps&lt;/li&gt; &#xA; &lt;li&gt;Storing configuration or state that tools need to access&lt;/li&gt; &#xA; &lt;li&gt;Passing data between steps without cluttering the AI conversation&lt;/li&gt; &#xA; &lt;li&gt;Implementing complex conditional logic based on computed values&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Instrumentation&lt;/h3&gt; &#xA;&lt;p&gt;Roast provides extensive instrumentation capabilities using ActiveSupport::Notifications. You can monitor workflow execution, track AI model usage, measure performance, and integrate with external monitoring systems. &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/roast/main/docs/INSTRUMENTATION.md&#34;&gt;Read the full instrumentation documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Built-in Tools&lt;/h3&gt; &#xA;&lt;p&gt;Roast provides several built-in tools that you can use in your workflows:&lt;/p&gt; &#xA;&lt;h4&gt;Tool Configuration&lt;/h4&gt; &#xA;&lt;p&gt;Tools can be configured using a hash format in your workflow YAML:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;tools:&#xA;  - Roast::Tools::ReadFile        # No configuration needed&#xA;  - Roast::Tools::Cmd:             # With configuration&#xA;      allowed_commands:&#xA;        - git&#xA;        - npm&#xA;        - yarn&#xA;  - Roast::Tools::CodingAgent:     # Optional configuration&#xA;      coding_agent_command: claude --model opus -p --allowedTools &#34;Bash, Glob, Grep, LS, Read&#34;&#xA;      model: opus                  # Model to use for all CodingAgent invocations&#xA;      retries: 3                   # Number of automatic retries on failure (default: 0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Currently supported configurations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Roast::Tools::Cmd&lt;/code&gt; via &lt;code&gt;allowed_commands&lt;/code&gt;: restricts which commands can be executed (defaults to: &lt;code&gt;pwd&lt;/code&gt;, &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;rake&lt;/code&gt;, &lt;code&gt;ruby&lt;/code&gt;, &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;mkdir&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Roast::Tools::CodingAgent&lt;/code&gt; via: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;coding_agent_command&lt;/code&gt;: customizes the Claude Code CLI command used by the agent&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;model&lt;/code&gt;: sets the model for all CodingAgent invocations (e.g., &lt;code&gt;opus&lt;/code&gt;, &lt;code&gt;sonnet&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;retries&lt;/code&gt;: number of times to automatically retry if the agent encounters an error (default: 0, no retries)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Cmd Tool Configuration&lt;/h5&gt; &#xA;&lt;p&gt;The &lt;code&gt;Cmd&lt;/code&gt; tool&#39;s &lt;code&gt;allowed_commands&lt;/code&gt; can be configured in two ways:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;1. Simple String Format&lt;/strong&gt; (uses default descriptions):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;tools:&#xA;  - Roast::Tools::Cmd:&#xA;      allowed_commands:&#xA;        - pwd&#xA;        - ls&#xA;        - git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;2. Hash Format with Custom Descriptions&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;tools:&#xA;  - Roast::Tools::Cmd:&#xA;      allowed_commands:&#xA;        - pwd&#xA;        - name: git&#xA;          description: &#34;git CLI - version control system with subcommands like status, commit, push&#34;&#xA;        - name: npm&#xA;          description: &#34;npm CLI - Node.js package manager with subcommands like install, run&#34;&#xA;        - name: docker&#xA;          description: &#34;Docker CLI - container platform with subcommands like build, run, ps&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Custom descriptions help the LLM understand when and how to use each command, making your workflows more effective.&lt;/p&gt; &#xA;&lt;h3&gt;Step-Level Tool Filtering&lt;/h3&gt; &#xA;&lt;p&gt;You can restrict which tools are available to specific steps using the &lt;code&gt;available_tools&lt;/code&gt; configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# Define all tools globally&#xA;tools:&#xA;  - Roast::Tools::Grep&#xA;  - Roast::Tools::ReadFile&#xA;  - Roast::Tools::WriteFile&#xA;  - Roast::Tools::Cmd:&#xA;      allowed_commands:&#xA;        - pwd&#xA;        - ls&#xA;        - echo&#xA;&#xA;# Configure steps with specific tool access&#xA;explore_directory:&#xA;  available_tools:&#xA;    - pwd&#xA;    - ls&#xA;&#xA;analyze_files:&#xA;  available_tools:&#xA;    - grep&#xA;    - read_file&#xA;&#xA;write_summary:&#xA;  available_tools:&#xA;    - write_file&#xA;    - echo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This feature provides:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Security&lt;/strong&gt;: Each step only has access to the tools it needs&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Performance&lt;/strong&gt;: Reduces the tool list sent to the LLM&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Clarity&lt;/strong&gt;: Makes tool usage explicit for each step&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Key points:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use snake_case tool names (e.g., &lt;code&gt;read_file&lt;/code&gt; for &lt;code&gt;Roast::Tools::ReadFile&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;For &lt;code&gt;Cmd&lt;/code&gt; tool, use the specific command names (e.g., &lt;code&gt;pwd&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;When &lt;code&gt;available_tools&lt;/code&gt; is not specified, all tools remain available (backward compatible)&lt;/li&gt; &#xA; &lt;li&gt;Empty array (&lt;code&gt;available_tools: []&lt;/code&gt;) means no tools for that step&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/roast/main/examples/available_tools_demo/&#34;&gt;available_tools_demo&lt;/a&gt; for a complete example.&lt;/p&gt; &#xA;&lt;h4&gt;ReadFile&lt;/h4&gt; &#xA;&lt;p&gt;Reads the contents of a file from the filesystem.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Basic usage&#xA;read_file(path: &#34;path/to/file.txt&#34;)&#xA;&#xA;# Reading a specific portion of a file&#xA;read_file(path: &#34;path/to/large_file.txt&#34;, offset: 100, limit: 50)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;path&lt;/code&gt; can be absolute or relative to the current working directory&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;limit&lt;/code&gt; for large files to read specific sections (line numbers)&lt;/li&gt; &#xA; &lt;li&gt;Returns the file content as a string&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;WriteFile&lt;/h4&gt; &#xA;&lt;p&gt;Writes content to a file, creating the file if it doesn&#39;t exist or overwriting it if it does.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Basic usage&#xA;write_file(path: &#34;output.txt&#34;, content: &#34;This is the file content&#34;)&#xA;&#xA;# With path restriction for security&#xA;write_file(&#xA;  path: &#34;output.txt&#34;,&#xA;  content: &#34;Restricted content&#34;,&#xA;  restrict: &#34;/safe/directory&#34; # Only allows writing to files under this path&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Creates missing directories automatically&lt;/li&gt; &#xA; &lt;li&gt;Can restrict file operations to specific directories for security&lt;/li&gt; &#xA; &lt;li&gt;Returns a success message with the number of lines written&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;UpdateFiles&lt;/h4&gt; &#xA;&lt;p&gt;Applies a unified diff/patch to one or more files. Changes are applied atomically when possible.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;update_files(&#xA;  diff: &amp;lt;&amp;lt;~DIFF,&#xA;    --- a/file1.txt&#xA;    +++ b/file1.txt&#xA;    @@ -1,3 +1,4 @@&#xA;     line1&#xA;    +new line&#xA;     line2&#xA;     line3&#xA;&#xA;    --- a/file2.txt&#xA;    +++ b/file2.txt&#xA;    @@ -5,7 +5,7 @@&#xA;     line5&#xA;     line6&#xA;    -old line7&#xA;    +updated line7&#xA;     line8&#xA;  DIFF&#xA;  base_path: &#34;/path/to/project&#34;, # Optional, defaults to current working directory&#xA;  restrict_path: &#34;/path/to/allowed&#34;, # Optional, restricts where files can be modified&#xA;  create_files: true, # Optional, defaults to true&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Accepts standard unified diff format from tools like &lt;code&gt;git diff&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Supports multiple file changes in a single operation&lt;/li&gt; &#xA; &lt;li&gt;Handles file creation, deletion, and modification&lt;/li&gt; &#xA; &lt;li&gt;Performs atomic operations with rollback on failure&lt;/li&gt; &#xA; &lt;li&gt;Includes fuzzy matching to handle minor context differences&lt;/li&gt; &#xA; &lt;li&gt;This tool is especially useful for making targeted changes to multiple files at once&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Grep&lt;/h4&gt; &#xA;&lt;p&gt;Searches file contents for a specific pattern using regular expressions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Basic usage&#xA;grep(pattern: &#34;function\\s+myFunction&#34;)&#xA;&#xA;# With file filtering&#xA;grep(pattern: &#34;class\\s+User&#34;, include: &#34;*.rb&#34;)&#xA;&#xA;# With directory scope&#xA;grep(pattern: &#34;TODO:&#34;, path: &#34;src/components&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Uses regular expressions for powerful pattern matching&lt;/li&gt; &#xA; &lt;li&gt;Can filter by file types using the &lt;code&gt;include&lt;/code&gt; parameter&lt;/li&gt; &#xA; &lt;li&gt;Can scope searches to specific directories with the &lt;code&gt;path&lt;/code&gt; parameter&lt;/li&gt; &#xA; &lt;li&gt;Returns a list of files containing matches&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;SearchFile&lt;/h4&gt; &#xA;&lt;p&gt;Provides advanced file search capabilities beyond basic pattern matching.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;search_file(query: &#34;class User&#34;, file_path: &#34;app/models&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Combines pattern matching with contextual search&lt;/li&gt; &#xA; &lt;li&gt;Useful for finding specific code structures or patterns&lt;/li&gt; &#xA; &lt;li&gt;Returns matched lines with context&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Cmd&lt;/h4&gt; &#xA;&lt;p&gt;Executes shell commands with configurable restrictions. By default, only allows specific safe commands.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Execute allowed commands (pwd, find, ls, rake, ruby, dev, mkdir by default)&#xA;pwd(args: &#34;-L&#34;)&#xA;ls(args: &#34;-la&#34;)&#xA;ruby(args: &#34;-e &#39;puts RUBY_VERSION&#39;&#34;)&#xA;&#xA;# Or use the legacy cmd function with full command&#xA;cmd(command: &#34;ls -la&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Commands are registered as individual functions based on allowed_commands configuration&lt;/li&gt; &#xA; &lt;li&gt;Default allowed commands: pwd, find, ls, rake, ruby, dev, mkdir&lt;/li&gt; &#xA; &lt;li&gt;Each command has built-in descriptions to help the LLM understand usage&lt;/li&gt; &#xA; &lt;li&gt;Configurable via workflow YAML (see Tool Configuration section)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Bash&lt;/h4&gt; &#xA;&lt;p&gt;Executes shell commands without restrictions. &lt;strong&gt;âš ï¸ WARNING: Use only in trusted environments!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Execute any command - no restrictions&#xA;bash(command: &#34;curl https://api.example.com | jq &#39;.data&#39;&#34;)&#xA;&#xA;# Complex operations with pipes and redirects&#xA;bash(command: &#34;find . -name &#39;*.log&#39; -mtime +30 -delete&#34;)&#xA;&#xA;# System administration tasks&#xA;bash(command: &#34;ps aux | grep ruby | awk &#39;{print $2}&#39;&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;No command restrictions&lt;/strong&gt; - full shell access&lt;/li&gt; &#xA; &lt;li&gt;Designed for prototyping and development environments&lt;/li&gt; &#xA; &lt;li&gt;Logs warnings by default (disable with &lt;code&gt;ROAST_BASH_WARNINGS=false&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Should NOT be used in production or untrusted contexts&lt;/li&gt; &#xA; &lt;li&gt;See &lt;code&gt;examples/bash_prototyping/&lt;/code&gt; for usage examples&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;CodingAgent&lt;/h4&gt; &#xA;&lt;p&gt;Creates a specialized agent for complex coding tasks or long-running operations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Basic usage&#xA;coding_agent(&#xA;  prompt: &#34;Refactor the authentication module to use JWT tokens&#34;,&#xA;  include_context_summary: true,  # Include workflow context in the agent prompt&#xA;  continue: true                  # Continue from previous agent session&#xA;)&#xA;&#xA;# With automatic retries on failure&#xA;coding_agent(&#xA;  prompt: &#34;Implement complex feature with error handling&#34;,&#xA;  retries: 3  # Retry up to 3 times if the agent encounters errors&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Delegates complex tasks to a specialized coding agent (Claude Code)&lt;/li&gt; &#xA; &lt;li&gt;Useful for tasks that require deep code understanding or multi-step changes&lt;/li&gt; &#xA; &lt;li&gt;Can work across multiple files and languages&lt;/li&gt; &#xA; &lt;li&gt;Supports automatic retries on transient failures (network issues, API errors)&lt;/li&gt; &#xA; &lt;li&gt;Retries can be configured globally (see Tool Configuration) or per invocation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;MCP (Model Context Protocol) Tools&lt;/h3&gt; &#xA;&lt;p&gt;Roast supports MCP tools, allowing you to integrate external services and tools through the Model Context Protocol standard. MCP enables seamless connections to databases, APIs, and specialized tools.&lt;/p&gt; &#xA;&lt;h4&gt;Configuring MCP Tools&lt;/h4&gt; &#xA;&lt;p&gt;MCP tools are configured in the &lt;code&gt;tools&lt;/code&gt; section of your workflow YAML alongside traditional Roast tools:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;tools:&#xA;  # Traditional Roast tools&#xA;  - Roast::Tools::ReadFile&#xA;&#xA;  # MCP tools with SSE (Server-Sent Events)&#xA;  - Documentation:&#xA;      url: https://gitmcp.io/myorg/myrepo/docs&#xA;      env:&#xA;        - &#34;Authorization: Bearer {{ENV[&#39;API_TOKEN&#39;]}}&#34;&#xA;&#xA;  # MCP tools with stdio&#xA;  - GitHub:&#xA;      command: npx&#xA;      args: [&#34;-y&#34;, &#34;@modelcontextprotocol/server-github&#34;]&#xA;      env:&#xA;        GITHUB_PERSONAL_ACCESS_TOKEN: &#34;{{ENV[&#39;GITHUB_TOKEN&#39;]}}&#34;&#xA;      only:&#xA;        - search_repositories&#xA;        - get_issue&#xA;        - create_issue&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SSE MCP Tools&lt;/h4&gt; &#xA;&lt;p&gt;Connect to HTTP endpoints implementing the MCP protocol:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- Tool Name:&#xA;    url: https://example.com/mcp-endpoint&#xA;    env:&#xA;      - &#34;Authorization: Bearer {{resource.api_token}}&#34;&#xA;    only: [function1, function2]  # Optional whitelist&#xA;    except: [function3]           # Optional blacklist&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Stdio MCP Tools&lt;/h4&gt; &#xA;&lt;p&gt;Connect to local processes implementing the MCP protocol:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- Tool Name:&#xA;    command: docker&#xA;    args: [&#34;run&#34;, &#34;-i&#34;, &#34;--rm&#34;, &#34;ghcr.io/example/mcp-server&#34;]&#xA;    env:&#xA;      API_KEY: &#34;{{ENV[&#39;API_KEY&#39;]}}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/roast/main/examples/mcp/&#34;&gt;MCP tools example&lt;/a&gt; for complete documentation and more examples.&lt;/p&gt; &#xA;&lt;h3&gt;Custom Tools&lt;/h3&gt; &#xA;&lt;p&gt;You can create your own tools using the &lt;a href=&#34;https://github.com/OlympiaAI/raix-rails?tab=readme-ov-file#use-of-toolsfunctions&#34;&gt;Raix function dispatch pattern&lt;/a&gt;. Custom tools should be placed in &lt;code&gt;.roast/initializers/&lt;/code&gt; (subdirectories are supported):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# .roast/initializers/tools/git_analyzer.rb&#xA;module MyProject&#xA;  module Tools&#xA;    module GitAnalyzer&#xA;      extend self&#xA;&#xA;      def self.included(base)&#xA;        base.class_eval do&#xA;          function(&#xA;            :analyze_commit,&#xA;            &#34;Analyze a git commit for code quality and changes&#34;,&#xA;            commit_sha: { type: &#34;string&#34;, description: &#34;The SHA of the commit to analyze&#34; },&#xA;            include_diff: { type: &#34;boolean&#34;, description: &#34;Include the full diff in the analysis&#34;, default: false }&#xA;          ) do |params|&#xA;            GitAnalyzer.call(params[:commit_sha], params[:include_diff])&#xA;          end&#xA;        end&#xA;      end&#xA;&#xA;      def call(commit_sha, include_diff = false)&#xA;        Roast::Helpers::Logger.info(&#34;ðŸ” Analyzing commit: #{commit_sha}\n&#34;)&#xA;&#xA;        # Your implementation here&#xA;        commit_info = `git show #{commit_sha} --stat`&#xA;        commit_info += &#34;\n\n&#34; + `git show #{commit_sha}` if include_diff&#xA;&#xA;        commit_info&#xA;      rescue StandardError =&amp;gt; e&#xA;        &#34;Error analyzing commit: #{e.message}&#34;.tap do |error_message|&#xA;          Roast::Helpers::Logger.error(error_message + &#34;\n&#34;)&#xA;        end&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then include your tool in the workflow:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;tools:&#xA;  - MyProject::Tools::GitAnalyzer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The tool will be available to the AI model during workflow execution, and it can call &lt;code&gt;analyze_commit&lt;/code&gt; with the appropriate parameters.&lt;/p&gt; &#xA;&lt;h3&gt;Project-specific Configuration&lt;/h3&gt; &#xA;&lt;p&gt;You can extend Roast with project-specific configuration by creating initializers in &lt;code&gt;.roast/initializers/&lt;/code&gt;. These are automatically loaded when workflows run, allowing you to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add custom instrumentation&lt;/li&gt; &#xA; &lt;li&gt;Configure monitoring and metrics&lt;/li&gt; &#xA; &lt;li&gt;Set up project-specific tools&lt;/li&gt; &#xA; &lt;li&gt;Customize workflow behavior&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example structure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;your-project/&#xA;  â”œâ”€â”€ .roast/&#xA;  â”‚   â””â”€â”€ initializers/&#xA;  â”‚       â”œâ”€â”€ metrics.rb&#xA;  â”‚       â”œâ”€â”€ logging.rb&#xA;  â”‚       â””â”€â”€ custom_tools.rb&#xA;  â””â”€â”€ ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Pre/Post Processing Framework&lt;/h3&gt; &#xA;&lt;p&gt;Roast supports pre-processing and post-processing phases for workflows. This enables powerful workflows that need setup/teardown or result aggregation across all processed files.&lt;/p&gt; &#xA;&lt;h4&gt;Overview&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Pre-processing&lt;/strong&gt;: Steps executed once before any targets are processed&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Post-processing&lt;/strong&gt;: Steps executed once after all targets have been processed&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Shared state&lt;/strong&gt;: Pre-processing results are available to all subsequent steps&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Result aggregation&lt;/strong&gt;: Post-processing has access to all workflow execution results&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Single-target support&lt;/strong&gt;: Pre/post processing works with single-target workflows too&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Output templates&lt;/strong&gt;: Post-processing supports &lt;code&gt;output.txt&lt;/code&gt; templates for custom formatting&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Configuration&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: optimize_tests&#xA;model: gpt-4o&#xA;target: &#34;test/**/*_test.rb&#34;&#xA;&#xA;# Pre-processing steps run once before any test files&#xA;pre_processing:&#xA;  - gather_baseline_metrics&#xA;  - setup_test_environment&#xA;&#xA;# Main workflow steps run for each test file&#xA;steps:&#xA;  - analyze_test&#xA;  - improve_coverage&#xA;  - optimize_performance&#xA;&#xA;# Post-processing steps run once after all test files&#xA;post_processing:&#xA;  - aggregate_results&#xA;  - generate_report&#xA;  - cleanup_environment&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Directory Structure&lt;/h4&gt; &#xA;&lt;p&gt;Pre and post-processing steps follow the same conventions as regular steps but are organized in their own directories:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;workflow.yml&#xA;pre_processing/&#xA;  â”œâ”€â”€ gather_baseline_metrics/&#xA;  â”‚   â””â”€â”€ prompt.md&#xA;  â””â”€â”€ setup_test_environment/&#xA;      â””â”€â”€ prompt.md&#xA;analyze_test/&#xA;  â””â”€â”€ prompt.md&#xA;improve_coverage/&#xA;  â””â”€â”€ prompt.md&#xA;optimize_performance/&#xA;  â””â”€â”€ prompt.md&#xA;post_processing/&#xA;  â”œâ”€â”€ output.txt&#xA;  â”œâ”€â”€ aggregate_results/&#xA;  â”‚   â””â”€â”€ prompt.md&#xA;  â”œâ”€â”€ generate_report/&#xA;  â”‚   â””â”€â”€ prompt.md&#xA;  â””â”€â”€ cleanup_environment/&#xA;      â””â”€â”€ prompt.md&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Data Access&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Pre-processing results in target workflows:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Target workflows have access to pre-processing results through the &lt;code&gt;pre_processing_data&lt;/code&gt; variable with dot notation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;# In a target workflow step prompt&#xA;The baseline metrics from pre-processing:&#xA;&amp;lt;%= pre_processing_data.gather_baseline_metrics %&amp;gt;&#xA;&#xA;Environment setup details:&#xA;&amp;lt;%= pre_processing_data.setup_test_environment %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Post-processing data access:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Post-processing steps have access to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;pre_processing&lt;/code&gt;: Direct access to pre-processing results with dot notation&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;targets&lt;/code&gt;: Hash of all target workflow results, keyed by file paths&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example post-processing prompt:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Generate Summary Report&#xA;&#xA;Based on the baseline metrics:&#xA;&amp;lt;%= pre_processing.gather_baseline_metrics %&amp;gt;&#xA;&#xA;Environment configuration:&#xA;&amp;lt;%= pre_processing.setup_test_environment %&amp;gt;&#xA;&#xA;And the results from processing all files:&#xA;&amp;lt;% targets.each do |file, target| %&amp;gt;&#xA;File: &amp;lt;%= file %&amp;gt;&#xA;Analysis results: &amp;lt;%= target.output.analyze_test %&amp;gt;&#xA;Coverage improvements: &amp;lt;%= target.output.improve_coverage %&amp;gt;&#xA;Performance optimizations: &amp;lt;%= target.output.optimize_performance %&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&#xA;Please generate a comprehensive summary report showing:&#xA;1. Overall improvements achieved&#xA;2. Files with the most significant changes&#xA;3. Recommendations for further optimization&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output Templates&lt;/h4&gt; &#xA;&lt;p&gt;Post-processing supports custom output formatting using ERB templates. Create an &lt;code&gt;output.txt&lt;/code&gt; file in your &lt;code&gt;post_processing&lt;/code&gt; directory to format the final workflow output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;# post_processing/output.txt&#xA;=== Workflow Summary Report ===&#xA;Generated at: &amp;lt;%= Time.now.strftime(&#34;%Y-%m-%d %H:%M:%S&#34;) %&amp;gt;&#xA;&#xA;Environment: &amp;lt;%= pre_processing.setup_test_environment %&amp;gt;&#xA;&#xA;Files Processed: &amp;lt;%= targets.size %&amp;gt;&#xA;&#xA;&amp;lt;% targets.each do |file, target| %&amp;gt;&#xA;- &amp;lt;%= file %&amp;gt;: &amp;lt;%= target.output.analyze_test %&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&#xA;&amp;lt;%= output.generate_report %&amp;gt;&#xA;===============================&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The template has access to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;pre_processing&lt;/code&gt;: All pre-processing step outputs with dot notation&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;targets&lt;/code&gt;: Hash of all target workflow results with dot notation (each target has &lt;code&gt;.output&lt;/code&gt; and &lt;code&gt;.final_output&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;output&lt;/code&gt;: Post-processing step outputs with dot notation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Use Cases&lt;/h4&gt; &#xA;&lt;p&gt;This pattern is ideal for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Code migrations&lt;/strong&gt;: Setup migration tools, process files, generate migration report&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Test optimization&lt;/strong&gt;: Baseline metrics, optimize tests, aggregate improvements&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Documentation generation&lt;/strong&gt;: Analyze codebase, generate docs per module, create index&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Dependency updates&lt;/strong&gt;: Check versions, update files, verify compatibility&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Security audits&lt;/strong&gt;: Setup scanners, check each file, generate security report&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Performance analysis&lt;/strong&gt;: Establish baselines, analyze components, summarize findings&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/roast/main/examples/pre_post_processing&#34;&gt;pre/post processing example&lt;/a&gt; for a complete working demonstration.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;After checking out the repo, run &lt;code&gt;bundle install&lt;/code&gt; to install dependencies. Then, run &lt;code&gt;bundle exec rake&lt;/code&gt; to run the tests and linter. You can also run &lt;code&gt;bin/console&lt;/code&gt; for an interactive prompt that will allow you to experiment.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>