<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-26T01:32:36Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kufu/activerecord-bitemporal</title>
    <updated>2022-07-26T01:32:36Z</updated>
    <id>tag:github.com,2022-07-26:/kufu/activerecord-bitemporal</id>
    <link href="https://github.com/kufu/activerecord-bitemporal" rel="alternate"></link>
    <summary type="html">&lt;p&gt;BiTemporal Data Model for ActiveRecord&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ActiveRecord::Bitemporal&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kufu/activerecord-bitemporal/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/kufu/activerecord-bitemporal.svg?color=blue&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://rubygems.org/gems/activerecord-bitemporal&#34;&gt;&lt;img src=&#34;https://img.shields.io/gem/v/activerecord-bitemporal.svg?sanitize=true&#34; alt=&#34;gem-version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://rubygems.org/gems/activerecord-bitemporal&#34;&gt;&lt;img src=&#34;https://img.shields.io/gem/dt/activerecord-bitemporal.svg?sanitize=true&#34; alt=&#34;gem-download&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/kufu/activerecord-bitemporal&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/kufu/activerecord-bitemporal.svg?style=svg&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;activerecord-bitemporal&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bundle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or install it yourself as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install activerecord-bitemporal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;概要&lt;/h2&gt; &#xA;&lt;p&gt;activerecord-bitemporal は Rails の ActiveRecord で Bitemporal Data Model を扱うためのライブラリになります。 activerecord-bitemporal では、モデルを生成すると&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;# MEMO: データをわかりやすくする為に時間を固定&#xA;#       2019/1/10 にレコードを生成する&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;以下のようなレコードが生成されます。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;id&lt;/th&gt; &#xA;   &lt;th&gt;bitemporal_id&lt;/th&gt; &#xA;   &lt;th&gt;emp_code&lt;/th&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;valid_from&lt;/th&gt; &#xA;   &lt;th&gt;valid_to&lt;/th&gt; &#xA;   &lt;th&gt;transaction_from&lt;/th&gt; &#xA;   &lt;th&gt;transaction_to&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Jane&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;そのモデルに対して更新を行うと&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/15&#34;) {&#xA;  # 更新する&#xA;  employee.update(name: &#34;Tom&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;次のような履歴レコードが暗黙的に生成されます。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;id&lt;/th&gt; &#xA;   &lt;th&gt;bitemporal_id&lt;/th&gt; &#xA;   &lt;th&gt;emp_code&lt;/th&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;valid_from&lt;/th&gt; &#xA;   &lt;th&gt;valid_to&lt;/th&gt; &#xA;   &lt;th&gt;transaction_from&lt;/th&gt; &#xA;   &lt;th&gt;transaction_to&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Jane&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Jane&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Tom&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;更に更新すると&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/15&#34;) {&#xA;  employee.update(name: &#34;Tom&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  # 更に更新&#xA;  employee.update(name: &#34;Kevin&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;更新する度にどんどん履歴レコードが増えていきます。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;id&lt;/th&gt; &#xA;   &lt;th&gt;bitemporal_id&lt;/th&gt; &#xA;   &lt;th&gt;emp_code&lt;/th&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;valid_from&lt;/th&gt; &#xA;   &lt;th&gt;valid_to&lt;/th&gt; &#xA;   &lt;th&gt;transaction_from&lt;/th&gt; &#xA;   &lt;th&gt;transaction_to&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Jane&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Jane&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Tom&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Tom&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Kevin&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;また、レコードを読み込む場合は暗黙的に『一番最新のレコード』を参照します。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/15&#34;) {&#xA;  employee.update(name: &#34;Tom&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  employee.update(name: &#34;Kevin&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/25&#34;) {&#xA;  # 現時点で有効なレコードのみを参照する&#xA;  pp Employee.count&#xA;  # =&amp;gt; 1&#xA;&#xA;  # name = &#34;Tom&#34; は過去の履歴レコードとして扱われるので参照されない&#xA;  pp Employee.find_by(name: &#34;Tom&#34;)&#xA;  # =&amp;gt; nil&#xA;&#xA;  # 最新のみ参照する&#xA;  pp Employee.all&#xA;  # [#&amp;lt;Employee:0x0000559b1b37eb08&#xA;  #   id: 1,&#xA;  #   bitemporal_id: 1,&#xA;  #   emp_code: &#34;001&#34;,&#xA;  #   name: &#34;Kevin&#34;,&#xA;  #   valid_from: 2019-01-20,&#xA;  #   valid_to: 9999-12-31,&#xA;  #   transaction_from: 2019-01-20,&#xA;  #   transaction_to: 9999-12-31&amp;gt;]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;任意の時間の履歴レコードを参照したい場合は &lt;code&gt;find_at_time(datetime, id)&lt;/code&gt; で時間指定して取得する事が出来ます。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/15&#34;) {&#xA;  employee.update(name: &#34;Tom&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  employee.update(name: &#34;Kevin&#34;)&#xA;}&#xA;&#xA;# 2019/1/25 に固定&#xA;Timecop.freeze(&#34;2019/1/25&#34;) {&#xA;  # 任意の時間の履歴レコードを取得する&#xA;  pp Employee.find_at_time(&#34;2019/1/13&#34;, employee.id).name&#xA;  # =&amp;gt; &#34;Jane&#34;&#xA;  pp Employee.find_at_time(&#34;2019/1/18&#34;, employee.id).name&#xA;  # =&amp;gt; &#34;Tom&#34;&#xA;  pp Employee.find_at_time(&#34;2019/1/23&#34;, employee.id).name&#xA;  # =&amp;gt; &#34;Kevin&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;このように activerecord-bitemporal は、&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;保存時に履歴レコードを自動生成&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.find_at_time&lt;/code&gt; 等で任意の時間のレコードを取得する&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;というような事を行うライブラリになります。&lt;/p&gt; &#xA;&lt;h2&gt;モデルを BiTemporal Data Model 化する&lt;/h2&gt; &#xA;&lt;p&gt;任意のモデルを BiTemporal Data Model(以下、BTDM)として扱う場合は、以下のカラムを DB に追加する必要があります。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ActiveRecord::Schema.define(version: 1) do&#xA;  create_table :employees, force: true do |t|&#xA;    t.string :emp_code&#xA;    t.string :name&#xA;&#xA;    # BTDM に必要なカラムを追加する&#xA;    t.integer :bitemporal_id&#xA;    t.datetime :valid_from&#xA;    t.datetime :valid_to&#xA;    t.datetime :transaction_from&#xA;    t.datetime :transaction_to&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;それぞれのカラムは以下のような意味を持ちます。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;カラム名&lt;/th&gt; &#xA;   &lt;th&gt;型&lt;/th&gt; &#xA;   &lt;th&gt;値&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;bitemporal_id&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;id&lt;/code&gt; と同じ型&lt;/td&gt; &#xA;   &lt;td&gt;BTDM が共通で持つ &lt;code&gt;id&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;valid_from&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;有効時間の開始時刻&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;valid_to&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;有効時間の終了時刻&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;transaction_from&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;システム時間の開始時刻&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;transaction_to&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;システム時間の終了終了&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;また、モデルクラスでは &lt;code&gt;ActiveRecord::Bitemporal&lt;/code&gt; を &lt;code&gt;include&lt;/code&gt; をする必要があります。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Employee &amp;lt; ActiveRecord::Base&#xA;  include ActiveRecord::Bitemporal&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;これで &lt;code&gt;Employee&lt;/code&gt; モデルを BTDM として扱うことが出来ます。 このドキュメントではこのモデルをサンプルとしてコードを書いていきます。&lt;/p&gt; &#xA;&lt;h2&gt;モデルインスタンスに対する操作について&lt;/h2&gt; &#xA;&lt;p&gt;ここではモデルの生成・更新・削除といったインスタンスに対する操作に関して解説します。&lt;/p&gt; &#xA;&lt;h3&gt;生成&lt;/h3&gt; &#xA;&lt;p&gt;以下のように BTDM を生成した場合、&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# MEMO: Timecop を使って擬似的に 2019/1/10 の日付でレコードを生成&#xA;#       データをわかりやすくする為に使用しているだけで activerecord-bitemporal には Timecop は必要ありません&#xA;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;以下のようなレコードが生成されます。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;id&lt;/th&gt; &#xA;   &lt;th&gt;bitemporal_id&lt;/th&gt; &#xA;   &lt;th&gt;emp_code&lt;/th&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;valid_from&lt;/th&gt; &#xA;   &lt;th&gt;valid_to&lt;/th&gt; &#xA;   &lt;th&gt;transaction_from&lt;/th&gt; &#xA;   &lt;th&gt;transaction_to&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Jane&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;この時に生成されるレコードのカラムには暗黙的に以下のような値が保存されます。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;カラム&lt;/th&gt; &#xA;   &lt;th&gt;値&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;bitemporal_id&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;自身の &lt;code&gt;id&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;valid_from&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;生成した時間&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;valid_to&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;擬似的な &lt;code&gt;INFINITY&lt;/code&gt; 時間&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;これは『&lt;code&gt;valid_from&lt;/code&gt; から &lt;code&gt;valid_to&lt;/code&gt; までの期間で有効なデータ』という意味になります。 また、 &lt;code&gt;valid_from&lt;/code&gt; や &lt;code&gt;valid_to&lt;/code&gt; を指定すれば『任意の時間』の履歴データも生成も出来ます。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  # 現時点よりも前からのデータを生成する&#xA;  Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;, valid_from: &#34;2019/1/1&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;更新&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;#update&lt;/code&gt; 等でモデルを更新すると『更新時間』を基準とした履歴レコードが暗黙的に生成されます。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  # モデルを更新すると履歴レコードが生成される&#xA;  employee.update(name: &#34;Tom&#34;)&#xA;  # これは #save でも同様に行われる&#xA;  # employee.name = &#34;Tom&#34;&#xA;  # employee.save&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;上記の操作を行うと以下のようなレコードが生成されます。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;id&lt;/th&gt; &#xA;   &lt;th&gt;bitemporal_id&lt;/th&gt; &#xA;   &lt;th&gt;emp_code&lt;/th&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;valid_from&lt;/th&gt; &#xA;   &lt;th&gt;valid_to&lt;/th&gt; &#xA;   &lt;th&gt;transaction_from&lt;/th&gt; &#xA;   &lt;th&gt;transaction_to&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Jane&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Jane&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Tom&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;更新時には以下のような処理を行っており、結果的に新しいレコードが2つ生成されることになります。 また、この時に生成されるレコードは共通の &lt;code&gt;bitemporal_id&lt;/code&gt; を保持します。&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;更新対象のレコード（&lt;code&gt;id = 1&lt;/code&gt;）のシステム時間の終了時刻を更新する&lt;/li&gt; &#xA; &lt;li&gt;更新を行った時間までのレコード（&lt;code&gt;id = 2&lt;/code&gt;）を新しく生成する&lt;/li&gt; &#xA; &lt;li&gt;更新を行った時間からのレコード（&lt;code&gt;id = 3&lt;/code&gt;）を新しく生成する&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;activerecord-bitemporal ではレコードの内容を変更する際にレコードを直接変更するのではなくて『既存のレコードはシステム時間では参照しないような時刻』にして『変更後のレコードを新しく生成』していきます。 ただし、&lt;code&gt;#update_columns&lt;/code&gt; で更新を行うと強制的にレコードが上書きされるので注意してください。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  # #update_columns で更新するとレコードが直接変更される&#xA;  employee.update_columns(name: &#34;Tom&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;上記の場合は以下のようなレコードになります。 &lt;code&gt;id = 1&lt;/code&gt; のレコードが直接変更されるので注意してください。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;id&lt;/th&gt; &#xA;   &lt;th&gt;bitemporal_id&lt;/th&gt; &#xA;   &lt;th&gt;emp_code&lt;/th&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;valid_from&lt;/th&gt; &#xA;   &lt;th&gt;valid_to&lt;/th&gt; &#xA;   &lt;th&gt;transaction_from&lt;/th&gt; &#xA;   &lt;th&gt;transaction_to&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Tom&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;履歴を生成せずに上書きして更新したいのであれば activerecord-bitemporal 側で用意している &lt;code&gt;#force_update&lt;/code&gt; を利用する事が出来ます。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  # #force_update のでは自身を受け取る&#xA;  # このブロック内であれば履歴を生成せずにレコードの変更が行われる&#xA;  employee.force_update { |employee|&#xA;    employee.update(name: &#34;Tom&#34;)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;上記の場合は以下のレコードが生成されます。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;id&lt;/th&gt; &#xA;   &lt;th&gt;bitemporal_id&lt;/th&gt; &#xA;   &lt;th&gt;emp_code&lt;/th&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;valid_from&lt;/th&gt; &#xA;   &lt;th&gt;valid_to&lt;/th&gt; &#xA;   &lt;th&gt;transaction_from&lt;/th&gt; &#xA;   &lt;th&gt;transaction_to&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Jane&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Tom&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;この場合は &lt;code&gt;id = 1&lt;/code&gt; はシステムの終了時刻が更新され、新しい &lt;code&gt;id = 2&lt;/code&gt; のレコードが生成されます。&lt;/p&gt; &#xA;&lt;h3&gt;更新時間を指定して更新&lt;/h3&gt; &#xA;&lt;p&gt;TODO:&lt;/p&gt; &#xA;&lt;h3&gt;削除&lt;/h3&gt; &#xA;&lt;p&gt;更新と同様にレコードのシステム時間の終了時刻を更新しつつ、新しいレコードが生成されます。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  employee.update(name: &#34;Tom&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/30&#34;) {&#xA;  # 削除を行うとその時間までの履歴が生成される&#xA;  employee.destroy&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;上記の場合では以下のようなレコードが生成されます。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;id&lt;/th&gt; &#xA;   &lt;th&gt;bitemporal_id&lt;/th&gt; &#xA;   &lt;th&gt;emp_code&lt;/th&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;valid_from&lt;/th&gt; &#xA;   &lt;th&gt;valid_to&lt;/th&gt; &#xA;   &lt;th&gt;transaction_from&lt;/th&gt; &#xA;   &lt;th&gt;transaction_to&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Jane&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Jane&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Tom&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-30&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Tom&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-30&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-30&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;削除も更新と同様に&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;削除対象のレコード（&lt;code&gt;id = 3&lt;/code&gt;）のシステム時間の終了時刻を更新する&lt;/li&gt; &#xA; &lt;li&gt;削除を行った時間までの履歴レコード（&lt;code&gt;id = 4&lt;/code&gt;）を新しく生成する&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;という風に『システム時間の終了時刻を更新してから新しいレコードを生成する』という処理を行っています。&lt;/p&gt; &#xA;&lt;h3&gt;ユニーク制約&lt;/h3&gt; &#xA;&lt;p&gt;BTDM では『履歴の時間が被っている場合』にユニーク制約のバリデーションを行います。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Employee.create!(name: &#34;Jane&#34;, valid_from: &#34;2019/1/1&#34;, valid_to: &#34;2019/1/10&#34;)&#xA;&#xA;# OK : 同じ時間帯で被っていない&#xA;Employee.create!(name: &#34;Jane&#34;, valid_from: &#34;2019/2/1&#34;, valid_to: &#34;2019/2/10&#34;)&#xA;&#xA;# NG : 同じ時間帯で被っている&#xA;Employee.create!(name: &#34;Jane&#34;, valid_from: &#34;2019/2/5&#34;, valid_to: &#34;2019/2/15&#34;)&#xA;&#xA;# OK : valid_from と valid_to は同じでも問題ない&#xA;Employee.create!(name: &#34;Jane&#34;, valid_from: &#34;2019/2/10&#34;, valid_to: &#34;2019/2/20&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;また、 BTDM の &lt;code&gt;bitemporal_id&lt;/code&gt; もユニーク制約となっているので注意してください。&lt;/p&gt; &#xA;&lt;h2&gt;検索について&lt;/h2&gt; &#xA;&lt;p&gt;BTDM のレコードの検索について解説します。&lt;/p&gt; &#xA;&lt;h3&gt;検索時にデフォルトで追加されるクエリ&lt;/h3&gt; &#xA;&lt;p&gt;BTDM では DB からレコードを参照する場合、暗黙的に&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;現在の時間を指定する時間指定クエリ&lt;/li&gt; &#xA; &lt;li&gt;論理削除を除くクエリ&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;が追加された状態で SQL 文が構築されます。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  # 現在の時間の履歴を返すために暗黙的に時間指定や論理削除されたレコードが除かれる&#xA;  puts Employee.all.to_sql&#xA;  # =&amp;gt; SELECT &#34;employees&#34;.* FROM &#34;employees&#34; WHERE &#34;employees&#34;.&#34;valid_from&#34; &amp;lt;= &#39;2019-01-20 00:00:00&#39; AND &#34;employees&#34;.&#34;valid_to&#34; &amp;gt; &#39;2019-01-20 00:00:00&#39; AND &#34;employees&#34;.&#34;transaction_to&#34; = &#39;9999-12-31 00:00:00&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;これにより DB 上に複数の履歴レコードや論理削除されているレコードがあっても『現時点で有効な』レコードが参照されます。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/15&#34;) {&#xA;  employee.update(name: &#34;Tom&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  # DB 上では履歴レコードや論理削除済みレコードなどが複数存在するが、暗黙的にクエリが追加されているので&#xA;  # 通常の ActiveRecord のモデルを操作した時と同じレコードを返す&#xA;  pp Employee.count&#xA;  # =&amp;gt; 1&#xA;&#xA;  pp Employee.first&#xA;  # =&amp;gt; #&amp;lt;Employee:0x000055efd894e9e0&#xA;  #     id: 1,&#xA;  #     bitemporal_id: 1,&#xA;  #     emp_code: nil,&#xA;  #     name: &#34;Tom&#34;,&#xA;  #     valid_from: 2019-01-15,&#xA;  #     valid_to: 9999-12-31,&#xA;  #     transaction_from: 2019-01-15,&#xA;  #     transaction_to: 9999-12-31&amp;gt;&#xA;&#xA;  # 更新前の名前で検索しても引っかからない&#xA;  pp Employee.where(name: &#34;Jane&#34;).first&#xA;  # =&amp;gt; nil&#xA;&#xA;  # なぜなら暗黙的に時間指定のクエリが追加されている為&#xA;  puts Employee.where(name: &#34;Jane&#34;).to_sql&#xA;  # =&amp;gt; SELECT &#34;employees&#34;.* FROM &#34;employees&#34; WHERE &#34;employees&#34;.&#34;valid_from&#34; &amp;lt;= &#39;2019-01-20 00:00:00&#39; AND &#34;employees&#34;.&#34;valid_to&#34; &amp;gt; &#39;2019-01-20 00:00:00&#39; AND &#34;employees&#34;.&#34;transaction_to&#34; = &#39;9999-12-31 00:00:00&#39; AND &#34;employees&#34;.&#34;name&#34; = &#39;Jane&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;このように『現在の時間で有効なレコード』のみが検索の対象となります。 また、これは &lt;code&gt;default_scope&lt;/code&gt; ではなくて BTDM が独自にハックして暗黙的に追加する仕組みを実装しているので &lt;code&gt;.unscoped&lt;/code&gt; で取り除く事は出来ないので注意してください。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# default_scope であれば unscoped で無効化することが出来るが、BTDM のデフォルトクエリはそのまま&#xA;puts Employee.unscoped { Employee.all.to_sql }&#xA;# =&amp;gt; SELECT &#34;employees&#34;.* FROM &#34;employees&#34; WHERE &#34;employees&#34;.&#34;valid_from&#34; &amp;lt;= &#39;2019-10-25 07:56:06.731259&#39; AND &#34;employees&#34;.&#34;valid_to&#34; &amp;gt; &#39;2019-10-25 07:56:06.731259&#39; AND &#34;employees&#34;.&#34;transaction_to&#34; = &#39;9999-12-31 00:00:00&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;検索時にデフォルトクエリを取り除く&lt;/h3&gt; &#xA;&lt;p&gt;検索時にデフォルトクエリを取り除きたい場合、以下のスコープを使用します。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;スコープ&lt;/th&gt; &#xA;   &lt;th&gt;動作&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.ignore_valid_datetime&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;時間指定を無視する&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.within_deleted&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;論理削除されているレコードを含める&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;.without_deleted&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;論理削除されているレコードを含めない&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  # 時間指定をしているクエリを取り除く&#xA;  puts Employee.ignore_valid_datetime.to_sql&#xA;  # =&amp;gt; SELECT &#34;employees&#34;.* FROM &#34;employees&#34; WHERE &#34;employees&#34;.&#34;transaction_to&#34; = &#39;9999-12-31 00:00:00&#39;&#xA;&#xA;  # 論理削除しているレコードも含める&#xA;  puts Employee.within_deleted.to_sql&#xA;  # =&amp;gt; SELECT &#34;employees&#34;.* FROM &#34;employees&#34; WHERE &#34;employees&#34;.&#34;valid_from&#34; &amp;lt;= &#39;2019-01-20 00:00:00&#39; AND &#34;employees&#34;.&#34;valid_to&#34; &amp;gt; &#39;2019-01-20 00:00:00&#39;&#xA;&#xA;  # 全てのレコードを対象とする&#xA;  puts Employee.ignore_valid_datetime.within_deleted.to_sql&#xA;  # =&amp;gt; SELECT &#34;employees&#34;.* FROM &#34;employees&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;『任意のレコードの履歴一覧を取得する』ようなことを行う場合は &lt;code&gt;ignore_valid_datetime&lt;/code&gt; を使用して全レコードを参照するようにします。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/15&#34;) {&#xA;  employee.update(name: &#34;Tom&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  employee.update(name: &#34;Kevin&#34;)&#xA;&#xA;  # NOTE: bitemporal_id を参照することで同一の履歴を取得する事が出来る&#xA;  pp Employee.ignore_valid_datetime.where(bitemporal_id: employee.bitemporal_id).map(&amp;amp;:name)&#xA;  # =&amp;gt; [&#34;Jane&#34;, &#34;Tom&#34;, &#34;Kevin&#34;]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;時間を指定して検索する&lt;/h3&gt; &#xA;&lt;p&gt;任意の時間を指定して検索を行いたい場合、&lt;code&gt;.valid_at(datetime)&lt;/code&gt; を利用する事が出来ます。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee1 = nil&#xA;employee2 = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee1 = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/15&#34;) {&#xA;  employee1.update(name: &#34;Tom&#34;)&#xA;  employee2 = Employee.create(emp_code: &#34;002&#34;, name: &#34;Homu&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  # valid_at で任意の時間を参照して検索する事が出来る&#xA;  puts Employee.valid_at(&#34;2019/1/10&#34;).to_sql&#xA;  # =&amp;gt; SELECT &#34;employees&#34;.* FROM &#34;employees&#34; WHERE &#34;employees&#34;.&#34;valid_from&#34; &amp;lt;= &#39;2019-01-10 00:00:00&#39; AND &#34;employees&#34;.&#34;valid_to&#34; &amp;gt; &#39;2019-01-10 00:00:00&#39; AND &#34;employees&#34;.&#34;transaction_to&#34; = &#39;9999-12-31 00:00:00&#39;&#xA;&#xA;  pp Employee.valid_at(&#34;2019/1/10&#34;).map(&amp;amp;:name)&#xA;  # =&amp;gt; [&#34;Jane&#34;]&#xA;  pp Employee.valid_at(&#34;2019/1/17&#34;).map(&amp;amp;:name)&#xA;  # =&amp;gt; [&#34;Tom&#34;, &#34;Homu&#34;]&#xA;&#xA;  # そのまま続けてリレーション出来る&#xA;  pp Employee.valid_at(&#34;2019/1/17&#34;).where(name: &#34;Tom&#34;).first&#xA;  # =&amp;gt; #&amp;lt;Employee:0x000055678afd1d20&#xA;  #     id: 1,&#xA;  #     bitemporal_id: 1,&#xA;  #     emp_code: &#34;001&#34;,&#xA;  #     name: &#34;Tom&#34;,&#xA;  #     valid_from: 2019-01-15,&#xA;  #     valid_to: 9999-12-31,&#xA;  #     transaction_from: 2019-01-15,&#xA;  #     transaction_to: 9999-12-31&amp;gt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;また、特定の &lt;code&gt;id&lt;/code&gt; で検索するのであれば &lt;code&gt;.find_at_time(datetime, id)&lt;/code&gt; も利用できます。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee1 = nil&#xA;employee2 = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee1 = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/15&#34;) {&#xA;  employee1.update(name: &#34;Tom&#34;)&#xA;  employee2 = Employee.create(emp_code: &#34;002&#34;, name: &#34;Homu&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  # 任意の時間の id のレコードを返す&#xA;  pp Employee.find_at_time(&#34;2019/1/12&#34;, employee1.id)&#xA;  # =&amp;gt; #&amp;lt;Employee:0x000055b776d7ff18&#xA;  #     id: 1,&#xA;  #     bitemporal_id: 1,&#xA;  #     emp_code: &#34;001&#34;,&#xA;  #     name: &#34;Jane&#34;,&#xA;  #     valid_from: 2019-01-10,&#xA;  #     valid_to: 2019-01-15,&#xA;  #     transaction_from: 2019-01-15,&#xA;  #     transaction_to: 9999-12-31&amp;gt;&#xA;&#xA;  # 見つからなければ nil を返す&#xA;  pp Employee.find_at_time(&#34;2019/1/12&#34;, employee2.id)&#xA;  # =&amp;gt; nil&#xA;&#xA;  # find_at_time の場合は例外を返す&#xA;  pp Employee.find_at_time!(&#34;2019/1/12&#34;, employee2.id)&#xA;  # =&amp;gt; raise ActiveRecord::RecordNotFound (ActiveRecord::RecordNotFound)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;id&lt;/code&gt; と &lt;code&gt;bitemporal_id&lt;/code&gt; について&lt;/h2&gt; &#xA;&lt;p&gt;BTDM のインスタンスの &lt;code&gt;id&lt;/code&gt; は特殊で『レコードの &lt;code&gt;id&lt;/code&gt;』ではなくて『&lt;code&gt;bitemporal_id&lt;/code&gt; の値』が割り当てられています。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/15&#34;) {&#xA;  employee.update(name: &#34;Tom&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  employee.update(name: &#34;Kevin&#34;)&#xA;&#xA;  # 現在のレコードの id は 1 を返す&#xA;  pp Employee.first.id&#xA;  # =&amp;gt; 1&#xA;&#xA;  # 別の履歴レコードを参照しても id は同じ&#xA;  pp Employee.find_at_time(&#34;2019/1/12&#34;, employee.id).id&#xA;  # =&amp;gt; 1&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;インスタンスの &lt;code&gt;id&lt;/code&gt; はレコードの読み込み時に自動的に設定されています。 これは &lt;code&gt;Employee.find(employee.id)&lt;/code&gt; で検索を行う際に &lt;code&gt;id&lt;/code&gt; の値が &lt;code&gt;レコードの id&lt;/code&gt; ではなくて &lt;code&gt;bitemporal_id&lt;/code&gt; のほうが実装上都合がいい、という由来になっています。 この影響により &lt;code&gt;Employee.pluck(:id)&lt;/code&gt; や &lt;code&gt;Employee.map(&amp;amp;:id)&lt;/code&gt;、 &lt;code&gt;Employee.ids&lt;/code&gt; が返す結果が微妙に異なるので注意してください。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/15&#34;) {&#xA;  employee.update(name: &#34;Tom&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  employee.update(name: &#34;Kevin&#34;)&#xA;&#xA;  # DB の生 id が返ってくる&#xA;  pp Employee.ignore_valid_datetime.pluck(:id)&#xA;&#xA;  # bitemporal_id が返ってくる&#xA;  pp Employee.ignore_valid_datetime.map(&amp;amp;:id)&#xA;&#xA;  # bitemporal_id が返ってくる&#xA;  pp Employee.ignore_valid_datetime.ids&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;レコードの内容&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;id&lt;/th&gt; &#xA;   &lt;th&gt;bitemporal_id&lt;/th&gt; &#xA;   &lt;th&gt;emp_code&lt;/th&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;valid_from&lt;/th&gt; &#xA;   &lt;th&gt;valid_to&lt;/th&gt; &#xA;   &lt;th&gt;transaction_from&lt;/th&gt; &#xA;   &lt;th&gt;transaction_to&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Jane&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Jane&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-10&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Tom&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Tom&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-15&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;001&lt;/td&gt; &#xA;   &lt;td&gt;Kevin&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;   &lt;td&gt;2019-01-20&lt;/td&gt; &#xA;   &lt;td&gt;9999-12-31&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;また、元々の DB の &lt;code&gt;id&lt;/code&gt; は &lt;code&gt;#swapped_id&lt;/code&gt; で参照する事が出来ます。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;employee = nil&#xA;Timecop.freeze(&#34;2019/1/10&#34;) {&#xA;  employee = Employee.create(emp_code: &#34;001&#34;, name: &#34;Jane&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/15&#34;) {&#xA;  employee.update(name: &#34;Tom&#34;)&#xA;}&#xA;&#xA;Timecop.freeze(&#34;2019/1/20&#34;) {&#xA;  employee.update(name: &#34;Kevin&#34;)&#xA;&#xA;  pp Employee.first.swapped_id&#xA;  # =&amp;gt; 5&#xA;  pp Employee.find_at_time(&#34;2019/1/12&#34;, employee.id).swapped_id&#xA;  # =&amp;gt; 2&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;まとめると BTDM のインスタンスは以下のような値を保持しています。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;id&lt;/code&gt; : &lt;code&gt;bitemporal_id&lt;/code&gt; が暗黙的に設定される&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bitemporal_id&lt;/code&gt; : BTDM 共通の &lt;code&gt;id&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;swapped_id&lt;/code&gt; : DB の生 &lt;code&gt;id&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;id&lt;/code&gt; 検索の注意点&lt;/h3&gt; &#xA;&lt;p&gt;BTDM では &lt;code&gt;find_by(id: xxx)&lt;/code&gt; や &lt;code&gt;where(id: xxx)&lt;/code&gt; を行う場合 &lt;code&gt;id&lt;/code&gt; ではなくて &lt;code&gt;bitemporal_id&lt;/code&gt; を参照する必要があります。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# NG : BTDM の場合は id 検索出来ない&#xA;Employee.find_by(id: employee.id)&#xA;&#xA;# OK : bitemporal_id で検索を行う&#xA;# MEMO: id = bitemporal_id なの&#xA;#       find_by(bitemporal_id: employee.id)&#xA;#       でも動作するが employee.bitemporal_id と書いたほうが意図が伝わりやすい&#xA;Employee.find_by(bitemporal_id: employee.bitemporal_id)&#xA;&#xA;# NG : BTDM の場合は id 検索出来ない&#xA;Employee.where(id: employee.id)&#xA;&#xA;# OK : bitemporal_id で検索を行う&#xA;Employee.where(bitemporal_id: employee.bitemporal_id)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;After checking out the repo, run &lt;code&gt;bin/setup&lt;/code&gt; to install dependencies. Then, run &lt;code&gt;rake spec&lt;/code&gt; to run the tests. You can also run &lt;code&gt;bin/console&lt;/code&gt; for an interactive prompt that will allow you to experiment.&lt;/p&gt; &#xA;&lt;p&gt;To install this gem onto your local machine, run &lt;code&gt;bundle exec rake install&lt;/code&gt;. To release a new version, update the version number in &lt;code&gt;version.rb&lt;/code&gt;, and then run &lt;code&gt;bundle exec rake release&lt;/code&gt;, which will create a git tag for the version, push git commits and tags, and push the &lt;code&gt;.gem&lt;/code&gt; file to &lt;a href=&#34;https://rubygems.org&#34;&gt;rubygems.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Bug reports and pull requests are welcome on GitHub at &lt;a href=&#34;https://github.com/kufu/activerecord-bitemporal&#34;&gt;https://github.com/kufu/activerecord-bitemporal&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;See ./LICENSE&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>saml-idp/saml_idp</title>
    <updated>2022-07-26T01:32:36Z</updated>
    <id>tag:github.com,2022-07-26:/saml-idp/saml_idp</id>
    <link href="https://github.com/saml-idp/saml_idp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ruby SAML Identity Provider, best used with Rails (though not required)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ruby SAML Identity Provider (IdP)&lt;/h1&gt; &#xA;&lt;p&gt;Forked from &lt;a href=&#34;https://github.com/lawrencepit/ruby-saml-idp&#34;&gt;https://github.com/lawrencepit/ruby-saml-idp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/saml-idp/saml_idp&#34;&gt;&lt;img src=&#34;https://travis-ci.org/saml-idp/saml_idp.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://badge.fury.io/rb/saml_idp&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/saml_idp.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The ruby SAML Identity Provider library is for implementing the server side of SAML authentication. It allows your application to act as an IdP (Identity Provider) using the &lt;a href=&#34;http://en.wikipedia.org/wiki/Security_Assertion_Markup_Language&#34;&gt;SAML v2.0&lt;/a&gt; protocol. It provides a means for managing authentication requests and confirmation responses for SPs (Service Providers).&lt;/p&gt; &#xA;&lt;p&gt;This was originally setup by @lawrencepit to test SAML Clients. I took it closer to a real SAML IDP implementation.&lt;/p&gt; &#xA;&lt;h2&gt;Installation and Usage&lt;/h2&gt; &#xA;&lt;p&gt;Add this to your Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    gem &#39;saml_idp&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Not using rails?&lt;/h3&gt; &#xA;&lt;p&gt;Include &lt;code&gt;SamlIdp::Controller&lt;/code&gt; and see the examples that use rails. It should be straightforward for you.&lt;/p&gt; &#xA;&lt;p&gt;Basically you call &lt;code&gt;decode_request(params[:SAMLRequest])&lt;/code&gt; on an incoming request and then use the value &lt;code&gt;saml_acs_url&lt;/code&gt; to determine the source for which you need to authenticate a user. How you authenticate a user is entirely up to you.&lt;/p&gt; &#xA;&lt;p&gt;Once a user has successfully authenticated on your system send the Service Provider a SAMLResponse by posting to &lt;code&gt;saml_acs_url&lt;/code&gt; the parameter &lt;code&gt;SAMLResponse&lt;/code&gt; with the return value from a call to &lt;code&gt;encode_response(user_email)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Using rails?&lt;/h3&gt; &#xA;&lt;p&gt;Check out our Wiki page for Rails integration &lt;a href=&#34;https://github.com/saml-idp/saml_idp/wiki/Rails_Integration&#34;&gt;Rails Integration guide&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;h4&gt;Signed assertions and Signed Response&lt;/h4&gt; &#xA;&lt;p&gt;By default SAML Assertion will be signed with an algorithm which defined to &lt;code&gt;config.algorithm&lt;/code&gt;. Because SAML assertions contain secure information used for authentication such as NameID.&lt;/p&gt; &#xA;&lt;p&gt;Signing SAML Response is optional, but some security perspective SP services might require Response message itself must be signed. For that, you can enable it with &lt;code&gt;config.signed_message&lt;/code&gt; option. &lt;a href=&#34;https://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf#page=68&#34;&gt;More about SAML spec&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Signing algorithm&lt;/h4&gt; &#xA;&lt;p&gt;Following algorithms you can set in your response signing algorithm :sha1 - RSA-SHA1 default value but not recommended to production environment Highly recommended to use one of following algorithm, suit with your computing power. :sha256 - RSA-SHA256 :sha384 - RSA-SHA384 :sha512 - RSA-SHA512&lt;/p&gt; &#xA;&lt;p&gt;Be sure to load a file like this during your app initialization:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SamlIdp.configure do |config|&#xA;  base = &#34;http://example.com&#34;&#xA;&#xA;  config.x509_certificate = &amp;lt;&amp;lt;-CERT&#xA;-----BEGIN CERTIFICATE-----&#xA;CERTIFICATE DATA&#xA;-----END CERTIFICATE-----&#xA;CERT&#xA;&#xA;  config.secret_key = &amp;lt;&amp;lt;-CERT&#xA;-----BEGIN RSA PRIVATE KEY-----&#xA;KEY DATA&#xA;-----END RSA PRIVATE KEY-----&#xA;CERT&#xA;&#xA;  # config.password = &#34;secret_key_password&#34;&#xA;  # config.algorithm = :sha256                                    # Default: sha1 only for development.&#xA;  # config.organization_name = &#34;Your Organization&#34;&#xA;  # config.organization_url = &#34;http://example.com&#34;&#xA;  # config.base_saml_location = &#34;#{base}/saml&#34;&#xA;  # config.reference_id_generator                                 # Default: -&amp;gt; { SecureRandom.uuid }&#xA;  # config.single_logout_service_post_location = &#34;#{base}/saml/logout&#34;&#xA;  # config.single_logout_service_redirect_location = &#34;#{base}/saml/logout&#34;&#xA;  # config.attribute_service_location = &#34;#{base}/saml/attributes&#34;&#xA;  # config.single_service_post_location = &#34;#{base}/saml/auth&#34;&#xA;  # config.session_expiry = 86400                                 # Default: 0 which means never&#xA;  # config.signed_message = true                                  # Default: false which means unsigned SAML Response&#xA;&#xA;  # Principal (e.g. User) is passed in when you `encode_response`&#xA;  #&#xA;  # config.name_id.formats =&#xA;  #   {                         # All 2.0&#xA;  #     email_address: -&amp;gt; (principal) { principal.email_address },&#xA;  #     transient: -&amp;gt; (principal) { principal.id },&#xA;  #     persistent: -&amp;gt; (p) { p.id },&#xA;  #   }&#xA;  #   OR&#xA;  #&#xA;  #   {&#xA;  #     &#34;1.1&#34; =&amp;gt; {&#xA;  #       email_address: -&amp;gt; (principal) { principal.email_address },&#xA;  #     },&#xA;  #     &#34;2.0&#34; =&amp;gt; {&#xA;  #       transient: -&amp;gt; (principal) { principal.email_address },&#xA;  #       persistent: -&amp;gt; (p) { p.id },&#xA;  #     },&#xA;  #   }&#xA;&#xA;  # If Principal responds to a method called `asserted_attributes`&#xA;  # the return value of that method will be used in lieu of the&#xA;  # attributes defined here in the global space. This allows for&#xA;  # per-user attribute definitions.&#xA;  #&#xA;  ## EXAMPLE **&#xA;  # class User&#xA;  #   def asserted_attributes&#xA;  #     {&#xA;  #       phone: { getter: :phone },&#xA;  #       email: {&#xA;  #         getter: :email,&#xA;  #         name_format: Saml::XML::Namespaces::Formats::NameId::EMAIL_ADDRESS,&#xA;  #         name_id_format: Saml::XML::Namespaces::Formats::NameId::EMAIL_ADDRESS&#xA;  #       }&#xA;  #     }&#xA;  #   end&#xA;  # end&#xA;  #&#xA;  # If you have a method called `asserted_attributes` in your Principal class,&#xA;  # there is no need to define it here in the config.&#xA;&#xA;  # config.attributes # =&amp;gt;&#xA;  #   {&#xA;  #     &amp;lt;friendly_name&amp;gt; =&amp;gt; {                                                  # required (ex &#34;eduPersonAffiliation&#34;)&#xA;  #       &#34;name&#34; =&amp;gt; &amp;lt;attrname&amp;gt;                                                # required (ex &#34;urn:oid:1.3.6.1.4.1.5923.1.1.1.1&#34;)&#xA;  #       &#34;name_format&#34; =&amp;gt; &#34;urn:oasis:names:tc:SAML:2.0:attrname-format:uri&#34;, # not required&#xA;  #       &#34;getter&#34; =&amp;gt; -&amp;gt;(principal) {                                         # not required&#xA;  #         principal.get_eduPersonAffiliation                                # If no &#34;getter&#34; defined, will try&#xA;  #       }                                                                   # `principal.eduPersonAffiliation`, or no values will&#xA;  #    }                                                                      # be output&#xA;  #&#xA;  ## EXAMPLE ##&#xA;  # config.attributes = {&#xA;  #   GivenName: {&#xA;  #     getter: :first_name,&#xA;  #   },&#xA;  #   SurName: {&#xA;  #     getter: :last_name,&#xA;  #   },&#xA;  # }&#xA;  ## EXAMPLE ##&#xA;&#xA;  # config.technical_contact.company = &#34;Example&#34;&#xA;  # config.technical_contact.given_name = &#34;Jonny&#34;&#xA;  # config.technical_contact.sur_name = &#34;Support&#34;&#xA;  # config.technical_contact.telephone = &#34;55555555555&#34;&#xA;  # config.technical_contact.email_address = &#34;example@example.com&#34;&#xA;&#xA;  service_providers = {&#xA;    &#34;some-issuer-url.com/saml&#34; =&amp;gt; {&#xA;      fingerprint: &#34;9E:65:2E:03:06:8D:80:F2:86:C7:6C:77:A1:D9:14:97:0A:4D:F4:4D&#34;,&#xA;      metadata_url: &#34;http://some-issuer-url.com/saml/metadata&#34;,&#xA;&#xA;      # We now validate AssertionConsumerServiceURL will match the MetadataURL set above.&#xA;      # *If* it&#39;s not going to match your Metadata URL&#39;s Host, then set this so we can validate the host using this list&#xA;      response_hosts: [&#34;foo.some-issuer-url.com&#34;]&#xA;    },&#xA;  }&#xA;&#xA;  # `identifier` is the entity_id or issuer of the Service Provider,&#xA;  # settings is an IncomingMetadata object which has a to_h method that needs to be persisted&#xA;  config.service_provider.metadata_persister = -&amp;gt;(identifier, settings) {&#xA;    fname = identifier.to_s.gsub(/\/|:/,&#34;_&#34;)&#xA;    FileUtils.mkdir_p(Rails.root.join(&#39;cache&#39;, &#39;saml&#39;, &#39;metadata&#39;).to_s)&#xA;    File.open Rails.root.join(&#34;cache/saml/metadata/#{fname}&#34;), &#34;r+b&#34; do |f|&#xA;      Marshal.dump settings.to_h, f&#xA;    end&#xA;  }&#xA;&#xA;  # `identifier` is the entity_id or issuer of the Service Provider,&#xA;  # `service_provider` is a ServiceProvider object. Based on the `identifier` or the&#xA;  # `service_provider` you should return the settings.to_h from above&#xA;  config.service_provider.persisted_metadata_getter = -&amp;gt;(identifier, service_provider){&#xA;    fname = identifier.to_s.gsub(/\/|:/,&#34;_&#34;)&#xA;    FileUtils.mkdir_p(Rails.root.join(&#39;cache&#39;, &#39;saml&#39;, &#39;metadata&#39;).to_s)&#xA;    full_filename = Rails.root.join(&#34;cache/saml/metadata/#{fname}&#34;)&#xA;    if File.file?(full_filename)&#xA;      File.open full_filename, &#34;rb&#34; do |f|&#xA;        Marshal.load f&#xA;      end&#xA;    end&#xA;  }&#xA;&#xA;  # Find ServiceProvider metadata_url and fingerprint based on our settings&#xA;  config.service_provider.finder = -&amp;gt;(issuer_or_entity_id) do&#xA;    service_providers[issuer_or_entity_id]&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Keys and Secrets&lt;/h2&gt; &#xA;&lt;p&gt;To generate the SAML Response it uses a default X.509 certificate and secret key... which isn&#39;t so secret. You can find them in &lt;code&gt;SamlIdp::Default&lt;/code&gt;. The X.509 certificate is valid until year 2032. Obviously you shouldn&#39;t use these if you intend to use this in production environments. In that case, within the controller set the properties &lt;code&gt;x509_certificate&lt;/code&gt; and &lt;code&gt;secret_key&lt;/code&gt; using a &lt;code&gt;prepend_before_action&lt;/code&gt; callback within the current request context or set them globally via the &lt;code&gt;SamlIdp.config.x509_certificate&lt;/code&gt; and &lt;code&gt;SamlIdp.config.secret_key&lt;/code&gt; properties.&lt;/p&gt; &#xA;&lt;p&gt;The fingerprint to use, if you use the default X.509 certificate of this gem, is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  9E:65:2E:03:06:8D:80:F2:86:C7:6C:77:A1:D9:14:97:0A:4D:F4:4D&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Fingerprint&lt;/h2&gt; &#xA;&lt;p&gt;The gem provides an helper to generate a fingerprint for a X.509 certificate. The second parameter is optional and default to your configuration &lt;code&gt;SamlIdp.config.algorithm&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  Fingerprint.certificate_digest(x509_cert, :sha512)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Service Providers&lt;/h2&gt; &#xA;&lt;p&gt;To act as a Service Provider which generates SAML Requests and can react to SAML Responses use the excellent &lt;a href=&#34;https://github.com/onelogin/ruby-saml&#34;&gt;ruby-saml&lt;/a&gt; gem.&lt;/p&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;Jon Phenow, &lt;a href=&#34;mailto:jon@jphenow.com&#34;&gt;jon@jphenow.com&lt;/a&gt;, jphenow.com, @jphenow&lt;/p&gt; &#xA;&lt;p&gt;Lawrence Pit, &lt;a href=&#34;mailto:lawrence.pit@gmail.com&#34;&gt;lawrence.pit@gmail.com&lt;/a&gt;, lawrencepit.com, @lawrencepit&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2012 Sport Ngin. Portions Copyright (c) 2010 OneLogin, LLC Portions Copyright (c) 2012 Lawrence Pit (&lt;a href=&#34;http://lawrencepit.com&#34;&gt;http://lawrencepit.com&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;See LICENSE for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-3-active-record-querying-methods-lab</title>
    <updated>2022-07-26T01:32:36Z</updated>
    <id>tag:github.com,2022-07-26:/learn-co-curriculum/phase-3-active-record-querying-methods-lab</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-active-record-querying-methods-lab" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Active Record Querying Methods Lab&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create a table using Active Record&lt;/li&gt; &#xA; &lt;li&gt;Use Active Record&#39;s querying methods&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;In this lab, we&#39;ll be working in a TV show domain. We have a TV show model, the &lt;code&gt;Show&lt;/code&gt; class, and a &lt;code&gt;shows&lt;/code&gt; table that you&#39;ll create in your database.&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll be required not only to write a migration that creates a &lt;code&gt;shows&lt;/code&gt; table and gives the &lt;code&gt;Show&lt;/code&gt; class certain attributes, but also to use Active Record&#39;s querying methods.&lt;/p&gt; &#xA;&lt;h3&gt;Active Record Querying Methods&lt;/h3&gt; &#xA;&lt;p&gt;Active Record makes it easy to ask our database for certain information and datasets by providing a bunch of built-in methods for us. For example, we can request the sum of all of the values of a particular column with the &lt;code&gt;#sum&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ClassName.sum(:column_name)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can query our database based on certain conditions using the &lt;code&gt;#where&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s say we have a &lt;code&gt;Song&lt;/code&gt; class and table and each song has a &lt;code&gt;number_of_stars&lt;/code&gt; rating attribute. We could query for songs with more than 3 stars like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Song.where(&#34;number_of_stars &amp;gt; ?&#34;, 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s look at one more example: Let&#39;s say we want to query our database for the lowest value in the &lt;code&gt;number_of_stars&lt;/code&gt; column, i.e., the lowest rating that any song has:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Song.minimum(:number_of_stars)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll be writing methods that &lt;em&gt;rely on Active Record methods like &lt;code&gt;#minimum&lt;/code&gt;, &lt;code&gt;#sum&lt;/code&gt;, and &lt;code&gt;#where&lt;/code&gt;&lt;/em&gt; to get these tests passing.&lt;/p&gt; &#xA;&lt;p&gt;Use the following resources to help you find the Active Record query methods that will help you pass these tests:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://guides.rubyonrails.org/active_record_querying.html#calculations&#34;&gt;Calculations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://guides.rubyonrails.org/active_record_querying.html#ordering&#34;&gt;Ordering&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://guides.rubyonrails.org/active_record_querying.html#conditions&#34;&gt;Conditions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Instructions&lt;/h2&gt; &#xA;&lt;h3&gt;Migration&lt;/h3&gt; &#xA;&lt;p&gt;Create a migration called &lt;code&gt;create_shows&lt;/code&gt; using Rake.&lt;/p&gt; &#xA;&lt;p&gt;In the migration file, write the migration code to create a &lt;code&gt;shows&lt;/code&gt; table. The table should have &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;network&lt;/code&gt;, &lt;code&gt;day&lt;/code&gt;, and &lt;code&gt;rating&lt;/code&gt; columns. &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;network&lt;/code&gt;, and &lt;code&gt;day&lt;/code&gt; have a datatype of string, and &lt;code&gt;rating&lt;/code&gt; has a datatype of integer.&lt;/p&gt; &#xA;&lt;p&gt;Create a file, &lt;code&gt;show.rb&lt;/code&gt;, in &lt;code&gt;app/models&lt;/code&gt;. In this file, you will define a &lt;code&gt;Show&lt;/code&gt; class that inherits from &lt;code&gt;ActiveRecord::Base&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Oops, we forgot a step in our first migration! Create a second migration to add another column to our &lt;code&gt;shows&lt;/code&gt; table. Use Rake to generate a &lt;code&gt;add_season_to_shows&lt;/code&gt; migration file. Write a migration to add a column, &lt;code&gt;season&lt;/code&gt;, to the &lt;code&gt;shows&lt;/code&gt; table. The datatype of this column is string.&lt;/p&gt; &#xA;&lt;h3&gt;Methods&lt;/h3&gt; &#xA;&lt;p&gt;You&#39;ll be defining the following methods as &lt;strong&gt;class methods&lt;/strong&gt; on the &lt;code&gt;Show&lt;/code&gt; class:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;.highest_rating&lt;/code&gt;: This method should return the highest value in the ratings column. &lt;strong&gt;Hint&lt;/strong&gt;: if there is a &lt;code&gt;.minimum&lt;/code&gt; Active Record method, might there be a &lt;code&gt;.maximum&lt;/code&gt; method?&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;.most_popular_show&lt;/code&gt;: Returns the &lt;strong&gt;show&lt;/strong&gt; with the highest rating.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;.lowest_rating&lt;/code&gt;: Returns the &lt;strong&gt;lowest value&lt;/strong&gt; in the ratings column.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;.least_popular_show&lt;/code&gt;: Returns the &lt;strong&gt;show&lt;/strong&gt; with the lowest rating.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;.ratings_sum&lt;/code&gt;: Returns the sum of all of the ratings.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;.popular_shows&lt;/code&gt;: Returns a list of all of the shows that have a rating greater than 5. &lt;strong&gt;Hint&lt;/strong&gt;: use the &lt;code&gt;.where&lt;/code&gt; Active Record method.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;.shows_by_alphabetical_order&lt;/code&gt;: Returns an array of all of the shows sorted in alphabetical order according to their names. &lt;strong&gt;Hint&lt;/strong&gt;: use the &lt;code&gt;.order&lt;/code&gt; Active Record method.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://guides.rubyonrails.org/active_record_querying.html#calculations&#34;&gt;Calculations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://guides.rubyonrails.org/active_record_querying.html#ordering&#34;&gt;Ordering&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://guides.rubyonrails.org/active_record_querying.html#conditions&#34;&gt;Conditions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>