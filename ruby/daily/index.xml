<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-08T01:39:09Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>learn-co-curriculum/phase-3-building-sinatra-applications</title>
    <updated>2022-11-08T01:39:09Z</updated>
    <id>tag:github.com,2022-11-08:/learn-co-curriculum/phase-3-building-sinatra-applications</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-building-sinatra-applications" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Sinatra Application Structure&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Understand the typical file structure for a Sinatra application&lt;/li&gt; &#xA; &lt;li&gt;Use the Rerun gem to help speed up development&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;In the last lesson, we saw a few of the key features of Sinatra, such as its ability to simplify routing logic and handle dynamic routes, as well as how to use Sinatra to send HTML and JSON data in response to HTTP requests.&lt;/p&gt; &#xA;&lt;p&gt;In this lesson, we&#39;ll discuss how to use Sinatra and Active Record together, and how to organize our code in different files to help with our application&#39;s &lt;strong&gt;separation of concerns&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ll also see some common gems used to speed up development when working with a Sinatra application.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;This lesson has a good amount of starter code already set up for you. The majority of this code should be familiar — all of it was taken from a previous Active Record lesson on creating a many-to-many association. For the Active Record side of things, we have the models, migrations and seed data all set up. Run these commands to install the dependencies and set up the database:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle install&#xA;$ bundle exec rake db:migrate db:seed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Running &lt;code&gt;rake db:migrate db:seed&lt;/code&gt; on one line will run the migrations first, then the seed file. It&#39;s a nice way to save a few keystrokes!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We&#39;ll be working with the models and migrations more in the next lesson. For now, let&#39;s review the project&#39;s file structure and talk about how our code is organized.&lt;/p&gt; &#xA;&lt;h2&gt;Separation of Concerns with File Structure&lt;/h2&gt; &#xA;&lt;p&gt;So far, we&#39;ve been setting up the file structure for our application in a way that nicely &lt;a href=&#34;https://en.wikipedia.org/wiki/Separation_of_concerns&#34;&gt;&lt;strong&gt;separates the concerns&lt;/strong&gt;&lt;/a&gt; of our code. Each folder, and each file within that folder, has a clearly defined responsibility. Let&#39;s review:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;app/models&lt;/code&gt;: Our Active Record models. Responsible for code that accesses and updates data in our database using classes that inherit from &lt;code&gt;ActiveRecord::Base&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;config&lt;/code&gt;: Code in this folder is responsible for our environment setup, like requiring files/gems, and establishing a connection to the database.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;db/migrate&lt;/code&gt;: Our Active Record migrations. Responsible for creating and altering the structure of the database (making new tables, adding columns to existing tables, etc).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;db/seeds.rb&lt;/code&gt;: Lets us easily add sample data to the database.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;spec&lt;/code&gt;: Our RSpec tests.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Gemfile&lt;/code&gt;: Lists all the gems our application depends on.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Rakefile&lt;/code&gt;: Code for common tasks that we can easily run from the command line, like &lt;code&gt;rake console&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By organizing our code this way and clearly separating out the different parts of the application, it becomes much easier for us and other developers to know where to add new code when it&#39;s time to build onto or modify our app.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: This file structure also closely mirrors the structure of a typical Rails application, as you&#39;ll see in the next phase!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;In the last lesson on Sinatra, we also saw some new code for writing a web server. How does that code fit in with our current file structure? Let&#39;s break it down a bit. Here&#39;s what that web server-specific code looks like in the &lt;code&gt;config.ru&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;sinatra&#39;&#xA;&#xA;class App &amp;lt; Sinatra::Base&#xA;&#xA;  get &#39;/&#39; do&#xA;    &#39;&amp;lt;h2&amp;gt;Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;!&amp;lt;/h2&amp;gt;&#39;&#xA;  end&#xA;&#xA;end&#xA;&#xA;run App&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where does this code belong? Well, we can leave &lt;em&gt;some&lt;/em&gt; of it in the &lt;code&gt;config.ru&lt;/code&gt; file so that we&#39;ll be able to run our server with &lt;code&gt;rackup config.ru&lt;/code&gt;. But we can also organize it a bit better so that we don&#39;t end up writing all of our Sinatra-specific code in one file!&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s make a new file for the &lt;code&gt;App&lt;/code&gt; class, called &lt;code&gt;application_controller.rb&lt;/code&gt;, and move it to a new folder called &lt;code&gt;app/controllers&lt;/code&gt; (alongside the &lt;code&gt;app/models&lt;/code&gt; folder). Let&#39;s also update the class name to &lt;code&gt;ApplicationController&lt;/code&gt; so it matches the name of the file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# app/controllers/application_controller.rb&#xA;class ApplicationController &amp;lt; Sinatra::Base&#xA;&#xA;  get &#39;/&#39; do&#xA;    &#39;&amp;lt;h2&amp;gt;Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;!&amp;lt;/h2&amp;gt;&#39;&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since our &lt;code&gt;config/environment.rb&lt;/code&gt; file does the work of &lt;code&gt;require&lt;/code&gt;-ing all our gems as well as all the files in the &lt;code&gt;app&lt;/code&gt; folder, we can just require the &lt;code&gt;config/environment.rb&lt;/code&gt; file in our &lt;code&gt;config.ru&lt;/code&gt; file and then run our &lt;code&gt;ApplicationController&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# config.ru&#xA;require_relative &#34;./config/environment&#34;&#xA;&#xA;run ApplicationController&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now as our application grows, it&#39;s easier to add code to the right place without having one file grow out of control!&lt;/p&gt; &#xA;&lt;p&gt;Try running the server with this updated file structure and make sure your server still works:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ rackup config.ru&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should still be able to visit &lt;a href=&#34;http://localhost:9292/&#34;&gt;http://localhost:9292/&lt;/a&gt; and see the HTML response from the server.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;: You may be wondering: What&#39;s a controller? Why &lt;code&gt;ApplicationController&lt;/code&gt;?&lt;/p&gt; &#xA; &lt;p&gt;The reason for using a &lt;code&gt;controllers&lt;/code&gt; folder and a class named with &lt;code&gt;Controller&lt;/code&gt; at the end is because of a software pattern known as Model-View-Controller, or MVC. We&#39;ll cover MVC in more depth in the next phase, but essentially, it&#39;s a common pattern used by web app developers that helps with the separation of concerns of different parts of the application:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Models: responsible for working with the database&lt;/li&gt; &#xA;  &lt;li&gt;Views: responsible for what the user sees on the webpage (typically, views are some form of HTML template)&lt;/li&gt; &#xA;  &lt;li&gt;Controllers: responsible for receiving a request and using the model to generate data needed for the view&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;For now, we won&#39;t go into too much depth on this subject — just know that MVC is a very common pattern in web development, and as long as you stick with this file structure, you&#39;ll be set up nicely to learn more about MVC down the road.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Running a Development Server&lt;/h2&gt; &#xA;&lt;p&gt;As developers, it&#39;s very helpful to be able to make small changes to our code and see what effect they have with as little friction as possible. Right now, any time we make a change to the code for our controller, we need to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Stop the server with &lt;code&gt;control + c&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Re-start the server with &lt;code&gt;rackup config.ru&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We can simplify this process by using the &lt;a href=&#34;https://github.com/alexch/rerun&#34;&gt;Rerun&lt;/a&gt; Ruby gem, which watches for changes to our file system and reloads the program (similar to webpack development server&#39;s hot reload feature when working with React applications).&lt;/p&gt; &#xA;&lt;p&gt;The Rerun gem is already included in the Gemfile, so we can try it out. To run our server in development mode using Rerun, run this command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle exec rerun -b &#39;rackup config.ru&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then make a request to &lt;a href=&#34;http://localhost:9292/&#34;&gt;http://localhost:9292/&lt;/a&gt; in the browser. Just like before, we&#39;ll still see the &#34;Hello World!&#34; message. But now we can make changes to the application and simply refresh the page in the browser to see those changes, without having to manually restart the server!&lt;/p&gt; &#xA;&lt;p&gt;Try updating the &lt;code&gt;ApplicationController&lt;/code&gt; and change the HTML being returned from the &lt;code&gt;GET /&lt;/code&gt; route. Then refresh the page in the browser. You should see your new code reflected in the updated response.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: It can take a few moments for &lt;code&gt;rerun&lt;/code&gt; to fully restart the server. Keep an eye on the terminal output to see when the server has been successfully restarted.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To make it a bit easier to start the server, we can also make a custom Rake task. Add this to your &lt;code&gt;Rakefile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;desc &#34;Start the server&#34;&#xA;task :server do&#xA;  exec &#34;rerun -b &#39;rackup config.ru&#39;&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we can run the server with this Rake command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle exec rake server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;ve now built out the core structure of our Sinatra applications. We&#39;ll be introducing one or two more new gems in this section, but for the most part, this setup is what you&#39;ll use for the rest of this phase. The file structure you&#39;ve seen here is also similar to what you&#39;ll use in the next phase with Rails, so by building it up gradually over the course of this phase, you&#39;ve hopefully gained familiarity with many of these common conventions.&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Separation_of_concerns&#34;&gt;Separation of concerns&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&#34;&gt;Model-View-Controller pattern&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/alexch/rerun&#34;&gt;Rerun gem&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-3-sinatra-with-active-record-get</title>
    <updated>2022-11-08T01:39:09Z</updated>
    <id>tag:github.com,2022-11-08:/learn-co-curriculum/phase-3-sinatra-with-active-record-get</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-sinatra-with-active-record-get" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Sinatra with Active Record: GET Requests&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Handle multiple &lt;code&gt;GET&lt;/code&gt; requests in a controller&lt;/li&gt; &#xA; &lt;li&gt;Use the params hash to look up data with Active Record&lt;/li&gt; &#xA; &lt;li&gt;Send a JSON response using data from an Active Record model&lt;/li&gt; &#xA; &lt;li&gt;Use the &lt;code&gt;#to_json&lt;/code&gt; method to serialize JSON data&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;OK, it&#39;s the moment of truth! Our application is all set up; we&#39;ve reviewed the file structure and talked about how to run the server. Let&#39;s talk about how we can use Sinatra to access data about our models and send that data as a response.&lt;/p&gt; &#xA;&lt;p&gt;Imagine this scenario: you&#39;re given the task of creating a new game review website from scratch. You want a dynamic, highly interactive frontend, so naturally you choose React. You also need to store the data about your users, your games, and the reviews somewhere. Well, it sounds like we need a database for that. Great! We can use Active Record to set up and access data from the database.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s the problem though. React can&#39;t communicate directly with the database — for that, you need Active Record and Ruby. Active Record also doesn&#39;t know anything about your React application (and nor should it!). So then how can we connect up our React frontend with the database?&lt;/p&gt; &#xA;&lt;p&gt;Well, it sounds like we need some sort of &lt;strong&gt;interface&lt;/strong&gt; between React and our database. Perhaps some sort of &lt;strong&gt;Application Programming Interface&lt;/strong&gt; (or as you may know it, API). We need a structured way for these two applications to communicate, using a couple things they &lt;strong&gt;do&lt;/strong&gt; have in common: &lt;strong&gt;HTTP&lt;/strong&gt; and &lt;strong&gt;JSON&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;That&lt;/em&gt; is what we&#39;ll be building for the rest of this section: an API (specifically, a JSON API) that will allow us to use Active Record to communicate with a database from a React application — or really, from any application that speaks HTTP!&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;ll continue building our Sinatra application using the code from the previous lesson. Run these commands to install the dependencies and set up the database:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle install&#xA;$ bundle exec rake db:migrate db:seed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Running &lt;code&gt;rake db:migrate db:seed&lt;/code&gt; on one line will run the migrations first, then the seed file. It&#39;s a nice way to save a few keystrokes!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;You can view the models in the &lt;code&gt;app/models&lt;/code&gt; directory, and the migrations in the &lt;code&gt;db/migrate&lt;/code&gt; folder. Here&#39;s what the relationships will look like in our ERD:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://curriculum-content.s3.amazonaws.com/phase-3/active-record-associations-many-to-many/games-reviews-users-erd.png&#34; alt=&#34;Game Reviews ERD&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then, run the server with our new Rake task:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle exec rake server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With that set up, let&#39;s work on getting Sinatra and Active Record working together!&lt;/p&gt; &#xA;&lt;h2&gt;Accessing the Model From the Controller&lt;/h2&gt; &#xA;&lt;p&gt;Imagine we&#39;re building a feature in a React application where we&#39;d like to show our users a list of all the games in the database. From React, we might have code similar to the following to make this request for the data:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;function GameList() {&#xA;  const [games, setGames] = useState([]);&#xA;&#xA;  useEffect(() =&amp;gt; {&#xA;    fetch(&#34;http://localhost:9292/games&#34;)&#xA;      .then((r) =&amp;gt; r.json())&#xA;      .then((games) =&amp;gt; setGames(games));&#xA;  }, []);&#xA;&#xA;  return (&#xA;    &amp;lt;section&amp;gt;&#xA;      {games.map((game) =&amp;gt; (&#xA;        &amp;lt;GameItem key={game.id} game={game} /&amp;gt;&#xA;      ))}&#xA;    &amp;lt;/section&amp;gt;&#xA;  );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s now our job to set up the server so that when a GET request is made to &lt;code&gt;/games&lt;/code&gt;, we return an array of all the games in our database in JSON format. Let&#39;s set up that code in our controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class ApplicationController &amp;lt; Sinatra::Base&#xA;&#xA;  get &#39;/games&#39; do&#xA;    # get all the games from the database&#xA;    # return a JSON response with an array of all the game data&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;How do we get all the games from the database? Thankfully for us, Active Record makes it simple:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;Game.all&#xA;# =&amp;gt; [#&amp;lt;Game&amp;gt;, #&amp;lt;Game&amp;gt;, #&amp;lt;Game&amp;gt;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also use Active Record&#39;s &lt;code&gt;#to_json&lt;/code&gt; method to convert this list of Active Record objects to a JSON-formatted string. All together, in our controller, here&#39;s how that would look:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class ApplicationController &amp;lt; Sinatra::Base&#xA;&#xA;  get &#39;/games&#39; do&#xA;    # get all the games from the database&#xA;    games = Game.all&#xA;    # return a JSON response with an array of all the game data&#xA;    games.to_json&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now head over to the browser, and visit the newly-created &lt;code&gt;/games&lt;/code&gt; endpoint at &lt;a href=&#34;http://localhost:9292/games&#34;&gt;http://localhost:9292/games&lt;/a&gt;. You should see a response with a JSON-formatted array of all the games from the database:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[&#xA;  {&#xA;    &#34;id&#34;: 1,&#xA;    &#34;title&#34;: &#34;Banjo-Kazooie: Grunty&#39;s Revenge&#34;,&#xA;    &#34;genre&#34;: &#34;Real-time strategy&#34;,&#xA;    &#34;platform&#34;: &#34;Nintendo DSi&#34;,&#xA;    &#34;price&#34;: 46,&#xA;    &#34;created_at&#34;: &#34;2021-07-19T21:55:24.266Z&#34;,&#xA;    &#34;updated_at&#34;: &#34;2021-07-19T21:55:24.266Z&#34;&#xA;  },&#xA;  {&#xA;    &#34;id&#34;: 2,&#xA;    &#34;title&#34;: &#34;The Witcher 2: Assassins of Kings&#34;,&#xA;    &#34;genre&#34;: &#34;Text adventure&#34;,&#xA;    &#34;platform&#34;: &#34;Game Boy Advance&#34;,&#xA;    &#34;price&#34;: 49,&#xA;    &#34;created_at&#34;: &#34;2021-07-19T21:55:24.298Z&#34;,&#xA;    &#34;updated_at&#34;: &#34;2021-07-19T21:55:24.298Z&#34;&#xA;  },&#xA;  ...&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Awesome!&lt;/p&gt; &#xA;&lt;p&gt;You also have a lot of control over how this data is returned by using Active Record. For example, you could sort the games by title instead of the default sort order:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;  get &#39;/games&#39; do&#xA;    games = Game.all.order(:title)&#xA;    games.to_json&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or just return the first 10 games:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;  get &#39;/games&#39; do&#xA;    games = Game.all.order(:title).limit(10)&#xA;    games.to_json&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now that you have full control over how the server handles the response, you have the freedom to design your API as you see fit — just think about what kind of data you need for your frontend application.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s make one more small adjustment to the controller. By default, Sinatra sets a &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Glossary/Response_header&#34;&gt;response header&lt;/a&gt; with the &lt;code&gt;Content-Type: text/html&lt;/code&gt;, since in general, web servers are used to send HTML content to browsers. Our server, however, will be used to send JSON data, as you&#39;ve seen above. We can indicate this by changing the response header for all our routes by adding this to the controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class ApplicationController &amp;lt; Sinatra::Base&#xA;&#xA;  # Add this line to set the Content-Type header for all responses&#xA;  set :default_content_type, &#39;application/json&#39;&#xA;&#xA;  get &#39;/games&#39; do&#xA;    games = Game.all.order(:title).limit(10)&#xA;    games.to_json&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting One Game Using Params&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;ve got our API set up to handle one feature so far: we can return a list of all the games in the application. Let&#39;s imagine we&#39;re building another frontend feature; this time, we want a component that will just display the details about one specific game, including its associated reviews. Here&#39;s how that component might look:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;function GameDetail({ gameId }) {&#xA;  const [game, setGame] = useState(null);&#xA;&#xA;  useEffect(() =&amp;gt; {&#xA;    fetch(`http://localhost:9292/games/${gameId}`)&#xA;      .then((r) =&amp;gt; r.json())&#xA;      .then((game) =&amp;gt; setGame(game));&#xA;  }, [gameId]);&#xA;&#xA;  if (!game) return &amp;lt;h2&amp;gt;Loading game data...&amp;lt;/h2&amp;gt;;&#xA;&#xA;  return (&#xA;    &amp;lt;div&amp;gt;&#xA;      &amp;lt;h2&amp;gt;{game.title}&amp;lt;/h2&amp;gt;&#xA;      &amp;lt;p&amp;gt;Genre: {game.genre}&amp;lt;/p&amp;gt;&#xA;      &amp;lt;h4&amp;gt;Reviews&amp;lt;/h4&amp;gt;&#xA;      {game.reviews.map((review) =&amp;gt; (&#xA;        &amp;lt;div&amp;gt;&#xA;          &amp;lt;h5&amp;gt;{review.user.name}&amp;lt;/h5&amp;gt;&#xA;          &amp;lt;p&amp;gt;Score: {review.score}&amp;lt;/p&amp;gt;&#xA;          &amp;lt;p&amp;gt;Comment: {review.comment}&amp;lt;/p&amp;gt;&#xA;        &amp;lt;/div&amp;gt;&#xA;      ))}&#xA;    &amp;lt;/div&amp;gt;&#xA;  );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So for this feature, we know our server needs to be able to handle a GET request to return data about a specific game, using the game&#39;s ID to find it in the database. For example, a &lt;code&gt;GET /games/10&lt;/code&gt; request should return the game with the ID of 10 from the database; and a &lt;code&gt;GET /games/29&lt;/code&gt; request should return the game with the ID of 29.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s start by adding a &lt;strong&gt;dynamic route&lt;/strong&gt; to the controller to handle any of these requests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class ApplicationController &amp;lt; Sinatra::Base&#xA;  set :default_content_type, &#39;application/json&#39;&#xA;&#xA;  get &#39;/games&#39; do&#xA;    games = Game.all.order(:title).limit(10)&#xA;    games.to_json&#xA;  end&#xA;&#xA;  # use the :id syntax to create a dynamic route&#xA;  get &#39;/games/:id&#39; do&#xA;    # look up the game in the database using its ID&#xA;    # send a JSON-formatted response of the game data&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As we saw earlier, we can access data from the dynamic portion of the URL by using the &lt;strong&gt;params hash&lt;/strong&gt;. For example, if we make a GET request to &lt;code&gt;/games/10&lt;/code&gt;, the params hash would look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;{ &#34;id&#34; =&amp;gt; &#34;10&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With that in mind, what Active Record method could we use to look up a game with a specific ID? Either &lt;a href=&#34;https://api.rubyonrails.org/v6.1.4/classes/ActiveRecord/FinderMethods.html#method-i-find&#34;&gt;&lt;code&gt;.find&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;https://api.rubyonrails.org/v6.1.4/classes/ActiveRecord/FinderMethods.html#method-i-find_by&#34;&gt;&lt;code&gt;.find_by&lt;/code&gt;&lt;/a&gt; would do the trick. Let&#39;s give it a shot:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;  get &#39;/games/:id&#39; do&#xA;    # look up the game in the database using its ID&#xA;    game = Game.find(params[:id])&#xA;    # send a JSON-formatted response of the game data&#xA;    game.to_json&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With this code in place in the controller, try accessing the data about one game in the browser at &lt;a href=&#34;http://localhost:9292/games/1&#34;&gt;http://localhost:9292/games/1&lt;/a&gt;. You should see an object like this in the response:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;id&#34;: 1,&#xA;  &#34;title&#34;: &#34;Banjo-Kazooie: Grunty&#39;s Revenge&#34;,&#xA;  &#34;genre&#34;: &#34;Real-time strategy&#34;,&#xA;  &#34;platform&#34;: &#34;Nintendo DSi&#34;,&#xA;  &#34;price&#34;: 46,&#xA;  &#34;created_at&#34;: &#34;2021-07-19T21:55:24.266Z&#34;,&#xA;  &#34;updated_at&#34;: &#34;2021-07-19T21:55:24.266Z&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Try making requests using other game IDs as well. As long as the ID exists in the database, you&#39;ll get a response.&lt;/p&gt; &#xA;&lt;h3&gt;Accessing Associated Data&lt;/h3&gt; &#xA;&lt;p&gt;Right now, our server is returning information about the game, but how can we also access data about its associated models like the users and reviews? We could make another endpoint for the user and review data, and make additional requests from the frontend, but that might get messy. It would be more efficient to return this data together along with the game data in just one single response.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s take a look at the JSON being returned from the server. How does this Ruby code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;game = Game.find(params[:id])&#xA;game.to_json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...turn into this JSON object?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;id&#34;: 1,&#xA;  &#34;title&#34;: &#34;Banjo-Kazooie: Grunty&#39;s Revenge&#34;,&#xA;  &#34;genre&#34;: &#34;Real-time strategy&#34;,&#xA;  &#34;platform&#34;: &#34;Nintendo DSi&#34;,&#xA;  &#34;price&#34;: 46,&#xA;  &#34;created_at&#34;: &#34;2021-07-19T21:55:24.266Z&#34;,&#xA;  &#34;updated_at&#34;: &#34;2021-07-19T21:55:24.266Z&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When we&#39;re using the &lt;code&gt;#to_json&lt;/code&gt; method, Active Record &lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveModel/Serializers/JSON.html#method-i-as_json&#34;&gt;serializes&lt;/a&gt; (converts from one format to another) the Active Record object into a JSON object by getting a list of the model&#39;s attributes based on the column names defined in the database table associated with the model.&lt;/p&gt; &#xA;&lt;p&gt;Under the hood, the &lt;code&gt;#to_json&lt;/code&gt; method calls the &lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveModel/Serializers/JSON.html#method-i-as_json&#34;&gt;&lt;code&gt;#as_json&lt;/code&gt;&lt;/a&gt; method to generate a hash before converting it to a JSON string. Looking at the documentation for &lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveModel/Serializers/JSON.html#method-i-as_json&#34;&gt;&lt;code&gt;#as_json&lt;/code&gt;&lt;/a&gt;, you&#39;ll notice we can pass some additional options to customize how the object is serialized. To include data about associated models in our JSON, we can pass the &lt;code&gt;include:&lt;/code&gt; option to &lt;code&gt;#to_json&lt;/code&gt;, which will pass it along to &lt;code&gt;#as_json&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;  get &#39;/games/:id&#39; do&#xA;    game = Game.find(params[:id])&#xA;&#xA;    # include associated reviews in the JSON response&#xA;    game.to_json(include: :reviews)&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will produce the following JSON structure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;id&#34;: 1,&#xA;  &#34;title&#34;: &#34;Banjo-Kazooie: Grunty&#39;s Revenge&#34;,&#xA;  &#34;genre&#34;: &#34;Real-time strategy&#34;,&#xA;  &#34;platform&#34;: &#34;Nintendo DSi&#34;,&#xA;  &#34;price&#34;: 46,&#xA;  &#34;created_at&#34;: &#34;2021-07-19T21:55:24.266Z&#34;,&#xA;  &#34;updated_at&#34;: &#34;2021-07-19T21:55:24.266Z&#34;,&#xA;  &#34;reviews&#34;: [&#xA;    {&#xA;      &#34;id&#34;: 1,&#xA;      &#34;score&#34;: 9,&#xA;      &#34;comment&#34;: &#34;Qui dolorem dolores occaecati.&#34;,&#xA;      &#34;game_id&#34;: 1,&#xA;      &#34;created_at&#34;: &#34;2021-07-19T21:55:24.292Z&#34;,&#xA;      &#34;updated_at&#34;: &#34;2021-07-19T21:55:24.292Z&#34;,&#xA;      &#34;user_id&#34;: 2&#xA;    },&#xA;    {&#xA;      &#34;id&#34;: 2,&#xA;      &#34;score&#34;: 3,&#xA;      &#34;comment&#34;: &#34;Omnis tempora sequi ut.&#34;,&#xA;      &#34;game_id&#34;: 1,&#xA;      &#34;created_at&#34;: &#34;2021-07-19T21:55:24.295Z&#34;,&#xA;      &#34;updated_at&#34;: &#34;2021-07-19T21:55:24.295Z&#34;,&#xA;      &#34;user_id&#34;: 5&#xA;    }&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that this only works because our &lt;code&gt;Game&lt;/code&gt; model has the correct associations set up:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class Game &amp;lt; ActiveRecord::Base&#xA;  has_many :reviews&#xA;  has_many :users, through: :reviews&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can even take it a level further, and include the users associated with each review:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;  get &#39;/games/:id&#39; do&#xA;    game = Game.find(params[:id])&#xA;&#xA;    # include associated reviews in the JSON response&#xA;    game.to_json(include: { reviews: { include: :user } })&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;id&#34;: 1,&#xA;  &#34;title&#34;: &#34;Banjo-Kazooie: Grunty&#39;s Revenge&#34;,&#xA;  &#34;genre&#34;: &#34;Real-time strategy&#34;,&#xA;  &#34;platform&#34;: &#34;Nintendo DSi&#34;,&#xA;  &#34;price&#34;: 46,&#xA;  &#34;created_at&#34;: &#34;2021-07-19T21:55:24.266Z&#34;,&#xA;  &#34;updated_at&#34;: &#34;2021-07-19T21:55:24.266Z&#34;,&#xA;  &#34;reviews&#34;: [&#xA;    {&#xA;      &#34;id&#34;: 1,&#xA;      &#34;score&#34;: 9,&#xA;      &#34;comment&#34;: &#34;Qui dolorem dolores occaecati.&#34;,&#xA;      &#34;game_id&#34;: 1,&#xA;      &#34;created_at&#34;: &#34;2021-07-19T21:55:24.292Z&#34;,&#xA;      &#34;updated_at&#34;: &#34;2021-07-19T21:55:24.292Z&#34;,&#xA;      &#34;user_id&#34;: 2,&#xA;      &#34;user&#34;: {&#xA;        &#34;id&#34;: 2,&#xA;        &#34;name&#34;: &#34;Miss Landon Boehm&#34;,&#xA;        &#34;created_at&#34;: &#34;2021-07-19T21:55:24.247Z&#34;,&#xA;        &#34;updated_at&#34;: &#34;2021-07-19T21:55:24.247Z&#34;&#xA;      }&#xA;    },&#xA;    {&#xA;      &#34;id&#34;: 2,&#xA;      &#34;score&#34;: 3,&#xA;      &#34;comment&#34;: &#34;Omnis tempora sequi ut.&#34;,&#xA;      &#34;game_id&#34;: 1,&#xA;      &#34;created_at&#34;: &#34;2021-07-19T21:55:24.295Z&#34;,&#xA;      &#34;updated_at&#34;: &#34;2021-07-19T21:55:24.295Z&#34;,&#xA;      &#34;user_id&#34;: 5,&#xA;      &#34;user&#34;: {&#xA;        &#34;id&#34;: 5,&#xA;        &#34;name&#34;: &#34;The Hon. Del Ruecker&#34;,&#xA;        &#34;created_at&#34;: &#34;2021-07-19T21:55:24.252Z&#34;,&#xA;        &#34;updated_at&#34;: &#34;2021-07-19T21:55:24.252Z&#34;&#xA;      }&#xA;    }&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also be more selective about which attributes are returned from each model with the &lt;code&gt;only&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;  get &#39;/games/:id&#39; do&#xA;    game = Game.find(params[:id])&#xA;&#xA;    # include associated reviews in the JSON response&#xA;    game.to_json(only: [:id, :title, :genre, :price], include: {&#xA;      reviews: { only: [:comment, :score], include: {&#xA;        user: { only: [:name] }&#xA;      } }&#xA;    })&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;id&#34;: 1,&#xA;  &#34;title&#34;: &#34;Banjo-Kazooie: Grunty&#39;s Revenge&#34;,&#xA;  &#34;genre&#34;: &#34;Real-time strategy&#34;,&#xA;  &#34;price&#34;: 46,&#xA;  &#34;reviews&#34;: [&#xA;    {&#xA;      &#34;score&#34;: 9,&#xA;      &#34;comment&#34;: &#34;Qui dolorem dolores occaecati.&#34;,&#xA;      &#34;user&#34;: {&#xA;        &#34;name&#34;: &#34;Miss Landon Boehm&#34;&#xA;      }&#xA;    },&#xA;    {&#xA;      &#34;score&#34;: 3,&#xA;      &#34;comment&#34;: &#34;Omnis tempora sequi ut.&#34;,&#xA;      &#34;user&#34;: {&#xA;        &#34;name&#34;: &#34;The Hon. Del Ruecker&#34;&#xA;      }&#xA;    }&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Needless to say, the &lt;code&gt;#to_json&lt;/code&gt; method has a lot of capabilities! It&#39;s very handy when you need to structure your JSON response in a specific format based on what data is needed on the frontend.&lt;/p&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;In this lesson, you created your very first web API! You learned how to set up multiple routes to handle different requests based on what kind of data we needed for a frontend application, and used Active Record to serialize the JSON response to include all the data needed. At their most basic levels, almost all web APIs provide a way for clients, like React applications, to interact with a database and gain access to data in a structured way. Thanks to tools like Sinatra and Active Record, setting up this interface is fairly straightforward.&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://rubydoc.info/gems/sinatra#routes&#34;&gt;Sinatra Routes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveModel/Serializers/JSON.html#method-i-as_json&#34;&gt;Active Model &lt;code&gt;#as_json&lt;/code&gt; method&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-3-web-server-fundamentals-with-rack</title>
    <updated>2022-11-08T01:39:09Z</updated>
    <id>tag:github.com,2022-11-08:/learn-co-curriculum/phase-3-web-server-fundamentals-with-rack</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-web-server-fundamentals-with-rack" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Web Server Fundamentals&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Understand how a web server works&lt;/li&gt; &#xA; &lt;li&gt;Use Rack to create a simple, bare-bones web server&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;How does a web server work?&lt;/p&gt; &#xA;&lt;p&gt;We open a browser and it uses HTTP to send a message to a server. Servers are just computers running code that waits for requests and sends back responses. But when you say &lt;code&gt;/search?item=shoes&amp;amp;size=13M&lt;/code&gt;, how does it know to run the code to search for shoes of size 13M?&lt;/p&gt; &#xA;&lt;p&gt;All web servers have a core architecture in common. By looking at that architecture, we can build a mental model for how all web servers work. As an analogy, we can explain how all cars work like this:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&#34;Explosions made by gasoline and fire make an inside wheel go round and that inside wheel makes the outside wheels go round&#34;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;In the same way, we can say that all web servers work like this:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&#34;They wait for an HTTP request and look at the HTTP verb and path, and then run some conditional logic to find out which stuff to send back in the response&#34;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;In Ruby, this idea of &#34;a core architecture&#34; for all web-server-like things is captured in a gem called Rack. Rails, which you&#39;ll learn in Phase 4, &#34;rides on top of&#34; Rack. Sinatra, which you&#39;ll learn in the coming lessons, &#34;rides on top of&#34; Rack too.&lt;/p&gt; &#xA;&lt;p&gt;In fact, the idea of a base, common web-server library was such a good idea, other languages like Python and JavaScript (via the NodeJS environment) implemented their own &#34;base&#34; web server. By understanding the core mechanics of how a server works in Ruby, you&#39;ll have a &lt;strong&gt;much&lt;/strong&gt; easier time learning how to work with servers in those other languages.&lt;/p&gt; &#xA;&lt;p&gt;Before we get to the complexity of things built &lt;em&gt;on top of Rack&lt;/em&gt;, let&#39;s get a simple server working on Rack by itself.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: We&#39;ll be moving on from Rack shortly, so don&#39;t worry too much about understanding the exact syntax in this lesson. Focus on the concepts.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;To code along with this lesson, run &lt;code&gt;bundle install&lt;/code&gt;. We&#39;ll be using the &lt;a href=&#34;https://github.com/rack/rack&#34;&gt;Rack gem&lt;/a&gt;, which is included in the Gemfile.&lt;/p&gt; &#xA;&lt;h2&gt;Setting up Rack&lt;/h2&gt; &#xA;&lt;p&gt;Our goal with any web server is to be able to &lt;strong&gt;receive a request&lt;/strong&gt; and &lt;strong&gt;send a response&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To accomplish this with Rack, we need to create a class that responds to a single method: &lt;code&gt;#call&lt;/code&gt;. All this method needs to do is return an array with three elements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Status&#34;&gt;&lt;strong&gt;status code&lt;/strong&gt;&lt;/a&gt; (where &lt;code&gt;200&lt;/code&gt; is used for &lt;code&gt;OK&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;A &lt;strong&gt;response headers&lt;/strong&gt; hash with a &lt;code&gt;&#34;Content-Type&#34;&lt;/code&gt; key that returns the value of &lt;code&gt;text/html&lt;/code&gt; (for HTML-based responses)&lt;/li&gt; &#xA; &lt;li&gt;An array of strings to send back in the &lt;strong&gt;body&lt;/strong&gt; of the response (in our case, we can format the string like HTML: &lt;code&gt;&#34;&amp;lt;p&amp;gt;Like this!&amp;lt;/p&amp;gt;&#34;&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Essentially, we need the &lt;code&gt;#call&lt;/code&gt; method to return something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;[status code, headers hash, response body]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s an example that returns an HTML string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;[200, { &#34;Content-Type&#34; =&amp;gt; &#34;text/html&#34; }, [&#34;&amp;lt;h2&amp;gt;Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;!&amp;lt;/h2&amp;gt;&#34;]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Creating a Rack-Based Web Server&lt;/h2&gt; &#xA;&lt;p&gt;With this goal in mind, let&#39;s create a basic web server. Follow along with the instructions below.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s create a file called &lt;code&gt;config.ru&lt;/code&gt;. Files that are used by Rack end with &lt;code&gt;.ru&lt;/code&gt; instead of &lt;code&gt;.rb&lt;/code&gt; because they&#39;re normally loaded with a command called &lt;code&gt;rackup&lt;/code&gt;. It&#39;s a way to indicate to other developers that this is our server definition file.&lt;/p&gt; &#xA;&lt;p&gt;Add this code to the &lt;code&gt;config.ru&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;rack&#39;&#xA;&#xA;class App&#xA;  def call(env)&#xA;    [200, { &#34;Content-Type&#34; =&amp;gt; &#34;text/html&#34; }, [&#34;&amp;lt;h2&amp;gt;Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;!&amp;lt;/h2&amp;gt;&#34;]]&#xA;  end&#xA;end&#xA;&#xA;run App.new&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When we run this code, Rack will essentially run in a loop in the background waiting for a &lt;strong&gt;request&lt;/strong&gt; to come in. When it receives a request, it will call the &lt;code&gt;#call&lt;/code&gt; method and pass in data about the request, so we can send back the appropriate &lt;strong&gt;response&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Run this code from the command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ rackup config.ru&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Rack will print out something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;[2021-07-19 16:38:10] INFO  WEBrick 1.4.2&#xA;[2021-07-19 16:38:10] INFO  ruby 2.6.3 (2019-04-16) [universal.x86_64-darwin20]&#xA;[2021-07-19 16:38:10] INFO  WEBrick::HTTPServer#start: pid=34006 port=9292&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;WEBrick is a Ruby library that provides a simple HTTP server. Rack needs a web server to handle connections, and WEBrick is the default since it&#39;s included with Ruby. Later, we&#39;ll be replacing this with another more powerful Ruby server, Thin.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Try visiting &lt;code&gt;http://localhost:9292&lt;/code&gt; in your browser. This will send a GET request to your Rack server, and you should see the HTML response of &lt;code&gt;Hello World&lt;/code&gt; appear!&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s deconstruct this URL a little bit though. The URL is &lt;code&gt;http://localhost:9292/&lt;/code&gt;. The protocol is &lt;code&gt;http&lt;/code&gt;. That makes sense, but the domain is &lt;code&gt;localhost:9292&lt;/code&gt;. What&#39;s going on there?&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;localhost&lt;/code&gt; is normally where a domain name like &lt;code&gt;google.com&lt;/code&gt; goes. In this case, since you are running the server on your computer, &lt;code&gt;localhost&lt;/code&gt; refers to the internal address of your computer.&lt;/p&gt; &#xA;&lt;p&gt;The last part of that URL is the &lt;code&gt;:9292&lt;/code&gt; section. This the &#34;port number&#34; of your server. You may want to run multiple servers on one computer (for example, one for React and one for Sinatra) and having different ports allows them to be running simultaneously without conflicting.&lt;/p&gt; &#xA;&lt;p&gt;The path, or resource, that you are requesting is &lt;code&gt;/&lt;/code&gt;. This is effectively like saying the home or default path. You should be able to go to &lt;code&gt;http://localhost:9292/&lt;/code&gt; and see &lt;code&gt;Hello World&lt;/code&gt; printed out by your web server!&lt;/p&gt; &#xA;&lt;p&gt;Feel free to change &lt;code&gt;config.ru&lt;/code&gt; to add changes to your web server. If you make changes to &lt;code&gt;config.ru&lt;/code&gt; &lt;strong&gt;you&#39;ll have to shut down the server (&lt;code&gt;control + c&lt;/code&gt;) and re-start it to see the changes&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We can also access different information about the &lt;strong&gt;request&lt;/strong&gt; object by using the &lt;code&gt;env&lt;/code&gt; argument that is passed into the &lt;code&gt;call&lt;/code&gt; method. Try adding a &lt;code&gt;binding.pry&lt;/code&gt; to the &lt;code&gt;#call&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;rack&#39;&#xA;require &#39;pry&#39;&#xA;&#xA;class App&#xA;  def call(env)&#xA;    binding.pry&#xA;    [200, { &#34;Content-Type&#34; =&amp;gt; &#34;text/html&#34; }, [&#34;&amp;lt;h2&amp;gt;Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;!&amp;lt;/h2&amp;gt;&#34;]]&#xA;  end&#xA;end&#xA;&#xA;run App.new&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, stop (&lt;code&gt;control + c&lt;/code&gt;) and restart the server (&lt;code&gt;rackup config.ru&lt;/code&gt;), and refresh the browser to make another request to the server. You should hit your &lt;code&gt;binding.pry&lt;/code&gt; breakpoint, where you can explore the &lt;code&gt;env&lt;/code&gt; hash with all the data about the request:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;env[&#34;REQUEST_METHOD&#34;]&#xA;# =&amp;gt; &#34;GET&#34;&#xA;env[&#34;PATH_INFO&#34;]&#xA;# =&amp;gt; &#34;/&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From here, it&#39;s not too much of a leap to see how we could make our server more dynamic and set it up to send back &lt;strong&gt;different responses&lt;/strong&gt; based on the &lt;strong&gt;path&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;rack&#39;&#xA;require &#39;pry&#39;&#xA;&#xA;class App&#xA;  def call(env)&#xA;    path = env[&#34;PATH_INFO&#34;]&#xA;&#xA;    if path == &#34;/&#34;&#xA;      [200, { &#34;Content-Type&#34; =&amp;gt; &#34;text/html&#34; }, [&#34;&amp;lt;h2&amp;gt;Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;!&amp;lt;/h2&amp;gt;&#34;]]&#xA;    elsif path == &#34;/potato&#34;&#xA;      [200, { &#34;Content-Type&#34; =&amp;gt; &#34;text/html&#34; }, [&#34;&amp;lt;p&amp;gt;Boil &#39;em, mash &#39;em, stick &#39;em in a stew&amp;lt;/p&amp;gt;&#34;]]&#xA;    else&#xA;      [404, { &#34;Content-Type&#34; =&amp;gt; &#34;text/html&#34; }, [&#34;Page not found&#34;]]&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;run App.new&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Try restarting the server, and make requests in the browser to see the response change based on the path:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://localhost:9292/&#34;&gt;http://localhost:9292/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://localhost:9292/potato&#34;&gt;http://localhost:9292/potato&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://localhost:9292/home&#34;&gt;http://localhost:9292/home&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This conditional logic based on the path (and also the HTTP verb, as we&#39;ll see later) is known as &lt;strong&gt;routing&lt;/strong&gt;, and it&#39;s is basically what web servers do all day long. Rails, Sinatra, any web programming framework you can name: one of their key features is to simplify and standardize how routing works so we can focus on working with data and generating responses.&lt;/p&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;Rack is a simple, low-level tool for writing servers in Ruby. Since it&#39;s such a low-level tool, it can be challenging to build more complex applications with. In the next lesson, we&#39;ll learn how to use Sinatra to help with some common tasks when building a web server.&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rack/rack&#34;&gt;Rack gem&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>