<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-19T01:32:52Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ytti/oxidized</title>
    <updated>2022-06-19T01:32:52Z</updated>
    <id>tag:github.com,2022-06-19:/ytti/oxidized</id>
    <link href="https://github.com/ytti/oxidized" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Oxidized is a network device configuration backup tool. It&#39;s a RANCID replacement!&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Oxidized&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.com/ytti/oxidized&#34;&gt;&lt;img src=&#34;https://api.travis-ci.com/ytti/oxidized.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/ytti/oxidized?branch=master&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/ytti/oxidized/coverage.svg?branch=master&#34; alt=&#34;codecov.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.codacy.com/app/ytti/oxidized?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=ytti/oxidized&amp;amp;utm_campaign=Badge_Grade&#34;&gt;&lt;img src=&#34;https://api.codacy.com/project/badge/Grade/5a90cb22db6a4d5ea23ad0dfb53fe03a&#34; alt=&#34;Codacy Badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/ytti/oxidized&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/ytti/oxidized/badges/gpa.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://badge.fury.io/rb/oxidized&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/oxidized.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/oxidized/Lobby?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/oxidized/Lobby.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/oxidized/Lobby&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Oxidized is a network device configuration backup tool. It&#39;s a RANCID replacement!&lt;/p&gt; &#xA;&lt;p&gt;Light and extensible, Oxidized supports over 130 operating system types.&lt;/p&gt; &#xA;&lt;p&gt;Feature highlights:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Automatically adds/removes threads to meet configured retrieval interval&lt;/li&gt; &#xA; &lt;li&gt;Restful API to a move node immediately to head-of-queue (GET/POST /node/next/[NODE])&lt;/li&gt; &#xA; &lt;li&gt;Syslog udp+file example to catch config change events (IOS/JunOS) and trigger a config fetch &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Will signal which IOS/JunOS user made the change, can then be used by output modules (via POST)&lt;/li&gt; &#xA;   &lt;li&gt;The &lt;code&gt;git&lt;/code&gt; output module uses this info - &#39;git blame&#39; will show who changed each line, and when&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Restful API to reload list of nodes (GET /reload)&lt;/li&gt; &#xA; &lt;li&gt;Restful API to fetch configurations (/node/fetch/[NODE] or /node/fetch/group/[NODE])&lt;/li&gt; &#xA; &lt;li&gt;Restful API to show list of nodes (GET /nodes)&lt;/li&gt; &#xA; &lt;li&gt;Restful API to show list of version for a node (/node/version[NODE]) and diffs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Check out the &lt;a href=&#34;http://youtu.be/kBQ_CTUuqeU#t=3h&#34;&gt;Oxidized TREX 2014 presentation&lt;/a&gt; video on YouTube!&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;span&gt;⚠&lt;/span&gt; &lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/#help-needed&#34;&gt;Maintainer Wanted!&lt;/a&gt; &lt;span&gt;⚠&lt;/span&gt;&lt;/p&gt; &#xA; &lt;p&gt;Is your company using Oxidized and has Ruby developers on staff? I&#39;d love help from an extra maintainer!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Index&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Supported-OS-Types.md&#34;&gt;Supported OS Types&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/#debian-and-ubuntu&#34;&gt;Debian and Ubuntu&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/#centos-oracle-linux-red-hat-linux&#34;&gt;CentOS, Oracle Linux, Red Hat Linux&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/#freebsd&#34;&gt;FreeBSD&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/#build-from-git&#34;&gt;Build from Git&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/#running-with-docker&#34;&gt;Docker&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/#installing-ruby-23-using-rvm&#34;&gt;Installing Ruby 2.3 using RVM&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/#configuration&#34;&gt;Initial Configuration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md&#34;&gt;Configuration&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md#debugging&#34;&gt;Debugging&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md#privileged-mode&#34;&gt;Privileged mode&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md#disabling-ssh-exec-channels&#34;&gt;Disabling SSH exec channels&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Sources.md&#34;&gt;Sources&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Sources.md#source-csv&#34;&gt;Source: CSV&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Sources.md#source-sql&#34;&gt;Source: SQL&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Sources.md#source-sqlite&#34;&gt;Source: SQLite&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Sources.md#source-mysql&#34;&gt;Source: Mysql&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Sources.md#source-http&#34;&gt;Source: HTTP&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Outputs.md&#34;&gt;Outputs&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Outputs.md#output-git&#34;&gt;Output: GIT&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Outputs.md#output-git-crypt&#34;&gt;Output: GIT-Crypt&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Outputs.md#output-http&#34;&gt;Output: HTTP&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Outputs.md#output-file&#34;&gt;Output: File&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Outputs.md#output-types&#34;&gt;Output types&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md#advanced-configuration&#34;&gt;Advanced Configuration&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md#advanced-group-configuration&#34;&gt;Advanced Group Configuration&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Hooks.md&#34;&gt;Hooks&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Hooks.md#hook-type-exec&#34;&gt;Hook: exec&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Hooks.md#hook-type-githubrepo&#34;&gt;Hook: githubrepo&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Hooks.md#hook-type-awssns&#34;&gt;Hook: awssns&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Hooks.md#hook-type-slackdiff&#34;&gt;Hook: slackdiff&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Hooks.md#hook-type-xmppdiff&#34;&gt;Hook: xmppdiff&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Hooks.md#hook-type-ciscosparkdiff&#34;&gt;Hook: ciscosparkdiff&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Creating-Models.md&#34;&gt;Creating and Extending Models&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/#help&#34;&gt;Help&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Ruby-API.md#ruby-api&#34;&gt;Ruby API&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Ruby-API.md#input&#34;&gt;Input&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Ruby-API.md#output&#34;&gt;Output&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Ruby-API.md#source&#34;&gt;Source&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Ruby-API.md#model&#34;&gt;Model&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Debian and Ubuntu&lt;/h3&gt; &#xA;&lt;p&gt;Debian &#34;buster&#34; or newer and Ubuntu 17.10 (artful) or newer are recommended. On Ubuntu, begin by enabling the &lt;code&gt;universe&lt;/code&gt; repository (required for libssh2-1-dev):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;add-apt-repository universe&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install the dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;apt-get install ruby ruby-dev libsqlite3-dev libssl-dev pkg-config cmake libssh2-1-dev libicu-dev zlib1g-dev g++&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, install the gems:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;gem install oxidized&#xA;gem install oxidized-script oxidized-web # If you don&#39;t install oxidized-web, ensure &#34;rest&#34; is removed from your Oxidized config.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CentOS, Oracle Linux, Red Hat Linux&lt;/h3&gt; &#xA;&lt;p&gt;On CentOS 6 and 7 / RHEL 6 and 7, begin by installing Ruby 2.3 or greater. This can be accomplished in one of several ways:&lt;/p&gt; &#xA;&lt;p&gt;Install Ruby 2.3 from &lt;a href=&#34;https://www.softwarecollections.org/en/scls/rhscl/rh-ruby23/&#34;&gt;SCL&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install centos-release-scl&#xA;yum install rh-ruby23 rh-ruby23-ruby-devel&#xA;scl enable rh-ruby23 bash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following additional packages will be required to build the dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install make cmake which sqlite-devel openssl-devel libssh2-devel ruby gcc ruby-devel libicu-devel gcc-c++&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, install Ruby 2.6 via RVM by following the instructions:&lt;/p&gt; &#xA;&lt;p&gt;Make sure you dont have any leftover ruby: &lt;code&gt;yum erase ruby&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then, install gpg key and rvm&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sudo&#34;&gt;curl -sSL https://get.rvm.io | bash -s stable&#xA;source /etc/profile.d/rvm.sh&#xA;rvm requirements run&#xA;rvm install 2.6.0&#xA;rvm use 2.6.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install oxidized requirements: &lt;code&gt;yum install make cmake which sqlite-devel openssl-devel libssh2-devel gcc libicu-devel gcc-c++&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Install the gems: &lt;code&gt;gem install oxidized oxidized-web&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;You need to wrap the gem and reference the wrap in the systemctl service file: &lt;code&gt;rvm wrapper oxidized&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can see where the wrapped gem is via &lt;code&gt;rvm wrapper show oxidized&lt;/code&gt; Use that path in the oxidized.service file, restart the systemctl daemon, run oxidized by hand once, edit config file, start service.&lt;/p&gt; &#xA;&lt;h3&gt;FreeBSD&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/#installing-ruby-23-using-rvm&#34;&gt;Use RVM to install Ruby v2.3&lt;/a&gt;, then install all required packages and gems:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pkg install cmake pkgconf&#xA;gem install oxidized&#xA;gem install oxidized-script oxidized-web&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Oxidized is also available via &lt;a href=&#34;https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=203374&#34;&gt;FreeBSD ports&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pkg install rubygem-oxidized rubygem-oxidized-script rubygem-oxidized-web&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build from Git&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/ytti/oxidized.git&#xA;cd oxidized/&#xA;gem install bundler&#xA;rake install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Running with Docker&lt;/h3&gt; &#xA;&lt;p&gt;Currently, Docker Hub automatically builds the master branch as &lt;a href=&#34;https://hub.docker.com/r/oxidized/oxidized/&#34;&gt;oxidized/oxidized&lt;/a&gt;, you can make use of this container or build your own.&lt;/p&gt; &#xA;&lt;p&gt;To build your own, clone git repo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/ytti/oxidized&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, build the container locally (requires docker 17.05.0-ce or higher):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker build -q -t oxidized/oxidized:latest oxidized/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you&#39;ve built the container (or chosen to make use of the automatically built container in Docker Hub, which will be downloaded for you by docker on the first &lt;code&gt;run&lt;/code&gt; command had you not built it), proceed as follows:&lt;/p&gt; &#xA;&lt;p&gt;Create a configuration directory in the host system:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir /etc/oxidized&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the container for the first time to initialize the config:&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: this step in only required for creating the Oxidized configuration file and can be skipped if you already have one.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run --rm -v /etc/oxidized:/root/.config/oxidized -p 8888:8888/tcp -t oxidized/oxidized:latest oxidized&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the RESTful API and Web Interface are enabled, on the docker host running the container edit &lt;code&gt;/etc/oxidized/config&lt;/code&gt; and modify &lt;code&gt;rest: 127.0.0.1:8888&lt;/code&gt; to &lt;code&gt;rest: 0.0.0.0:8888&lt;/code&gt;. This will bind port 8888 to all interfaces, and expose the port so that it could be accessed externally. &lt;a href=&#34;https://github.com/ytti/oxidized/issues/445&#34;&gt;(Issue #445)&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can use docker-compose to launch the oxidized container:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# docker-compose.yml&#xA;# docker-compose file example for oxidized that will start along with docker daemon&#xA;---&#xA;version: &#34;3&#34;&#xA;services:&#xA;  oxidized:&#xA;    restart: always&#xA;    image: oxidized/oxidized:latest&#xA;    ports:&#xA;      - 8888:8888/tcp&#xA;    environment:&#xA;      CONFIG_RELOAD_INTERVAL: 600&#xA;    volumes:&#xA;       - config:/root/.config/oxidized/config&#xA;       - router.db:/root/.config/oxidized/router.db&#xA;       - model:/root/.config/oxidized/model&#xA;       # if git is use as input&#xA;       - data:/root/.config/oxidized/backupcfg/&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create the &lt;code&gt;/etc/oxidized/router.db&lt;/code&gt; (see &lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Sources.md#source-csv&#34;&gt;CSV Source&lt;/a&gt; for further info):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/oxidized/router.db&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run container again to start oxidized with your configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -v /etc/oxidized:/root/.config/oxidized -p 8888:8888/tcp -t oxidized/oxidized:latest&#xA;oxidized[1]: Oxidized starting, running as pid 1&#xA;oxidized[1]: Loaded 1 nodes&#xA;Puma 2.13.4 starting...&#xA;* Min threads: 0, max threads: 16&#xA;* Environment: development&#xA;* Listening on tcp://0.0.0.0:8888&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to have the config automatically reloaded (e.g. when using a http source that changes):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -v /etc/oxidized:/root/.config/oxidized -p 8888:8888/tcp -e CONFIG_RELOAD_INTERVAL=3600 -t oxidized/oxidized:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to use an internal CA (e.g. to connect to an private github instance):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -v /etc/oxidized:/root/.config/oxidized -v /path/to/MY-CA.crt:/usr/local/share/ca-certificates/MY-CA.crt -p 8888:8888/tcp -e UPDATE_CA_CERTIFICATES=true -t oxidized/oxidized:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Installing Ruby 2.3 using RVM&lt;/h3&gt; &#xA;&lt;p&gt;Install Ruby 2.3 build dependencies&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install curl gcc-c++ patch readline readline-devel zlib zlib-devel&#xA;yum install libyaml-devel libffi-devel openssl-devel make cmake&#xA;yum install bzip2 autoconf automake libtool bison iconv-devel libssh2-devel libicu-devel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install RVM&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -L get.rvm.io | bash -s stable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Setup RVM environment and compile and install Ruby 2.3 and set it as default&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;source /etc/profile.d/rvm.sh&#xA;rvm install 2.3&#xA;rvm use --default 2.3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Oxidized configuration is in YAML format. Configuration files are subsequently sourced from &lt;code&gt;/etc/oxidized/config&lt;/code&gt; then &lt;code&gt;~/.config/oxidized/config&lt;/code&gt;. The hashes will be merged, this might be useful for storing source information in a system wide file and user specific configuration in the home directory (to only include a staff specific username and password). Eg. if many users are using &lt;code&gt;oxs&lt;/code&gt;, see &lt;a href=&#34;https://github.com/ytti/oxidized-script&#34;&gt;Oxidized::Script&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is recommended practice to run Oxidized using its own username. This username can be added using standard command-line tools:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;useradd -s /bin/bash -m oxidized&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;It is recommended &lt;strong&gt;not&lt;/strong&gt; to run Oxidized as root.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To initialize a default configuration in your home directory &lt;code&gt;~/.config/oxidized/config&lt;/code&gt;, simply run &lt;code&gt;oxidized&lt;/code&gt; once. If you don&#39;t further configure anything from the output and source sections, it&#39;ll extend the examples on a subsequent &lt;code&gt;oxidized&lt;/code&gt; execution. This is useful to see what options for a specific source or output backend are available.&lt;/p&gt; &#xA;&lt;p&gt;You can set the env variable &lt;code&gt;OXIDIZED_HOME&lt;/code&gt; to change its home directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;OXIDIZED_HOME=/etc/oxidized&#xA;&#xA;$ tree -L 1 /etc/oxidized&#xA;/etc/oxidized/&#xA;├── config&#xA;├── log-router-ssh&#xA;├── log-router-telnet&#xA;├── pid&#xA;├── router.db&#xA;└── repository.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Source&lt;/h2&gt; &#xA;&lt;p&gt;Oxidized supports &lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md#source-csv&#34;&gt;CSV&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md#source-sqlite&#34;&gt;SQLite&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md#source-mysql&#34;&gt;MySQL&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md#source-http&#34;&gt;HTTP&lt;/a&gt; as source backends. The CSV backend reads nodes from a rancid compatible router.db file. The SQLite and MySQL backends will fire queries against a database and map certain fields to model items. The HTTP backend will fire queries against a http/https url. Take a look at the &lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md&#34;&gt;Configuration&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Outputs&lt;/h2&gt; &#xA;&lt;p&gt;Possible outputs are either &lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md#output-file&#34;&gt;File&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md#output-git&#34;&gt;GIT&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md#output-git-crypt&#34;&gt;GIT-Crypt&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md#output-http&#34;&gt;HTTP&lt;/a&gt;. The file backend takes a destination directory as argument and will keep a file per device, with most recent running version of a device. The GIT backend (recommended) will initialize an empty GIT repository in the specified path and create a new commit on every configuration change. The GIT-Crypt backend will also initialize a GIT repository but every configuration push to it will be encrypted on the fly by using &lt;code&gt;git-crypt&lt;/code&gt; tool. Take a look at the &lt;a href=&#34;https://raw.githubusercontent.com/ytti/oxidized/master/docs/Configuration.md&#34;&gt;Configuration&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;Maps define how to map a model&#39;s fields to model &lt;a href=&#34;https://github.com/ytti/oxidized/tree/master/lib/oxidized/model&#34;&gt;model fields&lt;/a&gt;. Most of the settings should be self explanatory, log is ignored if &lt;code&gt;use_syslog&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;First create the directory where the CSV &lt;code&gt;output&lt;/code&gt; is going to store device configs and start Oxidized once.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir -p ~/.config/oxidized/configs&#xA;oxidized&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now tell Oxidized where it finds a list of network devices to backup configuration from. You can either use CSV or SQLite as source. To create a CSV source add the following snippet:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;source:&#xA;  default: csv&#xA;  csv:&#xA;    file: ~/.config/oxidized/router.db&#xA;    delimiter: !ruby/regexp /:/&#xA;    map:&#xA;      name: 0&#xA;      model: 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now lets create a file based device database (you might want to switch to SQLite later on). Put your routers in &lt;code&gt;~/.config/oxidized/router.db&lt;/code&gt; (file format is compatible with rancid). Simply add an item per line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;router01.example.com:ios&#xA;switch01.example.com:procurve&#xA;router02.example.com:ios&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run &lt;code&gt;oxidized&lt;/code&gt; again to take the first backups.&lt;/p&gt; &#xA;&lt;h2&gt;Extra&lt;/h2&gt; &#xA;&lt;h3&gt;Ubuntu init setup&lt;/h3&gt; &#xA;&lt;p&gt;The systemd service assumes that you have a user named &#39;oxidized&#39; and that oxidized is in one of the following paths:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;/sbin&#xA;/bin&#xA;/usr/sbin&#xA;/usr/bin&#xA;/usr/local/bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Copy systemd service file from extra/ folder to /etc/systemd/system&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo cp extra/oxidized.service /etc/systemd/system&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Setup /var/run/&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir /run/oxidized&#xA;chown oxidized:oxidized /run/oxidized&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Make oxidized start on boot&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo systemctl enable oxidized.service&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Help&lt;/h2&gt; &#xA;&lt;p&gt;If you need help with Oxidized then we have a few methods you can use to get in touch.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gitter.im/oxidized/Lobby?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;Gitter&lt;/a&gt; - You can join the Lobby on gitter to chat to other Oxidized users.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ytti/oxidized/&#34;&gt;GitHub&lt;/a&gt; - For help and requests for code changes / updates.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://community.librenms.org/c/help/oxidized&#34;&gt;Forum&lt;/a&gt; - A user forum run by &lt;a href=&#34;https://github.com/librenms/librenms&#34;&gt;LibreNMS&lt;/a&gt; where you can ask for help and support.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Help Needed&lt;/h2&gt; &#xA;&lt;p&gt;As things stand right now, &lt;code&gt;oxidized&lt;/code&gt; is maintained by a single person. A great many &lt;a href=&#34;https://github.com/ytti/oxidized/graphs/contributors&#34;&gt;contributors&lt;/a&gt; have helped further the software, however contributions are not the same as ongoing owner- and maintainer-ship. It appears that many companies use the software to manage their network infrastructure, this is great news! But without additional help to maintain the software and put out releases, the future of oxidized might be less bright. The current pace of development and the much needed refactoring simply are not sustainable if they are to be driven by a single person.&lt;/p&gt; &#xA;&lt;h2&gt;Maintainers&lt;/h2&gt; &#xA;&lt;p&gt;If you would like to be a maintainer for Oxidized then please read through the below and see if it&#39;s something you would like to help with. It&#39;s not a requirement that you can tick all the boxes below but it helps :)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Triage on issues, review pull requests and help answer any questions from users.&lt;/li&gt; &#xA; &lt;li&gt;Above average knowledge of the Ruby programming language.&lt;/li&gt; &#xA; &lt;li&gt;Professional experience with both oxidized and some other config backup tool (like rancid).&lt;/li&gt; &#xA; &lt;li&gt;Ability to keep a cool head, and enjoy interaction with end users! :)&lt;/li&gt; &#xA; &lt;li&gt;A desire and passion to help drive &lt;code&gt;oxidized&lt;/code&gt; towards its &lt;code&gt;1.x.x&lt;/code&gt; stage of life &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Help refactor the code&lt;/li&gt; &#xA;   &lt;li&gt;Rework the core infrastructure&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Permission from your employer to contribute to open source projects&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;YES, I WANT TO HELP&lt;/h2&gt; &#xA;&lt;p&gt;Awesome! Simply send an e-mail to Saku Ytti at &lt;a href=&#34;mailto:saku@ytti.fi&#34;&gt;saku@ytti.fi&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Further reading&lt;/h2&gt; &#xA;&lt;p&gt;Brian Anderson (from Rust fame) wrote an &lt;a href=&#34;http://brson.github.io/2017/04/05/minimally-nice-maintainer&#34;&gt;excellent post&lt;/a&gt; on what it means to be a maintainer.&lt;/p&gt; &#xA;&lt;h2&gt;License and Copyright&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;      Copyright&#xA;      2013-2015 Saku Ytti &amp;lt;saku@ytti.fi&amp;gt;&#xA;      2013-2015 Samer Abdel-Hafez &amp;lt;sam@arahant.net&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Shopify/ruby-lsp</title>
    <updated>2022-06-19T01:32:52Z</updated>
    <id>tag:github.com,2022-06-19:/Shopify/ruby-lsp</id>
    <link href="https://github.com/Shopify/ruby-lsp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An opinionated language server for Ruby&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/Shopify/ruby-lsp/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Ruby LSP&lt;/h1&gt; &#xA;&lt;p&gt;This gem is an implementation of the language server protocol specification for Ruby, used to improve editor features.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Install the gem. There&#39;s no need to require it, since the server is used as a standalone executable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;group :development do&#xA;  gem &#34;ruby-lsp&#34;, require: false&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If using VS Code, install the &lt;a href=&#34;https://github.com/Shopify/vscode-ruby-lsp&#34;&gt;Ruby LSP plugin&lt;/a&gt; to get the extra features in the editor.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://shopify.github.io/ruby-lsp&#34;&gt;documentation&lt;/a&gt; for supported features.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Bug reports and pull requests are welcome on GitHub at &lt;a href=&#34;https://github.com/Shopify/ruby-lsp&#34;&gt;https://github.com/Shopify/ruby-lsp&lt;/a&gt;. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the &lt;a href=&#34;https://github.com/Shopify/ruby-lsp/raw/main/CODE_OF_CONDUCT.md&#34;&gt;Contributor Covenant&lt;/a&gt; code of conduct.&lt;/p&gt; &#xA;&lt;h3&gt;Expectation testing&lt;/h3&gt; &#xA;&lt;p&gt;To simplify the way we run tests over different pieces of Ruby code, we use a custom expectations test framework against a set of Ruby fixtures.&lt;/p&gt; &#xA;&lt;p&gt;To add a new fixture to the expectations test suite:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add a new fixture &lt;code&gt;my_fixture.rb&lt;/code&gt; file under &lt;code&gt;test/fixtures&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;(optional) Add new expectations under &lt;code&gt;test/expectations/$HANDLER&lt;/code&gt; for the request handlers you&#39;re concerned by&lt;/li&gt; &#xA; &lt;li&gt;Profit by running &lt;code&gt;bin/test test/requests/$HANDLER_expectations_test my_fixture&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Handlers for which you added expectations will be checked with &lt;code&gt;assert_expectations&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Handlers without expectations will be ran against your new test to check that nothing breaks&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;To add a new expectations test runner for a new request handler:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Add a new file under &lt;code&gt;test/requests/$HANDLER_expectations_test.rb&lt;/code&gt; that subclasses &lt;code&gt;ExpectationsTestRunner&lt;/code&gt; and calls &lt;code&gt;expectations_tests $HANDLER, &#34;$EXPECTATIONS_DIR&#34;&lt;/code&gt; where: &lt;code&gt;$HANDLER&lt;/code&gt; is the fully qualified name or your handler class and &lt;code&gt;$EXPECTATIONS_DIR&lt;/code&gt; is the directory name where you want to store the expectation files.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# frozen_string_literal: true&#xA;&#xA;require &#34;test_helper&#34;&#xA;require &#34;expectations/expectations_test_runner&#34;&#xA;&#xA;class $HANDLERExpectationsTest &amp;lt; ExpectationsTestRunner&#xA;  expectations_tests RubyLsp::Requests::$HANDLER, &#34;$EXPECTATIONS_DIR&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;(optional) Override the &lt;code&gt;run_expectations&lt;/code&gt; and &lt;code&gt;assert_expectations&lt;/code&gt; methods if needed. See the different request handler expectations runners under &lt;code&gt;test/requests/*_expectations_test.rb&lt;/code&gt; for examples.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;(optional) Add new fixtures for your handler under &lt;code&gt;test/fixtures&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;(optional) Add new expectations under &lt;code&gt;test/expectations/$HANDLER&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;No need to write the expectations by hand, just run the test with an empty expectation file and copy from the output.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Profit by running, &lt;code&gt;bin/test test/expectations_test $HANDLER&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Tests with expectations will be checked with &lt;code&gt;assert_expectations&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Tests without expectations will be ran against your new $HANDLER to check that nothing breaks&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Debugging&lt;/h2&gt; &#xA;&lt;h3&gt;Tracing LSP requests and responses&lt;/h3&gt; &#xA;&lt;p&gt;LSP server tracing can be controlled through the &lt;code&gt;ruby lsp.trace.server&lt;/code&gt; config key in the &lt;code&gt;.vscode/settings.json&lt;/code&gt; config file.&lt;/p&gt; &#xA;&lt;p&gt;Possible values are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;off&lt;/code&gt;: no tracing&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;messages&lt;/code&gt;: display requests and responses notifications&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;verbose&lt;/code&gt;: display each request and response as JSON&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;https://github.com/Shopify/ruby-lsp/raw/main/LICENSE.txt&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>carrierwaveuploader/carrierwave</title>
    <updated>2022-06-19T01:32:52Z</updated>
    <id>tag:github.com,2022-06-19:/carrierwaveuploader/carrierwave</id>
    <link href="https://github.com/carrierwaveuploader/carrierwave" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Classier solution for file uploads for Rails, Sinatra and other Ruby web frameworks&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CarrierWave&lt;/h1&gt; &#xA;&lt;p&gt;This gem provides a simple and extremely flexible way to upload files from Ruby applications. It works well with Rack based web applications, such as Ruby on Rails.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/carrierwaveuploader/carrierwave/actions&#34;&gt;&lt;img src=&#34;https://github.com/carrierwaveuploader/carrierwave/workflows/Test/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/carrierwaveuploader/carrierwave&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/carrierwaveuploader/carrierwave.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://dependabot.com/compatibility-score.html?dependency-name=carrierwave&amp;amp;package-manager=bundler&amp;amp;version-scheme=semver&#34;&gt;&lt;img src=&#34;https://api.dependabot.com/badges/compatibility_score?dependency-name=carrierwave&amp;amp;package-manager=bundler&amp;amp;version-scheme=semver&#34; alt=&#34;SemVer&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Information&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RDoc documentation &lt;a href=&#34;http://rubydoc.info/gems/carrierwave/frames&#34;&gt;available on RubyDoc.info&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Source code &lt;a href=&#34;http://github.com/carrierwaveuploader/carrierwave&#34;&gt;available on GitHub&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;More information, known limitations, and how-tos &lt;a href=&#34;https://github.com/carrierwaveuploader/carrierwave/wiki&#34;&gt;available on the wiki&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Help&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Please ask the community on &lt;a href=&#34;https://stackoverflow.com/questions/tagged/carrierwave&#34;&gt;Stack Overflow&lt;/a&gt; for help if you have any questions. Please do not post usage questions on the issue tracker.&lt;/li&gt; &#xA; &lt;li&gt;Please report bugs on the &lt;a href=&#34;http://github.com/carrierwaveuploader/carrierwave/issues&#34;&gt;issue tracker&lt;/a&gt; but read the &#34;getting help&#34; section in the wiki first.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install the latest release:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install carrierwave&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In Rails, add it to your Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;carrierwave&#39;, &#39;~&amp;gt; 2.0&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, restart the server to apply the changes.&lt;/p&gt; &#xA;&lt;p&gt;As of version 2.0, CarrierWave requires Rails 5.0 or higher and Ruby 2.2 or higher. If you&#39;re on Rails 4, you should use 1.x.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Start off by generating an uploader:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rails generate uploader Avatar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;this should give you a file in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;app/uploaders/avatar_uploader.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check out this file for some hints on how you can customize your uploader. It should look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AvatarUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  storage :file&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use your uploader class to store and retrieve files like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;uploader = AvatarUploader.new&#xA;&#xA;uploader.store!(my_file)&#xA;&#xA;uploader.retrieve_from_store!(&#39;my_file.png&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;CarrierWave gives you a &lt;code&gt;store&lt;/code&gt; for permanent storage, and a &lt;code&gt;cache&lt;/code&gt; for temporary storage. You can use different stores, including filesystem and cloud storage.&lt;/p&gt; &#xA;&lt;p&gt;Most of the time you are going to want to use CarrierWave together with an ORM. It is quite simple to mount uploaders on columns in your model, so you can simply assign files and get going:&lt;/p&gt; &#xA;&lt;h3&gt;ActiveRecord&lt;/h3&gt; &#xA;&lt;p&gt;Make sure you are loading CarrierWave after loading your ORM, otherwise you&#39;ll need to require the relevant extension manually, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;carrierwave/orm/activerecord&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add a string column to the model you want to mount the uploader by creating a migration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rails g migration add_avatar_to_users avatar:string&#xA;rails db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Open your model file and mount the uploader:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ApplicationRecord&#xA;  mount_uploader :avatar, AvatarUploader&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can cache files by assigning them to the attribute, they will automatically be stored when the record is saved.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;u = User.new&#xA;u.avatar = params[:file] # Assign a file like this, or&#xA;&#xA;# like this&#xA;File.open(&#39;somewhere&#39;) do |f|&#xA;  u.avatar = f&#xA;end&#xA;&#xA;u.save!&#xA;u.avatar.url # =&amp;gt; &#39;/url/to/file.png&#39;&#xA;u.avatar.current_path # =&amp;gt; &#39;path/to/file.png&#39;&#xA;u.avatar_identifier # =&amp;gt; &#39;file.png&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;u.avatar&lt;/code&gt; will never return nil, even if there is no photo associated to it. To check if a photo was saved to the model, use &lt;code&gt;u.avatar.file.nil?&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;h3&gt;DataMapper, Mongoid, Sequel&lt;/h3&gt; &#xA;&lt;p&gt;Other ORM support has been extracted into separate gems:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/carrierwaveuploader/carrierwave-datamapper&#34;&gt;carrierwave-datamapper&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/carrierwaveuploader/carrierwave-mongoid&#34;&gt;carrierwave-mongoid&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/carrierwaveuploader/carrierwave-sequel&#34;&gt;carrierwave-sequel&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There are more extensions listed in &lt;a href=&#34;https://github.com/carrierwaveuploader/carrierwave/wiki&#34;&gt;the wiki&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Multiple file uploads&lt;/h2&gt; &#xA;&lt;p&gt;CarrierWave also has convenient support for multiple file upload fields.&lt;/p&gt; &#xA;&lt;h3&gt;ActiveRecord&lt;/h3&gt; &#xA;&lt;p&gt;Add a column which can store an array. This could be an array column or a JSON column for example. Your choice depends on what your database supports. For example, create a migration like this:&lt;/p&gt; &#xA;&lt;h4&gt;For databases with ActiveRecord json data type support (e.g. PostgreSQL, MySQL)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rails g migration add_avatars_to_users avatars:json&#xA;rails db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;For database without ActiveRecord json data type support (e.g. SQLite)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rails g migration add_avatars_to_users avatars:string&#xA;rails db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: JSON datatype doesn&#39;t exists in SQLite adapter, that&#39;s why you can use a string datatype which will be serialized in model.&lt;/p&gt; &#xA;&lt;p&gt;Open your model file and mount the uploader:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ApplicationRecord&#xA;  mount_uploaders :avatars, AvatarUploader&#xA;  serialize :avatars, JSON # If you use SQLite, add this line.&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure that you mount the uploader with write (mount_uploaders) with &lt;code&gt;s&lt;/code&gt; not (mount_uploader) in order to avoid errors when uploading multiple files&lt;/p&gt; &#xA;&lt;p&gt;Make sure your file input fields are set up as multiple file fields. For example in Rails you&#39;ll want to do something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;%= form.file_field :avatars, multiple: true %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, make sure your upload controller permits the multiple file upload attribute, &lt;em&gt;pointing to an empty array in a hash&lt;/em&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;params.require(:user).permit(:email, :first_name, :last_name, {avatars: []})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can select multiple files in the upload dialog (e.g. SHIFT+SELECT), and they will automatically be stored when the record is saved.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;u = User.new(params[:user])&#xA;u.save!&#xA;u.avatars[0].url # =&amp;gt; &#39;/url/to/file.png&#39;&#xA;u.avatars[0].current_path # =&amp;gt; &#39;path/to/file.png&#39;&#xA;u.avatars[0].identifier # =&amp;gt; &#39;file.png&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to preserve existing files on uploading new one, you can go like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;% user.avatars.each do |avatar| %&amp;gt;&#xA;  &amp;lt;%= hidden_field :user, :avatars, multiple: true, value: avatar.identifier %&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&amp;lt;%= form.file_field :avatars, multiple: true %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sorting avatars is supported as well by reordering &lt;code&gt;hidden_field&lt;/code&gt;, an example using jQuery UI Sortable is available &lt;a href=&#34;https://github.com/carrierwaveuploader/carrierwave/wiki/How-to%3A-Add%2C-remove-and-reorder-images-using-multiple-file-upload&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Changing the storage directory&lt;/h2&gt; &#xA;&lt;p&gt;In order to change where uploaded files are put, just override the &lt;code&gt;store_dir&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  def store_dir&#xA;    &#39;public/my/upload/directory&#39;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This works for the file storage as well as Amazon S3 and Rackspace Cloud Files. Define &lt;code&gt;store_dir&lt;/code&gt; as &lt;code&gt;nil&lt;/code&gt; if you&#39;d like to store files at the root level.&lt;/p&gt; &#xA;&lt;p&gt;If you store files outside the project root folder, you may want to define &lt;code&gt;cache_dir&lt;/code&gt; in the same way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  def cache_dir&#xA;    &#39;/tmp/projectname-cache&#39;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Securing uploads&lt;/h2&gt; &#xA;&lt;p&gt;Certain files might be dangerous if uploaded to the wrong location, such as PHP files or other script files. CarrierWave allows you to specify an allowlist of allowed extensions or content types.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re mounting the uploader, uploading a file with the wrong extension will make the record invalid instead. Otherwise, an error is raised.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  def extension_allowlist&#xA;    %w(jpg jpeg gif png)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The same thing could be done using content types. Let&#39;s say we need an uploader that accepts only images. This can be done like this&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  def content_type_allowlist&#xA;    /image\//&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use a denylist to reject content types. Let&#39;s say we need an uploader that reject JSON files. This can be done like this&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NoJsonUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  def content_type_denylist&#xA;    [&#39;application/text&#39;, &#39;application/json&#39;]&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CVE-2016-3714 (ImageTragick)&lt;/h3&gt; &#xA;&lt;p&gt;This version of CarrierWave has the ability to mitigate CVE-2016-3714. However, you &lt;strong&gt;MUST&lt;/strong&gt; set a content_type_allowlist in your uploaders for this protection to be effective, and you &lt;strong&gt;MUST&lt;/strong&gt; either disable ImageMagick&#39;s default SVG delegate or use the RSVG delegate for SVG processing.&lt;/p&gt; &#xA;&lt;p&gt;A valid allowlist that will restrict your uploader to images only, and mitigate the CVE is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  def content_type_allowlist&#xA;    [/image\//]&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: A &lt;code&gt;content_type_allowlist&lt;/code&gt; is the only form of allowlist or denylist supported by CarrierWave that can effectively mitigate against CVE-2016-3714. Use of &lt;code&gt;extension_allowlist&lt;/code&gt; will not inspect the file headers, and thus still leaves your application open to the vulnerability.&lt;/p&gt; &#xA;&lt;h3&gt;Filenames and unicode chars&lt;/h3&gt; &#xA;&lt;p&gt;Another security issue you should care for is the file names (see &lt;a href=&#34;http://guides.rubyonrails.org/security.html#file-uploads&#34;&gt;Ruby On Rails Security Guide&lt;/a&gt;). By default, CarrierWave provides only English letters, arabic numerals and some symbols as allowlisted characters in the file name. If you want to support local scripts (Cyrillic letters, letters with diacritics and so on), you have to override &lt;code&gt;sanitize_regexp&lt;/code&gt; method. It should return regular expression which would match all &lt;em&gt;non&lt;/em&gt;-allowed symbols.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CarrierWave::SanitizedFile.sanitize_regexp = /[^[:word:]\.\-\+]/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also make sure that allowing non-latin characters won&#39;t cause a compatibility issue with a third-party plugins or client-side software.&lt;/p&gt; &#xA;&lt;h2&gt;Setting the content type&lt;/h2&gt; &#xA;&lt;p&gt;As of v0.11.0, the &lt;code&gt;mime-types&lt;/code&gt; gem is a runtime dependency and the content type is set automatically. You no longer need to do this manually.&lt;/p&gt; &#xA;&lt;h2&gt;Adding versions&lt;/h2&gt; &#xA;&lt;p&gt;Often you&#39;ll want to add different versions of the same file. The classic example is image thumbnails. There is built in support for this*:&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; You must have Imagemagick installed to do image resizing.&lt;/p&gt; &#xA;&lt;p&gt;Some documentation refers to RMagick instead of MiniMagick but MiniMagick is recommended.&lt;/p&gt; &#xA;&lt;p&gt;To install Imagemagick on OSX with homebrew type the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ brew install imagemagick&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  include CarrierWave::MiniMagick&#xA;&#xA;  process resize_to_fit: [800, 800]&#xA;&#xA;  version :thumb do&#xA;    process resize_to_fill: [200,200]&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When this uploader is used, an uploaded image would be scaled to be no larger than 800 by 800 pixels. The original aspect ratio will be kept.&lt;/p&gt; &#xA;&lt;p&gt;A version called &lt;code&gt;:thumb&lt;/code&gt; is then created, which is scaled to exactly 200 by 200 pixels. The thumbnail uses &lt;code&gt;resize_to_fill&lt;/code&gt; which makes sure that the width and height specified are filled, only cropping if the aspect ratio requires it.&lt;/p&gt; &#xA;&lt;p&gt;The above uploader could be used like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;uploader = AvatarUploader.new&#xA;uploader.store!(my_file)                              # size: 1024x768&#xA;&#xA;uploader.url # =&amp;gt; &#39;/url/to/my_file.png&#39;               # size: 800x800&#xA;uploader.thumb.url # =&amp;gt; &#39;/url/to/thumb_my_file.png&#39;   # size: 200x200&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One important thing to remember is that process is called &lt;em&gt;before&lt;/em&gt; versions are created. This can cut down on processing cost.&lt;/p&gt; &#xA;&lt;h3&gt;Processing Methods: mini_magick&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;convert&lt;/code&gt; - Changes the image encoding format to the given format, eg. jpg&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;resize_to_limit&lt;/code&gt; - Resize the image to fit within the specified dimensions while retaining the original aspect ratio. Will only resize the image if it is larger than the specified dimensions. The resulting image may be shorter or narrower than specified in the smaller dimension but will not be larger than the specified values.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;resize_to_fit&lt;/code&gt; - Resize the image to fit within the specified dimensions while retaining the original aspect ratio. The image may be shorter or narrower than specified in the smaller dimension but will not be larger than the specified values.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;resize_to_fill&lt;/code&gt; - Resize the image to fit within the specified dimensions while retaining the aspect ratio of the original image. If necessary, crop the image in the larger dimension. Optionally, a &#34;gravity&#34; may be specified, for example &#34;Center&#34;, or &#34;NorthEast&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;resize_and_pad&lt;/code&gt; - Resize the image to fit within the specified dimensions while retaining the original aspect ratio. If necessary, will pad the remaining area with the given color, which defaults to transparent (for gif and png, white for jpeg). Optionally, a &#34;gravity&#34; may be specified, as above.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;code&gt;carrierwave/processing/mini_magick.rb&lt;/code&gt; for details.&lt;/p&gt; &#xA;&lt;h3&gt;conditional process&lt;/h3&gt; &#xA;&lt;p&gt;If you want to use conditional process, you can only use &lt;code&gt;if&lt;/code&gt; statement.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;code&gt;carrierwave/uploader/processing.rb&lt;/code&gt; for details.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  process :scale =&amp;gt; [200, 200], :if =&amp;gt; :image?&#xA;  &#xA;  def image?(carrier_wave_sanitized_file)&#xA;    true&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Nested versions&lt;/h3&gt; &#xA;&lt;p&gt;It is possible to nest versions within versions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; CarrierWave::Uploader::Base&#xA;&#xA;  version :animal do&#xA;    version :human&#xA;    version :monkey&#xA;    version :llama&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Conditional versions&lt;/h3&gt; &#xA;&lt;p&gt;Occasionally you want to restrict the creation of versions on certain properties within the model or based on the picture itself.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; CarrierWave::Uploader::Base&#xA;&#xA;  version :human, if: :is_human?&#xA;  version :monkey, if: :is_monkey?&#xA;  version :banner, if: :is_landscape?&#xA;&#xA;private&#xA;&#xA;  def is_human? picture&#xA;    model.can_program?(:ruby)&#xA;  end&#xA;&#xA;  def is_monkey? picture&#xA;    model.favorite_food == &#39;banana&#39;&#xA;  end&#xA;&#xA;  def is_landscape? picture&#xA;    image = MiniMagick::Image.new(picture.path)&#xA;    image[:width] &amp;gt; image[:height]&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;model&lt;/code&gt; variable points to the instance object the uploader is attached to.&lt;/p&gt; &#xA;&lt;h3&gt;Create versions from existing versions&lt;/h3&gt; &#xA;&lt;p&gt;For performance reasons, it is often useful to create versions from existing ones instead of using the original file. If your uploader generates several versions where the next is smaller than the last, it will take less time to generate from a smaller, already processed image.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; CarrierWave::Uploader::Base&#xA;&#xA;  version :thumb do&#xA;    process resize_to_fill: [280, 280]&#xA;  end&#xA;&#xA;  version :small_thumb, from_version: :thumb do&#xA;    process resize_to_fill: [20, 20]&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The option &lt;code&gt;:from_version&lt;/code&gt; uses the file cached in the &lt;code&gt;:thumb&lt;/code&gt; version instead of the original version, potentially resulting in faster processing.&lt;/p&gt; &#xA;&lt;h2&gt;Making uploads work across form redisplays&lt;/h2&gt; &#xA;&lt;p&gt;Often you&#39;ll notice that uploaded files disappear when a validation fails. CarrierWave has a feature that makes it easy to remember the uploaded file even in that case. Suppose your &lt;code&gt;user&lt;/code&gt; model has an uploader mounted on &lt;code&gt;avatar&lt;/code&gt; file, just add a hidden field called &lt;code&gt;avatar_cache&lt;/code&gt; (don&#39;t forget to add it to the attr_accessible list as necessary). In Rails, this would look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;%= form_for @user, html: { multipart: true } do |f| %&amp;gt;&#xA;  &amp;lt;p&amp;gt;&#xA;    &amp;lt;label&amp;gt;My Avatar&amp;lt;/label&amp;gt;&#xA;    &amp;lt;%= f.file_field :avatar %&amp;gt;&#xA;    &amp;lt;%= f.hidden_field :avatar_cache %&amp;gt;&#xA;  &amp;lt;/p&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It might be a good idea to show the user that a file has been uploaded, in the case of images, a small thumbnail would be a good indicator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;%= form_for @user, html: { multipart: true } do |f| %&amp;gt;&#xA;  &amp;lt;p&amp;gt;&#xA;    &amp;lt;label&amp;gt;My Avatar&amp;lt;/label&amp;gt;&#xA;    &amp;lt;%= image_tag(@user.avatar_url) if @user.avatar? %&amp;gt;&#xA;    &amp;lt;%= f.file_field :avatar %&amp;gt;&#xA;    &amp;lt;%= f.hidden_field :avatar_cache %&amp;gt;&#xA;  &amp;lt;/p&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Removing uploaded files&lt;/h2&gt; &#xA;&lt;p&gt;If you want to remove a previously uploaded file on a mounted uploader, you can easily add a checkbox to the form which will remove the file when checked.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;%= form_for @user, html: { multipart: true } do |f| %&amp;gt;&#xA;  &amp;lt;p&amp;gt;&#xA;    &amp;lt;label&amp;gt;My Avatar&amp;lt;/label&amp;gt;&#xA;    &amp;lt;%= image_tag(@user.avatar_url) if @user.avatar? %&amp;gt;&#xA;    &amp;lt;%= f.file_field :avatar %&amp;gt;&#xA;  &amp;lt;/p&amp;gt;&#xA;&#xA;  &amp;lt;p&amp;gt;&#xA;    &amp;lt;label&amp;gt;&#xA;      &amp;lt;%= f.check_box :remove_avatar %&amp;gt;&#xA;      Remove avatar&#xA;    &amp;lt;/label&amp;gt;&#xA;  &amp;lt;/p&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to remove the file manually, you can call &lt;code&gt;remove_avatar!&lt;/code&gt;, then save the object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;@user.remove_avatar!&#xA;@user.save&#xA;#=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Uploading files from a remote location&lt;/h2&gt; &#xA;&lt;p&gt;Your users may find it convenient to upload a file from a location on the Internet via a URL. CarrierWave makes this simple, just add the appropriate attribute to your form and you&#39;re good to go:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;%= form_for @user, html: { multipart: true } do |f| %&amp;gt;&#xA;  &amp;lt;p&amp;gt;&#xA;    &amp;lt;label&amp;gt;My Avatar URL:&amp;lt;/label&amp;gt;&#xA;    &amp;lt;%= image_tag(@user.avatar_url) if @user.avatar? %&amp;gt;&#xA;    &amp;lt;%= f.text_field :remote_avatar_url %&amp;gt;&#xA;  &amp;lt;/p&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;re using ActiveRecord, CarrierWave will indicate invalid URLs and download failures automatically with attribute validation errors. If you aren&#39;t, or you disable CarrierWave&#39;s &lt;code&gt;validate_download&lt;/code&gt; option, you&#39;ll need to handle those errors yourself.&lt;/p&gt; &#xA;&lt;h3&gt;Retry option for download from remote location&lt;/h3&gt; &#xA;&lt;p&gt;If you want to retry the download from the Remote URL, enable the download_retry_count option, an error occurs during download, it will try to execute the specified number of times every 5 second. This option is effective when the remote destination is unstable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;CarrierWave.configure do |config|&#xA;  config.download_retry_count = 3 # Default 0&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Providing a default URL&lt;/h2&gt; &#xA;&lt;p&gt;In many cases, especially when working with images, it might be a good idea to provide a default url, a fallback in case no file has been uploaded. You can do this easily by overriding the &lt;code&gt;default_url&lt;/code&gt; method in your uploader:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  def default_url(*args)&#xA;    &#34;/images/fallback/&#34; + [version_name, &#34;default.png&#34;].compact.join(&#39;_&#39;)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or if you are using the Rails asset pipeline:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  def default_url(*args)&#xA;    ActionController::Base.helpers.asset_path(&#34;fallback/&#34; + [version_name, &#34;default.png&#34;].compact.join(&#39;_&#39;))&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Recreating versions&lt;/h2&gt; &#xA;&lt;p&gt;You might come to a situation where you want to retroactively change a version or add a new one. You can use the &lt;code&gt;recreate_versions!&lt;/code&gt; method to recreate the versions from the base file. This uses a naive approach which will re-upload and process the specified version or all versions, if none is passed as an argument.&lt;/p&gt; &#xA;&lt;p&gt;When you are generating random unique filenames you have to call &lt;code&gt;save!&lt;/code&gt; on the model after using &lt;code&gt;recreate_versions!&lt;/code&gt;. This is necessary because &lt;code&gt;recreate_versions!&lt;/code&gt; doesn&#39;t save the new filename to the database. Calling &lt;code&gt;save!&lt;/code&gt; yourself will prevent that the database and file system are running out of sync.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;instance = MyUploader.new&#xA;instance.recreate_versions!(:thumb, :large)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or on a mounted uploader:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;User.find_each do |user|&#xA;  user.avatar.recreate_versions!&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: &lt;code&gt;recreate_versions!&lt;/code&gt; will throw an exception on records without an image. To avoid this, scope the records to those with images or check if an image exists within the block. If you&#39;re using ActiveRecord, recreating versions for a user avatar might look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;User.find_each do |user|&#xA;  user.avatar.recreate_versions! if user.avatar?&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuring CarrierWave&lt;/h2&gt; &#xA;&lt;p&gt;CarrierWave has a broad range of configuration options, which you can configure, both globally and on a per-uploader basis:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CarrierWave.configure do |config|&#xA;  config.permissions = 0666&#xA;  config.directory_permissions = 0777&#xA;  config.storage = :file&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or alternatively:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AvatarUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  permissions 0777&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;re using Rails, create an initializer for this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;config/initializers/carrierwave.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want CarrierWave to fail noisily in development, you can change these configs in your environment file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CarrierWave.configure do |config|&#xA;  config.ignore_integrity_errors = false&#xA;  config.ignore_processing_errors = false&#xA;  config.ignore_download_errors = false&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing with CarrierWave&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s a good idea to test your uploaders in isolation. In order to speed up your tests, it&#39;s recommended to switch off processing in your tests, and to use the file storage. In Rails you could do that by adding an initializer with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if Rails.env.test? or Rails.env.cucumber?&#xA;  CarrierWave.configure do |config|&#xA;    config.storage = :file&#xA;    config.enable_processing = false&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Remember, if you have already set &lt;code&gt;storage :something&lt;/code&gt; in your uploader, the &lt;code&gt;storage&lt;/code&gt; setting from this initializer will be ignored.&lt;/p&gt; &#xA;&lt;p&gt;If you need to test your processing, you should test it in isolation, and enable processing only for those tests that need it.&lt;/p&gt; &#xA;&lt;p&gt;CarrierWave comes with some RSpec matchers which you may find useful:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;carrierwave/test/matchers&#39;&#xA;&#xA;describe MyUploader do&#xA;  include CarrierWave::Test::Matchers&#xA;&#xA;  let(:user) { double(&#39;user&#39;) }&#xA;  let(:uploader) { MyUploader.new(user, :avatar) }&#xA;&#xA;  before do&#xA;    MyUploader.enable_processing = true&#xA;    File.open(path_to_file) { |f| uploader.store!(f) }&#xA;  end&#xA;&#xA;  after do&#xA;    MyUploader.enable_processing = false&#xA;    uploader.remove!&#xA;  end&#xA;&#xA;  context &#39;the thumb version&#39; do&#xA;    it &#34;scales down a landscape image to be exactly 64 by 64 pixels&#34; do&#xA;      expect(uploader.thumb).to have_dimensions(64, 64)&#xA;    end&#xA;  end&#xA;&#xA;  context &#39;the small version&#39; do&#xA;    it &#34;scales down a landscape image to fit within 200 by 200 pixels&#34; do&#xA;      expect(uploader.small).to be_no_larger_than(200, 200)&#xA;    end&#xA;  end&#xA;&#xA;  it &#34;makes the image readable only to the owner and not executable&#34; do&#xA;    expect(uploader).to have_permissions(0600)&#xA;  end&#xA;&#xA;  it &#34;has the correct format&#34; do&#xA;    expect(uploader).to be_format(&#39;png&#39;)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;re looking for minitest asserts, checkout &lt;a href=&#34;https://github.com/hcfairbanks/carrierwave_asserts&#34;&gt;carrierwave_asserts&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Setting the enable_processing flag on an uploader will prevent any of the versions from processing as well. Processing can be enabled for a single version by setting the processing flag on the version like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@uploader.thumb.enable_processing = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Fog&lt;/h2&gt; &#xA;&lt;p&gt;If you want to use fog you must add in your CarrierWave initializer the following lines&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.fog_credentials = { ... } # Provider specific credentials&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using Amazon S3&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://github.com/fog/fog-aws&#34;&gt;Fog AWS&lt;/a&gt; is used to support Amazon S3. Ensure you have it in your Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;fog-aws&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll need to provide your fog_credentials and a fog_directory (also known as a bucket) in an initializer. For the sake of performance it is assumed that the directory already exists, so please create it if it needs to be. You can also pass in additional options, as documented fully in lib/carrierwave/storage/fog.rb. Here&#39;s a full example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CarrierWave.configure do |config|&#xA;  config.fog_credentials = {&#xA;    provider:              &#39;AWS&#39;,                        # required&#xA;    aws_access_key_id:     &#39;xxx&#39;,                        # required unless using use_iam_profile&#xA;    aws_secret_access_key: &#39;yyy&#39;,                        # required unless using use_iam_profile&#xA;    use_iam_profile:       true,                         # optional, defaults to false&#xA;    region:                &#39;eu-west-1&#39;,                  # optional, defaults to &#39;us-east-1&#39;&#xA;    host:                  &#39;s3.example.com&#39;,             # optional, defaults to nil&#xA;    endpoint:              &#39;https://s3.example.com:8080&#39; # optional, defaults to nil&#xA;  }&#xA;  config.fog_directory  = &#39;name_of_bucket&#39;                                      # required&#xA;  config.fog_public     = false                                                 # optional, defaults to true&#xA;  config.fog_attributes = { cache_control: &#34;public, max-age=#{365.days.to_i}&#34; } # optional, defaults to {}&#xA;  # For an application which utilizes multiple servers but does not need caches persisted across requests,&#xA;  # uncomment the line :file instead of the default :storage.  Otherwise, it will use AWS as the temp cache store.&#xA;  # config.cache_storage = :file&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In your uploader, set the storage to :fog&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AvatarUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  storage :fog&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it! You can still use the &lt;code&gt;CarrierWave::Uploader#url&lt;/code&gt; method to return the url to the file on Amazon S3.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: for Carrierwave to work properly it needs credentials with the following permissions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;s3:ListBucket&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s3:PutObject&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s3:GetObject&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s3:DeleteObject&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s3:PutObjectAcl&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Using Rackspace Cloud Files&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://github.com/fog/fog&#34;&gt;Fog&lt;/a&gt; is used to support Rackspace Cloud Files. Ensure you have it in your Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;fog&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll need to configure a directory (also known as a container), username and API key in the initializer. For the sake of performance it is assumed that the directory already exists, so please create it if need be.&lt;/p&gt; &#xA;&lt;p&gt;Using a US-based account:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CarrierWave.configure do |config|&#xA;  config.fog_credentials = {&#xA;    provider:           &#39;Rackspace&#39;,&#xA;    rackspace_username: &#39;xxxxxx&#39;,&#xA;    rackspace_api_key:  &#39;yyyyyy&#39;,&#xA;    rackspace_region:   :ord                      # optional, defaults to :dfw&#xA;  }&#xA;  config.fog_directory = &#39;name_of_directory&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using a UK-based account:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CarrierWave.configure do |config|&#xA;  config.fog_credentials = {&#xA;    provider:           &#39;Rackspace&#39;,&#xA;    rackspace_username: &#39;xxxxxx&#39;,&#xA;    rackspace_api_key:  &#39;yyyyyy&#39;,&#xA;    rackspace_auth_url: Fog::Rackspace::UK_AUTH_ENDPOINT,&#xA;    rackspace_region:   :lon&#xA;  }&#xA;  config.fog_directory = &#39;name_of_directory&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can optionally include your CDN host name in the configuration. This is &lt;em&gt;highly&lt;/em&gt; recommended, as without it every request requires a lookup of this information.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.asset_host = &#34;http://c000000.cdn.rackspacecloud.com&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In your uploader, set the storage to :fog&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AvatarUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  storage :fog&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it! You can still use the &lt;code&gt;CarrierWave::Uploader#url&lt;/code&gt; method to return the url to the file on Rackspace Cloud Files.&lt;/p&gt; &#xA;&lt;h2&gt;Using Google Cloud Storage&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://github.com/fog/fog-google&#34;&gt;Fog&lt;/a&gt; is used to support Google Cloud Storage. Ensure you have it in your Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;fog-google&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll need to configure a directory (also known as a bucket) and the credentials in the initializer. For the sake of performance it is assumed that the directory already exists, so please create it if need be.&lt;/p&gt; &#xA;&lt;p&gt;Please read the &lt;a href=&#34;https://github.com/fog/fog-google/raw/master/README.md&#34;&gt;fog-google README&lt;/a&gt; on how to get credentials.&lt;/p&gt; &#xA;&lt;p&gt;For Google Storage JSON API (recommended):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CarrierWave.configure do |config|&#xA;    config.fog_provider = &#39;fog/google&#39;&#xA;    config.fog_credentials = {&#xA;        provider:               &#39;Google&#39;,&#xA;        google_project:         &#39;my-project&#39;,&#xA;        google_json_key_string: &#39;xxxxxx&#39;&#xA;        # or use google_json_key_location if using an actual file&#xA;    }&#xA;    config.fog_directory = &#39;google_cloud_storage_bucket_name&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Google Storage XML API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CarrierWave.configure do |config|&#xA;    config.fog_provider = &#39;fog/google&#39;&#xA;    config.fog_credentials = {&#xA;        provider:                         &#39;Google&#39;,&#xA;        google_storage_access_key_id:     &#39;xxxxxx&#39;,&#xA;        google_storage_secret_access_key: &#39;yyyyyy&#39;&#xA;    }&#xA;    config.fog_directory = &#39;google_cloud_storage_bucket_name&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In your uploader, set the storage to :fog&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AvatarUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  storage :fog&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it! You can still use the &lt;code&gt;CarrierWave::Uploader#url&lt;/code&gt; method to return the url to the file on Google.&lt;/p&gt; &#xA;&lt;h2&gt;Optimized Loading of Fog&lt;/h2&gt; &#xA;&lt;p&gt;Since Carrierwave doesn&#39;t know which parts of Fog you intend to use, it will just load the entire library (unless you use e.g. [&lt;code&gt;fog-aws&lt;/code&gt;, &lt;code&gt;fog-google&lt;/code&gt;] instead of fog proper). If you prefer to load fewer classes into your application, you need to load those parts of Fog yourself &lt;em&gt;before&lt;/em&gt; loading CarrierWave in your Gemfile. Ex:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;fog&#34;, &#34;~&amp;gt; 1.27&#34;, require: &#34;fog/rackspace/storage&#34;&#xA;gem &#34;carrierwave&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A couple of notes about versions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This functionality was introduced in Fog v1.20.&lt;/li&gt; &#xA; &lt;li&gt;This functionality is slated for CarrierWave v1.0.0.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you&#39;re not relying on Gemfile entries alone and are requiring &#34;carrierwave&#34; anywhere, ensure you require &#34;fog/rackspace/storage&#34; before it. Ex:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;fog/rackspace/storage&#34;&#xA;require &#34;carrierwave&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Beware that this specific require is only needed when working with a fog provider that was not extracted to its own gem yet. A list of the extracted providers can be found in the page of the &lt;code&gt;fog&lt;/code&gt; organizations &lt;a href=&#34;https://github.com/fog&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When in doubt, inspect &lt;code&gt;Fog.constants&lt;/code&gt; to see what has been loaded.&lt;/p&gt; &#xA;&lt;h2&gt;Dynamic Asset Host&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;asset_host&lt;/code&gt; config property can be assigned a proc (or anything that responds to &lt;code&gt;call&lt;/code&gt;) for generating the host dynamically. The proc-compliant object gets an instance of the current &lt;code&gt;CarrierWave::Storage::Fog::File&lt;/code&gt; or &lt;code&gt;CarrierWave::SanitizedFile&lt;/code&gt; as its only argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;CarrierWave.configure do |config|&#xA;  config.asset_host = proc do |file|&#xA;    identifier = # some logic&#xA;    &#34;http://#{identifier}.cdn.rackspacecloud.com&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using RMagick&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re uploading images, you&#39;ll probably want to manipulate them in some way, you might want to create thumbnail images for example. CarrierWave comes with a small library to make manipulating images with RMagick easier, you&#39;ll need to include it in your Uploader:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AvatarUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  include CarrierWave::RMagick&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The RMagick module gives you a few methods, like &lt;code&gt;CarrierWave::RMagick#resize_to_fill&lt;/code&gt; which manipulate the image file in some way. You can set a &lt;code&gt;process&lt;/code&gt; callback, which will call that method any time a file is uploaded. There is a demonstration of convert here. Convert will only work if the file has the same file extension, thus the use of the filename method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AvatarUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  include CarrierWave::RMagick&#xA;&#xA;  process resize_to_fill: [200, 200]&#xA;  process convert: &#39;png&#39;&#xA;&#xA;  def filename&#xA;    super.chomp(File.extname(super)) + &#39;.png&#39; if original_filename.present?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check out the manipulate! method, which makes it easy for you to write your own manipulation methods.&lt;/p&gt; &#xA;&lt;h2&gt;Using MiniMagick&lt;/h2&gt; &#xA;&lt;p&gt;MiniMagick is similar to RMagick but performs all the operations using the &#39;convert&#39; CLI which is part of the standard ImageMagick kit. This allows you to have the power of ImageMagick without having to worry about installing all the RMagick libraries.&lt;/p&gt; &#xA;&lt;p&gt;See the MiniMagick site for more details:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/minimagick/minimagick&#34;&gt;https://github.com/minimagick/minimagick&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;And the ImageMagick command line options for more for what&#39;s on offer:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.imagemagick.org/script/command-line-options.php&#34;&gt;http://www.imagemagick.org/script/command-line-options.php&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Currently, the MiniMagick carrierwave processor provides exactly the same methods as for the RMagick processor.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AvatarUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  include CarrierWave::MiniMagick&#xA;&#xA;  process resize_to_fill: [200, 200]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Migrating from Paperclip&lt;/h2&gt; &#xA;&lt;p&gt;If you are using Paperclip, you can use the provided compatibility module:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AvatarUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  include CarrierWave::Compatibility::Paperclip&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the documentation for &lt;code&gt;CarrierWave::Compatibility::Paperclip&lt;/code&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;Be sure to use mount_on to specify the correct column:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;mount_uploader :avatar, AvatarUploader, mount_on: :avatar_file_name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;I18n&lt;/h2&gt; &#xA;&lt;p&gt;The Active Record validations use the Rails &lt;code&gt;i18n&lt;/code&gt; framework. Add these keys to your translations file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;errors:&#xA;  messages:&#xA;    carrierwave_processing_error: failed to be processed&#xA;    carrierwave_integrity_error: is not of an allowed file type&#xA;    carrierwave_download_error: could not be downloaded&#xA;    extension_allowlist_error: &#34;You are not allowed to upload %{extension} files, allowed types: %{allowed_types}&#34;&#xA;    extension_denylist_error: &#34;You are not allowed to upload %{extension} files, prohibited types: %{prohibited_types}&#34;&#xA;    content_type_allowlist_error: &#34;You are not allowed to upload %{content_type} files, allowed types: %{allowed_types}&#34;&#xA;    content_type_denylist_error: &#34;You are not allowed to upload %{content_type} files&#34;&#xA;    processing_error: &#34;Failed to manipulate, maybe it is not an image?&#34;&#xA;    min_size_error: &#34;File size should be greater than %{min_size}&#34;&#xA;    max_size_error: &#34;File size should be less than %{max_size}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/carrierwaveuploader/carrierwave-i18n&#34;&gt;&lt;code&gt;carrierwave-i18n&lt;/code&gt;&lt;/a&gt; library adds support for additional locales.&lt;/p&gt; &#xA;&lt;h2&gt;Large files&lt;/h2&gt; &#xA;&lt;p&gt;By default, CarrierWave copies an uploaded file twice, first copying the file into the cache, then copying the file into the store. For large files, this can be prohibitively time consuming.&lt;/p&gt; &#xA;&lt;p&gt;You may change this behavior by overriding either or both of the &lt;code&gt;move_to_cache&lt;/code&gt; and &lt;code&gt;move_to_store&lt;/code&gt; methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; CarrierWave::Uploader::Base&#xA;  def move_to_cache&#xA;    true&#xA;  end&#xA;&#xA;  def move_to_store&#xA;    true&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When the &lt;code&gt;move_to_cache&lt;/code&gt; and/or &lt;code&gt;move_to_store&lt;/code&gt; methods return true, files will be moved (instead of copied) to the cache and store respectively.&lt;/p&gt; &#xA;&lt;p&gt;This has only been tested with the local filesystem store.&lt;/p&gt; &#xA;&lt;h2&gt;Skipping ActiveRecord callbacks&lt;/h2&gt; &#xA;&lt;p&gt;By default, mounting an uploader into an ActiveRecord model will add a few callbacks. For example, this code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User&#xA;  mount_uploader :avatar, AvatarUploader&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will add these callbacks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;before_save :write_avatar_identifier&#xA;after_save :store_previous_changes_for_avatar&#xA;after_commit :remove_avatar!, on: :destroy&#xA;after_commit :mark_remove_avatar_false, on: :update&#xA;after_commit :remove_previously_stored_avatar, on: :update&#xA;after_commit :store_avatar!, on: [:create, :update]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to skip any of these callbacks (eg. you want to keep the existing avatar, even after uploading a new one), you can use ActiveRecord’s &lt;code&gt;skip_callback&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User&#xA;  mount_uploader :avatar, AvatarUploader&#xA;  skip_callback :commit, :after, :remove_previously_stored_avatar&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Uploader Callbacks&lt;/h2&gt; &#xA;&lt;p&gt;In addition to the ActiveRecord callbacks described above, uploaders also have callbacks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyUploader &amp;lt; ::CarrierWave::Uploader::Base&#xA;  before :remove, :log_removal&#xA;  private&#xA;  def log_removal&#xA;    ::Rails.logger.info(format(&#39;Deleting file on S3: %s&#39;, @file))&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Uploader callbacks can be &lt;code&gt;before&lt;/code&gt; or &lt;code&gt;after&lt;/code&gt; the following events:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cache&#xA;process&#xA;remove&#xA;retrieve_from_cache&#xA;store&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing to CarrierWave&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/carrierwaveuploader/carrierwave/raw/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The MIT License (MIT)&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2008-2015 Jonas Nicklas&lt;/p&gt; &#xA;&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &#34;Software&#34;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:&lt;/p&gt; &#xA;&lt;p&gt;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&lt;/p&gt; &#xA;&lt;p&gt;THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&lt;/p&gt;</summary>
  </entry>
</feed>