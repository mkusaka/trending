<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-09T01:43:33Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Shopify/maintenance_tasks</title>
    <updated>2023-08-09T01:43:33Z</updated>
    <id>tag:github.com,2023-08-09:/Shopify/maintenance_tasks</id>
    <link href="https://github.com/Shopify/maintenance_tasks" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Rails engine for queueing and managing data migrations.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MaintenanceTasks&lt;/h1&gt; &#xA;&lt;p&gt;A Rails engine for queuing and managing maintenance tasks.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=BTuvTQxlFzs&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Shopify/maintenance_tasks/main/static/demo.png&#34; alt=&#34;Link to demo video&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;To install the gem and run the install generator, execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;bundle add maintenance_tasks&#xA;bin/rails generate maintenance_tasks:install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The generator creates and runs a migration to add the necessary table to your database. It also mounts Maintenance Tasks in your &lt;code&gt;config/routes.rb&lt;/code&gt;. By default the web UI can be accessed in the new &lt;code&gt;/maintenance_tasks&lt;/code&gt; path.&lt;/p&gt; &#xA;&lt;p&gt;In case you use an exception reporting service (e.g. Bugsnag) you might want to define an error handler. See &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/maintenance_tasks/main/#customizing-the-error-handler&#34;&gt;Customizing the error handler&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h3&gt;Active Job Dependency&lt;/h3&gt; &#xA;&lt;p&gt;The Maintenance Tasks framework relies on Active Job behind the scenes to run Tasks. The default queuing backend for Active Job is &lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveJob/QueueAdapters/AsyncAdapter.html&#34;&gt;asynchronous&lt;/a&gt;. It is &lt;strong&gt;strongly recommended&lt;/strong&gt; to change this to a persistent backend so that Task progress is not lost during code or infrastructure changes. For more information on configuring a queuing backend, take a look at the &lt;a href=&#34;https://guides.rubyonrails.org/active_job_basics.html#setting-the-backend&#34;&gt;Active Job documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Autoloading&lt;/h3&gt; &#xA;&lt;p&gt;The Maintenance Tasks framework does not support autoloading in &lt;code&gt;:classic&lt;/code&gt; mode. Please ensure your application is using &lt;a href=&#34;https://github.com/fxn/zeitwerk&#34;&gt;Zeitwerk&lt;/a&gt; to load your code. For more information, please consult the &lt;a href=&#34;https://guides.rubyonrails.org/autoloading_and_reloading_constants.html&#34;&gt;Rails guides on autoloading and reloading constants&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The typical Maintenance Tasks workflow is as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/maintenance_tasks/main/#creating-a-task&#34;&gt;Generate a class describing the Task&lt;/a&gt; and the work to be done.&lt;/li&gt; &#xA; &lt;li&gt;Run the Task &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;either by &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/maintenance_tasks/main/#running-a-task-from-the-web-ui&#34;&gt;using the included web UI&lt;/a&gt;,&lt;/li&gt; &#xA;   &lt;li&gt;or by &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/maintenance_tasks/main/#running-a-task-from-the-command-line&#34;&gt;using the command line&lt;/a&gt;,&lt;/li&gt; &#xA;   &lt;li&gt;or by &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/maintenance_tasks/main/#running-a-task-from-ruby&#34;&gt;using Ruby&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/maintenance_tasks/main/#monitoring-your-tasks-status&#34;&gt;Monitor the Task&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;either by using the included web UI,&lt;/li&gt; &#xA;   &lt;li&gt;or by manually checking your task’s run’s status in your database.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Optionally, delete the Task code if you no longer need it.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Creating a Task&lt;/h3&gt; &#xA;&lt;p&gt;A generator is provided to create tasks. Generate a new task by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;bin/rails generate maintenance_tasks:task update_posts&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This creates the task file &lt;code&gt;app/tasks/maintenance/update_posts_task.rb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The generated task is a subclass of &lt;code&gt;MaintenanceTasks::Task&lt;/code&gt; that implements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;collection&lt;/code&gt;: return an Active Record Relation or an Array to be iterated over.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;process&lt;/code&gt;: do the work of your maintenance task on a single record&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Optionally, tasks can also implement a custom &lt;code&gt;#count&lt;/code&gt; method, defining the number of elements that will be iterated over. Your task’s &lt;code&gt;tick_total&lt;/code&gt; will be calculated automatically based on the collection size, but this value may be overridden if desired using the &lt;code&gt;#count&lt;/code&gt; method (this might be done, for example, to avoid the query that would be produced to determine the size of your collection).&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/tasks/maintenance/update_posts_task.rb&#xA;&#xA;module Maintenance&#xA;  class UpdatePostsTask &amp;lt; MaintenanceTasks::Task&#xA;    def collection&#xA;      Post.all&#xA;    end&#xA;&#xA;    def process(post)&#xA;      post.update!(content: &#34;New content!&#34;)&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creating a CSV Task&lt;/h3&gt; &#xA;&lt;p&gt;You can also write a Task that iterates on a CSV file. Note that writing CSV Tasks &lt;strong&gt;requires Active Storage to be configured&lt;/strong&gt;. Ensure that the dependency is specified in your application’s Gemfile, and that you’ve followed the &lt;a href=&#34;https://edgeguides.rubyonrails.org/active_storage_overview.html#setup&#34;&gt;setup instructions&lt;/a&gt;. See also &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/maintenance_tasks/main/#customizing-which-active-storage-service-to-use&#34;&gt;Customizing which Active Storage service to use&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Generate a CSV Task by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;bin/rails generate maintenance_tasks:task import_posts --csv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The generated task is a subclass of &lt;code&gt;MaintenanceTasks::Task&lt;/code&gt; that implements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;process&lt;/code&gt;: do the work of your maintenance task on a &lt;code&gt;CSV::Row&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/tasks/maintenance/import_posts_task.rb&#xA;&#xA;module Maintenance&#xA;  class ImportPostsTask &amp;lt; MaintenanceTasks::Task&#xA;    csv_collection&#xA;&#xA;    def process(row)&#xA;      Post.create!(title: row[&#34;title&#34;], content: row[&#34;content&#34;])&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csv&#34;&gt;# posts.csv&#xA;title,content&#xA;My Title,Hello World!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The files uploaded to your Active Storage service provider will be renamed to include an ISO 8601 timestamp and the Task name in snake case format. The CSV is expected to have a trailing newline at the end of the file.&lt;/p&gt; &#xA;&lt;h4&gt;Batch CSV Tasks&lt;/h4&gt; &#xA;&lt;p&gt;Tasks can process CSVs in batches. Add the &lt;code&gt;in_batches&lt;/code&gt; option to your task’s &lt;code&gt;csv_collection&lt;/code&gt; macro:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/tasks/maintenance/batch_import_posts_task.rb&#xA;&#xA;module Maintenance&#xA;  class BatchImportPostsTask &amp;lt; MaintenanceTasks::Task&#xA;    csv_collection(in_batches: 50)&#xA;&#xA;    def process(batch_of_rows)&#xA;      Post.insert_all(post_rows.map(&amp;amp;:to_h))&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with a regular CSV task, ensure you’ve implemented the following method:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;process&lt;/code&gt;: do the work of your Task on a batch (array of &lt;code&gt;CSV::Row&lt;/code&gt; objects).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;#count&lt;/code&gt; is calculated automatically based on the number of batches in your collection, and your Task’s progress will be displayed in terms of batches (not the total number of rows in your CSV).&lt;/p&gt; &#xA;&lt;h3&gt;Processing Batch Collections&lt;/h3&gt; &#xA;&lt;p&gt;The Maintenance Tasks gem supports processing Active Records in batches. This can reduce the number of calls your Task makes to the database. Use &lt;code&gt;ActiveRecord::Batches#in_batches&lt;/code&gt; on the relation returned by your collection to specify that your Task should process batches instead of records. Active Record defaults to 1000 records by batch, but a custom size can be specified.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/tasks/maintenance/update_posts_in_batches_task.rb&#xA;&#xA;module Maintenance&#xA;  class UpdatePostsInBatchesTask &amp;lt; MaintenanceTasks::Task&#xA;    def collection&#xA;      Post.in_batches&#xA;    end&#xA;&#xA;    def process(batch_of_posts)&#xA;      batch_of_posts.update_all(content: &#34;New content added on #{Time.now.utc}&#34;)&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Ensure that you’ve implemented the following methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;collection&lt;/code&gt;: return an &lt;code&gt;ActiveRecord::Batches::BatchEnumerator&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;process&lt;/code&gt;: do the work of your Task on a batch (&lt;code&gt;ActiveRecord::Relation&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;#count&lt;/code&gt; is calculated automatically based on the number of batches in your collection, and your Task’s progress will be displayed in terms of batches (not the number of records in the relation).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important!&lt;/strong&gt; Batches should only be used if &lt;code&gt;#process&lt;/code&gt; is performing a batch operation such as &lt;code&gt;#update_all&lt;/code&gt; or &lt;code&gt;#delete_all&lt;/code&gt;. If you need to iterate over individual records, you should define a collection that &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/maintenance_tasks/main/#creating-a-task&#34;&gt;returns an &lt;code&gt;ActiveRecord::Relation&lt;/code&gt;&lt;/a&gt;. This uses batching internally, but loads the records with one SQL query. Conversely, batch collections load the primary keys of the records of the batch first, and then perform an additional query to load the records when calling &lt;code&gt;each&lt;/code&gt; (or any &lt;code&gt;Enumerable&lt;/code&gt; method) inside &lt;code&gt;#process&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Tasks that don’t need a Collection&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes, you might want to run a Task that performs a single operation, such as enqueuing another background job or hitting an external API. The gem supports collection-less tasks.&lt;/p&gt; &#xA;&lt;p&gt;Generate a collection-less Task by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;bin/rails generate maintenance_tasks:task no_collection_task --no-collection&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The generated task is a subclass of &lt;code&gt;MaintenanceTasks::Task&lt;/code&gt; that implements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;process&lt;/code&gt;: do the work of your maintenance task&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/tasks/maintenance/no_collection_task.rb&#xA;&#xA;module Maintenance&#xA;  class NoCollectionTask &amp;lt; MaintenanceTasks::Task&#xA;    no_collection&#xA;&#xA;    def process&#xA;      SomeAsyncJob.perform_later&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Throttling&lt;/h3&gt; &#xA;&lt;p&gt;Maintenance Tasks often modify a lot of data and can be taxing on your database. The gem provides a throttling mechanism that can be used to throttle a Task when a given condition is met. If a Task is throttled, it will be interrupted and retried after a backoff period has passed. The default backoff is 30 seconds. Specify the throttle condition as a block:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/tasks/maintenance/update_posts_throttled_task.rb&#xA;&#xA;module Maintenance&#xA;  class UpdatePostsThrottledTask &amp;lt; MaintenanceTasks::Task&#xA;    throttle_on(backoff: 1.minute) do&#xA;      DatabaseStatus.unhealthy?&#xA;    end&#xA;&#xA;    def collection&#xA;      Post.all&#xA;    end&#xA;&#xA;    def process(post)&#xA;      post.update!(content: &#34;New content added on #{Time.now.utc}&#34;)&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that it’s up to you to define a throttling condition that makes sense for your app. Shopify implements &lt;code&gt;DatabaseStatus.healthy?&lt;/code&gt; to check various MySQL metrics such as replication lag, DB threads, whether DB writes are available, etc.&lt;/p&gt; &#xA;&lt;p&gt;Tasks can define multiple throttle conditions. Throttle conditions are inherited by descendants, and new conditions will be appended without impacting existing conditions.&lt;/p&gt; &#xA;&lt;p&gt;The backoff can also be specified as a Proc:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/tasks/maintenance/update_posts_throttled_task.rb&#xA;&#xA;module Maintenance&#xA;  class UpdatePostsThrottledTask &amp;lt; MaintenanceTasks::Task&#xA;    throttle_on(backoff: -&amp;gt; { RandomBackoffGenerator.generate_duration } ) do&#xA;      DatabaseStatus.unhealthy?&#xA;    end&#xA;    ...&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom Task Parameters&lt;/h3&gt; &#xA;&lt;p&gt;Tasks may need additional information, supplied via parameters, to run. Parameters can be defined as Active Model Attributes in a Task, and then become accessible to any of Task’s methods: &lt;code&gt;#collection&lt;/code&gt;, &lt;code&gt;#count&lt;/code&gt;, or &lt;code&gt;#process&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/tasks/maintenance/update_posts_via_params_task.rb&#xA;&#xA;module Maintenance&#xA;  class UpdatePostsViaParamsTask &amp;lt; MaintenanceTasks::Task&#xA;    attribute :updated_content, :string&#xA;    validates :updated_content, presence: true&#xA;&#xA;    def collection&#xA;      Post.all&#xA;    end&#xA;&#xA;    def process(post)&#xA;      post.update!(content: updated_content)&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Tasks can leverage Active Model Validations when defining parameters. Arguments supplied to a Task accepting parameters will be validated before the Task starts to run. Since arguments are specified in the user interface via text area inputs, it’s important to check that they conform to the format your Task expects, and to sanitize any inputs if necessary.&lt;/p&gt; &#xA;&lt;h3&gt;Using Task Callbacks&lt;/h3&gt; &#xA;&lt;p&gt;The Task provides callbacks that hook into its life cycle.&lt;/p&gt; &#xA;&lt;p&gt;Available callbacks are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;after_start&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;after_pause&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;after_interrupt&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;after_cancel&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;after_complete&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;after_error&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module Maintenance&#xA;  class UpdatePostsTask &amp;lt; MaintenanceTasks::Task&#xA;    after_start :notify&#xA;&#xA;    def notify&#xA;      NotifyJob.perform_later(self.class.name)&#xA;    end&#xA;&#xA;    # ...&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: The &lt;code&gt;after_error&lt;/code&gt; callback is guaranteed to complete, so any exceptions raised in your callback code are ignored. If your &lt;code&gt;after_error&lt;/code&gt; callback code can raise an exception, you’ll need to rescue it and handle it appropriately within the callback.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module Maintenance&#xA;  class UpdatePostsTask &amp;lt; MaintenanceTasks::Task&#xA;    after_error :dangerous_notify&#xA;&#xA;    def dangerous_notify&#xA;      # This error is rescued in favour of the original error causing the error flow.&#xA;      raise NotDeliveredError&#xA;    end&#xA;&#xA;    # ...&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If any of the other callbacks cause an exception, it will be handled by the error handler, and will cause the task to stop running.&lt;/p&gt; &#xA;&lt;p&gt;Callback behaviour can be shared across all tasks using an initializer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializer/maintenance_tasks.rb&#xA;Rails.autoloaders.main.on_load(&#34;MaintenanceTasks::Task&#34;) do&#xA;  MaintenanceTasks::Task.class_eval do&#xA;    after_start(:notify)&#xA;&#xA;    private&#xA;&#xA;    def notify; end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Considerations when writing Tasks&lt;/h3&gt; &#xA;&lt;p&gt;MaintenanceTasks relies on the queue adapter configured for your application to run the job which is processing your Task. The guidelines for writing Task may depend on the queue adapter but in general, you should follow these rules:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Duration of &lt;code&gt;Task#process&lt;/code&gt;: processing a single element of the collection should take less than 25 seconds, or the duration set as a timeout for Sidekiq or the queue adapter configured in your application. It allows the Task to be safely interrupted and resumed.&lt;/li&gt; &#xA; &lt;li&gt;Idempotency of &lt;code&gt;Task#process&lt;/code&gt;: it should be safe to run &lt;code&gt;process&lt;/code&gt; multiple times for the same element of the collection. Read more in &lt;a href=&#34;https://github.com/mperham/sidekiq/wiki/Best-Practices#2-make-your-job-idempotent-and-transactional&#34;&gt;this Sidekiq best practice&lt;/a&gt;. It’s important if the Task errors and you run it again, because the same element that errored the Task may well be processed again. It especially matters in the situation described above, when the iteration duration exceeds the timeout: if the job is re-enqueued, multiple elements may be processed again.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Task object life cycle and memoization&lt;/h4&gt; &#xA;&lt;p&gt;When the Task runs or resumes, the Runner enqueues a job, which processes the Task. That job will instantiate a Task object which will live for the duration of the job. The first time the job runs, it will call &lt;code&gt;count&lt;/code&gt;. Every time a job runs, it will call &lt;code&gt;collection&lt;/code&gt; on the Task object, and then &lt;code&gt;process&lt;/code&gt; for each item in the collection, until the job stops. The job stops when either the collection is finished processing or after the maximum job runtime has expired.&lt;/p&gt; &#xA;&lt;p&gt;This means memoization can be misleading within &lt;code&gt;process&lt;/code&gt;, since the memoized values will be available for subsequent calls to &lt;code&gt;process&lt;/code&gt; within the same job. Still, memoization can be used for throttling or reporting, and you can use &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/maintenance_tasks/main/#using-task-callbacks&#34;&gt;Task callbacks&lt;/a&gt; to persist or log a report for example.&lt;/p&gt; &#xA;&lt;h3&gt;Writing tests for a Task&lt;/h3&gt; &#xA;&lt;p&gt;The task generator will also create a test file for your task in the folder &lt;code&gt;test/tasks/maintenance/&lt;/code&gt;. At a minimum, it’s recommended that the &lt;code&gt;#process&lt;/code&gt; method in your task be tested. You may also want to test the &lt;code&gt;#collection&lt;/code&gt; and &lt;code&gt;#count&lt;/code&gt; methods for your task if they are sufficiently complex.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# test/tasks/maintenance/update_posts_task_test.rb&#xA;&#xA;require &#34;test_helper&#34;&#xA;&#xA;module Maintenance&#xA;  class UpdatePostsTaskTest &amp;lt; ActiveSupport::TestCase&#xA;    test &#34;#process performs a task iteration&#34; do&#xA;      post = Post.new&#xA;&#xA;      Maintenance::UpdatePostsTask.process(post)&#xA;&#xA;      assert_equal &#34;New content!&#34;, post.content&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Writing tests for a CSV Task&lt;/h3&gt; &#xA;&lt;p&gt;You should write tests for your &lt;code&gt;#process&lt;/code&gt; method in a CSV Task as well. It takes a &lt;code&gt;CSV::Row&lt;/code&gt; as an argument. You can pass a row, or a hash with string keys to &lt;code&gt;#process&lt;/code&gt; from your test.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# test/tasks/maintenance/import_posts_task_test.rb&#xA;&#xA;require &#34;test_helper&#34;&#xA;&#xA;module Maintenance&#xA;  class ImportPostsTaskTest &amp;lt; ActiveSupport::TestCase&#xA;    test &#34;#process performs a task iteration&#34; do&#xA;      assert_difference -&amp;gt; { Post.count } do&#xA;        Maintenance::UpdatePostsTask.process({&#xA;          &#34;title&#34; =&amp;gt; &#34;My Title&#34;,&#xA;          &#34;content&#34; =&amp;gt; &#34;Hello World!&#34;,&#xA;        })&#xA;      end&#xA;&#xA;      post = Post.last&#xA;      assert_equal &#34;My Title&#34;, post.title&#xA;      assert_equal &#34;Hello World!&#34;, post.content&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Writing tests for a Task with parameters&lt;/h3&gt; &#xA;&lt;p&gt;Tests for tasks with parameters need to instantiate the task class in order to assign attributes. Once the task instance is setup, you may test &lt;code&gt;#process&lt;/code&gt; normally.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# test/tasks/maintenance/update_posts_via_params_task_test.rb&#xA;&#xA;require &#34;test_helper&#34;&#xA;&#xA;module Maintenance&#xA;  class UpdatePostsViaParamsTaskTest &amp;lt; ActiveSupport::TestCase&#xA;    setup do&#xA;      @task = UpdatePostsViaParamsTask.new&#xA;      @task.updated_content = &#34;Testing&#34;&#xA;    end&#xA;&#xA;    test &#34;#process performs a task iteration&#34; do&#xA;      assert_difference -&amp;gt; { Post.first.content } do&#xA;        task.process(Post.first)&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Running a Task&lt;/h3&gt; &#xA;&lt;h4&gt;Running a Task from the Web UI&lt;/h4&gt; &#xA;&lt;p&gt;You can run your new Task by accessing the Web UI and clicking on &#34;Run&#34;.&lt;/p&gt; &#xA;&lt;h4&gt;Running a Task from the command line&lt;/h4&gt; &#xA;&lt;p&gt;Alternatively, you can run your Task in the command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;bundle exec maintenance_tasks perform Maintenance::UpdatePostsTask&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run a Task that processes CSVs from the command line, use the &lt;code&gt;--csv&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;bundle exec maintenance_tasks perform Maintenance::ImportPostsTask --csv &#34;path/to/my_csv.csv&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;--csv&lt;/code&gt; option also works with CSV content coming from the standard input:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;curl &#34;some/remote/csv&#34; |&#xA;  bundle exec maintenance_tasks perform Maintenance::ImportPostsTask --csv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run a Task that takes arguments from the command line, use the &lt;code&gt;--arguments&lt;/code&gt; option, passing arguments as a set of &amp;lt;key&amp;gt;:&amp;lt;value&amp;gt; pairs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;bundle exec maintenance_tasks perform Maintenance::ParamsTask \&#xA;  --arguments post_ids:1,2,3 content:&#34;Hello, World!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Running a Task from Ruby&lt;/h4&gt; &#xA;&lt;p&gt;You can also run a Task in Ruby by sending &lt;code&gt;run&lt;/code&gt; with a Task name to Runner:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MaintenanceTasks::Runner.run(name: &#34;Maintenance::UpdatePostsTask&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run a Task that processes CSVs using the Runner, provide a Hash containing an open IO object and a filename to &lt;code&gt;run&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MaintenanceTasks::Runner.run(&#xA;  name: &#34;Maintenance::ImportPostsTask&#34;,&#xA;  csv_file: { io: File.open(&#34;path/to/my_csv.csv&#34;), filename: &#34;my_csv.csv&#34; }&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run a Task that takes arguments using the Runner, provide a Hash containing the set of arguments (&lt;code&gt;{ parameter_name: argument_value }&lt;/code&gt;) to &lt;code&gt;run&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MaintenanceTasks::Runner.run(&#xA;  name: &#34;Maintenance::ParamsTask&#34;,&#xA;  arguments: { post_ids: &#34;1,2,3&#34; }&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Monitoring your Task’s status&lt;/h3&gt; &#xA;&lt;p&gt;The web UI will provide updates on the status of your Task. Here are the states a Task can be in:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;new&lt;/strong&gt;: A Task that has not yet been run.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;enqueued&lt;/strong&gt;: A Task that is waiting to be performed after a user has instructed it to run.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;running&lt;/strong&gt;: A Task that is currently being performed by a job worker.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pausing&lt;/strong&gt;: A Task that was paused by a user, but needs to finish work before stopping.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;paused&lt;/strong&gt;: A Task that was paused by a user and is not performing. It can be resumed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;interrupted&lt;/strong&gt;: A Task that has been momentarily interrupted by the job infrastructure.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;cancelling&lt;/strong&gt;: A Task that was cancelled by a user, but needs to finish work before stopping.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;cancelled&lt;/strong&gt;: A Task that was cancelled by a user and is not performing. It cannot be resumed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;succeeded&lt;/strong&gt;: A Task that finished successfully.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;errored&lt;/strong&gt;: A Task that encountered an unhandled exception while performing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;How Maintenance Tasks runs a Task&lt;/h3&gt; &#xA;&lt;p&gt;Maintenance tasks can be running for a long time, and the purpose of the gem is to make it easy to continue running tasks through deploys, &lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/&#34;&gt;Kubernetes Pod scheduling&lt;/a&gt;, &lt;a href=&#34;https://www.heroku.com/dynos/lifecycle&#34;&gt;Heroku dyno restarts&lt;/a&gt; or other infrastructure or code changes.&lt;/p&gt; &#xA;&lt;p&gt;This means a Task can safely be interrupted, re-enqueued and resumed without any intervention at the end of an iteration, after the &lt;code&gt;process&lt;/code&gt; method returns.&lt;/p&gt; &#xA;&lt;p&gt;By default, a running Task will be interrupted after running for more 5 minutes. This is &lt;a href=&#34;https://github.com/Shopify/job-iteration/raw/-/guides/best-practices.md#max-job-runtime&#34;&gt;configured in the &lt;code&gt;job-iteration&lt;/code&gt; gem&lt;/a&gt; and can be tweaked in an initializer if necessary.&lt;/p&gt; &#xA;&lt;p&gt;Running tasks will also be interrupted and re-enqueued when needed. For example &lt;a href=&#34;https://github.com/mperham/sidekiq/wiki/Deployment&#34;&gt;when Sidekiq workers shuts down for a deploy&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When Sidekiq receives a TSTP or TERM signal, it will consider itself to be stopping.&lt;/li&gt; &#xA; &lt;li&gt;When Sidekiq is stopping, JobIteration stops iterating over the enumerator. The position in the iteration is saved, a new job is enqueued to resume work, and the Task is marked as interrupted.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When Sidekiq is stopping, it will give workers 25 seconds to finish before forcefully terminating them (this is the default but can be configured with the &lt;code&gt;--timeout&lt;/code&gt; option). Before the worker threads are terminated, Sidekiq will try to re-enqueue the job so your Task will be resumed. However, the position in the collection won’t be persisted so at least one iteration may run again.&lt;/p&gt; &#xA;&lt;h4&gt;Help! My Task is stuck&lt;/h4&gt; &#xA;&lt;p&gt;Finally, if the queue adapter configured for your application doesn’t have this property, or if Sidekiq crashes, is forcefully terminated, or is unable to re-enqueue the jobs that were in progress, the Task may be in a seemingly stuck situation where it appears to be running but is not. In that situation, pausing or cancelling it will not result in the Task being paused or cancelled, as the Task will get stuck in a state of &lt;code&gt;pausing&lt;/code&gt; or &lt;code&gt;cancelling&lt;/code&gt;. As a work-around, if a Task is &lt;code&gt;cancelling&lt;/code&gt; for more than 5 minutes, you will be able to cancel it for good, which will just mark it as cancelled, allowing you to run it again.&lt;/p&gt; &#xA;&lt;h3&gt;Configuring the gem&lt;/h3&gt; &#xA;&lt;p&gt;There are a few configurable options for the gem. Custom configurations should be placed in a &lt;code&gt;maintenance_tasks.rb&lt;/code&gt; initializer.&lt;/p&gt; &#xA;&lt;h4&gt;Customizing the error handler&lt;/h4&gt; &#xA;&lt;p&gt;Exceptions raised while a Task is performing are rescued and information about the error is persisted and visible in the UI.&lt;/p&gt; &#xA;&lt;p&gt;If you want to integrate with an exception monitoring service (e.g. Bugsnag), you can define an error handler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/maintenance_tasks.rb&#xA;&#xA;MaintenanceTasks.error_handler = -&amp;gt;(error, task_context, _errored_element) do&#xA;  Bugsnag.notify(error) do |notification|&#xA;    notification.add_metadata(:task, task_context)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The error handler should be a lambda that accepts three arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;error&lt;/code&gt;: The exception that was raised.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;task_context&lt;/code&gt;: A hash with additional information about the Task and the error:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;task_name&lt;/code&gt;: The name of the Task that errored&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;started_at&lt;/code&gt;: The time the Task started&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;ended_at&lt;/code&gt;: The time the Task errored&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Note that &lt;code&gt;task_context&lt;/code&gt; may be empty if the Task produced an error before any context could be gathered (for example, if deserializing the job to process your Task failed).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;errored_element&lt;/code&gt;: The element, if any, that was being processed when the Task raised an exception. If you would like to pass this object to your exception monitoring service, make sure you &lt;strong&gt;sanitize the object&lt;/strong&gt; to avoid leaking sensitive data and &lt;strong&gt;convert it to a format&lt;/strong&gt; that is compatible with your bug tracker. For example, Bugsnag only sends the id and class name of Active Record objects in order to protect sensitive data. CSV rows, on the other hand, are converted to strings and passed raw to Bugsnag, so make sure to filter any personal data from these objects before adding them to a report.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Customizing the maintenance tasks module&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;MaintenanceTasks.tasks_module&lt;/code&gt; can be configured to define the module in which tasks will be placed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/maintenance_tasks.rb&#xA;&#xA;MaintenanceTasks.tasks_module = &#34;TaskModule&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If no value is specified, it will default to &lt;code&gt;Maintenance&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Organizing tasks using namespaces&lt;/h4&gt; &#xA;&lt;p&gt;Tasks may be nested arbitrarily deeply under &lt;code&gt;app/tasks/maintenance&lt;/code&gt;, for example given a task file &lt;code&gt;app/tasks/maintenance/team_name/service_name/update_posts_task.rb&lt;/code&gt; we can define the task as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module Maintenance&#xA;  module TeamName&#xA;    module ServiceName&#xA;      class UpdatePostsTask &amp;lt; MaintenanceTasks::Task&#xA;        def process(rows)&#xA;          # ...&#xA;        end&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Customizing the underlying job class&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;MaintenanceTasks.job&lt;/code&gt; can be configured to define a Job class for your tasks to use. This is a global configuration, so this Job class will be used across all maintenance tasks in your application.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/maintenance_tasks.rb&#xA;&#xA;MaintenanceTasks.job = &#34;CustomTaskJob&#34;&#xA;&#xA;# app/jobs/custom_task_job.rb&#xA;&#xA;class CustomTaskJob &amp;lt; MaintenanceTasks::TaskJob&#xA;  queue_as :low_priority&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Job class &lt;strong&gt;must inherit&lt;/strong&gt; from &lt;code&gt;MaintenanceTasks::TaskJob&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;retry_on&lt;/code&gt; is not supported for custom Job classes, so failed jobs cannot be retried.&lt;/p&gt; &#xA;&lt;h4&gt;Customizing the rate at which task progress gets updated&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;MaintenanceTasks.ticker_delay&lt;/code&gt; can be configured to customize how frequently task progress gets persisted to the database. It can be a &lt;code&gt;Numeric&lt;/code&gt; value or an &lt;code&gt;ActiveSupport::Duration&lt;/code&gt; value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/maintenance_tasks.rb&#xA;&#xA;MaintenanceTasks.ticker_delay = 2.seconds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If no value is specified, it will default to 1 second.&lt;/p&gt; &#xA;&lt;h4&gt;Customizing which Active Storage service to use&lt;/h4&gt; &#xA;&lt;p&gt;The Active Storage framework in Rails 6.1 and up supports multiple storage services. To specify which service to use, &lt;code&gt;MaintenanceTasks.active_storage_service&lt;/code&gt; can be configured with the service’s key, as specified in your application’s &lt;code&gt;config/storage.yml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# config/storage.yml&#xA;&#xA;user_data:&#xA;  service: GCS&#xA;  credentials: &amp;lt;%= Rails.root.join(&#34;path/to/user/data/keyfile.json&#34;) %&amp;gt;&#xA;  project: &#34;my-project&#34;&#xA;  bucket: &#34;user-data-bucket&#34;&#xA;&#xA;internal:&#xA;  service: GCS&#xA;  credentials: &amp;lt;%= Rails.root.join(&#34;path/to/internal/keyfile.json&#34;) %&amp;gt;&#xA;  project: &#34;my-project&#34;&#xA;  bucket: &#34;internal-bucket&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/maintenance_tasks.rb&#xA;&#xA;MaintenanceTasks.active_storage_service = :internal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is no need to configure this option if your application uses only one storage service. &lt;code&gt;Rails.configuration.active_storage.service&lt;/code&gt; is used by default.&lt;/p&gt; &#xA;&lt;h4&gt;Customizing the backtrace cleaner&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;MaintenanceTasks.backtrace_cleaner&lt;/code&gt; can be configured to specify a backtrace cleaner to use when a Task errors and the backtrace is cleaned and persisted. An &lt;code&gt;ActiveSupport::BacktraceCleaner&lt;/code&gt; should be used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/maintenance_tasks.rb&#xA;&#xA;cleaner = ActiveSupport::BacktraceCleaner.new&#xA;cleaner.add_silencer { |line| line =~ /ignore_this_dir/ }&#xA;&#xA;MaintenanceTasks.backtrace_cleaner = cleaner&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If none is specified, the default &lt;code&gt;Rails.backtrace_cleaner&lt;/code&gt; will be used to clean backtraces.&lt;/p&gt; &#xA;&lt;h4&gt;Customizing the parent controller for the web UI&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;MaintenanceTasks.parent_controller&lt;/code&gt; can be configured to specify a controller class for all of the web UI engine&#39;s controllers to inherit from.&lt;/p&gt; &#xA;&lt;p&gt;This allows applications with common logic in their &lt;code&gt;ApplicationController&lt;/code&gt; (or any other controller) to optionally configure the web UI to inherit that logic with a simple assignment in the initializer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/maintenance_tasks.rb&#xA;&#xA;MaintenanceTasks.parent_controller = &#34;Services::CustomController&#34;&#xA;&#xA;# app/controllers/services/custom_controller.rb&#xA;&#xA;class Services::CustomController &amp;lt; ActionController::Base&#xA;  include CustomSecurityThings&#xA;  include CustomLoggingThings&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The parent controller value &lt;strong&gt;must&lt;/strong&gt; be a string corresponding to an existing controller class which &lt;strong&gt;must inherit&lt;/strong&gt; from &lt;code&gt;ActionController::Base&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If no value is specified, it will default to &lt;code&gt;&#34;ActionController::Base&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Metadata&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;MaintenanceTasks.metadata&lt;/code&gt; can be configured to specify a proc from which to get extra information about the run. Since this proc will be ran in the context of the &lt;code&gt;MaintenanceTasks.parent_controller&lt;/code&gt;, it can be used to keep the id or email of the user who performed the maintenance task.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/maintenance_tasks.rb&#xA;MaintenanceTasks.metadata = -&amp;gt; do&#xA; { user_email: current_user.email }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Upgrading&lt;/h2&gt; &#xA;&lt;p&gt;Use bundler to check for and upgrade to newer versions. After installing a new version, re-run the install command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;bin/rails generate maintenance_tasks:install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This ensures that new migrations are installed and run as well.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;What if I’ve deleted my previous Maintenance Task migrations?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The install command will attempt to reinstall these old migrations and migrating the database will cause problems. Use &lt;code&gt;bin/rails maintenance_tasks:install:migrations&lt;/code&gt; to copy the gem’s migrations to your &lt;code&gt;db/migrate&lt;/code&gt; folder. Check the release notes to see if any new migrations were added since your last gem upgrade. Ensure that these are kept, but remove any migrations that already ran.&lt;/p&gt; &#xA;&lt;p&gt;Run the migrations using &lt;code&gt;bin/rails db:migrate&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Would you like to report an issue or contribute with code? We accept issues and pull requests. You can find the contribution guidelines on &lt;a href=&#34;https://github.com/Shopify/maintenance_tasks/raw/main/.github/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Releasing new versions&lt;/h2&gt; &#xA;&lt;p&gt;Updates should be added to the latest draft release on GitHub as Pull Requests are merged.&lt;/p&gt; &#xA;&lt;p&gt;Once a release is ready, follow these steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update &lt;code&gt;spec.version&lt;/code&gt; in &lt;code&gt;maintenance_tasks.gemspec&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;bundle install&lt;/code&gt; to bump the &lt;code&gt;Gemfile.lock&lt;/code&gt; version of the gem.&lt;/li&gt; &#xA; &lt;li&gt;Open a PR and merge on approval.&lt;/li&gt; &#xA; &lt;li&gt;Deploy via &lt;a href=&#34;https://shipit.shopify.io/shopify/maintenance_tasks/rubygems&#34;&gt;Shipit&lt;/a&gt; and see the new version on &lt;a href=&#34;https://rubygems.org/gems/maintenance_tasks&#34;&gt;https://rubygems.org/gems/maintenance_tasks&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Ensure the release has documented all changes and publish it.&lt;/li&gt; &#xA; &lt;li&gt;Create a new &lt;a href=&#34;https://help.github.com/articles/creating-releases/&#34;&gt;draft release on GitHub&lt;/a&gt; with the title “Upcoming Release”. The tag version can be left blank. This will be the starting point for documenting changes related to the next release.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>