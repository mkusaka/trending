<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-25T01:45:23Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>flori/json</title>
    <updated>2023-01-25T01:45:23Z</updated>
    <id>tag:github.com,2023-01-25:/flori/json</id>
    <link href="https://github.com/flori/json" rel="alternate"></link>
    <summary type="html">&lt;p&gt;JSON implementation for Ruby&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;JSON implementation for Ruby&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/flori/json/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/flori/json/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;This is a implementation of the JSON specification according to RFC 7159 &lt;a href=&#34;http://www.ietf.org/rfc/rfc7159.txt&#34;&gt;http://www.ietf.org/rfc/rfc7159.txt&lt;/a&gt; . Starting from version 1.0.0 on there will be two variants available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A pure ruby variant, that relies on the iconv and the stringscan extensions, which are both part of the ruby standard library.&lt;/li&gt; &#xA; &lt;li&gt;The quite a bit faster native extension variant, which is in parts implemented in C or Java and comes with its own unicode conversion functions and a parser generated by the &lt;a href=&#34;http://www.colm.net/open-source/ragel/&#34;&gt;Ragel&lt;/a&gt; state machine compiler.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Both variants of the JSON generator generate UTF-8 character sequences by default. If an :ascii_only option with a true value is given, they escape all non-ASCII and control characters with \uXXXX escape sequences, and support UTF-16 surrogate pairs in order to be able to generate the whole range of unicode code points.&lt;/p&gt; &#xA;&lt;p&gt;All strings, that are to be encoded as JSON strings, should be UTF-8 byte sequences on the Ruby side. To encode raw binary strings, that aren&#39;t UTF-8 encoded, please use the to_json_raw_object method of String (which produces an object, that contains a byte array) and decode the result on the receiving endpoint.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s recommended to use the extension variant of JSON, because it&#39;s faster than the pure ruby variant. If you cannot build it on your system, you can settle for the latter.&lt;/p&gt; &#xA;&lt;p&gt;Just type into the command line as root:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# rake install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above command will build the extensions and install them on your system.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# rake install_pure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# ruby install.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will just install the pure ruby implementation of JSON.&lt;/p&gt; &#xA;&lt;p&gt;If you use Rubygems you can type&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# gem install json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;instead, to install the newest JSON version.&lt;/p&gt; &#xA;&lt;p&gt;There is also a pure ruby json only variant of the gem, that can be installed with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# gem install json_pure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compiling the extensions yourself&lt;/h2&gt; &#xA;&lt;p&gt;If you want to create the &lt;code&gt;parser.c&lt;/code&gt; file from its &lt;code&gt;parser.rl&lt;/code&gt; file or draw nice graphviz images of the state machines, you need &lt;a href=&#34;http://www.colm.net/open-source/ragel/&#34;&gt;Ragel&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;To use JSON you can&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;json&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to load the installed variant (either the extension &lt;code&gt;&#39;json&#39;&lt;/code&gt; or the pure variant &lt;code&gt;&#39;json_pure&#39;&lt;/code&gt;). If you have installed the extension variant, you can pick either the extension variant or the pure variant by typing&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;json/ext&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;json/pure&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can parse a JSON document into a ruby data structure by calling&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;JSON.parse(document)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to generate a JSON document from a ruby data structure call&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;JSON.generate(data)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use the &lt;code&gt;pretty_generate&lt;/code&gt; method (which formats the output more verbosely and nicely) or &lt;code&gt;fast_generate&lt;/code&gt; (which doesn&#39;t do any of the security checks generate performs, e. g. nesting deepness checks).&lt;/p&gt; &#xA;&lt;p&gt;There are also the JSON and JSON[] methods which use parse on a String or generate a JSON document from an array or hash:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;document = JSON &#39;test&#39;  =&amp;gt; 23 # =&amp;gt; &#34;{\&#34;test\&#34;:23}&#34;&#xA;document = JSON[&#39;test&#39; =&amp;gt; 23] # =&amp;gt; &#34;{\&#34;test\&#34;:23}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;data = JSON &#39;{&#34;test&#34;:23}&#39;  # =&amp;gt; {&#34;test&#34;=&amp;gt;23}&#xA;data = JSON[&#39;{&#34;test&#34;:23}&#39;] # =&amp;gt; {&#34;test&#34;=&amp;gt;23}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can choose to load a set of common additions to ruby core&#39;s objects if you&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;json/add/core&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After requiring this you can, e. g., serialise/deserialise Ruby ranges:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;JSON JSON(1..10) # =&amp;gt; 1..10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To find out how to add JSON support to other or your own classes, read the section &#34;More Examples&#34; below.&lt;/p&gt; &#xA;&lt;p&gt;To get the best compatibility to rails&#39; JSON implementation, you can&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;json/add/rails&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both of the additions attempt to require &lt;code&gt;&#39;json&#39;&lt;/code&gt; (like above) first, if it has not been required yet.&lt;/p&gt; &#xA;&lt;h2&gt;Serializing exceptions&lt;/h2&gt; &#xA;&lt;p&gt;The JSON module doesn&#39;t extend &lt;code&gt;Exception&lt;/code&gt; by default. If you convert an &lt;code&gt;Exception&lt;/code&gt; object to JSON, it will by default only include the exception message.&lt;/p&gt; &#xA;&lt;p&gt;To include the full details, you must either load the &lt;code&gt;json/add/core&lt;/code&gt; mentioned above, or specifically load the exception addition:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;json/add/exception&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;More Examples&lt;/h2&gt; &#xA;&lt;p&gt;To create a JSON document from a ruby data structure, you can call &lt;code&gt;JSON.generate&lt;/code&gt; like that:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;json = JSON.generate [1, 2, {&#34;a&#34;=&amp;gt;3.141}, false, true, nil, 4..10]&#xA;# =&amp;gt; &#34;[1,2,{\&#34;a\&#34;:3.141},false,true,null,\&#34;4..10\&#34;]&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To get back a ruby data structure from a JSON document, you have to call JSON.parse on it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;JSON.parse json&#xA;# =&amp;gt; [1, 2, {&#34;a&#34;=&amp;gt;3.141}, false, true, nil, &#34;4..10&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note, that the range from the original data structure is a simple string now. The reason for this is, that JSON doesn&#39;t support ranges or arbitrary classes. In this case the json library falls back to call &lt;code&gt;Object#to_json&lt;/code&gt;, which is the same as &lt;code&gt;#to_s.to_json&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s possible to add JSON support serialization to arbitrary classes by simply implementing a more specialized version of the &lt;code&gt;#to_json method&lt;/code&gt;, that should return a JSON object (a hash converted to JSON with &lt;code&gt;#to_json&lt;/code&gt;) like this (don&#39;t forget the &lt;code&gt;*a&lt;/code&gt; for all the arguments):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Range&#xA;  def to_json(*a)&#xA;    {&#xA;      &#39;json_class&#39;   =&amp;gt; self.class.name, # = &#39;Range&#39;&#xA;      &#39;data&#39;         =&amp;gt; [ first, last, exclude_end? ]&#xA;    }.to_json(*a)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The hash key &lt;code&gt;json_class&lt;/code&gt; is the class, that will be asked to deserialise the JSON representation later. In this case it&#39;s &lt;code&gt;Range&lt;/code&gt;, but any namespace of the form &lt;code&gt;A::B&lt;/code&gt; or &lt;code&gt;::A::B&lt;/code&gt; will do. All other keys are arbitrary and can be used to store the necessary data to configure the object to be deserialised.&lt;/p&gt; &#xA;&lt;p&gt;If the key &lt;code&gt;json_class&lt;/code&gt; is found in a JSON object, the JSON parser checks if the given class responds to the &lt;code&gt;json_create&lt;/code&gt; class method. If so, it is called with the JSON object converted to a Ruby hash. So a range can be deserialised by implementing &lt;code&gt;Range.json_create&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Range&#xA;  def self.json_create(o)&#xA;    new(*o[&#39;data&#39;])&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now it possible to serialise/deserialise ranges as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;json = JSON.generate [1, 2, {&#34;a&#34;=&amp;gt;3.141}, false, true, nil, 4..10]&#xA;# =&amp;gt; &#34;[1,2,{\&#34;a\&#34;:3.141},false,true,null,{\&#34;json_class\&#34;:\&#34;Range\&#34;,\&#34;data\&#34;:[4,10,false]}]&#34;&#xA;JSON.parse json&#xA;# =&amp;gt; [1, 2, {&#34;a&#34;=&amp;gt;3.141}, false, true, nil, 4..10]&#xA;json = JSON.generate [1, 2, {&#34;a&#34;=&amp;gt;3.141}, false, true, nil, 4..10]&#xA;# =&amp;gt; &#34;[1,2,{\&#34;a\&#34;:3.141},false,true,null,{\&#34;json_class\&#34;:\&#34;Range\&#34;,\&#34;data\&#34;:[4,10,false]}]&#34;&#xA;JSON.parse json, :create_additions =&amp;gt; true&#xA;# =&amp;gt; [1, 2, {&#34;a&#34;=&amp;gt;3.141}, false, true, nil, 4..10]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;JSON.generate&lt;/code&gt; always creates the shortest possible string representation of a ruby data structure in one line. This is good for data storage or network protocols, but not so good for humans to read. Fortunately there&#39;s also &lt;code&gt;JSON.pretty_generate&lt;/code&gt; (or &lt;code&gt;JSON.pretty_generate&lt;/code&gt;) that creates a more readable output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt; puts JSON.pretty_generate([1, 2, {&#34;a&#34;=&amp;gt;3.141}, false, true, nil, 4..10])&#xA; [&#xA;   1,&#xA;   2,&#xA;   {&#xA;     &#34;a&#34;: 3.141&#xA;   },&#xA;   false,&#xA;   true,&#xA;   null,&#xA;   {&#xA;     &#34;json_class&#34;: &#34;Range&#34;,&#xA;     &#34;data&#34;: [&#xA;       4,&#xA;       10,&#xA;       false&#xA;     ]&#xA;   }&#xA; ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are also the methods &lt;code&gt;Kernel#j&lt;/code&gt; for generate, and &lt;code&gt;Kernel#jj&lt;/code&gt; for &lt;code&gt;pretty_generate&lt;/code&gt; output to the console, that work analogous to Core Ruby&#39;s &lt;code&gt;p&lt;/code&gt; and the &lt;code&gt;pp&lt;/code&gt; library&#39;s &lt;code&gt;pp&lt;/code&gt; methods.&lt;/p&gt; &#xA;&lt;p&gt;The script &lt;code&gt;tools/server.rb&lt;/code&gt; contains a small example if you want to test, how receiving a JSON object from a webrick server in your browser with the JavaScript prototype library &lt;a href=&#34;http://www.prototypejs.org&#34;&gt;http://www.prototypejs.org&lt;/a&gt; works.&lt;/p&gt; &#xA;&lt;h2&gt;Speed Comparisons&lt;/h2&gt; &#xA;&lt;p&gt;I have created some benchmark results (see the benchmarks/data-p4-3Ghz subdir of the package) for the JSON-parser to estimate the speed up in the C extension:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; Comparing times (call_time_mean):&#xA;  1 ParserBenchmarkExt#parser   900 repeats:&#xA;        553.922304770 (  real) -&amp;gt;   21.500x&#xA;          0.001805307&#xA;  2 ParserBenchmarkYAML#parser  1000 repeats:&#xA;        224.513358139 (  real) -&amp;gt;    8.714x&#xA;          0.004454078&#xA;  3 ParserBenchmarkPure#parser  1000 repeats:&#xA;         26.755020642 (  real) -&amp;gt;    1.038x&#xA;          0.037376163&#xA;  4 ParserBenchmarkRails#parser 1000 repeats:&#xA;         25.763381731 (  real) -&amp;gt;    1.000x&#xA;          0.038814780&#xA;            calls/sec (  time) -&amp;gt;    speed  covers&#xA;            secs/call&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the table above 1 is &lt;code&gt;JSON::Ext::Parser&lt;/code&gt;, 2 is &lt;code&gt;YAML.load&lt;/code&gt; with YAML compatible JSON document, 3 is is &lt;code&gt;JSON::Pure::Parser&lt;/code&gt;, and 4 is &lt;code&gt;ActiveSupport::JSON.decode&lt;/code&gt;. The ActiveSupport JSON-decoder converts the input first to YAML and then uses the YAML-parser, the conversion seems to slow it down so much that it is only as fast as the &lt;code&gt;JSON::Pure::Parser&lt;/code&gt;!&lt;/p&gt; &#xA;&lt;p&gt;If you look at the benchmark data you can see that this is mostly caused by the frequent high outliers - the median of the Rails-parser runs is still overall smaller than the median of the &lt;code&gt;JSON::Pure::Parser&lt;/code&gt; runs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; Comparing times (call_time_median):&#xA;  1 ParserBenchmarkExt#parser   900 repeats:&#xA;        800.592479481 (  real) -&amp;gt;   26.936x&#xA;          0.001249075&#xA;  2 ParserBenchmarkYAML#parser  1000 repeats:&#xA;        271.002390644 (  real) -&amp;gt;    9.118x&#xA;          0.003690004&#xA;  3 ParserBenchmarkRails#parser 1000 repeats:&#xA;         30.227910865 (  real) -&amp;gt;    1.017x&#xA;          0.033082008&#xA;  4 ParserBenchmarkPure#parser  1000 repeats:&#xA;         29.722384421 (  real) -&amp;gt;    1.000x&#xA;          0.033644676&#xA;            calls/sec (  time) -&amp;gt;    speed  covers&#xA;            secs/call&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I have benchmarked the &lt;code&gt;JSON-Generator&lt;/code&gt; as well. This generated a few more values, because there are different modes that also influence the achieved speed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; Comparing times (call_time_mean):&#xA;  1 GeneratorBenchmarkExt#generator_fast    1000 repeats:&#xA;        547.354332608 (  real) -&amp;gt;   15.090x&#xA;          0.001826970&#xA;  2 GeneratorBenchmarkExt#generator_safe    1000 repeats:&#xA;        443.968212317 (  real) -&amp;gt;   12.240x&#xA;          0.002252414&#xA;  3 GeneratorBenchmarkExt#generator_pretty  900 repeats:&#xA;        375.104545883 (  real) -&amp;gt;   10.341x&#xA;          0.002665923&#xA;  4 GeneratorBenchmarkPure#generator_fast   1000 repeats:&#xA;         49.978706968 (  real) -&amp;gt;    1.378x&#xA;          0.020008521&#xA;  5 GeneratorBenchmarkRails#generator       1000 repeats:&#xA;         38.531868759 (  real) -&amp;gt;    1.062x&#xA;          0.025952543&#xA;  6 GeneratorBenchmarkPure#generator_safe   1000 repeats:&#xA;         36.927649925 (  real) -&amp;gt;    1.018x 7 (&amp;gt;=3859)&#xA;          0.027079979&#xA;  7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:&#xA;         36.272134441 (  real) -&amp;gt;    1.000x 6 (&amp;gt;=3859)&#xA;          0.027569373&#xA;            calls/sec (  time) -&amp;gt;    speed  covers&#xA;            secs/call&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the table above 1-3 are &lt;code&gt;JSON::Ext::Generator&lt;/code&gt; methods. 4, 6, and 7 are &lt;code&gt;JSON::Pure::Generator&lt;/code&gt; methods and 5 is the Rails JSON generator. It is now a bit faster than the &lt;code&gt;generator_safe&lt;/code&gt; and &lt;code&gt;generator_pretty&lt;/code&gt; methods of the pure variant but slower than the others.&lt;/p&gt; &#xA;&lt;p&gt;To achieve the fastest JSON document output, you can use the &lt;code&gt;fast_generate&lt;/code&gt; method. Beware, that this will disable the checking for circular Ruby data structures, which may cause JSON to go into an infinite loop.&lt;/p&gt; &#xA;&lt;p&gt;Here are the median comparisons for completeness&#39; sake:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; Comparing times (call_time_median):&#xA;  1 GeneratorBenchmarkExt#generator_fast    1000 repeats:&#xA;        708.258020939 (  real) -&amp;gt;   16.547x&#xA;          0.001411915&#xA;  2 GeneratorBenchmarkExt#generator_safe    1000 repeats:&#xA;        569.105020353 (  real) -&amp;gt;   13.296x&#xA;          0.001757145&#xA;  3 GeneratorBenchmarkExt#generator_pretty  900 repeats:&#xA;        482.825371244 (  real) -&amp;gt;   11.280x&#xA;          0.002071142&#xA;  4 GeneratorBenchmarkPure#generator_fast   1000 repeats:&#xA;         62.717626652 (  real) -&amp;gt;    1.465x&#xA;          0.015944481&#xA;  5 GeneratorBenchmarkRails#generator       1000 repeats:&#xA;         43.965681162 (  real) -&amp;gt;    1.027x&#xA;          0.022745013&#xA;  6 GeneratorBenchmarkPure#generator_safe   1000 repeats:&#xA;         43.929073409 (  real) -&amp;gt;    1.026x 7 (&amp;gt;=3859)&#xA;          0.022763968&#xA;  7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:&#xA;         42.802514491 (  real) -&amp;gt;    1.000x 6 (&amp;gt;=3859)&#xA;          0.023363113&#xA;            calls/sec (  time) -&amp;gt;    speed  covers&#xA;            secs/call&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;h3&gt;Release&lt;/h3&gt; &#xA;&lt;p&gt;Update the json.gemspec and json-java.gemspec.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rbenv shell 2.6.5&#xA;rake build&#xA;gem push pkg/json-2.3.0.gem&#xA;&#xA;rbenv shell jruby-9.2.9.0&#xA;rake build&#xA;gem push pkg/json-2.3.0-java.gem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;Florian Frank &lt;a href=&#34;mailto:flori@ping.de&#34;&gt;mailto:flori@ping.de&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Ruby License, see &lt;a href=&#34;https://www.ruby-lang.org/en/about/license.txt&#34;&gt;https://www.ruby-lang.org/en/about/license.txt&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;The latest version of this library can be downloaded at&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://rubygems.org/gems/json&#34;&gt;https://rubygems.org/gems/json&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Online Documentation should be located at&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.rubydoc.info/gems/json&#34;&gt;https://www.rubydoc.info/gems/json&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>boltops-tools/jets</title>
    <updated>2023-01-25T01:45:23Z</updated>
    <id>tag:github.com,2023-01-25:/boltops-tools/jets</id>
    <link href="https://github.com/boltops-tools/jets" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ruby on Jets&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;http://rubyonjets.com&#34;&gt;&lt;img src=&#34;http://rubyonjets.com/img/logos/jets-logo-full.png&#34;&gt;&lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;Ruby and Lambda had a baby and that child&#39;s name is &lt;a href=&#34;http://rubyonjets.com/&#34;&gt;Jets&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://codebuild.us-west-2.amazonaws.com/badges?uuid=eyJlbmNyeXB0ZWREYXRhIjoiZ08vK2hjOHczQUVoUDhSYnBNNUU4T0gxQWJuOTlLaXpwVGQ1NjJ3NnVDY1dSdFVXQ3d2VXVSQzRFcU1qd1JPMndFZlByRktIcTUrZm5GWlM5dHpjM1ZrPSIsIml2UGFyYW1ldGVyU3BlYyI6Imluc1Qrd25GanhUdHlidjUiLCJtYXRlcmlhbFNldFNlcmlhbCI6MX0%3D&amp;amp;branch=master&#34; alt=&#34;Build Status&#34;&gt; &lt;a href=&#34;https://circleci.com/gh/boltops-tools/jets&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/boltops-tools/jets.svg?style=svg&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://badge.fury.io/rb/jets&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/jets.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://rubyonjets.com/support/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Support-Help-blue.svg?sanitize=true&#34; alt=&#34;Support&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/boltops-tools/jets&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/boltops-tools/jets.png&#34; alt=&#34;Gitter Chat&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.boltops.com&#34;&gt;&lt;img src=&#34;https://img.boltops.com/boltops/badges/boltops-badge.png&#34; alt=&#34;BoltOps Badge&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Please &lt;strong&gt;watch/star&lt;/strong&gt; this repo to help grow and support the project.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Upgrading&lt;/strong&gt;: If you are upgrading Jets, please check on the &lt;a href=&#34;http://rubyonjets.com/docs/extras/upgrading/&#34;&gt;Upgrading Notes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Sponsors&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://arist.co/&#34;&gt;&lt;img src=&#34;https://img.boltops.com/boltops/tools/jets/sponsors/arist.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is Ruby on Jets?&lt;/h2&gt; &#xA;&lt;p&gt;Jets is a Ruby Serverless Framework. Jets allows you to create serverless applications with a beautiful language: Ruby. It includes everything required to build an application and deploy it to AWS Lambda.&lt;/p&gt; &#xA;&lt;p&gt;It is key to understand AWS Lambda and API Gateway to understand Jets conceptually. Jets maps your code to Lambda functions and API Gateway resources.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;AWS Lambda&lt;/strong&gt; is Functions as a Service. It allows you to upload and run functions without worrying about the underlying infrastructure.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;API Gateway&lt;/strong&gt; is the routing layer for Lambda. It is used to route REST URL endpoints to Lambda functions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The official documentation is at &lt;a href=&#34;http://rubyonjets.com&#34;&gt;Ruby on Jets&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Refer to the official docs for more info, but here&#39;s a quick intro.&lt;/p&gt; &#xA;&lt;h3&gt;Jets Functions&lt;/h3&gt; &#xA;&lt;p&gt;Jets supports writing AWS Lambda functions with Ruby. You define them in the &lt;code&gt;app/functions&lt;/code&gt; folder. A function looks like this:&lt;/p&gt; &#xA;&lt;p&gt;app/functions/simple.rb:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def lambda_handler(event:, context:)&#xA;  puts &#34;hello world&#34;&#xA;  {hello: &#34;world&#34;}&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s the function in the Lambda console:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tongueroo/jets/master/docs/img/docs/jets-simple-lambda-function-console.png&#34; alt=&#34;Code Example in AWS Lambda console&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Though simple functions are supported by Jets, they do not add much value as other ways to write Ruby code with Jets. Classes like &lt;a href=&#34;http://rubyonjets.com/docs/controllers/&#34;&gt;Controllers&lt;/a&gt; and &lt;a href=&#34;http://rubyonjets.com/docs/jobs/&#34;&gt;Jobs&lt;/a&gt; add many conveniences and are more powerful to use. We’ll cover them next.&lt;/p&gt; &#xA;&lt;h3&gt;Jets Controllers&lt;/h3&gt; &#xA;&lt;p&gt;A Jets controller handles a web request and renders a response. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;p&gt;app/controllers/posts_controller.rb:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostsController &amp;lt; ApplicationController&#xA;  def index&#xA;    # renders Lambda Proxy structure compatible with API Gateway&#xA;    render json: {hello: &#34;world&#34;, action: &#34;index&#34;}&#xA;  end&#xA;&#xA;  def show&#xA;    id = params[:id] # params available&#xA;    # puts goes to the lambda logs&#xA;    puts event # raw lambda event available&#xA;    render json: {action: &#34;show&#34;, id: id}&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Helper methods like &lt;code&gt;params&lt;/code&gt; provide the parameters from the API Gateway event. The &lt;code&gt;render&lt;/code&gt; method renders a Lambda Proxy structure back that API Gateway understands.&lt;/p&gt; &#xA;&lt;p&gt;Jets creates Lambda functions for each public method in your controller. Here they are in the Lambda console:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tongueroo/jets/master/docs/img/docs/demo-lambda-functions-controller.png&#34; alt=&#34;Lambda Functions for each public method in AWS Console&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Jets Routing&lt;/h3&gt; &#xA;&lt;p&gt;You connect Lambda functions to API Gateway URL endpoints with a routes file:&lt;/p&gt; &#xA;&lt;p&gt;config/routes.rb:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Jets.application.routes.draw do&#xA;  get  &#34;posts&#34;, to: &#34;posts#index&#34;&#xA;  get  &#34;posts/new&#34;, to: &#34;posts#new&#34;&#xA;  get  &#34;posts/:id&#34;, to: &#34;posts#show&#34;&#xA;  post &#34;posts&#34;, to: &#34;posts#create&#34;&#xA;  get  &#34;posts/:id/edit&#34;, to: &#34;posts#edit&#34;&#xA;  put  &#34;posts&#34;, to: &#34;posts#update&#34;&#xA;  delete  &#34;posts&#34;, to: &#34;posts#delete&#34;&#xA;&#xA;  resources :comments # expands to the RESTful routes above&#xA;&#xA;  any &#34;posts/hot&#34;, to: &#34;posts#hot&#34; # GET, POST, PUT, etc request all work&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;routes.rb&lt;/code&gt; gets translated to API Gateway resources:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tongueroo/jets/master/docs/img/quick-start/demo-api-gateway.png&#34; alt=&#34;API Gateway Resources generated from routes in AWS console&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Test your API Gateway endpoints with curl or postman. Note, replace the URL endpoint with the one that is created:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ curl -s &#34;https://quabepiu80.execute-api.us-east-1.amazonaws.com/dev/posts&#34; | jq .&#xA;{&#xA;  &#34;hello&#34;: &#34;world&#34;,&#xA;  &#34;action&#34;: &#34;index&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Jets Jobs&lt;/h3&gt; &#xA;&lt;p&gt;A Jets job handles asynchronous background jobs performed outside of the web request/response cycle. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;p&gt;app/jobs/hard_job.rb:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class HardJob &amp;lt; ApplicationJob&#xA;  rate &#34;10 hours&#34; # every 10 hours&#xA;  def dig&#xA;    puts &#34;done digging&#34;&#xA;  end&#xA;&#xA;  cron &#34;0 */12 * * ? *&#34; # every 12 hours&#xA;  def lift&#xA;    puts &#34;done lifting&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;HardJob#dig&lt;/code&gt; runs every 10 hours and &lt;code&gt;HardJob#lift&lt;/code&gt; runs every 12 hours. The &lt;code&gt;rate&lt;/code&gt; and &lt;code&gt;cron&lt;/code&gt; methods created CloudWatch Event Rules. Example:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tongueroo/jets/master/docs/img/docs/demo-job-cloudwatch-rule.png&#34; alt=&#34;CloudWatch Event Rules in AWS Console&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Jets Deployment&lt;/h3&gt; &#xA;&lt;p&gt;You can test your application with a local server that mimics API Gateway: &lt;a href=&#34;http://rubyonjets.com/docs/local-server/&#34;&gt;Jets Local Server&lt;/a&gt;. Once ready, deploying to AWS Lambda is a single command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;jets deploy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After deployment, you can test the Lambda functions with the AWS Lambda console or the CLI.&lt;/p&gt; &#xA;&lt;h3&gt;AWS Lambda Console&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://s3.amazonaws.com/boltops-demo/images/screenshots/lambda-console-posts-controller-index.png&#34; alt=&#34;Lambda Console&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Live Demos&lt;/h3&gt; &#xA;&lt;p&gt;Here are some demos of Jets applications:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://demo.rubyonjets.com/&#34;&gt;Quintessential CRUD Jets app&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://api.demo.rubyonjets.com/&#34;&gt;API Demo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://afterburner.demo.rubyonjets.com/&#34;&gt;Jets Afterburner: Easy Rails Support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://mega.demo.rubyonjets.com/&#34;&gt;Mega Mode: Jets and Rails Combined&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://upload.demo.rubyonjets.com/&#34;&gt;Image Upload with CarrierWave&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please feel free to add your own example to the &lt;a href=&#34;https://github.com/tongueroo/jets-examples&#34;&gt;jets-examples&lt;/a&gt; repo.&lt;/p&gt; &#xA;&lt;h3&gt;Rails Support&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://rubyonjets.com/docs/rails-support/&#34;&gt;Jets Afterburner Mode&lt;/a&gt; provides Rails support with little effort. This allows you to run a Rails application on AWS Lambda. Also here&#39;s a Tutorial Blog Post: &lt;a href=&#34;https://blog.boltops.com/2018/12/21/jets-afterburner-serverless-rails-on-aws-lambda-in-5-minutes&#34;&gt;Jets Afterburner: Rails Support&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;More Info&lt;/h3&gt; &#xA;&lt;p&gt;For more documentation, check out the official docs: &lt;a href=&#34;http://rubyonjets.com/&#34;&gt;Ruby on Jets&lt;/a&gt;. Here&#39;s a list of useful links:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/quick-start/&#34;&gt;Quick Start&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/docs/local-server/&#34;&gt;Local Jets Server&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/docs/repl-console/&#34;&gt;REPL Console&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/docs/structure/&#34;&gt;Project Structure&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/docs/app-config/&#34;&gt;App Configuration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/docs/database-support/&#34;&gt;Database Support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/docs/polymorphic-support/&#34;&gt;Polymorphic Support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/docs/rails-support/&#34;&gt;Rails Support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/docs/tutorials/&#34;&gt;Tutorials&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/docs/prewarming/&#34;&gt;Prewarming&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/docs/associated-resources/&#34;&gt;Custom Resources&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/docs/shared-resources/&#34;&gt;Shared Resources&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/docs/install/&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/reference/&#34;&gt;CLI Reference&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/docs/contributing/&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://rubyonjets.com/support-jets/&#34;&gt;Support Jets&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tongueroo/jets-examples&#34;&gt;Example Projects&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Learning Content&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/08/18/introducing-jets-a-ruby-serverless-framework&#34;&gt;Introducing Jets: A Ruby Serverless Framework&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/12/12/official-aws-ruby-support-for-jets-serverless-framework&#34;&gt;Official AWS Ruby Support for Jets&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2019/01/13/build-an-api-service-with-jets-ruby-serverless-framework&#34;&gt;Build an API with Jets&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2019/01/03/serverless-ruby-cron-jobs-with-jets-route53-backup&#34;&gt;Serverless Ruby Cron Jobs Tutorial: Route53 Backup&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2021/02/02/serverless-slack-commands-with-ruby&#34;&gt;Serverless Slack Commands: Fun with AWS Image Recognition&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/12/21/jets-afterburner-serverless-rails-on-aws-lambda-in-5-minutes&#34;&gt;Jets Afterburner: Rails Support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/11/03/jets-mega-mode-run-rails-on-aws-lambda&#34;&gt;Jets Mega Mode: Jets and Rails&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/09/25/toronto-serverless-presentation-jets-framework-on-aws-lambda&#34;&gt;Toronto Serverless Presentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/12/13/jets-image-upload-carrierwave-tutorial-binary-support&#34;&gt;Jets Image Uploads Tutorial with CarrierWave&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/09/07/jets-tutorial-crud-app-introduction-part-1&#34;&gt;Jets Tutorial An Introductory CRUD App Part 1&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/09/08/jets-tutorial-deploy-to-aws-lambda-part-2&#34;&gt;Jets Tutorial Deploy to AWS Lambda Part 2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/09/09/jets-tutorial-debugging-logs-part-3&#34;&gt;Jets Tutorial Debugging Logs Part 3&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/09/10/jets-tutorial-background-jobs-part-4&#34;&gt;Jets Tutorial Background Jobs Part 4&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/09/11/jets-tutorial-iam-policies-part-5&#34;&gt;Jets Tutorial IAM Policies Part 5&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/09/12/jets-tutorial-function-properties-part-6&#34;&gt;Jets Tutorial Function Properties Part 6&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/09/13/jets-tutorial-extra-environments-part-7&#34;&gt;Jets Tutorial Extra Environments Part 7&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/09/26/jets-tutorial-different-environments-part-8&#34;&gt;Jets Tutorial Different Environments Part 8&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/09/27/jets-tutorial-polymorphic-support-part-9&#34;&gt;Jets Tutorial Polymorphic Support Part 9&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.boltops.com/2018/11/12/jets-tutorial-jets-delete&#34;&gt;Jets Delete Tutorial&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>Casecommons/pg_search</title>
    <updated>2023-01-25T01:45:23Z</updated>
    <id>tag:github.com,2023-01-25:/Casecommons/pg_search</id>
    <link href="https://github.com/Casecommons/pg_search" rel="alternate"></link>
    <summary type="html">&lt;p&gt;pg_search builds ActiveRecord named scopes that take advantage of PostgreSQL’s full text search&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;http://github.com/Casecommons/pg_search/&#34;&gt;pg_search&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://rubygems.org/gems/pg_search&#34;&gt;&lt;img src=&#34;https://img.shields.io/gem/v/pg_search.svg?style=flat&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Casecommons/pg_search/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/Casecommons/pg_search/actions/workflows/ci.yml/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/Casecommons/pg_search?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/gitter-join%20chat-blue.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/Casecommons/pg_search&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;DESCRIPTION&lt;/h2&gt; &#xA;&lt;p&gt;PgSearch builds named scopes that take advantage of PostgreSQL&#39;s full text search.&lt;/p&gt; &#xA;&lt;p&gt;Read the blog post introducing PgSearch at &lt;a href=&#34;https://tanzu.vmware.com/content/blog/pg-search-how-i-learned-to-stop-worrying-and-love-postgresql-full-text-search&#34;&gt;https://tanzu.vmware.com/content/blog/pg-search-how-i-learned-to-stop-worrying-and-love-postgresql-full-text-search&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;REQUIREMENTS&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ruby 2.7+&lt;/li&gt; &#xA; &lt;li&gt;ActiveRecord 5.2+&lt;/li&gt; &#xA; &lt;li&gt;PostgreSQL 9.2+&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Casecommons/pg_search/wiki/Installing-PostgreSQL-Extensions&#34;&gt;PostgreSQL extensions&lt;/a&gt; for certain features&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;INSTALL&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install pg_search&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or add this line to your Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;pg_search&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Non-Rails projects&lt;/h3&gt; &#xA;&lt;p&gt;In addition to installing and requiring the gem, you may want to include the PgSearch rake tasks in your Rakefile. This isn&#39;t necessary for Rails projects, which gain the Rake tasks via a Railtie.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;load &#34;pg_search/tasks.rb&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;USAGE&lt;/h2&gt; &#xA;&lt;p&gt;To add PgSearch to an Active Record model, simply include the PgSearch module.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Shape &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Contents&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#multi-search-vs-search-scopes&#34;&gt;Multi-search vs. search scopes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#multi-search&#34;&gt;Multi-search&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#setup&#34;&gt;Setup&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#multisearchable&#34;&gt;&lt;code&gt;multisearchable&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#more-options&#34;&gt;More Options &lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#multi-search-associations&#34;&gt;Multi-search associations&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#searching-in-the-global-search-index&#34;&gt;Searching in the global search index&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#chaining-method-calls-onto-the-results&#34;&gt;Chaining method calls onto the results&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#configuring-multi-search&#34;&gt;Configuring multi-search&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#rebuilding-search-documents-for-a-given-class&#34;&gt;Rebuilding search documents for a given class&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#disabling-multi-search-indexing-temporarily&#34;&gt;Disabling multi-search indexing temporarily&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#pg_search_scope&#34;&gt;&lt;code&gt;pg_search_scope&lt;/code&gt;&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#searching-against-one-column&#34;&gt;Searching against one column&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#searching-against-multiple-columns&#34;&gt;Searching against multiple columns&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#dynamic-search-scopes&#34;&gt;Dynamic search scopes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#searching-through-associations&#34;&gt;Searching through associations&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#searching-using-different-search-features&#34;&gt;Searching using different search features&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#tsearch-full-text-search&#34;&gt;&lt;code&gt;:tsearch&lt;/code&gt; (Full Text Search)&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#weighting&#34;&gt;Weighting&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#prefix-postgresql-84-and-newer-only&#34;&gt;&lt;code&gt;:prefix&lt;/code&gt; (PostgreSQL 8.4 and newer only)&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#negation&#34;&gt;&lt;code&gt;:negation&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#dictionary&#34;&gt;&lt;code&gt;:dictionary&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#normalization&#34;&gt;&lt;code&gt;:normalization&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#any_word&#34;&gt;&lt;code&gt;:any_word&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#sort_only&#34;&gt;&lt;code&gt;:sort_only&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#highlight&#34;&gt;&lt;code&gt;:highlight&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#dmetaphone-double-metaphone-soundalike-search&#34;&gt;&lt;code&gt;:dmetaphone&lt;/code&gt; (Double Metaphone soundalike search)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#trigram-trigram-search&#34;&gt;&lt;code&gt;:trigram&lt;/code&gt; (Trigram search)&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#threshold&#34;&gt;&lt;code&gt;:threshold&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#word_similarity&#34;&gt;&lt;code&gt;:word_similarity&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#limiting-fields-when-combining-features&#34;&gt;Limiting Fields When Combining Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#ignoring-accent-marks&#34;&gt;Ignoring accent marks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#using-tsvector-columns&#34;&gt;Using tsvector columns&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#combining-multiple-tsvectors&#34;&gt;Combining multiple tsvectors&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#configuring-ranking-and-ordering&#34;&gt;Configuring ranking and ordering&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#ranked_by-choosing-a-ranking-algorithm&#34;&gt;&lt;code&gt;:ranked_by&lt;/code&gt; (Choosing a ranking algorithm)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#order_within_rank-breaking-ties&#34;&gt;&lt;code&gt;:order_within_rank&lt;/code&gt; (Breaking ties)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#pgsearchpg_search_rank-reading-a-records-rank-as-a-float&#34;&gt;&lt;code&gt;PgSearch#pg_search_rank&lt;/code&gt; (Reading a record&#39;s rank as a Float)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/#search-rank-and-chained-scopes&#34;&gt;Search rank and chained scopes&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Multi-search vs. search scopes&lt;/h3&gt; &#xA;&lt;p&gt;pg_search supports two different techniques for searching, multi-search and search scopes.&lt;/p&gt; &#xA;&lt;p&gt;The first technique is multi-search, in which records of many different Active Record classes can be mixed together into one global search index across your entire application. Most sites that want to support a generic search page will want to use this feature.&lt;/p&gt; &#xA;&lt;p&gt;The other technique is search scopes, which allow you to do more advanced searching against only one Active Record class. This is more useful for building things like autocompleters or filtering a list of items in a faceted search.&lt;/p&gt; &#xA;&lt;h3&gt;Multi-search&lt;/h3&gt; &#xA;&lt;h4&gt;Setup&lt;/h4&gt; &#xA;&lt;p&gt;Before using multi-search, you must generate and run a migration to create the pg_search_documents database table.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rails g pg_search:migration:multisearch&#xA;$ rake db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;multisearchable&lt;/h4&gt; &#xA;&lt;p&gt;To add a model to the global search index for your application, call multisearchable in its class definition.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class EpicPoem &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  multisearchable against: [:title, :author]&#xA;end&#xA;&#xA;class Flower &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  multisearchable against: :color&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If this model already has existing records, you will need to reindex this model to get existing records into the pg_search_documents table. See the rebuild task below.&lt;/p&gt; &#xA;&lt;p&gt;Whenever a record is created, updated, or destroyed, an Active Record callback will fire, leading to the creation of a corresponding PgSearch::Document record in the pg_search_documents table. The :against option can be one or several methods which will be called on the record to generate its search text.&lt;/p&gt; &#xA;&lt;p&gt;You can also pass a Proc or method name to call to determine whether or not a particular record should be included.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Convertible &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  multisearchable against: [:make, :model],&#xA;                  if: :available_in_red?&#xA;end&#xA;&#xA;class Jalopy &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  multisearchable against: [:make, :model],&#xA;                  if: lambda { |record| record.model_year &amp;gt; 1970 }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the Proc or method name is called in an after_save hook. This means that you should be careful when using Time or other objects. In the following example, if the record was last saved before the published_at timestamp, it won&#39;t get listed in global search at all until it is touched again after the timestamp.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AntipatternExample&#xA;  include PgSearch::Model&#xA;  multisearchable against: [:contents],&#xA;                  if: :published?&#xA;&#xA;  def published?&#xA;    published_at &amp;lt; Time.now&#xA;  end&#xA;end&#xA;&#xA;problematic_record = AntipatternExample.create!(&#xA;  contents: &#34;Using :if with a timestamp&#34;,&#xA;  published_at: 10.minutes.from_now&#xA;)&#xA;&#xA;problematic_record.published?     # =&amp;gt; false&#xA;PgSearch.multisearch(&#34;timestamp&#34;) # =&amp;gt; No results&#xA;&#xA;sleep 20.minutes&#xA;&#xA;problematic_record.published?     # =&amp;gt; true&#xA;PgSearch.multisearch(&#34;timestamp&#34;) # =&amp;gt; No results&#xA;&#xA;problematic_record.save!&#xA;&#xA;problematic_record.published?     # =&amp;gt; true&#xA;PgSearch.multisearch(&#34;timestamp&#34;) # =&amp;gt; Includes problematic_record&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;More Options&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Conditionally update pg_search_documents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can also use the &lt;code&gt;:update_if&lt;/code&gt; option to pass a Proc or method name to call to determine whether or not a particular record should be updated.&lt;/p&gt; &#xA;&lt;p&gt;Note that the Proc or method name is called in an &lt;code&gt;after_save&lt;/code&gt; hook, so if you are relying on ActiveRecord dirty flags use &lt;code&gt;*_previously_changed?&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Message &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  multisearchable against: [:body],&#xA;                  update_if: :body_previously_changed?&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Specify additional attributes to be saved on the pg_search_documents table&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can specify &lt;code&gt;:additional_attributes&lt;/code&gt; to be saved within the &lt;code&gt;pg_search_documents&lt;/code&gt; table. For example, perhaps you are indexing a book model and an article model and wanted to include the author_id.&lt;/p&gt; &#xA;&lt;p&gt;First, we need to add a reference to author to the migration creating our &lt;code&gt;pg_search_documents&lt;/code&gt; table.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  create_table :pg_search_documents do |t|&#xA;    t.text :content&#xA;    t.references :author, index: true&#xA;    t.belongs_to :searchable, polymorphic: true, index: true&#xA;    t.timestamps null: false&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, we can send in this additional attribute in a lambda&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  multisearchable(&#xA;    against: [:title, :body],&#xA;    additional_attributes: -&amp;gt; (article) { { author_id: article.author_id } }&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This allows much faster searches without joins later on by doing something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;PgSearch.multisearch(params[&#39;search&#39;]).where(author_id: 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE: You must currently manually call &lt;code&gt;record.update_pg_search_document&lt;/code&gt; for the additional attribute to be included in the pg_search_documents table&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Multi-search associations&lt;/h4&gt; &#xA;&lt;p&gt;Two associations are built automatically. On the original record, there is a has_one :pg_search_document association pointing to the PgSearch::Document record, and on the PgSearch::Document record there is a belongs_to :searchable polymorphic association pointing back to the original record.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;odyssey = EpicPoem.create!(title: &#34;Odyssey&#34;, author: &#34;Homer&#34;)&#xA;search_document = odyssey.pg_search_document #=&amp;gt; PgSearch::Document instance&#xA;search_document.searchable #=&amp;gt; #&amp;lt;EpicPoem id: 1, title: &#34;Odyssey&#34;, author: &#34;Homer&#34;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Searching in the global search index&lt;/h4&gt; &#xA;&lt;p&gt;To fetch the PgSearch::Document entries for all of the records that match a given query, use PgSearch.multisearch.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;odyssey = EpicPoem.create!(title: &#34;Odyssey&#34;, author: &#34;Homer&#34;)&#xA;rose = Flower.create!(color: &#34;Red&#34;)&#xA;PgSearch.multisearch(&#34;Homer&#34;) #=&amp;gt; [#&amp;lt;PgSearch::Document searchable: odyssey&amp;gt;]&#xA;PgSearch.multisearch(&#34;Red&#34;) #=&amp;gt; [#&amp;lt;PgSearch::Document searchable: rose&amp;gt;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Chaining method calls onto the results&lt;/h4&gt; &#xA;&lt;p&gt;PgSearch.multisearch returns an ActiveRecord::Relation, just like scopes do, so you can chain scope calls to the end. This works with gems like Kaminari that add scope methods. Just like with regular scopes, the database will only receive SQL requests when necessary.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;PgSearch.multisearch(&#34;Bertha&#34;).limit(10)&#xA;PgSearch.multisearch(&#34;Juggler&#34;).where(searchable_type: &#34;Occupation&#34;)&#xA;PgSearch.multisearch(&#34;Alamo&#34;).page(3).per(30)&#xA;PgSearch.multisearch(&#34;Diagonal&#34;).find_each do |document|&#xA;  puts document.searchable.updated_at&#xA;end&#xA;PgSearch.multisearch(&#34;Moro&#34;).reorder(&#34;&#34;).group(:searchable_type).count(:all)&#xA;PgSearch.multisearch(&#34;Square&#34;).includes(:searchable)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Configuring multi-search&lt;/h4&gt; &#xA;&lt;p&gt;PgSearch.multisearch can be configured using the same options as &lt;code&gt;pg_search_scope&lt;/code&gt; (explained in more detail below). Just set the PgSearch.multisearch_options in an initializer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;PgSearch.multisearch_options = {&#xA;  using: [:tsearch, :trigram],&#xA;  ignoring: :accents&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Rebuilding search documents for a given class&lt;/h4&gt; &#xA;&lt;p&gt;If you change the :against option on a class, add multisearchable to a class that already has records in the database, or remove multisearchable from a class in order to remove it from the index, you will find that the pg_search_documents table could become out-of-sync with the actual records in your other tables.&lt;/p&gt; &#xA;&lt;p&gt;The index can also become out-of-sync if you ever modify records in a way that does not trigger Active Record callbacks. For instance, the #update_attribute instance method and the .update_all class method both skip callbacks and directly modify the database.&lt;/p&gt; &#xA;&lt;p&gt;To remove all of the documents for a given class, you can simply delete all of the PgSearch::Document records.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;PgSearch::Document.delete_by(searchable_type: &#34;Animal&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To regenerate the documents for a given class, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;PgSearch::Multisearch.rebuild(Product)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;rebuild&lt;/code&gt; method will delete all the documents for the given class before regenerating them. In some situations this may not be desirable, such as when you&#39;re using single-table inheritance and &lt;code&gt;searchable_type&lt;/code&gt; is your base class. You can prevent &lt;code&gt;rebuild&lt;/code&gt; from deleting your records like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;PgSearch::Multisearch.rebuild(Product, clean_up: false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;rebuild&lt;/code&gt; runs inside a single transaction. To run outside of a transaction, you can pass &lt;code&gt;transactional: false&lt;/code&gt; like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;PgSearch::Multisearch.rebuild(Product, transactional: false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Rebuild is also available as a Rake task, for convenience.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ rake pg_search:multisearch:rebuild[BlogPost]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A second optional argument can be passed to specify the PostgreSQL schema search path to use, for multi-tenant databases that have multiple pg_search_documents tables. The following will set the schema search path to &#34;my_schema&#34; before reindexing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ rake pg_search:multisearch:rebuild[BlogPost,my_schema]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For models that are multisearchable &lt;code&gt;:against&lt;/code&gt; methods that directly map to Active Record attributes, an efficient single SQL statement is run to update the &lt;code&gt;pg_search_documents&lt;/code&gt; table all at once. However, if you call any dynamic methods in &lt;code&gt;:against&lt;/code&gt; then &lt;code&gt;update_pg_search_document&lt;/code&gt; will be called on the individual records being indexed in batches.&lt;/p&gt; &#xA;&lt;p&gt;You can also provide a custom implementation for rebuilding the documents by adding a class method called &lt;code&gt;rebuild_pg_search_documents&lt;/code&gt; to your model.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Movie &amp;lt; ActiveRecord::Base&#xA;  belongs_to :director&#xA;&#xA;  def director_name&#xA;    director.name&#xA;  end&#xA;&#xA;  multisearchable against: [:name, :director_name]&#xA;&#xA;  # Naive approach&#xA;  def self.rebuild_pg_search_documents&#xA;    find_each { |record| record.update_pg_search_document }&#xA;  end&#xA;&#xA;  # More sophisticated approach&#xA;  def self.rebuild_pg_search_documents&#xA;    connection.execute &amp;lt;&amp;lt;~SQL.squish&#xA;     INSERT INTO pg_search_documents (searchable_type, searchable_id, content, created_at, updated_at)&#xA;       SELECT &#39;Movie&#39; AS searchable_type,&#xA;              movies.id AS searchable_id,&#xA;              CONCAT_WS(&#39; &#39;, movies.name, directors.name) AS content,&#xA;              now() AS created_at,&#xA;              now() AS updated_at&#xA;       FROM movies&#xA;       LEFT JOIN directors&#xA;         ON directors.id = movies.director_id&#xA;    SQL&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If using PostgreSQL before 9.1, replace the &lt;code&gt;CONCAT_WS()&lt;/code&gt; function call with double-pipe concatenation, eg. &lt;code&gt;(movies.name || &#39; &#39; || directors.name)&lt;/code&gt;. However, now be aware that if &lt;em&gt;any&lt;/em&gt; of the joined values is NULL then the final &lt;code&gt;content&lt;/code&gt; value will also be NULL, whereas &lt;code&gt;CONCAT_WS()&lt;/code&gt; will selectively ignore NULL values.&lt;/p&gt; &#xA;&lt;h4&gt;Disabling multi-search indexing temporarily&lt;/h4&gt; &#xA;&lt;p&gt;If you have a large bulk operation to perform, such as importing a lot of records from an external source, you might want to speed things up by turning off indexing temporarily. You could then use one of the techniques above to rebuild the search documents off-line.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;PgSearch.disable_multisearch do&#xA;  Movie.import_from_xml_file(File.open(&#34;movies.xml&#34;))&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;pg_search_scope&lt;/h3&gt; &#xA;&lt;p&gt;You can use pg_search_scope to build a search scope. The first parameter is a scope name, and the second parameter is an options hash. The only required option is :against, which tells pg_search_scope which column or columns to search against.&lt;/p&gt; &#xA;&lt;h4&gt;Searching against one column&lt;/h4&gt; &#xA;&lt;p&gt;To search against a column, pass a symbol as the :against option.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class BlogPost &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :search_by_title, against: :title&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We now have an ActiveRecord scope named search_by_title on our BlogPost model. It takes one parameter, a search query string.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;BlogPost.create!(title: &#34;Recent Developments in the World of Pastrami&#34;)&#xA;BlogPost.create!(title: &#34;Prosciutto and You: A Retrospective&#34;)&#xA;BlogPost.search_by_title(&#34;pastrami&#34;) # =&amp;gt; [#&amp;lt;BlogPost id: 2, title: &#34;Recent Developments in the World of Pastrami&#34;&amp;gt;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Searching against multiple columns&lt;/h4&gt; &#xA;&lt;p&gt;Just pass an Array if you&#39;d like to search more than one column.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Person &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :search_by_full_name, against: [:first_name, :last_name]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now our search query can match either or both of the columns.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;person_1 = Person.create!(first_name: &#34;Grant&#34;, last_name: &#34;Hill&#34;)&#xA;person_2 = Person.create!(first_name: &#34;Hugh&#34;, last_name: &#34;Grant&#34;)&#xA;&#xA;Person.search_by_full_name(&#34;Grant&#34;) # =&amp;gt; [person_1, person_2]&#xA;Person.search_by_full_name(&#34;Grant Hill&#34;) # =&amp;gt; [person_1]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Dynamic search scopes&lt;/h4&gt; &#xA;&lt;p&gt;Just like with Active Record named scopes, you can pass in a Proc object that returns a hash of options. For instance, the following scope takes a parameter that dynamically chooses which column to search against.&lt;/p&gt; &#xA;&lt;p&gt;Important: The returned hash must include a :query key. Its value does not necessary have to be dynamic. You could choose to hard-code it to a specific value if you wanted.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Person &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :search_by_name, lambda { |name_part, query|&#xA;    raise ArgumentError unless [:first, :last].include?(name_part)&#xA;    {&#xA;      against: name_part,&#xA;      query: query&#xA;    }&#xA;  }&#xA;end&#xA;&#xA;person_1 = Person.create!(first_name: &#34;Grant&#34;, last_name: &#34;Hill&#34;)&#xA;person_2 = Person.create!(first_name: &#34;Hugh&#34;, last_name: &#34;Grant&#34;)&#xA;&#xA;Person.search_by_name :first, &#34;Grant&#34; # =&amp;gt; [person_1]&#xA;Person.search_by_name :last, &#34;Grant&#34; # =&amp;gt; [person_2]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Searching through associations&lt;/h4&gt; &#xA;&lt;p&gt;It is possible to search columns on associated models. Note that if you do this, it will be impossible to speed up searches with database indexes. However, it is supported as a quick way to try out cross-model searching.&lt;/p&gt; &#xA;&lt;p&gt;You can pass a Hash into the :associated_against option to set up searching through associations. The keys are the names of the associations and the value works just like an :against option for the other model. Right now, searching deeper than one association away is not supported. You can work around this by setting up a series of :through associations to point all the way through.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Cracker &amp;lt; ActiveRecord::Base&#xA;  has_many :cheeses&#xA;end&#xA;&#xA;class Cheese &amp;lt; ActiveRecord::Base&#xA;end&#xA;&#xA;class Salami &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;&#xA;  belongs_to :cracker&#xA;  has_many :cheeses, through: :cracker&#xA;&#xA;  pg_search_scope :tasty_search, associated_against: {&#xA;    cheeses: [:kind, :brand],&#xA;    cracker: :kind&#xA;  }&#xA;end&#xA;&#xA;salami_1 = Salami.create!&#xA;salami_2 = Salami.create!&#xA;salami_3 = Salami.create!&#xA;&#xA;limburger = Cheese.create!(kind: &#34;Limburger&#34;)&#xA;brie = Cheese.create!(kind: &#34;Brie&#34;)&#xA;pepper_jack = Cheese.create!(kind: &#34;Pepper Jack&#34;)&#xA;&#xA;Cracker.create!(kind: &#34;Black Pepper&#34;, cheeses: [brie], salami: salami_1)&#xA;Cracker.create!(kind: &#34;Ritz&#34;, cheeses: [limburger, pepper_jack], salami: salami_2)&#xA;Cracker.create!(kind: &#34;Graham&#34;, cheeses: [limburger], salami: salami_3)&#xA;&#xA;Salami.tasty_search(&#34;pepper&#34;) # =&amp;gt; [salami_1, salami_2]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Searching using different search features&lt;/h3&gt; &#xA;&lt;p&gt;By default, pg_search_scope uses the built-in &lt;a href=&#34;http://www.postgresql.org/docs/current/static/textsearch-intro.html&#34;&gt;PostgreSQL text search&lt;/a&gt;. If you pass the :using option to pg_search_scope, you can choose alternative search techniques.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Beer &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :search_name, against: :name, using: [:tsearch, :trigram, :dmetaphone]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s an example if you pass multiple :using options with additional configurations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Beer &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :search_name,&#xA;  against: :name,&#xA;  using: {&#xA;      :trigram =&amp;gt; {},&#xA;      :dmetaphone =&amp;gt; {},&#xA;      :tsearch =&amp;gt; { :prefix =&amp;gt; true }&#xA;  }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The currently implemented features are&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;:tsearch - &lt;a href=&#34;http://www.postgresql.org/docs/current/static/textsearch-intro.html&#34;&gt;Full text search&lt;/a&gt;, which is built-in to PostgreSQL&lt;/li&gt; &#xA; &lt;li&gt;:trigram - &lt;a href=&#34;http://www.postgresql.org/docs/current/static/pgtrgm.html&#34;&gt;Trigram search&lt;/a&gt;, which requires the trigram extension&lt;/li&gt; &#xA; &lt;li&gt;:dmetaphone - &lt;a href=&#34;http://www.postgresql.org/docs/current/static/fuzzystrmatch.html#AEN177521&#34;&gt;Double Metaphone search&lt;/a&gt;, which requires the fuzzystrmatch extension&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;:tsearch (Full Text Search)&lt;/h4&gt; &#xA;&lt;p&gt;PostgreSQL&#39;s built-in full text search supports weighting, prefix searches, and stemming in multiple languages.&lt;/p&gt; &#xA;&lt;h5&gt;Weighting&lt;/h5&gt; &#xA;&lt;p&gt;Each searchable column can be given a weight of &#34;A&#34;, &#34;B&#34;, &#34;C&#34;, or &#34;D&#34;. Columns with earlier letters are weighted higher than those with later letters. So, in the following example, the title is the most important, followed by the subtitle, and finally the content.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NewsArticle &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :search_full_text, against: {&#xA;    title: &#39;A&#39;,&#xA;    subtitle: &#39;B&#39;,&#xA;    content: &#39;C&#39;&#xA;  }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also pass the weights in as an array of arrays, or any other structure that responds to #each and yields either a single symbol or a symbol and a weight. If you omit the weight, a default will be used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NewsArticle &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :search_full_text, against: [&#xA;    [:title, &#39;A&#39;],&#xA;    [:subtitle, &#39;B&#39;],&#xA;    [:content, &#39;C&#39;]&#xA;  ]&#xA;end&#xA;&#xA;class NewsArticle &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :search_full_text, against: [&#xA;    [:title, &#39;A&#39;],&#xA;    {subtitle: &#39;B&#39;},&#xA;    :content&#xA;  ]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;:prefix (PostgreSQL 8.4 and newer only)&lt;/h5&gt; &#xA;&lt;p&gt;PostgreSQL&#39;s full text search matches on whole words by default. If you want to search for partial words, however, you can set :prefix to true. Since this is a :tsearch-specific option, you should pass it to :tsearch directly, as shown in the following example.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Superhero &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :whose_name_starts_with,&#xA;                  against: :name,&#xA;                  using: {&#xA;                    tsearch: { prefix: true }&#xA;                  }&#xA;end&#xA;&#xA;batman = Superhero.create name: &#39;Batman&#39;&#xA;batgirl = Superhero.create name: &#39;Batgirl&#39;&#xA;robin = Superhero.create name: &#39;Robin&#39;&#xA;&#xA;Superhero.whose_name_starts_with(&#34;Bat&#34;) # =&amp;gt; [batman, batgirl]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;:negation&lt;/h5&gt; &#xA;&lt;p&gt;PostgreSQL&#39;s full text search matches all search terms by default. If you want to exclude certain words, you can set :negation to true. Then any term that begins with an exclamation point &lt;code&gt;!&lt;/code&gt; will be excluded from the results. Since this is a :tsearch-specific option, you should pass it to :tsearch directly, as shown in the following example.&lt;/p&gt; &#xA;&lt;p&gt;Note that combining this with other search features can have unexpected results. For example, :trigram searches don&#39;t have a concept of excluded terms, and thus if you use both :tsearch and :trigram in tandem, you may still find results that contain the term that you were trying to exclude.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Animal &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :with_name_matching,&#xA;                  against: :name,&#xA;                  using: {&#xA;                    tsearch: {negation: true}&#xA;                  }&#xA;end&#xA;&#xA;one_fish = Animal.create(name: &#34;one fish&#34;)&#xA;two_fish = Animal.create(name: &#34;two fish&#34;)&#xA;red_fish = Animal.create(name: &#34;red fish&#34;)&#xA;blue_fish = Animal.create(name: &#34;blue fish&#34;)&#xA;&#xA;Animal.with_name_matching(&#34;fish !red !blue&#34;) # =&amp;gt; [one_fish, two_fish]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;:dictionary&lt;/h5&gt; &#xA;&lt;p&gt;PostgreSQL full text search also support multiple dictionaries for stemming. You can learn more about how dictionaries work by reading the &lt;a href=&#34;http://www.postgresql.org/docs/current/static/textsearch-dictionaries.html&#34;&gt;PostgreSQL documention&lt;/a&gt;. If you use one of the language dictionaries, such as &#34;english&#34;, then variants of words (e.g. &#34;jumping&#34; and &#34;jumped&#34;) will match each other. If you don&#39;t want stemming, you should pick the &#34;simple&#34; dictionary which does not do any stemming. If you don&#39;t specify a dictionary, the &#34;simple&#34; dictionary will be used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class BoringTweet &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :kinda_matching,&#xA;                  against: :text,&#xA;                  using: {&#xA;                    tsearch: {dictionary: &#34;english&#34;}&#xA;                  }&#xA;  pg_search_scope :literally_matching,&#xA;                  against: :text,&#xA;                  using: {&#xA;                    tsearch: {dictionary: &#34;simple&#34;}&#xA;                  }&#xA;end&#xA;&#xA;sleep = BoringTweet.create! text: &#34;I snoozed my alarm for fourteen hours today. I bet I can beat that tomorrow! #sleep&#34;&#xA;sleeping = BoringTweet.create! text: &#34;You know what I like? Sleeping. That&#39;s what. #enjoyment&#34;&#xA;sleeps = BoringTweet.create! text: &#34;In the jungle, the mighty jungle, the lion sleeps #tonight&#34;&#xA;&#xA;BoringTweet.kinda_matching(&#34;sleeping&#34;) # =&amp;gt; [sleep, sleeping, sleeps]&#xA;BoringTweet.literally_matching(&#34;sleeps&#34;) # =&amp;gt; [sleeps]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;:normalization&lt;/h5&gt; &#xA;&lt;p&gt;PostgreSQL supports multiple algorithms for ranking results against queries. For instance, you might want to consider overall document size or the distance between multiple search terms in the original text. This option takes an integer, which is passed directly to PostgreSQL. According to the latest &lt;a href=&#34;http://www.postgresql.org/docs/current/static/textsearch-controls.html&#34;&gt;PostgreSQL documentation&lt;/a&gt;, the supported algorithms are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;0 (the default) ignores the document length&#xA;1 divides the rank by 1 + the logarithm of the document length&#xA;2 divides the rank by the document length&#xA;4 divides the rank by the mean harmonic distance between extents&#xA;8 divides the rank by the number of unique words in document&#xA;16 divides the rank by 1 + the logarithm of the number of unique words in document&#xA;32 divides the rank by itself + 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This integer is a bitmask, so if you want to combine algorithms, you can add their numbers together. (e.g. to use algorithms 1, 8, and 32, you would pass 1 + 8 + 32 = 41)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class BigLongDocument &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :regular_search,&#xA;                  against: :text&#xA;&#xA;  pg_search_scope :short_search,&#xA;                  against: :text,&#xA;                  using: {&#xA;                    tsearch: {normalization: 2}&#xA;                  }&#xA;&#xA;long = BigLongDocument.create!(text: &#34;Four score and twenty years ago&#34;)&#xA;short = BigLongDocument.create!(text: &#34;Four score&#34;)&#xA;&#xA;BigLongDocument.regular_search(&#34;four score&#34;) #=&amp;gt; [long, short]&#xA;BigLongDocument.short_search(&#34;four score&#34;) #=&amp;gt; [short, long]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;:any_word&lt;/h5&gt; &#xA;&lt;p&gt;Setting this attribute to true will perform a search which will return all models containing any word in the search terms.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Number &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :search_any_word,&#xA;                  against: :text,&#xA;                  using: {&#xA;                    tsearch: {any_word: true}&#xA;                  }&#xA;&#xA;  pg_search_scope :search_all_words,&#xA;                  against: :text&#xA;end&#xA;&#xA;one = Number.create! text: &#39;one&#39;&#xA;two = Number.create! text: &#39;two&#39;&#xA;three = Number.create! text: &#39;three&#39;&#xA;&#xA;Number.search_any_word(&#39;one two three&#39;) # =&amp;gt; [one, two, three]&#xA;Number.search_all_words(&#39;one two three&#39;) # =&amp;gt; []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;:sort_only&lt;/h5&gt; &#xA;&lt;p&gt;Setting this attribute to true will make this feature available for sorting, but will not include it in the query&#39;s WHERE condition.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Person &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :search,&#xA;                  against: :name,&#xA;                  using: {&#xA;                    tsearch: {any_word: true},&#xA;                    dmetaphone: {any_word: true, sort_only: true}&#xA;                  }&#xA;end&#xA;&#xA;exact = Person.create!(name: &#39;ash hines&#39;)&#xA;one_exact_one_close = Person.create!(name: &#39;ash heinz&#39;)&#xA;one_exact = Person.create!(name: &#39;ash smith&#39;)&#xA;one_close = Person.create!(name: &#39;leigh heinz&#39;)&#xA;&#xA;Person.search(&#39;ash hines&#39;) # =&amp;gt; [exact, one_exact_one_close, one_exact]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;:highlight&lt;/h5&gt; &#xA;&lt;p&gt;Adding .with_pg_search_highlight after the pg_search_scope you can access to &lt;code&gt;pg_highlight&lt;/code&gt; attribute for each object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Person &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :search,&#xA;                  against: :bio,&#xA;                  using: {&#xA;                    tsearch: {&#xA;                      highlight: {&#xA;                        StartSel: &#39;&amp;lt;b&amp;gt;&#39;,&#xA;                        StopSel: &#39;&amp;lt;/b&amp;gt;&#39;,&#xA;                        MaxWords: 123,&#xA;                        MinWords: 456,&#xA;                        ShortWord: 4,&#xA;                        HighlightAll: true,&#xA;                        MaxFragments: 3,&#xA;                        FragmentDelimiter: &#39;&amp;amp;hellip;&#39;&#xA;                      }&#xA;                    }&#xA;                  }&#xA;end&#xA;&#xA;Person.create!(:bio =&amp;gt; &#34;Born in rural Alberta, where the buffalo roam.&#34;)&#xA;&#xA;first_match = Person.search(&#34;Alberta&#34;).with_pg_search_highlight.first&#xA;first_match.pg_search_highlight # =&amp;gt; &#34;Born in rural &amp;lt;b&amp;gt;Alberta&amp;lt;/b&amp;gt;, where the buffalo roam.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The highlight option accepts all &lt;a href=&#34;https://www.postgresql.org/docs/current/static/textsearch-controls.html&#34;&gt;options supported by ts_headline&lt;/a&gt;, and uses PostgreSQL&#39;s defaults.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://www.postgresql.org/docs/current/static/textsearch-controls.html&#34;&gt;documentation&lt;/a&gt; for details on the meaning of each option.&lt;/p&gt; &#xA;&lt;h4&gt;:dmetaphone (Double Metaphone soundalike search)&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Double_Metaphone&#34;&gt;Double Metaphone&lt;/a&gt; is an algorithm for matching words that sound alike even if they are spelled very differently. For example, &#34;Geoff&#34; and &#34;Jeff&#34; sound identical and thus match. Currently, this is not a true double-metaphone, as only the first metaphone is used for searching.&lt;/p&gt; &#xA;&lt;p&gt;Double Metaphone support is currently available as part of the &lt;a href=&#34;http://www.postgresql.org/docs/current/static/fuzzystrmatch.html&#34;&gt;fuzzystrmatch extension&lt;/a&gt; that must be installed before this feature can be used. In addition to the extension, you must install a utility function into your database. To generate and run a migration for this, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ rails g pg_search:migration:dmetaphone&#xA;$ rake db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following example shows how to use :dmetaphone.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Word &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :that_sounds_like,&#xA;                  against: :spelling,&#xA;                  using: :dmetaphone&#xA;end&#xA;&#xA;four = Word.create! spelling: &#39;four&#39;&#xA;far = Word.create! spelling: &#39;far&#39;&#xA;fur = Word.create! spelling: &#39;fur&#39;&#xA;five = Word.create! spelling: &#39;five&#39;&#xA;&#xA;Word.that_sounds_like(&#34;fir&#34;) # =&amp;gt; [four, far, fur]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;:trigram (Trigram search)&lt;/h4&gt; &#xA;&lt;p&gt;Trigram search works by counting how many three-letter substrings (or &#34;trigrams&#34;) match between the query and the text. For example, the string &#34;Lorem ipsum&#34; can be split into the following trigrams:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[&#34; Lo&#34;, &#34;Lor&#34;, &#34;ore&#34;, &#34;rem&#34;, &#34;em &#34;, &#34;m i&#34;, &#34; ip&#34;, &#34;ips&#34;, &#34;psu&#34;, &#34;sum&#34;, &#34;um &#34;, &#34;m  &#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Trigram search has some ability to work even with typos and misspellings in the query or text.&lt;/p&gt; &#xA;&lt;p&gt;Trigram support is currently available as part of the &lt;a href=&#34;http://www.postgresql.org/docs/current/static/pgtrgm.html&#34;&gt;pg_trgm extension&lt;/a&gt; that must be installed before this feature can be used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Website &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :kinda_spelled_like,&#xA;                  against: :name,&#xA;                  using: :trigram&#xA;end&#xA;&#xA;yahooo = Website.create! name: &#34;Yahooo!&#34;&#xA;yohoo = Website.create! name: &#34;Yohoo!&#34;&#xA;gogle = Website.create! name: &#34;Gogle&#34;&#xA;facebook = Website.create! name: &#34;Facebook&#34;&#xA;&#xA;Website.kinda_spelled_like(&#34;Yahoo!&#34;) # =&amp;gt; [yahooo, yohoo]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;:threshold&lt;/h5&gt; &#xA;&lt;p&gt;By default, trigram searches find records which have a similarity of at least 0.3 using pg_trgm&#39;s calculations. You may specify a custom threshold if you prefer. Higher numbers match more strictly, and thus return fewer results. Lower numbers match more permissively, letting in more results. Please note that setting a trigram threshold will force a table scan as the derived query uses the &lt;code&gt;similarity()&lt;/code&gt; function instead of the &lt;code&gt;%&lt;/code&gt; operator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Vegetable &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;&#xA;  pg_search_scope :strictly_spelled_like,&#xA;                  against: :name,&#xA;                  using: {&#xA;                    trigram: {&#xA;                      threshold: 0.5&#xA;                    }&#xA;                  }&#xA;&#xA;  pg_search_scope :roughly_spelled_like,&#xA;                  against: :name,&#xA;                  using: {&#xA;                    trigram: {&#xA;                      threshold: 0.1&#xA;                    }&#xA;                  }&#xA;end&#xA;&#xA;cauliflower = Vegetable.create! name: &#34;cauliflower&#34;&#xA;&#xA;Vegetable.roughly_spelled_like(&#34;couliflower&#34;) # =&amp;gt; [cauliflower]&#xA;Vegetable.strictly_spelled_like(&#34;couliflower&#34;) # =&amp;gt; [cauliflower]&#xA;&#xA;Vegetable.roughly_spelled_like(&#34;collyflower&#34;) # =&amp;gt; [cauliflower]&#xA;Vegetable.strictly_spelled_like(&#34;collyflower&#34;) # =&amp;gt; []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;:word_similarity&lt;/h5&gt; &#xA;&lt;p&gt;Allows you to match words in longer strings. By default, trigram searches use &lt;code&gt;%&lt;/code&gt; or &lt;code&gt;similarity()&lt;/code&gt; as a similarity value. Set &lt;code&gt;word_similarity&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; to opt for &lt;code&gt;&amp;lt;%&lt;/code&gt; and &lt;code&gt;word_similarity&lt;/code&gt; instead. This causes the trigram search to use the similarity of the query term and the word with greatest similarity.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Sentence &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;&#xA;  pg_search_scope :similarity_like,&#xA;                  against: :name,&#xA;                  using: {&#xA;                    trigram: {&#xA;                      word_similarity: true&#xA;                    }&#xA;                  }&#xA;&#xA;  pg_search_scope :word_similarity_like,&#xA;                  against: :name,&#xA;                  using: [:trigram]&#xA;end&#xA;&#xA;sentence = Sentence.create! name: &#34;Those are two words.&#34;&#xA;&#xA;Sentence.similarity_like(&#34;word&#34;) # =&amp;gt; []&#xA;Sentence.word_similarity_like(&#34;word&#34;) # =&amp;gt; [sentence]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Limiting Fields When Combining Features&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes when doing queries combining different features you might want to searching against only some of the fields with certain features. For example perhaps you want to only do a trigram search against the shorter fields so that you don&#39;t need to reduce the threshold excessively. You can specify which fields using the &#39;only&#39; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Image &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;&#xA;  pg_search_scope :combined_search,&#xA;                  against: [:file_name, :short_description, :long_description]&#xA;                  using: {&#xA;                    tsearch: { dictionary: &#39;english&#39; },&#xA;                    trigram: {&#xA;                      only: [:file_name, :short_description]&#xA;                    }&#xA;                  }&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can succesfully retrieve an Image with a file_name: &#39;image_foo.jpg&#39; and long_description: &#39;This description is so long that it would make a trigram search fail any reasonable threshold limit&#39; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Image.combined_search(&#39;reasonable&#39;) # found with tsearch&#xA;Image.combined_search(&#39;foo&#39;) # found with trigram&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Ignoring accent marks&lt;/h3&gt; &#xA;&lt;p&gt;Most of the time you will want to ignore accent marks when searching. This makes it possible to find words like &#34;piñata&#34; when searching with the query &#34;pinata&#34;. If you set a pg_search_scope to ignore accents, it will ignore accents in both the searchable text and the query terms.&lt;/p&gt; &#xA;&lt;p&gt;Ignoring accents uses the &lt;a href=&#34;http://www.postgresql.org/docs/current/static/unaccent.html&#34;&gt;unaccent extension&lt;/a&gt; that must be installed before this feature can be used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SpanishQuestion &amp;lt; ActiveRecord::Base&#xA;  include PgSearch::Model&#xA;  pg_search_scope :gringo_search,&#xA;                  against: :word,&#xA;                  ignoring: :accents&#xA;end&#xA;&#xA;what = SpanishQuestion.create(word: &#34;Qué&#34;)&#xA;how_many = SpanishQuestion.create(word: &#34;Cuánto&#34;)&#xA;how = SpanishQuestion.create(word: &#34;Cómo&#34;)&#xA;&#xA;SpanishQuestion.gringo_search(&#34;Que&#34;) # =&amp;gt; [what]&#xA;SpanishQuestion.gringo_search(&#34;Cüåñtô&#34;) # =&amp;gt; [how_many]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Advanced users may wish to add indexes for the expressions that pg_search generates. Unfortunately, the unaccent function supplied by this extension is not indexable (as of PostgreSQL 9.1). Thus, you may want to write your own wrapper function and use it instead. This can be configured by calling the following code, perhaps in an initializer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;PgSearch.unaccent_function = &#34;my_unaccent&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using tsvector columns&lt;/h3&gt; &#xA;&lt;p&gt;PostgreSQL allows you the ability to search against a column with type tsvector instead of using an expression; this speeds up searching dramatically as it offloads creation of the tsvector that the tsquery is evaluated against.&lt;/p&gt; &#xA;&lt;p&gt;To use this functionality you&#39;ll need to do a few things:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a column of type tsvector that you&#39;d like to search against. If you want to search using multiple search methods, for example tsearch and dmetaphone, you&#39;ll need a column for each.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a trigger function that will update the column(s) using the expression appropriate for that type of search. See: &lt;a href=&#34;http://www.postgresql.org/docs/current/static/textsearch-features.html#TEXTSEARCH-UPDATE-TRIGGERS&#34;&gt;the PostgreSQL documentation for text search triggers&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Should you have any pre-existing data in the table, update the newly-created tsvector columns with the expression that your trigger function uses.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add the option to pg_search_scope, e.g:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pg_search_scope :fast_content_search,&#xA;                against: :content,&#xA;                using: {&#xA;                  dmetaphone: {&#xA;                    tsvector_column: &#39;tsvector_content_dmetaphone&#39;&#xA;                  },&#xA;                  tsearch: {&#xA;                    dictionary: &#39;english&#39;,&#xA;                    tsvector_column: &#39;tsvector_content_tsearch&#39;&#xA;                  },&#xA;                  trigram: {} # trigram does not use tsvectors&#xA;                }&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please note that the :against column is only used when the tsvector_column is not present for the search type.&lt;/p&gt; &#xA;&lt;h4&gt;Combining multiple tsvectors&lt;/h4&gt; &#xA;&lt;p&gt;It&#39;s possible to search against more than one tsvector at a time. This could be useful if you want to maintain multiple search scopes but do not want to maintain separate tsvectors for each scope. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pg_search_scope :search_title,&#xA;                against: :title,&#xA;                using: {&#xA;                  tsearch: {&#xA;                    tsvector_column: &#34;title_tsvector&#34;&#xA;                  }&#xA;                }&#xA;&#xA;pg_search_scope :search_body,&#xA;                against: :body,&#xA;                using: {&#xA;                  tsearch: {&#xA;                    tsvector_column: &#34;body_tsvector&#34;&#xA;                  }&#xA;                }&#xA;&#xA;pg_search_scope :search_title_and_body,&#xA;                against: [:title, :body],&#xA;                using: {&#xA;                  tsearch: {&#xA;                    tsvector_column: [&#34;title_tsvector&#34;, &#34;body_tsvector&#34;]&#xA;                  }&#xA;                }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuring ranking and ordering&lt;/h3&gt; &#xA;&lt;h4&gt;:ranked_by (Choosing a ranking algorithm)&lt;/h4&gt; &#xA;&lt;p&gt;By default, pg_search ranks results based on the :tsearch similarity between the searchable text and the query. To use a different ranking algorithm, you can pass a :ranked_by option to pg_search_scope.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pg_search_scope :search_by_tsearch_but_rank_by_trigram,&#xA;                against: :title,&#xA;                using: [:tsearch],&#xA;                ranked_by: &#34;:trigram&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that :ranked_by using a String to represent the ranking expression. This allows for more complex possibilities. Strings like &#34;:tsearch&#34;, &#34;:trigram&#34;, and &#34;:dmetaphone&#34; are automatically expanded into the appropriate SQL expressions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Weighted ranking to balance multiple approaches&#xA;ranked_by: &#34;:dmetaphone + (0.25 * :trigram)&#34;&#xA;&#xA;# A more complex example, where books.num_pages is an integer column in the table itself&#xA;ranked_by: &#34;(books.num_pages * :trigram) + (:tsearch / 2.0)&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;:order_within_rank (Breaking ties)&lt;/h4&gt; &#xA;&lt;p&gt;PostgreSQL does not guarantee a consistent order when multiple records have the same value in the ORDER BY clause. This can cause trouble with pagination. Imagine a case where 12 records all have the same ranking value. If you use a pagination library such as &lt;a href=&#34;https://github.com/amatsuda/kaminari&#34;&gt;kaminari&lt;/a&gt; or &lt;a href=&#34;https://github.com/mislav/will_paginate&#34;&gt;will_paginate&lt;/a&gt; to return results in pages of 10, then you would expect to see 10 of the records on page 1, and the remaining 2 records at the top of the next page, ahead of lower-ranked results.&lt;/p&gt; &#xA;&lt;p&gt;But since there is no consistent ordering, PostgreSQL might choose to rearrange the order of those 12 records between different SQL statements. You might end up getting some of the same records from page 1 on page 2 as well, and likewise there may be records that don&#39;t show up at all.&lt;/p&gt; &#xA;&lt;p&gt;pg_search fixes this problem by adding a second expression to the ORDER BY clause, after the :ranked_by expression explained above. By default, the tiebreaker order is ascending by id.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ORDER BY [complicated :ranked_by expression...], id ASC&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This might not be desirable for your application, especially if you do not want old records to outrank new records. By passing an :order_within_rank, you can specify an alternate tiebreaker expression. A common example would be descending by updated_at, to rank the most recently updated records first.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;pg_search_scope :search_and_break_ties_by_latest_update,&#xA;                against: [:title, :content],&#xA;                order_within_rank: &#34;blog_posts.updated_at DESC&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;PgSearch#pg_search_rank (Reading a record&#39;s rank as a Float)&lt;/h4&gt; &#xA;&lt;p&gt;It may be useful or interesting to see the rank of a particular record. This can be helpful for debugging why one record outranks another. You could also use it to show some sort of relevancy value to end users of an application.&lt;/p&gt; &#xA;&lt;p&gt;To retrieve the rank, call &lt;code&gt;.with_pg_search_rank&lt;/code&gt; on a scope, and then call &lt;code&gt;.pg_search_rank&lt;/code&gt; on a returned record.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;shirt_brands = ShirtBrand.search_by_name(&#34;Penguin&#34;).with_pg_search_rank&#xA;shirt_brands[0].pg_search_rank #=&amp;gt; 0.0759909&#xA;shirt_brands[1].pg_search_rank #=&amp;gt; 0.0607927&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Search rank and chained scopes&lt;/h4&gt; &#xA;&lt;p&gt;Each PgSearch scope generates a named subquery for the search rank. If you chain multiple scopes then PgSearch will generate a ranking query for each scope, so the ranking queries must have unique names. If you need to reference the ranking query (e.g. in a GROUP BY clause) you can regenerate the subquery name with the &lt;code&gt;PgScope::Configuration.alias&lt;/code&gt; method by passing the name of the queried table.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;shirt_brands = ShirtBrand.search_by_name(&#34;Penguin&#34;)&#xA;  .joins(:shirt_sizes)&#xA;  .group(&#34;shirt_brands.id, #{PgSearch::Configuration.alias(&#39;shirt_brands&#39;)}.rank&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;ATTRIBUTIONS&lt;/h2&gt; &#xA;&lt;p&gt;PgSearch would not have been possible without inspiration from texticle (now renamed &lt;a href=&#34;https://github.com/textacular/textacular&#34;&gt;textacular&lt;/a&gt;). Thanks to &lt;a href=&#34;http://tenderlovemaking.com/&#34;&gt;Aaron Patterson&lt;/a&gt; for the original version and to Casebook PBC (&lt;a href=&#34;https://www.casebook.net&#34;&gt;https://www.casebook.net&lt;/a&gt;) for gifting the community with it!&lt;/p&gt; &#xA;&lt;h2&gt;CONTRIBUTIONS AND FEEDBACK&lt;/h2&gt; &#xA;&lt;p&gt;Please read our &lt;a href=&#34;https://github.com/Casecommons/pg_search/raw/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We also have a &lt;a href=&#34;http://groups.google.com/group/casecommons-dev&#34;&gt;Google Group&lt;/a&gt; for discussing pg_search and other Casebook PBC open source projects.&lt;/p&gt; &#xA;&lt;h2&gt;LICENSE&lt;/h2&gt; &#xA;&lt;p&gt;Copyright © 2010–2022 &lt;a href=&#34;http://www.casebook.net&#34;&gt;Casebook PBC&lt;/a&gt;. Licensed under the MIT license, see &lt;a href=&#34;https://raw.githubusercontent.com/Casecommons/pg_search/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file.&lt;/p&gt;</summary>
  </entry>
</feed>