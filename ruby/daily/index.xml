<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-04T01:35:12Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nsarno/knock</title>
    <updated>2024-03-04T01:35:12Z</updated>
    <id>tag:github.com,2024-03-04:/nsarno/knock</id>
    <link href="https://github.com/nsarno/knock" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Seamless JWT authentication for Rails API&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;DISCLAIMER&lt;/h2&gt; &#xA;&lt;p&gt;This project is not being maintained and I don&#39;t recommend using it in its current form. As an alternative, I recommend using the &lt;a href=&#34;https://github.com/jwt/ruby-jwt&#34;&gt;jwt&lt;/a&gt; gem directly.&lt;/p&gt; &#xA;&lt;h1&gt;knock&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://badge.fury.io/rb/knock&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/knock.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/nsarno/knock&#34;&gt;&lt;img src=&#34;https://travis-ci.org/nsarno/knock.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/nsarno/knock&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/nsarno/knock/badges/gpa.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Seamless JWT authentication for Rails API&lt;/p&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;Knock is an authentication solution for Rails API-only application based on JSON Web Tokens.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;knock&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;p&gt;Knock makes one assumption about your user model:&lt;/p&gt; &#xA;&lt;p&gt;It must have an &lt;code&gt;authenticate&lt;/code&gt; method, similar to the one added by &lt;a href=&#34;http://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html#method-i-has_secure_password&#34;&gt;has_secure_password&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ActiveRecord::Base&#xA;  has_secure_password&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using &lt;code&gt;has_secure_password&lt;/code&gt; is recommended, but you don&#39;t have to as long as your user model implements an &lt;code&gt;authenticate&lt;/code&gt; instance method with the same behavior.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;Include the &lt;code&gt;Knock::Authenticable&lt;/code&gt; module in your &lt;code&gt;ApplicationController&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::API&#xA;  include Knock::Authenticable&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now protect your resources by calling &lt;code&gt;authenticate_user&lt;/code&gt; as a before_action inside your controllers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SecuredController &amp;lt; ApplicationController&#xA;  before_action :authenticate_user&#xA;&#xA;  def index&#xA;    # etc...&#xA;  end&#xA;&#xA;  # etc...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can access the current user in your controller with &lt;code&gt;current_user&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If no valid token is passed with the request, Knock will respond with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;head :unauthorized&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can modify this behaviour by overriding &lt;code&gt;unauthorized_entity&lt;/code&gt; in your controller.&lt;/p&gt; &#xA;&lt;p&gt;You also have access directly to &lt;code&gt;current_user&lt;/code&gt; which will try to authenticate or return &lt;code&gt;nil&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def index&#xA;  if current_user&#xA;    # do something&#xA;  else&#xA;    # do something else&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: the &lt;code&gt;authenticate_user&lt;/code&gt; method uses the &lt;code&gt;current_user&lt;/code&gt; method. Overwriting &lt;code&gt;current_user&lt;/code&gt; may cause unexpected behaviour.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can do the exact same thing for any entity. E.g. for &lt;code&gt;Admin&lt;/code&gt;, use &lt;code&gt;authenticate_admin&lt;/code&gt; and &lt;code&gt;current_admin&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re using a namespaced model, Knock won&#39;t be able to infer it automatically from the method name. Instead you can use &lt;code&gt;authenticate_for&lt;/code&gt; directly like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include Knock::Authenticable&#xA;&#xA;  private&#xA;&#xA;  def authenticate_v1_user&#xA;    authenticate_for V1::User&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SecuredController &amp;lt; ApplicationController&#xA;  before_action :authenticate_v1_user&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you get the current user by calling &lt;code&gt;current_v1_user&lt;/code&gt; instead of &lt;code&gt;current_user&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;h4&gt;In the entity model&lt;/h4&gt; &#xA;&lt;p&gt;The entity model (e.g. &lt;code&gt;User&lt;/code&gt;) can implement specific methods to provide customization over different parts of the authentication process.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Find the entity when creating the token (when signing in)&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default, Knock tries to find the entity by email. If you want to modify this behaviour, implement within your entity model a class method &lt;code&gt;from_token_request&lt;/code&gt; that takes the request in argument.&lt;/p&gt; &#xA;&lt;p&gt;E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ActiveRecord::Base&#xA;  def self.from_token_request request&#xA;    # Returns a valid user, `nil` or raise `Knock.not_found_exception_class_name`&#xA;    # e.g.&#xA;    #   email = request.params[&#34;auth&#34;] &amp;amp;&amp;amp; request.params[&#34;auth&#34;][&#34;email&#34;]&#xA;    #   self.find_by email: email&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Find the authenticated entity from the token payload (when authenticating a request)&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default, Knock assumes the payload as a subject (&lt;code&gt;sub&lt;/code&gt;) claim containing the entity&#39;s id and calls &lt;code&gt;find&lt;/code&gt; on the model. If you want to modify this behaviour, implement within your entity model a class method &lt;code&gt;from_token_payload&lt;/code&gt; that takes the payload in argument.&lt;/p&gt; &#xA;&lt;p&gt;E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ActiveRecord::Base&#xA;  def self.from_token_payload payload&#xA;    # Returns a valid user, `nil` or raise&#xA;    # e.g.&#xA;    #   self.find payload[&#34;sub&#34;]&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Modify the token payload&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default the token payload contains the entity&#39;s id inside the subject (&lt;code&gt;sub&lt;/code&gt;) claim. If you want to modify this behaviour, implement within your entity model an instance method &lt;code&gt;to_token_payload&lt;/code&gt; that returns a hash representing the payload.&lt;/p&gt; &#xA;&lt;p&gt;E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ActiveRecord::Base&#xA;  def to_token_payload&#xA;    # Returns the payload as a hash&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Token Lifetime&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default the generated tokens will be valid, after generated, for 1 day. You can change it in the Knock configuration file (config/knock.rb), setting the desired lifetime:&lt;/p&gt; &#xA;&lt;p&gt;E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  Knock.token_lifetime = 3.hours&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are generating tokens for more than one entity, you can pass each lifetime in a hash, using the entities class names as keys, like:&lt;/p&gt; &#xA;&lt;p&gt;E.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  # How long before a token is expired. If nil is provided,&#xA;  # token will last forever.&#xA;  Knock.token_lifetime = {&#xA;    user: 1.day&#xA;    admin: 30.minutes&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;In the initializer&lt;/h4&gt; &#xA;&lt;p&gt;Read &lt;a href=&#34;https://github.com/nsarno/knock/raw/master/lib/knock.rb&#34;&gt;lib/knock.rb&lt;/a&gt; to learn about all the possible configuration options and their default values.&lt;/p&gt; &#xA;&lt;p&gt;You can create an initializer like in the example below:&lt;/p&gt; &#xA;&lt;p&gt;Inside &lt;code&gt;config/initializers/knock.rb&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Knock.setup do |config|&#xA;  config.token_lifetime = 1.hour&#xA;&#xA;  # For Auth0&#xA;  config.token_audience = -&amp;gt; { Rails.application.secrets.auth0_client_id }&#xA;  config.token_secret_signature_key = -&amp;gt; { JWT.base64url_decode Rails.application.secrets.auth0_client_secret }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Authenticating from a web or mobile application&lt;/h3&gt; &#xA;&lt;p&gt;Example request to get a token from your API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;POST /user_token&#xA;{&#34;auth&#34;: {&#34;email&#34;: &#34;foo@bar.com&#34;, &#34;password&#34;: &#34;secret&#34;}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example response from the API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;201 Created&#xA;{&#34;jwt&#34;: &#34;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To make an authenticated request to your API, you need to pass the token via the request header:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&#xA;GET /my_resources&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Knock responds with a &lt;code&gt;404 Not Found&lt;/code&gt; when the user cannot be found or the password is invalid. This is a security best practice to avoid giving away information about the existence or not of a particular user.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NB:&lt;/strong&gt; HTTPS should always be enabled when sending a password or token in your request.&lt;/p&gt; &#xA;&lt;h3&gt;Authenticated tests&lt;/h3&gt; &#xA;&lt;p&gt;To authenticate within your tests:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a valid token&lt;/li&gt; &#xA; &lt;li&gt;Pass it in your request&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SecuredResourcesControllerTest &amp;lt; ActionDispatch::IntegrationTest&#xA;  def authenticated_header&#xA;    token = Knock::AuthToken.new(payload: { sub: users(:one).id }).token&#xA;&#xA;    {&#xA;      &#39;Authorization&#39;: &#34;Bearer #{token}&#34;&#xA;    }&#xA;  end&#xA;&#xA;  it &#39;responds successfully&#39; do&#xA;    get secured_resources_url, headers: authenticated_header&#xA;&#xA;    assert_response :success&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Without ActiveRecord&lt;/h4&gt; &#xA;&lt;p&gt;If no ActiveRecord is used, then you will need to specify what Exception will be used when the user is not found with the given credentials.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Knock.setup do |config|&#xA;&#xA;  # Exception Class&#xA;  # ---------------&#xA;  #&#xA;  # Configure the Exception to be used (raised and rescued) for User Not Found.&#xA;  # note: change this if ActiveRecord is not being used.&#xA;  #&#xA;  # Default:&#xA;  config.not_found_exception_class_name = &#39;MyCustomException&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Algorithms&lt;/h3&gt; &#xA;&lt;p&gt;The JWT spec supports different kind of cryptographic signing algorithms. You can set &lt;code&gt;token_signature_algorithm&lt;/code&gt; to use the one you want in the initializer or do nothing and use the default one (HS256).&lt;/p&gt; &#xA;&lt;p&gt;You can specify any of the algorithms supported by the &lt;a href=&#34;https://github.com/jwt/ruby-jwt&#34;&gt;jwt&lt;/a&gt; gem.&lt;/p&gt; &#xA;&lt;p&gt;If the algorithm you use requires a public key, you also need to set &lt;code&gt;token_public_key&lt;/code&gt; in the initializer.&lt;/p&gt; &#xA;&lt;h2&gt;CORS&lt;/h2&gt; &#xA;&lt;p&gt;To enable cross-origin resource sharing, check out the &lt;a href=&#34;https://github.com/cyu/rack-cors&#34;&gt;rack-cors&lt;/a&gt; gem.&lt;/p&gt; &#xA;&lt;h2&gt;Related links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://auth0.com/blog/2014/01/27/ten-things-you-should-know-about-tokens-and-cookies/&#34;&gt;10 things you should know about tokens&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork it ( &lt;a href=&#34;https://github.com/nsarno/knock/fork&#34;&gt;https://github.com/nsarno/knock/fork&lt;/a&gt; )&lt;/li&gt; &#xA; &lt;li&gt;Create your feature branch (&lt;code&gt;git checkout -b my-new-feature&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Commit your changes (&lt;code&gt;git commit -am &#39;Add some feature&#39;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Push to the branch (&lt;code&gt;git push origin my-new-feature&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Create a new Pull Request&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>human-se/git-demo-app-2023-08fall</title>
    <updated>2024-03-04T01:35:12Z</updated>
    <id>tag:github.com,2024-03-04:/human-se/git-demo-app-2023-08fall</id>
    <link href="https://github.com/human-se/git-demo-app-2023-08fall" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;README&lt;/h1&gt; &#xA;&lt;p&gt;This README would normally document whatever steps are necessary to get the application up and running.&lt;/p&gt; &#xA;&lt;p&gt;Things you may want to cover:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Ruby version&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;System dependencies&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Configuration&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Database creation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Database initialization&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;How to run the test suite&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Services (job queues, cache servers, search engines, etc.)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Deployment instructions&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;...&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>Effilab/bing_ads_ruby_sdk</title>
    <updated>2024-03-04T01:35:12Z</updated>
    <id>tag:github.com,2024-03-04:/Effilab/bing_ads_ruby_sdk</id>
    <link href="https://github.com/Effilab/bing_ads_ruby_sdk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ruby SDK for Bing Ads API (src: https://github.com/Effilab/bing_ads_ruby_sdk)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;BingAdsRubySdk&lt;/h1&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add the following to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;bing_ads_ruby_sdk&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bundle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or install it yourself as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install bing_ads_ruby_sdk&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Getting Started&lt;/h3&gt; &#xA;&lt;p&gt;In order to use Microsoft&#39;s advertising API you need to &lt;a href=&#34;https://learn.microsoft.com/en-us/advertising/guides/get-started?view=bingads-13&#34;&gt;get your API credentials from MS&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;From there gem handles OAuth token generation. By default, there is only one store in the gem to store the oauth token. It&#39;s a file system based store. You can create one yourself to store credentials in a database or wherever you desire. The store class must implement &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;write(data)&lt;/code&gt; instance methods.&lt;/p&gt; &#xA;&lt;p&gt;To get your token, run the &lt;code&gt;bing_token:get&lt;/code&gt; rake task, then follow the prompts. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bin/rake bing_token:get[&#39;credentials.json&#39;,YOUR_DEVELOPER_TOKEN,YOUR_CLIENT_ID,YOUR_CLIENT_SECRET]&#xA;&#xA;# For example:&#xA;bin/rake bing_token:get[&#39;credentials.json&#39;,ABC1234,3431b6d0-a2ac-48e1-a1c5-1d0b82f3187f,SECRETVALUEHERE]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then to use the api:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;store = ::BingAdsRubySdk::OAuth2::FsStore.new(&#39;my_token.json&#39;)&#xA;api = BingAdsRubySdk::Api.new(&#xA;  oauth_store: store,&#xA;  developer_token: &#39;your_dev_token&#39;,&#xA;  client_id: &#39;your_bing_client_id&#39;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;BingAdsRubySdk.configure do |conf|&#xA;  conf.log = true&#xA;  conf.logger.level = Logger::DEBUG&#xA;  conf.pretty_print_xml = true&#xA;  # to filter sensitive data before logging&#xA;  conf.filters = [&#34;AuthenticationToken&#34;, &#34;DeveloperToken&#34;]&#xA;  &#xA;  # Optionally allow ActiveSupport::Notifications to be emitted by Excon.&#xA;  # These notifications can then be sent on to your profiling system&#xA;  # conf.instrumentor = ActiveSupport::Notifications &#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Account creation and management&lt;/h3&gt; &#xA;&lt;p&gt;If you want to create an account using the API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;api.customer_management.signup_customer(&#xA;  parent_customer_id: parent_customer_id,&#xA;  customer: customer_data, # a hash with your params&#xA;  account: account_data.merge(&#34;@type&#34; =&amp;gt; &#34;AdvertiserAccount&#34;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Otherwise you can &lt;a href=&#34;https://learn.microsoft.com/en-us/advertising/guides/get-started?view=bingads-13#get-ids&#34;&gt;use existing account IDs as explained here&lt;/a&gt;, or use the &lt;code&gt;customer_management&lt;/code&gt; endpoint as explained above.&lt;/p&gt; &#xA;&lt;p&gt;Once you have your MS Advertising customer and account ids:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;api.set_customer(customer_id: customer_id, account_id: account_id )&#xA;&#xA;api.campaign_management.get_campaigns_by_account_id(account_id: account_id)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll see services like &lt;code&gt;customer_management&lt;/code&gt; implement some methods, but not all the ones available in the API.&lt;/p&gt; &#xA;&lt;p&gt;The methods implemented contain additional code to ease data manipulation but any endpoint can be reached using &lt;code&gt;call&lt;/code&gt; on a service.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@cm = api.customer_management&#xA;&#xA;@cm.call(:find_accounts_or_customers_info, filter: &#39;name&#39;, top_n: 1)&#xA;# =&amp;gt; { account_info_with_customer_data: { account_info_with_customer_data: [{ customer_id: &#34;250364751&#34;, :&#xA;&#xA;# VS method dedicated to extract data&#xA;&#xA;@cm.find_accounts_or_customers_info(filter: &#39;name&#39;, top_n: 1)&#xA;# =&amp;gt; [{ customer_id: &#34;250364731&#34; ...&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reporting&lt;/h3&gt; &#xA;&lt;p&gt;You can generate the report following the &lt;a href=&#34;https://learn.microsoft.com/en-us/advertising/guides/request-download-report?view=bingads-13&#34;&gt;process recommended by Microsoft&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;p&gt;That would mean coding something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;submission_response = api.reporting&#xA;  .call(:submit_generate_report,&#xA;     account_performance_report_request: {&#xA;       exclude_report_header: true,&#xA;       exclude_report_footer: true,&#xA;       exclude_column_headers: true,&#xA;       format: &#34;Csv&#34;,&#xA;       aggregation: &#34;Daily&#34;,&#xA;       filter: nil,&#xA;       columns: [&#xA;         {&#xA;           account_performance_report_column: &#34;TimePeriod&#34;&#xA;         },&#xA;         {&#xA;           account_performance_report_column: &#34;AccountId&#34;&#xA;         },&#xA;         {&#xA;           account_performance_report_column: &#34;DeviceType&#34;&#xA;         },&#xA;         {&#xA;           account_performance_report_column: &#34;Clicks&#34;&#xA;         }&#xA;       ],&#xA;       scope: {&#xA;         # Your account ID here&#xA;         account_ids: [{long: 1000000}]&#xA;       },&#xA;       time: {&#xA;         custom_date_range_start: {&#xA;           day: 7,&#xA;           month: 5,&#xA;           year: 2023&#xA;         },&#xA;         custom_date_range_end: {&#xA;           day: 8,&#xA;           month: 5,&#xA;           year: 2023&#xA;         }&#xA;       }&#xA;     }&#xA;  )&#xA;&#xA;report_request_id = submission_response.fetch(:report_request_id)&#xA;&#xA;# Then you can poll the API to check the status of the report generation&#xA;poll_response = api.reporting.call(:poll_generate_report, report_request_id: report_request_id)&#xA;&#xA;# When it is ready you can download it&#xA;report_request_status = poll_response.fetch(:report_request_status)&#xA;&#xA;report_generation_status = report_request_status[:status].downcase.to_sym &#xA;# =&amp;gt; One of these: :pending, :error, :success&#xA;&#xA;if report_generation_status == :success&#xA;  url = report_request_status[:report_download_url]&#xA;  # =&amp;gt; The URL to download the report (with the library of your choice)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;🛈 Report request example &lt;a href=&#34;https://learn.microsoft.com/en-us/advertising/reporting-service/accountperformancereportrequest?view=bingads-13&#34;&gt;here in the API docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;🛈 Hint: convert parameter names from PascalCase to snake_case when consulting the API docs&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;You can run &lt;code&gt;bin/console&lt;/code&gt; for an interactive prompt that will allow you to experiment.&lt;/p&gt; &#xA;&lt;p&gt;To release a new version, update the version number in &lt;code&gt;version.rb&lt;/code&gt;, and then run &lt;code&gt;bundle exec rake release&lt;/code&gt;, which will create a git tag for the version, push git commits and tags, and push the &lt;code&gt;.gem&lt;/code&gt; file to &lt;a href=&#34;https://rubygems.org&#34;&gt;rubygems.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Updating to a new Bing API version&lt;/h3&gt; &#xA;&lt;p&gt;Bing regularly releases new versions of the API and removes support for old versions. When you want to support a new version of the API, here are some of the things that need to be changed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Go to &lt;a href=&#34;https://docs.microsoft.com/en-us/bingads/guides/migration-guide&#34;&gt;https://docs.microsoft.com/en-us/bingads/guides/migration-guide&lt;/a&gt; to see what has changed&lt;/li&gt; &#xA; &lt;li&gt;Set the default SDK version in lib/bing_ads_ruby_sdk/version.rb&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Specs&lt;/h3&gt; &#xA;&lt;p&gt;After checking out the repo, run &lt;code&gt;bin/setup&lt;/code&gt; to install dependencies. Then, run &lt;code&gt;rake spec&lt;/code&gt; to run unit tests.&lt;/p&gt; &#xA;&lt;p&gt;If you want to run the integration tests they are in the &lt;code&gt;spec/examples/&lt;/code&gt; folders. Remember that these will create real accounts and entities in Microsoft Advertising so take care to check your account spending settings.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s how to run the tests:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Make sure you have the token as described above&lt;/li&gt; &#xA; &lt;li&gt;Put your Client ID, Developer Token, and Parent Customer ID in the methods with the same names in &lt;code&gt;spec/examples/examples.rb&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run the specs in order, for example: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;bundle exec rspec spec/examples/1_...&lt;/code&gt;, at the end of the spec there will be a message at the end about copying an ID into &lt;code&gt;spec/examples/examples.rb&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;bundle exec rspec spec/examples/2_...&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;keep repeating until you have run all the specs in &lt;code&gt;spec/examples&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Bug reports and pull requests are welcome on GitHub at &lt;a href=&#34;https://github.com/Effilab/bing_ads_ruby_sdk&#34;&gt;https://github.com/Effilab/bing_ads_ruby_sdk&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;http://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>