<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-13T01:48:27Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cloudfoundry/cloud_controller_ng</title>
    <updated>2023-06-13T01:48:27Z</updated>
    <id>tag:github.com,2023-06-13:/cloudfoundry/cloud_controller_ng</id>
    <link href="https://github.com/cloudfoundry/cloud_controller_ng" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Cloud Foundry Cloud Controller&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://codeclimate.com/github/cloudfoundry/cloud_controller_ng&#34;&gt;&lt;img src=&#34;https://api.codeclimate.com/v1/badges/aa47fb93c59ced5fcc4f/maintainability&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/cloudfoundry/cloud_controller_ng&#34;&gt;&lt;img src=&#34;https://api.codeclimate.com/v1/badges/aa47fb93c59ced5fcc4f/test_coverage&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cloudfoundry.slack.com/messages/capi/&#34;&gt;&lt;img src=&#34;https://slack.cloudfoundry.org/badge.svg?sanitize=true&#34; alt=&#34;slack.cloudfoundry.org&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Welcome to the Cloud Controller&lt;/h1&gt; &#xA;&lt;h2&gt;Helpful Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://v3-apidocs.cloudfoundry.org&#34;&gt;V3 API Docs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://apidocs.cloudfoundry.org&#34;&gt;V2 API Docs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ci.cake.capi.land/&#34;&gt;Continuous Integration Pipelines&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cloudfoundry/cloud_controller_ng/wiki/Notes-on-V3-Architecture&#34;&gt;Notes on V3 Architecture&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cloudfoundry/capi-release&#34;&gt;capi-release&lt;/a&gt; - The bosh release used to deploy cloud controller&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cloudfoundry/cf-for-k8s&#34;&gt;cf-for-k8s&lt;/a&gt; - How Cloud Foundry (including Cloud Controller) is deployed against Kubernetes&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cloudfoundry/capi-k8s-release&#34;&gt;capi-k8s-release&lt;/a&gt; - The parts of cf-for-k8s that are specific to CF API (including Cloud Controller)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Components&lt;/h2&gt; &#xA;&lt;h3&gt;Cloud Controller&lt;/h3&gt; &#xA;&lt;p&gt;The Cloud Controller provides REST API endpoints to create and manage apps, services, user roles, and more!&lt;/p&gt; &#xA;&lt;h3&gt;Database&lt;/h3&gt; &#xA;&lt;p&gt;The Cloud Controller supports Postgres and Mysql.&lt;/p&gt; &#xA;&lt;h3&gt;Blobstore&lt;/h3&gt; &#xA;&lt;p&gt;The Cloud Controller manages a blobstore for:&lt;/p&gt; &#xA;&lt;p&gt;All Platforms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Resource cache: During package upload resource matching, Cloud Controller will only upload files it doesn&#39;t already have in this cache.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When deployed via capi-release only:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;App packages: Unstaged files for an application&lt;/li&gt; &#xA; &lt;li&gt;Droplets: An executable containing an app and its runtime dependencies&lt;/li&gt; &#xA; &lt;li&gt;Buildpacks: Set of programs that transform packages into droplets&lt;/li&gt; &#xA; &lt;li&gt;Buildpack cache: Cached dependencies and build artifacts to speed up future staging&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Cloud Controller currently supports &lt;a href=&#34;http://www.webdav.org/&#34;&gt;webdav&lt;/a&gt; and the following &lt;a href=&#34;http://fog.io&#34;&gt;fog&lt;/a&gt; connectors:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Alibaba Cloud (Experimental)&lt;/li&gt; &#xA; &lt;li&gt;Azure&lt;/li&gt; &#xA; &lt;li&gt;Openstack&lt;/li&gt; &#xA; &lt;li&gt;Local (NFS)&lt;/li&gt; &#xA; &lt;li&gt;Google&lt;/li&gt; &#xA; &lt;li&gt;AWS&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Runtime&lt;/h3&gt; &#xA;&lt;p&gt;The Cloud Controller on VMs uses &lt;a href=&#34;https://github.com/cloudfoundry/diego-release&#34;&gt;Diego&lt;/a&gt; to stage and run apps and tasks. See &lt;a href=&#34;https://github.com/cloudfoundry/diego-design-notes&#34;&gt;Diego Design Notes&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;When deployed on Kubernetes, Cloud Controller uses &lt;a href=&#34;https://github.com/pivotal/kpack&#34;&gt;kpack&lt;/a&gt; to build images from source with &lt;a href=&#34;https://buildpacks.io&#34;&gt;Cloud Native Buildpacks&lt;/a&gt; and &lt;a href=&#34;https://github.com/cloudfoundry-incubator/eirini&#34;&gt;Eirini&lt;/a&gt; to run apps directly on the Kubernetes cluster.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please read the &lt;a href=&#34;https://github.com/cloudfoundry/cloud_controller_ng/raw/main/CONTRIBUTING.md&#34;&gt;contributors&#39; guide&lt;/a&gt; and the &lt;a href=&#34;https://cloudfoundry.org/code-of-conduct/&#34;&gt;Cloud Foundry Code of Conduct&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Unit Tests&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;TLDR:&lt;/strong&gt; Always run &lt;code&gt;bundle exec rake&lt;/code&gt; before committing&lt;/p&gt; &#xA;&lt;p&gt;To maintain a consistent and effective approach to testing, please refer to &lt;a href=&#34;https://raw.githubusercontent.com/cloudfoundry/cloud_controller_ng/main/spec/README.md&#34;&gt;the spec README&lt;/a&gt; and keep it up to date, documenting the purpose of the various types of tests.&lt;/p&gt; &#xA;&lt;p&gt;By default &lt;code&gt;rspec&lt;/code&gt; will randomly pick between postgres and mysql.&lt;/p&gt; &#xA;&lt;p&gt;If postgres is not running on your OSX machine, you can start up a server by doing the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;brew services start postgresql&#xA;createuser -s postgres&#xA;DB=postgres rake db:create&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It will try to connect to those databases with the following connection string:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;postgres: &lt;code&gt;postgres://postgres@localhost:5432/cc_test&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;mysql: &lt;code&gt;mysql2://root:password@localhost:3306/cc_test&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To specify a custom username, password, host, or port for either database type, you can override the default connection string prefix (the part before the &lt;code&gt;cc_test&lt;/code&gt; database name) by setting the &lt;code&gt;MYSQL_CONNECTION_PREFIX&lt;/code&gt; and/or &lt;code&gt;POSTGRES_CONNECTION_PREFIX&lt;/code&gt; variables. Alternatively, to override the full connection string, including the database name, you can set the &lt;code&gt;DB_CONNECTION_STRING&lt;/code&gt; environment variable. This will restrict you to only running tests in serial, however.&lt;/p&gt; &#xA;&lt;p&gt;For example, to run unit tests in parallel with a custom mysql username and password, you could execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;MYSQL_CONNECTION_PREFIX=mysql2://custom_user:custom_password@localhost:3306 bundle exec rake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following are examples of completely fully overriding the database connection string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;DB_CONNECTION_STRING=&#34;postgres://postgres@localhost:5432/cc_test&#34; DB=postgres rake spec:serial&#xA;DB_CONNECTION_STRING=&#34;mysql2://root:password@localhost:3306/cc_test&#34; DB=mysql rake spec:serial&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are running the integration specs (which are included in the full rake), and you are specifying &lt;code&gt;DB_CONNECTION_STRING&lt;/code&gt;, you will also need to have a second test database with &lt;code&gt;_integration_cc&lt;/code&gt; as the name suffix.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you are using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;DB_CONNECTION_STRING=&#34;postgres://postgres@localhost:5432/cc_test&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will also need a database called:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;`cc_test_integration_cc`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rake db:create&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will create the above database when the &lt;code&gt;DB&lt;/code&gt; environment variable is set to postgres or mysql. You should run this before running rake in order to ensure that the &lt;code&gt;cc_test&lt;/code&gt; database exists.&lt;/p&gt; &#xA;&lt;h4&gt;Running tests on a single file&lt;/h4&gt; &#xA;&lt;p&gt;The development team typically will run the specs to a single file as (e.g.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rspec spec/controllers/runtime/users_controller_spec.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Running all the unit tests&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake spec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that this will run all tests in parallel by default. If you are setting a custom &lt;code&gt;DB_CONNECTION_STRING&lt;/code&gt;, you will need to run the tests in serial instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake spec:serial&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To be able to run the unit tests in parallel and still use custom connection strings, use the &lt;code&gt;MYSQL_CONNECTION_PREFIX&lt;/code&gt; and &lt;code&gt;POSTGRES_CONNECTION_PREFIX&lt;/code&gt; environment variables described above.&lt;/p&gt; &#xA;&lt;h4&gt;Running static analysis&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rubocop&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Running both unit tests and rubocop&lt;/h4&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;bundle exec rake&lt;/code&gt; will run the unit tests first, and then &lt;code&gt;rubocop&lt;/code&gt; if they pass. To run &lt;code&gt;rubocop&lt;/code&gt; first, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;RUBOCOP_FIRST=1 bundle exec rake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Logs&lt;/h2&gt; &#xA;&lt;p&gt;Cloud Controller uses &lt;a href=&#34;http://github.com/cloudfoundry/steno&#34;&gt;Steno&lt;/a&gt; to manage its logs. Each log entry includes a &#34;source&#34; field to designate which module in the code the entry originates from. Some of the possible sources are &#39;cc.app&#39;, &#39;cc.app_stager&#39;, and &#39;cc.healthmanager.client&#39;.&lt;/p&gt; &#xA;&lt;p&gt;Here are some use cases for the different log levels:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;error&lt;/code&gt; - the CC received a malformed HTTP request, or a request for a non-existent droplet&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;warn&lt;/code&gt; - the CC failed to delete a droplet, CC received a request with an invalid auth token&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;info&lt;/code&gt; - CC received a token from UAA, CC received a NATS request&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;debug2&lt;/code&gt; - CC created a service, updated a service&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;debug&lt;/code&gt; - CC syncs resource pool, CC uploaded a file&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;The Cloud Controller uses a YAML configuration file. For an example, see &lt;code&gt;config/cloud_controller.yml&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ipaddress-gem/ipaddress</title>
    <updated>2023-06-13T01:48:27Z</updated>
    <id>tag:github.com,2023-06-13:/ipaddress-gem/ipaddress</id>
    <link href="https://github.com/ipaddress-gem/ipaddress" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A library to handle IPv4 and IPv6 addresses in a modern and productive way.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;IPAddress&lt;/h1&gt; &#xA;&lt;p&gt;IPAddress is a Ruby library designed to make the use of IPv4 and IPv6 addresses simple, powerful and enjoyable. It provides a complete set of methods to handle IP addresses for any need, from simple scripting to full network design.&lt;/p&gt; &#xA;&lt;p&gt;This document provides a brief introduction to the library and examples of typical usage.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ruby 1.9.3 or later&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please refer to &lt;a href=&#34;https://travis-ci.org/ipaddress-gem/ipaddress&#34;&gt;Travis CI&lt;/a&gt; for Build Tests on specific versions of Ruby.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/ipaddress-gem/ipaddress&#34;&gt;&lt;img src=&#34;https://travis-ci.org/ipaddress-gem/ipaddress.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/ipaddress-gem/ipaddress&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/ipaddress-gem/ipaddress/badges/gpa.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.versioneye.com/user/projects/57001305fcd19a0051853bde&#34;&gt;&lt;img src=&#34;https://www.versioneye.com/user/projects/57001305fcd19a0051853bde/badge.s&#xA;vg?style=flat&#34; alt=&#34;Dependency Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;IPAddress 0.8.2 was manually tested on:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ruby-1.8.7-p334 [ i386 ]&lt;/li&gt; &#xA; &lt;li&gt;ree-1.8.7-2011.03 [ i386 ]&lt;/li&gt; &#xA; &lt;li&gt;rbx-head [ ]&lt;/li&gt; &#xA; &lt;li&gt;jruby-1.6.1 [ linux-i386-java ]&lt;/li&gt; &#xA; &lt;li&gt;ruby-1.9.1-p431 [ i386 ]&lt;/li&gt; &#xA; &lt;li&gt;ruby-1.9.2-p180 [ i386 ]&lt;/li&gt; &#xA; &lt;li&gt;ruby-2.0.0-p353 [ x86_64-darwin14.0.0 ]&lt;/li&gt; &#xA; &lt;li&gt;ruby-2.1.3-p242 [ x86_64-darwin14.0.0 ]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to contribute, please refer to [Contributing.md](&lt;a href=&#34;https://github.com/ipaddress-gem/ipaddress/raw/master/CONTR&#34;&gt;https://github.com/ipaddress-gem/ipaddress/blob/master/CONTR&lt;/a&gt; IBUTING.md).&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;This gem is installed like any other:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install it generally:&#xA;$ gem install ipaddress&#xA;&#xA;# or, add it to your current application gemfile:&#xA;$ bundle add ipaddress&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The code is fully documented with RDoc. You can generate the documentation with Rake:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rake rdoc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The latest documentation can be found online at [this address][https://rubydoc.info/gems/ipaddress/]&lt;/p&gt; &#xA;&lt;h2&gt;Introduction via examples&lt;/h2&gt; &#xA;&lt;p&gt;Below are two sections with examples. The first section is for IPv4, the second for IPv6 (further down).&lt;/p&gt; &#xA;&lt;h2&gt;IPv4&lt;/h2&gt; &#xA;&lt;p&gt;The class &lt;code&gt;IPAddress::IPv4&lt;/code&gt; is used to handle IPv4 type addresses.&lt;/p&gt; &#xA;&lt;h3&gt;Create a new IPv4 address&lt;/h3&gt; &#xA;&lt;p&gt;The usual way to express an IP Address is using its dotted decimal form, such as &lt;code&gt;172.16.10.1&lt;/code&gt;, and a prefix, such as &lt;code&gt;24&lt;/code&gt;, separated by a slash.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;172.16.10.1/24&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To create a new IPv4 object, you can use IPv4 own class&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress::IPv4.new &#34;172.16.10.1/24&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or, in a easier way, using the IPAddress parse method&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress.parse &#34;172.16.10.1/24&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which accepts and parses any kind of IP (uint32, IPv4, IPV6 and IPv4 IPv6 mapped addresses).&lt;/p&gt; &#xA;&lt;p&gt;If you like syntactic sugar, you can use the wrapper method &lt;code&gt;IPAddress()&lt;/code&gt;, which is built around &lt;code&gt;IPAddress::parse&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress &#34;172.16.10.1/24&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can specify an IPv4 address in any of two ways:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;IPAddress &#34;172.16.10.1/24&#34;&#xA;IPAddress &#34;172.16.10.1/255.255.255.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, prefix &lt;code&gt;/24&lt;/code&gt; and netmask &lt;code&gt;255.255.255.0&lt;/code&gt; are the same and you have the flexibility to use either one of them.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t explicitly specify the prefix (or the subnet mask), IPAddress thinks you&#39;re dealing with host addresses and not with networks. Therefore, the default prefix will be &lt;code&gt;/32&lt;/code&gt;, or &lt;code&gt;255.255.255.255&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# let&#39;s declare an host address&#xA;host = IPAddress::IPv4.new &#34;10.1.1.1&#34;&#xA;&#xA;puts host.to_s #=&amp;gt; &#34;10.1.1.1/32&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The new created object has prefix &lt;code&gt;/32&lt;/code&gt;, which is the same as we created the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;host = IPAddress::IPv4.new &#34;10.1.1.1/32&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also pass a &lt;code&gt;uint32&lt;/code&gt; to obtain an &lt;code&gt;IPAddress::IPv4&lt;/code&gt; object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Create host object&#xA;ip = IPAddress 167837953&#xA;puts ip.to_s #=&amp;gt; &#34;10.1.1.1/32&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Handling the IPv4 address&lt;/h3&gt; &#xA;&lt;p&gt;Once created, you can obtain the attributes for an IPv4 object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress(&#34;172.16.10.1/24&#34;)&#xA;&#xA;ip.address #=&amp;gt; &#34;172.16.10.1&#34;&#xA;ip.prefix #=&amp;gt; 24&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case you need to retrieve the netmask in IPv4 format, you can use the &lt;code&gt;IPv4#netmask&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.netmask #=&amp;gt; &#34;255.255.255.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A special attribute, &lt;code&gt;IPv4#octets&lt;/code&gt;, is available to get the four decimal octets from the IP address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.octets #=&amp;gt; [172,16,10,1]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The shortcut method &lt;code&gt;IPv4#[]&lt;/code&gt;, provides access to a given octet whithin the range:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip[1] #=&amp;gt; 16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to print out the IPv4 address in a canonical form, you can use &lt;code&gt;IPv4#to_s&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.to_s #=&amp;gt; &#34;172.16.10.1/24&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Changing netmask&lt;/h3&gt; &#xA;&lt;p&gt;You can set a new prefix (netmask) after creating an IPv4 object. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.prefix = 25&#xA;&#xA;ip.to_s #=&amp;gt; &#34;172.16.10.1/25&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to use a netmask in IPv4 format, you can achive so by using the &lt;code&gt;IPv4#netmask=&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.netmask = &#34;255.255.255.252&#34;&#xA;&#xA;ip.to_s #=&amp;gt; &#34;172.16.10.1/30&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Working with networks, broadcasts and addresses&lt;/h3&gt; &#xA;&lt;p&gt;Some important topics in dealing with IP addresses are the concepts of &lt;code&gt;network&lt;/code&gt; and &lt;code&gt;broadcast&lt;/code&gt;, as well as the addresses included in a range.&lt;/p&gt; &#xA;&lt;p&gt;When you specify an IPv4 address such as &lt;code&gt;172.16.10.1/24&lt;/code&gt;, you are actually handling two different information:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The IP address itself, &#34;172.16.10.1&#34;&lt;/li&gt; &#xA; &lt;li&gt;The subnet mask which indicates the network&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The network number is the IP which has all zeroes in the host portion. In our example, because the prefix is 24, we identify our network number to have the last 8 (32-24) bits all zeroes. Thus, IP address &lt;code&gt;172.16.10.1/24&lt;/code&gt; belongs to network &lt;code&gt;172.16.10.0/24&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is important because, for instance, IP &lt;code&gt;172.16.10.1/16&lt;/code&gt; is different to the previous one, belonging to the different network &lt;code&gt;172.16.0.0/16&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Networks&lt;/h4&gt; &#xA;&lt;p&gt;With IPAddress it&#39;s easy to calculate the network for an IP address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress &#34;172.16.10.1/24&#34;&#xA;&#xA;net = ip.network #=&amp;gt; #&amp;lt;IPAddress::IPv4:0xb7a5ab24 @octets=[172, 16, 10, 0], @prefix=24, @address=&#34;172.16.10.0&#34;&amp;gt;&#xA;net.to_s #=&amp;gt; &#34;172.16.10.0/24&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Method IPv4#network creates a new IPv4 object from the network number, calculated after the original object. We want to outline here that the network address is a perfect legitimate IPv4 address, which just happen to have all zeroes in the host portion.&lt;/p&gt; &#xA;&lt;p&gt;You can use method &lt;code&gt;IPv4#network?&lt;/code&gt; to check whether an IP address is a network or not:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip1 = IPAddress &#34;172.16.10.1/24&#34;&#xA;ip2 = IPAddress &#34;172.16.10.4/30&#34;&#xA;&#xA;ip1.network? #=&amp;gt; false&#xA;ip2.network? #=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Broadcast&lt;/h4&gt; &#xA;&lt;p&gt;The broadcast address is the contrary than the network number: where the network number has all zeroes in the host portion, the broadcast address has all one&#39;s. For example, ip &lt;code&gt;172.16.10.1/24&lt;/code&gt; has broadcast &lt;code&gt;172.16.10.255/24&lt;/code&gt;, where ip &lt;code&gt;172.16.10.1/16&lt;/code&gt; has broadcast &lt;code&gt;172.16.255.255/16&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Method &lt;code&gt;IPv4#broadcast&lt;/code&gt; has the same behavior as is &lt;code&gt;#network&lt;/code&gt; counterpart: it creates a new IPv4 object to handle the broadcast address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress &#34;172.16.10.1/24&#34;&#xA;&#xA;bcast = ip.broadcast #=&amp;gt; #&amp;lt;IPAddress::IPv4:0xb7a406fc @octets=[172, 16, 10, 255], @prefix=24, @address=&#34;172.16.10.255&#34;&amp;gt;&#xA;bcast.to_s #=&amp;gt; &#34;172.16.10.255/24&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Addresses, ranges and iterators&lt;/h4&gt; &#xA;&lt;p&gt;So we see that the netmask essentially specifies a range for IP addresses that are included in a network: all the addresses between the network number and the broadcast. IPAddress has many methods to iterate between those addresses. Let&#39;s start with &lt;code&gt;IPv4#each&lt;/code&gt;, which iterates over all addresses in a range&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress &#34;172.16.10.1/24&#34;&#xA;&#xA;ip.each do |addr|&#xA;  puts addr&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is important to note that it doesn&#39;t matter if the original IP is a host IP or a network number (or a broadcast address): the #each method only considers the range that the original IP specifies.&lt;/p&gt; &#xA;&lt;p&gt;If you only want to iterate over hosts IP, use the &lt;code&gt;IPv4#each_host&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress &#34;172.16.10.1/24&#34;&#xA;&#xA;ip.each_host do |host|&#xA;  puts host&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Methods &lt;code&gt;IPv4#first&lt;/code&gt; and &lt;code&gt;IPv4#last&lt;/code&gt; return a new object containing respectively the first and the last host address in the range&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress &#34;172.16.10.100/24&#34;&#xA;&#xA;ip.first.to_s #=&amp;gt; &#34;172.16.10.1/24&#34;&#xA;ip.last.to_s #=&amp;gt; &#34;172.16.10.254/24&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Checking if an address is loopback is easy with the &lt;code&gt;IPv4#loopback?&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress &#34;127.0.0.1&#34;&#xA;&#xA;ip.loopback? #=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Checking if an address is in the multicast range can be done using the &lt;code&gt;IPv4#multicast?&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress &#34;224.0.0.1/32&#34;&#xA;&#xA;ip.multicast? #=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The ability to generate a range also exists by using the &lt;code&gt;IPv4#to()&lt;/code&gt; method. This allows you to create a subnet agnostic range based off a fixed amount.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress &#34;172.16.10.100/24&#34;&#xA;ip.to(&#39;172.16.10.110&#39;) #=&amp;gt; [&#34;172.16.10.100&#34;, ..., &#34;172.16.10.110&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;IP special formats&lt;/h3&gt; &#xA;&lt;p&gt;The IPAddress library provides a complete set of methods to access an IPv4 address in special formats, such as binary, 32 bits unsigned int, data and hexadecimal.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s take the following IPv4 as an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress &#34;172.16.10.1/24&#34;&#xA;&#xA;ip.address #=&amp;gt; &#34;172.16.10.1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first thing to highlight here is that all these conversion methods only take into consideration the address portion of an IPv4 object and not the prefix (netmask).&lt;/p&gt; &#xA;&lt;p&gt;So, to express the address in binary format, use the &lt;code&gt;IPv4#bits&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.bits #=&amp;gt; &#34;10101100000100000000101000000001&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To calculate the 32 bits unsigned int format of the ip address, use the &lt;code&gt;IPv4#to_u32&lt;/code&gt; method&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.to_u32 #=&amp;gt; 2886732289&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This method is the equivalent of the Unix call &lt;code&gt;pton()&lt;/code&gt;, expressing an IP address in the so called +network byte order+ notation. However, if you want to transmit your IP over a network socket, you might need to transform it in data format using the &lt;code&gt;IPv4#data&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.data #=&amp;gt; &#34;\254\020\n\001&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, you can transform an IPv4 address into a format which is suitable to use in IPv4-IPv6 mapped addresses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.to_ipv6 #=&amp;gt; &#34;ac10:0a01&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, much like &lt;code&gt;IPv4#to_ipv6&lt;/code&gt; you can use to &lt;code&gt;IPv4#to_h&lt;/code&gt; method to return a non-semicolon delineated string (useful with pcap/byte level usage):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.to_h #=&amp;gt; &#34;ac100a01&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Classful networks&lt;/h3&gt; &#xA;&lt;p&gt;IPAddress allows you to create and manipulate objects using the old and deprecated (but apparently still popular) classful networks concept.&lt;/p&gt; &#xA;&lt;p&gt;Classful networks and addresses don&#39;t have a prefix: their subnet mask is univocally identified by their address, and therefore divided in classes. As per RFC 791, these classes are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Class A, from 0.0.0.0 to 127.255.255.255&lt;/li&gt; &#xA; &lt;li&gt;Class B, from 128.0.0.0 to 191.255.255.255&lt;/li&gt; &#xA; &lt;li&gt;Class C, from 192.0.0.0 to 255.255.255.255&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since classful networks here are only considered to calculate the default prefix number, classes D and E are not considered.&lt;/p&gt; &#xA;&lt;p&gt;To create a classful IP and prefix from an IP address, use the IPv4::parse_classful method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# classful ip&#xA;ip = IPAddress::IPv4::parse_classful &#34;10.1.1.1&#34;&#xA;&#xA;ip.prefix #=&amp;gt; 8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The method automatically created a new IPv4 object and assigned it the correct prefix.&lt;/p&gt; &#xA;&lt;p&gt;You can easily check which classful network an IPv4 object belongs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress(&#34;10.0.0.1/24&#34;)&#xA;ip.a? #=&amp;gt; true&#xA;&#xA;ip = IPAddress(&#34;172.16.10.1/24&#34;)&#xA;ip.b? #=&amp;gt; true&#xA;&#xA;ip = IPAddress(&#34;192.168.1.1/30&#34;)&#xA;ip.c? #=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Remember that these methods are only checking the address portion of an IP, and are independent from its prefix, as classful networks have no concept of prefix.&lt;/p&gt; &#xA;&lt;p&gt;For more information on classful networks visit the &lt;a href=&#34;https://en.wikipedia.org/wiki/Classful_network&#34;&gt;Wikipedia page&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Network design with IPAddress&lt;/h3&gt; &#xA;&lt;p&gt;IPAddress includes a lot of useful methods to manipulate IPv4 and IPv6 networks and do some basic network design.&lt;/p&gt; &#xA;&lt;h4&gt;Subnetting&lt;/h4&gt; &#xA;&lt;p&gt;The process of subnetting is the division of a network into smaller (in terms of hosts capacity) networks, called subnets, so that they all share a common root, which is the starting network.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you have network &#34;172.16.10.0/24&#34;, we can subnet it into 4 smaller subnets. The new prefix will be /26, because 4 is 2^2 and therefore we add 2 bits to the network prefix (24+2=26).&lt;/p&gt; &#xA;&lt;p&gt;Subnetting is easy with IPAddress. You actually have two options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;IPv4#subnet: specify a new prefix&lt;/li&gt; &#xA; &lt;li&gt;IPv4#split: tell IPAddress how many subnets you want to create.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Let&#39;s examine &lt;code&gt;IPv4#subnet&lt;/code&gt; first. Say you have network &#34;172.16.10.0/24&#34; and you want to subnet it into /26 networks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;network = IPAddress &#34;172.16.10.0/24&#34;&#xA;&#xA;subnets = network.subnet(26)&#xA;&#xA;subnets.map { |i| i.to_s } #=&amp;gt; [&#34;172.16.10.0/26&#34;, &#34;172.16.10.64/26&#34;, &#34;172.16.10.128/26&#34;, &#34;172.16.10.192/26&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, an Array has been created, containing 4 new IPv4 objects representing the new subnets.&lt;/p&gt; &#xA;&lt;p&gt;Another way to create subnets is to tell IPAddress how many subnets you&#39;d like to have, and letting the library calculate the new prefix for you.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s see how it works, using &lt;code&gt;IPv4#split&lt;/code&gt; method. Say you want 4 new subnets:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;network = IPAddress(&#34;172.16.10.0/24&#34;)&#xA;&#xA;subnets = network.split(4)&#xA;&#xA;subnets.map { |i| i.to_s } #=&amp;gt; [&#34;172.16.10.0/26&#34;, &#34;172.16.10.64/26&#34;, &#34;172.16.10.128/26&#34;, &#34;172.16.10.192/26&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hey, that&#39;s the same result as before! This actually makes sense, as the two operations are complementary. When you use &lt;code&gt;IPv4#subnet&lt;/code&gt; with the new prefix, IPAddress will always create a number of subnets that is a power of two. This is equivalent to use IPv4#split with a power of 2.&lt;/p&gt; &#xA;&lt;p&gt;Where &lt;code&gt;IPv4#split&lt;/code&gt; really shines is with the so called &#34;uneven subnetting&#34;. You are not limited to split a network into a power-of-two numbers of subnets: IPAddress lets you create any number of subnets, and it will try to organize the new created network in the best possible way, making an efficient allocation of the space.&lt;/p&gt; &#xA;&lt;p&gt;An example here is worth a thousand words. Let&#39;s use the same network as the previous examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;network = IPAddress(&#34;172.16.10.0/24&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;How do we split this network into 3 subnets? Easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;subnets = network.split(3)&#xA;&#xA;subnets.map { |i| i.to_s } #=&amp;gt; [&#34;172.16.10.0/26&#34;, &#34;172.16.10.64/26&#34;, &#34;172.16.10.128/25&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, IPAddress tried to perform a good allocation by filling up all the address space from the original network. There is no point in splitting a network into 3 subnets like &lt;code&gt;172.16.10.0/26&lt;/code&gt;, &lt;code&gt;172.16.10.64/26&lt;/code&gt; and &lt;code&gt;172.16.10.128/26&lt;/code&gt;, as you would end up having &lt;code&gt;172.16.10.192/26&lt;/code&gt; wasted.&lt;/p&gt; &#xA;&lt;p&gt;We can go even further and split into 11 subnets:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;network.split(11)&#xA;#=&amp;gt; [&#34;172.16.10.0/28&#34;, &#34;172.16.10.16/28&#34;, &#34;172.16.10.32/28&#34;,&#xA;#    &#34;172.16.10.48/28&#34;, &#34;172.16.10.64/28&#34;, &#34;172.16.10.80/28&#34;,&#xA;#    &#34;172.16.10.96/28&#34;, &#34;172.16.10.112/28&#34;, &#34;172.16.10.128/27&#34;,&#xA;#    &#34;172.16.10.160/27&#34;, &#34;172.16.10.192/26&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, most of the networks are &lt;code&gt;/28&lt;/code&gt;, with a few &lt;code&gt;/27&lt;/code&gt; and one &lt;code&gt;/26&lt;/code&gt; to fill up the remaining space.&lt;/p&gt; &#xA;&lt;h4&gt;Summarization&lt;/h4&gt; &#xA;&lt;p&gt;Summarization (or aggregation) is the process when two or more networks are taken together to check if a supernet, including all and only these networks, exists. If it exists then this supernet is called the summarized (or aggregated) network.&lt;/p&gt; &#xA;&lt;p&gt;It is important to understand that summarization can only occur if there are no holes in the aggregated network, or, in other words, if the given networks fill completely the address space of the supernet.&lt;/p&gt; &#xA;&lt;p&gt;So the two rules are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;The aggregate network must contain &lt;code&gt;all&lt;/code&gt; the IP addresses of the original networks;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The aggregate network must contain &lt;code&gt;only&lt;/code&gt; the IP addresses of the original networks;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;A few examples will help clarify the above. Let&#39;s consider for instance the following two networks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip1 = IPAddress(&#34;172.16.10.0/24&#34;)&#xA;ip2 = IPAddress(&#34;172.16.11.0/24&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These two networks can be expressed using only one IP address network if we change the prefix:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;IPAddress::IPv4::summarize(ip1,ip2).map(&amp;amp;:to_s) #=&amp;gt; &#34;172.16.10.0/23&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We note how the network &lt;code&gt;172.16.10.0/23&lt;/code&gt; includes all the addresses specified in the above networks, and (more important) includes only those addresses.&lt;/p&gt; &#xA;&lt;p&gt;If we summarized &lt;code&gt;ip1&lt;/code&gt; and &lt;code&gt;ip2&lt;/code&gt; with the following network:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#34;172.16.0.0/16&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;we would have satisfied rule #1 above, but not rule #2. So&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#34;172.16.0.0/16&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is not an aggregate network for &lt;code&gt;ip1&lt;/code&gt; and &lt;code&gt;ip2&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If it&#39;s not possible to compute a single aggregated network for all the original networks, the method returns an array with all the aggregate networks found. For example, the following four networks can be aggregated in a single &lt;code&gt;/22&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip1 = IPAddress(&#34;10.0.0.1/24&#34;)&#xA;ip2 = IPAddress(&#34;10.0.1.1/24&#34;)&#xA;ip3 = IPAddress(&#34;10.0.2.1/24&#34;)&#xA;ip4 = IPAddress(&#34;10.0.3.1/24&#34;)&#xA;&#xA;IPAddress::IPv4::summarize(ip1, ip2, ip3, ip4).map { |i| i.to_s } #=&amp;gt; [&#34;10.0.0.0/22&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But the following networks can&#39;t be summarized in a single network:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip1 = IPAddress(&#34;10.0.1.1/24&#34;)&#xA;ip2 = IPAddress(&#34;10.0.2.1/24&#34;)&#xA;ip3 = IPAddress(&#34;10.0.3.1/24&#34;)&#xA;ip4 = IPAddress(&#34;10.0.4.1/24&#34;)&#xA;&#xA;IPAddress::IPv4::summarize(ip1, ip2, ip3, ip4).map { |i| i.to_s } #=&amp;gt; [&#34;10.0.1.0/24&#34;,&#34;10.0.2.0/23&#34;,&#34;10.0.4.0/24&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, the two summarizables networks have been aggregated into a single &lt;code&gt;/23&lt;/code&gt;, while the other two networks have been left untouched.&lt;/p&gt; &#xA;&lt;h4&gt;Supernetting&lt;/h4&gt; &#xA;&lt;p&gt;Supernetting is a different operation than aggregation, as it only works on a single network and returns a new single IPv4 object, representing the supernet.&lt;/p&gt; &#xA;&lt;p&gt;Supernetting is similar to subnetting, except that you getting as a result a network with a smaller prefix (bigger host space). For example, given the network&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress(&#34;172.16.10.0/24&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;you can supernet it with a new /23 prefix&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.supernet(23).to_s #=&amp;gt; &#34;172.16.10.0/23&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However if you supernet it with a &lt;code&gt;/22&lt;/code&gt; prefix, the network address will change:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.supernet(22).to_s #=&amp;gt; &#34;172.16.8.0/22&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is because &lt;code&gt;172.16.10.0/22&lt;/code&gt; is not a network anymore, but an host address.&lt;/p&gt; &#xA;&lt;h2&gt;IPv6&lt;/h2&gt; &#xA;&lt;p&gt;IPAddress is not only fantastic for IPv4 addresses, it&#39;s also great to handle IPv6 addresses family! Let&#39;s discover together how to use it in our projects.&lt;/p&gt; &#xA;&lt;h3&gt;IPv6 addresses&lt;/h3&gt; &#xA;&lt;p&gt;IPv6 addresses are 128 bits long, in contrast with IPv4 addresses which are only 32 bits long. An IPv6 address is generally written as eight groups of four hexadecimal digits, each group representing 16 bits or two octet. For example, the following is a valid IPv6 address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;2001:0db8:0000:0000:0008:0800:200c:417a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Letters in an IPv6 address are usually written downcase, as per RFC. You can create a new IPv6 object using uppercase letters, but they will be converted.&lt;/p&gt; &#xA;&lt;h4&gt;Compression&lt;/h4&gt; &#xA;&lt;p&gt;Since IPv6 addresses are long to write, there are some simplifications and compressions that you can use to shorten them.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Leading zeroes: all the leading zeroes within a group can be omitted: &#34;0008&#34; would become &#34;8&#34;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A string of consecutive zeroes can be replaced by the string &#34;::&#34;. This can be only applied once.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Using compression, the IPv6 address written above can be shorten into the following, equivalent, address&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;2001:db8::8:800:200c:417a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This short version is often used in human representation.&lt;/p&gt; &#xA;&lt;h4&gt;Network Mask&lt;/h4&gt; &#xA;&lt;p&gt;As we used to do with IPv4 addresses, an IPv6 address can be written using the prefix notation to specify the subnet mask:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;2001:db8::8:800:200c:417a/64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The /64 part means that the first 64 bits of the address are representing the network portion, and the last 64 bits are the host portion.&lt;/p&gt; &#xA;&lt;h3&gt;Using IPAddress with IPv6 addresses&lt;/h3&gt; &#xA;&lt;p&gt;All the IPv6 representations we&#39;ve just seen are perfectly fine when you want to create a new IPv6 address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6 = IPAddress &#34;2001:0db8:0000:0000:0008:0800:200C:417A&#34;&#xA;&#xA;ip6 = IPAddress &#34;2001:db8:0:0:8:800:200C:417A&#34;&#xA;&#xA;ip6 = IPAddress &#34;2001:db8:8:800:200C:417A&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All three are giving out the same IPv6 object. The default subnet mask for an IPv6 is 128, as IPv6 addresses don&#39;t have classes like IPv4 addresses. If you want a different mask, you can go ahead and explicit it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6 = IPAddress &#34;2001:db8::8:800:200c:417a/64&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Access the address portion and the prefix by using the respective methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6 = IPAddress &#34;2001:db8::8:800:200c:417a/64&#34;&#xA;&#xA;ip6.address #=&amp;gt; &#34;2001:0db8:0000:0000:0008:0800:200c:417a&#34;&#xA;&#xA;ip6.prefix #=&amp;gt; 64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A compressed version of the IPv6 address can be obtained with the &lt;code&gt;IPv6#compressed&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6 = IPAddress &#34;2001:0db8:0000:0000:0008:200c:417a:00ab/64&#34;&#xA;&#xA;ip6.compressed #=&amp;gt; &#34;2001:db8::8:800:200c:417a&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Handling the IPv6 address&lt;/h3&gt; &#xA;&lt;p&gt;Accessing the groups that form an IPv6 address is easy with the &lt;code&gt;IPv6#groups&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6 = IPAddress &#34;2001:db8::8:800:200c:417a/64&#34;&#xA;&#xA;ip6.groups #=&amp;gt; [8193, 3512, 0, 0, 8, 2048, 8204, 16762]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with IPv4 addresses, each individual group can be accessed using the &lt;code&gt;IPv6#[]&lt;/code&gt; shortcut method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6[0] #=&amp;gt; 8193&#xA;ip6[1] #=&amp;gt; 3512&#xA;ip6[2] #=&amp;gt; 0&#xA;ip6[3] #=&amp;gt; 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that each 16 bits group is expressed in its decimal form. You can also obtain the groups into hexadecimal format using the &lt;code&gt;IPv6#hexs&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6.hexs #=&amp;gt; [&#34;2001&#34;, &#34;0db8&#34;, &#34;0000&#34;, &#34;0000&#34;, &#34;0008&#34;, &#34;0800&#34;, &#34;200c&#34;, &#34;417a&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A few other methods are available to transform an IPv6 address into decimal representation, with &lt;code&gt;IPv6.to_i&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6.to_i #=&amp;gt; 42540766411282592856906245548098208122&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or to hexadecimal representation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6.to_hex #=&amp;gt; &#34;20010db80000000000080800200c417a&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To print out an IPv6 address in human readable form, use the &lt;code&gt;IPv6#to_string&lt;/code&gt;, &lt;code&gt;IPv6#to_s&lt;/code&gt; and &lt;code&gt;IPv6#to_string_uncompressed&lt;/code&gt; methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6 = IPAddress &#34;2001:db8::8:800:200c:417a/64&#34;&#xA;&#xA;ip6.to_string #=&amp;gt; &#34;2001:db8::8:800:200c:417a/96&#34;&#xA;ip6.to_s #=&amp;gt; &#34;2001:db8::8:800:200c:417a/96&#34;&#xA;&#xA;ip6.to_string_uncompressed #=&amp;gt; &#34;2001:0db8:0000:0000:0008:0800:200c:417a/96&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, &lt;code&gt;IPv6.to_string&lt;/code&gt; prints out the compressed form, while &lt;code&gt;IPv6.to_string_uncompressed&lt;/code&gt; uses the expanded version.&lt;/p&gt; &#xA;&lt;h4&gt;Compressing and uncompressing&lt;/h4&gt; &#xA;&lt;p&gt;If you have a string representing an IPv6 address, you can easily compress it and uncompress it using the two class methods IPv6::expand and IPv6::compress.&lt;/p&gt; &#xA;&lt;p&gt;For example, let&#39;s say you have the following uncompressed IPv6 address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;str = &#34;2001:0DB8:0000:CD30:0000:0000:0000:0000&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is the compressed version:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;IPAddress::IPv6.compress(str) #=&amp;gt; &#34;2001:db8:0:cd30::&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The other way works as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;str = &#34;2001:db8:0:cd30::&#34;&#xA;&#xA;IPAddress::IPv6.expand(str) #=&amp;gt; &#34;2001:0DB8:0000:CD30:0000:0000:0000:0000&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These methods can be used when you don&#39;t want to create a new object just for expanding or compressing an address (although a new object is actually created internally).&lt;/p&gt; &#xA;&lt;h3&gt;New IPv6 address from other formats&lt;/h3&gt; &#xA;&lt;p&gt;You can create a new IPv6 address from different formats than just a string representing the colon-hex groups.&lt;/p&gt; &#xA;&lt;p&gt;For instance, if you have a data stream, you can use &lt;code&gt;IPv6::parse_data&lt;/code&gt;, like in the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;data = &#34; \001\r\270\000\000\000\000\000\b\b\000 \fAz&#34;&#xA;&#xA;ip6 = IPAddress::IPv6::parse_data data&#xA;ip6.prefix = 64&#xA;&#xA;ip6.to_s #=&amp;gt; &#34;2001:db8::8:800:200c:417a/64&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A new IPv6 address can also be created from an unsigned 128 bits integer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;u128 = 42540766411282592856906245548098208122&#xA;&#xA;ip6 = IPAddress::IPv6::parse_u128 u128&#xA;ip6.prefix = 64&#xA;&#xA;ip6.to_s #=&amp;gt;&#34;2001:db8::8:800:200c:417a/64&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, a new IPv6 address can be created from an hex string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;hex = &#34;20010db80000000000080800200c417a&#34;&#xA;&#xA;ip6 = IPAddress::IPv6::parse_hex hex&#xA;ip6.prefix = 64&#xA;&#xA;ip6.to_s #=&amp;gt; &#34;2001:db8::8:800:200c:417a/64&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Special IPv6 addresses&lt;/h3&gt; &#xA;&lt;p&gt;Some IPv6 have a special meaning and are expressed in a special form, quite different than an usual IPv6 address. IPAddress has built-in support for unspecified, loopback and mapped IPv6 addresses.&lt;/p&gt; &#xA;&lt;h4&gt;Unspecified address&lt;/h4&gt; &#xA;&lt;p&gt;The address with all zero bits is called the &lt;code&gt;unspecified&lt;/code&gt; address (corresponding to &lt;code&gt;0.0.0.0&lt;/code&gt; in IPv4). It should be something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;0000:0000:0000:0000:0000:0000:0000:0000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but, with the use of compression, it is usually written as just two colons:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;::&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or, specifying the netmask:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;::/128&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With IPAddress, create a new unspecified IPv6 address using its own subclass:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress::IPv6::Unspecified.new&#xA;&#xA;ip.to_s #=&amp;gt; &#34;::/128&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can easily check if an IPv6 object is an unspecified address by using the IPv6#unspecified? method&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.unspecified? #=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An unspecified IPv6 address can also be created with the wrapper method, like we&#39;ve seen before&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress &#34;::&#34;&#xA;&#xA;ip.unspecified? #=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This address must never be assigned to an interface and is to be used only in software before the application has learned its host&#39;s source address appropriate for a pending connection. Routers must not forward packets with the unspecified address.&lt;/p&gt; &#xA;&lt;h4&gt;Loopback address&lt;/h4&gt; &#xA;&lt;p&gt;The loopback address is a unicast localhost address. If an application in a host sends packets to this address, the IPv6 stack will loop these packets back on the same virtual interface.&lt;/p&gt; &#xA;&lt;p&gt;Loopback addresses are expressed in the following form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;::1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or, with their appropriate prefix,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;::1/128&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As for the unspecified addresses, IPv6 loopbacks can be created with IPAddress calling their own class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress::IPv6::Loopback.new&#xA;&#xA;ip.to_s #=&amp;gt; &#34;::1/128&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or by using the wrapper:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip = IPAddress &#34;::1&#34;&#xA;&#xA;ip.to_s #=&amp;gt; &#34;::1/128&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Checking if an address is loopback is easy with the &lt;code&gt;IPv6#loopback?&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip.loopback? #=&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The IPv6 loopback address corresponds to &lt;code&gt;127.0.0.1&lt;/code&gt; in IPv4.&lt;/p&gt; &#xA;&lt;h4&gt;Mapped address&lt;/h4&gt; &#xA;&lt;p&gt;It is usually identified as a IPv4 mapped IPv6 address, a particular IPv6 address which aids the transition from IPv4 to IPv6. The structure of the address is&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;::ffff:w.y.x.z&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &lt;code&gt;w.x.y.z&lt;/code&gt; is a normal IPv4 address. For example, the following is a mapped IPv6 address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;::ffff:192.168.100.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;IPAddress is powerful in handling mapped IPv6 addresses, as the IPv4 portion is stored internally as a normal IPv4 object. Let&#39;s have a look at some examples. To create a new mapped address, just use the class builder itself&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6 = IPAddress::IPv6::Mapped.new &#34;::ffff:172.16.10.1/128&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or just use the wrapper method&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6 = IPAddress &#34;::ffff:172.16.10.1/128&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s check it&#39;s really a mapped address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6.mapped? #=&amp;gt; true&#xA;&#xA;ip6.to_s #=&amp;gt; &#34;::ffff:172.16.10.1/128&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now with the &lt;code&gt;#ipv4&lt;/code&gt; attribute, we can easily access the IPv4 portion of the mapped IPv6 address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6.ipv4.address #=&amp;gt; &#34;172.16.10.1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Internally, the IPv4 address is stored as two 16 bits groups. Therefore all the usual methods for an IPv6 address are working perfectly fine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6.to_hex #=&amp;gt; &#34;00000000000000000000ffffac100a01&#34;&#xA;&#xA;ip6.address #=&amp;gt; &#34;0000:0000:0000:0000:0000:ffff:ac10:0a01&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A mapped IPv6 can also be created just by specify the address in the following format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6 = IPAddress &#34;::172.16.10.1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That is, two colons and the IPv4 address. However, as by RFC, the &lt;code&gt;ffff&lt;/code&gt; group will be automatically added at the beginning&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ip6.to_s #=&amp;gt; &#34;::ffff:172.16.10.1/128&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;making it a mapped IPv6 compatible address.&lt;/p&gt; &#xA;&lt;h2&gt;Why not using IPAddr?&lt;/h2&gt; &#xA;&lt;p&gt;IPAddr is the IP addresses library that comes with Ruby standard lib. We found this library, although well written, not suitable for all our needs.&lt;/p&gt; &#xA;&lt;p&gt;Some quick examples of things you can&#39;t do with IPAddr:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;store both the address and the prefix information&lt;/li&gt; &#xA; &lt;li&gt;quickly find the broadcast address of a network&lt;/li&gt; &#xA; &lt;li&gt;iterate over hosts&lt;/li&gt; &#xA; &lt;li&gt;perform subnetting or network aggregation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Many methods and procedures are so old that they have been declared deprecated by the IETF, and some others have bugs in their implementation.&lt;/p&gt; &#xA;&lt;p&gt;Moreover, IPAddress is more robust and is roughly twice as fast as IPAddr, in addition to provide an organic API with logical separation and code structure.&lt;/p&gt; &#xA;&lt;p&gt;We hope that IPAddress will address all these issues and meet all your needs in network programming.&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;Want to join the community?&lt;/p&gt; &#xA;&lt;p&gt;We have &lt;a href=&#34;https://github.com/ipaddress-gem/ipaddress/discussions&#34;&gt;discussions setup on Github&lt;/a&gt;, where anyone can participate and discuss.&lt;/p&gt; &#xA;&lt;h2&gt;Thanks to&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to Luca Russo (vargolo) and Simone Carletti (weppos) for all the support and technical review. Thanks to Marco Beri, Bryan T. Richardson, Nicolas Fevrier, jdpace, Daniele Alessandri, jrdioko, Ghislain Charrier, Pawel Krzesniak, Mark Sullivan, Leif Gensert, Erik Ahlström, Peter Vandenberk and Steve Rawlinson for their support, feedback and bug reports.&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2009-today Marco Ceresa and Mike Mackintosh. See LICENSE for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>QiuChenlyOpenSource/InjectLib</title>
    <updated>2023-06-13T01:48:27Z</updated>
    <id>tag:github.com,2023-06-13:/QiuChenlyOpenSource/InjectLib</id>
    <link href="https://github.com/QiuChenlyOpenSource/InjectLib" rel="alternate"></link>
    <summary type="html">&lt;p&gt;基于Ruby编写的命令行注入版本&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;命令行版本注入工具使用方法&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;终端进入本文件夹&lt;/li&gt; &#xA; &lt;li&gt;执行 sudo ruby main.rb 启动注入程序。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;App兼容性&lt;/h1&gt; &#xA;&lt;h3&gt;支持以下App的M系和Intel版本：&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;iShot 2.3.4&lt;/li&gt; &#xA; &lt;li&gt;Infuse Pro 通杀&lt;/li&gt; &#xA; &lt;li&gt;Parallels Desktop 18.3.1&lt;/li&gt; &#xA; &lt;li&gt;Surge Pro 5.1.1 2264&lt;/li&gt; &#xA; &lt;li&gt;CleanMyMac X 4.13.4&lt;/li&gt; &#xA; &lt;li&gt;MWEB Pro 通杀&lt;/li&gt; &#xA; &lt;li&gt;App Cleaner &amp;amp; Uninstaller 8.2 已支持macOS 14&lt;/li&gt; &#xA; &lt;li&gt;解优2 1.6.1 通杀&lt;/li&gt; &#xA; &lt;li&gt;Adobe PhotoShop 24.5&lt;/li&gt; &#xA; &lt;li&gt;Adobe Acrobat 23.003.20201&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;仅支持Intel版本: 因为官方没有做M系处理器适配&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Navicat Premium 应用商店版通杀&lt;/li&gt; &#xA; &lt;li&gt;Office Word/PowerPoint/Excel 16.73 应用商店365订阅版&lt;/li&gt; &#xA; &lt;li&gt;Adobe Illustrator 27.5.0&lt;/li&gt; &#xA; &lt;li&gt;Adobe PhotoShop Beta 24.7 支持创意填充 需要随便登录个账户&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;提示：&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;会自动扫描本地安装的App，你只需要在想注入的App后面输入y即可。&lt;/li&gt; &#xA; &lt;li&gt;Adobe App如果不想让官方ACC乱拉屎，可以用这个仓库下载v6版本的离线安装包: &lt;a href=&#34;https://github.com/Antibioticss/adobe-packager&#34;&gt;https://github.com/Antibioticss/adobe-packager&lt;/a&gt;, 然后配合AntiCC之类的组件运行Adobe产品。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;警告&lt;/h3&gt; &#xA;&lt;p&gt;一定要关闭SIP，因为我使用的注入方式依赖于关闭SIP。&lt;/p&gt;</summary>
  </entry>
</feed>