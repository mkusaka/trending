<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-24T01:35:19Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>DataDog/dogstatsd-ruby</title>
    <updated>2025-06-24T01:35:19Z</updated>
    <id>tag:github.com,2025-06-24:/DataDog/dogstatsd-ruby</id>
    <link href="https://github.com/DataDog/dogstatsd-ruby" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Ruby client for DogStatsd&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;dogstatsd-ruby&lt;/h1&gt; &#xA;&lt;p&gt;A client for DogStatsD, an extension of the StatsD metric server for Datadog. Full API documentation is available in &lt;a href=&#34;https://www.rubydoc.info/github/DataDog/dogstatsd-ruby/master/Datadog/Statsd&#34;&gt;DogStatsD-ruby rubydoc&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://travis-ci.org/DataDog/dogstatsd-ruby&#34;&gt;&lt;img src=&#34;https://secure.travis-ci.org/DataDog/dogstatsd-ruby.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/DataDog/dogstatsd-ruby/master/CHANGELOG.md&#34;&gt;CHANGELOG.md&lt;/a&gt; for changes. To suggest a feature, report a bug, or general discussion, &lt;a href=&#34;http://github.com/DataDog/dogstatsd-ruby/issues/&#34;&gt;open an issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;First install the library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gem install dogstatsd-ruby&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;To instantiate a DogStatsd client:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Import the library&#xA;require &#39;datadog/statsd&#39;&#xA;&#xA;# Create a DogStatsD client instance&#xA;statsd = Datadog::Statsd.new(&#39;localhost&#39;, 8125)&#xA;# ...&#xA;# release resources used by the client instance&#xA;statsd.close()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or if you want to connect over Unix Domain Socket:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Connection over Unix Domain Socket&#xA;statsd = Datadog::Statsd.new(socket_path: &#39;/path/to/socket/file&#39;)&#xA;# ...&#xA;# release resources used by the client instance&#xA;statsd.close()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Find a list of all the available options for your DogStatsD Client in the &lt;a href=&#34;https://www.rubydoc.info/github/DataDog/dogstatsd-ruby/master/Datadog/Statsd&#34;&gt;DogStatsD-ruby rubydoc&lt;/a&gt; or in the &lt;a href=&#34;https://docs.datadoghq.com/developers/dogstatsd/?code-lang=ruby#client-instantiation-parameters&#34;&gt;Datadog public DogStatsD documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Migrating from v4.x to v5.x&lt;/h3&gt; &#xA;&lt;p&gt;If you are already using DogStatsD-ruby v4.x and you want to migrate to a version v5.x, the major change concerning you is the new &lt;a href=&#34;https://raw.githubusercontent.com/DataDog/dogstatsd-ruby/master/#threading-model&#34;&gt;threading model&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;p&gt;In practice, it means two things:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Now that the client is buffering metrics before sending them, you have to call &lt;code&gt;Datadog::Statsd#flush(sync: true)&lt;/code&gt; if you want synchronous behavior. In most cases, this is not needed, as the sender thread will automatically flush the buffered metrics if the buffer gets full or when you are closing the instance.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You have to make sure you are either:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using a singleton instance of the DogStatsD client instead of creating a new instance whenever you need one; this will let the buffering mechanism flush metrics regularly&lt;/li&gt; &#xA; &lt;li&gt;Or properly disposing of the DogStatsD client instance when it is not needed anymore using the method &lt;code&gt;Datadog::Statsd#close&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you have issues with the sender thread or the buffering mode, you can instantiate a client that behaves exactly as in v4.x (i.e. no sender thread and flush on every metric submission):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Create a DogStatsD client instance using UDP&#xA;statsd = Datadog::Statsd.new(&#39;localhost&#39;, 8125, single_thread: true, buffer_max_pool_size: 1)&#xA;# ...&#xA;statsd.close()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Create a DogStatsD client instance using UDS&#xA;statsd = Datadog::Statsd.new(socket_path: &#39;/path/to/socket/file&#39;, single_thread: true, buffer_max_pool_size: 1)&#xA;# ...&#xA;statsd.close()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;v5.x Common Pitfalls&lt;/h3&gt; &#xA;&lt;p&gt;Version v5.x of &lt;code&gt;dogstatsd-ruby&lt;/code&gt; is using a sender thread for flushing. This provides better performance, but you need to consider the following pitfalls:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Applications that use &lt;code&gt;fork&lt;/code&gt; after having created the dogstatsd instance: the child process will automatically spawn a new sender thread to flush metrics.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Applications that create multiple instances of the client without closing them: it is important to &lt;code&gt;#close&lt;/code&gt; all instances to free the thread and the socket they are using otherwise you will leak those resources.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you are using &lt;a href=&#34;https://github.com/mperham/sidekiq&#34;&gt;Sidekiq&lt;/a&gt;, please make sure to close the client instances that are instantiated. &lt;a href=&#34;https://github.com/DataDog/dogstatsd-ruby/raw/master/examples/sidekiq_example.rb&#34;&gt;See this example on using DogStatsD-ruby v5.x with Sidekiq&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Applications that run into issues but can&#39;t apply these recommendations should use the &lt;code&gt;single_thread&lt;/code&gt; mode which disables the use of the sender thread. Here is how to instantiate a client in this mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;statsd = Datadog::Statsd.new(&#39;localhost&#39;, 8125, single_thread: true)&#xA;# ...&#xA;# release resources used by the client instance and flush last metrics&#xA;statsd.close()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Origin detection over UDP&lt;/h3&gt; &#xA;&lt;p&gt;Origin detection is a method to detect which pod DogStatsD packets are coming from, in order to add the pod&#39;s tags to the tag list.&lt;/p&gt; &#xA;&lt;p&gt;To enable origin detection over UDP, add the following lines to your application manifest:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;env:&#xA;  - name: DD_ENTITY_ID&#xA;    valueFrom:&#xA;      fieldRef:&#xA;        fieldPath: metadata.uid&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The DogStatsD client attaches an internal tag, &lt;code&gt;entity_id&lt;/code&gt;. The value of this tag is the content of the &lt;code&gt;DD_ENTITY_ID&lt;/code&gt; environment variable, which is the pod’s UID.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;In order to use DogStatsD metrics, events, and Service Checks the Datadog Agent must be &lt;a href=&#34;https://docs.datadoghq.com/developers/dogstatsd/?tab=ruby&#34;&gt;running and available&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Metrics&lt;/h3&gt; &#xA;&lt;p&gt;After the client is created, you can start sending custom metrics to Datadog. See the dedicated &lt;a href=&#34;https://docs.datadoghq.com/metrics/dogstatsd_metrics_submission/?tab=ruby&#34;&gt;Metric Submission: DogStatsD documentation&lt;/a&gt; to see how to submit all supported metric types to Datadog with working code examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.datadoghq.com/metrics/dogstatsd_metrics_submission/?code-lang=ruby#count&#34;&gt;Submit a COUNT metric&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.datadoghq.com/metrics/dogstatsd_metrics_submission/?code-lang=ruby#gauge&#34;&gt;Submit a GAUGE metric&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.datadoghq.com/metrics/dogstatsd_metrics_submission/?code-lang=ruby#set&#34;&gt;Submit a SET metric&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.datadoghq.com/metrics/dogstatsd_metrics_submission/?code-lang=ruby#histogram&#34;&gt;Submit a HISTOGRAM metric&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.datadoghq.com/metrics/dogstatsd_metrics_submission/?code-lang=ruby#distribution&#34;&gt;Submit a DISTRIBUTION metric&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some options are suppported when submitting metrics, like &lt;a href=&#34;https://docs.datadoghq.com/metrics/dogstatsd_metrics_submission/?tab=ruby#metric-submission-options&#34;&gt;applying a Sample Rate to your metrics&lt;/a&gt; or &lt;a href=&#34;https://docs.datadoghq.com/metrics/dogstatsd_metrics_submission/?tab=ruby#metric-tagging&#34;&gt;tagging your metrics with your custom tags&lt;/a&gt;. Find all the available functions to report metrics in the &lt;a href=&#34;https://www.rubydoc.info/github/DataDog/dogstatsd-ruby/master/Datadog/Statsd&#34;&gt;DogStatsD-ruby rubydoc&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Events&lt;/h3&gt; &#xA;&lt;p&gt;After the client is created, you can start sending events to your Datadog Event Stream. See the dedicated &lt;a href=&#34;https://docs.datadoghq.com/events/guides/dogstatsd/?code-lang=ruby&#34;&gt;Event Submission: DogStatsD documentation&lt;/a&gt; to see how to submit an event to Datadog your Event Stream.&lt;/p&gt; &#xA;&lt;h3&gt;Service Checks&lt;/h3&gt; &#xA;&lt;p&gt;After the client is created, you can start sending Service Checks to Datadog. See the dedicated &lt;a href=&#34;https://docs.datadoghq.com/developers/service_checks/dogstatsd_service_checks_submission/?tab=ruby&#34;&gt;Service Check Submission: DogStatsD documentation&lt;/a&gt; to see how to submit a Service Check to Datadog.&lt;/p&gt; &#xA;&lt;h3&gt;Maximum packet size in high-throughput scenarios&lt;/h3&gt; &#xA;&lt;p&gt;In order to have the most efficient use of this library in high-throughput scenarios, recommended values for the maximum packet size have already been set for both UDS (8192 bytes) and UDP (1432 bytes).&lt;/p&gt; &#xA;&lt;p&gt;However, if are in control of your network and want to use a different value for the maximum packet size, you can do it by setting the &lt;code&gt;buffer_max_payload_size&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;statsd = Datadog::Statsd.new(&#39;localhost&#39;, 8125, buffer_max_payload_size: 4096)&#xA;# ...&#xA;statsd.close()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Threading model&lt;/h2&gt; &#xA;&lt;p&gt;Starting with version 5.0, &lt;code&gt;dogstatsd-ruby&lt;/code&gt; employs a new threading model where one instance of &lt;code&gt;Datadog::Statsd&lt;/code&gt; can be shared between threads and where data sending is non-blocking (asynchronous).&lt;/p&gt; &#xA;&lt;p&gt;When you instantiate a &lt;code&gt;Datadog::Statsd&lt;/code&gt;, a sender thread is spawned. This thread will be called the Sender thread, as it is modeled by the &lt;a href=&#34;https://raw.githubusercontent.com/DataDog/dogstatsd-ruby/lib/datadog/statsd/sender.rb&#34;&gt;Sender&lt;/a&gt; class. You can make use of &lt;code&gt;single_thread: true&lt;/code&gt; to disable this behavior.&lt;/p&gt; &#xA;&lt;p&gt;This thread is stopped when you close the statsd client (&lt;code&gt;Datadog::Statsd#close&lt;/code&gt;). Instantiating a lot of statsd clients without calling &lt;code&gt;#close&lt;/code&gt; after they are not needed anymore will most likely lead to threads being leaked.&lt;/p&gt; &#xA;&lt;p&gt;The sender thread has the following logic (from &lt;code&gt;Datadog::Statsd::Sender#send_loop&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;while the sender message queue is not closed do&#xA;  read message from sender message queue&#xA;&#xA;  if message is a Control message to flush&#xA;    flush buffer in connection&#xA;  else if message is a Control message to synchronize&#xA;    synchronize with calling thread&#xA;  else&#xA;    add message to the buffer&#xA;  end&#xA;end while&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are three different kinds of messages:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;a control message to flush the buffer in the connection&lt;/li&gt; &#xA; &lt;li&gt;a control message to synchronize any thread with the sender thread&lt;/li&gt; &#xA; &lt;li&gt;a message to append to the buffer&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;There is also an implicit message which closes the queue which will cause the sender thread to finish processing and exit.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;statsd = Datadog::Statsd.new(&#39;localhost&#39;, 8125)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The message queue&#39;s maximum size (in messages) is given by the &lt;code&gt;sender_queue_size&lt;/code&gt; argument, and has appropriate defaults for UDP (2048), UDS (512) and &lt;code&gt;single_thread: true&lt;/code&gt; (1).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;buffer_flush_interval&lt;/code&gt;, if enabled, is implemented with an additional thread which manages the timing of those flushes. This additional thread is used even if &lt;code&gt;single_thread: true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Usual workflow&lt;/h3&gt; &#xA;&lt;p&gt;You push metrics to the statsd client which writes them quickly to the sender message queue. The sender thread receives those message, buffers them and flushes them to the connection when the buffer limit is reached.&lt;/p&gt; &#xA;&lt;h3&gt;Flushing&lt;/h3&gt; &#xA;&lt;p&gt;When calling &lt;code&gt;Datadog::Statsd#flush&lt;/code&gt;, a specific control message (&lt;code&gt;:flush&lt;/code&gt;) is sent to the sender thread. When the sender thread receives it, it flushes its internal buffer into the connection.&lt;/p&gt; &#xA;&lt;h3&gt;Rendez-vous&lt;/h3&gt; &#xA;&lt;p&gt;It is possible to ensure a message has been consumed by the sender thread and written to the buffer by simply calling a rendez-vous right after. This is done when you are doing a synchronous flush using &lt;code&gt;Datadog::Statsd#flush(sync: true)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Doing so means the caller thread is blocked and waiting until the data has been flushed by the sender thread.&lt;/p&gt; &#xA;&lt;p&gt;This is useful when preparing to exit the application or when checking unit tests.&lt;/p&gt; &#xA;&lt;h3&gt;Thread-safety&lt;/h3&gt; &#xA;&lt;p&gt;By default, instances of &lt;code&gt;Datadog::Statsd&lt;/code&gt; are thread-safe and we recommend that a single instance be reused by all application threads (even in applications that employ forking). The sole exception is the &lt;code&gt;#close&lt;/code&gt; method — this method is not yet thread safe (work in progress here &lt;a href=&#34;https://github.com/DataDog/dogstatsd-ruby/pull/209&#34;&gt;#209&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;When using the &lt;code&gt;single_thread: true&lt;/code&gt; mode, instances of &lt;code&gt;Datadog::Statsd&lt;/code&gt; are still thread-safe, but you may run into contention on heavily-threaded applications, so we don’t recommend (for performance reasons) reusing these instances.&lt;/p&gt; &#xA;&lt;h3&gt;Delaying serialization&lt;/h3&gt; &#xA;&lt;p&gt;By default, message serialization happens synchronously whenever stat methods such as &lt;code&gt;#increment&lt;/code&gt; gets called, blocking the caller. If the blocking is impacting your program&#39;s performance, you may want to consider the &lt;code&gt;delay_serialization: true&lt;/code&gt; mode.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;delay_serialization: true&lt;/code&gt; mode delays the serialization of metrics to avoid the wait when submitting metrics. Serialization will still have to happen at some point, but it might be postponed until a more convenient time, such as after an HTTP request has completed.&lt;/p&gt; &#xA;&lt;p&gt;In &lt;code&gt;single_thread: true&lt;/code&gt; mode, you&#39;ll probably want to set &lt;code&gt;sender_queue_size:&lt;/code&gt; from it&#39;s default of &lt;code&gt;1&lt;/code&gt; to some greater value, so that it can benefit from &lt;code&gt;delay_serialization: true&lt;/code&gt;. Messages will then be queued unserialized in the sender queue and processed normally whenever &lt;code&gt;sender_queue_size&lt;/code&gt; is reached or &lt;code&gt;#flush&lt;/code&gt; is called. You might set &lt;code&gt;sender_queue_size: Float::INFINITY&lt;/code&gt; to allow for an unbounded queue that will only be processed on explicit &lt;code&gt;#flush&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In &lt;code&gt;single_thread: false&lt;/code&gt; mode, &lt;code&gt;delay_serialization: true&lt;/code&gt;, will cause serialization to happen inside the sender thread.&lt;/p&gt; &#xA;&lt;h2&gt;Versioning&lt;/h2&gt; &#xA;&lt;p&gt;This Ruby gem is using &lt;a href=&#34;https://guides.rubygems.org/patterns/#semantic-versioning&#34;&gt;Semantic Versioning&lt;/a&gt; but please note that supported Ruby versions can change in a minor release of this library. As much as possible, we will add a &#34;future deprecation&#34; message in the minor release preceding the one dropping the support.&lt;/p&gt; &#xA;&lt;h2&gt;Ruby Versions&lt;/h2&gt; &#xA;&lt;p&gt;This gem supports and is tested on Ruby minor versions 2.1 through 3.3. Support for Ruby 2.0 was dropped in version 5.4.0.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;dogstatsd-ruby is forked from Rein Henrichs&#39; &lt;a href=&#34;https://github.com/reinh/statsd&#34;&gt;original Statsd client&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2011 Rein Henrichs. See LICENSE.txt for further details.&lt;/p&gt;</summary>
  </entry>
</feed>