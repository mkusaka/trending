<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-12T01:45:03Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>active-hash/active_hash</title>
    <updated>2023-02-12T01:45:03Z</updated>
    <id>tag:github.com,2023-02-12:/active-hash/active_hash</id>
    <link href="https://github.com/active-hash/active_hash" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A readonly ActiveRecord-esque base class that lets you use a hash, a Yaml file or a custom file as the datasource&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ActiveHash&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/active-hash/active_hash/actions/workflows/ruby.yml&#34;&gt;&lt;img src=&#34;https://github.com/active-hash/active_hash/actions/workflows/ruby.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;ActiveHash is a simple base class that allows you to use a ruby hash as a readonly datasource for an ActiveRecord-like model.&lt;/p&gt; &#xA;&lt;p&gt;ActiveHash assumes that every hash has an :id key, which is what you would probably store in a database. This allows you to seamlessly upgrade from ActiveHash objects to full ActiveRecord objects without having to change any code in your app, or any foreign keys in your database.&lt;/p&gt; &#xA;&lt;p&gt;It also allows you to use #has_many and #belongs_to (via belongs_to_active_hash) in your AR objects.&lt;/p&gt; &#xA;&lt;p&gt;ActiveHash can also be useful to create simple test classes that run without a database - ideal for testing plugins or gems that rely on simple AR behavior, but don&#39;t want to deal with databases or migrations for the spec suite.&lt;/p&gt; &#xA;&lt;p&gt;ActiveHash also ships with:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ActiveFile: a base class that you can use to create file data sources&lt;/li&gt; &#xA; &lt;li&gt;ActiveYaml: a base class that will turn YAML into a hash and load the data into an ActiveHash object&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;!!! Important notice !!!&lt;/h2&gt; &#xA;&lt;p&gt;We have changed returned value to chainable by v3.0.0. It&#39;s not just an &lt;code&gt;Array&lt;/code&gt; instance anymore. If it breaks your application, please report us on &lt;a href=&#34;https://github.com/active-hash/active_hash/issues&#34;&gt;issues&lt;/a&gt;, and use v2.x.x as following..&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;active_hash&#39;, &#39;~&amp;gt; 2.3.0&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Bundler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;active_hash&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Other:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem install active_hash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Currently version 2.x doesn&#39;t support Ruby &amp;lt; 2.4 and Rails &amp;lt; 5&lt;/strong&gt;. If you use these versions, please use 1.x.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;active_hash&#39;, &#39;~&amp;gt; 1.5.3&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Reason for being&lt;/h2&gt; &#xA;&lt;p&gt;We wrote ActiveHash so that we could use simple, in-memory, ActiveRecord-like data structures that play well with Rails forms, like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# in app/models/country.rb&#xA;class Country &amp;lt; ActiveHash::Base&#xA;  self.data = [&#xA;    {:id =&amp;gt; 1, :name =&amp;gt; &#34;US&#34;},&#xA;    {:id =&amp;gt; 2, :name =&amp;gt; &#34;Canada&#34;}&#xA;  ]&#xA;end&#xA;&#xA;# in some view&#xA;&amp;lt;%= collection_select :person, :country_id, Country.all, :id, :name %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Before ActiveHash, we did things like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# in app/models/person.rb&#xA;class Person &amp;lt; ActiveRecord::Base&#xA;  COUNTRIES = [&#34;US&#34;, &#34;Canada&#34;]&#xA;end&#xA;&#xA;# in some view&#xA;&amp;lt;%= collection_select :person, :country_id, Person::COUNTRIES, :to_s, :to_s %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The majority of ActiveHash uses involve setting up some data at boot time, and never modifying that data at runtime.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;To use ActiveHash, you need to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Inherit from ActiveHash::Base&lt;/li&gt; &#xA; &lt;li&gt;Define your data&lt;/li&gt; &#xA; &lt;li&gt;Define your fields and/or default values&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A quick example would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Country &amp;lt; ActiveHash::Base&#xA;  self.data = [&#xA;    {:id =&amp;gt; 1, :name =&amp;gt; &#34;US&#34;},&#xA;    {:id =&amp;gt; 2, :name =&amp;gt; &#34;Canada&#34;}&#xA;  ]&#xA;end&#xA;&#xA;country = Country.new(:name =&amp;gt; &#34;Mexico&#34;)&#xA;country.name  # =&amp;gt; &#34;Mexico&#34;&#xA;country.name? # =&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use &lt;em&gt;create&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Country &amp;lt; ActiveHash::Base&#xA;  field :name&#xA;  create :id =&amp;gt; 1, :name =&amp;gt; &#34;US&#34;&#xA;  create :id =&amp;gt; 2, :name =&amp;gt; &#34;Canada&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use &lt;em&gt;add&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Country &amp;lt; ActiveHash::Base&#xA;  field :name&#xA;  add :id =&amp;gt; 1, :name =&amp;gt; &#34;US&#34;&#xA;  add :id =&amp;gt; 2, :name =&amp;gt; &#34;Canada&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Auto-Defined fields&lt;/h2&gt; &#xA;&lt;p&gt;ActiveHash will auto-define all fields for you when you load the hash. For example, if you have the following class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class CustomField &amp;lt; ActiveHash::Base&#xA;  self.data = [&#xA;    {:custom_field_1 =&amp;gt; &#34;foo&#34;},&#xA;    {:custom_field_2 =&amp;gt; &#34;foo&#34;},&#xA;    {:custom_field_3 =&amp;gt; &#34;foo&#34;}&#xA;  ]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you call CustomField.all it will define methods for :custom_field_1, :custom_field_2 etc...&lt;/p&gt; &#xA;&lt;p&gt;If you need the fields at load time, as opposed to after .all is called, you can also define them manually, like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class CustomField &amp;lt; ActiveHash::Base&#xA;  fields :custom_field_1, :custom_field_2, :custom_field_3&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: auto-defined fields will &lt;em&gt;not&lt;/em&gt; override fields you&#39;ve defined, either on the class or on the instance.&lt;/p&gt; &#xA;&lt;h2&gt;Defining Fields with default values&lt;/h2&gt; &#xA;&lt;p&gt;If some of your hash values contain nil, and you want to provide a default, you can specify defaults with the :field method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Country &amp;lt; ActiveHash::Base&#xA;  field :is_axis_of_evil, :default =&amp;gt; false&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Defining Data&lt;/h2&gt; &#xA;&lt;p&gt;You can define data inside your class or outside. For example, you might have a class like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/models/country.rb&#xA;class Country &amp;lt; ActiveHash::Base&#xA;end&#xA;&#xA;# config/initializers/data.rb&#xA;Rails.application.config.to_prepare do&#xA;  Country.data = [&#xA;      {:id =&amp;gt; 1, :name =&amp;gt; &#34;US&#34;},&#xA;      {:id =&amp;gt; 2, :name =&amp;gt; &#34;Canada&#34;}&#xA;  ]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you prefer to store your data in YAML, see below.&lt;/p&gt; &#xA;&lt;h2&gt;Class Methods&lt;/h2&gt; &#xA;&lt;p&gt;ActiveHash gives you ActiveRecord-esque methods like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Country.all                    # =&amp;gt; returns all Country objects&#xA;Country.count                  # =&amp;gt; returns the length of the .data array&#xA;Country.first                  # =&amp;gt; returns the first country object&#xA;Country.last                   # =&amp;gt; returns the last country object&#xA;Country.find 1                 # =&amp;gt; returns the first country object with that id&#xA;Country.find [1,2]             # =&amp;gt; returns all Country objects with ids in the array&#xA;Country.find :all              # =&amp;gt; same as .all&#xA;Country.find :all, args        # =&amp;gt; the second argument is totally ignored, but allows it to play nicely with AR&#xA;Country.find { |country| country.name.start_with?(&#39;U&#39;) } # =&amp;gt; returns the first country for which the block evaluates to true&#xA;Country.find_by_id 1           # =&amp;gt; find the first object that matches the id&#xA;Country.find_by(name: &#39;US&#39;)    # =&amp;gt; returns the first country object with specified argument&#xA;Country.find_by!(name: &#39;US&#39;)   # =&amp;gt; same as find_by, but raise exception when not found&#xA;Country.where(name: &#39;US&#39;)      # =&amp;gt; returns all records with name: &#39;US&#39;&#xA;Country.where.not(name: &#39;US&#39;)  # =&amp;gt; returns all records without name: &#39;US&#39;&#xA;Country.order(name: :desc)     # =&amp;gt; returns all records ordered by name attribute in DESC order&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It also gives you a few dynamic finder methods. For example, if you defined :name as a field, you&#39;d get:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Country.find_by_name &#34;foo&#34;                    # =&amp;gt; returns the first object matching that name&#xA;Country.find_all_by_name &#34;foo&#34;                # =&amp;gt; returns an array of the objects with matching names&#xA;Country.find_by_id_and_name 1, &#34;Germany&#34;      # =&amp;gt; returns the first object matching that id and name&#xA;Country.find_all_by_id_and_name 1, &#34;Germany&#34;  # =&amp;gt; returns an array of objects matching that name and id&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Furthermore, it allows to create custom scope query methods, similar to how it&#39;s possible with ActiveRecord:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Country.scope :english, -&amp;gt; { where(language: &#39;English&#39;) } # Creates a class method Country.english performing the given query&#xA;Country.scope :with_language, -&amp;gt;(language) { where(language: language) } # Creates a class method Country.with_language(language) performing the given query&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Instance Methods&lt;/h2&gt; &#xA;&lt;p&gt;ActiveHash objects implement enough of the ActiveRecord api to satisfy most common needs. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Country#id          # =&amp;gt; returns the id or nil&#xA;Country#id=         # =&amp;gt; sets the id attribute&#xA;Country#quoted_id   # =&amp;gt; returns the numeric id&#xA;Country#to_param    # =&amp;gt; returns the id as a string&#xA;Country#new_record? # =&amp;gt; returns true if is not part of Country.all, false otherwise&#xA;Country#readonly?   # =&amp;gt; true&#xA;Country#hash        # =&amp;gt; the hash of the id (or the hash of nil)&#xA;Country#eql?        # =&amp;gt; compares type and id, returns false if id is nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ActiveHash also gives you methods related to the fields you defined. For example, if you defined :name as a field, you&#39;d get:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Country#name        # =&amp;gt; returns the passed in name&#xA;Country#name?       # =&amp;gt; returns true if the name is not blank&#xA;Country#name=       # =&amp;gt; sets the name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Saving in-memory records&lt;/h2&gt; &#xA;&lt;p&gt;The ActiveHash::Base.all method functions like an in-memory data store. You can save your records as ActiveHash::Relation object by using standard ActiveRecord create and save methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Country.all&#xA;=&amp;gt; #&amp;lt;ActiveHash::Relation:0x00007f861e043bb0 @klass=Country, @all_records=[], @query_hash={}, @records_dirty=false&amp;gt;&#xA;Country.create&#xA;=&amp;gt; #&amp;lt;Country:0x00007f861b7abce8 @attributes={:id=&amp;gt;1}&amp;gt;&#xA;Country.all&#xA;=&amp;gt; #&amp;lt;ActiveHash::Relation:0x00007f861b7b3628 @klass=Country, @all_records=[#&amp;lt;Country:0x00007f861b7abce8 @attributes={:id=&amp;gt;1}&amp;gt;], @query_hash={}, @records_dirty=false&amp;gt;&#xA;country = Country.new&#xA;=&amp;gt; #&amp;lt;Country:0x00007f861e059938 @attributes={}&amp;gt;&#xA;country.new_record?&#xA;=&amp;gt; true&#xA;country.save&#xA;=&amp;gt; true&#xA;country.new_record?&#xA;# =&amp;gt; false&#xA;Country.all&#xA;=&amp;gt; #&amp;lt;ActiveHash::Relation:0x00007f861e0ca610 @klass=Country, @all_records=[#&amp;lt;Country:0x00007f861b7abce8 @attributes={:id=&amp;gt;1}&amp;gt;, #&amp;lt;Country:0x00007f861e059938 @attributes={:id=&amp;gt;2}&amp;gt;], @query_hash={}, @records_dirty=false&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that when adding records to the collection, it will auto-increment the id for you by default. If you use string ids, it will not auto-increment the id. Available methods are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Country.insert( record )&#xA;Country#save&#xA;Country#save!&#xA;Country.create&#xA;Country.create!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As such, ActiveHash::Base and its descendants should work with Fixjour or FactoryBot, so you can treat ActiveHash records the same way you would any other ActiveRecord model in tests.&lt;/p&gt; &#xA;&lt;p&gt;To clear all records from the in-memory array, call delete_all:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Country.delete_all  # =&amp;gt; does not affect the yaml files in any way - just clears the in-memory array which can be useful for testing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Referencing ActiveHash objects from ActiveRecord Associations&lt;/h2&gt; &#xA;&lt;p&gt;One common use case for ActiveHash is to have top-level objects in memory that ActiveRecord objects belong to.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Country &amp;lt; ActiveHash::Base&#xA;end&#xA;&#xA;class Person &amp;lt; ActiveRecord::Base&#xA;  extend ActiveHash::Associations::ActiveRecordExtensions&#xA;  belongs_to :country&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: this needs to be called on a subclass of ActiveRecord::Base. If you extend ActiveRecord::Base, it will not work. If you want to extend ActiveRecord::Base so all your AR models can belong to ActiveHash::Base objects, you can use the &lt;code&gt;belongs_to_active_hash&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ActiveRecord::Base.extend ActiveHash::Associations::ActiveRecordExtensions&#xA;&#xA;class Country &amp;lt; ActiveHash::Base&#xA;end&#xA;&#xA;class Person &amp;lt; ActiveRecord::Base&#xA;  belongs_to_active_hash :country&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using shortcuts&lt;/h3&gt; &#xA;&lt;p&gt;Since ActiveHashes usually are static, we can use shortcuts to assign via an easy to remember string instead of an obscure ID number.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/models/country.rb&#xA;class Country &amp;lt; ActiveHash::Base&#xA;end&#xA;&#xA;# app/models/person.rb&#xA;class Person &amp;lt; ActiveRecord::Base&#xA;  extend ActiveHash::Associations::ActiveRecordExtensions&#xA;  belongs_to_active_hash :country, :shortcuts =&amp;gt; [:name]&#xA;end&#xA;&#xA;# config/initializers/data.rb&#xA;Rails.application.config.to_prepare do&#xA;  Country.data = [&#xA;      {:id =&amp;gt; 1, :name =&amp;gt; &#34;US&#34;},&#xA;      {:id =&amp;gt; 2, :name =&amp;gt; &#34;Canada&#34;}&#xA;  ]&#xA;end&#xA;&#xA;# Using `rails console`&#xA;john = Person.new&#xA;john.country_name = &#34;US&#34;&#xA;# Is the same as doing `john.country = Country.find_by_name(&#34;US&#34;)`&#xA;john.country_name&#xA;# Will return &#34;US&#34;, and is the same as doing `john.country.try(:name)`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can have multiple shortcuts, so settings &lt;code&gt;:shortcuts =&amp;gt; [:name, :friendly_name]&lt;/code&gt; will enable you to use &lt;code&gt;#country_name=&lt;/code&gt; and &lt;code&gt;#country_friendly_name=&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Referencing ActiveRecord objects from ActiveHash&lt;/h2&gt; &#xA;&lt;p&gt;If you include the ActiveHash::Associations module, you can also create associations from your ActiveHash classes, like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Country &amp;lt; ActiveHash::Base&#xA;  include ActiveHash::Associations&#xA;  has_many :people&#xA;end&#xA;&#xA;class Person &amp;lt; ActiveHash::Base&#xA;  include ActiveHash::Associations&#xA;  belongs_to :country&#xA;  has_many :pets&#xA;end&#xA;&#xA;class Pet &amp;lt; ActiveRecord::Base&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you define a belongs to, you also get the setter method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class City &amp;lt; ActiveHash::Base&#xA;  include ActiveHash::Associations&#xA;  belongs_to :state&#xA;end&#xA;&#xA;city = City.new&#xA;city.state = State.first&#xA;city.state_id             # is State.first.id&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: You cannot use ActiveHash objects as children of ActiveRecord and I don&#39;t plan on adding support for that. It doesn&#39;t really make any sense, since you&#39;d have to hard-code your database ids in your class or yaml files, which is a dependency inversion.&lt;/p&gt; &#xA;&lt;p&gt;Thanks to baldwindavid for the ideas and code on that one.&lt;/p&gt; &#xA;&lt;h2&gt;ActiveYaml&lt;/h2&gt; &#xA;&lt;p&gt;If you want to store your data in YAML files, just inherit from ActiveYaml and specify your path information:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Country &amp;lt; ActiveYaml::Base&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, this class will look for a yml file named &#34;countries.yml&#34; in the same directory as the file. You can either change the directory it looks in, the filename it looks for, or both:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Country &amp;lt; ActiveYaml::Base&#xA;  set_root_path &#34;/u/data&#34;&#xA;  set_filename &#34;sample&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above example will look for the file &#34;/u/data/sample.yml&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Since ActiveYaml just creates a hash from the YAML file, you will have all fields specified in YAML auto-defined for you. You can format your YAML as an array, or as a hash:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# array style&#xA;- id: 1&#xA;  name: US&#xA;- id: 2&#xA;  name: Canada&#xA;- id: 3&#xA;  name: Mexico&#xA;&#xA;# hash style&#xA;us:&#xA;  id: 1&#xA;  name: US&#xA;canada:&#xA;  id: 2&#xA;  name: Canada&#xA;mexico:&#xA;  id: 3&#xA;  name: Mexico&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Automatic Key Attribute&lt;/h3&gt; &#xA;&lt;p&gt;When using the hash format for your YAML file, ActiveYaml will automatically add a &lt;code&gt;key&lt;/code&gt; attribute with the name of the object. You can overwrite this by setting the key attribute in the YAML file. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;au:&#xA;  id: 1&#xA;  name: Australia&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you access the object you can do &lt;code&gt;Country.find(1).key =&amp;gt; &#39;au&#39;&lt;/code&gt;. Or &lt;code&gt;Country.find_by_key(&#39;au&#39;)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you want a different key on only some objects you can mix and match:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;au:&#xA;  id: 1&#xA;  key: aus&#xA;  name: Australia&#xA;nz:&#xA;  id: 2&#xA;  name: New Zealand&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Country.find(1).key =&amp;gt; &#39;aus&#39;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Country.find(2).key =&amp;gt; &#39;nz&#39;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Multiple files per model&lt;/h3&gt; &#xA;&lt;p&gt;You can use multiple files to store your data. You will have to choose between hash or array style as you cannot use both for one model.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Country &amp;lt; ActiveYaml::Base&#xA;  use_multiple_files&#xA;  set_filenames &#34;europe&#34;, &#34;america&#34;, &#34;asia&#34;, &#34;africa&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using aliases in YAML&lt;/h3&gt; &#xA;&lt;p&gt;Aliases can be used in ActiveYaml using either array or hash style by including &lt;code&gt;ActiveYaml::Aliases&lt;/code&gt;. With that module included, keys beginning with a &#39;/&#39; character can be safely added, and will be ignored, allowing you to add aliases anywhere in your code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# Array Style&#xA;- /aliases:&#xA;  soda_flavor: &amp;amp;soda_flavor&#xA;    sweet&#xA;  soda_price: &amp;amp;soda_price&#xA;    1.0&#xA;&#xA;- id: 1&#xA;  name: Coke&#xA;  flavor: *soda_flavor&#xA;  price: *soda_price&#xA;&#xA;&#xA; # Key style&#xA;/aliases:&#xA;  soda_flavor: &amp;amp;soda_flavor&#xA;    sweet&#xA;  soda_price: &amp;amp;soda_price&#xA;    1.0&#xA;&#xA;coke:&#xA;  id: 1&#xA;  name: Coke&#xA;  flavor: *soda_flavor&#xA;  price: *soda_price&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Soda &amp;lt; ActiveYaml::Base&#xA;  include ActiveYaml::Aliases&#xA;end&#xA;&#xA;Soda.length # =&amp;gt; 1&#xA;Soda.first.flavor # =&amp;gt; sweet&#xA;Soda.first.price # =&amp;gt; 1.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using ERB ruby in YAML&lt;/h3&gt; &#xA;&lt;p&gt;Embedded ruby can be used in ActiveYaml using erb brackets &lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; to set the result of a ruby operation as a value in the yaml file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- id: 1&#xA;  email: &amp;lt;%= &#34;user#{rand(100)}@email.com&#34; %&amp;gt;&#xA;  password: &amp;lt;%= ENV[&#39;USER_PASSWORD&#39;] %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;ActiveJSON&lt;/h2&gt; &#xA;&lt;p&gt;If you want to store your data in JSON files, just inherit from ActiveJSON and specify your path information:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Country &amp;lt; ActiveJSON::Base&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, this class will look for a json file named &#34;countries.json&#34; in the same directory as the file. You can either change the directory it looks in, the filename it looks for, or both:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Country &amp;lt; ActiveJSON::Base&#xA;  set_root_path &#34;/u/data&#34;&#xA;  set_filename &#34;sample&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above example will look for the file &#34;/u/data/sample.json&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Since ActiveJSON just creates a hash from the JSON file, you will have all fields specified in JSON auto-defined for you. You can format your JSON as an array, or as a hash:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# array style&#xA;[&#xA;  {&#xA;    &#34;id&#34;: 1,&#xA;    &#34;name&#34;: &#34;US&#34;,&#xA;    &#34;custom_field_1&#34;: &#34;value1&#34;&#xA;  },&#xA;  {&#xA;    &#34;id&#34;: 2,&#xA;    &#34;name&#34;: &#34;Canada&#34;,&#xA;    &#34;custom_field_2&#34;: &#34;value2&#34;&#xA;  }&#xA;]&#xA;&#xA;# hash style&#xA; {&#xA;  { &#34;us&#34;:&#xA;    {&#xA;      &#34;id&#34;: 1,&#xA;      &#34;name&#34;: &#34;US&#34;,&#xA;      &#34;custom_field_1&#34;: &#34;value1&#34;&#xA;    }&#xA;  },&#xA;  { &#34;canada&#34;:&#xA;    {&#xA;      &#34;id&#34;: 2,&#xA;      &#34;name&#34;: &#34;Canada&#34;,&#xA;      &#34;custom_field_2&#34;: &#34;value2&#34;&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiple files per model&lt;/h3&gt; &#xA;&lt;p&gt;This works as it does for &lt;code&gt;ActiveYaml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;ActiveFile&lt;/h2&gt; &#xA;&lt;p&gt;If you store encrypted data, or you&#39;d like to store your flat files as CSV or XML or any other format, you can easily include ActiveHash to parse and load your file. Just add a custom ::load_file method, and define the extension you want the file to use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Country &amp;lt; ActiveFile::Base&#xA;  set_root_path &#34;/u/data&#34;&#xA;  set_filename &#34;sample&#34;&#xA;&#xA;  class &amp;lt;&amp;lt; self&#xA;    def extension&#xA;      &#34;super_secret&#34;&#xA;    end&#xA;&#xA;    def load_file&#xA;      MyAwesomeDecoder.load_file(full_path)&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The two methods you need to implement are load_file, which needs to return an array of hashes, and .extension, which returns the file extension you are using. You have full_path available to you if you wish, or you can provide your own path.&lt;/p&gt; &#xA;&lt;p&gt;Setting the default file location in Rails:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/active_file.rb&#xA;ActiveFile::Base.set_root_path &#34;config/activefiles&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In Rails, in development mode, it reloads the entire class, which reloads the file. In production, the data cached in memory.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: By default, .full_path refers to the current working directory. In a rails app, this will be RAILS_ROOT.&lt;/p&gt; &#xA;&lt;h2&gt;Reloading ActiveYaml, ActiveJSON and ActiveFile&lt;/h2&gt; &#xA;&lt;p&gt;During the development you may often change your data and want to see your changes immediately. Call &lt;code&gt;Model.reload(true)&lt;/code&gt; to force reload the data from disk.&lt;/p&gt; &#xA;&lt;p&gt;In Rails, you can use this snippet. Please just note it resets the state every request, which may not always be desired.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;before_filter do&#xA;  [Model1, Model2, Model3].each { |m| m.reload(true) }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Enum&lt;/h2&gt; &#xA;&lt;p&gt;ActiveHash can expose its data in an Enumeration by setting constants for each record. This allows records to be accessed in code through a constant set in the ActiveHash class.&lt;/p&gt; &#xA;&lt;p&gt;The field to be used as the constant is set using &lt;em&gt;enum_accessor&lt;/em&gt; which takes the name of a field as an argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Country &amp;lt; ActiveHash::Base&#xA;  include ActiveHash::Enum&#xA;  self.data = [&#xA;      {:id =&amp;gt; 1, :name =&amp;gt; &#34;US&#34;, :capital =&amp;gt; &#34;Washington, DC&#34;},&#xA;      {:id =&amp;gt; 2, :name =&amp;gt; &#34;Canada&#34;, :capital =&amp;gt; &#34;Ottawa&#34;},&#xA;      {:id =&amp;gt; 3, :name =&amp;gt; &#34;Mexico&#34;, :capital =&amp;gt; &#34;Mexico City&#34;}&#xA;  ]&#xA;  enum_accessor :name&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Records can be accessed by looking up the field constant:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; Country::US.capital&#xA;=&amp;gt; &#34;Washington DC&#34;&#xA;&amp;gt;&amp;gt; Country::MEXICO.id&#xA;=&amp;gt; 3&#xA;&amp;gt;&amp;gt; Country::CANADA&#xA;=&amp;gt; #&amp;lt;Country:0x10229fb28 @attributes={:name=&amp;gt;&#34;Canada&#34;, :id=&amp;gt;2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may also use multiple attributes to generate the constant, like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Town &amp;lt; ActiveHash::Base&#xA;  include ActiveHash::Enum&#xA;  self.data = [&#xA;      {:id =&amp;gt; 1, :name =&amp;gt; &#34;Columbus&#34;, :state =&amp;gt; &#34;NY&#34;},&#xA;      {:id =&amp;gt; 2, :name =&amp;gt; &#34;Columbus&#34;, :state =&amp;gt; &#34;OH&#34;}&#xA;  ]&#xA;  enum_accessor :name, :state&#xA;end&#xA;&#xA;&amp;gt;&amp;gt; Town::COLUMBUS_NY&#xA;&amp;gt;&amp;gt; Town::COLUMBUS_OH&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Constants are formed by first stripping all non-word characters and then upcasing the result. This means strings like &#34;Blazing Saddles&#34;, &#34;ReBar&#34;, &#34;Mike &amp;amp; Ike&#34; and &#34;Ho! Ho! Ho!&#34; become BLAZING_SADDLES, REBAR, MIKE_IKE and HO_HO_HO.&lt;/p&gt; &#xA;&lt;p&gt;The field specified as the &lt;em&gt;enum_accessor&lt;/em&gt; must contain unique data values.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;d like to become an ActiveHash contributor, the easiest way it to fork this repo, make your changes, run the specs and submit a pull request once they pass.&lt;/p&gt; &#xA;&lt;p&gt;To run specs, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle install&#xA;bundle exec rspec spec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your changes seem reasonable and the specs pass I&#39;ll give you commit rights to this repo and add you to the list of people who can push the gem.&lt;/p&gt; &#xA;&lt;h2&gt;Releasing a new version&lt;/h2&gt; &#xA;&lt;p&gt;To make users&#39; lives easier, please maintain support for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ruby 2.4&lt;/li&gt; &#xA; &lt;li&gt;ActiveRecord/ActiveSupport from 5.0 through edge&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To that end, run specs against all rubies before committing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;wwtd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once appraisal passes in all supported rubies, follow these steps to release a new version of active_hash:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;update the changelog with a brief summary of the changes that are included in the release&lt;/li&gt; &#xA; &lt;li&gt;bump the gem version by editing the &lt;code&gt;version.rb&lt;/code&gt; file&lt;/li&gt; &#xA; &lt;li&gt;if there are new contributors, add them to the list of authors in the gemspec&lt;/li&gt; &#xA; &lt;li&gt;run &lt;code&gt;rake build&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;commit those changes&lt;/li&gt; &#xA; &lt;li&gt;run &lt;code&gt;rake install&lt;/code&gt; and verify that the gem loads correctly from an irb session&lt;/li&gt; &#xA; &lt;li&gt;run &lt;code&gt;rake release&lt;/code&gt;, which will rebuild the gem, tag it, push the tags (and your latest commit) to github, then push the gem to rubygems.org&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you have any questions about how to maintain backwards compatibility, please email me and we can figure it out.&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2010 Jeff Dean. See LICENSE for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>roo-rb/roo</title>
    <updated>2023-02-12T01:45:03Z</updated>
    <id>tag:github.com,2023-02-12:/roo-rb/roo</id>
    <link href="https://github.com/roo-rb/roo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Roo provides an interface to spreadsheets of several sorts.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Roo&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/roo-rb/roo&#34;&gt;&lt;img src=&#34;https://img.shields.io/travis/roo-rb/roo.svg?style=flat-square&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/roo-rb/roo/maintainability&#34;&gt;&lt;img src=&#34;https://api.codeclimate.com/v1/badges/be8d7bf34e2aeaf67c62/maintainability&#34; alt=&#34;Maintainability&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/r/roo-rb/roo&#34;&gt;&lt;img src=&#34;https://img.shields.io/coveralls/roo-rb/roo.svg?style=flat-square&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://rubygems.org/gems/roo&#34;&gt;&lt;img src=&#34;https://img.shields.io/gem/v/roo.svg?style=flat-square&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Roo implements read access for all common spreadsheet types. It can handle:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Excel 2007 - 2013 formats (xlsx, xlsm)&lt;/li&gt; &#xA; &lt;li&gt;LibreOffice / OpenOffice.org formats (ods)&lt;/li&gt; &#xA; &lt;li&gt;CSV&lt;/li&gt; &#xA; &lt;li&gt;Excel 97, Excel 2002 XML, and Excel 2003 XML formats when using the &lt;a href=&#34;https://github.com/roo-rb/roo-xls&#34;&gt;roo-xls&lt;/a&gt; gem (xls, xml)&lt;/li&gt; &#xA; &lt;li&gt;Google spreadsheets with read/write access when using &lt;a href=&#34;https://github.com/roo-rb/roo-google&#34;&gt;roo-google&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install as a gem&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install roo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or add it to your Gemfile&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;roo&#34;, &#34;~&amp;gt; 2.10.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Opening a spreadsheet&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;roo&#39;&#xA;&#xA;xlsx = Roo::Spreadsheet.open(&#39;./new_prices.xlsx&#39;)&#xA;xlsx = Roo::Excelx.new(&#34;./new_prices.xlsx&#34;)&#xA;&#xA;# Use the extension option if the extension is ambiguous.&#xA;xlsx = Roo::Spreadsheet.open(&#39;./rails_temp_upload&#39;, extension: :xlsx)&#xA;&#xA;xlsx.info&#xA;# =&amp;gt; Returns basic info about the spreadsheet file&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Roo::Spreadsheet.open&lt;/code&gt; can accept both paths and &lt;code&gt;File&lt;/code&gt; instances.&lt;/p&gt; &#xA;&lt;h3&gt;Working with sheets&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ods.sheets&#xA;# =&amp;gt; [&#39;Info&#39;, &#39;Sheet 2&#39;, &#39;Sheet 3&#39;]   # an Array of sheet names in the workbook&#xA;&#xA;ods.sheet(&#39;Info&#39;).row(1)&#xA;ods.sheet(0).row(1)&#xA;&#xA;# Set the last sheet as the default sheet.&#xA;ods.default_sheet = ods.sheets.last&#xA;ods.default_sheet = ods.sheets[2]&#xA;ods.default_sheet = &#39;Sheet 3&#39;&#xA;&#xA;# Iterate through each sheet&#xA;ods.each_with_pagename do |name, sheet|&#xA;  p sheet.row(1)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Accessing rows and columns&lt;/h3&gt; &#xA;&lt;p&gt;Roo uses Excel&#39;s numbering for rows, columns and cells, so &lt;code&gt;1&lt;/code&gt; is the first index, not &lt;code&gt;0&lt;/code&gt; as it is in an &lt;code&gt;Array&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sheet.row(1)&#xA;# returns the first row of the spreadsheet.&#xA;&#xA;sheet.column(1)&#xA;# returns the first column of the spreadsheet.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Almost all methods have an optional argument &lt;code&gt;sheet&lt;/code&gt;. If this parameter is omitted, the default_sheet will be used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sheet.first_row(sheet.sheets[0])&#xA;# =&amp;gt; 1             # the number of the first row&#xA;sheet.last_row&#xA;# =&amp;gt; 42            # the number of the last row&#xA;sheet.first_column&#xA;# =&amp;gt; 1             # the number of the first column&#xA;sheet.last_column&#xA;# =&amp;gt; 10            # the number of the last column&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Accessing cells&lt;/h4&gt; &#xA;&lt;p&gt;You can access the top-left cell in the following ways&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sheet.cell(1,1)&#xA;sheet.cell(&#39;A&#39;,1)&#xA;sheet.cell(1,&#39;A&#39;)&#xA;sheet.a1&#xA;&#xA;# Access the second sheet&#39;s top-left cell.&#xA;sheet.cell(1,&#39;A&#39;,sheet.sheets[1])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Querying a spreadsheet&lt;/h4&gt; &#xA;&lt;p&gt;Use &lt;code&gt;each&lt;/code&gt; to iterate over each row.&lt;/p&gt; &#xA;&lt;p&gt;If each is given a hash with the names of some columns, then each will generate a hash with the columns supplied for each row.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sheet.each(id: &#39;ID&#39;, name: &#39;FULL_NAME&#39;) do |hash|&#xA;  puts hash.inspect&#xA;  # =&amp;gt; { id: 1, name: &#39;John Smith&#39; }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;sheet.parse&lt;/code&gt; to return an array of rows. Column names can be a &lt;code&gt;String&lt;/code&gt; or a &lt;code&gt;Regexp&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sheet.parse(id: /UPC|SKU/, qty: /ATS*\sATP\s*QTY\z/)&#xA;# =&amp;gt; [{:id =&amp;gt; 727880013358, :qty =&amp;gt; 12}, ...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;:headers&lt;/code&gt; option to include the header row in the parsed content.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sheet.parse(headers: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;:header_search&lt;/code&gt; option to locate the header row and assign the header names.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sheet.parse(header_search: [/UPC*SKU/,/ATS*\sATP\s*QTY\z/])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;:clean&lt;/code&gt; option to strip out control characters and surrounding white space.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sheet.parse(clean: true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Options&lt;/h4&gt; &#xA;&lt;p&gt;When opening the file you can add a hash of options.&lt;/p&gt; &#xA;&lt;h5&gt;expand_merged_ranges&lt;/h5&gt; &#xA;&lt;p&gt;If you open a document with merged cells and do not want to end up with nil values for the rows after the first one.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;xlsx = Roo::Excelx.new(&#39;./roo_error.xlsx&#39;, {:expand_merged_ranges =&amp;gt; true})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Exporting spreadsheets&lt;/h3&gt; &#xA;&lt;p&gt;Roo has the ability to export sheets using the following formats. It will only export the &lt;code&gt;default_sheet&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sheet.to_csv&#xA;sheet.to_matrix&#xA;sheet.to_xml&#xA;sheet.to_yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Excel (xlsx and xlsm) Support&lt;/h3&gt; &#xA;&lt;p&gt;Stream rows from an Excelx spreadsheet.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;xlsx = Roo::Excelx.new(&#34;./test_data/test_small.xlsx&#34;)&#xA;xlsx.each_row_streaming do |row|&#xA;  puts row.inspect # Array of Excelx::Cell objects&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default blank cells will be excluded from the array. To keep them, use the option pad_cells = true. (They will be set to nil in the array)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;xlsx.each_row_streaming(pad_cells: true) do |row|&#xA;  puts row.inspect # Array of Excelx::Cell objects&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To stream only some of the rows, you can use the &lt;code&gt;max_rows&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;options.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;xlsx.each_row_streaming(offset: 1) do |row| # Will exclude first (inevitably header) row&#xA;  puts row.inspect # Array of Excelx::Cell objects&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;xlsx.each_row_streaming(max_rows: 3) do |row| # Will yield 4 rows (it&#39;s automatically incremented by 1) after the supplied offset.&#xA;  puts row.inspect # Array of Excelx::Cell objects&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Iterate over each row&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;xlsx.each_row do |row|&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Roo::Excelx&lt;/code&gt; also provides these helpful methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;xlsx.excelx_type(3, &#39;C&#39;)&#xA;# =&amp;gt; :numeric_or_formula&#xA;&#xA;xlsx.cell(3, &#39;C&#39;)&#xA;# =&amp;gt; 600000383.0&#xA;&#xA;xlsx.excelx_value(row,col)&#xA;# =&amp;gt; &#39;600000383&#39;&#xA;&#xA;xlsx.formatted_value(row,col)&#xA;# =&amp;gt; &#39;0600000383&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Roo::Excelx&lt;/code&gt; can access celltype, comments, font information, formulas, hyperlinks and labels.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;xlsx.comment(1,1, ods.sheets[-1])&#xA;xlsx.font(1,1).bold?&#xA;xlsx.formula(&#39;A&#39;, 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;OpenOffice / LibreOffice Support&lt;/h3&gt; &#xA;&lt;p&gt;Roo::OpenOffice has support for encrypted OpenOffice spreadsheets.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Load an encrypted OpenOffice Spreadsheet&#xA;ods = Roo::OpenOffice.new(&#34;myspreadsheet.ods&#34;, password: &#34;password&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Roo::OpenOffice&lt;/code&gt; can access celltype, comments, font information, formulas and labels.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ods.celltype&#xA;# =&amp;gt; :percentage&#xA;&#xA;ods.comment(1,1, ods.sheets[-1])&#xA;&#xA;ods.font(1,1).italic?&#xA;# =&amp;gt; false&#xA;&#xA;ods.formula(&#39;A&#39;, 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CSV Support&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Load a CSV file&#xA;csv = Roo::CSV.new(&#34;mycsv.csv&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because Roo uses the standard CSV library, you can use options available to that library to parse csv files. You can pass options using the &lt;code&gt;csv_options&lt;/code&gt; key.&lt;/p&gt; &#xA;&lt;p&gt;For instance, you can load tab-delimited files (&lt;code&gt;.tsv&lt;/code&gt;), and you can use a particular encoding when opening the file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Load a tab-delimited csv&#xA;csv = Roo::CSV.new(&#34;mytsv.tsv&#34;, csv_options: {col_sep: &#34;\t&#34;})&#xA;&#xA;# Load a csv with an explicit encoding&#xA;csv = Roo::CSV.new(&#34;mycsv.csv&#34;, csv_options: {encoding: Encoding::ISO_8859_1})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also open csv files through the Roo::Spreadsheet class (useful if you accept both CSV and Excel types from a user file upload, for example).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Load a spreadsheet from a file path&#xA;# Roo figures out the right parser based on file extension&#xA;spreadsheet = Roo::Spreadsheet.open(csv_or_xlsx_file)&#xA;&#xA;# Load a csv and auto-strip the BOM (byte order mark)&#xA;# csv files saved from MS Excel typically have the BOM marker at the beginning of the file&#xA;spreadsheet = Roo::Spreadsheet.open(&#34;mycsv.csv&#34;, { csv_options: { encoding: &#39;bom|utf-8&#39; } })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Upgrading from Roo 1.13.x&lt;/h2&gt; &#xA;&lt;p&gt;If you use &lt;code&gt;.xls&lt;/code&gt; or Google spreadsheets, you will need to install &lt;code&gt;roo-xls&lt;/code&gt; or &lt;code&gt;roo-google&lt;/code&gt; to continue using that functionality.&lt;/p&gt; &#xA;&lt;p&gt;Roo&#39;s public methods have stayed relatively consistent between 1.13.x and 2.0.0, but please check the &lt;a href=&#34;https://github.com/roo-rb/roo/raw/master/CHANGELOG.md&#34;&gt;Changelog&lt;/a&gt; to better understand the changes made since 1.13.x.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork it ( &lt;a href=&#34;https://github.com/roo-rb/roo/fork&#34;&gt;https://github.com/roo-rb/roo/fork&lt;/a&gt; )&lt;/li&gt; &#xA; &lt;li&gt;Install it (&lt;code&gt;bundle install --with local_development&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Create your feature branch (&lt;code&gt;git checkout -b my-new-feature&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Commit your changes (&lt;code&gt;git commit -am &#39;My new feature&#39;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Push to the branch (&lt;code&gt;git push origin my-new-feature&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Create a new Pull Request&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Testing&lt;/h3&gt; &#xA;&lt;p&gt;Roo uses Minitest and RSpec. The best of both worlds! Run &lt;code&gt;bundle exec rake&lt;/code&gt; to run the tests/examples.&lt;/p&gt; &#xA;&lt;p&gt;You can run the tests/examples with Rspec like reporters by running &lt;code&gt;USE_REPORTERS=true bundle exec rake&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Roo also has a few tests that take a long time (5+ seconds). To run these, use &lt;code&gt;LONG_RUN=true bundle exec rake&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Issues&lt;/h3&gt; &#xA;&lt;p&gt;If you find an issue, please create a gist and refer to it in an issue (&lt;a href=&#34;https://gist.github.com/stevendaniels/98a05849036e99bb8b3c&#34;&gt;sample gist&lt;/a&gt;). Here are some instructions for creating such a gist.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gist.github.com&#34;&gt;Create a gist&lt;/a&gt; with code that creates the error.&lt;/li&gt; &#xA; &lt;li&gt;Clone the gist repo locally, add a stripped down version of the offending spreadsheet to the gist repo, and push the gist&#39;s changes master.&lt;/li&gt; &#xA; &lt;li&gt;Paste the gist url here.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/roo-rb/roo/raw/master/LICENSE&#34;&gt;Roo uses an MIT License&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>