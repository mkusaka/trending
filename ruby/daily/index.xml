<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-16T01:41:42Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>learn-co-curriculum/phase-3-active-record-costume-store-lab</title>
    <updated>2023-05-16T01:41:42Z</updated>
    <id>tag:github.com,2023-05-16:/learn-co-curriculum/phase-3-active-record-costume-store-lab</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-active-record-costume-store-lab" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Costume Store Lab&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create migrations using Active Record&lt;/li&gt; &#xA; &lt;li&gt;Interact with a SQL database table from a Ruby class using Active Record&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Active Record Review&lt;/h2&gt; &#xA;&lt;p&gt;Active Record is magic. Well, not really. But it does build out a bunch of methods for you. For instance, when it&#39;s used properly it will give you access to methods such as &lt;code&gt;create&lt;/code&gt;, &lt;code&gt;save&lt;/code&gt;, and &lt;code&gt;find_by&lt;/code&gt;. Rejoice! Never again will you have to manually build out these methods!&lt;/p&gt; &#xA;&lt;p&gt;Active Record allows you to create a database that interacts with your class with only a few lines of code. These lines of code go to creating a model, which resides in the &lt;code&gt;app/models&lt;/code&gt; folder, and a migration, which resides in the &lt;code&gt;db/migrate&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;p&gt;The model inherits from &lt;code&gt;ActiveRecord::Base&lt;/code&gt; while the migration inherits from &lt;code&gt;ActiveRecord::Migration&lt;/code&gt;. Many migrations these days have a &lt;code&gt;change&lt;/code&gt; method, but you might also see migrations with an &lt;code&gt;up&lt;/code&gt; and a &lt;code&gt;down&lt;/code&gt; method instead. To use Active Record, you have to stick to some specific naming conventions: while the migrations are plural, the models are singular.&lt;/p&gt; &#xA;&lt;h3&gt;Migrations&lt;/h3&gt; &#xA;&lt;p&gt;When creating migrations, the class names in the migration files must match their file names. For instance, a class in the migration file called &lt;code&gt;20141013204115_create_candies.rb&lt;/code&gt; must be named &lt;code&gt;CreateCandies&lt;/code&gt; while a class in a migration file called &lt;code&gt;20130915204319_add_addresses_to_houses.rb&lt;/code&gt; must be called AddAddressesToHouses.&lt;/p&gt; &#xA;&lt;p&gt;You might notice that in both the examples above, the numbers at the front of the file name were ignored. These numbers are in the form &lt;code&gt;YYYYMMDDHHMMSS&lt;/code&gt;. These timestamps are used to determine which migration should be run and in what order. For instance, if you made a table called &lt;code&gt;dog_walkers&lt;/code&gt; and then added a column to it called &lt;code&gt;rating&lt;/code&gt;, that would be fine as the timestamp on the &lt;code&gt;dog_walkers&lt;/code&gt; table creation would indicate it needs to be migrated before adding the &lt;code&gt;rating&lt;/code&gt; column to it. However, if you did this in reverse order, that is adding a column to a table that doesn&#39;t exist, then creating the table, you would get an error.&lt;/p&gt; &#xA;&lt;p&gt;Migrations, as it was mentioned before, inherit from &lt;code&gt;ActiveRecord::Migration&lt;/code&gt; and usually have a method called &lt;code&gt;change&lt;/code&gt;. In change, you can create a table with the &lt;a href=&#34;http://guides.rubyonrails.org/migrations.html#creating-a-table&#34;&gt;create_table&lt;/a&gt; method. This method automatically will create a primary key column called &lt;code&gt;id&lt;/code&gt;, but this default can be overridden if you&#39;d like to customize it.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a simple example of the &lt;code&gt;create_table&lt;/code&gt; method in action:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class CreateDogs &amp;lt; ActiveRecord::Migration[6.1]&#xA;  def change&#xA;    create_table :dogs do |t|&#xA;      t.string :name&#xA;      t.string :breed&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above code would create a table called &lt;code&gt;dogs&lt;/code&gt; with three columns: &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;breed&lt;/code&gt; (both explicitly created), and an implicitly created &lt;code&gt;id&lt;/code&gt; column.&lt;/p&gt; &#xA;&lt;p&gt;Take a look at a few data types that Active Record supports below:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Data Type&lt;/th&gt; &#xA;   &lt;th&gt;Examples&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;boolean&lt;/td&gt; &#xA;   &lt;td&gt;true, false&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;integer&lt;/td&gt; &#xA;   &lt;td&gt;2, -13, 485&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;string&lt;/td&gt; &#xA;   &lt;td&gt;&#34;Halloween&#34;, &#34;Boo!&#34;, strings between 1-255 characters&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;datetime&lt;/td&gt; &#xA;   &lt;td&gt;DateTime.now, DateTime.new(2014,10,31)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;float&lt;/td&gt; &#xA;   &lt;td&gt;2.234, 32.2124, -6.342&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;text&lt;/td&gt; &#xA;   &lt;td&gt;strings between 1 and 2 ^ 32 - 1 characters&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Models&lt;/h3&gt; &#xA;&lt;p&gt;Like migrations, models also inherit some code from Active Record, but they inherit from &lt;code&gt;ActiveRecord::Base&lt;/code&gt;. A simple model would look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Dog &amp;lt; ActiveRecord::Base&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Even though there are no explicit methods for retrieving &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;breed&lt;/code&gt;, this &lt;code&gt;Dog&lt;/code&gt; model is associated with the created &lt;code&gt;dogs&lt;/code&gt; table above. Because of this integration, we can call &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;breed&lt;/code&gt;, and &lt;code&gt;id&lt;/code&gt; on any new instance of the Dog class. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;shiloh = Dog.new&#xA;# =&amp;gt; #&amp;lt;Dog id: 1, name: nil, breed: nil&amp;gt;&#xA;shiloh.name = &#34;Shiloh&#34;&#xA;# =&amp;gt; &#34;Shiloh&#34;&#xA;shiloh.breed = &#34;Beagle&#34;&#xA;# =&amp;gt; &#34;Beagle&#34;&#xA;shiloh.save&#xA;# =&amp;gt; true&#xA;&#xA;Dog.find_by(:name =&amp;gt; &#34;Shiloh&#34;) == shiloh&#xA;# =&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that you had access to reader and writer methods that work with the database that you never had to actually code in the model itself. You could set the name without ever writing &lt;code&gt;def name=()&lt;/code&gt; and call the &lt;code&gt;self.find_by(attribute)&lt;/code&gt; method without ever teaching your &lt;code&gt;Dog&lt;/code&gt; class how to look up data in the database. It&#39;s pretty awesome. Take a look at an example below.&lt;/p&gt; &#xA;&lt;h4&gt;Example&lt;/h4&gt; &#xA;&lt;p&gt;Let&#39;s say you wanted to make a class called &lt;code&gt;Candy&lt;/code&gt;. Candies should have two attributes, a name (string) and the number of calories (integer). You would write the migration as seen below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# db/migrate/20130915204319_create_candies.rb&#xA;class CreateCandies &amp;lt; ActiveRecord::Migration[6.1]&#xA;  def change&#xA;    create_table :candies do |t|&#xA;      t.string :name&#xA;      t.integer :calories&#xA;      t.timestamps&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: You might be wondering what &lt;code&gt;t.timestamps&lt;/code&gt; is doing here. Well, it creates two new columns, &lt;code&gt;created_at&lt;/code&gt; and &lt;code&gt;updated_at&lt;/code&gt;. These are handy columns to have around, as sometimes you want to query based on the time a record was created or updated instead of querying using attributes or ids. To read more about timestamps, go to Active Record&#39;s &lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html#method-i-timestamps&#34;&gt;docs on them&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;While the table name was plural, the model would be singular:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/models/candy.rb&#xA;class Candy &amp;lt; ActiveRecord::Base&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After saving the code above, running &lt;code&gt;rake db:migrate&lt;/code&gt; will apply the desired changes to the database by running the change method. Then you can alter the database with simple Ruby statements.&lt;/p&gt; &#xA;&lt;p&gt;For instance, you could create three rows in the table easily:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Candy.create(name: &#34;Milky Way Midnight&#34;, calories: 220)&#xA;Candy.create(name: &#34;Snickers&#34;, calories: 550)&#xA;Candy.create(name: &#34;Reese&#39;s Peanut Butter Cups&#34;, calories: 210)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Retrieving information is just as painless:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;reeses = Candy.find_by(:name =&amp;gt; &#34;Reese&#39;s Peanut Butter Cups&#34;)&#xA;# =&amp;gt; #&amp;lt;Candy id: 3, name: &#34;Reese&#39;s Peanut Butter Cups&#34;, calories: 210&amp;gt;&#xA;Candy.first&#xA;# =&amp;gt; #&amp;lt;Candy id: 1, name: &#34;Milky Way Midnight&#34;, calories: 220&amp;gt;&#xA;snickers = Candy.find(2)&#xA;# =&amp;gt; #&amp;lt;Candy id: 2, name: &#34;Snickers&#34;, calories: 550&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As is viewing attributes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;reeses = Candy.find(3)&#xA;# =&amp;gt; #&amp;lt;Candy id: 3, name: &#34;Reese&#39;s Peanut Batter Cups&#34;, calories: 210&amp;gt;&#xA;reeses.calories&#xA;# =&amp;gt; 210&#xA;reeses.name&#xA;# =&amp;gt; &#34;Reese&#39;s Peanut Batter Cups&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Updating information and viewing table info is also quite simple:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;snickers = Candy.find(2)&#xA;# =&amp;gt; #&amp;lt;Candy id: 2, name: &#34;Snickers&#34;, calories: 550&amp;gt;&#xA;snickers.update(:calories =&amp;gt; 250)&#xA;# =&amp;gt; true&#xA;&#xA;reeses = Candy.last&#xA;# =&amp;gt; #&amp;lt;Candy id: 3, name: &#34;Reese&#39;s Peanut Batter Cups&#34;, calories: 210&amp;gt;&#xA;reeses.update(:name =&amp;gt; &#34;Reeeese&#39;s Peanut Butter Cups&#34;)&#xA;# =&amp;gt; true&#xA;&#xA;Candy.find(2)&#xA;# =&amp;gt; #&amp;lt;Candy id: 2, name: &#34;Snickers&#34;, calories: 250&amp;gt;&#xA;Candy.last&#xA;# =&amp;gt; #&amp;lt;Candy id: 3, name: &#34;Reeeese&#39;s Peanut Butter Cups&#34;, calories: 210&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Isn&#39;t that amazing? Eleven lines of code allows you to create a table and a class that interact with each other elegantly and efficiently. It builds out methods like, &lt;code&gt;create&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;calories&lt;/code&gt;, along with others such as &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Instructions&lt;/h2&gt; &#xA;&lt;p&gt;In this lab, you&#39;ll be creating the following tables: &lt;code&gt;costumes&lt;/code&gt;, &lt;code&gt;costume_stores&lt;/code&gt;, and &lt;code&gt;haunted_houses&lt;/code&gt;. You&#39;ll be creating the following classes: &lt;code&gt;Costume&lt;/code&gt;, &lt;code&gt;CostumeStore&lt;/code&gt;, and &lt;code&gt;HauntedHouse&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;costumes&lt;/code&gt; table will have four columns:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;name (string)&lt;/li&gt; &#xA; &lt;li&gt;price (float)&lt;/li&gt; &#xA; &lt;li&gt;size (string)&lt;/li&gt; &#xA; &lt;li&gt;image_url (string)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;em&gt;as well as&lt;/em&gt; the two &lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html#method-i-timestamps&#34;&gt;timestamp&lt;/a&gt; columns: &lt;code&gt;created_at&lt;/code&gt; and &lt;code&gt;updated_at&lt;/code&gt;. This will provide a grand total of &lt;em&gt;six&lt;/em&gt; columns.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;costume_stores&lt;/code&gt; table will have seven columns:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;name (string)&lt;/li&gt; &#xA; &lt;li&gt;location (string)&lt;/li&gt; &#xA; &lt;li&gt;costume_inventory (integer)&lt;/li&gt; &#xA; &lt;li&gt;num_of_employees (integer)&lt;/li&gt; &#xA; &lt;li&gt;is_in_business (boolean)&lt;/li&gt; &#xA; &lt;li&gt;opening_time (datetime)&lt;/li&gt; &#xA; &lt;li&gt;closing_time (datetime)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The &lt;code&gt;haunted_houses&lt;/code&gt; table will have eight columns:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;name (string)&lt;/li&gt; &#xA; &lt;li&gt;location (string)&lt;/li&gt; &#xA; &lt;li&gt;theme (string)&lt;/li&gt; &#xA; &lt;li&gt;price (float)&lt;/li&gt; &#xA; &lt;li&gt;family_friendly (boolean)&lt;/li&gt; &#xA; &lt;li&gt;opening_date (datetime)&lt;/li&gt; &#xA; &lt;li&gt;closing_date (datetime)&lt;/li&gt; &#xA; &lt;li&gt;description (text)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Before coding out the creation of these tables, read about Active Record below.&lt;/p&gt; &#xA;&lt;h3&gt;File Structure&lt;/h3&gt; &#xA;&lt;p&gt;You will be altering code in three files in the &lt;code&gt;models&lt;/code&gt; folder and creating three files in the &lt;code&gt;db/migrate&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;├── app&#xA;│   └── models&#xA;│       ├── costume.rb&#xA;│       ├── costume_store.rb&#xA;│       └── haunted_house.rb&#xA;└──db&#xA;    └── migrate&#xA;        ├── 001_create_costumes.rb&#xA;        ├── 002_create_costume_stores.rb&#xA;        └── 003_create_haunted_houses.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting Started&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;This is a test-driven lab so start with the first test and work your way down.&lt;/strong&gt; Your models should be no longer than two lines of code. Most of your work will be done in the migrations.&lt;/p&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;rake db:create_migration&lt;/code&gt; to create the files for the migrations.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The first step is to run &lt;code&gt;bundle install&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Create the &lt;code&gt;Costume&lt;/code&gt; class in &lt;code&gt;app/models/costume.rb&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Fill out the Active Record migration for the &lt;code&gt;costumes&lt;/code&gt; table such that it passes the specs.&lt;/li&gt; &#xA; &lt;li&gt;Create the &lt;code&gt;CostumeStore&lt;/code&gt; class in &lt;code&gt;app/models/costume_store.rb&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Fill out the Active Record migration for the &lt;code&gt;costume_stores&lt;/code&gt; table such that it passes the specs.&lt;/li&gt; &#xA; &lt;li&gt;Create the &lt;code&gt;HauntedHouse&lt;/code&gt; class in &lt;code&gt;app/models/haunted_house.rb&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Fill out the Active Record migration for the &lt;code&gt;haunted_houses&lt;/code&gt; table such that it passes the specs.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When running your migrations and rollbacks, use &lt;code&gt;RACK_ENV=test&lt;/code&gt; in order to run the migrations for the test environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle exec rake db:migrate RACK_ENV=test&#xA;$ bundle exec rake db:rollback RACK_ENV=test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also run the migrations without &lt;code&gt;RACK_ENV=test&lt;/code&gt;, which will migrate the development database. This is helpful if you want to explore the code from the console:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle exec rake db:migrate&#xA;$ bundle exec rake console&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Just like for any other lab, run &lt;code&gt;learn test&lt;/code&gt; to view your test progress. However, unlike some of the other labs in this section, for this lab, when updating an existing migration, &lt;strong&gt;you will need to rollback your previous migrations for that table using the Rake command &lt;code&gt;rake db:rollback RACK_ENV=test&lt;/code&gt;&lt;/strong&gt;. Otherwise, the schema will remain unchanged and the changes you make to your migrations will not be seen.&lt;/p&gt; &#xA;&lt;p&gt;For example, say you&#39;ve run &lt;code&gt;rake db:migrate RACK_ENV=test&lt;/code&gt; and &lt;code&gt;learn test&lt;/code&gt; once to start, and see that you need to add an attribute to the &lt;code&gt;costume_stores&lt;/code&gt; table. Since this table is the second migration of three, you will need to run &lt;code&gt;rake db:rollback RACK_ENV=test&lt;/code&gt; twice to remove the previous migration for this table, then run &lt;code&gt;rake db:migrate RACK_ENV=test&lt;/code&gt; again to update the schema. Your code, however, may break if the other migration files are empty.&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://guides.rubyonrails.org/active_record_migrations.html&#34;&gt;Active Record Migrations&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Just look at the code for the example migrations&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://guides.rubyonrails.org/active_record_basics.html#creating-active-record-models&#34;&gt;Creating Active Record Models&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html#method-i-timestamps&#34;&gt;Timestamps&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>buildkite/docs</title>
    <updated>2023-05-16T01:41:42Z</updated>
    <id>tag:github.com,2023-05-16:/buildkite/docs</id>
    <link href="https://github.com/buildkite/docs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The source files for the Buildkite documentation&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Buildkite Documentation &lt;a href=&#34;https://buildkite.com/buildkite/docs&#34;&gt;&lt;img src=&#34;https://badge.buildkite.com/b1b9e3ef9d893c087f5e5c0a2d04c258ba393bed2379273f63.svg?branch=main&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;The source files for the &lt;a href=&#34;https://buildkite.com/docs&#34;&gt;Buildkite Documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To contribute, send a pull request! &lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;h3&gt;Before you start&lt;/h3&gt; &#xA;&lt;p&gt;For containerized development, you need Docker and Docker Compose. Most desktop installations of Docker include Docker Compose by default. On some platforms, you may need to prefix &lt;code&gt;docker&lt;/code&gt; commands with &lt;code&gt;sudo&lt;/code&gt; or add your user to the &lt;code&gt;docker&lt;/code&gt; group.&lt;/p&gt; &#xA;&lt;p&gt;For non-containerized development, you need Ruby. See &lt;a href=&#34;https://raw.githubusercontent.com/buildkite/docs/main/.ruby-version&#34;&gt;&lt;code&gt;.ruby-version&lt;/code&gt;&lt;/a&gt; for the current required version or use &lt;a href=&#34;https://github.com/rbenv/rbenv&#34;&gt;&lt;code&gt;rbenv&lt;/code&gt;&lt;/a&gt; to automatically select the correct version of Ruby&lt;/p&gt; &#xA;&lt;h3&gt;Run the development server&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Get the source. Run:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git@github.com:buildkite/docs.git&#xA;cd docs&#xA;git submodule update --init&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build and run the server.&lt;/p&gt; &lt;p&gt;For non-containerized development, run:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install dependencies&#xA;bin/setup&#xA;&#xA;# Start the app&#xA;foreman start&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Or with Docker, run:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Start the app on http://localhost:3000/&#xA;docker-compose up --build&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Open &lt;code&gt;http://localhost:3000&lt;/code&gt; to preview the docs site. After modifying a page, refresh to see your changes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; By default, search (through Algolia) does not work in development.&lt;/p&gt; &#xA;&lt;h2&gt;Updating buildkite-agent CLI Docs&lt;/h2&gt; &#xA;&lt;p&gt;With the development dependencies installed you can update the CLI docs using &lt;code&gt;scripts/update-agent-help.sh&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Set a custom PATH to select a locally built buildkite-agent&#xA;PATH=&#34;$HOME/Projects/buildkite/agent:$PATH&#34; ./scripts/update-agent-help.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Linting&lt;/h2&gt; &#xA;&lt;p&gt;We spell-check the docs (American English) and run a few automated checks for repeated words, common errors, and markdown and filename inconsistencies.&lt;/p&gt; &#xA;&lt;p&gt;You can run most of these checks with &lt;code&gt;./scripts/vale.sh&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;ve added a new valid word that showing up as a spelling error, add it to &lt;code&gt;vale/vocab.txt&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Style guide&lt;/h2&gt; &#xA;&lt;p&gt;Our documentation is based on the principles of common sense, clarity, and brevity.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/buildkite/docs/main/styleguide/STYLE.md&#34;&gt;style guide&lt;/a&gt; should provide you a general idea and an insight into using custom formatting elements.&lt;/p&gt; &#xA;&lt;h2&gt;Search index&lt;/h2&gt; &#xA;&lt;p&gt;The search index is updated once a day by a scheduled build using the config in &lt;code&gt;config/algolia.json&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To test changes to the indexing configuration:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Make sure you have an API key in &lt;code&gt;.env&lt;/code&gt; like:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-env&#34;&gt;APPLICATION_ID=APP_ID&#xA;API_KEY=YOUR_API_KEY&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run &lt;code&gt;bundle exec rake update_test_index&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/buildkite/docs/main/LICENSE.md&#34;&gt;LICENSE.md&lt;/a&gt; (MIT)&lt;/p&gt; &#xA;&lt;h2&gt;Updating the navigation&lt;/h2&gt; &#xA;&lt;p&gt;The navigation is split into the following files:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;nav_graphql.yml&lt;/code&gt;: For the GraphQL API content.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nav.yml&lt;/code&gt;: For everything else.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A combined navigation is generated when the application starts.&lt;/p&gt; &#xA;&lt;p&gt;To update the GraphQL docs, follow the &lt;a href=&#34;https://raw.githubusercontent.com/buildkite/docs/main/styleguide/STYLE.md#graphql-api-schemas&#34;&gt;style guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Otherwise, to update the general navigation:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Edit &lt;code&gt;nav.yml&lt;/code&gt; with your changes.&lt;/li&gt; &#xA; &lt;li&gt;Restart the application.&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>