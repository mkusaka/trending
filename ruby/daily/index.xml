<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-12T01:36:25Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>activeadmin/inherited_resources</title>
    <updated>2024-08-12T01:36:25Z</updated>
    <id>tag:github.com,2024-08-12:/activeadmin/inherited_resources</id>
    <link href="https://github.com/activeadmin/inherited_resources" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Notice&lt;/h2&gt; &#xA;&lt;p&gt;Inherited Resources is no longer actively maintained by the original author and has been transferred to the ActiveAdmin organization for maintenance. New feature requests are not encouraged.&lt;/p&gt; &#xA;&lt;p&gt;If you are not already using Inherited Resources we suggest instead using Rails&#39; &lt;code&gt;respond_with&lt;/code&gt; feature alongside the &lt;a href=&#34;https://github.com/heartcombo/responders&#34;&gt;responders gem&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Inherited Resources&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://rubygems.org/gems/inherited_resources&#34;&gt;&lt;img src=&#34;https://img.shields.io/gem/v/inherited_resources.svg?sanitize=true&#34; alt=&#34;Version         &#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/activeadmin/inherited_resources/actions&#34;&gt;&lt;img src=&#34;https://github.com/activeadmin/inherited_resources/workflows/ci/badge.svg?sanitize=true&#34; alt=&#34;Github Actions  &#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://tidelift.com/subscription/pkg/rubygems-inherited-resources?utm_source=rubygems-inherited-resources&amp;amp;utm_medium=referral&amp;amp;utm_campaign=readme&#34;&gt;&lt;img src=&#34;https://tidelift.com/badges/package/rubygems/inherited_resources?style=flat&#34; alt=&#34;Tidelift        &#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Inherited Resources speeds up development by making your controllers inherit all restful actions so you just have to focus on what is important. It makes your controllers more powerful and cleaner at the same time.&lt;/p&gt; &#xA;&lt;p&gt;In addition to making your controllers follow a pattern, it helps you to write better code by following fat models and skinny controllers convention. There are two screencasts available besides this README:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://railscasts.com/episodes/230-inherited-resources&#34;&gt;http://railscasts.com/episodes/230-inherited-resources&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.akitaonrails.com/2009/09/01/screencast-real-thin-restful-controllers-with-inherited-resources&#34;&gt;https://www.akitaonrails.com/2009/09/01/screencast-real-thin-restful-controllers-with-inherited-resources&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can let bundler install Inherited Resources by adding this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;inherited_resources&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or install it yourself with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gem install inherited_resources&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;HasScope&lt;/h2&gt; &#xA;&lt;p&gt;Since Inherited Resources 1.0, has_scope is not part of its core anymore but a gem dependency. Be sure to check the documentation to see how you can use it:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/heartcombo/has_scope&#34;&gt;https://github.com/heartcombo/has_scope&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And it can be installed as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gem install has_scope&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Responders&lt;/h2&gt; &#xA;&lt;p&gt;Since Inherited Resources 1.0, responders are not part of its core anymore, but is set as Inherited Resources dependency and it&#39;s used by default by InheritedResources controllers. Be sure to check the documentation to see how it will change your application:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/heartcombo/responders&#34;&gt;https://github.com/heartcombo/responders&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And it can be installed with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gem install responders&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using responders will set the flash message to :notice and :alert. You can change that through the following configuration value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;InheritedResources.flash_keys = [ :success, :failure ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice the CollectionResponder won&#39;t work with InheritedResources, as InheritedResources hardcodes the redirect path based on the current scope (like belongs to, polymorphic associations, etc).&lt;/p&gt; &#xA;&lt;h2&gt;Basic Usage&lt;/h2&gt; &#xA;&lt;p&gt;To use Inherited Resources you just have to inherit (duh) it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And all actions are defined and working, check it! Your projects collection (in the index action) is still available in the instance variable &lt;code&gt;@projects&lt;/code&gt; and your project resource (all other actions) is available as &lt;code&gt;@project&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The next step is to define which mime types this controller provides:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  respond_to :html, :xml, :json&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also specify them per action:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  respond_to :html, :xml, :json&#xA;  respond_to :js, :only =&amp;gt; :create&#xA;  respond_to :iphone, :except =&amp;gt; [ :edit, :update ]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For each request, it first checks if the &#34;controller/action.format&#34; file is available (for example &#34;projects/create.xml&#34;) and if it&#39;s not, it checks if the resource respond to :to_format (in this case, &lt;code&gt;:to_xml&lt;/code&gt;). Otherwise returns 404.&lt;/p&gt; &#xA;&lt;p&gt;Another option is to specify which actions the controller will inherit from the &lt;code&gt;InheritedResources::Base&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  actions :index, :show, :new, :create&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  actions :all, :except =&amp;gt; [ :edit, :update, :destroy ]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In your views, you will get the following helpers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;resource        #=&amp;gt; @project&#xA;collection      #=&amp;gt; @projects&#xA;resource_class  #=&amp;gt; Project&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you might expect, collection (&lt;code&gt;@projects&lt;/code&gt; instance variable) is only available on index actions.&lt;/p&gt; &#xA;&lt;p&gt;If for some reason you cannot inherit from &lt;code&gt;InheritedResources::Base&lt;/code&gt;, you can call inherit_resources in your controller class scope:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AccountsController &amp;lt; ApplicationController&#xA;  inherit_resources&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One reason to use the &lt;code&gt;inherit_resources&lt;/code&gt; macro would be to ensure that your controller never responds with the html mime-type. &lt;code&gt;InheritedResources::Base&lt;/code&gt; already responds to &lt;code&gt;:html&lt;/code&gt;, and the &lt;code&gt;respond_to&lt;/code&gt; macro is strictly additive. Therefore, if you want to create a controller that, for example, responds ONLY via &lt;code&gt;:js&lt;/code&gt;, you will have to write it this way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AccountsController &amp;lt; ApplicationController&#xA;  respond_to :js&#xA;  inherit_resources&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Overwriting defaults&lt;/h2&gt; &#xA;&lt;p&gt;Whenever you inherit from InheritedResources, several defaults are assumed. For example you can have an &lt;code&gt;AccountsController&lt;/code&gt; for account management while the resource is a &lt;code&gt;User&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AccountsController &amp;lt; InheritedResources::Base&#xA;  defaults :resource_class =&amp;gt; User, :collection_name =&amp;gt; &#39;users&#39;, :instance_name =&amp;gt; &#39;user&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the case above, in your views you will have &lt;code&gt;@users&lt;/code&gt; and &lt;code&gt;@user&lt;/code&gt; variables, but the routes used will still be &lt;code&gt;accounts_url&lt;/code&gt; and &lt;code&gt;account_url&lt;/code&gt;. If you plan also to change the routes, you can use &lt;code&gt;:route_collection_name&lt;/code&gt; and &lt;code&gt;:route_instance_name&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Namespaced controllers work out of the box, but if you need to specify a different route prefix you can do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Administrators::PeopleController &amp;lt; InheritedResources::Base&#xA;  defaults :route_prefix =&amp;gt; :admin&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then your named routes will be: &lt;code&gt;admin_people_url&lt;/code&gt;, &lt;code&gt;admin_person_url&lt;/code&gt; instead of &lt;code&gt;administrators_people_url&lt;/code&gt; and &lt;code&gt;administrators_person_url&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to customize how resources are retrieved you can overwrite collection and resource methods. The first is called on index action and the second on all other actions. Let&#39;s suppose you want to add pagination to your projects collection:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  protected&#xA;    def collection&#xA;      get_collection_ivar || set_collection_ivar(end_of_association_chain.paginate(:page =&amp;gt; params[:page]))&#xA;    end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;end_of_association_chain&lt;/code&gt; returns your resource after nesting all associations and scopes (more about this below).&lt;/p&gt; &#xA;&lt;p&gt;InheritedResources also introduces another method called &lt;code&gt;begin_of_association_chain&lt;/code&gt;. It&#39;s mostly used when you want to create resources based on the &lt;code&gt;@current_user&lt;/code&gt; and you have urls like &#34;account/projects&#34;. In such cases you have to do &lt;code&gt;@current_user.projects.find&lt;/code&gt; or &lt;code&gt;@current_user.projects.build&lt;/code&gt; in your actions.&lt;/p&gt; &#xA;&lt;p&gt;You can deal with it just by doing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  protected&#xA;    def begin_of_association_chain&#xA;      @current_user&#xA;    end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Overwriting actions&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s suppose that after destroying a project you want to redirect to your root url instead of redirecting to projects url. You just have to do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  def destroy&#xA;    super do |format|&#xA;      format.html { redirect_to root_url }&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You are opening your action and giving the parent action a new behavior. On the other hand, I have to agree that calling super is not very readable. That&#39;s why all methods have aliases. So this is equivalent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  def destroy&#xA;    destroy! do |format|&#xA;      format.html { redirect_to root_url }&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since most of the time when you change a create, update or destroy action you do so because you want to change its redirect url, a shortcut is provided. So you can do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  def destroy&#xA;    destroy! { root_url }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you simply want to change the flash message for a particular action, you can pass the message to the parent action using the keys &lt;code&gt;:notice&lt;/code&gt; and &lt;code&gt;:alert&lt;/code&gt; (as you would with flash):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  def create&#xA;    create!(:notice =&amp;gt; &#34;Dude! Nice job creating that project.&#34;)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can still pass the block to change the redirect, as mentioned above:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  def create&#xA;    create!(:notice =&amp;gt; &#34;Dude! Nice job creating that project.&#34;) { root_url }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now let&#39;s suppose that before create a project you have to do something special but you don&#39;t want to create a before filter for it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  def create&#xA;    @project = Project.new(params[:project])&#xA;    @project.something_special!&#xA;    create!&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Yes, it&#39;s that simple! The nice part is since you already set the instance variable &lt;code&gt;@project&lt;/code&gt;, it will not build a project again.&lt;/p&gt; &#xA;&lt;p&gt;Same goes for updating the project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  def update&#xA;    @project = Project.find(params[:id])&#xA;    @project.something_special!&#xA;    update!&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Before we finish this topic, we should talk about one more thing: &#34;success/failure blocks&#34;. Let&#39;s suppose that when we update our project, in case of failure, we want to redirect to the project url instead of re-rendering the edit template.&lt;/p&gt; &#xA;&lt;p&gt;Our first attempt to do this would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  def update&#xA;    update! do |format|&#xA;      unless @project.errors.empty? # failure&#xA;        format.html { redirect_to project_url(@project) }&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Looks too verbose, right? We can actually do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  def update&#xA;    update! do |success, failure|&#xA;      failure.html { redirect_to project_url(@project) }&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Much better! So explaining everything: when you give a block which expects one argument it will be executed in both scenarios: success and failure. But if you give a block that expects two arguments, the first will be executed only in success scenarios and the second in failure scenarios. You keep everything clean and organized inside the same action.&lt;/p&gt; &#xA;&lt;h2&gt;Smart redirects&lt;/h2&gt; &#xA;&lt;p&gt;Although the syntax above is a nice shortcut, you won&#39;t need to do it frequently because (since version 1.2) Inherited Resources has smart redirects. Redirects in actions calculates depending on the existent controller methods.&lt;/p&gt; &#xA;&lt;p&gt;Redirects in create and update actions calculates in the following order: &lt;code&gt;resource_url&lt;/code&gt;, &lt;code&gt;collection_url&lt;/code&gt;, &lt;code&gt;parent_url&lt;/code&gt; (which we are going to see later), and &lt;code&gt;root_url&lt;/code&gt;. Redirect in destroy action calculate in following order &lt;code&gt;collection_url&lt;/code&gt;, &lt;code&gt;parent_url&lt;/code&gt;, &lt;code&gt;root_url&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ButtonsController &amp;lt; InheritedResources::Base&#xA;  belongs_to :window&#xA;  actions :all, :except =&amp;gt; [:show, :index]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This controller redirect to parent window after all CUD actions.&lt;/p&gt; &#xA;&lt;h2&gt;Success and failure scenarios on destroy&lt;/h2&gt; &#xA;&lt;p&gt;The destroy action can also fail, this usually happens when you have a &lt;code&gt;before_destroy&lt;/code&gt; callback in your model which returns false. However, in order to tell InheritedResources that it really failed, you need to add errors to your model. So your &lt;code&gt;before_destroy&lt;/code&gt; callback on the model should be something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def before_destroy&#xA;  if cant_be_destroyed?&#xA;    errors.add(:base, &#34;not allowed&#34;)&#xA;    false&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Belongs to&lt;/h2&gt; &#xA;&lt;p&gt;Finally, our Projects are going to get some Tasks. Then you create a &lt;code&gt;TasksController&lt;/code&gt; and do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class TasksController &amp;lt; InheritedResources::Base&#xA;  belongs_to :project&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;belongs_to&lt;/code&gt; accepts several options to be able to configure the association. For example, if you want urls like &#34;/projects/:project_title/tasks&#34;, you can customize how InheritedResources find your projects:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class TasksController &amp;lt; InheritedResources::Base&#xA;  belongs_to :project, :finder =&amp;gt; :find_by_title!, :param =&amp;gt; :project_title&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It also accepts &lt;code&gt;:route_name&lt;/code&gt;, &lt;code&gt;:parent_class&lt;/code&gt; and &lt;code&gt;:instance_name&lt;/code&gt; as options. Check the &lt;a href=&#34;https://github.com/activeadmin/inherited_resources/raw/master/lib/inherited_resources/class_methods.rb&#34;&gt;lib/inherited_resources/class_methods.rb&lt;/a&gt; for more.&lt;/p&gt; &#xA;&lt;h2&gt;Nested belongs to&lt;/h2&gt; &#xA;&lt;p&gt;Now, our Tasks get some Comments and you need to nest even deeper. Good practices says that you should never nest more than two resources, but sometimes you have to for security reasons. So this is an example of how you can do it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class CommentsController &amp;lt; InheritedResources::Base&#xA;  nested_belongs_to :project, :task&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to configure any of these belongs to, you can nest them using blocks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class CommentsController &amp;lt; InheritedResources::Base&#xA;  belongs_to :project, :finder =&amp;gt; :find_by_title!, :param =&amp;gt; :project_title do&#xA;    belongs_to :task&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Warning: calling several &lt;code&gt;belongs_to&lt;/code&gt; is the same as nesting them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class CommentsController &amp;lt; InheritedResources::Base&#xA;  belongs_to :project&#xA;  belongs_to :task&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In other words, the code above is the same as calling &lt;code&gt;nested_belongs_to&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Polymorphic belongs to&lt;/h2&gt; &#xA;&lt;p&gt;We can go even further. Let&#39;s suppose our Projects can now have Files, Messages and Tasks, and they are all commentable. In this case, the best solution is to use polymorphism:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class CommentsController &amp;lt; InheritedResources::Base&#xA;  belongs_to :task, :file, :message, :polymorphic =&amp;gt; true&#xA;  # polymorphic_belongs_to :task, :file, :message&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can even use it with nested resources:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class CommentsController &amp;lt; InheritedResources::Base&#xA;  belongs_to :project do&#xA;    belongs_to :task, :file, :message, :polymorphic =&amp;gt; true&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The url in such cases can be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/project/1/task/13/comments&#xA;/project/1/file/11/comments&#xA;/project/1/message/9/comments&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using polymorphic associations, you get some free helpers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;parent?         #=&amp;gt; true&#xA;parent_type     #=&amp;gt; :task&#xA;parent_class    #=&amp;gt; Task&#xA;parent          #=&amp;gt; @task&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Right now, Inherited Resources is limited and does not allow you to have two polymorphic associations nested.&lt;/p&gt; &#xA;&lt;h2&gt;Optional belongs to&lt;/h2&gt; &#xA;&lt;p&gt;Later you decide to create a view to show all comments, independent if they belong to a task, file or message. You can reuse your polymorphic controller just doing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class CommentsController &amp;lt; InheritedResources::Base&#xA;  belongs_to :task, :file, :message, :optional =&amp;gt; true&#xA;  # optional_belongs_to :task, :file, :message&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will handle all those urls properly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/comment/1&#xA;/tasks/2/comment/5&#xA;/files/10/comment/3&#xA;/messages/13/comment/11&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is treated as a special type of polymorphic associations, thus all helpers are available. As you expect, when no parent is found, the helpers return:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;parent?         #=&amp;gt; false&#xA;parent_type     #=&amp;gt; nil&#xA;parent_class    #=&amp;gt; nil&#xA;parent          #=&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Singletons&lt;/h2&gt; &#xA;&lt;p&gt;Now we are going to add manager to projects. We say that &lt;code&gt;Manager&lt;/code&gt; is a singleton resource because a &lt;code&gt;Project&lt;/code&gt; has just one manager. You should declare it as &lt;code&gt;has_one&lt;/code&gt; (or resource) in your routes.&lt;/p&gt; &#xA;&lt;p&gt;To declare an resource of current controller as singleton, you just have to give the &lt;code&gt;:singleton&lt;/code&gt; option in defaults.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ManagersController &amp;lt; InheritedResources::Base&#xA;  defaults :singleton =&amp;gt; true&#xA;  belongs_to :project&#xA;  # singleton_belongs_to :project&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So now you can use urls like &#34;/projects/1/manager&#34;.&lt;/p&gt; &#xA;&lt;p&gt;In the case of nested resources (when some of the can be singletons) you can declare it separately&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class WorkersController &amp;lt; InheritedResources::Base&#xA;  #defaults :singleton =&amp;gt; true #if you have only single worker&#xA;  belongs_to :project&#xA;  belongs_to :manager, :singleton =&amp;gt; true&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is correspond urls like &#34;/projects/1/manager/workers/1&#34;.&lt;/p&gt; &#xA;&lt;p&gt;It will deal with everything again and hide the action :index from you.&lt;/p&gt; &#xA;&lt;h2&gt;Namespaced Controllers&lt;/h2&gt; &#xA;&lt;p&gt;Namespaced controllers works out the box.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Forum::PostsController &amp;lt; InheritedResources::Base&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Inherited Resources prioritizes the default resource class for the namespaced controller in this order:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Forum::Post&#xA;ForumPost&#xA;Post&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;URL Helpers&lt;/h2&gt; &#xA;&lt;p&gt;When you use InheritedResources it creates some URL helpers. And they handle everything for you. :)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# /posts/1/comments&#xA;resource_url               # =&amp;gt; /posts/1/comments/#{@comment.to_param}&#xA;resource_url(comment)      # =&amp;gt; /posts/1/comments/#{comment.to_param}&#xA;new_resource_url           # =&amp;gt; /posts/1/comments/new&#xA;edit_resource_url          # =&amp;gt; /posts/1/comments/#{@comment.to_param}/edit&#xA;edit_resource_url(comment) # =&amp;gt; /posts/1/comments/#{comment.to_param}/edit&#xA;collection_url             # =&amp;gt; /posts/1/comments&#xA;parent_url                 # =&amp;gt; /posts/1&#xA;&#xA;# /projects/1/tasks&#xA;resource_url               # =&amp;gt; /projects/1/tasks/#{@task.to_param}&#xA;resource_url(task)         # =&amp;gt; /projects/1/tasks/#{task.to_param}&#xA;new_resource_url           # =&amp;gt; /projects/1/tasks/new&#xA;edit_resource_url          # =&amp;gt; /projects/1/tasks/#{@task.to_param}/edit&#xA;edit_resource_url(task)    # =&amp;gt; /projects/1/tasks/#{task.to_param}/edit&#xA;collection_url             # =&amp;gt; /projects/1/tasks&#xA;parent_url                 # =&amp;gt; /projects/1&#xA;&#xA;# /users&#xA;resource_url               # =&amp;gt; /users/#{@user.to_param}&#xA;resource_url(user)         # =&amp;gt; /users/#{user.to_param}&#xA;new_resource_url           # =&amp;gt; /users/new&#xA;edit_resource_url          # =&amp;gt; /users/#{@user.to_param}/edit&#xA;edit_resource_url(user)    # =&amp;gt; /users/#{user.to_param}/edit&#xA;collection_url             # =&amp;gt; /users&#xA;parent_url                 # =&amp;gt; /&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Those urls helpers also accepts a hash as options, just as in named routes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# /projects/1/tasks&#xA;collection_url(:page =&amp;gt; 1, :limit =&amp;gt; 10) #=&amp;gt; /projects/1/tasks?page=1&amp;amp;limit=10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In polymorphic cases, you can also give the parent as parameter to &lt;code&gt;collection_url&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Another nice thing is that those urls are not guessed during runtime. They are all created when your application is loaded (except for polymorphic associations, that relies on Rails&#39; &lt;code&gt;polymorphic_url&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Custom actions&lt;/h2&gt; &#xA;&lt;p&gt;Since version 1.2, Inherited Resources allows you to define custom actions in controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ButtonsController &amp;lt; InheritedResources::Base&#xA;  custom_actions :resource =&amp;gt; :delete, :collection =&amp;gt; :search&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code creates delete and search actions in controller (they behaves like show and index actions accordingly). Also, it will produce &lt;code&gt;delete_resource_{path,url}&lt;/code&gt; and &lt;code&gt;search_resources_{path,url}&lt;/code&gt; url helpers.&lt;/p&gt; &#xA;&lt;h2&gt;What about views?&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes just DRYing up the controllers is not enough. If you need to DRY up your views, check this Wiki page:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/activeadmin/inherited_resources/wiki/Views-Inheritance&#34;&gt;https://github.com/activeadmin/inherited_resources/wiki/Views-Inheritance&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Notice that Rails 3.1 ships with view inheritance built-in.&lt;/p&gt; &#xA;&lt;h2&gt;Some DSL&lt;/h2&gt; &#xA;&lt;p&gt;For those DSL lovers, InheritedResources won&#39;t leave you alone. You can overwrite your success/failure blocks straight from your class binding. For it, you just need to add a DSL module to your application controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include InheritedResources::DSL&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then you can rewrite the last example as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ProjectsController &amp;lt; InheritedResources::Base&#xA;  update! do |success, failure|&#xA;    failure.html { redirect_to project_url(@project) }&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Strong Parameters&lt;/h2&gt; &#xA;&lt;p&gt;If your controller defines a method named &lt;code&gt;permitted_params&lt;/code&gt;, InheritedResources will call it where it would normally call params. This allows for easy integration with the strong_parameters gem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def permitted_params&#xA;  params.permit(:widget =&amp;gt; [:permitted_field, :other_permitted_field])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Remember that if your field is sent by client to server as an array, you have to write &lt;code&gt;:permitted_field =&amp;gt; []&lt;/code&gt;, not just &lt;code&gt;:permitted_field&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that this doesn&#39;t work if you use strong_parameters&#39; require method instead of permit, because whereas permit returns the entire sanitized parameter hash, require returns only the sanitized params below the parameter you required.&lt;/p&gt; &#xA;&lt;p&gt;If you need &lt;code&gt;params.require&lt;/code&gt; you can do it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def permitted_params&#xA;  {:widget =&amp;gt; params.fetch(:widget, {}).permit(:permitted_field, :other_permitted_field)}&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or better yet just override &lt;code&gt;#build_resource_params&lt;/code&gt; directly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def build_resource_params&#xA;  [params.fetch(:widget, {}).permit(:permitted_field, :other_permitted_field)]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead you can stick to a standard Rails 4 notation (as rails scaffold generates) and write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def widget_params&#xA;  params.require(:widget).permit(:permitted_field, :other_permitted_field)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In such case you should remove #permitted_params method because it has greater priority.&lt;/p&gt; &#xA;&lt;h2&gt;Funding&lt;/h2&gt; &#xA;&lt;p&gt;If you want to support us financially, you can &lt;a href=&#34;https://tidelift.com/subscription/pkg/rubygems-inherited-resources?utm_source=rubygems-inherited-resources&amp;amp;utm_medium=referral&amp;amp;utm_campaign=readme&#34;&gt;help fund the project through a Tidelift subscription&lt;/a&gt;. By buying a Tidelift subscription you make sure your whole dependency stack is properly maintained, while also getting a comprehensive view of outdated dependencies, new releases, security alerts, and licensing compatibility issues.&lt;/p&gt; &#xA;&lt;h2&gt;Bugs and Feedback&lt;/h2&gt; &#xA;&lt;p&gt;If you discover any bugs, please describe it in the issues tracker, including Rails and InheritedResources versions.&lt;/p&gt; &#xA;&lt;p&gt;Questions are better handled on StackOverflow.&lt;/p&gt; &#xA;&lt;p&gt;MIT License. Copyright (c) 2009-2017 José Valim.&lt;/p&gt; &#xA;&lt;h2&gt;Security contact information&lt;/h2&gt; &#xA;&lt;p&gt;Please use the Tidelift security contact to &lt;a href=&#34;https://tidelift.com/security&#34;&gt;report a security vulnerability&lt;/a&gt;. Tidelift will coordinate the fix and disclosure.&lt;/p&gt;</summary>
  </entry>
</feed>