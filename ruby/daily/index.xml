<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-27T01:43:46Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>discourse/message_bus</title>
    <updated>2023-06-27T01:43:46Z</updated>
    <id>tag:github.com,2023-06-27:/discourse/message_bus</id>
    <link href="https://github.com/discourse/message_bus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A reliable and robust messaging bus for Ruby and Rack&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MessageBus&lt;/h1&gt; &#xA;&lt;p&gt;A reliable, robust messaging bus for Ruby processes and web clients.&lt;/p&gt; &#xA;&lt;p&gt;MessageBus implements a Server to Server channel based protocol and Server to Web Client protocol (using polling, long-polling or long-polling + streaming)&lt;/p&gt; &#xA;&lt;p&gt;Since long-polling is implemented using Rack Hijack and Thin::Async, all common Ruby web servers (Thin, Puma, Unicorn, Passenger) can run MessageBus and handle a large number of concurrent connections that wait on messages.&lt;/p&gt; &#xA;&lt;p&gt;MessageBus is implemented as Rack middleware and can be used by any Rails / Sinatra or pure Rack application.&lt;/p&gt; &#xA;&lt;p&gt;Read the generated docs: &lt;a href=&#34;https://www.rubydoc.info/gems/message_bus&#34;&gt;https://www.rubydoc.info/gems/message_bus&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Ruby version support&lt;/h2&gt; &#xA;&lt;p&gt;MessageBus only support officially supported versions of Ruby; as of &lt;a href=&#34;https://www.ruby-lang.org/en/downloads/branches/&#34;&gt;2021-03-31&lt;/a&gt; this means we only support Ruby version 2.6 and up.&lt;/p&gt; &#xA;&lt;h2&gt;Can you handle concurrent requests?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Yes&lt;/strong&gt;, MessageBus uses Rack Hijack and this interface allows us to take control of the underlying socket. MessageBus can handle thousands of concurrent long polls on all popular Ruby webservers. MessageBus runs as middleware in your Rack (or by extension Rails) application and does not require a dedicated server. Background work is minimized to ensure it does not interfere with existing non-MessageBus traffic.&lt;/p&gt; &#xA;&lt;h2&gt;Is this used in production at scale?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Yes&lt;/strong&gt;, MessageBus was extracted out of &lt;a href=&#34;http://www.discourse.org/&#34;&gt;Discourse&lt;/a&gt; and is used in thousands of production Discourse sites at scale.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;message_bus&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ bundle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or install it yourself as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ gem install message_bus&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Server to Server messaging&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;message_id = MessageBus.publish &#34;/channel&#34;, &#34;message&#34;&#xA;&#xA;# in another process / spot&#xA;&#xA;MessageBus.subscribe &#34;/channel&#34; do |msg|&#xA;  # block called in a background thread when message is received&#xA;end&#xA;&#xA;# subscribe to channel and receive the entire backlog&#xA;MessageBus.subscribe &#34;/channel&#34;, 0 do |msg|&#xA;  # block called in a background thread when message is received&#xA;end&#xA;&#xA;# subscribe to channel and receive the backlog starting at message 6&#xA;MessageBus.subscribe &#34;/channel&#34;, 5 do |msg|&#xA;  # block called in a background thread when message is received&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# get the ID of the last message on a channel&#xA;id = MessageBus.last_id(&#34;/channel&#34;)&#xA;&#xA;# returns all messages after some id&#xA;MessageBus.backlog &#34;/channel&#34;, id&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Targeted messages&lt;/h3&gt; &#xA;&lt;p&gt;Messages can be targeted to particular clients by supplying the &lt;code&gt;client_ids&lt;/code&gt; option when publishing a message.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.publish &#34;/channel&#34;, &#34;hello&#34;, client_ids: [&#34;XXX&#34;, &#34;YYY&#34;] # (using MessageBus.clientId)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By configuring the &lt;code&gt;user_id_lookup&lt;/code&gt; and &lt;code&gt;group_ids_lookup&lt;/code&gt; options with a Proc or Lambda which will be called with a &lt;a href=&#34;https://github.com/rack/rack/raw/master/SPEC.rdoc#the-environment-&#34;&gt;Rack specification environment&lt;/a&gt;, messages can be targeted to particular clients users or groups by supplying either the &lt;code&gt;user_ids&lt;/code&gt; or &lt;code&gt;group_ids&lt;/code&gt; options when publishing a message.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.configure(user_id_lookup: proc do |env|&#xA;  # this lookup occurs on JS-client polling, so that server can retrieve backlog&#xA;  # for the client considering/matching/filtering user_ids set on published messages&#xA;  # if user_id is not set on publish time, any user_id returned here will receive the message&#xA;  # return the user id here&#xA;end)&#xA;&#xA;# Target user_ids when publishing a message&#xA;MessageBus.publish &#34;/channel&#34;, &#34;hello&#34;, user_ids: [1, 2, 3]&#xA;&#xA;MessageBus.configure(group_ids_lookup: proc do |env|&#xA;  # return the group ids the user belongs to&#xA;  # can be nil or []&#xA;end)&#xA;&#xA;# Target group_ids when publishing a message&#xA;MessageBus.publish &#34;/channel&#34;, &#34;hello&#34;, group_ids: [1, 2, 3]&#xA;&#xA;# example of MessageBus to set user_ids from an initializer in Rails and Devise:&#xA;# config/initializers/message_bus.rb&#xA;MessageBus.user_id_lookup do |env|&#xA;  req = Rack::Request.new(env)&#xA;&#xA;  if req.session &amp;amp;&amp;amp; req.session[&#34;warden.user.user.key&#34;] &amp;amp;&amp;amp; req.session[&#34;warden.user.user.key&#34;][0][0]&#xA;    user = User.find(req.session[&#34;warden.user.user.key&#34;][0][0])&#xA;    user.id&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If both &lt;code&gt;user_ids&lt;/code&gt; and &lt;code&gt;group_ids&lt;/code&gt; options are supplied when publishing a message, the message will be targeted at clients with lookup return values that matches on either the &lt;code&gt;user_ids&lt;/code&gt; &lt;strong&gt;or&lt;/strong&gt; the &lt;code&gt;group_ids&lt;/code&gt; options.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.publish &#34;/channel&#34;, &#34;hello&#34;, user_ids: [1, 2, 3], group_ids: [1, 2, 3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the &lt;code&gt;client_ids&lt;/code&gt; option is supplied with either the &lt;code&gt;user_ids&lt;/code&gt; or &lt;code&gt;group_ids&lt;/code&gt; options when publishing a message, the &lt;code&gt;client_ids&lt;/code&gt; option will be applied unconditionally and messages will be filtered further using &lt;code&gt;user_id&lt;/code&gt; or &lt;code&gt;group_id&lt;/code&gt; clauses.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.publish &#34;/channel&#34;, &#34;hello&#34;, client_ids: [&#34;XXX&#34;, &#34;YYY&#34;], user_ids: [1, 2, 3], group_ids: [1, 2, 3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Passing &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;[]&lt;/code&gt; to either &lt;code&gt;client_ids&lt;/code&gt;, &lt;code&gt;user_ids&lt;/code&gt; or &lt;code&gt;group_ids&lt;/code&gt; is equivalent to allowing all values on each option.&lt;/p&gt; &#xA;&lt;h3&gt;Filtering Client Messages&lt;/h3&gt; &#xA;&lt;p&gt;Custom client message filters can be registered via &lt;code&gt;MessageBus#register_client_message_filter&lt;/code&gt;. This can be useful for filtering away messages from the client based on the message&#39;s payload.&lt;/p&gt; &#xA;&lt;p&gt;For example, ensuring that only messages seen by the server in the last 20 seconds are published to the client:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.register_client_message_filter(&#39;/test&#39;) do |message|&#xA;  (Time.now.to_i - message.data[:published_at]) &amp;lt;= 20&#xA;end&#xA;&#xA;MessageBus.publish(&#39;/test/5&#39;, { data: &#34;somedata&#34;, published_at: Time.now.to_i })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Error handling&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.configure(on_middleware_error: proc do |env, e|&#xA;   # If you wish to add special handling based on error&#xA;   # return a rack result array: [status, headers, body]&#xA;   # If you just want to pass it on return nil&#xA;end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Disabling message_bus&lt;/h4&gt; &#xA;&lt;p&gt;In certain cases, it is undesirable for message_bus to start up on application start, for example in a Rails application during the &lt;code&gt;db:create&lt;/code&gt; rake task when using the Postgres backend (which will error trying to connect to the non-existent database to subscribe). You can invoke &lt;code&gt;MessageBus.off&lt;/code&gt; before the middleware chain is loaded in order to prevent subscriptions and publications from happening; in a Rails app you might do this in an initializer based on some environment variable or some other conditional means. If you want to just disable subscribing to the bus but want to continue to allow publications to be made, you can do &lt;code&gt;MessageBus.off(disable_publish: false)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Debugging&lt;/h3&gt; &#xA;&lt;p&gt;When setting up MessageBus, it&#39;s useful to manually inspect channels before integrating a client application.&lt;/p&gt; &#xA;&lt;p&gt;You can &lt;code&gt;curl&lt;/code&gt; MessageBus; this is helpful when trying to debug what may be going wrong. This example uses &lt;a href=&#34;https://chat.samsaffron.com&#34;&gt;https://chat.samsaffron.com&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl -H &#34;Content-Type: application/x-www-form-urlencoded&#34; -X POST --data &#34;/message=0&#34; https://chat.samsaffron.com/message-bus/client-id/poll\?dlp\=t&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should see a reply with the messages of that channel you requested (in this case &lt;code&gt;/message&lt;/code&gt;) starting at the message ID you requested (&lt;code&gt;0&lt;/code&gt;). The URL parameter &lt;code&gt;dlp=t&lt;/code&gt; disables long-polling: we do not want this request to stay open.&lt;/p&gt; &#xA;&lt;h3&gt;Transport&lt;/h3&gt; &#xA;&lt;p&gt;MessageBus ships with 3 transport mechanisms.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Long Polling with chunked encoding (streaming)&lt;/li&gt; &#xA; &lt;li&gt;Long Polling&lt;/li&gt; &#xA; &lt;li&gt;Polling&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Long Polling with chunked encoding allows a single connection to stream multiple messages to a client, and this requires HTTP/1.1.&lt;/p&gt; &#xA;&lt;p&gt;Chunked encoding provides all the benefits of &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/EventSource&#34;&gt;EventSource&lt;/a&gt; with greater browser support (as it works on IE10 and up as well)&lt;/p&gt; &#xA;&lt;p&gt;To setup NGINX to proxy to your app correctly be sure to enable HTTP1.1 and disable buffering:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;location /message-bus/ {&#xA;  ...&#xA;  proxy_http_version 1.1;&#xA;  proxy_buffering off;&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: do not set proxy_buffering off globally, it may have unintended consequences.&lt;/p&gt; &#xA;&lt;p&gt;In order to disable chunked encoding for a specific client in Javascript:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;MessageBus.enableChunkedEncoding = false;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or as a server-side policy in Ruby for all clients:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.configure(chunked_encoding_enabled: false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Long Polling requires no special setup; as soon as new data arrives on the channel the server delivers the data and closes the connection.&lt;/p&gt; &#xA;&lt;p&gt;Polling also requires no special setup; MessageBus will fallback to polling after a tab becomes inactive and remains inactive for a period.&lt;/p&gt; &#xA;&lt;h3&gt;Multisite support&lt;/h3&gt; &#xA;&lt;p&gt;MessageBus can be used in an environment that hosts multiple sites by multiplexing channels. To use this mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# define a site_id lookup method, which is executed&#xA;# when `MessageBus.publish` is called&#xA;MessageBus.configure(site_id_lookup: proc do&#xA;  some_method_that_returns_site_id_string&#xA;end)&#xA;&#xA;# you may post messages just to this site&#xA;MessageBus.publish &#34;/channel&#34;, &#34;some message&#34;&#xA;&#xA;# you can also choose to pass the `:site_id`.&#xA;# This takes precedence over whatever `site_id_lookup`&#xA;# returns&#xA;MessageBus.publish &#34;/channel&#34;, &#34;some message&#34;, site_id: &#34;site-id&#34;&#xA;&#xA;# you may publish messages to ALL sites using the /global/ prefix&#xA;MessageBus.publish &#34;/global/channel&#34;, &#34;will go to all sites&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Client support&lt;/h3&gt; &#xA;&lt;h4&gt;JavaScript Client&lt;/h4&gt; &#xA;&lt;p&gt;MessageBus ships a simple ~300 line JavaScript library which provides an API to interact with the server.&lt;/p&gt; &#xA;&lt;p&gt;JavaScript clients can listen on any channel and receive messages via polling or long polling. You may simply include the source file (located in &lt;code&gt;assets/&lt;/code&gt; within the message_bus source code):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&#34;message-bus.js&#34; type=&#34;text/javascript&#34;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or when used in a Rails application, import it through the asset pipeline:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//= require message-bus&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In your application Javascript, you can then subscribe to particular channels and define callback functions to be executed when messages are received:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;MessageBus.start(); // call once at startup&#xA;&#xA;// how often do you want the callback to fire in ms&#xA;MessageBus.callbackInterval = 500;&#xA;&#xA;// you will get all new messages sent to channel&#xA;MessageBus.subscribe(&#34;/channel&#34;, function (data) {&#xA;  // data shipped from server&#xA;});&#xA;&#xA;// you will get all new messages sent to channel (-1 is implicit)&#xA;MessageBus.subscribe(&#34;/channel&#34;, function(data){&#xA;  // data shipped from server&#xA;}, -1);&#xA;&#xA;// all messages AFTER message id 7 AND all new messages&#xA;MessageBus.subscribe(&#34;/channel&#34;, function(data){&#xA;  // data shipped from server&#xA;}, 7);&#xA;&#xA;// last 2 messages in channel AND all new messages&#xA;MessageBus.subscribe(&#34;/channel&#34;, function(data){&#xA;  // data shipped from server&#xA;}, -3);&#xA;&#xA;// you will get the entire backlog&#xA;MessageBus.subscribe(&#34;/channel&#34;, function(data){&#xA;  // data shipped from server&#xA;}, 0);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;JavaScript Client settings&lt;/h4&gt; &#xA;&lt;p&gt;All client settings are settable via &lt;code&gt;MessageBus.OPTION&lt;/code&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Setting&lt;/th&gt; &#xA;   &lt;th&gt;Default&lt;/th&gt; &#xA;   &lt;th&gt;Info&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;enableLongPolling&lt;/td&gt; &#xA;   &lt;td&gt;true&lt;/td&gt; &#xA;   &lt;td&gt;Allow long-polling (provided it is enabled by the server)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;callbackInterval&lt;/td&gt; &#xA;   &lt;td&gt;15000&lt;/td&gt; &#xA;   &lt;td&gt;Safeguard to ensure background polling does not exceed this interval (in milliseconds)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;backgroundCallbackInterval&lt;/td&gt; &#xA;   &lt;td&gt;60000&lt;/td&gt; &#xA;   &lt;td&gt;Interval to poll when long polling is disabled (either explicitly or due to browser being in background)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;minPollInterval&lt;/td&gt; &#xA;   &lt;td&gt;100&lt;/td&gt; &#xA;   &lt;td&gt;When polling requests succeed, this is the minimum amount of time to wait before making the next request.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;maxPollInterval&lt;/td&gt; &#xA;   &lt;td&gt;180000&lt;/td&gt; &#xA;   &lt;td&gt;If request to the server start failing, MessageBus will backoff, this is the upper limit of the backoff.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;alwaysLongPoll&lt;/td&gt; &#xA;   &lt;td&gt;false&lt;/td&gt; &#xA;   &lt;td&gt;For debugging you may want to disable the &#34;is browser in background&#34; check and always long-poll&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;shouldLongPollCallback&lt;/td&gt; &#xA;   &lt;td&gt;undefined&lt;/td&gt; &#xA;   &lt;td&gt;A callback returning true or false that determines if we should long-poll or not, if unset ignore and simply depend on window visibility.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;baseUrl&lt;/td&gt; &#xA;   &lt;td&gt;/&lt;/td&gt; &#xA;   &lt;td&gt;If message bus is mounted at a sub-path or different domain, you may configure it to perform requests there. See &lt;code&gt;MessageBus.base_route=&lt;/code&gt; on how to configure the MessageBus server to listen on a sub-path.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ajax&lt;/td&gt; &#xA;   &lt;td&gt;$.ajax falling back to XMLHttpRequest&lt;/td&gt; &#xA;   &lt;td&gt;MessageBus will first attempt to use jQuery and then fallback to a plain XMLHttpRequest version that&#39;s contained in the &lt;code&gt;message-bus-ajax.js&lt;/code&gt; file. &lt;code&gt;message-bus-ajax.js&lt;/code&gt; must be loaded after &lt;code&gt;message-bus.js&lt;/code&gt; for it to be used. You may override this option with a function that implements an ajax request by some other means&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;headers&lt;/td&gt; &#xA;   &lt;td&gt;{}&lt;/td&gt; &#xA;   &lt;td&gt;Extra headers to be include with requests. Properties and values of object must be valid values for HTTP Headers, i.e. no spaces or control characters.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;minHiddenPollInterval&lt;/td&gt; &#xA;   &lt;td&gt;1500&lt;/td&gt; &#xA;   &lt;td&gt;Time to wait between poll requests performed by background or hidden tabs and windows, shared state via localStorage&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;enableChunkedEncoding&lt;/td&gt; &#xA;   &lt;td&gt;true&lt;/td&gt; &#xA;   &lt;td&gt;Allows streaming of message bus data over the HTTP connection without closing the connection after each message.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Javascript Client API&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;MessageBus.start()&lt;/code&gt; : Starts up the MessageBus poller&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MessageBus.subscribe(channel,func,lastId)&lt;/code&gt; : Subscribes to a channel. You may optionally specify the id of the last message you received in the channel. The callback receives three arguments on message delivery: &lt;code&gt;func(payload, globalId, messageId)&lt;/code&gt;. You may save globalId or messageId of received messages and use then at a later time when client needs to subscribe, receiving the backlog since that id.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MessageBus.unsubscribe(channel,func)&lt;/code&gt; : Removes a subscription from a particular channel that was defined with a particular callback function (optional).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MessageBus.pause()&lt;/code&gt; : Pauses all MessageBus activity&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MessageBus.resume()&lt;/code&gt; : Resumes MessageBus activity&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MessageBus.stop()&lt;/code&gt; : Stops all MessageBus activity&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MessageBus.status()&lt;/code&gt; : Returns status (started, paused, stopped)&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;MessageBus.diagnostics()&lt;/code&gt; : Returns a log that may be used for diagnostics on the status of message bus.&lt;/p&gt; &#xA;&lt;h4&gt;Ruby&lt;/h4&gt; &#xA;&lt;p&gt;The gem ships with a Ruby implementation of the client library available with an API very similar to that of the JavaScript client. It was inspired by &lt;a href=&#34;https://github.com/lowjoel/message_bus-client&#34;&gt;https://github.com/lowjoel/message_bus-client&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Creates a client with the default configuration&#xA;client = MessageBus::HTTPClient.new(&#39;http://some.test.com&#39;)&#xA;&#xA;# Listen for the latest messages&#xA;client.subscribe(&#34;/channel&#34;) { |data| puts data }&#xA;&#xA;# Listen for all messages after id 7&#xA;client.subscribe(&#34;/channel&#34;, last_message_id: 7) { |data| puts data }&#xA;&#xA;# Listen for last message and all new messages&#xA;client.subscribe(&#34;/channel&#34;, last_message_id: -2) { |data| puts data }&#xA;&#xA;# Unsubscribe from a channel&#xA;client.unsubscribe(&#34;/channel&#34;)&#xA;&#xA;# Unsubscribe a particular callback from a channel&#xA;callback = -&amp;gt; { |data| puts data }&#xA;client.subscribe(&#34;/channel&#34;, &amp;amp;callback)&#xA;client.unsubscribe(&#34;/channel&#34;, &amp;amp;callback)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Ruby Client Settings&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Setting&lt;/th&gt; &#xA;   &lt;th&gt;Default&lt;/th&gt; &#xA;   &lt;th&gt;Info&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;enable_long_polling&lt;/td&gt; &#xA;   &lt;td&gt;true&lt;/td&gt; &#xA;   &lt;td&gt;Allow long-polling (provided it is enabled by the server)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;background_callback_interval&lt;/td&gt; &#xA;   &lt;td&gt;60s&lt;/td&gt; &#xA;   &lt;td&gt;Interval to poll when long polling is disabled&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;min_poll_interval&lt;/td&gt; &#xA;   &lt;td&gt;0.1s&lt;/td&gt; &#xA;   &lt;td&gt;When polling requests succeed, this is the minimum amount of time to wait before making the next request.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;max_poll_interval&lt;/td&gt; &#xA;   &lt;td&gt;180s&lt;/td&gt; &#xA;   &lt;td&gt;If request to the server start failing, MessageBus will backoff, this is the upper limit of the backoff.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;enable_chunked_encoding&lt;/td&gt; &#xA;   &lt;td&gt;true&lt;/td&gt; &#xA;   &lt;td&gt;Allows streaming of message bus data over the HTTP connection without closing the connection after each message.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;headers&lt;/td&gt; &#xA;   &lt;td&gt;{}&lt;/td&gt; &#xA;   &lt;td&gt;Extra headers to be include with requests. Properties and values of object must be valid values for HTTP Headers, i.e. no spaces or control characters.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;message_bus can be configured to use one of several available storage backends, and each has its own configuration options.&lt;/p&gt; &#xA;&lt;h3&gt;Keepalive&lt;/h3&gt; &#xA;&lt;p&gt;To ensure correct operation of message_bus, every 60 seconds a message is broadcast to itself. If for any reason the message is not consumed by the same process within 3 keepalive intervals a warning log message is raised.&lt;/p&gt; &#xA;&lt;p&gt;To control keepalive interval use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.configure(keepalive_interval: 60)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Redis&lt;/h3&gt; &#xA;&lt;p&gt;message_bus supports using Redis as a storage backend, and you can configure message_bus to use redis in &lt;code&gt;config/initializers/message_bus.rb&lt;/code&gt;, like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.configure(backend: :redis, url: &#34;redis://:p4ssw0rd@10.0.1.1:6380/15&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The redis client message_bus uses is &lt;a href=&#34;https://github.com/redis/redis-rb&#34;&gt;redis-rb&lt;/a&gt;, so you can visit it&#39;s repo to see what other options you can pass besides a &lt;code&gt;url&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Data Retention&lt;/h4&gt; &#xA;&lt;p&gt;Out of the box Redis keeps track of 2000 messages in the global backlog and 1000 messages in a per-channel backlog. Per-channel backlogs get cleared automatically after 7 days of inactivity. By default, the backlog will be pruned on every message publication. If exact backlog length limiting is not required, the &lt;code&gt;clear_every&lt;/code&gt; parameter can be set higher to improve performance.&lt;/p&gt; &#xA;&lt;p&gt;This is configurable via accessors on the Backend instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# only store 100 messages per channel&#xA;MessageBus.backend_instance.max_backlog_size = 100&#xA;&#xA;# only store 100 global messages&#xA;MessageBus.backend_instance.max_global_backlog_size = 100&#xA;&#xA;# flush per-channel backlog after 100 seconds of inactivity&#xA;MessageBus.backend_instance.max_backlog_age = 100&#xA;&#xA;# clear the backlog every 50 messages&#xA;MessageBus.backend_instance.clear_every = 50&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;PostgreSQL&lt;/h3&gt; &#xA;&lt;p&gt;message_bus also supports PostgreSQL as a backend, and can be configured like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.configure(backend: :postgres, backend_options: {user: &#39;message_bus&#39;, dbname: &#39;message_bus&#39;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The PostgreSQL client message_bus uses is &lt;a href=&#34;https://github.com/ged/ruby-pg&#34;&gt;ruby-pg&lt;/a&gt;, so you can visit it&#39;s repo to see what options you can include in &lt;code&gt;:backend_options&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;code&gt;:clear_every&lt;/code&gt; option is also supported, which limits backlog trimming frequency to the specified number of publications. If you set &lt;code&gt;clear_every: 100&lt;/code&gt;, the backlog will only be cleared every 100 publications. This can improve performance in cases where exact backlog length limiting is not required.&lt;/p&gt; &#xA;&lt;h3&gt;Memory&lt;/h3&gt; &#xA;&lt;p&gt;message_bus also supports an in-memory backend. This can be used for testing or simple single-process environments that do not require persistence or horizontal scalability.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.configure(backend: :memory)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;:clear_every&lt;/code&gt; option is supported in the same way as the PostgreSQL backend.&lt;/p&gt; &#xA;&lt;h3&gt;Transport codecs&lt;/h3&gt; &#xA;&lt;p&gt;By default MessageBus serializes messages to the backend using JSON. Under most situation this performs extremely well.&lt;/p&gt; &#xA;&lt;p&gt;In some exceptional cases you may consider a different transport codec. To configure a custom codec use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.configure(transport_codec: codec)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A codec class must implement MessageBus::Codec::Base. Specifically an &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;code&gt;bench&lt;/code&gt; directory for examples where the default JSON codec can perform poorly. A specific examples may be attempting to distribute a message to a restricted list of thousands of users. In cases like this you may consider using a packed string encoder.&lt;/p&gt; &#xA;&lt;p&gt;Keep in mind, much of MessageBus internals and supporting tools expect data to be converted to JSON and back, if you use a naive (and fast) &lt;code&gt;Marshal&lt;/code&gt; based codec you may need to limit the features you use. Specifically the Postgresql backend expects the codec never to return a string with &lt;code&gt;\u0000&lt;/code&gt;, additionally some classes like DistributedCache expect keys to be converted to Strings.&lt;/p&gt; &#xA;&lt;p&gt;Another example may be very large and complicated messages where Oj in compatibility mode outperforms JSON. To opt for the Oj codec use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.configure(transport_codec: MessageBus::Codec::Oj.new)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Forking/threading app servers&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re using a forking or threading app server and you&#39;re not getting immediate delivery of published messages, you might need to configure your web server to re-connect to the message_bus backend&lt;/p&gt; &#xA;&lt;h4&gt;Passenger&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Rails: config/application.rb or config.ru&#xA;if defined?(PhusionPassenger)&#xA;  PhusionPassenger.on_event(:starting_worker_process) do |forked|&#xA;    if forked&#xA;      # We&#39;re in smart spawning mode.&#xA;      MessageBus.after_fork&#xA;    else&#xA;      # We&#39;re in conservative spawning mode. We don&#39;t need to do anything.&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;MessageBus uses long polling which needs to be configured in Passenger&lt;/p&gt; &#xA;&lt;p&gt;For passenger version &amp;lt; 5.0.21, add the following to &lt;code&gt;application.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;PhusionPassenger.advertised_concurrency_level = 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For passenger version &amp;gt; 5.0.21, add the following to &lt;code&gt;nginx.conf&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;location /message-bus {&#xA;  passenger_app_group_name foo_websocket;&#xA;  passenger_force_max_concurrent_requests_per_process 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information see the &lt;a href=&#34;https://www.phusionpassenger.com/library/config/nginx/tuning_sse_and_websockets/&#34;&gt;Passenger documentation&lt;/a&gt; on long-polling.&lt;/p&gt; &#xA;&lt;h4&gt;Puma&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# path/to/your/config/puma.rb&#xA;on_worker_boot do&#xA;  MessageBus.after_fork&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Unicorn&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# path/to/your/config/unicorn.rb&#xA;after_fork do |server, worker|&#xA;  MessageBus.after_fork&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Middleware stack in Rails&lt;/h3&gt; &#xA;&lt;p&gt;MessageBus middleware has to show up after the session middleware, but depending on how the Rails app is configured that might be either &lt;code&gt;ActionDispatch::Session::CookieStore&lt;/code&gt; or &lt;code&gt;ActionDispatch::Session::ActiveRecordStore&lt;/code&gt;. To handle both cases, the middleware is inserted before &lt;code&gt;ActionDispatch::Flash&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For APIs or apps that have &lt;code&gt;ActionDispatch::Flash&lt;/code&gt; deleted from the stack the middleware is pushed to the bottom.&lt;/p&gt; &#xA;&lt;p&gt;Should you wish to manipulate the default behavior please refer to &lt;a href=&#34;http://api.rubyonrails.org/classes/Rails/Configuration/MiddlewareStackProxy.html&#34;&gt;Rails MiddlewareStackProxy documentation&lt;/a&gt; and alter the order of the middlewares in stack in &lt;code&gt;app/config/initializers/message_bus.rb&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/message_bus.rb&#xA;Rails.application.config do |config|&#xA;  # do anything you wish with config.middleware here&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Specifically, if you use a Rack middleware-based authentication solution (such as Warden) in a Rails application and wish to use it for authenticating message_bus requests, you must ensure that the MessageBus middleware comes after it in the stack.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/message_bus.rb&#xA;Rails.application.config.middleware.move_after(Warden::Manager, MessageBus::Rack::Middleware)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;A Distributed Cache&lt;/h3&gt; &#xA;&lt;p&gt;MessageBus ships with an optional &lt;code&gt;DistributedCache&lt;/code&gt; API which provides a simple and efficient way of synchronizing a cache between processes, based on the core of message_bus:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;message_bus/distributed_cache&#39;&#xA;&#xA;# process 1&#xA;cache = MessageBus::DistributedCache.new(&#34;animals&#34;)&#xA;&#xA;# process 2&#xA;cache = MessageBus::DistributedCache.new(&#34;animals&#34;)&#xA;&#xA;# process 1&#xA;cache[&#34;frogs&#34;] = 5&#xA;&#xA;# process 2&#xA;puts cache[&#34;frogs&#34;]&#xA;# =&amp;gt; 5&#xA;&#xA;cache[&#34;frogs&#34;] = nil&#xA;&#xA;# process 1&#xA;puts cache[&#34;frogs&#34;]&#xA;# =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can automatically expire the cache on application code changes by scoping the cache to a specific version of the application:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;cache = MessageBus::DistributedCache.new(&#34;cache name&#34;, app_version: &#34;12.1.7.ABDEB&#34;)&#xA;cache[&#34;a&#34;] = 77&#xA;&#xA;cache = MessageBus::DistributedCache.new(&#34;cache name&#34;, app_version: &#34;12.1.7.ABDEF&#34;)&#xA;&#xA;puts cache[&#34;a&#34;]&#xA;# =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Error Handling&lt;/h4&gt; &#xA;&lt;p&gt;The internet is a chaotic environment and clients can drop off for a variety of reasons. If this happens while message_bus is trying to write a message to the client you may see something like this in your logs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Errno::EPIPE: Broken pipe&#xA;  from message_bus/client.rb:159:in `write&#39;&#xA;  from message_bus/client.rb:159:in `write_headers&#39;&#xA;  from message_bus/client.rb:178:in `write_chunk&#39;&#xA;  from message_bus/client.rb:49:in `ensure_first_chunk_sent&#39;&#xA;  from message_bus/rack/middleware.rb:150:in `block in call&#39;&#xA;  from message_bus/client.rb:21:in `block in synchronize&#39;&#xA;  from message_bus/client.rb:21:in `synchronize&#39;&#xA;  from message_bus/client.rb:21:in `synchronize&#39;&#xA;  from message_bus/rack/middleware.rb:147:in `call&#39;&#xA;  ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The user doesn&#39;t see anything, but depending on your traffic you may acquire quite a few of these in your logs or exception tracking tool.&lt;/p&gt; &#xA;&lt;p&gt;You can rescue from errors that occur in MessageBus&#39;s middleware stack by adding a config option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.configure(on_middleware_error: proc do |env, e|&#xA;  # env contains the Rack environment at the time of error&#xA;  # e contains the exception that was raised&#xA;  if Errno::EPIPE === e&#xA;    [422, {}, [&#34;&#34;]]&#xA;  else&#xA;    raise e&#xA;  end&#xA;end)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Adding extra response headers&lt;/h3&gt; &#xA;&lt;p&gt;In e.g. &lt;code&gt;config/initializers/message_bus.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;MessageBus.extra_response_headers_lookup do |env|&#xA;  [&#xA;    [&#34;Access-Control-Allow-Origin&#34;, &#34;http://example.com:3000&#34;],&#xA;  ]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How it works&lt;/h2&gt; &#xA;&lt;p&gt;MessageBus provides durable messaging following the publish-subscribe (pubsub) pattern to subscribers who track their own subscriptions. Durability is by virtue of the persistence of messages in backlogs stored in the selected backend implementation (Redis, Postgres, etc) which can be queried up until a configurable expiry. Subscribers must keep track of the ID of the last message they processed, and request only more-recent messages in subsequent connections.&lt;/p&gt; &#xA;&lt;p&gt;The MessageBus implementation consists of several key parts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Backend implementations - these provide a consistent API over a variety of options for persisting published messages. The API they present is around the publication to and reading of messages from those backlogs in a manner consistent with message_bus&#39; philosophy. Each of these inherits from &lt;code&gt;MessageBus::Backends::Base&lt;/code&gt; and implements the interface it documents.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MessageBus::Rack::Middleware&lt;/code&gt; - which accepts requests from subscribers, validates and authenticates them, delivers existing messages from the backlog and informs a &lt;code&gt;MessageBus::ConnectionManager&lt;/code&gt; of a connection which is remaining open.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MessageBus::ConnectionManager&lt;/code&gt; - manages a set of subscribers with active connections to the server, such that messages which are published during the connection may be dispatched.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MessageBus::Client&lt;/code&gt; - represents a connected subscriber and delivers published messages over its connected socket.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MessageBus::Message&lt;/code&gt; - represents a published message and its encoding for persistence.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The public API is all defined on the &lt;code&gt;MessageBus&lt;/code&gt; module itself.&lt;/p&gt; &#xA;&lt;h3&gt;Subscriber protocol&lt;/h3&gt; &#xA;&lt;p&gt;The message_bus protocol for subscribing clients is based on HTTP, optionally with long-polling and chunked encoding, as specified by the HTTP/1.1 spec in RFC7230 and RFC7231.&lt;/p&gt; &#xA;&lt;p&gt;The protocol consists of a single HTTP end-point at &lt;code&gt;/message-bus/[client_id]/poll&lt;/code&gt;, which responds to &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;OPTIONS&lt;/code&gt;. In the course of a &lt;code&gt;POST&lt;/code&gt; request, the client must indicate the channels from which messages are desired, along with the last message ID the client received for each channel, and an incrementing integer sequence number for each request (used to detect out of order requests and close those with the same client ID and lower sequence numbers).&lt;/p&gt; &#xA;&lt;p&gt;Clients&#39; specification of requested channels can be submitted in either JSON format (with a &lt;code&gt;Content-Type&lt;/code&gt; of &lt;code&gt;application/json&lt;/code&gt;) or as HTML form data (using &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;). An example request might look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;POST /message-bus/3314c3f12b1e45b4b1fdf1a6e42ba826/poll HTTP/1.1&#xA;Host: foo.com&#xA;Content-Type: application/json&#xA;Content-Length: 37&#xA;&#xA;{&#34;/foo/bar&#34;:3,&#34;/doo/dah&#34;:0,&#34;__seq&#34;:7}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If there are messages more recent than the client-specified IDs in any of the requested channels, those messages will be immediately delivered to the client. If the server is configured for long-polling, the client has not requested to disable it (by specifying the &lt;code&gt;dlp=t&lt;/code&gt; query parameter), and no new messages are available, the connection will remain open for the configured long-polling interval (25 seconds by default); if a message becomes available in that time, it will be delivered, else the connection will close. If chunked encoding is enabled, message delivery will not automatically end the connection, and messages will be continuously delivered during the life of the connection, separated by &lt;code&gt;&#34;\r\n|\r\n&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The format for delivered messages is a JSON array of message objects like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[&#xA;  {&#xA;    &#34;global_id&#34;: 12,&#xA;    &#34;message_id&#34;: 1,&#xA;    &#34;channel&#34;: &#34;/some/channel/name&#34;,&#xA;    &#34;data&#34;: [the message as published]&#xA;  }&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;global_id&lt;/code&gt; field here indicates the ID of the message in the global backlog, while the &lt;code&gt;message_id&lt;/code&gt; is the ID of the message in the channel-specific backlog. The ID used for subscriptions is always the channel-specific one.&lt;/p&gt; &#xA;&lt;p&gt;In certain conditions, a status message will be delivered and look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;global_id&#34;: -1,&#xA;  &#34;message_id&#34;: -1,&#xA;  &#34;channel&#34;: &#34;/__status&#34;,&#xA;  &#34;data&#34;: {&#xA;    &#34;/some/channel&#34;: 5,&#xA;    &#34;/other/channel&#34;: 9&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This message indicates the last ID in the backlog for each channel that the client subscribed to. It is sent in the following circumstances:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When the client subscribes to a channel starting from &lt;code&gt;-1&lt;/code&gt;. When long-polling, this message will be delivered immediately.&lt;/li&gt; &#xA; &lt;li&gt;When the client subscribes to a channel starting from a message ID that is beyond the last message on that channel.&lt;/li&gt; &#xA; &lt;li&gt;When delivery of messages to a client is skipped because the message is filtered to other users/groups.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The values provided in this status message can be used by the client to skip requesting messages it will never receive and move forward in polling.&lt;/p&gt; &#xA;&lt;h3&gt;Publishing to MessageBus from outside of MessageBus&lt;/h3&gt; &#xA;&lt;p&gt;It may be necessary or desired for integration with existing systems to publish messages from outside the Ruby app where MessageBus is running. @tgodfrey has an example of how to do that, using the Redis backend, from Elixir here: &lt;a href=&#34;https://gist.github.com/tgodfrey/1a67753d51cb202ca8eb04b933cec924&#34;&gt;https://gist.github.com/tgodfrey/1a67753d51cb202ca8eb04b933cec924&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you are looking to contribute to this project here are some ideas&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MAKE THIS README BETTER!&lt;/li&gt; &#xA; &lt;li&gt;Build backends for other providers (zeromq, rabbitmq, disque) - currently we support pg and redis.&lt;/li&gt; &#xA; &lt;li&gt;Improve and properly document admin dashboard (add opt-in stats, better diagnostics into queues)&lt;/li&gt; &#xA; &lt;li&gt;Improve general documentation (Add examples, refine existing examples)&lt;/li&gt; &#xA; &lt;li&gt;Make MessageBus a nice website&lt;/li&gt; &#xA; &lt;li&gt;Add optional transports for websocket and shared web workers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When submitting a PR, please be sure to include notes on it in the &lt;code&gt;Unreleased&lt;/code&gt; section of the changelog, but do not bump the version number.&lt;/p&gt; &#xA;&lt;h3&gt;Running tests&lt;/h3&gt; &#xA;&lt;p&gt;To run tests you need both Postgres and Redis installed. By default on Redis the tests connect to &lt;code&gt;localhost:6379&lt;/code&gt; and on Postgres connect the database &lt;code&gt;localhost:5432/message_bus_test&lt;/code&gt; with the system username; if you wish to override this, you can set alternative values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PGUSER=some_user PGDATABASE=some_db bundle exec rake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We include a Docker Compose configuration to run test suite in isolation, or if you do not have Redis or Postgres installed natively. To execute it, do &lt;code&gt;docker-compose run tests&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Generating the documentation&lt;/h3&gt; &#xA;&lt;p&gt;Run &lt;code&gt;rake yard&lt;/code&gt; (or &lt;code&gt;docker-compose run docs rake yard&lt;/code&gt;) in order to generate the implementation&#39;s API docs in HTML format, and &lt;code&gt;open doc/index.html&lt;/code&gt; to view them.&lt;/p&gt; &#xA;&lt;p&gt;While working on documentation, it is useful to automatically re-build it as you make changes. You can do &lt;code&gt;yard server --reload&lt;/code&gt; (or &lt;code&gt;docker-compose up docs&lt;/code&gt;) and &lt;code&gt;open http://localhost:8808&lt;/code&gt; to browse live-built docs as you edit them.&lt;/p&gt; &#xA;&lt;h3&gt;Benchmarks&lt;/h3&gt; &#xA;&lt;p&gt;Some simple benchmarks are implemented in &lt;code&gt;spec/performance&lt;/code&gt; and can be executed using &lt;code&gt;rake performance&lt;/code&gt; (or &lt;code&gt;docker-compose run tests rake performance&lt;/code&gt;). You should run these before and after your changes to avoid introducing performance regressions.&lt;/p&gt;</summary>
  </entry>
</feed>